From 99db37018b1e804582ae8b8469737e3f6513e01a Mon Sep 17 00:00:00 2001
From: The-going <48602507+The-going@users.noreply.github.com>
Date: Tue, 8 Feb 2022 16:21:06 +0300
Subject: [PATCH] drv:net:rtl8723cs: include

---
 .../rtl8723cs/include/Hal8188EPhyCfg.h        |  274 +++
 .../rtl8723cs/include/Hal8188EPhyReg.h        | 1106 ++++++++++
 .../rtl8723cs/include/Hal8188EPwrSeq.h        |  176 ++
 .../rtl8723cs/include/Hal8188FPhyCfg.h        |  149 ++
 .../rtl8723cs/include/Hal8188FPhyReg.h        | 1171 +++++++++++
 .../rtl8723cs/include/Hal8188FPwrSeq.h        |  199 ++
 .../rtl8723cs/include/Hal8192EPhyCfg.h        |  178 ++
 .../rtl8723cs/include/Hal8192EPhyReg.h        | 1133 ++++++++++
 .../rtl8723cs/include/Hal8192EPwrSeq.h        |  155 ++
 .../rtl8723cs/include/Hal8703BPhyCfg.h        |  144 ++
 .../rtl8723cs/include/Hal8703BPhyReg.h        | 1139 ++++++++++
 .../rtl8723cs/include/Hal8703BPwrSeq.h        |  184 ++
 .../rtl8723cs/include/Hal8723BPhyCfg.h        |  149 ++
 .../rtl8723cs/include/Hal8723BPhyReg.h        | 1137 ++++++++++
 .../rtl8723cs/include/Hal8723BPwrSeq.h        |  233 +++
 .../realtek/rtl8723cs/include/Hal8723PwrSeq.h |  170 ++
 .../realtek/rtl8723cs/include/Hal8812PhyCfg.h |  165 ++
 .../realtek/rtl8723cs/include/Hal8812PhyReg.h |  739 +++++++
 .../realtek/rtl8723cs/include/Hal8812PwrSeq.h |  210 ++
 .../realtek/rtl8723cs/include/Hal8814PhyCfg.h |  282 +++
 .../realtek/rtl8723cs/include/Hal8814PhyReg.h |  867 ++++++++
 .../realtek/rtl8723cs/include/Hal8814PwrSeq.h |  237 +++
 .../rtl8723cs/include/Hal8821APwrSeq.h        |  186 ++
 .../realtek/rtl8723cs/include/HalPwrSeqCmd.h  |  138 ++
 .../realtek/rtl8723cs/include/HalVerDef.h     |  202 ++
 .../realtek/rtl8723cs/include/autoconf.h      |  305 +++
 .../realtek/rtl8723cs/include/basic_types.h   |  385 ++++
 .../rtl8723cs/include/byteorder/big_endian.h  |   88 +
 .../rtl8723cs/include/byteorder/generic.h     |  213 ++
 .../include/byteorder/little_endian.h         |   90 +
 .../rtl8723cs/include/byteorder/swab.h        |  141 ++
 .../rtl8723cs/include/byteorder/swabb.h       |  157 ++
 .../realtek/rtl8723cs/include/circ_buf.h      |   28 +
 .../realtek/rtl8723cs/include/cmd_osdep.h     |   32 +
 .../realtek/rtl8723cs/include/custom_gpio.h   |   32 +
 .../realtek/rtl8723cs/include/drv_conf.h      |  190 ++
 .../realtek/rtl8723cs/include/drv_types.h     | 1303 ++++++++++++
 .../realtek/rtl8723cs/include/drv_types_ce.h  |   91 +
 .../rtl8723cs/include/drv_types_gspi.h        |   56 +
 .../rtl8723cs/include/drv_types_linux.h       |   25 +
 .../realtek/rtl8723cs/include/drv_types_pci.h |  273 +++
 .../rtl8723cs/include/drv_types_sdio.h        |   81 +
 .../realtek/rtl8723cs/include/drv_types_xp.h  |   92 +
 .../realtek/rtl8723cs/include/ethernet.h      |   42 +
 .../realtek/rtl8723cs/include/gspi_hal.h      |   36 +
 .../realtek/rtl8723cs/include/gspi_ops.h      |  185 ++
 .../rtl8723cs/include/gspi_ops_linux.h        |   24 +
 .../realtek/rtl8723cs/include/gspi_osintf.h   |   31 +
 .../realtek/rtl8723cs/include/h2clbk.h        |   32 +
 .../realtek/rtl8723cs/include/hal_btcoex.h    |   97 +
 .../realtek/rtl8723cs/include/hal_com.h       |  544 +++++
 .../realtek/rtl8723cs/include/hal_com_h2c.h   |  363 ++++
 .../realtek/rtl8723cs/include/hal_com_led.h   |  398 ++++
 .../rtl8723cs/include/hal_com_phycfg.h        |  285 +++
 .../realtek/rtl8723cs/include/hal_com_reg.h   | 1780 ++++++++++++++++
 .../realtek/rtl8723cs/include/hal_data.h      |  653 ++++++
 .../realtek/rtl8723cs/include/hal_gspi.h      |   32 +
 .../realtek/rtl8723cs/include/hal_ic_cfg.h    |   93 +
 .../realtek/rtl8723cs/include/hal_intf.h      |  688 +++++++
 .../realtek/rtl8723cs/include/hal_pg.h        |  629 ++++++
 .../realtek/rtl8723cs/include/hal_phy.h       |  247 +++
 .../realtek/rtl8723cs/include/hal_phy_reg.h   |   31 +
 .../realtek/rtl8723cs/include/hal_sdio.h      |   32 +
 .../realtek/rtl8723cs/include/ieee80211.h     | 1832 +++++++++++++++++
 .../realtek/rtl8723cs/include/ieee80211_ext.h |  477 +++++
 .../realtek/rtl8723cs/include/if_ether.h      |  113 +
 .../wireless/realtek/rtl8723cs/include/ip.h   |  141 ++
 .../rtl8723cs/include/linux/wireless.h        |   97 +
 .../realtek/rtl8723cs/include/mlme_osdep.h    |   37 +
 .../realtek/rtl8723cs/include/mp_custom_oid.h |  354 ++++
 .../realtek/rtl8723cs/include/nic_spec.h      |   47 +
 .../realtek/rtl8723cs/include/osdep_intf.h    |  173 ++
 .../realtek/rtl8723cs/include/osdep_service.h |  625 ++++++
 .../rtl8723cs/include/osdep_service_bsd.h     |  749 +++++++
 .../rtl8723cs/include/osdep_service_ce.h      |  192 ++
 .../rtl8723cs/include/osdep_service_linux.h   |  420 ++++
 .../rtl8723cs/include/osdep_service_xp.h      |  202 ++
 .../realtek/rtl8723cs/include/pci_hal.h       |   46 +
 .../realtek/rtl8723cs/include/pci_ops.h       |   78 +
 .../realtek/rtl8723cs/include/pci_osintf.h    |   32 +
 .../realtek/rtl8723cs/include/recv_osdep.h    |   65 +
 .../realtek/rtl8723cs/include/rtl8188e_cmd.h  |  186 ++
 .../realtek/rtl8723cs/include/rtl8188e_dm.h   |   37 +
 .../realtek/rtl8723cs/include/rtl8188e_hal.h  |  321 +++
 .../realtek/rtl8723cs/include/rtl8188e_led.h  |   41 +
 .../realtek/rtl8723cs/include/rtl8188e_recv.h |  175 ++
 .../realtek/rtl8723cs/include/rtl8188e_rf.h   |   33 +
 .../realtek/rtl8723cs/include/rtl8188e_spec.h |  164 ++
 .../rtl8723cs/include/rtl8188e_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8188e_xmit.h |  299 +++
 .../realtek/rtl8723cs/include/rtl8188f_cmd.h  |  218 ++
 .../realtek/rtl8723cs/include/rtl8188f_dm.h   |   48 +
 .../realtek/rtl8723cs/include/rtl8188f_hal.h  |  322 +++
 .../realtek/rtl8723cs/include/rtl8188f_led.h  |   49 +
 .../realtek/rtl8723cs/include/rtl8188f_recv.h |   73 +
 .../realtek/rtl8723cs/include/rtl8188f_rf.h   |   31 +
 .../realtek/rtl8723cs/include/rtl8188f_spec.h |  302 +++
 .../rtl8723cs/include/rtl8188f_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8188f_xmit.h |  336 +++
 .../realtek/rtl8723cs/include/rtl8192e_cmd.h  |  175 ++
 .../realtek/rtl8723cs/include/rtl8192e_dm.h   |   38 +
 .../realtek/rtl8723cs/include/rtl8192e_hal.h  |  350 ++++
 .../realtek/rtl8723cs/include/rtl8192e_led.h  |   41 +
 .../realtek/rtl8723cs/include/rtl8192e_recv.h |  178 ++
 .../realtek/rtl8723cs/include/rtl8192e_rf.h   |   34 +
 .../realtek/rtl8723cs/include/rtl8192e_spec.h |  327 +++
 .../rtl8723cs/include/rtl8192e_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8192e_xmit.h |  451 ++++
 .../realtek/rtl8723cs/include/rtl8703b_cmd.h  |  214 ++
 .../realtek/rtl8723cs/include/rtl8703b_dm.h   |   48 +
 .../realtek/rtl8723cs/include/rtl8703b_hal.h  |  325 +++
 .../realtek/rtl8723cs/include/rtl8703b_led.h  |   49 +
 .../realtek/rtl8723cs/include/rtl8703b_recv.h |   92 +
 .../realtek/rtl8723cs/include/rtl8703b_rf.h   |   31 +
 .../realtek/rtl8723cs/include/rtl8703b_spec.h |  480 +++++
 .../rtl8723cs/include/rtl8703b_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8703b_xmit.h |  336 +++
 .../realtek/rtl8723cs/include/rtl8723b_cmd.h  |  217 ++
 .../realtek/rtl8723cs/include/rtl8723b_dm.h   |   48 +
 .../realtek/rtl8723cs/include/rtl8723b_hal.h  |  326 +++
 .../realtek/rtl8723cs/include/rtl8723b_led.h  |   49 +
 .../realtek/rtl8723cs/include/rtl8723b_recv.h |   92 +
 .../realtek/rtl8723cs/include/rtl8723b_rf.h   |   31 +
 .../realtek/rtl8723cs/include/rtl8723b_spec.h |  295 +++
 .../rtl8723cs/include/rtl8723b_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8723b_xmit.h |  336 +++
 .../realtek/rtl8723cs/include/rtl8812a_cmd.h  |  177 ++
 .../realtek/rtl8723cs/include/rtl8812a_dm.h   |   37 +
 .../realtek/rtl8723cs/include/rtl8812a_hal.h  |  373 ++++
 .../realtek/rtl8723cs/include/rtl8812a_led.h  |   41 +
 .../realtek/rtl8723cs/include/rtl8812a_recv.h |  162 ++
 .../realtek/rtl8723cs/include/rtl8812a_rf.h   |   34 +
 .../realtek/rtl8723cs/include/rtl8812a_spec.h |  275 +++
 .../rtl8723cs/include/rtl8812a_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8812a_xmit.h |  365 ++++
 .../realtek/rtl8723cs/include/rtl8814a_cmd.h  |  153 ++
 .../realtek/rtl8723cs/include/rtl8814a_dm.h   |   34 +
 .../realtek/rtl8723cs/include/rtl8814a_hal.h  |  335 +++
 .../realtek/rtl8723cs/include/rtl8814a_led.h  |   41 +
 .../realtek/rtl8723cs/include/rtl8814a_recv.h |  188 ++
 .../realtek/rtl8723cs/include/rtl8814a_rf.h   |   34 +
 .../realtek/rtl8723cs/include/rtl8814a_spec.h |  641 ++++++
 .../rtl8723cs/include/rtl8814a_sreset.h       |   30 +
 .../realtek/rtl8723cs/include/rtl8814a_xmit.h |  309 +++
 .../realtek/rtl8723cs/include/rtl8821a_spec.h |  107 +
 .../realtek/rtl8723cs/include/rtl8821a_xmit.h |  180 ++
 .../realtek/rtl8723cs/include/rtw_android.h   |  113 +
 .../realtek/rtl8723cs/include/rtw_ap.h        |   80 +
 .../rtl8723cs/include/rtw_beamforming.h       |  150 ++
 .../realtek/rtl8723cs/include/rtw_br_ext.h    |   76 +
 .../realtek/rtl8723cs/include/rtw_bt_mp.h     |  295 +++
 .../realtek/rtl8723cs/include/rtw_btcoex.h    |  436 ++++
 .../realtek/rtl8723cs/include/rtw_byteorder.h |   39 +
 .../realtek/rtl8723cs/include/rtw_cmd.h       | 1314 ++++++++++++
 .../realtek/rtl8723cs/include/rtw_debug.h     |  538 +++++
 .../realtek/rtl8723cs/include/rtw_eeprom.h    |  123 ++
 .../realtek/rtl8723cs/include/rtw_efuse.h     |  220 ++
 .../realtek/rtl8723cs/include/rtw_event.h     |  140 ++
 .../realtek/rtl8723cs/include/rtw_ht.h        |  221 ++
 .../realtek/rtl8723cs/include/rtw_io.h        |  578 ++++++
 .../realtek/rtl8723cs/include/rtw_ioctl.h     |  329 +++
 .../rtl8723cs/include/rtw_ioctl_query.h       |   33 +
 .../realtek/rtl8723cs/include/rtw_ioctl_rtl.h |   81 +
 .../realtek/rtl8723cs/include/rtw_ioctl_set.h |   76 +
 .../realtek/rtl8723cs/include/rtw_iol.h       |  137 ++
 .../realtek/rtl8723cs/include/rtw_mem.h       |   42 +
 .../realtek/rtl8723cs/include/rtw_mlme.h      | 1070 ++++++++++
 .../realtek/rtl8723cs/include/rtw_mlme_ext.h  | 1235 +++++++++++
 .../realtek/rtl8723cs/include/rtw_mp.h        |  860 ++++++++
 .../realtek/rtl8723cs/include/rtw_mp_ioctl.h  |  591 ++++++
 .../rtl8723cs/include/rtw_mp_phy_regdef.h     | 1100 ++++++++++
 .../realtek/rtl8723cs/include/rtw_odm.h       |   55 +
 .../realtek/rtl8723cs/include/rtw_p2p.h       |  179 ++
 .../realtek/rtl8723cs/include/rtw_pwrctrl.h   |  515 +++++
 .../realtek/rtl8723cs/include/rtw_qos.h       |   35 +
 .../realtek/rtl8723cs/include/rtw_recv.h      |  879 ++++++++
 .../realtek/rtl8723cs/include/rtw_rf.h        |  237 +++
 .../realtek/rtl8723cs/include/rtw_security.h  |  488 +++++
 .../realtek/rtl8723cs/include/rtw_sreset.h    |   61 +
 .../realtek/rtl8723cs/include/rtw_tdls.h      |  149 ++
 .../realtek/rtl8723cs/include/rtw_version.h   |    2 +
 .../realtek/rtl8723cs/include/rtw_vht.h       |  143 ++
 .../realtek/rtl8723cs/include/rtw_wapi.h      |  222 ++
 .../realtek/rtl8723cs/include/rtw_wifi_regd.h |   26 +
 .../realtek/rtl8723cs/include/rtw_xmit.h      |  865 ++++++++
 .../realtek/rtl8723cs/include/sdio_hal.h      |   56 +
 .../realtek/rtl8723cs/include/sdio_ops.h      |  140 ++
 .../realtek/rtl8723cs/include/sdio_ops_ce.h   |   55 +
 .../rtl8723cs/include/sdio_ops_linux.h        |   52 +
 .../realtek/rtl8723cs/include/sdio_ops_xp.h   |   55 +
 .../realtek/rtl8723cs/include/sdio_osintf.h   |   36 +
 .../realtek/rtl8723cs/include/sta_info.h      |  589 ++++++
 .../realtek/rtl8723cs/include/usb_hal.h       |   61 +
 .../realtek/rtl8723cs/include/usb_ops.h       |  148 ++
 .../realtek/rtl8723cs/include/usb_ops_linux.h |   89 +
 .../realtek/rtl8723cs/include/usb_osintf.h    |   32 +
 .../rtl8723cs/include/usb_vendor_req.h        |   60 +
 .../wireless/realtek/rtl8723cs/include/wifi.h | 1397 +++++++++++++
 .../realtek/rtl8723cs/include/wlan_bssdef.h   |  748 +++++++
 .../realtek/rtl8723cs/include/xmit_osdep.h    |  100 +
 200 files changed, 54452 insertions(+)
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8723PwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyCfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyReg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/Hal8821APwrSeq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/HalPwrSeqCmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/HalVerDef.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/autoconf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/basic_types.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/byteorder/big_endian.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/byteorder/generic.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/byteorder/little_endian.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swab.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swabb.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/circ_buf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/cmd_osdep.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/custom_gpio.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_conf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types_ce.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types_gspi.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types_linux.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types_pci.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types_sdio.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/drv_types_xp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/ethernet.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/gspi_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops_linux.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/gspi_osintf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/h2clbk.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_btcoex.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_com.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_com_h2c.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_com_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_com_phycfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_com_reg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_data.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_gspi.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_ic_cfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_intf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_pg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_phy.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_phy_reg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/hal_sdio.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/ieee80211.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/ieee80211_ext.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/if_ether.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/ip.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/linux/wireless.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/mlme_osdep.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/mp_custom_oid.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/nic_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/osdep_intf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/osdep_service.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_bsd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_ce.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_linux.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_xp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/pci_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/pci_ops.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/pci_osintf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/recv_osdep.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_dm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_led.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_spec.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_android.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_ap.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_beamforming.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_br_ext.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_bt_mp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_btcoex.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_byteorder.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_debug.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_eeprom.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_efuse.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_event.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_ht.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_io.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_query.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_rtl.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_set.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_iol.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_mem.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme_ext.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_ioctl.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_phy_regdef.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_odm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_p2p.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_pwrctrl.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_qos.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_recv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_security.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_sreset.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_tdls.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_version.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_vht.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_wapi.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_wifi_regd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/rtw_xmit.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sdio_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_ce.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_linux.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_xp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sdio_osintf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/sta_info.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/usb_hal.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/usb_ops.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/usb_ops_linux.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/usb_osintf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/usb_vendor_req.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/wifi.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/wlan_bssdef.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/include/xmit_osdep.h

diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyCfg.h
new file mode 100644
index 000000000..3eebf6f22
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyCfg.h
@@ -0,0 +1,274 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8188EPHYCFG_H__
+#define __INC_HAL8188EPHYCFG_H__
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue		0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+#define	MAX_TX_COUNT_8188E			1
+
+/* BB/RF related */
+
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//
+// BB and RF register read/write
+//
+u32	PHY_QueryBBReg8188E(	IN	PADAPTER	Adapter,
+								IN	u32		RegAddr,
+								IN	u32		BitMask	);
+void	PHY_SetBBReg8188E(	IN	PADAPTER	Adapter,
+								IN	u32		RegAddr,
+								IN	u32		BitMask,
+								IN	u32		Data	);
+u32	PHY_QueryRFReg8188E(	IN	PADAPTER	Adapter,
+								IN	u8				eRFPath,
+								IN	u32				RegAddr,
+								IN	u32				BitMask	);
+void	PHY_SetRFReg8188E(	IN	PADAPTER		Adapter,
+								IN	u8				eRFPath,
+								IN	u32				RegAddr,
+								IN	u32				BitMask,
+								IN	u32				Data	);
+
+//
+// Initialization related function
+//
+/* MAC/BB/RF HAL config */
+int	PHY_MACConfig8188E(IN	PADAPTER	Adapter	);
+int	PHY_BBConfig8188E(IN	PADAPTER	Adapter	);
+int	PHY_RFConfig8188E(IN	PADAPTER	Adapter	);
+
+/* RF config */
+int	rtl8188e_PHY_ConfigRFWithParaFile(IN PADAPTER Adapter, IN u8 * pFileName, u8 eRFPath);
+
+//
+// RF Power setting
+//
+//extern	BOOLEAN	PHY_SetRFPowerState(IN	PADAPTER			Adapter,
+//									IN	RT_RF_POWER_STATE	eRFPowerState);
+
+//
+// BB TX Power R/W
+//
+void	PHY_GetTxPowerLevel8188E(	IN	PADAPTER		Adapter,
+											OUT s32*    		powerlevel	);
+void	PHY_SetTxPowerLevel8188E(	IN	PADAPTER		Adapter,
+											IN	u8			channel	);
+BOOLEAN	PHY_UpdateTxPowerDbm8188E(	IN	PADAPTER	Adapter,
+											IN	int		powerInDbm	);
+
+VOID
+PHY_SetTxPowerIndex_8188E(
+	IN	PADAPTER			Adapter,
+	IN	u32					PowerIndex,
+	IN	u8					RFPath,
+	IN	u8					Rate
+	);
+
+u8
+PHY_GetTxPowerIndex_8188E(
+	IN	PADAPTER		pAdapter,
+	IN	u8				RFPath,
+	IN	u8				Rate,
+	IN	CHANNEL_WIDTH	BandWidth,
+	IN	u8				Channel
+	);
+
+//
+// Switch bandwidth for 8192S
+//
+//extern	void	PHY_SetBWModeCallback8192C(	IN	PRT_TIMER		pTimer	);
+void	PHY_SetBWMode8188E(	IN	PADAPTER			pAdapter,
+									IN	CHANNEL_WIDTH	ChnlWidth,
+									IN	unsigned char	Offset	);
+
+//
+// Set FW CMD IO for 8192S.
+//
+//extern	BOOLEAN HalSetIO8192C(	IN	PADAPTER			Adapter,
+//									IN	IO_TYPE				IOType);
+
+//
+// Set A2 entry to fw for 8192S
+//
+extern	void FillA2Entry8192C(		IN	PADAPTER			Adapter,
+										IN	u8				index,
+										IN	u8*				val);
+
+
+//
+// channel switch related funciton
+//
+//extern	void	PHY_SwChnlCallback8192C(	IN	PRT_TIMER		pTimer	);
+void	PHY_SwChnl8188E(	IN	PADAPTER		pAdapter,
+									IN	u8			channel	);
+
+VOID
+PHY_SetSwChnlBWMode8188E(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH	Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+//
+// BB/MAC/RF other monitor API
+//
+void	PHY_SetMonitorMode8192C(IN	PADAPTER	pAdapter,
+										IN	BOOLEAN		bEnableMonitorMode	);
+
+BOOLEAN	PHY_CheckIsLegalRfPath8192C(IN	PADAPTER	pAdapter,
+											IN	u32		eRFPath	);
+
+VOID PHY_SetRFPathSwitch_8188E(IN	PADAPTER	pAdapter, IN	BOOLEAN		bMain);
+
+extern	VOID
+PHY_SwitchEphyParameter(
+	IN	PADAPTER			Adapter
+	);
+
+extern	VOID
+PHY_EnableHostClkReq(
+	IN	PADAPTER			Adapter
+	);
+
+BOOLEAN
+SetAntennaConfig92C(
+	IN	PADAPTER	Adapter,
+	IN	u8		DefaultAnt
+	);
+
+VOID
+storePwrIndexDiffRateOffset(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	);
+/*--------------------------Exported Function prototype---------------------*/
+
+//
+// Initialization related function
+//
+/* MAC/BB/RF HAL config */
+//extern s32 PHY_MACConfig8723(PADAPTER padapter);
+//s32 PHY_BBConfig8723(PADAPTER padapter);
+//s32 PHY_RFConfig8723(PADAPTER padapter);
+
+
+
+//==================================================================
+// Note: If SIC_ENABLE under PCIE, because of the slow operation
+//	you should
+//	2) "#define RTL8723_FPGA_VERIFICATION	1"				in Precomp.h.WlanE.Windows
+//	3) "#define RTL8190_Download_Firmware_From_Header	0"	in Precomp.h.WlanE.Windows if needed.
+//
+#if (RTL8188E_SUPPORT == 1) && (RTL8188E_FPGA_TRUE_PHY_VERIFICATION == 1)
+#define	SIC_ENABLE				1
+#define	SIC_HW_SUPPORT		1
+#else
+#define	SIC_ENABLE				0
+#define	SIC_HW_SUPPORT		0
+#endif
+//==================================================================
+
+
+#define	SIC_MAX_POLL_CNT		5
+
+#if(SIC_HW_SUPPORT == 1)
+#define	SIC_CMD_READY			0
+#define	SIC_CMD_PREWRITE		0x1
+#if(RTL8188E_SUPPORT == 1)
+#define	SIC_CMD_WRITE			0x40
+#define	SIC_CMD_PREREAD		0x2
+#define	SIC_CMD_READ			0x80
+#define	SIC_CMD_INIT			0xf0
+#define	SIC_INIT_VAL			0xff
+
+#define	SIC_INIT_REG			0x1b7
+#define	SIC_CMD_REG			0x1EB		// 1byte
+#define	SIC_ADDR_REG			0x1E8		// 1b4~1b5, 2 bytes
+#define	SIC_DATA_REG			0x1EC		// 1b0~1b3
+#else
+#define	SIC_CMD_WRITE			0x11
+#define	SIC_CMD_PREREAD		0x2
+#define	SIC_CMD_READ			0x12
+#define	SIC_CMD_INIT			0x1f
+#define	SIC_INIT_VAL			0xff
+
+#define	SIC_INIT_REG			0x1b7
+#define	SIC_CMD_REG			0x1b6		// 1byte
+#define	SIC_ADDR_REG			0x1b4		// 1b4~1b5, 2 bytes
+#define	SIC_DATA_REG			0x1b0		// 1b0~1b3
+#endif
+#else
+#define	SIC_CMD_READY			0
+#define	SIC_CMD_WRITE			1
+#define	SIC_CMD_READ			2
+
+#if(RTL8188E_SUPPORT == 1)
+#define	SIC_CMD_REG			0x1EB		// 1byte
+#define	SIC_ADDR_REG			0x1E8		// 1b9~1ba, 2 bytes
+#define	SIC_DATA_REG			0x1EC		// 1bc~1bf
+#else
+#define	SIC_CMD_REG			0x1b8		// 1byte
+#define	SIC_ADDR_REG			0x1b9		// 1b9~1ba, 2 bytes
+#define	SIC_DATA_REG			0x1bc		// 1bc~1bf
+#endif
+#endif
+
+#if(SIC_ENABLE == 1)
+VOID SIC_Init(IN PADAPTER Adapter);
+#endif
+
+
+#endif	// __INC_HAL8192CPHYCFG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyReg.h
new file mode 100644
index 000000000..dc8d0be15
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPhyReg.h
@@ -0,0 +1,1106 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8188EPHYREG_H__
+#define __INC_HAL8188EPHYREG_H__
+/*--------------------------Define Parameters-------------------------------*/
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart				0x104
+#define		rPMAC_TxLegacySIG			0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum			0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble		0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK		0x170
+#define		rPMAC_OFDMRxCRC32Er		0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus				0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo					0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1				0x810	// Useless now
+#define		rFPGA0_RFTiming2				0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter	0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888
+#define		rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback		0x8b8	// Transceiver A HSPI Readback
+#define		TransceiverB_HSPI_Readback		0x8bc	// Transceiver B HSPI Readback
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo					0x90c	// Useless now // Status report??
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System					0xa00
+
+#define		rCCK0_AFESetting				0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1			0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2			0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort				0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         			0xa50
+#define		rCCK0_RxReport            			0xa54  //0xa57
+#define		rCCK0_FACounterLower      		0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      		0xa58  //0xa5c
+
+//
+// PageB(0xB00)
+//
+#define		rPdp_AntA      					0xb00
+#define		rPdp_AntA_4    				0xb04
+#define		rConfig_Pmpd_AntA 			0xb28
+#define		rConfig_ram64x16				0xb2c
+#define		rConfig_AntA 					0xb68
+#define		rConfig_AntB 					0xb6c
+#define		rPdp_AntB 					0xb70
+#define		rPdp_AntB_4 					0xb74
+#define		rConfig_Pmpd_AntB			0xb98
+#define		rAPK							0xbd8
+
+
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF					0xc00
+
+#define		rOFDM0_TRxPathEnable			0xc04
+#define		rOFDM0_TRMuxPar				0xc08
+#define		rOFDM0_TRSWIsolation			0xc0c
+
+#define		rOFDM0_XARxAFE				0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    		0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            			0xc18
+#define		rOFDM0_XBRxIQImbalance    		0xc1c
+#define		rOFDM0_XCRxAFE            			0xc20
+#define		rOFDM0_XCRxIQImbalance    		0xc24
+#define		rOFDM0_XDRxAFE            			0xc28
+#define		rOFDM0_XDRxIQImbalance    		0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC			0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold		0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold			0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1		0xc70
+#define		rOFDM0_AGCParameter2		0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter		0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync			0xcf0
+#define		rOFDM0_DFSReport			0xcf4
+
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO					0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD					0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet				0xd3c
+#define		rOFDM1_csi_fix_mask1				0xd40
+#define		rOFDM1_csi_fix_mask2				0xd44
+#define		rOFDM1_PseudoNoiseStateAB	0xd50
+#define		rOFDM1_PseudoNoiseStateCD	0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1			0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2			0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3			0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB			0xdac	// No setting now
+#define		rOFDM_ShortCFOCD			0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR				0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00		0xe10
+#define		rTxAGC_A_Mcs07_Mcs04		0xe14
+#define		rTxAGC_A_Mcs11_Mcs08		0xe18
+#define		rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00		0x83c
+#define		rTxAGC_B_Mcs07_Mcs04		0x848
+#define		rTxAGC_B_Mcs11_Mcs08		0x84c
+#define		rTxAGC_B_Mcs15_Mcs12		0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK 						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS 				0xed4
+#define		rRx_TO_Rx 					0xed8
+#define		rStandby 						0xedc
+#define		rSleep 						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1			0x1
+#define		rZebra1_TRxEnable2			0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	// RF channel switch
+
+//#endif
+#define		rZebra1_TxGain				0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl					0	// Useless now
+#define		rRTL8256_TxLPF				19
+#define		rRTL8256_RxLPF				11
+
+//RTL8258
+#define		rRTL8258_TxLPF				0x11	// Useless now
+#define		rRTL8258_RxLPF				0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1					0x01	//
+#define		RF_IQADJ_G2					0x02	//
+
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC					0x08	//
+#define		RF_IPA_G						0x09	//
+#define		RF_TXBIAS_G					0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A						0x0C	//
+#define		RF_TXBIAS_A					0x0D
+#define		RF_BS_PA_APSET_G9_G11		0x0E
+#define		RF_BS_IQGEN					0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_TXBIAS					0x16
+#define		RF_POW_ABILITY				0x17	//
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1						0x1E	//
+#define		RF_RCK2						0x1F	//
+
+#define		RF_TX_G1						0x20	//
+#define		RF_TX_G2						0x21	//
+#define		RF_TX_G3						0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER_88E					0x42	//
+#define		RF_T_METER					0x24	//
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define		RF_TX_BIAS_A					0x35
+#define		RF_TX_BIAS_D					0x36
+#define		RF_LOBF_9					0x38
+#define		RF_RXRF_A3					0x3C	//
+#define		RF_TRSW						0x3F
+
+#define		RF_TXRF_A2					0x41
+#define		RF_TXPA_G4					0x46
+#define		RF_TXPA_A4					0x4B
+#define 	RF_0x52 					0x52
+#define		RF_WE_LUT					0xEF
+
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB					0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart					0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback				0x10
+#define		bTxLSIG						0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength				0x1ffe0
+#define		bOFDMTxParity				0x20000
+#define		bTxHTSIG1					0xffffff
+#define		bTxHTMCSRate				0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2					0xffffff
+#define		bTxHTSmoothing				0x1
+#define		bTxHTSounding				0x2
+#define		bTxHTReserved				0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC					0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8					0x3fc00
+#define		bCounterReset				0x10000
+#define		bNumOfOFDMTx				0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval				0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader				0xffffffff
+#define		bTxDataInit					0xff
+#define		bTxHTMode					0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed				0xffffffff
+#define		bCCKTxPreamble				0x1
+#define		bCCKTxSFD					0xffff0000
+#define		bCCKTxSIG					0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus				0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD						0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode					0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn						0x1000000
+#define		bOFDMEn					0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  				0x3f
+
+#define		bAntennaSelect                 			0x0300
+
+#define		bXBTxAGC                  				0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  				0xf000
+#define		bXDTxAGC                  				0xf0000
+
+#define		bPAStart                  				0xf0000000	// Useless now
+#define		bTRStart                  				0x00f00000
+#define		bRFStart                  				0x0000f000
+#define		bBBStart                  				0x000000f0
+#define		bBBCCKStart               			0x0000000f
+#define		bPAEnd                    				0xf          //Reg0x814
+#define		bTREnd                    				0x0f000000
+#define		bRFEnd                    				0x000f0000
+#define		bCCAMask                  				0x000000f0   //T2R
+#define		bR2RCCAMask               			0x00000f00
+#define		bHSSI_R2TDelay            			0xf8000000
+#define		bHSSI_T2RDelay            			0xf80000
+#define		bContTxHSSI               			0x400     //chane gain at continue Tx
+#define		bIGFromCCK                			0x200
+#define		bAGCAddress               			0x3f
+#define		bRxHPTx                   				0x7000
+#define		bRxHPT2R                  				0x38000
+#define		bRxHPCCKIni               			0xc0000
+#define		bAGCTxCode                			0xc00000
+#define		bAGCRxCode                			0x300000
+
+#define		b3WireDataLength          			0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           			0x40000000
+#define		b2GPAPEPolarity           			0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           			0x1
+#define		bRFSI_3WireClock          			0x2
+#define		bRFSI_3WireLoad           			0x4
+#define		bRFSI_3WireRW             			0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      	0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           	0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        	0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x				0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          	0x40000
+#define		bAD7InputCMMode           	0x380000
+#define		bAD7Current               		0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          	0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          	0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       	0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                		0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       			0x10
+#define		bAntNonHT           	      		0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving         		0x80
+#define		bCCKRxPowerSaving         		0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                		0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable      	0x8000
+#define		bCCKFalseAlarmRead        	0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       	0x80000000
+#define		bCCKRxReport_MFOff        	0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      	0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       	0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       	0x4000
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             			0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             		0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               		0x3ff
+#define		bRXIQImb_B               			0xfc00
+#define		bRXIQImb_C               			0x3f0000
+#define		bRXIQImb_D               		0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              		0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              		0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              		0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     	0xe00
+#define		bFrame_Weight_Short      	0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              		0x10000
+#define		bTXIQImb_A               			0x3ff
+#define		bTXIQImb_B               			0xfc00
+#define		bTXIQImb_C               			0x3f0000
+#define		bTXIQImb_D               			0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             		0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED               		0x300
+#define		bRxInitialGain           			0x7f
+#define		bRxAntDivEn              		0x80
+#define		bRxAGCAddressForLNA      	0x7f00
+#define		bRxHighPowerFlow         		0x8000
+#define		bRxAGCFreezeThres        		0xc0000
+#define		bRxFreezeStep_AGC1       	0x300000
+#define		bRxFreezeStep_AGC2       	0xc00000
+#define		bRxFreezeStep_AGC3       	0x3000000
+#define		bRxFreezeStep_AGC0       	0xc000000
+#define		bRxRssi_Cmp_En           		0x10000000
+#define		bRxQuickAGCEn            		0x20000000
+#define		bRxAGCFreezeThresMode    	0x40000000
+#define		bRxOverFlowCheckType     	0x80000000
+#define		bRxAGCShift              			0x7f
+#define		bTRSW_Tri_Only           		0x80
+#define		bPowerThres              		0x300
+#define		bRxAGCEn                 			0x1
+#define		bRxAGCTogetherEn         		0x2
+#define		bRxAGCMin                		0x4
+#define		bRxHP_Ini                			0x7
+#define		bRxHP_TRLNA              		0x70
+#define		bRxHP_RSSI               			0x700
+#define		bRxHP_BBP1               		0x7000
+#define		bRxHP_BBP2               		0x70000
+#define		bRxHP_BBP3               		0x700000
+#define		bRSSI_H                  			0x7f0000     //the threshold for high power
+#define		bRSSI_Gen                			0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW           		0x7
+#define		bRxSettle_LNA            		0x38
+#define		bRxSettle_RSSI           		0x1c0
+#define		bRxSettle_BBP            		0xe00
+#define		bRxSettle_RxHP           		0x7000
+#define		bRxSettle_AntSW_RSSI     	0x38000
+#define		bRxSettle_AntSW          		0xc0000
+#define		bRxProcessTime_DAGC      	0x300000
+#define		bRxSettle_HSSI           		0x400000
+#define		bRxProcessTime_BBPPW     	0x800000
+#define		bRxAntennaPowerShift     	0x3000000
+#define		bRSSITableSelect         		0xc000000
+#define		bRxHP_Final              			0x7000000
+#define		bRxHTSettle_BBP          		0x7
+#define		bRxHTSettle_HSSI         		0x8
+#define		bRxHTSettle_RxHP         		0x70
+#define		bRxHTSettle_BBPPW        		0x80
+#define		bRxHTSettle_Idle         		0x300
+#define		bRxHTSettle_Reserved     	0x1c00
+#define		bRxHTRxHPEn              		0x8000
+#define		bRxHTAGCFreezeThres      	0x30000
+#define		bRxHTAGCTogetherEn       	0x40000
+#define		bRxHTAGCMin             	 	0x80000
+#define		bRxHTAGCEn               		0x100000
+#define		bRxHTDAGCEn              		0x200000
+#define		bRxHTRxHP_BBP            		0x1c00000
+#define		bRxHTRxHP_Final          		0xe0000000
+#define		bRxPWRatioTH             		0x3
+#define		bRxPWRatioEn             		0x4
+#define		bRxMFHold                			0x3800
+#define		bRxPD_Delay_TH1          		0x38
+#define		bRxPD_Delay_TH2          		0x1c0
+#define		bRxPD_DC_COUNT_MAX       	0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH           		0x8000
+#define		bRxProcess_Delay         		0xf0000
+#define		bRxSearchrange_GI2_Early 	0x700000
+#define		bRxFrame_Guard_Counter_L 	0x3800000
+#define		bRxSGI_Guard_L           		0xc000000
+#define		bRxSGI_Search_L          		0x30000000
+#define		bRxSGI_TH                			0xc0000000
+#define		bDFSCnt0                 			0xff
+#define		bDFSCnt1                 			0xff00
+#define		bDFSFlag                 			0xf0000
+#define		bMFWeightSum             		0x300000
+#define		bMinIdxTH                			0x7f000000
+#define		bDAFormat                			0x40000
+#define		bTxChEmuEnable           		0x01000000
+#define		bTRSWIsolation_A         		0x7f
+#define		bTRSWIsolation_B         		0x7f00
+#define		bTRSWIsolation_C         		0x7f0000
+#define		bTRSWIsolation_D         		0x7f000000
+#define		bExtLNAGain              		0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn                  			0x4	// Useless
+#define		bAntennaMapping          		0x10
+#define		bNss                     			0x20
+#define		bCFOAntSumD              		0x200
+#define		bPHYCounterReset         		0x8000000
+#define		bCFOReportGet            		0x4000000
+#define		bOFDMContinueTx          		0x10000000
+#define		bOFDMSingleCarrier       		0x20000000
+#define		bOFDMSingleTone          		0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect                			0x100
+#define		bCFOEn                   			0x10000
+#define		bCFOValue                			0xfff00000
+#define		bSigTone_Re              			0x3f
+#define		bSigTone_Im              			0x7f00
+#define		bCounter_CCA             		0xffff
+#define		bCounter_ParityFail      		0xffff0000
+#define		bCounter_RateIllegal     		0xffff
+#define		bCounter_CRC8Fail        		0xffff0000
+#define		bCounter_MCSNoSupport    	0xffff
+#define		bCounter_FastSync        		0xffff
+#define		bShortCFO                			0xfff
+#define		bShortCFOTLength         		12   //total
+#define		bShortCFOFLength         		11   //fraction
+#define		bLongCFO                 			0x7ff
+#define		bLongCFOTLength          		11
+#define		bLongCFOFLength          		11
+#define		bTailCFO                 			0x1fff
+#define		bTailCFOTLength          		13
+#define		bTailCFOFLength          		12
+#define		bmax_en_pwdB             		0xffff
+#define		bCC_power_dB             		0xffff0000
+#define		bnoise_pwdB              		0xffff
+#define		bPowerMeasTLength        	10
+#define		bPowerMeasFLength        	3
+#define		bRx_HT_BW                		0x1
+#define		bRxSC                    			0x6
+#define		bRx_HT                   			0x8
+#define		bNB_intf_det_on          		0x1
+#define		bIntf_win_len_cfg        		0x30
+#define		bNB_Intf_TH_cfg          		0x1c0
+#define		bRFGain                  			0x3f
+#define		bTableSel                			0x40
+#define		bTRSW                    			0x80
+#define		bRxSNR_A                 			0xff
+#define		bRxSNR_B                 			0xff00
+#define		bRxSNR_C                 			0xff0000
+#define		bRxSNR_D                 			0xff000000
+#define		bSNREVMTLength           		8
+#define		bSNREVMFLength           		1
+#define		bCSI1st                  			0xff
+#define		bCSI2nd                  			0xff00
+#define		bRxEVM1st                			0xff0000
+#define		bRxEVM2nd                		0xff000000
+#define		bSIGEVM                  			0xff
+#define		bPWDB                    			0xff00
+#define		bSGIEN                   			0x10000
+
+#define		bSFactorQAM1             		0xf	// Useless
+#define		bSFactorQAM2             		0xf0
+#define		bSFactorQAM3             		0xf00
+#define		bSFactorQAM4             		0xf000
+#define		bSFactorQAM5             		0xf0000
+#define		bSFactorQAM6             		0xf0000
+#define		bSFactorQAM7             		0xf00000
+#define		bSFactorQAM8             		0xf000000
+#define		bSFactorQAM9             		0xf0000000
+#define		bCSIScheme               			0x100000
+
+#define		bNoiseLvlTopSet          		0x3	// Useless
+#define		bChSmooth                			0x4
+#define		bChSmoothCfg1            		0x38
+#define		bChSmoothCfg2            		0x1c0
+#define		bChSmoothCfg3            		0xe00
+#define		bChSmoothCfg4            		0x7000
+#define		bMRCMode                 		0x800000
+#define		bTHEVMCfg                			0x7000000
+
+#define		bLoopFitType             			0x1	// Useless
+#define		bUpdCFO                  			0x40
+#define		bUpdCFOOffData           		0x80
+#define		bAdvUpdCFO               		0x100
+#define		bAdvTimeCtrl             		0x800
+#define		bUpdClko                 			0x1000
+#define		bFC                      				0x6000
+#define		bTrackingMode            		0x8000
+#define		bPhCmpEnable             		0x10000
+#define		bUpdClkoLTF              			0x20000
+#define		bComChCFO                		0x40000
+#define		bCSIEstiMode             		0x80000
+#define		bAdvUpdEqz               		0x100000
+#define		bUChCfg                  			0x7000000
+#define		bUpdEqz                  			0x8000000
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn         		0x20000000	// Useless
+#define		bRxPesudoNoise_A         		0xff
+#define		bRxPesudoNoise_B         		0xff00
+#define		bRxPesudoNoise_C         		0xff0000
+#define		bRxPesudoNoise_D         		0xff000000
+#define		bPesudoNoiseState_A      	0xffff
+#define		bPesudoNoiseState_B      	0xffff0000
+#define		bPesudoNoiseState_C      		0xffff
+#define		bPesudoNoiseState_D      	0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable        		0x8		// Useless
+#define		bZebra1_TRxControl        		0xc00
+#define		bZebra1_TRxGainSetting    	0x07f
+#define		bZebra1_RxCorner          		0xc00
+#define		bZebra1_TxChargePump      	0x38
+#define		bZebra1_RxChargePump      	0x7
+#define		bZebra1_ChannelNum        	0xf80
+#define		bZebra1_TxLPFBW           		0x400
+#define		bZebra1_RxLPFBW           		0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1      	0x100	// Useless
+#define		bRTL8256RegModeCtrl0      	0x40
+#define		bRTL8256_TxLPFBW          	0x18
+#define		bRTL8256_RxLPFBW          	0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW          	0xc	// Useless
+#define		bRTL8258_RxLPFBW          	0xc00
+#define		bRTL8258_RSSILPFBW        	0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0                    			0x1	// Useless
+#define		bByte1                    			0x2
+#define		bByte2                    			0x4
+#define		bByte3                    			0x8
+#define		bWord0                    			0x3
+#define		bWord1                    			0xc
+#define		bDWord                    			0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0                		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1                		0xff00
+#define		bMaskByte2                		0xff0000
+#define		bMaskByte3                		0xff000000
+#define		bMaskHWord                		0xffff0000
+#define		bMaskLWord                		0x0000ffff
+#define		bMaskDWord                		0xffffffff
+#define		bMaskH3Bytes				0xffffff00
+#define		bMask12Bits				0xfff
+#define		bMaskH4Bits				0xf0000000
+#define 		bMaskOFDM_D			0xffc00000
+#define		bMaskCCK				0x3f3f3f3f
+
+
+
+#define		bEnable                   0x1	// Useless
+#define		bDisable                  0x0
+
+#define		LeftAntenna               			0x0	// Useless
+#define		RightAntenna              		0x1
+
+#define		tCheckTxStatus            		500   //500ms // Useless
+#define		tUpdateRxCounter          		100   //100ms
+
+#define		rateCCK     				0	// Useless
+#define		rateOFDM    				1
+#define		rateHT      					2
+
+//define Register-End
+#define		bPMAC_End                 		0x1ff	// Useless
+#define		bFPGAPHY0_End             		0x8ff
+#define		bFPGAPHY1_End             		0x9ff
+#define		bCCKPHY0_End              		0xaff
+#define		bOFDMPHY0_End             		0xcff
+#define		bOFDMPHY1_End             		0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl              		0x0		// Useless
+#define		bWMACControl              		0x1
+#define		bWNICControl              		0x2
+
+#define		PathA                     			0x0	// Useless
+#define		PathB                     			0x1
+#define		PathC                     			0x2
+#define		PathD                     			0x3
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPwrSeq.h
new file mode 100644
index 000000000..6d1641f00
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188EPwrSeq.h
@@ -0,0 +1,176 @@
+
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL8188EPWRSEQ_H__
+#define __HAL8188EPWRSEQ_H__
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20110607-Paul-RTL8188E_Power_Architecture-R02.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+
+    PWR SEQ Version: rtl8188E_PwrSeq_V09.h
+*/
+#define	RTL8188E_TRANS_CARDEMU_TO_ACT_STEPS	10
+#define	RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS	10
+#define	RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS	10
+#define	RTL8188E_TRANS_SUS_TO_CARDEMU_STEPS	10
+#define	RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS	10
+#define	RTL8188E_TRANS_PDN_TO_CARDEMU_STEPS	10
+#define	RTL8188E_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8188E_TRANS_LPS_TO_ACT_STEPS	15
+#define	RTL8188E_TRANS_END_STEPS	1
+
+
+#define RTL8188E_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0|BIT1, 0}, /* 0x02[1:0] = 0	reset BB*/			\
+	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7}, /*0x24[23] = 2b'01 schmit trigger */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0}, /* 0x04[15] = 0 disable HWPDN (control by DRV)*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, 0}, /*0x04[12:11] = 2b'00 disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*0x04[8] = 1 polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0}, /*wait till 0x04[8] = 0*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*LDO normal mode*/	\
+
+#define RTL8188E_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*LDO Sleep mode*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+
+#define RTL8188E_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11enable WL suspend for PCIe*/	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, BIT7}, /*  0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */	\
+	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*Clear SIC_EN register 0x40[12] = 1'b0 */	\
+	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*Set USB suspend enable local register  0xfe10[4]=1 */	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8188E_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8188E_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7}, /*0x24[23] = 2b'01 schmit trigger */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*  0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */	\
+	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*Clear SIC_EN register 0x40[12] = 1'b0 */	\
+	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*Set USB suspend enable local register  0xfe10[4]=1 */	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8188E_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8188E_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8188E_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+//This is used by driver for LPSRadioOff Procedure, not for FW LPS Step
+#define RTL8188E_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8188E_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8188E_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8188E_power_on_flow[RTL8188E_TRANS_CARDEMU_TO_ACT_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_radio_off_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_card_disable_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_card_enable_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_suspend_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_resume_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_hwpdn_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_enter_lps_flow[RTL8188E_TRANS_ACT_TO_LPS_STEPS+RTL8188E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188E_leave_lps_flow[RTL8188E_TRANS_LPS_TO_ACT_STEPS+RTL8188E_TRANS_END_STEPS];
+
+#endif //__HAL8188EPWRSEQ_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyCfg.h
new file mode 100644
index 000000000..d3ed337db
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyCfg.h
@@ -0,0 +1,149 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8188FPHYCFG_H__
+#define __INC_HAL8188FPHYCFG_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters End-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+/*------------------------------Define structure End----------------------------*/
+
+/*--------------------------Exported Function prototype---------------------*/
+u32
+PHY_QueryBBReg_8188F(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask
+	);
+
+VOID
+PHY_SetBBReg_8188F(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	);
+
+u32
+PHY_QueryRFReg_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask
+	);
+
+VOID
+PHY_SetRFReg_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask,
+	IN	u32				Data
+	);
+
+/* MAC/BB/RF HAL config */
+int PHY_BBConfig8188F(PADAPTER	Adapter	);
+
+int PHY_RFConfig8188F(PADAPTER	Adapter	);
+
+s32 PHY_MACConfig8188F(PADAPTER padapter);
+
+int
+PHY_ConfigRFWithParaFile_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8* 				pFileName,
+	RF_PATH				eRFPath
+);
+
+VOID
+PHY_SetTxPowerIndex_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u32					PowerIndex,
+	IN	u8					RFPath,
+	IN	u8					Rate
+	);
+
+u8
+PHY_GetTxPowerIndex_8188F(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8					Channel
+	);
+
+VOID
+PHY_GetTxPowerLevel8188F(
+	IN	PADAPTER		Adapter,
+	OUT s32*		    		powerlevel
+	);
+
+VOID
+PHY_SetTxPowerLevel8188F(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel
+	);
+
+VOID
+PHY_SetBWMode8188F(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH			Bandwidth,	// 20M or 40M
+	IN	unsigned char				Offset		// Upper, Lower, or Don't care
+);
+
+VOID
+PHY_SwChnl8188F(	// Call after initialization
+	IN	PADAPTER	Adapter,
+	IN	u8		channel
+	);
+
+VOID
+PHY_SetSwChnlBWMode8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+VOID PHY_SetRFPathSwitch_8188F(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		bMain
+	);
+/*--------------------------Exported Function prototype End---------------------*/
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyReg.h
new file mode 100644
index 000000000..31013cde9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPhyReg.h
@@ -0,0 +1,1171 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8188FPHYREG_H__
+#define __INC_HAL8188FPHYREG_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       Regsiter offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rTxAGC_B_Rate18_06				0x830
+#define		rTxAGC_B_Rate54_24				0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback	0x8b8	// Transceiver A HSPI Readback
+#define		TransceiverB_HSPI_Readback	0x8bc	// Transceiver B HSPI Readback
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+#define 	rS0S1_PathSwitch			0x948
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+//
+// PageB(0xB00)
+//
+#define		rPdp_AntA      				0xb00
+#define		rPdp_AntA_4    				0xb04
+#define		rConfig_Pmpd_AntA 			0xb28
+#define		rConfig_AntA 				0xb68
+#define		rConfig_AntB 				0xb6c
+#define		rPdp_AntB 					0xb70
+#define		rPdp_AntB_4 				0xb74
+#define		rConfig_Pmpd_AntB			0xb98
+#define		rAPK						0xbd8
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK 						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS 				0xed4
+#define		rRx_TO_Rx 					0xed8
+#define		rStandby 						0xedc
+#define		rSleep 						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	// RF channel switch
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1				0x01	//
+#define		RF_IQADJ_G2				0x02	//
+#define		RF_BS_PA_APSET_G1_G4		0x03
+#define		RF_BS_PA_APSET_G5_G8		0x04
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC				0x08	//
+#define		RF_IPA_G					0x09	//
+#define		RF_TXBIAS_G				0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A					0x0C	//
+#define		RF_TXBIAS_A				0x0D
+#define		RF_BS_PA_APSET_G9_G11	0x0E
+#define		RF_BS_IQGEN				0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_TXBIAS					0x16 //
+#define		RF_POW_ABILITY			0x17	//
+#define		RF_MODE_AG				0x18	//
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1					0x1E	//
+#define		RF_RCK2					0x1F	//
+
+#define		RF_TX_G1					0x20	//
+#define		RF_TX_G2					0x21	//
+#define		RF_TX_G3					0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER					0x24	//
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define 	RF_TX_BIAS_A				0x35
+#define 	RF_TX_BIAS_D				0x36
+#define 	RF_LOBF_9					0x38
+#define 	RF_RXRF_A3					0x3C	//
+#define 	RF_TRSW 					0x3F
+
+#define 	RF_TXRF_A2					0x41
+#define 	RF_TXPA_G4					0x46
+#define 	RF_TXPA_A4					0x4B
+#define 	RF_0x52 					0x52
+#define		RF_RXG_MIX_SWBW				0x87
+#define		RF_DBG_LP_RX2				0xDF
+#define 	RF_WE_LUT					0xEF
+#define 	RF_S0S1 					0xB0
+
+#define RF_TX_GAIN_OFFSET_8188F(_val) (abs((_val)) | (((_val) > 0) ? BIT5 : 0))
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bAntennaSelect                 		0x0300
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode				0x3	// Useless
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand			0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble			0x8	// Useless
+#define		bCCKAntDiversity		0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate				0x3000
+#define		bCCKDCCancel			0x0800
+#define		bCCKISICancel			0x0400
+#define		bCCKMatchFilter			0x0200
+#define		bCCKEqualizer			0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart			0x300000
+#define		bCCKCCACount			0x080000
+#define		bCCKcs_lim				0x070000
+#define		bCCKBistMode			0x80000000
+#define		bCCKCCAMask			0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase		0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset			0xf0
+#define		bCCKRxDCOffset			0xf
+#define		bCCKCCAMode			0xc000
+#define		bCCKFalseCS_lim			0x3f00
+#define		bCCKCS_ratio			0xc00000
+#define		bCCKCorgBit_sel			0x300000
+#define		bCCKPD_lim				0x0f0000
+#define		bCCKNewCCA			0x80000000
+#define		bCCKRxHPofIG			0x8000
+#define		bCCKRxIG				0x7f00
+#define		bCCKLNAPolarity			0x800000
+#define		bCCKRx1stGain			0x7f0000
+#define		bCCKRFExtend			0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle			0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC			0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType	0x0300
+#define		bCCKRxDAGCEn			0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0				0x3f0000
+#define		bCCKTxC1				0x3f000000
+#define		bCCKTxC2				0x3f
+#define		bCCKTxC3				0x3f00
+#define		bCCKTxC4				0x3f0000
+#define		bCCKTxC5				0x3f000000
+#define		bCCKTxC6				0x3f
+#define		bCCKTxC7				0x3f00
+#define		bCCKDebugPort			0xff0000
+#define		bCCKDACDebug			0x0f000000
+#define		bCCKFalseAlarmEnable	0x8000
+#define		bCCKFalseAlarmRead		0x4000
+#define		bCCKTRSSI				0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel	0x80000000
+#define		bCCKRxReport_MFOff		0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss	0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate	0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze	0x4000
+#define		bCCKTxPathSel			0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF				0x3	// Useless
+#define		bShift_L					0xc0
+#define		bGI_TH					0xc
+#define		bRxPathA				0x1
+#define		bRxPathB				0x2
+#define		bRxPathC				0x4
+#define		bRxPathD				0x8
+#define		bTxPathA				0x1
+#define		bTxPathB				0x2
+#define		bTxPathC				0x4
+#define		bTxPathD				0x8
+#define		bTRSSIFreq				0x200
+#define		bADCBackoff				0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset			0xff00
+#define		bRxDFIRMode			0x1800000
+#define		bRxDCNFType			0xe000000
+#define		bRXIQImb_A				0x3ff
+#define		bRXIQImb_B				0xfc00
+#define		bRXIQImb_C				0x3f0000
+#define		bRXIQImb_D				0xffc00000
+#define		bDC_dc_Notch			0x60000
+#define		bRxNBINotch			0x1f000000
+#define		bPD_TH					0xf
+#define		bPD_TH_Opt2			0xc000
+#define		bPWED_TH				0x700
+#define		bIfMF_Win_L			0x800
+#define		bPD_Option				0x1000
+#define		bMF_Win_L				0xe000
+#define		bBW_Search_L			0x30000
+#define		bwin_enh_L				0xc0000
+#define		bBW_TH					0x700000
+#define		bED_TH2				0x3800000
+#define		bBW_option				0x4000000
+#define		bRatio_TH				0x18000000
+#define		bWindow_L				0xe0000000
+#define		bSBD_Option				0x1
+#define		bFrame_TH				0x1c
+#define		bFS_Option				0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L	0xe00
+#define		bFrame_Weight_Short	0x7000
+#define		bSub_Tune				0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2			0x7
+#define		bFrame_GI2_TH			0x38
+#define		bGI2_Sync_en			0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum				0x1
+#define		bCFOAcc				0x2
+#define		bCFOStartOffset			0xc
+#define		bCFOLookBack			0x70
+#define		bCFOSumWeight			0x80
+#define		bDAGCEnable			0x10000
+#define		bTXIQImb_A				0x3ff
+#define		bTXIQImb_B				0xfc00
+#define		bTXIQImb_C				0x3f0000
+#define		bTXIQImb_D				0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset			0xff00
+#define		bTxDFIRMode			0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption			0x20000
+#define		bCCADropThres			0xfff00000
+#define		bEDCCA_H				0xf
+#define		bEDCCA_L				0xf0
+#define		bLambda_ED			0x300
+#define		bRxInitialGain			0x7f
+#define		bRxAntDivEn				0x80
+#define		bRxAGCAddressForLNA	0x7f00
+#define		bRxHighPowerFlow		0x8000
+#define		bRxAGCFreezeThres		0xc0000
+#define		bRxFreezeStep_AGC1	0x300000
+#define		bRxFreezeStep_AGC2	0xc00000
+#define		bRxFreezeStep_AGC3	0x3000000
+#define		bRxFreezeStep_AGC0	0xc000000
+#define		bRxRssi_Cmp_En			0x10000000
+#define		bRxQuickAGCEn			0x20000000
+#define		bRxAGCFreezeThresMode	0x40000000
+#define		bRxOverFlowCheckType	0x80000000
+#define		bRxAGCShift				0x7f
+#define		bTRSW_Tri_Only			0x80
+#define		bPowerThres			0x300
+#define		bRxAGCEn				0x1
+#define		bRxAGCTogetherEn		0x2
+#define		bRxAGCMin				0x4
+#define		bRxHP_Ini				0x7
+#define		bRxHP_TRLNA			0x70
+#define		bRxHP_RSSI				0x700
+#define		bRxHP_BBP1				0x7000
+#define		bRxHP_BBP2				0x70000
+#define		bRxHP_BBP3				0x700000
+#define		bRSSI_H					0x7f0000     //the threshold for high power
+#define		bRSSI_Gen				0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW			0x7
+#define		bRxSettle_LNA			0x38
+#define		bRxSettle_RSSI			0x1c0
+#define		bRxSettle_BBP			0xe00
+#define		bRxSettle_RxHP			0x7000
+#define		bRxSettle_AntSW_RSSI	0x38000
+#define		bRxSettle_AntSW		0xc0000
+#define		bRxProcessTime_DAGC	0x300000
+#define		bRxSettle_HSSI			0x400000
+#define		bRxProcessTime_BBPPW	0x800000
+#define		bRxAntennaPowerShift	0x3000000
+#define		bRSSITableSelect		0xc000000
+#define		bRxHP_Final				0x7000000
+#define		bRxHTSettle_BBP			0x7
+#define		bRxHTSettle_HSSI		0x8
+#define		bRxHTSettle_RxHP		0x70
+#define		bRxHTSettle_BBPPW		0x80
+#define		bRxHTSettle_Idle		0x300
+#define		bRxHTSettle_Reserved	0x1c00
+#define		bRxHTRxHPEn			0x8000
+#define		bRxHTAGCFreezeThres	0x30000
+#define		bRxHTAGCTogetherEn	0x40000
+#define		bRxHTAGCMin			0x80000
+#define		bRxHTAGCEn				0x100000
+#define		bRxHTDAGCEn			0x200000
+#define		bRxHTRxHP_BBP			0x1c00000
+#define		bRxHTRxHP_Final		0xe0000000
+#define		bRxPWRatioTH			0x3
+#define		bRxPWRatioEn			0x4
+#define		bRxMFHold				0x3800
+#define		bRxPD_Delay_TH1		0x38
+#define		bRxPD_Delay_TH2		0x1c0
+#define		bRxPD_DC_COUNT_MAX	0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH			0x8000
+#define		bRxProcess_Delay		0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L			0xc000000
+#define		bRxSGI_Search_L		0x30000000
+#define		bRxSGI_TH				0xc0000000
+#define		bDFSCnt0				0xff
+#define		bDFSCnt1				0xff00
+#define		bDFSFlag				0xf0000
+#define		bMFWeightSum			0x300000
+#define		bMinIdxTH				0x7f000000
+#define		bDAFormat				0x40000
+#define		bTxChEmuEnable		0x01000000
+#define		bTRSWIsolation_A		0x7f
+#define		bTRSWIsolation_B		0x7f00
+#define		bTRSWIsolation_C		0x7f0000
+#define		bTRSWIsolation_D		0x7f000000
+#define		bExtLNAGain				0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn				0x4	// Useless
+#define		bAntennaMapping		0x10
+#define		bNss					0x20
+#define		bCFOAntSumD			0x200
+#define		bPHYCounterReset		0x8000000
+#define		bCFOReportGet			0x4000000
+#define		bOFDMContinueTx		0x10000000
+#define		bOFDMSingleCarrier		0x20000000
+#define		bOFDMSingleTone		0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect			0x100
+#define		bCFOEn				0x10000
+#define		bCFOValue			0xfff00000
+#define		bSigTone_Re		0x3f
+#define		bSigTone_Im		0x7f00
+#define		bCounter_CCA		0xffff
+#define		bCounter_ParityFail	0xffff0000
+#define		bCounter_RateIllegal		0xffff
+#define		bCounter_CRC8Fail	0xffff0000
+#define		bCounter_MCSNoSupport	0xffff
+#define		bCounter_FastSync	0xffff
+#define		bShortCFO			0xfff
+#define		bShortCFOTLength	12   //total
+#define		bShortCFOFLength	11   //fraction
+#define		bLongCFO			0x7ff
+#define		bLongCFOTLength	11
+#define		bLongCFOFLength	11
+#define		bTailCFO			0x1fff
+#define		bTailCFOTLength		13
+#define		bTailCFOFLength		12
+#define		bmax_en_pwdB		0xffff
+#define		bCC_power_dB		0xffff0000
+#define		bnoise_pwdB		0xffff
+#define		bPowerMeasTLength	10
+#define		bPowerMeasFLength	3
+#define		bRx_HT_BW			0x1
+#define		bRxSC				0x6
+#define		bRx_HT				0x8
+#define		bNB_intf_det_on		0x1
+#define		bIntf_win_len_cfg	0x30
+#define		bNB_Intf_TH_cfg		0x1c0
+#define		bRFGain				0x3f
+#define		bTableSel			0x40
+#define		bTRSW				0x80
+#define		bRxSNR_A			0xff
+#define		bRxSNR_B			0xff00
+#define		bRxSNR_C			0xff0000
+#define		bRxSNR_D			0xff000000
+#define		bSNREVMTLength		8
+#define		bSNREVMFLength		1
+#define		bCSI1st				0xff
+#define		bCSI2nd				0xff00
+#define		bRxEVM1st			0xff0000
+#define		bRxEVM2nd			0xff000000
+#define		bSIGEVM			0xff
+#define		bPWDB				0xff00
+#define		bSGIEN				0x10000
+
+#define		bSFactorQAM1		0xf	// Useless
+#define		bSFactorQAM2		0xf0
+#define		bSFactorQAM3		0xf00
+#define		bSFactorQAM4		0xf000
+#define		bSFactorQAM5		0xf0000
+#define		bSFactorQAM6		0xf0000
+#define		bSFactorQAM7		0xf00000
+#define		bSFactorQAM8		0xf000000
+#define		bSFactorQAM9		0xf0000000
+#define		bCSIScheme			0x100000
+
+#define		bNoiseLvlTopSet		0x3	// Useless
+#define		bChSmooth			0x4
+#define		bChSmoothCfg1		0x38
+#define		bChSmoothCfg2		0x1c0
+#define		bChSmoothCfg3		0xe00
+#define		bChSmoothCfg4		0x7000
+#define		bMRCMode			0x800000
+#define		bTHEVMCfg			0x7000000
+
+#define		bLoopFitType		0x1	// Useless
+#define		bUpdCFO			0x40
+#define		bUpdCFOOffData		0x80
+#define		bAdvUpdCFO			0x100
+#define		bAdvTimeCtrl		0x800
+#define		bUpdClko			0x1000
+#define		bFC					0x6000
+#define		bTrackingMode		0x8000
+#define		bPhCmpEnable		0x10000
+#define		bUpdClkoLTF		0x20000
+#define		bComChCFO			0x40000
+#define		bCSIEstiMode		0x80000
+#define		bAdvUpdEqz			0x100000
+#define		bUChCfg				0x7000000
+#define		bUpdEqz			0x8000000
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn		0x20000000	// Useless
+#define		bRxPesudoNoise_A		0xff
+#define		bRxPesudoNoise_B		0xff00
+#define		bRxPesudoNoise_C		0xff0000
+#define		bRxPesudoNoise_D		0xff000000
+#define		bPesudoNoiseState_A	0xffff
+#define		bPesudoNoiseState_B	0xffff0000
+#define		bPesudoNoiseState_C	0xffff
+#define		bPesudoNoiseState_D	0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable		0x8		// Useless
+#define		bZebra1_TRxControl		0xc00
+#define		bZebra1_TRxGainSetting	0x07f
+#define		bZebra1_RxCorner		0xc00
+#define		bZebra1_TxChargePump	0x38
+#define		bZebra1_RxChargePump	0x7
+#define		bZebra1_ChannelNum	0xf80
+#define		bZebra1_TxLPFBW		0x400
+#define		bZebra1_RxLPFBW		0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1	0x100	// Useless
+#define		bRTL8256RegModeCtrl0	0x40
+#define		bRTL8256_TxLPFBW		0x18
+#define		bRTL8256_RxLPFBW		0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW		0xc	// Useless
+#define		bRTL8258_RxLPFBW		0xc00
+#define		bRTL8258_RSSILPFBW	0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0				0x1	// Useless
+#define		bByte1				0x2
+#define		bByte2				0x4
+#define		bByte3				0x8
+#define		bWord0				0x3
+#define		bWord1				0xc
+#define		bDWord				0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0			0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1			0xff00
+#define		bMaskByte2			0xff0000
+#define		bMaskByte3			0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord			0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes		0xffffff00
+#define		bMask12Bits			0xfff
+#define		bMaskH4Bits			0xf0000000
+#define		bMaskOFDM_D		0xffc00000
+#define		bMaskCCK			0x3f3f3f3f
+
+
+#define		bEnable			0x1	// Useless
+#define		bDisable		0x0
+
+#define		LeftAntenna		0x0	// Useless
+#define		RightAntenna	0x1
+
+#define		tCheckTxStatus		500   //500ms // Useless
+#define		tUpdateRxCounter	100   //100ms
+
+#define		rateCCK		0	// Useless
+#define		rateOFDM	1
+#define		rateHT		2
+
+//define Register-End
+#define		bPMAC_End			0x1ff	// Useless
+#define		bFPGAPHY0_End		0x8ff
+#define		bFPGAPHY1_End		0x9ff
+#define		bCCKPHY0_End		0xaff
+#define		bOFDMPHY0_End		0xcff
+#define		bOFDMPHY1_End		0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl		0x0		// Useless
+#define		bWMACControl		0x1
+#define		bWNICControl		0x2
+
+#define		PathA			0x0	// Useless
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+// BB Register Definition
+//
+// 4. Page9(0x900)
+//
+#define rDPDT_control				0x92c
+#define rfe_ctrl_anta_src				0x930
+#define rS0S1_PathSwitch   			0x948
+#define	BBrx_DFIR						0x954
+#define AGC_table_select				0xb2c
+
+//
+// PageB(0xB00)
+//
+#define rPdp_AntA						0xb00
+#define rPdp_AntA_4						0xb04
+#define rPdp_AntA_8						0xb08
+#define rPdp_AntA_C						0xb0c
+#define rPdp_AntA_10					0xb10
+#define rPdp_AntA_14					0xb14
+#define rPdp_AntA_18					0xb18
+#define rPdp_AntA_1C					0xb1c
+#define rPdp_AntA_20					0xb20
+#define rPdp_AntA_24					0xb24
+
+#define rConfig_Pmpd_AntA 				0xb28
+#define rConfig_ram64x16				0xb2c
+
+#define rBndA							0xb30
+#define rHssiPar						0xb34
+
+#define rConfig_AntA					0xb68
+#define rConfig_AntB					0xb6c
+
+#define rPdp_AntB						0xb70
+#define rPdp_AntB_4						0xb74
+#define rPdp_AntB_8						0xb78
+#define rPdp_AntB_C						0xb7c
+#define rPdp_AntB_10					0xb80
+#define rPdp_AntB_14					0xb84
+#define rPdp_AntB_18					0xb88
+#define rPdp_AntB_1C					0xb8c
+#define rPdp_AntB_20					0xb90
+#define rPdp_AntB_24					0xb94
+
+#define rConfig_Pmpd_AntB				0xb98
+
+#define rBndB							0xba0
+
+#define rAPK							0xbd8
+#define rPm_Rx0_AntA					0xbdc
+#define rPm_Rx1_AntA					0xbe0
+#define rPm_Rx2_AntA					0xbe4
+#define rPm_Rx3_AntA					0xbe8
+#define rPm_Rx0_AntB					0xbec
+#define rPm_Rx1_AntB					0xbf0
+#define rPm_Rx2_AntB					0xbf4
+#define rPm_Rx3_AntB					0xbf8
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPwrSeq.h
new file mode 100644
index 000000000..f9fb5ba83
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8188FPwrSeq.h
@@ -0,0 +1,199 @@
+#ifndef REALTEK_POWER_SEQUENCE_8188F
+#define REALTEK_POWER_SEQUENCE_8188F
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20130815-JackieLau-RTL8188F_Power_Architecture v08.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8188F_TRANS_CARDEMU_TO_ACT_STEPS	13
+#define	RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS	14
+#define	RTL8188F_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8188F_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8188F_TRANS_ACT_TO_LPS_STEPS		11
+#define	RTL8188F_TRANS_LPS_TO_ACT_STEPS		13
+#define	RTL8188F_TRANS_ACT_TO_SWLPS_STEPS		21
+#define	RTL8188F_TRANS_SWLPS_TO_ACT_STEPS		14
+#define	RTL8188F_TRANS_END_STEPS		1
+
+
+#define RTL8188F_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT3), 0},/*  0x4[11]=1'b0 disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* 0x4[8]=1 polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/	 \
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x35}, /*0x27<=35 to reduce RF noise*/
+
+#define RTL8188F_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x34}, /*0x27 <= 34, xtal_qsel=0 to xtal bring up*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+
+#define RTL8188F_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00}, /*0x07=0x00 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/ \
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+#define RTL8188F_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+#define RTL8188F_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00}, /*0x07=0x00 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/ \
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+#define RTL8188F_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+
+#define RTL8188F_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8188F_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8188F_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*set RPWM IMR*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/
+
+
+#define RTL8188F_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84},  /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xff,0x35},/*xtal_qsel=1 for low noise*/	\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x002B, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x1c, 0x1c},   /*.	0x2b[4:2] = 3b'111	to enable BB,AFE clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0},  /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+
+ #define RTL8188F_TRANS_ACT_TO_SWLPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*set RPWM IMR*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+	{0x002b, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x1C, 0x00},/*0x2b[4:2]<=0 to gated BB,AFE clock*/	\
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x34},/*xtal_qsel=0 for bring up*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x00},/* sdio LPS option*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x83},/* usb LPS option, open bandgap, xtal*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /* 0xC4[5]<=0, digital LDO no standby mode*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /* 0xC4[7]<=1, on domain voltage adjust*/	\
+	{0x00a7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0xe0}, /* low power LPS enable for sdio*/	\
+	{0x00a7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0xe4}, /* low power LPS enable for usb*/	\
+	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /* enable WL_LPS_EN*/
+
+
+#define RTL8188F_TRANS_SWLPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/*polling TSF stable*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1, enable security engine*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x06B7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x09}, /*.	reset MAC rx state machine*/\
+	{0x06B4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x86}, /*.	reset MAC rx state machine*/\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/* set CPU RAM code ready*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* Enable CPU*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*enable CPU IO Wrapper*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2},/* Enable CPU*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, BIT7},/*polling FW init ready */	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT6, BIT6},/*polling FW init ready */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8188F_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8188F_power_on_flow[RTL8188F_TRANS_CARDEMU_TO_ACT_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_radio_off_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_card_disable_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_card_enable_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_suspend_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_resume_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_hwpdn_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS+RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_enter_lps_flow[RTL8188F_TRANS_ACT_TO_LPS_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_leave_lps_flow[RTL8188F_TRANS_LPS_TO_ACT_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_enter_swlps_flow[RTL8188F_TRANS_ACT_TO_SWLPS_STEPS+RTL8188F_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8188F_leave_swlps_flow[RTL8188F_TRANS_SWLPS_TO_ACT_STEPS+RTL8188F_TRANS_END_STEPS];
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyCfg.h
new file mode 100644
index 000000000..801a0869f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyCfg.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8192EPHYCFG_H__
+#define __INC_HAL8192EPHYCFG_H__
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*------------------------------Define structure----------------------------*/
+
+/* BB/RF related */
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//
+// BB and RF register read/write
+//
+u32	PHY_QueryBBReg8192E(	IN	PADAPTER	Adapter,
+								IN	u32			RegAddr,
+								IN	u32			BitMask	);
+void	PHY_SetBBReg8192E(	IN	PADAPTER		Adapter,
+								IN	u32			RegAddr,
+								IN	u32			BitMask,
+								IN	u32			Data	);
+u32	PHY_QueryRFReg8192E(	IN	PADAPTER	Adapter,
+								IN	u8			eRFPath,
+								IN	u32			RegAddr,
+								IN	u32			BitMask	);
+void	PHY_SetRFReg8192E(	IN	PADAPTER		Adapter,
+							IN	u8			eRFPath,
+								IN	u32			RegAddr,
+								IN	u32			BitMask,
+								IN	u32			Data	);
+
+//
+// Initialization related function
+//
+/* MAC/BB/RF HAL config */
+int	PHY_MACConfig8192E(IN PADAPTER	Adapter	);
+int	PHY_BBConfig8192E(IN PADAPTER	Adapter	);
+int	PHY_RFConfig8192E(IN PADAPTER	Adapter	);
+
+/* RF config */
+
+
+//
+// BB TX Power R/W
+//
+void	PHY_GetTxPowerLevel8192E(	IN PADAPTER	Adapter, OUT s32*	powerlevel	);
+void	PHY_SetTxPowerLevel8192E(	IN PADAPTER	Adapter, IN u8	channel	);
+BOOLEAN	PHY_UpdateTxPowerDbm8192E( IN PADAPTER	Adapter, IN int	powerInDbm	);
+
+VOID
+PHY_SetTxPowerIndex_8192E(
+	IN	PADAPTER			Adapter,
+	IN	u32					PowerIndex,
+	IN	u8					RFPath,
+	IN	u8					Rate
+	);
+
+u8
+PHY_GetTxPowerIndex_8192E(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8					Channel
+	);
+
+//
+// Switch bandwidth for 8192S
+//
+VOID
+PHY_SetBWMode8192E(
+	IN	PADAPTER			pAdapter,
+	IN	CHANNEL_WIDTH	Bandwidth,
+	IN	u8					Offset
+);
+
+//
+// channel switch related funciton
+//
+VOID
+PHY_SwChnl8192E(
+	IN	PADAPTER	Adapter,
+	IN	u8			channel
+);
+
+
+VOID
+PHY_SetSwChnlBWMode8192E(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH	Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+VOID
+PHY_SetRFEReg_8192E(
+	IN PADAPTER		Adapter
+);
+
+void
+phy_SpurCalibration_8192E(
+	IN	PADAPTER			Adapter,
+	IN	SPUR_CAL_METHOD	Method
+);
+void PHY_SpurCalibration_8192E(IN PADAPTER Adapter);
+
+#ifdef CONFIG_SPUR_CAL_NBI
+void
+phy_SpurCalibration_8192E_NBI(
+	IN	PADAPTER			Adapter
+);
+#endif
+//
+// BB/MAC/RF other monitor API
+//
+
+VOID
+PHY_SetRFPathSwitch_8192E(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		bMain
+);
+
+VOID
+storePwrIndexDiffRateOffset(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	);
+
+/*--------------------------Exported Function prototype---------------------*/
+#endif	// __INC_HAL8192CPHYCFG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyReg.h
new file mode 100644
index 000000000..128e461b2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPhyReg.h
@@ -0,0 +1,1133 @@
+/*****************************************************************************
+ *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+ *
+ * Module:	__INC_HAL8192SPHYREG_H
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *		Data		Who		Remark
+ *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
+ *							2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __INC_HAL8192EPHYREG_H
+#define __INC_HAL8192EPHYREG_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       8192S Regsiter offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart				0x104
+#define		rPMAC_TxLegacySIG			0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum			0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble		0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK		0x170
+#define		rPMAC_OFDMRxCRC32Er		0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus				0x18c
+
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo					0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1				0x810	// Useless now
+#define		rFPGA0_RFTiming2				0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter	0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888
+#define		rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback		0x8b8	// Transceiver A HSPI Readback
+#define		TransceiverB_HSPI_Readback		0x8bc	// Transceiver B HSPI Readback
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo					0x90c	// Useless now // Status report??
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System					0xa00
+
+#define		rCCK0_AFESetting				0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1			0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2			0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort				0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         			0xa50
+#define		rCCK0_RxReport            			0xa54  //0xa57
+#define		rCCK0_FACounterLower      		0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      		0xa58  //0xa5c
+
+//
+// PageB(0xB00)
+//
+#define		rPdp_AntA      					0xb00
+#define		rPdp_AntA_4    				0xb04
+#define		rConfig_Pmpd_AntA 			0xb28
+#define		rConfig_ram64x16				0xb2c
+
+#define		rConfig_AntA 					0xb68
+#define		rConfig_AntB 					0xb6c
+#define		rPdp_AntB 					0xb70
+#define		rPdp_AntB_4 					0xb74
+#define		rConfig_Pmpd_AntB			0xb98
+#define		rAPK							0xbd8
+
+
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF					0xc00
+
+#define		rOFDM0_TRxPathEnable			0xc04
+#define		rOFDM0_TRMuxPar				0xc08
+#define		rOFDM0_TRSWIsolation			0xc0c
+
+#define		rOFDM0_XARxAFE				0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    		0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            			0xc18
+#define		rOFDM0_XBRxIQImbalance    		0xc1c
+#define		rOFDM0_XCRxAFE            			0xc20
+#define		rOFDM0_XCRxIQImbalance    		0xc24
+#define		rOFDM0_XDRxAFE            			0xc28
+#define		rOFDM0_XDRxIQImbalance    		0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC			0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold		0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold			0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1		0xc70
+#define		rOFDM0_AGCParameter2		0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_RxHPParameter		0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync			0xcf0
+#define		rOFDM0_DFSReport			0xcf4
+
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO					0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD					0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet				0xd3c
+#define		rOFDM1_PseudoNoiseStateAB	0xd50
+#define		rOFDM1_PseudoNoiseStateCD	0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1			0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2			0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3			0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB			0xdac	// No setting now
+#define		rOFDM_ShortCFOCD			0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR				0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00		0xe10
+#define		rTxAGC_A_Mcs07_Mcs04		0xe14
+#define		rTxAGC_A_Mcs11_Mcs08		0xe18
+#define		rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00		0x83c
+#define		rTxAGC_B_Mcs07_Mcs04		0x848
+#define		rTxAGC_B_Mcs11_Mcs08		0x84c
+#define		rTxAGC_B_Mcs15_Mcs12		0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK 						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS 				0xed4
+#define		rRx_TO_Rx 					0xed8
+#define		rStandby 						0xedc
+#define		rSleep 						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1			0x1
+#define		rZebra1_TRxEnable2			0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	// RF channel switch
+
+//#endif
+#define		rZebra1_TxGain				0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl					0	// Useless now
+#define		rRTL8256_TxLPF				19
+#define		rRTL8256_RxLPF				11
+
+//RTL8258
+#define		rRTL8258_TxLPF				0x11	// Useless now
+#define		rRTL8258_RxLPF				0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1					0x01	//
+#define		RF_IQADJ_G2					0x02	//
+
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC					0x08	//
+#define		RF_IPA_G						0x09	//
+#define		RF_TXBIAS_G					0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A						0x0C	//
+#define		RF_TXBIAS_A					0x0D
+#define		RF_BS_PA_APSET_G9_G11		0x0E
+#define		RF_BS_IQGEN					0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_TXBIAS					0x16
+#define		RF_POW_ABILITY				0x17	//
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1						0x1E	//
+#define		RF_RCK2						0x1F	//
+
+#define		RF_TX_G1						0x20	//
+#define		RF_TX_G2						0x21	//
+#define		RF_TX_G3						0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER_8192E			0x42	//
+#define		RF_T_METER_88E				0x42	//
+#define		RF_T_METER					0x24	//
+
+//#endif
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define		RF_TX_BIAS_A					0x35
+#define		RF_TX_BIAS_D					0x36
+#define		RF_LOBF_9					0x38
+#define		RF_RXRF_A3					0x3C	//
+#define		RF_TRSW						0x3F
+
+#define		RF_TXRF_A2					0x41
+#define		RF_TXPA_G4					0x46
+#define		RF_TXPA_A4					0x4B
+#define 		RF_0x52						0x52
+#define 		RF_LDO						0xB1
+#define		RF_WE_LUT					0xEF
+
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB					0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart					0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback				0x10
+#define		bTxLSIG						0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength				0x1ffe0
+#define		bOFDMTxParity				0x20000
+#define		bTxHTSIG1					0xffffff
+#define		bTxHTMCSRate				0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2					0xffffff
+#define		bTxHTSmoothing				0x1
+#define		bTxHTSounding				0x2
+#define		bTxHTReserved				0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC					0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8					0x3fc00
+#define		bCounterReset				0x10000
+#define		bNumOfOFDMTx				0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval				0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader				0xffffffff
+#define		bTxDataInit					0xff
+#define		bTxHTMode					0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed				0xffffffff
+#define		bCCKTxPreamble				0x1
+#define		bCCKTxSFD					0xffff0000
+#define		bCCKTxSIG					0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus				0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+#define		RF_TX_GAIN_OFFSET_8192E(_val)		((abs((_val)) << 1) | (((_val) > 0) ? BIT0 : 0))
+
+
+// 2. Page8(0x800)
+#define		bRFMOD						0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode					0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn						0x1000000
+#define		bOFDMEn					0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  				0x3f
+
+#define		bAntennaSelect                 			0x0300
+
+#define		bXBTxAGC                  				0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  				0xf000
+#define		bXDTxAGC                  				0xf0000
+
+#define		bPAStart                  				0xf0000000	// Useless now
+#define		bTRStart                  				0x00f00000
+#define		bRFStart                  				0x0000f000
+#define		bBBStart                  				0x000000f0
+#define		bBBCCKStart               			0x0000000f
+#define		bPAEnd                    				0xf          //Reg0x814
+#define		bTREnd                    				0x0f000000
+#define		bRFEnd                    				0x000f0000
+#define		bCCAMask                  				0x000000f0   //T2R
+#define		bR2RCCAMask               			0x00000f00
+#define		bHSSI_R2TDelay            			0xf8000000
+#define		bHSSI_T2RDelay            			0xf80000
+#define		bContTxHSSI               			0x400     //chane gain at continue Tx
+#define		bIGFromCCK                			0x200
+#define		bAGCAddress               			0x3f
+#define		bRxHPTx                   				0x7000
+#define		bRxHPT2R                  				0x38000
+#define		bRxHPCCKIni               			0xc0000
+#define		bAGCTxCode                			0xc00000
+#define		bAGCRxCode                			0x300000
+
+#define		b3WireDataLength          			0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           			0x40000000
+#define		b2GPAPEPolarity           			0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           			0x1
+#define		bRFSI_3WireClock          			0x2
+#define		bRFSI_3WireLoad           			0x4
+#define		bRFSI_3WireRW             			0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      	0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           	0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        	0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x				0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          	0x40000
+#define		bAD7InputCMMode           	0x380000
+#define		bAD7Current               		0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          	0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          	0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       	0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                		0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       			0x10
+#define		bAntNonHT           	      		0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving         		0x80
+#define		bCCKRxPowerSaving         		0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                		0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable      	0x8000
+#define		bCCKFalseAlarmRead        	0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       	0x80000000
+#define		bCCKRxReport_MFOff        	0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      	0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       	0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       	0x4000
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             			0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             		0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               		0x3ff
+#define		bRXIQImb_B               			0xfc00
+#define		bRXIQImb_C               			0x3f0000
+#define		bRXIQImb_D               		0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              		0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              		0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              		0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     	0xe00
+#define		bFrame_Weight_Short      	0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              		0x10000
+#define		bTXIQImb_A               			0x3ff
+#define		bTXIQImb_B               			0xfc00
+#define		bTXIQImb_C               			0x3f0000
+#define		bTXIQImb_D               			0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             		0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED               		0x300
+#define		bRxInitialGain           			0x7f
+#define		bRxAntDivEn              		0x80
+#define		bRxAGCAddressForLNA      	0x7f00
+#define		bRxHighPowerFlow         		0x8000
+#define		bRxAGCFreezeThres        		0xc0000
+#define		bRxFreezeStep_AGC1       	0x300000
+#define		bRxFreezeStep_AGC2       	0xc00000
+#define		bRxFreezeStep_AGC3       	0x3000000
+#define		bRxFreezeStep_AGC0       	0xc000000
+#define		bRxRssi_Cmp_En           		0x10000000
+#define		bRxQuickAGCEn            		0x20000000
+#define		bRxAGCFreezeThresMode    	0x40000000
+#define		bRxOverFlowCheckType     	0x80000000
+#define		bRxAGCShift              			0x7f
+#define		bTRSW_Tri_Only           		0x80
+#define		bPowerThres              		0x300
+#define		bRxAGCEn                 			0x1
+#define		bRxAGCTogetherEn         		0x2
+#define		bRxAGCMin                		0x4
+#define		bRxHP_Ini                			0x7
+#define		bRxHP_TRLNA              		0x70
+#define		bRxHP_RSSI               			0x700
+#define		bRxHP_BBP1               		0x7000
+#define		bRxHP_BBP2               		0x70000
+#define		bRxHP_BBP3               		0x700000
+#define		bRSSI_H                  			0x7f0000     //the threshold for high power
+#define		bRSSI_Gen                			0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW           		0x7
+#define		bRxSettle_LNA            		0x38
+#define		bRxSettle_RSSI           		0x1c0
+#define		bRxSettle_BBP            		0xe00
+#define		bRxSettle_RxHP           		0x7000
+#define		bRxSettle_AntSW_RSSI     	0x38000
+#define		bRxSettle_AntSW          		0xc0000
+#define		bRxProcessTime_DAGC      	0x300000
+#define		bRxSettle_HSSI           		0x400000
+#define		bRxProcessTime_BBPPW     	0x800000
+#define		bRxAntennaPowerShift     	0x3000000
+#define		bRSSITableSelect         		0xc000000
+#define		bRxHP_Final              			0x7000000
+#define		bRxHTSettle_BBP          		0x7
+#define		bRxHTSettle_HSSI         		0x8
+#define		bRxHTSettle_RxHP         		0x70
+#define		bRxHTSettle_BBPPW        		0x80
+#define		bRxHTSettle_Idle         		0x300
+#define		bRxHTSettle_Reserved     	0x1c00
+#define		bRxHTRxHPEn              		0x8000
+#define		bRxHTAGCFreezeThres      	0x30000
+#define		bRxHTAGCTogetherEn       	0x40000
+#define		bRxHTAGCMin             	 	0x80000
+#define		bRxHTAGCEn               		0x100000
+#define		bRxHTDAGCEn              		0x200000
+#define		bRxHTRxHP_BBP            		0x1c00000
+#define		bRxHTRxHP_Final          		0xe0000000
+#define		bRxPWRatioTH             		0x3
+#define		bRxPWRatioEn             		0x4
+#define		bRxMFHold                			0x3800
+#define		bRxPD_Delay_TH1          		0x38
+#define		bRxPD_Delay_TH2          		0x1c0
+#define		bRxPD_DC_COUNT_MAX       	0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH           		0x8000
+#define		bRxProcess_Delay         		0xf0000
+#define		bRxSearchrange_GI2_Early 	0x700000
+#define		bRxFrame_Guard_Counter_L 	0x3800000
+#define		bRxSGI_Guard_L           		0xc000000
+#define		bRxSGI_Search_L          		0x30000000
+#define		bRxSGI_TH                			0xc0000000
+#define		bDFSCnt0                 			0xff
+#define		bDFSCnt1                 			0xff00
+#define		bDFSFlag                 			0xf0000
+#define		bMFWeightSum             		0x300000
+#define		bMinIdxTH                			0x7f000000
+#define		bDAFormat                			0x40000
+#define		bTxChEmuEnable           		0x01000000
+#define		bTRSWIsolation_A         		0x7f
+#define		bTRSWIsolation_B         		0x7f00
+#define		bTRSWIsolation_C         		0x7f0000
+#define		bTRSWIsolation_D         		0x7f000000
+#define		bExtLNAGain              		0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn                  			0x4	// Useless
+#define		bAntennaMapping          		0x10
+#define		bNss                     			0x20
+#define		bCFOAntSumD              		0x200
+#define		bPHYCounterReset         		0x8000000
+#define		bCFOReportGet            		0x4000000
+#define		bOFDMContinueTx          		0x10000000
+#define		bOFDMSingleCarrier       		0x20000000
+#define		bOFDMSingleTone          		0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect                			0x100
+#define		bCFOEn                   			0x10000
+#define		bCFOValue                			0xfff00000
+#define		bSigTone_Re              			0x3f
+#define		bSigTone_Im              			0x7f00
+#define		bCounter_CCA             		0xffff
+#define		bCounter_ParityFail      		0xffff0000
+#define		bCounter_RateIllegal     		0xffff
+#define		bCounter_CRC8Fail        		0xffff0000
+#define		bCounter_MCSNoSupport    	0xffff
+#define		bCounter_FastSync        		0xffff
+#define		bShortCFO                			0xfff
+#define		bShortCFOTLength         		12   //total
+#define		bShortCFOFLength         		11   //fraction
+#define		bLongCFO                 			0x7ff
+#define		bLongCFOTLength          		11
+#define		bLongCFOFLength          		11
+#define		bTailCFO                 			0x1fff
+#define		bTailCFOTLength          		13
+#define		bTailCFOFLength          		12
+#define		bmax_en_pwdB             		0xffff
+#define		bCC_power_dB             		0xffff0000
+#define		bnoise_pwdB              		0xffff
+#define		bPowerMeasTLength        	10
+#define		bPowerMeasFLength        	3
+#define		bRx_HT_BW                		0x1
+#define		bRxSC                    			0x6
+#define		bRx_HT                   			0x8
+#define		bNB_intf_det_on          		0x1
+#define		bIntf_win_len_cfg        		0x30
+#define		bNB_Intf_TH_cfg          		0x1c0
+#define		bRFGain                  			0x3f
+#define		bTableSel                			0x40
+#define		bTRSW                    			0x80
+#define		bRxSNR_A                 			0xff
+#define		bRxSNR_B                 			0xff00
+#define		bRxSNR_C                 			0xff0000
+#define		bRxSNR_D                 			0xff000000
+#define		bSNREVMTLength           		8
+#define		bSNREVMFLength           		1
+#define		bCSI1st                  			0xff
+#define		bCSI2nd                  			0xff00
+#define		bRxEVM1st                			0xff0000
+#define		bRxEVM2nd                		0xff000000
+#define		bSIGEVM                  			0xff
+#define		bPWDB                    			0xff00
+#define		bSGIEN                   			0x10000
+
+#define		bSFactorQAM1             		0xf	// Useless
+#define		bSFactorQAM2             		0xf0
+#define		bSFactorQAM3             		0xf00
+#define		bSFactorQAM4             		0xf000
+#define		bSFactorQAM5             		0xf0000
+#define		bSFactorQAM6             		0xf0000
+#define		bSFactorQAM7             		0xf00000
+#define		bSFactorQAM8             		0xf000000
+#define		bSFactorQAM9             		0xf0000000
+#define		bCSIScheme               			0x100000
+
+#define		bNoiseLvlTopSet          		0x3	// Useless
+#define		bChSmooth                			0x4
+#define		bChSmoothCfg1            		0x38
+#define		bChSmoothCfg2            		0x1c0
+#define		bChSmoothCfg3            		0xe00
+#define		bChSmoothCfg4            		0x7000
+#define		bMRCMode                 		0x800000
+#define		bTHEVMCfg                			0x7000000
+
+#define		bLoopFitType             			0x1	// Useless
+#define		bUpdCFO                  			0x40
+#define		bUpdCFOOffData           		0x80
+#define		bAdvUpdCFO               		0x100
+#define		bAdvTimeCtrl             		0x800
+#define		bUpdClko                 			0x1000
+#define		bFC                      				0x6000
+#define		bTrackingMode            		0x8000
+#define		bPhCmpEnable             		0x10000
+#define		bUpdClkoLTF              			0x20000
+#define		bComChCFO                		0x40000
+#define		bCSIEstiMode             		0x80000
+#define		bAdvUpdEqz               		0x100000
+#define		bUChCfg                  			0x7000000
+#define		bUpdEqz                  			0x8000000
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn         		0x20000000	// Useless
+#define		bRxPesudoNoise_A         		0xff
+#define		bRxPesudoNoise_B         		0xff00
+#define		bRxPesudoNoise_C         		0xff0000
+#define		bRxPesudoNoise_D         		0xff000000
+#define		bPesudoNoiseState_A      	0xffff
+#define		bPesudoNoiseState_B      	0xffff0000
+#define		bPesudoNoiseState_C      		0xffff
+#define		bPesudoNoiseState_D      	0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable        		0x8		// Useless
+#define		bZebra1_TRxControl        		0xc00
+#define		bZebra1_TRxGainSetting    	0x07f
+#define		bZebra1_RxCorner          		0xc00
+#define		bZebra1_TxChargePump      	0x38
+#define		bZebra1_RxChargePump      	0x7
+#define		bZebra1_ChannelNum        	0xf80
+#define		bZebra1_TxLPFBW           		0x400
+#define		bZebra1_RxLPFBW           		0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1      	0x100	// Useless
+#define		bRTL8256RegModeCtrl0      	0x40
+#define		bRTL8256_TxLPFBW          	0x18
+#define		bRTL8256_RxLPFBW          	0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW          	0xc	// Useless
+#define		bRTL8258_RxLPFBW          	0xc00
+#define		bRTL8258_RSSILPFBW        	0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0                    			0x1	// Useless
+#define		bByte1                    			0x2
+#define		bByte2                    			0x4
+#define		bByte3                    			0x8
+#define		bWord0                    			0x3
+#define		bWord1                    			0xc
+#define		bDWord                    			0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0                		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1                		0xff00
+#define		bMaskByte2                		0xff0000
+#define		bMaskByte3                		0xff000000
+#define		bMaskHWord                		0xffff0000
+#define		bMaskLWord                		0x0000ffff
+#define		bMaskDWord                		0xffffffff
+#define		bMaskH3Bytes				0xffffff00
+#define		bMask12Bits				0xfff
+#define		bMaskH4Bits				0xf0000000
+#define 		bMaskOFDM_D			0xffc00000
+#define		bMaskCCK				0x3f3f3f3f
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+//#define		bMask12Bits               0xfffff	// RF Reg mask bits
+//#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask			0xfffff
+
+#define		bEnable                   0x1	// Useless
+#define		bDisable                  0x0
+
+#define		LeftAntenna               			0x0	// Useless
+#define		RightAntenna              		0x1
+
+#define		tCheckTxStatus            		500   //500ms // Useless
+#define		tUpdateRxCounter          		100   //100ms
+
+#define		rateCCK     				0	// Useless
+#define		rateOFDM    				1
+#define		rateHT      					2
+
+//define Register-End
+#define		bPMAC_End                 		0x1ff	// Useless
+#define		bFPGAPHY0_End             		0x8ff
+#define		bFPGAPHY1_End             		0x9ff
+#define		bCCKPHY0_End              		0xaff
+#define		bOFDMPHY0_End             		0xcff
+#define		bOFDMPHY1_End             		0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl              		0x0		// Useless
+#define		bWMACControl              		0x1
+#define		bWNICControl              		0x2
+
+#define		PathA                     			0x0	// Useless
+#define		PathB                     			0x1
+#define		PathC                     			0x2
+#define		PathD                     			0x3
+
+
+// RSSI Dump Message
+#define		rA_RSSIDump_92E 			0xcb0
+#define		rB_RSSIDump_92E 			0xcb1
+#define		rS1_RXevmDump_92E			0xcb2
+#define		rS2_RXevmDump_92E			0xcb3
+#define		rA_RXsnrDump_92E			0xcb4
+#define		rB_RXsnrDump_92E			0xcb5
+#define		rA_CfoShortDump_92E		0xcb6
+#define		rB_CfoShortDump_92E		0xcb8
+#define   	rA_CfoLongDump_92E			0xcba
+#define		rB_CfoLongDump_92E			0xcbc
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	//__INC_HAL8188EPHYREG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPwrSeq.h
new file mode 100644
index 000000000..f321a7827
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8192EPwrSeq.h
@@ -0,0 +1,155 @@
+#ifndef REALTEK_POWER_SEQUENCE_8192E
+#define REALTEK_POWER_SEQUENCE_8192E
+
+#include "HalPwrSeqCmd.h"
+/*
+	Check document WM-20110607-Paul-RTL8192E_Power_Architecture-R02.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8192E_TRANS_CARDEMU_TO_ACT_STEPS	18
+#define	RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS	18
+#define	RTL8192E_TRANS_CARDEMU_TO_SUS_STEPS	18
+#define	RTL8192E_TRANS_SUS_TO_CARDEMU_STEPS	18
+#define	RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS	18
+#define	RTL8192E_TRANS_PDN_TO_CARDEMU_STEPS	18
+#define	RTL8192E_TRANS_ACT_TO_LPS_STEPS	23
+#define	RTL8192E_TRANS_LPS_TO_ACT_STEPS	23
+#define	RTL8192E_TRANS_END_STEPS	1
+
+
+#define RTL8192E_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3), 0},/* disable WL suspend*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/	\
+
+
+#define RTL8192E_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+
+
+#define RTL8192E_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8192E_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8192E_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x00CC, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*Unlock small LDO Register*/	\
+	{0x0011, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*Disable small LDO*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8192E_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0011, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*Enable small LDO*/	\
+	{0x00CC, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0}, /*Lock small LDO Register*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
+
+
+#define RTL8192E_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8192E_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8192E_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8192E_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM, For Repeatly In and out, Taggle bit should be changed*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/\
+	{0x013D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*Clear ISR*/
+
+#define RTL8192E_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8192E_power_on_flow[RTL8192E_TRANS_CARDEMU_TO_ACT_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_radio_off_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_card_disable_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_card_enable_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_suspend_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192E_TRANS_CARDEMU_TO_SUS_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_resume_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192E_TRANS_CARDEMU_TO_SUS_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_hwpdn_flow[RTL8192E_TRANS_ACT_TO_CARDEMU_STEPS+RTL8192E_TRANS_CARDEMU_TO_PDN_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_enter_lps_flow[RTL8192E_TRANS_ACT_TO_LPS_STEPS+RTL8192E_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8192E_leave_lps_flow[RTL8192E_TRANS_LPS_TO_ACT_STEPS+RTL8192E_TRANS_END_STEPS];
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyCfg.h
new file mode 100644
index 000000000..df6ee6fc0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyCfg.h
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8703BPHYCFG_H__
+#define __INC_HAL8703BPHYCFG_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters End-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+/*------------------------------Define structure End----------------------------*/
+
+/*--------------------------Exported Function prototype---------------------*/
+u32
+PHY_QueryBBReg_8703B(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask
+	);
+
+VOID
+PHY_SetBBReg_8703B(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	);
+
+u32
+PHY_QueryRFReg_8703B(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask
+	);
+
+VOID
+PHY_SetRFReg_8703B(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask,
+	IN	u32				Data
+	);
+
+/* MAC/BB/RF HAL config */
+int PHY_BBConfig8703B(PADAPTER	Adapter	);
+
+int PHY_RFConfig8703B(PADAPTER	Adapter	);
+
+s32 PHY_MACConfig8703B(PADAPTER padapter);
+
+int
+PHY_ConfigRFWithParaFile_8703B(
+	IN	PADAPTER			Adapter,
+	IN	u8* 				pFileName,
+	RF_PATH				eRFPath
+);
+
+VOID
+PHY_SetTxPowerIndex_8703B(
+	IN	PADAPTER			Adapter,
+	IN	u32					PowerIndex,
+	IN	u8					RFPath,
+	IN	u8					Rate
+	);
+
+u8
+PHY_GetTxPowerIndex_8703B(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8					Channel
+	);
+
+VOID
+PHY_GetTxPowerLevel8703B(
+	IN	PADAPTER		Adapter,
+	OUT s32*		    		powerlevel
+	);
+
+VOID
+PHY_SetTxPowerLevel8703B(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel
+	);
+
+VOID
+PHY_SetBWMode8703B(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH			Bandwidth,	// 20M or 40M
+	IN	unsigned char				Offset		// Upper, Lower, or Don't care
+);
+
+VOID
+PHY_SwChnl8703B(	// Call after initialization
+	IN	PADAPTER	Adapter,
+	IN	u8		channel
+	);
+
+VOID
+PHY_SetSwChnlBWMode8703B(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+/*--------------------------Exported Function prototype End---------------------*/
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyReg.h
new file mode 100644
index 000000000..36af1fc62
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPhyReg.h
@@ -0,0 +1,1139 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8703BPHYREG_H__
+#define __INC_HAL8703BPHYREG_H__
+
+#define		rSYM_WLBT_PAPE_SEL		0x64
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rTxAGC_B_Rate18_06				0x830
+#define		rTxAGC_B_Rate54_24				0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback	0x8b8	// Transceiver A HSPI Readback
+#define		TransceiverB_HSPI_Readback	0x8bc	// Transceiver B HSPI Readback
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define	rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+#define	rFPGA1_TxBlock				0x904	// Useless now
+#define	rFPGA1_DebugSelect			0x908	// Useless now
+#define	rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+#define	rDPDT_control				0x92c
+#define	rfe_ctrl_anta_src				0x930
+#define	rS0S1_PathSwitch   			0x948
+#define	rBBrx_DFIR					0x954
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+//
+// PageB(0xB00)
+//
+#define rPdp_AntA						0xb00
+#define rPdp_AntA_4						0xb04
+#define rPdp_AntA_8						0xb08
+#define rPdp_AntA_C						0xb0c
+#define rPdp_AntA_10					0xb10
+#define rPdp_AntA_14					0xb14
+#define rPdp_AntA_18					0xb18
+#define rPdp_AntA_1C					0xb1c
+#define rPdp_AntA_20					0xb20
+#define rPdp_AntA_24					0xb24
+
+#define rConfig_Pmpd_AntA 				0xb28
+#define rConfig_ram64x16				0xb2c
+
+#define rBndA							0xb30
+#define rHssiPar						0xb34
+
+#define rConfig_AntA					0xb68
+#define rConfig_AntB					0xb6c
+
+#define rPdp_AntB						0xb70
+#define rPdp_AntB_4						0xb74
+#define rPdp_AntB_8						0xb78
+#define rPdp_AntB_C						0xb7c
+#define rPdp_AntB_10					0xb80
+#define rPdp_AntB_14					0xb84
+#define rPdp_AntB_18					0xb88
+#define rPdp_AntB_1C					0xb8c
+#define rPdp_AntB_20					0xb90
+#define rPdp_AntB_24					0xb94
+
+#define rConfig_Pmpd_AntB				0xb98
+
+#define rBndB							0xba0
+
+#define rAPK							0xbd8
+#define rPm_Rx0_AntA					0xbdc
+#define rPm_Rx1_AntA					0xbe0
+#define rPm_Rx2_AntA					0xbe4
+#define rPm_Rx3_AntA					0xbe8
+#define rPm_Rx0_AntB					0xbec
+#define rPm_Rx1_AntB					0xbf0
+#define rPm_Rx2_AntB					0xbf4
+#define rPm_Rx3_AntB					0xbf8
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK 						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS 				0xed4
+#define		rRx_TO_Rx 					0xed8
+#define		rStandby 						0xedc
+#define		rSleep 						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	// RF channel switch
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1				0x01	//
+#define		RF_IQADJ_G2				0x02	//
+#define		RF_BS_PA_APSET_G1_G4		0x03
+#define		RF_BS_PA_APSET_G5_G8		0x04
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC				0x08	//
+#define		RF_IPA_G					0x09	//
+#define		RF_TXBIAS_G				0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A					0x0C	//
+#define		RF_TXBIAS_A				0x0D
+#define		RF_BS_PA_APSET_G9_G11	0x0E
+#define		RF_BS_IQGEN				0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_TXBIAS					0x16 //
+#define		RF_POW_ABILITY			0x17	//
+#define		RF_MODE_AG				0x18	//
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1					0x1E	//
+#define		RF_RCK2					0x1F	//
+
+#define		RF_TX_G1					0x20	//
+#define		RF_TX_G2					0x21	//
+#define		RF_TX_G3					0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER					0x24	//
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define 	RF_TX_BIAS_A				0x35
+#define 	RF_TX_BIAS_D				0x36
+#define 	RF_LOBF_9					0x38
+#define 	RF_RXRF_A3					0x3C	//
+#define 	RF_TRSW 					0x3F
+
+#define 	RF_TXRF_A2					0x41
+#define 	RF_TXPA_G4					0x46
+#define 	RF_TXPA_A4					0x4B
+#define 	RF_0x52 					0x52
+#define 	RF_WE_LUT					0xEF
+#define 	RF_S0S1 					0xB0
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+#define	RF_TX_GAIN_OFFSET_8703B(_val) (abs((_val)) | (((_val) > 0) ? BIT5 : 0))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bAntennaSelect                 		0x0300
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode				0x3	// Useless
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand			0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble			0x8	// Useless
+#define		bCCKAntDiversity		0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate				0x3000
+#define		bCCKDCCancel			0x0800
+#define		bCCKISICancel			0x0400
+#define		bCCKMatchFilter			0x0200
+#define		bCCKEqualizer			0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart			0x300000
+#define		bCCKCCACount			0x080000
+#define		bCCKcs_lim				0x070000
+#define		bCCKBistMode			0x80000000
+#define		bCCKCCAMask			0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase		0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset			0xf0
+#define		bCCKRxDCOffset			0xf
+#define		bCCKCCAMode			0xc000
+#define		bCCKFalseCS_lim			0x3f00
+#define		bCCKCS_ratio			0xc00000
+#define		bCCKCorgBit_sel			0x300000
+#define		bCCKPD_lim				0x0f0000
+#define		bCCKNewCCA			0x80000000
+#define		bCCKRxHPofIG			0x8000
+#define		bCCKRxIG				0x7f00
+#define		bCCKLNAPolarity			0x800000
+#define		bCCKRx1stGain			0x7f0000
+#define		bCCKRFExtend			0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle			0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC			0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType	0x0300
+#define		bCCKRxDAGCEn			0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0				0x3f0000
+#define		bCCKTxC1				0x3f000000
+#define		bCCKTxC2				0x3f
+#define		bCCKTxC3				0x3f00
+#define		bCCKTxC4				0x3f0000
+#define		bCCKTxC5				0x3f000000
+#define		bCCKTxC6				0x3f
+#define		bCCKTxC7				0x3f00
+#define		bCCKDebugPort			0xff0000
+#define		bCCKDACDebug			0x0f000000
+#define		bCCKFalseAlarmEnable	0x8000
+#define		bCCKFalseAlarmRead		0x4000
+#define		bCCKTRSSI				0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel	0x80000000
+#define		bCCKRxReport_MFOff		0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss	0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate	0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze	0x4000
+#define		bCCKTxPathSel			0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF				0x3	// Useless
+#define		bShift_L					0xc0
+#define		bGI_TH					0xc
+#define		bRxPathA				0x1
+#define		bRxPathB				0x2
+#define		bRxPathC				0x4
+#define		bRxPathD				0x8
+#define		bTxPathA				0x1
+#define		bTxPathB				0x2
+#define		bTxPathC				0x4
+#define		bTxPathD				0x8
+#define		bTRSSIFreq				0x200
+#define		bADCBackoff				0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset			0xff00
+#define		bRxDFIRMode			0x1800000
+#define		bRxDCNFType			0xe000000
+#define		bRXIQImb_A				0x3ff
+#define		bRXIQImb_B				0xfc00
+#define		bRXIQImb_C				0x3f0000
+#define		bRXIQImb_D				0xffc00000
+#define		bDC_dc_Notch			0x60000
+#define		bRxNBINotch			0x1f000000
+#define		bPD_TH					0xf
+#define		bPD_TH_Opt2			0xc000
+#define		bPWED_TH				0x700
+#define		bIfMF_Win_L			0x800
+#define		bPD_Option				0x1000
+#define		bMF_Win_L				0xe000
+#define		bBW_Search_L			0x30000
+#define		bwin_enh_L				0xc0000
+#define		bBW_TH					0x700000
+#define		bED_TH2				0x3800000
+#define		bBW_option				0x4000000
+#define		bRatio_TH				0x18000000
+#define		bWindow_L				0xe0000000
+#define		bSBD_Option				0x1
+#define		bFrame_TH				0x1c
+#define		bFS_Option				0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L	0xe00
+#define		bFrame_Weight_Short	0x7000
+#define		bSub_Tune				0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2			0x7
+#define		bFrame_GI2_TH			0x38
+#define		bGI2_Sync_en			0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum				0x1
+#define		bCFOAcc				0x2
+#define		bCFOStartOffset			0xc
+#define		bCFOLookBack			0x70
+#define		bCFOSumWeight			0x80
+#define		bDAGCEnable			0x10000
+#define		bTXIQImb_A				0x3ff
+#define		bTXIQImb_B				0xfc00
+#define		bTXIQImb_C				0x3f0000
+#define		bTXIQImb_D				0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset			0xff00
+#define		bTxDFIRMode			0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption			0x20000
+#define		bCCADropThres			0xfff00000
+#define		bEDCCA_H				0xf
+#define		bEDCCA_L				0xf0
+#define		bLambda_ED			0x300
+#define		bRxInitialGain			0x7f
+#define		bRxAntDivEn				0x80
+#define		bRxAGCAddressForLNA	0x7f00
+#define		bRxHighPowerFlow		0x8000
+#define		bRxAGCFreezeThres		0xc0000
+#define		bRxFreezeStep_AGC1	0x300000
+#define		bRxFreezeStep_AGC2	0xc00000
+#define		bRxFreezeStep_AGC3	0x3000000
+#define		bRxFreezeStep_AGC0	0xc000000
+#define		bRxRssi_Cmp_En			0x10000000
+#define		bRxQuickAGCEn			0x20000000
+#define		bRxAGCFreezeThresMode	0x40000000
+#define		bRxOverFlowCheckType	0x80000000
+#define		bRxAGCShift				0x7f
+#define		bTRSW_Tri_Only			0x80
+#define		bPowerThres			0x300
+#define		bRxAGCEn				0x1
+#define		bRxAGCTogetherEn		0x2
+#define		bRxAGCMin				0x4
+#define		bRxHP_Ini				0x7
+#define		bRxHP_TRLNA			0x70
+#define		bRxHP_RSSI				0x700
+#define		bRxHP_BBP1				0x7000
+#define		bRxHP_BBP2				0x70000
+#define		bRxHP_BBP3				0x700000
+#define		bRSSI_H					0x7f0000     //the threshold for high power
+#define		bRSSI_Gen				0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW			0x7
+#define		bRxSettle_LNA			0x38
+#define		bRxSettle_RSSI			0x1c0
+#define		bRxSettle_BBP			0xe00
+#define		bRxSettle_RxHP			0x7000
+#define		bRxSettle_AntSW_RSSI	0x38000
+#define		bRxSettle_AntSW		0xc0000
+#define		bRxProcessTime_DAGC	0x300000
+#define		bRxSettle_HSSI			0x400000
+#define		bRxProcessTime_BBPPW	0x800000
+#define		bRxAntennaPowerShift	0x3000000
+#define		bRSSITableSelect		0xc000000
+#define		bRxHP_Final				0x7000000
+#define		bRxHTSettle_BBP			0x7
+#define		bRxHTSettle_HSSI		0x8
+#define		bRxHTSettle_RxHP		0x70
+#define		bRxHTSettle_BBPPW		0x80
+#define		bRxHTSettle_Idle		0x300
+#define		bRxHTSettle_Reserved	0x1c00
+#define		bRxHTRxHPEn			0x8000
+#define		bRxHTAGCFreezeThres	0x30000
+#define		bRxHTAGCTogetherEn	0x40000
+#define		bRxHTAGCMin			0x80000
+#define		bRxHTAGCEn				0x100000
+#define		bRxHTDAGCEn			0x200000
+#define		bRxHTRxHP_BBP			0x1c00000
+#define		bRxHTRxHP_Final		0xe0000000
+#define		bRxPWRatioTH			0x3
+#define		bRxPWRatioEn			0x4
+#define		bRxMFHold				0x3800
+#define		bRxPD_Delay_TH1		0x38
+#define		bRxPD_Delay_TH2		0x1c0
+#define		bRxPD_DC_COUNT_MAX	0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH			0x8000
+#define		bRxProcess_Delay		0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L			0xc000000
+#define		bRxSGI_Search_L		0x30000000
+#define		bRxSGI_TH				0xc0000000
+#define		bDFSCnt0				0xff
+#define		bDFSCnt1				0xff00
+#define		bDFSFlag				0xf0000
+#define		bMFWeightSum			0x300000
+#define		bMinIdxTH				0x7f000000
+#define		bDAFormat				0x40000
+#define		bTxChEmuEnable		0x01000000
+#define		bTRSWIsolation_A		0x7f
+#define		bTRSWIsolation_B		0x7f00
+#define		bTRSWIsolation_C		0x7f0000
+#define		bTRSWIsolation_D		0x7f000000
+#define		bExtLNAGain				0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn				0x4	// Useless
+#define		bAntennaMapping		0x10
+#define		bNss					0x20
+#define		bCFOAntSumD			0x200
+#define		bPHYCounterReset		0x8000000
+#define		bCFOReportGet			0x4000000
+#define		bOFDMContinueTx		0x10000000
+#define		bOFDMSingleCarrier		0x20000000
+#define		bOFDMSingleTone		0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect			0x100
+#define		bCFOEn				0x10000
+#define		bCFOValue			0xfff00000
+#define		bSigTone_Re		0x3f
+#define		bSigTone_Im		0x7f00
+#define		bCounter_CCA		0xffff
+#define		bCounter_ParityFail	0xffff0000
+#define		bCounter_RateIllegal		0xffff
+#define		bCounter_CRC8Fail	0xffff0000
+#define		bCounter_MCSNoSupport	0xffff
+#define		bCounter_FastSync	0xffff
+#define		bShortCFO			0xfff
+#define		bShortCFOTLength	12   //total
+#define		bShortCFOFLength	11   //fraction
+#define		bLongCFO			0x7ff
+#define		bLongCFOTLength	11
+#define		bLongCFOFLength	11
+#define		bTailCFO			0x1fff
+#define		bTailCFOTLength		13
+#define		bTailCFOFLength		12
+#define		bmax_en_pwdB		0xffff
+#define		bCC_power_dB		0xffff0000
+#define		bnoise_pwdB		0xffff
+#define		bPowerMeasTLength	10
+#define		bPowerMeasFLength	3
+#define		bRx_HT_BW			0x1
+#define		bRxSC				0x6
+#define		bRx_HT				0x8
+#define		bNB_intf_det_on		0x1
+#define		bIntf_win_len_cfg	0x30
+#define		bNB_Intf_TH_cfg		0x1c0
+#define		bRFGain				0x3f
+#define		bTableSel			0x40
+#define		bTRSW				0x80
+#define		bRxSNR_A			0xff
+#define		bRxSNR_B			0xff00
+#define		bRxSNR_C			0xff0000
+#define		bRxSNR_D			0xff000000
+#define		bSNREVMTLength		8
+#define		bSNREVMFLength		1
+#define		bCSI1st				0xff
+#define		bCSI2nd				0xff00
+#define		bRxEVM1st			0xff0000
+#define		bRxEVM2nd			0xff000000
+#define		bSIGEVM			0xff
+#define		bPWDB				0xff00
+#define		bSGIEN				0x10000
+
+#define		bSFactorQAM1		0xf	// Useless
+#define		bSFactorQAM2		0xf0
+#define		bSFactorQAM3		0xf00
+#define		bSFactorQAM4		0xf000
+#define		bSFactorQAM5		0xf0000
+#define		bSFactorQAM6		0xf0000
+#define		bSFactorQAM7		0xf00000
+#define		bSFactorQAM8		0xf000000
+#define		bSFactorQAM9		0xf0000000
+#define		bCSIScheme			0x100000
+
+#define		bNoiseLvlTopSet		0x3	// Useless
+#define		bChSmooth			0x4
+#define		bChSmoothCfg1		0x38
+#define		bChSmoothCfg2		0x1c0
+#define		bChSmoothCfg3		0xe00
+#define		bChSmoothCfg4		0x7000
+#define		bMRCMode			0x800000
+#define		bTHEVMCfg			0x7000000
+
+#define		bLoopFitType		0x1	// Useless
+#define		bUpdCFO			0x40
+#define		bUpdCFOOffData		0x80
+#define		bAdvUpdCFO			0x100
+#define		bAdvTimeCtrl		0x800
+#define		bUpdClko			0x1000
+#define		bFC					0x6000
+#define		bTrackingMode		0x8000
+#define		bPhCmpEnable		0x10000
+#define		bUpdClkoLTF		0x20000
+#define		bComChCFO			0x40000
+#define		bCSIEstiMode		0x80000
+#define		bAdvUpdEqz			0x100000
+#define		bUChCfg				0x7000000
+#define		bUpdEqz			0x8000000
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn		0x20000000	// Useless
+#define		bRxPesudoNoise_A		0xff
+#define		bRxPesudoNoise_B		0xff00
+#define		bRxPesudoNoise_C		0xff0000
+#define		bRxPesudoNoise_D		0xff000000
+#define		bPesudoNoiseState_A	0xffff
+#define		bPesudoNoiseState_B	0xffff0000
+#define		bPesudoNoiseState_C	0xffff
+#define		bPesudoNoiseState_D	0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable		0x8		// Useless
+#define		bZebra1_TRxControl		0xc00
+#define		bZebra1_TRxGainSetting	0x07f
+#define		bZebra1_RxCorner		0xc00
+#define		bZebra1_TxChargePump	0x38
+#define		bZebra1_RxChargePump	0x7
+#define		bZebra1_ChannelNum	0xf80
+#define		bZebra1_TxLPFBW		0x400
+#define		bZebra1_RxLPFBW		0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1	0x100	// Useless
+#define		bRTL8256RegModeCtrl0	0x40
+#define		bRTL8256_TxLPFBW		0x18
+#define		bRTL8256_RxLPFBW		0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW		0xc	// Useless
+#define		bRTL8258_RxLPFBW		0xc00
+#define		bRTL8258_RSSILPFBW	0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0				0x1	// Useless
+#define		bByte1				0x2
+#define		bByte2				0x4
+#define		bByte3				0x8
+#define		bWord0				0x3
+#define		bWord1				0xc
+#define		bDWord				0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0			0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1			0xff00
+#define		bMaskByte2			0xff0000
+#define		bMaskByte3			0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord			0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes		0xffffff00
+#define		bMask12Bits			0xfff
+#define		bMaskH4Bits			0xf0000000
+#define		bMaskOFDM_D		0xffc00000
+#define		bMaskCCK			0x3f3f3f3f
+
+
+#define		bEnable			0x1	// Useless
+#define		bDisable		0x0
+
+#define		LeftAntenna		0x0	// Useless
+#define		RightAntenna	0x1
+
+#define		tCheckTxStatus		500   //500ms // Useless
+#define		tUpdateRxCounter	100   //100ms
+
+#define		rateCCK		0	// Useless
+#define		rateOFDM	1
+#define		rateHT		2
+
+//define Register-End
+#define		bPMAC_End			0x1ff	// Useless
+#define		bFPGAPHY0_End		0x8ff
+#define		bFPGAPHY1_End		0x9ff
+#define		bCCKPHY0_End		0xaff
+#define		bOFDMPHY0_End		0xcff
+#define		bOFDMPHY1_End		0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl		0x0		// Useless
+#define		bWMACControl		0x1
+#define		bWNICControl		0x2
+
+#define		PathA			0x0	// Useless
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPwrSeq.h
new file mode 100644
index 000000000..01a53722b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8703BPwrSeq.h
@@ -0,0 +1,184 @@
+#ifndef REALTEK_POWER_SEQUENCE_8703B
+#define REALTEK_POWER_SEQUENCE_8703B
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20140402-JackieLau-RTL8703B_Power_Architecture v09.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8703B_TRANS_CARDEMU_TO_ACT_STEPS	23
+#define	RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8703B_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8703B_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8703B_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8703B_TRANS_ACT_TO_LPS_STEPS		15
+#define	RTL8703B_TRANS_LPS_TO_ACT_STEPS		15
+#define	RTL8703B_TRANS_END_STEPS		1
+
+
+#define RTL8703B_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
+	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3|BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[11]=0*/	\
+	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
+	{0x0004, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 , BIT3},/* enabled usb resume */	\
+	{0x0004, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 , 0},/* disable usb resume */	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3), 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/	\
+	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/* Enable WL control XTAL setting*/	\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
+	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable GPIO9 interrupt mode*/\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
+	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
+	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable HSISR GPIO9 interrupt*/\
+	{0x0068, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3},/*For GPIO9 internal pull high setting by test chip*/\
+	{0x0069, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/*For GPIO9 internal pull high setting*/\
+
+
+#define RTL8703B_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, 0},/* Enable BT control XTAL setting*/\
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/\
+
+
+#define RTL8703B_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8703B_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8703B_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
+        {0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8703B_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+        {0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/
+
+
+#define RTL8703B_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8703B_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8703B_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8703B_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8703B_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8703B_power_on_flow[RTL8703B_TRANS_CARDEMU_TO_ACT_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_radio_off_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_card_disable_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_card_enable_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_suspend_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8703B_TRANS_CARDEMU_TO_SUS_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_resume_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8703B_TRANS_CARDEMU_TO_SUS_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_hwpdn_flow[RTL8703B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8703B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_enter_lps_flow[RTL8703B_TRANS_ACT_TO_LPS_STEPS+RTL8703B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8703B_leave_lps_flow[RTL8703B_TRANS_LPS_TO_ACT_STEPS+RTL8703B_TRANS_END_STEPS];
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyCfg.h
new file mode 100644
index 000000000..8a21cfa00
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyCfg.h
@@ -0,0 +1,149 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8723BPHYCFG_H__
+#define __INC_HAL8723BPHYCFG_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters End-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+/*------------------------------Define structure End----------------------------*/
+
+/*--------------------------Exported Function prototype---------------------*/
+u32
+PHY_QueryBBReg_8723B(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask
+	);
+
+VOID
+PHY_SetBBReg_8723B(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	);
+
+u32
+PHY_QueryRFReg_8723B(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask
+	);
+
+VOID
+PHY_SetRFReg_8723B(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask,
+	IN	u32				Data
+	);
+
+/* MAC/BB/RF HAL config */
+int PHY_BBConfig8723B(PADAPTER	Adapter	);
+
+int PHY_RFConfig8723B(PADAPTER	Adapter	);
+
+s32 PHY_MACConfig8723B(PADAPTER padapter);
+
+int
+PHY_ConfigRFWithParaFile_8723B(
+	IN	PADAPTER			Adapter,
+	IN	u8* 				pFileName,
+	RF_PATH				eRFPath
+);
+
+VOID
+PHY_SetTxPowerIndex_8723B(
+	IN	PADAPTER			Adapter,
+	IN	u32					PowerIndex,
+	IN	u8					RFPath,
+	IN	u8					Rate
+	);
+
+u8
+PHY_GetTxPowerIndex_8723B(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8					Channel
+	);
+
+VOID
+PHY_GetTxPowerLevel8723B(
+	IN	PADAPTER		Adapter,
+	OUT s32*		    		powerlevel
+	);
+
+VOID
+PHY_SetTxPowerLevel8723B(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel
+	);
+
+VOID
+PHY_SetBWMode8723B(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH			Bandwidth,	// 20M or 40M
+	IN	unsigned char				Offset		// Upper, Lower, or Don't care
+);
+
+VOID
+PHY_SwChnl8723B(	// Call after initialization
+	IN	PADAPTER	Adapter,
+	IN	u8		channel
+	);
+
+VOID
+PHY_SetSwChnlBWMode8723B(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+VOID PHY_SetRFPathSwitch_8723B(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		bMain
+	);
+/*--------------------------Exported Function prototype End---------------------*/
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyReg.h
new file mode 100644
index 000000000..3e3087d55
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPhyReg.h
@@ -0,0 +1,1137 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8723BPHYREG_H__
+#define __INC_HAL8723BPHYREG_H__
+
+#define		rSYM_WLBT_PAPE_SEL		0x64
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rTxAGC_B_Rate18_06				0x830
+#define		rTxAGC_B_Rate54_24				0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback	0x8b8	// Transceiver A HSPI Readback
+#define		TransceiverB_HSPI_Readback	0x8bc	// Transceiver B HSPI Readback
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define	rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+#define	rFPGA1_TxBlock				0x904	// Useless now
+#define	rFPGA1_DebugSelect			0x908	// Useless now
+#define	rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+#define	rDPDT_control				0x92c
+#define	rfe_ctrl_anta_src				0x930
+#define	rS0S1_PathSwitch   			0x948
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+//
+// PageB(0xB00)
+//
+#define rPdp_AntA						0xb00
+#define rPdp_AntA_4						0xb04
+#define rPdp_AntA_8						0xb08
+#define rPdp_AntA_C						0xb0c
+#define rPdp_AntA_10					0xb10
+#define rPdp_AntA_14					0xb14
+#define rPdp_AntA_18					0xb18
+#define rPdp_AntA_1C					0xb1c
+#define rPdp_AntA_20					0xb20
+#define rPdp_AntA_24					0xb24
+
+#define rConfig_Pmpd_AntA 				0xb28
+#define rConfig_ram64x16				0xb2c
+
+#define rBndA							0xb30
+#define rHssiPar						0xb34
+
+#define rConfig_AntA					0xb68
+#define rConfig_AntB					0xb6c
+
+#define rPdp_AntB						0xb70
+#define rPdp_AntB_4						0xb74
+#define rPdp_AntB_8						0xb78
+#define rPdp_AntB_C						0xb7c
+#define rPdp_AntB_10					0xb80
+#define rPdp_AntB_14					0xb84
+#define rPdp_AntB_18					0xb88
+#define rPdp_AntB_1C					0xb8c
+#define rPdp_AntB_20					0xb90
+#define rPdp_AntB_24					0xb94
+
+#define rConfig_Pmpd_AntB				0xb98
+
+#define rBndB							0xba0
+
+#define rAPK							0xbd8
+#define rPm_Rx0_AntA					0xbdc
+#define rPm_Rx1_AntA					0xbe0
+#define rPm_Rx2_AntA					0xbe4
+#define rPm_Rx3_AntA					0xbe8
+#define rPm_Rx0_AntB					0xbec
+#define rPm_Rx1_AntB					0xbf0
+#define rPm_Rx2_AntB					0xbf4
+#define rPm_Rx3_AntB					0xbf8
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK 						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS 				0xed4
+#define		rRx_TO_Rx 					0xed8
+#define		rStandby 						0xedc
+#define		rSleep 						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	// RF channel switch
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1				0x01	//
+#define		RF_IQADJ_G2				0x02	//
+#define		RF_BS_PA_APSET_G1_G4		0x03
+#define		RF_BS_PA_APSET_G5_G8		0x04
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC				0x08	//
+#define		RF_IPA_G					0x09	//
+#define		RF_TXBIAS_G				0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A					0x0C	//
+#define		RF_TXBIAS_A				0x0D
+#define		RF_BS_PA_APSET_G9_G11	0x0E
+#define		RF_BS_IQGEN				0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_TXBIAS					0x16 //
+#define		RF_POW_ABILITY			0x17	//
+#define		RF_MODE_AG				0x18	//
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1					0x1E	//
+#define		RF_RCK2					0x1F	//
+
+#define		RF_TX_G1					0x20	//
+#define		RF_TX_G2					0x21	//
+#define		RF_TX_G3					0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER					0x24	//
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define 	RF_TX_BIAS_A				0x35
+#define 	RF_TX_BIAS_D				0x36
+#define 	RF_LOBF_9					0x38
+#define 	RF_RXRF_A3					0x3C	//
+#define 	RF_TRSW 					0x3F
+
+#define 	RF_TXRF_A2					0x41
+#define 	RF_TXPA_G4					0x46
+#define 	RF_TXPA_A4					0x4B
+#define 	RF_0x52 					0x52
+#define 	RF_WE_LUT					0xEF
+#define 	RF_S0S1 					0xB0
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bAntennaSelect                 		0x0300
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode				0x3	// Useless
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand			0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble			0x8	// Useless
+#define		bCCKAntDiversity		0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate				0x3000
+#define		bCCKDCCancel			0x0800
+#define		bCCKISICancel			0x0400
+#define		bCCKMatchFilter			0x0200
+#define		bCCKEqualizer			0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart			0x300000
+#define		bCCKCCACount			0x080000
+#define		bCCKcs_lim				0x070000
+#define		bCCKBistMode			0x80000000
+#define		bCCKCCAMask			0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase		0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset			0xf0
+#define		bCCKRxDCOffset			0xf
+#define		bCCKCCAMode			0xc000
+#define		bCCKFalseCS_lim			0x3f00
+#define		bCCKCS_ratio			0xc00000
+#define		bCCKCorgBit_sel			0x300000
+#define		bCCKPD_lim				0x0f0000
+#define		bCCKNewCCA			0x80000000
+#define		bCCKRxHPofIG			0x8000
+#define		bCCKRxIG				0x7f00
+#define		bCCKLNAPolarity			0x800000
+#define		bCCKRx1stGain			0x7f0000
+#define		bCCKRFExtend			0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle			0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC			0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType	0x0300
+#define		bCCKRxDAGCEn			0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0				0x3f0000
+#define		bCCKTxC1				0x3f000000
+#define		bCCKTxC2				0x3f
+#define		bCCKTxC3				0x3f00
+#define		bCCKTxC4				0x3f0000
+#define		bCCKTxC5				0x3f000000
+#define		bCCKTxC6				0x3f
+#define		bCCKTxC7				0x3f00
+#define		bCCKDebugPort			0xff0000
+#define		bCCKDACDebug			0x0f000000
+#define		bCCKFalseAlarmEnable	0x8000
+#define		bCCKFalseAlarmRead		0x4000
+#define		bCCKTRSSI				0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel	0x80000000
+#define		bCCKRxReport_MFOff		0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss	0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate	0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze	0x4000
+#define		bCCKTxPathSel			0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF				0x3	// Useless
+#define		bShift_L					0xc0
+#define		bGI_TH					0xc
+#define		bRxPathA				0x1
+#define		bRxPathB				0x2
+#define		bRxPathC				0x4
+#define		bRxPathD				0x8
+#define		bTxPathA				0x1
+#define		bTxPathB				0x2
+#define		bTxPathC				0x4
+#define		bTxPathD				0x8
+#define		bTRSSIFreq				0x200
+#define		bADCBackoff				0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset			0xff00
+#define		bRxDFIRMode			0x1800000
+#define		bRxDCNFType			0xe000000
+#define		bRXIQImb_A				0x3ff
+#define		bRXIQImb_B				0xfc00
+#define		bRXIQImb_C				0x3f0000
+#define		bRXIQImb_D				0xffc00000
+#define		bDC_dc_Notch			0x60000
+#define		bRxNBINotch			0x1f000000
+#define		bPD_TH					0xf
+#define		bPD_TH_Opt2			0xc000
+#define		bPWED_TH				0x700
+#define		bIfMF_Win_L			0x800
+#define		bPD_Option				0x1000
+#define		bMF_Win_L				0xe000
+#define		bBW_Search_L			0x30000
+#define		bwin_enh_L				0xc0000
+#define		bBW_TH					0x700000
+#define		bED_TH2				0x3800000
+#define		bBW_option				0x4000000
+#define		bRatio_TH				0x18000000
+#define		bWindow_L				0xe0000000
+#define		bSBD_Option				0x1
+#define		bFrame_TH				0x1c
+#define		bFS_Option				0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L	0xe00
+#define		bFrame_Weight_Short	0x7000
+#define		bSub_Tune				0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2			0x7
+#define		bFrame_GI2_TH			0x38
+#define		bGI2_Sync_en			0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum				0x1
+#define		bCFOAcc				0x2
+#define		bCFOStartOffset			0xc
+#define		bCFOLookBack			0x70
+#define		bCFOSumWeight			0x80
+#define		bDAGCEnable			0x10000
+#define		bTXIQImb_A				0x3ff
+#define		bTXIQImb_B				0xfc00
+#define		bTXIQImb_C				0x3f0000
+#define		bTXIQImb_D				0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset			0xff00
+#define		bTxDFIRMode			0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption			0x20000
+#define		bCCADropThres			0xfff00000
+#define		bEDCCA_H				0xf
+#define		bEDCCA_L				0xf0
+#define		bLambda_ED			0x300
+#define		bRxInitialGain			0x7f
+#define		bRxAntDivEn				0x80
+#define		bRxAGCAddressForLNA	0x7f00
+#define		bRxHighPowerFlow		0x8000
+#define		bRxAGCFreezeThres		0xc0000
+#define		bRxFreezeStep_AGC1	0x300000
+#define		bRxFreezeStep_AGC2	0xc00000
+#define		bRxFreezeStep_AGC3	0x3000000
+#define		bRxFreezeStep_AGC0	0xc000000
+#define		bRxRssi_Cmp_En			0x10000000
+#define		bRxQuickAGCEn			0x20000000
+#define		bRxAGCFreezeThresMode	0x40000000
+#define		bRxOverFlowCheckType	0x80000000
+#define		bRxAGCShift				0x7f
+#define		bTRSW_Tri_Only			0x80
+#define		bPowerThres			0x300
+#define		bRxAGCEn				0x1
+#define		bRxAGCTogetherEn		0x2
+#define		bRxAGCMin				0x4
+#define		bRxHP_Ini				0x7
+#define		bRxHP_TRLNA			0x70
+#define		bRxHP_RSSI				0x700
+#define		bRxHP_BBP1				0x7000
+#define		bRxHP_BBP2				0x70000
+#define		bRxHP_BBP3				0x700000
+#define		bRSSI_H					0x7f0000     //the threshold for high power
+#define		bRSSI_Gen				0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW			0x7
+#define		bRxSettle_LNA			0x38
+#define		bRxSettle_RSSI			0x1c0
+#define		bRxSettle_BBP			0xe00
+#define		bRxSettle_RxHP			0x7000
+#define		bRxSettle_AntSW_RSSI	0x38000
+#define		bRxSettle_AntSW		0xc0000
+#define		bRxProcessTime_DAGC	0x300000
+#define		bRxSettle_HSSI			0x400000
+#define		bRxProcessTime_BBPPW	0x800000
+#define		bRxAntennaPowerShift	0x3000000
+#define		bRSSITableSelect		0xc000000
+#define		bRxHP_Final				0x7000000
+#define		bRxHTSettle_BBP			0x7
+#define		bRxHTSettle_HSSI		0x8
+#define		bRxHTSettle_RxHP		0x70
+#define		bRxHTSettle_BBPPW		0x80
+#define		bRxHTSettle_Idle		0x300
+#define		bRxHTSettle_Reserved	0x1c00
+#define		bRxHTRxHPEn			0x8000
+#define		bRxHTAGCFreezeThres	0x30000
+#define		bRxHTAGCTogetherEn	0x40000
+#define		bRxHTAGCMin			0x80000
+#define		bRxHTAGCEn				0x100000
+#define		bRxHTDAGCEn			0x200000
+#define		bRxHTRxHP_BBP			0x1c00000
+#define		bRxHTRxHP_Final		0xe0000000
+#define		bRxPWRatioTH			0x3
+#define		bRxPWRatioEn			0x4
+#define		bRxMFHold				0x3800
+#define		bRxPD_Delay_TH1		0x38
+#define		bRxPD_Delay_TH2		0x1c0
+#define		bRxPD_DC_COUNT_MAX	0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH			0x8000
+#define		bRxProcess_Delay		0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L			0xc000000
+#define		bRxSGI_Search_L		0x30000000
+#define		bRxSGI_TH				0xc0000000
+#define		bDFSCnt0				0xff
+#define		bDFSCnt1				0xff00
+#define		bDFSFlag				0xf0000
+#define		bMFWeightSum			0x300000
+#define		bMinIdxTH				0x7f000000
+#define		bDAFormat				0x40000
+#define		bTxChEmuEnable		0x01000000
+#define		bTRSWIsolation_A		0x7f
+#define		bTRSWIsolation_B		0x7f00
+#define		bTRSWIsolation_C		0x7f0000
+#define		bTRSWIsolation_D		0x7f000000
+#define		bExtLNAGain				0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn				0x4	// Useless
+#define		bAntennaMapping		0x10
+#define		bNss					0x20
+#define		bCFOAntSumD			0x200
+#define		bPHYCounterReset		0x8000000
+#define		bCFOReportGet			0x4000000
+#define		bOFDMContinueTx		0x10000000
+#define		bOFDMSingleCarrier		0x20000000
+#define		bOFDMSingleTone		0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect			0x100
+#define		bCFOEn				0x10000
+#define		bCFOValue			0xfff00000
+#define		bSigTone_Re		0x3f
+#define		bSigTone_Im		0x7f00
+#define		bCounter_CCA		0xffff
+#define		bCounter_ParityFail	0xffff0000
+#define		bCounter_RateIllegal		0xffff
+#define		bCounter_CRC8Fail	0xffff0000
+#define		bCounter_MCSNoSupport	0xffff
+#define		bCounter_FastSync	0xffff
+#define		bShortCFO			0xfff
+#define		bShortCFOTLength	12   //total
+#define		bShortCFOFLength	11   //fraction
+#define		bLongCFO			0x7ff
+#define		bLongCFOTLength	11
+#define		bLongCFOFLength	11
+#define		bTailCFO			0x1fff
+#define		bTailCFOTLength		13
+#define		bTailCFOFLength		12
+#define		bmax_en_pwdB		0xffff
+#define		bCC_power_dB		0xffff0000
+#define		bnoise_pwdB		0xffff
+#define		bPowerMeasTLength	10
+#define		bPowerMeasFLength	3
+#define		bRx_HT_BW			0x1
+#define		bRxSC				0x6
+#define		bRx_HT				0x8
+#define		bNB_intf_det_on		0x1
+#define		bIntf_win_len_cfg	0x30
+#define		bNB_Intf_TH_cfg		0x1c0
+#define		bRFGain				0x3f
+#define		bTableSel			0x40
+#define		bTRSW				0x80
+#define		bRxSNR_A			0xff
+#define		bRxSNR_B			0xff00
+#define		bRxSNR_C			0xff0000
+#define		bRxSNR_D			0xff000000
+#define		bSNREVMTLength		8
+#define		bSNREVMFLength		1
+#define		bCSI1st				0xff
+#define		bCSI2nd				0xff00
+#define		bRxEVM1st			0xff0000
+#define		bRxEVM2nd			0xff000000
+#define		bSIGEVM			0xff
+#define		bPWDB				0xff00
+#define		bSGIEN				0x10000
+
+#define		bSFactorQAM1		0xf	// Useless
+#define		bSFactorQAM2		0xf0
+#define		bSFactorQAM3		0xf00
+#define		bSFactorQAM4		0xf000
+#define		bSFactorQAM5		0xf0000
+#define		bSFactorQAM6		0xf0000
+#define		bSFactorQAM7		0xf00000
+#define		bSFactorQAM8		0xf000000
+#define		bSFactorQAM9		0xf0000000
+#define		bCSIScheme			0x100000
+
+#define		bNoiseLvlTopSet		0x3	// Useless
+#define		bChSmooth			0x4
+#define		bChSmoothCfg1		0x38
+#define		bChSmoothCfg2		0x1c0
+#define		bChSmoothCfg3		0xe00
+#define		bChSmoothCfg4		0x7000
+#define		bMRCMode			0x800000
+#define		bTHEVMCfg			0x7000000
+
+#define		bLoopFitType		0x1	// Useless
+#define		bUpdCFO			0x40
+#define		bUpdCFOOffData		0x80
+#define		bAdvUpdCFO			0x100
+#define		bAdvTimeCtrl		0x800
+#define		bUpdClko			0x1000
+#define		bFC					0x6000
+#define		bTrackingMode		0x8000
+#define		bPhCmpEnable		0x10000
+#define		bUpdClkoLTF		0x20000
+#define		bComChCFO			0x40000
+#define		bCSIEstiMode		0x80000
+#define		bAdvUpdEqz			0x100000
+#define		bUChCfg				0x7000000
+#define		bUpdEqz			0x8000000
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn		0x20000000	// Useless
+#define		bRxPesudoNoise_A		0xff
+#define		bRxPesudoNoise_B		0xff00
+#define		bRxPesudoNoise_C		0xff0000
+#define		bRxPesudoNoise_D		0xff000000
+#define		bPesudoNoiseState_A	0xffff
+#define		bPesudoNoiseState_B	0xffff0000
+#define		bPesudoNoiseState_C	0xffff
+#define		bPesudoNoiseState_D	0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable		0x8		// Useless
+#define		bZebra1_TRxControl		0xc00
+#define		bZebra1_TRxGainSetting	0x07f
+#define		bZebra1_RxCorner		0xc00
+#define		bZebra1_TxChargePump	0x38
+#define		bZebra1_RxChargePump	0x7
+#define		bZebra1_ChannelNum	0xf80
+#define		bZebra1_TxLPFBW		0x400
+#define		bZebra1_RxLPFBW		0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1	0x100	// Useless
+#define		bRTL8256RegModeCtrl0	0x40
+#define		bRTL8256_TxLPFBW		0x18
+#define		bRTL8256_RxLPFBW		0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW		0xc	// Useless
+#define		bRTL8258_RxLPFBW		0xc00
+#define		bRTL8258_RSSILPFBW	0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0				0x1	// Useless
+#define		bByte1				0x2
+#define		bByte2				0x4
+#define		bByte3				0x8
+#define		bWord0				0x3
+#define		bWord1				0xc
+#define		bDWord				0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0			0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1			0xff00
+#define		bMaskByte2			0xff0000
+#define		bMaskByte3			0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord			0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes		0xffffff00
+#define		bMask12Bits			0xfff
+#define		bMaskH4Bits			0xf0000000
+#define		bMaskOFDM_D		0xffc00000
+#define		bMaskCCK			0x3f3f3f3f
+
+
+#define		bEnable			0x1	// Useless
+#define		bDisable		0x0
+
+#define		LeftAntenna		0x0	// Useless
+#define		RightAntenna	0x1
+
+#define		tCheckTxStatus		500   //500ms // Useless
+#define		tUpdateRxCounter	100   //100ms
+
+#define		rateCCK		0	// Useless
+#define		rateOFDM	1
+#define		rateHT		2
+
+//define Register-End
+#define		bPMAC_End			0x1ff	// Useless
+#define		bFPGAPHY0_End		0x8ff
+#define		bFPGAPHY1_End		0x9ff
+#define		bCCKPHY0_End		0xaff
+#define		bOFDMPHY0_End		0xcff
+#define		bOFDMPHY1_End		0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl		0x0		// Useless
+#define		bWMACControl		0x1
+#define		bWNICControl		0x2
+
+#define		PathA			0x0	// Useless
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPwrSeq.h
new file mode 100644
index 000000000..756cd7b7f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723BPwrSeq.h
@@ -0,0 +1,233 @@
+#ifndef REALTEK_POWER_SEQUENCE_8723B
+#define REALTEK_POWER_SEQUENCE_8723B
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20130815-JackieLau-RTL8723B_Power_Architecture v08.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8723B_TRANS_CARDEMU_TO_ACT_STEPS	26
+#define	RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8723B_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8723B_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8723B_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8723B_TRANS_ACT_TO_LPS_STEPS		15
+#define	RTL8723B_TRANS_LPS_TO_ACT_STEPS		15
+#define	RTL8723B_TRANS_ACT_TO_SWLPS_STEPS		22
+#define	RTL8723B_TRANS_SWLPS_TO_ACT_STEPS		15
+#define	RTL8723B_TRANS_END_STEPS		1
+
+
+#define RTL8723B_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
+	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3|BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[11]=0*/	\
+	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3), 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/	\
+	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/* Enable WL control XTAL setting*/	\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
+	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable GPIO9 interrupt mode*/\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
+	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
+	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable HSISR GPIO9 interrupt*/\
+	{0x0068, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3},/*For GPIO9 internal pull high setting by test chip*/\
+	{0x0069, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/*For GPIO9 internal pull high setting*/\
+
+
+#define RTL8723B_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+	{0x0010, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, 0},/* Enable BT control XTAL setting*/\
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/\
+
+
+#define RTL8723B_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8723B_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8723B_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
+        {0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8723B_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+        {0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/
+
+
+#define RTL8723B_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8723B_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8723B_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8723B_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+
+ #define RTL8723B_TRANS_ACT_TO_SWLPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*enable 32 K source*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1},/*CCK and OFDM are enable*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1},/*CCK and OFDM are enable*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*disable security engine*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x40},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*reset dual TSF*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/*Reset CPU*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*Reset MCUFWDL register*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1},/*Reset CPU IO Wrapper*/	\
+	{0x0287, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*polling RXFF packet number = 0 */	\
+	{0x0286, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/*polling RXDMA idle */	\
+	{0x013D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Clear FW RPWM interrupt */\
+	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Set FW RPWM interrupt source*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4},/*switch TSF to 32K*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/*polling TSF stable*/\
+	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Set FW LPS*/	\
+	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/*polling FW LPS ready */
+
+
+#define RTL8723B_TRANS_SWLPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0},/*switch TSF to 32K*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/*polling TSF stable*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1, enable security engine*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x06B7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x09}, /*.	reset MAC rx state machine*/\
+	{0x06B4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x86}, /*.	reset MAC rx state machine*/\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/* set CPU RAM code ready*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* Enable CPU*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*enable CPU IO Wrapper*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2},/* Enable CPU*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, BIT7},/*polling FW init ready */	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT6, BIT6},/*polling FW init ready */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8723B_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8723B_power_on_flow[RTL8723B_TRANS_CARDEMU_TO_ACT_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_radio_off_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_card_disable_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_card_enable_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_suspend_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723B_TRANS_CARDEMU_TO_SUS_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_resume_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723B_TRANS_CARDEMU_TO_SUS_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_hwpdn_flow[RTL8723B_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723B_TRANS_CARDEMU_TO_PDN_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_enter_lps_flow[RTL8723B_TRANS_ACT_TO_LPS_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_leave_lps_flow[RTL8723B_TRANS_LPS_TO_ACT_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_enter_swlps_flow[RTL8723B_TRANS_ACT_TO_SWLPS_STEPS+RTL8723B_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723B_leave_swlps_flow[RTL8723B_TRANS_SWLPS_TO_ACT_STEPS+RTL8723B_TRANS_END_STEPS];
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723PwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723PwrSeq.h
new file mode 100644
index 000000000..ab31a7a3f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8723PwrSeq.h
@@ -0,0 +1,170 @@
+#ifndef __HAL8723PWRSEQ_H__
+#define __HAL8723PWRSEQ_H__
+/*
+	Check document WM-20110607-Paul-RTL8723A_Power_Architecture-R02.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#include "HalPwrSeqCmd.h"
+
+#define	RTL8723A_TRANS_CARDEMU_TO_ACT_STEPS	15
+#define	RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8723A_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8723A_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8723A_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8723A_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8723A_TRANS_LPS_TO_ACT_STEPS	15
+#define	RTL8723A_TRANS_END_STEPS	1
+
+
+#define RTL8723A_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
+	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3), 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/	\
+	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 1},/*0x4C[23] = 0x4E[7] = 1, switch DPDT_SEL_P output from WL BB */\
+
+#define RTL8723A_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/   \
+
+
+#define RTL8723A_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8723A_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8723A_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
+	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8723A_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/
+
+
+#define RTL8723A_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8723A_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8723A_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8723A_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8723A_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8723A_power_on_flow[RTL8723A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_radio_off_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_card_disable_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_card_enable_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_suspend_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_resume_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_hwpdn_flow[RTL8723A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8723A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_enter_lps_flow[RTL8723A_TRANS_ACT_TO_LPS_STEPS+RTL8723A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8723A_leave_lps_flow[RTL8723A_TRANS_LPS_TO_ACT_STEPS+RTL8723A_TRANS_END_STEPS];
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyCfg.h
new file mode 100644
index 000000000..b1c6df8a7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyCfg.h
@@ -0,0 +1,165 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8812PHYCFG_H__
+#define __INC_HAL8812PHYCFG_H__
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*------------------------------Define structure----------------------------*/
+
+
+/* BB/RF related */
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//
+// BB and RF register read/write
+//
+u32	PHY_QueryBBReg8812(	IN	PADAPTER	Adapter,
+								IN	u32			RegAddr,
+								IN	u32			BitMask	);
+void	PHY_SetBBReg8812(	IN	PADAPTER		Adapter,
+								IN	u32			RegAddr,
+								IN	u32			BitMask,
+								IN	u32			Data	);
+u32	PHY_QueryRFReg8812(	IN	PADAPTER	Adapter,
+								IN	u8			eRFPath,
+								IN	u32			RegAddr,
+								IN	u32			BitMask	);
+void	PHY_SetRFReg8812(	IN	PADAPTER		Adapter,
+								IN	u8			eRFPath,
+								IN	u32			RegAddr,
+								IN	u32			BitMask,
+								IN	u32			Data	);
+
+//
+// Initialization related function
+//
+/* MAC/BB/RF HAL config */
+int	PHY_MACConfig8812(IN PADAPTER	Adapter	);
+int	PHY_BBConfig8812(IN PADAPTER	Adapter	);
+void	PHY_BB8812_Config_1T(IN PADAPTER	Adapter );
+int	PHY_RFConfig8812(IN PADAPTER	Adapter	);
+
+/* RF config */
+
+s32
+PHY_SwitchWirelessBand8812(
+	IN PADAPTER		Adapter,
+	IN u8			Band
+);
+
+//
+// BB TX Power R/W
+//
+void	PHY_GetTxPowerLevel8812(	IN PADAPTER	Adapter, OUT s32*	powerlevel	);
+void	PHY_SetTxPowerLevel8812(	IN PADAPTER	Adapter, IN u8	Channel	);
+
+BOOLEAN	PHY_UpdateTxPowerDbm8812( IN PADAPTER	Adapter, IN int	powerInDbm	);
+u8 PHY_GetTxPowerIndex_8812A(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8					Channel
+	);
+
+u32 PHY_GetTxBBSwing_8812A(
+	IN	PADAPTER	Adapter,
+	IN	BAND_TYPE 	Band,
+	IN	u8			RFPath
+	);
+
+VOID
+PHY_SetTxPowerIndex_8812A(
+	IN	PADAPTER			Adapter,
+	IN	u4Byte				PowerIndex,
+	IN	u1Byte				RFPath,
+	IN	u1Byte				Rate
+	);
+
+//
+// Switch bandwidth for 8192S
+//
+VOID
+PHY_SetBWMode8812(
+	IN	PADAPTER			pAdapter,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset
+);
+
+//
+// channel switch related funciton
+//
+VOID
+PHY_SwChnl8812(
+	IN	PADAPTER	Adapter,
+	IN	u8			channel
+);
+
+
+VOID
+PHY_SetSwChnlBWMode8812(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+//
+// BB/MAC/RF other monitor API
+//
+
+VOID
+PHY_SetRFPathSwitch_8812A(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		bMain
+);
+
+/*--------------------------Exported Function prototype---------------------*/
+#endif	// __INC_HAL8192CPHYCFG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyReg.h
new file mode 100644
index 000000000..cfc323294
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PhyReg.h
@@ -0,0 +1,739 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8812PHYREG_H__
+#define __INC_HAL8812PHYREG_H__
+/*--------------------------Define Parameters-------------------------------*/
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+// BB Register Definition
+
+#define rCCAonSec_Jaguar		0x838
+#define rPwed_TH_Jaguar			0x830
+
+// BW and sideband setting
+#define rBWIndication_Jaguar		0x834
+#define rL1PeakTH_Jaguar			0x848
+#define rFPGA0_XA_LSSIReadBack	0x8a0	/*Tranceiver LSSI Readback*/
+#define rRFMOD_Jaguar			0x8ac	//RF mode
+#define rADC_Buf_Clk_Jaguar		0x8c4
+#define rRFECTRL_Jaguar			0x900
+#define bRFMOD_Jaguar			0xc3
+#define rCCK_System_Jaguar		0xa00   // for cck sideband
+#define bCCK_System_Jaguar		0x10
+
+// Block & Path enable
+#define rOFDMCCKEN_Jaguar 		0x808 // OFDM/CCK block enable
+#define bOFDMEN_Jaguar			0x20000000
+#define bCCKEN_Jaguar			0x10000000
+#define rRxPath_Jaguar			0x808	// Rx antenna
+#define bRxPath_Jaguar			0xff
+#define rTxPath_Jaguar			0x80c	// Tx antenna
+#define bTxPath_Jaguar			0x0fffffff
+#define rCCK_RX_Jaguar			0xa04	// for cck rx path selection
+#define bCCK_RX_Jaguar			0x0c000000
+#define rVhtlen_Use_Lsig_Jaguar	0x8c3	// Use LSIG for VHT length
+
+// RF read/write-related
+#define rHSSIRead_Jaguar			0x8b0  // RF read addr
+#define bHSSIRead_addr_Jaguar		0xff
+#define bHSSIRead_trigger_Jaguar	0x100
+#define rA_PIRead_Jaguar			0xd04 // RF readback with PI
+#define rB_PIRead_Jaguar			0xd44 // RF readback with PI
+#define rA_SIRead_Jaguar			0xd08 // RF readback with SI
+#define rB_SIRead_Jaguar			0xd48 // RF readback with SI
+#define rRead_data_Jaguar			0xfffff
+#define rA_LSSIWrite_Jaguar			0xc90 // RF write addr
+#define rB_LSSIWrite_Jaguar			0xe90 // RF write addr
+#define bLSSIWrite_data_Jaguar		0x000fffff
+#define bLSSIWrite_addr_Jaguar		0x0ff00000
+
+
+
+// YN: mask the following register definition temporarily
+#define rFPGA0_XA_RFInterfaceOE			0x860	// RF Channel switch
+#define rFPGA0_XB_RFInterfaceOE			0x864
+
+#define rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define rFPGA0_XCD_RFInterfaceSW		0x874
+
+//#define rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+//#define rFPGA0_XCD_RFParameter		0x87c
+
+//#define rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+//#define rFPGA0_AnalogParameter2		0x884
+//#define rFPGA0_AnalogParameter3		0x888
+//#define rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+//#define rFPGA0_AnalogParameter4		0x88c
+
+
+// CCK TX scaling
+#define rCCK_TxFilter1_Jaguar		0xa20
+#define bCCK_TxFilter1_C0_Jaguar   	0x00ff0000
+#define bCCK_TxFilter1_C1_Jaguar		0xff000000
+#define rCCK_TxFilter2_Jaguar		0xa24
+#define bCCK_TxFilter2_C2_Jaguar		0x000000ff
+#define bCCK_TxFilter2_C3_Jaguar		0x0000ff00
+#define bCCK_TxFilter2_C4_Jaguar		0x00ff0000
+#define bCCK_TxFilter2_C5_Jaguar		0xff000000
+#define rCCK_TxFilter3_Jaguar		0xa28
+#define bCCK_TxFilter3_C6_Jaguar		0x000000ff
+#define bCCK_TxFilter3_C7_Jaguar		0x0000ff00
+
+
+// YN: mask the following register definition temporarily
+//#define rPdp_AntA      					0xb00
+//#define rPdp_AntA_4    				0xb04
+//#define rConfig_Pmpd_AntA 			0xb28
+//#define rConfig_AntA 					0xb68
+//#define rConfig_AntB 					0xb6c
+//#define rPdp_AntB 					0xb70
+//#define rPdp_AntB_4 					0xb74
+//#define rConfig_Pmpd_AntB			0xb98
+//#define rAPK							0xbd8
+
+// RXIQC
+#define rA_RxIQC_AB_Jaguar    	0xc10  //RxIQ imblance matrix coeff. A & B
+#define rA_RxIQC_CD_Jaguar    	0xc14  //RxIQ imblance matrix coeff. C & D
+#define rA_TxScale_Jaguar 		0xc1c  // Pah_A TX scaling factor
+#define rB_TxScale_Jaguar 		0xe1c  // Path_B TX scaling factor
+#define rB_RxIQC_AB_Jaguar    	0xe10  //RxIQ imblance matrix coeff. A & B
+#define rB_RxIQC_CD_Jaguar    	0xe14  //RxIQ imblance matrix coeff. C & D
+#define b_RxIQC_AC_Jaguar		0x02ff  // bit mask for IQC matrix element A & C
+#define b_RxIQC_BD_Jaguar		0x02ff0000 // bit mask for IQC matrix element A & C
+
+
+// DIG-related
+#define rA_IGI_Jaguar				0xc50	// Initial Gain for path-A
+#define rB_IGI_Jaguar				0xe50	// Initial Gain for path-B
+#define rOFDM_FalseAlarm1_Jaguar	0xf48  // counter for break
+#define rOFDM_FalseAlarm2_Jaguar	0xf4c  // counter for spoofing
+#define rCCK_FalseAlarm_Jaguar        	0xa5c // counter for cck false alarm
+#define b_FalseAlarm_Jaguar			0xffff
+#define rCCK_CCA_Jaguar				0xa08	// cca threshold
+#define bCCK_CCA_Jaguar				0x00ff0000
+
+// Tx Power Ttraining-related
+#define rA_TxPwrTraing_Jaguar		0xc54
+#define rB_TxPwrTraing_Jaguar		0xe54
+
+// Report-related
+#define rOFDM_ShortCFOAB_Jaguar	0xf60
+#define rOFDM_LongCFOAB_Jaguar		0xf64
+#define rOFDM_EndCFOAB_Jaguar		0xf70
+#define rOFDM_AGCReport_Jaguar		0xf84
+#define rOFDM_RxSNR_Jaguar			0xf88
+#define rOFDM_RxEVMCSI_Jaguar		0xf8c
+#define rOFDM_SIGReport_Jaguar		0xf90
+
+// Misc functions
+#define rEDCCA_Jaguar				0x8a4 // EDCCA
+#define bEDCCA_Jaguar				0xffff
+#define rAGC_table_Jaguar			0x82c   // AGC tabel select
+#define bAGC_table_Jaguar			0x3
+#define b_sel5g_Jaguar    				0x1000 // sel5g
+#define b_LNA_sw_Jaguar				0x8000 // HW/WS control for LNA
+#define rFc_area_Jaguar				0x860   // fc_area
+#define bFc_area_Jaguar				0x1ffe000
+#define rSingleTone_ContTx_Jaguar	0x914
+
+// RFE
+#define rA_RFE_Pinmux_Jaguar	0xcb0  // Path_A RFE cotrol pinmux
+#define rB_RFE_Pinmux_Jaguar	0xeb0 // Path_B RFE control pinmux
+#define rA_RFE_Inv_Jaguar		0xcb4  // Path_A RFE cotrol
+#define rB_RFE_Inv_Jaguar		0xeb4 // Path_B RFE control
+#define rA_RFE_Jaguar			0xcb8  // Path_A RFE cotrol
+#define rB_RFE_Jaguar			0xeb8 // Path_B RFE control
+#define r_ANTSEL_SW_Jaguar		0x900 // ANTSEL SW Control
+#define bMask_RFEInv_Jaguar		0x3ff00000
+#define bMask_AntselPathFollow_Jaguar 0x00030000
+
+// TX AGC
+#define rTxAGC_A_CCK11_CCK1_JAguar				0xc20
+#define rTxAGC_A_Ofdm18_Ofdm6_JAguar				0xc24
+#define rTxAGC_A_Ofdm54_Ofdm24_JAguar			0xc28
+#define rTxAGC_A_MCS3_MCS0_JAguar					0xc2c
+#define rTxAGC_A_MCS7_MCS4_JAguar					0xc30
+#define rTxAGC_A_MCS11_MCS8_JAguar				0xc34
+#define rTxAGC_A_MCS15_MCS12_JAguar				0xc38
+#define rTxAGC_A_Nss1Index3_Nss1Index0_JAguar	0xc3c
+#define rTxAGC_A_Nss1Index7_Nss1Index4_JAguar	0xc40
+#define rTxAGC_A_Nss2Index1_Nss1Index8_JAguar	0xc44
+#define rTxAGC_A_Nss2Index5_Nss2Index2_JAguar	0xc48
+#define rTxAGC_A_Nss2Index9_Nss2Index6_JAguar	0xc4c
+#define rTxAGC_B_CCK11_CCK1_JAguar				0xe20
+#define rTxAGC_B_Ofdm18_Ofdm6_JAguar				0xe24
+#define rTxAGC_B_Ofdm54_Ofdm24_JAguar			0xe28
+#define rTxAGC_B_MCS3_MCS0_JAguar					0xe2c
+#define rTxAGC_B_MCS7_MCS4_JAguar					0xe30
+#define rTxAGC_B_MCS11_MCS8_JAguar				0xe34
+#define rTxAGC_B_MCS15_MCS12_JAguar				0xe38
+#define rTxAGC_B_Nss1Index3_Nss1Index0_JAguar		0xe3c
+#define rTxAGC_B_Nss1Index7_Nss1Index4_JAguar		0xe40
+#define rTxAGC_B_Nss2Index1_Nss1Index8_JAguar		0xe44
+#define rTxAGC_B_Nss2Index5_Nss2Index2_JAguar		0xe48
+#define rTxAGC_B_Nss2Index9_Nss2Index6_JAguar		0xe4c
+#define bTxAGC_byte0_Jaguar							0xff
+#define bTxAGC_byte1_Jaguar							0xff00
+#define bTxAGC_byte2_Jaguar							0xff0000
+#define bTxAGC_byte3_Jaguar							0xff000000
+
+// IQK YN: temporaily mask this part
+//#define rFPGA0_IQK					0xe28
+//#define rTx_IQK_Tone_A				0xe30
+//#define rRx_IQK_Tone_A				0xe34
+//#define rTx_IQK_PI_A					0xe38
+//#define rRx_IQK_PI_A					0xe3c
+
+//#define rTx_IQK 						0xe40
+//#define rRx_IQK						0xe44
+//#define rIQK_AGC_Pts					0xe48
+//#define rIQK_AGC_Rsp					0xe4c
+//#define rTx_IQK_Tone_B				0xe50
+//#define rRx_IQK_Tone_B				0xe54
+//#define rTx_IQK_PI_B					0xe58
+//#define rRx_IQK_PI_B					0xe5c
+//#define rIQK_AGC_Cont				0xe60
+
+
+// AFE-related
+#define rA_AFEPwr1_Jaguar					0xc60 // dynamic AFE power control
+#define rA_AFEPwr2_Jaguar					0xc64 // dynamic AFE power control
+#define rA_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xc68
+#define rA_Tx_CCKBBON_OFDMRFON_Jaguar	0xc6c
+#define rA_Tx_OFDMBBON_Tx2Rx_Jaguar		0xc70
+#define rA_Tx2Tx_RXCCK_Jaguar				0xc74
+#define rA_Rx_OFDM_WaitRIFS_Jaguar			0xc78
+#define rA_Rx2Rx_BT_Jaguar					0xc7c
+#define rA_sleep_nav_Jaguar 					0xc80
+#define rA_pmpd_Jaguar 						0xc84
+#define rB_AFEPwr1_Jaguar					0xe60 // dynamic AFE power control
+#define rB_AFEPwr2_Jaguar					0xe64 // dynamic AFE power control
+#define rB_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xe68
+#define rB_Tx_CCKBBON_OFDMRFON_Jaguar	0xe6c
+#define rB_Tx_OFDMBBON_Tx2Rx_Jaguar		0xe70
+#define rB_Tx2Tx_RXCCK_Jaguar				0xe74
+#define rB_Rx_OFDM_WaitRIFS_Jaguar			0xe78
+#define rB_Rx2Rx_BT_Jaguar					0xe7c
+#define rB_sleep_nav_Jaguar 					0xe80
+#define rB_pmpd_Jaguar 						0xe84
+
+
+// YN: mask these registers temporaily
+//#define rTx_Power_Before_IQK_A		0xe94
+//#define rTx_Power_After_IQK_A			0xe9c
+
+//#define rRx_Power_Before_IQK_A		0xea0
+//#define rRx_Power_Before_IQK_A_2		0xea4
+//#define rRx_Power_After_IQK_A			0xea8
+//#define rRx_Power_After_IQK_A_2		0xeac
+
+//#define rTx_Power_Before_IQK_B		0xeb4
+//#define rTx_Power_After_IQK_B			0xebc
+
+//#define rRx_Power_Before_IQK_B		0xec0
+//#define rRx_Power_Before_IQK_B_2		0xec4
+//#define rRx_Power_After_IQK_B			0xec8
+//#define rRx_Power_After_IQK_B_2		0xecc
+
+
+// RSSI Dump
+#define rA_RSSIDump_Jaguar 			0xBF0
+#define rB_RSSIDump_Jaguar 			0xBF1
+#define rS1_RXevmDump_Jaguar		0xBF4
+#define rS2_RXevmDump_Jaguar 		0xBF5
+#define rA_RXsnrDump_Jaguar		0xBF6
+#define rB_RXsnrDump_Jaguar		0xBF7
+#define rA_CfoShortDump_Jaguar		0xBF8
+#define rB_CfoShortDump_Jaguar		0xBFA
+#define rA_CfoLongDump_Jaguar		0xBEC
+#define rB_CfoLongDump_Jaguar		0xBEE
+
+
+// RF Register
+//
+#define RF_AC_Jaguar				0x00	//
+#define RF_RF_Top_Jaguar			0x07	//
+#define RF_TXLOK_Jaguar				0x08	//
+#define RF_TXAPK_Jaguar				0x0B
+#define RF_CHNLBW_Jaguar 			0x18	// RF channel and BW switch
+#define RF_RCK1_Jaguar				0x1c	//
+#define RF_RCK2_Jaguar				0x1d
+#define RF_RCK3_Jaguar   			0x1e
+#define RF_ModeTableAddr			0x30
+#define RF_ModeTableData0			0x31
+#define RF_ModeTableData1			0x32
+#define RF_TxLCTank_Jaguar          	0x54
+#define RF_APK_Jaguar				0x63
+#define RF_LCK						0xB4
+#define RF_WeLut_Jaguar				0xEF
+
+#define bRF_CHNLBW_MOD_AG_Jaguar	0x70300
+#define bRF_CHNLBW_BW 				0xc00
+
+
+//
+// RL6052 Register definition
+//
+#define RF_AC						0x00	//
+#define RF_IPA_A					0x0C	//
+#define RF_TXBIAS_A					0x0D
+#define RF_BS_PA_APSET_G9_G11		0x0E
+#define RF_MODE1					0x10	//
+#define RF_MODE2					0x11	//
+#define RF_CHNLBW					0x18	// RF channel and BW switch
+#define RF_RCK_OS					0x30	// RF TX PA control
+#define RF_TXPA_G1					0x31	// RF TX PA control
+#define RF_TXPA_G2					0x32	// RF TX PA control
+#define RF_TXPA_G3					0x33	// RF TX PA control
+#define RF_0x52 						0x52
+#define RF_WE_LUT					0xEF
+
+#define RF_TX_GAIN_OFFSET_8812A(_val) ((abs((_val)) << 1) | (((_val) > 0) ? BIT0 : 0))
+#define RF_TX_GAIN_OFFSET_8821A(_val) ((abs((_val)) << 1) | (((_val) > 0) ? BIT0 : 0))
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define bBBResetB					0x100	// Useless now?
+#define bGlobalResetB				0x200
+#define bOFDMTxStart				0x4
+#define bCCKTxStart					0x8
+#define bCRC32Debug					0x100
+#define bPMACLoopback				0x10
+#define bTxLSIG						0xffffff
+#define bOFDMTxRate					0xf
+#define bOFDMTxReserved			0x10
+#define bOFDMTxLength				0x1ffe0
+#define bOFDMTxParity				0x20000
+#define bTxHTSIG1					0xffffff
+#define bTxHTMCSRate				0x7f
+#define bTxHTBW						0x80
+#define bTxHTLength					0xffff00
+#define bTxHTSIG2					0xffffff
+#define bTxHTSmoothing				0x1
+#define bTxHTSounding				0x2
+#define bTxHTReserved				0x4
+#define bTxHTAggreation				0x8
+#define bTxHTSTBC					0x30
+#define bTxHTAdvanceCoding			0x40
+#define bTxHTShortGI					0x80
+#define bTxHTNumberHT_LTF			0x300
+#define bTxHTCRC8					0x3fc00
+#define bCounterReset				0x10000
+#define bNumOfOFDMTx				0xffff
+#define bNumOfCCKTx					0xffff0000
+#define bTxIdleInterval				0xffff
+#define bOFDMService				0xffff0000
+#define bTxMACHeader				0xffffffff
+#define bTxDataInit					0xff
+#define bTxHTMode					0x100
+#define bTxDataType					0x30000
+#define bTxRandomSeed				0xffffffff
+#define bCCKTxPreamble				0x1
+#define bCCKTxSFD					0xffff0000
+#define bCCKTxSIG					0xff
+#define bCCKTxService				0xff00
+#define bCCKLengthExt				0x8000
+#define bCCKTxLength				0xffff0000
+#define bCCKTxCRC16					0xffff
+#define bCCKTxStatus					0x1
+#define bOFDMTxStatus				0x2
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define rPMAC_Reset					0x100
+#define rPMAC_TxStart				0x104
+#define rPMAC_TxLegacySIG			0x108
+#define rPMAC_TxHTSIG1				0x10c
+#define rPMAC_TxHTSIG2				0x110
+#define rPMAC_PHYDebug				0x114
+#define rPMAC_TxPacketNum			0x118
+#define rPMAC_TxIdle					0x11c
+#define rPMAC_TxMACHeader0			0x120
+#define rPMAC_TxMACHeader1			0x124
+#define rPMAC_TxMACHeader2			0x128
+#define rPMAC_TxMACHeader3			0x12c
+#define rPMAC_TxMACHeader4			0x130
+#define rPMAC_TxMACHeader5			0x134
+#define rPMAC_TxDataType			0x138
+#define rPMAC_TxRandomSeed		0x13c
+#define rPMAC_CCKPLCPPreamble		0x140
+#define rPMAC_CCKPLCPHeader		0x144
+#define rPMAC_CCKCRC16				0x148
+#define rPMAC_OFDMRxCRC32OK		0x170
+#define rPMAC_OFDMRxCRC32Er		0x174
+#define rPMAC_OFDMRxParityEr		0x178
+#define rPMAC_OFDMRxCRC8Er			0x17c
+#define rPMAC_CCKCRxRC16Er			0x180
+#define rPMAC_CCKCRxRC32Er			0x184
+#define rPMAC_CCKCRxRC32OK			0x188
+#define rPMAC_TxStatus				0x18c
+
+//
+// 3. Page8(0x800)
+//
+#define rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define rFPGA0_TxInfo				0x804	// Status report??
+#define rFPGA0_PSDFunction			0x808
+#define rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define rFPGA0_XA_HSSIParameter1	0x820	// RF 3 wire register
+#define rFPGA0_XA_HSSIParameter2	0x824
+#define rFPGA0_XB_HSSIParameter1	0x828
+#define rFPGA0_XB_HSSIParameter2	0x82c
+
+#define rFPGA0_XAB_SwitchControl	0x858	// RF Channel switch
+#define rFPGA0_XCD_SwitchControl	0x85c
+
+#define rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define rFPGA0_XCD_RFParameter		0x87c
+
+#define rFPGA0_AnalogParameter1	0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define rFPGA0_AnalogParameter2	0x884
+#define rFPGA0_AnalogParameter3	0x888
+#define rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+#define rFPGA0_AnalogParameter4	0x88c
+#define rFPGA0_XB_LSSIReadBack		0x8a4
+#define rFPGA0_XCD_RFPara	0x8b4
+
+//
+// 4. Page9(0x900)
+//
+#define rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define rFPGA1_TxBlock				0x904	// Useless now
+#define rFPGA1_DebugSelect			0x908	// Useless now
+#define rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+
+//
+// PageA(0xA00)
+//
+#define rCCK0_System				0xa00
+#define rCCK0_AFESetting				0xa04	// Disable init gain now // Select RX path by RSSI
+#define	rCCK0_DSPParameter2			0xa1c	//SQ threshold
+#define rCCK0_TxFilter1				0xa20
+#define rCCK0_TxFilter2				0xa24
+#define rCCK0_DebugPort				0xa28	//debug port and Tx filter3
+#define	rCCK0_FalseAlarmReport			0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+
+//
+// PageB(0xB00)
+//
+#define rPdp_AntA      				0xb00
+#define rPdp_AntA_4    				0xb04
+#define rConfig_Pmpd_AntA 			0xb28
+#define rConfig_AntA 					0xb68
+#define rConfig_AntB 					0xb6c
+#define rPdp_AntB 					0xb70
+#define rPdp_AntB_4 					0xb74
+#define rConfig_Pmpd_AntB			0xb98
+#define rAPK							0xbd8
+
+//
+// 6. PageC(0xC00)
+//
+#define rOFDM0_LSTF					0xc00
+
+#define rOFDM0_TRxPathEnable		0xc04
+#define rOFDM0_TRMuxPar			0xc08
+#define rOFDM0_TRSWIsolation		0xc0c
+
+#define rOFDM0_XARxAFE				0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define rOFDM0_XBRxAFE            		0xc18
+#define rOFDM0_XBRxIQImbalance    	0xc1c
+#define rOFDM0_XCRxAFE            		0xc20
+#define rOFDM0_XCRxIQImbalance    	0xc24
+#define rOFDM0_XDRxAFE            		0xc28
+#define rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define rOFDM0_CFOandDAGC			0xc44  //CFO & DAGC
+#define rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define rOFDM0_XAAGCCore1			0xc50	// DIG
+#define rOFDM0_XAAGCCore2			0xc54
+#define rOFDM0_XBAGCCore1			0xc58
+#define rOFDM0_XBAGCCore2			0xc5c
+#define rOFDM0_XCAGCCore1			0xc60
+#define rOFDM0_XCAGCCore2			0xc64
+#define rOFDM0_XDAGCCore1			0xc68
+#define rOFDM0_XDAGCCore2			0xc6c
+
+#define rOFDM0_AGCParameter1		0xc70
+#define rOFDM0_AGCParameter2		0xc74
+#define rOFDM0_AGCRSSITable		0xc78
+#define rOFDM0_HTSTFAGC			0xc7c
+
+#define rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define rOFDM0_XATxAFE				0xc84
+#define rOFDM0_XBTxIQImbalance		0xc88
+#define rOFDM0_XBTxAFE				0xc8c
+#define rOFDM0_XCTxIQImbalance		0xc90
+#define rOFDM0_XCTxAFE            		0xc94
+#define rOFDM0_XDTxIQImbalance		0xc98
+#define rOFDM0_XDTxAFE				0xc9c
+
+#define rOFDM0_RxIQExtAnta			0xca0
+#define rOFDM0_TxCoeff1				0xca4
+#define rOFDM0_TxCoeff2				0xca8
+#define rOFDM0_TxCoeff3				0xcac
+#define rOFDM0_TxCoeff4				0xcb0
+#define rOFDM0_TxCoeff5				0xcb4
+#define rOFDM0_TxCoeff6				0xcb8
+#define rOFDM0_RxHPParameter		0xce0
+#define rOFDM0_TxPseudoNoiseWgt	0xce4
+#define rOFDM0_FrameSync			0xcf0
+#define rOFDM0_DFSReport			0xcf4
+
+//
+// 7. PageD(0xD00)
+//
+#define rOFDM1_LSTF					0xd00
+#define rOFDM1_TRxPathEnable		0xd04
+
+//
+// 8. PageE(0xE00)
+//
+#define rTxAGC_A_Rate18_06			0xe00
+#define rTxAGC_A_Rate54_24			0xe04
+#define rTxAGC_A_CCK1_Mcs32		0xe08
+#define rTxAGC_A_Mcs03_Mcs00		0xe10
+#define rTxAGC_A_Mcs07_Mcs04		0xe14
+#define rTxAGC_A_Mcs11_Mcs08		0xe18
+#define rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+#define rTxAGC_B_Rate18_06			0x830
+#define rTxAGC_B_Rate54_24			0x834
+#define rTxAGC_B_CCK1_55_Mcs32	0x838
+#define rTxAGC_B_Mcs03_Mcs00		0x83c
+#define rTxAGC_B_Mcs07_Mcs04		0x848
+#define rTxAGC_B_Mcs11_Mcs08		0x84c
+#define rTxAGC_B_Mcs15_Mcs12		0x868
+#define rTxAGC_B_CCK11_A_CCK2_11	0x86c
+
+#define rFPGA0_IQK					0xe28
+#define rTx_IQK_Tone_A				0xe30
+#define rRx_IQK_Tone_A				0xe34
+#define rTx_IQK_PI_A				0xe38
+#define rRx_IQK_PI_A				0xe3c
+
+#define rTx_IQK 						0xe40
+#define rRx_IQK						0xe44
+#define rIQK_AGC_Pts					0xe48
+#define rIQK_AGC_Rsp				0xe4c
+#define rTx_IQK_Tone_B				0xe50
+#define rRx_IQK_Tone_B				0xe54
+#define rTx_IQK_PI_B					0xe58
+#define rRx_IQK_PI_B					0xe5c
+#define rIQK_AGC_Cont				0xe60
+
+#define rBlue_Tooth					0xe6c
+#define rRx_Wait_CCA				0xe70
+#define rTx_CCK_RFON				0xe74
+#define rTx_CCK_BBON				0xe78
+#define rTx_OFDM_RFON				0xe7c
+#define rTx_OFDM_BBON				0xe80
+#define rTx_To_Rx					0xe84
+#define rTx_To_Tx					0xe88
+#define rRx_CCK						0xe8c
+
+#define rTx_Power_Before_IQK_A		0xe94
+#define rTx_Power_After_IQK_A		0xe9c
+
+#define rRx_Power_Before_IQK_A		0xea0
+#define rRx_Power_Before_IQK_A_2	0xea4
+#define rRx_Power_After_IQK_A		0xea8
+#define rRx_Power_After_IQK_A_2		0xeac
+
+#define rTx_Power_Before_IQK_B		0xeb4
+#define rTx_Power_After_IQK_B		0xebc
+
+#define rRx_Power_Before_IQK_B		0xec0
+#define rRx_Power_Before_IQK_B_2	0xec4
+#define rRx_Power_After_IQK_B		0xec8
+#define rRx_Power_After_IQK_B_2		0xecc
+
+#define rRx_OFDM					0xed0
+#define rRx_Wait_RIFS 				0xed4
+#define rRx_TO_Rx 					0xed8
+#define rStandby 						0xedc
+#define rSleep 						0xee0
+#define rPMPD_ANAEN				0xeec
+
+
+// 2. Page8(0x800)
+#define bRFMOD						0x1	// Reg 0x800 rFPGA0_RFMOD
+#define bJapanMode					0x2
+#define bCCKTxSC					0x30
+#define bCCKEn						0x1000000
+#define bOFDMEn						0x2000000
+#define bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define bXCTxAGC                  			0xf000
+#define bXDTxAGC                  			0xf0000
+
+// 4. PageA(0xA00)
+#define bCCKBBMode                			0x3	// Useless
+#define bCCKTxPowerSaving         		0x80
+#define bCCKRxPowerSaving         		0x40
+
+#define bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define bCCKScramble              		0x8	// Useless
+#define bCCKAntDiversity    		      	0x8000
+#define bCCKCarrierRecovery   	    	0x4000
+#define bCCKTxRate           		     	0x3000
+#define bCCKDCCancel             	 		0x0800
+#define bCCKISICancel             			0x0400
+#define bCCKMatchFilter           		0x0200
+#define bCCKEqualizer             			0x0100
+#define bCCKPreambleDetect       	 	0x800000
+#define bCCKFastFalseCCA          		0x400000
+#define bCCKChEstStart            		0x300000
+#define bCCKCCACount              		0x080000
+#define bCCKcs_lim                			0x070000
+#define bCCKBistMode              			0x80000000
+#define bCCKCCAMask             	  		0x40000000
+#define bCCKTxDACPhase         	   	0x4
+#define bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define bCCKr_cp_mode0         	   	0x0100
+#define bCCKTxDCOffset           	 	0xf0
+#define bCCKRxDCOffset           	 	0xf
+#define bCCKCCAMode              	 		0xc000
+#define bCCKFalseCS_lim           		0x3f00
+#define bCCKCS_ratio              			0xc00000
+#define bCCKCorgBit_sel           		0x300000
+#define bCCKPD_lim                			0x0f0000
+#define bCCKNewCCA                		0x80000000
+#define bCCKRxHPofIG              		0x8000
+#define bCCKRxIG                  			0x7f00
+#define bCCKLNAPolarity           		0x800000
+#define bCCKRx1stGain             		0x7f0000
+#define bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define bCCKRxAGCSatLevel        	 	0x1f000000
+#define bCCKRxAGCSatCount       	  	0xe0
+#define bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define bCCKAntennaPolarity      	 	0x2000
+#define bCCKTxFilterType          		0x0c00
+#define bCCKRxAGCReportType   	   	0x0300
+#define bCCKRxDAGCEn              		0x80000000
+#define bCCKRxDAGCPeriod        	  	0x20000000
+#define bCCKRxDAGCSatLevel     	   	0x1f000000
+#define bCCKTimingRecovery       	 	0x800000
+#define bCCKTxC0                  			0x3f0000
+#define bCCKTxC1                  			0x3f000000
+#define bCCKTxC2                  			0x3f
+#define bCCKTxC3                  			0x3f00
+#define bCCKTxC4                  			0x3f0000
+#define bCCKTxC5                  			0x3f000000
+#define bCCKTxC6                  			0x3f
+#define bCCKTxC7                  			0x3f00
+#define bCCKDebugPort             		0xff0000
+#define bCCKDACDebug              		0x0f000000
+#define bCCKFalseAlarmEnable      		0x8000
+#define bCCKFalseAlarmRead        		0x4000
+#define bCCKTRSSI                 			0x7f
+#define bCCKRxAGCReport           		0xfe
+#define bCCKRxReport_AntSel       		0x80000000
+#define bCCKRxReport_MFOff        		0x40000000
+#define bCCKRxRxReport_SQLoss     	0x20000000
+#define bCCKRxReport_Pktloss      		0x10000000
+#define bCCKRxReport_Lockedbit    	0x08000000
+#define bCCKRxReport_RateError    	0x04000000
+#define bCCKRxReport_RxRate       		0x03000000
+#define bCCKRxFACounterLower      	0xff
+#define bCCKRxFACounterUpper      	0xff000000
+#define bCCKRxHPAGCStart          		0xe000
+#define bCCKRxHPAGCFinal          		0x1c00
+#define bCCKRxFalseAlarmEnable    	0x8000
+#define bCCKFACounterFreeze       		0x4000
+#define bCCKTxPathSel             		0x10000000
+#define bCCKDefaultRxPath         		0xc000000
+#define bCCKOptionRxPath          		0x3000000
+
+// 6. PageE(0xE00)
+#define bSTBCEn                  			0x4	// Useless
+#define bAntennaMapping          		0x10
+#define bNss                     				0x20
+#define bCFOAntSumD              		0x200
+#define bPHYCounterReset         		0x8000000
+#define bCFOReportGet            			0x4000000
+#define bOFDMContinueTx          		0x10000000
+#define bOFDMSingleCarrier       		0x20000000
+#define bOFDMSingleTone          		0x40000000
+
+
+//
+// Other Definition
+//
+
+#define bEnable                   0x1	// Useless
+#define bDisable                  0x0
+
+//byte endable for srwrite
+#define bByte0                    		0x1	// Useless
+#define bByte1                    		0x2
+#define bByte2                    		0x4
+#define bByte3                    		0x8
+#define bWord0                    		0x3
+#define bWord1                    		0xc
+#define bDWord                    		0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define bMaskByte0                		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define bMaskByte1                		0xff00
+#define bMaskByte2                		0xff0000
+#define bMaskByte3                		0xff000000
+#define bMaskHWord                	0xffff0000
+#define bMaskLWord                		0x0000ffff
+#define bMaskDWord                	0xffffffff
+#define bMaskH3Bytes				0xffffff00
+#define bMask12Bits				0xfff
+#define bMaskH4Bits				0xf0000000
+#define bMaskOFDM_D			0xffc00000
+#define bMaskCCK				0x3f3f3f3f
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PwrSeq.h
new file mode 100644
index 000000000..de8c795e4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8812PwrSeq.h
@@ -0,0 +1,210 @@
+
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL8812PWRSEQ_H__
+#define __HAL8812PWRSEQ_H__
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WB-110628-DZ-RTL8195 (Jaguar) Power Architecture-R04.pdf
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8812_TRANS_CARDEMU_TO_ACT_STEPS	15
+#define	RTL8812_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8812_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8812_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8812_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8812_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8812_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8812_TRANS_LPS_TO_ACT_STEPS	15
+#define	RTL8812_TRANS_END_STEPS	1
+
+
+#define RTL8812_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	/*{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0}, disable HWPDN 0x04[15]=0*/ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/
+
+#define RTL8812_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
+	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
+	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},//0x1F[7:0] = 0 turn off RF*/	\
+	/*{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},//0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x2A}, /* 0x07[7:0] = 0x28 sps pwm mode 0x2a for BT coex*/	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	/*{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0|BIT1, 0}, //  0x02[1:0] = 0	reset BB */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/
+
+#define RTL8812_TRANS_CARDEMU_TO_SUS													\
+	/* format */								\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xcc},\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xEC},\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
+	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
+	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* suspend option all off */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, BIT7},/*0x14[7] = 1 turn on ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, BIT0},/* 0x15[0] =1 trun on ZCD */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 2b'11 enable WL suspend for PCIe*/
+
+#define RTL8812_TRANS_SUS_TO_CARDEMU													\
+	/* format */								\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 2b'01enable WL suspend*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO sleep mode leave */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, 0},/* 0x15[0] =0 trun off ZCD */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, 0},/*0x14[7] = 0 turn off ZCD */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */
+
+#define RTL8812_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	/**{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, //0x194[0]=0 , disable 32K clock*/	\
+	/**{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x94}, //0x93=0x94 , 90[30] =0 enable 500k ANA clock .switch clock from 12M to 500K , 90 [26] =0 disable EEprom loader clock*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0}, /*0x03[2] = 0, reset 8051*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x05}, /*0x80=05h if reload fw, fill the default value of host_CPU handshake field*/	\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xcc},\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xEC},\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
+	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
+	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, BIT7},/*0x14[7] = 1 turn on ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, BIT0},/* 0x15[0] =1 trun on ZCD */	\
+	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, 0},/*0x12[0] = 0 force PFM mode */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /*0x01f[1]=0 , disable RFC_0  control  REG_RF_CTRL_8812 */	\
+	{0x0076, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /*0x076[1]=0 , disable RFC_1  control REG_OPT_CTRL_8812 +2 */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 2b'01 enable WL suspend*/
+
+#define RTL8812_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/                       \
+	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*0x12[0] = 1 force PWM mode */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, 0},/*0x14[7] = 0 turn off ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, 0},/* 0x15[0] =0 trun off ZCD */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO leave sleep mode */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0}, /*0x04[10] = 0, enable SW LPS PCIE only*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 2b'01enable WL suspend*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x03[2] = 1, enable 8051*/	\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/
+
+
+#define RTL8812_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8812_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8812_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/		\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
+	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated,and RF closed*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/			\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/		\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/
+
+
+#define RTL8812_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/	\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/	\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/	\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/			\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/					\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8812_TRANS_END																\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/		\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8812_power_on_flow[RTL8812_TRANS_CARDEMU_TO_ACT_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_radio_off_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_card_disable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_card_enable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_suspend_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_SUS_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_resume_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_SUS_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_hwpdn_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_enter_lps_flow[RTL8812_TRANS_ACT_TO_LPS_STEPS+RTL8812_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8812_leave_lps_flow[RTL8812_TRANS_LPS_TO_ACT_STEPS+RTL8812_TRANS_END_STEPS];
+
+#endif //__HAL8812PWRSEQ_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyCfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyCfg.h
new file mode 100644
index 000000000..f94719719
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyCfg.h
@@ -0,0 +1,282 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8814PHYCFG_H__
+#define __INC_HAL8814PHYCFG_H__
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+
+#ifdef CONFIG_PCI_HCI
+#define MAX_AGGR_NUM	0x0B
+#else
+#define MAX_AGGR_NUM	0x07
+#endif // CONFIG_PCI_HCI
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*------------------------------Define structure----------------------------*/
+
+
+/* BB/RF related */
+
+#define	SIC_ENABLE				0
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//1. BB register R/W API
+
+extern	u32
+PHY_QueryBBReg8814A(	IN	PADAPTER	Adapter,
+								IN	u32		RegAddr,
+								IN	u32		BitMask	);
+
+
+VOID
+PHY_SetBBReg8814A(	IN	PADAPTER	Adapter,
+								IN	u32		RegAddr,
+								IN	u32		BitMask,
+								IN	u32		Data	);
+
+
+extern	u32
+PHY_QueryRFReg8814A(	IN	PADAPTER			Adapter,
+								IN	u8			eRFPath,
+								IN	u32			RegAddr,
+								IN	u32			BitMask	);
+
+
+void
+PHY_SetRFReg8814A(	IN	PADAPTER			Adapter,
+								IN	u8			eRFPath,
+								IN	u32				RegAddr,
+								IN	u32				BitMask,
+								IN	u32				Data	);
+
+//1 3. Initial BB/RF config by reading MAC/BB/RF txt.
+s32
+phy_BB8814A_Config_ParaFile(
+	IN	PADAPTER	Adapter
+	);
+
+
+RT_STATUS
+PHY_BBConfigMP_8814A(
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+PHY_ConfigBB_8814A(
+	IN	PADAPTER	Adapter
+	);
+
+
+VOID
+phy_ADC_CLK_8814A(
+	IN	PADAPTER	Adapter
+	);
+
+s32
+PHY_RFConfig8814A(
+	IN	PADAPTER	Adapter
+	);
+
+//
+// RF Power setting
+//
+//BOOLEAN	PHY_SetRFPowerState8814A(PADAPTER Adapter, rt_rf_power_state	eRFPowerState);
+
+//1 5. Tx  Power setting API
+
+VOID
+PHY_GetTxPowerLevel8814(
+	IN	PADAPTER		Adapter,
+	OUT ps4Byte			powerlevel
+	);
+
+VOID
+PHY_SetTxPowerLevel8814(
+	IN	PADAPTER		Adapter,
+	IN	u8			Channel
+	);
+
+u8
+PHY_GetTxPowerIndex_8814A(
+	IN	PADAPTER			Adapter,
+	IN  u8  				RFPath,
+	IN	u8				Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8				Channel
+	);
+
+VOID
+PHY_SetTxPowerIndex_8814A(
+	IN	PADAPTER			Adapter,
+	IN	u32				PowerIndex,
+	IN	u8				RFPath,
+	IN	u8				Rate
+	);
+
+
+BOOLEAN
+PHY_UpdateTxPowerDbm8814A(
+	IN	PADAPTER	Adapter,
+	IN	s4Byte		powerInDbm
+	);
+
+
+u32
+PHY_GetTxBBSwing_8814A(
+	IN	PADAPTER	Adapter,
+	IN	BAND_TYPE 	Band,
+	IN 	u8 		RFPath
+	);
+
+
+
+//1 6. Channel setting API
+
+VOID
+PHY_SwChnlTimerCallback8814A(
+	IN	PRT_TIMER		pTimer
+	);
+
+VOID
+PHY_SwChnlWorkItemCallback8814A(
+	IN PVOID            pContext
+	);
+
+
+VOID
+HAL_HandleSwChnl8814A(
+	IN	PADAPTER	pAdapter,
+	IN	u8		channel
+	);
+
+VOID
+PHY_SwChnlSynchronously8814A(	IN	PADAPTER		pAdapter,
+										IN	u8			channel	);
+
+VOID
+PHY_SwChnlAndSetBWModeCallback8814A(IN PVOID            pContext);
+
+
+VOID
+PHY_HandleSwChnlAndSetBW8814A(
+	IN	PADAPTER			Adapter,
+	IN	BOOLEAN				bSwitchChannel,
+	IN	BOOLEAN				bSetBandWidth,
+	IN	u8					ChannelNum,
+	IN	CHANNEL_WIDTH		ChnlWidth,
+	IN	u8					ChnlOffsetOf40MHz,
+	IN	u8					ChnlOffsetOf80MHz,
+	IN	u8					CenterFrequencyIndex1
+);
+
+
+BOOLEAN
+PHY_QueryRFPathSwitch_8814A(	IN	PADAPTER	pAdapter);
+
+
+
+//VOID PHY_SetMonitorMode8814A(PADAPTER pAdapter, BOOLEAN bEnableMonitorMode);
+
+
+#if (USE_WORKITEM)
+VOID
+RtCheckForHangWorkItemCallback8814A(
+                IN PVOID   pContext
+);
+#endif
+
+BOOLEAN
+SetAntennaConfig8814A(
+	IN	PADAPTER	Adapter,
+	IN	u8		DefaultAnt
+	);
+
+VOID
+PHY_SetRFEReg8814A(
+	IN PADAPTER		Adapter,
+	IN BOOLEAN		bInit,
+	IN u8		Band
+	);
+
+
+s32
+PHY_SwitchWirelessBand8814A(
+	IN PADAPTER		 Adapter,
+	IN u8		Band
+);
+
+VOID
+PHY_SetIO_8814A(
+    PADAPTER		pAdapter
+    );
+
+VOID
+PHY_SetBWMode8814(
+	IN	PADAPTER			Adapter,
+	IN	CHANNEL_WIDTH	Bandwidth,	// 20M or 40M
+	IN	u8					Offset		// Upper, Lower, or Don't care
+);
+
+VOID
+PHY_SwChnl8814(
+	IN	PADAPTER	Adapter,
+	IN	u8			channel
+	);
+
+VOID
+PHY_SetSwChnlBWMode8814(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+s32 PHY_MACConfig8814(PADAPTER Adapter);
+int PHY_BBConfig8814(PADAPTER	Adapter);
+VOID PHY_Set_SecCCATH_by_RXANT_8814A(PADAPTER	pAdapter, u4Byte ulAntennaRx);
+
+
+
+/*--------------------------Exported Function prototype---------------------*/
+
+/*--------------------------Exported Function prototype---------------------*/
+#endif	// __INC_HAL8192CPHYCFG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyReg.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyReg.h
new file mode 100644
index 000000000..7c6a1d417
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PhyReg.h
@@ -0,0 +1,867 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8814PHYREG_H__
+#define __INC_HAL8814PHYREG_H__
+/*--------------------------Define Parameters-------------------------------*/
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+/* BB Register Definition */
+
+#define rCCAonSec_Jaguar		0x838
+#define rPwed_TH_Jaguar			0x830
+#define rL1_Weight_Jaguar		0x840
+
+// BW and sideband setting
+#define rBWIndication_Jaguar		0x834
+#define rL1PeakTH_Jaguar		0x848
+#define rRFMOD_Jaguar			0x8ac	//RF mode
+#define rADC_Buf_Clk_Jaguar		0x8c4
+#define	rADC_Buf_40_Clk_Jaguar2		0x8c8
+#define rRFECTRL_Jaguar			0x900
+#define bRFMOD_Jaguar			0xc3
+#define rCCK_System_Jaguar		0xa00   // for cck sideband
+#define bCCK_System_Jaguar		0x10
+
+// Block & Path enable
+#define rOFDMCCKEN_Jaguar 		0x808 // OFDM/CCK block enable
+#define bOFDMEN_Jaguar			0x20000000
+#define bCCKEN_Jaguar			0x10000000
+#define rRxPath_Jaguar			0x808	// Rx antenna
+#define bRxPath_Jaguar			0xff
+#define rTxPath_Jaguar			0x80c	// Tx antenna
+#define bTxPath_Jaguar			0x0fffffff
+#define rCCK_RX_Jaguar			0xa04	// for cck rx path selection
+#define bCCK_RX_Jaguar			0x0c000000
+#define rVhtlen_Use_Lsig_Jaguar	0x8c3	// Use LSIG for VHT length
+
+#define	rRxPath_Jaguar2				0xa04	// Rx antenna
+#define	rTxAnt_1Nsts_Jaguar2		0x93c	// Tx antenna for 1Nsts
+#define	rTxAnt_23Nsts_Jaguar2		0x940	// Tx antenna for 2Nsts and 3Nsts
+
+
+// RF read/write-related
+#define rHSSIRead_Jaguar			0x8b0  // RF read addr
+#define bHSSIRead_addr_Jaguar		0xff
+#define bHSSIRead_trigger_Jaguar	0x100
+#define rA_PIRead_Jaguar			0xd04 // RF readback with PI
+#define rB_PIRead_Jaguar			0xd44 // RF readback with PI
+#define rA_SIRead_Jaguar			0xd08 // RF readback with SI
+#define rB_SIRead_Jaguar			0xd48 // RF readback with SI
+#define rRead_data_Jaguar			0xfffff
+#define rA_LSSIWrite_Jaguar			0xc90 // RF write addr
+#define rB_LSSIWrite_Jaguar			0xe90 // RF write addr
+#define bLSSIWrite_data_Jaguar		0x000fffff
+#define bLSSIWrite_addr_Jaguar		0x0ff00000
+
+#define	rC_PIRead_Jaguar2			0xd84 // RF readback with PI
+#define	rD_PIRead_Jaguar2			0xdC4 // RF readback with PI
+#define	rC_SIRead_Jaguar2			0xd88 // RF readback with SI
+#define	rD_SIRead_Jaguar2			0xdC8 // RF readback with SI
+#define	rC_LSSIWrite_Jaguar2		0x1890 // RF write addr
+#define	rD_LSSIWrite_Jaguar2		0x1A90 // RF write addr
+
+
+// YN: mask the following register definition temporarily
+#define rFPGA0_XA_RFInterfaceOE			0x860	// RF Channel switch
+#define rFPGA0_XB_RFInterfaceOE			0x864
+
+#define rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define rFPGA0_XCD_RFInterfaceSW		0x874
+
+//#define rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+//#define rFPGA0_XCD_RFParameter		0x87c
+
+//#define rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+//#define rFPGA0_AnalogParameter2		0x884
+//#define rFPGA0_AnalogParameter3		0x888
+//#define rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+//#define rFPGA0_AnalogParameter4		0x88c
+
+
+// CCK TX scaling
+#define rCCK_TxFilter1_Jaguar		0xa20
+#define bCCK_TxFilter1_C0_Jaguar   	0x00ff0000
+#define bCCK_TxFilter1_C1_Jaguar		0xff000000
+#define rCCK_TxFilter2_Jaguar		0xa24
+#define bCCK_TxFilter2_C2_Jaguar		0x000000ff
+#define bCCK_TxFilter2_C3_Jaguar		0x0000ff00
+#define bCCK_TxFilter2_C4_Jaguar		0x00ff0000
+#define bCCK_TxFilter2_C5_Jaguar		0xff000000
+#define rCCK_TxFilter3_Jaguar		0xa28
+#define bCCK_TxFilter3_C6_Jaguar		0x000000ff
+#define bCCK_TxFilter3_C7_Jaguar		0x0000ff00
+/* NBI & CSI Mask setting */
+#define	rCSI_Mask_Setting1_Jaguar	0x874
+#define	rCSI_Fix_Mask0_Jaguar		0x880
+#define	rCSI_Fix_Mask1_Jaguar		0x884
+#define	rCSI_Fix_Mask2_Jaguar		0x888
+#define	rCSI_Fix_Mask3_Jaguar		0x88c
+#define	rCSI_Fix_Mask4_Jaguar		0x890
+#define	rCSI_Fix_Mask5_Jaguar		0x894
+#define	rCSI_Fix_Mask6_Jaguar		0x898
+#define	rCSI_Fix_Mask7_Jaguar		0x89c
+#define	rNBI_Setting_Jaguar			0x87c
+
+
+// YN: mask the following register definition temporarily
+//#define rPdp_AntA      					0xb00
+//#define rPdp_AntA_4    				0xb04
+//#define rConfig_Pmpd_AntA 			0xb28
+//#define rConfig_AntA 					0xb68
+//#define rConfig_AntB 					0xb6c
+//#define rPdp_AntB 					0xb70
+//#define rPdp_AntB_4 					0xb74
+//#define rConfig_Pmpd_AntB			0xb98
+//#define rAPK							0xbd8
+
+// RXIQC
+#define rA_RxIQC_AB_Jaguar    	0xc10  //RxIQ imblance matrix coeff. A & B
+#define rA_RxIQC_CD_Jaguar    	0xc14  //RxIQ imblance matrix coeff. C & D
+#define rA_TxScale_Jaguar 		0xc1c  // Pah_A TX scaling factor
+#define rB_TxScale_Jaguar 		0xe1c  // Path_B TX scaling factor
+#define rB_RxIQC_AB_Jaguar    	0xe10  //RxIQ imblance matrix coeff. A & B
+#define rB_RxIQC_CD_Jaguar    	0xe14  //RxIQ imblance matrix coeff. C & D
+#define b_RxIQC_AC_Jaguar		0x02ff  // bit mask for IQC matrix element A & C
+#define b_RxIQC_BD_Jaguar		0x02ff0000 // bit mask for IQC matrix element A & C
+
+#define	rC_TxScale_Jaguar2 		0x181c  // Pah_C TX scaling factor
+#define	rD_TxScale_Jaguar2 		0x1A1c  // Path_D TX scaling factor
+#define	rRF_TxGainOffset		0x55
+
+// DIG-related
+#define rA_IGI_Jaguar				0xc50	// Initial Gain for path-A
+#define rB_IGI_Jaguar				0xe50	// Initial Gain for path-B
+#define	rC_IGI_Jaguar2				0x1850	// Initial Gain for path-C
+#define	rD_IGI_Jaguar2				0x1A50	// Initial Gain for path-D
+
+#define rOFDM_FalseAlarm1_Jaguar	0xf48  // counter for break
+#define rOFDM_FalseAlarm2_Jaguar	0xf4c  // counter for spoofing
+#define rCCK_FalseAlarm_Jaguar        	0xa5c // counter for cck false alarm
+#define b_FalseAlarm_Jaguar			0xffff
+#define rCCK_CCA_Jaguar				0xa08	// cca threshold
+#define bCCK_CCA_Jaguar				0x00ff0000
+
+// Tx Power Ttraining-related
+#define rA_TxPwrTraing_Jaguar		0xc54
+#define rB_TxPwrTraing_Jaguar		0xe54
+
+// Report-related
+#define rOFDM_ShortCFOAB_Jaguar	0xf60
+#define rOFDM_LongCFOAB_Jaguar		0xf64
+#define rOFDM_EndCFOAB_Jaguar		0xf70
+#define rOFDM_AGCReport_Jaguar		0xf84
+#define rOFDM_RxSNR_Jaguar			0xf88
+#define rOFDM_RxEVMCSI_Jaguar		0xf8c
+#define rOFDM_SIGReport_Jaguar		0xf90
+
+// Misc functions
+#define rEDCCA_Jaguar				0x8a4 // EDCCA
+#define bEDCCA_Jaguar				0xffff
+#define rAGC_table_Jaguar			0x82c   // AGC tabel select
+#define bAGC_table_Jaguar			0x3
+#define b_sel5g_Jaguar    				0x1000 // sel5g
+#define b_LNA_sw_Jaguar				0x8000 // HW/WS control for LNA
+#define rFc_area_Jaguar				0x860   // fc_area
+#define bFc_area_Jaguar				0x1ffe000
+#define rSingleTone_ContTx_Jaguar	0x914
+
+#define	rAGC_table_Jaguar2			0x958	// AGC tabel select
+#define	rDMA_trigger_Jaguar2		0x95C	// ADC sample mode
+
+
+// RFE
+#define rA_RFE_Pinmux_Jaguar	0xcb0  // Path_A RFE cotrol pinmux
+#define rB_RFE_Pinmux_Jaguar	0xeb0 // Path_B RFE control pinmux
+#define rA_RFE_Inv_Jaguar		0xcb4  // Path_A RFE cotrol
+#define rB_RFE_Inv_Jaguar		0xeb4 // Path_B RFE control
+#define rA_RFE_Jaguar			0xcb8  // Path_A RFE cotrol
+#define rB_RFE_Jaguar			0xeb8 // Path_B RFE control
+#define r_ANTSEL_SW_Jaguar		0x900 // ANTSEL SW Control
+#define bMask_RFEInv_Jaguar		0x3ff00000
+#define bMask_AntselPathFollow_Jaguar 0x00030000
+
+#define	rC_RFE_Pinmux_Jaguar	0x18B4	// Path_C RFE cotrol pinmux
+#define	rD_RFE_Pinmux_Jaguar	0x1AB4	// Path_D RFE cotrol pinmux
+#define	rA_RFE_Sel_Jaguar2		0x1990
+
+
+
+// TX AGC
+#define rTxAGC_A_CCK11_CCK1_JAguar				0xc20
+#define rTxAGC_A_Ofdm18_Ofdm6_JAguar				0xc24
+#define rTxAGC_A_Ofdm54_Ofdm24_JAguar			0xc28
+#define rTxAGC_A_MCS3_MCS0_JAguar					0xc2c
+#define rTxAGC_A_MCS7_MCS4_JAguar					0xc30
+#define rTxAGC_A_MCS11_MCS8_JAguar				0xc34
+#define rTxAGC_A_MCS15_MCS12_JAguar				0xc38
+#define rTxAGC_A_Nss1Index3_Nss1Index0_JAguar	0xc3c
+#define rTxAGC_A_Nss1Index7_Nss1Index4_JAguar	0xc40
+#define rTxAGC_A_Nss2Index1_Nss1Index8_JAguar	0xc44
+#define rTxAGC_A_Nss2Index5_Nss2Index2_JAguar	0xc48
+#define rTxAGC_A_Nss2Index9_Nss2Index6_JAguar	0xc4c
+#define rTxAGC_B_CCK11_CCK1_JAguar				0xe20
+#define rTxAGC_B_Ofdm18_Ofdm6_JAguar				0xe24
+#define rTxAGC_B_Ofdm54_Ofdm24_JAguar			0xe28
+#define rTxAGC_B_MCS3_MCS0_JAguar					0xe2c
+#define rTxAGC_B_MCS7_MCS4_JAguar					0xe30
+#define rTxAGC_B_MCS11_MCS8_JAguar				0xe34
+#define rTxAGC_B_MCS15_MCS12_JAguar				0xe38
+#define rTxAGC_B_Nss1Index3_Nss1Index0_JAguar		0xe3c
+#define rTxAGC_B_Nss1Index7_Nss1Index4_JAguar		0xe40
+#define rTxAGC_B_Nss2Index1_Nss1Index8_JAguar		0xe44
+#define rTxAGC_B_Nss2Index5_Nss2Index2_JAguar		0xe48
+#define rTxAGC_B_Nss2Index9_Nss2Index6_JAguar		0xe4c
+#define bTxAGC_byte0_Jaguar							0xff
+#define bTxAGC_byte1_Jaguar							0xff00
+#define bTxAGC_byte2_Jaguar							0xff0000
+#define bTxAGC_byte3_Jaguar							0xff000000
+
+
+// TX AGC
+#define		rTxAGC_A_CCK11_CCK1_Jaguar2	0xc20
+#define		rTxAGC_A_Ofdm18_Ofdm6_Jaguar2	0xc24
+#define		rTxAGC_A_Ofdm54_Ofdm24_Jaguar2	0xc28
+#define		rTxAGC_A_MCS3_MCS0_Jaguar2	0xc2c
+#define		rTxAGC_A_MCS7_MCS4_Jaguar2	0xc30
+#define		rTxAGC_A_MCS11_MCS8_Jaguar2	0xc34
+#define		rTxAGC_A_MCS15_MCS12_Jaguar2	0xc38
+#define		rTxAGC_A_MCS19_MCS16_Jaguar2	0xcd8
+#define		rTxAGC_A_MCS23_MCS20_Jaguar2	0xcdc
+#define		rTxAGC_A_Nss1Index3_Nss1Index0_Jaguar2	0xc3c
+#define		rTxAGC_A_Nss1Index7_Nss1Index4_Jaguar2	0xc40
+#define		rTxAGC_A_Nss2Index1_Nss1Index8_Jaguar2	0xc44
+#define		rTxAGC_A_Nss2Index5_Nss2Index2_Jaguar2	0xc48
+#define		rTxAGC_A_Nss2Index9_Nss2Index6_Jaguar2	0xc4c
+#define		rTxAGC_A_Nss3Index3_Nss3Index0_Jaguar2	0xce0
+#define		rTxAGC_A_Nss3Index7_Nss3Index4_Jaguar2	0xce4
+#define		rTxAGC_A_Nss3Index9_Nss3Index8_Jaguar2	0xce8
+#define		rTxAGC_B_CCK11_CCK1_Jaguar2	0xe20
+#define		rTxAGC_B_Ofdm18_Ofdm6_Jaguar2	0xe24
+#define		rTxAGC_B_Ofdm54_Ofdm24_Jaguar2	0xe28
+#define		rTxAGC_B_MCS3_MCS0_Jaguar2	0xe2c
+#define		rTxAGC_B_MCS7_MCS4_Jaguar2	0xe30
+#define		rTxAGC_B_MCS11_MCS8_Jaguar2	0xe34
+#define		rTxAGC_B_MCS15_MCS12_Jaguar2	0xe38
+#define		rTxAGC_B_MCS19_MCS16_Jaguar2	0xed8
+#define		rTxAGC_B_MCS23_MCS20_Jaguar2	0xedc
+#define		rTxAGC_B_Nss1Index3_Nss1Index0_Jaguar2	0xe3c
+#define		rTxAGC_B_Nss1Index7_Nss1Index4_Jaguar2	0xe40
+#define		rTxAGC_B_Nss2Index1_Nss1Index8_Jaguar2	0xe44
+#define		rTxAGC_B_Nss2Index5_Nss2Index2_Jaguar2	0xe48
+#define		rTxAGC_B_Nss2Index9_Nss2Index6_Jaguar2	0xe4c
+#define		rTxAGC_B_Nss3Index3_Nss3Index0_Jaguar2	0xee0
+#define		rTxAGC_B_Nss3Index7_Nss3Index4_Jaguar2	0xee4
+#define		rTxAGC_B_Nss3Index9_Nss3Index8_Jaguar2	0xee8
+#define		rTxAGC_C_CCK11_CCK1_Jaguar2	0x1820
+#define		rTxAGC_C_Ofdm18_Ofdm6_Jaguar2	0x1824
+#define		rTxAGC_C_Ofdm54_Ofdm24_Jaguar2	0x1828
+#define		rTxAGC_C_MCS3_MCS0_Jaguar2	0x182c
+#define		rTxAGC_C_MCS7_MCS4_Jaguar2	0x1830
+#define		rTxAGC_C_MCS11_MCS8_Jaguar2	0x1834
+#define		rTxAGC_C_MCS15_MCS12_Jaguar2	0x1838
+#define		rTxAGC_C_MCS19_MCS16_Jaguar2	0x18d8
+#define		rTxAGC_C_MCS23_MCS20_Jaguar2	0x18dc
+#define		rTxAGC_C_Nss1Index3_Nss1Index0_Jaguar2	0x183c
+#define		rTxAGC_C_Nss1Index7_Nss1Index4_Jaguar2	0x1840
+#define		rTxAGC_C_Nss2Index1_Nss1Index8_Jaguar2	0x1844
+#define		rTxAGC_C_Nss2Index5_Nss2Index2_Jaguar2	0x1848
+#define		rTxAGC_C_Nss2Index9_Nss2Index6_Jaguar2	0x184c
+#define		rTxAGC_C_Nss3Index3_Nss3Index0_Jaguar2	0x18e0
+#define		rTxAGC_C_Nss3Index7_Nss3Index4_Jaguar2	0x18e4
+#define		rTxAGC_C_Nss3Index9_Nss3Index8_Jaguar2	0x18e8
+#define		rTxAGC_D_CCK11_CCK1_Jaguar2	0x1a20
+#define		rTxAGC_D_Ofdm18_Ofdm6_Jaguar2	0x1a24
+#define		rTxAGC_D_Ofdm54_Ofdm24_Jaguar2	0x1a28
+#define		rTxAGC_D_MCS3_MCS0_Jaguar2	0x1a2c
+#define		rTxAGC_D_MCS7_MCS4_Jaguar2	0x1a30
+#define		rTxAGC_D_MCS11_MCS8_Jaguar2	0x1a34
+#define		rTxAGC_D_MCS15_MCS12_Jaguar2	0x1a38
+#define		rTxAGC_D_MCS19_MCS16_Jaguar2	0x1ad8
+#define		rTxAGC_D_MCS23_MCS20_Jaguar2	0x1adc
+#define		rTxAGC_D_Nss1Index3_Nss1Index0_Jaguar2	0x1a3c
+#define		rTxAGC_D_Nss1Index7_Nss1Index4_Jaguar2	0x1a40
+#define		rTxAGC_D_Nss2Index1_Nss1Index8_Jaguar2	0x1a44
+#define		rTxAGC_D_Nss2Index5_Nss2Index2_Jaguar2	0x1a48
+#define		rTxAGC_D_Nss2Index9_Nss2Index6_Jaguar2	0x1a4c
+#define		rTxAGC_D_Nss3Index3_Nss3Index0_Jaguar2	0x1ae0
+#define		rTxAGC_D_Nss3Index7_Nss3Index4_Jaguar2	0x1ae4
+#define		rTxAGC_D_Nss3Index9_Nss3Index8_Jaguar2	0x1ae8
+// IQK YN: temporaily mask this part
+//#define rFPGA0_IQK					0xe28
+//#define rTx_IQK_Tone_A				0xe30
+//#define rRx_IQK_Tone_A				0xe34
+//#define rTx_IQK_PI_A					0xe38
+//#define rRx_IQK_PI_A					0xe3c
+
+//#define rTx_IQK 						0xe40
+//#define rRx_IQK						0xe44
+//#define rIQK_AGC_Pts					0xe48
+//#define rIQK_AGC_Rsp					0xe4c
+//#define rTx_IQK_Tone_B				0xe50
+//#define rRx_IQK_Tone_B				0xe54
+//#define rTx_IQK_PI_B					0xe58
+//#define rRx_IQK_PI_B					0xe5c
+//#define rIQK_AGC_Cont				0xe60
+
+
+// AFE-related
+#define rA_AFEPwr1_Jaguar					0xc60 // dynamic AFE power control
+#define rA_AFEPwr2_Jaguar					0xc64 // dynamic AFE power control
+#define rA_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xc68
+#define rA_Tx_CCKBBON_OFDMRFON_Jaguar	0xc6c
+#define rA_Tx_OFDMBBON_Tx2Rx_Jaguar		0xc70
+#define rA_Tx2Tx_RXCCK_Jaguar				0xc74
+#define rA_Rx_OFDM_WaitRIFS_Jaguar			0xc78
+#define rA_Rx2Rx_BT_Jaguar					0xc7c
+#define rA_sleep_nav_Jaguar 					0xc80
+#define rA_pmpd_Jaguar 						0xc84
+#define rB_AFEPwr1_Jaguar					0xe60 // dynamic AFE power control
+#define rB_AFEPwr2_Jaguar					0xe64 // dynamic AFE power control
+#define rB_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xe68
+#define rB_Tx_CCKBBON_OFDMRFON_Jaguar	0xe6c
+#define rB_Tx_OFDMBBON_Tx2Rx_Jaguar		0xe70
+#define rB_Tx2Tx_RXCCK_Jaguar				0xe74
+#define rB_Rx_OFDM_WaitRIFS_Jaguar			0xe78
+#define rB_Rx2Rx_BT_Jaguar					0xe7c
+#define rB_sleep_nav_Jaguar 					0xe80
+#define rB_pmpd_Jaguar 						0xe84
+
+
+// YN: mask these registers temporaily
+//#define rTx_Power_Before_IQK_A		0xe94
+//#define rTx_Power_After_IQK_A			0xe9c
+
+//#define rRx_Power_Before_IQK_A		0xea0
+//#define rRx_Power_Before_IQK_A_2		0xea4
+//#define rRx_Power_After_IQK_A			0xea8
+//#define rRx_Power_After_IQK_A_2		0xeac
+
+//#define rTx_Power_Before_IQK_B		0xeb4
+//#define rTx_Power_After_IQK_B			0xebc
+
+//#define rRx_Power_Before_IQK_B		0xec0
+//#define rRx_Power_Before_IQK_B_2		0xec4
+//#define rRx_Power_After_IQK_B			0xec8
+//#define rRx_Power_After_IQK_B_2		0xecc
+
+
+// RSSI Dump
+#define rA_RSSIDump_Jaguar 			0xBF0
+#define rB_RSSIDump_Jaguar 			0xBF1
+#define rS1_RXevmDump_Jaguar		0xBF4
+#define rS2_RXevmDump_Jaguar 		0xBF5
+#define rA_RXsnrDump_Jaguar		0xBF6
+#define rB_RXsnrDump_Jaguar		0xBF7
+#define rA_CfoShortDump_Jaguar		0xBF8
+#define rB_CfoShortDump_Jaguar		0xBFA
+#define rA_CfoLongDump_Jaguar		0xBEC
+#define rB_CfoLongDump_Jaguar		0xBEE
+
+
+// RF Register
+//
+#define RF_AC_Jaguar				0x00	//
+#define RF_RF_Top_Jaguar			0x07	//
+#define RF_TXLOK_Jaguar				0x08	//
+#define RF_TXAPK_Jaguar				0x0B
+#define RF_CHNLBW_Jaguar 			0x18	// RF channel and BW switch
+#define RF_RCK1_Jaguar				0x1c	//
+#define RF_RCK2_Jaguar				0x1d
+#define RF_RCK3_Jaguar   			0x1e
+#define RF_ModeTableAddr			0x30
+#define RF_ModeTableData0			0x31
+#define RF_ModeTableData1			0x32
+#define RF_TxLCTank_Jaguar          	0x54
+#define RF_APK_Jaguar				0x63
+#define RF_LCK						0xB4
+#define RF_WeLut_Jaguar				0xEF
+
+#define bRF_CHNLBW_MOD_AG_Jaguar	0x70300
+#define bRF_CHNLBW_BW 				0xc00
+
+
+//
+// RL6052 Register definition
+//
+#define RF_AC						0x00	//
+#define RF_IPA_A					0x0C	//
+#define RF_TXBIAS_A					0x0D
+#define RF_BS_PA_APSET_G9_G11		0x0E
+#define RF_MODE1					0x10	//
+#define RF_MODE2					0x11	//
+#define RF_CHNLBW					0x18	// RF channel and BW switch
+#define RF_RCK_OS					0x30	// RF TX PA control
+#define RF_TXPA_G1					0x31	// RF TX PA control
+#define RF_TXPA_G2					0x32	// RF TX PA control
+#define RF_TXPA_G3					0x33	// RF TX PA control
+#define RF_0x52 						0x52
+#define RF_WE_LUT					0xEF
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define bBBResetB					0x100	// Useless now?
+#define bGlobalResetB				0x200
+#define bOFDMTxStart				0x4
+#define bCCKTxStart					0x8
+#define bCRC32Debug					0x100
+#define bPMACLoopback				0x10
+#define bTxLSIG						0xffffff
+#define bOFDMTxRate					0xf
+#define bOFDMTxReserved			0x10
+#define bOFDMTxLength				0x1ffe0
+#define bOFDMTxParity				0x20000
+#define bTxHTSIG1					0xffffff
+#define bTxHTMCSRate				0x7f
+#define bTxHTBW						0x80
+#define bTxHTLength					0xffff00
+#define bTxHTSIG2					0xffffff
+#define bTxHTSmoothing				0x1
+#define bTxHTSounding				0x2
+#define bTxHTReserved				0x4
+#define bTxHTAggreation				0x8
+#define bTxHTSTBC					0x30
+#define bTxHTAdvanceCoding			0x40
+#define bTxHTShortGI					0x80
+#define bTxHTNumberHT_LTF			0x300
+#define bTxHTCRC8					0x3fc00
+#define bCounterReset				0x10000
+#define bNumOfOFDMTx				0xffff
+#define bNumOfCCKTx					0xffff0000
+#define bTxIdleInterval				0xffff
+#define bOFDMService				0xffff0000
+#define bTxMACHeader				0xffffffff
+#define bTxDataInit					0xff
+#define bTxHTMode					0x100
+#define bTxDataType					0x30000
+#define bTxRandomSeed				0xffffffff
+#define bCCKTxPreamble				0x1
+#define bCCKTxSFD					0xffff0000
+#define bCCKTxSIG					0xff
+#define bCCKTxService				0xff00
+#define bCCKLengthExt				0x8000
+#define bCCKTxLength				0xffff0000
+#define bCCKTxCRC16					0xffff
+#define bCCKTxStatus					0x1
+#define bOFDMTxStatus				0x2
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define rPMAC_Reset					0x100
+#define rPMAC_TxStart				0x104
+#define rPMAC_TxLegacySIG			0x108
+#define rPMAC_TxHTSIG1				0x10c
+#define rPMAC_TxHTSIG2				0x110
+#define rPMAC_PHYDebug				0x114
+#define rPMAC_TxPacketNum			0x118
+#define rPMAC_TxIdle					0x11c
+#define rPMAC_TxMACHeader0			0x120
+#define rPMAC_TxMACHeader1			0x124
+#define rPMAC_TxMACHeader2			0x128
+#define rPMAC_TxMACHeader3			0x12c
+#define rPMAC_TxMACHeader4			0x130
+#define rPMAC_TxMACHeader5			0x134
+#define rPMAC_TxDataType			0x138
+#define rPMAC_TxRandomSeed		0x13c
+#define rPMAC_CCKPLCPPreamble		0x140
+#define rPMAC_CCKPLCPHeader		0x144
+#define rPMAC_CCKCRC16				0x148
+#define rPMAC_OFDMRxCRC32OK		0x170
+#define rPMAC_OFDMRxCRC32Er		0x174
+#define rPMAC_OFDMRxParityEr		0x178
+#define rPMAC_OFDMRxCRC8Er			0x17c
+#define rPMAC_CCKCRxRC16Er			0x180
+#define rPMAC_CCKCRxRC32Er			0x184
+#define rPMAC_CCKCRxRC32OK			0x188
+#define rPMAC_TxStatus				0x18c
+
+//
+// 3. Page8(0x800)
+//
+#define rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define rFPGA0_TxInfo				0x804	// Status report??
+#define rFPGA0_PSDFunction			0x808
+#define rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define rFPGA0_XA_HSSIParameter1	0x820	// RF 3 wire register
+#define rFPGA0_XA_HSSIParameter2	0x824
+#define rFPGA0_XB_HSSIParameter1	0x828
+#define rFPGA0_XB_HSSIParameter2	0x82c
+
+#define	rFPGA0_XA_LSSIParameter		0x840
+#define	rFPGA0_XB_LSSIParameter		0x844
+
+#define rFPGA0_XAB_SwitchControl	0x858	// RF Channel switch
+#define rFPGA0_XCD_SwitchControl	0x85c
+
+#define rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define rFPGA0_XCD_RFParameter		0x87c
+
+#define rFPGA0_AnalogParameter1	0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define rFPGA0_AnalogParameter2	0x884
+#define rFPGA0_AnalogParameter3	0x888
+#define rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+#define rFPGA0_AnalogParameter4	0x88c
+
+#define	rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define	rFPGA0_XB_LSSIReadBack		0x8a4
+#define	rFPGA0_XC_LSSIReadBack		0x8a8
+#define	rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define rFPGA0_XCD_RFPara	0x8b4
+#define	rFPGA0_PSDReport				0x8b4	// Useless now
+#define	TransceiverA_HSPI_Readback		0x8b8	// Transceiver A HSPI Readback
+#define	TransceiverB_HSPI_Readback		0x8bc	// Transceiver B HSPI Readback
+#define	rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define	rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+#define	REG_BB_TX_PATH_SEL_1		0x93c
+#define	REG_BB_TX_PATH_SEL_2		0x940
+#define rFPGA1_TxBlock				0x904	// Useless now
+#define rFPGA1_DebugSelect			0x908	// Useless now
+#define rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+
+/*Page 19 for TxBF*/
+#define	REG_BB_TXBF_ANT_SET_BF1	0x19ac
+#define	REG_BB_TXBF_ANT_SET_BF0	0x19b4
+//
+// PageA(0xA00)
+//
+#define rCCK0_System				0xa00
+#define rCCK0_AFESetting				0xa04	// Disable init gain now // Select RX path by RSSI
+#define	rCCK0_DSPParameter2			0xa1c	//SQ threshold
+#define rCCK0_TxFilter1				0xa20
+#define rCCK0_TxFilter2				0xa24
+#define rCCK0_DebugPort				0xa28	//debug port and Tx filter3
+#define	rCCK0_FalseAlarmReport			0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+
+//
+// PageB(0xB00)
+//
+#define rPdp_AntA      				0xb00
+#define rPdp_AntA_4    				0xb04
+#define rConfig_Pmpd_AntA 			0xb28
+#define rConfig_AntA 					0xb68
+#define rConfig_AntB 					0xb6c
+#define rPdp_AntB 					0xb70
+#define rPdp_AntB_4 					0xb74
+#define rConfig_Pmpd_AntB			0xb98
+#define rAPK							0xbd8
+
+//
+// 6. PageC(0xC00)
+//
+#define rOFDM0_LSTF					0xc00
+
+#define rOFDM0_TRxPathEnable		0xc04
+#define rOFDM0_TRMuxPar			0xc08
+#define rOFDM0_TRSWIsolation		0xc0c
+
+#define rOFDM0_XARxAFE				0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define rOFDM0_XBRxAFE            		0xc18
+#define rOFDM0_XBRxIQImbalance    	0xc1c
+#define rOFDM0_XCRxAFE            		0xc20
+#define rOFDM0_XCRxIQImbalance    	0xc24
+#define rOFDM0_XDRxAFE            		0xc28
+#define rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define rOFDM0_CFOandDAGC			0xc44  //CFO & DAGC
+#define rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define rOFDM0_XAAGCCore1			0xc50	// DIG
+#define rOFDM0_XAAGCCore2			0xc54
+#define rOFDM0_XBAGCCore1			0xc58
+#define rOFDM0_XBAGCCore2			0xc5c
+#define rOFDM0_XCAGCCore1			0xc60
+#define rOFDM0_XCAGCCore2			0xc64
+#define rOFDM0_XDAGCCore1			0xc68
+#define rOFDM0_XDAGCCore2			0xc6c
+
+#define rOFDM0_AGCParameter1		0xc70
+#define rOFDM0_AGCParameter2		0xc74
+#define rOFDM0_AGCRSSITable		0xc78
+#define rOFDM0_HTSTFAGC			0xc7c
+
+#define rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define rOFDM0_XATxAFE				0xc84
+#define rOFDM0_XBTxIQImbalance		0xc88
+#define rOFDM0_XBTxAFE				0xc8c
+#define rOFDM0_XCTxIQImbalance		0xc90
+#define rOFDM0_XCTxAFE            		0xc94
+#define rOFDM0_XDTxIQImbalance		0xc98
+#define rOFDM0_XDTxAFE				0xc9c
+
+#define rOFDM0_RxIQExtAnta			0xca0
+#define rOFDM0_TxCoeff1				0xca4
+#define rOFDM0_TxCoeff2				0xca8
+#define rOFDM0_TxCoeff3				0xcac
+#define rOFDM0_TxCoeff4				0xcb0
+#define rOFDM0_TxCoeff5				0xcb4
+#define rOFDM0_TxCoeff6				0xcb8
+#define rOFDM0_RxHPParameter		0xce0
+#define rOFDM0_TxPseudoNoiseWgt	0xce4
+#define rOFDM0_FrameSync			0xcf0
+#define rOFDM0_DFSReport			0xcf4
+
+//
+// 7. PageD(0xD00)
+//
+#define rOFDM1_LSTF					0xd00
+#define rOFDM1_TRxPathEnable		0xd04
+
+//
+// 8. PageE(0xE00)
+//
+#define rTxAGC_A_Rate18_06			0xe00
+#define rTxAGC_A_Rate54_24			0xe04
+#define rTxAGC_A_CCK1_Mcs32		0xe08
+#define rTxAGC_A_Mcs03_Mcs00		0xe10
+#define rTxAGC_A_Mcs07_Mcs04		0xe14
+#define rTxAGC_A_Mcs11_Mcs08		0xe18
+#define rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+#define rTxAGC_B_Rate18_06			0x830
+#define rTxAGC_B_Rate54_24			0x834
+#define rTxAGC_B_CCK1_55_Mcs32	0x838
+#define rTxAGC_B_Mcs03_Mcs00		0x83c
+#define rTxAGC_B_Mcs07_Mcs04		0x848
+#define rTxAGC_B_Mcs11_Mcs08		0x84c
+#define rTxAGC_B_Mcs15_Mcs12		0x868
+#define rTxAGC_B_CCK11_A_CCK2_11	0x86c
+
+#define rFPGA0_IQK					0xe28
+#define rTx_IQK_Tone_A				0xe30
+#define rRx_IQK_Tone_A				0xe34
+#define rTx_IQK_PI_A				0xe38
+#define rRx_IQK_PI_A				0xe3c
+
+#define rTx_IQK 						0xe40
+#define rRx_IQK						0xe44
+#define rIQK_AGC_Pts					0xe48
+#define rIQK_AGC_Rsp				0xe4c
+#define rTx_IQK_Tone_B				0xe50
+#define rRx_IQK_Tone_B				0xe54
+#define rTx_IQK_PI_B					0xe58
+#define rRx_IQK_PI_B					0xe5c
+#define rIQK_AGC_Cont				0xe60
+
+#define rBlue_Tooth					0xe6c
+#define rRx_Wait_CCA				0xe70
+#define rTx_CCK_RFON				0xe74
+#define rTx_CCK_BBON				0xe78
+#define rTx_OFDM_RFON				0xe7c
+#define rTx_OFDM_BBON				0xe80
+#define rTx_To_Rx					0xe84
+#define rTx_To_Tx					0xe88
+#define rRx_CCK						0xe8c
+
+#define rTx_Power_Before_IQK_A		0xe94
+#define rTx_Power_After_IQK_A		0xe9c
+
+#define rRx_Power_Before_IQK_A		0xea0
+#define rRx_Power_Before_IQK_A_2	0xea4
+#define rRx_Power_After_IQK_A		0xea8
+#define rRx_Power_After_IQK_A_2		0xeac
+
+#define rTx_Power_Before_IQK_B		0xeb4
+#define rTx_Power_After_IQK_B		0xebc
+
+#define rRx_Power_Before_IQK_B		0xec0
+#define rRx_Power_Before_IQK_B_2	0xec4
+#define rRx_Power_After_IQK_B		0xec8
+#define rRx_Power_After_IQK_B_2		0xecc
+
+#define rRx_OFDM					0xed0
+#define rRx_Wait_RIFS 				0xed4
+#define rRx_TO_Rx 					0xed8
+#define rStandby 						0xedc
+#define rSleep 						0xee0
+#define rPMPD_ANAEN				0xeec
+
+
+// 2. Page8(0x800)
+#define bRFMOD						0x1	// Reg 0x800 rFPGA0_RFMOD
+#define bJapanMode					0x2
+#define bCCKTxSC					0x30
+#define bCCKEn						0x1000000
+#define bOFDMEn						0x2000000
+#define bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define bXCTxAGC                  			0xf000
+#define bXDTxAGC                  			0xf0000
+
+// 4. PageA(0xA00)
+#define bCCKBBMode                			0x3	// Useless
+#define bCCKTxPowerSaving         		0x80
+#define bCCKRxPowerSaving         		0x40
+
+#define bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define bCCKScramble              		0x8	// Useless
+#define bCCKAntDiversity    		      	0x8000
+#define bCCKCarrierRecovery   	    	0x4000
+#define bCCKTxRate           		     	0x3000
+#define bCCKDCCancel             	 		0x0800
+#define bCCKISICancel             			0x0400
+#define bCCKMatchFilter           		0x0200
+#define bCCKEqualizer             			0x0100
+#define bCCKPreambleDetect       	 	0x800000
+#define bCCKFastFalseCCA          		0x400000
+#define bCCKChEstStart            		0x300000
+#define bCCKCCACount              		0x080000
+#define bCCKcs_lim                			0x070000
+#define bCCKBistMode              			0x80000000
+#define bCCKCCAMask             	  		0x40000000
+#define bCCKTxDACPhase         	   	0x4
+#define bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define bCCKr_cp_mode0         	   	0x0100
+#define bCCKTxDCOffset           	 	0xf0
+#define bCCKRxDCOffset           	 	0xf
+#define bCCKCCAMode              	 		0xc000
+#define bCCKFalseCS_lim           		0x3f00
+#define bCCKCS_ratio              			0xc00000
+#define bCCKCorgBit_sel           		0x300000
+#define bCCKPD_lim                			0x0f0000
+#define bCCKNewCCA                		0x80000000
+#define bCCKRxHPofIG              		0x8000
+#define bCCKRxIG                  			0x7f00
+#define bCCKLNAPolarity           		0x800000
+#define bCCKRx1stGain             		0x7f0000
+#define bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define bCCKRxAGCSatLevel        	 	0x1f000000
+#define bCCKRxAGCSatCount       	  	0xe0
+#define bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define bCCKAntennaPolarity      	 	0x2000
+#define bCCKTxFilterType          		0x0c00
+#define bCCKRxAGCReportType   	   	0x0300
+#define bCCKRxDAGCEn              		0x80000000
+#define bCCKRxDAGCPeriod        	  	0x20000000
+#define bCCKRxDAGCSatLevel     	   	0x1f000000
+#define bCCKTimingRecovery       	 	0x800000
+#define bCCKTxC0                  			0x3f0000
+#define bCCKTxC1                  			0x3f000000
+#define bCCKTxC2                  			0x3f
+#define bCCKTxC3                  			0x3f00
+#define bCCKTxC4                  			0x3f0000
+#define bCCKTxC5                  			0x3f000000
+#define bCCKTxC6                  			0x3f
+#define bCCKTxC7                  			0x3f00
+#define bCCKDebugPort             		0xff0000
+#define bCCKDACDebug              		0x0f000000
+#define bCCKFalseAlarmEnable      		0x8000
+#define bCCKFalseAlarmRead        		0x4000
+#define bCCKTRSSI                 			0x7f
+#define bCCKRxAGCReport           		0xfe
+#define bCCKRxReport_AntSel       		0x80000000
+#define bCCKRxReport_MFOff        		0x40000000
+#define bCCKRxRxReport_SQLoss     	0x20000000
+#define bCCKRxReport_Pktloss      		0x10000000
+#define bCCKRxReport_Lockedbit    	0x08000000
+#define bCCKRxReport_RateError    	0x04000000
+#define bCCKRxReport_RxRate       		0x03000000
+#define bCCKRxFACounterLower      	0xff
+#define bCCKRxFACounterUpper      	0xff000000
+#define bCCKRxHPAGCStart          		0xe000
+#define bCCKRxHPAGCFinal          		0x1c00
+#define bCCKRxFalseAlarmEnable    	0x8000
+#define bCCKFACounterFreeze       		0x4000
+#define bCCKTxPathSel             		0x10000000
+#define bCCKDefaultRxPath         		0xc000000
+#define bCCKOptionRxPath          		0x3000000
+
+#define		RF_T_METER_88E				0x42	//
+
+// 6. PageE(0xE00)
+#define bSTBCEn                  			0x4	// Useless
+#define bAntennaMapping          		0x10
+#define bNss                     				0x20
+#define bCFOAntSumD              		0x200
+#define bPHYCounterReset         		0x8000000
+#define bCFOReportGet            			0x4000000
+#define bOFDMContinueTx          		0x10000000
+#define bOFDMSingleCarrier       		0x20000000
+#define bOFDMSingleTone          		0x40000000
+
+
+//
+// Other Definition
+//
+
+#define bEnable                   0x1	// Useless
+#define bDisable                  0x0
+
+//byte endable for srwrite
+#define bByte0                    		0x1	// Useless
+#define bByte1                    		0x2
+#define bByte2                    		0x4
+#define bByte3                    		0x8
+#define bWord0                    		0x3
+#define bWord1                    		0xc
+#define bDWord                    		0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define bMaskByte0                		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define bMaskByte1                		0xff00
+#define bMaskByte2                		0xff0000
+#define bMaskByte3                		0xff000000
+#define bMaskHWord                	0xffff0000
+#define bMaskLWord                		0x0000ffff
+#define bMaskDWord                	0xffffffff
+#define bMaskH3Bytes				0xffffff00
+#define bMask12Bits				0xfff
+#define bMaskH4Bits				0xf0000000
+#define bMaskOFDM_D			0xffc00000
+#define bMaskCCK				0x3f3f3f3f
+#define bMask7bits				0x7f
+#define bMaskByte2HighNibble			0x00f00000
+#define bMaskByte3LowNibble				0x0f000000
+#define bMaskL3Bytes			0x00ffffff
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PwrSeq.h
new file mode 100644
index 000000000..bc059ceeb
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8814PwrSeq.h
@@ -0,0 +1,237 @@
+
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL8814PWRSEQ_H__
+#define __HAL8814PWRSEQ_H__
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WB-110628-DZ-RTL8195 (Jaguar) Power Architecture-R04.pdf
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8814A_TRANS_CARDEMU_TO_ACT_STEPS	16
+#define	RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS	20
+#define	RTL8814A_TRANS_CARDEMU_TO_SUS_STEPS	17
+#define	RTL8814A_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS	17
+#define	RTL8814A_TRANS_PDN_TO_CARDEMU_STEPS	16
+#define	RTL8814A_TRANS_ACT_TO_LPS_STEPS	20
+#define	RTL8814A_TRANS_LPS_TO_ACT_STEPS	15
+#define	RTL8814A_TRANS_END_STEPS	1
+
+
+#define RTL8814A_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x002B, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /* ??0x28[24]=1, enable pll phase select*/ \
+	{0x0015, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT3|BIT2|BIT1), (BIT3|BIT2|BIT1)},/* 0x14[11:9]=3'b111,OCP current threshold=1.5A */ \
+	{0x002D, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x0E, 0x08},/* 0x2C[11:9]=3'b100, select lpf R3 */ \
+	{0x002D, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x70, 0x50},/* 0x2C[14:12]=3'b101, select lpf Rs*/ \
+	{0x007B, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/* 0x78[30]=1'b1, SDM order select*/ \
+	/*{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0}, */ /* disable HWPDN 0x04[15]=0*/ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0},/* disable WL suspend*/	\
+	{0x00F0, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* */	\
+	{0x0081, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x30, 0x20},/* */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/
+
+#define RTL8814A_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
+	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},  /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US}, /*Delay 1us*/	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
+	{0x1002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},  /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
+	{0x0002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US}, /*Delay 1us*/	\
+	{0x1002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},  /*0x1F[7:0] = 0 turn off RF*/	\
+	/*{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},*/  /*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x28},   /* 0x07[7:0] = 0x28 sps pwm mode 0x2a for BT coex*/	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},   /*0x8[1] = 0 ANA clk =500k */	\
+	/*{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0|BIT1, 0},*/   /*  0x02[1:0] = 0	reset BB */	\
+	{0x0066, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},   /*0x66[7]=0, disable ckreq for gpio7 output SUS */	\
+	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0},   /*0x41[4]=0, disable sic for gpio7 output SUS */	\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},   /*0x42[1]=0, disable ckout for gpio7 output SUS */	\
+	{0x004e, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},   /*0x4E[5]=1, disable LED2 for gpio7 output SUS */	\
+	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},   /*0x41[0]=0, disable uart for gpio7 output SUS */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/
+
+#define RTL8814A_TRANS_CARDEMU_TO_SUS													\
+	/* format */								\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0061, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x0F, 0x0c},\
+	{0x0061, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x0F, 0x0E},\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x0F, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
+	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
+	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* suspend option all off */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*0x14[13] = 1 turn on ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/* 0x14[14] =1 trun on ZCD */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	{0x0091, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xA0, 0xA0}, /* 0x91[7]=1 0x91[5]=1 , disable sps,ldo sleep mode */	\
+	{0x0070, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /* 0x70[3]=1 enable mainbias polling */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 1 enable WL suspend */
+
+#define RTL8814A_TRANS_SUS_TO_CARDEMU													\
+	/* format */								\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 0 enable WL suspend*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO sleep mode leave */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, 0},/* 0x14[14] =0 trun off ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0},/*0x14[13] = 0 turn off ZCD */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */
+
+#define RTL8814A_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	/**{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, //0x194[0]=0 , disable 32K clock*/	\
+	/**{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x94}, //0x93=0x94 , 90[30] =0 enable 500k ANA clock .switch clock from 12M to 500K , 90 [26] =0 disable EEprom loader clock*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0}, /*0x03[2] = 0, reset 3081*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x01}, /*0x80=05h if reload fw, fill the default value of host_CPU handshake field*/	\
+	{0x0081, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x30}, /*0x80=05h if reload fw, fill the default value of host_CPU handshake field*/	\
+	/*{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xcc},*/   \
+	/*{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xEC},*/   \
+	/*{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},*/  /* gpio11 input mode, gpio10~8 output mode */	\
+	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
+	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/* 0x15[6] =1 trun on ZCD output */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*0x15[5] = 1 turn on ZCD */	\
+	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, 0},/*0x12[6] = 0 force PFM mode */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4},/*0x23[4] = 1 hpon LDO sleep mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /* 0x01f[1]=0 , disable RFC_0  control  REG_RF_CTRL_8814A */	\
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /* 0x020[1]=0 , disable RFC_1  control  REG_RF_CTRL_8814A */	\
+	{0x0021, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /* 0x021[1]=0 , disable RFC_2  control  REG_RF_CTRL_8814A */	\
+	{0x0076, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0}, /* 0x076[1]=0 , disable RFC_3  control REG_OPT_CTRL_8814A +2 */	\
+	{0x0091, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xA0, 0xA0}, /* 0x91[7]=1 0x91[5]=1 , disable sps,ldo sleep mode */	\
+	{0x0070, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /* 0x70[3]=1 enable mainbias polling */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, BIT3}, /*0x04[11] = 1 enable WL suspend*/
+
+#define RTL8814A_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/                       \
+	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, BIT6},/*0x12[6] = 1 force PWM mode */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0},/*0x15[5] = 0 turn off ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, 0},/* 0x15[6] =0 trun off ZCD output */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0},/*0x23[4] = 0 hpon LDO leave sleep mode */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00}, /* gpio11 input mode, gpio10~8 input mode */ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0}, /*0x04[10] = 0, enable SW LPS PCIE only*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0}, /*0x04[11] = 0, enable WL suspend*/	\
+	/*{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2},*/ /*0x03[2] = 1, enable 3081*/	\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/		\
+	{0x0071, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/*0x70[10] = 0, CPHY_MBIAS_EN disable*/
+
+
+#define RTL8814A_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8814A_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8814A_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/		\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
+	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated,and RF closed*/	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
+	{0x1002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated,and RF closed*/	\
+	{0x0002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x1002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/			\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/		\
+	{0x05F1, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Respond TxOK to scheduler*/
+
+
+#define RTL8814A_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/	\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/	\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /* Delay*/	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/	\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /* Polling 0x109[7]=0  TSF in 40M*/			\
+	/*{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, */ /*.	??0x29[7:6] = 2b'00	 enable BB clock*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/					\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/	\
+	{0x0002, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/	\
+	{0x1002, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x1002[1:0] = 2b'11	 enable BB macro*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8814A_TRANS_END																\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/		\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8814A_power_on_flow[RTL8814A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_radio_off_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_card_disable_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_card_enable_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_suspend_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8814A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_resume_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8814A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_hwpdn_flow[RTL8814A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8814A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_enter_lps_flow[RTL8814A_TRANS_ACT_TO_LPS_STEPS+RTL8814A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8814A_leave_lps_flow[RTL8814A_TRANS_LPS_TO_ACT_STEPS+RTL8814A_TRANS_END_STEPS];
+
+#endif //__HAL8814PWRSEQ_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/Hal8821APwrSeq.h b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8821APwrSeq.h
new file mode 100644
index 000000000..8b29a99f5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/Hal8821APwrSeq.h
@@ -0,0 +1,186 @@
+#ifndef REALTEK_POWER_SEQUENCE_8821
+#define REALTEK_POWER_SEQUENCE_8821
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20130516-JackieLau-RTL8821A_Power_Architecture-R10.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS	25
+#define	RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8821A_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS	15
+#define	RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8821A_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8821A_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8821A_TRANS_LPS_TO_ACT_STEPS	15
+#define	RTL8821A_TRANS_END_STEPS	1
+
+
+#define RTL8821A_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
+	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3|BIT2), 0},/* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[12:11]=0*/	\
+	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , BIT0},/* Disable USB suspend */	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0075, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0 , 0},/* Enable USB suspend */	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT4|BIT3), 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/	\
+	{0x004F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*0x4C[24] = 0x4F[0] = 1, switch DPDT_SEL_P output from WL BB */\
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT5|BIT4), (BIT5|BIT4)},/*0x66[13] = 0x67[5] = 1, switch for PAPE_G/PAPE_A from WL BB ; 0x66[12] = 0x67[4] = 1, switch LNAON from WL BB */\
+	{0x0025, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6, 0},/*anapar_mac<118> , 0x25[6]=0 by wlan single function*/\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable falling edge triggering interrupt*/\
+	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable GPIO9 interrupt mode*/\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable GPIO9 input mode*/\
+	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/*Enable HSISR GPIO[C:0] interrupt*/\
+	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1},/*Enable HSISR GPIO9 interrupt*/\
+	{0x007A, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x3A},/*0x7A = 0x3A start BT*/\
+	{0x002E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF , 0x82 },/* 0x2C[23:12]=0x820 ; XTAL trim */ \
+	{0x0010, PWR_CUT_A_MSK , PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6 , BIT6 },/* 0x10[6]=1 ; MPsW0x2CvA0x10[6]]1~WLAN */ \
+
+
+#define RTL8821A_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x004F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*0x4C[24] = 0x4F[0] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Enable rising edge triggering interrupt*/ \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/   \
+
+
+#define RTL8821A_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4|BIT3, (BIT4|BIT3)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8821A_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8821A_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, BIT2}, /*0x04[10] = 1, enable SW LPS*/	\
+        {0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8821A_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3 | BIT7, 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3|BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/
+
+
+#define RTL8821A_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, BIT4}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8821A_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8821A_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8821A_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT6|BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8821A_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern WLAN_PWR_CFG rtl8821A_power_on_flow[RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_radio_off_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_card_disable_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_card_enable_flow[RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_suspend_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_resume_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_hwpdn_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_enter_lps_flow[RTL8821A_TRANS_ACT_TO_LPS_STEPS+RTL8821A_TRANS_END_STEPS];
+extern WLAN_PWR_CFG rtl8821A_leave_lps_flow[RTL8821A_TRANS_LPS_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS];
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/HalPwrSeqCmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/HalPwrSeqCmd.h
new file mode 100644
index 000000000..24e4a54b4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/HalPwrSeqCmd.h
@@ -0,0 +1,138 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HALPWRSEQCMD_H__
+#define __HALPWRSEQCMD_H__
+
+#include <drv_types.h>
+
+/*---------------------------------------------*/
+//3 The value of cmd: 4 bits
+/*---------------------------------------------*/
+#define PWR_CMD_READ			0x00
+     // offset: the read register offset
+     // msk: the mask of the read value
+     // value: N/A, left by 0
+     // note: dirver shall implement this function by read & msk
+
+#define PWR_CMD_WRITE			0x01
+     // offset: the read register offset
+     // msk: the mask of the write bits
+     // value: write value
+     // note: driver shall implement this cmd by read & msk after write
+
+#define PWR_CMD_POLLING			0x02
+     // offset: the read register offset
+     // msk: the mask of the polled value
+     // value: the value to be polled, masked by the msd field.
+     // note: driver shall implement this cmd by
+     // do{
+     // if( (Read(offset) & msk) == (value & msk) )
+     // break;
+     // } while(not timeout);
+
+#define PWR_CMD_DELAY			0x03
+     // offset: the value to delay
+     // msk: N/A
+     // value: the unit of delay, 0: us, 1: ms
+
+#define PWR_CMD_END				0x04
+     // offset: N/A
+     // msk: N/A
+     // value: N/A
+
+/*---------------------------------------------*/
+//3 The value of base: 4 bits
+/*---------------------------------------------*/
+   // define the base address of each block
+#define PWR_BASEADDR_MAC		0x00
+#define PWR_BASEADDR_USB		0x01
+#define PWR_BASEADDR_PCIE		0x02
+#define PWR_BASEADDR_SDIO		0x03
+
+/*---------------------------------------------*/
+//3 The value of interface_msk: 4 bits
+/*---------------------------------------------*/
+#define	PWR_INTF_SDIO_MSK		BIT(0)
+#define	PWR_INTF_USB_MSK		BIT(1)
+#define	PWR_INTF_PCI_MSK		BIT(2)
+#define	PWR_INTF_ALL_MSK		(BIT(0)|BIT(1)|BIT(2)|BIT(3))
+
+/*---------------------------------------------*/
+//3 The value of fab_msk: 4 bits
+/*---------------------------------------------*/
+#define	PWR_FAB_TSMC_MSK		BIT(0)
+#define	PWR_FAB_UMC_MSK			BIT(1)
+#define	PWR_FAB_ALL_MSK			(BIT(0)|BIT(1)|BIT(2)|BIT(3))
+
+/*---------------------------------------------*/
+//3 The value of cut_msk: 8 bits
+/*---------------------------------------------*/
+#define	PWR_CUT_TESTCHIP_MSK	BIT(0)
+#define	PWR_CUT_A_MSK			BIT(1)
+#define	PWR_CUT_B_MSK			BIT(2)
+#define	PWR_CUT_C_MSK			BIT(3)
+#define	PWR_CUT_D_MSK			BIT(4)
+#define	PWR_CUT_E_MSK			BIT(5)
+#define	PWR_CUT_F_MSK			BIT(6)
+#define	PWR_CUT_G_MSK			BIT(7)
+#define	PWR_CUT_ALL_MSK			0xFF
+
+
+typedef enum _PWRSEQ_CMD_DELAY_UNIT_
+{
+	PWRSEQ_DELAY_US,
+	PWRSEQ_DELAY_MS,
+} PWRSEQ_DELAY_UNIT;
+
+typedef struct _WL_PWR_CFG_
+{
+	u16 offset;
+	u8 cut_msk;
+	u8 fab_msk:4;
+	u8 interface_msk:4;
+	u8 base:4;
+	u8 cmd:4;
+	u8 msk;
+	u8 value;
+} WLAN_PWR_CFG, *PWLAN_PWR_CFG;
+
+
+#define GET_PWR_CFG_OFFSET(__PWR_CMD)		__PWR_CMD.offset
+#define GET_PWR_CFG_CUT_MASK(__PWR_CMD)		__PWR_CMD.cut_msk
+#define GET_PWR_CFG_FAB_MASK(__PWR_CMD)		__PWR_CMD.fab_msk
+#define GET_PWR_CFG_INTF_MASK(__PWR_CMD)	__PWR_CMD.interface_msk
+#define GET_PWR_CFG_BASE(__PWR_CMD)			__PWR_CMD.base
+#define GET_PWR_CFG_CMD(__PWR_CMD)			__PWR_CMD.cmd
+#define GET_PWR_CFG_MASK(__PWR_CMD)			__PWR_CMD.msk
+#define GET_PWR_CFG_VALUE(__PWR_CMD)		__PWR_CMD.value
+
+
+//================================================================================
+//	Prototype of protected function.
+//================================================================================
+u8 HalPwrSeqCmdParsing(
+	PADAPTER		padapter,
+	u8				CutVersion,
+	u8				FabVersion,
+	u8				InterfaceType,
+	WLAN_PWR_CFG	PwrCfgCmd[]);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/HalVerDef.h b/drivers/net/wireless/realtek/rtl8723cs/include/HalVerDef.h
new file mode 100644
index 000000000..ab5770a28
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/HalVerDef.h
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_VERSION_DEF_H__
+#define __HAL_VERSION_DEF_H__
+
+#define TRUE 	_TRUE
+#define FALSE	_FALSE
+
+// HAL_IC_TYPE_E
+typedef enum tag_HAL_IC_Type_Definition
+{
+	CHIP_8192S	=	0,
+	CHIP_8188C	=	1,
+	CHIP_8192C	=	2,
+	CHIP_8192D	=	3,
+	CHIP_8723A	=	4,
+	CHIP_8188E	=	5,
+	CHIP_8812	=	6,
+	CHIP_8821	=	7,
+	CHIP_8723B 	=	8,
+	CHIP_8192E 	=	9,
+	CHIP_8814A	=	10,
+	CHIP_8703B	=	11,
+	CHIP_8188F	=	12,
+}HAL_IC_TYPE_E;
+
+//HAL_CHIP_TYPE_E
+typedef enum tag_HAL_CHIP_Type_Definition
+{
+	TEST_CHIP 		=	0,
+	NORMAL_CHIP 	=	1,
+	FPGA			=	2,
+}HAL_CHIP_TYPE_E;
+
+//HAL_CUT_VERSION_E
+typedef enum tag_HAL_Cut_Version_Definition
+{
+	A_CUT_VERSION 		=	0,
+	B_CUT_VERSION 		=	1,
+	C_CUT_VERSION 		=	2,
+	D_CUT_VERSION 		=	3,
+	E_CUT_VERSION 		=	4,
+	F_CUT_VERSION 		=	5,
+	G_CUT_VERSION 		=	6,
+	H_CUT_VERSION 		=	7,
+	I_CUT_VERSION 		=	8,
+	J_CUT_VERSION 		=	9,
+	K_CUT_VERSION 		=	10,
+}HAL_CUT_VERSION_E;
+
+// HAL_Manufacturer
+typedef enum tag_HAL_Manufacturer_Version_Definition
+{
+	CHIP_VENDOR_TSMC 	=	0,
+	CHIP_VENDOR_UMC 	=	1,
+	CHIP_VENDOR_SMIC 	=	2,
+}HAL_VENDOR_E;
+
+typedef enum tag_HAL_RF_Type_Definition
+{
+	RF_TYPE_1T1R 	=	0,
+	RF_TYPE_1T2R 	=	1,
+	RF_TYPE_2T2R	=	2,
+	RF_TYPE_2T3R	=	3,
+	RF_TYPE_2T4R	=	4,
+	RF_TYPE_3T3R	=	5,
+	RF_TYPE_3T4R	=	6,
+	RF_TYPE_4T4R	=	7,
+}HAL_RF_TYPE_E;
+
+typedef	struct tag_HAL_VERSION
+{
+	HAL_IC_TYPE_E		ICType;
+	HAL_CHIP_TYPE_E		ChipType;
+	HAL_CUT_VERSION_E	CUTVersion;
+	HAL_VENDOR_E		VendorType;
+	HAL_RF_TYPE_E		RFType;
+	u8					ROMVer;
+}HAL_VERSION,*PHAL_VERSION;
+
+//VERSION_8192C			VersionID;
+//HAL_VERSION			VersionID;
+
+// Get element
+#define GET_CVID_IC_TYPE(version)			((HAL_IC_TYPE_E)(((HAL_VERSION)version).ICType)	)
+#define GET_CVID_CHIP_TYPE(version)			((HAL_CHIP_TYPE_E)(((HAL_VERSION)version).ChipType)	)
+#define GET_CVID_RF_TYPE(version)			((HAL_RF_TYPE_E)(((HAL_VERSION)version).RFType))
+#define GET_CVID_MANUFACTUER(version)		((HAL_VENDOR_E)(((HAL_VERSION)version).VendorType))
+#define GET_CVID_CUT_VERSION(version)		((HAL_CUT_VERSION_E)(((HAL_VERSION)version).CUTVersion))
+#define GET_CVID_ROM_VERSION(version)		((((HAL_VERSION)version).ROMVer) & ROM_VERSION_MASK)
+
+//----------------------------------------------------------------------------
+//Common Macro. --
+//----------------------------------------------------------------------------
+//HAL_VERSION VersionID
+
+// HAL_IC_TYPE_E
+#if 0
+#define IS_81XXC(version)				(((GET_CVID_IC_TYPE(version) == CHIP_8192C)||(GET_CVID_IC_TYPE(version) == CHIP_8188C))? TRUE : FALSE)
+#define IS_8723_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723A)? TRUE : FALSE)
+#define IS_92D(version)					((GET_CVID_IC_TYPE(version) == CHIP_8192D)? TRUE : FALSE)
+#endif
+
+#define IS_8188E(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188E)? TRUE : FALSE)
+#define IS_8188F(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188F) ? TRUE : FALSE)
+#define IS_8192E(version)					((GET_CVID_IC_TYPE(version) == CHIP_8192E)? TRUE : FALSE)
+#define IS_8812_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8812)? TRUE : FALSE)
+#define IS_8821_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8821)? TRUE : FALSE)
+#define IS_8814A_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8814A) ? TRUE : FALSE)
+#define IS_8723B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723B)? TRUE : FALSE)
+#define IS_8703B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8703B)? TRUE : FALSE)
+
+//HAL_CHIP_TYPE_E
+#define IS_TEST_CHIP(version)			((GET_CVID_CHIP_TYPE(version)==TEST_CHIP)? TRUE: FALSE)
+#define IS_NORMAL_CHIP(version)			((GET_CVID_CHIP_TYPE(version)==NORMAL_CHIP)? TRUE: FALSE)
+
+//HAL_CUT_VERSION_E
+#define IS_A_CUT(version)				((GET_CVID_CUT_VERSION(version) == A_CUT_VERSION) ? TRUE : FALSE)
+#define IS_B_CUT(version)				((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? TRUE : FALSE)
+#define IS_C_CUT(version)				((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? TRUE : FALSE)
+#define IS_D_CUT(version)				((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? TRUE : FALSE)
+#define IS_E_CUT(version)				((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? TRUE : FALSE)
+#define IS_F_CUT(version)				((GET_CVID_CUT_VERSION(version) == F_CUT_VERSION) ? TRUE : FALSE)
+#define IS_I_CUT(version)				((GET_CVID_CUT_VERSION(version) == I_CUT_VERSION) ? TRUE : FALSE)
+#define IS_J_CUT(version)				((GET_CVID_CUT_VERSION(version) == J_CUT_VERSION) ? TRUE : FALSE)
+#define IS_K_CUT(version)				((GET_CVID_CUT_VERSION(version) == K_CUT_VERSION) ? TRUE : FALSE)
+
+//HAL_VENDOR_E
+#define IS_CHIP_VENDOR_TSMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_TSMC)? TRUE: FALSE)
+#define IS_CHIP_VENDOR_UMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_UMC)? TRUE: FALSE)
+#define IS_CHIP_VENDOR_SMIC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_SMIC)? TRUE: FALSE)
+
+//HAL_RF_TYPE_E
+#define IS_1T1R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T1R)? TRUE : FALSE )
+#define IS_1T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R)? TRUE : FALSE)
+#define IS_2T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R)? TRUE : FALSE)
+#define IS_3T3R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T3R)? TRUE : FALSE)
+#define IS_3T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T4R)? TRUE : FALSE)
+#define IS_4T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_4T4R)? TRUE : FALSE)
+
+
+
+//----------------------------------------------------------------------------
+//Chip version Macro. --
+//----------------------------------------------------------------------------
+#if 0
+#define IS_81XXC_TEST_CHIP(version)		((IS_81XXC(version) && (!IS_NORMAL_CHIP(version)))? TRUE: FALSE)
+
+#define IS_92C_SERIAL(version)   					((IS_81XXC(version) && IS_2T2R(version)) ? TRUE : FALSE)
+#define IS_81xxC_VENDOR_UMC_A_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_A_CUT(version) ? TRUE : FALSE) : FALSE): FALSE)
+#define IS_81xxC_VENDOR_UMC_B_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_B_CUT(version) ? TRUE : FALSE) : FALSE): FALSE)
+#define IS_81xxC_VENDOR_UMC_C_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_C_CUT(version) ? TRUE : FALSE) : FALSE): FALSE)
+
+#define IS_NORMAL_CHIP92D(version)		(( IS_92D(version))?((GET_CVID_CHIP_TYPE(version)==NORMAL_CHIP)? TRUE: FALSE):FALSE)
+
+#define IS_92D_SINGLEPHY(version)		((IS_92D(version)) ? (IS_2T2R(version) ? TRUE: FALSE) : FALSE)
+#define IS_92D_C_CUT(version)			((IS_92D(version)) ? (IS_C_CUT(version) ? TRUE : FALSE) : FALSE)
+#define IS_92D_D_CUT(version)			((IS_92D(version)) ? (IS_D_CUT(version) ? TRUE : FALSE) : FALSE)
+#define IS_92D_E_CUT(version)			((IS_92D(version)) ? (IS_E_CUT(version) ? TRUE : FALSE) : FALSE)
+
+#define IS_8723A_A_CUT(version)				((IS_8723_SERIES(version)) ? ( IS_A_CUT(version)?TRUE : FALSE) : FALSE)
+#define IS_8723A_B_CUT(version)				((IS_8723_SERIES(version)) ? ( IS_B_CUT(version)?TRUE : FALSE) : FALSE)
+#endif
+
+#define IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)		((IS_8188E(GET_HAL_DATA(_Adapter)->VersionID)) ? ((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->VersionID) >= I_CUT_VERSION) ? TRUE : FALSE) : FALSE)
+
+#define IS_VENDOR_8812A_TEST_CHIP(_Adapter)		((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? FALSE : TRUE) : FALSE)
+#define IS_VENDOR_8812A_MP_CHIP(_Adapter)		((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? TRUE : FALSE) : FALSE)
+#define IS_VENDOR_8812A_C_CUT(_Adapter)			((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->VersionID) == C_CUT_VERSION) ? TRUE : FALSE) : FALSE)
+
+#define IS_VENDOR_8821A_TEST_CHIP(_Adapter)	((IS_8821_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? FALSE : TRUE) : FALSE)
+#define IS_VENDOR_8821A_MP_CHIP(_Adapter)		((IS_8821_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? TRUE : FALSE) : FALSE)
+
+#define IS_VENDOR_8192E_B_CUT(_Adapter)		((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->VersionID) == B_CUT_VERSION) ? TRUE : FALSE)
+
+#define IS_VENDOR_8723B_TEST_CHIP(_Adapter)	((IS_8723B_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? FALSE : TRUE) : FALSE)
+#define IS_VENDOR_8723B_MP_CHIP(_Adapter)		((IS_8723B_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? TRUE : FALSE) : FALSE)
+
+#define IS_VENDOR_8703B_TEST_CHIP(_Adapter)	((IS_8703B_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? FALSE : TRUE) : FALSE)
+#define IS_VENDOR_8703B_MP_CHIP(_Adapter)		((IS_8703B_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? TRUE : FALSE) : FALSE)
+#define IS_VENDOR_8814A_TEST_CHIP(_Adapter)	((IS_8814A_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? FALSE : TRUE) : FALSE)
+#define IS_VENDOR_8814A_MP_CHIP(_Adapter)		((IS_8814A_SERIES(GET_HAL_DATA(_Adapter)->VersionID)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->VersionID)) ? TRUE : FALSE) : FALSE)
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/autoconf.h b/drivers/net/wireless/realtek/rtl8723cs/include/autoconf.h
new file mode 100644
index 000000000..116aa48f6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/autoconf.h
@@ -0,0 +1,305 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*
+ * Public General Config
+ */
+#define AUTOCONF_INCLUDED
+
+#define RTL871X_MODULE_NAME "8723CS"
+#define DRV_NAME "rtl8723cs"
+#ifndef CONFIG_RTL8703B
+#define CONFIG_RTL8703B
+#endif
+#define CONFIG_SDIO_HCI
+
+#define PLATFORM_LINUX
+
+
+/*
+ * Wi-Fi Functions Config
+ */
+#define CONFIG_80211N_HT
+#define CONFIG_RECV_REORDERING_CTRL
+
+/* #define CONFIG_IOCTL_CFG80211 */		/* Set from Makefile */
+#ifdef CONFIG_IOCTL_CFG80211
+	/*
+	 * Indecate new sta asoc through cfg80211_new_sta
+	 * If kernel version >= 3.2 or
+	 * version < 3.2 but already apply cfg80211 patch,
+	 * RTW_USE_CFG80211_STA_EVENT must be defiend!
+	 */
+	/* #define RTW_USE_CFG80211_STA_EVENT */ /* Indecate new sta asoc through cfg80211_new_sta */
+	#ifndef CONFIG_PLATFORM_INTEL_BYT
+	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
+	#endif /* !CONFIG_PLATFORM_INTEL_BYT */
+	/* #define CONFIG_DEBUG_CFG80211 */
+	#define CONFIG_SET_SCAN_DENY_TIMER
+#endif
+
+#define CONFIG_AP_MODE
+#ifdef CONFIG_AP_MODE
+	#define CONFIG_NATIVEAP_MLME
+	#ifndef CONFIG_NATIVEAP_MLME
+		#define CONFIG_HOSTAPD_MLME
+	#endif
+	/* #define CONFIG_FIND_BEST_CHANNEL */
+	#define CONFIG_TX_MCAST2UNI	/* Support IP multicast->unicast */
+#endif
+
+#define CONFIG_P2P
+#ifdef CONFIG_P2P
+	/* Added by Albert 20110812
+	The CONFIG_WFD is for supporting the Wi-Fi display */
+	#define CONFIG_WFD
+
+	#define CONFIG_P2P_REMOVE_GROUP_INFO
+
+	/* #define CONFIG_DBG_P2P */
+	#define CONFIG_P2P_PS
+	/* #define CONFIG_P2P_IPS */
+	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
+	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  /* replace CONFIG_P2P_CHK_INVITE_CH_LIST flag */
+	#define CONFIG_P2P_INVITE_IOT
+#endif
+
+/* Added by Kurt 20110511 */
+#ifdef CONFIG_TDLS
+	#define CONFIG_TDLS_DRIVER_SETUP
+	/* #ifndef CONFIG_WFD
+		#define CONFIG_WFD
+	#endif */
+	/* #define CONFIG_TDLS_AUTOSETUP */
+	#define CONFIG_TDLS_AUTOCHECKALIVE
+	#define CONFIG_TDLS_CH_SW		/* Enable "CONFIG_TDLS_CH_SW" by default, however limit it to only work in wifi logo test mode but not in normal mode currently */
+#endif
+
+/* #define CONFIG_CONCURRENT_MODE */	/* Set from Makefile */
+#ifdef CONFIG_CONCURRENT_MODE
+	/* #define CONFIG_HWPORT_SWAP */				/* Port0->Sec , Port1 -> Pri */
+	#define CONFIG_RUNTIME_PORT_SWITCH
+	#ifndef CONFIG_RUNTIME_PORT_SWITCH
+		#define CONFIG_TSF_RESET_OFFLOAD			/* For 2 PORT TSF SYNC. */
+	#endif
+	/* #define DBG_RUNTIME_PORT_SWITCH */
+	#define CONFIG_SCAN_BACKOP
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#define CONFIG_LAYER2_ROAMING
+#define CONFIG_LAYER2_ROAMING_RESUME
+
+/* #define CONFIG_80211D */
+
+
+/*
+ * Hareware/Firmware Related Config
+ */
+/* #define CONFIG_BT_COEXIST */	/* Set from Makefile */
+/* #define CONFIG_ANTENNA_DIVERSITY */	/* Set from Makefile */
+/* #define SUPPORT_HW_RFOFF_DETECTED */
+
+/* #define CONFIG_SW_LED */
+
+#define CONFIG_XMIT_ACK
+#ifdef CONFIG_XMIT_ACK
+	#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+#endif
+
+#define CONFIG_C2H_PACKET_EN
+
+#define CONFIG_RF_GAIN_OFFSET
+
+#define DISABLE_BB_RF	0
+
+#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */
+
+
+/*
+ * Interface Related Config
+ */
+#define CONFIG_TX_AGGREGATION
+#define CONFIG_SDIO_RX_COPY
+#define CONFIG_XMIT_THREAD_MODE
+/* #define CONFIG_SDIO_TX_ENABLE_AVAL_INT */
+
+
+/*
+ * Others
+ */
+/* #define CONFIG_MAC_LOOPBACK_DRIVER */
+
+#define CONFIG_SKB_COPY	/* for amsdu */
+
+#define CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+#define CONFIG_EMBEDDED_FWIMG
+/* #define CONFIG_FILE_FWIMG */
+
+#define CONFIG_LONG_DELAY_ISSUE
+/* #define CONFIG_PATCH_JOIN_WRONG_CHANNEL */
+#define CONFIG_ATTEMPT_TO_FIX_AP_BEACON_ERROR
+
+
+/*
+ * Auto Config Section
+ */
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+#undef CONFIG_IOCTL_CFG80211
+#undef CONFIG_AP_MODE
+#undef CONFIG_NATIVEAP_MLME
+#undef CONFIG_POWER_SAVING
+#undef CONFIG_BT_COEXIST
+#undef CONFIG_ANTENNA_DIVERSITY
+#undef SUPPORT_HW_RFOFF_DETECTED
+#endif
+
+#ifdef CONFIG_MP_INCLUDED
+	#define MP_DRIVER	1
+	#define CONFIG_MP_IWPRIV_SUPPORT
+	/* disable unnecessary functions for MP */
+	/* #undef CONFIG_POWER_SAVING
+	#undef CONFIG_BT_COEXIST
+	#undef CONFIG_ANTENNA_DIVERSITY
+	#undef SUPPORT_HW_RFOFF_DETECTED */
+#else /* !CONFIG_MP_INCLUDED */
+	#define MP_DRIVER	0
+	#undef CONFIG_MP_IWPRIV_SUPPORT
+#endif /* !CONFIG_MP_INCLUDED */
+
+#ifdef CONFIG_POWER_SAVING
+	#define CONFIG_IPS
+	#define CONFIG_LPS
+
+	#if defined(CONFIG_LPS) && (defined(CONFIG_GSPI_HCI) || defined(CONFIG_SDIO_HCI))
+	#define CONFIG_LPS_LCLK
+	#endif
+
+	#ifdef CONFIG_LPS
+		#define CONFIG_CHECK_LEAVE_LPS
+		#ifndef CONFIG_PLATFORM_INTEL_BYT
+		#define CONFIG_LPS_SLOW_TRANSITION
+		#endif /* !CONFIG_PLATFORM_INTEL_BYT */
+	#endif
+
+	#ifdef CONFIG_LPS_LCLK
+	#define CONFIG_DETECT_CPWM_BY_POLLING
+	#define CONFIG_LPS_RPWM_TIMER
+	#if defined(CONFIG_LPS_RPWM_TIMER) || defined(CONFIG_DETECT_CPWM_BY_POLLING)
+	#define LPS_RPWM_WAIT_MS 300
+	#endif
+	#define CONFIG_LPS_LCLK_WD_TIMER /* Watch Dog timer in LPS LCLK */
+	#endif
+
+	#ifdef CONFIG_IPS
+	#define CONFIG_IPS_CHECK_IN_WD /* Do IPS Check in WatchDog. */
+	/* #define CONFIG_SWLPS_IN_IPS */ /* Do SW LPS flow when entering and leaving IPS */
+	/* #define CONFIG_FWLPS_IN_IPS */ /* issue H2C command to let FW do LPS when entering IPS */
+	#endif
+#endif /* CONFIG_POWER_SAVING */
+
+#ifdef CONFIG_BT_COEXIST
+	/* for ODM and outsrc BT-Coex */
+
+	#ifndef CONFIG_LPS
+		#define CONFIG_LPS	/* download reserved page to FW */
+	#endif
+
+	#ifndef CONFIG_C2H_PACKET_EN
+		#define CONFIG_C2H_PACKET_EN
+	#endif
+#endif /* !CONFIG_BT_COEXIST */
+
+#ifdef CONFIG_WOWLAN
+	/* #define CONFIG_GTK_OL */
+	#define CONFIG_ARP_KEEP_ALIVE
+#endif /* CONFIG_WOWLAN */
+
+#ifdef CONFIG_GPIO_WAKEUP
+	#ifndef WAKEUP_GPIO_IDX
+		//#define WAKEUP_GPIO_IDX	12	/* WIFI Chip Side */
+		#define WAKEUP_GPIO_IDX		8	/* WIFI Chip Side */
+	#endif /* !WAKEUP_GPIO_IDX */
+#endif /* CONFIG_GPIO_WAKEUP */
+
+
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+#define CONFIG_HW_ANTENNA_DIVERSITY
+#endif
+
+
+/*
+ * Platform dependent
+ */
+#ifdef CONFIG_PLATFORM_SPRD
+
+#undef CONFIG_SDIO_RX_COPY
+
+#ifdef ANDROID_2X
+
+#define CONFIG_SDIO_RX_COPY
+
+#else /*  !ANDROID_2X */
+	#undef CONFIG_WOWLAN
+	#undef CONFIG_WOWLAN_8723
+	/* #define CONFIG_SDIO_RX_COPY */
+	/* #define CONFIG_LINKED_LCOK */
+	#define CONFIG_AUTH_DIRECT_WITHOUT_BCN
+	/* #define CONFIG_DISCONNECT_H2CWAY */
+	/* #define CONFIG_DONT_CARE_TP */
+	#define CONFIG_LOW_PWR_LPS
+	/* #define CONFIG_CMCC_TEST */
+
+	/* 1) LPS unit is only 102 ms, it's not
+	a good idear to retry it use timer,
+	2) we must wait ACK, or lots of IO
+	is not allowed under 32k, because
+	this will cause hw hang */
+	#undef CONFIG_LPS_RPWM_TIMER
+	#define CONFIG_WAIT_PS_ACK
+	#define CONFIG_SOFTAP_11N
+	#define CONFIG_CHECK_BT_HANG
+
+	/* #define CONFIG_8703BS_TEST */
+#endif /* !ANDROID_2X */
+
+#endif /* CONFIG_PLATFORM_SPRD */
+
+
+/*
+ * Debug Related Config
+ */
+//#define CONFIG_DEBUG
+
+#ifdef CONFIG_DEBUG
+#define DBG	1	/* for ODM & BTCOEX debug */
+/* #define CONFIG_DEBUG_RTL871X */ /* RT_TRACE, RT_PRINT_DATA, _func_enter_, _func_exit_ */
+#else /* !CONFIG_DEBUG */
+#define DBG	0	/* for ODM & BTCOEX debug */
+#endif /* !CONFIG_DEBUG */
+
+#define CONFIG_PROC_DEBUG
+
+#define DBG_CONFIG_ERROR_DETECT
+/* #define DBG_XMIT_BUF */
+/* #define DBG_XMIT_BUF_EXT */
+#define DBG_CHECK_FW_PS_STATE
+#define DBG_CHECK_FW_PS_STATE_H2C
+/* #define CONFIG_FW_C2H_DEBUG */
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/basic_types.h b/drivers/net/wireless/realtek/rtl8723cs/include/basic_types.h
new file mode 100644
index 000000000..7b0a39053
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/basic_types.h
@@ -0,0 +1,385 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+#ifndef TRUE
+	#define _TRUE	1
+#else
+	#define _TRUE	TRUE
+#endif
+
+#ifndef FALSE
+	#define _FALSE	0
+#else
+	#define _FALSE	FALSE
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+	typedef signed char s8;
+	typedef unsigned char u8;
+
+	typedef signed short s16;
+	typedef unsigned short u16;
+
+	typedef signed long s32;
+	typedef unsigned long u32;
+
+	typedef unsigned int	uint;
+	typedef	signed int		sint;
+
+
+	typedef signed long long s64;
+	typedef unsigned long long u64;
+
+	#ifdef NDIS50_MINIPORT
+
+		#define NDIS_MAJOR_VERSION       5
+		#define NDIS_MINOR_VERSION       0
+
+	#endif
+
+	#ifdef NDIS51_MINIPORT
+
+		#define NDIS_MAJOR_VERSION       5
+		#define NDIS_MINOR_VERSION       1
+
+	#endif
+
+	typedef NDIS_PROC proc_t;
+
+	typedef LONG atomic_t;
+
+#endif
+
+
+#ifdef PLATFORM_LINUX
+	#include <linux/version.h>
+	#include <linux/types.h>
+	#include <linux/module.h>
+	#include <linux/kernel.h>
+	#include <linux/init.h>
+	#include <linux/utsname.h>
+	#define IN
+	#define OUT
+	#define VOID void
+	#define NDIS_OID uint
+	#define NDIS_STATUS uint
+
+	typedef	signed int sint;
+
+	#ifndef	PVOID
+	typedef void * PVOID;
+	//#define PVOID	(void *)
+	#endif
+
+        #define UCHAR u8
+	#define USHORT u16
+	#define UINT u32
+	#define ULONG u32
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		typedef _Bool bool;
+	#endif
+
+	typedef void (*proc_t)(void*);
+
+	typedef 	__kernel_size_t	SIZE_T;
+	typedef	__kernel_ssize_t	SSIZE_T;
+	#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
+
+#endif
+
+
+#ifdef PLATFORM_FREEBSD
+
+	typedef signed char s8;
+	typedef unsigned char u8;
+
+	typedef signed short s16;
+	typedef unsigned short u16;
+
+	typedef signed int s32;
+	typedef unsigned int u32;
+
+	typedef unsigned int	uint;
+	typedef	signed int		sint;
+	typedef long atomic_t;
+
+	typedef signed long long s64;
+	typedef unsigned long long u64;
+	#define IN
+	#define OUT
+	#define VOID void
+	#define NDIS_OID uint
+	#define NDIS_STATUS uint
+
+	#ifndef	PVOID
+	typedef void * PVOID;
+	//#define PVOID	(void *)
+	#endif
+	typedef u32 dma_addr_t;
+    #define UCHAR u8
+	#define USHORT u16
+	#define UINT u32
+	#define ULONG u32
+
+	typedef void (*proc_t)(void*);
+
+  typedef unsigned int __kernel_size_t;
+  typedef int __kernel_ssize_t;
+
+	typedef 	__kernel_size_t	SIZE_T;
+	typedef	__kernel_ssize_t	SSIZE_T;
+	#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
+
+#endif
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+#define SIZE_PTR SIZE_T
+#define SSIZE_PTR SSIZE_T
+
+/*
+* Continuous bits starting from least significant bit
+* Example:
+* BIT_LEN_MASK_32(0) => 0x00000000
+* BIT_LEN_MASK_32(1) => 0x00000001
+* BIT_LEN_MASK_32(2) => 0x00000003
+* BIT_LEN_MASK_32(32) => 0xFFFFFFFF
+*/
+#define BIT_LEN_MASK_32(__BitLen) ((u32)(0xFFFFFFFF >> (32 - (__BitLen))))
+#define BIT_LEN_MASK_16(__BitLen) ((u16)(0xFFFF >> (16 - (__BitLen))))
+#define BIT_LEN_MASK_8(__BitLen) ((u8)(0xFF >> (8 - (__BitLen))))
+
+/*
+* Continuous bits starting from least significant bit
+* Example:
+* BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
+* BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
+*/
+#define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) ((u32)(BIT_LEN_MASK_32(__BitLen) << (__BitOffset)))
+#define BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) ((u16)(BIT_LEN_MASK_16(__BitLen) << (__BitOffset)))
+#define BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) ((u8)(BIT_LEN_MASK_8(__BitLen) << (__BitOffset)))
+
+/*
+* Convert LE data to host byte order
+*/
+#define EF1Byte (u8)
+#define EF2Byte le16_to_cpu
+#define EF4Byte le32_to_cpu
+
+/*
+* Read LE data from memory to host byte order
+*/
+#define ReadLE4Byte(_ptr)	le32_to_cpu(*((u32 *)(_ptr)))
+#define ReadLE2Byte(_ptr)	le16_to_cpu(*((u16 *)(_ptr)))
+#define ReadLE1Byte(_ptr)	(*((u8 *)(_ptr)))
+
+/*
+* Read BE data from memory to host byte order
+*/
+#define ReadBEE4Byte(_ptr)	be32_to_cpu(*((u32 *)(_ptr)))
+#define ReadBE2Byte(_ptr)	be16_to_cpu(*((u16 *)(_ptr)))
+#define ReadBE1Byte(_ptr)	(*((u8 *)(_ptr)))
+
+/*
+* Write host byte order data to memory in LE order
+*/
+#define WriteLE4Byte(_ptr, _val)	(*((u32 *)(_ptr))) = cpu_to_le32(_val)
+#define WriteLE2Byte(_ptr, _val)	(*((u16 *)(_ptr))) = cpu_to_le16(_val)
+#define WriteLE1Byte(_ptr, _val)	(*((u8 *)(_ptr))) = ((u8)(_val))
+
+/*
+* Write host byte order data to memory in BE order
+*/
+#define WriteBE4Byte(_ptr, _val)	(*((u32 *)(_ptr))) = cpu_to_be32(_val)
+#define WriteBE2Byte(_ptr, _val)	(*((u16 *)(_ptr))) = cpu_to_be16(_val)
+#define WriteBE1Byte(_ptr, _val)	(*((u8 *)(_ptr))) = ((u8)(_val))
+
+/*
+* Return 4-byte value in host byte ordering from 4-byte pointer in litten-endian system.
+*/
+#define LE_P4BYTE_TO_HOST_4BYTE(__pStart) (le32_to_cpu(*((u32 *)(__pStart))))
+#define LE_P2BYTE_TO_HOST_2BYTE(__pStart) (le16_to_cpu(*((u16 *)(__pStart))))
+#define LE_P1BYTE_TO_HOST_1BYTE(__pStart) ((*((u8 *)(__pStart))))
+
+/*
+* Return 4-byte value in host byte ordering from 4-byte pointer in big-endian system.
+*/
+#define BE_P4BYTE_TO_HOST_4BYTE(__pStart) (be32_to_cpu(*((u32 *)(__pStart))))
+#define BE_P2BYTE_TO_HOST_2BYTE(__pStart) (be16_to_cpu(*((u16 *)(__pStart))))
+#define BE_P1BYTE_TO_HOST_1BYTE(__pStart) ((*((u8 *)(__pStart))))
+
+/*
+* Translate subfield (continuous bits in little-endian) of 4-byte value in LE byte to
+* 4-byte value in host byte ordering.
+*/
+#define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	((LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_32(__BitLen))
+
+#define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	((LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_16(__BitLen))
+
+#define LE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	((LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_8(__BitLen))
+
+/*
+* Translate subfield (continuous bits in big-endian) of 4-byte value in BE byte to
+* 4-byte value in host byte ordering.
+*/
+#define BE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	((BE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_32(__BitLen))
+
+#define BE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	((BE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_16(__BitLen))
+
+#define BE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	((BE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_8(__BitLen))
+
+/*
+* Mask subfield (continuous bits in little-endian) of 4-byte value in LE byte oredering
+* and return the result in 4-byte value in host byte ordering.
+*/
+#define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	(LE_P4BYTE_TO_HOST_4BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)))
+
+#define LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	(LE_P2BYTE_TO_HOST_2BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)))
+
+#define LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	(LE_P1BYTE_TO_HOST_1BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen)))
+
+/*
+* Mask subfield (continuous bits in big-endian) of 4-byte value in BE byte oredering
+* and return the result in 4-byte value in host byte ordering.
+*/
+#define BE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	(BE_P4BYTE_TO_HOST_4BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)))
+
+#define BE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	(BE_P2BYTE_TO_HOST_2BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)))
+
+#define BE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	(BE_P1BYTE_TO_HOST_1BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen)))
+
+/*
+* Set subfield of little-endian 4-byte value to specified value.
+*/
+#define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 32) \
+			WriteLE4Byte(__pStart, __Value); \
+		else { \
+			WriteLE4Byte(__pStart, \
+				LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_LE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 16) \
+			WriteLE2Byte(__pStart, __Value); \
+		else { \
+			WriteLE2Byte(__pStart, \
+				LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_LE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 8) \
+			WriteLE1Byte(__pStart, __Value); \
+		else { \
+			WriteLE1Byte(__pStart, \
+				LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+/*
+* Set subfield of big-endian 4-byte value to specified value.
+*/
+#define SET_BITS_TO_BE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 32) \
+			WriteBE4Byte(__pStart, __Value); \
+		else { \
+			WriteBE4Byte(__pStart, \
+				BE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_BE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 16) \
+			WriteBE2Byte(__pStart, __Value); \
+		else { \
+			WriteBE2Byte(__pStart, \
+				BE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_BE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 8) \
+			WriteBE1Byte(__pStart, __Value); \
+		else { \
+			WriteBE1Byte(__pStart, \
+				BE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+// Get the N-bytes aligment offset from the current length
+#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))
+
+typedef unsigned char	BOOLEAN, *PBOOLEAN, boolean;
+
+#define TEST_FLAG(__Flag,__testFlag)		(((__Flag) & (__testFlag)) != 0)
+#define SET_FLAG(__Flag, __setFlag)			((__Flag) |= __setFlag)
+#define CLEAR_FLAG(__Flag, __clearFlag)		((__Flag) &= ~(__clearFlag))
+#define CLEAR_FLAGS(__Flag)					((__Flag) = 0)
+#define TEST_FLAGS(__Flag, __testFlags)		(((__Flag) & (__testFlags)) == (__testFlags))
+
+#endif //__BASIC_TYPES_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/big_endian.h b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/big_endian.h
new file mode 100644
index 000000000..ccb31328d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/big_endian.h
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include <byteorder/swab.h>
+
+#define __constant_htonl(x) ((__u32)(x))
+#define __constant_ntohl(x) ((__u32)(x))
+#define __constant_htons(x) ((__u16)(x))
+#define __constant_ntohs(x) ((__u16)(x))
+#define __constant_cpu_to_le64(x) ___constant_swab64((x))
+#define __constant_le64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_le32(x) ___constant_swab32((x))
+#define __constant_le32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_le16(x) ___constant_swab16((x))
+#define __constant_le16_to_cpu(x) ___constant_swab16((x))
+#define __constant_cpu_to_be64(x) ((__u64)(x))
+#define __constant_be64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_be32(x) ((__u32)(x))
+#define __constant_be32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_be16(x) ((__u16)(x))
+#define __constant_be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64(x) __swab64((x))
+#define __le64_to_cpu(x) __swab64((x))
+#define __cpu_to_le32(x) __swab32((x))
+#define __le32_to_cpu(x) __swab32((x))
+#define __cpu_to_le16(x) __swab16((x))
+#define __le16_to_cpu(x) __swab16((x))
+#define __cpu_to_be64(x) ((__u64)(x))
+#define __be64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_be32(x) ((__u32)(x))
+#define __be32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_be16(x) ((__u16)(x))
+#define __be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64p(x) __swab64p((x))
+#define __le64_to_cpup(x) __swab64p((x))
+#define __cpu_to_le32p(x) __swab32p((x))
+#define __le32_to_cpup(x) __swab32p((x))
+#define __cpu_to_le16p(x) __swab16p((x))
+#define __le16_to_cpup(x) __swab16p((x))
+#define __cpu_to_be64p(x) (*(__u64*)(x))
+#define __be64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_be32p(x) (*(__u32*)(x))
+#define __be32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_be16p(x) (*(__u16*)(x))
+#define __be16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do {} while (0)
+#define __be64_to_cpus(x) do {} while (0)
+#define __cpu_to_be32s(x) do {} while (0)
+#define __be32_to_cpus(x) do {} while (0)
+#define __cpu_to_be16s(x) do {} while (0)
+#define __be16_to_cpus(x) do {} while (0)
+
+#include <byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/generic.h b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/generic.h
new file mode 100644
index 000000000..759b0c472
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/generic.h
@@ -0,0 +1,213 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/*
+ * linux/byteorder_generic.h
+ * Generic Byte-reordering support
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19970707
+ *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
+ *    cleaned them up.
+ *    I hope it is compliant with non-GCC compilers.
+ *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
+ *    because I wasn't sure it would be ok to put it in types.h
+ *    Upgraded it to 2.1.43
+ * Francois-Rene Rideau <fare@tunes.org> 19971012
+ *    Upgraded it to 2.1.57
+ *    to please Linus T., replaced huge #ifdef's between little/big endian
+ *    by nestedly #include'd files.
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    Made it to 2.1.71; now a facelift:
+ *    Put files under include/linux/byteorder/
+ *    Split swab from generic support.
+ *
+ * TODO:
+ *   = Regular kernel maintainers could also replace all these manual
+ *    byteswap macros that remain, disseminated among drivers,
+ *    after some grep or the sources...
+ *   = Linus might want to rename all these macros and files to fit his taste,
+ *    to fit his personal naming scheme.
+ *   = it seems that a few drivers would also appreciate
+ *    nybble swapping support...
+ *   = every architecture could add their byteswap macro in asm/byteorder.h
+ *    see how some architectures already do (i386, alpha, ppc, etc)
+ *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
+ *    distinguished throughout the kernel. This is not the case currently,
+ *    since little endian, big endian, and pdp endian machines needn't it.
+ *    But this might be the case for, say, a port of Linux to 20/21 bit
+ *    architectures (and F21 Linux addict around?).
+ */
+
+/*
+ * The following macros are to be defined by <asm/byteorder.h>:
+ *
+ * Conversion of long and short int between network and host format
+ *	ntohl(__u32 x)
+ *	ntohs(__u16 x)
+ *	htonl(__u32 x)
+ *	htons(__u16 x)
+ * It seems that some programs (which? where? or perhaps a standard? POSIX?)
+ * might like the above to be functions, not macros (why?).
+ * if that's true, then detect them, and take measures.
+ * Anyway, the measure is: define only ___ntohl as a macro instead,
+ * and in a separate file, have
+ * unsigned long inline ntohl(x){return ___ntohl(x);}
+ *
+ * The same for constant arguments
+ *	__constant_ntohl(__u32 x)
+ *	__constant_ntohs(__u16 x)
+ *	__constant_htonl(__u32 x)
+ *	__constant_htons(__u16 x)
+ *
+ * Conversion of XX-bit integers (16- 32- or 64-)
+ * between native CPU format and little/big endian format
+ * 64-bit stuff only defined for proper architectures
+ *	cpu_to_[bl]eXX(__uXX x)
+ *	[bl]eXX_to_cpu(__uXX x)
+ *
+ * The same, but takes a pointer to the value to convert
+ *	cpu_to_[bl]eXXp(__uXX x)
+ *	[bl]eXX_to_cpup(__uXX x)
+ *
+ * The same, but change in situ
+ *	cpu_to_[bl]eXXs(__uXX x)
+ *	[bl]eXX_to_cpus(__uXX x)
+ *
+ * See asm-foo/byteorder.h for examples of how to provide
+ * architecture-optimized versions
+ *
+ */
+
+
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL) || defined(PLATFORM_FREEBSD)
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+#endif
+
+
+/*
+ * Handle ntohl and suches. These have various compatibility
+ * issues - like we want to give the prototype even though we
+ * also have a macro for them in case some strange program
+ * wants to take the address of the thing or something..
+ *
+ * Note that these used to return a "long" in libc5, even though
+ * long is often 64-bit these days.. Thus the casts.
+ *
+ * They have to be macros in order to do the constant folding
+ * correctly - if the argument passed into a inline function
+ * it is no longer constant according to gcc..
+ */
+
+#undef ntohl
+#undef ntohs
+#undef htonl
+#undef htons
+
+/*
+ * Do the prototypes. Somebody might want to take the
+ * address or some such sick thing..
+ */
+#if defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+extern __u32			ntohl(__u32);
+extern __u32			htonl(__u32);
+#else //defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+#ifndef PLATFORM_FREEBSD
+extern unsigned long int	ntohl(unsigned long int);
+extern unsigned long int	htonl(unsigned long int);
+#endif
+#endif
+#ifndef PLATFORM_FREEBSD
+extern unsigned short int	ntohs(unsigned short int);
+extern unsigned short int	htons(unsigned short int);
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) ||  defined(PLATFORM_MPIXEL)
+
+#define ___htonl(x) __cpu_to_be32(x)
+#define ___htons(x) __cpu_to_be16(x)
+#define ___ntohl(x) __be32_to_cpu(x)
+#define ___ntohs(x) __be16_to_cpu(x)
+
+#if defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+#define htonl(x) ___htonl(x)
+#define ntohl(x) ___ntohl(x)
+#else
+#define htonl(x) ((unsigned long)___htonl(x))
+#define ntohl(x) ((unsigned long)___ntohl(x))
+#endif
+#define htons(x) ___htons(x)
+#define ntohs(x) ___ntohs(x)
+
+#endif /* OPTIMIZE */
+
+
+#if defined (PLATFORM_WINDOWS)
+
+#define htonl(x) __cpu_to_be32(x)
+#define ntohl(x) __be32_to_cpu(x)
+#define htons(x) __cpu_to_be16(x)
+#define ntohs(x) __be16_to_cpu(x)
+
+
+#endif
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/little_endian.h b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/little_endian.h
new file mode 100644
index 000000000..5a3c8ab48
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/little_endian.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#include <byteorder/swab.h>
+
+#ifndef __constant_htonl
+#define __constant_htonl(x) ___constant_swab32((x))
+#define __constant_ntohl(x) ___constant_swab32((x))
+#define __constant_htons(x) ___constant_swab16((x))
+#define __constant_ntohs(x) ___constant_swab16((x))
+#define __constant_cpu_to_le64(x) ((__u64)(x))
+#define __constant_le64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_le32(x) ((__u32)(x))
+#define __constant_le32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_le16(x) ((__u16)(x))
+#define __constant_le16_to_cpu(x) ((__u16)(x))
+#define __constant_cpu_to_be64(x) ___constant_swab64((x))
+#define __constant_be64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_be32(x) ___constant_swab32((x))
+#define __constant_be32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_be16(x) ___constant_swab16((x))
+#define __constant_be16_to_cpu(x) ___constant_swab16((x))
+#define __cpu_to_le64(x) ((__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_le32(x) ((__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_le16(x) ((__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_be64(x) __swab64((x))
+#define __be64_to_cpu(x) __swab64((x))
+#define __cpu_to_be32(x) __swab32((x))
+#define __be32_to_cpu(x) __swab32((x))
+#define __cpu_to_be16(x) __swab16((x))
+#define __be16_to_cpu(x) __swab16((x))
+#define __cpu_to_le64p(x) (*(__u64*)(x))
+#define __le64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_le32p(x) (*(__u32*)(x))
+#define __le32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_le16p(x) (*(__u16*)(x))
+#define __le16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_be64p(x) __swab64p((x))
+#define __be64_to_cpup(x) __swab64p((x))
+#define __cpu_to_be32p(x) __swab32p((x))
+#define __be32_to_cpup(x) __swab32p((x))
+#define __cpu_to_be16p(x) __swab16p((x))
+#define __be16_to_cpup(x) __swab16p((x))
+#define __cpu_to_le64s(x) do {} while (0)
+#define __le64_to_cpus(x) do {} while (0)
+#define __cpu_to_le32s(x) do {} while (0)
+#define __le32_to_cpus(x) do {} while (0)
+#define __cpu_to_le16s(x) do {} while (0)
+#define __le16_to_cpus(x) do {} while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+#endif	// __constant_htonl
+
+#include <byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swab.h b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swab.h
new file mode 100644
index 000000000..067c8e434
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swab.h
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_SWAB_H
+#define _LINUX_BYTEORDER_SWAB_H
+
+#if !defined(CONFIG_PLATFORM_MSTAR)
+#ifndef __u16
+typedef unsigned short __u16;
+#endif
+
+#ifndef __u32
+typedef unsigned int	__u32;
+#endif
+
+#ifndef __u8
+typedef unsigned char __u8;
+#endif
+
+#ifndef __u64
+typedef unsigned long long	__u64;	
+#endif
+
+
+__inline static __u16  ___swab16(__u16 x)
+{
+	__u16 __x = x; 
+	return 
+	((__u16)( 
+		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
+		(((__u16)(__x) & (__u16)0xff00U) >> 8) ));
+
+}
+
+__inline static __u32  ___swab32(__u32 x)
+{
+	__u32 __x = (x);
+	return ((__u32)(
+		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
+		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
+		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24) ));
+}
+
+__inline static __u64  ___swab64(__u64 x)
+{
+	__u64 __x = (x);
+	
+	return 
+	((__u64)( \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
+}
+#endif // CONFIG_PLATFORM_MSTAR
+
+#ifndef __arch__swab16
+__inline static __u16 __arch__swab16(__u16 x)
+{
+	return ___swab16(x);
+}
+
+#endif
+
+#ifndef __arch__swab32
+__inline static __u32 __arch__swab32(__u32 x)
+{
+	__u32 __tmp = (x) ; 
+	return ___swab32(__tmp);
+}
+#endif
+
+#ifndef __arch__swab64
+
+__inline static __u64 __arch__swab64(__u64 x)
+{
+	__u64 __tmp = (x) ; 
+	return ___swab64(__tmp);
+}
+
+
+#endif
+
+#ifndef __swab16
+#define __swab16(x) __fswab16(x)
+#define __swab32(x) __fswab32(x)
+#define __swab64(x) __fswab64(x)
+#endif	// __swab16
+
+#ifdef PLATFORM_FREEBSD
+__inline static __u16 __fswab16(__u16 x)
+#else
+__inline static const __u16 __fswab16(__u16 x)
+#endif //PLATFORM_FREEBSD
+{
+	return __arch__swab16(x);
+}
+#ifdef PLATFORM_FREEBSD
+__inline static __u32 __fswab32(__u32 x)
+#else
+__inline static const __u32 __fswab32(__u32 x)
+#endif //PLATFORM_FREEBSD
+{
+	return __arch__swab32(x);
+}
+
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS)
+#define swab16 __swab16
+#define swab32 __swab32
+#define swab64 __swab64
+#define swab16p __swab16p
+#define swab32p __swab32p
+#define swab64p __swab64p
+#define swab16s __swab16s
+#define swab32s __swab32s
+#define swab64s __swab64s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWAB_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swabb.h b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swabb.h
new file mode 100644
index 000000000..dbbd50f89
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/byteorder/swabb.h
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_SWABB_H
+#define _LINUX_BYTEORDER_SWABB_H
+
+/*
+ * linux/byteorder/swabb.h
+ * SWAp Bytes Bizarrely
+ *	swaHHXX[ps]?(foo)
+ *
+ * Support for obNUXIous pdp-endian and other bizarre architectures.
+ * Will Linux ever run on such ancient beasts? if not, this file
+ * will be but a programming pearl. Still, it's a reminder that we
+ * shouldn't be making too many assumptions when trying to be portable.
+ *
+ */
+
+/*
+ * Meaning of the names I chose (vaxlinux people feel free to correct them):
+ * swahw32	swap 16-bit half-words in a 32-bit word
+ * swahb32	swap 8-bit halves of each 16-bit half-word in a 32-bit word
+ *
+ * No 64-bit support yet. I don't know NUXI conventions for long longs.
+ * I guarantee it will be a mess when it's there, though :->
+ * It will be even worse if there are conflicting 64-bit conventions.
+ * Hopefully, no one ever used 64-bit objects on NUXI machines.
+ *
+ */
+
+#define ___swahw32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x0000ffffUL) << 16) | \
+		(((__u32)(__x) & (__u32)0xffff0000UL) >> 16) )); \
+})
+#define ___swahb32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x00ff00ffUL) << 8) | \
+		(((__u32)(__x) & (__u32)0xff00ff00UL) >> 8) )); \
+})
+
+#define ___constant_swahw32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x0000ffffUL) << 16) | \
+		(((__u32)(x) & (__u32)0xffff0000UL) >> 16) ))
+#define ___constant_swahb32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | \
+		(((__u32)(x) & (__u32)0xff00ff00UL) >> 8) ))
+
+/*
+ * provide defaults when no architecture-specific optimization is detected
+ */
+#ifndef __arch__swahw32
+#  define __arch__swahw32(x) ___swahw32(x)
+#endif
+#ifndef __arch__swahb32
+#  define __arch__swahb32(x) ___swahb32(x)
+#endif
+
+#ifndef __arch__swahw32p
+#  define __arch__swahw32p(x) __swahw32(*(x))
+#endif
+#ifndef __arch__swahb32p
+#  define __arch__swahb32p(x) __swahb32(*(x))
+#endif
+
+#ifndef __arch__swahw32s
+#  define __arch__swahw32s(x) do { *(x) = __swahw32p((x)); } while (0)
+#endif
+#ifndef __arch__swahb32s
+#  define __arch__swahb32s(x) do { *(x) = __swahb32p((x)); } while (0)
+#endif
+
+
+/*
+ * Allow constant folding
+ */
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
+#  define __swahw32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swahw32((x)) : \
+ __fswahw32((x)))
+#  define __swahb32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swahb32((x)) : \
+ __fswahb32((x)))
+#else
+#  define __swahw32(x) __fswahw32(x)
+#  define __swahb32(x) __fswahb32(x)
+#endif /* OPTIMIZE */
+
+
+__inline static__ __const__ __u32 __fswahw32(__u32 x)
+{
+	return __arch__swahw32(x);
+}
+__inline static__ __u32 __swahw32p(__u32 *x)
+{
+	return __arch__swahw32p(x);
+}
+__inline static__ void __swahw32s(__u32 *addr)
+{
+	__arch__swahw32s(addr);
+}
+
+
+__inline static__ __const__ __u32 __fswahb32(__u32 x)
+{
+	return __arch__swahb32(x);
+}
+__inline static__ __u32 __swahb32p(__u32 *x)
+{
+	return __arch__swahb32p(x);
+}
+__inline static__ void __swahb32s(__u32 *addr)
+{
+	__arch__swahb32s(addr);
+}
+
+#ifdef __BYTEORDER_HAS_U64__
+/*
+ * Not supported yet
+ */
+#endif /* __BYTEORDER_HAS_U64__ */
+
+#if defined(PLATFORM_LINUX)
+#define swahw32 __swahw32
+#define swahb32 __swahb32
+#define swahw32p __swahw32p
+#define swahb32p __swahb32p
+#define swahw32s __swahw32s
+#define swahb32s __swahb32s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWABB_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/circ_buf.h b/drivers/net/wireless/realtek/rtl8723cs/include/circ_buf.h
new file mode 100644
index 000000000..455b1d6f7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/circ_buf.h
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __CIRC_BUF_H_
+#define __CIRC_BUF_H_ 1
+
+#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))
+
+#define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))
+
+#endif //_CIRC_BUF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/cmd_osdep.h b/drivers/net/wireless/realtek/rtl8723cs/include/cmd_osdep.h
new file mode 100644
index 000000000..2c77a0af4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/cmd_osdep.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __CMD_OSDEP_H_
+#define __CMD_OSDEP_H_
+
+
+extern sint _rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern sint _rtw_init_evt_priv(struct evt_priv *pevtpriv);
+extern void _rtw_free_evt_priv (struct	evt_priv *pevtpriv);
+extern void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern sint _rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj, bool to_head);
+extern struct cmd_obj *_rtw_dequeue_cmd(_queue *queue);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/custom_gpio.h b/drivers/net/wireless/realtek/rtl8723cs/include/custom_gpio.h
new file mode 100644
index 000000000..c76b340ff
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/custom_gpio.h
@@ -0,0 +1,32 @@
+#ifndef __CUSTOM_GPIO_H__
+#define __CUSTOM_GPIO_H___
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#ifdef PLATFORM_OS_XP
+#include <drv_types_xp.h>
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <drv_types_ce.h>
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <drv_types_linux.h>
+#endif
+
+typedef enum cust_gpio_modes {
+	WLAN_PWDN_ON,
+	WLAN_PWDN_OFF,
+	WLAN_POWER_ON,
+	WLAN_POWER_OFF,
+	WLAN_BT_PWDN_ON,
+	WLAN_BT_PWDN_OFF
+} cust_gpio_modes_t;
+
+extern int rtw_wifi_gpio_init(void);
+extern int rtw_wifi_gpio_deinit(void);
+extern void rtw_wifi_gpio_wlan_ctrl(int onoff);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_conf.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_conf.h
new file mode 100644
index 000000000..049b6d049
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_conf.h
@@ -0,0 +1,190 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_CONF_H__
+#define __DRV_CONF_H__
+#include "autoconf.h"
+#include "hal_ic_cfg.h"
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+//Older Android kernel doesn't has CONFIG_ANDROID defined,
+//add this to force CONFIG_ANDROID defined
+#ifdef CONFIG_PLATFORM_ANDROID
+#ifndef CONFIG_ANDROID
+#define CONFIG_ANDROID
+#endif
+#endif
+
+#ifdef CONFIG_ANDROID
+//Some Android build will restart the UI while non-printable ascii is passed
+//between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID
+//for Android here. If you are sure there is no risk on your system about this,
+//mask this macro define to support non-printable ascii ssid.
+//#define CONFIG_VALIDATE_SSID
+
+//Android expect dbm as the rx signal strength unit
+#define CONFIG_SIGNAL_DISPLAY_DBM
+#endif
+
+/*
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined (CONFIG_RESUME_IN_WORKQUEUE)
+	#warning "You have CONFIG_HAS_EARLYSUSPEND enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
+	#undef CONFIG_RESUME_IN_WORKQUEUE
+#endif
+
+#if defined(CONFIG_ANDROID_POWER) && defined (CONFIG_RESUME_IN_WORKQUEUE)
+	#warning "You have CONFIG_ANDROID_POWER enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
+	#undef CONFIG_RESUME_IN_WORKQUEUE
+#endif
+*/
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE //this can be removed, because there is no case for this...
+	#if !defined( CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
+	#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
+	#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
+	#endif
+#endif
+
+//About USB VENDOR REQ
+#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
+	#define CONFIG_USB_VENDOR_REQ_MUTEX
+#endif
+#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
+	#define CONFIG_USB_VENDOR_REQ_MUTEX
+#endif
+
+#if !defined(CONFIG_AP_MODE) && defined(CONFIG_DFS_MASTER)
+	#warning "undef CONFIG_DFS_MASTER because CONFIG_AP_MODE is not defined"
+	#undef CONFIG_DFS_MASTER
+#endif
+
+#define DYNAMIC_CAMID_ALLOC
+
+#define RTW_SCAN_SPARSE_MIRACAST 1
+#define RTW_SCAN_SPARSE_BG 0
+
+#ifndef CONFIG_RTW_HIQ_FILTER
+	#define CONFIG_RTW_HIQ_FILTER 1
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_EN
+	#define CONFIG_RTW_ADAPTIVITY_EN 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_MODE
+	#define CONFIG_RTW_ADAPTIVITY_MODE 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_DML
+	#define CONFIG_RTW_ADAPTIVITY_DML 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_DC_BACKOFF
+	#define CONFIG_RTW_ADAPTIVITY_DC_BACKOFF 2
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_TH_L2H_INI
+	#define CONFIG_RTW_ADAPTIVITY_TH_L2H_INI 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF
+	#define CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF 0
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_A
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_A {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_B
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_B {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_C
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_C {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_D
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_D {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_A
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_A {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_B
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_B {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_C
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_C {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_D
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_D {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_AMPLIFIER_TYPE_2G
+	#define CONFIG_RTW_AMPLIFIER_TYPE_2G 0
+#endif
+
+#ifndef CONFIG_RTW_AMPLIFIER_TYPE_5G
+	#define CONFIG_RTW_AMPLIFIER_TYPE_5G 0
+#endif
+
+#ifndef CONFIG_RTW_RFE_TYPE
+	#define CONFIG_RTW_RFE_TYPE 64
+#endif
+
+#ifndef CONFIG_RTW_GLNA_TYPE
+	#define CONFIG_RTW_GLNA_TYPE 0
+#endif
+
+#ifndef CONFIG_RTW_PLL_REF_CLK_SEL
+	#define CONFIG_RTW_PLL_REF_CLK_SEL 0x0F
+#endif
+
+#define MACID_NUM_SW_LIMIT 32
+#define SEC_CAM_ENT_NUM_SW_LIMIT 32
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8814A)
+	#define CONFIG_IEEE80211_BAND_5GHZ
+#endif
+
+/*
+	Mark CONFIG_DEAUTH_BEFORE_CONNECT by Arvin 2015/07/20
+	If the failure of Wi-Fi connection is due to some irregular disconnection behavior (like unplug dongle,
+	power down etc.) in last time, we can unmark this flag to avoid some unpredictable response from AP.
+*/
+/*#define CONFIG_DEAUTH_BEFORE_CONNECT */
+
+/*#define CONFIG_WEXT_DONT_JOIN_BYSSID	*/
+//#include <rtl871x_byteorder.h>
+
+
+/*#define CONFIG_DOSCAN_IN_BUSYTRAFFIC	*/
+
+#endif // __DRV_CONF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types.h
new file mode 100644
index 000000000..b49e9712b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types.h
@@ -0,0 +1,1303 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*-------------------------------------------------------------------------------
+
+	For type defines and data structure defines
+
+--------------------------------------------------------------------------------*/
+
+
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+#include <drv_conf.h>
+#include <basic_types.h>
+#include <osdep_service.h>
+#include <rtw_byteorder.h>
+#include <wlan_bssdef.h>
+#include <wifi.h>
+#include <ieee80211.h>
+#ifdef CONFIG_ARP_KEEP_ALIVE
+#include <net/neighbour.h>
+#include <net/arp.h>
+#endif
+
+#ifdef PLATFORM_OS_XP
+#include <drv_types_xp.h>
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <drv_types_ce.h>
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <drv_types_linux.h>
+#endif
+
+enum _NIC_VERSION {
+
+	RTL8711_NIC,
+	RTL8712_NIC,
+	RTL8713_NIC,
+	RTL8716_NIC
+
+};
+
+typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
+
+#include <rtw_debug.h>
+#include <rtw_rf.h>
+
+#ifdef CONFIG_80211N_HT
+#include <rtw_ht.h>
+#endif
+
+#ifdef CONFIG_80211AC_VHT
+#include <rtw_vht.h>
+#endif
+
+#ifdef CONFIG_INTEL_WIDI
+#include <rtw_intel_widi.h>
+#endif
+
+#include <rtw_cmd.h>
+#include <cmd_osdep.h>
+#include <rtw_security.h>
+#include <rtw_xmit.h>
+#include <xmit_osdep.h>
+#include <rtw_recv.h>
+
+#ifdef CONFIG_BEAMFORMING
+#include <rtw_beamforming.h>
+#endif
+
+#include <recv_osdep.h>
+#include <rtw_efuse.h>
+#include <rtw_sreset.h>
+#include <hal_intf.h>
+#include <hal_com.h>
+#include<hal_com_h2c.h>
+#include <hal_com_led.h>
+#include "../hal/hal_dm.h"
+#include <rtw_qos.h>
+#include <rtw_pwrctrl.h>
+#include <rtw_mlme.h>
+#include <mlme_osdep.h>
+#include <rtw_io.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <rtw_ioctl_query.h>
+#include <rtw_ioctl_rtl.h>
+#include <osdep_intf.h>
+#include <rtw_eeprom.h>
+#include <sta_info.h>
+#include <rtw_event.h>
+#include <rtw_mlme_ext.h>
+#include <rtw_ap.h>
+#include <rtw_efuse.h>
+#include <rtw_version.h>
+#include <rtw_odm.h>
+
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+#include <rtw_mem.h>
+#endif
+
+#ifdef CONFIG_P2P
+#include <rtw_p2p.h>
+#endif // CONFIG_P2P
+
+#ifdef CONFIG_TDLS
+#include <rtw_tdls.h>
+#endif // CONFIG_TDLS
+
+#ifdef CONFIG_WAPI_SUPPORT
+#include <rtw_wapi.h>
+#endif // CONFIG_WAPI_SUPPORT
+
+#ifdef CONFIG_DRVEXT_MODULE
+#include <drvext_api.h>
+#endif // CONFIG_DRVEXT_MODULE
+
+#ifdef CONFIG_MP_INCLUDED
+#include <rtw_mp.h>
+#endif // CONFIG_MP_INCLUDED
+
+#ifdef CONFIG_BR_EXT
+#include <rtw_br_ext.h>
+#endif // CONFIG_BR_EXT
+
+#ifdef CONFIG_IOL
+#include <rtw_iol.h>
+#endif // CONFIG_IOL
+
+#include <ip.h>
+#include <if_ether.h>
+#include <ethernet.h>
+#include <circ_buf.h>
+
+#include <rtw_android.h>
+
+#ifdef CONFIG_BT_COEXIST
+#include <rtw_btcoex.h>
+#endif // CONFIG_BT_COEXIST
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
+#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
+#define SPEC_DEV_ID_ASSIGN_IFNAME BIT(5)
+
+struct specific_device_id{
+
+	u32		flags;
+
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv
+{
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	NDIS_802_11_SSID	ssid;
+	u8	network_mode;	//infra, ad-hoc, auto
+	u8	channel;//ad-hoc support requirement
+	u8	wireless_mode;//A, B, G, auto
+	u8	scan_mode;//active, passive
+	u8	radio_enable;
+	u8	preamble;//long, short, auto
+	u8	vrtl_carrier_sense;//Enable, Disable, Auto
+	u8	vcs_type;//RTS/CTS, CTS-to-self
+	u16	rts_thresh;
+	u16	frag_thresh;
+	u8	adhoc_tx_pwr;
+	u8	soft_ap;
+	u8	power_mgnt;
+	u8	ips_mode;
+	u8	smart_ps;
+	u8	usb_rxagg_mode;
+	u8	long_retry_lmt;
+	u8	short_retry_lmt;
+	u16	busy_thresh;
+	u8	ack_policy;
+	u8	mp_mode;
+	u8 	mp_dm;
+	u8	software_encrypt;
+	u8	software_decrypt;
+	#ifdef CONFIG_TX_EARLY_MODE
+	u8   early_mode;
+	#endif
+	u8	acm_method;
+	  //UAPSD
+	u8	wmm_enable;
+	u8	uapsd_enable;
+	u8	uapsd_max_sp;
+	u8	uapsd_acbk_en;
+	u8	uapsd_acbe_en;
+	u8	uapsd_acvi_en;
+	u8	uapsd_acvo_en;
+
+	WLAN_BSSID_EX    dev_network;
+
+#ifdef CONFIG_80211N_HT
+	u8	ht_enable;
+	// 0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz
+	// 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7
+	// 0x21 means enable 2.4G 40MHz & 5G 80MHz
+	u8	bw_mode;
+	u8	ampdu_enable;//for tx
+	u8 	rx_stbc;
+	u8	ampdu_amsdu;//A-MPDU Supports A-MSDU is permitted
+	// Short GI support Bit Map
+	// BIT0 - 20MHz, 1: support, 0: non-support
+	// BIT1 - 40MHz, 1: support, 0: non-support
+	// BIT2 - 80MHz, 1: support, 0: non-support
+	// BIT3 - 160MHz, 1: support, 0: non-support
+	u8	short_gi;
+	// BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx
+	u8	ldpc_cap;
+	// BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx
+	u8	stbc_cap;
+	// BIT0: Enable VHT Beamformer, BIT1: Enable VHT Beamformee, BIT4: Enable HT Beamformer, BIT5: Enable HT Beamformee
+	u8	beamform_cap;
+	u8	beamformer_rf_num;
+	u8	beamformee_rf_num;
+#endif //CONFIG_80211N_HT
+
+#ifdef CONFIG_80211AC_VHT
+	u8	vht_enable; //0:disable, 1:enable, 2:auto
+	u8	ampdu_factor;
+	u8	vht_rate_sel;
+#endif //CONFIG_80211AC_VHT
+
+	u8	lowrate_two_xmit;
+
+	u8	rf_config ;
+	u8	low_power ;
+
+	u8	wifi_spec;// !turbo_mode
+	u8	special_rf_path; // 0: 2T2R ,1: only turn on path A 1T1R
+	u8	channel_plan;
+#ifdef CONFIG_BT_COEXIST
+	u8	btcoex;
+	u8	bt_iso;
+	u8	bt_sco;
+	u8	bt_ampdu;
+	s8	ant_num;
+#endif
+	BOOLEAN	bAcceptAddbaReq;
+
+	u8	antdiv_cfg;
+	u8	antdiv_type;
+
+	u8	switch_usb3;
+
+	u8	usbss_enable;//0:disable,1:enable
+	u8	hwpdn_mode;//0:disable,1:enable,2:decide by EFUSE config
+	u8	hwpwrp_detect;//0:disable,1:enable
+
+	u8	hw_wps_pbc;//0:disable,1:enable
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+	char	adaptor_info_caching_file_path[PATH_LENGTH_MAX];
+#endif
+
+#ifdef CONFIG_LAYER2_ROAMING
+	u8	max_roaming_times; // the max number driver will try to roaming
+#endif
+
+#ifdef CONFIG_IOL
+	u8 fw_iol; //enable iol without other concern
+#endif
+
+#ifdef CONFIG_80211D
+	u8 enable80211d;
+#endif
+
+	u8 ifname[16];
+	u8 if2name[16];
+
+	u8 notch_filter;
+
+#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+	u8 force_ant;//0 normal,1 main,2 aux
+	u8 force_igi;//0 normal
+#endif
+
+	/* for pll reference clock selction */
+	u8 pll_ref_clk_sel;
+
+	//define for tx power adjust
+	u8	RegEnableTxPowerLimit;
+	u8	RegEnableTxPowerByRate;
+	u8	RegPowerBase;
+	u8	RegPwrTblSel;
+
+	u8 target_tx_pwr_valid;
+	s8 target_tx_pwr_2g[RF_PATH_MAX][RATE_SECTION_NUM];
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+	s8 target_tx_pwr_5g[RF_PATH_MAX][RATE_SECTION_NUM - 1];
+#endif
+
+	s8	TxBBSwing_2G;
+	s8	TxBBSwing_5G;
+	u8	AmplifierType_2G;
+	u8	AmplifierType_5G;
+	u8	bEn_RFE;
+	u8	RFE_Type;
+	u8	GLNA_Type;
+	u8  check_fw_ps;
+	u8	RegRfKFreeEnable;
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	u8	load_phy_file;
+	u8	RegDecryptCustomFile;
+#endif
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+	u8 ext_iface_num;//primary/secondary iface is excluded
+#endif
+	u8 qos_opt_enable;
+
+	u8 hiq_filter;
+	u8 adaptivity_en;
+	u8 adaptivity_mode;
+	u8 adaptivity_dml;
+	u8 adaptivity_dc_backoff;
+	s8 adaptivity_th_l2h_ini;
+	s8 adaptivity_th_edcca_hl_diff;
+
+	u8 boffefusemask;
+	BOOLEAN bFileMaskEfuse;
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	u8 acs_mode;
+	u8 acs_auto_scan;
+#endif
+};
+
+//For registry parameters
+#define RGTRY_OFT(field) ((ULONG)FIELD_OFFSET(struct registry_priv,field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv*) 0)->field)
+
+#define GetRegAmplifierType2G(_Adapter)	(_Adapter->registrypriv.AmplifierType_2G)
+#define GetRegAmplifierType5G(_Adapter)	(_Adapter->registrypriv.AmplifierType_5G)
+
+#define GetRegTxBBSwing_2G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_2G)
+#define GetRegTxBBSwing_5G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_5G)
+
+#define GetRegbENRFEType(_Adapter)	(_Adapter->registrypriv.bEn_RFE)
+#define GetRegRFEType(_Adapter)	(_Adapter->registrypriv.RFE_Type)
+#define GetRegGLNAType(_Adapter)	(_Adapter->registrypriv.GLNA_Type)
+
+#define BSSID_OFT(field) ((ULONG)FIELD_OFFSET(WLAN_BSSID_EX,field))
+#define BSSID_SZ(field)   sizeof(((PWLAN_BSSID_EX) 0)->field)
+
+#define REGSTY_BW_2G(regsty) ((regsty)->bw_mode & 0x0F)
+#define REGSTY_BW_5G(regsty) (((regsty)->bw_mode) >> 4)
+#define REGSTY_IS_BW_2G_SUPPORT(regsty, bw) (REGSTY_BW_2G((regsty)) >= (bw))
+#define REGSTY_IS_BW_5G_SUPPORT(regsty, bw) (REGSTY_BW_5G((regsty)) >= (bw))
+
+#define REGSTY_IS_11AC_ENABLE(regsty) ((regsty)->vht_enable != 0)
+#define REGSTY_IS_11AC_AUTO(regsty) ((regsty)->vht_enable == 2)
+
+#ifdef CONFIG_SDIO_HCI
+#include <drv_types_sdio.h>
+#define INTF_DATA SDIO_DATA
+#elif defined(CONFIG_GSPI_HCI)
+#include <drv_types_gspi.h>
+#define INTF_DATA GSPI_DATA
+#elif defined(CONFIG_PCI_HCI)
+#include <drv_types_pci.h>
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+#define is_primary_adapter(adapter) (adapter->adapter_type == PRIMARY_ADAPTER)
+#define is_vir_adapter(adapter) (adapter->adapter_type == MAX_ADAPTER)
+#define get_iface_type(adapter) (adapter->iface_type)
+#else
+#define is_primary_adapter(adapter) (1)
+#define is_vir_adapter(adapter) (0)
+#define get_iface_type(adapter) (IFACE_PORT0)
+#endif
+#define GET_PRIMARY_ADAPTER(padapter) (((_adapter *)padapter)->dvobj->padapters[IFACE_ID0])
+#define GET_IFACE_NUMS(padapter) (((_adapter *)padapter)->dvobj->iface_nums)
+#define GET_ADAPTER(padapter, iface_id) (((_adapter *)padapter)->dvobj->padapters[iface_id])
+
+#define GetDefaultAdapter(padapter)	padapter
+
+enum _IFACE_ID {
+	IFACE_ID0, //maping to PRIMARY_ADAPTER
+	IFACE_ID1, //maping to SECONDARY_ADAPTER
+	IFACE_ID2,
+	IFACE_ID3,
+	IFACE_ID_MAX,
+};
+
+#ifdef CONFIG_DBG_COUNTER
+
+struct rx_logs {
+	u32 intf_rx;
+	u32 intf_rx_err_recvframe;
+	u32 intf_rx_err_skb;
+	u32 intf_rx_report;
+	u32 core_rx;
+	u32 core_rx_pre;
+	u32 core_rx_pre_ver_err;
+	u32 core_rx_pre_mgmt;
+	u32 core_rx_pre_mgmt_err_80211w;
+	u32 core_rx_pre_mgmt_err;
+	u32 core_rx_pre_ctrl;
+	u32 core_rx_pre_ctrl_err;
+	u32 core_rx_pre_data;
+	u32 core_rx_pre_data_wapi_seq_err;
+	u32 core_rx_pre_data_wapi_key_err;
+	u32 core_rx_pre_data_handled;
+	u32 core_rx_pre_data_err;
+	u32 core_rx_pre_data_unknown;
+	u32 core_rx_pre_unknown;
+	u32 core_rx_enqueue;
+	u32 core_rx_dequeue;
+	u32 core_rx_post;
+	u32 core_rx_post_decrypt;
+	u32 core_rx_post_decrypt_wep;
+	u32 core_rx_post_decrypt_tkip;
+	u32 core_rx_post_decrypt_aes;
+	u32 core_rx_post_decrypt_wapi;
+	u32 core_rx_post_decrypt_hw;
+	u32 core_rx_post_decrypt_unknown;
+	u32 core_rx_post_decrypt_err;
+	u32 core_rx_post_defrag_err;
+	u32 core_rx_post_portctrl_err;
+	u32 core_rx_post_indicate;
+	u32 core_rx_post_indicate_in_oder;
+	u32 core_rx_post_indicate_reoder;
+	u32 core_rx_post_indicate_err;
+	u32 os_indicate;
+	u32 os_indicate_ap_mcast;
+	u32 os_indicate_ap_forward;
+	u32 os_indicate_ap_self;
+	u32 os_indicate_err;
+	u32 os_netif_ok;
+	u32 os_netif_err;
+};
+
+struct tx_logs {
+	u32 os_tx;
+	u32 os_tx_err_up;
+	u32 os_tx_err_xmit;
+	u32 os_tx_m2u;
+	u32 os_tx_m2u_ignore_fw_linked;
+	u32 os_tx_m2u_ignore_self;
+	u32 os_tx_m2u_entry;
+	u32 os_tx_m2u_entry_err_xmit;
+	u32 os_tx_m2u_entry_err_skb;
+	u32 os_tx_m2u_stop;
+	u32 core_tx;
+	u32 core_tx_err_pxmitframe;
+	u32 core_tx_err_brtx;
+	u32 core_tx_upd_attrib;
+	u32 core_tx_upd_attrib_adhoc;
+	u32 core_tx_upd_attrib_sta;
+	u32 core_tx_upd_attrib_ap;
+	u32 core_tx_upd_attrib_unknown;
+	u32 core_tx_upd_attrib_dhcp;
+	u32 core_tx_upd_attrib_icmp;
+	u32 core_tx_upd_attrib_active;
+	u32 core_tx_upd_attrib_err_ucast_sta;
+	u32 core_tx_upd_attrib_err_ucast_ap_link;
+	u32 core_tx_upd_attrib_err_sta;
+	u32 core_tx_upd_attrib_err_link;
+	u32 core_tx_upd_attrib_err_sec;
+	u32 core_tx_ap_enqueue_warn_fwstate;
+	u32 core_tx_ap_enqueue_warn_sta;
+	u32 core_tx_ap_enqueue_warn_nosta;
+	u32 core_tx_ap_enqueue_warn_link;
+	u32 core_tx_ap_enqueue_warn_trigger;
+	u32 core_tx_ap_enqueue_mcast;
+	u32 core_tx_ap_enqueue_ucast;
+	u32 core_tx_ap_enqueue;
+	u32 intf_tx;
+	u32 intf_tx_pending_ac;
+	u32 intf_tx_pending_fw_under_survey;
+	u32 intf_tx_pending_fw_under_linking;
+	u32 intf_tx_pending_xmitbuf;
+	u32 intf_tx_enqueue;
+	u32 core_tx_enqueue;
+	u32 core_tx_enqueue_class;
+	u32 core_tx_enqueue_class_err_sta;
+	u32 core_tx_enqueue_class_err_nosta;
+	u32 core_tx_enqueue_class_err_fwlink;
+	u32 intf_tx_direct;
+	u32 intf_tx_direct_err_coalesce;
+	u32 intf_tx_dequeue;
+	u32 intf_tx_dequeue_err_coalesce;
+	u32 intf_tx_dump_xframe;
+	u32 intf_tx_dump_xframe_err_txdesc;
+	u32 intf_tx_dump_xframe_err_port;
+};
+
+struct int_logs {
+	u32 all;
+	u32 err;
+	u32 tbdok;
+	u32 tbder;
+	u32 bcnderr;
+	u32 bcndma;
+	u32 bcndma_e;
+	u32 rx;
+	u32 rx_rdu;
+	u32 rx_fovw;
+	u32 txfovw;
+	u32 mgntok;
+	u32 highdok;
+	u32 bkdok;
+	u32 bedok;
+	u32 vidok;
+	u32 vodok;
+};
+
+#endif // CONFIG_DBG_COUNTER
+
+struct debug_priv {
+	u32 dbg_sdio_free_irq_error_cnt;
+	u32 dbg_sdio_alloc_irq_error_cnt;
+	u32 dbg_sdio_free_irq_cnt;
+	u32 dbg_sdio_alloc_irq_cnt;
+	u32 dbg_sdio_deinit_error_cnt;
+	u32 dbg_sdio_init_error_cnt;
+	u32 dbg_suspend_error_cnt;
+	u32 dbg_suspend_cnt;
+	u32 dbg_resume_cnt;
+	u32 dbg_resume_error_cnt;
+	u32 dbg_deinit_fail_cnt;
+	u32 dbg_carddisable_cnt;
+	u32 dbg_carddisable_error_cnt;
+	u32 dbg_ps_insuspend_cnt;
+	u32	dbg_dev_unload_inIPS_cnt;
+	u32 dbg_wow_leave_ps_fail_cnt;
+	u32 dbg_scan_pwr_state_cnt;
+	u32 dbg_downloadfw_pwr_state_cnt;
+	u32 dbg_fw_read_ps_state_fail_cnt;
+	u32 dbg_leave_ips_fail_cnt;
+	u32 dbg_leave_lps_fail_cnt;
+	u32 dbg_h2c_leave32k_fail_cnt;
+	u32 dbg_diswow_dload_fw_fail_cnt;
+	u32 dbg_enwow_dload_fw_fail_cnt;
+	u32 dbg_ips_drvopen_fail_cnt;
+	u32 dbg_poll_fail_cnt;
+	u32 dbg_rpwm_toogle_cnt;
+	u32 dbg_rpwm_timeout_fail_cnt;
+	u32 dbg_sreset_cnt;
+	u64 dbg_rx_fifo_last_overflow;
+	u64 dbg_rx_fifo_curr_overflow;
+	u64 dbg_rx_fifo_diff_overflow;
+	u64 dbg_rx_ampdu_drop_count;
+	u64 dbg_rx_ampdu_forced_indicate_count;
+	u64 dbg_rx_ampdu_loss_count;
+	u64 dbg_rx_dup_mgt_frame_drop_count;
+	u64 dbg_rx_ampdu_window_shift_cnt;
+	u64 dbg_rx_conflic_mac_addr_cnt;
+};
+
+struct rtw_traffic_statistics {
+	// tx statistics
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u64	cur_tx_bytes;
+	u64	last_tx_bytes;
+	u32	cur_tx_tp; // Tx throughput in MBps.
+
+	// rx statistics
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+	u64	cur_rx_bytes;
+	u64	last_rx_bytes;
+	u32	cur_rx_tp; // Rx throughput in MBps.
+};
+
+#define SEC_CAP_CHK_BMC	BIT0
+
+#define SEC_STATUS_STA_PK_GK_CONFLICT_DIS_BMC_SEARCH	BIT0
+
+struct sec_cam_bmp {
+	u32 m0;
+#if (SEC_CAM_ENT_NUM_SW_LIMIT > 32)
+	u32 m1;
+#endif
+#if (SEC_CAM_ENT_NUM_SW_LIMIT > 64)
+	u32 m2;
+#endif
+#if (SEC_CAM_ENT_NUM_SW_LIMIT > 96)
+	u32 m3;
+#endif
+};
+
+struct cam_ctl_t {
+	_lock lock;
+
+	u8 sec_cap;
+	u32 flags;
+
+	u8 num;
+	struct sec_cam_bmp used;
+
+	_mutex sec_cam_access_mutex;
+};
+
+struct sec_cam_ent {
+	u16 ctrl;
+	u8 mac[ETH_ALEN];
+	u8 key[16];
+};
+
+#define KEY_FMT "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
+#define KEY_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5], \
+	((u8*)(x))[6],((u8*)(x))[7],((u8*)(x))[8],((u8*)(x))[9],((u8*)(x))[10],((u8*)(x))[11], \
+	((u8*)(x))[12],((u8*)(x))[13],((u8*)(x))[14],((u8*)(x))[15]
+
+struct macid_bmp {
+	u32 m0;
+#if (MACID_NUM_SW_LIMIT > 32)
+	u32 m1;
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	u32 m2;
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	u32 m3;
+#endif
+};
+
+struct macid_ctl_t {
+	_lock lock;
+	u8 num;
+	struct macid_bmp used;
+	struct macid_bmp bmc;
+	struct macid_bmp if_g[IFACE_ID_MAX];
+	struct macid_bmp ch_g[2]; /* 2 ch concurrency */
+	u8 h2c_msr[MACID_NUM_SW_LIMIT];
+};
+
+struct rf_ctl_t {
+	#ifdef CONFIG_DFS_MASTER
+	bool radar_detect_by_sta_link;
+	bool pre_radar_detect_by_sta_link;
+	bool dfs_master_enabled;
+
+	u8 radar_detect_ch;
+	u8 radar_detect_bw;
+	u8 radar_detect_offset;
+	u8 pre_radar_detect_ch;
+	u8 pre_radar_detect_bw;
+	u8 pre_radar_detect_offset;
+
+	u32 cac_end_time;
+
+	u8 dbg_dfs_master_fake_radar_detect_cnt;
+	u8 dbg_dfs_master_radar_detect_trigger_non;
+	u8 dbg_dfs_master_choose_dfs_ch_first;
+	#endif
+};
+
+#define RTW_CAC_STOPPED 0
+#define IS_UNDER_CAC(rfctl) ((rfctl)->cac_end_time > rtw_get_current_time())
+#define IS_CAC_STOPPED(rfctl) ((rfctl)->cac_end_time == RTW_CAC_STOPPED)
+
+struct dvobj_priv
+{
+	/*-------- below is common data --------*/
+	u8	chip_type;
+	u8	HardwareType;
+	u8	interface_type;/*USB,SDIO,SPI,PCI*/
+
+	ATOMIC_T	bSurpriseRemoved;
+	ATOMIC_T	bDriverStopped;
+
+	s32	processing_dev_remove;
+
+	struct debug_priv drv_dbg;
+
+	_mutex hw_init_mutex;
+	_mutex h2c_fwcmd_mutex;
+	_mutex setch_mutex;
+	_mutex setbw_mutex;
+	_mutex rf_read_reg_mutex;
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+	_mutex sd_indirect_access_mutex;
+#endif
+
+	unsigned char	oper_channel; //saved channel info when call set_channel_bw
+	unsigned char	oper_bwmode;
+	unsigned char	oper_ch_offset;//PRIME_CHNL_OFFSET
+	u32 on_oper_ch_time;
+
+	//extend to support mulitu interface
+	/*padapters[IFACE_ID0] == if1 - PRIMARY_ADAPTER*/
+	/*padapters[IFACE_ID1] == if2 - SECONDARY_ADAPTER*/
+	_adapter *padapters[IFACE_ID_MAX];
+	u8 iface_nums; // total number of ifaces used runtime
+
+	struct macid_ctl_t macid_ctl;
+
+	struct cam_ctl_t cam_ctl;
+	struct sec_cam_ent cam_cache[SEC_CAM_ENT_NUM_SW_LIMIT];
+
+	struct rf_ctl_t rf_ctl;
+
+	//For 92D, DMDP have 2 interface.
+	u8	InterfaceNumber;
+	u8	NumInterfaces;
+
+	//In /Out Pipe information
+	int	RtInPipe[2];
+	int	RtOutPipe[4];
+	u8	Queue2Pipe[HW_QUEUE_ENTRY];//for out pipe mapping
+
+	u8	irq_alloc;
+	ATOMIC_T continual_io_error;
+
+	ATOMIC_T disable_func;
+
+	struct pwrctrl_priv pwrctl_priv;
+
+	struct rtw_traffic_statistics	traffic_stat;
+
+#if defined(CONFIG_IOCTL_CFG80211) && defined(RTW_SINGLE_WIPHY)
+	struct wiphy *wiphy;
+#endif
+
+/*-------- below is for SDIO INTERFACE --------*/
+
+#ifdef INTF_DATA
+	INTF_DATA intf_data;
+#endif
+
+/*-------- below is for USB INTERFACE --------*/
+
+#ifdef CONFIG_USB_HCI
+
+	u8	usb_speed; // 1.1, 2.0 or 3.0
+	u8	nr_endpoint;
+	u8	RtNumInPipes;
+	u8	RtNumOutPipes;
+	int	ep_num[6]; //endpoint number
+
+	int	RegUsbSS;
+
+	_sema	usb_suspend_sema;
+
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	_mutex  usb_vendor_req_mutex;
+#endif
+
+#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+	u8 * usb_alloc_vendor_req_buf;
+	u8 * usb_vendor_req_buf;
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	//related device objects
+	PDEVICE_OBJECT	pphysdevobj;//pPhysDevObj;
+	PDEVICE_OBJECT	pfuncdevobj;//pFuncDevObj;
+	PDEVICE_OBJECT	pnextdevobj;//pNextDevObj;
+
+	u8	nextdevstacksz;//unsigned char NextDeviceStackSize;	//= (CHAR)CEdevice->pUsbDevObj->StackSize + 1;
+
+	//urb for control diescriptor request
+
+#ifdef PLATFORM_OS_XP
+	struct _URB_CONTROL_DESCRIPTOR_REQUEST descriptor_urb;
+	PUSB_CONFIGURATION_DESCRIPTOR	pconfig_descriptor;//UsbConfigurationDescriptor;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	WCHAR			active_path[MAX_ACTIVE_REG_PATH];	// adapter regpath
+	USB_EXTENSION	usb_extension;
+
+	_nic_hdl		pipehdls_r8192c[0x10];
+#endif
+
+	u32	config_descriptor_len;//ULONG UsbConfigurationDescriptorLength;
+#endif//PLATFORM_WINDOWS
+
+#ifdef PLATFORM_LINUX
+	struct usb_interface *pusbintf;
+	struct usb_device *pusbdev;
+#endif//PLATFORM_LINUX
+
+#ifdef PLATFORM_FREEBSD
+	struct usb_interface *pusbintf;
+	struct usb_device *pusbdev;
+#endif//PLATFORM_FREEBSD
+
+#endif//CONFIG_USB_HCI
+
+/*-------- below is for PCIE INTERFACE --------*/
+
+#ifdef CONFIG_PCI_HCI
+
+#ifdef PLATFORM_LINUX
+	struct pci_dev *ppcidev;
+
+	//PCI MEM map
+	unsigned long	pci_mem_end;	/* shared mem end	*/
+	unsigned long	pci_mem_start;	/* shared mem start	*/
+
+	//PCI IO map
+	unsigned long	pci_base_addr;	/* device I/O address	*/
+
+	//PciBridge
+	struct pci_priv	pcipriv;
+
+	unsigned int irq; /* get from pci_dev.irq, store to net_device.irq */
+	u16	irqline;
+	u8	irq_enabled;
+	RT_ISR_CONTENT	isr_content;
+	_lock	irq_th_lock;
+
+	//ASPM
+	u8	const_pci_aspm;
+	u8	const_amdpci_aspm;
+	u8	const_hwsw_rfoff_d3;
+	u8	const_support_pciaspm;
+	// pci-e bridge */
+	u8 	const_hostpci_aspm_setting;
+	// pci-e device */
+	u8 	const_devicepci_aspm_setting;
+	u8 	b_support_aspm; // If it supports ASPM, Offset[560h] = 0x40, otherwise Offset[560h] = 0x00.
+	u8	b_support_backdoor;
+	u8	bdma64;
+#endif//PLATFORM_LINUX
+
+#endif//CONFIG_PCI_HCI
+};
+
+#define dvobj_to_pwrctl(dvobj) (&(dvobj->pwrctl_priv))
+#define pwrctl_to_dvobj(pwrctl) container_of(pwrctl, struct dvobj_priv, pwrctl_priv)
+#define dvobj_to_macidctl(dvobj) (&(dvobj->macid_ctl))
+#define dvobj_to_regsty(dvobj) (&(dvobj->padapters[IFACE_ID0]->registrypriv))
+#if defined(CONFIG_IOCTL_CFG80211) && defined(RTW_SINGLE_WIPHY)
+#define dvobj_to_wiphy(dvobj) ((dvobj)->wiphy)
+#endif
+#define dvobj_to_rfctl(dvobj) (&(dvobj->rf_ctl))
+#define rfctl_to_dvobj(rfctl) container_of((rfctl), struct dvobj_priv, rf_ctl)
+
+#ifdef PLATFORM_LINUX
+static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
+{
+	/* todo: get interface type from dvobj and the return the dev accordingly */
+#ifdef RTW_DVOBJ_CHIP_HW_TYPE
+#endif
+
+#ifdef CONFIG_USB_HCI
+	return &dvobj->pusbintf->dev;
+#endif
+#ifdef CONFIG_SDIO_HCI
+	return &dvobj->intf_data.func->dev;
+#endif
+#ifdef CONFIG_GSPI_HCI
+	return &dvobj->intf_data.func->dev;
+#endif
+#ifdef CONFIG_PCI_HCI
+	return &dvobj->ppcidev->dev;
+#endif
+}
+#endif
+
+_adapter *dvobj_get_port0_adapter(struct dvobj_priv *dvobj);
+
+enum _IFACE_TYPE {
+	IFACE_PORT0, //mapping to port0 for C/D series chips
+	IFACE_PORT1, //mapping to port1 for C/D series chip
+	MAX_IFACE_PORT,
+};
+
+enum _ADAPTER_TYPE {
+	PRIMARY_ADAPTER,
+	SECONDARY_ADAPTER,
+	MAX_ADAPTER = 0xFF,
+};
+
+typedef enum _DRIVER_STATE{
+	DRIVER_NORMAL = 0,
+	DRIVER_DISAPPEAR = 1,
+	DRIVER_REPLACE_DONGLE = 2,
+}DRIVER_STATE;
+
+#ifdef CONFIG_INTEL_PROXIM
+struct proxim {
+	bool proxim_support;
+	bool proxim_on;
+
+	void *proximity_priv;
+	int (*proxim_rx)(_adapter *padapter,
+		union recv_frame *precv_frame);
+	u8	(*proxim_get_var)(_adapter* padapter, u8 type);
+};
+#endif	//CONFIG_INTEL_PROXIM
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+typedef struct loopbackdata
+{
+	_sema	sema;
+	_thread_hdl_ lbkthread;
+	u8 bstop;
+	u32 cnt;
+	u16 size;
+	u16 txsize;
+	u8 txbuf[0x8000];
+	u16 rxsize;
+	u8 rxbuf[0x8000];
+	u8 msg[100];
+
+}LOOPBACKDATA, *PLOOPBACKDATA;
+#endif
+
+struct _ADAPTER{
+	int	DriverState;// for disable driver using module, use dongle to replace module.
+	int	pid[3];//process id from UI, 0:wps, 1:hostapd, 2:dhcpcd
+	int	bDongle;//build-in module or external dongle
+
+	struct dvobj_priv *dvobj;
+	struct	mlme_priv mlmepriv;
+	struct	mlme_ext_priv mlmeextpriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	//struct	io_queue	*pio_queue;
+	struct 	io_priv	iopriv;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	_lock   security_key_mutex; // add for CONFIG_IEEE80211W, none 11w also can use
+	struct	registry_priv	registrypriv;
+
+	struct	led_priv	ledpriv;
+
+#ifdef CONFIG_MP_INCLUDED
+       struct	mp_priv	mppriv;
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+	struct	drvext_priv	drvextpriv;
+#endif
+
+#ifdef CONFIG_AP_MODE
+	struct	hostapd_priv	*phostapdpriv;
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+#ifdef CONFIG_P2P
+	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
+#endif //CONFIG_P2P
+#endif //CONFIG_IOCTL_CFG80211
+	u32	setband;
+#ifdef CONFIG_P2P
+	struct wifidirect_info	wdinfo;
+#endif //CONFIG_P2P
+
+#ifdef CONFIG_TDLS
+	struct tdls_info	tdlsinfo;
+#endif //CONFIG_TDLS
+
+#ifdef CONFIG_WAPI_SUPPORT
+	u8	WapiSupport;
+	RT_WAPI_T	wapiInfo;
+#endif
+
+
+#ifdef CONFIG_WFD
+	struct wifi_display_info wfd_info;
+#endif //CONFIG_WFD
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	struct bt_coex_info coex_info;
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+
+	ERROR_CODE		LastError; /* <20130613, Kordan> Only the functions associated with MP records the error code by now. */
+
+	PVOID			HalData;
+	u32 hal_data_sz;
+	struct hal_ops	HalFunc;
+
+	u32	IsrContent;
+	u32	ImrContent;
+
+	u8	EepromAddressSize;
+	u8	bDriverIsGoingToUnload;
+	u8	init_adpt_in_progress;
+	u8	bHaltInProgress;
+#ifdef CONFIG_GPIO_API
+	u8	pre_gpio_pin;
+	struct gpio_int_priv {
+		u8 interrupt_mode;
+		u8 interrupt_enable_mask;
+		void (*callback[8])(u8 level);
+	}gpiointpriv;
+#endif
+	_thread_hdl_ cmdThread;
+	_thread_hdl_ evtThread;
+	_thread_hdl_ xmitThread;
+	_thread_hdl_ recvThread;
+
+#ifndef PLATFORM_LINUX
+	NDIS_STATUS (*dvobj_init)(struct dvobj_priv *dvobj);
+	void (*dvobj_deinit)(struct dvobj_priv *dvobj);
+#endif
+
+ 	u32 (*intf_init)(struct dvobj_priv *dvobj);
+	void (*intf_deinit)(struct dvobj_priv *dvobj);
+	int (*intf_alloc_irq)(struct dvobj_priv *dvobj);
+	void (*intf_free_irq)(struct dvobj_priv *dvobj);
+
+
+	void (*intf_start)(_adapter * adapter);
+	void (*intf_stop)(_adapter * adapter);
+
+#ifdef PLATFORM_WINDOWS
+	_nic_hdl		hndis_adapter;//hNdisAdapter(NDISMiniportAdapterHandle);
+	_nic_hdl		hndis_config;//hNdisConfiguration;
+	NDIS_STRING fw_img;
+
+	u32	NdisPacketFilter;
+	u8	MCList[MAX_MCAST_LIST_NUM][6];
+	u32	MCAddrCount;
+#endif //end of PLATFORM_WINDOWS
+
+
+#ifdef PLATFORM_LINUX
+	_nic_hdl pnetdev;
+	char old_ifname[IFNAMSIZ];
+
+	// used by rtw_rereg_nd_name related function
+	struct rereg_nd_name_data {
+		_nic_hdl old_pnetdev;
+		char old_ifname[IFNAMSIZ];
+		u8 old_ips_mode;
+		u8 old_bRegUseLed;
+	} rereg_nd_name_priv;
+
+	u8 ndev_unregistering;
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+	struct proc_dir_entry *dir_dev;// for proc directory
+	struct proc_dir_entry *dir_odm;
+
+#ifdef CONFIG_IOCTL_CFG80211
+	struct wireless_dev *rtw_wdev;
+	struct rtw_wdev_priv wdev_data;
+
+	#if !defined(RTW_SINGLE_WIPHY)
+	struct wiphy *wiphy;
+	#endif
+
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+#endif /* PLATFORM_LINUX */
+
+#ifdef PLATFORM_FREEBSD
+	_nic_hdl pifp;
+	int bup;
+	_lock glock;
+#endif //PLATFORM_FREEBSD
+	u8 mac_addr[ETH_ALEN];
+	int net_closed;
+
+	u8 netif_up;
+
+	u8 bFWReady;
+	u8 bBTFWReady;
+	u8 bLinkInfoDump;
+	u8 bRxRSSIDisplay;
+	//	Added by Albert 2012/10/26
+	//	The driver will show up the desired channel number when this flag is 1.
+	u8 bNotifyChannelChange;
+#ifdef CONFIG_P2P
+	//	Added by Albert 2012/12/06
+	//	The driver will show the current P2P status when the upper application reads it.
+	u8 bShowGetP2PState;
+#endif
+#ifdef CONFIG_AUTOSUSPEND
+	u8	bDisableAutosuspend;
+#endif
+
+	//pbuddy_adapter is used only in  two inteface case, (iface_nums=2 in struct dvobj_priv)
+	//PRIMARY_ADAPTER's buddy is SECONDARY_ADAPTER
+	//SECONDARY_ADAPTER's buddy is PRIMARY_ADAPTER
+	//for iface_id > SECONDARY_ADAPTER(IFACE_ID1), refer to padapters[iface_id]  in struct dvobj_priv
+	//and their pbuddy_adapter is PRIMARY_ADAPTER.
+	//for PRIMARY_ADAPTER(IFACE_ID0) can directly refer to if1 in struct dvobj_priv
+	_adapter *pbuddy_adapter;
+
+#if defined(CONFIG_CONCURRENT_MODE)
+	u8 isprimary; //is primary adapter or not
+	//notes:
+	// if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER
+	// if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for SECONDARY_ADAPTER
+	// refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff.
+	u8 adapter_type;//used only in  two inteface case(PRIMARY_ADAPTER and SECONDARY_ADAPTER) .
+	u8 iface_type; //interface port type, it depends on HW port
+#endif //CONFIG_CONCURRENT_MODE
+
+	//extend to support multi interface
+       //IFACE_ID0 is equals to PRIMARY_ADAPTER
+       //IFACE_ID1 is equals to SECONDARY_ADAPTER
+	u8 iface_id;
+
+#ifdef CONFIG_BR_EXT
+	_lock					br_ext_lock;
+	//unsigned int			macclone_completed;
+	struct nat25_network_db_entry	*nethash[NAT25_HASH_SIZE];
+	int				pppoe_connection_in_progress;
+	unsigned char			pppoe_addr[MACADDRLEN];
+	unsigned char			scdb_mac[MACADDRLEN];
+	unsigned char			scdb_ip[4];
+	struct nat25_network_db_entry	*scdb_entry;
+	unsigned char			br_mac[MACADDRLEN];
+	unsigned char			br_ip[4];
+
+	struct br_ext_info		ethBrExtInfo;
+#endif	// CONFIG_BR_EXT
+
+#ifdef CONFIG_INTEL_PROXIM
+	/* intel Proximity, should be alloc mem
+	 * in intel Proximity module and can only
+	 * be used in intel Proximity mode */
+	struct proxim proximity;
+#endif	//CONFIG_INTEL_PROXIM
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+	PLOOPBACKDATA ploopback;
+#endif
+
+	//for debug purpose
+	u8 fix_rate;
+	u8 data_fb; /* data rate fallback, valid only when fix_rate is not 0xff */
+	u8 driver_vcs_en; //Enable=1, Disable=0 driver control vrtl_carrier_sense for tx
+	u8 driver_vcs_type;//force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1.
+	u8 driver_ampdu_spacing;//driver control AMPDU Density for peer sta's rx
+	u8 driver_rx_ampdu_factor;//0xff: disable drv ctrl, 0:8k, 1:16k, 2:32k, 3:64k;
+	u8 driver_rx_ampdu_spacing;  //driver control Rx AMPDU Density
+	u8 fix_rx_ampdu_accept;
+	u8 fix_rx_ampdu_size; /* 0~127, TODO:consider each sta and each TID */
+	unsigned char     in_cta_test;
+#ifdef DBG_RX_COUNTER_DUMP
+	u8 dump_rx_cnt_mode;/*BIT0:drv,BIT1:mac,BIT2:phy*/
+	u32 drv_rx_cnt_ok;
+	u32 drv_rx_cnt_crcerror;
+	u32 drv_rx_cnt_drop;
+#endif
+
+#ifdef CONFIG_DBG_COUNTER
+	struct rx_logs rx_logs;
+	struct tx_logs tx_logs;
+	struct int_logs int_logs;
+#endif
+};
+
+#define adapter_to_dvobj(adapter) ((adapter)->dvobj)
+#define adapter_to_regsty(adapter) dvobj_to_regsty(adapter_to_dvobj((adapter)))
+#define adapter_to_pwrctl(adapter) dvobj_to_pwrctl(adapter_to_dvobj((adapter)))
+#define adapter_wdev_data(adapter) (&((adapter)->wdev_data))
+#if defined(RTW_SINGLE_WIPHY)
+#define adapter_to_wiphy(adapter) dvobj_to_wiphy(adapter_to_dvobj(adapter))
+#else
+#define adapter_to_wiphy(adapter) ((adapter)->wiphy)
+#endif
+
+#define adapter_to_rfctl(adapter) dvobj_to_rfctl(adapter_to_dvobj((adapter)))
+
+#define adapter_mac_addr(adapter) (adapter->mac_addr)
+
+#define mlme_to_adapter(mlme) container_of((mlme), struct _ADAPTER, mlmepriv)
+#define tdls_info_to_adapter(tdls) container_of((tdls), struct _ADAPTER, tdlsinfo)
+
+#define rtw_get_chip_type(adapter) (((PADAPTER)adapter)->dvobj->chip_type)
+#define rtw_get_hw_type(adapter) (((PADAPTER)adapter)->dvobj->HardwareType)
+#define rtw_get_intf_type(adapter) (((PADAPTER)adapter)->dvobj->interface_type)
+
+static inline void rtw_set_surprise_removed(_adapter *padapter)
+{
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->bSurpriseRemoved, _TRUE);
+}
+static inline void rtw_clr_surprise_removed(_adapter *padapter)
+{
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->bSurpriseRemoved, _FALSE);
+}
+static inline void rtw_set_drv_stopped(_adapter *padapter)
+{
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->bDriverStopped, _TRUE);
+}
+static inline void rtw_clr_drv_stopped(_adapter *padapter)
+{
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->bDriverStopped, _FALSE);
+}
+#define rtw_is_surprise_removed(padapter)	(ATOMIC_READ(&adapter_to_dvobj(padapter)->bSurpriseRemoved) == _TRUE)
+#define rtw_is_drv_stopped(padapter)		(ATOMIC_READ(&adapter_to_dvobj(padapter)->bDriverStopped) == _TRUE)
+
+//
+// Function disabled.
+//
+#define DF_TX_BIT		BIT0			/*write_port_cancel*/
+#define DF_RX_BIT		BIT1			/*read_port_cancel*/
+#define DF_IO_BIT		BIT2
+
+//#define RTW_DISABLE_FUNC(padapter, func) (ATOMIC_ADD(&adapter_to_dvobj(padapter)->disable_func, (func)))
+//#define RTW_ENABLE_FUNC(padapter, func) (ATOMIC_SUB(&adapter_to_dvobj(padapter)->disable_func, (func)))
+__inline static void RTW_DISABLE_FUNC(_adapter*padapter, int func_bit)
+{
+	int	df = ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func);
+	df |= func_bit;
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->disable_func, df);
+}
+
+__inline static void RTW_ENABLE_FUNC(_adapter*padapter, int func_bit)
+{
+	int	df = ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func);
+	df &= ~(func_bit);
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->disable_func, df);
+}
+
+#define RTW_CANNOT_RUN(padapter) \
+			(rtw_is_surprise_removed(padapter) || \
+				rtw_is_drv_stopped(padapter))
+
+#define RTW_IS_FUNC_DISABLED(padapter, func_bit) (ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func) & (func_bit))
+
+#define RTW_CANNOT_IO(padapter) \
+			(rtw_is_surprise_removed(padapter) || \
+				RTW_IS_FUNC_DISABLED((padapter), DF_IO_BIT))
+
+#define RTW_CANNOT_RX(padapter) \
+			(RTW_CANNOT_RUN(padapter) || \
+			 RTW_IS_FUNC_DISABLED((padapter), DF_RX_BIT))
+
+#define RTW_CANNOT_TX(padapter) \
+			(RTW_CANNOT_RUN(padapter) || \
+			 RTW_IS_FUNC_DISABLED((padapter), DF_TX_BIT))
+
+#ifdef CONFIG_PNO_SUPPORT
+int rtw_parse_ssid_list_tlv(char** list_str, pno_ssid_t* ssid, int max, int *bytes_left);
+int rtw_dev_pno_set(struct net_device *net, pno_ssid_t* ssid, int num,
+					int pno_time, int pno_repeat, int pno_freq_expo_max);
+#ifdef CONFIG_PNO_SET_DEBUG
+void rtw_dev_pno_debug(struct net_device *net);
+#endif //CONFIG_PNO_SET_DEBUG
+#endif //CONFIG_PNO_SUPPORT
+
+#ifdef CONFIG_WOWLAN
+int rtw_suspend_wow(_adapter *padapter);
+int rtw_resume_process_wow(_adapter *padapter);
+#endif
+
+// HCI Related header file
+#ifdef CONFIG_USB_HCI
+#include <usb_osintf.h>
+#include <usb_ops.h>
+#include <usb_hal.h>
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_osintf.h>
+#include <sdio_ops.h>
+#include <sdio_hal.h>
+#endif
+
+#ifdef CONFIG_GSPI_HCI
+#include <gspi_osintf.h>
+#include <gspi_ops.h>
+#include <gspi_hal.h>
+#endif
+
+#ifdef CONFIG_PCI_HCI
+#include <pci_osintf.h>
+#include <pci_ops.h>
+#include <pci_hal.h>
+#endif
+
+#endif //__DRV_TYPES_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_ce.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_ce.h
new file mode 100644
index 000000000..bb3f29e6c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_ce.h
@@ -0,0 +1,91 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_CE_H__
+#define __DRV_TYPES_CE_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#include <Sdcardddk.h>
+
+#define MAX_ACTIVE_REG_PATH 256
+
+#define MAX_MCAST_LIST_NUM					32
+
+
+
+//for ioctl
+#define MAKE_DRIVER_VERSION(_MainVer,_MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)
+
+#define NIC_HEADER_SIZE				14			//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+#define NIC_MAX_SEND_PACKETS			10		// max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h
+#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0,001)	//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+
+typedef struct _MP_REG_ENTRY
+{
+
+	NDIS_STRING		RegName;	// variable name text
+	BOOLEAN			bRequired;	// 1 -> required, 0 -> optional
+
+	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
+	uint			FieldOffset;	// offset to MP_ADAPTER field
+	uint			FieldSize;	// size (in bytes) of the field
+
+#ifdef UNDER_AMD64
+	u64			Default;
+#else
+	u32			Default;	// default value to use
+#endif
+
+	u32			Min;		// minimum value allowed
+	u32			Max;		// maximum value allowed
+} MP_REG_ENTRY, *PMP_REG_ENTRY;
+
+#ifdef CONFIG_USB_HCI
+typedef struct _USB_EXTENSION {
+	LPCUSB_FUNCS	_lpUsbFuncs;
+	USB_HANDLE	_hDevice;
+	PVOID 		pAdapter;
+
+#if 0
+	USB_ENDPOINT_DESCRIPTOR		_endpACLIn;
+	USB_ENDPOINT_DESCRIPTOR		_endpACLOutHigh;
+	USB_ENDPOINT_DESCRIPTOR		_endpACLOutNormal;
+
+	USB_PIPE        pPipeIn;
+	USB_PIPE        pPipeOutNormal;
+	USB_PIPE        pPipeOutHigh;
+#endif
+
+} USB_EXTENSION, *PUSB_EXTENSION;
+#endif
+
+
+typedef struct _OCTET_STRING{
+	u8      *Octet;
+	u16      Length;
+} OCTET_STRING, *POCTET_STRING;
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_gspi.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_gspi.h
new file mode 100644
index 000000000..545776b2e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_gspi.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_GSPI_H__
+#define __DRV_TYPES_GSPI_H__
+
+// SPI Header Files
+#ifdef PLATFORM_LINUX
+	#include <linux/platform_device.h>
+	#include <linux/spi/spi.h>
+	#include <linux/gpio.h>
+	//#include <mach/ldo.h>
+	#include <asm/mach-types.h>
+	#include <asm/gpio.h>
+	#include <asm/io.h>
+	#include <mach/board.h>
+	#include <mach/hardware.h>
+	#include <mach/irqs.h>
+	#include <custom_gpio.h>
+#endif
+
+
+typedef struct gspi_data
+{
+	u8  func_number;
+
+	u8  tx_block_mode;
+	u8  rx_block_mode;
+	u32 block_transfer_len;
+
+#ifdef PLATFORM_LINUX
+	struct spi_device *func;
+
+	struct workqueue_struct *priv_wq;
+	struct delayed_work irq_work;
+#endif
+} GSPI_DATA, *PGSPI_DATA;
+
+#endif // #ifndef __DRV_TYPES_GSPI_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_linux.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_linux.h
new file mode 100644
index 000000000..57542afb7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_linux.h
@@ -0,0 +1,25 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_LINUX_H__
+#define __DRV_TYPES_LINUX_H__
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_pci.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_pci.h
new file mode 100644
index 000000000..2d04af814
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_pci.h
@@ -0,0 +1,273 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_PCI_H__
+#define __DRV_TYPES_PCI_H__
+
+
+#ifdef PLATFORM_LINUX
+#include <linux/pci.h>
+#endif
+
+
+#define	INTEL_VENDOR_ID				0x8086
+#define	SIS_VENDOR_ID					0x1039
+#define	ATI_VENDOR_ID					0x1002
+#define	ATI_DEVICE_ID					0x7914
+#define	AMD_VENDOR_ID					0x1022
+
+#define	PCI_MAX_BRIDGE_NUMBER			255
+#define	PCI_MAX_DEVICES				32
+#define	PCI_MAX_FUNCTION				8
+
+#define	PCI_CONF_ADDRESS   				0x0CF8   // PCI Configuration Space Address
+#define	PCI_CONF_DATA					0x0CFC   // PCI Configuration Space Data
+
+#define	PCI_CLASS_BRIDGE_DEV			0x06
+#define	PCI_SUBCLASS_BR_PCI_TO_PCI	0x04
+
+#define 	PCI_CAPABILITY_ID_PCI_EXPRESS	0x10
+
+#define	U1DONTCARE 					0xFF
+#define	U2DONTCARE 					0xFFFF
+#define	U4DONTCARE 					0xFFFFFFFF
+
+#define PCI_VENDER_ID_REALTEK		0x10ec
+
+#define HAL_HW_PCI_8180_DEVICE_ID           	0x8180
+#define HAL_HW_PCI_8185_DEVICE_ID           	0x8185	//8185 or 8185b
+#define HAL_HW_PCI_8188_DEVICE_ID           	0x8188	//8185b
+#define HAL_HW_PCI_8198_DEVICE_ID           	0x8198	//8185b
+#define HAL_HW_PCI_8190_DEVICE_ID           	0x8190	//8190
+#define HAL_HW_PCI_8723E_DEVICE_ID		0x8723	//8723E
+#define HAL_HW_PCI_8192_DEVICE_ID           	0x8192	//8192 PCI-E
+#define HAL_HW_PCI_8192SE_DEVICE_ID		0x8192	//8192 SE
+#define HAL_HW_PCI_8174_DEVICE_ID           	0x8174	//8192 SE
+#define HAL_HW_PCI_8173_DEVICE_ID           	0x8173	//8191 SE Crab
+#define HAL_HW_PCI_8172_DEVICE_ID           	0x8172	//8191 SE RE
+#define HAL_HW_PCI_8171_DEVICE_ID           	0x8171	//8191 SE Unicron
+#define HAL_HW_PCI_0045_DEVICE_ID			0x0045	//8190 PCI for Ceraga
+#define HAL_HW_PCI_0046_DEVICE_ID			0x0046	//8190 Cardbus for Ceraga
+#define HAL_HW_PCI_0044_DEVICE_ID			0x0044	//8192e PCIE for Ceraga
+#define HAL_HW_PCI_0047_DEVICE_ID			0x0047	//8192e Express Card for Ceraga
+#define HAL_HW_PCI_700F_DEVICE_ID			0x700F
+#define HAL_HW_PCI_701F_DEVICE_ID			0x701F
+#define HAL_HW_PCI_DLINK_DEVICE_ID		0x3304
+#define HAL_HW_PCI_8188EE_DEVICE_ID		0x8179
+
+#define HAL_MEMORY_MAPPED_IO_RANGE_8190PCI 		0x1000     //8190 support 16 pages of IO registers
+#define HAL_HW_PCI_REVISION_ID_8190PCI			0x00
+#define HAL_MEMORY_MAPPED_IO_RANGE_8192PCIE	0x4000	//8192 support 16 pages of IO registers
+#define HAL_HW_PCI_REVISION_ID_8192PCIE			0x01
+#define HAL_MEMORY_MAPPED_IO_RANGE_8192SE		0x4000	//8192 support 16 pages of IO registers
+#define HAL_HW_PCI_REVISION_ID_8192SE			0x10
+#define HAL_HW_PCI_REVISION_ID_8192CE			0x1
+#define HAL_MEMORY_MAPPED_IO_RANGE_8192CE		0x4000	//8192 support 16 pages of IO registers
+#define HAL_HW_PCI_REVISION_ID_8192DE			0x0
+#define HAL_MEMORY_MAPPED_IO_RANGE_8192DE		0x4000	//8192 support 16 pages of IO registers
+
+enum pci_bridge_vendor {
+	PCI_BRIDGE_VENDOR_INTEL = 0x0,//0b'0000,0001
+	PCI_BRIDGE_VENDOR_ATI, //= 0x02,//0b'0000,0010
+	PCI_BRIDGE_VENDOR_AMD, //= 0x04,//0b'0000,0100
+	PCI_BRIDGE_VENDOR_SIS ,//= 0x08,//0b'0000,1000
+	PCI_BRIDGE_VENDOR_UNKNOWN, //= 0x40,//0b'0100,0000
+	PCI_BRIDGE_VENDOR_MAX ,//= 0x80
+} ;
+
+// copy this data structor defination from MSDN SDK
+typedef struct _PCI_COMMON_CONFIG {
+	u16	VendorID;
+	u16	DeviceID;
+	u16	Command;
+	u16	Status;
+	u8	RevisionID;
+	u8	ProgIf;
+	u8	SubClass;
+	u8	BaseClass;
+	u8	CacheLineSize;
+	u8	LatencyTimer;
+	u8	HeaderType;
+	u8	BIST;
+
+	union {
+	struct _PCI_HEADER_TYPE_0 {
+		u32	BaseAddresses[6];
+		u32	CIS;
+		u16	SubVendorID;
+		u16	SubSystemID;
+		u32	ROMBaseAddress;
+		u8	CapabilitiesPtr;
+		u8	Reserved1[3];
+		u32	Reserved2;
+
+		u8	InterruptLine;
+		u8	InterruptPin;
+		u8	MinimumGrant;
+		u8	MaximumLatency;
+	} type0;
+#if 0
+	struct _PCI_HEADER_TYPE_1 {
+		ULONG BaseAddresses[PCI_TYPE1_ADDRESSES];
+		UCHAR PrimaryBusNumber;
+		UCHAR SecondaryBusNumber;
+		UCHAR SubordinateBusNumber;
+		UCHAR SecondaryLatencyTimer;
+		UCHAR IOBase;
+		UCHAR IOLimit;
+		USHORT SecondaryStatus;
+		USHORT MemoryBase;
+		USHORT MemoryLimit;
+		USHORT PrefetchableMemoryBase;
+		USHORT PrefetchableMemoryLimit;
+		ULONG PrefetchableMemoryBaseUpper32;
+		ULONG PrefetchableMemoryLimitUpper32;
+		USHORT IOBaseUpper;
+		USHORT IOLimitUpper;
+		ULONG Reserved2;
+		ULONG ExpansionROMBase;
+		UCHAR InterruptLine;
+		UCHAR InterruptPin;
+		USHORT BridgeControl;
+	} type1;
+
+	struct _PCI_HEADER_TYPE_2 {
+		ULONG BaseAddress;
+		UCHAR CapabilitiesPtr;
+		UCHAR Reserved2;
+		USHORT SecondaryStatus;
+		UCHAR PrimaryBusNumber;
+		UCHAR CardbusBusNumber;
+		UCHAR SubordinateBusNumber;
+		UCHAR CardbusLatencyTimer;
+		ULONG MemoryBase0;
+		ULONG MemoryLimit0;
+		ULONG MemoryBase1;
+		ULONG MemoryLimit1;
+		USHORT IOBase0_LO;
+		USHORT IOBase0_HI;
+		USHORT IOLimit0_LO;
+		USHORT IOLimit0_HI;
+		USHORT IOBase1_LO;
+		USHORT IOBase1_HI;
+		USHORT IOLimit1_LO;
+		USHORT IOLimit1_HI;
+		UCHAR InterruptLine;
+		UCHAR InterruptPin;
+		USHORT BridgeControl;
+		USHORT SubVendorID;
+		USHORT SubSystemID;
+		ULONG LegacyBaseAddress;
+		UCHAR Reserved3[56];
+		ULONG SystemControl;
+		UCHAR MultiMediaControl;
+		UCHAR GeneralStatus;
+		UCHAR Reserved4[2];
+		UCHAR GPIO0Control;
+		UCHAR GPIO1Control;
+		UCHAR GPIO2Control;
+		UCHAR GPIO3Control;
+		ULONG IRQMuxRouting;
+		UCHAR RetryStatus;
+		UCHAR CardControl;
+		UCHAR DeviceControl;
+		UCHAR Diagnostic;
+	} type2;
+#endif
+	} u;
+
+	u8	DeviceSpecific[108];
+} PCI_COMMON_CONFIG , *PPCI_COMMON_CONFIG;
+
+typedef struct _RT_PCI_CAPABILITIES_HEADER {
+    u8   CapabilityID;
+    u8   Next;
+} RT_PCI_CAPABILITIES_HEADER, *PRT_PCI_CAPABILITIES_HEADER;
+
+struct pci_priv{
+	BOOLEAN		pci_clk_req;
+
+	u8	pciehdr_offset;
+	//  PCIeCap is only differece between B-cut and C-cut.
+	//  Configuration Space offset 72[7:4]
+	//  0: A/B cut
+	//  1: C cut and later.
+	u8	pcie_cap;
+	u8	linkctrl_reg;
+
+	u8	busnumber;
+	u8	devnumber;
+	u8	funcnumber;
+
+	u8	pcibridge_busnum;
+	u8	pcibridge_devnum;
+	u8	pcibridge_funcnum;
+	u8	pcibridge_vendor;
+	u16	pcibridge_vendorid;
+	u16	pcibridge_deviceid;
+	u8	pcibridge_pciehdr_offset;
+	u8	pcibridge_linkctrlreg;
+
+	u8	amd_l1_patch;
+};
+
+typedef struct _RT_ISR_CONTENT
+{
+	union{
+		u32			IntArray[2];
+		u32			IntReg4Byte;
+		u16			IntReg2Byte;
+	};
+}RT_ISR_CONTENT, *PRT_ISR_CONTENT;
+
+//#define RegAddr(addr)           (addr + 0xB2000000UL)
+//some platform macros will def here
+static inline void NdisRawWritePortUlong(u32 port,  u32 val)
+{
+	outl(val, port);
+	//writel(val, (u8 *)RegAddr(port));
+}
+
+static inline void NdisRawWritePortUchar(u32 port,  u8 val)
+{
+	outb(val, port);
+	//writeb(val, (u8 *)RegAddr(port));
+}
+
+static inline void NdisRawReadPortUchar(u32 port, u8 *pval)
+{
+	*pval = inb(port);
+	//*pval = readb((u8 *)RegAddr(port));
+}
+
+static inline void NdisRawReadPortUshort(u32 port, u16 *pval)
+{
+	*pval = inw(port);
+	//*pval = readw((u8 *)RegAddr(port));
+}
+
+static inline void NdisRawReadPortUlong(u32 port, u32 *pval)
+{
+	*pval = inl(port);
+	//*pval = readl((u8 *)RegAddr(port));
+}
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_sdio.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_sdio.h
new file mode 100644
index 000000000..c926c2e1f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_sdio.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_SDIO_H__
+#define __DRV_TYPES_SDIO_H__
+
+// SDIO Header Files
+#ifdef PLATFORM_LINUX
+	#include <linux/mmc/sdio_func.h>
+	#include <linux/mmc/sdio_ids.h>
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_PLATFORM_SPRD)
+	#include <linux/mmc/host.h>
+	#include <linux/mmc/card.h>
+#endif
+
+#ifdef CONFIG_PLATFORM_SPRD
+	#include <linux/gpio.h>
+	#include <custom_gpio.h>
+#endif // CONFIG_PLATFORM_SPRD
+#endif
+
+#ifdef PLATFORM_OS_XP
+#include <wdm.h>
+#include <ntddsd.h>
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <sdcardddk.h>
+#endif
+
+
+typedef struct sdio_data
+{
+	u8  func_number;
+
+	u8  tx_block_mode;
+	u8  rx_block_mode;
+	u32 block_transfer_len;
+
+#ifdef PLATFORM_LINUX
+	struct sdio_func	 *func;
+	_thread_hdl_ sys_sdio_irq_thd;
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PDEVICE_OBJECT			pphysdevobj;
+	PDEVICE_OBJECT			pfuncdevobj;
+	PDEVICE_OBJECT			pnextdevobj;
+	SDBUS_INTERFACE_STANDARD	sdbusinft;
+	u8				nextdevstacksz;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	SD_DEVICE_HANDLE			hDevice;
+	SD_CARD_RCA					sd_rca;
+	SD_CARD_INTERFACE			card_intf;
+	BOOLEAN						enableIsarWithStatus;
+	WCHAR						active_path[MAX_ACTIVE_REG_PATH];
+	SD_HOST_BLOCK_CAPABILITY	sd_host_blk_cap;
+#endif
+} SDIO_DATA, *PSDIO_DATA;
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_xp.h b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_xp.h
new file mode 100644
index 000000000..5da864cdc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/drv_types_xp.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_XP_H__
+#define __DRV_TYPES_XP_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+
+#define MAX_MCAST_LIST_NUM					32
+
+
+
+//for ioctl
+#define MAKE_DRIVER_VERSION(_MainVer,_MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)
+
+#define NIC_HEADER_SIZE				14			//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+#define NIC_MAX_SEND_PACKETS			10		// max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h
+#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0,001)	//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+
+
+#undef ON_VISTA
+//added by Jackson
+#ifndef ON_VISTA
+//
+// Bus driver versions
+//
+
+#define SDBUS_DRIVER_VERSION_1          0x100
+#define SDBUS_DRIVER_VERSION_2          0x200
+
+#define    SDP_FUNCTION_TYPE	4
+#define    SDP_BUS_DRIVER_VERSION 5
+#define    SDP_BUS_WIDTH 6
+#define    SDP_BUS_CLOCK 7
+#define    SDP_BUS_INTERFACE_CONTROL 8
+#define    SDP_HOST_BLOCK_LENGTH 9
+#define    SDP_FUNCTION_BLOCK_LENGTH 10
+#define    SDP_FN0_BLOCK_LENGTH 11
+#define    SDP_FUNCTION_INT_ENABLE 12
+#endif
+
+
+typedef struct _MP_REG_ENTRY
+{
+
+	NDIS_STRING		RegName;	// variable name text
+	BOOLEAN			bRequired;	// 1 -> required, 0 -> optional
+
+	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
+	uint			FieldOffset;	// offset to MP_ADAPTER field
+	uint			FieldSize;	// size (in bytes) of the field
+
+#ifdef UNDER_AMD64
+	u64			Default;
+#else
+	u32			Default;		// default value to use
+#endif
+
+	u32			Min;			// minimum value allowed
+	u32			Max;		// maximum value allowed
+} MP_REG_ENTRY, *PMP_REG_ENTRY;
+
+
+typedef struct _OCTET_STRING{
+	u8      *Octet;
+	u16      Length;
+} OCTET_STRING, *POCTET_STRING;
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/ethernet.h b/drivers/net/wireless/realtek/rtl8723cs/include/ethernet.h
new file mode 100644
index 000000000..376123518
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/ethernet.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*! \file */
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH				6		//!< Ethernet Address Length
+#define ETHERNET_HEADER_SIZE				14		//!< Ethernet Header Length
+#define LLC_HEADER_SIZE						6		//!< LLC Header Length
+#define TYPE_LENGTH_FIELD_SIZE				2		//!< Type/Length Size
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((UCHAR *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
+#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
+											((UCHAR *)(_pAddr))[0]==0xff	&& 		\
+											((UCHAR *)(_pAddr))[1]==0xff	&&		\
+											((UCHAR *)(_pAddr))[2]==0xff	&&		\
+											((UCHAR *)(_pAddr))[3]==0xff	&&		\
+											((UCHAR *)(_pAddr))[4]==0xff	&&		\
+											((UCHAR *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
+
+
+#endif // #ifndef __INC_ETHERNET_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/gspi_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_hal.h
new file mode 100644
index 000000000..758151258
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_hal.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __GSPI_HAL_H__
+#define __GSPI_HAL_H__
+
+
+void spi_int_dpc(PADAPTER padapter, u32 sdio_hisr);
+u8 rtw_set_hal_ops(_adapter *padapter);
+
+#ifdef CONFIG_RTL8188E
+void rtl8188es_set_hal_ops(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8723B
+void rtl8723bs_set_hal_ops(PADAPTER padapter);
+#endif
+
+#endif //__GSPI_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops.h b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops.h
new file mode 100644
index 000000000..e04c28a91
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops.h
@@ -0,0 +1,185 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __GSPI_OPS_H__
+#define __GSPI_OPS_H__
+
+/* follwing defination is based on
+ * GSPI spec of RTL8723, we temp
+ * suppose that it will be the same
+ * for diff chips of GSPI, if not
+ * we should move it to HAL folder */
+#define SPI_LOCAL_DOMAIN 				0x0
+#define WLAN_IOREG_DOMAIN 			0x8
+#define FW_FIFO_DOMAIN 				0x4
+#define TX_HIQ_DOMAIN 					0xc
+#define TX_MIQ_DOMAIN 					0xd
+#define TX_LOQ_DOMAIN 					0xe
+#define RX_RXFIFO_DOMAIN 				0x1f
+
+//IO Bus domain address mapping
+#define DEFUALT_OFFSET					0x0
+#define SPI_LOCAL_OFFSET    				0x10250000
+#define WLAN_IOREG_OFFSET   			0x10260000
+#define FW_FIFO_OFFSET 	    			0x10270000
+#define TX_HIQ_OFFSET	    				0x10310000
+#define TX_MIQ_OFFSET					0x1032000
+#define TX_LOQ_OFFSET					0x10330000
+#define RX_RXOFF_OFFSET	    			0x10340000
+
+//SPI Local registers
+#define SPI_REG_TX_CTRL					0x0000 // SPI Tx Control
+#define SPI_REG_STATUS_RECOVERY		0x0004
+#define SPI_REG_INT_TIMEOUT		   	0x0006
+#define SPI_REG_HIMR					0x0014 // SPI Host Interrupt Mask
+#define SPI_REG_HISR					0x0018 // SPI Host Interrupt Service Routine
+#define SPI_REG_RX0_REQ_LEN			0x001C // RXDMA Request Length
+#define SPI_REG_FREE_TXPG				0x0020 // Free Tx Buffer Page
+#define SPI_REG_HCPWM1					0x0024 // HCI Current Power Mode 1
+#define SPI_REG_HCPWM2					0x0026 // HCI Current Power Mode 2
+#define SPI_REG_HTSFR_INFO				0x0030 // HTSF Informaion
+#define SPI_REG_HRPWM1					0x0080 // HCI Request Power Mode 1
+#define SPI_REG_HRPWM2					0x0082 // HCI Request Power Mode 2
+#define SPI_REG_HPS_CLKR				0x0084 // HCI Power Save Clock
+#define SPI_REG_HSUS_CTRL				0x0086 // SPI HCI Suspend Control
+#define SPI_REG_HIMR_ON				0x0090 //SPI Host Extension Interrupt Mask Always
+#define SPI_REG_HISR_ON				0x0091 //SPI Host Extension Interrupt Status Always
+#define SPI_REG_CFG						0x00F0 //SPI Configuration Register
+
+#define SPI_TX_CTRL 	               			(SPI_REG_TX_CTRL  |SPI_LOCAL_OFFSET)
+#define SPI_STATUS_RECOVERY		   	(SPI_REG_STATUS_RECOVERY  |SPI_LOCAL_OFFSET)
+#define SPI_INT_TIMEOUT		   	   		(SPI_REG_INT_TIMEOUT  |SPI_LOCAL_OFFSET)
+#define SPI_HIMR 	                  			(SPI_REG_HIMR |SPI_LOCAL_OFFSET)
+#define SPI_HISR 	                   			(SPI_REG_HISR |SPI_LOCAL_OFFSET)
+#define SPI_RX0_REQ_LEN_1_BYTE 	   	(SPI_REG_RX0_REQ_LEN |SPI_LOCAL_OFFSET)
+#define SPI_FREE_TXPG 	               		(SPI_REG_FREE_TXPG |SPI_LOCAL_OFFSET)
+
+#define	SPI_HIMR_DISABLED				0
+
+//SPI HIMR MASK diff with SDIO
+#define SPI_HISR_RX_REQUEST    			BIT(0)
+#define SPI_HISR_AVAL					BIT(1)
+#define SPI_HISR_TXERR					BIT(2)
+#define SPI_HISR_RXERR					BIT(3)
+#define SPI_HISR_TXFOVW				BIT(4)
+#define SPI_HISR_RXFOVW				BIT(5)
+#define SPI_HISR_TXBCNOK				BIT(6)
+#define SPI_HISR_TXBCNERR				BIT(7)
+#define SPI_HISR_BCNERLY_INT			BIT(16)
+#define SPI_HISR_ATIMEND				BIT(17)
+#define SPI_HISR_ATIMEND_E				BIT(18)
+#define SPI_HISR_CTWEND				BIT(19)
+#define SPI_HISR_C2HCMD				BIT(20)
+#define SPI_HISR_CPWM1					BIT(21)
+#define SPI_HISR_CPWM2					BIT(22)
+#define SPI_HISR_HSISR_IND				BIT(23)
+#define SPI_HISR_GTINT3_IND				BIT(24)
+#define SPI_HISR_GTINT4_IND				BIT(25)
+#define SPI_HISR_PSTIMEOUT				BIT(26)
+#define SPI_HISR_OCPINT					BIT(27)
+#define SPI_HISR_TSF_BIT32_TOGGLE		BIT(29)
+
+#define MASK_SPI_HISR_CLEAR		(SPI_HISR_TXERR |\
+									SPI_HISR_RXERR |\
+									SPI_HISR_TXFOVW |\
+									SPI_HISR_RXFOVW |\
+									SPI_HISR_TXBCNOK |\
+									SPI_HISR_TXBCNERR |\
+									SPI_HISR_C2HCMD |\
+									SPI_HISR_CPWM1 |\
+									SPI_HISR_CPWM2 |\
+									SPI_HISR_HSISR_IND |\
+									SPI_HISR_GTINT3_IND |\
+									SPI_HISR_GTINT4_IND |\
+									SPI_HISR_PSTIMEOUT |\
+									SPI_HISR_OCPINT)
+
+#define REG_LEN_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 0, 8, x)//(x<<(unsigned int)24)
+#define REG_ADDR_FORMAT(pcmd,x) 			SET_BITS_TO_LE_4BYTE(pcmd, 8, 16, x)//(x<<(unsigned int)16)
+#define REG_DOMAIN_ID_FORMAT(pcmd,x) 		SET_BITS_TO_LE_4BYTE(pcmd, 24, 5, x)//(x<<(unsigned int)0)
+#define REG_FUN_FORMAT(pcmd,x) 			SET_BITS_TO_LE_4BYTE(pcmd, 29, 2, x)//(x<<(unsigned int)5)
+#define REG_RW_FORMAT(pcmd,x) 				SET_BITS_TO_LE_4BYTE(pcmd, 31, 1, x)//(x<<(unsigned int)7)
+
+#define FIFO_LEN_FORMAT(pcmd, x) 			SET_BITS_TO_LE_4BYTE(pcmd, 0, 16, x)//(x<<(unsigned int)24)
+//#define FIFO_ADDR_FORMAT(pcmd,x) 			SET_BITS_TO_LE_4BYTE(pcmd, 8, 16, x)//(x<<(unsigned int)16)
+#define FIFO_DOMAIN_ID_FORMAT(pcmd,x) 	SET_BITS_TO_LE_4BYTE(pcmd, 24, 5, x)//(x<<(unsigned int)0)
+#define FIFO_FUN_FORMAT(pcmd,x) 			SET_BITS_TO_LE_4BYTE(pcmd, 29, 2, x)//(x<<(unsigned int)5)
+#define FIFO_RW_FORMAT(pcmd,x) 			SET_BITS_TO_LE_4BYTE(pcmd, 31, 1, x)//(x<<(unsigned int)7)
+
+
+//get status dword0
+#define GET_STATUS_PUB_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 24, 8)
+#define GET_STATUS_HI_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 18, 6)
+#define GET_STATUS_MID_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 12, 6)
+#define GET_STATUS_LOW_PAGE_NUM(status)		LE_BITS_TO_4BYTE(status, 6, 6)
+#define GET_STATUS_HISR_HI6BIT(status)			LE_BITS_TO_4BYTE(status, 0, 6)
+
+//get status dword1
+#define GET_STATUS_HISR_MID8BIT(status)		LE_BITS_TO_4BYTE(status + 4, 24, 8)
+#define GET_STATUS_HISR_LOW8BIT(status)		LE_BITS_TO_4BYTE(status + 4, 16, 8)
+#define GET_STATUS_ERROR(status)		    		LE_BITS_TO_4BYTE(status + 4, 17, 1)
+#define GET_STATUS_INT(status)		        		LE_BITS_TO_4BYTE(status + 4, 16, 1)
+#define GET_STATUS_RX_LENGTH(status)			LE_BITS_TO_4BYTE(status + 4, 0, 16)
+
+
+#define RXDESC_SIZE	24
+
+
+struct spi_more_data {
+	unsigned long more_data;
+	unsigned long len;
+};
+
+#ifdef CONFIG_RTL8188E
+void rtl8188es_set_hal_ops(PADAPTER padapter);
+#define set_hal_ops rtl8188es_set_hal_ops
+#endif
+extern void spi_set_chip_endian(PADAPTER padapter);
+extern unsigned int spi_write8_endian(ADAPTER *Adapter, unsigned int addr, unsigned int buf, u32 big);
+extern void spi_set_intf_ops(_adapter *padapter,struct _io_ops *pops);
+extern void spi_set_chip_endian(PADAPTER padapter);
+extern void InitInterrupt8723ASdio(PADAPTER padapter);
+extern void InitSysInterrupt8723ASdio(PADAPTER padapter);
+extern void EnableInterrupt8723ASdio(PADAPTER padapter);
+extern void DisableInterrupt8723ASdio(PADAPTER padapter);
+extern void spi_int_hdl(PADAPTER padapter);
+extern u8 HalQueryTxBufferStatus8723ASdio(PADAPTER padapter);
+#ifdef CONFIG_RTL8723B
+extern void InitInterrupt8723BSdio(PADAPTER padapter);
+extern void InitSysInterrupt8723BSdio(PADAPTER padapter);
+extern void EnableInterrupt8723BSdio(PADAPTER padapter);
+extern void DisableInterrupt8723BSdio(PADAPTER padapter);
+extern u8 HalQueryTxBufferStatus8723BSdio(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8188E
+extern void InitInterrupt8188EGspi(PADAPTER padapter);
+extern void EnableInterrupt8188EGspi(PADAPTER padapter);
+extern void DisableInterrupt8188EGspi(PADAPTER padapter);
+extern void UpdateInterruptMask8188EGspi(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
+extern u8 HalQueryTxBufferStatus8189EGspi(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8189EGspi(PADAPTER padapter);
+extern void ClearInterrupt8188EGspi(PADAPTER padapter);
+extern u8 CheckIPSStatus(PADAPTER padapter);
+#endif // CONFIG_RTL8188E
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+extern u8 RecvOnePkt(PADAPTER padapter, u32 size);
+#endif // CONFIG_WOWLAN
+
+#endif //__GSPI_OPS_H__
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops_linux.h b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops_linux.h
new file mode 100644
index 000000000..6358a0fa6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_ops_linux.h
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OPS_LINUX_H__
+#define __SDIO_OPS_LINUX_H__
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/gspi_osintf.h b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_osintf.h
new file mode 100644
index 000000000..5b57bdb66
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/gspi_osintf.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OSINTF_H__
+#define __SDIO_OSINTF_H__
+
+
+#ifdef PLATFORM_OS_CE
+extern NDIS_STATUS ce_sd_get_dev_hdl(PADAPTER padapter);
+SD_API_STATUS ce_sd_int_callback(SD_DEVICE_HANDLE hDevice, PADAPTER padapter);
+extern void sd_setup_irs(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/h2clbk.h b/drivers/net/wireless/realtek/rtl8723cs/include/h2clbk.h
new file mode 100644
index 000000000..01cefe060
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/h2clbk.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _H2CLBK_H_
+
+
+void _lbk_cmd(PADAPTER Adapter);
+
+void _lbk_rsp(PADAPTER Adapter);
+
+void _lbk_evt(IN PADAPTER Adapter);
+
+void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_btcoex.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_btcoex.h
new file mode 100644
index 000000000..dd2eb84f4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_btcoex.h
@@ -0,0 +1,97 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_BTCOEX_H__
+#define __HAL_BTCOEX_H__
+
+#include <drv_types.h>
+
+// Some variables can't get from outsrc BT-Coex,
+// so we need to save here
+typedef struct _BT_COEXIST
+{
+	u8 bBtExist;
+	u8 btTotalAntNum;
+	u8 btChipType;
+	u8 bInitlized;
+	u8 btAntisolation;
+} BT_COEXIST, *PBT_COEXIST;
+
+void DBG_BT_INFO(u8 *dbgmsg);
+
+void hal_btcoex_SetBTCoexist(PADAPTER padapter, u8 bBtExist);
+u8 hal_btcoex_IsBtExist(PADAPTER padapter);
+u8 hal_btcoex_IsBtDisabled(PADAPTER);
+void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType);
+u8 hal_btcoex_GetChipType(PADAPTER padapter);
+void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum);
+u8 hal_btcoex_GetPgAntNum(PADAPTER padapter);
+void hal_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath);
+
+u8 hal_btcoex_Initialize(PADAPTER padapter);
+void hal_btcoex_PowerOnSetting(PADAPTER padapter);
+void hal_btcoex_PreLoadFirmware(PADAPTER padapter);
+void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly);
+
+void hal_btcoex_IpsNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_LpsNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_ScanNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_ConnectNotify(PADAPTER padapter, u8 action);
+void hal_btcoex_MediaStatusNotify(PADAPTER padapter, u8 mediaStatus);
+void hal_btcoex_SpecialPacketNotify(PADAPTER padapter, u8 pktType);
+void hal_btcoex_IQKNotify(PADAPTER padapter, u8 state);
+void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_BtMpRptNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state);
+void hal_btcoex_HaltNotify(PADAPTER padapter);
+void hal_btcoex_ScoreBoardStatusNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter);
+
+void hal_btcoex_Hanlder(PADAPTER padapter);
+
+s32 hal_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
+s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER padapter);
+u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter);
+void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual);
+u8 hal_btcoex_1Ant(PADAPTER padapter);
+u8 hal_btcoex_IsBtControlLps(PADAPTER);
+u8 hal_btcoex_IsLpsOn(PADAPTER);
+u8 hal_btcoex_RpwmVal(PADAPTER);
+u8 hal_btcoex_LpsVal(PADAPTER);
+u32 hal_btcoex_GetRaMask(PADAPTER);
+void hal_btcoex_RecordPwrMode(PADAPTER padapter, u8 *pCmdBuf, u8 cmdLen);
+void hal_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
+void hal_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
+u32 hal_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
+u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER);
+u8 hal_btcoex_IsBtLinkExist(PADAPTER);
+void hal_btcoex_SetBtPatchVersion(PADAPTER,u16 btHciVer,u16 btPatchVer);
+void hal_btcoex_SetHciVersion(PADAPTER, u16 hciVersion);
+void hal_btcoex_SendScanNotify(PADAPTER, u8 type);
+void hal_btcoex_StackUpdateProfileInfo(void);
+void hal_btcoex_BTOffOnNotify(PADAPTER padapter, u8 bBTON);
+void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype);
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+int hal_btcoex_AntIsolationConfig_ParaFile(IN PADAPTER	Adapter,IN char* pFileName);
+int hal_btcoex_ParseAntIsolationConfigFile(PADAPTER Adapter, char*	buffer);
+#endif // CONFIG_LOAD_PHY_PARA_FROM_FILE
+u16 hal_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
+u16 hal_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
+#endif // !__HAL_BTCOEX_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_com.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com.h
new file mode 100644
index 000000000..efa73d8fa
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com.h
@@ -0,0 +1,544 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_H__
+#define __HAL_COMMON_H__
+
+#include "HalVerDef.h"
+#include "hal_pg.h"
+#include "hal_phy.h"
+#include "hal_phy_reg.h"
+#include "hal_com_reg.h"
+#include "hal_com_phycfg.h"
+#include "../hal/hal_com_c2h.h"
+
+/*------------------------------ Tx Desc definition Macro ------------------------*/
+//#pragma mark -- Tx Desc related definition. --
+//----------------------------------------------------------------------------
+//-----------------------------------------------------------
+//	Rate
+//-----------------------------------------------------------
+// CCK Rates, TxHT = 0
+#define DESC_RATE1M					0x00
+#define DESC_RATE2M					0x01
+#define DESC_RATE5_5M				0x02
+#define DESC_RATE11M				0x03
+
+// OFDM Rates, TxHT = 0
+#define DESC_RATE6M					0x04
+#define DESC_RATE9M					0x05
+#define DESC_RATE12M				0x06
+#define DESC_RATE18M				0x07
+#define DESC_RATE24M				0x08
+#define DESC_RATE36M				0x09
+#define DESC_RATE48M				0x0a
+#define DESC_RATE54M				0x0b
+
+// MCS Rates, TxHT = 1
+#define DESC_RATEMCS0				0x0c
+#define DESC_RATEMCS1				0x0d
+#define DESC_RATEMCS2				0x0e
+#define DESC_RATEMCS3				0x0f
+#define DESC_RATEMCS4				0x10
+#define DESC_RATEMCS5				0x11
+#define DESC_RATEMCS6				0x12
+#define DESC_RATEMCS7				0x13
+#define DESC_RATEMCS8				0x14
+#define DESC_RATEMCS9				0x15
+#define DESC_RATEMCS10				0x16
+#define DESC_RATEMCS11				0x17
+#define DESC_RATEMCS12				0x18
+#define DESC_RATEMCS13				0x19
+#define DESC_RATEMCS14				0x1a
+#define DESC_RATEMCS15				0x1b
+#define DESC_RATEMCS16				0x1C
+#define DESC_RATEMCS17				0x1D
+#define DESC_RATEMCS18				0x1E
+#define DESC_RATEMCS19				0x1F
+#define DESC_RATEMCS20				0x20
+#define DESC_RATEMCS21				0x21
+#define DESC_RATEMCS22				0x22
+#define DESC_RATEMCS23				0x23
+#define DESC_RATEMCS24				0x24
+#define DESC_RATEMCS25				0x25
+#define DESC_RATEMCS26				0x26
+#define DESC_RATEMCS27				0x27
+#define DESC_RATEMCS28				0x28
+#define DESC_RATEMCS29				0x29
+#define DESC_RATEMCS30				0x2A
+#define DESC_RATEMCS31				0x2B
+#define DESC_RATEVHTSS1MCS0		0x2C
+#define DESC_RATEVHTSS1MCS1		0x2D
+#define DESC_RATEVHTSS1MCS2		0x2E
+#define DESC_RATEVHTSS1MCS3		0x2F
+#define DESC_RATEVHTSS1MCS4		0x30
+#define DESC_RATEVHTSS1MCS5		0x31
+#define DESC_RATEVHTSS1MCS6		0x32
+#define DESC_RATEVHTSS1MCS7		0x33
+#define DESC_RATEVHTSS1MCS8		0x34
+#define DESC_RATEVHTSS1MCS9		0x35
+#define DESC_RATEVHTSS2MCS0		0x36
+#define DESC_RATEVHTSS2MCS1		0x37
+#define DESC_RATEVHTSS2MCS2		0x38
+#define DESC_RATEVHTSS2MCS3		0x39
+#define DESC_RATEVHTSS2MCS4		0x3A
+#define DESC_RATEVHTSS2MCS5		0x3B
+#define DESC_RATEVHTSS2MCS6		0x3C
+#define DESC_RATEVHTSS2MCS7		0x3D
+#define DESC_RATEVHTSS2MCS8		0x3E
+#define DESC_RATEVHTSS2MCS9		0x3F
+#define DESC_RATEVHTSS3MCS0		0x40
+#define DESC_RATEVHTSS3MCS1		0x41
+#define DESC_RATEVHTSS3MCS2		0x42
+#define DESC_RATEVHTSS3MCS3		0x43
+#define DESC_RATEVHTSS3MCS4		0x44
+#define DESC_RATEVHTSS3MCS5		0x45
+#define DESC_RATEVHTSS3MCS6		0x46
+#define DESC_RATEVHTSS3MCS7		0x47
+#define DESC_RATEVHTSS3MCS8		0x48
+#define DESC_RATEVHTSS3MCS9		0x49
+#define DESC_RATEVHTSS4MCS0		0x4A
+#define DESC_RATEVHTSS4MCS1		0x4B
+#define DESC_RATEVHTSS4MCS2		0x4C
+#define DESC_RATEVHTSS4MCS3		0x4D
+#define DESC_RATEVHTSS4MCS4		0x4E
+#define DESC_RATEVHTSS4MCS5		0x4F
+#define DESC_RATEVHTSS4MCS6		0x50
+#define DESC_RATEVHTSS4MCS7		0x51
+#define DESC_RATEVHTSS4MCS8		0x52
+#define DESC_RATEVHTSS4MCS9		0x53
+
+#define HDATA_RATE(rate)\
+(rate == DESC_RATE1M)?"CCK_1M" :\
+(rate == DESC_RATE2M)?"CCK_2M" :\
+(rate == DESC_RATE5_5M)?"CCK5_5M" :\
+(rate == DESC_RATE11M)?"CCK_11M" :\
+(rate == DESC_RATE6M)?"OFDM_6M" :\
+(rate == DESC_RATE9M)?"OFDM_9M" :\
+(rate == DESC_RATE12M)?"OFDM_12M" :\
+(rate == DESC_RATE18M)?"OFDM_18M" :\
+(rate == DESC_RATE24M)?"OFDM_24M" :\
+(rate == DESC_RATE36M)?"OFDM_36M" :\
+(rate == DESC_RATE48M)?"OFDM_48M" :\
+(rate == DESC_RATE54M)?"OFDM_54M" :\
+(rate == DESC_RATEMCS0)?"MCS0" :\
+(rate == DESC_RATEMCS1)?"MCS1" :\
+(rate == DESC_RATEMCS2)?"MCS2" :\
+(rate == DESC_RATEMCS3)?"MCS3" :\
+(rate == DESC_RATEMCS4)?"MCS4" :\
+(rate == DESC_RATEMCS5)?"MCS5" :\
+(rate == DESC_RATEMCS6)?"MCS6" :\
+(rate == DESC_RATEMCS7)?"MCS7" :\
+(rate == DESC_RATEMCS8)?"MCS8" :\
+(rate == DESC_RATEMCS9)?"MCS9" :\
+(rate == DESC_RATEMCS10)?"MCS10" :\
+(rate == DESC_RATEMCS11)?"MCS11" :\
+(rate == DESC_RATEMCS12)?"MCS12" :\
+(rate == DESC_RATEMCS13)?"MCS13" :\
+(rate == DESC_RATEMCS14)?"MCS14" :\
+(rate == DESC_RATEMCS15)?"MCS15" :\
+(rate == DESC_RATEMCS16)?"MCS16" :\
+(rate == DESC_RATEMCS17)?"MCS17" :\
+(rate == DESC_RATEMCS18)?"MCS18" :\
+(rate == DESC_RATEMCS19)?"MCS19" :\
+(rate == DESC_RATEMCS20)?"MCS20" :\
+(rate == DESC_RATEMCS21)?"MCS21" :\
+(rate == DESC_RATEMCS22)?"MCS22" :\
+(rate == DESC_RATEMCS23)?"MCS23" :\
+(rate == DESC_RATEVHTSS1MCS0)?"VHTSS1MCS0" :\
+(rate == DESC_RATEVHTSS1MCS1)?"VHTSS1MCS1" :\
+(rate == DESC_RATEVHTSS1MCS2)?"VHTSS1MCS2" :\
+(rate == DESC_RATEVHTSS1MCS3)?"VHTSS1MCS3" :\
+(rate == DESC_RATEVHTSS1MCS4)?"VHTSS1MCS4" :\
+(rate == DESC_RATEVHTSS1MCS5)?"VHTSS1MCS5" :\
+(rate == DESC_RATEVHTSS1MCS6)?"VHTSS1MCS6" :\
+(rate == DESC_RATEVHTSS1MCS7)?"VHTSS1MCS7" :\
+(rate == DESC_RATEVHTSS1MCS8)?"VHTSS1MCS8" :\
+(rate == DESC_RATEVHTSS1MCS9)?"VHTSS1MCS9" :\
+(rate == DESC_RATEVHTSS2MCS0)?"VHTSS2MCS0" :\
+(rate == DESC_RATEVHTSS2MCS1)?"VHTSS2MCS1" :\
+(rate == DESC_RATEVHTSS2MCS2)?"VHTSS2MCS2" :\
+(rate == DESC_RATEVHTSS2MCS3)?"VHTSS2MCS3" :\
+(rate == DESC_RATEVHTSS2MCS4)?"VHTSS2MCS4" :\
+(rate == DESC_RATEVHTSS2MCS5)?"VHTSS2MCS5" :\
+(rate == DESC_RATEVHTSS2MCS6)?"VHTSS2MCS6" :\
+(rate == DESC_RATEVHTSS2MCS7)?"VHTSS2MCS7" :\
+(rate == DESC_RATEVHTSS2MCS8)?"VHTSS2MCS8" :\
+(rate == DESC_RATEVHTSS2MCS9)?"VHTSS2MCS9" :\
+(rate == DESC_RATEVHTSS3MCS0)?"VHTSS3MCS0" :\
+(rate == DESC_RATEVHTSS3MCS1)?"VHTSS3MCS1" :\
+(rate == DESC_RATEVHTSS3MCS2)?"VHTSS3MCS2" :\
+(rate == DESC_RATEVHTSS3MCS3)?"VHTSS3MCS3" :\
+(rate == DESC_RATEVHTSS3MCS4)?"VHTSS3MCS4" :\
+(rate == DESC_RATEVHTSS3MCS5)?"VHTSS3MCS5" :\
+(rate == DESC_RATEVHTSS3MCS6)?"VHTSS3MCS6" :\
+(rate == DESC_RATEVHTSS3MCS7)?"VHTSS3MCS7" :\
+(rate == DESC_RATEVHTSS3MCS8)?"VHTSS3MCS8" :\
+(rate == DESC_RATEVHTSS3MCS9)?"VHTSS3MCS9" : "UNKNOWN"
+
+
+enum{
+	UP_LINK,
+	DOWN_LINK,
+};
+typedef enum _RT_MEDIA_STATUS {
+	RT_MEDIA_DISCONNECT = 0,
+	RT_MEDIA_CONNECT       = 1
+} RT_MEDIA_STATUS;
+
+#define MAX_DLFW_PAGE_SIZE			4096	// @ page : 4k bytes
+typedef enum _FIRMWARE_SOURCE {
+	FW_SOURCE_IMG_FILE = 0,
+	FW_SOURCE_HEADER_FILE = 1,		//from header file
+} FIRMWARE_SOURCE, *PFIRMWARE_SOURCE;
+
+//
+// Queue Select Value in TxDesc
+//
+#define QSLT_BK							0x2//0x01
+#define QSLT_BE							0x0
+#define QSLT_VI							0x5//0x4
+#define QSLT_VO							0x7//0x6
+#define QSLT_BEACON						0x10
+#define QSLT_HIGH						0x11
+#define QSLT_MGNT						0x12
+#define QSLT_CMD						0x13
+
+// BK, BE, VI, VO, HCCA, MANAGEMENT, COMMAND, HIGH, BEACON.
+//#define MAX_TX_QUEUE		9
+
+#define TX_SELE_HQ			BIT(0)		// High Queue
+#define TX_SELE_LQ			BIT(1)		// Low Queue
+#define TX_SELE_NQ			BIT(2)		// Normal Queue
+#define TX_SELE_EQ			BIT(3)		// Extern Queue
+
+#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
+#define PageNum_256(_Len)		(u32)(((_Len)>>8) + ((_Len)&0xFF ? 1:0))
+#define PageNum_512(_Len)		(u32)(((_Len)>>9) + ((_Len)&0x1FF ? 1:0))
+#define PageNum(_Len, _Size)		(u32)(((_Len)/(_Size)) + ((_Len)&((_Size) - 1) ? 1:0))
+
+struct dbg_rx_counter
+{
+	u32	rx_pkt_ok;
+	u32	rx_pkt_crc_error;
+	u32	rx_pkt_drop;
+	u32	rx_ofdm_fa;
+	u32	rx_cck_fa;
+	u32	rx_ht_fa;
+};
+void rtw_dump_mac_rx_counters(_adapter* padapter,struct dbg_rx_counter *rx_counter);
+void rtw_dump_phy_rx_counters(_adapter* padapter,struct dbg_rx_counter *rx_counter);
+void rtw_reset_mac_rx_counters(_adapter* padapter);
+void rtw_reset_phy_rx_counters(_adapter* padapter);
+
+#ifdef DBG_RX_COUNTER_DUMP
+#define DUMP_DRV_RX_COUNTER	BIT0
+#define DUMP_MAC_RX_COUNTER	BIT1
+#define DUMP_PHY_RX_COUNTER	BIT2
+#define DUMP_DRV_TRX_COUNTER_DATA	BIT3
+
+void rtw_dump_phy_rxcnts_preprocess(_adapter* padapter,u8 rx_cnt_mode);
+void rtw_dump_rx_counters(_adapter* padapter);
+#endif
+
+void dump_chip_info(HAL_VERSION	ChipVersion);
+void rtw_hal_config_rftype(PADAPTER  padapter);
+
+#define BAND_CAP_2G			BIT0
+#define BAND_CAP_5G			BIT1
+#define BAND_CAP_BIT_NUM	2
+
+#define BW_CAP_5M		BIT0
+#define BW_CAP_10M		BIT1
+#define BW_CAP_20M		BIT2
+#define BW_CAP_40M		BIT3
+#define BW_CAP_80M		BIT4
+#define BW_CAP_160M		BIT5
+#define BW_CAP_80_80M	BIT6
+#define BW_CAP_BIT_NUM	7
+
+#define PROTO_CAP_11B		BIT0
+#define PROTO_CAP_11G		BIT1
+#define PROTO_CAP_11N		BIT2
+#define PROTO_CAP_11AC		BIT3
+#define PROTO_CAP_BIT_NUM	4
+
+#define WL_FUNC_P2P			BIT0
+#define WL_FUNC_MIRACAST	BIT1
+#define WL_FUNC_TDLS		BIT2
+#define WL_FUNC_FTM			BIT3
+#define WL_FUNC_BIT_NUM		4
+
+int hal_spec_init(_adapter *adapter);
+void dump_hal_spec(void *sel, _adapter *adapter);
+
+bool hal_chk_band_cap(_adapter *adapter, u8 cap);
+bool hal_chk_bw_cap(_adapter *adapter, u8 cap);
+bool hal_chk_proto_cap(_adapter *adapter, u8 cap);
+bool hal_is_band_support(_adapter *adapter, u8 band);
+bool hal_is_bw_support(_adapter *adapter, u8 bw);
+bool hal_is_wireless_mode_support(_adapter *adapter, u8 mode);
+u8 hal_largest_bw(_adapter *adapter, u8 in_bw);
+
+bool hal_chk_wl_func(_adapter *adapter, u8 func);
+
+u8	//return the final channel plan decision
+hal_com_config_channel_plan(
+	IN	PADAPTER	padapter,
+	IN	u8			hw_channel_plan,	//channel plan from HW (efuse/eeprom)
+	IN	u8			sw_channel_plan,	//channel plan from SW (registry/module param)
+	IN	u8			def_channel_plan,	//channel plan used when the former two is invalid
+	IN	BOOLEAN		AutoLoadFail
+	);
+
+int hal_config_macaddr(_adapter *adapter, bool autoload_fail);
+
+BOOLEAN
+HAL_IsLegalChannel(
+	IN	PADAPTER	Adapter,
+	IN	u32			Channel
+	);
+
+u8	MRateToHwRate(u8 rate);
+
+u8	HwRateToMRate(u8 rate);
+
+void	HalSetBrateCfg(
+	IN PADAPTER		Adapter,
+	IN u8			*mBratesOS,
+	OUT u16			*pBrateCfg);
+
+BOOLEAN
+Hal_MappingOutPipe(
+	IN	PADAPTER	pAdapter,
+	IN	u8		NumOutPipe
+	);
+
+void hal_init_macaddr(_adapter *adapter);
+
+void rtw_init_hal_com_default_value(PADAPTER Adapter);
+
+void c2h_evt_clear(_adapter *adapter);
+s32 c2h_evt_read(_adapter *adapter, u8 *buf);
+s32 c2h_evt_read_88xx(_adapter *adapter, u8 *buf);
+
+u8  rtw_hal_networktype_to_raid(_adapter *adapter, struct sta_info *psta);
+u8 rtw_get_mgntframe_raid(_adapter *adapter,unsigned char network_type);
+void rtw_hal_update_sta_rate_mask(PADAPTER padapter, struct sta_info *psta);
+
+/* access HW only */
+u32 rtw_sec_read_cam(_adapter *adapter, u8 addr);
+void rtw_sec_write_cam(_adapter *adapter, u8 addr, u32 wdata);
+void rtw_sec_read_cam_ent(_adapter *adapter, u8 id, u8 *ctrl, u8 *mac, u8 *key);
+void rtw_sec_write_cam_ent(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+bool rtw_sec_read_cam_is_gk(_adapter *adapter, u8 id);
+
+void hw_var_port_switch(_adapter *adapter);
+
+void SetHwReg(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg(PADAPTER padapter, u8 variable, u8 *val);
+void rtw_hal_check_rxfifo_full(_adapter *adapter);
+
+u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
+u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
+
+BOOLEAN
+eqNByte(
+	u8*	str1,
+	u8*	str2,
+	u32	num
+	);
+
+BOOLEAN
+IsHexDigit(
+	IN	char	chTmp
+	);
+
+u32
+MapCharToHexDigit(
+	IN	char	chTmp
+);
+
+BOOLEAN
+GetHexValueFromString(
+	IN		char*			szStr,
+	IN OUT	u32*			pu4bVal,
+	IN OUT	u32*			pu4bMove
+	);
+
+BOOLEAN
+GetFractionValueFromString(
+	IN		char*		szStr,
+	IN OUT	u8*			pInteger,
+	IN OUT	u8*			pFraction,
+	IN OUT	u32*		pu4bMove
+	);
+
+BOOLEAN
+IsCommentString(
+	IN		char*		szStr
+	);
+
+BOOLEAN
+ParseQualifiedString(
+    IN	char* In,
+    IN OUT  u32* Start,
+    OUT	char* Out,
+    IN	char  LeftQualifier,
+    IN	char  RightQualifier
+    );
+
+BOOLEAN
+GetU1ByteIntegerFromStringInDecimal(
+	IN		char* Str,
+	IN OUT	u8* pInt
+	);
+
+BOOLEAN
+isAllSpaceOrTab(
+	u8*	data,
+	u8	size
+	);
+
+void linked_info_dump(_adapter *padapter,u8 benable);
+#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
+void rtw_get_raw_rssi_info(void *sel, _adapter *padapter);
+void rtw_store_phy_info(_adapter *padapter, union recv_frame *prframe);
+void rtw_dump_raw_rssi_info(_adapter *padapter);
+#endif
+
+#define		HWSET_MAX_SIZE			512
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+#define		EFUSE_FILE_COLUMN_NUM		16
+u32 Hal_readPGDataFromConfigFile(PADAPTER padapter);
+u32 Hal_ReadMACAddrFromFile(PADAPTER padapter, u8 *mac_addr);
+#endif /* CONFIG_EFUSE_CONFIG_FILE */
+
+int check_phy_efuse_tx_power_info_valid(PADAPTER padapter);
+int hal_efuse_macaddr_offset(_adapter *adapter);
+int Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8 *mac_addr);
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+void rtw_bb_rf_gain_offset(_adapter *padapter);
+#endif //CONFIG_RF_GAIN_OFFSET
+
+void dm_DynamicUsbTxAgg(_adapter *padapter, u8 from_timer);
+u8 rtw_hal_busagg_qsel_check(_adapter *padapter,u8 pre_qsel,u8 next_qsel);
+void GetHalODMVar(
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	PVOID					pValue1,
+	PVOID					pValue2);
+void SetHalODMVar(
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	PVOID					pValue1,
+	BOOLEAN					bSet);
+
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+struct noise_info
+{
+	u8 		bPauseDIG;
+	u8 		IGIValue;
+	u32 	max_time;//ms
+	u8		chan;
+};
+#endif
+
+void rtw_get_noise(_adapter* padapter);
+
+void rtw_hal_set_fw_rsvd_page(_adapter* adapter, bool finished);
+
+#ifdef CONFIG_GPIO_API
+u8 rtw_hal_get_gpio(_adapter* adapter, u8 gpio_num);
+int rtw_hal_set_gpio_output_value(_adapter* adapter, u8 gpio_num, bool isHigh);
+int rtw_hal_config_gpio(_adapter* adapter, u8 gpio_num, bool isOutput);
+int rtw_hal_register_gpio_interrupt(_adapter* adapter, int gpio_num, void(*callback)(u8 level));
+int rtw_hal_disable_gpio_interrupt(_adapter* adapter, int gpio_num);
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+void rtw_hal_set_output_gpio(_adapter *padapter, u8 index, u8 outputval);
+#endif
+
+typedef enum _HAL_PHYDM_OPS {
+	HAL_PHYDM_DIS_ALL_FUNC,
+	HAL_PHYDM_FUNC_SET,
+	HAL_PHYDM_FUNC_CLR,
+	HAL_PHYDM_ABILITY_BK,
+	HAL_PHYDM_ABILITY_RESTORE,
+	HAL_PHYDM_ABILITY_SET,
+	HAL_PHYDM_ABILITY_GET,
+} HAL_PHYDM_OPS;
+
+
+#define DYNAMIC_FUNC_DISABLE		(0x0)
+u32 rtw_phydm_ability_ops(_adapter *adapter, HAL_PHYDM_OPS ops, u32 ability);
+
+#define rtw_phydm_func_disable_all(adapter)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0)
+
+#define rtw_phydm_func_for_offchannel(adapter) \
+	do { \
+		rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0); \
+		if (rtw_odm_adaptivity_needed(adapter)) \
+			rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ODM_BB_ADAPTIVITY); \
+	} while (0)
+
+#define rtw_phydm_func_set(adapter, ability)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ability)
+
+#define rtw_phydm_func_clr(adapter, ability)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_CLR, ability)
+
+#define rtw_phydm_ability_backup(adapter)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_BK, 0)
+
+#define rtw_phydm_ability_restore(adapter)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_RESTORE, 0)
+
+#define rtw_phydm_ability_set(adapter, ability)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_SET, ability)
+
+static inline u32 rtw_phydm_ability_get(_adapter *adapter)
+{
+	return rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_GET, 0);
+}
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+extern char *rtw_phy_file_path;
+extern char file__path[PATH_LENGTH_MAX];
+#define GetLineFromBuffer(buffer)   strsep(&buffer, "\r\n")
+#endif
+
+#ifdef CONFIG_FW_C2H_DEBUG
+void Debug_FwC2H(PADAPTER padapter, u8 *pdata, u8 len);
+#endif
+/*CONFIG_FW_C2H_DEBUG*/
+
+void update_IOT_info(_adapter *padapter);
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+void rtw_acs_start(_adapter *padapter, bool bStart);
+#endif
+
+void hal_set_crystal_cap(_adapter *adapter, u8 crystal_cap);
+
+#endif //__HAL_COMMON_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_h2c.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_h2c.h
new file mode 100644
index 000000000..7d94c1c3a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_h2c.h
@@ -0,0 +1,363 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __COMMON_H2C_H__
+#define __COMMON_H2C_H__
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD DEFINITION    ------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+// 88e, 8723b, 8812, 8821, 92e use the same FW code base
+enum h2c_cmd{
+	//Common Class: 000
+	H2C_RSVD_PAGE = 0x00,
+	H2C_MEDIA_STATUS_RPT = 0x01,
+	H2C_SCAN_ENABLE = 0x02,
+	H2C_KEEP_ALIVE = 0x03,
+	H2C_DISCON_DECISION = 0x04,
+	H2C_PSD_OFFLOAD = 0x05,
+	H2C_AP_OFFLOAD = 0x08,
+	H2C_BCN_RSVDPAGE = 0x09,
+	H2C_PROBERSP_RSVDPAGE = 0x0A,
+	H2C_FCS_RSVDPAGE = 0x10,
+	H2C_FCS_INFO = 0x11,
+	H2C_AP_WOW_GPIO_CTRL = 0x13,
+
+	//PoweSave Class: 001
+	H2C_SET_PWR_MODE = 0x20,
+	H2C_PS_TUNING_PARA = 0x21,
+	H2C_PS_TUNING_PARA2 = 0x22,
+	H2C_P2P_LPS_PARAM = 0x23,
+	H2C_P2P_PS_OFFLOAD = 0x24,
+	H2C_PS_SCAN_ENABLE = 0x25,
+	H2C_SAP_PS_ = 0x26,
+	H2C_INACTIVE_PS_ = 0x27, //Inactive_PS
+	H2C_FWLPS_IN_IPS_ = 0x28,
+
+	//Dynamic Mechanism Class: 010
+	H2C_MACID_CFG = 0x40,
+	H2C_TXBF = 0x41,
+	H2C_RSSI_SETTING = 0x42,
+	H2C_AP_REQ_TXRPT = 0x43,
+	H2C_INIT_RATE_COLLECT = 0x44,
+	H2C_IQ_CALIBRATION	= 0x45,
+
+	H2C_RA_MASK_3SS = 0x46,/* for 8814A */
+	H2C_RA_PARA_ADJUST = 0x47,/* CONFIG_RA_DBG_CMD */
+	H2C_DYNAMIC_TX_PATH = 0x48,/* for 8814A */
+
+	H2C_FW_TRACE_EN = 0x49,
+
+	//BT Class: 011
+	H2C_B_TYPE_TDMA = 0x60,
+	H2C_BT_INFO = 0x61,
+	H2C_FORCE_BT_TXPWR = 0x62,
+	H2C_BT_IGNORE_WLANACT = 0x63,
+	H2C_DAC_SWING_VALUE = 0x64,
+	H2C_ANT_SEL_RSV = 0x65,
+	H2C_WL_OPMODE = 0x66,
+	H2C_BT_MP_OPER = 0x67,
+	H2C_BT_CONTROL = 0x68,
+	H2C_BT_WIFI_CTRL = 0x69,
+	H2C_BT_FW_PATCH = 0x6A,
+
+	//WOWLAN Class: 100
+	H2C_WOWLAN = 0x80,
+	H2C_REMOTE_WAKE_CTRL = 0x81,
+	H2C_AOAC_GLOBAL_INFO = 0x82,
+	H2C_AOAC_RSVD_PAGE = 0x83,
+	H2C_AOAC_RSVD_PAGE2 = 0x84,
+	H2C_D0_SCAN_OFFLOAD_CTRL = 0x85,
+	H2C_D0_SCAN_OFFLOAD_INFO = 0x86,
+	H2C_CHNL_SWITCH_OFFLOAD = 0x87,
+	H2C_AOAC_RSVDPAGE3 = 0x88,
+	H2C_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
+	H2C_P2P_OFFLOAD = 0x8B,
+
+	H2C_RESET_TSF = 0xC0,
+	H2C_BCNHWSEQ = 0xC2,
+	H2C_MAXID,
+};
+
+#define H2C_INACTIVE_PS_LEN		3
+#define H2C_RSVDPAGE_LOC_LEN		5
+#define H2C_MEDIA_STATUS_RPT_LEN		3
+#define H2C_KEEP_ALIVE_CTRL_LEN	2
+#define H2C_DISCON_DECISION_LEN	 	3
+#define H2C_AP_OFFLOAD_LEN		3
+#define H2C_AP_WOW_GPIO_CTRL_LEN	4
+#define H2C_AP_PS_LEN			2
+#define H2C_PWRMODE_LEN			7
+#define H2C_PSTUNEPARAM_LEN			4
+#define H2C_MACID_CFG_LEN	 	7
+#define H2C_BTMP_OPER_LEN			5
+#define H2C_WOWLAN_LEN			5
+#define H2C_REMOTE_WAKE_CTRL_LEN	3
+#define H2C_AOAC_GLOBAL_INFO_LEN	2
+#define H2C_AOAC_RSVDPAGE_LOC_LEN	7
+#define H2C_SCAN_OFFLOAD_CTRL_LEN	4
+#define H2C_BT_FW_PATCH_LEN			6
+#define H2C_RSSI_SETTING_LEN		4
+#define H2C_AP_REQ_TXRPT_LEN		2
+#define H2C_FORCE_BT_TXPWR_LEN		3
+#define H2C_BCN_RSVDPAGE_LEN		5
+#define H2C_PROBERSP_RSVDPAGE_LEN	5
+#define H2C_P2PRSVDPAGE_LOC_LEN	5
+#define H2C_P2P_OFFLOAD_LEN	3
+
+#define eqMacAddr(a,b)						( ((a)[0]==(b)[0] && (a)[1]==(b)[1] && (a)[2]==(b)[2] && (a)[3]==(b)[3] && (a)[4]==(b)[4] && (a)[5]==(b)[5]) ? 1:0 )
+#define cpMacAddr(des,src)					((des)[0]=(src)[0],(des)[1]=(src)[1],(des)[2]=(src)[2],(des)[3]=(src)[3],(des)[4]=(src)[4],(des)[5]=(src)[5])
+#define cpIpAddr(des,src)					((des)[0]=(src)[0],(des)[1]=(src)[1],(des)[2]=(src)[2],(des)[3]=(src)[3])
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+//
+// ARP packet
+//
+// LLC Header
+#define GET_ARP_PKT_LLC_TYPE(__pHeader)					ReadLE2Byte(((u8 *)(__pHeader)) + 6)
+
+//ARP element
+#define GET_ARP_PKT_OPERATION(__pHeader)				ReadLE2Byte(((u8 *)(__pHeader)) + 6)
+#define GET_ARP_PKT_SENDER_MAC_ADDR(__pHeader, _val) 	cpMacAddr((u8*)(_val), ((u8*)(__pHeader))+8)
+#define GET_ARP_PKT_SENDER_IP_ADDR(__pHeader, _val) 		cpIpAddr((u8*)(_val), ((u8*)(__pHeader))+14)
+#define GET_ARP_PKT_TARGET_MAC_ADDR(__pHeader, _val) 	cpMacAddr((u8*)(_val), ((u8*)(__pHeader))+18)
+#define GET_ARP_PKT_TARGET_IP_ADDR(__pHeader, _val) 	cpIpAddr((u8*)(_val), ((u8*)(__pHeader))+24)
+
+#define SET_ARP_PKT_HW(__pHeader, __Value)					WriteLE2Byte(((u8 *)(__pHeader)) + 0, __Value)
+#define SET_ARP_PKT_PROTOCOL(__pHeader, __Value)			WriteLE2Byte(((u8 *)(__pHeader)) + 2, __Value)
+#define SET_ARP_PKT_HW_ADDR_LEN(__pHeader, __Value)			WriteLE1Byte(((u8 *)(__pHeader)) + 4, __Value)
+#define SET_ARP_PKT_PROTOCOL_ADDR_LEN(__pHeader, __Value)	WriteLE1Byte(((u8 *)(__pHeader)) + 5, __Value)
+#define SET_ARP_PKT_OPERATION(__pHeader, __Value)			WriteLE2Byte(((u8 *)(__pHeader)) + 6, __Value)
+#define SET_ARP_PKT_SENDER_MAC_ADDR(__pHeader, _val) 	cpMacAddr(((u8*)(__pHeader))+8, (u8*)(_val))
+#define SET_ARP_PKT_SENDER_IP_ADDR(__pHeader, _val) 		cpIpAddr(((u8*)(__pHeader))+14, (u8*)(_val))
+#define SET_ARP_PKT_TARGET_MAC_ADDR(__pHeader, _val) 	cpMacAddr(((u8*)(__pHeader))+18, (u8*)(_val))
+#define SET_ARP_PKT_TARGET_IP_ADDR(__pHeader, _val) 		cpIpAddr(((u8*)(__pHeader))+24, (u8*)(_val))
+
+#define FW_WOWLAN_FUN_EN				BIT(0)
+#define FW_WOWLAN_PATTERN_MATCH			BIT(1)
+#define FW_WOWLAN_MAGIC_PKT				BIT(2)
+#define FW_WOWLAN_UNICAST				BIT(3)
+#define FW_WOWLAN_ALL_PKT_DROP			BIT(4)
+#define FW_WOWLAN_GPIO_ACTIVE			BIT(5)
+#define FW_WOWLAN_REKEY_WAKEUP			BIT(6)
+#define FW_WOWLAN_DEAUTH_WAKEUP			BIT(7)
+
+#define FW_WOWLAN_GPIO_WAKEUP_EN		BIT(0)
+#define FW_FW_PARSE_MAGIC_PKT			BIT(1)
+
+#define FW_REMOTE_WAKE_CTRL_EN			BIT(0)
+#define FW_REALWOWLAN_EN				BIT(5)
+
+#define FW_WOWLAN_KEEP_ALIVE_EN			BIT(0)
+#define FW_ADOPT_USER					BIT(1)
+#define FW_WOWLAN_KEEP_ALIVE_PKT_TYPE	BIT(2)
+
+#define FW_REMOTE_WAKE_CTRL_EN			BIT(0)
+#define FW_ARP_EN						BIT(1)
+#define FW_REALWOWLAN_EN				BIT(5)
+#define FW_WOW_FW_UNICAST_EN			BIT(7)
+
+#endif //CONFIG_WOWLAN
+
+//_RSVDPAGE_LOC_CMD_0x00
+#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+//_MEDIA_STATUS_RPT_PARM_CMD_0x01
+#define SET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 1, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 2, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 3, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 4, 4, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 1, 0, 8, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 2, 0, 8, (__Value))
+
+#define GET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 0, 1)
+#define GET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 2, 1)
+#define GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd)	LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 3, 1)
+#define GET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd)			LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 4, 4)
+
+#define H2C_MSR_ROLE_RSVD	0
+#define H2C_MSR_ROLE_STA	1
+#define H2C_MSR_ROLE_AP		2
+#define H2C_MSR_ROLE_GC		3
+#define H2C_MSR_ROLE_GO		4
+#define H2C_MSR_ROLE_TDLS	5
+#define H2C_MSR_ROLE_MAX	6
+
+extern const char * const _h2c_msr_role_str[];
+#define h2c_msr_role_str(role) (((role) >= H2C_MSR_ROLE_MAX) ? _h2c_msr_role_str[H2C_MSR_ROLE_MAX] : _h2c_msr_role_str[(role)])
+
+#define H2C_MSR_FMT "%s %s%s"
+#define H2C_MSR_ARG(h2c_msr) \
+	GET_H2CCMD_MSRRPT_PARM_OPMODE((h2c_msr)) ? " C" : "", \
+	h2c_msr_role_str(GET_H2CCMD_MSRRPT_PARM_ROLE((h2c_msr))), \
+	GET_H2CCMD_MSRRPT_PARM_MIRACAST((h2c_msr)) ? (GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK((h2c_msr)) ? " MSINK" : " MSRC") : ""
+
+s32 rtw_hal_set_FwMediaStatusRpt_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, bool macid_ind, u8 macid_end);
+s32 rtw_hal_set_FwMediaStatusRpt_single_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid);
+s32 rtw_hal_set_FwMediaStatusRpt_range_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, u8 macid_end);
+
+//_KEEP_ALIVE_CMD_0x03
+#define SET_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+
+//_DISCONNECT_DECISION_CMD_0x04
+#define SET_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+
+//_AP_Offload 0x08
+#define SET_H2CCMD_AP_WOWLAN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+//_BCN_RsvdPage	0x09
+#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_BCN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+//_Probersp_RsvdPage 0x0a
+#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_ProbeRsp(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+//_Probersp_RsvdPage 0x13
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_INDEX(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_PLUS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_HIGH_ACTIVE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_DURATION(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+//_AP_PS 0x26
+#define SET_H2CCMD_AP_WOW_PS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_AP_WOW_PS_32K_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_AP_WOW_PS_RF(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_AP_WOW_PS_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+
+// _WoWLAN PARAM_CMD_0x80
+#define SET_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_H2CCMD_WOWLAN_ALL_PKT_DROP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_ACTIVE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_H2CCMD_WOWLAN_REKEY_WAKE_UP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+#define SET_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 7, __Value)
+#define SET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 7, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 1, 7, __Value)
+#define SET_H2CCMD_WOWLAN_LOWPR_RX(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_CHANGE_UNIT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 2, 1, __Value)
+// _REMOTE_WAKEUP_CMD_0x81
+#define SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_NDP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_NBNS_FILTER_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 2, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_PARSING_UNTIL_WAKEUP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 4, 1, __Value)
+
+// AOAC_GLOBAL_INFO_0x82
+#define SET_H2CCMD_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+
+// AOAC_RSVDPAGE_LOC_0x83
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NEIGHBOR_ADV(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#ifdef CONFIG_GTK_OL
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_EXT_MEM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+#endif //CONFIG_GTK_OL
+#ifdef CONFIG_PNO_SUPPORT
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NLO_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+// D0_Scan_Offload_Info_0x86
+#define SET_H2CCMD_AOAC_NLO_FUN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 3, 1, __Value)
+#define SET_H2CCMD_AOAC_NLO_IPS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 4, 1, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_PROBE_PACKET(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SCAN_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#endif //CONFIG_PNO_SUPPORT
+
+#ifdef CONFIG_P2P_WOWLAN
+//P2P_RsvdPage_0x8a
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#endif //CONFIG_P2P_WOWLAN
+
+//---------------------------------------------------------------------------------------------------------//
+//-------------------------------------------    Structure    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+typedef struct _RSVDPAGE_LOC {
+	u8 LocProbeRsp;
+	u8 LocPsPoll;
+	u8 LocNullData;
+	u8 LocQosNull;
+	u8 LocBTQosNull;
+#ifdef CONFIG_WOWLAN
+	u8 LocRemoteCtrlInfo;
+	u8 LocArpRsp;
+	u8 LocNbrAdv;
+	u8 LocGTKRsp;
+	u8 LocGTKInfo;
+	u8 LocProbeReq;
+	u8 LocNetList;
+#ifdef CONFIG_GTK_OL
+	u8 LocGTKEXTMEM;
+#endif //CONFIG_GTK_OL
+#ifdef CONFIG_PNO_SUPPORT
+	u8 LocPNOInfo;
+	u8 LocScanInfo;
+	u8 LocSSIDInfo;
+	u8 LocProbePacket;
+#endif //CONFIG_PNO_SUPPORT
+#endif //CONFIG_WOWLAN
+	u8 LocApOffloadBCN;
+#ifdef CONFIG_P2P_WOWLAN
+	u8 LocP2PBeacon;
+	u8 LocP2PProbeRsp;
+	u8 LocNegoRsp;
+	u8 LocInviteRsp;
+	u8 LocPDRsp;
+#endif //CONFIG_P2P_WOWLAN
+} RSVDPAGE_LOC, *PRSVDPAGE_LOC;
+
+#endif
+void dump_TX_FIFO(PADAPTER padapter, u8 page_num, u16 page_size);
+u8 rtw_hal_set_fw_media_status_cmd(_adapter* adapter, u8 mstatus, u8 macid);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+//WOW command function
+void rtw_hal_set_fw_wow_related_cmd(_adapter* padapter, u8 enable);
+#ifdef CONFIG_P2P_WOWLAN
+//H2C 0x8A
+u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter* adapter, PRSVDPAGE_LOC rsvdpageloc);
+//H2C 0x8B
+u8 rtw_hal_set_p2p_wowlan_offload_cmd(_adapter* adapter);
+#endif //CONFIG_P2P_WOWLAN
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_led.h
new file mode 100644
index 000000000..372682587
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_led.h
@@ -0,0 +1,398 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_LED_H_
+#define __HAL_COMMON_LED_H_
+
+
+#define MSECS(t)        (HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
+
+//================================================================================
+//	LED Behavior Constant.
+//================================================================================
+// Default LED behavior.
+//
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+#define LED_INITIAL_INTERVAL		1800
+
+// LED Customerization
+
+//NETTRONIX
+#define LED_BLINK_NORMAL_INTERVAL_NETTRONIX	100
+#define LED_BLINK_SLOWLY_INTERVAL_NETTRONIX	2000
+
+//PORNET
+#define LED_BLINK_SLOWLY_INTERVAL_PORNET	1000
+#define LED_BLINK_NORMAL_INTERVAL_PORNET	100
+#define LED_BLINK_FAST_INTERVAL_BITLAND		30
+
+//AzWave.
+#define LED_CM2_BLINK_ON_INTERVAL		250
+#define LED_CM2_BLINK_OFF_INTERVAL		4750
+#define LED_CM8_BLINK_OFF_INTERVAL		3750	//for QMI
+
+//RunTop
+#define LED_RunTop_BLINK_INTERVAL		300
+
+//ALPHA
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA_500MS 500 //add by ylb 20121012 for customer led for alpha
+#define LED_BLINK_LINK_INTERVAL_ALPHA		500	//500
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180 	//150
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+// 111122 by hpfan: Customized for Xavi
+#define LED_CM11_BLINK_INTERVAL			300
+#define LED_CM11_LINK_ON_INTERVEL		3000
+
+//Netgear
+#define LED_BLINK_LINK_INTERVAL_NETGEAR		500
+#define LED_BLINK_LINK_SLOWLY_INTERVAL_NETGEAR		1000
+
+#define LED_WPS_BLINK_OFF_INTERVAL_NETGEAR		100
+#define LED_WPS_BLINK_ON_INTERVAL_NETGEAR		500
+
+//Belkin AC950
+#define LED_BLINK_LINK_INTERVAL_ON_BELKIN		200
+#define LED_BLINK_LINK_INTERVAL_OFF_BELKIN		100
+#define LED_BLINK_ERROR_INTERVAL_BELKIN		100
+
+//by chiyokolin for Azurewave
+#define LED_CM12_BLINK_INTERVAL_5Mbps		160
+#define LED_CM12_BLINK_INTERVAL_10Mbps		80
+#define LED_CM12_BLINK_INTERVAL_20Mbps		50
+#define LED_CM12_BLINK_INTERVAL_40Mbps		40
+#define LED_CM12_BLINK_INTERVAL_80Mbps		30
+#define LED_CM12_BLINK_INTERVAL_MAXMbps		25
+
+//Dlink
+#define	LED_BLINK_NO_LINK_INTERVAL		1000
+#define	LED_BLINK_LINK_IDEL_INTERVAL		100
+
+#define	LED_BLINK_SCAN_ON_INTERVAL		30
+#define	LED_BLINK_SCAN_OFF_INTERVAL		300
+
+#define LED_WPS_BLINK_ON_INTERVAL_DLINK		30
+#define LED_WPS_BLINK_OFF_INTERVAL_DLINK			300
+#define LED_WPS_BLINK_LINKED_ON_INTERVAL_DLINK			5000
+
+//================================================================================
+// LED object.
+//================================================================================
+
+typedef enum _LED_CTL_MODE{
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+	LED_CTL_START_WPS_BOTTON = 11, //added for runtop
+	LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, //added for BELKIN
+	LED_CTL_CONNECTION_NO_TRANSFER = 14,
+}LED_CTL_MODE;
+
+typedef	enum _LED_STATE{
+	LED_UNKNOWN = 0,
+	RTW_LED_ON = 1,
+	RTW_LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_BLINK_POWER_ON = 5,
+	LED_BLINK_SCAN = 6, 	// LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
+	LED_BLINK_NO_LINK = 7, // LED is blinking during no link state.
+	LED_BLINK_StartToBlink = 8, // Customzied for Sercomm Printer Server case
+	LED_BLINK_TXRX = 9,
+	LED_BLINK_WPS = 10,	// LED is blinkg during WPS communication
+	LED_BLINK_WPS_STOP = 11,	//for ALPHA
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	//for BELKIN
+	LED_BLINK_RUNTOP = 13, 	// Customized for RunTop
+	LED_BLINK_CAMEO = 14,
+	LED_BLINK_XAVI = 15,
+	LED_BLINK_ALWAYS_ON = 16,
+	LED_BLINK_LINK_IN_PROCESS = 17,  //Customized for Belkin AC950
+	LED_BLINK_AUTH_ERROR = 18,  //Customized for Belkin AC950
+	LED_BLINK_Azurewave_5Mbps = 19,
+	LED_BLINK_Azurewave_10Mbps = 20,
+	LED_BLINK_Azurewave_20Mbps = 21,
+	LED_BLINK_Azurewave_40Mbps = 22,
+	LED_BLINK_Azurewave_80Mbps = 23,
+	LED_BLINK_Azurewave_MAXMbps = 24,
+	LED_BLINK_LINK_IDEL = 25,
+	LED_BLINK_WPS_LINKED = 26,
+}LED_STATE;
+
+typedef enum _LED_PIN{
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1,
+	LED_PIN_LED2
+}LED_PIN;
+
+
+//================================================================================
+// PCIE LED Definition.
+//================================================================================
+#ifdef CONFIG_PCI_HCI
+typedef	enum _LED_STRATEGY_PCIE{
+	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
+	SW_LED_MODE1, // SW control for PCI Express
+	SW_LED_MODE2, // SW control for Cameo.
+	SW_LED_MODE3, // SW contorl for RunTop.
+	SW_LED_MODE4, // SW control for Netcore
+	SW_LED_MODE5, //added by vivi, for led new mode, DLINK
+	SW_LED_MODE6, //added by vivi, for led new mode, PRONET
+	SW_LED_MODE7, //added by chiyokolin, for Lenovo, PCI Express Minicard Spec Rev.1.2 spec
+	SW_LED_MODE8, //added by chiyokolin, for QMI
+	SW_LED_MODE9, //added by chiyokolin, for BITLAND-LENOVO, PCI Express Minicard Spec Rev.1.1
+	SW_LED_MODE10, //added by chiyokolin, for Edimax-ASUS
+	SW_LED_MODE11,	//added by hpfan, for Xavi
+	SW_LED_MODE12,	//added by chiyokolin, for Azurewave
+	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes)
+}LED_STRATEGY_PCIE, *PLED_STRATEGY_PCIE;
+
+typedef struct _LED_PCIE{
+	PADAPTER		padapter;
+
+	LED_PIN			LedPin;	// Identify how to implement this SW led.
+
+	LED_STATE		CurrLedState; // Current LED state.
+	BOOLEAN			bLedOn; // TRUE if LED is ON, FALSE if LED is OFF.
+
+	BOOLEAN			bLedBlinkInProgress; // TRUE if it is blinking, FALSE o.w..
+	BOOLEAN			bLedWPSBlinkInProgress; // TRUE if it is blinking, FALSE o.w..
+
+	BOOLEAN			bLedSlowBlinkInProgress;//added by vivi, for led new mode
+	u32				BlinkTimes; // Number of times to toggle led state for blinking.
+	LED_STATE		BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
+
+	_timer			BlinkTimer; // Timer object for led blinking.
+} LED_PCIE, *PLED_PCIE;
+
+typedef struct _LED_PCIE	LED_DATA, *PLED_DATA;
+typedef enum _LED_STRATEGY_PCIE	LED_STRATEGY, *PLED_STRATEGY;
+
+VOID
+LedControlPCIE(
+	IN	PADAPTER		Adapter,
+	IN	LED_CTL_MODE		LedAction
+	);
+
+VOID
+gen_RefreshLedState(
+	IN	PADAPTER		Adapter);
+
+//================================================================================
+// USB  LED Definition.
+//================================================================================
+#elif defined(CONFIG_USB_HCI)
+
+#define IS_LED_WPS_BLINKING(_LED_USB)	(((PLED_USB)_LED_USB)->CurrLedState==LED_BLINK_WPS \
+					|| ((PLED_USB)_LED_USB)->CurrLedState==LED_BLINK_WPS_STOP \
+					|| ((PLED_USB)_LED_USB)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_USB) 	(((PLED_USB)_LED_USB)->bLedWPSBlinkInProgress \
+					||((PLED_USB)_LED_USB)->bLedScanBlinkInProgress)
+
+
+typedef	enum _LED_STRATEGY_USB{
+	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
+	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
+	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
+	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
+	SW_LED_MODE4, //for Edimax / Belkin
+	SW_LED_MODE5, //for Sercomm / Belkin
+	SW_LED_MODE6,	//for 88CU minicard, porting from ce SW_LED_MODE7
+	SW_LED_MODE7,	//for Netgear special requirement
+	SW_LED_MODE8, //for LC
+	SW_LED_MODE9, //for Belkin AC950
+	SW_LED_MODE10, //for Netgear A6200V2
+	SW_LED_MODE11, //for Edimax / ASUS
+	SW_LED_MODE12, //for WNC/NEC
+	SW_LED_MODE13, //for Netgear A6100, 8811Au
+	SW_LED_MODE14, //for Buffalo, DNI, 8811Au
+	SW_LED_MODE15, //for DLINK,  8811Au/8812AU
+	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
+}LED_STRATEGY_USB, *PLED_STRATEGY_USB;
+
+
+typedef struct _LED_USB{
+	PADAPTER			padapter;
+
+	LED_PIN				LedPin;	// Identify how to implement this SW led.
+
+	LED_STATE			CurrLedState; // Current LED state.
+	BOOLEAN				bLedOn; // TRUE if LED is ON, FALSE if LED is OFF.
+
+	BOOLEAN				bSWLedCtrl;
+
+	BOOLEAN				bLedBlinkInProgress; // TRUE if it is blinking, FALSE o.w..
+	// ALPHA, added by chiyoko, 20090106
+	BOOLEAN				bLedNoLinkBlinkInProgress;
+	BOOLEAN				bLedLinkBlinkInProgress;
+	BOOLEAN				bLedStartToLinkBlinkInProgress;
+	BOOLEAN				bLedScanBlinkInProgress;
+	BOOLEAN				bLedWPSBlinkInProgress;
+
+	u32					BlinkTimes; // Number of times to toggle led state for blinking.
+	u8					BlinkCounter; //Added for turn off overlap led after blinking a while, by page, 20120821
+	LED_STATE			BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
+
+	_timer				BlinkTimer; // Timer object for led blinking.
+
+	_workitem			BlinkWorkItem; // Workitem used by BlinkTimer to manipulate H/W to blink LED.'
+	ATOMIC_T			bCancelWorkItem; //check if WorkItem is cancelled
+} LED_USB, *PLED_USB;
+
+typedef struct _LED_USB	LED_DATA, *PLED_DATA;
+typedef enum _LED_STRATEGY_USB	LED_STRATEGY, *PLED_STRATEGY;
+
+VOID
+LedControlUSB(
+	IN	PADAPTER		Adapter,
+	IN	LED_CTL_MODE		LedAction
+	);
+
+
+//================================================================================
+// SDIO LED Definition.
+//================================================================================
+#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+
+#define IS_LED_WPS_BLINKING(_LED_SDIO)	(((PLED_SDIO)_LED_SDIO)->CurrLedState==LED_BLINK_WPS \
+					|| ((PLED_SDIO)_LED_SDIO)->CurrLedState==LED_BLINK_WPS_STOP \
+					|| ((PLED_SDIO)_LED_SDIO)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_SDIO) 	(((PLED_SDIO)_LED_SDIO)->bLedWPSBlinkInProgress \
+					||((PLED_SDIO)_LED_SDIO)->bLedScanBlinkInProgress)
+
+
+typedef	enum _LED_STRATEGY_SDIO{
+	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
+	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
+	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
+	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
+	SW_LED_MODE4, //for Edimax / Belkin
+	SW_LED_MODE5, //for Sercomm / Belkin
+	SW_LED_MODE6,	//for 88CU minicard, porting from ce SW_LED_MODE7
+	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
+}LED_STRATEGY_SDIO, *PLED_STRATEGY_SDIO;
+
+typedef struct _LED_SDIO{
+	PADAPTER			padapter;
+
+	LED_PIN				LedPin;	// Identify how to implement this SW led.
+
+	LED_STATE			CurrLedState; // Current LED state.
+	BOOLEAN				bLedOn; // TRUE if LED is ON, FALSE if LED is OFF.
+
+	BOOLEAN				bSWLedCtrl;
+
+	BOOLEAN				bLedBlinkInProgress; // TRUE if it is blinking, FALSE o.w..
+	// ALPHA, added by chiyoko, 20090106
+	BOOLEAN				bLedNoLinkBlinkInProgress;
+	BOOLEAN				bLedLinkBlinkInProgress;
+	BOOLEAN				bLedStartToLinkBlinkInProgress;
+	BOOLEAN				bLedScanBlinkInProgress;
+	BOOLEAN				bLedWPSBlinkInProgress;
+
+	u32					BlinkTimes; // Number of times to toggle led state for blinking.
+	LED_STATE			BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
+
+	_timer				BlinkTimer; // Timer object for led blinking.
+
+	_workitem			BlinkWorkItem; // Workitem used by BlinkTimer to manipulate H/W to blink LED.
+} LED_SDIO, *PLED_SDIO;
+
+typedef struct _LED_SDIO	LED_DATA, *PLED_DATA;
+typedef enum _LED_STRATEGY_SDIO	LED_STRATEGY, *PLED_STRATEGY;
+
+VOID
+LedControlSDIO(
+	IN	PADAPTER		Adapter,
+	IN	LED_CTL_MODE		LedAction
+	);
+
+#endif
+
+struct led_priv{
+	/* add for led controll */
+	LED_DATA			SwLed0;
+	LED_DATA			SwLed1;
+	LED_DATA			SwLed2;
+	LED_STRATEGY		LedStrategy;
+	u8					bRegUseLed;
+	void (*LedControlHandler)(_adapter *padapter, LED_CTL_MODE LedAction);
+	void (*SwLedOn)(_adapter *padapter, PLED_DATA pLed);
+	void (*SwLedOff)(_adapter *padapter, PLED_DATA pLed);
+	/* add for led controll */
+};
+
+#ifdef CONFIG_SW_LED
+#define rtw_led_control(adapter, LedAction) \
+	do { \
+		if((adapter)->ledpriv.LedControlHandler) \
+			(adapter)->ledpriv.LedControlHandler((adapter), (LedAction)); \
+	} while(0)
+#else //CONFIG_SW_LED
+#define rtw_led_control(adapter, LedAction)
+#endif //CONFIG_SW_LED
+
+#define SwLedOn(adapter, pLed) \
+	do { \
+		if((adapter)->ledpriv.SwLedOn) \
+			(adapter)->ledpriv.SwLedOn((adapter), (pLed)); \
+	} while(0)
+
+#define SwLedOff(adapter, pLed) \
+	do { \
+		if((adapter)->ledpriv.SwLedOff) \
+			(adapter)->ledpriv.SwLedOff((adapter), (pLed)); \
+	} while(0)
+
+void BlinkTimerCallback(struct timer_list *t);
+void BlinkWorkItemCallback(_workitem *work);
+
+void ResetLedStatus(PLED_DATA pLed);
+
+void
+InitLed(
+	_adapter			*padapter,
+	PLED_DATA		pLed,
+	LED_PIN			LedPin
+	);
+
+void
+DeInitLed(
+	PLED_DATA		pLed
+	);
+
+//hal...
+extern void BlinkHandler(PLED_DATA	pLed);
+
+#endif //__RTW_LED_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_phycfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_phycfg.h
new file mode 100644
index 000000000..7e9b2f6e1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_phycfg.h
@@ -0,0 +1,285 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COM_PHYCFG_H__
+#define __HAL_COM_PHYCFG_H__
+
+#define		PathA                     			0x0	// Useless
+#define		PathB                     			0x1
+#define		PathC                     			0x2
+#define		PathD                     			0x3
+
+typedef enum _RF_TX_NUM {
+	RF_1TX = 0,
+	RF_2TX,
+	RF_3TX,
+	RF_4TX,
+	RF_MAX_TX_NUM,
+	RF_TX_NUM_NONIMPLEMENT,
+} RF_TX_NUM;
+
+#define MAX_POWER_INDEX 		0x3F
+
+typedef enum _REGULATION_TXPWR_LMT {
+	TXPWR_LMT_FCC = 0,
+	TXPWR_LMT_MKK = 1,
+	TXPWR_LMT_ETSI = 2,
+	TXPWR_LMT_WW = 3,
+
+	TXPWR_LMT_MAX_REGULATION_NUM = 4
+} REGULATION_TXPWR_LMT;
+
+#define TX_PWR_LMT_REF_VHT_FROM_HT	BIT0
+#define TX_PWR_LMT_REF_HT_FROM_VHT	BIT1
+
+/*------------------------------Define structure----------------------------*/
+typedef struct _BB_REGISTER_DEFINITION{
+	u32 rfintfs;			// set software control:
+						//		0x870~0x877[8 bytes]
+
+	u32 rfintfo; 			// output data:
+						//		0x860~0x86f [16 bytes]
+
+	u32 rfintfe; 			// output enable:
+						//		0x860~0x86f [16 bytes]
+
+	u32 rf3wireOffset;	// LSSI data:
+						//		0x840~0x84f [16 bytes]
+
+	u32 rfHSSIPara2; 	// wire parameter control2 :
+						//		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes]
+
+	u32 rfLSSIReadBack; 	//LSSI RF readback data SI mode
+						//		0x8a0~0x8af [16 bytes]
+
+	u32 rfLSSIReadBackPi; 	//LSSI RF readback data PI mode 0x8b8-8bc for Path A and B
+
+}BB_REGISTER_DEFINITION_T, *PBB_REGISTER_DEFINITION_T;
+
+
+//----------------------------------------------------------------------
+u8
+PHY_GetTxPowerByRateBase(
+	IN	PADAPTER		Adapter,
+	IN	u8				Band,
+	IN	u8				RfPath,
+	IN	u8				TxNum,
+	IN	RATE_SECTION	RateSection
+	);
+
+#ifdef TX_POWER_BY_RATE_OLD
+u8
+PHY_GetRateSectionIndexOfTxPowerByRate(
+	IN	PADAPTER	pAdapter,
+	IN	u32			RegAddr,
+	IN	u32			BitMask
+	);
+#endif /* TX_POWER_BY_RATE_OLD */
+
+VOID
+PHY_GetRateValuesOfTxPowerByRate(
+	IN	PADAPTER pAdapter,
+	IN	u32 RegAddr,
+	IN	u32 BitMask,
+	IN	u32 Value,
+	OUT	u8 *Rate,
+	OUT	s8 *PwrByRateVal,
+	OUT	u8 *RateNum
+	);
+
+u8
+PHY_GetRateIndexOfTxPowerByRate(
+	IN	u8	Rate
+	);
+
+VOID
+PHY_SetTxPowerIndexByRateSection(
+	IN	PADAPTER		pAdapter,
+	IN	u8				RFPath,
+	IN	u8				Channel,
+	IN	u8				RateSection
+	);
+
+s8
+_PHY_GetTxPowerByRate(
+	IN	PADAPTER	pAdapter,
+	IN	u8			Band,
+	IN	u8			RFPath,
+	IN	u8			TxNum,
+	IN	u8			RateIndex
+	);
+
+s8
+PHY_GetTxPowerByRate(
+	IN	PADAPTER	pAdapter,
+	IN	u8			Band,
+	IN	u8			RFPath,
+	IN	u8			TxNum,
+	IN	u8			RateIndex
+	);
+
+VOID
+PHY_SetTxPowerByRate(
+	IN	PADAPTER	pAdapter,
+	IN	u8			Band,
+	IN	u8			RFPath,
+	IN	u8			TxNum,
+	IN	u8			Rate,
+	IN	s8			Value
+	);
+
+VOID
+PHY_SetTxPowerLevelByPath(
+	IN	PADAPTER	Adapter,
+	IN	u8			channel,
+	IN	u8			path
+	);
+
+VOID
+PHY_SetTxPowerIndexByRateArray(
+	IN	PADAPTER		pAdapter,
+	IN	u8				RFPath,
+	IN	CHANNEL_WIDTH	BandWidth,
+	IN	u8				Channel,
+	IN	u8*				Rates,
+	IN	u8				RateArraySize
+	);
+
+VOID
+PHY_InitTxPowerByRate(
+	IN	PADAPTER	pAdapter
+	);
+
+VOID
+PHY_StoreTxPowerByRate(
+	IN	PADAPTER	pAdapter,
+	IN	u32			Band,
+	IN	u32			RfPath,
+	IN	u32			TxNum,
+	IN	u32			RegAddr,
+	IN	u32			BitMask,
+	IN	u32			Data
+	);
+
+VOID
+PHY_TxPowerByRateConfiguration(
+	IN  PADAPTER			pAdapter
+	);
+
+u8
+PHY_GetTxPowerIndexBase(
+	IN	PADAPTER		pAdapter,
+	IN	u8				RFPath,
+	IN	u8				Rate,
+	IN	CHANNEL_WIDTH	BandWidth,
+	IN	u8				Channel,
+	OUT PBOOLEAN		bIn24G
+	);
+
+s8
+PHY_GetTxPowerLimit(
+	IN	PADAPTER		Adapter,
+	IN	u32				RegPwrTblSel,
+	IN	BAND_TYPE		Band,
+	IN	CHANNEL_WIDTH	Bandwidth,
+	IN	u8				RfPath,
+	IN	u8				DataRate,
+	IN	u8				Channel
+	);
+
+VOID
+PHY_ConvertTxPowerLimitToPowerIndex(
+	IN	PADAPTER			Adapter
+	);
+
+VOID
+PHY_InitTxPowerLimit(
+	IN	PADAPTER			Adapter
+	);
+
+s8
+PHY_GetTxPowerTrackingOffset(
+	PADAPTER	pAdapter,
+	u8			Rate,
+	u8			RFPath
+	);
+
+u8
+PHY_GetTxPowerIndex(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	CHANNEL_WIDTH		BandWidth,
+	IN	u8					Channel
+	);
+
+VOID
+PHY_SetTxPowerIndex(
+	IN	PADAPTER		pAdapter,
+	IN	u32				PowerIndex,
+	IN	u8				RFPath,
+	IN	u8				Rate
+	);
+
+bool phy_is_tx_power_limit_needed(_adapter *adapter);
+bool phy_is_tx_power_by_rate_needed(_adapter *adapter);
+int phy_load_tx_power_by_rate(_adapter *adapter, const char *hal_file_name, u8 force);
+int phy_load_tx_power_limit(_adapter *adapter, const char *hal_file_name, u8 force);
+void phy_load_tx_power_ext_info(_adapter *adapter, u8 chk_file, u8 force);
+void phy_reload_tx_power_ext_info(_adapter *adapter);
+void phy_reload_default_tx_power_ext_info(_adapter *adapter);
+
+void dump_tx_power_ext_info(void *sel, _adapter *adapter);
+void dump_target_tx_power(void *sel, _adapter *adapter);
+void dump_tx_power_by_rate(void *sel, _adapter *adapter);
+void dump_tx_power_limit(void *sel, _adapter *adapter);
+
+int rtw_is_phy_file_readable(const char *hal_file_name);
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+#define MAX_PARA_FILE_BUF_LEN	25600
+
+#define LOAD_MAC_PARA_FILE				BIT0
+#define LOAD_BB_PARA_FILE					BIT1
+#define LOAD_BB_PG_PARA_FILE				BIT2
+#define LOAD_BB_MP_PARA_FILE				BIT3
+#define LOAD_RF_PARA_FILE					BIT4
+#define LOAD_RF_TXPWR_TRACK_PARA_FILE	BIT5
+#define LOAD_RF_TXPWR_LMT_PARA_FILE		BIT6
+
+int phy_ConfigMACWithParaFile(IN PADAPTER	Adapter, IN char*	pFileName);
+
+int phy_ConfigBBWithParaFile(IN PADAPTER	Adapter, IN char*	pFileName, IN u32	ConfigType);
+
+int phy_ConfigBBWithPgParaFile(IN PADAPTER	Adapter, IN const char *pFileName);
+
+int phy_ConfigBBWithMpParaFile(IN PADAPTER	Adapter, IN char*	pFileName);
+
+int PHY_ConfigRFWithParaFile(IN	PADAPTER	Adapter, IN char*	pFileName, IN u8	eRFPath);
+
+int PHY_ConfigRFWithTxPwrTrackParaFile(IN PADAPTER	Adapter, IN char*	pFileName);
+
+int PHY_ConfigRFWithPowerLimitTableParaFile(IN PADAPTER	Adapter, IN const char *pFileName);
+
+void phy_free_filebuf_mask(_adapter *padapter, u8 mask);
+void phy_free_filebuf(_adapter *padapter);
+#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
+
+#endif /* __HAL_COMMON_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_reg.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_reg.h
new file mode 100644
index 000000000..6482ae45c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_com_reg.h
@@ -0,0 +1,1780 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_REG_H__
+#define __HAL_COMMON_REG_H__
+
+
+#define MAC_ADDR_LEN				6
+
+#define HAL_NAV_UPPER_UNIT		128		// micro-second
+
+// 8188E PKT_BUFF_ACCESS_CTRL value
+#define TXPKT_BUF_SELECT				0x69
+#define RXPKT_BUF_SELECT				0xA5
+#define DISABLE_TRXPKT_BUF_ACCESS		0x0
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_ISO_CTRL				0x0000
+#define REG_SYS_FUNC_EN				0x0002
+#define REG_APS_FSMCO					0x0004
+#define REG_SYS_CLKR					0x0008
+#define REG_SYS_CLK_CTRL				REG_SYS_CLKR
+#define REG_9346CR						0x000A
+#define REG_SYS_EEPROM_CTRL			0x000A
+#define REG_EE_VPD						0x000C
+#define REG_AFE_MISC					0x0010
+#define REG_SPS0_CTRL					0x0011
+#define REG_SPS0_CTRL_6					0x0016
+#define REG_POWER_OFF_IN_PROCESS 		0x0017
+#define REG_SPS_OCP_CFG				0x0018
+#define REG_RSV_CTRL					0x001C
+#define REG_RF_CTRL						0x001F
+#define REG_LDOA15_CTRL				0x0020
+#define REG_LDOV12D_CTRL				0x0021
+#define REG_LDOHCI12_CTRL				0x0022
+#define REG_LPLDO_CTRL					0x0023
+#define REG_AFE_XTAL_CTRL				0x0024
+#define REG_AFE_LDO_CTRL				0x0027 // 1.5v for 8188EE test chip, 1.4v for MP chip
+#define REG_AFE_PLL_CTRL				0x0028
+#define REG_MAC_PHY_CTRL				0x002c //for 92d, DMDP,SMSP,DMSP contrl
+#define REG_APE_PLL_CTRL_EXT			0x002c
+#define REG_EFUSE_CTRL					0x0030
+#define REG_EFUSE_TEST					0x0034
+#define REG_PWR_DATA					0x0038
+#define REG_CAL_TIMER					0x003C
+#define REG_ACLK_MON					0x003E
+#define REG_GPIO_MUXCFG				0x0040
+#define REG_GPIO_IO_SEL					0x0042
+#define REG_MAC_PINMUX_CFG			0x0043
+#define REG_GPIO_PIN_CTRL				0x0044
+#define REG_GPIO_INTM					0x0048
+#define REG_LEDCFG0						0x004C
+#define REG_LEDCFG1						0x004D
+#define REG_LEDCFG2						0x004E
+#define REG_LEDCFG3						0x004F
+#define REG_FSIMR						0x0050
+#define REG_FSISR						0x0054
+#define REG_HSIMR						0x0058
+#define REG_HSISR						0x005c
+#define REG_GPIO_PIN_CTRL_2			0x0060 // RTL8723 WIFI/BT/GPS Multi-Function GPIO Pin Control.
+#define REG_GPIO_IO_SEL_2				0x0062 // RTL8723 WIFI/BT/GPS Multi-Function GPIO Select.
+#define REG_MULTI_FUNC_CTRL			0x0068 // RTL8723 WIFI/BT/GPS Multi-Function control source.
+#define REG_GSSR						0x006c
+#define REG_AFE_XTAL_CTRL_EXT			0x0078 //RTL8188E
+#define REG_XCK_OUT_CTRL				0x007c //RTL8188E
+#define REG_MCUFWDL					0x0080
+#define REG_WOL_EVENT					0x0081 //RTL8188E
+#define REG_MCUTSTCFG					0x0084
+#define REG_FDHM0						0x0088
+#define REG_HOST_SUSP_CNT				0x00BC	// RTL8192C Host suspend counter on FPGA platform
+#define REG_SYSTEM_ON_CTRL			0x00CC	// For 8723AE Reset after S3
+#define REG_EFUSE_ACCESS				0x00CF	// Efuse access protection for RTL8723
+#define REG_BIST_SCAN					0x00D0
+#define REG_BIST_RPT					0x00D4
+#define REG_BIST_ROM_RPT				0x00D8
+#define REG_USB_SIE_INTF				0x00E0
+#define REG_PCIE_MIO_INTF				0x00E4
+#define REG_PCIE_MIO_INTD				0x00E8
+#define REG_HPON_FSM					0x00EC
+#define REG_SYS_CFG						0x00F0
+#define REG_GPIO_OUTSTS				0x00F4	// For RTL8723 only.
+#define REG_TYPE_ID						0x00FC
+
+//
+// 2010/12/29 MH Add for 92D
+//
+#define REG_MAC_PHY_CTRL_NORMAL		0x00f8
+
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_CR							0x0100
+#define REG_PBP							0x0104
+#define REG_PKT_BUFF_ACCESS_CTRL		0x0106
+#define REG_TRXDMA_CTRL				0x010C
+#define REG_TRXFF_BNDY					0x0114
+#define REG_TRXFF_STATUS				0x0118
+#define REG_RXFF_PTR					0x011C
+#define REG_HIMR						0x0120
+#define REG_HISR						0x0124
+#define REG_HIMRE						0x0128
+#define REG_HISRE						0x012C
+#define REG_CPWM						0x012F
+#define REG_FWIMR						0x0130
+#define REG_FWISR						0x0134
+#define REG_FTIMR						0x0138
+#define REG_FTISR						0x013C //RTL8192C
+#define REG_PKTBUF_DBG_CTRL			0x0140
+#define REG_RXPKTBUF_CTRL				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_PKTBUF_DBG_DATA_L			0x0144
+#define REG_PKTBUF_DBG_DATA_H		0x0148
+
+#define REG_TC0_CTRL					0x0150
+#define REG_TC1_CTRL					0x0154
+#define REG_TC2_CTRL					0x0158
+#define REG_TC3_CTRL					0x015C
+#define REG_TC4_CTRL					0x0160
+#define REG_TCUNIT_BASE				0x0164
+#define REG_MBIST_START				0x0174
+#define REG_MBIST_DONE					0x0178
+#define REG_MBIST_FAIL					0x017C
+#define REG_32K_CTRL					0x0194 //RTL8188E
+#define REG_C2HEVT_MSG_NORMAL		0x01A0
+#define REG_C2HEVT_CLEAR				0x01AF
+#define REG_MCUTST_1					0x01c0
+#define REG_MCUTST_WOWLAN			0x01C7	// Defined after 8188E series.
+#define REG_FMETHR						0x01C8
+#define REG_HMETFR						0x01CC
+#define REG_HMEBOX_0					0x01D0
+#define REG_HMEBOX_1					0x01D4
+#define REG_HMEBOX_2					0x01D8
+#define REG_HMEBOX_3					0x01DC
+#define REG_LLT_INIT					0x01E0
+#define REG_HMEBOX_EXT_0				0x01F0
+#define REG_HMEBOX_EXT_1				0x01F4
+#define REG_HMEBOX_EXT_2				0x01F8
+#define REG_HMEBOX_EXT_3				0x01FC
+
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RQPN						0x0200
+#define REG_FIFOPAGE					0x0204
+#define REG_TDECTRL						0x0208
+#define REG_TXDMA_OFFSET_CHK			0x020C
+#define REG_TXDMA_STATUS				0x0210
+#define REG_RQPN_NPQ					0x0214
+#define REG_AUTO_LLT					0x0224
+
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_AGG_PG_TH			0x0280
+#define REG_RXPKT_NUM					0x0284
+#define REG_RXDMA_STATUS				0x0288
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define REG_PCIE_CTRL_REG				0x0300
+#define REG_INT_MIG					0x0304	/* Interrupt Migration */
+#define REG_BCNQ_DESA					0x0308	/* TX Beacon Descriptor Address */
+#define REG_HQ_DESA					0x0310	/* TX High Queue Descriptor Address */
+#define REG_MGQ_DESA					0x0318	/* TX Manage Queue Descriptor Address */
+#define REG_VOQ_DESA					0x0320	/* TX VO Queue Descriptor Address */
+#define REG_VIQ_DESA					0x0328	/* TX VI Queue Descriptor Address */
+#define REG_BEQ_DESA					0x0330	/* TX BE Queue Descriptor Address */
+#define REG_BKQ_DESA					0x0338	/* TX BK Queue Descriptor Address */
+#define REG_RX_DESA					0x0340	/* RX Queue Descriptor Address */
+//sherry added for DBI Read/Write  20091126
+#define REG_DBI_WDATA					0x0348	/*  Backdoor REG for Access Configuration */
+#define REG_DBI_RDATA					0x034C	/* Backdoor REG for Access Configuration */
+#define REG_DBI_CTRL					0x0350	/* Backdoor REG for Access Configuration */
+#define REG_DBI_FLAG					0x0352	/* Backdoor REG for Access Configuration */
+#define REG_MDIO					0x0354	/* MDIO for Access PCIE PHY */
+#define REG_DBG_SEL					0x0360	/* Debug Selection Register */
+#define REG_PCIE_HRPWM					0x0361	/* PCIe RPWM */
+#define REG_PCIE_HCPWM					0x0363	/* PCIe CPWM */
+#define REG_WATCH_DOG					0x0368
+#define REG_RX_RXBD_NUM					0x0382
+
+// RTL8723 series -------------------------------
+#define REG_PCIE_HISR_EN				0x0394	/* PCIE Local Interrupt Enable Register */
+#define REG_PCIE_HISR					0x03A0
+#define REG_PCIE_HISRE					0x03A4
+#define REG_PCIE_HIMR					0x03A8
+#define REG_PCIE_HIMRE					0x03AC
+
+#define REG_USB_HIMR					0xFE38
+#define REG_USB_HIMRE					0xFE3C
+#define REG_USB_HISR					0xFE78
+#define REG_USB_HISRE					0xFE7C
+
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+
+/* 92C, 92D */
+#define REG_VOQ_INFO	0x0400
+#define REG_VIQ_INFO	0x0404
+#define REG_BEQ_INFO	0x0408
+#define REG_BKQ_INFO	0x040C
+
+/* 88E, 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q0_INFO	0x400
+#define REG_Q1_INFO	0x404
+#define REG_Q2_INFO	0x408
+#define REG_Q3_INFO	0x40C
+
+#define REG_MGQ_INFO	0x0410
+#define REG_HGQ_INFO	0x0414
+#define REG_BCNQ_INFO	0x0418
+#define REG_TXPKT_EMPTY				0x041A
+#define REG_CPU_MGQ_INFORMATION		0x041C
+#define REG_FWHW_TXQ_CTRL				0x0420
+#define REG_HWSEQ_CTRL					0x0423
+#define REG_BCNQ_BDNY					0x0424
+#define REG_MGQ_BDNY					0x0425
+#define REG_LIFETIME_CTRL				0x0426
+#define REG_MULTI_BCNQ_OFFSET			0x0427
+#define REG_SPEC_SIFS					0x0428
+#define REG_RL							0x042A
+#define REG_DARFRC						0x0430
+#define REG_RARFRC						0x0438
+#define REG_RRSR						0x0440
+#define REG_ARFR0						0x0444
+#define REG_ARFR1						0x0448
+#define REG_ARFR2						0x044C
+#define REG_ARFR3						0x0450
+#define REG_BCNQ1_BDNY					0x0457
+
+#define REG_AGGLEN_LMT					0x0458
+#define REG_AMPDU_MIN_SPACE			0x045C
+#define REG_WMAC_LBK_BF_HD			0x045D
+#define REG_FAST_EDCA_CTRL				0x0460
+#define REG_RD_RESP_PKT_TH				0x0463
+
+/* 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q4_INFO	0x468
+#define REG_Q5_INFO	0x46C
+#define REG_Q6_INFO	0x470
+#define REG_Q7_INFO	0x474
+
+#define REG_INIRTS_RATE_SEL				0x0480
+#define REG_INIDATA_RATE_SEL			0x0484
+
+/* 8723B, 92E, 8812A, 8821A*/
+#define REG_MACID_SLEEP_3				0x0484
+#define REG_MACID_SLEEP_1				0x0488
+
+#define REG_POWER_STAGE1				0x04B4
+#define REG_POWER_STAGE2				0x04B8
+#define REG_PKT_VO_VI_LIFE_TIME		0x04C0
+#define REG_PKT_BE_BK_LIFE_TIME		0x04C2
+#define REG_STBC_SETTING				0x04C4
+#define REG_QUEUE_CTRL					0x04C6
+#define REG_SINGLE_AMPDU_CTRL			0x04c7
+#define REG_PROT_MODE_CTRL			0x04C8
+#define REG_MAX_AGGR_NUM				0x04CA
+#define REG_RTS_MAX_AGGR_NUM			0x04CB
+#define REG_BAR_MODE_CTRL				0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT		0x04CF
+
+/* 8723A */
+#define REG_MACID_DROP	0x04D0
+
+/* 88E */
+#define REG_EARLY_MODE_CONTROL	0x04D0
+
+/* 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP_2	0x04D0
+
+/* 8723A, 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP	0x04D4
+
+#define REG_NQOS_SEQ					0x04DC
+#define REG_QOS_SEQ					0x04DE
+#define REG_NEED_CPU_HANDLE			0x04E0
+#define REG_PKT_LOSE_RPT				0x04E1
+#define REG_PTCL_ERR_STATUS			0x04E2
+#define REG_TX_RPT_CTRL					0x04EC
+#define REG_TX_RPT_TIME					0x04F0	// 2 byte
+#define REG_DUMMY						0x04FC
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_EDCA_VO_PARAM				0x0500
+#define REG_EDCA_VI_PARAM				0x0504
+#define REG_EDCA_BE_PARAM				0x0508
+#define REG_EDCA_BK_PARAM				0x050C
+#define REG_BCNTCFG						0x0510
+#define REG_PIFS							0x0512
+#define REG_RDG_PIFS					0x0513
+#define REG_SIFS_CTX					0x0514
+#define REG_SIFS_TRX					0x0516
+#define REG_TSFTR_SYN_OFFSET			0x0518
+#define REG_AGGR_BREAK_TIME			0x051A
+#define REG_SLOT						0x051B
+#define REG_TX_PTCL_CTRL				0x0520
+#define REG_TXPAUSE						0x0522
+#define REG_DIS_TXREQ_CLR				0x0523
+#define REG_RD_CTRL						0x0524
+//
+// Format for offset 540h-542h:
+//	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
+//	[7:4]:   Reserved.
+//	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
+//	[23:20]: Reserved
+// Description:
+//	              |
+//     |<--Setup--|--Hold------------>|
+//	--------------|----------------------
+//                |
+//               TBTT
+// Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
+// Described by Designer Tim and Bruce, 2011-01-14.
+//
+#define REG_TBTT_PROHIBIT				0x0540
+#define REG_RD_NAV_NXT					0x0544
+#define REG_NAV_PROT_LEN				0x0546
+#define REG_BCN_CTRL					0x0550
+#define REG_BCN_CTRL_1					0x0551
+#define REG_MBID_NUM					0x0552
+#define REG_DUAL_TSF_RST				0x0553
+#define REG_BCN_INTERVAL				0x0554	// The same as REG_MBSSID_BCN_SPACE
+#define REG_DRVERLYINT					0x0558
+#define REG_BCNDMATIM					0x0559
+#define REG_ATIMWND					0x055A
+#define REG_USTIME_TSF					0x055C
+#define REG_BCN_MAX_ERR				0x055D
+#define REG_RXTSF_OFFSET_CCK			0x055E
+#define REG_RXTSF_OFFSET_OFDM			0x055F
+#define REG_TSFTR						0x0560
+#define REG_TSFTR1						0x0568	// HW Port 1 TSF Register
+#define REG_ATIMWND_1					0x0570
+#define REG_P2P_CTWIN					0x0572 // 1 Byte long (in unit of TU)
+#define REG_PSTIMER						0x0580
+#define REG_TIMER0						0x0584
+#define REG_TIMER1						0x0588
+#define REG_ACMHWCTRL					0x05C0
+#define REG_NOA_DESC_SEL				0x05CF
+#define REG_NOA_DESC_DURATION		0x05E0
+#define REG_NOA_DESC_INTERVAL			0x05E4
+#define REG_NOA_DESC_START			0x05E8
+#define REG_NOA_DESC_COUNT			0x05EC
+
+#define REG_DMC							0x05F0	//Dual MAC Co-Existence Register
+#define REG_SCH_TX_CMD					0x05F8
+
+#define REG_FW_RESET_TSF_CNT_1		0x05FC
+#define REG_FW_RESET_TSF_CNT_0		0x05FD
+#define REG_FW_BCN_DIS_CNT			0x05FE
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_APSD_CTRL					0x0600
+#define REG_BWOPMODE					0x0603
+#define REG_TCR							0x0604
+#define REG_RCR							0x0608
+#define REG_RX_PKT_LIMIT				0x060C
+#define REG_RX_DLK_TIME				0x060D
+#define REG_RX_DRVINFO_SZ				0x060F
+
+#define REG_MACID						0x0610
+#define REG_BSSID						0x0618
+#define REG_MAR							0x0620
+#define REG_MBIDCAMCFG					0x0628
+
+#define REG_PNO_STATUS					0x0631
+#define REG_USTIME_EDCA				0x0638
+#define REG_MAC_SPEC_SIFS				0x063A
+// 20100719 Joseph: Hardware register definition change. (HW datasheet v54)
+#define REG_RESP_SIFS_CCK				0x063C	// [15:8]SIFS_R2T_OFDM, [7:0]SIFS_R2T_CCK
+#define REG_RESP_SIFS_OFDM                    0x063E	// [15:8]SIFS_T2T_OFDM, [7:0]SIFS_T2T_CCK
+
+#define REG_ACKTO						0x0640
+#define REG_CTS2TO						0x0641
+#define REG_EIFS							0x0642
+
+
+//RXERR_RPT
+#define RXERR_TYPE_OFDM_PPDU			0
+#define RXERR_TYPE_OFDM_FALSE_ALARM 	1
+#define RXERR_TYPE_OFDM_MPDU_OK 		2
+#define RXERR_TYPE_OFDM_MPDU_FAIL	3
+#define RXERR_TYPE_CCK_PPDU 			4
+#define RXERR_TYPE_CCK_FALSE_ALARM	5
+#define RXERR_TYPE_CCK_MPDU_OK		6
+#define RXERR_TYPE_CCK_MPDU_FAIL		7
+#define RXERR_TYPE_HT_PPDU				8
+#define RXERR_TYPE_HT_FALSE_ALARM	9
+#define RXERR_TYPE_HT_MPDU_TOTAL		10
+#define RXERR_TYPE_HT_MPDU_OK			11
+#define RXERR_TYPE_HT_MPDU_FAIL 		12
+#define RXERR_TYPE_RX_FULL_DROP 		15
+
+#define RXERR_COUNTER_MASK			0xFFFFF
+#define RXERR_RPT_RST					BIT(27)
+#define _RXERR_RPT_SEL(type)			((type) << 28)
+
+//
+// Note:
+//	The NAV upper value is very important to WiFi 11n 5.2.3 NAV test. The default value is
+//	always too small, but the WiFi TestPlan test by 25,000 microseconds of NAV through sending
+//	CTS in the air. We must update this value greater than 25,000 microseconds to pass the item.
+//	The offset of NAV_UPPER in 8192C Spec is incorrect, and the offset should be 0x0652. Commented
+//	by SD1 Scott.
+// By Bruce, 2011-07-18.
+//
+#define REG_NAV_UPPER					0x0652	// unit of 128
+
+//WMA, BA, CCX
+#define REG_NAV_CTRL					0x0650
+#define REG_BACAMCMD					0x0654
+#define REG_BACAMCONTENT				0x0658
+#define REG_LBDLY						0x0660
+#define REG_FWDLY						0x0661
+#define REG_RXERR_RPT					0x0664
+#define REG_WMAC_TRXPTCL_CTL			0x0668
+
+// Security
+#define REG_CAMCMD						0x0670
+#define REG_CAMWRITE					0x0674
+#define REG_CAMREAD					0x0678
+#define REG_CAMDBG						0x067C
+#define REG_SECCFG						0x0680
+
+// Power
+#define REG_WOW_CTRL					0x0690
+#define REG_PS_RX_INFO					0x0692
+#define REG_UAPSD_TID					0x0693
+#define REG_WKFMCAM_CMD				0x0698
+#define REG_WKFMCAM_NUM				REG_WKFMCAM_CMD
+#define REG_WKFMCAM_RWD				0x069C
+#define REG_RXFLTMAP0					0x06A0
+#define REG_RXFLTMAP1					0x06A2
+#define REG_RXFLTMAP2					0x06A4
+#define REG_BCN_PSR_RPT				0x06A8
+#define REG_BT_COEX_TABLE				0x06C0
+
+// Hardware Port 2
+#define REG_MACID1						0x0700
+#define REG_BSSID1						0x0708
+
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+#define REG_USB_INFO					0xFE17
+#define REG_USB_SPECIAL_OPTION		0xFE55
+#define REG_USB_DMA_AGG_TO			0xFE5B
+#define REG_USB_AGG_TO					0xFE5C
+#define REG_USB_AGG_TH					0xFE5D
+
+#define REG_USB_HRPWM					0xFE58
+#define REG_USB_HCPWM					0xFE57
+
+// for 92DU high_Queue low_Queue Normal_Queue select
+#define REG_USB_High_NORMAL_Queue_Select_MAC0	0xFE44
+//#define REG_USB_LOW_Queue_Select_MAC0		0xFE45
+#define REG_USB_High_NORMAL_Queue_Select_MAC1	0xFE47
+//#define REG_USB_LOW_Queue_Select_MAC1		0xFE48
+
+// For test chip
+#define REG_TEST_USB_TXQS				0xFE48
+#define REG_TEST_SIE_VID				0xFE60		// 0xFE60~0xFE61
+#define REG_TEST_SIE_PID				0xFE62		// 0xFE62~0xFE63
+#define REG_TEST_SIE_OPTIONAL			0xFE64
+#define REG_TEST_SIE_CHIRP_K			0xFE65
+#define REG_TEST_SIE_PHY				0xFE66		// 0xFE66~0xFE6B
+#define REG_TEST_SIE_MAC_ADDR			0xFE70		// 0xFE70~0xFE75
+#define REG_TEST_SIE_STRING			0xFE80		// 0xFE80~0xFEB9
+
+
+// For normal chip
+#define REG_NORMAL_SIE_VID				0xFE60		// 0xFE60~0xFE61
+#define REG_NORMAL_SIE_PID				0xFE62		// 0xFE62~0xFE63
+#define REG_NORMAL_SIE_OPTIONAL		0xFE64
+#define REG_NORMAL_SIE_EP				0xFE65		// 0xFE65~0xFE67
+#define REG_NORMAL_SIE_PHY			0xFE68		// 0xFE68~0xFE6B
+#define REG_NORMAL_SIE_OPTIONAL2		0xFE6C
+#define REG_NORMAL_SIE_GPS_EP			0xFE6D		// 0xFE6D, for RTL8723 only.
+#define REG_NORMAL_SIE_MAC_ADDR		0xFE70		// 0xFE70~0xFE75
+#define REG_NORMAL_SIE_STRING			0xFE80		// 0xFE80~0xFEDF
+
+
+//-----------------------------------------------------
+//
+//	Redifine 8192C register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+
+#define EFUSE_CTRL				REG_EFUSE_CTRL		// E-Fuse Control.
+#define EFUSE_TEST				REG_EFUSE_TEST		// E-Fuse Test.
+#define MSR						(REG_CR + 2)		// Media Status register
+//#define ISR						REG_HISR
+
+#define TSFR						REG_TSFTR			// Timing Sync Function Timer Register.
+#define TSFR1					REG_TSFTR1			// HW Port 1 TSF Register
+
+#define PBP						REG_PBP
+
+// Redifine MACID register, to compatible prior ICs.
+#define IDR0						REG_MACID			// MAC ID Register, Offset 0x0050-0x0053
+#define IDR4						(REG_MACID + 4)		// MAC ID Register, Offset 0x0054-0x0055
+
+
+//
+// 9. Security Control Registers	(Offset: )
+//
+#define RWCAM					REG_CAMCMD		//IN 8190 Data Sheet is called CAMcmd
+#define WCAMI					REG_CAMWRITE	// Software write CAM input content
+#define RCAMO					REG_CAMREAD		// Software read/write CAM config
+#define CAMDBG					REG_CAMDBG
+#define SECR						REG_SECCFG		//Security Configuration Register
+
+// Unused register
+#define UnusedRegister			0x1BF
+#define DCAM					UnusedRegister
+#define PSR						UnusedRegister
+#define BBAddr					UnusedRegister
+#define PhyDataR					UnusedRegister
+
+// Min Spacing related settings.
+#define MAX_MSS_DENSITY_2T 			0x13
+#define MAX_MSS_DENSITY_1T 			0x0A
+
+//----------------------------------------------------------------------------
+//       8192C Cmd9346CR bits					(Offset 0xA, 16bit)
+//----------------------------------------------------------------------------
+#define CmdEEPROM_En				BIT5	 // EEPROM enable when set 1
+#define CmdEERPOMSEL				BIT4 	// System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
+#define Cmd9346CR_9356SEL			BIT4
+
+//----------------------------------------------------------------------------
+//       8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIOSEL_GPIO				0
+#define GPIOSEL_ENBT				BIT5
+
+//----------------------------------------------------------------------------
+//       8192C GPIO PIN Control Register (offset 0x44, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIO_IN					REG_GPIO_PIN_CTRL		// GPIO pins input value
+#define GPIO_OUT				(REG_GPIO_PIN_CTRL+1)	// GPIO pins output value
+#define GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+#define GPIO_MOD				(REG_GPIO_PIN_CTRL+3)
+
+//----------------------------------------------------------------------------
+//       8811A GPIO PIN Control Register (offset 0x60, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIO_IN_8811A			REG_GPIO_PIN_CTRL_2		// GPIO pins input value
+#define GPIO_OUT_8811A			(REG_GPIO_PIN_CTRL_2+1)	// GPIO pins output value
+#define GPIO_IO_SEL_8811A		(REG_GPIO_PIN_CTRL_2+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+#define GPIO_MOD_8811A			(REG_GPIO_PIN_CTRL_2+3)
+
+//----------------------------------------------------------------------------
+//       8723/8188E Host System Interrupt Mask Register (offset 0x58, 32 byte)
+//----------------------------------------------------------------------------
+#define HSIMR_GPIO12_0_INT_EN			BIT0
+#define HSIMR_SPS_OCP_INT_EN			BIT5
+#define HSIMR_RON_INT_EN				BIT6
+#define HSIMR_PDN_INT_EN				BIT7
+#define HSIMR_GPIO9_INT_EN				BIT25
+
+//----------------------------------------------------------------------------
+//       8723/8188E Host System Interrupt Status Register (offset 0x5C, 32 byte)
+//----------------------------------------------------------------------------
+#define HSISR_GPIO12_0_INT				BIT0
+#define HSISR_SPS_OCP_INT				BIT5
+#define HSISR_RON_INT					BIT6
+#define HSISR_PDNINT					BIT7
+#define HSISR_GPIO9_INT					BIT25
+
+//----------------------------------------------------------------------------
+//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
+//----------------------------------------------------------------------------
+/*
+Network Type
+00: No link
+01: Link in ad hoc network
+10: Link in infrastructure network
+11: AP mode
+Default: 00b.
+*/
+#define MSR_NOLINK				0x00
+#define MSR_ADHOC				0x01
+#define MSR_INFRA				0x02
+#define MSR_AP					0x03
+
+//----------------------------------------------------------------------------
+//       USB INTR CONTENT
+//----------------------------------------------------------------------------
+#define USB_C2H_CMDID_OFFSET					0
+#define USB_C2H_SEQ_OFFSET					1
+#define USB_C2H_EVENT_OFFSET					2
+#define USB_INTR_CPWM_OFFSET					16
+#define USB_INTR_CONTENT_C2H_OFFSET			0
+#define USB_INTR_CONTENT_CPWM1_OFFSET		16
+#define USB_INTR_CONTENT_CPWM2_OFFSET		20
+#define USB_INTR_CONTENT_HISR_OFFSET			48
+#define USB_INTR_CONTENT_HISRE_OFFSET		52
+#define USB_INTR_CONTENT_LENGTH				56
+
+//----------------------------------------------------------------------------
+//       Response Rate Set Register	(offset 0x440, 24bits)
+//----------------------------------------------------------------------------
+#define RRSR_1M					BIT0
+#define RRSR_2M					BIT1
+#define RRSR_5_5M				BIT2
+#define RRSR_11M				BIT3
+#define RRSR_6M					BIT4
+#define RRSR_9M					BIT5
+#define RRSR_12M				BIT6
+#define RRSR_18M				BIT7
+#define RRSR_24M				BIT8
+#define RRSR_36M				BIT9
+#define RRSR_48M				BIT10
+#define RRSR_54M				BIT11
+#define RRSR_MCS0				BIT12
+#define RRSR_MCS1				BIT13
+#define RRSR_MCS2				BIT14
+#define RRSR_MCS3				BIT15
+#define RRSR_MCS4				BIT16
+#define RRSR_MCS5				BIT17
+#define RRSR_MCS6				BIT18
+#define RRSR_MCS7				BIT19
+
+#define RRSR_CCK_RATES (RRSR_11M|RRSR_5_5M|RRSR_2M|RRSR_1M)
+#define RRSR_OFDM_RATES (RRSR_54M|RRSR_48M|RRSR_36M|RRSR_24M|RRSR_18M|RRSR_12M|RRSR_9M|RRSR_6M)
+
+// WOL bit information
+#define HAL92C_WOL_PTK_UPDATE_EVENT		BIT0
+#define HAL92C_WOL_GTK_UPDATE_EVENT		BIT1
+#define HAL92C_WOL_DISASSOC_EVENT		BIT2
+#define HAL92C_WOL_DEAUTH_EVENT			BIT3
+#define HAL92C_WOL_FW_DISCONNECT_EVENT	BIT4
+
+//----------------------------------------------------------------------------
+//       Rate Definition
+//----------------------------------------------------------------------------
+//CCK
+#define	RATR_1M					0x00000001
+#define	RATR_2M					0x00000002
+#define	RATR_55M					0x00000004
+#define	RATR_11M					0x00000008
+//OFDM
+#define	RATR_6M					0x00000010
+#define	RATR_9M					0x00000020
+#define	RATR_12M					0x00000040
+#define	RATR_18M					0x00000080
+#define	RATR_24M					0x00000100
+#define	RATR_36M					0x00000200
+#define	RATR_48M					0x00000400
+#define	RATR_54M					0x00000800
+//MCS 1 Spatial Stream
+#define	RATR_MCS0					0x00001000
+#define	RATR_MCS1					0x00002000
+#define	RATR_MCS2					0x00004000
+#define	RATR_MCS3					0x00008000
+#define	RATR_MCS4					0x00010000
+#define	RATR_MCS5					0x00020000
+#define	RATR_MCS6					0x00040000
+#define	RATR_MCS7					0x00080000
+//MCS 2 Spatial Stream
+#define	RATR_MCS8					0x00100000
+#define	RATR_MCS9					0x00200000
+#define	RATR_MCS10					0x00400000
+#define	RATR_MCS11					0x00800000
+#define	RATR_MCS12					0x01000000
+#define	RATR_MCS13					0x02000000
+#define	RATR_MCS14					0x04000000
+#define	RATR_MCS15					0x08000000
+
+//CCK
+#define RATE_1M					BIT(0)
+#define RATE_2M					BIT(1)
+#define RATE_5_5M				BIT(2)
+#define RATE_11M				BIT(3)
+//OFDM
+#define RATE_6M					BIT(4)
+#define RATE_9M					BIT(5)
+#define RATE_12M				BIT(6)
+#define RATE_18M				BIT(7)
+#define RATE_24M				BIT(8)
+#define RATE_36M				BIT(9)
+#define RATE_48M				BIT(10)
+#define RATE_54M				BIT(11)
+//MCS 1 Spatial Stream
+#define RATE_MCS0				BIT(12)
+#define RATE_MCS1				BIT(13)
+#define RATE_MCS2				BIT(14)
+#define RATE_MCS3				BIT(15)
+#define RATE_MCS4				BIT(16)
+#define RATE_MCS5				BIT(17)
+#define RATE_MCS6				BIT(18)
+#define RATE_MCS7				BIT(19)
+//MCS 2 Spatial Stream
+#define RATE_MCS8				BIT(20)
+#define RATE_MCS9				BIT(21)
+#define RATE_MCS10				BIT(22)
+#define RATE_MCS11				BIT(23)
+#define RATE_MCS12				BIT(24)
+#define RATE_MCS13				BIT(25)
+#define RATE_MCS14				BIT(26)
+#define RATE_MCS15				BIT(27)
+
+
+// ALL CCK Rate
+#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
+#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
+						RATR_36M|RATR_48M|RATR_54M
+#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
+						RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
+#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
+						RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
+
+#define RATE_BITMAP_ALL			0xFFFFF
+
+// Only use CCK 1M rate for ACK
+#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
+#define RATE_RRSR_WITHOUT_CCK		0xFFFF0
+
+//----------------------------------------------------------------------------
+//       BW_OPMODE bits				(Offset 0x603, 8bit)
+//----------------------------------------------------------------------------
+#define BW_OPMODE_20MHZ			BIT2
+#define BW_OPMODE_5G				BIT1
+
+//----------------------------------------------------------------------------
+//       CAM Config Setting (offset 0x680, 1 byte)
+//----------------------------------------------------------------------------
+#define CAM_VALID				BIT15
+#define CAM_NOTVALID			0x0000
+#define CAM_USEDK				BIT5
+
+#define CAM_CONTENT_COUNT 	8
+
+#define CAM_NONE				0x0
+#define CAM_WEP40				0x01
+#define CAM_TKIP				0x02
+#define CAM_AES					0x04
+#define CAM_WEP104				0x05
+#define CAM_SMS4				0x6
+
+#define TOTAL_CAM_ENTRY		32
+#define HALF_CAM_ENTRY			16
+
+#define CAM_CONFIG_USEDK		_TRUE
+#define CAM_CONFIG_NO_USEDK	_FALSE
+
+#define CAM_WRITE				BIT16
+#define CAM_READ				0x00000000
+#define CAM_POLLINIG			BIT31
+
+//
+// 10. Power Save Control Registers
+//
+#define WOW_PMEN				BIT0 // Power management Enable.
+#define WOW_WOMEN				BIT1 // WoW function on or off.
+#define WOW_MAGIC				BIT2 // Magic packet
+#define WOW_UWF				BIT3 // Unicast Wakeup frame.
+
+//
+// 12. Host Interrupt Status Registers
+//
+//----------------------------------------------------------------------------
+//      8190 IMR/ISR bits
+//----------------------------------------------------------------------------
+#define IMR8190_DISABLED		0x0
+#define IMR_DISABLED			0x0
+// IMR DW0 Bit 0-31
+#define IMR_BCNDMAINT6			BIT31		// Beacon DMA Interrupt 6
+#define IMR_BCNDMAINT5			BIT30		// Beacon DMA Interrupt 5
+#define IMR_BCNDMAINT4			BIT29		// Beacon DMA Interrupt 4
+#define IMR_BCNDMAINT3			BIT28		// Beacon DMA Interrupt 3
+#define IMR_BCNDMAINT2			BIT27		// Beacon DMA Interrupt 2
+#define IMR_BCNDMAINT1			BIT26		// Beacon DMA Interrupt 1
+#define IMR_BCNDOK8				BIT25		// Beacon Queue DMA OK Interrup 8
+#define IMR_BCNDOK7				BIT24		// Beacon Queue DMA OK Interrup 7
+#define IMR_BCNDOK6				BIT23		// Beacon Queue DMA OK Interrup 6
+#define IMR_BCNDOK5				BIT22		// Beacon Queue DMA OK Interrup 5
+#define IMR_BCNDOK4				BIT21		// Beacon Queue DMA OK Interrup 4
+#define IMR_BCNDOK3				BIT20		// Beacon Queue DMA OK Interrup 3
+#define IMR_BCNDOK2				BIT19		// Beacon Queue DMA OK Interrup 2
+#define IMR_BCNDOK1				BIT18		// Beacon Queue DMA OK Interrup 1
+#define IMR_TIMEOUT2			BIT17		// Timeout interrupt 2
+#define IMR_TIMEOUT1			BIT16		// Timeout interrupt 1
+#define IMR_TXFOVW				BIT15		// Transmit FIFO Overflow
+#define IMR_PSTIMEOUT			BIT14		// Power save time out interrupt
+#define IMR_BcnInt				BIT13		// Beacon DMA Interrupt 0
+#define IMR_RXFOVW				BIT12		// Receive FIFO Overflow
+#define IMR_RDU					BIT11		// Receive Descriptor Unavailable
+#define IMR_ATIMEND				BIT10		// For 92C,ATIM Window End Interrupt. For 8723 and later ICs, it also means P2P CTWin End interrupt.
+#define IMR_BDOK				BIT9		// Beacon Queue DMA OK Interrup
+#define IMR_HIGHDOK				BIT8		// High Queue DMA OK Interrupt
+#define IMR_TBDOK				BIT7		// Transmit Beacon OK interrup
+#define IMR_MGNTDOK			BIT6		// Management Queue DMA OK Interrupt
+#define IMR_TBDER				BIT5		// For 92C,Transmit Beacon Error Interrupt
+#define IMR_BKDOK				BIT4		// AC_BK DMA OK Interrupt
+#define IMR_BEDOK				BIT3		// AC_BE DMA OK Interrupt
+#define IMR_VIDOK				BIT2		// AC_VI DMA OK Interrupt
+#define IMR_VODOK				BIT1		// AC_VO DMA Interrupt
+#define IMR_ROK					BIT0		// Receive DMA OK Interrupt
+
+// 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh)
+#define IMR_TSF_BIT32_TOGGLE	BIT15
+#define IMR_BcnInt_E				BIT12
+#define IMR_TXERR				BIT11
+#define IMR_RXERR				BIT10
+#define IMR_C2HCMD				BIT9
+#define IMR_CPWM				BIT8
+//RSVD [2-7]
+#define IMR_OCPINT				BIT1
+#define IMR_WLANOFF			BIT0
+
+//----------------------------------------------------------------------------
+// 8723E series PCIE Host IMR/ISR bit
+//----------------------------------------------------------------------------
+// IMR DW0 Bit 0-31
+#define PHIMR_TIMEOUT2				BIT31
+#define PHIMR_TIMEOUT1				BIT30
+#define PHIMR_PSTIMEOUT			BIT29
+#define PHIMR_GTINT4				BIT28
+#define PHIMR_GTINT3				BIT27
+#define PHIMR_TXBCNERR				BIT26
+#define PHIMR_TXBCNOK				BIT25
+#define PHIMR_TSF_BIT32_TOGGLE	BIT24
+#define PHIMR_BCNDMAINT3			BIT23
+#define PHIMR_BCNDMAINT2			BIT22
+#define PHIMR_BCNDMAINT1			BIT21
+#define PHIMR_BCNDMAINT0			BIT20
+#define PHIMR_BCNDOK3				BIT19
+#define PHIMR_BCNDOK2				BIT18
+#define PHIMR_BCNDOK1				BIT17
+#define PHIMR_BCNDOK0				BIT16
+#define PHIMR_HSISR_IND_ON			BIT15
+#define PHIMR_BCNDMAINT_E			BIT14
+#define PHIMR_ATIMEND_E			BIT13
+#define PHIMR_ATIM_CTW_END		BIT12
+#define PHIMR_HISRE_IND			BIT11	// RO. HISRE Indicator (HISRE & HIMRE is true, this bit is set to 1)
+#define PHIMR_C2HCMD				BIT10
+#define PHIMR_CPWM2				BIT9
+#define PHIMR_CPWM					BIT8
+#define PHIMR_HIGHDOK				BIT7		// High Queue DMA OK Interrupt
+#define PHIMR_MGNTDOK				BIT6		// Management Queue DMA OK Interrupt
+#define PHIMR_BKDOK					BIT5		// AC_BK DMA OK Interrupt
+#define PHIMR_BEDOK					BIT4		// AC_BE DMA OK Interrupt
+#define PHIMR_VIDOK					BIT3		// AC_VI DMA OK Interrupt
+#define PHIMR_VODOK				BIT2		// AC_VO DMA Interrupt
+#define PHIMR_RDU					BIT1		// Receive Descriptor Unavailable
+#define PHIMR_ROK					BIT0		// Receive DMA OK Interrupt
+
+// PCIE Host Interrupt Status Extension bit
+#define PHIMR_BCNDMAINT7			BIT23
+#define PHIMR_BCNDMAINT6			BIT22
+#define PHIMR_BCNDMAINT5			BIT21
+#define PHIMR_BCNDMAINT4			BIT20
+#define PHIMR_BCNDOK7				BIT19
+#define PHIMR_BCNDOK6				BIT18
+#define PHIMR_BCNDOK5				BIT17
+#define PHIMR_BCNDOK4				BIT16
+// bit12 15: RSVD
+#define PHIMR_TXERR					BIT11
+#define PHIMR_RXERR					BIT10
+#define PHIMR_TXFOVW				BIT9
+#define PHIMR_RXFOVW				BIT8
+// bit2-7: RSVD
+#define PHIMR_OCPINT				BIT1
+// bit0: RSVD
+
+#define UHIMR_TIMEOUT2				BIT31
+#define UHIMR_TIMEOUT1				BIT30
+#define UHIMR_PSTIMEOUT			BIT29
+#define UHIMR_GTINT4				BIT28
+#define UHIMR_GTINT3				BIT27
+#define UHIMR_TXBCNERR				BIT26
+#define UHIMR_TXBCNOK				BIT25
+#define UHIMR_TSF_BIT32_TOGGLE	BIT24
+#define UHIMR_BCNDMAINT3			BIT23
+#define UHIMR_BCNDMAINT2			BIT22
+#define UHIMR_BCNDMAINT1			BIT21
+#define UHIMR_BCNDMAINT0			BIT20
+#define UHIMR_BCNDOK3				BIT19
+#define UHIMR_BCNDOK2				BIT18
+#define UHIMR_BCNDOK1				BIT17
+#define UHIMR_BCNDOK0				BIT16
+#define UHIMR_HSISR_IND			BIT15
+#define UHIMR_BCNDMAINT_E			BIT14
+//RSVD	BIT13
+#define UHIMR_CTW_END				BIT12
+//RSVD	BIT11
+#define UHIMR_C2HCMD				BIT10
+#define UHIMR_CPWM2				BIT9
+#define UHIMR_CPWM					BIT8
+#define UHIMR_HIGHDOK				BIT7		// High Queue DMA OK Interrupt
+#define UHIMR_MGNTDOK				BIT6		// Management Queue DMA OK Interrupt
+#define UHIMR_BKDOK				BIT5		// AC_BK DMA OK Interrupt
+#define UHIMR_BEDOK				BIT4		// AC_BE DMA OK Interrupt
+#define UHIMR_VIDOK					BIT3		// AC_VI DMA OK Interrupt
+#define UHIMR_VODOK				BIT2		// AC_VO DMA Interrupt
+#define UHIMR_RDU					BIT1		// Receive Descriptor Unavailable
+#define UHIMR_ROK					BIT0		// Receive DMA OK Interrupt
+
+// USB Host Interrupt Status Extension bit
+#define UHIMR_BCNDMAINT7			BIT23
+#define UHIMR_BCNDMAINT6			BIT22
+#define UHIMR_BCNDMAINT5			BIT21
+#define UHIMR_BCNDMAINT4			BIT20
+#define UHIMR_BCNDOK7				BIT19
+#define UHIMR_BCNDOK6				BIT18
+#define UHIMR_BCNDOK5				BIT17
+#define UHIMR_BCNDOK4				BIT16
+// bit14-15: RSVD
+#define UHIMR_ATIMEND_E			BIT13
+#define UHIMR_ATIMEND				BIT12
+#define UHIMR_TXERR					BIT11
+#define UHIMR_RXERR					BIT10
+#define UHIMR_TXFOVW				BIT9
+#define UHIMR_RXFOVW				BIT8
+// bit2-7: RSVD
+#define UHIMR_OCPINT				BIT1
+// bit0: RSVD
+
+
+#define HAL_NIC_UNPLUG_ISR			0xFFFFFFFF	// The value when the NIC is unplugged for PCI.
+#define HAL_NIC_UNPLUG_PCI_ISR		0xEAEAEAEA	// The value when the NIC is unplugged for PCI in PCI interrupt (page 3).
+
+//----------------------------------------------------------------------------
+//       8188 IMR/ISR bits
+//----------------------------------------------------------------------------
+#define IMR_DISABLED_88E			0x0
+// IMR DW0(0x0060-0063) Bit 0-31
+#define IMR_TXCCK_88E				BIT30		// TXRPT interrupt when CCX bit of the packet is set
+#define IMR_PSTIMEOUT_88E			BIT29		// Power Save Time Out Interrupt
+#define IMR_GTINT4_88E				BIT28		// When GTIMER4 expires, this bit is set to 1
+#define IMR_GTINT3_88E				BIT27		// When GTIMER3 expires, this bit is set to 1
+#define IMR_TBDER_88E				BIT26		// Transmit Beacon0 Error
+#define IMR_TBDOK_88E				BIT25		// Transmit Beacon0 OK
+#define IMR_TSF_BIT32_TOGGLE_88E	BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define IMR_BCNDMAINT0_88E		BIT20		// Beacon DMA Interrupt 0
+#define IMR_BCNDERR0_88E			BIT16		// Beacon Queue DMA Error 0
+#define IMR_HSISR_IND_ON_INT_88E	BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define IMR_BCNDMAINT_E_88E		BIT14		// Beacon DMA Interrupt Extension for Win7
+#define IMR_ATIMEND_88E			BIT12		// CTWidnow End or ATIM Window End
+#define IMR_HISR1_IND_INT_88E		BIT11		// HISR1 Indicator (HISR1 & HIMR1 is true, this bit is set to 1)
+#define IMR_C2HCMD_88E				BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define IMR_CPWM2_88E				BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define IMR_CPWM_88E				BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define IMR_HIGHDOK_88E			BIT7			// High Queue DMA OK
+#define IMR_MGNTDOK_88E			BIT6			// Management Queue DMA OK
+#define IMR_BKDOK_88E				BIT5			// AC_BK DMA OK
+#define IMR_BEDOK_88E				BIT4			// AC_BE DMA OK
+#define IMR_VIDOK_88E				BIT3			// AC_VI DMA OK
+#define IMR_VODOK_88E				BIT2			// AC_VO DMA OK
+#define IMR_RDU_88E					BIT1			// Rx Descriptor Unavailable
+#define IMR_ROK_88E					BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define IMR_BCNDMAINT7_88E		BIT27		// Beacon DMA Interrupt 7
+#define IMR_BCNDMAINT6_88E		BIT26		// Beacon DMA Interrupt 6
+#define IMR_BCNDMAINT5_88E		BIT25		// Beacon DMA Interrupt 5
+#define IMR_BCNDMAINT4_88E		BIT24		// Beacon DMA Interrupt 4
+#define IMR_BCNDMAINT3_88E		BIT23		// Beacon DMA Interrupt 3
+#define IMR_BCNDMAINT2_88E		BIT22		// Beacon DMA Interrupt 2
+#define IMR_BCNDMAINT1_88E		BIT21		// Beacon DMA Interrupt 1
+#define IMR_BCNDOK7_88E			BIT20		// Beacon Queue DMA OK Interrup 7
+#define IMR_BCNDOK6_88E			BIT19		// Beacon Queue DMA OK Interrup 6
+#define IMR_BCNDOK5_88E			BIT18		// Beacon Queue DMA OK Interrup 5
+#define IMR_BCNDOK4_88E			BIT17		// Beacon Queue DMA OK Interrup 4
+#define IMR_BCNDOK3_88E			BIT16		// Beacon Queue DMA OK Interrup 3
+#define IMR_BCNDOK2_88E			BIT15		// Beacon Queue DMA OK Interrup 2
+#define IMR_BCNDOK1_88E			BIT14		// Beacon Queue DMA OK Interrup 1
+#define IMR_ATIMEND_E_88E			BIT13		// ATIM Window End Extension for Win7
+#define IMR_TXERR_88E				BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define IMR_RXERR_88E				BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define IMR_TXFOVW_88E				BIT9			// Transmit FIFO Overflow
+#define IMR_RXFOVW_88E				BIT8			// Receive FIFO Overflow
+
+/*===================================================================
+=====================================================================
+Here the register defines are for 92C. When the define is as same with 92C,
+we will use the 92C's define for the consistency
+So the following defines for 92C is not entire!!!!!!
+=====================================================================
+=====================================================================*/
+/*
+Based on Datasheet V33---090401
+Register Summary
+Current IOREG MAP
+0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
+0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
+0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
+0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
+0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
+0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
+0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
+0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
+0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
+*/
+	//----------------------------------------------------------------------------
+	//		 8192C (TXPAUSE) transmission pause 	(Offset 0x522, 8 bits)
+	//----------------------------------------------------------------------------
+// Note:
+//	The the bits of stoping AC(VO/VI/BE/BK) queue in datasheet RTL8192S/RTL8192C are wrong,
+//	the correct arragement is VO - Bit0, VI - Bit1, BE - Bit2, and BK - Bit3.
+//	8723 and 88E may be not correct either in the eralier version. Confirmed with DD Tim.
+// By Bruce, 2011-09-22.
+#define StopBecon		BIT6
+#define StopHigh			BIT5
+#define StopMgt			BIT4
+#define StopBK			BIT3
+#define StopBE			BIT2
+#define StopVI			BIT1
+#define StopVO			BIT0
+
+//----------------------------------------------------------------------------
+//       8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
+//----------------------------------------------------------------------------
+#define RCR_APPFCS				BIT31	// WMAC append FCS after pauload
+#define RCR_APP_MIC				BIT30	// MACRX will retain the MIC at the bottom of the packet.
+#define RCR_APP_ICV				BIT29	// MACRX will retain the ICV at the bottom of the packet.
+#define RCR_APP_PHYST_RXFF		BIT28	// PHY Status is appended before RX packet in RXFF
+#define RCR_APP_BA_SSN			BIT27	// SSN of previous TXBA is appended as after original RXDESC as the 4-th DW of RXDESC.
+#define RCR_VHT_DACK			BIT26	/* This bit to control response type for vht single mpdu data packet. 1. ACK as response 0. BA as response */
+#define RCR_TCPOFLD_EN			BIT25	/* Enable TCP checksum offload */
+#define RCR_ENMBID				BIT24	// Enable Multiple BssId. Only response ACK to the packets whose DID(A1) matching to the addresses in the MBSSID CAM Entries.
+#define RCR_LSIGEN				BIT23	// Enable LSIG TXOP Protection function. Search KEYCAM for each rx packet to check if LSIGEN bit is set.
+#define RCR_MFBEN				BIT22	// Enable immediate MCS Feedback function. When Rx packet with MRQ = 1'b1, then search KEYCAM to find sender's MCS Feedback function and send response.
+#define RCR_DISCHKPPDLLEN		BIT21	/* Do not check PPDU while the PPDU length is smaller than 14 byte. */
+#define RCR_PKTCTL_DLEN			BIT20	/* While rx path dead lock occurs, reset rx path */
+#define RCR_DISGCLK				BIT19	/* Disable macrx clock gating control (no used) */
+#define RCR_TIM_PARSER_EN		BIT18	// RX Beacon TIM Parser.
+#define RCR_BC_MD_EN			BIT17	/* Broadcast data packet more data bit check interrupt enable.*/
+#define RCR_UC_MD_EN			BIT16	/* Unicast data packet more data bit check interrupt enable. */
+#define RCR_RXSK_PERPKT			BIT15	/* Executing key search per MPDU */
+#define RCR_HTC_LOC_CTRL		BIT14	// MFC<--HTC=1 MFC-->HTC=0
+#define RCR_AMF					BIT13	// Accept management type frame
+#define RCR_ACF					BIT12	// Accept control type frame. Control frames BA, BAR, and PS-Poll (when in AP mode) are not controlled by this bit. They are controlled by ADF.
+#define RCR_ADF					BIT11	// Accept data type frame. This bit also regulates BA, BAR, and PS-Poll (AP mode only).
+#define RCR_DISDECMYPKT			BIT10	/* This bit determines whether hw need to do decryption.1: If A1 match, do decryption.0: Do decryption. */
+#define RCR_AICV					BIT9		// Accept ICV error packet
+#define RCR_ACRC32				BIT8		// Accept CRC32 error packet
+#define RCR_CBSSID_BCN			BIT7		// Accept BSSID match packet (Rx beacon, probe rsp)
+#define RCR_CBSSID_DATA		BIT6		// Accept BSSID match packet (Data)
+#define RCR_APWRMGT			BIT5		// Accept power management packet
+#define RCR_ADD3				BIT4		// Accept address 3 match packet
+#define RCR_AB					BIT3		// Accept broadcast packet
+#define RCR_AM					BIT2		// Accept multicast packet
+#define RCR_APM					BIT1		// Accept physical match packet
+#define RCR_AAP					BIT0		// Accept all unicast packet
+
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+
+//2 SYS_ISO_CTRL
+#define ISO_MD2PP				BIT(0)
+#define ISO_UA2USB				BIT(1)
+#define ISO_UD2CORE				BIT(2)
+#define ISO_PA2PCIE				BIT(3)
+#define ISO_PD2CORE				BIT(4)
+#define ISO_IP2MAC				BIT(5)
+#define ISO_DIOP					BIT(6)
+#define ISO_DIOE					BIT(7)
+#define ISO_EB2CORE				BIT(8)
+#define ISO_DIOR					BIT(9)
+#define PWC_EV12V				BIT(15)
+
+
+//2 SYS_FUNC_EN
+#define FEN_BBRSTB				BIT(0)
+#define FEN_BB_GLB_RSTn		BIT(1)
+#define FEN_USBA				BIT(2)
+#define FEN_UPLL				BIT(3)
+#define FEN_USBD				BIT(4)
+#define FEN_DIO_PCIE			BIT(5)
+#define FEN_PCIEA				BIT(6)
+#define FEN_PPLL					BIT(7)
+#define FEN_PCIED				BIT(8)
+#define FEN_DIOE				BIT(9)
+#define FEN_CPUEN				BIT(10)
+#define FEN_DCORE				BIT(11)
+#define FEN_ELDR				BIT(12)
+#define FEN_EN_25_1				BIT(13)
+#define FEN_HWPDN				BIT(14)
+#define FEN_MREGEN				BIT(15)
+
+//2 APS_FSMCO
+#define PFM_LDALL				BIT(0)
+#define PFM_ALDN				BIT(1)
+#define PFM_LDKP				BIT(2)
+#define PFM_WOWL				BIT(3)
+#define EnPDN					BIT(4)
+#define PDN_PL					BIT(5)
+#define APFM_ONMAC				BIT(8)
+#define APFM_OFF				BIT(9)
+#define APFM_RSM				BIT(10)
+#define AFSM_HSUS				BIT(11)
+#define AFSM_PCIE				BIT(12)
+#define APDM_MAC				BIT(13)
+#define APDM_HOST				BIT(14)
+#define APDM_HPDN				BIT(15)
+#define RDY_MACON				BIT(16)
+#define SUS_HOST				BIT(17)
+#define ROP_ALD					BIT(20)
+#define ROP_PWR					BIT(21)
+#define ROP_SPS					BIT(22)
+#define SOP_MRST				BIT(25)
+#define SOP_FUSE				BIT(26)
+#define SOP_ABG					BIT(27)
+#define SOP_AMB					BIT(28)
+#define SOP_RCK					BIT(29)
+#define SOP_A8M					BIT(30)
+#define XOP_BTCK				BIT(31)
+
+//2 SYS_CLKR
+#define ANAD16V_EN				BIT(0)
+#define ANA8M					BIT(1)
+#define MACSLP					BIT(4)
+#define LOADER_CLK_EN			BIT(5)
+
+
+//2 9346CR /REG_SYS_EEPROM_CTRL
+#define BOOT_FROM_EEPROM		BIT(4)
+#define EEPROMSEL				BIT(4)
+#define EEPROM_EN				BIT(5)
+
+
+//2 RF_CTRL
+#define RF_EN					BIT(0)
+#define RF_RSTB					BIT(1)
+#define RF_SDMRSTB				BIT(2)
+
+
+//2 LDOV12D_CTRL
+#define LDV12_EN				BIT(0)
+#define LDV12_SDBY				BIT(1)
+#define LPLDO_HSM				BIT(2)
+#define LPLDO_LSM_DIS			BIT(3)
+#define _LDV12_VADJ(x)			(((x) & 0xF) << 4)
+
+
+
+//2 EFUSE_TEST (For RTL8723 partially)
+#define EF_TRPT					BIT(7)
+#define EF_CELL_SEL				(BIT(8)|BIT(9)) // 00: Wifi Efuse, 01: BT Efuse0, 10: BT Efuse1, 11: BT Efuse2
+#define LDOE25_EN				BIT(31)
+#define EFUSE_SEL(x)				(((x) & 0x3) << 8)
+#define EFUSE_SEL_MASK			0x300
+#define EFUSE_WIFI_SEL_0		0x0
+#define EFUSE_BT_SEL_0			0x1
+#define EFUSE_BT_SEL_1			0x2
+#define EFUSE_BT_SEL_2			0x3
+
+
+//2 8051FWDL
+//2 MCUFWDL
+#define MCUFWDL_EN				BIT(0)
+#define MCUFWDL_RDY			BIT(1)
+#define FWDL_ChkSum_rpt		BIT(2)
+#define MACINI_RDY				BIT(3)
+#define BBINI_RDY				BIT(4)
+#define RFINI_RDY				BIT(5)
+#define WINTINI_RDY				BIT(6)
+#define RAM_DL_SEL				BIT(7)
+#define CPU_DL_READY			BIT(15) /* add flag  by gw for fw download ready 20130826 */
+#define ROM_DLEN				BIT(19)
+#define CPRST					BIT(23)
+
+
+//2 REG_SYS_CFG
+#define XCLK_VLD				BIT(0)
+#define ACLK_VLD				BIT(1)
+#define UCLK_VLD				BIT(2)
+#define PCLK_VLD				BIT(3)
+#define PCIRSTB					BIT(4)
+#define V15_VLD					BIT(5)
+#define SW_OFFLOAD_EN			BIT(7)
+#define SIC_IDLE					BIT(8)
+#define BD_MAC2					BIT(9)
+#define BD_MAC1					BIT(10)
+#define IC_MACPHY_MODE		BIT(11)
+#define CHIP_VER				(BIT(12)|BIT(13)|BIT(14)|BIT(15))
+#define BT_FUNC					BIT(16)
+#define VENDOR_ID				BIT(19)
+#define EXT_VENDOR_ID			(BIT(18)|BIT(19)) //Currently only for RTL8723B
+#define PAD_HWPD_IDN			BIT(22)
+#define TRP_VAUX_EN				BIT(23)	// RTL ID
+#define TRP_BT_EN				BIT(24)
+#define BD_PKG_SEL				BIT(25)
+#define BD_HCI_SEL				BIT(26)
+#define TYPE_ID					BIT(27)
+#define RF_TYPE_ID				BIT(27)
+
+#define RTL_ID					BIT(23) // TestChip ID, 1:Test(RLE); 0:MP(RL)
+#define SPS_SEL					BIT(24) // 1:LDO regulator mode; 0:Switching regulator mode
+
+
+#define CHIP_VER_RTL_MASK		0xF000	//Bit 12 ~ 15
+#define CHIP_VER_RTL_SHIFT		12
+#define EXT_VENDOR_ID_SHIFT	18
+
+//2 REG_GPIO_OUTSTS (For RTL8723 only)
+#define EFS_HCI_SEL				(BIT(0)|BIT(1))
+#define PAD_HCI_SEL				(BIT(2)|BIT(3))
+#define HCI_SEL					(BIT(4)|BIT(5))
+#define PKG_SEL_HCI				BIT(6)
+#define FEN_GPS					BIT(7)
+#define FEN_BT					BIT(8)
+#define FEN_WL					BIT(9)
+#define FEN_PCI					BIT(10)
+#define FEN_USB					BIT(11)
+#define BTRF_HWPDN_N			BIT(12)
+#define WLRF_HWPDN_N			BIT(13)
+#define PDN_BT_N				BIT(14)
+#define PDN_GPS_N				BIT(15)
+#define BT_CTL_HWPDN			BIT(16)
+#define GPS_CTL_HWPDN			BIT(17)
+#define PPHY_SUSB				BIT(20)
+#define UPHY_SUSB				BIT(21)
+#define PCI_SUSEN				BIT(22)
+#define USB_SUSEN				BIT(23)
+#define RF_RL_ID					(BIT(31)|BIT(30)|BIT(29)|BIT(28))
+
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+
+//2 Function Enable Registers
+//2 CR
+#define HCI_TXDMA_EN			BIT(0)
+#define HCI_RXDMA_EN			BIT(1)
+#define TXDMA_EN				BIT(2)
+#define RXDMA_EN				BIT(3)
+#define PROTOCOL_EN				BIT(4)
+#define SCHEDULE_EN				BIT(5)
+#define MACTXEN					BIT(6)
+#define MACRXEN					BIT(7)
+#define ENSWBCN					BIT(8)
+#define ENSEC					BIT(9)
+#define CALTMR_EN				BIT(10)	// 32k CAL TMR enable
+
+// Network type
+#define _NETTYPE(x)				(((x) & 0x3) << 16)
+#define MASK_NETTYPE			0x30000
+#define NT_NO_LINK				0x0
+#define NT_LINK_AD_HOC			0x1
+#define NT_LINK_AP				0x2
+#define NT_AS_AP				0x3
+
+//2 PBP - Page Size Register
+#define GET_RX_PAGE_SIZE(value)			((value) & 0xF)
+#define GET_TX_PAGE_SIZE(value)			(((value) & 0xF0) >> 4)
+#define _PSRX_MASK				0xF
+#define _PSTX_MASK				0xF0
+#define _PSRX(x)				(x)
+#define _PSTX(x)				((x) << 4)
+
+#define PBP_64					0x0
+#define PBP_128					0x1
+#define PBP_256					0x2
+#define PBP_512					0x3
+#define PBP_1024				0x4
+
+
+//2 TX/RXDMA
+#define RXDMA_ARBBW_EN		BIT(0)
+#define RXSHFT_EN				BIT(1)
+#define RXDMA_AGG_EN			BIT(2)
+#define QS_VO_QUEUE			BIT(8)
+#define QS_VI_QUEUE				BIT(9)
+#define QS_BE_QUEUE			BIT(10)
+#define QS_BK_QUEUE			BIT(11)
+#define QS_MANAGER_QUEUE		BIT(12)
+#define QS_HIGH_QUEUE			BIT(13)
+
+#define HQSEL_VOQ				BIT(0)
+#define HQSEL_VIQ				BIT(1)
+#define HQSEL_BEQ				BIT(2)
+#define HQSEL_BKQ				BIT(3)
+#define HQSEL_MGTQ				BIT(4)
+#define HQSEL_HIQ				BIT(5)
+
+// For normal driver, 0x10C
+#define _TXDMA_CMQ_MAP(x) 	 		(((x)&0x3) << 16)
+#define _TXDMA_HIQ_MAP(x) 	 		(((x)&0x3) << 14)
+#define _TXDMA_MGQ_MAP(x) 	 		(((x)&0x3) << 12)
+#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)
+#define _TXDMA_BEQ_MAP(x) 	 		(((x)&0x3) << 8 )
+#define _TXDMA_VIQ_MAP(x) 	 		(((x)&0x3) << 6 )
+#define _TXDMA_VOQ_MAP(x) 	 		(((x)&0x3) << 4 )
+
+#define QUEUE_EXTRA				0
+#define QUEUE_LOW				1
+#define QUEUE_NORMAL			2
+#define QUEUE_HIGH				3
+
+
+//2 TRXFF_BNDY
+
+
+//2 LLT_INIT
+#define _LLT_NO_ACTIVE				0x0
+#define _LLT_WRITE_ACCESS			0x1
+#define _LLT_READ_ACCESS			0x2
+
+#define _LLT_INIT_DATA(x)			((x) & 0xFF)
+#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
+#define _LLT_OP(x)					(((x) & 0x3) << 30)
+#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
+
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+//2 RQPN
+#define _HPQ(x)					((x) & 0xFF)
+#define _LPQ(x)					(((x) & 0xFF) << 8)
+#define _PUBQ(x)					(((x) & 0xFF) << 16)
+#define _NPQ(x)					((x) & 0xFF)			// NOTE: in RQPN_NPQ register
+#define _EPQ(x)					(((x) & 0xFF) << 16)	// NOTE: in RQPN_EPQ register
+
+
+#define HPQ_PUBLIC_DIS			BIT(24)
+#define LPQ_PUBLIC_DIS			BIT(25)
+#define LD_RQPN					BIT(31)
+
+
+//2 TDECTL
+#define BLK_DESC_NUM_SHIFT			4
+#define BLK_DESC_NUM_MASK			0xF
+
+
+//2 TXDMA_OFFSET_CHK
+#define DROP_DATA_EN				BIT(9)
+
+//2 AUTO_LLT
+#define BIT_SHIFT_TXPKTNUM 24
+#define BIT_MASK_TXPKTNUM 0xff
+#define BIT_TXPKTNUM(x) (((x) & BIT_MASK_TXPKTNUM) << BIT_SHIFT_TXPKTNUM)
+
+#define BIT_TDE_DBG_SEL BIT(23)
+#define BIT_AUTO_INIT_LLT BIT(16)
+
+#define BIT_SHIFT_Tx_OQT_free_space 8
+#define BIT_MASK_Tx_OQT_free_space 0xff
+#define BIT_Tx_OQT_free_space(x) (((x) & BIT_MASK_Tx_OQT_free_space) << BIT_SHIFT_Tx_OQT_free_space)
+
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x028Bh	RX DMA Configuration
+//
+//-----------------------------------------------------
+
+//2 REG_RXDMA_CONTROL, 0x0286h
+// Write only. When this bit is set, RXDMA will decrease RX PKT counter by one. Before
+// this bit is polled, FW shall update RXFF_RD_PTR first. This register is write pulse and auto clear.
+//#define RXPKT_RELEASE_POLL			BIT(0)
+// Read only. When RXMA finishes on-going DMA operation, RXMDA will report idle state in
+// this bit. FW can start releasing packets after RXDMA entering idle mode.
+//#define RXDMA_IDLE					BIT(1)
+// When this bit is set, RXDMA will enter this mode after on-going RXDMA packet to host
+// completed, and stop DMA packet to host. RXDMA will then report Default: 0;
+//#define RW_RELEASE_EN				BIT(2)
+
+//2 REG_RXPKT_NUM, 0x0284
+#define 	RXPKT_RELEASE_POLL	BIT(16)
+#define	RXDMA_IDLE				BIT(17)
+#define	RW_RELEASE_EN			BIT(18)
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+//2 FWHW_TXQ_CTRL
+#define EN_AMPDU_RTY_NEW			BIT(7)
+
+
+//2 SPEC SIFS
+#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
+#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
+
+//2 RL
+#define	RETRY_LIMIT_SHORT_SHIFT			8
+#define	RETRY_LIMIT_LONG_SHIFT			0
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+
+//2 EDCA setting
+#define AC_PARAM_TXOP_LIMIT_OFFSET		16
+#define AC_PARAM_ECW_MAX_OFFSET			12
+#define AC_PARAM_ECW_MIN_OFFSET			8
+#define AC_PARAM_AIFS_OFFSET				0
+
+
+#define _LRL(x)					((x) & 0x3F)
+#define _SRL(x)					(((x) & 0x3F) << 8)
+
+
+//2 BCN_CTRL
+#define EN_TXBCN_RPT			BIT(2)
+#define EN_BCN_FUNCTION		BIT(3)
+#define STOP_BCNQ				BIT(6)
+#define DIS_RX_BSSID_FIT		BIT(6)
+
+#define DIS_ATIM					BIT(0)
+#define DIS_BCNQ_SUB			BIT(1)
+#define DIS_TSF_UDT				BIT(4)
+
+// The same function but different bit field.
+#define DIS_TSF_UDT0_NORMAL_CHIP	BIT(4)
+#define DIS_TSF_UDT0_TEST_CHIP	BIT(5)
+
+
+//2 ACMHWCTRL
+#define AcmHw_HwEn				BIT(0)
+#define AcmHw_BeqEn			BIT(1)
+#define AcmHw_ViqEn				BIT(2)
+#define AcmHw_VoqEn			BIT(3)
+#define AcmHw_BeqStatus		BIT(4)
+#define AcmHw_ViqStatus			BIT(5)
+#define AcmHw_VoqStatus		BIT(6)
+
+//2 //REG_DUAL_TSF_RST (0x553)
+#define DUAL_TSF_RST_P2P		BIT(4)
+
+//2 // REG_NOA_DESC_SEL (0x5CF)
+#define NOA_DESC_SEL_0			0
+#define NOA_DESC_SEL_1			BIT(4)
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+
+//2 APSD_CTRL
+#define APSDOFF					BIT(6)
+
+//2 TCR
+#define TSFRST					BIT(0)
+#define DIS_GCLK					BIT(1)
+#define PAD_SEL					BIT(2)
+#define PWR_ST					BIT(6)
+#define PWRBIT_OW_EN			BIT(7)
+#define ACRC						BIT(8)
+#define CFENDFORM				BIT(9)
+#define ICV						BIT(10)
+
+
+//2 RCR
+#define AAP						BIT(0)
+#define APM						BIT(1)
+#define AM						BIT(2)
+#define AB						BIT(3)
+#define ADD3						BIT(4)
+#define APWRMGT				BIT(5)
+#define CBSSID					BIT(6)
+#define CBSSID_DATA				BIT(6)
+#define CBSSID_BCN				BIT(7)
+#define ACRC32					BIT(8)
+#define AICV						BIT(9)
+#define ADF						BIT(11)
+#define ACF						BIT(12)
+#define AMF						BIT(13)
+#define HTC_LOC_CTRL			BIT(14)
+#define UC_DATA_EN				BIT(16)
+#define BM_DATA_EN				BIT(17)
+#define MFBEN					BIT(22)
+#define LSIGEN					BIT(23)
+#define EnMBID					BIT(24)
+#define FORCEACK				BIT(26)
+#define APP_BASSN				BIT(27)
+#define APP_PHYSTS				BIT(28)
+#define APP_ICV					BIT(29)
+#define APP_MIC					BIT(30)
+#define APP_FCS					BIT(31)
+
+
+//2 SECCFG
+#define SCR_TxUseDK				BIT(0)			//Force Tx Use Default Key
+#define SCR_RxUseDK				BIT(1)			//Force Rx Use Default Key
+#define SCR_TxEncEnable			BIT(2)			//Enable Tx Encryption
+#define SCR_RxDecEnable			BIT(3)			//Enable Rx Decryption
+#define SCR_SKByA2				BIT(4)			//Search kEY BY A2
+#define SCR_NoSKMC				BIT(5)			//No Key Search Multicast
+#define SCR_TXBCUSEDK			BIT(6)			// Force Tx Broadcast packets Use Default Key
+#define SCR_RXBCUSEDK			BIT(7)			// Force Rx Broadcast packets Use Default Key
+#define SCR_CHK_KEYID			BIT(8)
+#define SCR_CHK_BMC				BIT(9)			/* add option to support a2+keyid+bcm */
+
+//-----------------------------------------------------
+//
+//	SDIO Bus Specification
+//
+//-----------------------------------------------------
+
+// I/O bus domain address mapping
+#define SDIO_LOCAL_BASE		0x10250000
+#define WLAN_IOREG_BASE		0x10260000
+#define FIRMWARE_FIFO_BASE	0x10270000
+#define TX_HIQ_BASE				0x10310000
+#define TX_MIQ_BASE				0x10320000
+#define TX_LOQ_BASE				0x10330000
+#define TX_EPQ_BASE				0x10350000
+#define RX_RX0FF_BASE			0x10340000
+
+//SDIO host local register space mapping.
+#define SDIO_LOCAL_MSK				0x0FFF
+#define WLAN_IOREG_MSK 	             	0x7FFF
+#define WLAN_FIFO_MSK			      	0x1FFF	// Aggregation Length[12:0]
+#define WLAN_RX0FF_MSK			      	0x0003
+
+#define SDIO_WITHOUT_REF_DEVICE_ID	0	// Without reference to the SDIO Device ID
+#define SDIO_LOCAL_DEVICE_ID           		0	// 0b[16], 000b[15:13]
+#define WLAN_TX_HIQ_DEVICE_ID			4	// 0b[16], 100b[15:13]
+#define WLAN_TX_MIQ_DEVICE_ID 		5	// 0b[16], 101b[15:13]
+#define WLAN_TX_LOQ_DEVICE_ID 		6	// 0b[16], 110b[15:13]
+#define WLAN_TX_EXQ_DEVICE_ID		3	// 0b[16], 011b[15:13]
+#define WLAN_RX0FF_DEVICE_ID 			7	// 0b[16], 111b[15:13]
+#define WLAN_IOREG_DEVICE_ID 			8	// 1b[16]
+
+//SDIO Tx Free Page Index
+#define HI_QUEUE_IDX           			0
+#define MID_QUEUE_IDX         			1
+#define LOW_QUEUE_IDX 	      			2
+#define PUBLIC_QUEUE_IDX    			3
+
+#define SDIO_MAX_TX_QUEUE			3		// HIQ, MIQ and LOQ
+#define SDIO_MAX_RX_QUEUE			1
+
+#define SDIO_REG_TX_CTRL			0x0000 // SDIO Tx Control
+#define SDIO_REG_HIMR				0x0014 // SDIO Host Interrupt Mask
+#define SDIO_REG_HISR				0x0018 // SDIO Host Interrupt Service Routine
+#define SDIO_REG_HCPWM			0x0019 // HCI Current Power Mode
+#define SDIO_REG_RX0_REQ_LEN		0x001C // RXDMA Request Length
+#define SDIO_REG_OQT_FREE_PG		0x001E // OQT Free Page
+#define SDIO_REG_FREE_TXPG			0x0020 // Free Tx Buffer Page
+#define SDIO_REG_HCPWM1			0x0024 // HCI Current Power Mode 1
+#define SDIO_REG_HCPWM2			0x0026 // HCI Current Power Mode 2
+#define SDIO_REG_FREE_TXPG_SEQ	0x0028 // Free Tx Page Sequence
+#define SDIO_REG_HTSFR_INFO		0x0030 // HTSF Informaion
+#define SDIO_REG_HRPWM1			0x0080 // HCI Request Power Mode 1
+#define SDIO_REG_HRPWM2			0x0082 // HCI Request Power Mode 2
+#define SDIO_REG_HPS_CLKR			0x0084 // HCI Power Save Clock
+#define SDIO_REG_HSUS_CTRL			0x0086 // SDIO HCI Suspend Control
+#define SDIO_REG_HIMR_ON			0x0090 //SDIO Host Extension Interrupt Mask Always
+#define SDIO_REG_HISR_ON			0x0091 //SDIO Host Extension Interrupt Status Always
+
+#define SDIO_HIMR_DISABLED			0
+
+// RTL8723/RTL8188E SDIO Host Interrupt Mask Register
+#define SDIO_HIMR_RX_REQUEST_MSK		BIT0
+#define SDIO_HIMR_AVAL_MSK			BIT1
+#define SDIO_HIMR_TXERR_MSK			BIT2
+#define SDIO_HIMR_RXERR_MSK			BIT3
+#define SDIO_HIMR_TXFOVW_MSK			BIT4
+#define SDIO_HIMR_RXFOVW_MSK			BIT5
+#define SDIO_HIMR_TXBCNOK_MSK			BIT6
+#define SDIO_HIMR_TXBCNERR_MSK		BIT7
+#define SDIO_HIMR_BCNERLY_INT_MSK		BIT16
+#define SDIO_HIMR_C2HCMD_MSK			BIT17
+#define SDIO_HIMR_CPWM1_MSK			BIT18
+#define SDIO_HIMR_CPWM2_MSK			BIT19
+#define SDIO_HIMR_HSISR_IND_MSK		BIT20
+#define SDIO_HIMR_GTINT3_IND_MSK		BIT21
+#define SDIO_HIMR_GTINT4_IND_MSK		BIT22
+#define SDIO_HIMR_PSTIMEOUT_MSK		BIT23
+#define SDIO_HIMR_OCPINT_MSK			BIT24
+#define SDIO_HIMR_ATIMEND_MSK			BIT25
+#define SDIO_HIMR_ATIMEND_E_MSK		BIT26
+#define SDIO_HIMR_CTWEND_MSK			BIT27
+
+//RTL8188E SDIO Specific
+#define SDIO_HIMR_MCU_ERR_MSK			BIT28
+#define SDIO_HIMR_TSF_BIT32_TOGGLE_MSK		BIT29
+
+// SDIO Host Interrupt Service Routine
+#define SDIO_HISR_RX_REQUEST			BIT0
+#define SDIO_HISR_AVAL					BIT1
+#define SDIO_HISR_TXERR					BIT2
+#define SDIO_HISR_RXERR					BIT3
+#define SDIO_HISR_TXFOVW				BIT4
+#define SDIO_HISR_RXFOVW				BIT5
+#define SDIO_HISR_TXBCNOK				BIT6
+#define SDIO_HISR_TXBCNERR				BIT7
+#define SDIO_HISR_BCNERLY_INT			BIT16
+#define SDIO_HISR_C2HCMD				BIT17
+#define SDIO_HISR_CPWM1				BIT18
+#define SDIO_HISR_CPWM2				BIT19
+#define SDIO_HISR_HSISR_IND			BIT20
+#define SDIO_HISR_GTINT3_IND			BIT21
+#define SDIO_HISR_GTINT4_IND			BIT22
+#define SDIO_HISR_PSTIMEOUT			BIT23
+#define SDIO_HISR_OCPINT				BIT24
+#define SDIO_HISR_ATIMEND				BIT25
+#define SDIO_HISR_ATIMEND_E			BIT26
+#define SDIO_HISR_CTWEND				BIT27
+
+//RTL8188E SDIO Specific
+#define SDIO_HISR_MCU_ERR				BIT28
+#define SDIO_HISR_TSF_BIT32_TOGGLE	BIT29
+
+#define MASK_SDIO_HISR_CLEAR		(SDIO_HISR_TXERR |\
+									SDIO_HISR_RXERR |\
+									SDIO_HISR_TXFOVW |\
+									SDIO_HISR_RXFOVW |\
+									SDIO_HISR_TXBCNOK |\
+									SDIO_HISR_TXBCNERR |\
+									SDIO_HISR_C2HCMD |\
+									SDIO_HISR_CPWM1 |\
+									SDIO_HISR_CPWM2 |\
+									SDIO_HISR_HSISR_IND |\
+									SDIO_HISR_GTINT3_IND |\
+									SDIO_HISR_GTINT4_IND |\
+									SDIO_HISR_PSTIMEOUT |\
+									SDIO_HISR_OCPINT)
+
+// SDIO HCI Suspend Control Register
+#define HCI_RESUME_PWR_RDY			BIT1
+#define HCI_SUS_CTRL					BIT0
+
+// SDIO Tx FIFO related
+#define SDIO_TX_FREE_PG_QUEUE			4	// The number of Tx FIFO free page
+#define SDIO_TX_FIFO_PAGE_SZ 			128
+
+#ifdef CONFIG_SDIO_HCI
+	#define MAX_TX_AGG_PACKET_NUMBER 	0x8
+#else
+	#define MAX_TX_AGG_PACKET_NUMBER 	0xFF
+	#define MAX_TX_AGG_PACKET_NUMBER_8812 	64
+#endif
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+
+//2 USB Information (0xFE17)
+#define USB_IS_HIGH_SPEED			0
+#define USB_IS_FULL_SPEED			1
+#define USB_SPEED_MASK				BIT(5)
+
+#define USB_NORMAL_SIE_EP_MASK	0xF
+#define USB_NORMAL_SIE_EP_SHIFT	4
+
+//2 Special Option
+#define USB_AGG_EN				BIT(3)
+
+// 0; Use interrupt endpoint to upload interrupt pkt
+// 1; Use bulk endpoint to upload interrupt pkt,
+#define INT_BULK_SEL			BIT(4)
+
+//2REG_C2HEVT_CLEAR
+#define C2H_EVT_HOST_CLOSE		0x00	// Set by driver and notify FW that the driver has read the C2H command message
+#define C2H_EVT_FW_CLOSE		0xFF	// Set by FW indicating that FW had set the C2H command message and it's not yet read by driver.
+
+
+//2REG_MULTI_FUNC_CTRL(For RTL8723 Only)
+#define WL_HWPDN_EN			BIT0	// Enable GPIO[9] as WiFi HW PDn source
+#define WL_HWPDN_SL			BIT1	// WiFi HW PDn polarity control
+#define WL_FUNC_EN				BIT2	// WiFi function enable
+#define WL_HWROF_EN			BIT3	// Enable GPIO[9] as WiFi RF HW PDn source
+#define BT_HWPDN_EN			BIT16	// Enable GPIO[11] as BT HW PDn source
+#define BT_HWPDN_SL			BIT17	// BT HW PDn polarity control
+#define BT_FUNC_EN				BIT18	// BT function enable
+#define BT_HWROF_EN			BIT19	// Enable GPIO[11] as BT/GPS RF HW PDn source
+#define GPS_HWPDN_EN			BIT20	// Enable GPIO[10] as GPS HW PDn source
+#define GPS_HWPDN_SL			BIT21	// GPS HW PDn polarity control
+#define GPS_FUNC_EN			BIT22	// GPS function enable
+
+//3 REG_LIFECTRL_CTRL
+#define HAL92C_EN_PKT_LIFE_TIME_BK		BIT3
+#define HAL92C_EN_PKT_LIFE_TIME_BE		BIT2
+#define HAL92C_EN_PKT_LIFE_TIME_VI		BIT1
+#define HAL92C_EN_PKT_LIFE_TIME_VO		BIT0
+
+#define HAL92C_MSDU_LIFE_TIME_UNIT		128	// in us, said by Tim.
+
+//2 8192D PartNo.
+#define PARTNO_92D_NIC							(BIT7|BIT6)
+#define PARTNO_92D_NIC_REMARK 				(BIT5|BIT4)
+#define PARTNO_SINGLE_BAND_VS  				BIT3
+#define PARTNO_SINGLE_BAND_VS_REMARK 		BIT1
+#define PARTNO_CONCURRENT_BAND_VC 			(BIT3|BIT2)
+#define PARTNO_CONCURRENT_BAND_VC_REMARK 	(BIT1|BIT0)
+
+//========================================================
+// General definitions
+//========================================================
+
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(__Adapter)	   ( IS_VENDOR_8188E_I_CUT_SERIES(__Adapter) ? 255 : 175 )
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8812			255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723B		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8192C		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8703B		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC	127
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188F		255
+
+#define POLLING_LLT_THRESHOLD				20
+#if defined(CONFIG_RTL8723B) && defined(CONFIG_PCI_HCI)
+#define POLLING_READY_TIMEOUT_COUNT		6000
+#else
+#define POLLING_READY_TIMEOUT_COUNT		1000
+#endif
+
+
+// GPIO BIT
+#define	HAL_8812A_HW_GPIO_WPS_BIT	BIT2
+#define	HAL_8192C_HW_GPIO_WPS_BIT	BIT2
+#define	HAL_8192EU_HW_GPIO_WPS_BIT	BIT7
+#define	HAL_8188E_HW_GPIO_WPS_BIT	BIT7
+
+#endif //__HAL_COMMON_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_data.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_data.h
new file mode 100644
index 000000000..b4506a526
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_data.h
@@ -0,0 +1,653 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_DATA_H__
+#define __HAL_DATA_H__
+
+#if 1//def  CONFIG_SINGLE_IMG
+
+#include "../hal/phydm/phydm_precomp.h"
+#ifdef CONFIG_BT_COEXIST
+#include <hal_btcoex.h>
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#include <hal_sdio.h>
+#endif
+#ifdef CONFIG_GSPI_HCI
+#include <hal_gspi.h>
+#endif
+//
+// <Roger_Notes> For RTL8723 WiFi/BT/GPS multi-function configuration. 2010.10.06.
+//
+typedef enum _RT_MULTI_FUNC{
+	RT_MULTI_FUNC_NONE	= 0x00,
+	RT_MULTI_FUNC_WIFI 	= 0x01,
+	RT_MULTI_FUNC_BT 		= 0x02,
+	RT_MULTI_FUNC_GPS 	= 0x04,
+}RT_MULTI_FUNC,*PRT_MULTI_FUNC;
+//
+// <Roger_Notes> For RTL8723 WiFi PDn/GPIO polarity control configuration. 2010.10.08.
+//
+typedef enum _RT_POLARITY_CTL {
+	RT_POLARITY_LOW_ACT 	= 0,
+	RT_POLARITY_HIGH_ACT 	= 1,
+} RT_POLARITY_CTL, *PRT_POLARITY_CTL;
+
+// For RTL8723 regulator mode. by tynli. 2011.01.14.
+typedef enum _RT_REGULATOR_MODE {
+	RT_SWITCHING_REGULATOR 	= 0,
+	RT_LDO_REGULATOR 			= 1,
+} RT_REGULATOR_MODE, *PRT_REGULATOR_MODE;
+
+//
+// Interface type.
+//
+typedef	enum _INTERFACE_SELECT_PCIE{
+	INTF_SEL0_SOLO_MINICARD			= 0,		// WiFi solo-mCard
+	INTF_SEL1_BT_COMBO_MINICARD		= 1,		// WiFi+BT combo-mCard
+	INTF_SEL2_PCIe						= 2,		// PCIe Card
+} INTERFACE_SELECT_PCIE, *PINTERFACE_SELECT_PCIE;
+
+
+typedef	enum _INTERFACE_SELECT_USB{
+	INTF_SEL0_USB 				= 0,		// USB
+	INTF_SEL1_USB_High_Power  	= 1,		// USB with high power PA
+	INTF_SEL2_MINICARD		  	= 2,		// Minicard
+	INTF_SEL3_USB_Solo 		= 3,		// USB solo-Slim module
+	INTF_SEL4_USB_Combo		= 4,		// USB Combo-Slim module
+	INTF_SEL5_USB_Combo_MF	= 5,		// USB WiFi+BT Multi-Function Combo, i.e., Proprietary layout(AS-VAU) which is the same as SDIO card
+} INTERFACE_SELECT_USB, *PINTERFACE_SELECT_USB;
+
+typedef enum _RT_AMPDU_BRUST_MODE{
+	RT_AMPDU_BRUST_NONE 		= 0,
+	RT_AMPDU_BRUST_92D 		= 1,
+	RT_AMPDU_BRUST_88E 		= 2,
+	RT_AMPDU_BRUST_8812_4 	= 3,
+	RT_AMPDU_BRUST_8812_8 	= 4,
+	RT_AMPDU_BRUST_8812_12 	= 5,
+	RT_AMPDU_BRUST_8812_15	= 6,
+	RT_AMPDU_BRUST_8723B	 	= 7,
+}RT_AMPDU_BRUST,*PRT_AMPDU_BRUST_MODE;
+
+/*
+#define CHANNEL_MAX_NUMBER			14+24+21	// 14 is the max channel number
+*/
+#define CHANNEL_GROUP_MAX		(3 + 9)	/* ch1~3, ch4~9, ch10~14 total three groups */
+#define MAX_PG_GROUP			13
+
+// Tx Power Limit Table Size
+#define MAX_REGULATION_NUM						4
+#define MAX_RF_PATH_NUM_IN_POWER_LIMIT_TABLE	4
+#define MAX_2_4G_BANDWIDTH_NUM					2
+#define MAX_RATE_SECTION_NUM						10
+#define MAX_5G_BANDWIDTH_NUM						4
+
+#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			10 //  CCK:1,OFDM:1, HT:4, VHT:4
+#define MAX_BASE_NUM_IN_PHY_REG_PG_5G			9 // OFDM:1, HT:4, VHT:4
+
+
+//###### duplicate code,will move to ODM #########
+//#define IQK_MAC_REG_NUM		4
+//#define IQK_ADDA_REG_NUM		16
+
+//#define IQK_BB_REG_NUM			10
+#define IQK_BB_REG_NUM_92C	9
+#define IQK_BB_REG_NUM_92D	10
+#define IQK_BB_REG_NUM_test	6
+
+#define IQK_Matrix_Settings_NUM_92D	1+24+21
+
+//#define HP_THERMAL_NUM		8
+//###### duplicate code,will move to ODM #########
+
+#ifdef CONFIG_USB_RX_AGGREGATION
+typedef enum _USB_RX_AGG_MODE{
+	USB_RX_AGG_DISABLE,
+	USB_RX_AGG_DMA,
+	USB_RX_AGG_USB,
+	USB_RX_AGG_MIX
+}USB_RX_AGG_MODE;
+
+//#define MAX_RX_DMA_BUFFER_SIZE	10240		// 10K for 8192C RX DMA buffer
+
+#endif
+
+/* For store initial value of BB register */
+typedef struct _BB_INIT_REGISTER {
+	u16	offset;
+	u32	value;
+
+} BB_INIT_REGISTER, *PBB_INIT_REGISTER;
+
+#define PAGE_SIZE_128	128
+#define PAGE_SIZE_256	256
+#define PAGE_SIZE_512	512
+
+#define HCI_SUS_ENTER		0
+#define HCI_SUS_LEAVING		1
+#define HCI_SUS_LEAVE		2
+#define HCI_SUS_ENTERING	3
+#define HCI_SUS_ERR			4
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+typedef enum _ACS_OP {
+	ACS_INIT,		/*ACS - Variable init*/
+	ACS_RESET,		/*ACS - NHM Counter reset*/
+	ACS_SELECT,		/*ACS - NHM Counter Statistics */
+} ACS_OP;
+
+typedef enum _ACS_STATE {
+	ACS_DISABLE,
+	ACS_ENABLE,
+} ACS_STATE;
+
+struct auto_chan_sel {
+	ATOMIC_T state;
+	u8	ch; /* previous channel*/
+};
+#endif /*CONFIG_AUTO_CHNL_SEL_NHM*/
+
+#define EFUSE_FILE_UNUSED 0
+#define EFUSE_FILE_FAILED 1
+#define EFUSE_FILE_LOADED 2
+
+#define MACADDR_FILE_UNUSED 0
+#define MACADDR_FILE_FAILED 1
+#define MACADDR_FILE_LOADED 2
+
+#define KFREE_FLAG_ON				BIT0
+#define KFREE_FLAG_THERMAL_K_ON		BIT1
+
+struct kfree_data_t {
+		u8 flag;
+		s8 bb_gain[BB_GAIN_NUM][RF_PATH_MAX];
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+		s8 pa_bias_5g[RF_PATH_MAX];
+		s8 pad_bias_5g[RF_PATH_MAX];
+#endif
+		s8 thermal;
+};
+
+bool kfree_data_is_bb_gain_empty(struct kfree_data_t *data);
+
+struct hal_spec_t {
+	u8 macid_num;
+
+	u8 sec_cam_ent_num;
+	u8 sec_cap;
+
+	u8 nss_num;
+	u8 band_cap;	/* value of BAND_CAP_XXX */
+	u8 bw_cap;		/* value of BW_CAP_XXX */
+	u8 proto_cap;	/* value of PROTO_CAP_XXX */
+
+	u8 wl_func;		/* value of WL_FUNC_XXX */
+};
+
+typedef struct hal_com_data
+{
+	HAL_VERSION			VersionID;
+	RT_MULTI_FUNC		MultiFunc; // For multi-function consideration.
+	RT_POLARITY_CTL		PolarityCtl; // For Wifi PDn Polarity control.
+	RT_REGULATOR_MODE	RegulatorMode; // switching regulator or LDO
+	u8	hw_init_completed;
+	/****** FW related ******/
+	u16	FirmwareVersion;
+	u16	FirmwareVersionRev;
+	u16	FirmwareSubVersion;
+	u16	FirmwareSignature;
+	u8	RegFWOffload;
+	u8	fw_ractrl;
+	u8	FwRsvdPageStartOffset; /* 2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ.*/
+	u8	LastHMEBoxNum;	/* H2C - for host message to fw */
+
+	/****** current WIFI_PHY values ******/
+	WIRELESS_MODE	CurrentWirelessMode;
+	CHANNEL_WIDTH	CurrentChannelBW;
+	BAND_TYPE		CurrentBandType;	/* 0:2.4G, 1:5G */
+	BAND_TYPE		BandSet;
+	u8				CurrentChannel;
+	u8				CurrentCenterFrequencyIndex1;
+	u8				nCur40MhzPrimeSC;	/* Control channel sub-carrier */
+	u8				nCur80MhzPrimeSC;   /* used for primary 40MHz of 80MHz mode */
+	BOOLEAN 		bSwChnlAndSetBWInProgress;
+	u8				bDisableSWChannelPlan; /* flag of disable software change channel plan	 */
+	u16				BasicRateSet;
+	u32				ReceiveConfig;
+	BOOLEAN			bSwChnl;
+	BOOLEAN			bSetChnlBW;
+	BOOLEAN			bChnlBWInitialized;
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	struct auto_chan_sel acs;
+#endif
+	/****** rf_ctrl *****/
+	u8	rf_chip;
+	u8	rf_type;
+	u8	PackageType;
+	u8	NumTotalRFPath;
+
+	/****** Debug ******/
+	u16	ForcedDataRate;	/* Force Data Rate. 0: Auto, 0x02: 1M ~ 0x6C: 54M. */
+	u8	u1ForcedIgiLb;	/* forced IGI lower bound */
+	u8	bDumpRxPkt;
+	u8	bDumpTxPkt;
+	u8 	bDisableTXPowerTraining;
+
+
+	/****** EEPROM setting.******/
+	u8	bautoload_fail_flag;
+	u8	efuse_file_status;
+	u8	macaddr_file_status;
+	u8	EepromOrEfuse;
+	u8	efuse_eeprom_data[EEPROM_MAX_SIZE]; /*92C:256bytes, 88E:512bytes, we use union set (512bytes)*/
+	u8	InterfaceSel; /* board type kept in eFuse */
+	u16	CustomerID;
+
+	u16	EEPROMVID;
+	u16	EEPROMSVID;
+#ifdef CONFIG_USB_HCI
+	u16	EEPROMPID;
+	u16	EEPROMSDID;
+#endif
+#ifdef CONFIG_PCI_HCI
+ 	u16	EEPROMDID;
+	u16	EEPROMSMID;
+#endif
+
+	u8	EEPROMCustomerID;
+	u8	EEPROMSubCustomerID;
+	u8	EEPROMVersion;
+	u8	EEPROMRegulatory;
+	u8	EEPROMThermalMeter;
+	u8	EEPROMBluetoothCoexist;
+	u8	EEPROMBluetoothType;
+	u8	EEPROMBluetoothAntNum;
+	u8	EEPROMBluetoothAntIsolation;
+	u8	EEPROMBluetoothRadioShared;
+	u8	bTXPowerDataReadFromEEPORM;
+	u8	EEPROMMACAddr[ETH_ALEN];
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+	u8	EEPROMRFGainOffset;
+	u8	EEPROMRFGainVal;
+	struct kfree_data_t kfree_data;
+#endif /*CONFIG_RF_GAIN_OFFSET*/
+
+#if defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8703B)
+	u8	adjuseVoltageVal;
+#endif
+	u8	EfuseUsedPercentage;
+	u16	EfuseUsedBytes;
+	/*u8		EfuseMap[2][HWSET_MAX_SIZE_JAGUAR];*/
+	EFUSE_HAL	EfuseHal;
+
+	/*---------------------------------------------------------------------------------*/
+	//3 [2.4G]
+	u8	Index24G_CCK_Base[MAX_RF_PATH][CENTER_CH_2G_NUM];
+	u8	Index24G_BW40_Base[MAX_RF_PATH][CENTER_CH_2G_NUM];
+	//If only one tx, only BW20 and OFDM are used.
+	s8	CCK_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	OFDM_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW20_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW40_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	//3 [5G]
+	u8	Index5G_BW40_Base[MAX_RF_PATH][CENTER_CH_5G_ALL_NUM];
+	u8	Index5G_BW80_Base[MAX_RF_PATH][CENTER_CH_5G_80M_NUM];
+	s8	OFDM_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW20_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW40_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW80_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+
+	u8	Regulation2_4G;
+	u8	Regulation5G;
+
+	u8	TxPwrInPercentage;
+
+	/********************************
+	*	TX power by rate table at most 4RF path.
+	*	The register is
+	*
+	*	VHT TX power by rate off setArray =
+	*	Band:-2G&5G = 0 / 1
+	*	RF: at most 4*4 = ABCD=0/1/2/3
+	*	CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
+	**********************************/
+	u8	TxPwrByRateTable;
+	u8	TxPwrByRateBand;
+	s8	TxPwrByRateOffset[TX_PWR_BY_RATE_NUM_BAND]
+						 [TX_PWR_BY_RATE_NUM_RF]
+						 [TX_PWR_BY_RATE_NUM_RF]
+						 [TX_PWR_BY_RATE_NUM_RATE];
+	//---------------------------------------------------------------------------------//
+
+	/*
+	//2 Power Limit Table
+	u8	TxPwrLevelCck[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];
+	u8	TxPwrLevelHT40_1S[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	s8	TxPwrHt20Diff[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
+	u8	TxPwrLegacyHtDiff[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
+	*/
+
+	u8 tx_pwr_lmt_5g_20_40_ref;
+
+	// Power Limit Table for 2.4G
+	s8	TxPwrLimit_2_4G[MAX_REGULATION_NUM]
+						[MAX_2_4G_BANDWIDTH_NUM]
+						[MAX_RATE_SECTION_NUM]
+						[CENTER_CH_2G_NUM]
+						[MAX_RF_PATH];
+
+	// Power Limit Table for 5G
+	s8	TxPwrLimit_5G[MAX_REGULATION_NUM]
+						[MAX_5G_BANDWIDTH_NUM]
+						[MAX_RATE_SECTION_NUM]
+						[CENTER_CH_5G_ALL_NUM]
+						[MAX_RF_PATH];
+
+
+	// Store the original power by rate value of the base of each rate section of rf path A & B
+	u8	TxPwrByRateBase2_4G[TX_PWR_BY_RATE_NUM_RF]
+						[TX_PWR_BY_RATE_NUM_RF]
+						[MAX_BASE_NUM_IN_PHY_REG_PG_2_4G];
+	u8	TxPwrByRateBase5G[TX_PWR_BY_RATE_NUM_RF]
+						[TX_PWR_BY_RATE_NUM_RF]
+						[MAX_BASE_NUM_IN_PHY_REG_PG_5G];
+
+	u8	txpwr_by_rate_loaded:1;
+	u8	txpwr_by_rate_from_file:1;
+	u8	txpwr_limit_loaded:1;
+	u8	txpwr_limit_from_file:1;
+
+	// For power group
+	/*
+	u8	PwrGroupHT20[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];
+	u8	PwrGroupHT40[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];
+	*/
+	u8	PGMaxGroup;
+
+	// The current Tx Power Level
+	u8	CurrentCckTxPwrIdx;
+	u8	CurrentOfdm24GTxPwrIdx;
+	u8	CurrentBW2024GTxPwrIdx;
+	u8	CurrentBW4024GTxPwrIdx;
+
+	// Read/write are allow for following hardware information variables
+	u8	pwrGroupCnt;
+	u32	MCSTxPowerLevelOriginalOffset[MAX_PG_GROUP][16];
+	u32	CCKTxPowerLevelOriginalOffset;
+
+	u8	CrystalCap;
+
+	u8	PAType_2G;
+	u8	PAType_5G;
+	u8	LNAType_2G;
+	u8	LNAType_5G;
+	u8	ExternalPA_2G;
+	u8	ExternalLNA_2G;
+	u8	ExternalPA_5G;
+	u8	ExternalLNA_5G;
+	u16	TypeGLNA;
+	u16	TypeGPA;
+	u16	TypeALNA;
+	u16	TypeAPA;
+	u16	RFEType;
+
+	u8	bLedOpenDrain; /* Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16. */
+	u32	AcParam_BE; /* Original parameter for BE, use for EDCA turbo.	*/
+
+	BB_REGISTER_DEFINITION_T	PHYRegDef[MAX_RF_PATH];	//Radio A/B/C/D
+
+	u32	RfRegChnlVal[MAX_RF_PATH];
+
+	//RDG enable
+	BOOLEAN	 bRDGEnable;
+
+	u8	RegTxPause;
+	// Beacon function related global variable.
+	u8	RegBcnCtrlVal;
+	u8	RegFwHwTxQCtrl;
+	u8	RegReg542;
+	u8	RegCR_1;
+	u8	Reg837;
+	u16	RegRRSR;
+
+	/****** antenna diversity ******/
+	u8	CurAntenna;
+	u8	AntDivCfg;
+	u8	AntDetection;
+	u8	TRxAntDivType;
+	u8	ant_path; //for 8723B s0/s1 selection
+	u32	AntennaTxPath;					/* Antenna path Tx */
+	u32	AntennaRxPath;					/* Antenna path Rx */
+
+	/******** PHY DM & DM Section **********/
+	u8			DM_Type;
+	_lock		IQKSpinLock;
+	u8			INIDATA_RATE[MACID_NUM_SW_LIMIT];
+	/* Upper and Lower Signal threshold for Rate Adaptive*/
+	int			EntryMinUndecoratedSmoothedPWDB;
+	int			EntryMaxUndecoratedSmoothedPWDB;
+	int			MinUndecoratedPWDBForDM;
+	DM_ODM_T	odmpriv;
+	u8			bIQKInitialized;
+	u8 			bNeedIQK;
+	/******** PHY DM & DM Section **********/
+
+
+
+	// 2010/08/09 MH Add CU power down mode.
+	BOOLEAN		pwrdown;
+
+	// Add for dual MAC  0--Mac0 1--Mac1
+	u32	interfaceIndex;
+
+#ifdef CONFIG_P2P
+	u8	p2p_ps_offload;
+#endif
+	/* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
+	u8	bMacPwrCtrlOn;
+	u8 hci_sus_state;
+
+	u8	RegIQKFWOffload;
+	struct submit_ctx 	iqk_sctx;
+
+	RT_AMPDU_BRUST		AMPDUBurstMode; //92C maybe not use, but for compile successfully
+
+	u8	OutEpQueueSel;
+	u8	OutEpNumber;
+
+#if defined (CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	//
+	// For SDIO Interface HAL related
+	//
+
+	//
+	// SDIO ISR Related
+	//
+//	u32			IntrMask[1];
+//	u32			IntrMaskToSet[1];
+//	LOG_INTERRUPT		InterruptLog;
+	u32			sdio_himr;
+	u32			sdio_hisr;
+
+	//
+	// SDIO Tx FIFO related.
+	//
+	// HIQ, MID, LOW, PUB free pages; padapter->xmitpriv.free_txpg
+	u8			SdioTxFIFOFreePage[SDIO_TX_FREE_PG_QUEUE];
+	_lock		SdioTxFIFOFreePageLock;
+	u8			SdioTxOQTMaxFreeSpace;
+	u8			SdioTxOQTFreeSpace;
+
+	//
+	// SDIO Rx FIFO related.
+	//
+	u8			SdioRxFIFOCnt;
+	u16			SdioRxFIFOSize;
+
+	u32			sdio_tx_max_len[SDIO_MAX_TX_QUEUE];// H, N, L, used for sdio tx aggregation max length per queue
+#endif //CONFIG_SDIO_HCI
+
+#ifdef CONFIG_USB_HCI
+
+	// 2010/12/10 MH Add for USB aggreation mode dynamic shceme.
+	BOOLEAN		UsbRxHighSpeedMode;
+	BOOLEAN		UsbTxVeryHighSpeedMode;
+	u32			UsbBulkOutSize;
+	BOOLEAN		bSupportUSB3;
+
+	// Interrupt relatd register information.
+	u32			IntArray[3];//HISR0,HISR1,HSISR
+	u32			IntrMask[3];
+	u8			C2hArray[16];
+	#ifdef CONFIG_USB_TX_AGGREGATION
+	u8			UsbTxAggMode;
+	u8			UsbTxAggDescNum;
+	#endif // CONFIG_USB_TX_AGGREGATION
+
+	#ifdef CONFIG_USB_RX_AGGREGATION
+	u16			HwRxPageSize;				// Hardware setting
+	u32			MaxUsbRxAggBlock;
+
+	USB_RX_AGG_MODE	UsbRxAggMode;
+	u8			UsbRxAggBlockCount;		/* FOR USB Mode, USB Block count. Block size is 512-byte in hight speed and 64-byte in full speed */
+	u8			UsbRxAggBlockTimeout;
+	u8			UsbRxAggPageCount;			/* FOR DMA Mode, 8192C DMA page count*/
+	u8			UsbRxAggPageTimeout;
+
+	u8			RegAcUsbDmaSize;
+	u8			RegAcUsbDmaTime;
+	#endif//CONFIG_USB_RX_AGGREGATION
+#endif //CONFIG_USB_HCI
+
+
+#ifdef CONFIG_PCI_HCI
+	//
+	// EEPROM setting.
+	//
+	u32			TransmitConfig;
+	u32			IntrMaskToSet[2];
+	u32			IntArray[2];
+	u32			IntrMask[2];
+	u32			SysIntArray[1];
+	u32			SysIntrMask[1];
+	u32			IntrMaskReg[2];
+	u32			IntrMaskDefault[2];
+
+	BOOLEAN	 	bL1OffSupport;
+	BOOLEAN 	bSupportBackDoor;
+
+	u8			bDefaultAntenna;
+
+	u8			bInterruptMigration;
+	u8			bDisableTxInt;
+
+	u16			RxTag;
+#endif //CONFIG_PCI_HCI
+
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	struct sreset_priv srestpriv;
+#endif //#ifdef DBG_CONFIG_ERROR_DETECT
+
+#ifdef CONFIG_BT_COEXIST
+	// For bluetooth co-existance
+	BT_COEXIST		bt_coexist;
+#endif // CONFIG_BT_COEXIST
+
+#if defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8703B) || defined(CONFIG_RTL8188F)
+	#ifndef CONFIG_PCI_HCI	// mutual exclusive with PCI -- so they're SDIO and GSPI
+	// Interrupt relatd register information.
+	u32			SysIntrStatus;
+	u32			SysIntrMask;
+	#endif
+#endif /*endif CONFIG_RTL8723B	*/
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	char	para_file_buf[MAX_PARA_FILE_BUF_LEN];
+	char *mac_reg;
+	u32	mac_reg_len;
+	char *bb_phy_reg;
+	u32	bb_phy_reg_len;
+	char *bb_agc_tab;
+	u32	bb_agc_tab_len;
+	char *bb_phy_reg_pg;
+	u32	bb_phy_reg_pg_len;
+	char *bb_phy_reg_mp;
+	u32	bb_phy_reg_mp_len;
+	char *rf_radio_a;
+	u32	rf_radio_a_len;
+	char *rf_radio_b;
+	u32	rf_radio_b_len;
+	char *rf_tx_pwr_track;
+	u32	rf_tx_pwr_track_len;
+	char *rf_tx_pwr_lmt;
+	u32	rf_tx_pwr_lmt_len;
+#endif
+
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+	s16 noise[ODM_MAX_CHANNEL_NUM];
+#endif
+
+	struct hal_spec_t hal_spec;
+
+	u8	RfKFreeEnable;
+	u8	RfKFree_ch_group;
+	BOOLEAN				bCCKinCH14;
+	BB_INIT_REGISTER	RegForRecover[5];
+
+#if defined(CONFIG_PCI_HCI) && defined(RTL8814AE_SW_BCN)
+	BOOLEAN bCorrectBCN;
+#endif
+
+} HAL_DATA_COMMON, *PHAL_DATA_COMMON;
+
+
+
+typedef struct hal_com_data HAL_DATA_TYPE, *PHAL_DATA_TYPE;
+#define GET_HAL_DATA(__pAdapter)			((HAL_DATA_TYPE *)((__pAdapter)->HalData))
+#define GET_HAL_SPEC(__pAdapter)			(&(GET_HAL_DATA((__pAdapter))->hal_spec))
+
+#define GET_HAL_RFPATH_NUM(__pAdapter)		(((HAL_DATA_TYPE *)((__pAdapter)->HalData))->NumTotalRFPath )
+#define RT_GetInterfaceSelection(_Adapter) 		(GET_HAL_DATA(_Adapter)->InterfaceSel)
+#define GET_RF_TYPE(__pAdapter)				(GET_HAL_DATA(__pAdapter)->rf_type)
+#define GET_KFREE_DATA(_adapter) (&(GET_HAL_DATA((_adapter))->kfree_data))
+
+#define	SUPPORT_HW_RADIO_DETECT(Adapter)	(	RT_GetInterfaceSelection(Adapter) == INTF_SEL2_MINICARD ||\
+												RT_GetInterfaceSelection(Adapter) == INTF_SEL3_USB_Solo ||\
+												RT_GetInterfaceSelection(Adapter) == INTF_SEL4_USB_Combo)
+
+#define get_hal_mac_addr(adapter) 				(GET_HAL_DATA(adapter)->EEPROMMACAddr)
+#define is_boot_from_eeprom(adapter) 			(GET_HAL_DATA(adapter)->EepromOrEfuse)
+#define rtw_get_hw_init_completed(adapter)		(GET_HAL_DATA(adapter)->hw_init_completed)
+#define rtw_is_hw_init_completed(adapter)		(GET_HAL_DATA(adapter)->hw_init_completed == _TRUE)
+#endif
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+#define GET_ACS_STATE(padapter)					(ATOMIC_READ(&GET_HAL_DATA(padapter)->acs.state))
+#define SET_ACS_STATE(padapter, set_state)			(ATOMIC_SET(&GET_HAL_DATA(padapter)->acs.state, set_state))
+#define rtw_get_acs_channel(padapter)				(GET_HAL_DATA(padapter)->acs.ch)
+#define rtw_set_acs_channel(padapter, survey_ch)	(GET_HAL_DATA(padapter)->acs.ch = survey_ch)
+#endif /*CONFIG_AUTO_CHNL_SEL_NHM*/
+
+#endif //__HAL_DATA_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_gspi.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_gspi.h
new file mode 100644
index 000000000..0f6b99693
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_gspi.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_GSPI_H_
+#define __HAL_GSPI_H_
+
+#define ffaddr2deviceId(pdvobj, addr)	(pdvobj->Queue2Pipe[addr])
+
+u8 rtw_hal_gspi_max_txoqt_free_space(_adapter *padapter);
+u8 rtw_hal_gspi_query_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_gspi_update_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_set_gspi_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
+u32 rtw_hal_get_gspi_tx_max_length(PADAPTER padapter, u8 queue_idx);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_ic_cfg.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_ic_cfg.h
new file mode 100644
index 000000000..0dd6c4b54
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_ic_cfg.h
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_IC_CFG_H__
+#define __HAL_IC_CFG_H__
+
+#define RTL8188E_SUPPORT				0
+#define RTL8812A_SUPPORT				0
+#define RTL8821A_SUPPORT				0
+#define RTL8723B_SUPPORT				0
+#define RTL8192E_SUPPORT				0
+#define RTL8814A_SUPPORT				0
+#define RTL8195A_SUPPORT				0
+#define RTL8703B_SUPPORT				0
+#define RTL8188F_SUPPORT				0
+#define RTL8822B_SUPPORT				0
+#define RTL8821B_SUPPORT				0
+
+/*#if (RTL8188E_SUPPORT==1)*/
+#define RATE_ADAPTIVE_SUPPORT			0
+#define POWER_TRAINING_ACTIVE			0
+
+#ifdef CONFIG_MULTIDRV
+#endif
+
+#ifdef CONFIG_RTL8188E
+#undef RTL8188E_SUPPORT
+#undef RATE_ADAPTIVE_SUPPORT
+#undef POWER_TRAINING_ACTIVE
+
+#define RTL8188E_SUPPORT				1
+#define RATE_ADAPTIVE_SUPPORT			1
+#define POWER_TRAINING_ACTIVE			1
+#endif
+
+#ifdef CONFIG_RTL8812A
+#undef RTL8812A_SUPPORT
+#define RTL8812A_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8821A
+#undef RTL8821A_SUPPORT
+#define RTL8821A_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8192E
+#undef RTL8192E_SUPPORT
+#define RTL8192E_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8723B
+#undef RTL8723B_SUPPORT
+#define RTL8723B_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8814A
+#undef RTL8814A_SUPPORT
+#define RTL8814A_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8703B
+#undef RTL8703B_SUPPORT
+#define RTL8703B_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8188F
+#undef RTL8188F_SUPPORT
+#define RTL8188F_SUPPORT				1
+#endif
+
+#ifdef CONFIG_RTL8822B
+#undef RTL8822B_SUPPORT
+#define RTL8822B_SUPPORT				1
+#endif
+
+#endif /*__HAL_IC_CFG_H__*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_intf.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_intf.h
new file mode 100644
index 000000000..dd2836c65
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_intf.h
@@ -0,0 +1,688 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_INTF_H__
+#define __HAL_INTF_H__
+
+
+enum RTL871X_HCI_TYPE {
+	RTW_PCIE	= BIT0,
+	RTW_USB 	= BIT1,
+	RTW_SDIO 	= BIT2,
+	RTW_GSPI	= BIT3,
+};
+
+enum _CHIP_TYPE {
+
+	NULL_CHIP_TYPE,
+	RTL8188E,
+	RTL8192E,
+	RTL8812,
+	RTL8821, //RTL8811
+	RTL8723B,
+	RTL8814A,
+	RTL8703B,
+	RTL8188F,
+	MAX_CHIP_TYPE
+};
+
+extern const u32 _chip_type_to_odm_ic_type[];
+#define chip_type_to_odm_ic_type(chip_type) (((chip_type) >= MAX_CHIP_TYPE) ? _chip_type_to_odm_ic_type[MAX_CHIP_TYPE] : _chip_type_to_odm_ic_type[(chip_type)])
+
+typedef enum _HAL_HW_TIMER_TYPE {
+	HAL_TIMER_NONE = 0,
+	HAL_TIMER_TXBF = 1,
+	HAL_TIMER_EARLYMODE = 2,
+} HAL_HW_TIMER_TYPE, *PHAL_HW_TIMER_TYPE;
+
+
+typedef enum _HW_VARIABLES{
+	HW_VAR_MEDIA_STATUS,
+	HW_VAR_MEDIA_STATUS1,
+	HW_VAR_SET_OPMODE,
+	HW_VAR_MAC_ADDR,
+	HW_VAR_BSSID,
+	HW_VAR_INIT_RTS_RATE,
+	HW_VAR_BASIC_RATE,
+	HW_VAR_TXPAUSE,
+	HW_VAR_BCN_FUNC,
+	HW_VAR_CORRECT_TSF,
+	HW_VAR_CHECK_BSSID,
+	HW_VAR_MLME_DISCONNECT,
+	HW_VAR_MLME_SITESURVEY,
+	HW_VAR_MLME_JOIN,
+	HW_VAR_ON_RCR_AM,
+       HW_VAR_OFF_RCR_AM,
+	HW_VAR_BEACON_INTERVAL,
+	HW_VAR_SLOT_TIME,
+	HW_VAR_RESP_SIFS,
+	HW_VAR_ACK_PREAMBLE,
+	HW_VAR_SEC_CFG,
+	HW_VAR_SEC_DK_CFG,
+	HW_VAR_BCN_VALID,
+	HW_VAR_RF_TYPE,
+	/* PHYDM odm->SupportAbility */
+	HW_VAR_CAM_EMPTY_ENTRY,
+	HW_VAR_CAM_INVALID_ALL,
+	HW_VAR_AC_PARAM_VO,
+	HW_VAR_AC_PARAM_VI,
+	HW_VAR_AC_PARAM_BE,
+	HW_VAR_AC_PARAM_BK,
+	HW_VAR_ACM_CTRL,
+	HW_VAR_AMPDU_MIN_SPACE,
+	HW_VAR_AMPDU_FACTOR,
+	HW_VAR_RXDMA_AGG_PG_TH,
+	HW_VAR_SET_RPWM,
+	HW_VAR_CPWM,
+	HW_VAR_H2C_FW_PWRMODE,
+	HW_VAR_H2C_PS_TUNE_PARAM,
+	HW_VAR_H2C_FW_JOINBSSRPT,
+	HW_VAR_FWLPS_RF_ON,
+	HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+	HW_VAR_TDLS_WRCR,
+	HW_VAR_TDLS_RS_RCR,
+	HW_VAR_TRIGGER_GPIO_0,
+	HW_VAR_BT_SET_COEXIST,
+	HW_VAR_BT_ISSUE_DELBA,
+	HW_VAR_CURRENT_ANTENNA,
+	HW_VAR_ANTENNA_DIVERSITY_SELECT,
+	HW_VAR_SWITCH_EPHY_WoWLAN,
+	HW_VAR_EFUSE_USAGE,
+	HW_VAR_EFUSE_BYTES,
+	HW_VAR_EFUSE_BT_USAGE,
+	HW_VAR_EFUSE_BT_BYTES,
+	HW_VAR_FIFO_CLEARN_UP,
+	HW_VAR_RESTORE_HW_SEQ,
+	HW_VAR_CHECK_TXBUF,
+	HW_VAR_PCIE_STOP_TX_DMA,
+	HW_VAR_APFM_ON_MAC, //Auto FSM to Turn On, include clock, isolation, power control for MAC only
+	HW_VAR_HCI_SUS_STATE,
+	// The valid upper nav range for the HW updating, if the true value is larger than the upper range, the HW won't update it.
+	// Unit in microsecond. 0 means disable this function.
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	HW_VAR_WOWLAN,
+	HW_VAR_WAKEUP_REASON,
+	HW_VAR_RPWM_TOG,
+#endif
+#ifdef CONFIG_GPIO_WAKEUP
+	HW_SET_GPIO_WL_CTRL,
+#endif
+	HW_VAR_SYS_CLKR,
+	HW_VAR_NAV_UPPER,
+	HW_VAR_C2H_HANDLE,
+	HW_VAR_RPT_TIMER_SETTING,
+	HW_VAR_TX_RPT_MAX_MACID,
+	HW_VAR_CHK_HI_QUEUE_EMPTY,
+	HW_VAR_DL_BCN_SEL,
+	HW_VAR_AMPDU_MAX_TIME,
+	HW_VAR_WIRELESS_MODE,
+	HW_VAR_USB_MODE,
+	HW_VAR_PORT_SWITCH,
+	HW_VAR_DO_IQK,
+	HW_VAR_DM_IN_LPS,
+	HW_VAR_SET_REQ_FW_PS,
+	HW_VAR_FW_PS_STATE,
+	HW_VAR_SOUNDING_ENTER,
+	HW_VAR_SOUNDING_LEAVE,
+	HW_VAR_SOUNDING_RATE,
+	HW_VAR_SOUNDING_STATUS,
+	HW_VAR_SOUNDING_FW_NDPA,
+	HW_VAR_SOUNDING_CLK,
+/*Add by YuChen for TXBF HW timer*/
+	HW_VAR_HW_REG_TIMER_INIT,
+	HW_VAR_HW_REG_TIMER_RESTART,
+	HW_VAR_HW_REG_TIMER_START,
+	HW_VAR_HW_REG_TIMER_STOP,
+/*Add by YuChen for TXBF HW timer*/
+	HW_VAR_DL_RSVD_PAGE,
+	HW_VAR_MACID_LINK,
+	HW_VAR_MACID_NOLINK,
+	HW_VAR_MACID_SLEEP,
+	HW_VAR_MACID_WAKEUP,
+	HW_VAR_DUMP_MAC_QUEUE_INFO,
+	HW_VAR_ASIX_IOT,
+}HW_VARIABLES;
+
+typedef enum _HAL_DEF_VARIABLE{
+	HAL_DEF_UNDERCORATEDSMOOTHEDPWDB,
+	HAL_DEF_IS_SUPPORT_ANT_DIV,
+	HAL_DEF_CURRENT_ANTENNA,
+	HAL_DEF_DRVINFO_SZ,
+	HAL_DEF_MAX_RECVBUF_SZ,
+	HAL_DEF_RX_PACKET_OFFSET,
+	HAL_DEF_RX_DMA_SZ_WOW,
+	HAL_DEF_RX_DMA_SZ,
+	HAL_DEF_RX_PAGE_SIZE,
+	HAL_DEF_DBG_DUMP_RXPKT,//for dbg
+	HAL_DEF_RA_DECISION_RATE,
+	HAL_DEF_RA_SGI,
+	HAL_DEF_PT_PWR_STATUS,
+	HAL_DEF_TX_LDPC, 				// LDPC support
+	HAL_DEF_RX_LDPC, 				// LDPC support
+	HAL_DEF_TX_STBC, 				// TX STBC support
+	HAL_DEF_RX_STBC, 				// RX STBC support
+	HAL_DEF_EXPLICIT_BEAMFORMER,// Explicit  Compressed Steering Capable
+	HAL_DEF_EXPLICIT_BEAMFORMEE,// Explicit Compressed Beamforming Feedback Capable
+	HAL_DEF_BEAMFORMER_CAP,
+	HAL_DEF_BEAMFORMEE_CAP,
+	HW_VAR_MAX_RX_AMPDU_FACTOR,
+	HW_DEF_RA_INFO_DUMP,
+	HAL_DEF_DBG_DUMP_TXPKT,
+
+	HAL_DEF_TX_PAGE_SIZE,
+	HAL_DEF_TX_PAGE_BOUNDARY,
+	HAL_DEF_TX_PAGE_BOUNDARY_WOWLAN,
+	HAL_DEF_ANT_DETECT,//to do for 8723a
+	HAL_DEF_PCI_SUUPORT_L1_BACKDOOR, // Determine if the L1 Backdoor setting is turned on.
+	HAL_DEF_PCI_AMD_L1_SUPPORT,
+	HAL_DEF_PCI_ASPM_OSC, // Support for ASPM OSC, added by Roger, 2013.03.27.
+	HAL_DEF_MACID_SLEEP, // Support for MACID sleep
+	HAL_DEF_DBG_DIS_PWT, //disable Tx power training or not.
+	HAL_DEF_EFUSE_USAGE,	/* Get current EFUSE utilization. 2008.12.19. Added by Roger. */
+	HAL_DEF_EFUSE_BYTES,
+	HW_VAR_BEST_AMPDU_DENSITY,
+}HAL_DEF_VARIABLE;
+
+typedef enum _HAL_ODM_VARIABLE{
+	HAL_ODM_STA_INFO,
+	HAL_ODM_P2P_STATE,
+	HAL_ODM_WIFI_DISPLAY_STATE,
+	HAL_ODM_NOISE_MONITOR,
+	HAL_ODM_REGULATION,
+	HAL_ODM_INITIAL_GAIN,
+	HAL_ODM_FA_CNT_DUMP,
+	HAL_ODM_DBG_FLAG,
+	HAL_ODM_DBG_LEVEL,
+	HAL_ODM_RX_INFO_DUMP,
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	HAL_ODM_AUTO_CHNL_SEL,
+#endif
+}HAL_ODM_VARIABLE;
+
+typedef enum _HAL_INTF_PS_FUNC{
+	HAL_USB_SELECT_SUSPEND,
+	HAL_MAX_ID,
+}HAL_INTF_PS_FUNC;
+
+typedef s32 (*c2h_id_filter)(u8 *c2h_evt);
+
+struct hal_ops {
+	/*** initialize section ***/
+	void	(*read_chip_version)(_adapter *padapter);
+	void	(*init_default_value)(_adapter *padapter);
+	void	(*intf_chip_configure)(_adapter *padapter);
+	void	(*read_adapter_info)(_adapter *padapter);
+	u32	(*hal_power_on)(_adapter *padapter);
+	void	(*hal_power_off)(_adapter *padapter);
+	u32	(*hal_init)(_adapter *padapter);
+	u32	(*hal_deinit)(_adapter *padapter);
+	void	(*dm_init)(_adapter *padapter);
+	void	(*dm_deinit)(_adapter *padapter);
+
+	/*** xmit section ***/
+	s32	(*init_xmit_priv)(_adapter *padapter);
+	void	(*free_xmit_priv)(_adapter *padapter);
+	s32	(*hal_xmit)(_adapter *padapter, struct xmit_frame *pxmitframe);
+	/*
+	 * mgnt_xmit should be implemented to run in interrupt context
+	 */
+	s32 (*mgnt_xmit)(_adapter *padapter, struct xmit_frame *pmgntframe);
+	s32	(*hal_xmitframe_enqueue)(_adapter *padapter, struct xmit_frame *pxmitframe);
+#ifdef CONFIG_XMIT_THREAD_MODE
+	s32 (*xmit_thread_handler)(_adapter *padapter);
+#endif
+	void	(*run_thread)(_adapter *padapter);
+	void	(*cancel_thread)(_adapter *padapter);
+
+	/*** recv section ***/
+	s32	(*init_recv_priv)(_adapter *padapter);
+	void	(*free_recv_priv)(_adapter *padapter);
+#if defined(CONFIG_USB_HCI)||defined(CONFIG_PCI_HCI)
+	u32	(*inirp_init)(_adapter *padapter);
+	u32	(*inirp_deinit)(_adapter *padapter);
+#endif
+	/*** interrupt hdl section ***/
+	void	(*enable_interrupt)(_adapter *padapter);
+	void	(*disable_interrupt)(_adapter *padapter);
+	u8	(*check_ips_status)(_adapter *padapter);
+#if defined(CONFIG_PCI_HCI)
+	s32	(*interrupt_handler)(_adapter *padapter);
+#endif
+
+#if defined(CONFIG_USB_HCI) && defined(CONFIG_SUPPORT_USB_INT)
+	void	(*interrupt_handler)(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+
+#if defined(CONFIG_PCI_HCI)
+	void	(*irp_reset)(_adapter *padapter);
+#endif
+
+	/*** DM section ***/
+
+	void	(*InitSwLeds)(_adapter *padapter);
+	void	(*DeInitSwLeds)(_adapter *padapter);
+
+
+	void	(*set_bwmode_handler)(_adapter *padapter, CHANNEL_WIDTH Bandwidth, u8 Offset);
+	void	(*set_channel_handler)(_adapter *padapter, u8 channel);
+	void	(*set_chnl_bw_handler)(_adapter *padapter, u8 channel, CHANNEL_WIDTH Bandwidth, u8 Offset40, u8 Offset80);
+
+	void	(*set_tx_power_level_handler)(_adapter *padapter, u8 channel);
+	void	(*get_tx_power_level_handler)(_adapter *padapter, s32 *powerlevel);
+
+	void	(*hal_dm_watchdog)(_adapter *padapter);
+#ifdef CONFIG_LPS_LCLK_WD_TIMER
+	void	(*hal_dm_watchdog_in_lps)(_adapter *padapter);
+#endif
+
+	void	(*SetHwRegHandler)(_adapter *padapter, u8	variable,u8* val);
+	void	(*GetHwRegHandler)(_adapter *padapter, u8	variable,u8* val);
+
+#ifdef CONFIG_C2H_PACKET_EN
+	void	(*SetHwRegHandlerWithBuf)(_adapter *padapter, u8 variable, u8 * pbuf, int len);
+#endif
+
+	u8	(*GetHalDefVarHandler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
+	u8	(*SetHalDefVarHandler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
+
+	void	(*GetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,PVOID pValue2);
+	void	(*SetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet);
+
+	void	(*UpdateRAMaskHandler)(_adapter *padapter, u32 mac_id, u8 rssi_level);
+	void	(*SetBeaconRelatedRegistersHandler)(_adapter *padapter);
+
+	void	(*Add_RateATid)(_adapter *padapter, u64 bitmap, u8 *arg, u8 rssi_level);
+
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	u8	(*AntDivBeforeLinkHandler)(_adapter *padapter);
+	void	(*AntDivCompareHandler)(_adapter *padapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+#endif
+	u8	(*interface_ps_func)(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id, u8* val);
+
+
+	u32	(*read_bbreg)(_adapter *padapter, u32 RegAddr, u32 BitMask);
+	void	(*write_bbreg)(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
+	u32	(*read_rfreg)(_adapter *padapter, u8 eRFPath, u32 RegAddr, u32 BitMask);
+	void	(*write_rfreg)(_adapter *padapter, u8 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+#ifdef CONFIG_HOSTAPD_MLME
+	s32	(*hostap_mgnt_xmit_entry)(_adapter *padapter, _pkt *pkt);
+#endif
+
+	void (*EfusePowerSwitch)(_adapter *padapter, u8 bWrite, u8 PwrState);
+	void (*BTEfusePowerSwitch)(_adapter *padapter, u8 bWrite, u8 PwrState);
+	void (*ReadEFuse)(_adapter *padapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf, BOOLEAN bPseudoTest);
+	void (*EFUSEGetEfuseDefinition)(_adapter *padapter, u8 efuseType, u8 type, void *pOut, BOOLEAN bPseudoTest);
+	u16	(*EfuseGetCurrentSize)(_adapter *padapter, u8 efuseType, BOOLEAN bPseudoTest);
+	int 	(*Efuse_PgPacketRead)(_adapter *padapter, u8 offset, u8 *data, BOOLEAN bPseudoTest);
+	int 	(*Efuse_PgPacketWrite)(_adapter *padapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
+	u8	(*Efuse_WordEnableDataWrite)(_adapter *padapter, u16 efuse_addr, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
+	BOOLEAN	(*Efuse_PgPacketWrite_BT)(_adapter *padapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	void (*sreset_init_value)(_adapter *padapter);
+	void (*sreset_reset_value)(_adapter *padapter);
+	void (*silentreset)(_adapter *padapter);
+	void (*sreset_xmit_status_check)(_adapter *padapter);
+	void (*sreset_linked_status_check) (_adapter *padapter);
+	u8 (*sreset_get_wifi_status)(_adapter *padapter);
+	bool (*sreset_inprogress)(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_IOL
+	int (*IOL_exec_cmds_sync)(_adapter *padapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
+#endif
+
+	void (*hal_notch_filter)(_adapter * adapter, bool enable);
+	s32 (*c2h_handler)(_adapter *padapter, u8 *c2h_evt);
+	c2h_id_filter c2h_id_filter_ccx;
+	s32 (*fill_h2c_cmd)(PADAPTER, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+	void (*fill_fake_txdesc)(PADAPTER, u8 *pDesc, u32 BufferLen,
+			u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+	s32 (*fw_dl)(_adapter *adapter, u8 wowlan);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	void (*clear_interrupt)(_adapter *padapter);
+#endif
+	u8 (*hal_get_tx_buff_rsvd_page_num)(_adapter *adapter, bool wowlan);
+#ifdef CONFIG_GPIO_API
+	void (*update_hisr_hsisr_ind)(PADAPTER padapter, u32 flag);
+#endif
+	void (*fw_correct_bcn)(PADAPTER padapter);
+};
+
+typedef	enum _RT_EEPROM_TYPE{
+	EEPROM_93C46,
+	EEPROM_93C56,
+	EEPROM_BOOT_EFUSE,
+}RT_EEPROM_TYPE,*PRT_EEPROM_TYPE;
+
+
+
+#define RF_CHANGE_BY_INIT	0
+#define RF_CHANGE_BY_IPS 	BIT28
+#define RF_CHANGE_BY_PS 	BIT29
+#define RF_CHANGE_BY_HW 	BIT30
+#define RF_CHANGE_BY_SW 	BIT31
+
+typedef enum _HARDWARE_TYPE{
+	HARDWARE_TYPE_RTL8188EE,
+	HARDWARE_TYPE_RTL8188EU,
+	HARDWARE_TYPE_RTL8188ES,
+//	NEW_GENERATION_IC
+	HARDWARE_TYPE_RTL8192EE,
+	HARDWARE_TYPE_RTL8192EU,
+	HARDWARE_TYPE_RTL8192ES,
+	HARDWARE_TYPE_RTL8812E,
+	HARDWARE_TYPE_RTL8812AU,
+	HARDWARE_TYPE_RTL8811AU,
+	HARDWARE_TYPE_RTL8821E,
+	HARDWARE_TYPE_RTL8821U,
+	HARDWARE_TYPE_RTL8821S,
+	HARDWARE_TYPE_RTL8723BE,
+	HARDWARE_TYPE_RTL8723BU,
+	HARDWARE_TYPE_RTL8723BS,
+	HARDWARE_TYPE_RTL8814AE,
+	HARDWARE_TYPE_RTL8814AU,
+	HARDWARE_TYPE_RTL8814AS,
+	HARDWARE_TYPE_RTL8821BE,
+	HARDWARE_TYPE_RTL8821BU,
+	HARDWARE_TYPE_RTL8821BS,
+	HARDWARE_TYPE_RTL8822BE,
+	HARDWARE_TYPE_RTL8822BU,
+	HARDWARE_TYPE_RTL8822BS,
+	HARDWARE_TYPE_RTL8703BE,
+	HARDWARE_TYPE_RTL8703BU,
+	HARDWARE_TYPE_RTL8703BS,
+	HARDWARE_TYPE_RTL8188FE,
+	HARDWARE_TYPE_RTL8188FU,
+	HARDWARE_TYPE_RTL8188FS,
+	HARDWARE_TYPE_MAX,
+}HARDWARE_TYPE;
+
+#define IS_NEW_GENERATION_IC(_Adapter)	(rtw_get_hw_type(_Adapter) >= HARDWARE_TYPE_RTL8192EE)
+//
+// RTL8188E Series
+//
+#define IS_HARDWARE_TYPE_8188EE(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188EE)
+#define IS_HARDWARE_TYPE_8188EU(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188EU)
+#define IS_HARDWARE_TYPE_8188ES(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188ES)
+#define	IS_HARDWARE_TYPE_8188E(_Adapter)	\
+(IS_HARDWARE_TYPE_8188EE(_Adapter) || IS_HARDWARE_TYPE_8188EU(_Adapter) || IS_HARDWARE_TYPE_8188ES(_Adapter))
+
+// RTL8812 Series
+#define IS_HARDWARE_TYPE_8812E(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8812E)
+#define IS_HARDWARE_TYPE_8812AU(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8812AU)
+#define IS_HARDWARE_TYPE_8812(_Adapter)			\
+(IS_HARDWARE_TYPE_8812E(_Adapter) || IS_HARDWARE_TYPE_8812AU(_Adapter))
+
+// RTL8821 Series
+#define IS_HARDWARE_TYPE_8821E(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821E)
+#define IS_HARDWARE_TYPE_8811AU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8811AU)
+#define IS_HARDWARE_TYPE_8821U(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821U ||	\
+													rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8811AU)
+#define IS_HARDWARE_TYPE_8821S(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821S)
+#define IS_HARDWARE_TYPE_8821(_Adapter)			\
+(IS_HARDWARE_TYPE_8821E(_Adapter) || IS_HARDWARE_TYPE_8821U(_Adapter)|| IS_HARDWARE_TYPE_8821S(_Adapter))
+
+#define IS_HARDWARE_TYPE_JAGUAR(_Adapter)		\
+(IS_HARDWARE_TYPE_8812(_Adapter) || IS_HARDWARE_TYPE_8821(_Adapter))
+
+//RTL8192E Series
+#define IS_HARDWARE_TYPE_8192EE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192EE)
+#define IS_HARDWARE_TYPE_8192EU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192EU)
+#define IS_HARDWARE_TYPE_8192ES(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8192ES)
+
+#define IS_HARDWARE_TYPE_8192E(_Adapter)		\
+(IS_HARDWARE_TYPE_8192EE(_Adapter) || IS_HARDWARE_TYPE_8192EU(_Adapter) ||IS_HARDWARE_TYPE_8192ES(_Adapter))
+
+#define IS_HARDWARE_TYPE_8723BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723BE)
+#define IS_HARDWARE_TYPE_8723BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723BU)
+#define IS_HARDWARE_TYPE_8723BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8723BS)
+
+#define IS_HARDWARE_TYPE_8723B(_Adapter) \
+	(IS_HARDWARE_TYPE_8723BE(_Adapter) || IS_HARDWARE_TYPE_8723BU(_Adapter) ||IS_HARDWARE_TYPE_8723BS(_Adapter))
+
+/* RTL8814A Series */
+#define IS_HARDWARE_TYPE_8814AE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814AE)
+#define IS_HARDWARE_TYPE_8814AU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814AU)
+#define IS_HARDWARE_TYPE_8814AS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8814AS)
+
+#define IS_HARDWARE_TYPE_8814A(_Adapter)		\
+(IS_HARDWARE_TYPE_8814AE(_Adapter) || IS_HARDWARE_TYPE_8814AU(_Adapter) || IS_HARDWARE_TYPE_8814AS(_Adapter))
+
+#define IS_HARDWARE_TYPE_JAGUAR2(_Adapter)		\
+(IS_HARDWARE_TYPE_8814A(_Adapter) || IS_HARDWARE_TYPE_8821B(_Adapter) || IS_HARDWARE_TYPE_8822B(_Adapter))
+
+#define IS_HARDWARE_TYPE_JAGUAR_AND_JAGUAR2(_Adapter)		\
+(IS_HARDWARE_TYPE_JAGUAR(_Adapter) || IS_HARDWARE_TYPE_JAGUAR2(_Adapter))
+
+/* RTL8703B Series */
+#define IS_HARDWARE_TYPE_8703BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8703BE)
+#define IS_HARDWARE_TYPE_8703BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8703BS)
+#define IS_HARDWARE_TYPE_8703BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8703BU)
+#define	IS_HARDWARE_TYPE_8703B(_Adapter)			\
+(IS_HARDWARE_TYPE_8703BE(_Adapter) || IS_HARDWARE_TYPE_8703BU(_Adapter) || IS_HARDWARE_TYPE_8703BS(_Adapter))
+
+/* RTL8188F Series */
+#define IS_HARDWARE_TYPE_8188FE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188FE)
+#define IS_HARDWARE_TYPE_8188FS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188FS)
+#define IS_HARDWARE_TYPE_8188FU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188FU)
+#define	IS_HARDWARE_TYPE_8188F(_Adapter)			\
+(IS_HARDWARE_TYPE_8188FE(_Adapter) || IS_HARDWARE_TYPE_8188FU(_Adapter) || IS_HARDWARE_TYPE_8188FS(_Adapter))
+
+#define IS_HARDWARE_TYPE_8821BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821BE)
+#define IS_HARDWARE_TYPE_8821BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821BU)
+#define IS_HARDWARE_TYPE_8821BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8821BS)
+
+#define IS_HARDWARE_TYPE_8821B(_Adapter)		\
+(IS_HARDWARE_TYPE_8821BE(_Adapter) || IS_HARDWARE_TYPE_8821BU(_Adapter) || IS_HARDWARE_TYPE_8821BS(_Adapter))
+
+#define IS_HARDWARE_TYPE_8822BE(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822BE)
+#define IS_HARDWARE_TYPE_8822BU(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822BU)
+#define IS_HARDWARE_TYPE_8822BS(_Adapter)		(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8822BS)
+#define IS_HARDWARE_TYPE_8822B(_Adapter)		\
+(IS_HARDWARE_TYPE_8822BE(_Adapter) || IS_HARDWARE_TYPE_8822BU(_Adapter) || IS_HARDWARE_TYPE_8822BS(_Adapter))
+
+
+
+typedef enum _wowlan_subcode {
+	WOWLAN_ENABLE			= 0,
+	WOWLAN_DISABLE			= 1,
+	WOWLAN_AP_ENABLE		= 2,
+	WOWLAN_AP_DISABLE		= 3,
+	WOWLAN_PATTERN_CLEAN		= 4
+} wowlan_subcode;
+
+struct wowlan_ioctl_param{
+	unsigned int subcode;
+	unsigned int subcode_value;
+	unsigned int wakeup_reason;
+};
+
+#define Rx_Pairwisekey			0x01
+#define Rx_GTK					0x02
+#define Rx_DisAssoc				0x04
+#define Rx_DeAuth				0x08
+#define Rx_ARPReq				0x09
+#define FWDecisionDisconnect	0x10
+#define Rx_MagicPkt				0x21
+#define Rx_UnicastPkt			0x22
+#define Rx_PatternPkt			0x23
+#define	RX_PNOWakeUp			0x55
+#define	AP_WakeUp			0x66
+
+u8 rtw_hal_data_init(_adapter *padapter);
+void rtw_hal_data_deinit(_adapter *padapter);
+
+void rtw_hal_def_value_init(_adapter *padapter);
+
+void	rtw_hal_free_data(_adapter *padapter);
+
+void rtw_hal_dm_init(_adapter *padapter);
+void rtw_hal_dm_deinit(_adapter *padapter);
+void rtw_hal_sw_led_init(_adapter *padapter);
+void rtw_hal_sw_led_deinit(_adapter *padapter);
+
+u32 rtw_hal_power_on(_adapter *padapter);
+void rtw_hal_power_off(_adapter *padapter);
+
+uint rtw_hal_init(_adapter *padapter);
+uint rtw_hal_deinit(_adapter *padapter);
+void rtw_hal_stop(_adapter *padapter);
+void rtw_hal_set_hwreg(PADAPTER padapter, u8 variable, u8 *val);
+void rtw_hal_get_hwreg(PADAPTER padapter, u8 variable, u8 *val);
+
+#ifdef CONFIG_C2H_PACKET_EN
+void rtw_hal_set_hwreg_with_buf(_adapter *padapter, u8 variable, u8 *pbuf, int len);
+#endif
+
+void rtw_hal_chip_configure(_adapter *padapter);
+void rtw_hal_read_chip_info(_adapter *padapter);
+void rtw_hal_read_chip_version(_adapter *padapter);
+
+u8 rtw_hal_set_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
+u8 rtw_hal_get_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
+
+void rtw_hal_set_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet);
+void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,PVOID pValue2);
+
+void rtw_hal_enable_interrupt(_adapter *padapter);
+void rtw_hal_disable_interrupt(_adapter *padapter);
+
+u8 rtw_hal_check_ips_status(_adapter *padapter);
+
+#if defined(CONFIG_USB_HCI)||defined(CONFIG_PCI_HCI)
+u32	rtw_hal_inirp_init(_adapter *padapter);
+u32	rtw_hal_inirp_deinit(_adapter *padapter);
+#endif
+
+#if defined(CONFIG_PCI_HCI)
+void	rtw_hal_irp_reset(_adapter *padapter);
+#endif
+
+u8	rtw_hal_intf_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id, u8* val);
+
+s32	rtw_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32	rtw_hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe);
+
+s32	rtw_hal_init_xmit_priv(_adapter *padapter);
+void	rtw_hal_free_xmit_priv(_adapter *padapter);
+
+s32	rtw_hal_init_recv_priv(_adapter *padapter);
+void	rtw_hal_free_recv_priv(_adapter *padapter);
+
+void rtw_hal_update_ra_mask(struct sta_info *psta, u8 rssi_level);
+void	rtw_hal_add_ra_tid(_adapter *padapter, u64 bitmap, u8 *arg, u8 rssi_level);
+
+void	rtw_hal_start_thread(_adapter *padapter);
+void	rtw_hal_stop_thread(_adapter *padapter);
+
+void rtw_hal_bcn_related_reg_setting(_adapter *padapter);
+
+u32	rtw_hal_read_bbreg(_adapter *padapter, u32 RegAddr, u32 BitMask);
+void	rtw_hal_write_bbreg(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
+u32	rtw_hal_read_rfreg(_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask);
+void	rtw_hal_write_rfreg(_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+#define PHY_QueryBBReg(Adapter, RegAddr, BitMask) rtw_hal_read_bbreg((Adapter), (RegAddr), (BitMask))
+#define PHY_SetBBReg(Adapter, RegAddr, BitMask, Data) rtw_hal_write_bbreg((Adapter), (RegAddr), (BitMask), (Data))
+#define PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask) rtw_hal_read_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask))
+#define PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data) rtw_hal_write_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask), (Data))
+
+#define PHY_SetMacReg	PHY_SetBBReg
+#define PHY_QueryMacReg PHY_QueryBBReg
+
+#if defined(CONFIG_PCI_HCI)
+s32	rtw_hal_interrupt_handler(_adapter *padapter);
+#endif
+#if  defined(CONFIG_USB_HCI) && defined(CONFIG_SUPPORT_USB_INT)
+void	rtw_hal_interrupt_handler(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+
+void	rtw_hal_set_bwmode(_adapter *padapter, CHANNEL_WIDTH Bandwidth, u8 Offset);
+void	rtw_hal_set_chan(_adapter *padapter, u8 channel);
+void	rtw_hal_set_chnl_bw(_adapter *padapter, u8 channel, CHANNEL_WIDTH Bandwidth, u8 Offset40, u8 Offset80);
+void	rtw_hal_dm_watchdog(_adapter *padapter);
+void	rtw_hal_dm_watchdog_in_lps(_adapter *padapter);
+
+void	rtw_hal_set_tx_power_level(_adapter *padapter, u8 channel);
+void	rtw_hal_get_tx_power_level(_adapter *padapter, s32 *powerlevel);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+u8	rtw_hal_antdiv_before_linked(_adapter *padapter);
+void	rtw_hal_antdiv_rssi_compared(_adapter *padapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+#endif
+
+#ifdef CONFIG_HOSTAPD_MLME
+s32	rtw_hal_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt);
+#endif
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+void rtw_hal_sreset_init(_adapter *padapter);
+void rtw_hal_sreset_reset(_adapter *padapter);
+void rtw_hal_sreset_reset_value(_adapter *padapter);
+void rtw_hal_sreset_xmit_status_check(_adapter *padapter);
+void rtw_hal_sreset_linked_status_check (_adapter *padapter);
+u8   rtw_hal_sreset_get_wifi_status(_adapter *padapter);
+bool rtw_hal_sreset_inprogress(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_IOL
+int rtw_hal_iol_cmd(ADAPTER *adapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
+#endif
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+s32 rtw_hal_xmit_thread_handler(_adapter *padapter);
+#endif
+
+void rtw_hal_notch_filter(_adapter * adapter, bool enable);
+
+bool rtw_hal_c2h_valid(_adapter *adapter, u8 *buf);
+s32 rtw_hal_c2h_evt_read(_adapter *adapter, u8 *buf);
+s32 rtw_hal_c2h_handler(_adapter *adapter, u8 *c2h_evt);
+c2h_id_filter rtw_hal_c2h_id_filter_ccx(_adapter *adapter);
+
+s32 rtw_hal_is_disable_sw_channel_plan(PADAPTER padapter);
+
+s32 rtw_hal_macid_sleep(PADAPTER padapter, u8 macid);
+s32 rtw_hal_macid_wakeup(PADAPTER padapter, u8 macid);
+
+s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+void rtw_hal_fill_fake_txdesc(_adapter *padapter, u8 *pDesc, u32 BufferLen,
+		u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+u8 rtw_hal_get_txbuff_rsvd_page_num(_adapter *adapter, bool wowlan);
+
+#ifdef CONFIG_GPIO_API
+void rtw_hal_update_hisr_hsisr_ind(_adapter *padapter, u32 flag);
+#endif
+
+void rtw_hal_fw_correct_bcn(_adapter *padapter);
+s32 rtw_hal_fw_dl(_adapter *padapter, u8 wowlan);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void rtw_hal_clear_interrupt(_adapter *padapter);
+#endif
+u8 rtw_hal_ops_check(_adapter *padapter);
+
+#endif //__HAL_INTF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_pg.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_pg.h
new file mode 100644
index 000000000..8bb5daff6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_pg.h
@@ -0,0 +1,629 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL_PG_H__
+#define __HAL_PG_H__
+
+#define PPG_BB_GAIN_2G_TX_OFFSET_MASK	0x0F
+#define PPG_BB_GAIN_2G_TXB_OFFSET_MASK	0xF0
+
+#define PPG_BB_GAIN_5G_TX_OFFSET_MASK	0x1F
+#define PPG_THERMAL_OFFSET_MASK			0x1F
+#define KFREE_BB_GAIN_2G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_2G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
+#define KFREE_BB_GAIN_5G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_5G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
+#define KFREE_THERMAL_OFFSET(_ppg_v) (((_ppg_v) == PPG_THERMAL_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 88EE/88EU/88ES
+//====================================================
+#define EEPROM_TX_PWR_INX_88E					0x10
+
+#define EEPROM_ChannelPlan_88E					0xB8
+#define EEPROM_XTAL_88E						0xB9
+#define EEPROM_THERMAL_METER_88E				0xBA
+#define EEPROM_IQK_LCK_88E						0xBB
+
+#define EEPROM_RF_BOARD_OPTION_88E			0xC1
+#define EEPROM_RF_FEATURE_OPTION_88E			0xC2
+#define EEPROM_RF_BT_SETTING_88E				0xC3
+#define EEPROM_VERSION_88E						0xC4
+#define EEPROM_CustomID_88E					0xC5
+#define EEPROM_RF_ANTENNA_OPT_88E			0xC9
+
+// RTL88EE
+#define EEPROM_MAC_ADDR_88EE					0xD0
+#define EEPROM_VID_88EE						0xD6
+#define EEPROM_DID_88EE						0xD8
+#define EEPROM_SVID_88EE						0xDA
+#define EEPROM_SMID_88EE						0xDC
+
+//RTL88EU
+#define EEPROM_MAC_ADDR_88EU					0xD7
+#define EEPROM_VID_88EU						0xD0
+#define EEPROM_PID_88EU						0xD2
+#define EEPROM_USB_OPTIONAL_FUNCTION0		0xD4 //8188EU,8192EU, 8812AU is the same
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8811AU 0x104
+
+// RTL88ES
+#define EEPROM_MAC_ADDR_88ES					0x11A
+//====================================================
+//			EEPROM/Efuse PG Offset for 8192EE/8192EU/8192ES
+//====================================================
+#define GET_PG_KFREE_ON_8192E(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8192E(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8192E	0x1F6
+#define PPG_THERMAL_OFFSET_8192E		0x1F5
+
+// 0x10 ~ 0x63 = TX power area.
+#define	EEPROM_TX_PWR_INX_8192E				0x10
+
+#define	EEPROM_ChannelPlan_8192E				0xB8
+#define	EEPROM_XTAL_8192E						0xB9
+#define	EEPROM_THERMAL_METER_8192E			0xBA
+#define	EEPROM_IQK_LCK_8192E					0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8192E			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8192E	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8192E	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8192E		0xC1
+#define	EEPROM_RF_FEATURE_OPTION_8192E		0xC2
+#define	EEPROM_RF_BT_SETTING_8192E			0xC3
+#define	EEPROM_VERSION_8192E					0xC4
+#define	EEPROM_CustomID_8192E				0xC5
+#define	EEPROM_TX_BBSWING_2G_8192E			0xC6
+#define	EEPROM_TX_BBSWING_5G_8192E			0xC7
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8192E	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8192E			0xC9
+#define	EEPROM_RFE_OPTION_8192E				0xCA
+
+// RTL8192EE
+#define	EEPROM_MAC_ADDR_8192EE				0xD0
+#define	EEPROM_VID_8192EE						0xD6
+#define	EEPROM_DID_8192EE						0xD8
+#define	EEPROM_SVID_8192EE					0xDA
+#define	EEPROM_SMID_8192EE					0xDC
+
+//RTL8192EU
+#define	EEPROM_MAC_ADDR_8192EU				0xD7
+#define	EEPROM_VID_8192EU						0xD0
+#define	EEPROM_PID_8192EU						0xD2
+#define 	EEPROM_PA_TYPE_8192EU               		0xBC
+#define 	EEPROM_LNA_TYPE_2G_8192EU           	0xBD
+#define 	EEPROM_LNA_TYPE_5G_8192EU           	0xBF
+
+// RTL8192ES
+#define	EEPROM_MAC_ADDR_8192ES				0x11A
+//====================================================
+//			EEPROM/Efuse PG Offset for 8812AE/8812AU/8812AS
+//====================================================
+// 0x10 ~ 0x63 = TX power area.
+#define EEPROM_USB_MODE_8812					0x08
+#define EEPROM_TX_PWR_INX_8812				0x10
+
+#define EEPROM_ChannelPlan_8812				0xB8
+#define EEPROM_XTAL_8812						0xB9
+#define EEPROM_THERMAL_METER_8812			0xBA
+#define EEPROM_IQK_LCK_8812					0xBB
+#define EEPROM_2G_5G_PA_TYPE_8812			0xBC
+#define EEPROM_2G_LNA_TYPE_GAIN_SEL_8812	0xBD
+#define EEPROM_5G_LNA_TYPE_GAIN_SEL_8812	0xBF
+
+#define EEPROM_RF_BOARD_OPTION_8812			0xC1
+#define EEPROM_RF_FEATURE_OPTION_8812		0xC2
+#define EEPROM_RF_BT_SETTING_8812				0xC3
+#define EEPROM_VERSION_8812					0xC4
+#define EEPROM_CustomID_8812					0xC5
+#define EEPROM_TX_BBSWING_2G_8812			0xC6
+#define EEPROM_TX_BBSWING_5G_8812			0xC7
+#define EEPROM_TX_PWR_CALIBRATE_RATE_8812	0xC8
+#define EEPROM_RF_ANTENNA_OPT_8812			0xC9
+#define EEPROM_RFE_OPTION_8812				0xCA
+
+// RTL8812AE
+#define EEPROM_MAC_ADDR_8812AE				0xD0
+#define EEPROM_VID_8812AE						0xD6
+#define EEPROM_DID_8812AE						0xD8
+#define EEPROM_SVID_8812AE						0xDA
+#define EEPROM_SMID_8812AE					0xDC
+
+//RTL8812AU
+#define EEPROM_MAC_ADDR_8812AU				0xD7
+#define EEPROM_VID_8812AU						0xD0
+#define EEPROM_PID_8812AU						0xD2
+#define EEPROM_PA_TYPE_8812AU					0xBC
+#define EEPROM_LNA_TYPE_2G_8812AU			0xBD
+#define EEPROM_LNA_TYPE_5G_8812AU			0xBF
+
+//RTL8814AU
+#define	EEPROM_MAC_ADDR_8814AU				0xD8
+#define	EEPROM_VID_8814AU						0xD0
+#define	EEPROM_PID_8814AU						0xD2
+#define	EEPROM_PA_TYPE_8814AU				0xBC
+#define	EEPROM_LNA_TYPE_2G_8814AU			0xBD
+#define	EEPROM_LNA_TYPE_5G_8814AU			0xBF
+
+/* RTL8814AE */
+#define EEPROM_MAC_ADDR_8814AE				0xD0
+#define EEPROM_VID_8814AE						0xD6
+#define EEPROM_DID_8814AE						0xD8
+#define EEPROM_SVID_8814AE						0xDA
+#define EEPROM_SMID_8814AE					0xDC
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 8814AU
+//====================================================
+#define GET_PG_KFREE_ON_8814A(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8814A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define KFREE_GAIN_DATA_LENGTH_8814A	22
+
+#define PPG_BB_GAIN_2G_TXBA_OFFSET_8814A	0x3EE
+
+#define PPG_THERMAL_OFFSET_8814A		0x3EF
+
+#define EEPROM_TX_PWR_INX_8814				0x10
+#define EEPROM_ChannelPlan_8814				0xB8
+#define EEPROM_XTAL_8814					0xB9
+#define EEPROM_THERMAL_METER_8814			0xBA
+#define	EEPROM_IQK_LCK_8814					0xBB
+
+
+#define EEPROM_PA_TYPE_8814					0xBC
+#define EEPROM_LNA_TYPE_AB_2G_8814			0xBD
+#define	EEPROM_LNA_TYPE_CD_2G_8814			0xBE
+#define EEPROM_LNA_TYPE_AB_5G_8814			0xBF
+#define EEPROM_LNA_TYPE_CD_5G_8814			0xC0
+#define	EEPROM_RF_BOARD_OPTION_8814			0xC1
+#define	EEPROM_RF_BT_SETTING_8814			0xC3
+#define	EEPROM_VERSION_8814					0xC4
+#define	EEPROM_CustomID_8814				0xC5
+#define	EEPROM_TX_BBSWING_2G_8814			0xC6
+#define	EEPROM_TX_BBSWING_5G_8814			0xC7
+#define EEPROM_TRX_ANTENNA_OPTION_8814		0xC9
+#define	EEPROM_RFE_OPTION_8814				0xCA
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 8821AE/8821AU/8821AS
+//====================================================
+
+#define GET_PG_KFREE_ON_8821A(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8821A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8821A		0x1F6
+#define PPG_THERMAL_OFFSET_8821A			0x1F5
+#define PPG_BB_GAIN_5GLB1_TXA_OFFSET_8821A	0x1F4
+#define PPG_BB_GAIN_5GLB2_TXA_OFFSET_8821A	0x1F3
+#define PPG_BB_GAIN_5GMB1_TXA_OFFSET_8821A	0x1F2
+#define PPG_BB_GAIN_5GMB2_TXA_OFFSET_8821A	0x1F1
+#define PPG_BB_GAIN_5GHB_TXA_OFFSET_8821A	0x1F0
+
+#define EEPROM_TX_PWR_INX_8821				0x10
+
+#define EEPROM_ChannelPlan_8821				0xB8
+#define EEPROM_XTAL_8821						0xB9
+#define EEPROM_THERMAL_METER_8821			0xBA
+#define EEPROM_IQK_LCK_8821					0xBB
+
+
+#define EEPROM_RF_BOARD_OPTION_8821			0xC1
+#define EEPROM_RF_FEATURE_OPTION_8821		0xC2
+#define EEPROM_RF_BT_SETTING_8821				0xC3
+#define EEPROM_VERSION_8821					0xC4
+#define EEPROM_CustomID_8821					0xC5
+#define EEPROM_RF_ANTENNA_OPT_8821			0xC9
+
+// RTL8821AE
+#define EEPROM_MAC_ADDR_8821AE				0xD0
+#define EEPROM_VID_8821AE						0xD6
+#define EEPROM_DID_8821AE						0xD8
+#define EEPROM_SVID_8821AE						0xDA
+#define EEPROM_SMID_8821AE					0xDC
+
+//RTL8821AU
+#define EEPROM_PA_TYPE_8821AU					0xBC
+#define EEPROM_LNA_TYPE_8821AU				0xBF
+
+// RTL8821AS
+#define EEPROM_MAC_ADDR_8821AS				0x11A
+
+//RTL8821AU
+#define EEPROM_MAC_ADDR_8821AU				0x107
+#define EEPROM_VID_8821AU						0x100
+#define EEPROM_PID_8821AU						0x102
+
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 8192 SE/SU
+//====================================================
+#define EEPROM_VID_92SE						0x0A
+#define EEPROM_DID_92SE						0x0C
+#define EEPROM_SVID_92SE						0x0E
+#define EEPROM_SMID_92SE						0x10
+
+#define EEPROM_MAC_ADDR_92S					0x12
+
+#define EEPROM_TSSI_A_92SE						0x74
+#define EEPROM_TSSI_B_92SE						0x75
+
+#define EEPROM_Version_92SE					0x7C
+
+
+#define EEPROM_VID_92SU						0x08
+#define EEPROM_PID_92SU						0x0A
+
+#define EEPROM_Version_92SU					0x50
+#define EEPROM_TSSI_A_92SU						0x6b
+#define EEPROM_TSSI_B_92SU						0x6c
+
+/* ====================================================
+	EEPROM/Efuse PG Offset for 8188FE/8188FU/8188FS
+   ====================================================
+ */
+
+#define GET_PG_KFREE_ON_8188F(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8188F(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8188F	0xEE
+#define PPG_THERMAL_OFFSET_8188F		0xEF
+
+/* 0x10 ~ 0x63 = TX power area. */
+#define	EEPROM_TX_PWR_INX_8188F				0x10
+
+#define	EEPROM_ChannelPlan_8188F			0xB8
+#define	EEPROM_XTAL_8188F					0xB9
+#define	EEPROM_THERMAL_METER_8188F			0xBA
+#define	EEPROM_IQK_LCK_8188F				0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8188F			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8188F	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8188F	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8188F		0xC1
+#define	EEPROM_FEATURE_OPTION_8188F			0xC2
+#define	EEPROM_RF_BT_SETTING_8188F			0xC3
+#define	EEPROM_VERSION_8188F				0xC4
+#define	EEPROM_CustomID_8188F				0xC5
+#define	EEPROM_TX_BBSWING_2G_8188F			0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8188F	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8188F			0xC9
+#define	EEPROM_RFE_OPTION_8188F				0xCA
+#define EEPROM_CUSTOMER_ID_8188F			0x7F
+#define EEPROM_SUBCUSTOMER_ID_8188F			0x59
+
+/* RTL8188FU */
+#define EEPROM_MAC_ADDR_8188FU				0xD7
+#define EEPROM_VID_8188FU					0xD0
+#define EEPROM_PID_8188FU					0xD2
+#define EEPROM_PA_TYPE_8188FU				0xBC
+#define EEPROM_LNA_TYPE_2G_8188FU			0xBD
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8188FU 0xD4
+
+/* RTL8188FS */
+#define	EEPROM_MAC_ADDR_8188FS				0x11A
+#define EEPROM_Voltage_ADDR_8188F			0x8
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 8723BE/8723BU/8723BS
+//====================================================
+// 0x10 ~ 0x63 = TX power area.
+#define	EEPROM_TX_PWR_INX_8723B				0x10
+
+#define	EEPROM_ChannelPlan_8723B				0xB8
+#define	EEPROM_XTAL_8723B						0xB9
+#define	EEPROM_THERMAL_METER_8723B			0xBA
+#define	EEPROM_IQK_LCK_8723B					0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8723B			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8723B	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8723B	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8723B		0xC1
+#define	EEPROM_FEATURE_OPTION_8723B			0xC2
+#define	EEPROM_RF_BT_SETTING_8723B			0xC3
+#define	EEPROM_VERSION_8723B					0xC4
+#define	EEPROM_CustomID_8723B				0xC5
+#define	EEPROM_TX_BBSWING_2G_8723B			0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8723B	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8723B		0xC9
+#define	EEPROM_RFE_OPTION_8723B				0xCA
+
+// RTL8723BE
+#define EEPROM_MAC_ADDR_8723BE				0xD0
+#define EEPROM_VID_8723BE						0xD6
+#define EEPROM_DID_8723BE						0xD8
+#define EEPROM_SVID_8723BE						0xDA
+#define EEPROM_SMID_8723BE						0xDC
+
+//RTL8723BU
+#define EEPROM_MAC_ADDR_8723BU				0x107
+#define EEPROM_VID_8723BU						0x100
+#define EEPROM_PID_8723BU						0x102
+#define EEPROM_PA_TYPE_8723BU					0xBC
+#define EEPROM_LNA_TYPE_2G_8723BU				0xBD
+
+
+//RTL8723BS
+#define	EEPROM_MAC_ADDR_8723BS				0x11A
+#define EEPROM_Voltage_ADDR_8723B			0x8
+
+//====================================================
+/*			EEPROM/Efuse PG Offset for 8703B		*/
+//====================================================
+#define GET_PG_KFREE_ON_8703B(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8703B(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8703B	0xEE
+#define PPG_THERMAL_OFFSET_8703B		0xEF
+
+#define	EEPROM_TX_PWR_INX_8703B				0x10
+
+#define	EEPROM_ChannelPlan_8703B				0xB8
+#define	EEPROM_XTAL_8703B					0xB9
+#define	EEPROM_THERMAL_METER_8703B			0xBA
+#define	EEPROM_IQK_LCK_8703B					0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8703B			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8703B	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8703B	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8703B		0xC1
+#define	EEPROM_FEATURE_OPTION_8703B			0xC2
+#define	EEPROM_RF_BT_SETTING_8703B			0xC3
+#define	EEPROM_VERSION_8703B					0xC4
+#define	EEPROM_CustomID_8703B					0xC5
+#define	EEPROM_TX_BBSWING_2G_8703B			0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8703B	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8703B		0xC9
+#define	EEPROM_RFE_OPTION_8703B				0xCA
+
+/* RTL8703BU */
+#define EEPROM_MAC_ADDR_8703BU                          0x107
+#define EEPROM_VID_8703BU                               0x100
+#define EEPROM_PID_8703BU                               0x102
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8703BU            0x104
+#define EEPROM_PA_TYPE_8703BU                           0xBC
+#define EEPROM_LNA_TYPE_2G_8703BU                       0xBD
+
+//RTL8703BS
+#define	EEPROM_MAC_ADDR_8703BS				0x11A
+#define 	EEPROM_Voltage_ADDR_8703B			0x8
+
+//====================================================
+//			EEPROM/Efuse Value Type
+//====================================================
+#define EETYPE_TX_PWR							0x0
+//====================================================
+//			EEPROM/Efuse Default Value
+//====================================================
+#define EEPROM_CID_DEFAULT					0x0
+#define EEPROM_CID_DEFAULT_EXT				0xFF // Reserved for Realtek
+#define EEPROM_CID_TOSHIBA						0x4
+#define EEPROM_CID_CCX							0x10
+#define EEPROM_CID_QMI							0x0D
+#define EEPROM_CID_WHQL 						0xFE
+
+#define EEPROM_CHANNEL_PLAN_FCC				0x0
+#define EEPROM_CHANNEL_PLAN_IC				0x1
+#define EEPROM_CHANNEL_PLAN_ETSI				0x2
+#define EEPROM_CHANNEL_PLAN_SPAIN			0x3
+#define EEPROM_CHANNEL_PLAN_FRANCE			0x4
+#define EEPROM_CHANNEL_PLAN_MKK				0x5
+#define EEPROM_CHANNEL_PLAN_MKK1				0x6
+#define EEPROM_CHANNEL_PLAN_ISRAEL			0x7
+#define EEPROM_CHANNEL_PLAN_TELEC			0x8
+#define EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
+#define EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
+#define EEPROM_CHANNEL_PLAN_NCC_TAIWAN		0xB
+#define EEPROM_CHANNEL_PLAN_CHIAN			0XC
+#define EEPROM_CHANNEL_PLAN_SINGAPORE_INDIA_MEXICO  0XD
+#define EEPROM_CHANNEL_PLAN_KOREA			0xE
+#define EEPROM_CHANNEL_PLAN_TURKEY              	0xF
+#define EEPROM_CHANNEL_PLAN_JAPAN                 	0x10
+#define EEPROM_CHANNEL_PLAN_FCC_NO_DFS		0x11
+#define EEPROM_CHANNEL_PLAN_JAPAN_NO_DFS	0x12
+#define EEPROM_CHANNEL_PLAN_WORLD_WIDE_5G	0x13
+#define EEPROM_CHANNEL_PLAN_TAIWAN_NO_DFS 	0x14
+
+#define EEPROM_USB_OPTIONAL1					0xE
+#define EEPROM_CHANNEL_PLAN_BY_HW_MASK		0x80
+
+#define RTL_EEPROM_ID							0x8129
+#define EEPROM_Default_TSSI						0x0
+#define EEPROM_Default_BoardType				0x02
+#define EEPROM_Default_ThermalMeter			0x12
+#define EEPROM_Default_ThermalMeter_92SU		0x7
+#define EEPROM_Default_ThermalMeter_88E		0x18
+#define EEPROM_Default_ThermalMeter_8812		0x18
+#define	EEPROM_Default_ThermalMeter_8192E			0x1A
+#define	EEPROM_Default_ThermalMeter_8723B		0x18
+#define	EEPROM_Default_ThermalMeter_8703B		0x18
+#define	EEPROM_Default_ThermalMeter_8188F		0x18
+#define EEPROM_Default_ThermalMeter_8814A		0x18
+
+
+#define EEPROM_Default_CrystalCap				0x0
+#define EEPROM_Default_CrystalCap_8723A		0x20
+#define EEPROM_Default_CrystalCap_88E 			0x20
+#define EEPROM_Default_CrystalCap_8812			0x20
+#define EEPROM_Default_CrystalCap_8814			0x20
+#define EEPROM_Default_CrystalCap_8192E			0x20
+#define EEPROM_Default_CrystalCap_8723B			0x20
+#define EEPROM_Default_CrystalCap_8703B			0x20
+#define EEPROM_Default_CrystalCap_8188F			0x20
+#define EEPROM_Default_CrystalFreq				0x0
+#define EEPROM_Default_TxPowerLevel_92C		0x22
+#define EEPROM_Default_TxPowerLevel_2G			0x2C
+#define EEPROM_Default_TxPowerLevel_5G			0x22
+#define EEPROM_Default_TxPowerLevel			0x22
+#define EEPROM_Default_HT40_2SDiff				0x0
+#define EEPROM_Default_HT20_Diff				2
+#define EEPROM_Default_LegacyHTTxPowerDiff		0x3
+#define EEPROM_Default_LegacyHTTxPowerDiff_92C	0x3
+#define EEPROM_Default_LegacyHTTxPowerDiff_92D	0x4
+#define EEPROM_Default_HT40_PwrMaxOffset		0
+#define EEPROM_Default_HT20_PwrMaxOffset		0
+
+#define EEPROM_Default_PID						0x1234
+#define EEPROM_Default_VID						0x5678
+#define EEPROM_Default_CustomerID				0xAB
+#define EEPROM_Default_CustomerID_8188E		0x00
+#define EEPROM_Default_SubCustomerID			0xCD
+#define EEPROM_Default_Version					0
+
+#define EEPROM_Default_externalPA_C9		0x00
+#define EEPROM_Default_externalPA_CC		0xFF
+#define EEPROM_Default_internalPA_SP3T_C9	0xAA
+#define EEPROM_Default_internalPA_SP3T_CC	0xAF
+#define EEPROM_Default_internalPA_SPDT_C9	0xAA
+#ifdef CONFIG_PCI_HCI
+#define EEPROM_Default_internalPA_SPDT_CC	0xA0
+#else
+#define EEPROM_Default_internalPA_SPDT_CC	0xFA
+#endif
+#define EEPROM_Default_PAType						0
+#define EEPROM_Default_LNAType						0
+
+//New EFUSE deafult value
+#define EEPROM_DEFAULT_24G_INDEX			0x2D
+#define EEPROM_DEFAULT_24G_HT20_DIFF		0X02
+#define EEPROM_DEFAULT_24G_OFDM_DIFF	0X04
+
+#define EEPROM_DEFAULT_5G_INDEX			0X2A
+#define EEPROM_DEFAULT_5G_HT20_DIFF		0X00
+#define EEPROM_DEFAULT_5G_OFDM_DIFF		0X04
+
+#define EEPROM_DEFAULT_DIFF				0XFE
+#define EEPROM_DEFAULT_CHANNEL_PLAN		0x7F
+#define EEPROM_DEFAULT_BOARD_OPTION		0x00
+#define EEPROM_DEFAULT_RFE_OPTION_8192E 0xFF
+#define EEPROM_DEFAULT_RFE_OPTION		0x04
+#define EEPROM_DEFAULT_FEATURE_OPTION	0x00
+#define EEPROM_DEFAULT_BT_OPTION			0x10
+
+
+#define EEPROM_DEFAULT_TX_CALIBRATE_RATE	0x00
+
+// PCIe related
+#define	EEPROM_PCIE_DEV_CAP_01				0xE0 // Express device capability in PCIe configuration space, i.e., map to offset 0x74
+#define	EEPROM_PCIE_DEV_CAP_02				0xE1 // Express device capability in PCIe configuration space, i.e., map to offset 0x75
+
+
+//
+// For VHT series TX power by rate table.
+// VHT TX power by rate off setArray =
+// Band:-2G&5G = 0 / 1
+// RF: at most 4*4 = ABCD=0/1/2/3
+// CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
+//
+#define TX_PWR_BY_RATE_NUM_BAND			2
+#define TX_PWR_BY_RATE_NUM_RF			4
+#define TX_PWR_BY_RATE_NUM_RATE			84
+
+#define TXPWR_LMT_MAX_RF				4
+
+//----------------------------------------------------------------------------
+//       EEPROM/EFUSE data structure definition.
+//----------------------------------------------------------------------------
+
+//For 88E new structure
+
+/*
+2.4G:
+{
+{1,2},
+{3,4,5},
+{6,7,8},
+{9,10,11},
+{12,13},
+{14}
+}
+
+5G:
+{
+{36,38,40},
+{44,46,48},
+{52,54,56},
+{60,62,64},
+{100,102,104},
+{108,110,112},
+{116,118,120},
+{124,126,128},
+{132,134,136},
+{140,142,144},
+{149,151,153},
+{157,159,161},
+{173,175,177},
+}
+*/
+#define	MAX_RF_PATH				4
+#define RF_PATH_MAX				MAX_RF_PATH
+#define	MAX_CHNL_GROUP_24G		6
+#define	MAX_CHNL_GROUP_5G		14
+
+//It must always set to 4, otherwise read efuse table secquence will be wrong.
+#define 	MAX_TX_COUNT				4
+
+typedef struct _TxPowerInfo24G{
+	u8 IndexCCK_Base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	u8 IndexBW40_Base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	//If only one tx, only BW20 and OFDM are used.
+	s8 CCK_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 OFDM_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW20_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW40_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+}TxPowerInfo24G, *PTxPowerInfo24G;
+
+typedef struct _TxPowerInfo5G{
+	u8 IndexBW40_Base[MAX_RF_PATH][MAX_CHNL_GROUP_5G];
+	//If only one tx, only BW20, OFDM, BW80 and BW160 are used.
+	s8 OFDM_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW20_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW40_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW80_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW160_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+}TxPowerInfo5G, *PTxPowerInfo5G;
+
+
+typedef	enum _BT_Ant_NUM{
+	Ant_x2	= 0,
+	Ant_x1	= 1
+} BT_Ant_NUM, *PBT_Ant_NUM;
+
+typedef	enum _BT_CoType{
+	BT_2WIRE		= 0,
+	BT_ISSC_3WIRE	= 1,
+	BT_ACCEL		= 2,
+	BT_CSR_BC4		= 3,
+	BT_CSR_BC8		= 4,
+	BT_RTL8756		= 5,
+	BT_RTL8723A		= 6,
+	BT_RTL8821		= 7,
+	BT_RTL8723B		= 8,
+	BT_RTL8192E		= 9,
+	BT_RTL8814A		= 10,
+	BT_RTL8812A		= 11,
+	BT_RTL8703B		= 12
+} BT_CoType, *PBT_CoType;
+
+typedef	enum _BT_RadioShared{
+	BT_Radio_Shared 	= 0,
+	BT_Radio_Individual	= 1,
+} BT_RadioShared, *PBT_RadioShared;
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_phy.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_phy.h
new file mode 100644
index 000000000..19da4029e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_phy.h
@@ -0,0 +1,247 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_PHY_H__
+#define __HAL_PHY_H__
+
+
+#if DISABLE_BB_RF
+#define	HAL_FW_ENABLE				0
+#define	HAL_MAC_ENABLE			0
+#define	HAL_BB_ENABLE				0
+#define	HAL_RF_ENABLE				0
+#else // FPGA_PHY and ASIC
+#define 	HAL_FW_ENABLE				1
+#define	HAL_MAC_ENABLE			1
+#define	HAL_BB_ENABLE				1
+#define	HAL_RF_ENABLE				1
+#endif
+
+#define	RF6052_MAX_TX_PWR			0x3F
+#define	RF6052_MAX_REG_88E			0xFF
+#define	RF6052_MAX_REG_92C			0x7F
+
+#define	RF6052_MAX_REG	\
+		(RF6052_MAX_REG_88E > RF6052_MAX_REG_92C) ? RF6052_MAX_REG_88E: RF6052_MAX_REG_92C
+
+#define GET_RF6052_REAL_MAX_REG(_Adapter)	\
+		IS_HARDWARE_TYPE_8188E(_Adapter) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C
+
+#define	RF6052_MAX_PATH				2
+
+//
+// Antenna detection method, i.e., using single tone detection or RSSI reported from each antenna detected.
+// Added by Roger, 2013.05.22.
+//
+#define ANT_DETECT_BY_SINGLE_TONE	BIT0
+#define ANT_DETECT_BY_RSSI				BIT1
+#define IS_ANT_DETECT_SUPPORT_SINGLE_TONE(__Adapter)		((GET_HAL_DATA(__Adapter)->AntDetection) & ANT_DETECT_BY_SINGLE_TONE)
+#define IS_ANT_DETECT_SUPPORT_RSSI(__Adapter)		((GET_HAL_DATA(__Adapter)->AntDetection) & ANT_DETECT_BY_RSSI)
+
+
+/*--------------------------Define Parameters-------------------------------*/
+typedef	enum _RF_TYPE{
+	RF_TYPE_MIN = 0, 	// 0
+	RF_8225=1,			// 1 11b/g RF for verification only
+	RF_8256=2,			// 2 11b/g/n
+	RF_8258=3,			// 3 11a/b/g/n RF
+	RF_6052=4,			// 4 11b/g/n RF
+	RF_PSEUDO_11N=5,	// 5, It is a temporality RF.
+	RF_TYPE_MAX
+}RF_TYPE_E,*PRF_TYPE_E;
+
+#define	TX_1S			0
+#define	TX_2S			1
+#define	TX_3S			2
+#define	TX_4S			3
+
+#define	RF_PATH_MAX_92C_88E 		2
+#define	RF_PATH_MAX_90_8812		4	//Max RF number 90 support
+
+typedef enum _ANTENNA_PATH{
+       ANTENNA_NONE 	= 0,
+	ANTENNA_D		= 1,
+	ANTENNA_C		= 2,
+	ANTENNA_CD	= 3,
+	ANTENNA_B		= 4,
+	ANTENNA_BD	= 5,
+	ANTENNA_BC	= 6,
+	ANTENNA_BCD	= 7,
+	ANTENNA_A		= 8,
+	ANTENNA_AD	= 9,
+	ANTENNA_AC	= 10,
+	ANTENNA_ACD	= 11,
+	ANTENNA_AB	= 12,
+	ANTENNA_ABD	= 13,
+	ANTENNA_ABC	= 14,
+	ANTENNA_ABCD	= 15
+} ANTENNA_PATH;
+
+typedef enum _RF_CONTENT{
+	radioa_txt = 0x1000,
+	radiob_txt = 0x1001,
+	radioc_txt = 0x1002,
+	radiod_txt = 0x1003
+} RF_CONTENT;
+
+typedef enum _BaseBand_Config_Type{
+	BaseBand_Config_PHY_REG = 0,			//Radio Path A
+	BaseBand_Config_AGC_TAB = 1,			//Radio Path B
+	BaseBand_Config_AGC_TAB_2G = 2,
+	BaseBand_Config_AGC_TAB_5G = 3,
+	BaseBand_Config_PHY_REG_PG
+}BaseBand_Config_Type, *PBaseBand_Config_Type;
+
+typedef enum _HW_BLOCK{
+	HW_BLOCK_MAC = 0,
+	HW_BLOCK_PHY0 = 1,
+	HW_BLOCK_PHY1 = 2,
+	HW_BLOCK_RF = 3,
+	HW_BLOCK_MAXIMUM = 4, // Never use this
+}HW_BLOCK_E, *PHW_BLOCK_E;
+
+typedef enum _WIRELESS_MODE {
+	WIRELESS_MODE_UNKNOWN = 0x00,
+	WIRELESS_MODE_A = 0x01,
+	WIRELESS_MODE_B = 0x02,
+	WIRELESS_MODE_G = 0x04,
+	WIRELESS_MODE_AUTO = 0x08,
+	WIRELESS_MODE_N_24G = 0x10,
+	WIRELESS_MODE_N_5G = 0x20,
+	WIRELESS_MODE_AC_5G = 0x40,
+	WIRELESS_MODE_AC_24G  = 0x80,
+	WIRELESS_MODE_AC_ONLY  = 0x100,
+} WIRELESS_MODE;
+
+typedef enum _SwChnlCmdID{
+	CmdID_End,
+	CmdID_SetTxPowerLevel,
+	CmdID_BBRegWrite10,
+	CmdID_WritePortUlong,
+	CmdID_WritePortUshort,
+	CmdID_WritePortUchar,
+	CmdID_RF_WriteReg,
+}SwChnlCmdID;
+
+typedef struct _SwChnlCmd{
+	SwChnlCmdID	CmdID;
+	u32				Para1;
+	u32				Para2;
+	u32				msDelay;
+}SwChnlCmd;
+
+typedef struct _R_ANTENNA_SELECT_OFDM{
+	u32			r_tx_antenna:4;
+	u32			r_ant_l:4;
+	u32			r_ant_non_ht:4;
+	u32			r_ant_ht1:4;
+	u32			r_ant_ht2:4;
+	u32			r_ant_ht_s1:4;
+	u32			r_ant_non_ht_s1:4;
+	u32			OFDM_TXSC:2;
+	u32			Reserved:2;
+}R_ANTENNA_SELECT_OFDM;
+
+typedef struct _R_ANTENNA_SELECT_CCK{
+	u8			r_cckrx_enable_2:2;
+	u8			r_cckrx_enable:2;
+	u8			r_ccktx_enable:4;
+}R_ANTENNA_SELECT_CCK;
+
+typedef struct RF_Shadow_Compare_Map {
+	// Shadow register value
+	u32		Value;
+	// Compare or not flag
+	u8		Compare;
+	// Record If it had ever modified unpredicted
+	u8		ErrorOrNot;
+	// Recorver Flag
+	u8		Recorver;
+	//
+	u8		Driver_Write;
+}RF_SHADOW_T;
+
+/*--------------------------Exported Function prototype---------------------*/
+
+u32
+PHY_CalculateBitShift(
+	u32 BitMask
+	);
+
+u32
+PHY_RFShadowRead(
+	IN	PADAPTER		Adapter,
+	IN	u8				eRFPath,
+	IN	u32				Offset);
+
+VOID
+PHY_RFShadowWrite(
+	IN	PADAPTER		Adapter,
+	IN	u8				eRFPath,
+	IN	u32				Offset,
+	IN	u32				Data);
+
+BOOLEAN
+PHY_RFShadowCompare(
+	IN	PADAPTER		Adapter,
+	IN	u8				eRFPath,
+	IN	u32				Offset);
+
+VOID
+PHY_RFShadowRecorver(
+	IN	PADAPTER		Adapter,
+	IN	u8				eRFPath,
+	IN	u32				Offset);
+
+VOID
+PHY_RFShadowCompareAll(
+	IN	PADAPTER		Adapter);
+
+VOID
+PHY_RFShadowRecorverAll(
+	IN	PADAPTER		Adapter);
+
+VOID
+PHY_RFShadowCompareFlagSet(
+	IN	PADAPTER		Adapter,
+	IN	u8				eRFPath,
+	IN	u32				Offset,
+	IN	u8				Type);
+
+VOID
+PHY_RFShadowRecorverFlagSet(
+	IN	PADAPTER		Adapter,
+	IN	u8				eRFPath,
+	IN	u32				Offset,
+	IN	u8				Type);
+
+VOID
+PHY_RFShadowCompareFlagSetAll(
+	IN	PADAPTER		Adapter);
+
+VOID
+PHY_RFShadowRecorverFlagSetAll(
+	IN	PADAPTER		Adapter);
+
+VOID
+PHY_RFShadowRefresh(
+	IN	PADAPTER		Adapter);
+
+#endif //__HAL_COMMON_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_phy_reg.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_phy_reg.h
new file mode 100644
index 000000000..36c28a8a0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_phy_reg.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_PHY_REG_H__
+#define __HAL_PHY_REG_H__
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+//#if (RTL92SE_FPGA_VERIFY == 1)
+//#define 		bRFRegOffsetMask	0xfff
+//#else
+#define 		bRFRegOffsetMask	0xfffff
+//#endif
+
+#endif //__HAL_PHY_REG_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/hal_sdio.h b/drivers/net/wireless/realtek/rtl8723cs/include/hal_sdio.h
new file mode 100644
index 000000000..e2ab122de
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/hal_sdio.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_SDIO_H_
+#define __HAL_SDIO_H_
+
+#define ffaddr2deviceId(pdvobj, addr)	(pdvobj->Queue2Pipe[addr])
+
+u8 rtw_hal_sdio_max_txoqt_free_space(_adapter *padapter);
+u8 rtw_hal_sdio_query_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_sdio_update_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_set_sdio_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
+u32 rtw_hal_get_sdio_tx_max_length(PADAPTER padapter, u8 queue_idx);
+
+#endif //__RTW_LED_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/ieee80211.h b/drivers/net/wireless/realtek/rtl8723cs/include/ieee80211.h
new file mode 100644
index 000000000..bd94f375f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/ieee80211.h
@@ -0,0 +1,1832 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+
+#ifndef CONFIG_RTL8711FW
+
+	#if defined PLATFORM_OS_XP
+	#include <ntstrsafe.h>
+	#endif
+#else
+
+#endif
+
+#define MGMT_QUEUE_NUM 5
+
+#define ETH_ALEN	6
+#define ETH_TYPE_LEN		2
+#define PAYLOAD_TYPE_LEN	1
+
+#ifdef CONFIG_AP_MODE
+
+#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)
+
+/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	RTL871X_HOSTAPD_FLUSH = 1,
+	RTL871X_HOSTAPD_ADD_STA = 2,
+	RTL871X_HOSTAPD_REMOVE_STA = 3,
+	RTL871X_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	RTL871X_HOSTAPD_GET_WPAIE_STA = 5,
+	RTL871X_SET_ENCRYPTION = 6,
+	RTL871X_GET_ENCRYPTION = 7,
+	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
+	RTL871X_HOSTAPD_GET_RID = 9,
+	RTL871X_HOSTAPD_SET_RID = 10,
+	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
+	RTL871X_HOSTAPD_MLME = 13,
+	RTL871X_HOSTAPD_SCAN_REQ = 14,
+	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
+	RTL871X_HOSTAPD_SET_BEACON=16,
+	RTL871X_HOSTAPD_SET_WPS_BEACON = 17,
+	RTL871X_HOSTAPD_SET_WPS_PROBE_RESP = 18,
+	RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP = 19,
+	RTL871X_HOSTAPD_SET_HIDDEN_SSID = 20,
+	RTL871X_HOSTAPD_SET_MACADDR_ACL = 21,
+	RTL871X_HOSTAPD_ACL_ADD_STA = 22,
+	RTL871X_HOSTAPD_ACL_REMOVE_STA = 23,
+};
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_VHT BIT(14)
+#define WLAN_STA_NONERP BIT(31)
+
+#endif
+
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE				2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME						4
+
+#define IEEE_PARAM_WPA_ENABLED				1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED			3
+#define IEEE_PARAM_PRIVACY_INVOKED			4
+#define IEEE_PARAM_AUTH_ALGS					5
+#define IEEE_PARAM_IEEE_802_1X				6
+#define IEEE_PARAM_WPAX_SELECT				7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH				1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE 	BIT(0)
+#define WPA_CIPHER_WEP40 	BIT(1)
+#define WPA_CIPHER_WEP104 BIT(2)
+#define WPA_CIPHER_TKIP 	BIT(3)
+#define WPA_CIPHER_CCMP 	BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN 4
+extern u8 RTW_WPA_OUI_TYPE[] ;
+extern u16 RTW_WPA_VERSION ;
+extern u8 WPA_AUTH_KEY_MGMT_NONE[];
+extern u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern u8 WPA_CIPHER_SUITE_NONE[];
+extern u8 WPA_CIPHER_SUITE_WEP40[];
+extern u8 WPA_CIPHER_SUITE_TKIP[];
+extern u8 WPA_CIPHER_SUITE_WRAP[];
+extern u8 WPA_CIPHER_SUITE_CCMP[];
+extern u8 WPA_CIPHER_SUITE_WEP104[];
+
+
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+
+extern u16 RSN_VERSION_BSD;
+extern u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern u8 RSN_CIPHER_SUITE_NONE[];
+extern u8 RSN_CIPHER_SUITE_WEP40[];
+extern u8 RSN_CIPHER_SUITE_TKIP[];
+extern u8 RSN_CIPHER_SUITE_WRAP[];
+extern u8 RSN_CIPHER_SUITE_CCMP[];
+extern u8 RSN_CIPHER_SUITE_WEP104[];
+
+
+typedef enum _RATEID_IDX_ {
+	RATEID_IDX_BGN_40M_2SS = 0,
+	RATEID_IDX_BGN_40M_1SS = 1,
+	RATEID_IDX_BGN_20M_2SS_BN = 2,
+	RATEID_IDX_BGN_20M_1SS_BN = 3,
+	RATEID_IDX_GN_N2SS = 4,
+	RATEID_IDX_GN_N1SS = 5,
+	RATEID_IDX_BG = 6,
+	RATEID_IDX_G = 7,
+	RATEID_IDX_B = 8,
+	RATEID_IDX_VHT_2SS = 9,
+	RATEID_IDX_VHT_1SS = 10,
+	RATEID_IDX_MIX1 = 11,
+	RATEID_IDX_MIX2 = 12,
+	RATEID_IDX_VHT_3SS = 13,
+	RATEID_IDX_BGN_3SS = 14,
+} RATEID_IDX, *PRATEID_IDX;
+
+typedef enum _RATR_TABLE_MODE{
+	RATR_INX_WIRELESS_NGB = 0,	// BGN 40 Mhz 2SS 1SS
+	RATR_INX_WIRELESS_NG = 1,		// GN or N
+	RATR_INX_WIRELESS_NB = 2,		// BGN 20 Mhz 2SS 1SS  or BN
+	RATR_INX_WIRELESS_N = 3,
+	RATR_INX_WIRELESS_GB = 4,
+	RATR_INX_WIRELESS_G = 5,
+	RATR_INX_WIRELESS_B = 6,
+	RATR_INX_WIRELESS_MC = 7,
+	RATR_INX_WIRELESS_AC_N = 8,
+}RATR_TABLE_MODE, *PRATR_TABLE_MODE;
+
+
+enum NETWORK_TYPE
+{
+	WIRELESS_INVALID = 0,
+	//Sub-Element
+	WIRELESS_11B = BIT(0), // tx: cck only , rx: cck only, hw: cck
+	WIRELESS_11G = BIT(1), // tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm
+	WIRELESS_11A = BIT(2), // tx: ofdm only, rx: ofdm only, hw: ofdm only
+	WIRELESS_11_24N = BIT(3), // tx: MCS only, rx: MCS & cck, hw: MCS & cck
+	WIRELESS_11_5N = BIT(4), // tx: MCS only, rx: MCS & ofdm, hw: ofdm only
+	WIRELESS_AUTO = BIT(5),
+	WIRELESS_11AC = BIT(6),
+
+	//Combination
+	//Type for current wireless mode
+	WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G), // tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm
+	WIRELESS_11G_24N = (WIRELESS_11G|WIRELESS_11_24N), // tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm
+	WIRELESS_11A_5N = (WIRELESS_11A|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
+	WIRELESS_11B_24N = (WIRELESS_11B|WIRELESS_11_24N), // tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck
+	WIRELESS_11BG_24N = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N), // tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck
+	WIRELESS_11_24AC = (WIRELESS_11G|WIRELESS_11AC),
+	WIRELESS_11_5AC = (WIRELESS_11A|WIRELESS_11AC),
+
+
+	//Type for registry default wireless mode
+	WIRELESS_11AGN = (WIRELESS_11A|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
+	WIRELESS_11ABGN = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N),
+	WIRELESS_MODE_24G = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N),
+	WIRELESS_MODE_5G = (WIRELESS_11A|WIRELESS_11_5N|WIRELESS_11AC),
+	WIRELESS_MODE_MAX = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N|WIRELESS_11AC),
+};
+
+#define SUPPORTED_24G_NETTYPE_MSK WIRELESS_MODE_24G
+#define SUPPORTED_5G_NETTYPE_MSK WIRELESS_MODE_5G
+
+#define IsLegacyOnly(NetType)  ((NetType) == ((NetType) & (WIRELESS_11BG|WIRELESS_11A)))
+
+#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? _TRUE : _FALSE)
+#define IsSupported5G(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? _TRUE : _FALSE)
+
+#define IsEnableHWCCK(NetType) IsSupported24G(NetType)
+#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11_24N|SUPPORTED_5G_NETTYPE_MSK) ? _TRUE : _FALSE)
+
+#define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
+#define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
+#define IsSupportedRxHT(NetType) IsEnableHWOFDM(NetType)
+
+#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? _TRUE : _FALSE)
+#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? _TRUE : _FALSE)
+#define IsSupportedHT(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? _TRUE : _FALSE)
+
+#define IsSupportedVHT(NetType) ((NetType) & (WIRELESS_11AC) ? _TRUE : _FALSE)
+
+
+typedef struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+	        struct{
+			int command;
+    			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+#ifdef CONFIG_AP_MODE
+		struct {
+			u16 aid;
+			u16 capability;
+			int flags;
+			u8 tx_supp_rates[16];
+			struct rtw_ieee80211_ht_cap ht_cap;
+		} add_sta;
+		struct {
+			u8	reserved[2];//for set max_num_sta
+			u8	buf[0];
+		} bcn_ie;
+#endif
+
+	} u;
+}ieee_param;
+
+#ifdef CONFIG_AP_MODE
+typedef struct ieee_param_ex {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	u8 data[0];
+}ieee_param_ex;
+
+struct sta_data{
+	u16 aid;
+	u16 capability;
+	int flags;
+	u32 sta_set;
+	u8 tx_supp_rates[16];
+	u32 tx_supp_rates_len;
+	struct rtw_ieee80211_ht_cap ht_cap;
+	u64	rx_pkts;
+	u64	rx_bytes;
+	u64	rx_drops;
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64	tx_drops;
+};
+#endif
+
+
+#if WIRELESS_EXT < 17
+#define IW_QUAL_QUAL_INVALID   0x10
+#define IW_QUAL_LEVEL_INVALID  0x20
+#define IW_QUAL_NOISE_INVALID  0x40
+#define IW_QUAL_QUAL_UPDATED   0x1
+#define IW_QUAL_LEVEL_UPDATED  0x2
+#define IW_QUAL_NOISE_UPDATED  0x4
+#endif
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	_list	list;
+};
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)||defined(PLATFORM_FREEBSD)
+
+struct rtw_ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+} __attribute__ ((packed));
+
+
+struct rtw_ieee80211_hdr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	u16	qc;
+}  __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr_qos {
+        u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+       u16     qc;
+}  __attribute__ ((packed));
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __attribute__ ((packed));
+
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct rtw_ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+};
+
+struct rtw_ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+};
+
+
+struct rtw_ieee80211_hdr_qos {
+	struct rtw_ieee80211_hdr wlan_hdr;
+	u16	qc;
+};
+
+struct rtw_ieee80211_hdr_3addr_qos {
+        struct  rtw_ieee80211_hdr_3addr wlan_hdr;
+        u16     qc;
+};
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+};
+#pragma pack()
+
+#endif
+
+
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define RTW_IEEE80211_FCTL_VERS		0x0003
+#define RTW_IEEE80211_FCTL_FTYPE		0x000c
+#define RTW_IEEE80211_FCTL_STYPE		0x00f0
+#define RTW_IEEE80211_FCTL_TODS		0x0100
+#define RTW_IEEE80211_FCTL_FROMDS	0x0200
+#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
+#define RTW_IEEE80211_FCTL_RETRY		0x0800
+#define RTW_IEEE80211_FCTL_PM		0x1000
+#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
+#define RTW_IEEE80211_FCTL_PROTECTED	0x4000
+#define RTW_IEEE80211_FCTL_ORDER		0x8000
+#define RTW_IEEE80211_FCTL_CTL_EXT	0x0f00
+
+#define RTW_IEEE80211_FTYPE_MGMT		0x0000
+#define RTW_IEEE80211_FTYPE_CTL		0x0004
+#define RTW_IEEE80211_FTYPE_DATA		0x0008
+#define RTW_IEEE80211_FTYPE_EXT		0x000c
+
+/* management */
+#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define RTW_IEEE80211_STYPE_ASSOC_RESP 	0x0010
+#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
+#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
+#define RTW_IEEE80211_STYPE_BEACON		0x0080
+#define RTW_IEEE80211_STYPE_ATIM		0x0090
+#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
+#define RTW_IEEE80211_STYPE_AUTH		0x00B0
+#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
+#define RTW_IEEE80211_STYPE_ACTION		0x00D0
+
+/* control */
+#define RTW_IEEE80211_STYPE_CTL_EXT		0x0060
+#define RTW_IEEE80211_STYPE_BACK_REQ		0x0080
+#define RTW_IEEE80211_STYPE_BACK		0x0090
+#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_RTS		0x00B0
+#define RTW_IEEE80211_STYPE_CTS		0x00C0
+#define RTW_IEEE80211_STYPE_ACK		0x00D0
+#define RTW_IEEE80211_STYPE_CFEND		0x00E0
+#define RTW_IEEE80211_STYPE_CFENDACK		0x00F0
+
+/* data */
+#define RTW_IEEE80211_STYPE_DATA		0x0000
+#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
+#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
+#define RTW_IEEE80211_STYPE_CFACK		0x0050
+#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
+#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
+#define RTW_IEEE80211_STYPE_QOS_DATA		0x0080
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACK		0x0090
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACKPOLL	0x00B0
+#define RTW_IEEE80211_STYPE_QOS_NULLFUNC	0x00C0
+#define RTW_IEEE80211_STYPE_QOS_CFACK		0x00D0
+#define RTW_IEEE80211_STYPE_QOS_CFPOLL		0x00E0
+#define RTW_IEEE80211_STYPE_QOS_CFACKPOLL	0x00F0
+
+/* sequence control field */
+#define RTW_IEEE80211_SCTL_FRAG	0x000F
+#define RTW_IEEE80211_SCTL_SEQ	0xFFF0
+
+
+#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
+#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
+#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW) || defined(PLATFORM_FREEBSD)
+
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+};
+#pragma pack()
+
+#endif
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_ACTIVE_ROAM 65533
+#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
+#define WLAN_REASON_EXPIRATION_CHK 65535
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+/* EIDs defined by IEEE 802.11h - START */
+#define WLAN_EID_PWR_CONSTRAINT 32
+#define WLAN_EID_PWR_CAPABILITY 33
+#define WLAN_EID_TPC_REQUEST 34
+#define WLAN_EID_TPC_REPORT 35
+#define WLAN_EID_SUPPORTED_CHANNELS 36
+#define WLAN_EID_CHANNEL_SWITCH 37
+#define WLAN_EID_MEASURE_REQUEST 38
+#define WLAN_EID_MEASURE_REPORT 39
+#define WLAN_EID_QUITE 40
+#define WLAN_EID_IBSS_DFS 41
+/* EIDs defined by IEEE 802.11h - END */
+#define WLAN_EID_ERP_INFO 42
+#define WLAN_EID_HT_CAP 45
+#define WLAN_EID_RSN 48
+#define WLAN_EID_EXT_SUPP_RATES 50
+#define WLAN_EID_MOBILITY_DOMAIN 54
+#define WLAN_EID_FAST_BSS_TRANSITION 55
+#define WLAN_EID_TIMEOUT_INTERVAL 56
+#define WLAN_EID_RIC_DATA 57
+#define WLAN_EID_HT_OPERATION 61
+#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
+#define WLAN_EID_20_40_BSS_COEXISTENCE 72
+#define WLAN_EID_20_40_BSS_INTOLERANT 73
+#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
+#define WLAN_EID_MMIE 76
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
+#define WLAN_EID_VHT_CAPABILITY 191
+#define WLAN_EID_VHT_OPERATION 192
+#define WLAN_EID_VHT_OP_MODE_NOTIFY 199
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN  		4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN 		8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
+        IEEE80211_CCK_RATE_5MB_MASK | \
+        IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
+	IEEE80211_OFDM_RATE_9MB_MASK  | \
+	IEEE80211_OFDM_RATE_18MB_MASK | \
+	IEEE80211_OFDM_RATE_36MB_MASK | \
+	IEEE80211_OFDM_RATE_48MB_MASK | \
+	IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+enum MGN_RATE{
+	MGN_1M		= 0x02,
+	MGN_2M		= 0x04,
+	MGN_5_5M 	= 0x0B,
+	MGN_6M	 	= 0x0C,
+	MGN_9M		= 0x12,
+	MGN_11M 	= 0x16,
+	MGN_12M	= 0x18,
+	MGN_18M	= 0x24,
+	MGN_24M	= 0x30,
+	MGN_36M	= 0x48,
+	MGN_48M	= 0x60,
+	MGN_54M	= 0x6C,
+	MGN_MCS32	= 0x7F,
+	MGN_MCS0,
+	MGN_MCS1,
+	MGN_MCS2,
+	MGN_MCS3,
+	MGN_MCS4,
+	MGN_MCS5,
+	MGN_MCS6,
+	MGN_MCS7,
+	MGN_MCS8,
+	MGN_MCS9,
+	MGN_MCS10,
+	MGN_MCS11,
+	MGN_MCS12,
+	MGN_MCS13,
+	MGN_MCS14,
+	MGN_MCS15,
+	MGN_MCS16,
+	MGN_MCS17,
+	MGN_MCS18,
+	MGN_MCS19,
+	MGN_MCS20,
+	MGN_MCS21,
+	MGN_MCS22,
+	MGN_MCS23,
+	MGN_MCS24,
+	MGN_MCS25,
+	MGN_MCS26,
+	MGN_MCS27,
+	MGN_MCS28,
+	MGN_MCS29,
+	MGN_MCS30,
+	MGN_MCS31,
+	MGN_VHT1SS_MCS0,
+	MGN_VHT1SS_MCS1,
+	MGN_VHT1SS_MCS2,
+	MGN_VHT1SS_MCS3,
+	MGN_VHT1SS_MCS4,
+	MGN_VHT1SS_MCS5,
+	MGN_VHT1SS_MCS6,
+	MGN_VHT1SS_MCS7,
+	MGN_VHT1SS_MCS8,
+	MGN_VHT1SS_MCS9,
+	MGN_VHT2SS_MCS0,
+	MGN_VHT2SS_MCS1,
+	MGN_VHT2SS_MCS2,
+	MGN_VHT2SS_MCS3,
+	MGN_VHT2SS_MCS4,
+	MGN_VHT2SS_MCS5,
+	MGN_VHT2SS_MCS6,
+	MGN_VHT2SS_MCS7,
+	MGN_VHT2SS_MCS8,
+	MGN_VHT2SS_MCS9,
+	MGN_VHT3SS_MCS0,
+	MGN_VHT3SS_MCS1,
+	MGN_VHT3SS_MCS2,
+	MGN_VHT3SS_MCS3,
+	MGN_VHT3SS_MCS4,
+	MGN_VHT3SS_MCS5,
+	MGN_VHT3SS_MCS6,
+	MGN_VHT3SS_MCS7,
+	MGN_VHT3SS_MCS8,
+	MGN_VHT3SS_MCS9,
+	MGN_VHT4SS_MCS0,
+	MGN_VHT4SS_MCS1,
+	MGN_VHT4SS_MCS2,
+	MGN_VHT4SS_MCS3,
+	MGN_VHT4SS_MCS4,
+	MGN_VHT4SS_MCS5,
+	MGN_VHT4SS_MCS6,
+	MGN_VHT4SS_MCS7,
+	MGN_VHT4SS_MCS8,
+	MGN_VHT4SS_MCS9,
+	MGN_UNKNOWN
+};
+
+#define IS_HT_RATE(_rate)	((_rate) >= MGN_MCS0 && (_rate) <= MGN_MCS31)
+#define IS_VHT_RATE(_rate)	((_rate) >= MGN_VHT1SS_MCS0 && (_rate) <= MGN_VHT4SS_MCS9)
+#define IS_CCK_RATE(_rate)	((_rate) == MGN_1M || (_rate) == MGN_2M || (_rate) == MGN_5_5M || (_rate) == MGN_11M)
+#define IS_OFDM_RATE(_rate)	((_rate) >= MGN_6M && (_rate) <= MGN_54M  && (_rate) != MGN_11M)
+
+#define IS_HT1SS_RATE(_rate) ((_rate) >= MGN_MCS0 && (_rate) <= MGN_MCS7)
+#define IS_HT2SS_RATE(_rate) ((_rate) >= MGN_MCS8 && (_rate) <= MGN_MCS15)
+#define IS_HT3SS_RATE(_rate) ((_rate) >= MGN_MCS16 && (_rate) <= MGN_MCS23)
+#define IS_HT4SS_RATE(_rate) ((_rate) >= MGN_MCS24 && (_rate) <= MGN_MCS31)
+
+#define IS_VHT1SS_RATE(_rate) ((_rate) >= MGN_VHT1SS_MCS0 && (_rate) <= MGN_VHT1SS_MCS9)
+#define IS_VHT2SS_RATE(_rate) ((_rate) >= MGN_VHT2SS_MCS0 && (_rate) <= MGN_VHT2SS_MCS9)
+#define IS_VHT3SS_RATE(_rate) ((_rate) >= MGN_VHT3SS_MCS0 && (_rate) <= MGN_VHT3SS_MCS9)
+#define IS_VHT4SS_RATE(_rate) ((_rate) >= MGN_VHT4SS_MCS0 && (_rate) <= MGN_VHT4SS_MCS9)
+
+#define IS_1T_RATE(_rate)	(IS_CCK_RATE((_rate)) || IS_OFDM_RATE((_rate)) || IS_HT1SS_RATE((_rate)) || IS_VHT1SS_RATE((_rate)))
+#define IS_2T_RATE(_rate)	(IS_HT2SS_RATE((_rate)) || IS_VHT2SS_RATE((_rate)))
+#define IS_3T_RATE(_rate)	(IS_HT3SS_RATE((_rate)) || IS_VHT3SS_RATE((_rate)))
+#define IS_4T_RATE(_rate)	(IS_HT4SS_RATE((_rate)) || IS_VHT4SS_RATE((_rate)))
+
+typedef enum _RATE_SECTION {
+	CCK = 0,
+	OFDM = 1,
+	HT_MCS0_MCS7 = 2,
+	HT_MCS8_MCS15 = 3,
+	HT_MCS16_MCS23 = 4,
+	HT_MCS24_MCS31 = 5,
+	HT_1SS = HT_MCS0_MCS7,
+	HT_2SS = HT_MCS8_MCS15,
+	HT_3SS = HT_MCS16_MCS23,
+	HT_4SS = HT_MCS24_MCS31,
+	VHT_1SSMCS0_1SSMCS9 = 6,
+	VHT_2SSMCS0_2SSMCS9 = 7,
+	VHT_3SSMCS0_3SSMCS9 = 8,
+	VHT_4SSMCS0_4SSMCS9 = 9,
+	VHT_1SS = VHT_1SSMCS0_1SSMCS9,
+	VHT_2SS = VHT_2SSMCS0_2SSMCS9,
+	VHT_3SS = VHT_3SSMCS0_3SSMCS9,
+	VHT_4SS = VHT_4SSMCS0_4SSMCS9,
+	RATE_SECTION_NUM,
+} RATE_SECTION;
+
+const char *rate_section_str(u8 section);
+
+#define IS_CCK_RATE_SECTION(section) ((section) == CCK)
+#define IS_OFDM_RATE_SECTION(section) ((section) == OFDM)
+#define IS_HT_RATE_SECTION(section) ((section) >= HT_1SS && (section) <= HT_4SS)
+#define IS_VHT_RATE_SECTION(section) ((section) >= VHT_1SS && (section) <= VHT_4SS)
+
+#define IS_1T_RATE_SECTION(section) ((section) == CCK || (section) == OFDM || (section) == HT_1SS || (section) == VHT_1SS)
+#define IS_2T_RATE_SECTION(section) ((section) == HT_2SS || (section) == VHT_2SS)
+#define IS_3T_RATE_SECTION(section) ((section) == HT_3SS || (section) == VHT_3SS)
+#define IS_4T_RATE_SECTION(section) ((section) == HT_4SS || (section) == VHT_4SS)
+
+extern u8 mgn_rates_cck[];
+extern u8 mgn_rates_ofdm[];
+extern u8 mgn_rates_mcs0_7[];
+extern u8 mgn_rates_mcs8_15[];
+extern u8 mgn_rates_mcs16_23[];
+extern u8 mgn_rates_mcs24_31[];
+extern u8 mgn_rates_vht1ss[];
+extern u8 mgn_rates_vht2ss[];
+extern u8 mgn_rates_vht3ss[];
+extern u8 mgn_rates_vht4ss[];
+
+struct rate_section_ent {
+	u8 tx_num; /* value of RF_TX_NUM */
+	u8 rate_num;
+	u8 *rates;
+};
+
+extern struct rate_section_ent rates_by_sections[];
+
+#define rate_section_to_tx_num(section) (rates_by_sections[(section)].tx_num)
+#define rate_section_rate_num(section) (rates_by_sections[(section)].rate_num)
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	//u32 mac_time[2];
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	//u8 control;
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   //jackson
+	uint tid;	//jackson
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+#ifndef PLATFORM_FREEBSD //Baron BSD has already defined
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+#endif //PLATFORM_FREEBSD
+struct ieee80211_softmac_stats{
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+#ifdef CONFIG_IEEE80211W
+#define BIP_MAX_KEYID 5
+#define BIP_AAD_SIZE  20
+#endif //CONFIG_IEEE80211W
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} ;
+#pragma pack()
+
+#endif
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__ ((packed));
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __attribute__ ((packed));
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} ;
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} ;
+#pragma pack()
+
+#endif
+
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	//struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_request_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	//u8 current_ap[ETH_ALEN];
+	struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_response_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+//	struct ieee80211_info_element info_element; /* supported rates */
+} __attribute__ ((packed));
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	//struct ieee80211_info_element_hdr info_element;
+} ;
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} ;
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} ;
+
+struct ieee80211_assoc_request_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	//u8 current_ap[ETH_ALEN];
+	struct ieee80211_info_element_hdr info_element;
+} ;
+
+struct ieee80211_assoc_response_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+//	struct ieee80211_info_element info_element; /* supported rates */
+};
+
+#pragma pack()
+
+#endif
+
+
+
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+//(HZ / 2)
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN (256)
+#define MAX_WPS_IE_LEN (512)
+#define MAX_P2P_IE_LEN (256)
+#define MAX_WFD_IE_LEN (128)
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+#if 0
+struct ieee80211_network {
+	/* These entries are used to identify a unique network */
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	/* Ensure null-terminated for any debug msgs */
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
+	u8	rssi;	//relative signal strength
+	u8	sq;		//signal quality
+
+	/* These are network statistics */
+	//struct ieee80211_rx_stats stats;
+	u16 capability;
+	u16	aid;
+	u8 rates[MAX_RATES_LENGTH];
+	u8 rates_len;
+	u8 rates_ex[MAX_RATES_EX_LENGTH];
+	u8 rates_ex_len;
+
+	u8 edca_parmsets[18];
+
+	u8 mode;
+	u8 flags;
+	u8 time_stamp[8];
+	u16 beacon_interval;
+	u16 listen_interval;
+	u16 atim_window;
+	u8 wpa_ie[MAX_WPA_IE_LEN];
+	size_t wpa_ie_len;
+	u8 rsn_ie[MAX_WPA_IE_LEN];
+	size_t rsn_ie_len;
+	u8 country[6];
+	u8 dtim_period;
+	u8 dtim_data;
+	u8 power_constraint;
+	u8 qosinfo;
+	u8 qbssload[5];
+	u8 network_type;
+	int join_res;
+	unsigned long	last_scanned;
+};
+#endif
+/*
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+*/
+
+#ifndef PLATFORM_FREEBSD //Baron BSD has already defined
+
+enum ieee80211_state {
+
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+
+};
+#endif //PLATFORM_FREEBSD
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
+#define IP_FMT "%d.%d.%d.%d"
+#define IP_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3]
+#define PORT_FMT "%u"
+#define PORT_ARG(x) ntohs(*((u16 *)(x)))
+
+#ifdef PLATFORM_FREEBSD //Baron change func to macro
+#define is_multicast_mac_addr(Addr) ((((Addr[0]) & 0x01) == 0x01) && ((Addr[0]) != 0xff))
+#define is_broadcast_mac_addr(Addr) ((((Addr[0]) & 0xff) == 0xff) && (((Addr[1]) & 0xff) == 0xff) && \
+(((Addr[2]) & 0xff) == 0xff) && (((Addr[3]) & 0xff) == 0xff) && (((Addr[4]) & 0xff) == 0xff) && \
+(((Addr[5]) & 0xff) == 0xff))
+#else
+extern __inline int is_multicast_mac_addr(const u8 *addr)
+{
+        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+extern __inline int is_broadcast_mac_addr(const u8 *addr)
+{
+	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
+		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
+}
+
+extern __inline int is_zero_mac_addr(const u8 *addr)
+{
+	return ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) &&   \
+		(addr[3] == 0x00) && (addr[4] == 0x00) && (addr[5] == 0x00));
+}
+#endif //PLATFORM_FREEBSD
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+typedef struct tx_pending_t{
+	int frag;
+	struct ieee80211_txb *txb;
+}tx_pending_t;
+
+
+
+#define TID_NUM	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+//Baron move to ieee80211.c
+int ieee80211_is_empty_essid(const char *essid, int essid_len);
+int ieee80211_get_hdrlen(u16 fc);
+
+#if 0
+/* Action frame categories (IEEE 802.11-2007, 7.3.1.11, Table 7-24) */
+#define WLAN_ACTION_SPECTRUM_MGMT 0
+#define WLAN_ACTION_QOS 1
+#define WLAN_ACTION_DLS 2
+#define WLAN_ACTION_BLOCK_ACK 3
+#define WLAN_ACTION_RADIO_MEASUREMENT 5
+#define WLAN_ACTION_FT 6
+#define WLAN_ACTION_SA_QUERY 8
+#define WLAN_ACTION_WMM 17
+#endif
+
+
+/* Action category code */
+enum rtw_ieee80211_category {
+	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	RTW_WLAN_CATEGORY_QOS = 1,
+	RTW_WLAN_CATEGORY_DLS = 2,
+	RTW_WLAN_CATEGORY_BACK = 3,
+	RTW_WLAN_CATEGORY_PUBLIC = 4, //IEEE 802.11 public action frames
+	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
+	RTW_WLAN_CATEGORY_FT = 6,
+	RTW_WLAN_CATEGORY_HT = 7,
+	RTW_WLAN_CATEGORY_SA_QUERY = 8,
+	RTW_WLAN_CATEGORY_UNPROTECTED_WNM = 11, // add for CONFIG_IEEE80211W, none 11w also can use
+	RTW_WLAN_CATEGORY_TDLS = 12,
+	RTW_WLAN_CATEGORY_SELF_PROTECTED = 15, // add for CONFIG_IEEE80211W, none 11w also can use
+	RTW_WLAN_CATEGORY_WMM = 17,
+	RTW_WLAN_CATEGORY_VHT = 21,
+	RTW_WLAN_CATEGORY_P2P = 0x7f,//P2P action frames
+};
+
+/* SPECTRUM_MGMT action code */
+enum rtw_ieee80211_spectrum_mgmt_actioncode {
+	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
+	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
+	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+enum _PUBLIC_ACTION{
+	ACT_PUBLIC_BSSCOEXIST = 0, // 20/40 BSS Coexistence
+	ACT_PUBLIC_DSE_ENABLE = 1,
+	ACT_PUBLIC_DSE_DEENABLE = 2,
+	ACT_PUBLIC_DSE_REG_LOCATION = 3,
+	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
+	ACT_PUBLIC_DSE_MSR_REQ = 5,
+	ACT_PUBLIC_DSE_MSR_RPRT = 6,
+	ACT_PUBLIC_MP = 7, // Measurement Pilot
+	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
+	ACT_PUBLIC_VENDOR = 9, // for WIFI_DIRECT
+	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
+	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
+	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
+	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
+	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
+	ACT_PUBLIC_LOCATION_TRACK = 15,
+	ACT_PUBLIC_MAX
+};
+
+#ifdef CONFIG_TDLS
+enum TDLS_ACTION_FIELD{
+	TDLS_SETUP_REQUEST = 0,
+	TDLS_SETUP_RESPONSE = 1,
+	TDLS_SETUP_CONFIRM = 2,
+	TDLS_TEARDOWN = 3,
+	TDLS_PEER_TRAFFIC_INDICATION = 4,
+	TDLS_CHANNEL_SWITCH_REQUEST = 5,
+	TDLS_CHANNEL_SWITCH_RESPONSE = 6,
+	TDLS_PEER_PSM_REQUEST = 7,
+	TDLS_PEER_PSM_RESPONSE = 8,
+	TDLS_PEER_TRAFFIC_RESPONSE = 9,
+	TDLS_DISCOVERY_REQUEST = 10,
+	TDLS_DISCOVERY_RESPONSE = 14,	//it's used in public action frame
+};
+
+#define	TUNNELED_PROBE_REQ	15
+#define	TUNNELED_PROBE_RSP	16
+#endif //CONFIG_TDLS
+
+/* BACK action code */
+enum rtw_ieee80211_back_actioncode {
+	RTW_WLAN_ACTION_ADDBA_REQ = 0,
+	RTW_WLAN_ACTION_ADDBA_RESP = 1,
+	RTW_WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum rtw_ieee80211_ht_actioncode {
+	RTW_WLAN_ACTION_HT_NOTI_CHNL_WIDTH = 0,
+       RTW_WLAN_ACTION_HT_SM_PS = 1,
+       RTW_WLAN_ACTION_HT_PSMP = 2,
+       RTW_WLAN_ACTION_HT_SET_PCO_PHASE = 3,
+       RTW_WLAN_ACTION_HT_CSI = 4,
+       RTW_WLAN_ACTION_HT_NON_COMPRESS_BEAMFORMING = 5,
+       RTW_WLAN_ACTION_HT_COMPRESS_BEAMFORMING = 6,
+       RTW_WLAN_ACTION_HT_ASEL_FEEDBACK = 7,
+};
+
+/* BACK (block-ack) parties */
+enum rtw_ieee80211_back_parties {
+	RTW_WLAN_BACK_RECIPIENT = 0,
+	RTW_WLAN_BACK_INITIATOR = 1,
+	RTW_WLAN_BACK_TIMER = 2,
+};
+
+/*20/40 BSS Coexistence element */
+#define RTW_WLAN_20_40_BSS_COEX_INFO_REQ            BIT(0)
+#define RTW_WLAN_20_40_BSS_COEX_40MHZ_INTOL         BIT(1)
+#define RTW_WLAN_20_40_BSS_COEX_20MHZ_WIDTH_REQ     BIT(2)
+#define RTW_WLAN_20_40_BSS_COEX_OBSS_EXEMPT_REQ     BIT(3)
+#define RTW_WLAN_20_40_BSS_COEX_OBSS_EXEMPT_GRNT    BIT(4)
+
+/* VHT features action code */
+enum rtw_ieee80211_vht_actioncode{
+	RTW_WLAN_ACTION_VHT_COMPRESSED_BEAMFORMING = 0,
+       RTW_WLAN_ACTION_VHT_GROUPID_MANAGEMENT = 1,
+       RTW_WLAN_ACTION_VHT_OPMODE_NOTIFICATION = 2,
+};
+
+
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+#ifndef PLATFORM_FREEBSD //Baron BSD has defined
+#define WME_OUI_TYPE 2
+#endif //PLATFORM_FREEBSD
+#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WME_VERSION 1
+
+#define WME_ACTION_CODE_SETUP_REQUEST 0
+#define WME_ACTION_CODE_SETUP_RESPONSE 1
+#define WME_ACTION_CODE_TEARDOWN 2
+
+#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
+#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
+#define WME_SETUP_RESPONSE_STATUS_REFUSED 3
+
+#define WME_TSPEC_DIRECTION_UPLINK 0
+#define WME_TSPEC_DIRECTION_DOWNLINK 1
+#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3
+
+
+#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+
+#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
+
+/**
+ * enum rtw_ieee80211_channel_flags - channel flags
+ *
+ * Channel flags set by the regulatory control code.
+ *
+ * @RTW_IEEE80211_CHAN_DISABLED: This channel is disabled.
+ * @RTW_IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted
+ *      on this channel.
+ * @RTW_IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
+ * @RTW_IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
+ * @RTW_IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
+ *      is not permitted.
+ * @RTW_IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
+ *      is not permitted.
+ */
+  enum rtw_ieee80211_channel_flags {
+          RTW_IEEE80211_CHAN_DISABLED         = 1<<0,
+          RTW_IEEE80211_CHAN_PASSIVE_SCAN     = 1<<1,
+          RTW_IEEE80211_CHAN_NO_IBSS          = 1<<2,
+          RTW_IEEE80211_CHAN_RADAR            = 1<<3,
+          RTW_IEEE80211_CHAN_NO_HT40PLUS      = 1<<4,
+          RTW_IEEE80211_CHAN_NO_HT40MINUS     = 1<<5,
+  };
+
+  #define RTW_IEEE80211_CHAN_NO_HT40 \
+          (RTW_IEEE80211_CHAN_NO_HT40PLUS | RTW_IEEE80211_CHAN_NO_HT40MINUS)
+
+/* Represent channel details, subset of ieee80211_channel */
+struct rtw_ieee80211_channel {
+	//enum ieee80211_band band;
+	//u16 center_freq;
+	u16 hw_value;
+	u32 flags;
+	//int max_antenna_gain;
+	//int max_power;
+	//int max_reg_power;
+	//bool beacon_found;
+	//u32 orig_flags;
+	//int orig_mag;
+	//int orig_mpwr;
+};
+
+#define CHAN_FMT \
+	/*"band:%d, "*/ \
+	/*"center_freq:%u, "*/ \
+	"hw_value:%u, " \
+	"flags:0x%08x" \
+	/*"max_antenna_gain:%d\n"*/ \
+	/*"max_power:%d\n"*/ \
+	/*"max_reg_power:%d\n"*/ \
+	/*"beacon_found:%u\n"*/ \
+	/*"orig_flags:0x%08x\n"*/ \
+	/*"orig_mag:%d\n"*/ \
+	/*"orig_mpwr:%d\n"*/
+
+#define CHAN_ARG(channel) \
+	/*(channel)->band*/ \
+	/*, (channel)->center_freq*/ \
+	(channel)->hw_value \
+	, (channel)->flags \
+	/*, (channel)->max_antenna_gain*/ \
+	/*, (channel)->max_power*/ \
+	/*, (channel)->max_reg_power*/ \
+	/*, (channel)->beacon_found*/ \
+	/*, (channel)->orig_flags*/ \
+	/*, (channel)->orig_mag*/ \
+	/*, (channel)->orig_mpwr*/ \
+
+/* Parsed Information Elements */
+struct rtw_ieee802_11_elems {
+	u8 *ssid;
+	u8 ssid_len;
+	u8 *supp_rates;
+	u8 supp_rates_len;
+	u8 *fh_params;
+	u8 fh_params_len;
+	u8 *ds_params;
+	u8 ds_params_len;
+	u8 *cf_params;
+	u8 cf_params_len;
+	u8 *tim;
+	u8 tim_len;
+	u8 *ibss_params;
+	u8 ibss_params_len;
+	u8 *challenge;
+	u8 challenge_len;
+	u8 *erp_info;
+	u8 erp_info_len;
+	u8 *ext_supp_rates;
+	u8 ext_supp_rates_len;
+	u8 *wpa_ie;
+	u8 wpa_ie_len;
+	u8 *rsn_ie;
+	u8 rsn_ie_len;
+	u8 *wme;
+	u8 wme_len;
+	u8 *wme_tspec;
+	u8 wme_tspec_len;
+	u8 *wps_ie;
+	u8 wps_ie_len;
+	u8 *power_cap;
+	u8 power_cap_len;
+	u8 *supp_channels;
+	u8 supp_channels_len;
+	u8 *mdie;
+	u8 mdie_len;
+	u8 *ftie;
+	u8 ftie_len;
+	u8 *timeout_int;
+	u8 timeout_int_len;
+	u8 *ht_capabilities;
+	u8 ht_capabilities_len;
+	u8 *ht_operation;
+	u8 ht_operation_len;
+	u8 *vendor_ht_cap;
+	u8 vendor_ht_cap_len;
+	u8 *vht_capabilities;
+	u8 vht_capabilities_len;
+	u8 *vht_operation;
+	u8 vht_operation_len;
+	u8 *vht_op_mode_notify;
+	u8 vht_op_mode_notify_len;
+};
+
+typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
+
+ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors);
+
+u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
+u8 *rtw_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
+
+enum secondary_ch_offset {
+	SCN = 0, /* no secondary channel */
+	SCA = 1, /* secondary channel above */
+	SCB = 3,  /* secondary channel below */
+};
+u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset);
+u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset);
+u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode, u8 new_ch, u8 ch_switch_cnt);
+u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset);
+u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl, u8 flags, u16 reason, u16 precedence);
+
+u8 *rtw_get_ie(u8*pbuf, sint index, sint *len, sint limit);
+u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, uint *ielen);
+int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len);
+
+void rtw_set_supported_rate(u8* SupportedRates, uint mode) ;
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+int rtw_get_wpa_cipher_suite(u8 *s);
+int rtw_get_wpa2_cipher_suite(u8 *s);
+int rtw_get_wapi_ie(u8 *in_ie,uint in_len,u8 *wapi_ie,u16 *wapi_len);
+int rtw_parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
+int rtw_parse_wpa2_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
+
+int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len);
+
+u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
+u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, u8 frame_type);
+u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_content, uint *len_content);
+
+/**
+ * for_each_ie - iterate over continuous IEs
+ * @ie:
+ * @buf:
+ * @buf_len:
+ */
+#define for_each_ie(ie, buf, buf_len) \
+	for (ie = (void*)buf; (((u8*)ie) - ((u8*)buf) + 1) < buf_len; ie = (void*)(((u8*)ie) + *(((u8*)ie)+1) + 2))
+
+void dump_ies(void *sel, u8 *buf, u32 buf_len);
+
+#ifdef CONFIG_80211N_HT
+void dump_ht_cap_ie_content(void *sel, u8 *buf, u32 buf_len);
+#endif
+
+void dump_wps_ie(void *sel, u8 *ie, u32 ie_len);
+
+void rtw_ies_get_chbw(u8 *ies, int ies_len, u8 *ch, u8 *bw, u8 *offset);
+
+void rtw_bss_get_chbw(WLAN_BSSID_EX *bss, u8 *ch, u8 *bw, u8 *offset);
+
+bool rtw_is_chbw_grouped(u8 ch_a, u8 bw_a, u8 offset_a
+	, u8 ch_b, u8 bw_b, u8 offset_b);
+void rtw_sync_chbw(u8 *req_ch, u8 *req_bw, u8 *req_offset
+	, u8 *g_ch, u8 *g_bw, u8 *g_offset);
+
+#ifdef CONFIG_P2P
+u32 rtw_get_p2p_merged_ies_len(u8 *in_ie, u32 in_len);
+int rtw_p2p_merge_ies(u8 *in_ie, u32 in_len, u8 *merge_ie);
+void dump_p2p_ie(void *sel, u8 *ie, u32 ie_len);
+u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen);
+u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_content, uint *len_content);
+u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr);
+uint rtw_del_p2p_ie(u8 *ies, uint ies_len_ori, const char *msg);
+uint rtw_del_p2p_attr(u8 *ie, uint ielen_ori, u8 attr_id);
+u8 *rtw_bss_ex_get_p2p_ie(WLAN_BSSID_EX *bss_ex, u8 *p2p_ie, uint *p2p_ielen);
+void rtw_bss_ex_del_p2p_ie(WLAN_BSSID_EX *bss_ex);
+void rtw_bss_ex_del_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);
+#endif
+
+#ifdef CONFIG_WFD
+void dump_wfd_ie(void *sel, u8 *ie, u32 ie_len);
+u8 *rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
+u8 *rtw_get_wfd_attr(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *buf_content, uint *len_content);
+uint rtw_del_wfd_ie(u8 *ies, uint ies_len_ori, const char *msg);
+uint rtw_del_wfd_attr(u8 *ie, uint ielen_ori, u8 attr_id);
+u8 *rtw_bss_ex_get_wfd_ie(WLAN_BSSID_EX *bss_ex, u8 *wfd_ie, uint *wfd_ielen);
+void rtw_bss_ex_del_wfd_ie(WLAN_BSSID_EX *bss_ex);
+void rtw_bss_ex_del_wfd_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);
+#endif /* CONFIG_WFD */
+
+uint	rtw_get_rateset_len(u8	*rateset);
+
+struct registry_priv;
+int rtw_generate_ie(struct registry_priv *pregistrypriv);
+
+int rtw_get_bit_value_from_ieee_value(u8 val);
+
+uint	rtw_is_cckrates_included(u8 *rate);
+
+uint	rtw_is_cckratesonly_included(u8 *rate);
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);
+
+void rtw_get_bcn_info(struct wlan_network *pnetwork);
+
+u8 rtw_check_invalid_mac_address(u8 *mac_addr, u8 check_local_bit);
+void rtw_macaddr_cfg(struct device *dev, u8 *out, const u8 *hw_mac_addr);
+
+u16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI, unsigned char * MCS_rate);
+u8	rtw_ht_mcsset_to_nss(u8 *supp_mcs_set);
+
+int rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8* category, u8 *action);
+const char *action_public_str(u8 action);
+
+u8 key_2char2num(u8 hch, u8 lch);
+u8 str_2char2num(u8 hch, u8 lch);
+void macstr2num(u8 *dst, u8 *src);
+u8 convert_ip_addr(u8 hch, u8 mch, u8 lch);
+int wifirate2_ratetbl_inx(unsigned char rate);
+
+#endif /* IEEE80211_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/ieee80211_ext.h b/drivers/net/wireless/realtek/rtl8723cs/include/ieee80211_ext.h
new file mode 100644
index 000000000..218fbd611
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/ieee80211_ext.h
@@ -0,0 +1,477 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_EXT_H
+#define __IEEE80211_EXT_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WPA_PROTO_WPA BIT(0)
+#define WPA_PROTO_RSN BIT(1)
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+
+
+#define WPA_CAPABILITY_PREAUTH BIT(0)
+#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
+#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)
+
+
+#define PMKID_LEN 16
+
+
+#ifdef PLATFORM_LINUX
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct wme_ac_parameter {
+#if defined(CONFIG_LITTLE_ENDIAN)
+	/* byte 1 */
+	u8 	aifsn:4,
+		acm:1,
+	 	aci:2,
+	 	reserved:1;
+
+	/* byte 2 */
+	u8 	eCWmin:4,
+	 	eCWmax:4;
+#elif defined(CONFIG_BIG_ENDIAN)
+	/* byte 1 */
+	u8 	reserved:1,
+	 	aci:2,
+	 	acm:1,
+	 	aifsn:4;
+
+	/* byte 2 */
+	u8 	eCWmax:4,
+	 	eCWmin:4;
+#else
+#error	"Please fix <endian.h>"
+#endif
+
+	/* bytes 3 & 4 */
+	u16 txopLimit;
+} __attribute__ ((packed));
+
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
+	u8 reserved;
+	struct wme_ac_parameter ac[4];
+
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+};
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+};
+
+#pragma pack()
+
+#endif
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((u8 *) (a), (val))
+//#define RSN_SELECTOR_PUT(a, val) WPA_PUT_LE32((u8 *) (a), (val))
+
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       WLAN_ACTION_SM_PS = 1,
+       WLAN_ACTION_PSPM = 2,
+       WLAN_ACTION_PCO_PHASE = 3,
+       WLAN_ACTION_MIMO_CSI_MX = 4,
+       WLAN_ACTION_MIMO_NONCP_BF = 5,
+       WLAN_ACTION_MIMP_CP_BF = 6,
+       WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+#ifdef PLATFORM_LINUX
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  __attribute__ ((packed)) auth;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) reassoc_req;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) disassoc;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  __attribute__ ((packed)) beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_req;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) wme_action;
+#if 0
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  __attribute__ ((packed)) chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  __attribute__ ((packed)) measurement;
+#endif
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  __attribute__ ((packed)) addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  __attribute__ ((packed)) addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  __attribute__ ((packed)) delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  __attribute__ ((packed)) plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) mesh_action;
+			} __attribute__ ((packed)) u;
+		}  __attribute__ ((packed)) action;
+	} __attribute__ ((packed)) u;
+}__attribute__ ((packed));
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  auth;
+		struct {
+			u16 reason_code;
+		}  deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  reassoc_req;
+		struct {
+			u16 reason_code;
+		}  disassoc;
+#if 0
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  probe_req;
+
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  probe_resp;
+#endif
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  wme_action;
+/*
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  measurement;
+*/
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  mesh_action;
+			} u;
+		}  action;
+	} u;
+} ;
+
+#pragma pack()
+
+#endif
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/if_ether.h b/drivers/net/wireless/realtek/rtl8723cs/include/if_ether.h
new file mode 100644
index 000000000..b0c69822a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/if_ether.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr
+{
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+};
+
+struct _vlan {
+   unsigned short       h_vlan_TCI;                // Encapsulates priority and VLAN ID
+   unsigned short       h_vlan_encapsulated_proto;
+};
+
+
+
+#define get_vlan_id(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI))>>13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short )pvlan->h_vlan_encapsulated_proto))
+
+
+#endif	/* _LINUX_IF_ETHER_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/ip.h b/drivers/net/wireless/realtek/rtl8723cs/include/ip.h
new file mode 100644
index 000000000..d77c05a2e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/ip.h
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+
+/* SOL_IP socket options */
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 |IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
+#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 |IPOPT_CONTROL)
+#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+
+   REASONS: it is clear that nobody used them because:
+   - MAX_ROUTES value was wrong.
+   - "struct route" was wrong.
+   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+#ifdef PLATFORM_LINUX
+
+struct ip_options {
+  __u32		faddr;				/* Saved first hop address */
+  unsigned char	optlen;
+  unsigned char srr;
+  unsigned char rr;
+  unsigned char ts;
+  unsigned char is_setbyuser:1,			/* Set by setsockopt?			*/
+                is_data:1,			/* Options in __data, rather than skb	*/
+                is_strictroute:1,		/* Strict source route			*/
+                srr_is_hit:1,			/* Packet destination addr was our one	*/
+                is_changed:1,			/* IP checksum more not valid		*/
+                rr_needaddr:1,			/* Need to record addr of outgoing dev	*/
+                ts_needtime:1,			/* Need to record timestamp		*/
+                ts_needaddr:1;			/* Need to record addr of outgoing dev  */
+  unsigned char router_alert;
+  unsigned char __pad1;
+  unsigned char __pad2;
+  unsigned char __data[0];
+};
+
+#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
+#endif
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+#endif	/* _LINUX_IP_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/linux/wireless.h b/drivers/net/wireless/realtek/rtl8723cs/include/linux/wireless.h
new file mode 100644
index 000000000..d79caeb59
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/linux/wireless.h
@@ -0,0 +1,97 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/***************************** INCLUDES *****************************/
+
+#if 0
+#include <linux/types.h>		/* for __u* and __s* typedefs */
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+#else
+#define __user
+//typedef uint16_t	__u16;
+#include <sys/socket.h>			/* for "struct sockaddr" et al	*/
+#include <net/if.h>			/* for IFNAMSIZ and co... */
+#endif
+
+/****************************** TYPES ******************************/
+#ifdef CONFIG_COMPAT
+struct compat_iw_point {
+         compat_caddr_t pointer;
+         __u16 length;
+         __u16 flags;
+};
+#endif
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+#endif	/* _LINUX_WIRELESS_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/mlme_osdep.h b/drivers/net/wireless/realtek/rtl8723cs/include/mlme_osdep.h
new file mode 100644
index 000000000..9bc5eb685
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/mlme_osdep.h
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+
+#if defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL)
+extern int time_after(u32 now, u32 old);
+#endif
+
+extern void rtw_init_mlme_timer(_adapter *padapter);
+extern void rtw_os_indicate_disconnect( _adapter *adapter );
+extern void rtw_os_indicate_connect( _adapter *adapter );
+void rtw_os_indicate_scan_done( _adapter *padapter, bool aborted);
+extern void rtw_report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie);
+
+void rtw_reset_securitypriv( _adapter *adapter );
+
+#endif	//_MLME_OSDEP_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/mp_custom_oid.h b/drivers/net/wireless/realtek/rtl8723cs/include/mp_custom_oid.h
new file mode 100644
index 000000000..12153a2fc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/mp_custom_oid.h
@@ -0,0 +1,354 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+// by Owen
+// 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
+// 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
+// 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility
+
+//
+
+// by Owen for Production Kit
+// For Production Kit with Agilent Equipments
+// in order to make our custom oids hopefully somewhat unique
+// we will use 0xFF (indicating implementation specific OID)
+//               81(first byte of non zero Realtek unique identifier)
+//               80 (second byte of non zero Realtek unique identifier)
+//               XX (the custom OID number - providing 255 possible custom oids)
+
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST    			0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+// added by Owen on 04/08/03 for Cameo's request
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+//
+
+//Sean
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+
+//========================================================================
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+//========================================================================
+
+
+// by Owen for RTL8185 Phy Status Report Utility
+#define OID_RT_UTILITY_FALSE_ALARM_COUNTERS				0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE				0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER				0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS					0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS			0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS	0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS			0xFF818586
+//
+
+// by Owen on 03/09/19-03/09/22 for RTL8185
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+//
+
+#define OID_RT_GET_CONNECT_STATE                	0xFF030001
+#define OID_RT_RESCAN	                        	0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE                 	0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY               	0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A//S
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B//S
+
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+
+// by Owen on 03/31/03 for Cameo's request
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+//
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+
+// For Netgear request. 2005.01.13, by rcnjko.
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+// For Netgear request. 2005.02.17, by rcnjko.
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+// For AZ project. 2005.06.27, by rcnjko.
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+
+// Vincent 8185MP
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+
+//Andy TEST
+//#define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1
+//#define OID_RT_PRO_READ_REGISTRY			0xFF0111C2
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+
+
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+
+// AP OID
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304	// Determine if driver supports AP mode. 2004.08.27, by rcnjko.
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	// Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko.
+
+// 8187MP. 2004.09.06, by rcnjko.
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+
+// Meeting House. added by Annie, 2005-07-20.
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+
+//8711 MP OID added 20051230.
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100//S
+
+#define OID_RT_PRO_READ_REGISTER			0xFF871101 //Q
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 //S
+
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 //Q
+#define OID_RT_PRO_BURST_WRITE_REGISTER 		0xFF871104 //S
+
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 //S
+
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106 //Q
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 //S
+
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 //S
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 //Q
+
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A //Q
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B //Q
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C//Q
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D//S
+
+
+//Method 2 for H2C/C2H
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 //S
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 //Q
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 //S
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 //Q
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114//Q
+
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 //Q, S
+
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 //S
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 //Q,S
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 //Q
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 //Q
+
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A //S
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B //Q
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C //S
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D //Q
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E //S
+#define OID_RT_POLL_RX_STATUS				0xFF87111F //Q
+
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 //Q,S
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121//S
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122//S
+#define OID_RT_PRO_READ_TSSI				0xFF871123//S
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124//S
+
+
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 //Q
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 //S
+
+//Method 2 , using workitem
+#define OID_RT_SET_READ_REG				0xFF871181 //S
+#define OID_RT_SET_WRITE_REG				0xFF871182 //S
+#define OID_RT_SET_BURST_READ_REG			0xFF871183 //S
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 //S
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185 //S
+#define OID_RT_SET_READ16_EEPROM			0xFF871186 //S
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 //S
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188 //Q
+
+//For SDIO INTERFACE only
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 //Q, S
+#define OID_RT_PRO_871X_DRV_EXT 			0xFF8711A1
+
+//For USB INTERFACE only
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 //Q, S
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 //S
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 //S
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 //Q
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 //Q
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB //S
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC //S
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 //Q, S
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 //S
+#define OID_RT_PRO_DELE_STA_INFO    			0xFF871202 //S
+#define OID_RT_PRO_QUERY_DR_VARIABLE   			0xFF871203 //Q
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 //Q, S
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205 //Q
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 //S
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 //Q, S
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 //Q
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209 //S
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A //S
+
+#define OID_RT_SET_RX_PACKET_TYPE    			0xFF87120B //S
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C //Q
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D //S
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E //S
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F //S
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 //Q
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 //S
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 //Q
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 //Q
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214 //S
+
+#define OID_RT_GET_POWER_MODE				0xFF871215 //Q
+
+#define OID_RT_PRO_EFUSE				0xFF871216 //Q, S
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217 //Q, S
+
+#endif //#ifndef	__CUSTOM_OID_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/nic_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/nic_spec.h
new file mode 100644
index 000000000..803605323
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/nic_spec.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef __NIC_SPEC_H__
+#define __NIC_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8711_MCTRL_		(0x20000)
+#define RTL8711_UART_		(0x30000)
+#define RTL8711_TIMER_		(0x40000)
+#define RTL8711_FINT_		(0x50000)
+#define RTL8711_HINT_		(0x50000)
+#define RTL8711_GPIO_		(0x60000)
+#define RTL8711_WLANCTRL_	(0x200000)
+#define RTL8711_WLANFF_		(0xe00000)
+#define RTL8711_HCICTRL_	(0x600000)
+#define RTL8711_SYSCFG_		(0x620000)
+#define RTL8711_SYSCTRL_	(0x620000)
+#define RTL8711_MCCTRL_		(0x020000)
+
+
+#include <rtl8711_regdef.h>
+
+#include <rtl8711_bitdef.h>
+
+
+#endif // __RTL8711_SPEC_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/osdep_intf.h b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_intf.h
new file mode 100644
index 000000000..8b8679fa1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_intf.h
@@ -0,0 +1,173 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+
+struct intf_priv {
+
+	u8 *intf_dev;
+	u32	max_iosz; 	//USB2.0: 128, USB1.1: 64, SDIO:64
+	u32	max_xmitsz; //USB2.0: unlimited, SDIO:512
+	u32	max_recvsz; //USB2.0: unlimited, SDIO:512
+
+	volatile u8 *io_rwmem;
+	volatile u8 *allocated_io_rwmem;
+	u32	io_wsz; //unit: 4bytes
+	u32	io_rsz;//unit: 4bytes
+	u8 intf_status;
+
+	void (*_bus_io)(u8 *priv);
+
+/*
+Under Sync. IRP (SDIO/USB)
+A protection mechanism is necessary for the io_rwmem(read/write protocol)
+
+Under Async. IRP (SDIO/USB)
+The protection mechanism is through the pending queue.
+*/
+
+	_mutex ioctl_mutex;
+
+
+#ifdef PLATFORM_LINUX
+	#ifdef CONFIG_USB_HCI
+	// when in USB, IO is through interrupt in/out endpoints
+	struct usb_device 	*udev;
+	PURB	piorw_urb;
+	u8 io_irp_cnt;
+	u8 bio_irp_pending;
+	_sema io_retevt;
+	_timer	io_timer;
+	u8 bio_irp_timeout;
+	u8 bio_timer_cancel;
+	#endif
+#endif
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		// below is for io_rwmem...
+		PMDL pmdl;
+		PSDBUS_REQUEST_PACKET  sdrp;
+		PSDBUS_REQUEST_PACKET  recv_sdrp;
+		PSDBUS_REQUEST_PACKET  xmit_sdrp;
+
+			PIRP		piorw_irp;
+
+	#endif
+	#ifdef CONFIG_USB_HCI
+		PURB	piorw_urb;
+		PIRP		piorw_irp;
+		u8 io_irp_cnt;
+		u8 bio_irp_pending;
+		_sema io_retevt;
+	#endif
+#endif
+
+};
+
+
+#ifdef CONFIG_R871X_TEST
+int rtw_start_pseudo_adhoc(_adapter *padapter);
+int rtw_stop_pseudo_adhoc(_adapter *padapter);
+#endif
+
+struct dvobj_priv *devobj_init(void);
+void devobj_deinit(struct dvobj_priv *pdvobj);
+
+u8 rtw_init_drv_sw(_adapter *padapter);
+u8 rtw_free_drv_sw(_adapter *padapter);
+u8 rtw_reset_drv_sw(_adapter *padapter);
+void rtw_dev_unload(PADAPTER padapter);
+
+u32 rtw_start_drv_threads(_adapter *padapter);
+void rtw_stop_drv_threads (_adapter *padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void rtw_cancel_dynamic_chk_timer(_adapter *padapter);
+#endif
+void rtw_cancel_all_timer(_adapter *padapter);
+
+uint loadparam(_adapter *adapter);
+
+#ifdef PLATFORM_LINUX
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname);
+struct net_device *rtw_init_netdev(_adapter *padapter);
+
+void rtw_os_ndev_free(_adapter *adapter);
+int rtw_os_ndev_init(_adapter *adapter, char *name);
+void rtw_os_ndev_deinit(_adapter *adapter);
+void rtw_os_ndevs_unregister(struct dvobj_priv *dvobj);
+int rtw_os_ndevs_init(struct dvobj_priv *dvobj);
+void rtw_os_ndevs_deinit(struct dvobj_priv *dvobj);
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+u16 rtw_recv_select_queue(struct sk_buff *skb);
+#endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
+
+int rtw_ndev_notifier_register(void);
+void rtw_ndev_notifier_unregister(void);
+
+#include "../os_dep/linux/rtw_proc.h"
+
+#ifdef CONFIG_IOCTL_CFG80211
+#include "../os_dep/linux/ioctl_cfg80211.h"
+#endif //CONFIG_IOCTL_CFG80211
+
+#endif //PLATFORM_LINUX
+
+
+#ifdef PLATFORM_FREEBSD
+extern int rtw_ioctl(struct ifnet * ifp, u_long cmd, caddr_t data);
+#endif
+
+void rtw_ips_dev_unload(_adapter *padapter);
+
+#ifdef CONFIG_IPS
+int rtw_ips_pwr_up(_adapter *padapter);
+void rtw_ips_pwr_down(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+struct _io_ops;
+_adapter *rtw_drv_if2_init(_adapter *primary_padapter, void (*set_intf_ops)(_adapter *primary_padapter,struct _io_ops *pops));
+void rtw_drv_if2_free(_adapter *if2);
+void rtw_drv_if2_stop(_adapter *if2);
+#ifdef CONFIG_MULTI_VIR_IFACES
+struct dvobj_priv;
+_adapter *rtw_drv_add_vir_if(_adapter *primary_padapter, void (*set_intf_ops)(_adapter *primary_padapter,struct _io_ops *pops));
+void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj);
+void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj);
+#endif //CONFIG_MULTI_VIR_IFACES
+#endif
+
+void rtw_ndev_destructor(_nic_hdl ndev);
+
+#ifdef CONFIG_ARP_KEEP_ALIVE
+int	rtw_gw_addr_query(_adapter *padapter);
+#endif
+
+int rtw_suspend_common(_adapter *padapter);
+int rtw_resume_common(_adapter *padapter);
+
+#endif	//_OSDEP_INTF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service.h b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service.h
new file mode 100644
index 000000000..af66a3335
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service.h
@@ -0,0 +1,625 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+
+#define _FAIL		0
+#define _SUCCESS	1
+#define RTW_RX_HANDLED 2
+//#define RTW_STATUS_TIMEDOUT -110
+
+#undef _TRUE
+#define _TRUE		1
+
+#undef _FALSE
+#define _FALSE		0
+
+
+#ifdef PLATFORM_FREEBSD
+#include <osdep_service_bsd.h>
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <osdep_service_linux.h>
+#endif
+
+#ifdef PLATFORM_OS_XP
+#include <osdep_service_xp.h>
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <osdep_service_ce.h>
+#endif
+
+#define RTW_TIMER_HDL_NAME(name) rtw_##name##_timer_hdl
+#define RTW_DECLARE_TIMER_HDL(name) void RTW_TIMER_HDL_NAME(name)(RTW_TIMER_HDL_ARGS)
+
+//#include <rtw_byteorder.h>
+
+#ifndef BIT
+	#define BIT(x)	( 1 << (x))
+#endif
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+#define BIT32	0x0100000000
+#define BIT33	0x0200000000
+#define BIT34	0x0400000000
+#define BIT35	0x0800000000
+#define BIT36	0x1000000000
+
+extern int RTW_STATUS_CODE(int error_code);
+
+#ifndef RTK_DMP_PLATFORM
+#define CONFIG_USE_VMALLOC
+#endif
+
+/* flags used for rtw_mstat_update() */
+enum mstat_f {
+	/* type: 0x00ff */
+	MSTAT_TYPE_VIR = 0x00,
+	MSTAT_TYPE_PHY= 0x01,
+	MSTAT_TYPE_SKB = 0x02,
+	MSTAT_TYPE_USB = 0x03,
+	MSTAT_TYPE_MAX = 0x04,
+
+	/* func: 0xff00 */
+	MSTAT_FUNC_UNSPECIFIED = 0x00<<8,
+	MSTAT_FUNC_IO = 0x01<<8,
+	MSTAT_FUNC_TX_IO = 0x02<<8,
+	MSTAT_FUNC_RX_IO = 0x03<<8,
+	MSTAT_FUNC_TX = 0x04<<8,
+	MSTAT_FUNC_RX = 0x05<<8,
+	MSTAT_FUNC_CFG_VENDOR = 0x06<<8,
+	MSTAT_FUNC_MAX = 0x07<<8,
+};
+
+#define mstat_tf_idx(flags) ((flags)&0xff)
+#define mstat_ff_idx(flags) (((flags)&0xff00) >> 8)
+
+typedef enum mstat_status{
+	MSTAT_ALLOC_SUCCESS = 0,
+	MSTAT_ALLOC_FAIL,
+	MSTAT_FREE
+} MSTAT_STATUS;
+
+#ifdef DBG_MEM_ALLOC
+void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 sz);
+void rtw_mstat_dump (void *sel);
+u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_vmfree(u8 *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);
+u8* dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+u8* dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_mfree(u8 *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);
+
+struct sk_buff * dbg_rtw_skb_alloc(unsigned int size, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_skb_free(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
+struct sk_buff *dbg_rtw_skb_copy(const struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
+struct sk_buff *dbg_rtw_skb_clone(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
+int dbg_rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
+void dbg_rtw_skb_queue_purge(struct sk_buff_head *list, enum mstat_f flags, const char *func, int line);
+#ifdef CONFIG_USB_HCI
+void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma, const enum mstat_f flags, const char *func, const int line);
+#endif /* CONFIG_USB_HCI */
+
+#ifdef CONFIG_USE_VMALLOC
+#define rtw_vmalloc(sz)			dbg_rtw_vmalloc((sz), MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
+#define rtw_zvmalloc(sz)			dbg_rtw_zvmalloc((sz), MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
+#define rtw_vmfree(pbuf, sz)		dbg_rtw_vmfree((pbuf), (sz), MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
+#define rtw_vmalloc_f(sz, mstat_f)			dbg_rtw_vmalloc((sz), ((mstat_f)&0xff00)|MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
+#define rtw_zvmalloc_f(sz, mstat_f)		dbg_rtw_zvmalloc((sz), ((mstat_f)&0xff00)|MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	dbg_rtw_vmfree((pbuf), (sz), ((mstat_f)&0xff00)|MSTAT_TYPE_VIR, __FUNCTION__, __LINE__)
+#else /* CONFIG_USE_VMALLOC */
+#define rtw_vmalloc(sz)			dbg_rtw_malloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_zvmalloc(sz)			dbg_rtw_zmalloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_vmfree(pbuf, sz)		dbg_rtw_mfree((pbuf), (sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_vmalloc_f(sz, mstat_f)			dbg_rtw_malloc((sz), ((mstat_f)&0xff00)|MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_zvmalloc_f(sz, mstat_f)		dbg_rtw_zmalloc((sz), ((mstat_f)&0xff00)|MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	dbg_rtw_mfree((pbuf), (sz), ((mstat_f)&0xff00)|MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#endif /* CONFIG_USE_VMALLOC */
+#define rtw_malloc(sz)			dbg_rtw_malloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_zmalloc(sz)			dbg_rtw_zmalloc((sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_mfree(pbuf, sz)		dbg_rtw_mfree((pbuf), (sz), MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_malloc_f(sz, mstat_f)			dbg_rtw_malloc((sz), ((mstat_f)&0xff00)|MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_zmalloc_f(sz, mstat_f)			dbg_rtw_zmalloc((sz), ((mstat_f)&0xff00)|MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+#define rtw_mfree_f(pbuf, sz, mstat_f)		dbg_rtw_mfree((pbuf), (sz), ((mstat_f)&0xff00)|MSTAT_TYPE_PHY, __FUNCTION__, __LINE__)
+
+#define rtw_skb_alloc(size)	dbg_rtw_skb_alloc((size), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_free(skb)	dbg_rtw_skb_free((skb), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_alloc_f(size, mstat_f)	dbg_rtw_skb_alloc((size), ((mstat_f)&0xff00)|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_free_f(skb, mstat_f)	dbg_rtw_skb_free((skb), ((mstat_f)&0xff00)|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_copy(skb)	dbg_rtw_skb_copy((skb), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_clone(skb)	dbg_rtw_skb_clone((skb), MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_copy_f(skb, mstat_f)	dbg_rtw_skb_copy((skb), ((mstat_f)&0xff00)|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_clone_f(skb, mstat_f)	dbg_rtw_skb_clone((skb), ((mstat_f)&0xff00)|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_netif_rx(ndev, skb)	dbg_rtw_netif_rx(ndev, skb, MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#define rtw_skb_queue_purge(sk_buff_head) dbg_rtw_skb_queue_purge(sk_buff_head, MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#ifdef CONFIG_USB_HCI
+#define rtw_usb_buffer_alloc(dev, size, dma)		dbg_rtw_usb_buffer_alloc((dev), (size), (dma), MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
+#define rtw_usb_buffer_free(dev, size, addr, dma)	dbg_rtw_usb_buffer_free((dev), (size), (addr), (dma), MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
+#define rtw_usb_buffer_alloc_f(dev, size, dma, mstat_f)			dbg_rtw_usb_buffer_alloc((dev), (size), (dma), ((mstat_f)&0xff00)|MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
+#define rtw_usb_buffer_free_f(dev, size, addr, dma, mstat_f)	dbg_rtw_usb_buffer_free((dev), (size), (addr), (dma), ((mstat_f)&0xff00)|MSTAT_TYPE_USB, __FUNCTION__, __LINE__)
+#endif /* CONFIG_USB_HCI */
+
+#else /* DBG_MEM_ALLOC */
+#define rtw_mstat_update(flag, status, sz) do {} while(0)
+#define rtw_mstat_dump(sel) do {} while(0)
+u8*	_rtw_vmalloc(u32 sz);
+u8*	_rtw_zvmalloc(u32 sz);
+void	_rtw_vmfree(u8 *pbuf, u32 sz);
+u8*	_rtw_zmalloc(u32 sz);
+u8*	_rtw_malloc(u32 sz);
+void	_rtw_mfree(u8 *pbuf, u32 sz);
+
+struct sk_buff *_rtw_skb_alloc(u32 sz);
+void _rtw_skb_free(struct sk_buff *skb);
+struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb);
+struct sk_buff *_rtw_skb_clone(struct sk_buff *skb);
+int _rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb);
+void _rtw_skb_queue_purge(struct sk_buff_head *list);
+
+#ifdef CONFIG_USB_HCI
+void *_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma);
+void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma);
+#endif /* CONFIG_USB_HCI */
+
+#ifdef CONFIG_USE_VMALLOC
+#define rtw_vmalloc(sz)			_rtw_vmalloc((sz))
+#define rtw_zvmalloc(sz)			_rtw_zvmalloc((sz))
+#define rtw_vmfree(pbuf, sz)		_rtw_vmfree((pbuf), (sz))
+#define rtw_vmalloc_f(sz, mstat_f)			_rtw_vmalloc((sz))
+#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zvmalloc((sz))
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_vmfree((pbuf), (sz))
+#else /* CONFIG_USE_VMALLOC */
+#define rtw_vmalloc(sz)			_rtw_malloc((sz))
+#define rtw_zvmalloc(sz)			_rtw_zmalloc((sz))
+#define rtw_vmfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
+#define rtw_vmalloc_f(sz, mstat_f)			_rtw_malloc((sz))
+#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zmalloc((sz))
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_mfree((pbuf), (sz))
+#endif /* CONFIG_USE_VMALLOC */
+#define rtw_malloc(sz)			_rtw_malloc((sz))
+#define rtw_zmalloc(sz)			_rtw_zmalloc((sz))
+#define rtw_mfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
+#define rtw_malloc_f(sz, mstat_f)			_rtw_malloc((sz))
+#define rtw_zmalloc_f(sz, mstat_f)			_rtw_zmalloc((sz))
+#define rtw_mfree_f(pbuf, sz, mstat_f)		_rtw_mfree((pbuf), (sz))
+
+#define rtw_skb_alloc(size) _rtw_skb_alloc((size))
+#define rtw_skb_free(skb) _rtw_skb_free((skb))
+#define rtw_skb_alloc_f(size, mstat_f)	_rtw_skb_alloc((size))
+#define rtw_skb_free_f(skb, mstat_f)	_rtw_skb_free((skb))
+#define rtw_skb_copy(skb)	_rtw_skb_copy((skb))
+#define rtw_skb_clone(skb)	_rtw_skb_clone((skb))
+#define rtw_skb_copy_f(skb, mstat_f)	_rtw_skb_copy((skb))
+#define rtw_skb_clone_f(skb, mstat_f)	_rtw_skb_clone((skb))
+#define rtw_netif_rx(ndev, skb) _rtw_netif_rx(ndev, skb)
+#define rtw_skb_queue_purge(sk_buff_head) _rtw_skb_queue_purge(sk_buff_head)
+#ifdef CONFIG_USB_HCI
+#define rtw_usb_buffer_alloc(dev, size, dma) _rtw_usb_buffer_alloc((dev), (size), (dma))
+#define rtw_usb_buffer_free(dev, size, addr, dma) _rtw_usb_buffer_free((dev), (size), (addr), (dma))
+#define rtw_usb_buffer_alloc_f(dev, size, dma, mstat_f) _rtw_usb_buffer_alloc((dev), (size), (dma))
+#define rtw_usb_buffer_free_f(dev, size, addr, dma, mstat_f) _rtw_usb_buffer_free((dev), (size), (addr), (dma))
+#endif /* CONFIG_USB_HCI */
+#endif /* DBG_MEM_ALLOC */
+
+extern void*	rtw_malloc2d(int h, int w, size_t size);
+extern void	rtw_mfree2d(void *pbuf, int h, int w, int size);
+
+extern void	_rtw_memcpy(void *dec, const void *sour, u32 sz);
+extern void _rtw_memmove(void *dst, const void *src, u32 sz);
+extern int	_rtw_memcmp(void *dst, void *src, u32 sz);
+extern void	_rtw_memset(void *pbuf, int c, u32 sz);
+
+extern void	_rtw_init_listhead(_list *list);
+extern u32	rtw_is_list_empty(_list *phead);
+extern void	rtw_list_insert_head(_list *plist, _list *phead);
+extern void	rtw_list_insert_tail(_list *plist, _list *phead);
+#ifndef PLATFORM_FREEBSD
+extern void	rtw_list_delete(_list *plist);
+#endif //PLATFORM_FREEBSD
+
+extern void	_rtw_init_sema(_sema *sema, int init_val);
+extern void	_rtw_free_sema(_sema	*sema);
+extern void	_rtw_up_sema(_sema	*sema);
+extern u32	_rtw_down_sema(_sema *sema);
+extern void	_rtw_mutex_init(_mutex *pmutex);
+extern void	_rtw_mutex_free(_mutex *pmutex);
+#ifndef PLATFORM_FREEBSD
+extern void	_rtw_spinlock_init(_lock *plock);
+#endif //PLATFORM_FREEBSD
+extern void	_rtw_spinlock_free(_lock *plock);
+extern void	_rtw_spinlock(_lock	*plock);
+extern void	_rtw_spinunlock(_lock	*plock);
+extern void	_rtw_spinlock_ex(_lock	*plock);
+extern void	_rtw_spinunlock_ex(_lock	*plock);
+
+extern void	_rtw_init_queue(_queue *pqueue);
+extern void _rtw_deinit_queue(_queue *pqueue);
+extern u32	_rtw_queue_empty(_queue	*pqueue);
+extern u32	rtw_end_of_queue_search(_list *queue, _list *pelement);
+
+extern u32	rtw_get_current_time(void);
+extern u32	rtw_systime_to_ms(u32 systime);
+extern u32	rtw_ms_to_systime(u32 ms);
+extern s32	rtw_get_passing_time_ms(u32 start);
+extern s32	rtw_get_time_interval_ms(u32 start, u32 end);
+
+extern void	rtw_sleep_schedulable(int ms);
+
+extern void	rtw_msleep_os(int ms);
+extern void	rtw_usleep_os(int us);
+
+extern u32 	rtw_atoi(u8* s);
+
+#ifdef DBG_DELAY_OS
+#define rtw_mdelay_os(ms) _rtw_mdelay_os((ms), __FUNCTION__, __LINE__)
+#define rtw_udelay_os(ms) _rtw_udelay_os((ms), __FUNCTION__, __LINE__)
+extern void _rtw_mdelay_os(int ms, const char *func, const int line);
+extern void _rtw_udelay_os(int us, const char *func, const int line);
+#else
+extern void	rtw_mdelay_os(int ms);
+extern void	rtw_udelay_os(int us);
+#endif
+
+extern void rtw_yield_os(void);
+
+__inline static unsigned char _cancel_timer_ex(_timer *ptimer)
+{
+#ifdef PLATFORM_LINUX
+	return del_timer_sync(ptimer);
+#endif
+#ifdef PLATFORM_FREEBSD
+	_cancel_timer(ptimer,0);
+	return 0;
+#endif
+#ifdef PLATFORM_WINDOWS
+	u8 bcancelled;
+
+	_cancel_timer(ptimer, &bcancelled);
+
+	return bcancelled;
+#endif
+}
+
+static __inline void thread_enter(char *name)
+{
+#ifdef PLATFORM_LINUX
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
+	daemonize("%s", name);
+	#endif
+	allow_signal(SIGTERM);
+#endif
+#ifdef PLATFORM_FREEBSD
+	printf("%s", "RTKTHREAD_enter");
+#endif
+}
+
+__inline static void flush_signals_thread(void)
+{
+#ifdef PLATFORM_LINUX
+	if (signal_pending (current))
+	{
+		flush_signals(current);
+	}
+#endif
+}
+
+__inline static _OS_STATUS res_to_status(sint res)
+{
+
+#if defined (PLATFORM_LINUX) || defined (PLATFORM_MPIXEL) || defined (PLATFORM_FREEBSD)
+	return res;
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+	if (res == _SUCCESS)
+		return NDIS_STATUS_SUCCESS;
+	else
+		return NDIS_STATUS_FAILURE;
+
+#endif
+
+}
+
+__inline static void rtw_dump_stack(void)
+{
+#ifdef PLATFORM_LINUX
+	dump_stack();
+#endif
+}
+
+#ifdef PLATFORM_LINUX
+#define rtw_warn_on(condition) WARN_ON(condition)
+#else
+#define rtw_warn_on(condition) do {} while (0)
+#endif
+
+__inline static int rtw_bug_check(void *parg1, void *parg2, void *parg3, void *parg4)
+{
+	int ret = _TRUE;
+
+#ifdef PLATFORM_WINDOWS
+	if ( ((uint)parg1) <= 0x7fffffff ||
+	 	((uint)parg2) <= 0x7fffffff ||
+	 	((uint)parg3) <= 0x7fffffff ||
+	 	((uint)parg4) <= 0x7fffffff)
+	{
+		ret = _FALSE;
+		KeBugCheckEx(0x87110000, (ULONG_PTR)parg1, (ULONG_PTR)parg2, (ULONG_PTR)parg3, (ULONG_PTR)parg4);
+	}
+#endif
+
+	return ret;
+
+}
+
+#define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0: 1)) << 2)
+
+__inline static u32 _RND4(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
+
+	return val;
+
+}
+
+__inline static u32 _RND8(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
+
+	return val;
+
+}
+
+__inline static u32 _RND128(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
+
+	return val;
+
+}
+
+__inline static u32 _RND256(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
+
+	return val;
+
+}
+
+__inline static u32 _RND512(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
+
+	return val;
+
+}
+
+__inline static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1) break;
+
+	return i;
+}
+
+#define rtw_min(a, b) ((a>b)?b:a)
+#define rtw_is_range_a_in_b(hi_a, lo_a, hi_b, lo_b) (((hi_a) <= (hi_b)) && ((lo_a) >= (lo_b)))
+#define rtw_is_range_overlap(hi_a, lo_a, hi_b, lo_b) (((hi_a) > (lo_b)) && ((lo_a) < (hi_b)))
+
+#ifndef MAC_FMT
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#endif
+#ifndef MAC_ARG
+#define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
+#endif
+
+
+extern void rtw_suspend_lock_init(void);
+extern void rtw_suspend_lock_uninit(void);
+extern void rtw_lock_suspend(void);
+extern void rtw_unlock_suspend(void);
+extern void rtw_lock_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_ext_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_rx_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_traffic_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_resume_scan_timeout(u32 timeout_ms);
+extern void rtw_resume_lock_suspend(void);
+extern void rtw_resume_unlock_suspend(void);
+#ifdef CONFIG_AP_WOWLAN
+extern void rtw_softap_lock_suspend(void);
+extern void rtw_softap_unlock_suspend(void);
+#endif
+
+extern void ATOMIC_SET(ATOMIC_T *v, int i);
+extern int ATOMIC_READ(ATOMIC_T *v);
+extern void ATOMIC_ADD(ATOMIC_T *v, int i);
+extern void ATOMIC_SUB(ATOMIC_T *v, int i);
+extern void ATOMIC_INC(ATOMIC_T *v);
+extern void ATOMIC_DEC(ATOMIC_T *v);
+extern int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
+extern int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
+extern int ATOMIC_INC_RETURN(ATOMIC_T *v);
+extern int ATOMIC_DEC_RETURN(ATOMIC_T *v);
+
+//File operation APIs, just for linux now
+extern int rtw_is_file_readable(char *path);
+extern int rtw_retrieve_from_file(char *path, u8 *buf, u32 sz);
+extern int rtw_store_to_file(char *path, u8* buf, u32 sz);
+
+
+#ifndef PLATFORM_FREEBSD
+extern void rtw_free_netdev(struct net_device * netdev);
+#endif //PLATFORM_FREEBSD
+
+
+extern u64 rtw_modular64(u64 x, u64 y);
+extern u64 rtw_division64(u64 x, u64 y);
+extern u32 rtw_random32(void);
+
+/* Macros for handling unaligned memory accesses */
+
+#define RTW_GET_BE16(a) ((u16) (((a)[0] << 8) | (a)[1]))
+#define RTW_PUT_BE16(a, val)			\
+	do {					\
+		(a)[0] = ((u16) (val)) >> 8;	\
+		(a)[1] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_LE16(a) ((u16) (((a)[1] << 8) | (a)[0]))
+#define RTW_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_BE24(a) ((((u32) (a)[0]) << 16) | (((u32) (a)[1]) << 8) | \
+			 ((u32) (a)[2]))
+#define RTW_PUT_BE24(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[2] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+#define RTW_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_LE32(a) ((((u32) (a)[3]) << 24) | (((u32) (a)[2]) << 16) | \
+			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))
+#define RTW_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE64(a) ((((u64) (a)[0]) << 56) | (((u64) (a)[1]) << 48) | \
+			 (((u64) (a)[2]) << 40) | (((u64) (a)[3]) << 32) | \
+			 (((u64) (a)[4]) << 24) | (((u64) (a)[5]) << 16) | \
+			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))
+#define RTW_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (u8) (((u64) (val)) >> 56);	\
+		(a)[1] = (u8) (((u64) (val)) >> 48);	\
+		(a)[2] = (u8) (((u64) (val)) >> 40);	\
+		(a)[3] = (u8) (((u64) (val)) >> 32);	\
+		(a)[4] = (u8) (((u64) (val)) >> 24);	\
+		(a)[5] = (u8) (((u64) (val)) >> 16);	\
+		(a)[6] = (u8) (((u64) (val)) >> 8);	\
+		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+#define RTW_GET_LE64(a) ((((u64) (a)[7]) << 56) | (((u64) (a)[6]) << 48) | \
+			 (((u64) (a)[5]) << 40) | (((u64) (a)[4]) << 32) | \
+			 (((u64) (a)[3]) << 24) | (((u64) (a)[2]) << 16) | \
+			 (((u64) (a)[1]) << 8) | ((u64) (a)[0]))
+
+void rtw_buf_free(u8 **buf, u32 *buf_len);
+void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len);
+
+struct rtw_cbuf {
+	u32 write;
+	u32 read;
+	u32 size;
+	void *bufs[0];
+};
+
+bool rtw_cbuf_full(struct rtw_cbuf *cbuf);
+bool rtw_cbuf_empty(struct rtw_cbuf *cbuf);
+bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf);
+void *rtw_cbuf_pop(struct rtw_cbuf *cbuf);
+struct rtw_cbuf *rtw_cbuf_alloc(u32 size);
+void rtw_cbuf_free(struct rtw_cbuf *cbuf);
+
+// String handler
+/*
+ * Write formatted output to sized buffer
+ */
+#ifdef PLATFORM_LINUX
+#define rtw_sprintf(buf, size, format, arg...)	snprintf(buf, size, format, ##arg)
+#else // !PLATFORM_LINUX
+#error "NOT DEFINE \"rtw_sprintf\"!!"
+#endif // !PLATFORM_LINUX
+
+#endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_bsd.h b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_bsd.h
new file mode 100644
index 000000000..fdb5a91ef
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_bsd.h
@@ -0,0 +1,749 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_BSD_SERVICE_H_
+#define __OSDEP_BSD_SERVICE_H_
+
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/systm.h>
+#include <sys/param.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/mbuf.h>
+#include <sys/kernel.h>
+#include <sys/socket.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/endian.h>
+#include <sys/kdb.h>
+#include <sys/kthread.h>
+#include <sys/malloc.h>
+#include <sys/time.h>
+#include <machine/atomic.h>
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/rman.h>
+
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/ethernet.h>
+#include <net/if_dl.h>
+#include <net/if_media.h>
+#include <net/if_types.h>
+#include <net/route.h>
+
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_var.h>
+#include <netinet/if_ether.h>
+#include <if_ether.h>
+
+#include <net80211/ieee80211_var.h>
+#include <net80211/ieee80211_regdomain.h>
+#include <net80211/ieee80211_radiotap.h>
+#include <net80211/ieee80211_ratectl.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+#include "usbdevs.h"
+
+#define	USB_DEBUG_VAR rum_debug
+#include <dev/usb/usb_debug.h>
+
+#if 1 //Baron porting from linux, it's all temp solution, needs to check again
+#include <sys/sema.h>
+#include <sys/pcpu.h> /* XXX for PCPU_GET */
+//	typedef struct 	semaphore _sema;
+	typedef struct 	sema _sema;
+//	typedef	spinlock_t	_lock;
+	typedef	struct mtx	_lock;
+	typedef struct mtx 		_mutex;
+	typedef struct timer_list _timer;
+	struct list_head {
+	struct list_head *next, *prev;
+	};
+	struct	__queue	{
+		struct	list_head	queue;
+		_lock	lock;
+	};
+
+	//typedef	struct sk_buff	_pkt;
+	typedef	struct mbuf	_pkt;
+	typedef struct mbuf	_buffer;
+
+	typedef struct	__queue	_queue;
+	typedef struct	list_head	_list;
+	typedef	int	_OS_STATUS;
+	//typedef u32	_irqL;
+	typedef unsigned long _irqL;
+	typedef	struct	ifnet * _nic_hdl;
+
+	typedef pid_t		_thread_hdl_;
+//	typedef struct thread		_thread_hdl_;
+	typedef void		thread_return;
+	typedef void*	thread_context;
+
+	//#define thread_exit() complete_and_exit(NULL, 0)
+
+	#define thread_exit() do{printf("%s", "RTKTHREAD_exit");}while(0)
+
+	typedef void timer_hdl_return;
+	typedef void* timer_hdl_context;
+	typedef struct work_struct _workitem;
+
+#define   KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+/* emulate a modern version */
+#define LINUX_VERSION_CODE KERNEL_VERSION(2, 6, 35)
+
+#define WIRELESS_EXT -1
+#define HZ hz
+#define spin_lock_irqsave mtx_lock_irqsave
+#define spin_lock_bh mtx_lock_irqsave
+#define mtx_lock_irqsave(lock, x) mtx_lock(lock)//{local_irq_save((x)); mtx_lock_spin((lock));}
+//#define IFT_RTW	0xf9 //ifnet allocate type for RTW
+#define free_netdev if_free
+#define LIST_CONTAINOR(ptr, type, member) \
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+#define container_of(p,t,n) (t*)((p)-&(((t*)0)->n))
+/*
+ * Linux timers are emulated using FreeBSD callout functions
+ * (and taskqueue functionality).
+ *
+ * Currently no timer stats functionality.
+ *
+ * See (linux_compat) processes.c
+ *
+ */
+struct timer_list {
+
+        /* FreeBSD callout related fields */
+        struct callout callout;
+
+ 	//timeout function
+        void (*function)(void*);
+	//argument
+	 void *arg;
+
+};
+struct workqueue_struct;
+struct work_struct;
+typedef void (*work_func_t)(struct work_struct *work);
+/* Values for the state of an item of work (work_struct) */
+typedef enum work_state {
+        WORK_STATE_UNSET = 0,
+        WORK_STATE_CALLOUT_PENDING = 1,
+        WORK_STATE_TASK_PENDING = 2,
+        WORK_STATE_WORK_CANCELLED = 3
+} work_state_t;
+
+struct work_struct {
+        struct task task; /* FreeBSD task */
+        work_state_t state; /* the pending or otherwise state of work. */
+        work_func_t func;
+};
+#define spin_unlock_irqrestore mtx_unlock_irqrestore
+#define spin_unlock_bh mtx_unlock_irqrestore
+#define mtx_unlock_irqrestore(lock,x)    mtx_unlock(lock);
+extern void	_rtw_spinlock_init(_lock *plock);
+
+//modify private structure to match freebsd
+#define BITS_PER_LONG 32
+union ktime {
+	s64	tv64;
+#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
+	struct {
+#ifdef __BIG_ENDIAN
+	s32	sec, nsec;
+#else
+	s32	nsec, sec;
+#endif
+	} tv;
+#endif
+};
+#define kmemcheck_bitfield_begin(name)
+#define kmemcheck_bitfield_end(name)
+#define CHECKSUM_NONE 0
+typedef unsigned char *sk_buff_data_t;
+typedef union ktime ktime_t;		/* Kill this */
+
+void rtw_mtx_lock(_lock *plock);
+
+void rtw_mtx_unlock(_lock *plock);
+
+/**
+ *	struct sk_buff - socket buffer
+ *	@next: Next buffer in list
+ *	@prev: Previous buffer in list
+ *	@sk: Socket we are owned by
+ *	@tstamp: Time we arrived
+ *	@dev: Device we arrived on/are leaving by
+ *	@transport_header: Transport layer header
+ *	@network_header: Network layer header
+ *	@mac_header: Link layer header
+ *	@_skb_refdst: destination entry (with norefcount bit)
+ *	@sp: the security path, used for xfrm
+ *	@cb: Control buffer. Free for use by every layer. Put private vars here
+ *	@len: Length of actual data
+ *	@data_len: Data length
+ *	@mac_len: Length of link layer header
+ *	@hdr_len: writable header length of cloned skb
+ *	@csum: Checksum (must include start/offset pair)
+ *	@csum_start: Offset from skb->head where checksumming should start
+ *	@csum_offset: Offset from csum_start where checksum should be stored
+ *	@local_df: allow local fragmentation
+ *	@cloned: Head may be cloned (check refcnt to be sure)
+ *	@nohdr: Payload reference only, must not modify header
+ *	@pkt_type: Packet class
+ *	@fclone: skbuff clone status
+ *	@ip_summed: Driver fed us an IP checksum
+ *	@priority: Packet queueing priority
+ *	@users: User count - see {datagram,tcp}.c
+ *	@protocol: Packet protocol from driver
+ *	@truesize: Buffer size
+ *	@head: Head of buffer
+ *	@data: Data head pointer
+ *	@tail: Tail pointer
+ *	@end: End pointer
+ *	@destructor: Destruct function
+ *	@mark: Generic packet mark
+ *	@nfct: Associated connection, if any
+ *	@ipvs_property: skbuff is owned by ipvs
+ *	@peeked: this packet has been seen already, so stats have been
+ *		done for it, don't do them again
+ *	@nf_trace: netfilter packet trace flag
+ *	@nfctinfo: Relationship of this skb to the connection
+ *	@nfct_reasm: netfilter conntrack re-assembly pointer
+ *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
+ *	@skb_iif: ifindex of device we arrived on
+ *	@rxhash: the packet hash computed on receive
+ *	@queue_mapping: Queue mapping for multiqueue devices
+ *	@tc_index: Traffic control index
+ *	@tc_verd: traffic control verdict
+ *	@ndisc_nodetype: router type (from link layer)
+ *	@dma_cookie: a cookie to one of several possible DMA operations
+ *		done by skb DMA functions
+ *	@secmark: security marking
+ *	@vlan_tci: vlan tag control information
+ */
+
+struct sk_buff {
+	/* These two members must be first. */
+	struct sk_buff		*next;
+	struct sk_buff		*prev;
+
+	ktime_t			tstamp;
+
+	struct sock		*sk;
+	//struct net_device	*dev;
+	struct ifnet *dev;
+
+	/*
+	 * This is the control buffer. It is free to use for every
+	 * layer. Please put your private variables there. If you
+	 * want to keep them across layers you have to do a skb_clone()
+	 * first. This is owned by whoever has the skb queued ATM.
+	 */
+	char			cb[48] __aligned(8);
+
+	unsigned long		_skb_refdst;
+#ifdef CONFIG_XFRM
+	struct	sec_path	*sp;
+#endif
+	unsigned int		len,
+				data_len;
+	u16			mac_len,
+				hdr_len;
+	union {
+		u32		csum;
+		struct {
+			u16	csum_start;
+			u16	csum_offset;
+		}smbol2;
+	}smbol1;
+	u32			priority;
+	kmemcheck_bitfield_begin(flags1);
+	u8			local_df:1,
+				cloned:1,
+				ip_summed:2,
+				nohdr:1,
+				nfctinfo:3;
+	u8			pkt_type:3,
+				fclone:2,
+				ipvs_property:1,
+				peeked:1,
+				nf_trace:1;
+	kmemcheck_bitfield_end(flags1);
+	u16			protocol;
+
+	void			(*destructor)(struct sk_buff *skb);
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+	struct nf_conntrack	*nfct;
+	struct sk_buff		*nfct_reasm;
+#endif
+#ifdef CONFIG_BRIDGE_NETFILTER
+	struct nf_bridge_info	*nf_bridge;
+#endif
+
+	int			skb_iif;
+#ifdef CONFIG_NET_SCHED
+	u16			tc_index;	/* traffic control index */
+#ifdef CONFIG_NET_CLS_ACT
+	u16			tc_verd;	/* traffic control verdict */
+#endif
+#endif
+
+	u32			rxhash;
+
+	kmemcheck_bitfield_begin(flags2);
+	u16			queue_mapping:16;
+#ifdef CONFIG_IPV6_NDISC_NODETYPE
+	u8			ndisc_nodetype:2,
+				deliver_no_wcard:1;
+#else
+	u8			deliver_no_wcard:1;
+#endif
+	kmemcheck_bitfield_end(flags2);
+
+	/* 0/14 bit hole */
+
+#ifdef CONFIG_NET_DMA
+	dma_cookie_t		dma_cookie;
+#endif
+#ifdef CONFIG_NETWORK_SECMARK
+	u32			secmark;
+#endif
+	union {
+		u32		mark;
+		u32		dropcount;
+	}symbol3;
+
+	u16			vlan_tci;
+
+	sk_buff_data_t		transport_header;
+	sk_buff_data_t		network_header;
+	sk_buff_data_t		mac_header;
+	/* These elements must be at the end, see alloc_skb() for details.  */
+	sk_buff_data_t		tail;
+	sk_buff_data_t		end;
+	unsigned char		*head,
+				*data;
+	unsigned int		truesize;
+	atomic_t		users;
+};
+struct sk_buff_head {
+	/* These two members must be first. */
+	struct sk_buff	*next;
+	struct sk_buff	*prev;
+
+	u32		qlen;
+	_lock	lock;
+};
+#define skb_tail_pointer(skb)	skb->tail
+static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
+{
+	unsigned char *tmp = skb_tail_pointer(skb);
+	//SKB_LINEAR_ASSERT(skb);
+	skb->tail += len;
+	skb->len  += len;
+	return tmp;
+}
+
+static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
+{
+	skb->len -= len;
+	if(skb->len < skb->data_len)
+		printf("%s(),%d,error!\n",__FUNCTION__,__LINE__);
+	return skb->data += len;
+}
+static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
+{
+	#ifdef PLATFORM_FREEBSD
+	return __skb_pull(skb, len);
+	#else
+	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
+	#endif //PLATFORM_FREEBSD
+}
+static inline u32 skb_queue_len(const struct sk_buff_head *list_)
+{
+	return list_->qlen;
+}
+static inline void __skb_insert(struct sk_buff *newsk,
+				struct sk_buff *prev, struct sk_buff *next,
+				struct sk_buff_head *list)
+{
+	newsk->next = next;
+	newsk->prev = prev;
+	next->prev  = prev->next = newsk;
+	list->qlen++;
+}
+static inline void __skb_queue_before(struct sk_buff_head *list,
+				      struct sk_buff *next,
+				      struct sk_buff *newsk)
+{
+	__skb_insert(newsk, next->prev, next, list);
+}
+static inline void skb_queue_tail(struct sk_buff_head *list,
+				   struct sk_buff *newsk)
+{
+	mtx_lock(&list->lock);
+	__skb_queue_before(list, (struct sk_buff *)list, newsk);
+	mtx_unlock(&list->lock);
+}
+static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
+{
+	struct sk_buff *list = ((struct sk_buff *)list_)->next;
+	if (list == (struct sk_buff *)list_)
+		list = NULL;
+	return list;
+}
+static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
+{
+	struct sk_buff *next, *prev;
+
+	list->qlen--;
+	next	   = skb->next;
+	prev	   = skb->prev;
+	skb->next  = skb->prev = NULL;
+	next->prev = prev;
+	prev->next = next;
+}
+
+static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
+{
+	mtx_lock(&list->lock);
+
+	struct sk_buff *skb = skb_peek(list);
+	if (skb)
+		__skb_unlink(skb, list);
+
+	mtx_unlock(&list->lock);
+
+	return skb;
+}
+static inline void skb_reserve(struct sk_buff *skb, int len)
+{
+	skb->data += len;
+	skb->tail += len;
+}
+static inline void __skb_queue_head_init(struct sk_buff_head *list)
+{
+	list->prev = list->next = (struct sk_buff *)list;
+	list->qlen = 0;
+}
+/*
+ * This function creates a split out lock class for each invocation;
+ * this is needed for now since a whole lot of users of the skb-queue
+ * infrastructure in drivers have different locking usage (in hardirq)
+ * than the networking core (in softirq only). In the long run either the
+ * network layer or drivers should need annotation to consolidate the
+ * main types of usage into 3 classes.
+ */
+static inline void skb_queue_head_init(struct sk_buff_head *list)
+{
+	_rtw_spinlock_init(&list->lock);
+	__skb_queue_head_init(list);
+}
+unsigned long copy_from_user(void *to, const void *from, unsigned long n);
+unsigned long copy_to_user(void *to, const void *from, unsigned long n);
+struct sk_buff * dev_alloc_skb(unsigned int size);
+struct sk_buff *skb_clone(const struct sk_buff *skb);
+void dev_kfree_skb_any(struct sk_buff *skb);
+#endif //Baron porting from linux, it's all temp solution, needs to check again
+
+
+#if 1 // kenny add Linux compatibility code for Linux USB driver
+#include <dev/usb/usb_compat_linux.h>
+
+#define __init		// __attribute ((constructor))
+#define __exit		// __attribute ((destructor))
+
+/*
+ * Definitions for module_init and module_exit macros.
+ *
+ * These macros will use the SYSINIT framework to call a specified
+ * function (with no arguments) on module loading or unloading.
+ *
+ */
+
+void module_init_exit_wrapper(void *arg);
+
+#define module_init(initfn)                             \
+        SYSINIT(mod_init_ ## initfn,                    \
+                SI_SUB_KLD, SI_ORDER_FIRST,             \
+                module_init_exit_wrapper, initfn)
+
+#define module_exit(exitfn)                             \
+        SYSUNINIT(mod_exit_ ## exitfn,                  \
+                  SI_SUB_KLD, SI_ORDER_ANY,             \
+                  module_init_exit_wrapper, exitfn)
+
+/*
+ * The usb_register and usb_deregister functions are used to register
+ * usb drivers with the usb subsystem.
+ */
+int usb_register(struct usb_driver *driver);
+int usb_deregister(struct usb_driver *driver);
+
+/*
+ * usb_get_dev and usb_put_dev - increment/decrement the reference count
+ * of the usb device structure.
+ *
+ * Original body of usb_get_dev:
+ *
+ *       if (dev)
+ *               get_device(&dev->dev);
+ *       return dev;
+ *
+ * Reference counts are not currently used in this compatibility
+ * layer. So these functions will do nothing.
+ */
+static inline struct usb_device *
+usb_get_dev(struct usb_device *dev)
+{
+        return dev;
+}
+
+static inline void
+usb_put_dev(struct usb_device *dev)
+{
+        return;
+}
+
+
+// rtw_usb_compat_linux
+int rtw_usb_submit_urb(struct urb *urb, uint16_t mem_flags);
+int rtw_usb_unlink_urb(struct urb *urb);
+int rtw_usb_clear_halt(struct usb_device *dev, struct usb_host_endpoint *uhe);
+int rtw_usb_control_msg(struct usb_device *dev, struct usb_host_endpoint *uhe,
+    uint8_t request, uint8_t requesttype,
+    uint16_t value, uint16_t index, void *data,
+    uint16_t size, usb_timeout_t timeout);
+int rtw_usb_set_interface(struct usb_device *dev, uint8_t iface_no, uint8_t alt_index);
+int rtw_usb_setup_endpoint(struct usb_device *dev,
+    struct usb_host_endpoint *uhe, usb_size_t bufsize);
+struct urb *rtw_usb_alloc_urb(uint16_t iso_packets, uint16_t mem_flags);
+struct usb_host_endpoint *rtw_usb_find_host_endpoint(struct usb_device *dev, uint8_t type, uint8_t ep);
+struct usb_host_interface *rtw_usb_altnum_to_altsetting(const struct usb_interface *intf, uint8_t alt_index);
+struct usb_interface *rtw_usb_ifnum_to_if(struct usb_device *dev, uint8_t iface_no);
+void *rtw_usbd_get_intfdata(struct usb_interface *intf);
+void rtw_usb_linux_register(void *arg);
+void rtw_usb_linux_deregister(void *arg);
+void rtw_usb_linux_free_device(struct usb_device *dev);
+void rtw_usb_free_urb(struct urb *urb);
+void rtw_usb_init_urb(struct urb *urb);
+void rtw_usb_kill_urb(struct urb *urb);
+void rtw_usb_set_intfdata(struct usb_interface *intf, void *data);
+void rtw_usb_fill_bulk_urb(struct urb *urb, struct usb_device *udev,
+    struct usb_host_endpoint *uhe, void *buf,
+    int length, usb_complete_t callback, void *arg);
+int rtw_usb_bulk_msg(struct usb_device *udev, struct usb_host_endpoint *uhe,
+    void *data, int len, uint16_t *pactlen, usb_timeout_t timeout);
+void *usb_get_intfdata(struct usb_interface *intf);
+int usb_linux_init_endpoints(struct usb_device *udev);
+
+
+
+typedef struct urb *  PURB;
+
+typedef unsigned gfp_t;
+#define __GFP_WAIT      ((gfp_t)0x10u)  /* Can wait and reschedule? */
+#define __GFP_HIGH      ((gfp_t)0x20u)  /* Should access emergency pools? */
+#define __GFP_IO        ((gfp_t)0x40u)  /* Can start physical IO? */
+#define __GFP_FS        ((gfp_t)0x80u)  /* Can call down to low-level FS? */
+#define __GFP_COLD      ((gfp_t)0x100u) /* Cache-cold page required */
+#define __GFP_NOWARN    ((gfp_t)0x200u) /* Suppress page allocation failure warning */
+#define __GFP_REPEAT    ((gfp_t)0x400u) /* Retry the allocation.  Might fail */
+#define __GFP_NOFAIL    ((gfp_t)0x800u) /* Retry for ever.  Cannot fail */
+#define __GFP_NORETRY   ((gfp_t)0x1000u)/* Do not retry.  Might fail */
+#define __GFP_NO_GROW   ((gfp_t)0x2000u)/* Slab internal usage */
+#define __GFP_COMP      ((gfp_t)0x4000u)/* Add compound page metadata */
+#define __GFP_ZERO      ((gfp_t)0x8000u)/* Return zeroed page on success */
+#define __GFP_NOMEMALLOC ((gfp_t)0x10000u) /* Don't use emergency reserves */
+#define __GFP_HARDWALL   ((gfp_t)0x20000u) /* Enforce hardwall cpuset memory allocs */
+
+/* This equals 0, but use constants in case they ever change */
+#define GFP_NOWAIT      (GFP_ATOMIC & ~__GFP_HIGH)
+/* GFP_ATOMIC means both !wait (__GFP_WAIT not set) and use emergency pool */
+#define GFP_ATOMIC      (__GFP_HIGH)
+#define GFP_NOIO        (__GFP_WAIT)
+#define GFP_NOFS        (__GFP_WAIT | __GFP_IO)
+#define GFP_KERNEL      (__GFP_WAIT | __GFP_IO | __GFP_FS)
+#define GFP_USER        (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
+#define GFP_HIGHUSER    (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \
+                         __GFP_HIGHMEM)
+
+
+#endif // kenny add Linux compatibility code for Linux USB
+
+__inline static _list *get_next(_list	*list)
+{
+	return list->next;
+}
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+
+#define LIST_CONTAINOR(ptr, type, member) \
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+
+
+__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_bh(plock, *pirqL);
+}
+
+__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_bh(plock, *pirqL);
+}
+
+__inline static void _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+
+		mtx_lock(pmutex);
+
+}
+
+
+__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+
+		mtx_unlock(pmutex);
+
+}
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+__inline static void rtw_list_delete(_list *plist)
+{
+	__list_del(plist->prev, plist->next);
+	INIT_LIST_HEAD(plist);
+}
+
+__inline static void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,void* cntx)
+{
+	ptimer->function = pfunc;
+	ptimer->arg = cntx;
+	callout_init(&ptimer->callout, CALLOUT_MPSAFE);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{
+	//	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));
+	if(ptimer->function && ptimer->arg){
+		rtw_mtx_lock(NULL);
+		callout_reset(&ptimer->callout, delay_time,ptimer->function, ptimer->arg);
+		rtw_mtx_unlock(NULL);
+	}
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	//	del_timer_sync(ptimer);
+	//	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
+	rtw_mtx_lock(NULL);
+	callout_drain(&ptimer->callout);
+	rtw_mtx_unlock(NULL);
+}
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+	printf("%s Not implement yet! \n",__FUNCTION__);
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+	printf("%s Not implement yet! \n",__FUNCTION__);
+//	schedule_work(pwork);
+}
+
+//
+// Global Mutex: can only be used at PASSIVE level.
+//
+
+#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+}
+
+#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+}
+
+#define ATOMIC_INIT(i)  { (i) }
+
+static __inline void thread_enter(char *name);
+
+//Atomic integer operations
+typedef uint32_t ATOMIC_T ;
+
+#define rtw_netdev_priv(netdev) (((struct ifnet *)netdev)->if_softc)
+
+#define rtw_free_netdev(netdev) if_free((netdev))
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ""
+#define ADPT_FMT "%s"
+#define ADPT_ARG(adapter) ""
+#define FUNC_NDEV_FMT "%s"
+#define FUNC_NDEV_ARG(ndev) __func__
+#define FUNC_ADPT_FMT "%s"
+#define FUNC_ADPT_ARG(adapter) __func__
+
+#define STRUCT_PACKED
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_ce.h b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_ce.h
new file mode 100644
index 000000000..2812abe2e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_ce.h
@@ -0,0 +1,192 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __OSDEP_CE_SERVICE_H_
+#define __OSDEP_CE_SERVICE_H_
+
+
+#include <ndis.h>
+#include <ntddndis.h>
+
+#ifdef CONFIG_SDIO_HCI
+#include "SDCardDDK.h"
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usbdi.h>
+#endif
+
+typedef HANDLE 	_sema;
+typedef	LIST_ENTRY	_list;
+typedef NDIS_STATUS _OS_STATUS;
+
+typedef NDIS_SPIN_LOCK	_lock;
+
+typedef HANDLE 		_rwlock; //Mutex
+
+typedef u32	_irqL;
+
+typedef NDIS_HANDLE  _nic_hdl;
+
+
+typedef NDIS_MINIPORT_TIMER    _timer;
+
+struct	__queue	{
+	LIST_ENTRY	queue;
+	_lock	lock;
+};
+
+typedef	NDIS_PACKET	_pkt;
+typedef NDIS_BUFFER	_buffer;
+typedef struct	__queue	_queue;
+
+typedef HANDLE 	_thread_hdl_;
+typedef DWORD thread_return;
+typedef void*	thread_context;
+typedef NDIS_WORK_ITEM _workitem;
+
+#define thread_exit() ExitThread(STATUS_SUCCESS); return 0;
+
+
+#define SEMA_UPBND	(0x7FFFFFFF)   //8192
+
+__inline static _list *get_prev(_list	*list)
+{
+	return list->Blink;
+}
+
+__inline static _list *get_next(_list	*list)
+{
+	return list->Flink;
+}
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
+
+__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisAcquireSpinLock(plock);
+}
+
+__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisReleaseSpinLock(plock);
+}
+
+__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);
+}
+
+__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);
+}
+
+
+__inline static void _enter_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+	WaitForSingleObject(*prwlock, INFINITE );
+
+}
+
+__inline static void _exit_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+	ReleaseMutex(*prwlock);
+}
+
+__inline static void rtw_list_delete(_list *plist)
+{
+	RemoveEntryList(plist);
+	InitializeListHead(plist);
+}
+
+#define RTW_TIMER_HDL_ARGS IN PVOID SystemSpecific1, IN PVOID FunctionContext, IN PVOID SystemSpecific2, IN PVOID SystemSpecific3
+
+__inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,PVOID cntx)
+{
+	NdisMInitializeTimer(ptimer, nic_hdl, pfunc, cntx);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{
+ 	NdisMSetTimer(ptimer,delay_time);
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	NdisMCancelTimer(ptimer,bcancelled);
+}
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+
+	NdisInitializeWorkItem(pwork, pfunc, cntx);
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+	NdisScheduleWorkItem(pwork);
+}
+
+#define ATOMIC_INIT(i)  { (i) }
+
+//
+// Global Mutex: can only be used at PASSIVE level.
+//
+
+#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+    while (NdisInterlockedIncrement((PULONG)&(_MutexCounter)) != 1)\
+    {                                                           \
+        NdisInterlockedDecrement((PULONG)&(_MutexCounter));        \
+        NdisMSleep(10000);                          \
+    }                                                           \
+}
+
+#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+    NdisInterlockedDecrement((PULONG)&(_MutexCounter));              \
+}
+
+// limitation of path length
+#define PATH_LENGTH_MAX MAX_PATH
+
+//Atomic integer operations
+#define ATOMIC_T LONG
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ""
+#define ADPT_FMT "%s"
+#define ADPT_ARG(adapter) ""
+#define FUNC_NDEV_FMT "%s"
+#define FUNC_NDEV_ARG(ndev) __func__
+#define FUNC_ADPT_FMT "%s"
+#define FUNC_ADPT_ARG(adapter) __func__
+
+#define STRUCT_PACKED
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_linux.h b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_linux.h
new file mode 100644
index 000000000..fa5c94c30
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_linux.h
@@ -0,0 +1,420 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_LINUX_SERVICE_H_
+#define __OSDEP_LINUX_SERVICE_H_
+
+	#include <linux/version.h>
+	#include <linux/spinlock.h>
+	#include <linux/compiler.h>
+	#include <linux/kernel.h>
+	#include <linux/errno.h>
+	#include <linux/init.h>
+	#include <linux/slab.h>
+	#include <linux/module.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,5))
+	#include <linux/kref.h>
+#endif
+	//#include <linux/smp_lock.h>
+	#include <linux/netdevice.h>
+	#include <linux/skbuff.h>
+	#include <linux/circ_buf.h>
+	#include <asm/uaccess.h>
+	#include <asm/byteorder.h>
+	#include <asm/atomic.h>
+	#include <asm/io.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+	#include <asm/semaphore.h>
+#else
+	#include <linux/semaphore.h>
+#endif
+	#include <linux/sem.h>
+	#include <linux/sched.h>
+	#include <linux/etherdevice.h>
+	#include <linux/wireless.h>
+	#include <net/iw_handler.h>
+	#include <linux/if_arp.h>
+	#include <linux/rtnetlink.h>
+	#include <linux/delay.h>
+	#include <linux/interrupt.h>	// for struct tasklet_struct
+	#include <linux/ip.h>
+	#include <linux/kthread.h>
+	#include <linux/list.h>
+	#include <linux/vmalloc.h>
+	#include <linux/signal.h>
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,41))
+	#include <linux/tqueue.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
+	#include <uapi/linux/limits.h>
+#else
+	#include <linux/limits.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+	#include <linux/sched/signal.h>
+#endif
+
+#ifdef RTK_DMP_PLATFORM
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
+	#include <linux/pageremap.h>
+#endif
+	#include <asm/io.h>
+#endif
+
+#ifdef CONFIG_NET_RADIO
+	#define CONFIG_WIRELESS_EXT
+#endif
+
+	/* Monitor mode */
+	#include <net/ieee80211_radiotap.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+/*	#include <linux/ieee80211.h> */
+	#include <net/cfg80211.h>
+#endif //CONFIG_IOCTL_CFG80211
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	#include <linux/in.h>
+	#include <linux/udp.h>
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	#include <linux/earlysuspend.h>
+#endif //CONFIG_HAS_EARLYSUSPEND
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+	#include <linux/fs.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+	#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+	#include <linux/usb_ch9.h>
+#else
+	#include <linux/usb/ch9.h>
+#endif
+#endif
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	#include <net/sock.h>
+	#include <net/tcp.h>
+	#include <linux/udp.h>
+	#include <linux/in.h>
+	#include <linux/netlink.h>
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+
+#ifdef CONFIG_USB_HCI
+	typedef struct urb *  PURB;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
+#ifdef CONFIG_USB_SUSPEND
+#define CONFIG_AUTOSUSPEND	1
+#endif
+#endif
+#endif
+
+	typedef struct 	semaphore _sema;
+	typedef	spinlock_t	_lock;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	typedef struct mutex 		_mutex;
+#else
+	typedef struct semaphore	_mutex;
+#endif
+	typedef struct timer_list _timer;
+
+	struct	__queue	{
+		struct	list_head	queue;
+		_lock	lock;
+	};
+
+	typedef	struct sk_buff	_pkt;
+	typedef unsigned char	_buffer;
+
+	typedef struct	__queue	_queue;
+	typedef struct	list_head	_list;
+	typedef	int	_OS_STATUS;
+	//typedef u32	_irqL;
+	typedef unsigned long _irqL;
+	typedef	struct	net_device * _nic_hdl;
+
+	typedef void*		_thread_hdl_;
+	typedef int		thread_return;
+	typedef void*	thread_context;
+
+	#define thread_exit() complete_and_exit(NULL, 0)
+
+	typedef void timer_hdl_return;
+	typedef void* timer_hdl_context;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41))
+	typedef struct work_struct _workitem;
+#else
+	typedef struct tq_struct _workitem;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+// Porting from linux kernel, for compatible with old kernel.
+static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
+{
+	return skb->tail;
+}
+
+static inline void skb_reset_tail_pointer(struct sk_buff *skb)
+{
+	skb->tail = skb->data;
+}
+
+static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
+{
+	skb->tail = skb->data + offset;
+}
+
+static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
+{
+	return skb->end;
+}
+#endif
+
+__inline static _list *get_next(_list	*list)
+{
+	return list->next;
+}
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+
+#define LIST_CONTAINOR(ptr, type, member) \
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+
+
+__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_bh(plock);
+}
+
+__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_bh(plock);
+}
+
+__inline static int _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	int ret = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	//mutex_lock(pmutex);
+	ret = mutex_lock_interruptible(pmutex);
+#else
+	ret = down_interruptible(pmutex);
+#endif
+	return ret;
+}
+
+
+__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		mutex_unlock(pmutex);
+#else
+		up(pmutex);
+#endif
+}
+
+__inline static void rtw_list_delete(_list *plist)
+{
+	list_del_init(plist);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{
+	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	del_timer_sync(ptimer);
+	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
+}
+
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	INIT_WORK(pwork, pfunc);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41))
+	INIT_WORK(pwork, pfunc,pwork);
+#else
+	INIT_TQUEUE(pwork, pfunc,pwork);
+#endif
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41))
+	schedule_work(pwork);
+#else
+	schedule_task(pwork);
+#endif
+}
+
+__inline static void _cancel_workitem_sync(_workitem *pwork)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
+	cancel_work_sync(pwork);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41))
+	flush_scheduled_work();
+#else
+	flush_scheduled_tasks();
+#endif
+}
+//
+// Global Mutex: can only be used at PASSIVE level.
+//
+
+#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+	while (atomic_inc_return((atomic_t *)&(_MutexCounter)) != 1)\
+	{                                                           \
+		atomic_dec((atomic_t *)&(_MutexCounter));        \
+		msleep(10);                          \
+	}                                                           \
+}
+
+#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+	atomic_dec((atomic_t *)&(_MutexCounter));        \
+}
+
+static inline int rtw_netif_queue_stopped(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	return (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)) );
+#else
+	return netif_queue_stopped(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_wake_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	netif_tx_wake_all_queues(pnetdev);
+#else
+	netif_wake_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_start_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	netif_tx_start_all_queues(pnetdev);
+#else
+	netif_start_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	netif_tx_stop_all_queues(pnetdev);
+#else
+	netif_stop_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_merge_string(char *dst, int dst_len, const char *src1, const char *src2)
+{
+	int	len = 0;
+	len += snprintf(dst+len, dst_len - len, "%s", src1);
+	len += snprintf(dst+len, dst_len - len, "%s", src2);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)),(sig), 1)
+#else //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
+#endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+
+
+// Suspend lock prevent system from going suspend
+#ifdef CONFIG_WAKELOCK
+#include <linux/wakelock.h>
+#elif defined(CONFIG_ANDROID_POWER)
+#include <linux/android_power.h>
+#endif
+
+// limitation of path length
+#define PATH_LENGTH_MAX PATH_MAX
+
+//Atomic integer operations
+#define ATOMIC_T atomic_t
+
+#define rtw_netdev_priv(netdev) ( ((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv )
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ndev->name
+#define ADPT_FMT "%s"
+#define ADPT_ARG(adapter) adapter->pnetdev->name
+#define FUNC_NDEV_FMT "%s(%s)"
+#define FUNC_NDEV_ARG(ndev) __func__, ndev->name
+#define FUNC_ADPT_FMT "%s(%s)"
+#define FUNC_ADPT_ARG(adapter) __func__, adapter->pnetdev->name
+
+struct rtw_netdev_priv_indicator {
+	void *priv;
+	u32 sizeof_priv;
+};
+struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
+extern struct net_device * rtw_alloc_etherdev(int sizeof_priv);
+
+#define STRUCT_PACKED __attribute__ ((packed))
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_xp.h b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_xp.h
new file mode 100644
index 000000000..2e2683d27
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/osdep_service_xp.h
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_LINUX_SERVICE_H_
+#define __OSDEP_LINUX_SERVICE_H_
+
+	#include <ndis.h>
+	#include <ntddk.h>
+	#include <ntddndis.h>
+	#include <ntdef.h>
+
+#ifdef CONFIG_USB_HCI
+	#include <usb.h>
+	#include <usbioctl.h>
+	#include <usbdlib.h>
+#endif
+
+	typedef KSEMAPHORE 	_sema;
+	typedef	LIST_ENTRY	_list;
+	typedef NDIS_STATUS _OS_STATUS;
+
+
+	typedef NDIS_SPIN_LOCK	_lock;
+
+	typedef KMUTEX 			_mutex;
+
+	typedef KIRQL	_irqL;
+
+	// USB_PIPE for WINCE , but handle can be use just integer under windows
+	typedef NDIS_HANDLE  _nic_hdl;
+
+
+	typedef NDIS_MINIPORT_TIMER    _timer;
+
+	struct	__queue	{
+		LIST_ENTRY	queue;
+		_lock	lock;
+	};
+
+	typedef	NDIS_PACKET	_pkt;
+	typedef NDIS_BUFFER	_buffer;
+	typedef struct	__queue	_queue;
+
+	typedef PKTHREAD _thread_hdl_;
+	typedef void	thread_return;
+	typedef void* thread_context;
+
+	typedef NDIS_WORK_ITEM _workitem;
+
+	#define thread_exit() PsTerminateSystemThread(STATUS_SUCCESS);
+
+	#define HZ			10000000
+	#define SEMA_UPBND	(0x7FFFFFFF)   //8192
+
+__inline static _list *get_next(_list	*list)
+{
+	return list->Flink;
+}
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+
+#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
+
+
+__inline static _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisAcquireSpinLock(plock);
+}
+
+__inline static _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisReleaseSpinLock(plock);
+}
+
+
+__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);
+}
+
+__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);
+}
+
+__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);
+}
+
+__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);
+}
+
+__inline static _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	KeWaitForSingleObject(pmutex, Executive, KernelMode, FALSE, NULL);
+}
+
+
+__inline static _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	KeReleaseMutex(pmutex, FALSE);
+}
+
+
+__inline static void rtw_list_delete(_list *plist)
+{
+	RemoveEntryList(plist);
+	InitializeListHead(plist);
+}
+
+#define RTW_TIMER_HDL_ARGS IN PVOID SystemSpecific1, IN PVOID FunctionContext, IN PVOID SystemSpecific2, IN PVOID SystemSpecific3
+
+__inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,PVOID cntx)
+{
+	NdisMInitializeTimer(ptimer, nic_hdl, pfunc, cntx);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{
+ 	NdisMSetTimer(ptimer,delay_time);
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	NdisMCancelTimer(ptimer,bcancelled);
+}
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+
+	NdisInitializeWorkItem(pwork, pfunc, cntx);
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+	NdisScheduleWorkItem(pwork);
+}
+
+
+#define ATOMIC_INIT(i)  { (i) }
+
+//
+// Global Mutex: can only be used at PASSIVE level.
+//
+
+#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+    while (NdisInterlockedIncrement((PULONG)&(_MutexCounter)) != 1)\
+    {                                                           \
+        NdisInterlockedDecrement((PULONG)&(_MutexCounter));        \
+        NdisMSleep(10000);                          \
+    }                                                           \
+}
+
+#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+    NdisInterlockedDecrement((PULONG)&(_MutexCounter));              \
+}
+
+// limitation of path length
+#define PATH_LENGTH_MAX MAX_PATH
+
+//Atomic integer operations
+#define ATOMIC_T LONG
+
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ""
+#define ADPT_FMT "%s"
+#define ADPT_ARG(adapter) ""
+#define FUNC_NDEV_FMT "%s"
+#define FUNC_NDEV_ARG(ndev) __func__
+#define FUNC_ADPT_FMT "%s"
+#define FUNC_ADPT_ARG(adapter) __func__
+
+#define STRUCT_PACKED
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/pci_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/pci_hal.h
new file mode 100644
index 000000000..e7d9bd9d3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/pci_hal.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __PCI_HAL_H__
+#define __PCI_HAL_H__
+
+#ifdef CONFIG_RTL8188E
+void rtl8188ee_set_hal_ops(_adapter *padapter);
+#endif
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
+void rtl8812ae_set_hal_ops(_adapter *padapter);
+#endif
+
+#if defined(CONFIG_RTL8192E)
+void rtl8192ee_set_hal_ops(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_RTL8723B
+void rtl8723be_set_hal_ops(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_RTL8814A
+void rtl8814ae_set_hal_ops(_adapter *padapter);
+#endif
+
+u8 rtw_set_hal_ops(_adapter *padapter);
+
+#endif //__PCIE_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/pci_ops.h b/drivers/net/wireless/realtek/rtl8723cs/include/pci_ops.h
new file mode 100644
index 000000000..7930ac445
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/pci_ops.h
@@ -0,0 +1,78 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __PCI_OPS_H_
+#define __PCI_OPS_H_
+
+
+#ifdef CONFIG_RTL8188E
+u32	rtl8188ee_init_desc_ring(_adapter *padapter);
+u32	rtl8188ee_free_desc_ring(_adapter *padapter);
+void	rtl8188ee_reset_desc_ring(_adapter *padapter);
+int	rtl8188ee_interrupt(PADAPTER Adapter);
+void	rtl8188ee_xmit_tasklet(void *priv);
+void	rtl8188ee_recv_tasklet(void *priv);
+void	rtl8188ee_prepare_bcn_tasklet(void *priv);
+void	rtl8188ee_set_intf_ops(struct _io_ops	*pops);
+#endif
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
+u32	rtl8812ae_init_desc_ring(_adapter *padapter);
+u32	rtl8812ae_free_desc_ring(_adapter *padapter);
+void	rtl8812ae_reset_desc_ring(_adapter *padapter);
+int	rtl8812ae_interrupt(PADAPTER Adapter);
+void	rtl8812ae_xmit_tasklet(void *priv);
+void	rtl8812ae_recv_tasklet(void *priv);
+void	rtl8812ae_prepare_bcn_tasklet(void *priv);
+void	rtl8812ae_set_intf_ops(struct _io_ops	*pops);
+#endif
+
+#ifdef CONFIG_RTL8192E
+u32	rtl8192ee_init_desc_ring(_adapter *padapter);
+u32	rtl8192ee_free_desc_ring(_adapter *padapter);
+void	rtl8192ee_reset_desc_ring(_adapter *padapter);
+void	rtl8192ee_recv_tasklet(void *priv);
+void	rtl8192ee_prepare_bcn_tasklet(void *priv);
+int	rtl8192ee_interrupt(PADAPTER Adapter);
+void	rtl8192ee_set_intf_ops(struct _io_ops	*pops);
+#endif
+
+#ifdef CONFIG_RTL8723B
+u32	rtl8723be_init_desc_ring(_adapter *padapter);
+u32	rtl8723be_free_desc_ring(_adapter *padapter);
+void	rtl8723be_reset_desc_ring(_adapter *padapter);
+int	rtl8723be_interrupt(PADAPTER Adapter);
+void	rtl8723be_recv_tasklet(void *priv);
+void	rtl8723be_prepare_bcn_tasklet(void *priv);
+void	rtl8723be_set_intf_ops(struct _io_ops	*pops);
+#endif
+
+#ifdef CONFIG_RTL8814A
+u32	rtl8814ae_init_desc_ring(_adapter *padapter);
+u32	rtl8814ae_free_desc_ring(_adapter *padapter);
+void	rtl8814ae_reset_desc_ring(_adapter *padapter);
+int	rtl8814ae_interrupt(PADAPTER Adapter);
+void	rtl8814ae_xmit_tasklet(void *priv);
+void	rtl8814ae_recv_tasklet(void *priv);
+void	rtl8814ae_prepare_bcn_tasklet(void *priv);
+void	rtl8814ae_set_intf_ops(struct _io_ops	*pops);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/pci_osintf.h b/drivers/net/wireless/realtek/rtl8723cs/include/pci_osintf.h
new file mode 100644
index 000000000..d1f7c7ffa
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/pci_osintf.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __PCI_OSINTF_H
+#define __PCI_OSINTF_H
+
+
+void	rtw_pci_disable_aspm(_adapter *padapter);
+void	rtw_pci_enable_aspm(_adapter *padapter);
+void	PlatformClearPciPMEStatus(PADAPTER Adapter);
+#ifdef CONFIG_64BIT_DMA
+u8	PlatformEnableDMA64(PADAPTER Adapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/recv_osdep.h b/drivers/net/wireless/realtek/rtl8723cs/include/recv_osdep.h
new file mode 100644
index 000000000..c77aa54a1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/recv_osdep.h
@@ -0,0 +1,65 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+
+extern sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+extern void _rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+
+extern s32  rtw_recv_entry(union recv_frame *precv_frame);
+extern int rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
+extern void rtw_recv_returnpacket(IN _nic_hdl cnxt, IN _pkt *preturnedpkt);
+
+extern int rtw_recv_monitor(_adapter *padapter, union recv_frame *precv_frame);
+
+extern void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
+
+struct sta_info;
+extern void rtw_handle_tkip_mic_err(_adapter *padapter, struct sta_info *sta, u8 bgroup);
+
+
+int	rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+void rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+
+int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter);
+int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe);
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv);
+
+
+int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8 *pdata, _pkt *pskb);
+void rtw_os_free_recvframe(union recv_frame *precvframe);
+
+
+int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf);
+int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf);
+
+_pkt *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, u16 nSubframe_Length, u8 *pdata);
+void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attrib *pattrib);
+
+void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+
+#endif //
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_cmd.h
new file mode 100644
index 000000000..2ef938ad8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_cmd.h
@@ -0,0 +1,186 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_CMD_H__
+#define __RTL8188E_CMD_H__
+
+#if 0
+enum cmd_msg_element_id
+{
+	NONE_CMDMSG_EID,
+	AP_OFFLOAD_EID = 0,
+	SET_PWRMODE_EID = 1,
+	JOINBSS_RPT_EID = 2,
+	RSVD_PAGE_EID = 3,
+	RSSI_4_EID = 4,
+	RSSI_SETTING_EID = 5,
+	MACID_CONFIG_EID = 6,
+	MACID_PS_MODE_EID = 7,
+	P2P_PS_OFFLOAD_EID = 8,
+	SELECTIVE_SUSPEND_ROF_CMD = 9,
+	P2P_PS_CTW_CMD_EID = 32,
+	MAX_CMDMSG_EID
+};
+#else
+typedef enum _RTL8188E_H2C_CMD_ID
+{
+	//Class Common
+	H2C_COM_RSVD_PAGE			=0x00,
+	H2C_COM_MEDIA_STATUS_RPT	=0x01,
+	H2C_COM_SCAN					=0x02,
+	H2C_COM_KEEP_ALIVE			=0x03,
+	H2C_COM_DISCNT_DECISION		=0x04,
+#ifndef CONFIG_WOWLAN
+	H2C_COM_WWLAN				=0x05,
+#endif
+	H2C_COM_INIT_OFFLOAD			=0x06,
+	H2C_COM_REMOTE_WAKE_CTL	=0x07,
+	H2C_COM_AP_OFFLOAD			=0x08,
+	H2C_COM_BCN_RSVD_PAGE		=0x09,
+	H2C_COM_PROB_RSP_RSVD_PAGE	=0x0A,
+
+	//Class PS
+	H2C_PS_PWR_MODE				=0x20,
+	H2C_PS_TUNE_PARA				=0x21,
+	H2C_PS_TUNE_PARA_2			=0x22,
+	H2C_PS_LPS_PARA				=0x23,
+	H2C_PS_P2P_OFFLOAD			=0x24,
+
+	//Class DM
+	H2C_DM_MACID_CFG				=0x40,
+	H2C_DM_TXBF					=0x41,
+	H2C_RSSI_REPORT 				=0x42,
+	//Class BT
+	H2C_BT_COEX_MASK				=0x60,
+	H2C_BT_COEX_GPIO_MODE		=0x61,
+	H2C_BT_DAC_SWING_VAL			=0x62,
+	H2C_BT_PSD_RST				=0x63,
+
+	//Class Remote WakeUp
+#ifdef CONFIG_WOWLAN
+	H2C_COM_WWLAN				=0x80,
+	H2C_COM_REMOTE_WAKE_CTRL	=0x81,
+	H2C_COM_AOAC_GLOBAL_INFO	=0x82,
+	H2C_COM_AOAC_RSVD_PAGE		=0x83,
+#endif
+
+	//Class
+	 //H2C_RESET_TSF				=0xc0,
+}RTL8188E_H2C_CMD_ID;
+
+#endif
+
+
+struct cmd_msg_parm {
+	u8 eid; //element id
+	u8 sz; // sz
+	u8 buf[6];
+};
+
+enum{
+	PWRS
+};
+
+typedef struct _SETPWRMODE_PARM {
+	u8 Mode;//0:Active,1:LPS,2:WMMPS
+	//u8 RLBM:4;//0:Min,1:Max,2: User define
+	u8 SmartPS_RLBM;//LPS=0:PS_Poll,1:PS_Poll,2:NullData,WMM=0:PS_Poll,1:NullData
+	u8 AwakeInterval;	// unit: beacon interval
+	u8 bAllQueueUAPSD;
+	u8 PwrState;//AllON(0x0c),RFON(0x04),RFOFF(0x00)
+} SETPWRMODE_PARM, *PSETPWRMODE_PARM;
+
+struct H2C_SS_RFOFF_PARAM{
+	u8 ROFOn; // 1: on, 0:off
+	u16 gpio_period; // unit: 1024 us
+}__attribute__ ((packed));
+
+
+typedef struct JOINBSSRPT_PARM_88E{
+	u8 OpMode;	// RT_MEDIA_STATUS
+#ifdef CONFIG_WOWLAN
+	u8 MacID;       // MACID
+#endif //CONFIG_WOWLAN
+}JOINBSSRPT_PARM_88E, *PJOINBSSRPT_PARM_88E;
+
+/* move to hal_com_h2c.h
+typedef struct _RSVDPAGE_LOC_88E {
+	u8 LocProbeRsp;
+	u8 LocPsPoll;
+	u8 LocNullData;
+	u8 LocQosNull;
+	u8 LocBTQosNull;
+#ifdef CONFIG_WOWLAN
+	u8 LocRemoteCtrlInfo;
+	u8 LocArpRsp;
+	u8 LocNbrAdv;
+	u8 LocGTKRsp;
+	u8 LocGTKInfo;
+	u8 LocProbeReq;
+	u8 LocNetList;
+#endif //CONFIG_WOWLAN
+} RSVDPAGE_LOC_88E, *PRSVDPAGE_LOC_88E;
+*/
+
+// host message to firmware cmd
+void rtl8188e_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
+void rtl8188e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
+u8 rtl8188e_set_rssi_cmd(PADAPTER padapter, u8 *param);
+u8 rtl8188e_set_raid_cmd(_adapter *padapter, u32 bitmap, u8 *arg);
+void rtl8188e_Add_RateATid(PADAPTER padapter, u64 rate_bitmap, u8 *arg, u8 rssi_level);
+s32 FillH2CCmd_88E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+//u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period);
+u8 GetTxBufferRsvdPageNum8188E(_adapter *padapter, bool wowlan);
+
+
+#ifdef CONFIG_P2P
+void rtl8188e_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+//u8 rtl8188e_reset_tsf(_adapter *padapter, u8 reset_port);
+int reset_tsf(PADAPTER Adapter, u8 reset_port );
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+
+//#define H2C_8188E_RSVDPAGE_LOC_LEN      5
+//#define H2C_8188E_AOAC_RSVDPAGE_LOC_LEN 7
+
+#ifdef CONFIG_WOWLAN
+void SetFwRelatedForWoWLAN8188ES(_adapter* padapter, u8 bHostIsGoingtoSleep);
+#endif//CONFIG_WOWLAN
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD CONTENT    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+//
+/* move to hal_com_h2c.h
+//_RSVDPAGE_LOC_CMD_0x00
+#define SET_8188E_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)     SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8188E_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)            SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8188E_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)     SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8188E_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)     SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+// AOAC_RSVDPAGE_LOC_0x83
+#define SET_8188E_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(__pH2CCmd, __Value)        SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
+#define SET_8188E_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(__pH2CCmd, __Value)                  SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+*/
+#endif//__RTL8188E_CMD_H__
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_dm.h
new file mode 100644
index 000000000..eb97de187
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_dm.h
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_DM_H__
+#define __RTL8188E_DM_H__
+
+void rtl8188e_init_dm_priv(IN PADAPTER Adapter);
+void rtl8188e_deinit_dm_priv(IN PADAPTER Adapter);
+void rtl8188e_InitHalDm(IN PADAPTER Adapter);
+void rtl8188e_HalDmWatchDog(IN PADAPTER Adapter);
+
+//VOID rtl8192c_dm_CheckTXPowerTracking(IN PADAPTER Adapter);
+
+//void rtl8192c_dm_RF_Saving(IN PADAPTER pAdapter, IN u8 bForceInNormal);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void	AntDivCompare8188E(PADAPTER Adapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+u8 AntDivBeforeLink8188E(PADAPTER Adapter );
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_hal.h
new file mode 100644
index 000000000..13e9cd380
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_hal.h
@@ -0,0 +1,321 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_HAL_H__
+#define __RTL8188E_HAL_H__
+
+//#include "hal_com.h"
+#include "hal_data.h"
+
+//include HAL Related header after HAL Related compiling flags
+#include "rtl8188e_spec.h"
+#include "Hal8188EPhyReg.h"
+#include "Hal8188EPhyCfg.h"
+#include "rtl8188e_rf.h"
+#include "rtl8188e_dm.h"
+#include "rtl8188e_recv.h"
+#include "rtl8188e_xmit.h"
+#include "rtl8188e_cmd.h"
+#include "rtl8188e_led.h"
+#include "Hal8188EPwrSeq.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8188e_sreset.h"
+#endif
+
+#if 0
+	// Fw Array
+	#define Rtl8188E_FwImageArray				Rtl8188EFwImgArray
+	#define Rtl8188E_FWImgArrayLength			Rtl8188EFWImgArrayLength
+#ifdef CONFIG_WOWLAN
+	#define Rtl8188E_FwWoWImageArray			Array_MP_8188E_FW_WoWLAN
+	#define Rtl8188E_FwWoWImgArrayLength		ArrayLength_MP_8188E_FW_WoWLAN
+#endif //CONFIG_WOWLAN
+#endif
+
+
+	#define RTL8188E_FW_IMG					"rtl8188e/FW_NIC.bin"
+	#define RTL8188E_FW_WW_IMG				"rtl8188e/FW_WoWLAN.bin"
+	#define RTL8188E_PHY_REG					"rtl8188e/PHY_REG.txt"
+	#define RTL8188E_PHY_RADIO_A				"rtl8188e/RadioA.txt"
+	#define RTL8188E_PHY_RADIO_B				"rtl8188e/RadioB.txt"
+	#define RTL8188E_TXPWR_TRACK				"rtl8188e/TxPowerTrack.txt"
+	#define RTL8188E_AGC_TAB					"rtl8188e/AGC_TAB.txt"
+	#define RTL8188E_PHY_MACREG 				"rtl8188e/MAC_REG.txt"
+	#define RTL8188E_PHY_REG_PG				"rtl8188e/PHY_REG_PG.txt"
+	#define RTL8188E_PHY_REG_MP 				"rtl8188e/PHY_REG_MP.txt"
+	#define RTL8188E_TXPWR_LMT				"rtl8188e/TXPWR_LMT.txt"
+
+	//---------------------------------------------------------------------
+	//		RTL8188E Power Configuration CMDs for USB/SDIO/PCIE interfaces
+	//---------------------------------------------------------------------
+	#define Rtl8188E_NIC_PWR_ON_FLOW				rtl8188E_power_on_flow
+	#define Rtl8188E_NIC_RF_OFF_FLOW				rtl8188E_radio_off_flow
+	#define Rtl8188E_NIC_DISABLE_FLOW				rtl8188E_card_disable_flow
+	#define Rtl8188E_NIC_ENABLE_FLOW				rtl8188E_card_enable_flow
+	#define Rtl8188E_NIC_SUSPEND_FLOW				rtl8188E_suspend_flow
+	#define Rtl8188E_NIC_RESUME_FLOW				rtl8188E_resume_flow
+	#define Rtl8188E_NIC_PDN_FLOW					rtl8188E_hwpdn_flow
+	#define Rtl8188E_NIC_LPS_ENTER_FLOW			rtl8188E_enter_lps_flow
+	#define Rtl8188E_NIC_LPS_LEAVE_FLOW			rtl8188E_leave_lps_flow
+
+
+#if 1 // download firmware related data structure
+#define MAX_FW_8188E_SIZE			0x8000 //32768,32k / 16384,16k
+
+#define FW_8188E_SIZE				0x4000 //16384,16k
+#define FW_8188E_SIZE_2			0x8000 //32768,32k
+
+#define FW_8188E_START_ADDRESS	0x1000
+#define FW_8188E_END_ADDRESS		0x1FFF //0x5FFF
+
+
+#define IS_FW_HEADER_EXIST_88E(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x88E0)
+
+typedef struct _RT_FIRMWARE_8188E {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[MAX_FW_8188E_SIZE];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8188E, *PRT_FIRMWARE_8188E;
+
+//
+// This structure must be cared byte-ordering
+//
+
+typedef struct _RT_8188E_FIRMWARE_HDR
+{
+	// 8-byte alinment required
+
+	//--- LONG WORD 0 ----
+	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+	u8		Category;	// AP/NIC and USB/PCI
+	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+	u16		Version;		// FW Version
+	u8		Subversion;	// FW Subversion, default 0x00
+	u16		Rsvd1;
+
+
+	//--- LONG WORD 1 ----
+	u8		Month;	// Release time Month field
+	u8		Date;	// Release time Date field
+	u8		Hour;	// Release time Hour field
+	u8		Minute;	// Release time Minute field
+	u16		RamCodeSize;	// The size of RAM code
+	u8		Foundry;
+	u8		Rsvd2;
+
+	//--- LONG WORD 2 ----
+	u32		SvnIdx;	// The SVN entry index
+	u32		Rsvd3;
+
+	//--- LONG WORD 3 ----
+	u32		Rsvd4;
+	u32		Rsvd5;
+}RT_8188E_FIRMWARE_HDR, *PRT_8188E_FIRMWARE_HDR;
+#endif // download firmware related data structure
+
+
+#define DRIVER_EARLY_INT_TIME_8188E			0x05
+#define BCN_DMA_ATIME_INT_TIME_8188E		0x02
+
+
+//#define MAX_RX_DMA_BUFFER_SIZE_88E	      0x2400 //9k for 88E nornal chip , //MaxRxBuff=10k-max(TxReportSize(64*8), WOLPattern(16*24))
+#define RX_DMA_SIZE_88E(__Adapter) ((!IS_VENDOR_8188E_I_CUT_SERIES(__Adapter))?0x2800:0x4000)
+
+#ifdef CONFIG_WOWLAN
+#define RESV_FMWF	WKFMCAM_SIZE*MAX_WKFM_NUM /* 16 entries, for each is 24 bytes*/
+#else
+#define RESV_FMWF	0
+#endif
+
+#define RX_DMA_RESERVD_FW_FEATURE	0x200 /* for tx report (64*8) */
+
+#define MAX_RX_DMA_BUFFER_SIZE_88E(__Adapter) RX_DMA_SIZE_88E(__Adapter)-RX_DMA_RESERVD_FW_FEATURE
+
+#define MAX_TX_REPORT_BUFFER_SIZE			0x0400 /* 1k */
+
+// Note: We will divide number of page equally for each queue other than public queue!
+// 22k = 22528 bytes = 176 pages (@page =  128 bytes)
+// must reserved about 7 pages for LPS =>  176-7 = 169 (0xA9)
+// 2*BCN / 1*ps-poll / 1*null-data /1*prob_rsp /1*QOS null-data /1*BT QOS null-data
+
+#define BCNQ_PAGE_NUM_88E		0x08
+
+//For WoWLan , more reserved page
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_88E	0x00
+#else
+#define WOWLAN_PAGE_NUM_88E	0x00
+#endif
+
+/* Note:
+Tx FIFO Size : previous CUT:22K /I_CUT after:32KB
+Tx page Size : 128B
+Total page numbers : 176(0xB0) / 256(0x100)
+*/
+#define TOTAL_PAGE_NUMBER_88E(_Adapter)	((IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)?0x100:0xB0) - 1)/* must reserved 1 page for dma issue */
+#define TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	(TOTAL_PAGE_NUMBER_88E(_Adapter) - BCNQ_PAGE_NUM_88E - WOWLAN_PAGE_NUM_88E)
+#define TX_PAGE_BOUNDARY_88E(_Adapter)		(TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1) /* beacon header start address */
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	TX_TOTAL_PAGE_NUMBER_88E(_Adapter)
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_88E(_Adapter)		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1)
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723B
+#define NORMAL_PAGE_NUM_HPQ_88E		0x0
+#define NORMAL_PAGE_NUM_LPQ_88E		0x09
+#define NORMAL_PAGE_NUM_NPQ_88E		0x0
+
+// Note: For Normal Chip Setting, modify later
+#define WMM_NORMAL_PAGE_NUM_HPQ_88E		0x29
+#define WMM_NORMAL_PAGE_NUM_LPQ_88E		0x1C
+#define WMM_NORMAL_PAGE_NUM_NPQ_88E		0x1C
+
+
+//-------------------------------------------------------------------------
+//	Chip specific
+//-------------------------------------------------------------------------
+#define CHIP_BONDING_IDENTIFIER(_value)	(((_value)>>22)&0x3)
+#define CHIP_BONDING_92C_1T2R	0x1
+#define CHIP_BONDING_88C_USB_MCARD	0x2
+#define CHIP_BONDING_88C_USB_HP	0x1
+
+//-------------------------------------------------------------------------
+//	Channel Plan
+//-------------------------------------------------------------------------
+
+
+#define EFUSE_REAL_CONTENT_LEN		512
+#define EFUSE_MAP_LEN				128
+#define EFUSE_MAX_SECTION			16
+#define EFUSE_IC_ID_OFFSET			506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR(addr) 	(addr < EFUSE_REAL_CONTENT_LEN)
+//
+// <Roger_Notes>
+// To prevent out of boundary programming case,
+// leave 1byte and program full section
+// 9bytes + 1byt + 5bytes and pre 1byte.
+// For worst case:
+// | 1byte|----8bytes----|1byte|--5bytes--|
+// |         |            Reserved(14bytes)	      |
+//
+#define EFUSE_OOB_PROTECT_BYTES 		15	// PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte.
+
+#define		EFUSE_REAL_CONTENT_LEN_88E	256
+#define		EFUSE_MAP_LEN_88E		512
+#define		EFUSE_MAX_SECTION_88E		64
+#define		EFUSE_MAX_WORD_UNIT_88E		4
+#define		EFUSE_IC_ID_OFFSET_88E			506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define 		AVAILABLE_EFUSE_ADDR_88E(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_88E)
+// <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
+// 9bytes + 1byt + 5bytes and pre 1byte.
+// For worst case:
+// | 2byte|----8bytes----|1byte|--7bytes--| //92D
+#define 		EFUSE_OOB_PROTECT_BYTES_88E	18 	// PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte.
+#define		EFUSE_PROTECT_BYTES_BANK_88E	16
+
+
+//========================================================
+//			EFUSE for BT definition
+//========================================================
+#define EFUSE_BT_REAL_CONTENT_LEN		1536	// 512*3
+#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
+#define EFUSE_BT_MAX_SECTION			128		// 1024/8
+
+#define EFUSE_PROTECT_BYTES_BANK		16
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+//#define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? _TRUE : _FALSE)
+
+//#define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) )
+
+#ifdef CONFIG_PCI_HCI
+void InterruptRecognized8188EE(PADAPTER Adapter, PRT_ISR_CONTENT pIsrContent);
+void UpdateInterruptMask8188EE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
+#endif	//CONFIG_PCI_HCI
+
+// rtl8188e_hal_init.c
+
+s32 rtl8188e_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
+void _8051Reset88E(PADAPTER padapter);
+void rtl8188e_InitializeFirmwareVars(PADAPTER padapter);
+
+
+s32 InitLLTTable(PADAPTER padapter, u8 txpktbuf_bndy);
+
+// EFuse
+u8 GetEEPROMSize8188E(PADAPTER padapter);
+void Hal_InitPGData88E(PADAPTER padapter);
+void Hal_EfuseParseIDCode88E(PADAPTER padapter, u8 *hwinfo);
+void Hal_ReadTxPowerInfo88E(PADAPTER padapter,u8* hwinfo,BOOLEAN	AutoLoadFail);
+
+void Hal_EfuseParseEEPROMVer88E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void rtl8188e_EfuseParseChnlPlan(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseCustomerID88E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_ReadAntennaDiversity88E	(PADAPTER pAdapter,u8*PROMContent,BOOLEAN AutoLoadFail);
+void Hal_ReadThermalMeter_88E(PADAPTER	Adapter,u8* PROMContent,BOOLEAN 	AutoloadFail);
+void Hal_EfuseParseXtal_8188E(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+void Hal_EfuseParseBoardType88E(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+void Hal_ReadPowerSavingMode88E(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+
+BOOLEAN HalDetectPwrDownMode88E(PADAPTER Adapter);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+void Hal_ReadRFGainOffset(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+#endif //CONFIG_RF_GAIN_OFFSET
+
+void rtl8188e_init_default_value(_adapter *adapter);
+
+void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8188e(_adapter *adapter);
+
+// register
+void SetBcnCtrlReg(PADAPTER padapter, u8 SetBits, u8 ClearBits);
+
+void rtl8188e_start_thread(_adapter *padapter);
+void rtl8188e_stop_thread(_adapter *padapter);
+
+void rtw_IOL_cmd_tx_pkt_buf_dump(ADAPTER *Adapter,int data_len);
+#ifdef CONFIG_IOL_EFUSE_PATCH
+s32 rtl8188e_iol_efuse_patch(PADAPTER padapter);
+#endif//CONFIG_IOL_EFUSE_PATCH
+void _InitTransferPageSize(PADAPTER padapter);
+
+void SetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
+void ResumeTxBeacon(PADAPTER padapter);
+void StopTxBeacon(PADAPTER padapter);
+u8
+GetHalDefVar8188E(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	);
+#endif //__RTL8188E_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_led.h
new file mode 100644
index 000000000..90b512694
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_led.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_LED_H__
+#define __RTL8188E_LED_H__
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8188eu_InitSwLeds(PADAPTER padapter);
+void rtl8188eu_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_PCI_HCI
+void rtl8188ee_InitSwLeds(PADAPTER padapter);
+void rtl8188ee_DeInitSwLeds(PADAPTER padapter);
+#endif
+#if defined (CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+void rtl8188es_InitSwLeds(PADAPTER padapter);
+void rtl8188es_DeInitSwLeds(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_recv.h
new file mode 100644
index 000000000..eec3c8ef6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_recv.h
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_RECV_H__
+#define __RTL8188E_RECV_H__
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+#if defined(CONFIG_USB_HCI)
+
+#ifndef MAX_RECVBUF_SZ
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+	#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+		//#define MAX_RECVBUF_SZ (32768) // 32k
+		//#define MAX_RECVBUF_SZ (16384) //16K
+		//#define MAX_RECVBUF_SZ (10240) //10K
+		#ifdef CONFIG_PLATFORM_MSTAR
+			#define MAX_RECVBUF_SZ (8192) // 8K
+		#else
+		        #define MAX_RECVBUF_SZ (15360) // 15k < 16k
+		#endif
+		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+	#else
+		#define MAX_RECVBUF_SZ (4000) // about 4K
+	#endif
+#endif
+#endif //!MAX_RECVBUF_SZ
+
+#elif defined(CONFIG_PCI_HCI)
+//#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+//	#define MAX_RECVBUF_SZ (9100)
+//#else
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+//#endif
+
+
+#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+
+#define MAX_RECVBUF_SZ (10240)
+
+#endif
+
+// Rx smooth factor
+#define	Rx_Smooth_Factor (20)
+
+#define TX_RPT1_PKT_LEN 8
+
+typedef struct rxreport_8188e
+{
+	//Offset 0
+	u32 pktlen:14;
+	u32 crc32:1;
+	u32 icverr:1;
+	u32 drvinfosize:4;
+	u32 security:3;
+	u32 qos:1;
+	u32 shift:2;
+	u32 physt:1;
+	u32 swdec:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 eor:1;
+	u32 own:1;
+
+	//Offset 4
+	u32 macid:5;
+	u32 tid:4;
+	u32 hwrsvd:4;
+	u32 amsdu:1;
+	u32 paggr:1;
+	u32 faggr:1;
+	u32 a1fit:4;
+	u32 a2fit:4;
+	u32 pam:1;
+	u32 pwr:1;
+	u32 md:1;
+	u32 mf:1;
+	u32 type:2;
+	u32 mc:1;
+	u32 bc:1;
+
+	//Offset 8
+	u32 seq:12;
+	u32 frag:4;
+	u32 nextpktlen:14;
+	u32 nextind:1;
+	u32 rsvd0831:1;
+
+	//Offset 12
+	u32 rxmcs:6;
+	u32 rxht:1;
+	u32 gf:1;
+	u32 splcp:1;
+	u32 bw:1;
+	u32 htc:1;
+	u32 eosp:1;
+	u32 bssidfit:2;
+	u32 rpt_sel:2;
+	u32 rsvd1216:13;
+	u32 pattern_match:1;
+	u32 unicastwake:1;
+	u32 magicwake:1;
+
+	//Offset 16
+	/*
+	u32 pattern0match:1;
+	u32 pattern1match:1;
+	u32 pattern2match:1;
+	u32 pattern3match:1;
+	u32 pattern4match:1;
+	u32 pattern5match:1;
+	u32 pattern6match:1;
+	u32 pattern7match:1;
+	u32 pattern8match:1;
+	u32 pattern9match:1;
+	u32 patternamatch:1;
+	u32 patternbmatch:1;
+	u32 patterncmatch:1;
+	u32 rsvd1613:19;
+	*/
+	u32 rsvd16;
+
+	//Offset 20
+	u32 tsfl;
+
+	//Offset 24
+	u32 bassn:12;
+	u32 bavld:1;
+	u32 rsvd2413:19;
+} RXREPORT, *PRXREPORT;
+
+
+#if defined (CONFIG_SDIO_HCI)||defined(CONFIG_GSPI_HCI)
+s32 rtl8188es_init_recv_priv(PADAPTER padapter);
+void rtl8188es_free_recv_priv(PADAPTER padapter);
+void rtl8188es_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
+#endif
+
+#ifdef CONFIG_USB_HCI
+void rtl8188eu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+s32 rtl8188eu_init_recv_priv(PADAPTER padapter);
+void rtl8188eu_free_recv_priv(PADAPTER padapter);
+void rtl8188eu_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
+void rtl8188eu_recv_tasklet(void *priv);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8188ee_init_recv_priv(PADAPTER padapter);
+void rtl8188ee_free_recv_priv(PADAPTER padapter);
+#endif
+
+void rtl8188e_query_rx_desc_status(union recv_frame *precvframe, struct recv_stat *prxstat);
+
+#endif /* __RTL8188E_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_rf.h
new file mode 100644
index 000000000..96c026326
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_rf.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_RF_H__
+#define __RTL8188E_RF_H__
+
+
+
+int	PHY_RF6052_Config8188E(	IN	PADAPTER		Adapter	);
+void		rtl8188e_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
+										IN	u16		DataRate);
+void		rtl8188e_PHY_RF6052SetBandwidth(
+										IN	PADAPTER				Adapter,
+										IN	CHANNEL_WIDTH		Bandwidth);
+
+#endif//__RTL8188E_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_spec.h
new file mode 100644
index 000000000..b0dc2759a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_spec.h
@@ -0,0 +1,164 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8188E_SPEC_H__
+#define __RTL8188E_SPEC_H__
+
+
+//============================================================
+//       8188E Regsiter offset definition
+//============================================================
+
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_BB_PAD_CTRL				0x0064
+#define REG_HMEBOX_E0					0x0088
+#define REG_HMEBOX_E1					0x008A
+#define REG_HMEBOX_E2					0x008C
+#define REG_HMEBOX_E3					0x008E
+#define REG_HMEBOX_EXT_0				0x01F0
+#define REG_HMEBOX_EXT_1				0x01F4
+#define REG_HMEBOX_EXT_2				0x01F8
+#define REG_HMEBOX_EXT_3				0x01FC
+#define REG_HIMR_88E					0x00B0 //RTL8188E
+#define REG_HISR_88E					0x00B4 //RTL8188E
+#define REG_HIMRE_88E					0x00B8 //RTL8188E
+#define REG_HISRE_88E					0x00BC //RTL8188E
+#define REG_MACID_NO_LINK_0			0x0484
+#define REG_MACID_NO_LINK_1			0x0488
+#define REG_MACID_PAUSE_0			0x048c
+#define REG_MACID_PAUSE_1			0x0490
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_PKTBUF_DBG_ADDR 			(REG_PKTBUF_DBG_CTRL)
+#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
+#define REG_WOWLAN_WAKE_REASON		REG_MCUTST_WOWLAN
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x01a4
+#define REG_TXPKTBUF_IV_HIGH            0x01a8
+#endif
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#ifdef CONFIG_RF_GAIN_OFFSET
+#define EEPROM_RF_GAIN_OFFSET			0xC1
+#define EEPROM_RF_GAIN_VAL				0xF6
+#define EEPROM_THERMAL_OFFSET			0xF5
+#endif //CONFIG_RF_GAIN_OFFSET
+//----------------------------------------------------------------------------
+//       88E Driver Initialization Offload REG_FDHM0(Offset 0x88, 8 bits)
+//----------------------------------------------------------------------------
+//IOL config for REG_FDHM0(Reg0x88)
+#define CMD_INIT_LLT					BIT0
+#define CMD_READ_EFUSE_MAP		BIT1
+#define CMD_EFUSE_PATCH			BIT2
+#define CMD_IOCONFIG				BIT3
+#define CMD_INIT_LLT_ERR			BIT4
+#define CMD_READ_EFUSE_MAP_ERR	BIT5
+#define CMD_EFUSE_PATCH_ERR		BIT6
+#define CMD_IOCONFIG_ERR			BIT7
+
+//-----------------------------------------------------
+//
+//	Redifine register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+#define ISR_88E				REG_HISR_88E
+
+#ifdef CONFIG_PCI_HCI
+//#define IMR_RX_MASK		(IMR_ROK_88E|IMR_RDU_88E|IMR_RXFOVW_88E)
+#define IMR_TX_MASK			(IMR_VODOK_88E|IMR_VIDOK_88E|IMR_BEDOK_88E|IMR_BKDOK_88E|IMR_MGNTDOK_88E|IMR_HIGHDOK_88E|IMR_BCNDERR0_88E)
+
+#ifdef CONFIG_CONCURRENT_MODE
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_88E | IMR_TBDOK_88E | IMR_TBDER_88E | IMR_BCNDMAINT_E_88E)
+#else
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_88E | IMR_TBDOK_88E | IMR_TBDER_88E)
+#endif
+
+#define RT_AC_INT_MASKS	(IMR_VIDOK_88E | IMR_VODOK_88E | IMR_BEDOK_88E|IMR_BKDOK_88E)
+#endif
+
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_88E 64
+#define SEC_CAM_ENT_NUM_88E 32
+#define NSS_NUM_88E 1
+#define BAND_CAP_88E (BAND_CAP_2G)
+#define BW_CAP_88E (BW_CAP_20M | BW_CAP_40M)
+
+//----------------------------------------------------------------------------
+//       8192C EEPROM/EFUSE share register definition.
+//----------------------------------------------------------------------------
+
+#define EFUSE_ACCESS_ON			0x69	// For RTL8723 only.
+#define EFUSE_ACCESS_OFF			0x00	// For RTL8723 only.
+
+#endif /* __RTL8188E_SPEC_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_sreset.h
new file mode 100644
index 000000000..513556008
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8188E_SRESET_H_
+#define _RTL8188E_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8188e_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8188e_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_xmit.h
new file mode 100644
index 000000000..df2bb365e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188e_xmit.h
@@ -0,0 +1,299 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188E_XMIT_H__
+#define __RTL8188E_XMIT_H__
+
+
+
+
+//For 88e early mode
+#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
+#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
+#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
+#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
+#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
+#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
+#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+#define BMC		BIT(24)
+#define LSG		BIT(26)
+#define FSG		BIT(27)
+#define OWN 		BIT(31)
+
+
+//OFFSET 4
+#define PKT_OFFSET_SZ		0
+#define QSEL_SHT			8
+#define RATE_ID_SHT			16
+#define NAVUSEHDR			BIT(20)
+#define SEC_TYPE_SHT 		22
+#define PKT_OFFSET_SHT		26
+
+//OFFSET 8
+#define AGG_EN				BIT(12)
+#define AGG_BK					BIT(16)
+#define AMPDU_DENSITY_SHT	20
+#define ANTSEL_A			BIT(24)
+#define ANTSEL_B			BIT(25)
+#define TX_ANT_CCK_SHT		26
+#define TX_ANTL_SHT			28
+#define TX_ANT_HT_SHT		30
+
+//OFFSET 12
+#define SEQ_SHT				16
+#define EN_HWSEQ			BIT(31)
+
+//OFFSET 16
+#define 	QOS                          BIT(6)
+#define	HW_SSN				BIT(7)
+#define 	USERATE			BIT(8)
+#define 	DISDATAFB			BIT(10)
+#define   CTS_2_SELF			BIT(11)
+#define	RTS_EN				BIT(12)
+#define	HW_RTS_EN			BIT(13)
+#define 	DATA_SHORT			BIT(24)
+#define 	PWR_STATUS_SHT	15
+#define 	DATA_SC_SHT		20
+#define 	DATA_BW			BIT(25)
+
+//OFFSET 20
+#define	RTY_LMT_EN			BIT(17)
+
+
+//OFFSET 20
+#define SGI					BIT(6)
+#define USB_TXAGG_NUM_SHT	24
+
+typedef struct txdesc_88e
+{
+	//Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 own:1;
+
+	//Offset 4
+	u32 macid:6;
+	u32 rsvd0406:2;
+	u32 qsel:5;
+	u32 rd_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:4;
+	u32 navusehdr:1;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 rsvd0424:2;
+	u32 pkt_offset:5;	// unit: 8 bytes
+	u32 rsvd0431:1;
+
+	//Offset 8
+	u32 rts_rc:6;
+	u32 data_rc:6;
+	u32 agg_en:1;
+	u32 rd_en:1;
+	u32 bar_rty_th:2;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 ccx:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 ant_sel_a:1;
+	u32 ant_sel_b:1;
+	u32 tx_ant_cck:2;
+	u32 tx_antl:2;
+	u32 tx_ant_ht:2;
+
+	//Offset 12
+	u32 nextheadpage:8;
+	u32 tailpage:8;
+	u32 seq:12;
+	u32 cpu_handle:1;
+	u32 tag1:1;
+	u32 trigger_int:1;
+	u32 hwseq_en:1;
+
+	//Offset 16
+	u32 rtsrate:5;
+	u32 ap_dcfe:1;
+	u32 hwseq_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 pwr_status:3;
+	u32 wait_dcts:1;
+	u32 cts2ap_en:1;
+	u32 data_sc:2;
+	u32 data_stbc:2;
+	u32 data_short:1;
+	u32 data_bw:1;
+	u32 rts_short:1;
+	u32 rts_bw:1;
+	u32 rts_sc:2;
+	u32 vcs_stbc:2;
+
+	//Offset 20
+	u32 datarate:6;
+	u32 sgi:1;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 usb_txagg_num:8;
+
+	//Offset 24
+	u32 txagg_a:5;
+	u32 txagg_b:5;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 mcsg1_max_len:4;
+	u32 mcsg2_max_len:4;
+	u32 mcsg3_max_len:4;
+	u32 mcs7_sgi_max_len:4;
+
+	//Offset 28
+	u32 checksum:16;	// TxBuffSize(PCIe)/CheckSum(USB)
+	u32 sw0:8; /* offset 30 */
+	u32 sw1:4;
+	u32 mcs15_sgi_max_len:4;
+}TXDESC_8188E, *PTXDESC_8188E;
+
+#define txdesc_set_ccx_sw_88e(txdesc, value) \
+	do { \
+		((struct txdesc_88e *)(txdesc))->sw1 = (((value)>>8) & 0x0f); \
+		((struct txdesc_88e *)(txdesc))->sw0 = ((value) & 0xff); \
+	} while (0)
+
+struct txrpt_ccx_88e {
+	/* offset 0 */
+	u8 tag1:1;
+	u8 pkt_num:3;
+	u8 txdma_underflow:1;
+	u8 int_bt:1;
+	u8 int_tri:1;
+	u8 int_ccx:1;
+
+	/* offset 1 */
+	u8 mac_id:6;
+	u8 pkt_ok:1;
+	u8 bmc:1;
+
+	/* offset 2 */
+	u8 retry_cnt:6;
+	u8 lifetime_over:1;
+	u8 retry_over:1;
+
+	/* offset 3 */
+	u8 ccx_qtime0;
+	u8 ccx_qtime1;
+
+	/* offset 5 */
+	u8 final_data_rate;
+
+	/* offset 6 */
+	u8 sw1:4;
+	u8 qsel:4;
+
+	/* offset 7 */
+	u8 sw0;
+};
+
+#define txrpt_ccx_sw_88e(txrpt_ccx) ((txrpt_ccx)->sw0 + ((txrpt_ccx)->sw1<<8))
+#define txrpt_ccx_qtime_88e(txrpt_ccx) ((txrpt_ccx)->ccx_qtime0+((txrpt_ccx)->ccx_qtime1<<8))
+
+#define SET_TX_DESC_SEC_TYPE_8188E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+
+void rtl8188e_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,
+		u8 IsPsPoll,u8	IsBTQosNull, u8 bDataFrame);
+void rtl8188e_cal_txdesc_chksum(struct tx_desc	*ptxdesc);
+
+#if defined(CONFIG_SDIO_HCI)||defined (CONFIG_GSPI_HCI)
+s32 rtl8188es_init_xmit_priv(PADAPTER padapter);
+void rtl8188es_free_xmit_priv(PADAPTER padapter);
+s32 rtl8188es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8188es_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+thread_return rtl8188es_xmit_thread(thread_context context);
+s32 rtl8188es_xmit_buf_handler(PADAPTER padapter);
+
+#ifdef CONFIG_SDIO_TX_TASKLET
+void rtl8188es_xmit_tasklet(void *priv);
+#endif
+#endif
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8188eu_init_xmit_priv(PADAPTER padapter);
+void rtl8188eu_free_xmit_priv(PADAPTER padapter);
+s32 rtl8188eu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188eu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8188eu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188eu_xmit_buf_handler(PADAPTER padapter);
+void rtl8188eu_xmit_tasklet(void *priv);
+s32 rtl8188eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8188ee_init_xmit_priv(PADAPTER padapter);
+void rtl8188ee_free_xmit_priv(PADAPTER padapter);
+void	rtl8188ee_xmitframe_resume(_adapter *padapter);
+s32 rtl8188ee_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188ee_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8188ee_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtl8188ee_xmit_tasklet(void *priv);
+#endif
+
+
+
+#ifdef CONFIG_TX_EARLY_MODE
+void UpdateEarlyModeInfo8188E(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf );
+#endif
+
+#ifdef CONFIG_XMIT_ACK
+void dump_txrpt_ccx_88e(void *buf);
+void handle_txrpt_ccx_88e(_adapter *adapter, u8 *buf);
+#else
+#define dump_txrpt_ccx_88e(buf) do {} while(0)
+#define handle_txrpt_ccx_88e(adapter, buf) do {} while(0)
+#endif //CONFIG_XMIT_ACK
+
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,struct tx_desc *ptxdesc);
+#endif //__RTL8188E_XMIT_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_cmd.h
new file mode 100644
index 000000000..6e71cf160
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_cmd.h
@@ -0,0 +1,218 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_CMD_H__
+#define __RTL8188F_CMD_H__
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD DEFINITION    ------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+enum h2c_cmd_8188F{
+	//Common Class: 000
+	H2C_8188F_RSVD_PAGE = 0x00,
+	H2C_8188F_MEDIA_STATUS_RPT = 0x01,
+	H2C_8188F_SCAN_ENABLE = 0x02,
+	H2C_8188F_KEEP_ALIVE = 0x03,
+	H2C_8188F_DISCON_DECISION = 0x04,
+	H2C_8188F_PSD_OFFLOAD = 0x05,
+	H2C_8188F_AP_OFFLOAD = 0x08,
+	H2C_8188F_BCN_RSVDPAGE = 0x09,
+	H2C_8188F_PROBERSP_RSVDPAGE = 0x0A,
+	H2C_8188F_FCS_RSVDPAGE = 0x10,
+	H2C_8188F_FCS_INFO = 0x11,
+	H2C_8188F_AP_WOW_GPIO_CTRL = 0x13,
+
+	//PoweSave Class: 001
+	H2C_8188F_SET_PWR_MODE = 0x20,
+	H2C_8188F_PS_TUNING_PARA = 0x21,
+	H2C_8188F_PS_TUNING_PARA2 = 0x22,
+	H2C_8188F_P2P_LPS_PARAM = 0x23,
+	H2C_8188F_P2P_PS_OFFLOAD = 0x24,
+	H2C_8188F_PS_SCAN_ENABLE = 0x25,
+	H2C_8188F_SAP_PS_ = 0x26,
+	H2C_8188F_INACTIVE_PS_ = 0x27, //Inactive_PS
+	H2C_8188F_FWLPS_IN_IPS_ = 0x28,
+
+	//Dynamic Mechanism Class: 010
+	H2C_8188F_MACID_CFG = 0x40,
+	H2C_8188F_TXBF = 0x41,
+	H2C_8188F_RSSI_SETTING = 0x42,
+	H2C_8188F_AP_REQ_TXRPT = 0x43,
+	H2C_8188F_INIT_RATE_COLLECT = 0x44,
+	H2C_8188F_RA_PARA_ADJUST = 0x46,
+
+	//BT Class: 011
+	H2C_8188F_B_TYPE_TDMA = 0x60,
+	H2C_8188F_BT_INFO = 0x61,
+	H2C_8188F_FORCE_BT_TXPWR = 0x62,
+	H2C_8188F_BT_IGNORE_WLANACT = 0x63,
+	H2C_8188F_DAC_SWING_VALUE = 0x64,
+	H2C_8188F_ANT_SEL_RSV = 0x65,
+	H2C_8188F_WL_OPMODE = 0x66,
+	H2C_8188F_BT_MP_OPER = 0x67,
+	H2C_8188F_BT_CONTROL = 0x68,
+	H2C_8188F_BT_WIFI_CTRL = 0x69,
+	H2C_8188F_BT_FW_PATCH = 0x6A,
+	H2C_8188F_BT_WLAN_CALIBRATION = 0x6D,
+
+	//WOWLAN Class: 100
+	H2C_8188F_WOWLAN = 0x80,
+	H2C_8188F_REMOTE_WAKE_CTRL = 0x81,
+	H2C_8188F_AOAC_GLOBAL_INFO = 0x82,
+	H2C_8188F_AOAC_RSVD_PAGE = 0x83,
+	H2C_8188F_AOAC_RSVD_PAGE2 = 0x84,
+	H2C_8188F_D0_SCAN_OFFLOAD_CTRL = 0x85,
+	H2C_8188F_D0_SCAN_OFFLOAD_INFO = 0x86,
+	H2C_8188F_CHNL_SWITCH_OFFLOAD = 0x87,
+	H2C_8188F_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
+	H2C_8188F_P2P_OFFLOAD = 0x8B,
+
+	H2C_8188F_RESET_TSF = 0xC0,
+	H2C_8188F_MAXID,
+};
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD CONTENT    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+//_RSVDPAGE_LOC_CMD_0x00
+#define SET_8188F_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8188F_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8188F_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8188F_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8188F_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+
+//_KEEP_ALIVE_CMD_0x03
+#define SET_8188F_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8188F_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8188F_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8188F_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
+
+//_DISCONNECT_DECISION_CMD_0x04
+#define SET_8188F_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8188F_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8188F_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8188F_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+2, 0, 8, __Value)
+
+// _PWR_MOD_CMD_0x20
+#define SET_8188F_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8188F_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8188F_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8188F_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8188F_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8188F_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8188F_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+5, 0, 8, __Value)
+
+#define GET_8188F_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+// _PS_TUNE_PARAM_CMD_0x21
+#define SET_8188F_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8188F_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8188F_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
+#define SET_8188F_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
+#define SET_8188F_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+
+//_MACID_CFG_CMD_0x40
+#define SET_8188F_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
+#define SET_8188F_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)
+
+//_RSSI_SETTING_CMD_0x42
+#define SET_8188F_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8188F_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
+#define SET_8188F_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+
+// _AP_REQ_TXRPT_CMD_0x43
+#define SET_8188F_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8188F_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+
+// _FORCE_BT_TXPWR_CMD_0x62
+#define SET_8188F_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+
+// _FORCE_BT_MP_OPER_CMD_0x67
+#define SET_8188F_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#define SET_8188F_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
+#define SET_8188F_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8188F_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+#define SET_8188F_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_8188F_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+
+// _BT_FW_PATCH_0x6A
+#define SET_8188F_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((pu1Byte)(__pH2CCmd), 0, 16, __Value)
+#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8188F_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+
+
+//---------------------------------------------------------------------------------------------------------//
+//-------------------------------------------    Structure    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    Function Statement     --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+// host message to firmware cmd
+void rtl8188f_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
+void rtl8188f_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
+void rtl8188f_set_rssi_cmd(PADAPTER padapter, u8 *param);
+void rtl8188f_Add_RateATid(PADAPTER pAdapter, u64 bitmap, u8* arg, u8 rssi_level);
+void rtl8188f_fw_try_ap_cmd(PADAPTER padapter, u32 need_ack);
+//s32 rtl8188f_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable);
+void rtl8188f_set_FwPsTuneParam_cmd(PADAPTER padapter);
+void rtl8188f_set_FwMacIdConfig_cmd(_adapter* padapter, u8 mac_id, u8 raid, u8 bw, u8 sgi, u32 mask);
+void rtl8188f_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
+void rtl8188f_download_rsvd_page(PADAPTER padapter, u8 mstatus);
+#ifdef CONFIG_BT_COEXIST
+void rtl8188f_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
+#ifdef CONFIG_P2P
+void rtl8188f_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void SetFwRelatedForWoWLAN8188f(_adapter* padapter, u8 bHostIsGoingtoSleep);
+#endif//CONFIG_WOWLAN
+
+#ifdef CONFIG_P2P_WOWLAN
+void rtl8188f_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
+#endif
+
+void rtl8188f_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+u8 rtl8188f_reset_tsf(_adapter *padapter, u8 reset_port);
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+s32 FillH2CCmd8188F(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8188F(_adapter *padapter, bool wowlan);
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_dm.h
new file mode 100644
index 000000000..d703ae524
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_dm.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_DM_H__
+#define __RTL8188F_DM_H__
+//============================================================
+// Description:
+//
+// This file is for 8188F dynamic mechanism only
+//
+//
+//============================================================
+
+//============================================================
+// structure and define
+//============================================================
+
+//============================================================
+// function prototype
+//============================================================
+
+void rtl8188f_init_dm_priv(PADAPTER padapter);
+void rtl8188f_deinit_dm_priv(PADAPTER padapter);
+
+void rtl8188f_InitHalDm(PADAPTER padapter);
+void rtl8188f_HalDmWatchDog(PADAPTER padapter);
+void rtl8188f_HalDmWatchDog_in_LPS(PADAPTER padapter);
+void rtl8188f_hal_dm_in_lps(PADAPTER padapter);
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_hal.h
new file mode 100644
index 000000000..064df8ca2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_hal.h
@@ -0,0 +1,322 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_HAL_H__
+#define __RTL8188F_HAL_H__
+
+#include "hal_data.h"
+
+#include "rtl8188f_spec.h"
+#include "rtl8188f_rf.h"
+#include "rtl8188f_dm.h"
+#include "rtl8188f_recv.h"
+#include "rtl8188f_xmit.h"
+#include "rtl8188f_cmd.h"
+#include "rtl8188f_led.h"
+#include "Hal8188FPwrSeq.h"
+#include "Hal8188FPhyReg.h"
+#include "Hal8188FPhyCfg.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8188f_sreset.h"
+#endif
+
+
+//---------------------------------------------------------------------
+//		RTL8188F From file
+//---------------------------------------------------------------------
+	#define RTL8188F_FW_IMG					"rtl8188f/FW_NIC.bin"
+	#define RTL8188F_FW_WW_IMG				"rtl8188f/FW_WoWLAN.bin"
+	#define RTL8188F_PHY_REG					"rtl8188f/PHY_REG.txt"
+	#define RTL8188F_PHY_RADIO_A				"rtl8188f/RadioA.txt"
+	#define RTL8188F_PHY_RADIO_B				"rtl8188f/RadioB.txt"
+	#define RTL8188F_TXPWR_TRACK				"rtl8188f/TxPowerTrack.txt"
+	#define RTL8188F_AGC_TAB					"rtl8188f/AGC_TAB.txt"
+	#define RTL8188F_PHY_MACREG 				"rtl8188f/MAC_REG.txt"
+	#define RTL8188F_PHY_REG_PG				"rtl8188f/PHY_REG_PG.txt"
+	#define RTL8188F_PHY_REG_MP				"rtl8188f/PHY_REG_MP.txt"
+	#define RTL8188F_TXPWR_LMT 				"rtl8188f/TXPWR_LMT.txt"
+
+//---------------------------------------------------------------------
+//		RTL8188F From header
+//---------------------------------------------------------------------
+
+#if MP_DRIVER == 1
+	#define Rtl8188F_FwBTImgArray				Rtl8188FFwBTImgArray
+	#define Rtl8188F_FwBTImgArrayLength		Rtl8188FFwBTImgArrayLength
+
+	#define Rtl8188F_FwMPImageArray			Rtl8188FFwMPImgArray
+	#define Rtl8188F_FwMPImgArrayLength		Rtl8188FMPImgArrayLength
+
+	#define Rtl8188F_PHY_REG_Array_MP			Rtl8188F_PHYREG_Array_MP
+	#define Rtl8188F_PHY_REG_Array_MPLength	Rtl8188F_PHYREG_Array_MPLength
+#endif
+
+
+#define FW_8188F_SIZE			0x8000
+#define FW_8188F_START_ADDRESS	0x1000
+#define FW_8188F_END_ADDRESS		0x1FFF //0x5FFF
+
+#define IS_FW_HEADER_EXIST_8188F(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x88F0)
+
+typedef struct _RT_FIRMWARE {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[FW_8188F_SIZE];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8188F, *PRT_FIRMWARE_8188F;
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+typedef struct _RT_8188F_FIRMWARE_HDR
+{
+	// 8-byte alinment required
+
+	//--- LONG WORD 0 ----
+	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+	u8		Category;	// AP/NIC and USB/PCI
+	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+	u16		Version;		// FW Version
+	u16		Subversion;	// FW Subversion, default 0x00
+
+	//--- LONG WORD 1 ----
+	u8		Month;	// Release time Month field
+	u8		Date;	// Release time Date field
+	u8		Hour;	// Release time Hour field
+	u8		Minute;	// Release time Minute field
+	u16		RamCodeSize;	// The size of RAM code
+	u16		Rsvd2;
+
+	//--- LONG WORD 2 ----
+	u32		SvnIdx;	// The SVN entry index
+	u32		Rsvd3;
+
+	//--- LONG WORD 3 ----
+	u32		Rsvd4;
+	u32		Rsvd5;
+}RT_8188F_FIRMWARE_HDR, *PRT_8188F_FIRMWARE_HDR;
+
+#define DRIVER_EARLY_INT_TIME_8188F		0x05
+#define BCN_DMA_ATIME_INT_TIME_8188F		0x02
+
+// for 8188F
+// TX 32K, RX 16K, Page size 128B for TX, 8B for RX
+#define PAGE_SIZE_TX_8188F			128
+#define PAGE_SIZE_RX_8188F			8
+
+#define RX_DMA_SIZE_8188F			0x4000	// 16K
+#ifdef CONFIG_FW_C2H_DEBUG
+#define RX_DMA_RESERVED_SIZE_8188F	0x100	// 256B, reserved for c2h debug message
+#else
+#define RX_DMA_RESERVED_SIZE_8188F	0x80	// 128B, reserved for tx report
+#endif
+
+#ifdef CONFIG_WOWLAN
+#define RESV_FMWF	WKFMCAM_SIZE*MAX_WKFM_NUM /* 16 entries, for each is 24 bytes*/
+#else
+#define RESV_FMWF	0
+#endif
+
+#define RX_DMA_BOUNDARY_8188F		(RX_DMA_SIZE_8188F - RX_DMA_RESERVED_SIZE_8188F - 1)
+
+// Note: We will divide number of page equally for each queue other than public queue!
+
+//For General Reserved Page Number(Beacon Queue is reserved page)
+//Beacon:2, PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1
+#define BCNQ_PAGE_NUM_8188F		0x08
+#ifdef CONFIG_CONCURRENT_MODE
+#define BCNQ1_PAGE_NUM_8188F		0x08 // 0x04
+#else
+#define BCNQ1_PAGE_NUM_8188F		0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef BCNQ1_PAGE_NUM_8188F
+#define BCNQ1_PAGE_NUM_8188F		0x00 // 0x04
+#endif
+
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8188F	0x07
+#else
+#define WOWLAN_PAGE_NUM_8188F	0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef WOWLAN_PAGE_NUM_8188F
+#define WOWLAN_PAGE_NUM_8188F	0x15
+#endif
+
+#ifdef CONFIG_AP_WOWLAN
+#define AP_WOWLAN_PAGE_NUM_8188F	0x02
+#endif
+
+#define TX_TOTAL_PAGE_NUMBER_8188F	(0xFF - BCNQ_PAGE_NUM_8188F - BCNQ1_PAGE_NUM_8188F - WOWLAN_PAGE_NUM_8188F)
+#define TX_PAGE_BOUNDARY_8188F		(TX_TOTAL_PAGE_NUMBER_8188F + 1)
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8188F	TX_TOTAL_PAGE_NUMBER_8188F
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8188F		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8188F + 1)
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8188F
+#define NORMAL_PAGE_NUM_HPQ_8188F		0x0C
+#define NORMAL_PAGE_NUM_LPQ_8188F		0x02
+#define NORMAL_PAGE_NUM_NPQ_8188F		0x02
+
+// Note: For Normal Chip Setting, modify later
+#define WMM_NORMAL_PAGE_NUM_HPQ_8188F		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8188F		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8188F		0x20
+
+
+#include "HalVerDef.h"
+#include "hal_com.h"
+
+#define EFUSE_OOB_PROTECT_BYTES 		15
+
+#define HAL_EFUSE_MEMORY
+
+#define HWSET_MAX_SIZE_8188F			512
+#define EFUSE_REAL_CONTENT_LEN_8188F		512
+#define EFUSE_MAP_LEN_8188F				512
+#define EFUSE_MAX_SECTION_8188F			64
+
+#define EFUSE_IC_ID_OFFSET			506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_8188F)
+
+#define EFUSE_ACCESS_ON			0x69	// For RTL8188 only.
+#define EFUSE_ACCESS_OFF			0x00	// For RTL8188 only.
+
+//========================================================
+//			EFUSE for BT definition
+//========================================================
+#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
+#define EFUSE_BT_REAL_CONTENT_LEN		1536	// 512*3
+#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
+#define EFUSE_BT_MAX_SECTION			128		// 1024/8
+
+#define EFUSE_PROTECT_BYTES_BANK		16
+
+typedef struct _C2H_EVT_HDR
+{
+	u8	CmdID;
+	u8	CmdLen;
+	u8	CmdSeq;
+} __attribute__((__packed__)) C2H_EVT_HDR, *PC2H_EVT_HDR;
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+// rtl8188a_hal_init.c
+s32 rtl8188f_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
+void rtl8188f_FirmwareSelfReset(PADAPTER padapter);
+void rtl8188f_InitializeFirmwareVars(PADAPTER padapter);
+
+void rtl8188f_InitAntenna_Selection(PADAPTER padapter);
+void rtl8188f_DeinitAntenna_Selection(PADAPTER padapter);
+void rtl8188f_CheckAntenna_Selection(PADAPTER padapter);
+void rtl8188f_init_default_value(PADAPTER padapter);
+
+s32 rtl8188f_InitLLTTable(PADAPTER padapter);
+
+s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
+s32 CardDisableWithoutHWSM(PADAPTER padapter);
+
+// EFuse
+u8 GetEEPROMSize8188F(PADAPTER padapter);
+void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
+void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
+void Hal_EfuseParseTxPowerInfo_8188F(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
+/* void Hal_EfuseParseBTCoexistInfo_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail); */
+void Hal_EfuseParseEEPROMVer_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseChnlPlan_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseCustomerID_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParsePowerSavingMode_8188F(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseAntennaDiversity_8188F(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseXtal_8188F(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
+void Hal_EfuseParseThermalMeter_8188F(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
+void Hal_EfuseParseKFreeData_8188F(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+VOID Hal_EfuseParseMacHidden_8188F(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+
+#if 0 /* Do not need for rtl8188f */
+VOID Hal_EfuseParseVoltage_8188F(PADAPTER pAdapter,u8* hwinfo,BOOLEAN 	AutoLoadFail);
+#endif
+
+#ifdef CONFIG_C2H_PACKET_EN
+void rtl8188f_c2h_packet_handler(PADAPTER padapter, u8 *pbuf, u16 length);
+#endif
+
+void rtl8188f_set_pll_ref_clk_sel(_adapter *adapter, u8 sel);
+
+void rtl8188f_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8188f(_adapter *adapter);
+void SetHwReg8188F(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg8188F(PADAPTER padapter, u8 variable, u8 *val);
+#ifdef CONFIG_C2H_PACKET_EN
+void SetHwRegWithBuf8188F(PADAPTER padapter, u8 variable, u8 *pbuf, int len);
+#endif // CONFIG_C2H_PACKET_EN
+u8 SetHalDefVar8188F(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+u8 GetHalDefVar8188F(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+
+// register
+void rtl8188f_InitBeaconParameters(PADAPTER padapter);
+void rtl8188f_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
+void	_InitBurstPktLen_8188FS(PADAPTER Adapter);
+void _8051Reset8188(PADAPTER padapter);
+#ifdef CONFIG_WOWLAN
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+void rtl8188f_start_thread(_adapter *padapter);
+void rtl8188f_stop_thread(_adapter *padapter);
+
+#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
+void rtl8188fs_init_checkbthang_workqueue(_adapter * adapter);
+void rtl8188fs_free_checkbthang_workqueue(_adapter * adapter);
+void rtl8188fs_cancle_checkbthang_workqueue(_adapter * adapter);
+void rtl8188fs_hal_check_bt_hang(_adapter * adapter);
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
+#endif
+
+int FirmwareDownloadBT(IN PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
+
+void CCX_FwC2HTxRpt_8188f(PADAPTER padapter, u8 *pdata, u8 len);
+#ifdef CONFIG_FW_C2H_DEBUG
+void Debug_FwC2H_8188f(PADAPTER padapter, u8 *pdata, u8 len);
+#endif //CONFIG_FW_C2H_DEBUG
+s32 c2h_id_filter_ccx_8188f(u8 *buf);
+s32 c2h_handler_8188f(PADAPTER padapter, u8 *pC2hEvent);
+u8 MRateToHwRate8188F(u8  rate);
+u8 HwRateToMRate8188F(u8	 rate);
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8188FE(PADAPTER Adapter);
+VOID	UpdateInterruptMask8188FE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_led.h
new file mode 100644
index 000000000..9b7bf78c5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_led.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_LED_H__
+#define __RTL8188F_LED_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8188fu_InitSwLeds(PADAPTER padapter);
+void rtl8188fu_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_SDIO_HCI
+void rtl8188fs_InitSwLeds(PADAPTER padapter);
+void rtl8188fs_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_GSPI_HCI
+void rtl8188fs_InitSwLeds(PADAPTER padapter);
+void rtl8188fs_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_PCI_HCI
+void rtl8188fe_InitSwLeds(PADAPTER padapter);
+void rtl8188fe_DeInitSwLeds(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_recv.h
new file mode 100644
index 000000000..18f84ea79
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_recv.h
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_RECV_H__
+#define __RTL8188F_RECV_H__
+
+#if defined(CONFIG_USB_HCI)
+	#ifndef MAX_RECVBUF_SZ
+		#ifdef PLATFORM_OS_CE
+			#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+		#else
+			#ifdef CONFIG_MINIMAL_MEMORY_USAGE
+				#define MAX_RECVBUF_SZ (4000) // about 4K
+			#else
+				#ifdef CONFIG_PLATFORM_MSTAR
+					#define MAX_RECVBUF_SZ (8192) // 8K
+				#elif defined(CONFIG_PLATFORM_HISILICON)
+					#define MAX_RECVBUF_SZ (16384) /* 16k */
+				#else
+					#define MAX_RECVBUF_SZ (32768) /* 32k */
+				#endif
+				//#define MAX_RECVBUF_SZ (20480) //20K
+				//#define MAX_RECVBUF_SZ (10240) //10K
+				//#define MAX_RECVBUF_SZ (16384) //  16k - 92E RX BUF :16K
+				//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+			#endif
+		#endif
+	#endif //!MAX_RECVBUF_SZ
+#elif defined(CONFIG_PCI_HCI)
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+#elif defined(CONFIG_SDIO_HCI)
+	#define MAX_RECVBUF_SZ (RX_DMA_BOUNDARY_8188F + 1)
+#endif /* CONFIG_SDIO_HCI */
+
+// Rx smooth factor
+#define	Rx_Smooth_Factor (20)
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+s32 rtl8188fs_init_recv_priv(PADAPTER padapter);
+void rtl8188fs_free_recv_priv(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_USB_HCI
+int rtl8188fu_init_recv_priv(_adapter *padapter);
+void rtl8188fu_free_recv_priv (_adapter *padapter);
+void rtl8188fu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8188fe_init_recv_priv(PADAPTER padapter);
+void rtl8188fe_free_recv_priv(PADAPTER padapter);
+#endif
+
+void rtl8188f_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+
+#endif /* __RTL8188F_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_rf.h
new file mode 100644
index 000000000..ea71ef13e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_rf.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_RF_H__
+#define __RTL8188F_RF_H__
+
+int	PHY_RF6052_Config8188F(	IN	PADAPTER		Adapter	);
+
+VOID
+PHY_RF6052SetBandwidth8188F(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH		Bandwidth);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_spec.h
new file mode 100644
index 000000000..801e6caeb
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_spec.h
@@ -0,0 +1,302 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8188F_SPEC_H__
+#define __RTL8188F_SPEC_H__
+
+#include <drv_conf.h>
+
+
+#define HAL_NAV_UPPER_UNIT_8188F		128		// micro-second
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_RSV_CTRL_8188F				0x001C	// 3 Byte
+#define REG_BT_WIFI_ANTENNA_SWITCH_8188F	0x0038
+#define REG_HSISR_8188F					0x005c
+#define REG_PAD_CTRL1_8188F		0x0064
+#define REG_AFE_CTRL_4_8188F		0x0078
+#define REG_HMEBOX_DBG_0_8188F	0x0088
+#define REG_HMEBOX_DBG_1_8188F	0x008A
+#define REG_HMEBOX_DBG_2_8188F	0x008C
+#define REG_HMEBOX_DBG_3_8188F	0x008E
+#define REG_HIMR0_8188F					0x00B0
+#define REG_HISR0_8188F					0x00B4
+#define REG_HIMR1_8188F					0x00B8
+#define REG_HISR1_8188F					0x00BC
+#define REG_PMC_DBG_CTRL2_8188F			0x00CC
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_C2HEVT_CMD_ID_8188F	0x01A0
+#define REG_C2HEVT_CMD_LEN_8188F	0x01AE
+#define REG_WOWLAN_WAKE_REASON 0x01C7
+#define REG_WOWLAN_GTK_DBG1	0x630
+#define REG_WOWLAN_GTK_DBG2	0x634
+
+#define REG_HMEBOX_EXT0_8188F			0x01F0
+#define REG_HMEBOX_EXT1_8188F			0x01F4
+#define REG_HMEBOX_EXT2_8188F			0x01F8
+#define REG_HMEBOX_EXT3_8188F			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_CONTROL_8188F		0x0286 // Control the RX DMA.
+#define REG_RXDMA_MODE_CTRL_8188F		0x0290
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG_8188F		0x0300
+#define	REG_INT_MIG_8188F				0x0304	// Interrupt Migration
+#define	REG_BCNQ_DESA_8188F			0x0308	// TX Beacon Descriptor Address
+#define	REG_HQ_DESA_8188F				0x0310	// TX High Queue Descriptor Address
+#define	REG_MGQ_DESA_8188F			0x0318	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_DESA_8188F			0x0320	// TX VO Queue Descriptor Address
+#define	REG_VIQ_DESA_8188F				0x0328	// TX VI Queue Descriptor Address
+#define	REG_BEQ_DESA_8188F			0x0330	// TX BE Queue Descriptor Address
+#define	REG_BKQ_DESA_8188F			0x0338	// TX BK Queue Descriptor Address
+#define	REG_RX_DESA_8188F				0x0340	// RX Queue	Descriptor Address
+#define	REG_DBI_WDATA_8188F			0x0348	// DBI Write Data
+#define	REG_DBI_RDATA_8188F			0x034C	// DBI Read Data
+#define	REG_DBI_ADDR_8188F				0x0350	// DBI Address
+#define	REG_DBI_FLAG_8188F				0x0352	// DBI Read/Write Flag
+#define	REG_MDIO_WDATA_8188F		0x0354	// MDIO for Write PCIE PHY
+#define	REG_MDIO_RDATA_8188F			0x0356	// MDIO for Reads PCIE PHY
+#define	REG_MDIO_CTL_8188F			0x0358	// MDIO for Control
+#define	REG_DBG_SEL_8188F				0x0360	// Debug Selection Register
+#define	REG_PCIE_HRPWM_8188F			0x0361	//PCIe RPWM
+#define	REG_PCIE_HCPWM_8188F			0x0363	//PCIe CPWM
+#define	REG_PCIE_MULTIFET_CTRL_8188F	0x036A	//PCIE Multi-Fethc Control
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_TXPKTBUF_BCNQ_BDNY_8188F	0x0424
+#define REG_TXPKTBUF_MGQ_BDNY_8188F	0x0425
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8188F	0x045D
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
+#define REG_AMPDU_BURST_MODE_8188F	0x04BC
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_SECONDARY_CCA_CTRL_8188F	0x0577
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+
+
+//============================================================
+// SDIO Bus Specification
+//============================================================
+
+//-----------------------------------------------------
+// SDIO CMD Address Mapping
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// I/O bus domain (Host)
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// SDIO register
+//-----------------------------------------------------
+#define SDIO_REG_HIQ_FREEPG_8188F		0x0020
+#define SDIO_REG_MID_FREEPG_8188F		0x0022
+#define SDIO_REG_LOW_FREEPG_8188F		0x0024
+#define SDIO_REG_PUB_FREEPG_8188F		0x0026
+#define SDIO_REG_EXQ_FREEPG_8188F		0x0028
+#define SDIO_REG_AC_OQT_FREEPG_8188F	0x002A
+#define SDIO_REG_NOAC_OQT_FREEPG_8188F	0x002B
+
+#define SDIO_REG_HCPWM1_8188F			0x0038
+
+/* indirect access */
+#define SDIO_REG_INDIRECT_REG_CFG_8188F		0x40
+#define SET_INDIRECT_REG_ADDR(_cmd, _addr)	SET_BITS_TO_LE_2BYTE(((u8 *)(_cmd)) + 0, 0, 16, (_addr))
+#define SET_INDIRECT_REG_SIZE_1BYTE(_cmd)	SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 0, 2, 0)
+#define SET_INDIRECT_REG_SIZE_2BYTE(_cmd)	SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 0, 2, 1)
+#define SET_INDIRECT_REG_SIZE_4BYTE(_cmd)	SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 0, 2, 2)
+#define SET_INDIRECT_REG_WRITE(_cmd)		SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 2, 1, 1)
+#define SET_INDIRECT_REG_READ(_cmd)			SET_BITS_TO_LE_1BYTE(((u8 *)(_cmd)) + 2, 3, 1, 1)
+#define GET_INDIRECT_REG_RDY(_cmd)			LE_BITS_TO_1BYTE(((u8 *)(_cmd)) + 2, 4, 1)
+
+#define SDIO_REG_INDIRECT_REG_DATA_8188F	0x44
+
+//============================================================================
+//	8188 Regsiter Bit and Content definition
+//============================================================================
+
+//2 HSISR
+// interrupt mask which needs to clear
+#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
+								HSISR_SPS_OCP_INT |\
+								HSISR_RON_INT |\
+								HSISR_PDNINT |\
+								HSISR_GPIO9_INT)
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define BIT_USB_RXDMA_AGG_EN	BIT(31)
+#define RXDMA_AGG_MODE_EN		BIT(1)
+
+#ifdef CONFIG_WOWLAN
+#define RXPKT_RELEASE_POLL		BIT(16)
+#define RXDMA_IDLE				BIT(17)
+#define RW_RELEASE_EN			BIT(18)
+#endif
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+
+//----------------------------------------------------------------------------
+//       8188F REG_CCK_CHECK						(offset 0x454)
+//----------------------------------------------------------------------------
+#define BIT_BCN_PORT_SEL		BIT5
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+
+//----------------------------------------------------------------------------
+//       8195 IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8188F					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8188F					BIT31		// Timeout interrupt 2
+#define	IMR_TIMER1_8188F					BIT30		// Timeout interrupt 1
+#define	IMR_PSTIMEOUT_8188F				BIT29		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8188F					BIT28		// When GTIMER4 expires, this bit is set to 1
+#define	IMR_GTINT3_8188F					BIT27		// When GTIMER3 expires, this bit is set to 1
+#define	IMR_TXBCN0ERR_8188F				BIT26		// Transmit Beacon0 Error
+#define	IMR_TXBCN0OK_8188F				BIT25		// Transmit Beacon0 OK
+#define	IMR_TSF_BIT32_TOGGLE_8188F		BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define	IMR_BCNDMAINT0_8188F				BIT20		// Beacon DMA Interrupt 0
+#define	IMR_BCNDERR0_8188F				BIT16		// Beacon Queue DMA OK0
+#define	IMR_HSISR_IND_ON_INT_8188F		BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8188F			BIT14		// Beacon DMA Interrupt Extension for Win7
+#define	IMR_ATIMEND_8188F				BIT12		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8188F					BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define	IMR_CPWM2_8188F					BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_CPWM_8188F					BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_HIGHDOK_8188F				BIT7			// High Queue DMA OK
+#define	IMR_MGNTDOK_8188F				BIT6			// Management Queue DMA OK
+#define	IMR_BKDOK_8188F					BIT5			// AC_BK DMA OK
+#define	IMR_BEDOK_8188F					BIT4			// AC_BE DMA OK
+#define	IMR_VIDOK_8188F					BIT3			// AC_VI DMA OK
+#define	IMR_VODOK_8188F					BIT2			// AC_VO DMA OK
+#define	IMR_RDU_8188F					BIT1			// Rx Descriptor Unavailable
+#define	IMR_ROK_8188F					BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_BCNDMAINT7_8188F				BIT27		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8188F				BIT26		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8188F				BIT25		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8188F				BIT24		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8188F				BIT23		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8188F				BIT22		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8188F				BIT21		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8188F					BIT20		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8188F					BIT19		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8188F					BIT18		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8188F					BIT17		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8188F					BIT16		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8188F					BIT15		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8188F					BIT14		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8188F				BIT13		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8188F					BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8188F					BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8188F					BIT9			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8188F					BIT8			// Receive FIFO Overflow
+
+#ifdef CONFIG_PCI_HCI
+//#define IMR_RX_MASK		(IMR_ROK_8188F|IMR_RDU_8188F|IMR_RXFOVW_8188F)
+#define IMR_TX_MASK			(IMR_VODOK_8188F|IMR_VIDOK_8188F|IMR_BEDOK_8188F|IMR_BKDOK_8188F|IMR_MGNTDOK_8188F|IMR_HIGHDOK_8188F)
+
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8188F | IMR_TXBCN0OK_8188F | IMR_TXBCN0ERR_8188F | IMR_BCNDERR0_8188F)
+
+#define RT_AC_INT_MASKS	(IMR_VIDOK_8188F | IMR_VODOK_8188F | IMR_BEDOK_8188F|IMR_BKDOK_8188F)
+#endif
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8188F 16
+#define SEC_CAM_ENT_NUM_8188F 16
+#define NSS_NUM_8188F 1
+#define BAND_CAP_8188F (BAND_CAP_2G)
+#define BW_CAP_8188F (BW_CAP_20M | BW_CAP_40M)
+
+#endif /* __RTL8188F_SPEC_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_sreset.h
new file mode 100644
index 000000000..8a2762415
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8188F_SRESET_H_
+#define _RTL8188F_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8188f_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8188f_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_xmit.h
new file mode 100644
index 000000000..b98c91e84
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8188f_xmit.h
@@ -0,0 +1,336 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8188F_XMIT_H__
+#define __RTL8188F_XMIT_H__
+
+
+#define MAX_TID (15)
+
+
+#ifndef __INC_HAL8188FDESC_H
+#define __INC_HAL8188FDESC_H
+
+#define RX_STATUS_DESC_SIZE_8188F		24
+#define RX_DRV_INFO_SIZE_UNIT_8188F 8
+
+
+//DWORD 0
+#define SET_RX_STATUS_DESC_PKT_LEN_8188F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_8188F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_8188F(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
+
+#define GET_RX_STATUS_DESC_PKT_LEN_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32_8188F(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICV_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8188F(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT_8188F(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC_8188F(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
+#define GET_RX_STATUS_DESC_LAST_SEG_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 28, 1)
+#define GET_RX_STATUS_DESC_FIRST_SEG_8188F(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 29, 1)
+#define GET_RX_STATUS_DESC_EOR_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID_8188F(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_TID_8188F(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_AMSDU_8188F(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH_8188F(__pRxDesc)		LE_BITS_TO_4BYTE( __pRxDesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR_8188F(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_A1_FIT_8188F(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 16, 4)
+#define GET_RX_STATUS_DESC_CHKERR_8188F(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_IPVER_8188F(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_IS_TCPUDP__8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_CHK_VLD_8188F(__pRxDesc) 	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM_8188F(__pRxDesc) 			LE_BITS_TO_4BYTE( __pRxDesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR_8188F(__pRxDesc) 			LE_BITS_TO_4BYTE( __pRxDesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_MC_8188F(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC_8188F(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ_8188F(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 12, 4)
+#define GET_RX_STATUS_DESC_RX_IS_QOS_8188F(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 1)
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8188F(__pRxStatusDesc) 	LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_RPT_SEL_8188F(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 28, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_HTC_8188F(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP_8188F(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT_8188F(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 12, 2)
+#ifdef CONFIG_USB_RX_AGGREGATION
+#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8188F(__pRxStatusDesc)	LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 16, 8)
+#endif
+#define GET_RX_STATUS_DESC_PATTERN_MATCH_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_MATCH_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_MATCH_8188F(__pRxDesc) 		LE_BITS_TO_4BYTE( __pRxDesc+12, 31, 1)
+
+//DWORD 6
+#define GET_RX_STATUS_DESC_SPLCP_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 0, 1)
+#define GET_RX_STATUS_DESC_LDPC_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 1, 1)
+#define GET_RX_STATUS_DESC_STBC_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 2, 1)
+#define GET_RX_STATUS_DESC_BW_8188F(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 4, 2)
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL_8188F(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+20, 0, 32)
+
+#define GET_RX_STATUS_DESC_BUFF_ADDR_8188F(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR64_8188F(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)
+
+#define SET_RX_STATUS_DESC_BUFF_ADDR_8188F(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)
+
+
+// Dword 0
+#define GET_TX_DESC_OWN_8188F(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
+
+#define SET_TX_DESC_PKT_SIZE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
+#define SET_TX_DESC_OFFSET_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
+#define SET_TX_DESC_BMC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
+#define SET_TX_DESC_LINIP_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
+#define SET_TX_DESC_NO_ACM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
+#define SET_TX_DESC_GF_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+
+// Dword 1
+#define SET_TX_DESC_MACID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
+
+
+// Dword 2
+#define SET_TX_DESC_PAID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
+#define SET_TX_DESC_AGG_BREAK_8188F(__pTxDesc, __Value) 				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
+#define SET_TX_DESC_RAW_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
+#define SET_TX_DESC_SPE_RPT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_INT_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
+
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
+#define SET_TX_DESC_CHK_EN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
+#define SET_TX_DESC_EARLY_MODE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HWSEQ_SEL_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
+
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT_8188F(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
+#define SET_TX_DESC_CTROL_STBC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
+
+
+// Dword 6
+#define SET_TX_DESC_SW_DEFINE_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_MBSSID_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
+#define SET_TX_DESC_ANTSEL_A_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
+#define SET_TX_DESC_ANTSEL_B_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
+#define SET_TX_DESC_ANTSEL_C_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
+#define SET_TX_DESC_ANTSEL_D_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)
+
+// Dword 7
+#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)
+#define SET_TX_DESC_TX_BUFFER_SIZE_8188F(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#else
+#define SET_TX_DESC_TX_DESC_CHECKSUM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#endif
+#define SET_TX_DESC_USB_TXAGG_NUM_8188F(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
+#if(DEV_BUS_TYPE == RT_SDIO_INTERFACE)
+#define SET_TX_DESC_SDIO_TXSEQ_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
+#endif
+
+// Dword 8
+#define SET_TX_DESC_HWSEQ_EN_8188F(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+
+// Dword 9
+#define SET_TX_DESC_SEQ_8188F(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
+
+// Dword 10
+#define SET_TX_DESC_TX_BUFFER_ADDRESS_8188F(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
+#define GET_TX_DESC_TX_BUFFER_ADDRESS_8188F(__pTxDesc) 	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)
+
+// Dword 11
+#define SET_TX_DESC_NEXT_DESC_ADDRESS_8188F(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)
+
+
+#define SET_EARLYMODE_PKTNUM_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
+#define SET_EARLYMODE_LEN3_8188F(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+#endif
+//-----------------------------------------------------------
+//
+//	Rate
+//
+//-----------------------------------------------------------
+// CCK Rates, TxHT = 0
+#define DESC8188F_RATE1M				0x00
+#define DESC8188F_RATE2M				0x01
+#define DESC8188F_RATE5_5M				0x02
+#define DESC8188F_RATE11M				0x03
+
+// OFDM Rates, TxHT = 0
+#define DESC8188F_RATE6M				0x04
+#define DESC8188F_RATE9M				0x05
+#define DESC8188F_RATE12M				0x06
+#define DESC8188F_RATE18M				0x07
+#define DESC8188F_RATE24M				0x08
+#define DESC8188F_RATE36M				0x09
+#define DESC8188F_RATE48M				0x0a
+#define DESC8188F_RATE54M				0x0b
+
+// MCS Rates, TxHT = 1
+#define DESC8188F_RATEMCS0				0x0c
+#define DESC8188F_RATEMCS1				0x0d
+#define DESC8188F_RATEMCS2				0x0e
+#define DESC8188F_RATEMCS3				0x0f
+#define DESC8188F_RATEMCS4				0x10
+#define DESC8188F_RATEMCS5				0x11
+#define DESC8188F_RATEMCS6				0x12
+#define DESC8188F_RATEMCS7				0x13
+#define DESC8188F_RATEMCS8				0x14
+#define DESC8188F_RATEMCS9				0x15
+#define DESC8188F_RATEMCS10 		0x16
+#define DESC8188F_RATEMCS11 		0x17
+#define DESC8188F_RATEMCS12 		0x18
+#define DESC8188F_RATEMCS13 		0x19
+#define DESC8188F_RATEMCS14 		0x1a
+#define DESC8188F_RATEMCS15 		0x1b
+#define DESC8188F_RATEVHTSS1MCS0		0x2c
+#define DESC8188F_RATEVHTSS1MCS1		0x2d
+#define DESC8188F_RATEVHTSS1MCS2		0x2e
+#define DESC8188F_RATEVHTSS1MCS3		0x2f
+#define DESC8188F_RATEVHTSS1MCS4		0x30
+#define DESC8188F_RATEVHTSS1MCS5		0x31
+#define DESC8188F_RATEVHTSS1MCS6		0x32
+#define DESC8188F_RATEVHTSS1MCS7		0x33
+#define DESC8188F_RATEVHTSS1MCS8		0x34
+#define DESC8188F_RATEVHTSS1MCS9		0x35
+#define DESC8188F_RATEVHTSS2MCS0		0x36
+#define DESC8188F_RATEVHTSS2MCS1		0x37
+#define DESC8188F_RATEVHTSS2MCS2		0x38
+#define DESC8188F_RATEVHTSS2MCS3		0x39
+#define DESC8188F_RATEVHTSS2MCS4		0x3a
+#define DESC8188F_RATEVHTSS2MCS5		0x3b
+#define DESC8188F_RATEVHTSS2MCS6		0x3c
+#define DESC8188F_RATEVHTSS2MCS7		0x3d
+#define DESC8188F_RATEVHTSS2MCS8		0x3e
+#define DESC8188F_RATEVHTSS2MCS9		0x3f
+
+
+#define 	RX_HAL_IS_CCK_RATE_8188F(pDesc)\
+			(GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE1M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE2M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE5_5M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8188F(pDesc) == DESC8188F_RATE11M)
+
+
+void rtl8188f_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
+void rtl8188f_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+s32 rtl8188fs_init_xmit_priv(PADAPTER padapter);
+void rtl8188fs_free_xmit_priv(PADAPTER padapter);
+s32 rtl8188fs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188fs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8188fs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188fs_xmit_buf_handler(PADAPTER padapter);
+thread_return rtl8188fs_xmit_thread(thread_context context);
+#define hal_xmit_handler rtl8188fs_xmit_buf_handler
+#endif
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8188fu_xmit_buf_handler(PADAPTER padapter);
+#define hal_xmit_handler rtl8188fu_xmit_buf_handler
+
+
+s32 rtl8188fu_init_xmit_priv(PADAPTER padapter);
+void rtl8188fu_free_xmit_priv(PADAPTER padapter);
+s32 rtl8188fu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188fu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	 rtl8188fu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+//s32 rtl8812au_xmit_buf_handler(PADAPTER padapter);
+void rtl8188fu_xmit_tasklet(void *priv);
+s32 rtl8188fu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,struct tx_desc *ptxdesc);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8188fe_init_xmit_priv(PADAPTER padapter);
+void rtl8188fe_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf *rtl8188fe_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+void	rtl8188fe_xmitframe_resume(_adapter *padapter);
+s32 rtl8188fe_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8188fe_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8188fe_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtl8188fe_xmit_tasklet(void *priv);
+#endif
+
+u8	BWMapping_8188F(PADAPTER Adapter, struct pkt_attrib *pattrib);
+u8	SCMapping_8188F(PADAPTER Adapter, struct pkt_attrib	*pattrib);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_cmd.h
new file mode 100644
index 000000000..ca7b811fd
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_cmd.h
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_CMD_H__
+#define __RTL8192E_CMD_H__
+
+typedef enum _RTL8192E_H2C_CMD
+{
+	H2C_8192E_RSVDPAGE	= 0x00,
+	H2C_8192E_MSRRPT	= 0x01,
+	H2C_8192E_SCAN		= 0x02,
+	H2C_8192E_KEEP_ALIVE_CTRL = 0x03,
+	H2C_8192E_DISCONNECT_DECISION = 0x04,
+	H2C_8192E_INIT_OFFLOAD = 0x06,
+	H2C_8192E_AP_OFFLOAD = 0x08,
+	H2C_8192E_BCN_RSVDPAGE = 0x09,
+	H2C_8192E_PROBERSP_RSVDPAGE = 0x0a,
+
+	H2C_8192E_AP_WOW_GPIO_CTRL = 0x13,
+
+	H2C_8192E_SETPWRMODE = 0x20,
+	H2C_8192E_PS_TUNING_PARA = 0x21,
+	H2C_8192E_PS_TUNING_PARA2 = 0x22,
+	H2C_8192E_PS_LPS_PARA = 0x23,
+	H2C_8192E_P2P_PS_OFFLOAD = 0x24,
+	H2C_8192E_SAP_PS = 0x26,
+	H2C_8192E_RA_MASK = 0x40,
+	H2C_8192E_RSSI_REPORT = 0x42,
+	H2C_8192E_RA_PARA_ADJUST = 0x46,
+
+	H2C_8192E_WO_WLAN = 0x80,
+	H2C_8192E_REMOTE_WAKE_CTRL = 0x81,
+	H2C_8192E_AOAC_GLOBAL_INFO = 0x82,
+	H2C_8192E_AOAC_RSVDPAGE = 0x83,
+
+	//Not defined in new 88E H2C CMD Format
+	H2C_8192E_SELECTIVE_SUSPEND_ROF_CMD,
+	H2C_8192E_P2P_PS_MODE,
+	H2C_8192E_PSD_RESULT,
+	MAX_8192E_H2CCMD
+}RTL8192E_H2C_CMD;
+
+struct cmd_msg_parm {
+	u8 eid; //element id
+	u8 sz; // sz
+	u8 buf[6];
+};
+
+enum{
+	PWRS
+};
+
+typedef struct _SETPWRMODE_PARM {
+	u8 Mode;//0:Active,1:LPS,2:WMMPS
+	//u8 RLBM:4;//0:Min,1:Max,2: User define
+	u8 SmartPS_RLBM;//LPS=0:PS_Poll,1:PS_Poll,2:NullData,WMM=0:PS_Poll,1:NullData
+	u8 AwakeInterval;	// unit: beacon interval
+	u8 bAllQueueUAPSD;
+	u8 PwrState;//AllON(0x0c),RFON(0x04),RFOFF(0x00)
+} SETPWRMODE_PARM, *PSETPWRMODE_PARM;
+
+struct H2C_SS_RFOFF_PARAM{
+	u8 ROFOn; // 1: on, 0:off
+	u16 gpio_period; // unit: 1024 us
+}__attribute__ ((packed));
+
+
+typedef struct JOINBSSRPT_PARM_92E{
+	u8 OpMode;	// RT_MEDIA_STATUS
+#ifdef CONFIG_WOWLAN
+	u8 MacID;       // MACID
+#endif //CONFIG_WOWLAN
+}JOINBSSRPT_PARM_92E, *PJOINBSSRPT_PARM_92E;
+
+/* move to hal_com_h2c.h
+typedef struct _RSVDPAGE_LOC_92E {
+	u8 LocProbeRsp;
+	u8 LocPsPoll;
+	u8 LocNullData;
+	u8 LocQosNull;
+	u8 LocBTQosNull;
+} RSVDPAGE_LOC_92E, *PRSVDPAGE_LOC_92E;
+*/
+
+
+//_SETPWRMODE_PARM
+#define SET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+5, 0, 8, __Value)
+#define GET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)						LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+//_P2P_PS_OFFLOAD
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+
+
+// host message to firmware cmd
+void rtl8192e_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
+void rtl8192e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
+u8 rtl8192e_set_rssi_cmd(PADAPTER padapter, u8 *param);
+void rtl8192e_set_raid_cmd(PADAPTER padapter, u32 bitmap, u8* arg);
+void rtl8192e_Add_RateATid(PADAPTER padapter, u64 rate_bitmap, u8 *arg, u8 rssi_level);
+s32 FillH2CCmd_8192E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8192E(_adapter *padapter, bool wowlan);
+//u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period);
+s32 c2h_handler_8192e(PADAPTER padapter, u8 *buf);
+#ifdef CONFIG_BT_COEXIST
+void rtl8192e_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
+#ifdef CONFIG_P2P_PS
+void rtl8192e_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+int reset_tsf(PADAPTER Adapter, u8 reset_port );
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void SetFwRelatedForWoWLAN8192E(_adapter* padapter, u8 bHostIsGoingtoSleep);
+#endif
+/// TX Feedback Content
+#define 	USEC_UNIT_FOR_8192E_C2H_TX_RPT_QUEUE_TIME			256
+
+#define	GET_8192E_C2H_TX_RPT_QUEUE_SELECT(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 5)
+#define	GET_8192E_C2H_TX_RPT_PKT_BROCAST(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 5, 1)
+#define	GET_8192E_C2H_TX_RPT_LIFE_TIME_OVER(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 6, 1)
+#define	GET_8192E_C2H_TX_RPT_RETRY_OVER(_Header)				LE_BITS_TO_1BYTE((_Header + 0), 7, 1)
+#define	GET_8192E_C2H_TX_RPT_MAC_ID(_Header)					LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
+#define	GET_8192E_C2H_TX_RPT_DATA_RETRY_CNT(_Header)		LE_BITS_TO_1BYTE((_Header + 2), 0, 6)
+#define	GET_8192E_C2H_TX_RPT_QUEUE_TIME(_Header)				LE_BITS_TO_2BYTE((_Header + 3), 0, 16)	// In unit of 256 microseconds.
+#define	GET_8192E_C2H_TX_RPT_FINAL_DATA_RATE(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)
+
+
+
+void C2HContentParsing8192E(
+	IN	PADAPTER		Adapter,
+	IN	u1Byte			c2hCmdId,
+	IN	u1Byte			c2hCmdLen,
+	IN	pu1Byte 			tmpBuf
+);
+VOID
+C2HPacketHandler_8192E(
+	IN	PADAPTER		Adapter,
+	IN	pu1Byte			Buffer,
+	IN	u1Byte			Length
+);
+
+#endif//__RTL8192E_CMD_H__
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_dm.h
new file mode 100644
index 000000000..bb4f7a5ef
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_dm.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_DM_H__
+#define __RTL8192E_DM_H__
+
+
+void rtl8192e_init_dm_priv(IN PADAPTER Adapter);
+void rtl8192e_deinit_dm_priv(IN PADAPTER Adapter);
+void rtl8192e_InitHalDm(IN PADAPTER Adapter);
+void rtl8192e_HalDmWatchDog(IN PADAPTER Adapter);
+
+//VOID rtl8192c_dm_CheckTXPowerTracking(IN PADAPTER Adapter);
+
+//void rtl8192c_dm_RF_Saving(IN PADAPTER pAdapter, IN u8 bForceInNormal);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void	AntDivCompare8192e(PADAPTER Adapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+u8 AntDivBeforeLink8192e(PADAPTER Adapter );
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_hal.h
new file mode 100644
index 000000000..3bf5386e8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_hal.h
@@ -0,0 +1,350 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_HAL_H__
+#define __RTL8192E_HAL_H__
+
+//#include "hal_com.h"
+
+#include "hal_data.h"
+
+//include HAL Related header after HAL Related compiling flags
+#include "rtl8192e_spec.h"
+#include "rtl8192e_rf.h"
+#include "rtl8192e_dm.h"
+#include "rtl8192e_recv.h"
+#include "rtl8192e_xmit.h"
+#include "rtl8192e_cmd.h"
+#include "rtl8192e_led.h"
+#include "Hal8192EPwrSeq.h"
+#include "Hal8192EPhyReg.h"
+#include "Hal8192EPhyCfg.h"
+
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8192e_sreset.h"
+#endif
+
+
+//---------------------------------------------------------------------
+//		RTL8192E From header
+//---------------------------------------------------------------------
+	#define RTL8192E_FW_IMG					"rtl8192e/FW_NIC.bin"
+	#define RTL8192E_FW_WW_IMG				"rtl8192e/FW_WoWLAN.bin"
+	#define RTL8192E_PHY_REG					"rtl8192e/PHY_REG.txt"
+	#define RTL8192E_PHY_RADIO_A				"rtl8192e/RadioA.txt"
+	#define RTL8192E_PHY_RADIO_B				"rtl8192e/RadioB.txt"
+	#define RTL8192E_TXPWR_TRACK				"rtl8192e/TxPowerTrack.txt"
+	#define RTL8192E_AGC_TAB					"rtl8192e/AGC_TAB.txt"
+	#define RTL8192E_PHY_MACREG 				"rtl8192e/MAC_REG.txt"
+	#define RTL8192E_PHY_REG_PG				"rtl8192e/PHY_REG_PG.txt"
+	#define RTL8192E_PHY_REG_MP 				"rtl8192e/PHY_REG_MP.txt"
+	#define RTL8192E_TXPWR_LMT					"rtl8192e/TXPWR_LMT.txt"
+	#define RTL8192E_WIFI_ANT_ISOLATION		"rtl8192e/wifi_ant_isolation.txt"
+
+//---------------------------------------------------------------------
+//		RTL8192E Power Configuration CMDs for PCIe interface
+//---------------------------------------------------------------------
+#define Rtl8192E_NIC_PWR_ON_FLOW				rtl8192E_power_on_flow
+#define Rtl8192E_NIC_RF_OFF_FLOW				rtl8192E_radio_off_flow
+#define Rtl8192E_NIC_DISABLE_FLOW				rtl8192E_card_disable_flow
+#define Rtl8192E_NIC_ENABLE_FLOW				rtl8192E_card_enable_flow
+#define Rtl8192E_NIC_SUSPEND_FLOW				rtl8192E_suspend_flow
+#define Rtl8192E_NIC_RESUME_FLOW				rtl8192E_resume_flow
+#define Rtl8192E_NIC_PDN_FLOW					rtl8192E_hwpdn_flow
+#define Rtl8192E_NIC_LPS_ENTER_FLOW			rtl8192E_enter_lps_flow
+#define Rtl8192E_NIC_LPS_LEAVE_FLOW			rtl8192E_leave_lps_flow
+
+
+#if 1 // download firmware related data structure
+#define FW_SIZE_8192E			0x8000 // Compatible with RTL8192e Maximal RAM code size 32k
+#define FW_START_ADDRESS		0x1000
+#define FW_END_ADDRESS			0x5FFF
+
+
+#define IS_FW_HEADER_EXIST_8192E(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8192E(_pFwHdr) &0xFFF0) ==  0x92E0)
+
+
+
+typedef struct _RT_FIRMWARE_8192E {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[FW_SIZE_8192E];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8192E, *PRT_FIRMWARE_8192E;
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+
+//=====================================================
+//					Firmware Header(8-byte alinment required)
+//=====================================================
+//--- LONG WORD 0 ----
+#define GET_FIRMWARE_HDR_SIGNATURE_8192E(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16) // 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+#define GET_FIRMWARE_HDR_CATEGORY_8192E(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) // AP/NIC and USB/PCI
+#define GET_FIRMWARE_HDR_FUNCTION_8192E(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 24, 8) // Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+#define GET_FIRMWARE_HDR_VERSION_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)// FW Version
+#define GET_FIRMWARE_HDR_SUB_VER_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) // FW Subversion, default 0x00
+#define GET_FIRMWARE_HDR_RSVD1_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8)
+
+//--- LONG WORD 1 ----
+#define GET_FIRMWARE_HDR_MONTH_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 8) // Release time Month field
+#define GET_FIRMWARE_HDR_DATE_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 8, 8) // Release time Date field
+#define GET_FIRMWARE_HDR_HOUR_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 16, 8)// Release time Hour field
+#define GET_FIRMWARE_HDR_MINUTE_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 24, 8)// Release time Minute field
+#define GET_FIRMWARE_HDR_ROMCODE_SIZE_8192E(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+12, 0, 16)// The size of RAM code
+#define GET_FIRMWARE_HDR_RSVD2_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 16, 16)
+
+//--- LONG WORD 2 ----
+#define GET_FIRMWARE_HDR_SVN_IDX_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+16, 0, 32)// The SVN entry index
+#define GET_FIRMWARE_HDR_RSVD3_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 0, 32)
+
+//--- LONG WORD 3 ----
+#define GET_FIRMWARE_HDR_RSVD4_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 0, 32)
+#define GET_FIRMWARE_HDR_RSVD5_8192E(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)
+
+#endif // download firmware related data structure
+
+#define DRIVER_EARLY_INT_TIME_8192E		0x05
+#define BCN_DMA_ATIME_INT_TIME_8192E		0x02
+#define RX_DMA_SIZE_8192E					0x4000	/* 16K*/
+
+#ifdef CONFIG_WOWLAN
+#define RESV_FMWF	WKFMCAM_SIZE*MAX_WKFM_NUM /* 16 entries, for each is 24 bytes*/
+#else
+#define RESV_FMWF	0
+#endif
+
+#ifdef CONFIG_FW_C2H_DEBUG
+	#define RX_DMA_RESERVED_SIZE_8192E	0x100	/* 256B, reserved for c2h debug message*/
+#else
+	#define RX_DMA_RESERVED_SIZE_8192E	0x40	/* 64B, reserved for c2h event(16bytes) or ccx(8 Bytes )*/
+#endif
+#define MAX_RX_DMA_BUFFER_SIZE_8192E		(RX_DMA_SIZE_8192E-RX_DMA_RESERVED_SIZE_8192E)	/*RX 16K*/
+
+//For General Reserved Page Number(Beacon Queue is reserved page)
+//if (CONFIG_2BCN_EN) Beacon:4, PS-Poll:1, Null Data:1,Prob Rsp:1,Qos Null Data:1
+//Beacon:2, PS-Poll:1, Null Data:1,Prob Rsp:1,Qos Null Data:1
+#define RSVD_PAGE_NUM_8192E		0x08
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8192E	0x07
+#else
+#define WOWLAN_PAGE_NUM_8192E	0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef WOWLAN_PAGE_NUM_8192E
+#define WOWLAN_PAGE_NUM_8192E	0x0d
+#endif
+
+/* Note:
+Tx FIFO Size : 64KB
+Tx page Size : 256B
+Total page numbers : 256(0x100)
+*/
+
+#define	TOTAL_RSVD_PAGE_NUMBER_8192E 	(RSVD_PAGE_NUM_8192E+WOWLAN_PAGE_NUM_8192E)
+
+#define	TOTAL_PAGE_NUMBER_8192E	(0x100)
+#define	TX_TOTAL_PAGE_NUMBER_8192E	(TOTAL_PAGE_NUMBER_8192E - TOTAL_RSVD_PAGE_NUMBER_8192E)
+
+#define	TX_PAGE_BOUNDARY_8192E	( TX_TOTAL_PAGE_NUMBER_8192E ) /* beacon header start address */
+
+
+#define PAGE_SIZE_TX_92E	PAGE_SIZE_256
+#define RSVD_PKT_LEN_92E	(TOTAL_RSVD_PAGE_NUMBER_8192E *PAGE_SIZE_TX_92E)
+
+#define TX_PAGE_LOAD_FW_BOUNDARY_8192E		0x47 //0xA5
+#define TX_PAGE_BOUNDARY_WOWLAN_8192E		0xE0
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_92C
+
+#define NORMAL_PAGE_NUM_HPQ_8192E			0x10
+#define NORMAL_PAGE_NUM_LPQ_8192E			0x10
+#define NORMAL_PAGE_NUM_NPQ_8192E			0x10
+#define NORMAL_PAGE_NUM_EPQ_8192E			0x00
+
+
+//Note: For WMM Normal Chip Setting ,modify later
+#define WMM_NORMAL_PAGE_NUM_HPQ_8192E		NORMAL_PAGE_NUM_HPQ_8192E
+#define WMM_NORMAL_PAGE_NUM_LPQ_8192E		NORMAL_PAGE_NUM_LPQ_8192E
+#define WMM_NORMAL_PAGE_NUM_NPQ_8192E		NORMAL_PAGE_NUM_NPQ_8192E
+
+
+//-------------------------------------------------------------------------
+//	Chip specific
+//-------------------------------------------------------------------------
+
+// pic buffer descriptor
+#define RTL8192EE_SEG_NUM			TX_BUFFER_SEG_NUM
+#define TX_DESC_NUM_92E			128
+#define RX_DESC_NUM_92E			128
+
+//-------------------------------------------------------------------------
+//	Channel Plan
+//-------------------------------------------------------------------------
+
+#define		HWSET_MAX_SIZE_8192E			512
+
+#define		EFUSE_REAL_CONTENT_LEN_8192E	512
+
+#define		EFUSE_MAP_LEN_8192E			512
+#define		EFUSE_MAX_SECTION_8192E		64
+#define		EFUSE_MAX_WORD_UNIT_8192E		4
+#define		EFUSE_IC_ID_OFFSET_8192E		506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define 		AVAILABLE_EFUSE_ADDR_8192E(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_8192E)
+//
+// <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
+// 9bytes + 1byt + 5bytes and pre 1byte.
+// For worst case:
+// | 1byte|----8bytes----|1byte|--5bytes--|
+// |         |            Reserved(14bytes)	      |
+//
+#define		EFUSE_OOB_PROTECT_BYTES_8192E 		15	// PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte.
+
+
+
+//========================================================
+//			EFUSE for BT definition
+//========================================================
+#define		EFUSE_BT_REAL_BANK_CONTENT_LEN_8192E	512
+#define		EFUSE_BT_REAL_CONTENT_LEN_8192E			1024	// 512*2
+#define		EFUSE_BT_MAP_LEN_8192E					1024	// 1k bytes
+#define		EFUSE_BT_MAX_SECTION_8192E				128		// 1024/8
+
+#define		EFUSE_PROTECT_BYTES_BANK_8192E			16
+#define 		EFUSE_MAX_BANK_8192E					3
+//===========================================================
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+//#define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? _TRUE : _FALSE)
+
+//#define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) )
+
+// rtl8812_hal_init.c
+void	_8051Reset8192E(PADAPTER padapter);
+s32	FirmwareDownload8192E(PADAPTER Adapter, BOOLEAN bUsedWoWLANFw);
+void	InitializeFirmwareVars8192E(PADAPTER padapter);
+
+s32	InitLLTTable8192E(PADAPTER padapter, u8 txpktbuf_bndy);
+
+// EFuse
+u8	GetEEPROMSize8192E(PADAPTER padapter);
+void	hal_InitPGData_8192E(PADAPTER padapter, u8* PROMContent);
+void	Hal_EfuseParseIDCode8192E(PADAPTER padapter, u8 *hwinfo);
+void	Hal_ReadPROMVersion8192E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void	Hal_ReadPowerSavingMode8192E(PADAPTER padapter, u8*	hwinfo, BOOLEAN	AutoLoadFail);
+void	Hal_ReadTxPowerInfo8192E(PADAPTER padapter,u8* hwinfo,BOOLEAN	AutoLoadFail);
+void	Hal_ReadBoardType8192E(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+void	Hal_ReadThermalMeter_8192E(PADAPTER	Adapter,u8* PROMContent,BOOLEAN 	AutoloadFail);
+void	Hal_ReadChannelPlan8192E(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void	Hal_EfuseParseXtal_8192E(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+void	Hal_ReadAntennaDiversity8192E(PADAPTER pAdapter,u8* PROMContent,BOOLEAN AutoLoadFail);
+void	Hal_ReadPAType_8192E(PADAPTER Adapter,u8* PROMContent, BOOLEAN AutoloadFail);
+void	Hal_ReadAmplifierType_8192E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
+void	Hal_ReadRFEType_8192E(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
+void	Hal_EfuseParseBTCoexistInfo8192E(PADAPTER Adapter, u8* hwinfo, BOOLEAN AutoLoadFail);
+void	Hal_EfuseParseKFreeData_8192E(PADAPTER pAdapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+
+u8 Hal_CrystalAFEAdjust(_adapter * Adapter);
+
+BOOLEAN HalDetectPwrDownMode8192E(PADAPTER Adapter);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+/***********************************************************/
+// RTL8192E-MAC Setting
+VOID _InitQueueReservedPage_8192E(IN  PADAPTER Adapter);
+VOID _InitQueuePriority_8192E(IN	PADAPTER Adapter);
+VOID _InitTxBufferBoundary_8192E(IN PADAPTER Adapter,IN u8 txpktbuf_bndy);
+VOID _InitPageBoundary_8192E(IN PADAPTER Adapter);
+//VOID _InitTransferPageSize_8192E(IN PADAPTER Adapter);
+VOID _InitDriverInfoSize_8192E(IN PADAPTER Adapter,IN u8 drvInfoSize);
+VOID _InitRDGSetting_8192E(PADAPTER Adapter);
+void _InitID_8192E(IN  PADAPTER Adapter);
+VOID _InitNetworkType_8192E(IN  PADAPTER Adapter);
+VOID _InitWMACSetting_8192E(IN PADAPTER Adapter);
+VOID _InitAdaptiveCtrl_8192E(IN  PADAPTER Adapter);
+VOID _InitRateFallback_8192E(IN  PADAPTER Adapter);
+VOID _InitEDCA_8192E( IN  PADAPTER Adapter);
+VOID _InitRetryFunction_8192E(	IN  PADAPTER Adapter);
+VOID _BBTurnOnBlock_8192E(IN	PADAPTER Adapter);
+VOID _InitBeaconParameters_8192E(IN  PADAPTER Adapter);
+VOID _InitBeaconMaxError_8192E(
+	IN  PADAPTER	Adapter,
+	IN	BOOLEAN		InfraMode
+	);
+void SetBeaconRelatedRegisters8192E(PADAPTER padapter);
+VOID hal_ReadRFType_8192E(PADAPTER	Adapter);
+// RTL8192E-MAC Setting
+/***********************************************************/
+
+void SetHwReg8192E(PADAPTER Adapter, u8 variable, u8* val);
+void GetHwReg8192E(PADAPTER Adapter, u8 variable, u8* val);
+u8
+SetHalDefVar8192E(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	);
+u8
+GetHalDefVar8192E(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	);
+
+void rtl8192e_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8192e(_adapter *adapter);
+void rtl8192e_init_default_value(_adapter * padapter);
+// register
+void SetBcnCtrlReg(PADAPTER padapter, u8 SetBits, u8 ClearBits);
+
+void rtl8192e_start_thread(_adapter *padapter);
+void rtl8192e_stop_thread(_adapter *padapter);
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8192EE(PADAPTER Adapter);
+u16	get_txdesc_buf_addr(u16 ff_hwaddr);
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT
+void _init_available_page_threshold(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
+#endif
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+void rtl8192e_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
+#endif
+
+#endif //__RTL8192E_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_led.h
new file mode 100644
index 000000000..d8f55f404
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_led.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_LED_H__
+#define __RTL8192E_LED_H__
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8192eu_InitSwLeds(PADAPTER padapter);
+void rtl8192eu_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_PCI_HCI
+void rtl8192ee_InitSwLeds(PADAPTER padapter);
+void rtl8192ee_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_SDIO_HCI
+void rtl8192es_InitSwLeds(PADAPTER padapter);
+void rtl8192es_DeInitSwLeds(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_recv.h
new file mode 100644
index 000000000..e27c7d6a4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_recv.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_RECV_H__
+#define __RTL8192E_RECV_H__
+
+#if defined(CONFIG_USB_HCI)
+
+#ifndef MAX_RECVBUF_SZ
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+	#ifdef CONFIG_MINIMAL_MEMORY_USAGE
+		#define MAX_RECVBUF_SZ (4000) // about 4K
+	#else
+		#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+			#define MAX_RECVBUF_SZ (rtw_rtkm_get_buff_size()) /*depend rtkm*/
+		#elif defined(CONFIG_PLATFORM_HISILICON)
+			#define MAX_RECVBUF_SZ (16384) /* 16k */
+		#else
+			#define MAX_RECVBUF_SZ (32768) /* 32k */
+		#endif
+		//#define MAX_RECVBUF_SZ (20480) //20K
+		//#define MAX_RECVBUF_SZ (10240) //10K
+		//#define MAX_RECVBUF_SZ (16384) //  16k - 92E RX BUF :16K
+		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+	#endif
+#endif
+#endif //!MAX_RECVBUF_SZ
+
+#elif defined(CONFIG_PCI_HCI)
+//#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+//	#define MAX_RECVBUF_SZ (9100)
+//#else
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+//#endif
+
+
+#elif defined(CONFIG_SDIO_HCI)
+
+#define MAX_RECVBUF_SZ (16384)
+
+#endif
+
+
+// Rx smooth factor
+#define Rx_Smooth_Factor (20)
+
+//=============
+// [1] Rx Buffer Descriptor (for PCIE) buffer descriptor architecture
+//DWORD 0
+#define SET_RX_BUFFER_DESC_DATA_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc,__Value)	SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 15, 1, __Value)
+#define SET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 1, __Value)
+#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 15, __Value)
+
+#define GET_RX_BUFFER_DESC_OWN_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+#define GET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 1)
+#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 15)
+
+
+//DWORD 1
+#define SET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+4, 0, 32, __Value)
+#define GET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 0, 32)
+
+//DWORD 2
+#define SET_RX_BUFFER_PHYSICAL_HIGH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+8, 0, 32, __Value)
+
+//=============
+// [2] Rx Descriptor
+//DWORD 0
+#define GET_RX_STATUS_DESC_PKT_LEN_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICVERR_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
+#define GET_RX_STATUS_DESC_EOR_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+
+
+#define SET_RX_STATUS_DESC_PKT_LEN_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID_92E(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_TID_92E(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_MACID_VLD_92E(__pRxDesc) 				LE_BITS_TO_4BYTE(__pRxDesc+4, 12, 1)
+#define GET_RX_STATUS_DESC_AMSDU_92E(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH_92E(__pRxDesc) 			LE_BITS_TO_4BYTE(__pRxDesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_A1_FITS_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 16, 4)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHKERR_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_IPVER_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_IS_TCPUDP_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHK_VLD_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_MC_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ_92E(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 12, 4)
+#define GET_RX_STATUS_DESC_RX_IS_QOS_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 1)
+
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_HWRSVD_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 24, 4)
+#define GET_RX_STATUS_DESC_FCS_OK_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 31, 1)
+#define GET_RX_STATUS_DESC_RPT_SEL_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 28, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_HTC_92E(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP_92E(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 12, 2)
+#define GET_RX_STATUS_DESC_DMA_AGG_NUM_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 16, 8)
+
+#define GET_RX_STATUS_DESC_PATTERN_MATCH_92E(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_92E(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_WAKE_92E(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 31, 1)
+
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+20, 0, 32)
+
+#define GET_RX_STATUS_DESC_BUFF_ADDR_92E(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR64_92E(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)
+
+
+#ifdef CONFIG_SDIO_HCI
+s32 rtl8192es_init_recv_priv(PADAPTER padapter);
+void rtl8192es_free_recv_priv(PADAPTER padapter);
+void rtl8192es_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
+#endif
+
+#ifdef CONFIG_USB_HCI
+void rtl8192eu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+s32 rtl8192eu_init_recv_priv(PADAPTER padapter);
+void rtl8192eu_free_recv_priv(PADAPTER padapter);
+void rtl8192eu_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
+void rtl8192eu_recv_tasklet(void *priv);
+
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8192ee_init_recv_priv(PADAPTER padapter);
+void rtl8192ee_free_recv_priv(PADAPTER padapter);
+#endif
+
+void rtl8192e_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+
+#endif /* __RTL8192E_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_rf.h
new file mode 100644
index 000000000..fec92256c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_rf.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_RF_H__
+#define __RTL8192E_RF_H__
+
+VOID
+PHY_RF6052SetBandwidth8192E(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH		Bandwidth);
+
+
+int
+PHY_RF6052_Config_8192E(
+	IN	PADAPTER	Adapter	);
+
+#endif//__RTL8192E_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_spec.h
new file mode 100644
index 000000000..47923644d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_spec.h
@@ -0,0 +1,327 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8192E_SPEC_H__
+#define __RTL8192E_SPEC_H__
+
+#include <drv_conf.h>
+
+
+//============================================================
+//       8192E Regsiter offset definition
+//============================================================
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_SWR_CTRL1_8192E		0x0010	// 1 Byte
+#define REG_SYS_SWR_CTRL2_8192E		0x0014	// 1 Byte
+#define REG_AFE_CTRL1_8192E			0x0024
+#define REG_AFE_CTRL2_8192E			0x0028
+#define REG_AFE_CTRL3_8192E			0x002c
+
+#define REG_PAD_CTRL1_8192E			0x0064
+#define REG_SDIO_CTRL_8192E			0x0070
+#define REG_OPT_CTRL_8192E				0x0074
+#define REG_RF_B_CTRL_8192E			0x0076
+#define REG_AFE_CTRL4_8192E			0x0078
+#define REG_LDO_SWR_CTRL				0x007C
+#define REG_FW_DRV_MSG_8192E			0x0088
+#define REG_HMEBOX_E2_E3_8192E		0x008C
+#define REG_HIMR0_8192E				0x00B0
+#define REG_HISR0_8192E					0x00B4
+#define REG_HIMR1_8192E					0x00B8
+#define REG_HISR1_8192E					0x00BC
+
+#define REG_SYS_CFG1_8192E				0x00F0
+#define REG_SYS_CFG2_8192E				0x00FC
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_PKTBUF_DBG_ADDR 			(REG_PKTBUF_DBG_CTRL)
+#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
+#define REG_WOWLAN_WAKE_REASON		REG_MCUTST_WOWLAN
+
+#define REG_RSVD3_8192E					0x0168
+#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
+#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
+#define REG_C2HEVT_CMD_LEN_88XX		0x01AE
+
+#define REG_HMEBOX_EXT0_8192E			0x01F0
+#define REG_HMEBOX_EXT1_8192E			0x01F4
+#define REG_HMEBOX_EXT2_8192E			0x01F8
+#define REG_HMEBOX_EXT3_8192E			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_DWBCN0_CTRL             0x0208
+#define REG_DWBCN1_CTRL             0x0228
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_8192E					0x0290
+#define REG_EARLY_MODE_CONTROL_8192E		0x02BC
+
+#define REG_RSVD5_8192E					0x02F0
+#define REG_RSVD6_8192E					0x02F4
+#define REG_RSVD7_8192E					0x02F8
+#define REG_RSVD8_8192E					0x02FC
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG_8192E			0x0300
+#define	REG_INT_MIG_8192E					0x0304	// Interrupt Migration
+#define	REG_BCNQ_TXBD_DESA_8192E		0x0308	// TX Beacon Descriptor Address
+#define	REG_MGQ_TXBD_DESA_8192E			0x0310	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_TXBD_DESA_8192E			0x0318	// TX VO Queue Descriptor Address
+#define	REG_VIQ_TXBD_DESA_8192E			0x0320	// TX VI Queue Descriptor Address
+#define	REG_BEQ_TXBD_DESA_8192E			0x0328	// TX BE Queue Descriptor Address
+#define	REG_BKQ_TXBD_DESA_8192E			0x0330	// TX BK Queue Descriptor Address
+#define	REG_RXQ_RXBD_DESA_8192E			0x0338	// RX Queue	Descriptor Address
+#define 	REG_HI0Q_TXBD_DESA_8192E			0x0340
+#define 	REG_HI1Q_TXBD_DESA_8192E			0x0348
+#define 	REG_HI2Q_TXBD_DESA_8192E			0x0350
+#define 	REG_HI3Q_TXBD_DESA_8192E			0x0358
+#define	REG_HI4Q_TXBD_DESA_8192E			0x0360
+#define 	REG_HI5Q_TXBD_DESA_8192E			0x0368
+#define 	REG_HI6Q_TXBD_DESA_8192E			0x0370
+#define 	REG_HI7Q_TXBD_DESA_8192E			0x0378
+#define	REG_MGQ_TXBD_NUM_8192E			0x0380
+#define	REG_RX_RXBD_NUM_8192E			0x0382
+#define	REG_VOQ_TXBD_NUM_8192E			0x0384
+#define	REG_VIQ_TXBD_NUM_8192E			0x0386
+#define	REG_BEQ_TXBD_NUM_8192E			0x0388
+#define	REG_BKQ_TXBD_NUM_8192E			0x038A
+#define	REG_HI0Q_TXBD_NUM_8192E			0x038C
+#define	REG_HI1Q_TXBD_NUM_8192E			0x038E
+#define	REG_HI2Q_TXBD_NUM_8192E			0x0390
+#define	REG_HI3Q_TXBD_NUM_8192E			0x0392
+#define	REG_HI4Q_TXBD_NUM_8192E			0x0394
+#define	REG_HI5Q_TXBD_NUM_8192E			0x0396
+#define	REG_HI6Q_TXBD_NUM_8192E			0x0398
+#define	REG_HI7Q_TXBD_NUM_8192E			0x039A
+#define	REG_TSFTIMER_HCI_8192E			0x039C
+
+//Read Write Point
+#define	REG_VOQ_TXBD_IDX_8192E			0x03A0
+#define	REG_VIQ_TXBD_IDX_8192E			0x03A4
+#define	REG_BEQ_TXBD_IDX_8192E			0x03A8
+#define	REG_BKQ_TXBD_IDX_8192E			0x03AC
+#define	REG_MGQ_TXBD_IDX_8192E			0x03B0
+#define	REG_RXQ_TXBD_IDX_8192E			0x03B4
+#define	REG_HI0Q_TXBD_IDX_8192E			0x03B8
+#define	REG_HI1Q_TXBD_IDX_8192E			0x03BC
+#define	REG_HI2Q_TXBD_IDX_8192E			0x03C0
+#define	REG_HI3Q_TXBD_IDX_8192E			0x03C4
+#define	REG_HI4Q_TXBD_IDX_8192E			0x03C8
+#define	REG_HI5Q_TXBD_IDX_8192E			0x03CC
+#define	REG_HI6Q_TXBD_IDX_8192E			0x03D0
+#define	REG_HI7Q_TXBD_IDX_8192E			0x03D4
+
+#define	REG_PCIE_HCPWM_8192EE			0x03D8 // ??????
+#define	REG_PCIE_HRPWM_8192EE			0x03DC	//PCIe RPWM // ??????
+#define	REG_DBI_WDATA_V1_8192E			0x03E8
+#define	REG_DBI_RDATA_V1_8192E			0x03EC
+#define	REG_DBI_FLAG_V1_8192E				0x03F0
+#define 	REG_MDIO_V1_8192E					0x3F4
+#define 	REG_PCIE_MIX_CFG_8192E				0x3F8
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_TXBF_CTRL_8192E				0x042C
+#define REG_ARFR0_8192E					0x0444
+#define REG_ARFR1_8192E					0x044C
+#define REG_CCK_CHECK_8192E				0x0454
+#define REG_AMPDU_MAX_TIME_8192E			0x0456
+#define REG_BCNQ1_BDNY_8192E				0x0457
+
+#define REG_AMPDU_MAX_LENGTH_8192E	0x0458
+#define REG_WMAC_LBK_BUF_HD_8192E			0x045D
+#define REG_NDPA_OPT_CTRL_8192E		0x045F
+#define REG_DATA_SC_8192E				0x0483
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
+#define REG_ARFR2_8192E					0x048C
+#define REG_ARFR3_8192E					0x0494
+#define REG_TXRPT_START_OFFSET			0x04AC
+#define REG_AMPDU_BURST_MODE_8192E	0x04BC
+#define REG_HT_SINGLE_AMPDU_8192E		0x04C7
+#define REG_MACID_PKT_DROP0_8192E		0x04D0
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_CTWND_8192E					0x0572
+#define REG_SECONDARY_CCA_CTRL_8192E	0x0577
+#define REG_SCH_TXCMD_8192E			0x05F8
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_MAC_CR_8192E				0x0600
+
+#define REG_MAC_TX_SM_STATE_8192E		0x06B4
+
+// Power
+#define REG_BFMER0_INFO_8192E			0x06E4
+#define REG_BFMER1_INFO_8192E			0x06EC
+#define REG_CSI_RPT_PARAM_BW20_8192E	0x06F4
+#define REG_CSI_RPT_PARAM_BW40_8192E	0x06F8
+#define REG_CSI_RPT_PARAM_BW80_8192E	0x06FC
+
+// Hardware Port 2
+#define REG_BFMEE_SEL_8192E				0x0714
+#define REG_SND_PTCL_CTRL_8192E		0x0718
+
+
+//-----------------------------------------------------
+//
+//	Redifine register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+#define	ISR_8192E							REG_HISR0_8192E
+
+//----------------------------------------------------------------------------
+//       8192E IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8192E					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8192E					BIT31		// Timeout interrupt 2
+#define	IMR_TIMER1_8192E					BIT30		// Timeout interrupt 1
+#define	IMR_PSTIMEOUT_8192E				BIT29		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8192E					BIT28		// When GTIMER4 expires, this bit is set to 1
+#define	IMR_GTINT3_8192E					BIT27		// When GTIMER3 expires, this bit is set to 1
+#define	IMR_TXBCN0ERR_8192E				BIT26		// Transmit Beacon0 Error
+#define	IMR_TXBCN0OK_8192E					BIT25		// Transmit Beacon0 OK
+#define	IMR_TSF_BIT32_TOGGLE_8192E		BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define	IMR_BCNDMAINT0_8192E				BIT20		// Beacon DMA Interrupt 0
+#define	IMR_BCNDERR0_8192E					BIT16		// Beacon Queue DMA OK0
+#define	IMR_HSISR_IND_ON_INT_8192E		BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8192E				BIT14		// Beacon DMA Interrupt Extension for Win7
+#define	IMR_ATIMEND_8192E					BIT12		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8192E					BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define	IMR_CPWM2_8192E					BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_CPWM_8192E						BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_HIGHDOK_8192E					BIT7			// High Queue DMA OK
+#define	IMR_MGNTDOK_8192E					BIT6			// Management Queue DMA OK
+#define	IMR_BKDOK_8192E					BIT5			// AC_BK DMA OK
+#define	IMR_BEDOK_8192E					BIT4			// AC_BE DMA OK
+#define	IMR_VIDOK_8192E					BIT3			// AC_VI DMA OK
+#define	IMR_VODOK_8192E					BIT2			// AC_VO DMA OK
+#define	IMR_RDU_8192E						BIT1			// Rx Descriptor Unavailable
+#define	IMR_ROK_8192E						BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_BCNDMAINT7_8192E				BIT27		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8192E				BIT26		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8192E				BIT25		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8192E				BIT24		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8192E				BIT23		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8192E				BIT22		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8192E				BIT21		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8192E					BIT20		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8192E					BIT19		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8192E					BIT18		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8192E					BIT17		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8192E					BIT16		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8192E					BIT15		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8192E					BIT14		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8192E				BIT13		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8192E					BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8192E					BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8192E					BIT9			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8192E					BIT8			// Receive FIFO Overflow
+
+//----------------------------------------------------------------------------
+//       8192E Auto LLT bits						(offset 0x224,  8bits)
+//----------------------------------------------------------------------------
+//224 REG_AUTO_LLT
+// move to hal_com_reg.h
+
+//----------------------------------------------------------------------------
+//       8192E Auto LLT bits						(offset 0x290,  32bits)
+//----------------------------------------------------------------------------
+#define BIT_DMA_MODE			BIT1
+#define BIT_USB_RXDMA_AGG_EN	BIT31
+
+//----------------------------------------------------------------------------
+//       8192E REG_SYS_CFG1						(offset 0xF0,  32bits)
+//----------------------------------------------------------------------------
+#define BIT_SPSLDO_SEL			BIT24
+
+
+//----------------------------------------------------------------------------
+//       8192E REG_CCK_CHECK						(offset 0x454,  8bits)
+//----------------------------------------------------------------------------
+#define BIT_BCN_PORT_SEL		BIT5
+
+//============================================================================
+//       Regsiter Bit and Content definition
+//============================================================================
+
+//2 ACMHWCTRL 0x05C0
+#define	AcmHw_HwEn_8192E				BIT(0)
+#define	AcmHw_VoqEn_8192E				BIT(1)
+#define	AcmHw_ViqEn_8192E				BIT(2)
+#define	AcmHw_BeqEn_8192E				BIT(3)
+#define	AcmHw_VoqStatus_8192E			BIT(5)
+#define	AcmHw_ViqStatus_8192E			BIT(6)
+#define	AcmHw_BeqStatus_8192E			BIT(7)
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8192E 128
+#define SEC_CAM_ENT_NUM_8192E 64
+#define NSS_NUM_8192E 2
+#define BAND_CAP_8192E (BAND_CAP_2G)
+#define BW_CAP_8192E (BW_CAP_20M | BW_CAP_40M)
+
+#endif //__RTL8192E_SPEC_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_sreset.h
new file mode 100644
index 000000000..879e7b057
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL88812A_SRESET_H_
+#define _RTL8812A_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8192e_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8192e_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_xmit.h
new file mode 100644
index 000000000..d483a47f6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8192e_xmit.h
@@ -0,0 +1,451 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192E_XMIT_H__
+#define __RTL8192E_XMIT_H__
+
+typedef struct txdescriptor_8192e
+{
+	//Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 own:1;
+
+	//Offset 4
+	u32 macid:6;
+	u32 rsvd0406:2;
+	u32 qsel:5;
+	u32 rd_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:4;
+	u32 navusehdr:1;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 rsvd0424:2;
+	u32 pkt_offset:5;	// unit: 8 bytes
+	u32 rsvd0431:1;
+
+	//Offset 8
+	u32 rts_rc:6;
+	u32 data_rc:6;
+	u32 agg_en:1;
+	u32 rd_en:1;
+	u32 bar_rty_th:2;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 ccx:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 ant_sel_a:1;
+	u32 ant_sel_b:1;
+	u32 tx_ant_cck:2;
+	u32 tx_antl:2;
+	u32 tx_ant_ht:2;
+
+	//Offset 12
+	u32 nextheadpage:8;
+	u32 tailpage:8;
+	u32 seq:12;
+	u32 cpu_handle:1;
+	u32 tag1:1;
+	u32 trigger_int:1;
+	u32 hwseq_en:1;
+
+	//Offset 16
+	u32 rtsrate:5;
+	u32 ap_dcfe:1;
+	u32 hwseq_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 pwr_status:3;
+	u32 wait_dcts:1;
+	u32 cts2ap_en:1;
+	u32 data_sc:2;
+	u32 data_stbc:2;
+	u32 data_short:1;
+	u32 data_bw:1;
+	u32 rts_short:1;
+	u32 rts_bw:1;
+	u32 rts_sc:2;
+	u32 vcs_stbc:2;
+
+	//Offset 20
+	u32 datarate:6;
+	u32 sgi:1;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 usb_txagg_num:8;
+
+	//Offset 24
+	u32 txagg_a:5;
+	u32 txagg_b:5;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 mcsg1_max_len:4;
+	u32 mcsg2_max_len:4;
+	u32 mcsg3_max_len:4;
+	u32 mcs7_sgi_max_len:4;
+
+	//Offset 28
+	u32 checksum:16;	// TxBuffSize(PCIe)/CheckSum(USB)
+	u32 mcsg4_max_len:4;
+	u32 mcsg5_max_len:4;
+	u32 mcsg6_max_len:4;
+	u32 mcs15_sgi_max_len:4;
+}TXDESC_8192E, *PTXDESC_8192E;
+
+
+
+//For 88e early mode
+#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
+#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
+#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
+#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
+#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
+#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
+#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+#define BMC		BIT(24)
+#define LSG		BIT(26)
+#define FSG		BIT(27)
+#define OWN 		BIT(31)
+
+
+//OFFSET 4
+#define PKT_OFFSET_SZ		0
+#define QSEL_SHT			8
+#define RATE_ID_SHT			16
+#define NAVUSEHDR			BIT(20)
+#define SEC_TYPE_SHT 		22
+#define PKT_OFFSET_SHT		26
+
+//OFFSET 8
+#define AGG_EN				BIT(12)
+#define AGG_BK					BIT(16)
+#define AMPDU_DENSITY_SHT	20
+#define ANTSEL_A			BIT(24)
+#define ANTSEL_B			BIT(25)
+#define TX_ANT_CCK_SHT		26
+#define TX_ANTL_SHT			28
+#define TX_ANT_HT_SHT		30
+
+//OFFSET 12
+#define SEQ_SHT				16
+#define EN_HWSEQ			BIT(31)
+
+//OFFSET 16
+#define 	QOS                          BIT(6)
+#define	HW_SSN				BIT(7)
+#define 	USERATE			BIT(8)
+#define 	DISDATAFB			BIT(10)
+#define   CTS_2_SELF			BIT(11)
+#define	RTS_EN				BIT(12)
+#define	HW_RTS_EN			BIT(13)
+#define 	DATA_SHORT			BIT(24)
+#define 	PWR_STATUS_SHT	15
+#define 	DATA_SC_SHT		20
+#define 	DATA_BW			BIT(25)
+
+//OFFSET 20
+#define	RTY_LMT_EN			BIT(17)
+
+
+//OFFSET 20
+#define SGI					BIT(6)
+#define USB_TXAGG_NUM_SHT	24
+
+
+//=====Tx Desc Buffer content
+
+// config element for each tx buffer
+/*
+#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 0, 16, __Valeu)
+#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 31, 1, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+4, 0, 32, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
+*/
+#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
+#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
+
+
+// Dword 0
+#define SET_TX_BUFF_DESC_LEN_0_92E(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 14, __Valeu)
+#define SET_TX_BUFF_DESC_PSB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
+#define SET_TX_BUFF_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+// Dword 1
+#define SET_TX_BUFF_DESC_ADDR_LOW_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
+#define GET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0,32)
+
+
+// Dword 2
+#define SET_TX_BUFF_DESC_ADDR_HIGH_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
+// Dword 3, RESERVED
+
+
+//=====Tx Desc content
+// Dword 0
+#define SET_TX_DESC_PKT_SIZE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
+#define SET_TX_DESC_OFFSET_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
+#define SET_TX_DESC_BMC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
+#define SET_TX_DESC_LINIP_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
+#define SET_TX_DESC_NO_ACM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
+#define SET_TX_DESC_GF_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+#define GET_TX_DESC_OWN_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
+
+// Dword 1
+#define SET_TX_DESC_MACID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
+#define SET_TX_DESC_MORE_DATA_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)
+#define SET_TX_DESC_TXOP_PS_CAP_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 30, 1, __Value)
+#define SET_TX_DESC_TXOP_PS_MODE_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 31, 1, __Value)
+
+
+// Dword 2
+#define SET_TX_DESC_PAID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
+#define SET_TX_DESC_NULL_0_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
+#define SET_TX_DESC_NULL_1_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
+#define SET_TX_DESC_BK_92E(__pTxDesc, __Value) 				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
+#define SET_TX_DESC_RAW_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
+#define GET_TX_DESC_MORE_FRAG_92E(__pTxDesc)				LE_BITS_TO_4BYTE( __pTxDesc+8, 17, 1)
+#define SET_TX_DESC_SPE_RPT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_NULL_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
+
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
+#define SET_TX_DESC_CHK_EN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
+#define SET_TX_DESC_EARLY_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HWSEQ_SEL_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
+#define SET_TX_DESC_HW_PORT_ID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
+#define SET_TX_DESC_TRY_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
+#define SET_TX_DESC_PCTS_ENABLE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
+#define SET_TX_DESC_PCTS_MASK_IDX_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)
+
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT_92E(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
+#define SET_TX_DESC_VCS_STBC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
+#define SET_TX_DESC_TX_ANT_92E(__pTxDesc,__Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 4, __Value)
+#define SET_TX_DESC_TX_POWER_0_PSET_92E(__pTxDesc,__Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)
+
+// Dword 6
+#define SET_TX_DESC_SW_DEFINE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_MBSSID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
+#define SET_TX_DESC_ANTSEL_A_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
+#define SET_TX_DESC_ANTSEL_B_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
+#define SET_TX_DESC_ANTSEL_C_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
+#define SET_TX_DESC_ANTSEL_D_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)
+
+// Dword 7
+#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)
+#define SET_TX_DESC_TX_BUFFER_SIZE_92E(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#else
+#define SET_TX_DESC_TX_DESC_CHECKSUM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#endif
+#define SET_TX_DESC_USB_TXAGG_NUM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
+
+
+//#define SET_TX_DESC_HWSEQ_EN_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+// Dword 8
+
+#define SET_TX_DESC_RTS_RC_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
+#define SET_TX_DESC_BAR_RTY_TH_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
+#define SET_TX_DESC_DATA_RC_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
+#define SET_TX_DESC_EN_HWSEQ_92E(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+#define SET_TX_DESC_NEXT_HEAD_PAGE_92E(__pTxDesc,__Value)(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
+#define SET_TX_DESC_TAIL_PAGE_92E(__pTxDesc,__Value)(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)
+
+// Dword 9
+#define SET_TX_DESC_PADDING_LENGTH_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
+#define SET_TX_DESC_TXBF_PATH_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 11, 1, __Value)
+#define SET_TX_DESC_SEQ_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
+#define SET_TX_DESC_FINAL_DATA_RATE_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 8, __Value)
+
+
+#define SET_EARLYMODE_PKTNUM_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
+#define SET_EARLYMODE_LEN3_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+void rtl8192e_cal_txdesc_chksum(u8 *ptxdesc);
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8192eu_init_xmit_priv(PADAPTER padapter);
+void rtl8192eu_free_xmit_priv(PADAPTER padapter);
+s32 rtl8192eu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8192eu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8192eu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8192eu_xmit_buf_handler(PADAPTER padapter);
+#define hal_xmit_handler rtl8192eu_xmit_buf_handler
+void rtl8192eu_xmit_tasklet(void *priv);
+s32 rtl8192eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8192ee_init_xmit_priv(PADAPTER padapter);
+void rtl8192ee_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf *rtl8192ee_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+s32	rtl8192ee_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void	rtl8192ee_xmitframe_resume(_adapter *padapter);
+s32 rtl8192ee_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8192ee_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+void rtl8192ee_xmit_tasklet(void *priv);
+#endif
+
+#if defined(CONFIG_SDIO_HCI)||defined (CONFIG_GSPI_HCI)
+s32 rtl8192es_init_xmit_priv(PADAPTER padapter);
+void rtl8192es_free_xmit_priv(PADAPTER padapter);
+
+s32 rtl8192es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8192es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8192es_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+thread_return rtl8192es_xmit_thread(thread_context context);
+s32 rtl8192es_xmit_buf_handler(PADAPTER padapter);
+
+#ifdef CONFIG_SDIO_TX_TASKLET
+void rtl8192es_xmit_tasklet(void *priv);
+#endif
+#endif
+
+struct txrpt_ccx_92e {
+	/* offset 0 */
+	u8 tag1:1;
+	u8 pkt_num:3;
+	u8 txdma_underflow:1;
+	u8 int_bt:1;
+	u8 int_tri:1;
+	u8 int_ccx:1;
+
+	/* offset 1 */
+	u8 mac_id:6;
+	u8 pkt_ok:1;
+	u8 bmc:1;
+
+	/* offset 2 */
+	u8 retry_cnt:6;
+	u8 lifetime_over:1;
+	u8 retry_over:1;
+
+	/* offset 3 */
+	u8 ccx_qtime0;
+	u8 ccx_qtime1;
+
+	/* offset 5 */
+	u8 final_data_rate;
+
+	/* offset 6 */
+	u8 sw1:4;
+	u8 qsel:4;
+
+	/* offset 7 */
+	u8 sw0;
+};
+
+#ifdef CONFIG_TX_EARLY_MODE
+void UpdateEarlyModeInfo8192E(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf );
+#endif
+ s32	rtl8192e_init_xmit_priv(_adapter *padapter);
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,u8 *ptxdesc);
+
+void rtl8192e_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,
+		u8 IsPsPoll,u8	IsBTQosNull, u8 bDataFrame);
+void rtl8192e_cal_txdesc_chksum(u8 *ptxdesc);
+
+u8	BWMapping_92E(PADAPTER Adapter, struct pkt_attrib *pattrib);
+u8	SCMapping_92E(PADAPTER Adapter, struct pkt_attrib	*pattrib);
+void fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
+void fill_txdesc_vcs(struct pkt_attrib *pattrib, u8 *ptxdesc);
+void fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
+void rtl8192e_fixed_rate(_adapter *padapter,u8 *ptxdesc);
+
+#endif //__RTL8192E_XMIT_H__
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_cmd.h
new file mode 100644
index 000000000..7aae31435
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_cmd.h
@@ -0,0 +1,214 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_CMD_H__
+#define __RTL8703B_CMD_H__
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD DEFINITION    ------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+enum h2c_cmd_8703B{
+	//Common Class: 000
+	H2C_8703B_RSVD_PAGE = 0x00,
+	H2C_8703B_MEDIA_STATUS_RPT = 0x01,
+	H2C_8703B_SCAN_ENABLE = 0x02,
+	H2C_8703B_KEEP_ALIVE = 0x03,
+	H2C_8703B_DISCON_DECISION = 0x04,
+	H2C_8703B_PSD_OFFLOAD = 0x05,
+	H2C_8703B_AP_OFFLOAD = 0x08,
+	H2C_8703B_BCN_RSVDPAGE = 0x09,
+	H2C_8703B_PROBERSP_RSVDPAGE = 0x0A,
+	H2C_8703B_FCS_RSVDPAGE = 0x10,
+	H2C_8703B_FCS_INFO = 0x11,
+	H2C_8703B_AP_WOW_GPIO_CTRL = 0x13,
+
+	//PoweSave Class: 001
+	H2C_8703B_SET_PWR_MODE = 0x20,
+	H2C_8703B_PS_TUNING_PARA = 0x21,
+	H2C_8703B_PS_TUNING_PARA2 = 0x22,
+	H2C_8703B_P2P_LPS_PARAM = 0x23,
+	H2C_8703B_P2P_PS_OFFLOAD = 0x24,
+	H2C_8703B_PS_SCAN_ENABLE = 0x25,
+	H2C_8703B_SAP_PS_ = 0x26,
+	H2C_8703B_INACTIVE_PS_ = 0x27, //Inactive_PS
+	H2C_8703B_FWLPS_IN_IPS_ = 0x28,
+
+	//Dynamic Mechanism Class: 010
+	H2C_8703B_MACID_CFG = 0x40,
+	H2C_8703B_TXBF = 0x41,
+	H2C_8703B_RSSI_SETTING = 0x42,
+	H2C_8703B_AP_REQ_TXRPT = 0x43,
+	H2C_8703B_INIT_RATE_COLLECT = 0x44,
+	H2C_8703B_RA_PARA_ADJUST = 0x46,
+
+	//BT Class: 011
+	H2C_8703B_B_TYPE_TDMA = 0x60,
+	H2C_8703B_BT_INFO = 0x61,
+	H2C_8703B_FORCE_BT_TXPWR = 0x62,
+	H2C_8703B_BT_IGNORE_WLANACT = 0x63,
+	H2C_8703B_DAC_SWING_VALUE = 0x64,
+	H2C_8703B_ANT_SEL_RSV = 0x65,
+	H2C_8703B_WL_OPMODE = 0x66,
+	H2C_8703B_BT_MP_OPER = 0x67,
+	H2C_8703B_BT_CONTROL = 0x68,
+	H2C_8703B_BT_WIFI_CTRL = 0x69,
+	H2C_8703B_BT_FW_PATCH = 0x6A,
+	H2C_8703B_BT_WLAN_CALIBRATION = 0x6D,
+
+	//WOWLAN Class: 100
+	H2C_8703B_WOWLAN = 0x80,
+	H2C_8703B_REMOTE_WAKE_CTRL = 0x81,
+	H2C_8703B_AOAC_GLOBAL_INFO = 0x82,
+	H2C_8703B_AOAC_RSVD_PAGE = 0x83,
+	H2C_8703B_AOAC_RSVD_PAGE2 = 0x84,
+	H2C_8703B_D0_SCAN_OFFLOAD_CTRL = 0x85,
+	H2C_8703B_D0_SCAN_OFFLOAD_INFO = 0x86,
+	H2C_8703B_CHNL_SWITCH_OFFLOAD = 0x87,
+	H2C_8703B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
+	H2C_8703B_P2P_OFFLOAD = 0x8B,
+
+	H2C_8703B_RESET_TSF = 0xC0,
+	H2C_8703B_MAXID,
+};
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD CONTENT    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+//_RSVDPAGE_LOC_CMD_0x00
+#define SET_8703B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8703B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8703B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8703B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8703B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+//_KEEP_ALIVE_CMD_0x03
+#define SET_8703B_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8703B_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8703B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8703B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+
+//_DISCONNECT_DECISION_CMD_0x04
+#define SET_8703B_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8703B_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8703B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8703B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+
+// _PWR_MOD_CMD_0x20
+#define SET_8703B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8703B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8703B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8703B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8703B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8703B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8703B_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+
+#define GET_8703B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+// _PS_TUNE_PARAM_CMD_0x21
+#define SET_8703B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8703B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8703B_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
+#define SET_8703B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
+#define SET_8703B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+
+//_MACID_CFG_CMD_0x40
+#define SET_8703B_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
+#define SET_8703B_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)
+
+//_RSSI_SETTING_CMD_0x42
+#define SET_8703B_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8703B_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
+#define SET_8703B_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+
+// _AP_REQ_TXRPT_CMD_0x43
+#define SET_8703B_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8703B_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+
+// _FORCE_BT_TXPWR_CMD_0x62
+#define SET_8703B_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+
+// _FORCE_BT_MP_OPER_CMD_0x67
+#define SET_8703B_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#define SET_8703B_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
+#define SET_8703B_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8703B_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+#define SET_8703B_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_8703B_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+
+// _BT_FW_PATCH_0x6A
+#define SET_8703B_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((pu1Byte)(__pH2CCmd), 0, 16, __Value)
+#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8703B_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+
+//---------------------------------------------------------------------------------------------------------//
+//-------------------------------------------    Structure    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    Function Statement     --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+// host message to firmware cmd
+void rtl8703b_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
+void rtl8703b_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
+void rtl8703b_set_rssi_cmd(PADAPTER padapter, u8 *param);
+void rtl8703b_Add_RateATid(PADAPTER pAdapter, u64 rate_bitmap, u8 *arg, u8 rssi_level);
+void rtl8703b_fw_try_ap_cmd(PADAPTER padapter, u32 need_ack);
+//s32 rtl8703b_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable);
+void rtl8703b_set_FwPsTuneParam_cmd(PADAPTER padapter);
+void rtl8703b_set_FwMacIdConfig_cmd(_adapter* padapter, u8 mac_id, u8 raid, u8 bw, u8 sgi, u32 mask);
+void rtl8703b_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
+void rtl8703b_download_rsvd_page(PADAPTER padapter, u8 mstatus);
+#ifdef CONFIG_BT_COEXIST
+void rtl8703b_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
+#ifdef CONFIG_P2P
+void rtl8703b_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+
+#ifdef CONFIG_P2P_WOWLAN
+void rtl8703b_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
+#endif
+
+void rtl8703b_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+u8 rtl8703b_reset_tsf(_adapter *padapter, u8 reset_port);
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+s32 FillH2CCmd8703B(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8703B(_adapter *padapter, bool wowlan);
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_dm.h
new file mode 100644
index 000000000..094adc85e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_dm.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_DM_H__
+#define __RTL8703B_DM_H__
+//============================================================
+// Description:
+//
+// This file is for 8703B dynamic mechanism only
+//
+//
+//============================================================
+
+//============================================================
+// structure and define
+//============================================================
+
+//============================================================
+// function prototype
+//============================================================
+
+void rtl8703b_init_dm_priv(PADAPTER padapter);
+void rtl8703b_deinit_dm_priv(PADAPTER padapter);
+
+void rtl8703b_InitHalDm(PADAPTER padapter);
+void rtl8703b_HalDmWatchDog(PADAPTER padapter);
+void rtl8703b_HalDmWatchDog_in_LPS(PADAPTER padapter);
+void rtl8703b_hal_dm_in_lps(PADAPTER padapter);
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_hal.h
new file mode 100644
index 000000000..af31ac863
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_hal.h
@@ -0,0 +1,325 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_HAL_H__
+#define __RTL8703B_HAL_H__
+
+#include "hal_data.h"
+
+#include "rtl8703b_spec.h"
+#include "rtl8703b_rf.h"
+#include "rtl8703b_dm.h"
+#include "rtl8703b_recv.h"
+#include "rtl8703b_xmit.h"
+#include "rtl8703b_cmd.h"
+#include "rtl8703b_led.h"
+#include "Hal8703BPwrSeq.h"
+#include "Hal8703BPhyReg.h"
+#include "Hal8703BPhyCfg.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8703b_sreset.h"
+#endif
+
+
+//---------------------------------------------------------------------
+//		RTL8703B From file
+//---------------------------------------------------------------------
+	#define RTL8703B_FW_IMG					"rtl8703b/FW_NIC.bin"
+	#define RTL8703B_FW_WW_IMG				"rtl8703b/FW_WoWLAN.bin"
+	#define RTL8703B_PHY_REG					"rtl8703b/PHY_REG.txt"
+	#define RTL8703B_PHY_RADIO_A				"rtl8703b/RadioA.txt"
+	#define RTL8703B_PHY_RADIO_B				"rtl8703b/RadioB.txt"
+	#define RTL8703B_TXPWR_TRACK				"rtl8703b/TxPowerTrack.txt"
+	#define RTL8703B_AGC_TAB					"rtl8703b/AGC_TAB.txt"
+	#define RTL8703B_PHY_MACREG 				"rtl8703b/MAC_REG.txt"
+	#define RTL8703B_PHY_REG_PG				"rtl8703b/PHY_REG_PG.txt"
+	#define RTL8703B_PHY_REG_MP				"rtl8703b/PHY_REG_MP.txt"
+	#define RTL8703B_TXPWR_LMT 				"rtl8703b/TXPWR_LMT.txt"
+
+//---------------------------------------------------------------------
+//		RTL8703B From header
+//---------------------------------------------------------------------
+
+#if MP_DRIVER == 1
+	#define Rtl8703B_FwBTImgArray				Rtl8703BFwBTImgArray
+	#define Rtl8703B_FwBTImgArrayLength		Rtl8703BFwBTImgArrayLength
+
+	#define Rtl8703B_PHY_REG_Array_MP			Rtl8703B_PHYREG_Array_MP
+	#define Rtl8703B_PHY_REG_Array_MPLength	Rtl8703B_PHYREG_Array_MPLength
+#endif
+
+
+#define FW_8703B_SIZE			0x8000
+#define FW_8703B_START_ADDRESS	0x1000
+#define FW_8703B_END_ADDRESS		0x1FFF //0x5FFF
+
+#define IS_FW_HEADER_EXIST_8703B(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x03B0)
+
+typedef struct _RT_FIRMWARE {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[FW_8703B_SIZE];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8703B, *PRT_FIRMWARE_8703B;
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+typedef struct _RT_8703B_FIRMWARE_HDR
+{
+	// 8-byte alinment required
+
+	//--- LONG WORD 0 ----
+	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+	u8		Category;	// AP/NIC and USB/PCI
+	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+	u16		Version;		// FW Version
+	u16		Subversion;	// FW Subversion, default 0x00
+
+	//--- LONG WORD 1 ----
+	u8		Month;	// Release time Month field
+	u8		Date;	// Release time Date field
+	u8		Hour;	// Release time Hour field
+	u8		Minute;	// Release time Minute field
+	u16		RamCodeSize;	// The size of RAM code
+	u16		Rsvd2;
+
+	//--- LONG WORD 2 ----
+	u32		SvnIdx;	// The SVN entry index
+	u32		Rsvd3;
+
+	//--- LONG WORD 3 ----
+	u32		Rsvd4;
+	u32		Rsvd5;
+}RT_8703B_FIRMWARE_HDR, *PRT_8703B_FIRMWARE_HDR;
+
+#define DRIVER_EARLY_INT_TIME_8703B		0x05
+#define BCN_DMA_ATIME_INT_TIME_8703B		0x02
+
+// for 8703B
+// TX 32K, RX 16K, Page size 128B for TX, 8B for RX
+#define PAGE_SIZE_TX_8703B			128
+#define PAGE_SIZE_RX_8703B			8
+
+#define TX_DMA_SIZE_8703B			0x8000	/* 32K(TX) */
+#define RX_DMA_SIZE_8703B			0x4000	/* 16K(RX) */
+
+#ifdef CONFIG_WOWLAN
+#define RESV_FMWF	WKFMCAM_SIZE*MAX_WKFM_NUM /* 16 entries, for each is 24 bytes*/
+#else
+#define RESV_FMWF	0
+#endif
+
+#ifdef CONFIG_FW_C2H_DEBUG
+#define RX_DMA_RESERVED_SIZE_8703B	0x100	// 256B, reserved for c2h debug message
+#else
+#define RX_DMA_RESERVED_SIZE_8703B	0x80	// 128B, reserved for tx report
+#endif
+#define RX_DMA_BOUNDARY_8703B		(RX_DMA_SIZE_8703B - RX_DMA_RESERVED_SIZE_8703B - 1)
+
+
+// Note: We will divide number of page equally for each queue other than public queue!
+
+//For General Reserved Page Number(Beacon Queue is reserved page)
+//Beacon:2, PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1
+#define BCNQ_PAGE_NUM_8703B		0x08
+#ifdef CONFIG_CONCURRENT_MODE
+#define BCNQ1_PAGE_NUM_8703B		0x08 // 0x04
+#else
+#define BCNQ1_PAGE_NUM_8703B		0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef BCNQ1_PAGE_NUM_8703B
+#define BCNQ1_PAGE_NUM_8703B		0x00 // 0x04
+#endif
+
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8703B	0x07
+#else
+#define WOWLAN_PAGE_NUM_8703B	0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef WOWLAN_PAGE_NUM_8703B
+#define WOWLAN_PAGE_NUM_8703B	0x15
+#endif
+
+#ifdef CONFIG_AP_WOWLAN
+#define AP_WOWLAN_PAGE_NUM_8703B	0x02
+#endif
+
+#define TX_TOTAL_PAGE_NUMBER_8703B	(0xFF - BCNQ_PAGE_NUM_8703B - BCNQ1_PAGE_NUM_8703B - WOWLAN_PAGE_NUM_8703B)
+#define TX_PAGE_BOUNDARY_8703B		(TX_TOTAL_PAGE_NUMBER_8703B + 1)
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8703B	TX_TOTAL_PAGE_NUMBER_8703B
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8703B		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8703B + 1)
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8703B
+#define NORMAL_PAGE_NUM_HPQ_8703B		0x0C
+#define NORMAL_PAGE_NUM_LPQ_8703B		0x02
+#define NORMAL_PAGE_NUM_NPQ_8703B		0x02
+
+// Note: For Normal Chip Setting, modify later
+#define WMM_NORMAL_PAGE_NUM_HPQ_8703B		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8703B		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8703B		0x20
+
+
+#include "HalVerDef.h"
+#include "hal_com.h"
+
+#define EFUSE_OOB_PROTECT_BYTES 		15
+
+#define HAL_EFUSE_MEMORY
+
+#define HWSET_MAX_SIZE_8703B			256
+#define EFUSE_REAL_CONTENT_LEN_8703B		256
+#define EFUSE_MAP_LEN_8703B				512
+#define EFUSE_MAX_SECTION_8703B			64
+
+#define EFUSE_IC_ID_OFFSET			506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_8703B)
+
+#define EFUSE_ACCESS_ON			0x69
+#define EFUSE_ACCESS_OFF			0x00
+
+//========================================================
+//			EFUSE for BT definition
+//========================================================
+#define BANK_NUM		1
+#define EFUSE_BT_REAL_BANK_CONTENT_LEN	128
+#define EFUSE_BT_REAL_CONTENT_LEN		(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)
+#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
+#define EFUSE_BT_MAX_SECTION			(EFUSE_BT_MAP_LEN / 8)
+#define EFUSE_PROTECT_BYTES_BANK		16
+
+typedef struct _C2H_EVT_HDR
+{
+	u8	CmdID;
+	u8	CmdLen;
+	u8	CmdSeq;
+} __attribute__((__packed__)) C2H_EVT_HDR, *PC2H_EVT_HDR;
+
+typedef enum tag_Package_Definition
+{
+    PACKAGE_DEFAULT,
+    PACKAGE_QFN68,
+    PACKAGE_TFBGA90,
+    PACKAGE_TFBGA80,
+    PACKAGE_TFBGA79
+}PACKAGE_TYPE_E;
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+// rtl8703b_hal_init.c
+s32 rtl8703b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
+void rtl8703b_FirmwareSelfReset(PADAPTER padapter);
+void rtl8703b_InitializeFirmwareVars(PADAPTER padapter);
+
+void rtl8703b_InitAntenna_Selection(PADAPTER padapter);
+void rtl8703b_DeinitAntenna_Selection(PADAPTER padapter);
+void rtl8703b_CheckAntenna_Selection(PADAPTER padapter);
+void rtl8703b_init_default_value(PADAPTER padapter);
+
+s32 rtl8703b_InitLLTTable(PADAPTER padapter);
+
+s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
+s32 CardDisableWithoutHWSM(PADAPTER padapter);
+
+// EFuse
+u8 GetEEPROMSize8703B(PADAPTER padapter);
+void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
+void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
+void Hal_EfuseParseTxPowerInfo_8703B(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseBTCoexistInfo_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseEEPROMVer_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseChnlPlan_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseCustomerID_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseAntennaDiversity_8703B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseXtal_8703B(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
+void Hal_EfuseParseThermalMeter_8703B(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
+VOID Hal_EfuseParseVoltage_8703B(PADAPTER pAdapter,u8* hwinfo,BOOLEAN 	AutoLoadFail);
+VOID Hal_EfuseParseBoardType_8703B(PADAPTER Adapter,	u8*	PROMContent,BOOLEAN AutoloadFail);
+
+#ifdef CONFIG_C2H_PACKET_EN
+void rtl8703b_c2h_packet_handler(PADAPTER padapter, u8 *pbuf, u16 length);
+#endif
+
+
+void rtl8703b_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8703b(_adapter *adapter);
+void SetHwReg8703B(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg8703B(PADAPTER padapter, u8 variable, u8 *val);
+#ifdef CONFIG_C2H_PACKET_EN
+void SetHwRegWithBuf8703B(PADAPTER padapter, u8 variable, u8 *pbuf, int len);
+#endif // CONFIG_C2H_PACKET_EN
+u8 SetHalDefVar8703B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+u8 GetHalDefVar8703B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+
+// register
+void rtl8703b_InitBeaconParameters(PADAPTER padapter);
+void rtl8703b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
+void	_InitBurstPktLen_8703BS(PADAPTER Adapter);
+void _InitLTECoex_8703BS(PADAPTER Adapter);
+void _InitMacAPLLSetting_8703B(PADAPTER Adapter);
+void _8051Reset8703(PADAPTER padapter);
+#ifdef CONFIG_WOWLAN
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+void rtl8703b_start_thread(_adapter *padapter);
+void rtl8703b_stop_thread(_adapter *padapter);
+
+#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
+void rtl8703bs_init_checkbthang_workqueue(_adapter * adapter);
+void rtl8703bs_free_checkbthang_workqueue(_adapter * adapter);
+void rtl8703bs_cancle_checkbthang_workqueue(_adapter * adapter);
+void rtl8703bs_hal_check_bt_hang(_adapter * adapter);
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
+#endif
+
+int FirmwareDownloadBT(IN PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
+
+void CCX_FwC2HTxRpt_8703b(PADAPTER padapter, u8 *pdata, u8 len);
+s32 c2h_id_filter_ccx_8703b(u8 *buf);
+s32 c2h_handler_8703b(PADAPTER padapter, u8 *pC2hEvent);
+u8 MRateToHwRate8703B(u8  rate);
+u8 HwRateToMRate8703B(u8	 rate);
+
+void Hal_ReadRFGainOffset(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8703BE(PADAPTER Adapter);
+VOID	UpdateInterruptMask8703BE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_led.h
new file mode 100644
index 000000000..bfd851e6f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_led.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_LED_H__
+#define __RTL8703B_LED_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8703bu_InitSwLeds(PADAPTER padapter);
+void rtl8703bu_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_SDIO_HCI
+void rtl8703bs_InitSwLeds(PADAPTER padapter);
+void rtl8703bs_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_GSPI_HCI
+void rtl8703bs_InitSwLeds(PADAPTER padapter);
+void rtl8703bs_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_PCI_HCI
+void rtl8703be_InitSwLeds(PADAPTER padapter);
+void rtl8703be_DeInitSwLeds(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_recv.h
new file mode 100644
index 000000000..091705e0b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_recv.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_RECV_H__
+#define __RTL8703B_RECV_H__
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+#if defined(CONFIG_USB_HCI)
+
+#ifndef MAX_RECVBUF_SZ
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+	#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+		//#define MAX_RECVBUF_SZ (32768) // 32k
+		//#define MAX_RECVBUF_SZ (16384) //16K
+		//#define MAX_RECVBUF_SZ (10240) //10K
+		#ifdef CONFIG_PLATFORM_MSTAR
+			#define MAX_RECVBUF_SZ (8192) // 8K
+		#else
+		        #define MAX_RECVBUF_SZ (15360) // 15k < 16k
+		#endif
+		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+	#else
+		#define MAX_RECVBUF_SZ (4000) // about 4K
+	#endif
+#endif
+#endif //!MAX_RECVBUF_SZ
+
+#elif defined(CONFIG_PCI_HCI)
+//#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+//	#define MAX_RECVBUF_SZ (9100)
+//#else
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+//#endif
+
+
+#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+
+#define MAX_RECVBUF_SZ (10240)
+
+#endif
+
+// Rx smooth factor
+#define	Rx_Smooth_Factor (20)
+
+#ifdef CONFIG_SDIO_HCI
+#ifndef CONFIG_SDIO_RX_COPY
+#undef MAX_RECVBUF_SZ
+#define MAX_RECVBUF_SZ	(RX_DMA_SIZE_8703B - RX_DMA_RESERVED_SIZE_8703B)
+#endif // !CONFIG_SDIO_RX_COPY
+#endif // CONFIG_SDIO_HCI
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+s32 rtl8703bs_init_recv_priv(PADAPTER padapter);
+void rtl8703bs_free_recv_priv(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_USB_HCI
+int rtl8703bu_init_recv_priv(_adapter *padapter);
+void rtl8703bu_free_recv_priv (_adapter *padapter);
+void rtl8703bu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8703be_init_recv_priv(PADAPTER padapter);
+void rtl8703be_free_recv_priv(PADAPTER padapter);
+#endif
+
+void rtl8703b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+
+#endif /* __RTL8703B_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_rf.h
new file mode 100644
index 000000000..20e7268aa
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_rf.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_RF_H__
+#define __RTL8703B_RF_H__
+
+int	PHY_RF6052_Config8703B(	IN	PADAPTER		Adapter	);
+
+VOID
+PHY_RF6052SetBandwidth8703B(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH		Bandwidth);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_spec.h
new file mode 100644
index 000000000..82a95ab82
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_spec.h
@@ -0,0 +1,480 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8703B_SPEC_H__
+#define __RTL8703B_SPEC_H__
+
+#include <drv_conf.h>
+
+
+#define HAL_NAV_UPPER_UNIT_8703B		128		// micro-second
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_ISO_CTRL_8703B			0x0000	// 2 Byte
+#define REG_SYS_FUNC_EN_8703B			0x0002	// 2 Byte
+#define REG_APS_FSMCO_8703B			0x0004	// 4 Byte
+#define REG_SYS_CLKR_8703B				0x0008	// 2 Byte
+#define REG_9346CR_8703B				0x000A	// 2 Byte
+#define REG_EE_VPD_8703B				0x000C	// 2 Byte
+#define REG_AFE_MISC_8703B				0x0010	// 1 Byte
+#define REG_SPS0_CTRL_8703B				0x0011	// 7 Byte
+#define REG_SPS_OCP_CFG_8703B			0x0018	// 4 Byte
+#define REG_RSV_CTRL_8703B				0x001C	// 3 Byte
+#define REG_RF_CTRL_8703B				0x001F	// 1 Byte
+#define REG_LPLDO_CTRL_8703B			0x0023	// 1 Byte
+#define REG_AFE_XTAL_CTRL_8703B		0x0024	// 4 Byte
+#define REG_AFE_PLL_CTRL_8703B			0x0028	// 4 Byte
+#define REG_MAC_PLL_CTRL_EXT_8703B		0x002c 	// 4 Byte
+#define REG_EFUSE_CTRL_8703B			0x0030
+#define REG_EFUSE_TEST_8703B			0x0034
+#define REG_PWR_DATA_8703B				0x0038
+#define REG_CAL_TIMER_8703B				0x003C
+#define REG_ACLK_MON_8703B				0x003E
+#define REG_GPIO_MUXCFG_8703B			0x0040
+#define REG_GPIO_IO_SEL_8703B			0x0042
+#define REG_MAC_PINMUX_CFG_8703B		0x0043
+#define REG_GPIO_PIN_CTRL_8703B			0x0044
+#define REG_GPIO_INTM_8703B				0x0048
+#define REG_LEDCFG0_8703B				0x004C
+#define REG_LEDCFG1_8703B				0x004D
+#define REG_LEDCFG2_8703B				0x004E
+#define REG_LEDCFG3_8703B				0x004F
+#define REG_FSIMR_8703B					0x0050
+#define REG_FSISR_8703B					0x0054
+#define REG_HSIMR_8703B					0x0058
+#define REG_HSISR_8703B					0x005c
+#define REG_GPIO_EXT_CTRL				0x0060
+#define REG_PAD_CTRL1_8703B		0x0064
+#define REG_MULTI_FUNC_CTRL_8703B		0x0068
+#define REG_GPIO_STATUS_8703B			0x006C
+#define REG_SDIO_CTRL_8703B				0x0070
+#define REG_OPT_CTRL_8703B				0x0074
+#define REG_AFE_CTRL_4_8703B		0x0078
+#define REG_MCUFWDL_8703B				0x0080
+#define REG_HMEBOX_DBG_0_8703B	0x0088
+#define REG_HMEBOX_DBG_1_8703B	0x008A
+#define REG_HMEBOX_DBG_2_8703B	0x008C
+#define REG_HMEBOX_DBG_3_8703B	0x008E
+#define REG_HIMR0_8703B					0x00B0
+#define REG_HISR0_8703B					0x00B4
+#define REG_HIMR1_8703B					0x00B8
+#define REG_HISR1_8703B					0x00BC
+#define REG_PMC_DBG_CTRL2_8703B			0x00CC
+#define	REG_EFUSE_BURN_GNT_8703B		0x00CF
+#define REG_HPON_FSM_8703B				0x00EC
+#define REG_SYS_CFG_8703B				0x00F0
+#define REG_SYS_CFG1_8703B				0x00FC
+#define REG_ROM_VERSION					0x00FD
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_C2HEVT_CMD_ID_8703B	0x01A0
+#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
+#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
+#define REG_C2HEVT_CMD_LEN_8703B        0x01AE
+#define REG_C2HEVT_CMD_LEN_88XX		REG_C2HEVT_CMD_LEN_8703B
+#define REG_C2HEVT_CLEAR_8703B			0x01AF
+#define REG_MCUTST_1_8703B				0x01C0
+#define REG_WOWLAN_WAKE_REASON 0x01C7
+#define REG_FMETHR_8703B				0x01C8
+#define REG_HMETFR_8703B				0x01CC
+#define REG_HMEBOX_0_8703B				0x01D0
+#define REG_HMEBOX_1_8703B				0x01D4
+#define REG_HMEBOX_2_8703B				0x01D8
+#define REG_HMEBOX_3_8703B				0x01DC
+#define REG_LLT_INIT_8703B				0x01E0
+#define REG_HMEBOX_EXT0_8703B			0x01F0
+#define REG_HMEBOX_EXT1_8703B			0x01F4
+#define REG_HMEBOX_EXT2_8703B			0x01F8
+#define REG_HMEBOX_EXT3_8703B			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RQPN_8703B					0x0200
+#define REG_FIFOPAGE_8703B				0x0204
+#define REG_DWBCN0_CTRL_8703B			REG_TDECTRL
+#define REG_TXDMA_OFFSET_CHK_8703B	0x020C
+#define REG_TXDMA_STATUS_8703B		0x0210
+#define REG_RQPN_NPQ_8703B			0x0214
+#define REG_DWBCN1_CTRL_8703B			0x0228
+
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_AGG_PG_TH_8703B		0x0280
+#define REG_FW_UPD_RDPTR_8703B		0x0284 // FW shall update this register before FW write RXPKT_RELEASE_POLL to 1
+#define REG_RXDMA_CONTROL_8703B		0x0286 // Control the RX DMA.
+#define REG_RXPKT_NUM_8703B			0x0287 // The number of packets in RXPKTBUF.
+#define REG_RXDMA_STATUS_8703B			0x0288
+#define REG_RXDMA_MODE_CTRL_8703B		0x0290
+#define REG_EARLY_MODE_CONTROL_8703B	0x02BC
+#define REG_RSVD5_8703B					0x02F0
+#define REG_RSVD6_8703B					0x02F4
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG_8703B		0x0300
+#define	REG_INT_MIG_8703B				0x0304	// Interrupt Migration
+#define	REG_BCNQ_DESA_8703B			0x0308	// TX Beacon Descriptor Address
+#define	REG_HQ_DESA_8703B				0x0310	// TX High Queue Descriptor Address
+#define	REG_MGQ_DESA_8703B			0x0318	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_DESA_8703B			0x0320	// TX VO Queue Descriptor Address
+#define	REG_VIQ_DESA_8703B				0x0328	// TX VI Queue Descriptor Address
+#define	REG_BEQ_DESA_8703B			0x0330	// TX BE Queue Descriptor Address
+#define	REG_BKQ_DESA_8703B			0x0338	// TX BK Queue Descriptor Address
+#define	REG_RX_DESA_8703B				0x0340	// RX Queue	Descriptor Address
+#define	REG_DBI_WDATA_8703B			0x0348	// DBI Write Data
+#define	REG_DBI_RDATA_8703B			0x034C	// DBI Read Data
+#define	REG_DBI_ADDR_8703B				0x0350	// DBI Address
+#define	REG_DBI_FLAG_8703B				0x0352	// DBI Read/Write Flag
+#define	REG_MDIO_WDATA_8703B		0x0354	// MDIO for Write PCIE PHY
+#define	REG_MDIO_RDATA_8703B			0x0356	// MDIO for Reads PCIE PHY
+#define	REG_MDIO_CTL_8703B			0x0358	// MDIO for Control
+#define	REG_DBG_SEL_8703B				0x0360	// Debug Selection Register
+#define	REG_PCIE_HRPWM_8703B			0x0361	//PCIe RPWM
+#define	REG_PCIE_HCPWM_8703B			0x0363	//PCIe CPWM
+#define	REG_PCIE_MULTIFET_CTRL_8703B	0x036A	//PCIE Multi-Fethc Control
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_VOQ_INFORMATION_8703B		0x0400
+#define REG_VIQ_INFORMATION_8703B		0x0404
+#define REG_BEQ_INFORMATION_8703B		0x0408
+#define REG_BKQ_INFORMATION_8703B		0x040C
+#define REG_MGQ_INFORMATION_8703B		0x0410
+#define REG_HGQ_INFORMATION_8703B		0x0414
+#define REG_BCNQ_INFORMATION_8703B	0x0418
+#define REG_TXPKT_EMPTY_8703B			0x041A
+
+#define REG_FWHW_TXQ_CTRL_8703B		0x0420
+#define REG_HWSEQ_CTRL_8703B			0x0423
+#define REG_TXPKTBUF_BCNQ_BDNY_8703B	0x0424
+#define REG_TXPKTBUF_MGQ_BDNY_8703B	0x0425
+#define REG_LIFECTRL_CTRL_8703B			0x0426
+#define REG_MULTI_BCNQ_OFFSET_8703B	0x0427
+#define REG_SPEC_SIFS_8703B				0x0428
+#define REG_RL_8703B						0x042A
+#define REG_TXBF_CTRL_8703B				0x042C
+#define REG_DARFRC_8703B				0x0430
+#define REG_RARFRC_8703B				0x0438
+#define REG_RRSR_8703B					0x0440
+#define REG_ARFR0_8703B					0x0444
+#define REG_ARFR1_8703B					0x044C
+#define REG_CCK_CHECK_8703B				0x0454
+#define REG_AMPDU_MAX_TIME_8703B		0x0456
+#define REG_TXPKTBUF_BCNQ_BDNY1_8703B	0x0457
+
+#define REG_AMPDU_MAX_LENGTH_8703B	0x0458
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8703B	0x045D
+#define REG_NDPA_OPT_CTRL_8703B		0x045F
+#define REG_FAST_EDCA_CTRL_8703B		0x0460
+#define REG_RD_RESP_PKT_TH_8703B		0x0463
+#define REG_DATA_SC_8703B				0x0483
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
+#define REG_TXRPT_START_OFFSET		0x04AC
+#define REG_POWER_STAGE1_8703B		0x04B4
+#define REG_POWER_STAGE2_8703B		0x04B8
+#define REG_AMPDU_BURST_MODE_8703B	0x04BC
+#define REG_PKT_VO_VI_LIFE_TIME_8703B	0x04C0
+#define REG_PKT_BE_BK_LIFE_TIME_8703B	0x04C2
+#define REG_STBC_SETTING_8703B			0x04C4
+#define REG_HT_SINGLE_AMPDU_8703B		0x04C7
+#define REG_PROT_MODE_CTRL_8703B		0x04C8
+#define REG_MAX_AGGR_NUM_8703B		0x04CA
+#define REG_RTS_MAX_AGGR_NUM_8703B	0x04CB
+#define REG_BAR_MODE_CTRL_8703B		0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT_8703B	0x04CF
+#define REG_MACID_PKT_DROP0_8703B		0x04D0
+#define REG_MACID_PKT_SLEEP_8703B		0x04D4
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_EDCA_VO_PARAM_8703B		0x0500
+#define REG_EDCA_VI_PARAM_8703B		0x0504
+#define REG_EDCA_BE_PARAM_8703B		0x0508
+#define REG_EDCA_BK_PARAM_8703B		0x050C
+#define REG_BCNTCFG_8703B				0x0510
+#define REG_PIFS_8703B					0x0512
+#define REG_RDG_PIFS_8703B				0x0513
+#define REG_SIFS_CTX_8703B				0x0514
+#define REG_SIFS_TRX_8703B				0x0516
+#define REG_AGGR_BREAK_TIME_8703B		0x051A
+#define REG_SLOT_8703B					0x051B
+#define REG_TX_PTCL_CTRL_8703B			0x0520
+#define REG_TXPAUSE_8703B				0x0522
+#define REG_DIS_TXREQ_CLR_8703B		0x0523
+#define REG_RD_CTRL_8703B				0x0524
+//
+// Format for offset 540h-542h:
+//	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
+//	[7:4]:   Reserved.
+//	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
+//	[23:20]: Reserved
+// Description:
+//	              |
+//     |<--Setup--|--Hold------------>|
+//	--------------|----------------------
+//                |
+//               TBTT
+// Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
+// Described by Designer Tim and Bruce, 2011-01-14.
+//
+#define REG_TBTT_PROHIBIT_8703B			0x0540
+#define REG_RD_NAV_NXT_8703B			0x0544
+#define REG_NAV_PROT_LEN_8703B			0x0546
+#define REG_BCN_CTRL_8703B				0x0550
+#define REG_BCN_CTRL_1_8703B			0x0551
+#define REG_MBID_NUM_8703B				0x0552
+#define REG_DUAL_TSF_RST_8703B			0x0553
+#define REG_BCN_INTERVAL_8703B			0x0554
+#define REG_DRVERLYINT_8703B			0x0558
+#define REG_BCNDMATIM_8703B			0x0559
+#define REG_ATIMWND_8703B				0x055A
+#define REG_USTIME_TSF_8703B			0x055C
+#define REG_BCN_MAX_ERR_8703B			0x055D
+#define REG_RXTSF_OFFSET_CCK_8703B		0x055E
+#define REG_RXTSF_OFFSET_OFDM_8703B	0x055F
+#define REG_TSFTR_8703B					0x0560
+#define REG_CTWND_8703B					0x0572
+#define REG_SECONDARY_CCA_CTRL_8703B	0x0577
+#define REG_PSTIMER_8703B				0x0580
+#define REG_TIMER0_8703B				0x0584
+#define REG_TIMER1_8703B				0x0588
+#define REG_ACMHWCTRL_8703B			0x05C0
+#define REG_SCH_TXCMD_8703B			0x05F8
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_MAC_CR_8703B				0x0600
+#define REG_TCR_8703B					0x0604
+#define REG_RCR_8703B					0x0608
+#define REG_RX_PKT_LIMIT_8703B			0x060C
+#define REG_RX_DLK_TIME_8703B			0x060D
+#define REG_RX_DRVINFO_SZ_8703B		0x060F
+
+#define REG_MACID_8703B					0x0610
+#define REG_BSSID_8703B					0x0618
+#define REG_MAR_8703B					0x0620
+#define REG_MBIDCAMCFG_8703B			0x0628
+#define REG_WOWLAN_GTK_DBG1	0x630
+#define REG_WOWLAN_GTK_DBG2	0x634
+
+#define REG_USTIME_EDCA_8703B			0x0638
+#define REG_MAC_SPEC_SIFS_8703B		0x063A
+#define REG_RESP_SIFP_CCK_8703B			0x063C
+#define REG_RESP_SIFS_OFDM_8703B		0x063E
+#define REG_ACKTO_8703B					0x0640
+#define REG_CTS2TO_8703B				0x0641
+#define REG_EIFS_8703B					0x0642
+
+#define REG_NAV_UPPER_8703B			0x0652	// unit of 128
+#define REG_TRXPTCL_CTL_8703B			0x0668
+
+// Security
+#define REG_CAMCMD_8703B				0x0670
+#define REG_CAMWRITE_8703B				0x0674
+#define REG_CAMREAD_8703B				0x0678
+#define REG_CAMDBG_8703B				0x067C
+#define REG_SECCFG_8703B				0x0680
+
+// Power
+#define REG_WOW_CTRL_8703B				0x0690
+#define REG_PS_RX_INFO_8703B			0x0692
+#define REG_UAPSD_TID_8703B				0x0693
+#define REG_WKFMCAM_CMD_8703B			0x0698
+#define REG_WKFMCAM_NUM_8703B			0x0698
+#define REG_WKFMCAM_RWD_8703B			0x069C
+#define REG_RXFLTMAP0_8703B				0x06A0
+#define REG_RXFLTMAP1_8703B				0x06A2
+#define REG_RXFLTMAP2_8703B				0x06A4
+#define REG_BCN_PSR_RPT_8703B			0x06A8
+#define REG_BT_COEX_TABLE_8703B		0x06C0
+#define REG_BFMER0_INFO_8703B			0x06E4
+#define REG_BFMER1_INFO_8703B			0x06EC
+#define REG_CSI_RPT_PARAM_BW20_8703B	0x06F4
+#define REG_CSI_RPT_PARAM_BW40_8703B	0x06F8
+#define REG_CSI_RPT_PARAM_BW80_8703B	0x06FC
+
+// Hardware Port 2
+#define REG_MACID1_8703B				0x0700
+#define REG_BSSID1_8703B				0x0708
+#define REG_BFMEE_SEL_8703B				0x0714
+#define REG_SND_PTCL_CTRL_8703B		0x0718
+
+// LTE_COEX
+#define REG_LTECOEX_CTRL			0x07C0
+#define REG_LTECOEX_WRITE_DATA		0x07C4
+#define REG_LTECOEX_READ_DATA		0x07C8
+#define REG_LTECOEX_PATH_CONTROL	0x70
+
+//============================================================
+// SDIO Bus Specification
+//============================================================
+
+//-----------------------------------------------------
+// SDIO CMD Address Mapping
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// I/O bus domain (Host)
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// SDIO register
+//-----------------------------------------------------
+#define SDIO_REG_HCPWM1_8703B	0x025 // HCI Current Power Mode 1
+
+
+//============================================================================
+//	8703 Regsiter Bit and Content definition
+//============================================================================
+
+#define BIT_USB_RXDMA_AGG_EN	BIT(31)
+#define RXDMA_AGG_MODE_EN		BIT(1)
+
+#ifdef CONFIG_WOWLAN
+#define RXPKT_RELEASE_POLL		BIT(16)
+#define RXDMA_IDLE				BIT(17)
+#define RW_RELEASE_EN			BIT(18)
+#endif
+
+//2 HSISR
+// interrupt mask which needs to clear
+#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
+								HSISR_SPS_OCP_INT |\
+								HSISR_RON_INT |\
+								HSISR_PDNINT |\
+								HSISR_GPIO9_INT)
+
+
+//----------------------------------------------------------------------------
+//       8703B REG_CCK_CHECK						(offset 0x454)
+//----------------------------------------------------------------------------
+#define BIT_BCN_PORT_SEL		BIT5
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+
+#ifdef CONFIG_RTL8703B
+#define EEPROM_RF_GAIN_OFFSET			0xC1
+#endif
+
+#define EEPROM_RF_GAIN_VAL				0x1F6
+#endif //CONFIG_RF_GAIN_OFFSET
+
+
+//----------------------------------------------------------------------------
+//       8195 IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8703B					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8703B					BIT31		// Timeout interrupt 2
+#define	IMR_TIMER1_8703B					BIT30		// Timeout interrupt 1
+#define	IMR_PSTIMEOUT_8703B				BIT29		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8703B					BIT28		// When GTIMER4 expires, this bit is set to 1
+#define	IMR_GTINT3_8703B					BIT27		// When GTIMER3 expires, this bit is set to 1
+#define	IMR_TXBCN0ERR_8703B				BIT26		// Transmit Beacon0 Error
+#define	IMR_TXBCN0OK_8703B				BIT25		// Transmit Beacon0 OK
+#define	IMR_TSF_BIT32_TOGGLE_8703B		BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define	IMR_BCNDMAINT0_8703B				BIT20		// Beacon DMA Interrupt 0
+#define	IMR_BCNDERR0_8703B				BIT16		// Beacon Queue DMA OK0
+#define	IMR_HSISR_IND_ON_INT_8703B		BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8703B			BIT14		// Beacon DMA Interrupt Extension for Win7
+#define	IMR_ATIMEND_8703B				BIT12		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8703B					BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define	IMR_CPWM2_8703B					BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_CPWM_8703B					BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_HIGHDOK_8703B				BIT7			// High Queue DMA OK
+#define	IMR_MGNTDOK_8703B				BIT6			// Management Queue DMA OK
+#define	IMR_BKDOK_8703B					BIT5			// AC_BK DMA OK
+#define	IMR_BEDOK_8703B					BIT4			// AC_BE DMA OK
+#define	IMR_VIDOK_8703B					BIT3			// AC_VI DMA OK
+#define	IMR_VODOK_8703B					BIT2			// AC_VO DMA OK
+#define	IMR_RDU_8703B					BIT1			// Rx Descriptor Unavailable
+#define	IMR_ROK_8703B					BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_BCNDMAINT7_8703B				BIT27		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8703B				BIT26		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8703B				BIT25		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8703B				BIT24		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8703B				BIT23		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8703B				BIT22		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8703B				BIT21		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8703B					BIT20		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8703B					BIT19		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8703B					BIT18		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8703B					BIT17		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8703B					BIT16		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8703B					BIT15		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8703B					BIT14		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8703B				BIT13		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8703B					BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8703B					BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8703B					BIT9			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8703B					BIT8			// Receive FIFO Overflow
+
+#ifdef CONFIG_PCI_HCI
+//#define IMR_RX_MASK		(IMR_ROK_8703B|IMR_RDU_8703B|IMR_RXFOVW_8703B)
+#define IMR_TX_MASK			(IMR_VODOK_8703B|IMR_VIDOK_8703B|IMR_BEDOK_8703B|IMR_BKDOK_8703B|IMR_MGNTDOK_8703B|IMR_HIGHDOK_8703B)
+
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8703B | IMR_TXBCN0OK_8703B | IMR_TXBCN0ERR_8703B | IMR_BCNDERR0_8703B)
+
+#define RT_AC_INT_MASKS	(IMR_VIDOK_8703B | IMR_VODOK_8703B | IMR_BEDOK_8703B|IMR_BKDOK_8703B)
+#endif
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8703B 128
+#define SEC_CAM_ENT_NUM_8703B 16
+#define NSS_NUM_8703B 1
+#define BAND_CAP_8703B (BAND_CAP_2G)
+#define BW_CAP_8703B (BW_CAP_20M | BW_CAP_40M)
+#define PROTO_CAP_8703B (PROTO_CAP_11B|PROTO_CAP_11G|PROTO_CAP_11N)
+
+#endif /* __RTL8703B_SPEC_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_sreset.h
new file mode 100644
index 000000000..4eb70ddb9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8703B_SRESET_H_
+#define _RTL8703B_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8703b_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8703b_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_xmit.h
new file mode 100644
index 000000000..66c63a995
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8703b_xmit.h
@@ -0,0 +1,336 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8703B_XMIT_H__
+#define __RTL8703B_XMIT_H__
+
+
+#define MAX_TID (15)
+
+
+#ifndef __INC_HAL8703BDESC_H
+#define __INC_HAL8703BDESC_H
+
+#define RX_STATUS_DESC_SIZE_8703B		24
+#define RX_DRV_INFO_SIZE_UNIT_8703B 8
+
+
+//DWORD 0
+#define SET_RX_STATUS_DESC_PKT_LEN_8703B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_8703B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_8703B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
+
+#define GET_RX_STATUS_DESC_PKT_LEN_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32_8703B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICV_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8703B(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT_8703B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC_8703B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
+#define GET_RX_STATUS_DESC_LAST_SEG_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 28, 1)
+#define GET_RX_STATUS_DESC_FIRST_SEG_8703B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 29, 1)
+#define GET_RX_STATUS_DESC_EOR_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID_8703B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_TID_8703B(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_AMSDU_8703B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH_8703B(__pRxDesc)		LE_BITS_TO_4BYTE( __pRxDesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR_8703B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_A1_FIT_8703B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 16, 4)
+#define GET_RX_STATUS_DESC_CHKERR_8703B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_IPVER_8703B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_IS_TCPUDP__8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_CHK_VLD_8703B(__pRxDesc) 	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM_8703B(__pRxDesc) 			LE_BITS_TO_4BYTE( __pRxDesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR_8703B(__pRxDesc) 			LE_BITS_TO_4BYTE( __pRxDesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_MC_8703B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC_8703B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ_8703B(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 12, 4)
+#define GET_RX_STATUS_DESC_RX_IS_QOS_8703B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 1)
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8703B(__pRxStatusDesc) 	LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_RPT_SEL_8703B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 28, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_HTC_8703B(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP_8703B(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT_8703B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 12, 2)
+#ifdef CONFIG_USB_RX_AGGREGATION
+#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8703B(__pRxStatusDesc)	LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 16, 8)
+#endif
+#define GET_RX_STATUS_DESC_PATTERN_MATCH_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_MATCH_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_MATCH_8703B(__pRxDesc) 		LE_BITS_TO_4BYTE( __pRxDesc+12, 31, 1)
+
+//DWORD 6
+#define GET_RX_STATUS_DESC_SPLCP_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 0, 1)
+#define GET_RX_STATUS_DESC_LDPC_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 1, 1)
+#define GET_RX_STATUS_DESC_STBC_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 2, 1)
+#define GET_RX_STATUS_DESC_BW_8703B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 4, 2)
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL_8703B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+20, 0, 32)
+
+#define GET_RX_STATUS_DESC_BUFF_ADDR_8703B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR64_8703B(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)
+
+#define SET_RX_STATUS_DESC_BUFF_ADDR_8703B(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)
+
+
+// Dword 0
+#define GET_TX_DESC_OWN_8703B(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
+
+#define SET_TX_DESC_PKT_SIZE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
+#define SET_TX_DESC_OFFSET_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
+#define SET_TX_DESC_BMC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
+#define SET_TX_DESC_LINIP_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
+#define SET_TX_DESC_NO_ACM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
+#define SET_TX_DESC_GF_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+
+// Dword 1
+#define SET_TX_DESC_MACID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
+
+
+// Dword 2
+#define SET_TX_DESC_PAID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
+#define SET_TX_DESC_AGG_BREAK_8703B(__pTxDesc, __Value) 				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
+#define SET_TX_DESC_RAW_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
+#define SET_TX_DESC_SPE_RPT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_INT_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
+
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
+#define SET_TX_DESC_CHK_EN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
+#define SET_TX_DESC_EARLY_MODE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HWSEQ_SEL_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
+
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT_8703B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
+#define SET_TX_DESC_CTROL_STBC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
+
+
+// Dword 6
+#define SET_TX_DESC_SW_DEFINE_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_MBSSID_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
+#define SET_TX_DESC_ANTSEL_A_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
+#define SET_TX_DESC_ANTSEL_B_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
+#define SET_TX_DESC_ANTSEL_C_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
+#define SET_TX_DESC_ANTSEL_D_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)
+
+// Dword 7
+#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)
+#define SET_TX_DESC_TX_BUFFER_SIZE_8703B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#else
+#define SET_TX_DESC_TX_DESC_CHECKSUM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#endif
+#define SET_TX_DESC_USB_TXAGG_NUM_8703B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
+#if(DEV_BUS_TYPE == RT_SDIO_INTERFACE)
+#define SET_TX_DESC_SDIO_TXSEQ_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
+#endif
+
+// Dword 8
+#define SET_TX_DESC_HWSEQ_EN_8703B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+
+// Dword 9
+#define SET_TX_DESC_SEQ_8703B(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
+
+// Dword 10
+#define SET_TX_DESC_TX_BUFFER_ADDRESS_8703B(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
+#define GET_TX_DESC_TX_BUFFER_ADDRESS_8703B(__pTxDesc) 	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)
+
+// Dword 11
+#define SET_TX_DESC_NEXT_DESC_ADDRESS_8703B(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)
+
+
+#define SET_EARLYMODE_PKTNUM_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
+#define SET_EARLYMODE_LEN3_8703B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+#endif
+//-----------------------------------------------------------
+//
+//	Rate
+//
+//-----------------------------------------------------------
+// CCK Rates, TxHT = 0
+#define DESC8703B_RATE1M				0x00
+#define DESC8703B_RATE2M				0x01
+#define DESC8703B_RATE5_5M				0x02
+#define DESC8703B_RATE11M				0x03
+
+// OFDM Rates, TxHT = 0
+#define DESC8703B_RATE6M				0x04
+#define DESC8703B_RATE9M				0x05
+#define DESC8703B_RATE12M				0x06
+#define DESC8703B_RATE18M				0x07
+#define DESC8703B_RATE24M				0x08
+#define DESC8703B_RATE36M				0x09
+#define DESC8703B_RATE48M				0x0a
+#define DESC8703B_RATE54M				0x0b
+
+// MCS Rates, TxHT = 1
+#define DESC8703B_RATEMCS0				0x0c
+#define DESC8703B_RATEMCS1				0x0d
+#define DESC8703B_RATEMCS2				0x0e
+#define DESC8703B_RATEMCS3				0x0f
+#define DESC8703B_RATEMCS4				0x10
+#define DESC8703B_RATEMCS5				0x11
+#define DESC8703B_RATEMCS6				0x12
+#define DESC8703B_RATEMCS7				0x13
+#define DESC8703B_RATEMCS8				0x14
+#define DESC8703B_RATEMCS9				0x15
+#define DESC8703B_RATEMCS10 		0x16
+#define DESC8703B_RATEMCS11 		0x17
+#define DESC8703B_RATEMCS12 		0x18
+#define DESC8703B_RATEMCS13 		0x19
+#define DESC8703B_RATEMCS14 		0x1a
+#define DESC8703B_RATEMCS15 		0x1b
+#define DESC8703B_RATEVHTSS1MCS0		0x2c
+#define DESC8703B_RATEVHTSS1MCS1		0x2d
+#define DESC8703B_RATEVHTSS1MCS2		0x2e
+#define DESC8703B_RATEVHTSS1MCS3		0x2f
+#define DESC8703B_RATEVHTSS1MCS4		0x30
+#define DESC8703B_RATEVHTSS1MCS5		0x31
+#define DESC8703B_RATEVHTSS1MCS6		0x32
+#define DESC8703B_RATEVHTSS1MCS7		0x33
+#define DESC8703B_RATEVHTSS1MCS8		0x34
+#define DESC8703B_RATEVHTSS1MCS9		0x35
+#define DESC8703B_RATEVHTSS2MCS0		0x36
+#define DESC8703B_RATEVHTSS2MCS1		0x37
+#define DESC8703B_RATEVHTSS2MCS2		0x38
+#define DESC8703B_RATEVHTSS2MCS3		0x39
+#define DESC8703B_RATEVHTSS2MCS4		0x3a
+#define DESC8703B_RATEVHTSS2MCS5		0x3b
+#define DESC8703B_RATEVHTSS2MCS6		0x3c
+#define DESC8703B_RATEVHTSS2MCS7		0x3d
+#define DESC8703B_RATEVHTSS2MCS8		0x3e
+#define DESC8703B_RATEVHTSS2MCS9		0x3f
+
+
+#define 	RX_HAL_IS_CCK_RATE_8703B(pDesc)\
+			(GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE1M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE2M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE5_5M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8703B(pDesc) == DESC8703B_RATE11M)
+
+
+void rtl8703b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
+void rtl8703b_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+s32 rtl8703bs_init_xmit_priv(PADAPTER padapter);
+void rtl8703bs_free_xmit_priv(PADAPTER padapter);
+s32 rtl8703bs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8703bs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8703bs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8703bs_xmit_buf_handler(PADAPTER padapter);
+thread_return rtl8703bs_xmit_thread(thread_context context);
+#define hal_xmit_handler rtl8703bs_xmit_buf_handler
+#endif
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8703bu_xmit_buf_handler(PADAPTER padapter);
+#define hal_xmit_handler rtl8703bu_xmit_buf_handler
+
+
+s32 rtl8703bu_init_xmit_priv(PADAPTER padapter);
+void rtl8703bu_free_xmit_priv(PADAPTER padapter);
+s32 rtl8703bu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8703bu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	 rtl8703bu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+//s32 rtl8812au_xmit_buf_handler(PADAPTER padapter);
+void rtl8703bu_xmit_tasklet(void *priv);
+s32 rtl8703bu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,struct tx_desc *ptxdesc);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8703be_init_xmit_priv(PADAPTER padapter);
+void rtl8703be_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf *rtl8703be_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+void	rtl8703be_xmitframe_resume(_adapter *padapter);
+s32 rtl8703be_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8703be_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8703be_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtl8703be_xmit_tasklet(void *priv);
+#endif
+
+u8	BWMapping_8703B(PADAPTER Adapter, struct pkt_attrib *pattrib);
+u8	SCMapping_8703B(PADAPTER Adapter, struct pkt_attrib	*pattrib);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_cmd.h
new file mode 100644
index 000000000..8588a4fce
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_cmd.h
@@ -0,0 +1,217 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_CMD_H__
+#define __RTL8723B_CMD_H__
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD DEFINITION    ------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+enum h2c_cmd_8723B{
+	//Common Class: 000
+	H2C_8723B_RSVD_PAGE = 0x00,
+	H2C_8723B_MEDIA_STATUS_RPT = 0x01,
+	H2C_8723B_SCAN_ENABLE = 0x02,
+	H2C_8723B_KEEP_ALIVE = 0x03,
+	H2C_8723B_DISCON_DECISION = 0x04,
+	H2C_8723B_PSD_OFFLOAD = 0x05,
+	H2C_8723B_AP_OFFLOAD = 0x08,
+	H2C_8723B_BCN_RSVDPAGE = 0x09,
+	H2C_8723B_PROBERSP_RSVDPAGE = 0x0A,
+	H2C_8723B_FCS_RSVDPAGE = 0x10,
+	H2C_8723B_FCS_INFO = 0x11,
+	H2C_8723B_AP_WOW_GPIO_CTRL = 0x13,
+
+	//PoweSave Class: 001
+	H2C_8723B_SET_PWR_MODE = 0x20,
+	H2C_8723B_PS_TUNING_PARA = 0x21,
+	H2C_8723B_PS_TUNING_PARA2 = 0x22,
+	H2C_8723B_P2P_LPS_PARAM = 0x23,
+	H2C_8723B_P2P_PS_OFFLOAD = 0x24,
+	H2C_8723B_PS_SCAN_ENABLE = 0x25,
+	H2C_8723B_SAP_PS_ = 0x26,
+	H2C_8723B_INACTIVE_PS_ = 0x27, //Inactive_PS
+	H2C_8723B_FWLPS_IN_IPS_ = 0x28,
+
+	//Dynamic Mechanism Class: 010
+	H2C_8723B_MACID_CFG = 0x40,
+	H2C_8723B_TXBF = 0x41,
+	H2C_8723B_RSSI_SETTING = 0x42,
+	H2C_8723B_AP_REQ_TXRPT = 0x43,
+	H2C_8723B_INIT_RATE_COLLECT = 0x44,
+	H2C_8723B_RA_PARA_ADJUST = 0x46,
+
+	//BT Class: 011
+	H2C_8723B_B_TYPE_TDMA = 0x60,
+	H2C_8723B_BT_INFO = 0x61,
+	H2C_8723B_FORCE_BT_TXPWR = 0x62,
+	H2C_8723B_BT_IGNORE_WLANACT = 0x63,
+	H2C_8723B_DAC_SWING_VALUE = 0x64,
+	H2C_8723B_ANT_SEL_RSV = 0x65,
+	H2C_8723B_WL_OPMODE = 0x66,
+	H2C_8723B_BT_MP_OPER = 0x67,
+	H2C_8723B_BT_CONTROL = 0x68,
+	H2C_8723B_BT_WIFI_CTRL = 0x69,
+	H2C_8723B_BT_FW_PATCH = 0x6A,
+	H2C_8723B_BT_WLAN_CALIBRATION = 0x6D,
+
+	//WOWLAN Class: 100
+	H2C_8723B_WOWLAN = 0x80,
+	H2C_8723B_REMOTE_WAKE_CTRL = 0x81,
+	H2C_8723B_AOAC_GLOBAL_INFO = 0x82,
+	H2C_8723B_AOAC_RSVD_PAGE = 0x83,
+	H2C_8723B_AOAC_RSVD_PAGE2 = 0x84,
+	H2C_8723B_D0_SCAN_OFFLOAD_CTRL = 0x85,
+	H2C_8723B_D0_SCAN_OFFLOAD_INFO = 0x86,
+	H2C_8723B_CHNL_SWITCH_OFFLOAD = 0x87,
+	H2C_8723B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
+	H2C_8723B_P2P_OFFLOAD = 0x8B,
+
+	H2C_8723B_RESET_TSF = 0xC0,
+	H2C_8723B_MAXID,
+};
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    H2C CMD CONTENT    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+//_RSVDPAGE_LOC_CMD_0x00
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+
+//_KEEP_ALIVE_CMD_0x03
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
+
+//_DISCONNECT_DECISION_CMD_0x04
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+2, 0, 8, __Value)
+
+// _PWR_MOD_CMD_0x20
+#define SET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+5, 0, 8, __Value)
+
+#define GET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+// _PS_TUNE_PARAM_CMD_0x21
+#define SET_8723B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PSTUNE_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 1, __Value)
+#define SET_8723B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 1, 7, __Value)
+#define SET_8723B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+
+//_MACID_CFG_CMD_0x40
+#define SET_8723B_H2CCMD_MACID_CFG_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_RAID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 5, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_SGI_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 7, 1, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_BW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 2, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_NO_UPDATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 3, 1, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_VHT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 4, 2, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_DISPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 6, 1, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_DISRA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 7, 1, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
+#define SET_8723B_H2CCMD_MACID_CFG_RATE_MASK3(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+6, 0, 8, __Value)
+
+//_RSSI_SETTING_CMD_0x42
+#define SET_8723B_H2CCMD_RSSI_SETTING_MACID(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSSI_SETTING_RSSI(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 7, __Value)
+#define SET_8723B_H2CCMD_RSSI_SETTING_ULDL_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+
+// _AP_REQ_TXRPT_CMD_0x43
+#define SET_8723B_H2CCMD_APREQRPT_PARM_MACID1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_APREQRPT_PARM_MACID2(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+
+// _FORCE_BT_TXPWR_CMD_0x62
+#define SET_8723B_H2CCMD_BT_PWR_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+
+// _FORCE_BT_MP_OPER_CMD_0x67
+#define SET_8723B_H2CCMD_BT_MPOPER_VER(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#define SET_8723B_H2CCMD_BT_MPOPER_REQNUM(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
+#define SET_8723B_H2CCMD_BT_MPOPER_IDX(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_BT_MPOPER_PARAM1(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_BT_MPOPER_PARAM2(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_BT_MPOPER_PARAM3(__pH2CCmd, __Value)							SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+
+// _BT_FW_PATCH_0x6A
+#define SET_8723B_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((pu1Byte)(__pH2CCmd), 0, 16, __Value)
+#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8723B_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value) 					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+
+//---------------------------------------------------------------------------------------------------------//
+//-------------------------------------------    Structure    --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+
+//---------------------------------------------------------------------------------------------------------//
+//----------------------------------    Function Statement     --------------------------------------------------//
+//---------------------------------------------------------------------------------------------------------//
+
+// host message to firmware cmd
+void rtl8723b_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
+void rtl8723b_set_FwJoinBssRpt_cmd(PADAPTER padapter, u8 mstatus);
+void rtl8723b_set_rssi_cmd(PADAPTER padapter, u8 *param);
+void rtl8723b_Add_RateATid(PADAPTER pAdapter, u64 rate_bitmap, u8 *arg, u8 rssi_level);
+void rtl8723b_fw_try_ap_cmd(PADAPTER padapter, u32 need_ack);
+//s32 rtl8723b_set_lowpwr_lps_cmd(PADAPTER padapter, u8 enable);
+void rtl8723b_set_FwPsTuneParam_cmd(PADAPTER padapter);
+void rtl8723b_set_FwMacIdConfig_cmd(_adapter* padapter, u8 mac_id, u8 raid, u8 bw, u8 sgi, u32 mask);
+void rtl8723b_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
+void rtl8723b_download_rsvd_page(PADAPTER padapter, u8 mstatus);
+#ifdef CONFIG_BT_COEXIST
+void rtl8723b_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
+#ifdef CONFIG_P2P
+void rtl8723b_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void SetFwRelatedForWoWLAN8723b(_adapter* padapter, u8 bHostIsGoingtoSleep);
+#endif//CONFIG_WOWLAN
+
+#ifdef CONFIG_P2P_WOWLAN
+void rtl8723b_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
+#endif
+
+void rtl8723b_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+u8 rtl8723b_reset_tsf(_adapter *padapter, u8 reset_port);
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+s32 FillH2CCmd8723B(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8723B(_adapter *padapter, bool wowlan);
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_dm.h
new file mode 100644
index 000000000..2108c46dd
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_dm.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_DM_H__
+#define __RTL8723B_DM_H__
+//============================================================
+// Description:
+//
+// This file is for 8723B dynamic mechanism only
+//
+//
+//============================================================
+
+//============================================================
+// structure and define
+//============================================================
+
+//============================================================
+// function prototype
+//============================================================
+
+void rtl8723b_init_dm_priv(PADAPTER padapter);
+void rtl8723b_deinit_dm_priv(PADAPTER padapter);
+
+void rtl8723b_InitHalDm(PADAPTER padapter);
+void rtl8723b_HalDmWatchDog(PADAPTER padapter);
+void rtl8723b_HalDmWatchDog_in_LPS(PADAPTER padapter);
+void rtl8723b_hal_dm_in_lps(PADAPTER padapter);
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_hal.h
new file mode 100644
index 000000000..10efcff30
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_hal.h
@@ -0,0 +1,326 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_HAL_H__
+#define __RTL8723B_HAL_H__
+
+#include "hal_data.h"
+
+#include "rtl8723b_spec.h"
+#include "rtl8723b_rf.h"
+#include "rtl8723b_dm.h"
+#include "rtl8723b_recv.h"
+#include "rtl8723b_xmit.h"
+#include "rtl8723b_cmd.h"
+#include "rtl8723b_led.h"
+#include "Hal8723BPwrSeq.h"
+#include "Hal8723BPhyReg.h"
+#include "Hal8723BPhyCfg.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8723b_sreset.h"
+#endif
+
+
+//---------------------------------------------------------------------
+//		RTL8723B From file
+//---------------------------------------------------------------------
+	#define RTL8723B_FW_IMG					"rtl8723b/FW_NIC.bin"
+	#define RTL8723B_FW_WW_IMG				"rtl8723b/FW_WoWLAN.bin"
+	#define RTL8723B_PHY_REG					"rtl8723b/PHY_REG.txt"
+	#define RTL8723B_PHY_RADIO_A				"rtl8723b/RadioA.txt"
+	#define RTL8723B_PHY_RADIO_B				"rtl8723b/RadioB.txt"
+	#define RTL8723B_TXPWR_TRACK				"rtl8723b/TxPowerTrack.txt"
+	#define RTL8723B_AGC_TAB					"rtl8723b/AGC_TAB.txt"
+	#define RTL8723B_PHY_MACREG 				"rtl8723b/MAC_REG.txt"
+	#define RTL8723B_PHY_REG_PG				"rtl8723b/PHY_REG_PG.txt"
+	#define RTL8723B_PHY_REG_MP				"rtl8723b/PHY_REG_MP.txt"
+	#define RTL8723B_TXPWR_LMT 				"rtl8723b/TXPWR_LMT.txt"
+
+//---------------------------------------------------------------------
+//		RTL8723B From header
+//---------------------------------------------------------------------
+
+#if MP_DRIVER == 1
+	#define Rtl8723B_FwBTImgArray				Rtl8723BFwBTImgArray
+	#define Rtl8723B_FwBTImgArrayLength		Rtl8723BFwBTImgArrayLength
+
+	#define Rtl8723B_PHY_REG_Array_MP			Rtl8723B_PHYREG_Array_MP
+	#define Rtl8723B_PHY_REG_Array_MPLength	Rtl8723B_PHYREG_Array_MPLength
+#endif
+
+
+#define FW_8723B_SIZE			0x8000
+#define FW_8723B_START_ADDRESS	0x1000
+#define FW_8723B_END_ADDRESS		0x1FFF //0x5FFF
+
+#define IS_FW_HEADER_EXIST_8723B(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x5300)
+
+typedef struct _RT_FIRMWARE {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[FW_8723B_SIZE];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8723B, *PRT_FIRMWARE_8723B;
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+typedef struct _RT_8723B_FIRMWARE_HDR
+{
+	// 8-byte alinment required
+
+	//--- LONG WORD 0 ----
+	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+	u8		Category;	// AP/NIC and USB/PCI
+	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+	u16		Version;		// FW Version
+	u16		Subversion;	// FW Subversion, default 0x00
+
+	//--- LONG WORD 1 ----
+	u8		Month;	// Release time Month field
+	u8		Date;	// Release time Date field
+	u8		Hour;	// Release time Hour field
+	u8		Minute;	// Release time Minute field
+	u16		RamCodeSize;	// The size of RAM code
+	u16		Rsvd2;
+
+	//--- LONG WORD 2 ----
+	u32		SvnIdx;	// The SVN entry index
+	u32		Rsvd3;
+
+	//--- LONG WORD 3 ----
+	u32		Rsvd4;
+	u32		Rsvd5;
+}RT_8723B_FIRMWARE_HDR, *PRT_8723B_FIRMWARE_HDR;
+
+#define DRIVER_EARLY_INT_TIME_8723B		0x05
+#define BCN_DMA_ATIME_INT_TIME_8723B		0x02
+
+// for 8723B
+// TX 32K, RX 16K, Page size 128B for TX, 8B for RX
+#define PAGE_SIZE_TX_8723B			128
+#define PAGE_SIZE_RX_8723B			8
+
+#define TX_DMA_SIZE_8723B			0x8000	/* 32K(TX) */
+#define RX_DMA_SIZE_8723B			0x4000	/* 16K(RX) */
+
+#ifdef CONFIG_WOWLAN
+#define RESV_FMWF	WKFMCAM_SIZE*MAX_WKFM_NUM /* 16 entries, for each is 24 bytes*/
+#else
+#define RESV_FMWF	0
+#endif
+
+#ifdef CONFIG_FW_C2H_DEBUG
+#define RX_DMA_RESERVED_SIZE_8723B	0x100	// 256B, reserved for c2h debug message
+#else
+#define RX_DMA_RESERVED_SIZE_8723B	0x80	// 128B, reserved for tx report
+#endif
+#define RX_DMA_BOUNDARY_8723B		(RX_DMA_SIZE_8723B - RX_DMA_RESERVED_SIZE_8723B - 1)
+
+
+// Note: We will divide number of page equally for each queue other than public queue!
+
+//For General Reserved Page Number(Beacon Queue is reserved page)
+//Beacon:2, PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1
+#define BCNQ_PAGE_NUM_8723B		0x08
+#ifdef CONFIG_CONCURRENT_MODE
+#define BCNQ1_PAGE_NUM_8723B		0x08 // 0x04
+#else
+#define BCNQ1_PAGE_NUM_8723B		0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef BCNQ1_PAGE_NUM_8723B
+#define BCNQ1_PAGE_NUM_8723B		0x00 // 0x04
+#endif
+
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8723B	0x07
+#else
+#define WOWLAN_PAGE_NUM_8723B	0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef WOWLAN_PAGE_NUM_8723B
+#define WOWLAN_PAGE_NUM_8723B	0x15
+#endif
+
+#ifdef CONFIG_AP_WOWLAN
+#define AP_WOWLAN_PAGE_NUM_8723B	0x02
+#endif
+
+#define TX_TOTAL_PAGE_NUMBER_8723B	(0xFF - BCNQ_PAGE_NUM_8723B - BCNQ1_PAGE_NUM_8723B - WOWLAN_PAGE_NUM_8723B)
+#define TX_PAGE_BOUNDARY_8723B		(TX_TOTAL_PAGE_NUMBER_8723B + 1)
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8723B	TX_TOTAL_PAGE_NUMBER_8723B
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8723B		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8723B + 1)
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723B
+#define NORMAL_PAGE_NUM_HPQ_8723B		0x0C
+#define NORMAL_PAGE_NUM_LPQ_8723B		0x02
+#define NORMAL_PAGE_NUM_NPQ_8723B		0x02
+
+// Note: For Normal Chip Setting, modify later
+#define WMM_NORMAL_PAGE_NUM_HPQ_8723B		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8723B		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8723B		0x20
+
+
+#include "HalVerDef.h"
+#include "hal_com.h"
+
+#define EFUSE_OOB_PROTECT_BYTES 		15
+
+#define HAL_EFUSE_MEMORY
+
+#define HWSET_MAX_SIZE_8723B			512
+#define EFUSE_REAL_CONTENT_LEN_8723B		512
+#define EFUSE_MAP_LEN_8723B				512
+#define EFUSE_MAX_SECTION_8723B			64
+
+#define EFUSE_IC_ID_OFFSET			506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_8723B)
+
+#define EFUSE_ACCESS_ON			0x69	// For RTL8723 only.
+#define EFUSE_ACCESS_OFF			0x00	// For RTL8723 only.
+
+//========================================================
+//			EFUSE for BT definition
+//========================================================
+#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
+#define EFUSE_BT_REAL_CONTENT_LEN		1536	// 512*3
+#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
+#define EFUSE_BT_MAX_SECTION			128		// 1024/8
+
+#define EFUSE_PROTECT_BYTES_BANK		16
+
+typedef struct _C2H_EVT_HDR
+{
+	u8	CmdID;
+	u8	CmdLen;
+	u8	CmdSeq;
+} __attribute__((__packed__)) C2H_EVT_HDR, *PC2H_EVT_HDR;
+
+typedef enum tag_Package_Definition
+{
+    PACKAGE_DEFAULT,
+    PACKAGE_QFN68,
+    PACKAGE_TFBGA90,
+    PACKAGE_TFBGA80,
+    PACKAGE_TFBGA79
+}PACKAGE_TYPE_E;
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+// rtl8723a_hal_init.c
+s32 rtl8723b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
+void rtl8723b_FirmwareSelfReset(PADAPTER padapter);
+void rtl8723b_InitializeFirmwareVars(PADAPTER padapter);
+
+void rtl8723b_InitAntenna_Selection(PADAPTER padapter);
+void rtl8723b_DeinitAntenna_Selection(PADAPTER padapter);
+void rtl8723b_CheckAntenna_Selection(PADAPTER padapter);
+void rtl8723b_init_default_value(PADAPTER padapter);
+
+s32 rtl8723b_InitLLTTable(PADAPTER padapter);
+
+s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
+s32 CardDisableWithoutHWSM(PADAPTER padapter);
+
+// EFuse
+u8 GetEEPROMSize8723B(PADAPTER padapter);
+void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
+void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
+void Hal_EfuseParseTxPowerInfo_8723B(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseBTCoexistInfo_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseEEPROMVer_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseChnlPlan_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseCustomerID_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseAntennaDiversity_8723B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void Hal_EfuseParseXtal_8723B(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
+void Hal_EfuseParseThermalMeter_8723B(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
+VOID Hal_EfuseParsePackageType_8723B(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+VOID Hal_EfuseParseVoltage_8723B(PADAPTER pAdapter,u8* hwinfo,BOOLEAN 	AutoLoadFail);
+VOID Hal_EfuseParseBoardType_8723B(PADAPTER Adapter,	u8*	PROMContent,BOOLEAN AutoloadFail);
+
+#ifdef CONFIG_C2H_PACKET_EN
+void rtl8723b_c2h_packet_handler(PADAPTER padapter, u8 *pbuf, u16 length);
+#endif
+
+
+void rtl8723b_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8723b(_adapter *adapter);
+void SetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val);
+#ifdef CONFIG_C2H_PACKET_EN
+void SetHwRegWithBuf8723B(PADAPTER padapter, u8 variable, u8 *pbuf, int len);
+#endif // CONFIG_C2H_PACKET_EN
+u8 SetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+u8 GetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+
+// register
+void rtl8723b_InitBeaconParameters(PADAPTER padapter);
+void rtl8723b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
+void	_InitBurstPktLen_8723BS(PADAPTER Adapter);
+void _8051Reset8723(PADAPTER padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+void rtl8723b_start_thread(_adapter *padapter);
+void rtl8723b_stop_thread(_adapter *padapter);
+
+#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
+void rtl8723bs_init_checkbthang_workqueue(_adapter * adapter);
+void rtl8723bs_free_checkbthang_workqueue(_adapter * adapter);
+void rtl8723bs_cancle_checkbthang_workqueue(_adapter * adapter);
+void rtl8723bs_hal_check_bt_hang(_adapter * adapter);
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
+#endif
+
+int FirmwareDownloadBT(IN PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
+
+void CCX_FwC2HTxRpt_8723b(PADAPTER padapter, u8 *pdata, u8 len);
+s32 c2h_id_filter_ccx_8723b(u8 *buf);
+s32 c2h_handler_8723b(PADAPTER padapter, u8 *pC2hEvent);
+u8 MRateToHwRate8723B(u8  rate);
+u8 HwRateToMRate8723B(u8	 rate);
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+void Hal_ReadRFGainOffset(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
+#endif //CONFIG_RF_GAIN_OFFSET
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8723BE(PADAPTER Adapter);
+VOID	UpdateInterruptMask8723BE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_led.h
new file mode 100644
index 000000000..161fa4840
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_led.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_LED_H__
+#define __RTL8723B_LED_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8723bu_InitSwLeds(PADAPTER padapter);
+void rtl8723bu_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_SDIO_HCI
+void rtl8723bs_InitSwLeds(PADAPTER padapter);
+void rtl8723bs_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_GSPI_HCI
+void rtl8723bs_InitSwLeds(PADAPTER padapter);
+void rtl8723bs_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_PCI_HCI
+void rtl8723be_InitSwLeds(PADAPTER padapter);
+void rtl8723be_DeInitSwLeds(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_recv.h
new file mode 100644
index 000000000..a49385a9e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_recv.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_RECV_H__
+#define __RTL8723B_RECV_H__
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+#if defined(CONFIG_USB_HCI)
+
+#ifndef MAX_RECVBUF_SZ
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+	#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+		//#define MAX_RECVBUF_SZ (32768) // 32k
+		//#define MAX_RECVBUF_SZ (16384) //16K
+		//#define MAX_RECVBUF_SZ (10240) //10K
+		#ifdef CONFIG_PLATFORM_MSTAR
+			#define MAX_RECVBUF_SZ (8192) // 8K
+		#else
+		        #define MAX_RECVBUF_SZ (15360) // 15k < 16k
+		#endif
+		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+	#else
+		#define MAX_RECVBUF_SZ (4000) // about 4K
+	#endif
+#endif
+#endif //!MAX_RECVBUF_SZ
+
+#elif defined(CONFIG_PCI_HCI)
+//#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+//	#define MAX_RECVBUF_SZ (9100)
+//#else
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+//#endif
+
+
+#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+
+#define MAX_RECVBUF_SZ (10240)
+
+#endif
+
+// Rx smooth factor
+#define	Rx_Smooth_Factor (20)
+
+#ifdef CONFIG_SDIO_HCI
+#ifndef CONFIG_SDIO_RX_COPY
+#undef MAX_RECVBUF_SZ
+#define MAX_RECVBUF_SZ	(RX_DMA_SIZE_8723B - RX_DMA_RESERVED_SIZE_8723B)
+#endif // !CONFIG_SDIO_RX_COPY
+#endif // CONFIG_SDIO_HCI
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+s32 rtl8723bs_init_recv_priv(PADAPTER padapter);
+void rtl8723bs_free_recv_priv(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_USB_HCI
+int rtl8723bu_init_recv_priv(_adapter *padapter);
+void rtl8723bu_free_recv_priv (_adapter *padapter);
+void rtl8723bu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8723be_init_recv_priv(PADAPTER padapter);
+void rtl8723be_free_recv_priv(PADAPTER padapter);
+#endif
+
+void rtl8723b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+
+#endif /* __RTL8723B_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_rf.h
new file mode 100644
index 000000000..2bb734176
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_rf.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_RF_H__
+#define __RTL8723B_RF_H__
+
+int	PHY_RF6052_Config8723B(	IN	PADAPTER		Adapter	);
+
+VOID
+PHY_RF6052SetBandwidth8723B(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH		Bandwidth);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_spec.h
new file mode 100644
index 000000000..078b4ff89
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_spec.h
@@ -0,0 +1,295 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8723B_SPEC_H__
+#define __RTL8723B_SPEC_H__
+
+#include <drv_conf.h>
+
+
+#define HAL_NAV_UPPER_UNIT_8723B		128		// micro-second
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_RSV_CTRL_8723B				0x001C	// 3 Byte
+#define REG_BT_WIFI_ANTENNA_SWITCH_8723B	0x0038
+#define REG_HSISR_8723B					0x005c
+#define REG_PAD_CTRL1_8723B		0x0064
+#define REG_AFE_CTRL_4_8723B		0x0078
+#define REG_HMEBOX_DBG_0_8723B	0x0088
+#define REG_HMEBOX_DBG_1_8723B	0x008A
+#define REG_HMEBOX_DBG_2_8723B	0x008C
+#define REG_HMEBOX_DBG_3_8723B	0x008E
+#define REG_HIMR0_8723B					0x00B0
+#define REG_HISR0_8723B					0x00B4
+#define REG_HIMR1_8723B					0x00B8
+#define REG_HISR1_8723B					0x00BC
+#define REG_PMC_DBG_CTRL2_8723B			0x00CC
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_C2HEVT_CMD_ID_8723B	0x01A0
+#define REG_C2HEVT_CMD_LEN_8723B	0x01AE
+#define REG_WOWLAN_WAKE_REASON 0x01C7
+#define REG_WOWLAN_GTK_DBG1	0x630
+#define REG_WOWLAN_GTK_DBG2	0x634
+
+#define REG_HMEBOX_EXT0_8723B			0x01F0
+#define REG_HMEBOX_EXT1_8723B			0x01F4
+#define REG_HMEBOX_EXT2_8723B			0x01F8
+#define REG_HMEBOX_EXT3_8723B			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_CONTROL_8723B		0x0286 // Control the RX DMA.
+#define REG_RXDMA_MODE_CTRL_8723B		0x0290
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG_8723B		0x0300
+#define	REG_INT_MIG_8723B				0x0304	// Interrupt Migration
+#define	REG_BCNQ_DESA_8723B			0x0308	// TX Beacon Descriptor Address
+#define	REG_HQ_DESA_8723B				0x0310	// TX High Queue Descriptor Address
+#define	REG_MGQ_DESA_8723B			0x0318	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_DESA_8723B			0x0320	// TX VO Queue Descriptor Address
+#define	REG_VIQ_DESA_8723B				0x0328	// TX VI Queue Descriptor Address
+#define	REG_BEQ_DESA_8723B			0x0330	// TX BE Queue Descriptor Address
+#define	REG_BKQ_DESA_8723B			0x0338	// TX BK Queue Descriptor Address
+#define	REG_RX_DESA_8723B				0x0340	// RX Queue	Descriptor Address
+#define	REG_DBI_WDATA_8723B			0x0348	// DBI Write Data
+#define	REG_DBI_RDATA_8723B			0x034C	// DBI Read Data
+#define	REG_DBI_ADDR_8723B				0x0350	// DBI Address
+#define	REG_DBI_FLAG_8723B				0x0352	// DBI Read/Write Flag
+#define	REG_MDIO_WDATA_8723B		0x0354	// MDIO for Write PCIE PHY
+#define	REG_MDIO_RDATA_8723B			0x0356	// MDIO for Reads PCIE PHY
+#define	REG_MDIO_CTL_8723B			0x0358	// MDIO for Control
+#define	REG_DBG_SEL_8723B				0x0360	// Debug Selection Register
+#define	REG_PCIE_HRPWM_8723B			0x0361	//PCIe RPWM
+#define	REG_PCIE_HCPWM_8723B			0x0363	//PCIe CPWM
+#define	REG_PCIE_MULTIFET_CTRL_8723B	0x036A	//PCIE Multi-Fethc Control
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_TXPKTBUF_BCNQ_BDNY_8723B	0x0424
+#define REG_TXPKTBUF_MGQ_BDNY_8723B	0x0425
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8723B	0x045D
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
+#define REG_AMPDU_BURST_MODE_8723B	0x04BC
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_SECONDARY_CCA_CTRL_8723B	0x0577
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+
+
+//============================================================
+// SDIO Bus Specification
+//============================================================
+
+//-----------------------------------------------------
+// SDIO CMD Address Mapping
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// I/O bus domain (Host)
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// SDIO register
+//-----------------------------------------------------
+#define SDIO_REG_HCPWM1_8723B	0x025 // HCI Current Power Mode 1
+
+
+//============================================================================
+//	8723 Regsiter Bit and Content definition
+//============================================================================
+
+//2 HSISR
+// interrupt mask which needs to clear
+#define MASK_HSISR_CLEAR		(HSISR_GPIO12_0_INT |\
+								HSISR_SPS_OCP_INT |\
+								HSISR_RON_INT |\
+								HSISR_PDNINT |\
+								HSISR_GPIO9_INT)
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#undef IS_E_CUT
+#define IS_E_CUT(version)		FALSE
+#undef IS_F_CUT
+#define IS_F_CUT(version)		((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? TRUE : FALSE)
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define BIT_USB_RXDMA_AGG_EN	BIT(31)
+#define RXDMA_AGG_MODE_EN		BIT(1)
+
+#ifdef CONFIG_WOWLAN
+#define RXPKT_RELEASE_POLL		BIT(16)
+#define RXDMA_IDLE				BIT(17)
+#define RW_RELEASE_EN			BIT(18)
+#endif
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+
+//----------------------------------------------------------------------------
+//       8723B REG_CCK_CHECK						(offset 0x454)
+//----------------------------------------------------------------------------
+#define BIT_BCN_PORT_SEL		BIT5
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#ifdef CONFIG_RF_GAIN_OFFSET
+
+#ifdef CONFIG_RTL8723B
+#define EEPROM_RF_GAIN_OFFSET			0xC1
+#endif
+
+#define EEPROM_RF_GAIN_VAL				0x1F6
+#endif //CONFIG_RF_GAIN_OFFSET
+
+
+//----------------------------------------------------------------------------
+//       8195 IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8723B					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8723B					BIT31		// Timeout interrupt 2
+#define	IMR_TIMER1_8723B					BIT30		// Timeout interrupt 1
+#define	IMR_PSTIMEOUT_8723B				BIT29		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8723B					BIT28		// When GTIMER4 expires, this bit is set to 1
+#define	IMR_GTINT3_8723B					BIT27		// When GTIMER3 expires, this bit is set to 1
+#define	IMR_TXBCN0ERR_8723B				BIT26		// Transmit Beacon0 Error
+#define	IMR_TXBCN0OK_8723B				BIT25		// Transmit Beacon0 OK
+#define	IMR_TSF_BIT32_TOGGLE_8723B		BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define	IMR_BCNDMAINT0_8723B				BIT20		// Beacon DMA Interrupt 0
+#define	IMR_BCNDERR0_8723B				BIT16		// Beacon Queue DMA OK0
+#define	IMR_HSISR_IND_ON_INT_8723B		BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8723B			BIT14		// Beacon DMA Interrupt Extension for Win7
+#define	IMR_ATIMEND_8723B				BIT12		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8723B					BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define	IMR_CPWM2_8723B					BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_CPWM_8723B					BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_HIGHDOK_8723B				BIT7			// High Queue DMA OK
+#define	IMR_MGNTDOK_8723B				BIT6			// Management Queue DMA OK
+#define	IMR_BKDOK_8723B					BIT5			// AC_BK DMA OK
+#define	IMR_BEDOK_8723B					BIT4			// AC_BE DMA OK
+#define	IMR_VIDOK_8723B					BIT3			// AC_VI DMA OK
+#define	IMR_VODOK_8723B					BIT2			// AC_VO DMA OK
+#define	IMR_RDU_8723B					BIT1			// Rx Descriptor Unavailable
+#define	IMR_ROK_8723B					BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_BCNDMAINT7_8723B				BIT27		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8723B				BIT26		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8723B				BIT25		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8723B				BIT24		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8723B				BIT23		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8723B				BIT22		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8723B				BIT21		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8723B					BIT20		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8723B					BIT19		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8723B					BIT18		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8723B					BIT17		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8723B					BIT16		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8723B					BIT15		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8723B					BIT14		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8723B				BIT13		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8723B					BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8723B					BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8723B					BIT9			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8723B					BIT8			// Receive FIFO Overflow
+
+#ifdef CONFIG_PCI_HCI
+//#define IMR_RX_MASK		(IMR_ROK_8723B|IMR_RDU_8723B|IMR_RXFOVW_8723B)
+#define IMR_TX_MASK			(IMR_VODOK_8723B|IMR_VIDOK_8723B|IMR_BEDOK_8723B|IMR_BKDOK_8723B|IMR_MGNTDOK_8723B|IMR_HIGHDOK_8723B)
+
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8723B | IMR_TXBCN0OK_8723B | IMR_TXBCN0ERR_8723B | IMR_BCNDERR0_8723B)
+
+#define RT_AC_INT_MASKS	(IMR_VIDOK_8723B | IMR_VODOK_8723B | IMR_BEDOK_8723B|IMR_BKDOK_8723B)
+#endif
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8723B 128
+#define SEC_CAM_ENT_NUM_8723B 64
+#define NSS_NUM_8723B 1
+#define BAND_CAP_8723B (BAND_CAP_2G)
+#define BW_CAP_8723B (BW_CAP_20M | BW_CAP_40M)
+
+#endif /* __RTL8723B_SPEC_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_sreset.h
new file mode 100644
index 000000000..9ade2dc75
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8723B_SRESET_H_
+#define _RTL8723B_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8723b_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8723b_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_xmit.h
new file mode 100644
index 000000000..8fdf25602
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8723b_xmit.h
@@ -0,0 +1,336 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8723B_XMIT_H__
+#define __RTL8723B_XMIT_H__
+
+
+#define MAX_TID (15)
+
+
+#ifndef __INC_HAL8723BDESC_H
+#define __INC_HAL8723BDESC_H
+
+#define RX_STATUS_DESC_SIZE_8723B		24
+#define RX_DRV_INFO_SIZE_UNIT_8723B 8
+
+
+//DWORD 0
+#define SET_RX_STATUS_DESC_PKT_LEN_8723B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_8723B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_8723B(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
+
+#define GET_RX_STATUS_DESC_PKT_LEN_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32_8723B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICV_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8723B(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT_8723B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC_8723B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
+#define GET_RX_STATUS_DESC_LAST_SEG_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 28, 1)
+#define GET_RX_STATUS_DESC_FIRST_SEG_8723B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc, 29, 1)
+#define GET_RX_STATUS_DESC_EOR_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID_8723B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_TID_8723B(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_AMSDU_8723B(__pRxDesc)					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH_8723B(__pRxDesc)		LE_BITS_TO_4BYTE( __pRxDesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR_8723B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_A1_FIT_8723B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 16, 4)
+#define GET_RX_STATUS_DESC_CHKERR_8723B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_IPVER_8723B(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_IS_TCPUDP__8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_CHK_VLD_8723B(__pRxDesc) 	LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM_8723B(__pRxDesc) 			LE_BITS_TO_4BYTE( __pRxDesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR_8723B(__pRxDesc) 			LE_BITS_TO_4BYTE( __pRxDesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_MC_8723B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC_8723B(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ_8723B(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 12, 4)
+#define GET_RX_STATUS_DESC_RX_IS_QOS_8723B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 1)
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8723B(__pRxStatusDesc) 	LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_RPT_SEL_8723B(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 28, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_HTC_8723B(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP_8723B(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT_8723B(__pRxStatusDesc) 		LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 12, 2)
+#ifdef CONFIG_USB_RX_AGGREGATION
+#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8723B(__pRxStatusDesc)	LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 16, 8)
+#endif
+#define GET_RX_STATUS_DESC_PATTERN_MATCH_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_MATCH_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_MATCH_8723B(__pRxDesc) 		LE_BITS_TO_4BYTE( __pRxDesc+12, 31, 1)
+
+//DWORD 6
+#define GET_RX_STATUS_DESC_SPLCP_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 0, 1)
+#define GET_RX_STATUS_DESC_LDPC_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 1, 1)
+#define GET_RX_STATUS_DESC_STBC_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 2, 1)
+#define GET_RX_STATUS_DESC_BW_8723B(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 4, 2)
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL_8723B(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+20, 0, 32)
+
+#define GET_RX_STATUS_DESC_BUFF_ADDR_8723B(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR64_8723B(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)
+
+#define SET_RX_STATUS_DESC_BUFF_ADDR_8723B(__pRxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)
+
+
+// Dword 0
+#define GET_TX_DESC_OWN_8723B(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
+
+#define SET_TX_DESC_PKT_SIZE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
+#define SET_TX_DESC_OFFSET_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
+#define SET_TX_DESC_BMC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
+#define SET_TX_DESC_LINIP_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
+#define SET_TX_DESC_NO_ACM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
+#define SET_TX_DESC_GF_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+
+// Dword 1
+#define SET_TX_DESC_MACID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
+
+
+// Dword 2
+#define SET_TX_DESC_PAID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
+#define SET_TX_DESC_AGG_BREAK_8723B(__pTxDesc, __Value) 				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
+#define SET_TX_DESC_RAW_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
+#define SET_TX_DESC_SPE_RPT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_INT_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
+
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
+#define SET_TX_DESC_CHK_EN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
+#define SET_TX_DESC_EARLY_MODE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HWSEQ_SEL_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
+
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT_8723B(__pTxDesc, __Value)	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
+#define SET_TX_DESC_CTROL_STBC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
+
+
+// Dword 6
+#define SET_TX_DESC_SW_DEFINE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_MBSSID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
+#define SET_TX_DESC_ANTSEL_A_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
+#define SET_TX_DESC_ANTSEL_B_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
+#define SET_TX_DESC_ANTSEL_C_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
+#define SET_TX_DESC_ANTSEL_D_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)
+
+// Dword 7
+#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)
+#define SET_TX_DESC_TX_BUFFER_SIZE_8723B(__pTxDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#else
+#define SET_TX_DESC_TX_DESC_CHECKSUM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#endif
+#define SET_TX_DESC_USB_TXAGG_NUM_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
+#if(DEV_BUS_TYPE == RT_SDIO_INTERFACE)
+#define SET_TX_DESC_SDIO_TXSEQ_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
+#endif
+
+// Dword 8
+#define SET_TX_DESC_HWSEQ_EN_8723B(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+
+// Dword 9
+#define SET_TX_DESC_SEQ_8723B(__pTxDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
+
+// Dword 10
+#define SET_TX_DESC_TX_BUFFER_ADDRESS_8723B(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
+#define GET_TX_DESC_TX_BUFFER_ADDRESS_8723B(__pTxDesc) 	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)
+
+// Dword 11
+#define SET_TX_DESC_NEXT_DESC_ADDRESS_8723B(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)
+
+
+#define SET_EARLYMODE_PKTNUM_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,	__Value)
+#define SET_EARLYMODE_LEN3_8723B(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+#endif
+//-----------------------------------------------------------
+//
+//	Rate
+//
+//-----------------------------------------------------------
+// CCK Rates, TxHT = 0
+#define DESC8723B_RATE1M				0x00
+#define DESC8723B_RATE2M				0x01
+#define DESC8723B_RATE5_5M				0x02
+#define DESC8723B_RATE11M				0x03
+
+// OFDM Rates, TxHT = 0
+#define DESC8723B_RATE6M				0x04
+#define DESC8723B_RATE9M				0x05
+#define DESC8723B_RATE12M				0x06
+#define DESC8723B_RATE18M				0x07
+#define DESC8723B_RATE24M				0x08
+#define DESC8723B_RATE36M				0x09
+#define DESC8723B_RATE48M				0x0a
+#define DESC8723B_RATE54M				0x0b
+
+// MCS Rates, TxHT = 1
+#define DESC8723B_RATEMCS0				0x0c
+#define DESC8723B_RATEMCS1				0x0d
+#define DESC8723B_RATEMCS2				0x0e
+#define DESC8723B_RATEMCS3				0x0f
+#define DESC8723B_RATEMCS4				0x10
+#define DESC8723B_RATEMCS5				0x11
+#define DESC8723B_RATEMCS6				0x12
+#define DESC8723B_RATEMCS7				0x13
+#define DESC8723B_RATEMCS8				0x14
+#define DESC8723B_RATEMCS9				0x15
+#define DESC8723B_RATEMCS10 		0x16
+#define DESC8723B_RATEMCS11 		0x17
+#define DESC8723B_RATEMCS12 		0x18
+#define DESC8723B_RATEMCS13 		0x19
+#define DESC8723B_RATEMCS14 		0x1a
+#define DESC8723B_RATEMCS15 		0x1b
+#define DESC8723B_RATEVHTSS1MCS0		0x2c
+#define DESC8723B_RATEVHTSS1MCS1		0x2d
+#define DESC8723B_RATEVHTSS1MCS2		0x2e
+#define DESC8723B_RATEVHTSS1MCS3		0x2f
+#define DESC8723B_RATEVHTSS1MCS4		0x30
+#define DESC8723B_RATEVHTSS1MCS5		0x31
+#define DESC8723B_RATEVHTSS1MCS6		0x32
+#define DESC8723B_RATEVHTSS1MCS7		0x33
+#define DESC8723B_RATEVHTSS1MCS8		0x34
+#define DESC8723B_RATEVHTSS1MCS9		0x35
+#define DESC8723B_RATEVHTSS2MCS0		0x36
+#define DESC8723B_RATEVHTSS2MCS1		0x37
+#define DESC8723B_RATEVHTSS2MCS2		0x38
+#define DESC8723B_RATEVHTSS2MCS3		0x39
+#define DESC8723B_RATEVHTSS2MCS4		0x3a
+#define DESC8723B_RATEVHTSS2MCS5		0x3b
+#define DESC8723B_RATEVHTSS2MCS6		0x3c
+#define DESC8723B_RATEVHTSS2MCS7		0x3d
+#define DESC8723B_RATEVHTSS2MCS8		0x3e
+#define DESC8723B_RATEVHTSS2MCS9		0x3f
+
+
+#define 	RX_HAL_IS_CCK_RATE_8723B(pDesc)\
+			(GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE1M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE2M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE5_5M ||\
+			GET_RX_STATUS_DESC_RX_RATE_8723B(pDesc) == DESC8723B_RATE11M)
+
+
+void rtl8723b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem);
+void rtl8723b_fill_fake_txdesc(PADAPTER padapter, u8 *pDesc, u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+s32 rtl8723bs_init_xmit_priv(PADAPTER padapter);
+void rtl8723bs_free_xmit_priv(PADAPTER padapter);
+s32 rtl8723bs_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8723bs_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8723bs_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8723bs_xmit_buf_handler(PADAPTER padapter);
+thread_return rtl8723bs_xmit_thread(thread_context context);
+#define hal_xmit_handler rtl8723bs_xmit_buf_handler
+#endif
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8723bu_xmit_buf_handler(PADAPTER padapter);
+#define hal_xmit_handler rtl8723bu_xmit_buf_handler
+
+
+s32 rtl8723bu_init_xmit_priv(PADAPTER padapter);
+void rtl8723bu_free_xmit_priv(PADAPTER padapter);
+s32 rtl8723bu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8723bu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	 rtl8723bu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+//s32 rtl8812au_xmit_buf_handler(PADAPTER padapter);
+void rtl8723bu_xmit_tasklet(void *priv);
+s32 rtl8723bu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,struct tx_desc *ptxdesc);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8723be_init_xmit_priv(PADAPTER padapter);
+void rtl8723be_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf *rtl8723be_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+void	rtl8723be_xmitframe_resume(_adapter *padapter);
+s32 rtl8723be_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8723be_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8723be_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtl8723be_xmit_tasklet(void *priv);
+#endif
+
+u8	BWMapping_8723B(PADAPTER Adapter, struct pkt_attrib *pattrib);
+u8	SCMapping_8723B(PADAPTER Adapter, struct pkt_attrib	*pattrib);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_cmd.h
new file mode 100644
index 000000000..20aa404d2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_cmd.h
@@ -0,0 +1,177 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_CMD_H__
+#define __RTL8812A_CMD_H__
+
+typedef enum _RTL8812_H2C_CMD
+{
+	H2C_8812_RSVDPAGE = 0,
+	H2C_8812_MSRRPT = 1,
+	H2C_8812_SCAN = 2,
+	H2C_8812_KEEP_ALIVE_CTRL = 3,
+	H2C_8812_DISCONNECT_DECISION = 4,
+
+	H2C_8812_INIT_OFFLOAD = 6,
+	H2C_8812_AP_OFFLOAD = 8,
+	H2C_8812_BCN_RSVDPAGE = 9,
+	H2C_8812_PROBERSP_RSVDPAGE = 10,
+
+	H2C_8812_SETPWRMODE = 0x20,
+	H2C_8812_PS_TUNING_PARA = 0x21,
+	H2C_8812_PS_TUNING_PARA2 = 0x22,
+	H2C_8812_PS_LPS_PARA = 0x23,
+	H2C_8812_P2P_PS_OFFLOAD = 0x24,
+	H2C_8812_RA_MASK = 0x40,
+	H2C_8812_TxBF = 0x41,
+	H2C_8812_RSSI_REPORT = 0x42,
+	H2C_8812_IQ_CALIBRATION = 0x45,
+	H2C_8812_RA_PARA_ADJUST = 0x46,
+
+	H2C_8812_BT_FW_PATCH = 0x6a,
+
+	H2C_8812_WO_WLAN = 0x80,
+	H2C_8812_REMOTE_WAKE_CTRL = 0x81,
+	H2C_8812_AOAC_GLOBAL_INFO = 0x82,
+	H2C_8812_AOAC_RSVDPAGE = 0x83,
+	H2C_8812_FW_SWCHANNL = 0x87,
+
+	H2C_8812_TSF_RESET = 0xC0,
+
+	MAX_8812_H2CCMD
+}RTL8812_H2C_CMD;
+
+struct cmd_msg_parm {
+	u8 eid; //element id
+	u8 sz; // sz
+	u8 buf[6];
+};
+
+enum{
+	PWRS
+};
+
+struct H2C_SS_RFOFF_PARAM{
+	u8 ROFOn; // 1: on, 0:off
+	u16 gpio_period; // unit: 1024 us
+}__attribute__ ((packed));
+
+
+
+//_RSVDPAGE_LOC_CMD0
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+
+//_SETPWRMODE_PARM
+#define SET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+5, 0, 8, __Value)
+
+#define GET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)							LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+//_P2P_PS_OFFLOAD
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+
+
+void	Set_RA_LDPC_8812(struct sta_info	*psta, BOOLEAN bLDPC);
+
+// host message to firmware cmd
+s32 FillH2CCmd_8812(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+void rtl8812_set_FwPwrMode_cmd(PADAPTER padapter, u8 PSMode);
+void rtl8812_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
+u8 rtl8812_set_rssi_cmd(PADAPTER padapter, u8 *param);
+void rtl8812_set_raid_cmd(PADAPTER padapter, u32 bitmap, u8* arg);
+void rtl8812_Add_RateATid(PADAPTER padapter, u64 rate_bitmap, u8 *arg, u8 rssi_level);
+void rtl8812_set_wowlan_cmd(_adapter* padapter, u8 enable);
+s32 FillH2CCmd_8812(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8812(_adapter *padapter, bool wowlan);
+
+#ifdef CONFIG_BT_COEXIST
+void rtl8812a_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
+#ifdef CONFIG_P2P_PS
+void rtl8812_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+int reset_tsf(PADAPTER Adapter, u8 reset_port );
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+
+#ifdef CONFIG_WOWLAN
+void SetFwRelatedForWoWLAN8812(_adapter* padapter, u8 bHostIsGoingtoSleep);
+#endif//CONFIG_WOWLAN
+
+//------------------------------------
+//     C2H format
+//------------------------------------
+
+// TX Beamforming
+#define GET_8812_C2H_TXBF_ORIGINATE(_Header)			LE_BITS_TO_1BYTE(_Header, 0, 8)
+#define GET_8812_C2H_TXBF_MACID(_Header)				LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
+
+
+
+/// TX Feedback Content
+#define 	USEC_UNIT_FOR_8812_C2H_TX_RPT_QUEUE_TIME			256
+
+#define	GET_8812_C2H_TX_RPT_QUEUE_SELECT(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 5)
+#define	GET_8812_C2H_TX_RPT_PKT_BROCAST(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 5, 1)
+#define	GET_8812_C2H_TX_RPT_LIFE_TIME_OVER(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 6, 1)
+#define	GET_8812_C2H_TX_RPT_RETRY_OVER(_Header)				LE_BITS_TO_1BYTE((_Header + 0), 7, 1)
+#define	GET_8812_C2H_TX_RPT_MAC_ID(_Header)					LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
+#define	GET_8812_C2H_TX_RPT_DATA_RETRY_CNT(_Header)		LE_BITS_TO_1BYTE((_Header + 2), 0, 6)
+#define	GET_8812_C2H_TX_RPT_QUEUE_TIME(_Header)				LE_BITS_TO_2BYTE((_Header + 3), 0, 16)	// In unit of 256 microseconds.
+#define	GET_8812_C2H_TX_RPT_FINAL_DATA_RATE(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)
+
+// BT_FW_PATCH
+#define SET_8812_H2CCMD_BT_FW_PATCH_SIZE(__pH2CCmd, __Value)					SET_BITS_TO_LE_2BYTE((pu1Byte)(__pH2CCmd), 0, 16, __Value)
+#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR0(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((pu1Byte)(__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR1(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((pu1Byte)(__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR2(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((pu1Byte)(__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8812_H2CCMD_BT_FW_PATCH_ADDR3(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((pu1Byte)(__pH2CCmd)+5, 0, 8, __Value)
+
+int	rtl8812_iqk_wait(_adapter* padapter, u32 timeout_ms);
+void	rtl8812_iqk_done(_adapter* padapter);
+
+s32
+_C2HContentParsing8812(
+	IN	PADAPTER	Adapter,
+	IN	u8			c2hCmdId,
+	IN	u8			c2hCmdLen,
+	IN	u8 			*tmpBuf
+);
+void	C2HPacketHandler_8812(PADAPTER Adapter, u8 *Buffer, u8 Length);
+
+#endif//__RTL8812A_CMD_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_dm.h
new file mode 100644
index 000000000..3196973d8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_dm.h
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_DM_H__
+#define __RTL8812A_DM_H__
+
+void rtl8812_init_dm_priv(IN PADAPTER Adapter);
+void rtl8812_deinit_dm_priv(IN PADAPTER Adapter);
+void rtl8812_InitHalDm(IN PADAPTER Adapter);
+void rtl8812_HalDmWatchDog(IN PADAPTER Adapter);
+
+//VOID rtl8192c_dm_CheckTXPowerTracking(IN PADAPTER Adapter);
+
+//void rtl8192c_dm_RF_Saving(IN PADAPTER pAdapter, IN u8 bForceInNormal);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void	AntDivCompare8812(PADAPTER Adapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+u8 AntDivBeforeLink8812(PADAPTER Adapter );
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_hal.h
new file mode 100644
index 000000000..c4413e1e9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_hal.h
@@ -0,0 +1,373 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_HAL_H__
+#define __RTL8812A_HAL_H__
+
+//#include "hal_com.h"
+#include "hal_data.h"
+
+//include HAL Related header after HAL Related compiling flags
+#include "rtl8812a_spec.h"
+#include "rtl8812a_rf.h"
+#include "rtl8812a_dm.h"
+#include "rtl8812a_recv.h"
+#include "rtl8812a_xmit.h"
+#include "rtl8812a_cmd.h"
+#include "rtl8812a_led.h"
+#include "Hal8812PwrSeq.h"
+#include "Hal8821APwrSeq.h" //for 8821A/8811A
+#include "Hal8812PhyReg.h"
+#include "Hal8812PhyCfg.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8812a_sreset.h"
+#endif
+
+
+//---------------------------------------------------------------------
+//		RTL8812AU From header
+//---------------------------------------------------------------------
+		#define RTL8812_FW_IMG						"rtl8812a/FW_NIC.bin"
+		#define RTL8812_FW_WW_IMG				"rtl8812a/FW_WoWLAN.bin"
+		#define RTL8812_PHY_REG					"rtl8812a/PHY_REG.txt"
+		#define RTL8812_PHY_RADIO_A				"rtl8812a/RadioA.txt"
+		#define RTL8812_PHY_RADIO_B				"rtl8812a/RadioB.txt"
+		#define RTL8812_TXPWR_TRACK				"rtl8812a/TxPowerTrack.txt"
+		#define RTL8812_AGC_TAB					"rtl8812a/AGC_TAB.txt"
+		#define RTL8812_PHY_MACREG 				"rtl8812a/MAC_REG.txt"
+		#define RTL8812_PHY_REG_PG					"rtl8812a/PHY_REG_PG.txt"
+		#define RTL8812_PHY_REG_MP 				"rtl8812a/PHY_REG_MP.txt"
+		#define RTL8812_TXPWR_LMT					"rtl8812a/TXPWR_LMT.txt"
+		#define RTL8812_WIFI_ANT_ISOLATION		"rtl8812a/wifi_ant_isolation.txt"
+
+//---------------------------------------------------------------------
+//		RTL8821U From file
+//---------------------------------------------------------------------
+		#define RTL8821_FW_IMG						"rtl8821a/FW_NIC.bin"
+		#define RTL8821_FW_WW_IMG				"rtl8821a/FW_WoWLAN.bin"
+		#define RTL8821_PHY_REG					"rtl8821a/PHY_REG.txt"
+		#define RTL8821_PHY_RADIO_A				"rtl8821a/RadioA.txt"
+		#define RTL8821_PHY_RADIO_B				"rtl8821a/RadioB.txt"
+		#define RTL8821_TXPWR_TRACK				"rtl8821a/TxPowerTrack.txt"
+		#define RTL8821_AGC_TAB					"rtl8821a/AGC_TAB.txt"
+		#define RTL8821_PHY_MACREG 				"rtl8821a/MAC_REG.txt"
+		#define RTL8821_PHY_REG_PG					"rtl8821a/PHY_REG_PG.txt"
+		#define RTL8821_PHY_REG_MP 				"rtl8821a/PHY_REG_MP.txt"
+		#define RTL8821_TXPWR_LMT					"rtl8821a/TXPWR_LMT.txt"
+
+//---------------------------------------------------------------------
+//		RTL8812 Power Configuration CMDs for PCIe interface
+//---------------------------------------------------------------------
+#define Rtl8812_NIC_PWR_ON_FLOW				rtl8812_power_on_flow
+#define Rtl8812_NIC_RF_OFF_FLOW				rtl8812_radio_off_flow
+#define Rtl8812_NIC_DISABLE_FLOW				rtl8812_card_disable_flow
+#define Rtl8812_NIC_ENABLE_FLOW				rtl8812_card_enable_flow
+#define Rtl8812_NIC_SUSPEND_FLOW				rtl8812_suspend_flow
+#define Rtl8812_NIC_RESUME_FLOW				rtl8812_resume_flow
+#define Rtl8812_NIC_PDN_FLOW					rtl8812_hwpdn_flow
+#define Rtl8812_NIC_LPS_ENTER_FLOW			rtl8812_enter_lps_flow
+#define Rtl8812_NIC_LPS_LEAVE_FLOW				rtl8812_leave_lps_flow
+
+//---------------------------------------------------------------------
+//		RTL8821 Power Configuration CMDs for PCIe interface
+//---------------------------------------------------------------------
+#define Rtl8821A_NIC_PWR_ON_FLOW				rtl8821A_power_on_flow
+#define Rtl8821A_NIC_RF_OFF_FLOW				rtl8821A_radio_off_flow
+#define Rtl8821A_NIC_DISABLE_FLOW				rtl8821A_card_disable_flow
+#define Rtl8821A_NIC_ENABLE_FLOW				rtl8821A_card_enable_flow
+#define Rtl8821A_NIC_SUSPEND_FLOW				rtl8821A_suspend_flow
+#define Rtl8821A_NIC_RESUME_FLOW				rtl8821A_resume_flow
+#define Rtl8821A_NIC_PDN_FLOW					rtl8821A_hwpdn_flow
+#define Rtl8821A_NIC_LPS_ENTER_FLOW			rtl8821A_enter_lps_flow
+#define Rtl8821A_NIC_LPS_LEAVE_FLOW			rtl8821A_leave_lps_flow
+
+
+#if 1 // download firmware related data structure
+#define FW_SIZE_8812			0x8000 // Compatible with RTL8723 Maximal RAM code size 24K.   modified to 32k, TO compatible with 92d maximal fw size 32k
+#define FW_START_ADDRESS		0x1000
+#define FW_END_ADDRESS		0x5FFF
+
+
+
+typedef struct _RT_FIRMWARE_8812 {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[FW_SIZE_8812];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8812, *PRT_FIRMWARE_8812;
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+#define IS_FW_HEADER_EXIST_8812(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8812(_pFwHdr) &0xFFF0) ==  0x9500)
+
+#define IS_FW_HEADER_EXIST_8821(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8812(_pFwHdr) &0xFFF0) ==  0x2100)
+//=====================================================
+//					Firmware Header(8-byte alinment required)
+//=====================================================
+//--- LONG WORD 0 ----
+#define GET_FIRMWARE_HDR_SIGNATURE_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16) // 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+#define GET_FIRMWARE_HDR_CATEGORY_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) // AP/NIC and USB/PCI
+#define GET_FIRMWARE_HDR_FUNCTION_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 24, 8) // Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+#define GET_FIRMWARE_HDR_VERSION_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)// FW Version
+#define GET_FIRMWARE_HDR_SUB_VER_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) // FW Subversion, default 0x00
+#define GET_FIRMWARE_HDR_RSVD1_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8)
+
+//--- LONG WORD 1 ----
+#define GET_FIRMWARE_HDR_MONTH_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 8) // Release time Month field
+#define GET_FIRMWARE_HDR_DATE_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 8, 8) // Release time Date field
+#define GET_FIRMWARE_HDR_HOUR_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 16, 8)// Release time Hour field
+#define GET_FIRMWARE_HDR_MINUTE_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+8, 24, 8)// Release time Minute field
+#define GET_FIRMWARE_HDR_ROMCODE_SIZE_8812(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+12, 0, 16)// The size of RAM code
+#define GET_FIRMWARE_HDR_RSVD2_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 16, 16)
+
+//--- LONG WORD 2 ----
+#define GET_FIRMWARE_HDR_SVN_IDX_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+16, 0, 32)// The SVN entry index
+#define GET_FIRMWARE_HDR_RSVD3_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 0, 32)
+
+//--- LONG WORD 3 ----
+#define GET_FIRMWARE_HDR_RSVD4_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 0, 32)
+#define GET_FIRMWARE_HDR_RSVD5_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)
+
+#endif // download firmware related data structure
+
+
+#define DRIVER_EARLY_INT_TIME_8812		0x05
+#define BCN_DMA_ATIME_INT_TIME_8812		0x02
+
+//for 8812
+// TX 128K, RX 16K, Page size 512B for TX, 128B for RX
+#define MAX_RX_DMA_BUFFER_SIZE_8812	0x3E80 /* RX 16K */
+
+#ifdef CONFIG_WOWLAN
+#define RESV_FMWF	WKFMCAM_SIZE*MAX_WKFM_NUM /* 16 entries, for each is 24 bytes*/
+#else
+#define RESV_FMWF	0
+#endif
+
+#ifdef CONFIG_FW_C2H_DEBUG
+#define RX_DMA_RESERVED_SIZE_8812	0x100	// 256B, reserved for c2h debug message
+#else
+#define RX_DMA_RESERVED_SIZE_8812	0x0	// 0B
+#endif
+#define RX_DMA_BOUNDARY_8812		(MAX_RX_DMA_BUFFER_SIZE_8812 - RX_DMA_RESERVED_SIZE_8812 - 1)
+
+#define BCNQ_PAGE_NUM_8812		0x07
+
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:1,GTK EXT MEM:1, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8812	0x05
+#else
+#define WOWLAN_PAGE_NUM_8812	0x00
+#endif
+
+
+#ifdef	CONFIG_BEAMFORMER_FW_NDPA
+#define FW_NDPA_PAGE_NUM	0x02
+#else
+#define FW_NDPA_PAGE_NUM	0x00
+#endif
+
+#define TX_TOTAL_PAGE_NUMBER_8812	(0xFF - BCNQ_PAGE_NUM_8812 - WOWLAN_PAGE_NUM_8812-FW_NDPA_PAGE_NUM)
+#define TX_PAGE_BOUNDARY_8812			(TX_TOTAL_PAGE_NUMBER_8812 + 1)
+
+#define TX_PAGE_BOUNDARY_WOWLAN_8812		(0xFF - BCNQ_PAGE_NUM_8812 - WOWLAN_PAGE_NUM_8812 + 1)
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8812	TX_PAGE_BOUNDARY_8812
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8812		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8812 + 1)
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8812
+#define NORMAL_PAGE_NUM_LPQ_8812				0x10
+#define NORMAL_PAGE_NUM_HPQ_8812			0x10
+#define NORMAL_PAGE_NUM_NPQ_8812			0x00
+
+#define WMM_NORMAL_PAGE_NUM_HPQ_8812		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8812		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8812		0x20
+
+
+// for 8821A
+// TX 64K, RX 16K, Page size 256B for TX, 128B for RX
+#define PAGE_SIZE_TX_8821A					256
+#define PAGE_SIZE_RX_8821A					128
+
+#define MAX_RX_DMA_BUFFER_SIZE_8821			0x3E80 /* RX 16K */
+
+#ifdef CONFIG_FW_C2H_DEBUG
+#define RX_DMA_RESERVED_SIZE_8821	0x100	// 256B, reserved for c2h debug message
+#else
+#define RX_DMA_RESERVED_SIZE_8821	0x0	// 0B
+#endif
+#define RX_DMA_BOUNDARY_8821		(MAX_RX_DMA_BUFFER_SIZE_8821 - RX_DMA_RESERVED_SIZE_8821 - 1)
+
+#define BCNQ_PAGE_NUM_8821		0x08
+#ifdef CONFIG_CONCURRENT_MODE
+#define BCNQ1_PAGE_NUM_8821		0x04
+#else
+#define BCNQ1_PAGE_NUM_8821		0x00
+#endif
+
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:1,GTK EXT MEM:1, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8821	0x06
+#else
+#define WOWLAN_PAGE_NUM_8821	0x00
+#endif
+
+#define TX_TOTAL_PAGE_NUMBER_8821	(0xFF - BCNQ_PAGE_NUM_8821 - BCNQ1_PAGE_NUM_8821 - WOWLAN_PAGE_NUM_8821)
+#define TX_PAGE_BOUNDARY_8821				(TX_TOTAL_PAGE_NUMBER_8821 + 1)
+//#define TX_PAGE_BOUNDARY_WOWLAN_8821		0xE0
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8821	TX_TOTAL_PAGE_NUMBER_8821
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8821		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8821 + 1)
+
+
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER
+#define NORMAL_PAGE_NUM_LPQ_8821			0x08//0x10
+#define NORMAL_PAGE_NUM_HPQ_8821		0x08//0x10
+#define NORMAL_PAGE_NUM_NPQ_8821		0x00
+
+#define WMM_NORMAL_PAGE_NUM_HPQ_8821		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8821		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8821		0x20
+
+
+#define	EFUSE_HIDDEN_812AU					0
+#define	EFUSE_HIDDEN_812AU_VS				1
+#define	EFUSE_HIDDEN_812AU_VL				2
+#define	EFUSE_HIDDEN_812AU_VN				3
+
+#if 0
+#define EFUSE_REAL_CONTENT_LEN_JAGUAR		1024
+#define HWSET_MAX_SIZE_JAGUAR					1024
+#else
+#define EFUSE_REAL_CONTENT_LEN_JAGUAR		512
+#define HWSET_MAX_SIZE_JAGUAR					512
+#endif
+
+#define EFUSE_MAX_BANK_8812A					2
+#define EFUSE_MAP_LEN_JAGUAR					512
+#define EFUSE_MAX_SECTION_JAGUAR				64
+#define EFUSE_MAX_WORD_UNIT_JAGUAR			4
+#define EFUSE_IC_ID_OFFSET_JAGUAR				506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR_8812(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_JAGUAR)
+// <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
+// 9bytes + 1byt + 5bytes and pre 1byte.
+// For worst case:
+// | 2byte|----8bytes----|1byte|--7bytes--| //92D
+#define EFUSE_OOB_PROTECT_BYTES_JAGUAR		18 	// PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte.
+#define EFUSE_PROTECT_BYTES_BANK_JAGUAR		16
+// Added for different registry settings to adjust TxPwr index. added by Roger, 2010.03.09.
+typedef enum _TX_PWR_PERCENTAGE{
+	TX_PWR_PERCENTAGE_0 = 0x01, // 12.5%
+	TX_PWR_PERCENTAGE_1 = 0x02, // 25%
+	TX_PWR_PERCENTAGE_2 = 0x04, // 50%
+	TX_PWR_PERCENTAGE_3 = 0x08, //100%, default target output power.
+} TX_PWR_PERCENTAGE;
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+//#define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? _TRUE : _FALSE)
+
+//#define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) )
+
+// rtl8812_hal_init.c
+void	_8051Reset8812(PADAPTER padapter);
+s32	FirmwareDownload8812(PADAPTER Adapter, BOOLEAN bUsedWoWLANFw);
+void	InitializeFirmwareVars8812(PADAPTER padapter);
+
+s32	_LLTWrite_8812A(PADAPTER Adapter, u32 address, u32 data);
+s32	InitLLTTable8812A(PADAPTER padapter, u8 txpktbuf_bndy);
+void InitRDGSetting8812A(PADAPTER padapter);
+
+void CheckAutoloadState8812A(PADAPTER padapter);
+
+// EFuse
+u8	GetEEPROMSize8812A(PADAPTER padapter);
+void InitPGData8812A(PADAPTER padapter);
+void	Hal_EfuseParseIDCode8812A(PADAPTER padapter, u8 *hwinfo);
+void	Hal_ReadPROMVersion8812A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void	Hal_ReadTxPowerInfo8812A(PADAPTER padapter, u8* hwinfo,BOOLEAN	AutoLoadFail);
+void	Hal_ReadBoardType8812A(PADAPTER pAdapter, u8* hwinfo,BOOLEAN AutoLoadFail);
+void	Hal_ReadThermalMeter_8812A(PADAPTER	Adapter, u8* PROMContent,BOOLEAN 	AutoloadFail);
+void	Hal_ReadChannelPlan8812A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void	Hal_EfuseParseXtal_8812A(PADAPTER pAdapter, u8* hwinfo,BOOLEAN AutoLoadFail);
+void	Hal_ReadAntennaDiversity8812A(PADAPTER pAdapter,u8* PROMContent,BOOLEAN AutoLoadFail);
+void	Hal_ReadAntennaDiversity8821A(PADAPTER pAdapter, u8* PROMContent, BOOLEAN AutoLoadFail);
+void	Hal_ReadAmplifierType_8812A(PADAPTER Adapter,u8* PROMContent, BOOLEAN AutoloadFail);
+void	Hal_ReadPAType_8821A(PADAPTER Adapter,u8* PROMContent, BOOLEAN AutoloadFail);
+void	Hal_ReadRFEType_8812A(PADAPTER Adapter,u8* PROMContent, BOOLEAN AutoloadFail);
+void	Hal_EfuseParseBTCoexistInfo8812A(PADAPTER Adapter, u8* hwinfo, BOOLEAN AutoLoadFail);
+void	hal_ReadUsbType_8812AU(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
+int 	FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
+void	Hal_ReadRemoteWakeup_8812A(PADAPTER padapter, u8* hwinfo, BOOLEAN AutoLoadFail);
+
+BOOLEAN HalDetectPwrDownMode8812(PADAPTER Adapter);
+void Hal_EfuseParseKFreeData_8821A(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
+
+#ifdef CONFIG_WOWLAN
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+void _InitBeaconParameters_8812A(PADAPTER padapter);
+void SetBeaconRelatedRegisters8812A(PADAPTER padapter);
+
+void ReadRFType8812A(PADAPTER padapter);
+void InitDefaultValue8821A(PADAPTER padapter);
+
+void SetHwReg8812A(PADAPTER padapter, u8 variable, u8 *pval);
+void GetHwReg8812A(PADAPTER padapter, u8 variable, u8 *pval);
+u8 SetHalDefVar8812A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+u8 GetHalDefVar8812A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+s32 c2h_id_filter_ccx_8812a(u8 *buf);
+void rtl8812_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8812a(_adapter *adapter);
+void init_hal_spec_8821a(_adapter *adapter);
+
+// register
+void SetBcnCtrlReg(PADAPTER padapter, u8 SetBits, u8 ClearBits);
+
+void rtl8812_start_thread(PADAPTER padapter);
+void rtl8812_stop_thread(PADAPTER padapter);
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8812AE(PADAPTER Adapter);
+VOID	UpdateInterruptMask8812AE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+void rtl8812a_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
+#endif
+
+VOID
+Hal_PatchwithJaguar_8812(
+	IN PADAPTER				Adapter,
+	IN RT_MEDIA_STATUS		MediaStatus
+	);
+
+#endif //__RTL8188E_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_led.h
new file mode 100644
index 000000000..66e85baa2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_led.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_LED_H__
+#define __RTL8812A_LED_H__
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8812au_InitSwLeds(PADAPTER padapter);
+void rtl8812au_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_PCI_HCI
+void rtl8812ae_InitSwLeds(PADAPTER padapter);
+void rtl8812ae_DeInitSwLeds(PADAPTER padapter);
+#endif
+#ifdef CONFIG_SDIO_HCI
+void rtl8821as_InitSwLeds(PADAPTER padapter);
+void rtl8821as_DeInitSwLeds(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_recv.h
new file mode 100644
index 000000000..7729d4267
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_recv.h
@@ -0,0 +1,162 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_RECV_H__
+#define __RTL8812A_RECV_H__
+
+#if defined(CONFIG_USB_HCI)
+
+#ifndef MAX_RECVBUF_SZ
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+	#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+		#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+			#define MAX_RECVBUF_SZ (rtw_rtkm_get_buff_size()) /*depend rtkm*/
+		#else
+			#define MAX_RECVBUF_SZ (32768)  /*32k*/
+		#endif
+		//#define MAX_RECVBUF_SZ (24576) // 24k
+		//#define MAX_RECVBUF_SZ (20480) //20K
+		//#define MAX_RECVBUF_SZ (10240) //10K
+		//#define MAX_RECVBUF_SZ (15360) // 15k < 16k
+		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+		#ifdef CONFIG_PLATFORM_NOVATEK_NT72668
+		#undef MAX_RECVBUF_SZ
+		#define MAX_RECVBUF_SZ (15360) // 15k < 16k
+		#endif //CONFIG_PLATFORM_NOVATEK_NT72668
+	#else
+		#define MAX_RECVBUF_SZ (4000) // about 4K
+	#endif
+#endif
+#endif //!MAX_RECVBUF_SZ
+
+#elif defined(CONFIG_PCI_HCI)
+//#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+//	#define MAX_RECVBUF_SZ (9100)
+//#else
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+//#endif
+
+
+#elif defined(CONFIG_SDIO_HCI)
+
+#define MAX_RECVBUF_SZ (RX_DMA_BOUNDARY_8821 + 1)
+
+#endif
+
+
+// Rx smooth factor
+#define Rx_Smooth_Factor (20)
+
+//DWORD 0
+#define SET_RX_STATUS_DESC_PKT_LEN_8812(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_8812(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_8812(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
+
+#define GET_RX_STATUS_DESC_PKT_LEN_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICV_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8812(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
+#define GET_RX_STATUS_DESC_LAST_SEG_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 28, 1)
+#define GET_RX_STATUS_DESC_FIRST_SEG_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 29, 1)
+#define GET_RX_STATUS_DESC_EOR_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID_8812(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_TID_8812(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_AMSDU_8812(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH_8812(__pRxDesc)		LE_BITS_TO_4BYTE( __pRxDesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_A1_FIT_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 16, 4)
+#define GET_RX_STATUS_DESC_CHKERR_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_IPVER_8812(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_IS_TCPUDP__8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_CHK_VLD_8812(__pRxDesc)		LE_BITS_TO_4BYTE(__pRxDesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_MC_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC_8812(__pRxDesc)				LE_BITS_TO_4BYTE( __pRxDesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ_8812(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 12, 4)
+#define GET_RX_STATUS_DESC_RX_IS_QOS_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 1)
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8812(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_RPT_SEL_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 28, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_HTC_8812(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP_8812(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT_8812(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 12, 2)
+#ifdef CONFIG_USB_RX_AGGREGATION
+#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8812(__pRxStatusDesc)	LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 16, 8)
+#endif
+#define GET_RX_STATUS_DESC_PATTERN_MATCH_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_MATCH_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_MATCH_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+12, 31, 1)
+
+//DWORD 6
+#define GET_RX_STATUS_DESC_SPLCP_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 0, 1)
+#define GET_RX_STATUS_DESC_LDPC_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 1, 1)
+#define GET_RX_STATUS_DESC_STBC_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 2, 1)
+#define GET_RX_STATUS_DESC_BW_8812(__pRxDesc)			LE_BITS_TO_4BYTE( __pRxDesc+16, 4, 2)
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL_8812(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+20, 0, 32)
+
+#define GET_RX_STATUS_DESC_BUFF_ADDR_8812(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR64_8812(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)
+
+#define SET_RX_STATUS_DESC_BUFF_ADDR_8812(__pRxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)
+
+
+#ifdef CONFIG_SDIO_HCI
+s32 InitRecvPriv8821AS(PADAPTER padapter);
+void FreeRecvPriv8821AS(PADAPTER padapter);
+#endif // CONFIG_SDIO_HCI
+
+#ifdef CONFIG_USB_HCI
+void rtl8812au_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+s32 rtl8812au_init_recv_priv(PADAPTER padapter);
+void rtl8812au_free_recv_priv(PADAPTER padapter);
+void rtl8812au_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
+void rtl8812au_recv_tasklet(void *priv);
+
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8812ae_init_recv_priv(PADAPTER padapter);
+void rtl8812ae_free_recv_priv(PADAPTER padapter);
+#endif
+
+void rtl8812_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+
+#endif /* __RTL8812A_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_rf.h
new file mode 100644
index 000000000..e87b88534
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_rf.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_RF_H__
+#define __RTL8812A_RF_H__
+
+VOID
+PHY_RF6052SetBandwidth8812(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH		Bandwidth);
+
+
+int
+PHY_RF6052_Config_8812(
+	IN	PADAPTER	Adapter	);
+
+#endif//__RTL8188E_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_spec.h
new file mode 100644
index 000000000..6d636a8c3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_spec.h
@@ -0,0 +1,275 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8812A_SPEC_H__
+#define __RTL8812A_SPEC_H__
+
+#include <drv_conf.h>
+
+
+//============================================================
+//       8812 Regsiter offset definition
+//============================================================
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_CLKR_8812A				0x0008
+#define REG_AFE_PLL_CTRL_8812A		0x0028
+#define REG_HSIMR_8812					0x0058
+#define REG_HSISR_8812					0x005c
+#define REG_GPIO_EXT_CTRL				0x0060
+#define REG_GPIO_STATUS_8812			0x006C
+#define REG_SDIO_CTRL_8812				0x0070
+#define REG_OPT_CTRL_8812				0x0074
+#define REG_RF_B_CTRL_8812				0x0076
+#define REG_FW_DRV_MSG_8812			0x0088
+#define REG_HMEBOX_E2_E3_8812			0x008C
+#define REG_HIMR0_8812					0x00B0
+#define REG_HISR0_8812					0x00B4
+#define REG_HIMR1_8812					0x00B8
+#define REG_HISR1_8812					0x00BC
+#define REG_EFUSE_BURN_GNT_8812		0x00CF
+#define REG_SYS_CFG1_8812				0x00FC
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_CR_8812A					0x100
+#define REG_PKTBUF_DBG_ADDR 			(REG_PKTBUF_DBG_CTRL)
+#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
+#define REG_WOWLAN_WAKE_REASON			REG_MCUTST_WOWLAN
+
+#define REG_RSVD3_8812					0x0168
+#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
+#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
+#define REG_C2HEVT_CMD_LEN_88XX		0x01AE
+
+#define REG_HMEBOX_EXT0_8812			0x01F0
+#define REG_HMEBOX_EXT1_8812			0x01F4
+#define REG_HMEBOX_EXT2_8812			0x01F8
+#define REG_HMEBOX_EXT3_8812			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_DWBCN0_CTRL_8812				REG_TDECTRL
+#define REG_DWBCN1_CTRL_8812				0x0228
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_TDECTRL_8812A				0x0208
+#define REG_RXDMA_CONTROL_8812A		0x0286		/*Control the RX DMA.*/
+#define REG_RXDMA_PRO_8812			0x0290
+#define REG_EARLY_MODE_CONTROL_8812	0x02BC
+#define REG_RSVD5_8812					0x02F0
+#define REG_RSVD6_8812					0x02F4
+#define REG_RSVD7_8812					0x02F8
+#define REG_RSVD8_8812					0x02FC
+
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG_8812A		0x0300
+#define	REG_DBI_WDATA_8812			0x0348	// DBI Write Data
+#define	REG_DBI_RDATA_8812			0x034C	// DBI Read Data
+#define	REG_DBI_ADDR_8812				0x0350	// DBI Address
+#define	REG_DBI_FLAG_8812				0x0352	// DBI Read/Write Flag
+#define	REG_MDIO_WDATA_8812			0x0354	// MDIO for Write PCIE PHY
+#define	REG_MDIO_RDATA_8812			0x0356	// MDIO for Reads PCIE PHY
+#define	REG_MDIO_CTL_8812				0x0358	// MDIO for Control
+#define	REG_PCIE_MULTIFET_CTRL_8812	0x036A	//PCIE Multi-Fethc Control
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_TXPKT_EMPTY_8812A			0x041A
+#define REG_FWHW_TXQ_CTRL_8812A		0x0420
+#define REG_TXBF_CTRL_8812A			0x042C
+#define REG_ARFR0_8812					0x0444
+#define REG_ARFR1_8812					0x044C
+#define REG_CCK_CHECK_8812				0x0454
+#define REG_AMPDU_MAX_TIME_8812		0x0456
+#define REG_TXPKTBUF_BCNQ_BDNY1_8812	0x0457
+
+#define REG_AMPDU_MAX_LENGTH_8812	0x0458
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8812	0x045D
+#define REG_NDPA_OPT_CTRL_8812A		0x045F
+#define REG_DATA_SC_8812				0x0483
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
+#define REG_ARFR2_8812					0x048C
+#define REG_ARFR3_8812					0x0494
+#define REG_TXRPT_START_OFFSET		0x04AC
+#define REG_AMPDU_BURST_MODE_8812	0x04BC
+#define REG_HT_SINGLE_AMPDU_8812		0x04C7
+#define REG_MACID_PKT_DROP0_8812		0x04D0
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_TXPAUSE_8812A				0x0522
+#define REG_CTWND_8812					0x0572
+#define REG_SECONDARY_CCA_CTRL_8812	0x0577
+#define REG_SCH_TXCMD_8812A			0x05F8
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_MAC_CR_8812				0x0600
+
+#define REG_MAC_TX_SM_STATE_8812		0x06B4
+
+// Power
+#define REG_BFMER0_INFO_8812A			0x06E4
+#define REG_BFMER1_INFO_8812A			0x06EC
+#define REG_CSI_RPT_PARAM_BW20_8812A	0x06F4
+#define REG_CSI_RPT_PARAM_BW40_8812A	0x06F8
+#define REG_CSI_RPT_PARAM_BW80_8812A	0x06FC
+
+// Hardware Port 2
+#define REG_BFMEE_SEL_8812A			0x0714
+#define REG_SND_PTCL_CTRL_8812A		0x0718
+
+
+//-----------------------------------------------------
+//
+//	Redifine register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+#define	ISR_8812							REG_HISR0_8812
+
+//----------------------------------------------------------------------------
+//       8195 IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8812					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8812					BIT31		// Timeout interrupt 2
+#define	IMR_TIMER1_8812					BIT30		// Timeout interrupt 1
+#define	IMR_PSTIMEOUT_8812				BIT29		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8812					BIT28		// When GTIMER4 expires, this bit is set to 1
+#define	IMR_GTINT3_8812					BIT27		// When GTIMER3 expires, this bit is set to 1
+#define	IMR_TXBCN0ERR_8812				BIT26		// Transmit Beacon0 Error
+#define	IMR_TXBCN0OK_8812					BIT25		// Transmit Beacon0 OK
+#define	IMR_TSF_BIT32_TOGGLE_8812		BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define	IMR_BCNDMAINT0_8812				BIT20		// Beacon DMA Interrupt 0
+#define	IMR_BCNDERR0_8812					BIT16		// Beacon Queue DMA OK0
+#define	IMR_HSISR_IND_ON_INT_8812		BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8812				BIT14		// Beacon DMA Interrupt Extension for Win7
+#define	IMR_ATIMEND_8812					BIT12		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8812					BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define	IMR_CPWM2_8812					BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_CPWM_8812						BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_HIGHDOK_8812					BIT7			// High Queue DMA OK
+#define	IMR_MGNTDOK_8812					BIT6			// Management Queue DMA OK
+#define	IMR_BKDOK_8812					BIT5			// AC_BK DMA OK
+#define	IMR_BEDOK_8812					BIT4			// AC_BE DMA OK
+#define	IMR_VIDOK_8812					BIT3			// AC_VI DMA OK
+#define	IMR_VODOK_8812					BIT2			// AC_VO DMA OK
+#define	IMR_RDU_8812						BIT1			// Rx Descriptor Unavailable
+#define	IMR_ROK_8812						BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_BCNDMAINT7_8812				BIT27		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8812				BIT26		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8812				BIT25		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8812				BIT24		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8812				BIT23		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8812				BIT22		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8812				BIT21		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8812					BIT20		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8812					BIT19		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8812					BIT18		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8812					BIT17		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8812					BIT16		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8812					BIT15		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8812					BIT14		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8812				BIT13		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8812					BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8812					BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8812					BIT9			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8812					BIT8			// Receive FIFO Overflow
+
+
+#ifdef CONFIG_PCI_HCI
+//#define IMR_RX_MASK		(IMR_ROK_8812|IMR_RDU_8812|IMR_RXFOVW_8812)
+#define IMR_TX_MASK			(IMR_VODOK_8812|IMR_VIDOK_8812|IMR_BEDOK_8812|IMR_BKDOK_8812|IMR_MGNTDOK_8812|IMR_HIGHDOK_8812)
+
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8812 | IMR_TXBCN0OK_8812 | IMR_TXBCN0ERR_8812 | IMR_BCNDERR0_8812)
+
+#define RT_AC_INT_MASKS	(IMR_VIDOK_8812 | IMR_VODOK_8812 | IMR_BEDOK_8812|IMR_BKDOK_8812)
+#endif
+
+
+//============================================================================
+//       Regsiter Bit and Content definition
+//============================================================================
+
+//2 ACMHWCTRL 0x05C0
+#define	AcmHw_HwEn_8812				BIT(0)
+#define	AcmHw_VoqEn_8812				BIT(1)
+#define	AcmHw_ViqEn_8812				BIT(2)
+#define	AcmHw_BeqEn_8812				BIT(3)
+#define	AcmHw_VoqStatus_8812			BIT(5)
+#define	AcmHw_ViqStatus_8812			BIT(6)
+#define	AcmHw_BeqStatus_8812			BIT(7)
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8812A 128
+#define SEC_CAM_ENT_NUM_8812A 64
+#define NSS_NUM_8812A 2
+#define BAND_CAP_8812A (BAND_CAP_2G | BAND_CAP_5G)
+#define BW_CAP_8812A (BW_CAP_20M | BW_CAP_40M | BW_CAP_80M)
+
+#endif /* __RTL8812A_SPEC_H__ */
+
+#ifdef CONFIG_RTL8821A
+#include "rtl8821a_spec.h"
+#endif /* CONFIG_RTL8821A */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_sreset.h
new file mode 100644
index 000000000..087743381
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL88812A_SRESET_H_
+#define _RTL8812A_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8812_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8812_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_xmit.h
new file mode 100644
index 000000000..64f4c3e4a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8812a_xmit.h
@@ -0,0 +1,365 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_XMIT_H__
+#define __RTL8812A_XMIT_H__
+
+
+//For 88e early mode
+#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
+#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
+#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
+#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
+#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
+#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
+#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+#define BMC			BIT(24)
+#define LSG			BIT(26)
+#define FSG			BIT(27)
+#define OWN 		BIT(31)
+
+
+//OFFSET 4
+#define PKT_OFFSET_SZ		0
+#define QSEL_SHT			8
+#define RATE_ID_SHT			16
+#define NAVUSEHDR			BIT(20)
+#define SEC_TYPE_SHT 		22
+#define PKT_OFFSET_SHT		26
+
+//OFFSET 8
+#define AGG_EN				BIT(12)
+#define AGG_BK				BIT(16)
+#define AMPDU_DENSITY_SHT	20
+#define ANTSEL_A			BIT(24)
+#define ANTSEL_B			BIT(25)
+#define TX_ANT_CCK_SHT		26
+#define TX_ANTL_SHT			28
+#define TX_ANT_HT_SHT		30
+
+//OFFSET 12
+#define SEQ_SHT				16
+#define EN_HWSEQ			BIT(31)
+
+//OFFSET 16
+#define QOS					BIT(6)
+#define	HW_SSN				BIT(7)
+#define USERATE				BIT(8)
+#define DISDATAFB			BIT(10)
+#define CTS_2_SELF			BIT(11)
+#define	RTS_EN				BIT(12)
+#define	HW_RTS_EN			BIT(13)
+#define DATA_SHORT			BIT(24)
+#define PWR_STATUS_SHT	15
+#define DATA_SC_SHT		20
+#define DATA_BW				BIT(25)
+
+//OFFSET 20
+#define	RTY_LMT_EN			BIT(17)
+
+//OFFSET 20
+#define SGI					BIT(6)
+#define USB_TXAGG_NUM_SHT	24
+
+typedef struct txdescriptor_8812
+{
+	// Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 own:1;
+
+	// Offset 4
+	u32 macid:6;
+	u32 rsvd0406:2;
+	u32 qsel:5;
+	u32 rd_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:4;
+	u32 navusehdr:1;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 rsvd0424:2;
+	u32 pkt_offset:5;	// unit: 8 bytes
+	u32 rsvd0431:1;
+
+	// Offset 8
+	u32 rts_rc:6;
+	u32 data_rc:6;
+	u32 agg_en:1;
+	u32 rd_en:1;
+	u32 bar_rty_th:2;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 ccx:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 ant_sel_a:1;
+	u32 ant_sel_b:1;
+	u32 tx_ant_cck:2;
+	u32 tx_antl:2;
+	u32 tx_ant_ht:2;
+
+	// Offset 12
+	u32 nextheadpage:8;
+	u32 tailpage:8;
+	u32 seq:12;
+	u32 cpu_handle:1;
+	u32 tag1:1;
+	u32 trigger_int:1;
+	u32 hwseq_en:1;
+
+	// Offset 16
+	u32 rtsrate:5;
+	u32 ap_dcfe:1;
+	u32 hwseq_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 pwr_status:3;
+	u32 wait_dcts:1;
+	u32 cts2ap_en:1;
+	u32 data_sc:2;
+	u32 data_stbc:2;
+	u32 data_short:1;
+	u32 data_bw:1;
+	u32 rts_short:1;
+	u32 rts_bw:1;
+	u32 rts_sc:2;
+	u32 vcs_stbc:2;
+
+	// Offset 20
+	u32 datarate:6;
+	u32 sgi:1;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 usb_txagg_num:8;
+
+	// Offset 24
+	u32 txagg_a:5;
+	u32 txagg_b:5;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 mcsg1_max_len:4;
+	u32 mcsg2_max_len:4;
+	u32 mcsg3_max_len:4;
+	u32 mcs7_sgi_max_len:4;
+
+	// Offset 28
+	u32 checksum:16;	// TxBuffSize(PCIe)/CheckSum(USB)
+	u32 mcsg4_max_len:4;
+	u32 mcsg5_max_len:4;
+	u32 mcsg6_max_len:4;
+	u32 mcs15_sgi_max_len:4;
+
+	// Offset 32
+	u32 rsvd32;
+
+	// Offset 36
+	u32 rsvd36;
+}TXDESC_8812, *PTXDESC_8812;
+
+
+// Dword 0
+#define GET_TX_DESC_OWN_8812(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
+#define SET_TX_DESC_PKT_SIZE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
+#define SET_TX_DESC_OFFSET_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
+#define SET_TX_DESC_BMC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
+#define SET_TX_DESC_LINIP_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
+#define SET_TX_DESC_NO_ACM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
+#define SET_TX_DESC_GF_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+
+// Dword 1
+#define SET_TX_DESC_MACID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET_8812(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
+
+// Dword 2
+#define SET_TX_DESC_PAID_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE_8812(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE_8812(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
+#define SET_TX_DESC_AGG_BREAK_8812(__pTxDesc, __Value) 				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
+#define SET_TX_DESC_RAW_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
+#define SET_TX_DESC_SPE_RPT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_INT_8812(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID_8812(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 4, __Value)
+#define SET_TX_DESC_CHK_EN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 4, 1, __Value)
+#define SET_TX_DESC_EARLY_MODE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HWSEQ_SEL_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA_8812(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME_8812(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT_8812(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
+#define SET_TX_DESC_CTROL_STBC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
+#define SET_TX_DESC_TX_ANT_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 4, __Value)
+
+// Dword 6
+#define SET_TX_DESC_SW_DEFINE_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_ANTSEL_A_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
+#define SET_TX_DESC_ANTSEL_B_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
+#define SET_TX_DESC_ANTSEL_C_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
+#define SET_TX_DESC_ANTSEL_D_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 25, 3, __Value)
+#define SET_TX_DESC_MBSSID_8821(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
+
+// Dword 7
+#define SET_TX_DESC_TX_BUFFER_SIZE_8812(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#define SET_TX_DESC_TX_DESC_CHECKSUM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#define SET_TX_DESC_USB_TXAGG_NUM_8812(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
+#ifdef CONFIG_SDIO_HCI
+#define SET_TX_DESC_SDIO_TXSEQ_8812(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
+#endif
+
+// Dword 8
+#define SET_TX_DESC_HWSEQ_EN_8812(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+
+// Dword 9
+#define SET_TX_DESC_SEQ_8812(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
+
+// Dword 10
+#define SET_TX_DESC_TX_BUFFER_ADDRESS_8812(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
+#define GET_TX_DESC_TX_BUFFER_ADDRESS_8812(__pTxDesc) 	LE_BITS_TO_4BYTE(__pTxDesc+40, 0, 32)
+
+// Dword 11
+#define SET_TX_DESC_NEXT_DESC_ADDRESS_8812(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)
+
+
+#define SET_EARLYMODE_PKTNUM_8812(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0_8812(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1_8812(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2_8812(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2_8812(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
+#define SET_EARLYMODE_LEN3_8812(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+#ifdef CONFIG_TX_EARLY_MODE
+#define USB_DUMMY_OFFSET		2
+#else
+#define USB_DUMMY_OFFSET		1
+#endif
+#define USB_DUMMY_LENGTH		(USB_DUMMY_OFFSET * PACKET_OFFSET_SZ)
+
+
+void rtl8812a_cal_txdesc_chksum(u8 *ptxdesc);
+void rtl8812a_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,u8 IsPsPoll,u8	IsBTQosNull, u8 bDataFrame);
+void rtl8812a_fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
+void rtl8812a_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
+void rtl8812a_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8812au_init_xmit_priv(PADAPTER padapter);
+void rtl8812au_free_xmit_priv(PADAPTER padapter);
+s32 rtl8812au_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8812au_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	 rtl8812au_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8812au_xmit_buf_handler(PADAPTER padapter);
+void rtl8812au_xmit_tasklet(void *priv);
+s32 rtl8812au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8812ae_init_xmit_priv(PADAPTER padapter);
+void rtl8812ae_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf *rtl8812ae_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+void	rtl8812ae_xmitframe_resume(_adapter *padapter);
+s32 rtl8812ae_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8812ae_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8812ae_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtl8812ae_xmit_tasklet(void *priv);
+#endif
+
+#ifdef CONFIG_TX_EARLY_MODE
+void UpdateEarlyModeInfo8812(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf );
+#endif
+
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,u8 *ptxdesc);
+
+u8	BWMapping_8812(PADAPTER Adapter, struct pkt_attrib *pattrib);
+
+u8	SCMapping_8812(PADAPTER Adapter, struct pkt_attrib	*pattrib);
+
+#endif //__RTL8812_XMIT_H__
+
+#ifdef CONFIG_RTL8821A
+#include "rtl8821a_xmit.h"
+#endif // CONFIG_RTL8821A
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_cmd.h
new file mode 100644
index 000000000..935ef7c3d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_cmd.h
@@ -0,0 +1,153 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_CMD_H__
+#define __RTL8814A_CMD_H__
+#include "hal_com_h2c.h"
+
+//_RSVDPAGE_LOC_CMD0
+#define SET_8814A_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8814A_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8814A_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8814A_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8814A_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+//_SETPWRMODE_PARM
+#define SET_8814A_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8814A_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8814A_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8814A_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8814A_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8814A_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8814A_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+
+#define GET_8814A_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+
+// _WoWLAN PARAM_CMD5
+#define SET_8814A_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_ALL_PKT_DROP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_GPIO_ACTIVE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_REKEY_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8814A_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+
+
+//WLANINFO_PARM
+#define SET_8814A_H2CCMD_WLANINFO_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8814A_H2CCMD_WLANINFO_PARM_CHANNEL(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8814A_H2CCMD_WLANINFO_PARM_BW40MHZ(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+
+// _REMOTE_WAKEUP_CMD7
+#define SET_8814A_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8814A_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8814A_H2CCMD_REMOTE_WAKE_CTRL_NDP_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8814A_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+
+
+// _AP_OFFLOAD_CMD8
+#define SET_8814A_H2CCMD_AP_OFFLOAD_ON(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8814A_H2CCMD_AP_OFFLOAD_HIDDEN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8814A_H2CCMD_AP_OFFLOAD_DENYANY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8814A_H2CCMD_AP_OFFLOAD_WAKEUP_EVT_RPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+
+// _PWR_MOD_CMD20
+#define SET_88E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_88E_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_88E_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_88E_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_88E_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_88E_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+/*BCNHWSEQ*/
+#define SET_8814A_H2CCMD_BCNHWSEQ_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 1, __Value)
+#define SET_8814A_H2CCMD_BCNHWSEQ_BCN_NUMBER(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 1, 3, __Value)
+#define SET_8814A_H2CCMD_BCNHWSEQ_HWSEQ(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 6, 1, __Value)
+#define SET_8814A_H2CCMD_BCNHWSEQ_EXHWSEQ(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 7, 1, __Value)
+#define SET_8814A_H2CCMD_BCNHWSEQ_PAGE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+void rtl8814_fw_update_beacon_cmd(_adapter *padapter);
+
+// TX Beamforming
+#define GET_8814A_C2H_TXBF_ORIGINATE(_Header)			LE_BITS_TO_1BYTE(_Header, 0, 8)
+#define GET_8814A_C2H_TXBF_MACID(_Header)				LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
+
+
+
+/// TX Feedback Content
+#define 	USEC_UNIT_FOR_8814A_C2H_TX_RPT_QUEUE_TIME			256
+
+#define	GET_8814A_C2H_TX_RPT_QUEUE_SELECT(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 0, 5)
+#define	GET_8814A_C2H_TX_RPT_PKT_BROCAST(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 5, 1)
+#define	GET_8814A_C2H_TX_RPT_LIFE_TIME_OVER(_Header)			LE_BITS_TO_1BYTE((_Header + 0), 6, 1)
+#define	GET_8814A_C2H_TX_RPT_RETRY_OVER(_Header)				LE_BITS_TO_1BYTE((_Header + 0), 7, 1)
+#define	GET_8814A_C2H_TX_RPT_MAC_ID(_Header)					LE_BITS_TO_1BYTE((_Header + 1), 0, 8)
+#define	GET_8814A_C2H_TX_RPT_DATA_RETRY_CNT(_Header)		LE_BITS_TO_1BYTE((_Header + 2), 0, 6)
+#define	GET_8814A_C2H_TX_RPT_QUEUE_TIME(_Header)				LE_BITS_TO_2BYTE((_Header + 3), 0, 16)	// In unit of 256 microseconds.
+#define	GET_8814A_C2H_TX_RPT_FINAL_DATA_RATE(_Header)		LE_BITS_TO_1BYTE((_Header + 5), 0, 8)
+
+
+//_P2P_PS_OFFLOAD
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+
+s32 FillH2CCmd_8814(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+void rtl8814_set_raid_cmd(PADAPTER padapter, u64 bitmap, u8* arg);
+void rtl8814_Add_RateATid(PADAPTER padapter, u64 rate_bitmap, u8 *arg, u8 rssi_level);
+void rtl8814_set_wowlan_cmd(_adapter* padapter, u8 enable);
+void rtl8814_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
+void rtl8814_set_FwPwrMode_cmd(PADAPTER padapter, u8 PSMode);
+u8 GetTxBufferRsvdPageNum8814(_adapter *padapter, bool wowlan);
+u8 rtl8814_set_rssi_cmd(_adapter*padapter, u8 *param);
+
+void
+Set_RA_LDPC_8814(
+	struct sta_info	*psta,
+	BOOLEAN			bLDPC
+	);
+int rtl8814_iqk_wait(_adapter* padapter, u32 timeout_ms);
+void rtl8814_iqk_done(_adapter* padapter);
+VOID
+C2HPacketHandler_8814(
+	IN	PADAPTER	Adapter,
+	IN	u8			*Buffer,
+	IN	u8			Length
+	);
+#ifdef CONFIG_P2P_PS
+void rtl8814_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif //CONFIG_P2P
+
+s32
+_C2HContentParsing8814(
+	IN	PADAPTER	Adapter,
+	IN	u8			c2hCmdId,
+	IN	u8			c2hCmdLen,
+	IN	u8 			*tmpBuf
+);
+
+#endif/* __RTL8814A_CMD_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_dm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_dm.h
new file mode 100644
index 000000000..48837700e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_dm.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_DM_H__
+#define __RTL8814A_DM_H__
+
+void rtl8814_init_dm_priv(IN PADAPTER Adapter);
+void rtl8814_deinit_dm_priv(IN PADAPTER Adapter);
+void rtl8814_InitHalDm(IN PADAPTER Adapter);
+void rtl8814_HalDmWatchDog(IN PADAPTER Adapter);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void AntDivCompare8814(PADAPTER Adapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+u8 AntDivBeforeLink8814(PADAPTER Adapter );
+#endif //CONFIG_ANTENNA_DIVERSITY
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_hal.h
new file mode 100644
index 000000000..0b0d86d47
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_hal.h
@@ -0,0 +1,335 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_HAL_H__
+#define __RTL8814A_HAL_H__
+
+//#include "hal_com.h"
+#include "hal_data.h"
+
+//include HAL Related header after HAL Related compiling flags
+#include "rtl8814a_spec.h"
+#include "rtl8814a_rf.h"
+#include "rtl8814a_dm.h"
+#include "rtl8814a_recv.h"
+#include "rtl8814a_xmit.h"
+#include "rtl8814a_cmd.h"
+#include "rtl8814a_led.h"
+#include "Hal8814PwrSeq.h"
+#include "Hal8814PhyReg.h"
+#include "Hal8814PhyCfg.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8814a_sreset.h"
+#endif //DBG_CONFIG_ERROR_DETECT
+
+
+typedef enum _TX_PWR_PERCENTAGE{
+	TX_PWR_PERCENTAGE_0 = 0x01, // 12.5%
+	TX_PWR_PERCENTAGE_1 = 0x02, // 25%
+	TX_PWR_PERCENTAGE_2 = 0x04, // 50%
+	TX_PWR_PERCENTAGE_3 = 0x08, //100%, default target output power.
+} TX_PWR_PERCENTAGE;
+
+
+enum{
+		VOLTAGE_V25						= 0x03,
+		LDOE25_SHIFT					= 28 ,
+	};
+#define FW_SIZE					      0x10000  // Compatible with RTL8723 Maximal RAM code size 24K.   modified to 32k, TO compatible with 92d maximal fw size 32k
+#define FW_START_ADDRESS   0x1000
+typedef struct _RT_FIRMWARE_8814 {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8*			szFwBuffer;
+#else
+	u8			szFwBuffer[FW_SIZE];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8814, *PRT_FIRMWARE_8814;
+
+#define PAGE_SIZE_TX_8814	PAGE_SIZE_128
+#define BCNQ_PAGE_NUM_8814		0x08
+
+//---------------------------------------------------------------------
+//		RTL8814AU From header
+//---------------------------------------------------------------------
+		#define RTL8814A_FW_IMG					"rtl8814a/FW_NIC.bin"
+		#define RTL8814A_FW_WW_IMG				"rtl8814a/FW_WoWLAN.bin"
+		#define RTL8814A_PHY_REG					"rtl8814a/PHY_REG.txt"
+		#define RTL8814A_PHY_RADIO_A				"rtl8814a/RadioA.txt"
+		#define RTL8814A_PHY_RADIO_B				"rtl8814a/RadioB.txt"
+		#define RTL8814A_PHY_RADIO_C				"rtl8814a/RadioC.txt"
+		#define RTL8814A_PHY_RADIO_D				"rtl8814a/RadioD.txt"
+		#define RTL8814A_TXPWR_TRACK				"rtl8814a/TxPowerTrack.txt"
+		#define RTL8814A_AGC_TAB					"rtl8814a/AGC_TAB.txt"
+		#define RTL8814A_PHY_MACREG 				"rtl8814a/MAC_REG.txt"
+		#define RTL8814A_PHY_REG_PG				"rtl8814a/PHY_REG_PG.txt"
+		#define RTL8814A_PHY_REG_MP 				"rtl8814a/PHY_REG_MP.txt"
+		#define RTL8814A_TXPWR_LMT				"rtl8814a/TXPWR_LMT.txt"
+		#define RTL8814A_WIFI_ANT_ISOLATION		"rtl8814a/wifi_ant_isolation.txt"
+
+#define Rtl8814A_NIC_PWR_ON_FLOW				rtl8814A_power_on_flow
+#define Rtl8814A_NIC_RF_OFF_FLOW				rtl8814A_radio_off_flow
+#define Rtl8814A_NIC_DISABLE_FLOW				rtl8814A_card_disable_flow
+#define Rtl8814A_NIC_ENABLE_FLOW				rtl8814A_card_enable_flow
+#define Rtl8814A_NIC_SUSPEND_FLOW				rtl8814A_suspend_flow
+#define Rtl8814A_NIC_RESUME_FLOW				rtl8814A_resume_flow
+#define Rtl8814A_NIC_PDN_FLOW					rtl8814A_hwpdn_flow
+#define Rtl8814A_NIC_LPS_ENTER_FLOW			rtl8814A_enter_lps_flow
+#define Rtl8814A_NIC_LPS_LEAVE_FLOW			rtl8814A_leave_lps_flow
+
+//=====================================================
+//				New	Firmware Header(8-byte alinment required)
+//=====================================================
+//--- LONG WORD 0 ----
+#define GET_FIRMWARE_HDR_SIGNATURE_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16)
+#define GET_FIRMWARE_HDR_CATEGORY_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) // AP/NIC and USB/PCI
+#define GET_FIRMWARE_HDR_FUNCTION_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr, 24, 8) // Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+#define GET_FIRMWARE_HDR_VERSION_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)// FW Version
+#define GET_FIRMWARE_HDR_SUB_VER_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) // FW Subversion, default 0x00
+#define GET_FIRMWARE_HDR_SUB_IDX_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8) // FW Subversion Index
+
+//--- LONG WORD 1 ----
+#define GET_FIRMWARE_HDR_SVN_IDX_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 32)// The SVN entry index
+#define GET_FIRMWARE_HDR_RSVD1_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 0, 32)
+
+//--- LONG WORD 2 ----
+#define GET_FIRMWARE_HDR_MONTH_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+16, 0, 8) // Release time Month field
+#define GET_FIRMWARE_HDR_DATE_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+16, 8, 8) // Release time Date field
+#define GET_FIRMWARE_HDR_HOUR_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+16, 16, 8)// Release time Hour field
+#define GET_FIRMWARE_HDR_MINUTE_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+16, 24, 8)// Release time Minute field
+#define GET_FIRMWARE_HDR_YEAR_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+20, 0, 16)// Release time Year field
+#define GET_FIRMWARE_HDR_FOUNDRY_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 16, 8)// Release time Foundry field
+#define GET_FIRMWARE_HDR_RSVD2_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 24, 8)
+
+//--- LONG WORD 3 ----
+#define GET_FIRMWARE_HDR_MEM_UASGE_DL_FROM_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+24, 0, 1)
+#define GET_FIRMWARE_HDR_MEM_UASGE_BOOT_FROM_3081(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+24, 1, 1)
+#define GET_FIRMWARE_HDR_MEM_UASGE_BOOT_LOADER_3081(__FwHdr)LE_BITS_TO_4BYTE(__FwHdr+24, 2, 1)
+#define GET_FIRMWARE_HDR_MEM_UASGE_IRAM_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 3, 1)
+#define GET_FIRMWARE_HDR_MEM_UASGE_ERAM_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 4, 1)
+#define GET_FIRMWARE_HDR_MEM_UASGE_RSVD4_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+24, 5, 3)
+#define GET_FIRMWARE_HDR_RSVD3_3081(__FwHdr)					LE_BITS_TO_4BYTE(__FwHdr+24, 8, 8)
+#define GET_FIRMWARE_HDR_BOOT_LOADER_SZ_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 16, 16)
+#define GET_FIRMWARE_HDR_RSVD5_3081(__FwHdr)					LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)
+
+//--- LONG WORD 4 ----
+#define GET_FIRMWARE_HDR_TOTAL_DMEM_SZ_3081(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+36, 0, 32)
+#define GET_FIRMWARE_HDR_FW_CFG_SZ_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+36, 0, 16)
+#define GET_FIRMWARE_HDR_FW_ATTR_SZ_3081(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+36, 16, 16)
+
+//--- LONG WORD 5 ----
+#define GET_FIRMWARE_HDR_IROM_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+40, 0, 32)
+#define GET_FIRMWARE_HDR_EROM_3081(__FwHdr)				LE_BITS_TO_4BYTE(__FwHdr+44, 0, 32)
+
+//--- LONG WORD 6 ----
+#define GET_FIRMWARE_HDR_IRAM_SZ_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+48, 0, 32)
+#define GET_FIRMWARE_HDR_ERAM_SZ_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+52, 0, 32)
+
+//--- LONG WORD 7 ----
+#define GET_FIRMWARE_HDR_RSVD6_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+56, 0, 32)
+#define GET_FIRMWARE_HDR_RSVD7_3081(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+60, 0, 32)
+
+
+
+//
+// 2013/08/16 MH MOve from SDIO.h for common use.
+//
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
+#define TRX_SHARE_MODE_8814A				0	//TRX Buffer Share Index
+#define BASIC_RXFF_SIZE_8814A				24576//Basic RXFF Size is 24K = 24*1024 Unit: Byte
+#define TRX_SHARE_BUFF_UNIT_8814A			65536//TRX Share Buffer unit Size 64K = 64*1024 Unit: Byte
+#define TRX_SHARE_BUFF_UNIT_PAGE_8814A	TRX_SHARE_BUFF_UNIT_8814A/PAGE_SIZE_8814A//512 Pages
+
+//Origin:
+#define  HPQ_PGNUM_8814A	 				0x20	//High Queue
+#define  LPQ_PGNUM_8814A	 				0x20	//Low Queue
+#define  NPQ_PGNUM_8814A	 				0x20	//Normal Queue
+#define  EPQ_PGNUM_8814A	 				0x20	//Extra Queue
+
+#else	// #if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
+
+#define  HPQ_PGNUM_8814A		20
+#define  NPQ_PGNUM_8814A		20
+#define  LPQ_PGNUM_8814A		20 //1972
+#define  EPQ_PGNUM_8814A		20
+#define  BCQ_PGNUM_8814A		32
+
+#endif //#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_HCI)
+
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8814	0x00
+#else
+#define WOWLAN_PAGE_NUM_8814	0x00
+#endif
+
+#define PAGE_SIZE_8814A						128//TXFF Page Size, Unit: Byte
+#define MAX_RX_DMA_BUFFER_SIZE_8814A		0x5C00	//BASIC_RXFF_SIZE_8814A+TRX_SHARE_MODE_8814A*TRX_SHARE_BUFF_UNIT_8814A //Basic RXFF Size + ShareBuffer Size
+#define TX_PAGE_BOUNDARY_8814A			TXPKT_PGNUM_8814A	// Need to enlarge boundary, by KaiYuan
+#define TX_PAGE_BOUNDARY_WOWLAN_8814A	TXPKT_PGNUM_8814A	//TODO: 20130415 KaiYuan Check this value later
+
+
+#define  TOTAL_PGNUM_8814A		2048
+#define  TXPKT_PGNUM_8814A		(2048 - BCNQ_PAGE_NUM_8814-WOWLAN_PAGE_NUM_8814)
+#define  PUB_PGNUM_8814A		(TXPKT_PGNUM_8814A-HPQ_PGNUM_8814A-NPQ_PGNUM_8814A-LPQ_PGNUM_8814A-EPQ_PGNUM_8814A)
+
+//Note: For WMM Normal Chip Setting ,modify later
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8814A	TX_PAGE_BOUNDARY_8814A
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8814A		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8814A + 1)
+
+#define DRIVER_EARLY_INT_TIME_8814		0x05
+#define BCN_DMA_ATIME_INT_TIME_8814		0x02
+
+
+#define MAX_PAGE_SIZE			4096	// @ page : 4k bytes
+
+#define EFUSE_MAX_SECTION_JAGUAR				64
+
+#define	HWSET_MAX_SIZE_8814A			512
+
+#define	EFUSE_REAL_CONTENT_LEN_8814A	1024
+#define	EFUSE_MAX_BANK_8814A		2
+
+#define	EFUSE_MAP_LEN_8814A			512
+#define	EFUSE_MAX_SECTION_8814A		64
+#define	EFUSE_MAX_WORD_UNIT_8814A		4
+#define	EFUSE_PROTECT_BYTES_BANK_8814A		16
+
+#define	EFUSE_IC_ID_OFFSET_8814A		506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR_8814A(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_8814A)
+
+/*-------------------------------------------------------------------------
+Chip specific
+-------------------------------------------------------------------------*/
+
+/* pic buffer descriptor */
+#if 1 /* according to the define in the rtw_xmit.h, rtw_recv.h */
+#define RTL8814AE_SEG_NUM  TX_BUFFER_SEG_NUM /* 0:2 seg, 1: 4 seg, 2: 8 seg */
+#define TX_DESC_NUM_8814A  TXDESC_NUM   /* 128 */
+#define RX_DESC_NUM_8814A  PCI_MAX_RX_COUNT /* 128 */
+#ifdef CONFIG_CONCURRENT_MODE
+#define BE_QUEUE_TX_DESC_NUM_8814A  (TXDESC_NUM<<1)    /* 256 */
+#else
+#define BE_QUEUE_TX_DESC_NUM_8814A  (TXDESC_NUM+(TXDESC_NUM>>1)) /* 192 */
+#endif
+#else
+#define RTL8814AE_SEG_NUM  TX_BUFFER_SEG_NUM /* 0:2 seg, 1: 4 seg, 2: 8 seg */
+#define TX_DESC_NUM_8814A  128 /* 1024//2048 change by ylb 20130624 */
+#define RX_DESC_NUM_8814A  128 /* 1024 //512 change by ylb 20130624 */
+#endif
+
+// <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
+// 9bytes + 1byt + 5bytes and pre 1byte.
+// For worst case:
+// | 1byte|----8bytes----|1byte|--5bytes--|
+// |         |            Reserved(14bytes)	      |
+//
+#define	EFUSE_OOB_PROTECT_BYTES 		15	// PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte.
+
+/* rtl8814_hal_init.c */
+s32 FirmwareDownload8814A( PADAPTER	Adapter, BOOLEAN bUsedWoWLANFw);
+void	InitializeFirmwareVars8814(PADAPTER padapter);
+
+VOID
+Hal_InitEfuseVars_8814A(
+	IN	PADAPTER	Adapter
+	);
+
+s32 InitLLTTable8814A(
+	IN	PADAPTER	Adapter
+	);
+
+
+void InitRDGSetting8814A(PADAPTER padapter);
+
+//void CheckAutoloadState8812A(PADAPTER padapter);
+
+// EFuse
+u8	GetEEPROMSize8814A(PADAPTER padapter);
+void InitPGData8814A(PADAPTER padapter);
+
+void	hal_ReadPROMVersion8814A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void	hal_ReadTxPowerInfo8814A(PADAPTER padapter, u8* hwinfo,BOOLEAN	AutoLoadFail);
+void	hal_ReadBoardType8814A(PADAPTER pAdapter, u8* hwinfo,BOOLEAN AutoLoadFail);
+void	hal_ReadThermalMeter_8814A(PADAPTER	Adapter, u8* PROMContent,BOOLEAN 	AutoloadFail);
+void	hal_ReadChannelPlan8814A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
+void	hal_EfuseParseXtal_8814A(PADAPTER pAdapter, u8* hwinfo,BOOLEAN AutoLoadFail);
+void	hal_ReadAntennaDiversity8814A(PADAPTER pAdapter,u8* PROMContent,BOOLEAN AutoLoadFail);
+void	hal_Read_TRX_antenna_8814A(PADAPTER	Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
+VOID hal_ReadAmplifierType_8814A(
+	IN	PADAPTER		Adapter
+	);
+VOID hal_ReadPAType_8814A(
+	IN	PADAPTER	Adapter,
+	IN	u8*			PROMContent,
+	IN	BOOLEAN		AutoloadFail,
+	OUT u8*		pPAType,
+	OUT u8*		pLNAType
+	);
+void Hal_EfuseParseKFreeData_8814A(
+	IN		PADAPTER		Adapter,
+	IN		u8				*PROMContent,
+	IN		BOOLEAN			AutoloadFail);
+void	hal_ReadRFEType_8814A(PADAPTER Adapter,u8* PROMContent, BOOLEAN AutoloadFail);
+void	hal_EfuseParseBTCoexistInfo8814A(PADAPTER Adapter, u8* hwinfo, BOOLEAN AutoLoadFail);
+
+//void	hal_ReadUsbType_8812AU(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
+//int 	FirmwareDownloadBT(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
+void	hal_ReadRemoteWakeup_8814A(PADAPTER padapter, u8* hwinfo, BOOLEAN AutoLoadFail);
+u8	MgntQuery_NssTxRate(u16 Rate);
+
+//BOOLEAN HalDetectPwrDownMode8812(PADAPTER Adapter);
+
+#ifdef CONFIG_WOWLAN
+void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif //CONFIG_WOWLAN
+
+void _InitBeaconParameters_8814A(PADAPTER padapter);
+void SetBeaconRelatedRegisters8814A(PADAPTER padapter);
+
+void ReadRFType8814A(PADAPTER padapter);
+void InitDefaultValue8814A(PADAPTER padapter);
+
+void SetHwReg8814A(PADAPTER padapter, u8 variable, u8 *pval);
+void GetHwReg8814A(PADAPTER padapter, u8 variable, u8 *pval);
+u8 SetHalDefVar8814A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+u8 GetHalDefVar8814A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
+s32 c2h_id_filter_ccx_8814a(u8 *buf);
+void rtl8814_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8814a(_adapter *adapter);
+
+// register
+void SetBcnCtrlReg(PADAPTER padapter, u8 SetBits, u8 ClearBits);
+void SetBcnCtrlReg(PADAPTER	Adapter, u8	SetBits, u8	ClearBits);
+void rtl8814_start_thread(PADAPTER padapter);
+void rtl8814_stop_thread(PADAPTER padapter);
+
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8814AE(PADAPTER Adapter);
+VOID	UpdateInterruptMask8814AE(PADAPTER Adapter, u32 AddMSR, u32 AddMSR1, u32 RemoveMSR, u32 RemoveMSR1);
+u16	get_txbd_idx_addr(u16 ff_hwaddr);
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+void rtl8812a_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
+#endif
+
+#endif //__RTL8188E_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_led.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_led.h
new file mode 100644
index 000000000..b2f3b5ae8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_led.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_LED_H__
+#define __RTL8814A_LED_H__
+
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+#ifdef CONFIG_USB_HCI
+void rtl8814au_InitSwLeds(PADAPTER padapter);
+void rtl8814au_DeInitSwLeds(PADAPTER padapter);
+#endif //CONFIG_USB_HCI
+#ifdef CONFIG_PCI_HCI
+void rtl8814ae_InitSwLeds(PADAPTER padapter);
+void rtl8814ae_DeInitSwLeds(PADAPTER padapter);
+#endif //CONFIG_PCI_HCI
+#ifdef CONFIG_SDIO_HCI
+void rtl8814s_InitSwLeds(PADAPTER padapter);
+void rtl8814s_DeInitSwLeds(PADAPTER padapter);
+#endif //CONFIG_SDIO_HCI
+
+#endif //__RTL8814A_LED_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_recv.h
new file mode 100644
index 000000000..718e74935
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_recv.h
@@ -0,0 +1,188 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_RECV_H__
+#define __RTL8814A_RECV_H__
+
+#if defined(CONFIG_USB_HCI)
+
+#ifndef MAX_RECVBUF_SZ
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+	#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+		#ifdef CONFIG_PLATFORM_MSTAR
+			#define MAX_RECVBUF_SZ (8192) // 8K
+		#else
+		#define MAX_RECVBUF_SZ (32768) // 32k
+		#endif
+		//#define MAX_RECVBUF_SZ (24576) // 24k
+		//#define MAX_RECVBUF_SZ (20480) //20K
+		//#define MAX_RECVBUF_SZ (10240) //10K
+		//#define MAX_RECVBUF_SZ (15360) // 15k < 16k
+		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+	#else
+		#define MAX_RECVBUF_SZ (4000) // about 4K
+	#endif
+#endif
+#endif //!MAX_RECVBUF_SZ
+
+#elif defined(CONFIG_PCI_HCI)
+//#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+//	#define MAX_RECVBUF_SZ (9100)
+//#else
+	#define MAX_RECVBUF_SZ (4000) // about 4K
+//#endif
+
+
+#elif defined(CONFIG_SDIO_HCI)
+/* temp solution
+#ifdef CONFIG_SDIO_RX_COPY
+#define MAX_RECVBUF_SZ (10240)
+#else // !CONFIG_SDIO_RX_COPY
+#define MAX_RECVBUF_SZ	MAX_RX_DMA_BUFFER_SIZE_8821
+#endif // !CONFIG_SDIO_RX_COPY
+*/
+#endif
+
+
+/* RX buffer descriptor */
+/* DWORD 0 */
+#define SET_RX_BUFFER_DESC_DATA_LENGTH_8814A(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_BUFFER_DESC_LS_8814A(__pRxStatusDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 14, 1, __Value)
+#define SET_RX_BUFFER_DESC_FS_8814A(__pRxStatusDesc, __Value)					SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 15, 1, __Value)
+#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_8814A(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE(__pRxStatusDesc, 16, 16, __Value)
+
+#define GET_RX_BUFFER_DESC_OWN_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE(__pRxStatusDesc, 31, 1)
+#define GET_RX_BUFFER_DESC_LS_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE(__pRxStatusDesc, 14, 1)
+#define GET_RX_BUFFER_DESC_FS_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE(__pRxStatusDesc, 15, 1)
+#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc, 16, 15)
+
+/* DWORD 1 */
+#define SET_RX_BUFFER_PHYSICAL_LOW_8814A(__pRxStatusDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+4, 0, 32, __Value)
+#define GET_RX_BUFFER_PHYSICAL_LOW_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 0, 32)
+
+/* DWORD 2 */
+#define SET_RX_BUFFER_PHYSICAL_HIGH_8814A(__pRxStatusDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pRxStatusDesc+8, 0, 32, __Value)
+
+/* DWORD 3*/ /* RESERVED */
+
+
+/*=============
+//RX Info
+==============*/
+//DWORD 0
+#define SET_RX_STATUS_DESC_PKT_LEN_8814A(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_8814A(__pRxStatusDesc, __Value)			SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_8814AE(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
+
+#define GET_RX_STATUS_DESC_PKT_LEN_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICV_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
+#define GET_RX_STATUS_DESC_LAST_SEG_8814AE(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 28, 1)
+#define GET_RX_STATUS_DESC_EOR_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_EXT_SECTYPE_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 7, 1)/* 20130415 KaiYuan add for 8814 */
+#define GET_RX_STATUS_DESC_TID_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_MACID_VLD_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 12, 1)
+#define GET_RX_STATUS_DESC_AMSDU_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHKERR_8814A(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_IPVER_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_IS_TCPUDP_8814A(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_TCPOFFLOAD_CHK_VLD_8814A(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_FIRST_SEG_8814AE(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 29, 1)
+#define GET_RX_STATUS_DESC_EOR_8814AE(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_MC_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC_8814A(__pRxStatusDesc)							LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 12, 4)
+#ifdef CONFIG_USB_RX_AGGREGATION
+#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 8)
+#else
+#define GET_RX_STATUS_DESC_RX_IS_QOS_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 16, 1)
+#endif
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_HWRSVD_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 24, 4)
+#define GET_RX_STATUS_C2H_8814A(__pRxStatusDesc)								LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 28, 1)
+#define GET_RX_STATUS_DESC_FCS_OK_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+8, 31, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_BSSID_FIT_H_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 7, 3)//20130415 KaiYuan add for 8814
+#define GET_RX_STATUS_DESC_HTC_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT_L_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 12, 2)
+#define GET_RX_STATUS_DESC_DMA_AGG_NUM_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+12, 16, 8)//20130415 KaiYuan Check if it exist anymore
+#define GET_RX_STATUS_DESC_PATTERN_MATCH_8814A(__pRxStatusDesc)			LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_8814A(__pRxStatusDesc)					LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_WAKE_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE(__pRxStatusDesc+12, 31, 1)
+
+//DWORD 4
+#define GET_RX_STATUS_DESC_PATTERN_IDX_8814A(__pRxStatusDesc)	 			LE_BITS_TO_4BYTE( __pRxStatusDesc+16, 0, 8)
+#define GET_RX_STATUS_DESC_RX_EOF_8814A(__pRxStatusDesc)	 				LE_BITS_TO_4BYTE( __pRxStatusDesc+16, 8, 1)
+#define GET_RX_STATUS_DESC_RX_SCRAMBLER_8814A(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc+16, 9, 7)
+#define GET_RX_STATUS_DESC_RX_PRE_NDP_VLD_8814A(__pRxStatusDesc)	 		LE_BITS_TO_4BYTE( __pRxStatusDesc+16, 16, 1)
+#define GET_RX_STATUS_DESC_A1_FIT_8814A(__pRxStatusDesc)	 					LE_BITS_TO_4BYTE( __pRxStatusDesc+16, 24, 5)
+
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL_8814A(__pRxStatusDesc)						LE_BITS_TO_4BYTE( __pRxStatusDesc+20, 0, 32)
+
+
+// Rx smooth factor
+#define Rx_Smooth_Factor (20)
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8814au_init_recv_priv(PADAPTER padapter);
+void rtl8814au_free_recv_priv(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8814ae_init_recv_priv(PADAPTER padapter);
+void rtl8814ae_free_recv_priv(PADAPTER padapter);
+#endif
+
+/* temp solution
+#ifdef CONFIG_SDIO_HCI
+s32 InitRecvPriv8821AS(PADAPTER padapter);
+void FreeRecvPriv8821AS(PADAPTER padapter);
+#endif // CONFIG_SDIO_HCI
+*/
+
+void rtl8814_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+
+#endif /* __RTL8814A_RECV_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_rf.h
new file mode 100644
index 000000000..5cd517a87
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_rf.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_RF_H__
+#define __RTL8814A_RF_H__
+
+VOID
+PHY_RF6052SetBandwidth8814A(
+	IN	PADAPTER				Adapter,
+	IN	CHANNEL_WIDTH		Bandwidth);
+
+
+int
+PHY_RF6052_Config_8814A(
+	IN	PADAPTER	Adapter	);
+
+#endif//__RTL8188E_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_spec.h
new file mode 100644
index 000000000..96defaf37
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_spec.h
@@ -0,0 +1,641 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8814A_SPEC_H__
+#define __RTL8814A_SPEC_H__
+
+#include <drv_conf.h>
+
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_ISO_CTRL_8814A			0x0000	// 2 Byte
+#define REG_SYS_FUNC_EN_8814A			0x0002	// 2 Byte
+#define REG_SYS_PW_CTRL_8814A			0x0004	// 4 Byte
+#define REG_SYS_CLKR_8814A				0x0008	// 2 Byte
+#define REG_SYS_EEPROM_CTRL_8814A		0x000A	// 2 Byte
+#define REG_EE_VPD_8814A				0x000C	// 2 Byte
+#define REG_SYS_SWR_CTRL1_8814A			0x0010	// 1 Byte
+#define REG_SPS0_CTRL_8814A				0x0011	// 7 Byte
+#define REG_SYS_SWR_CTRL3_8814A			0x0018	// 4 Byte
+#define REG_RSV_CTRL_8814A				0x001C	// 3 Byte
+#define REG_RF_CTRL0_8814A				0x001F	// 1 Byte
+#define REG_RF_CTRL1_8814A				0x0020	// 1 Byte
+#define REG_RF_CTRL2_8814A				0x0021	// 1 Byte
+#define REG_LPLDO_CTRL_8814A			0x0023	// 1 Byte
+#define REG_AFE_CTRL1_8814A				0x0024	// 4 Byte
+#define REG_AFE_CTRL2_8814A				0x0028	// 4 Byte
+#define REG_AFE_CTRL3_8814A				0x002c 	// 4 Byte
+#define REG_EFUSE_CTRL_8814A			0x0030
+#define REG_LDO_EFUSE_CTRL_8814A		0x0034
+#define REG_PWR_DATA_8814A				0x0038
+#define REG_CAL_TIMER_8814A				0x003C
+#define REG_ACLK_MON_8814A				0x003E
+#define REG_GPIO_MUXCFG_8814A			0x0040
+#define REG_GPIO_IO_SEL_8814A			0x0042
+#define REG_MAC_PINMUX_CFG_8814A		0x0043
+#define REG_GPIO_PIN_CTRL_8814A			0x0044
+#define REG_GPIO_INTM_8814A				0x0048
+#define REG_LEDCFG0_8814A				0x004C
+#define REG_LEDCFG1_8814A				0x004D
+#define REG_LEDCFG2_8814A				0x004E
+#define REG_LEDCFG3_8814A				0x004F
+#define REG_FSIMR_8814A					0x0050
+#define REG_FSISR_8814A					0x0054
+#define REG_HSIMR_8814A					0x0058
+#define REG_HSISR_8814A					0x005c
+#define REG_GPIO_EXT_CTRL_8814A			0x0060
+#define REG_GPIO_STATUS_8814A			0x006C
+#define REG_SDIO_CTRL_8814A				0x0070
+#define REG_HCI_OPT_CTRL_8814A			0x0074
+#define REG_RF_CTRL3_8814A				0x0076	// 1 Byte
+#define REG_AFE_CTRL4_8814A				0x0078
+#define REG_8051FW_CTRL_8814A			0x0080
+#define REG_HIMR0_8814A					0x00B0
+#define REG_HISR0_8814A					0x00B4
+#define REG_HIMR1_8814A					0x00B8
+#define REG_HISR1_8814A					0x00BC
+#define REG_SYS_CFG1_8814A				0x00F0
+#define REG_SYS_CFG2_8814A				0x00FC
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_CR_8814A						0x0100
+#define REG_PBP_8814A					0x0104
+#define REG_PKT_BUFF_ACCESS_CTRL_8814A	0x0106
+#define REG_TRXDMA_CTRL_8814A			0x010C
+#define REG_TRXFF_BNDY_8814A			0x0114
+#define REG_TRXFF_STATUS_8814A			0x0118
+#define REG_RXFF_PTR_8814A				0x011C
+#define REG_CPWM_8814A					0x012F
+#define REG_FWIMR_8814A					0x0130
+#define REG_FWISR_8814A					0x0134
+#define REG_FTIMR_8814A					0x0138
+#define REG_PKTBUF_DBG_CTRL_8814A		0x0140
+#define REG_RXPKTBUF_CTRL_8814A		0x0142
+#define REG_PKTBUF_DBG_DATA_L_8814A	0x0144
+#define REG_PKTBUF_DBG_DATA_H_8814A	0x0148
+
+#define REG_TC0_CTRL_8814A				0x0150
+#define REG_TC1_CTRL_8814A				0x0154
+#define REG_TC2_CTRL_8814A				0x0158
+#define REG_TC3_CTRL_8814A				0x015C
+#define REG_TC4_CTRL_8814A				0x0160
+#define REG_TCUNIT_BASE_8814A			0x0164
+#define REG_RSVD3_8814A					0x0168
+#define REG_C2HEVT_MSG_NORMAL_8814A	0x01A0
+#define REG_C2HEVT_CLEAR_8814A			0x01AF
+#define REG_MCUTST_1_8814A				0x01C0
+#define REG_MCUTST_WOWLAN_8814A		0x01C7
+#define REG_FMETHR_8814A				0x01C8
+#define REG_HMETFR_8814A				0x01CC
+#define REG_HMEBOX_0_8814A				0x01D0
+#define REG_HMEBOX_1_8814A				0x01D4
+#define REG_HMEBOX_2_8814A				0x01D8
+#define REG_HMEBOX_3_8814A				0x01DC
+#define REG_LLT_INIT_8814A				0x01E0
+#define REG_LLT_ADDR_8814A				0x01E4 //20130415 KaiYuan add for 8814
+#define REG_HMEBOX_EXT0_8814A			0x01F0
+#define REG_HMEBOX_EXT1_8814A			0x01F4
+#define REG_HMEBOX_EXT2_8814A			0x01F8
+#define REG_HMEBOX_EXT3_8814A			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_FIFOPAGE_CTRL_1_8814A			0x0200
+#define REG_FIFOPAGE_CTRL_2_8814A		0x0204
+#define REG_AUTO_LLT_8814A					0x0208
+#define REG_TXDMA_OFFSET_CHK_8814A	0x020C
+#define REG_TXDMA_STATUS_8814A			0x0210
+#define REG_RQPN_NPQ_8814A				0x0214
+#define REG_TQPNT1_8814A					0x0218
+#define REG_TQPNT2_8814A					0x021C
+#define REG_TQPNT3_8814A					0x0220
+#define REG_TQPNT4_8814A					0x0224
+#define REG_RQPN_CTRL_1_8814A				0x0228
+#define REG_RQPN_CTRL_2_8814A				0x022C
+#define REG_FIFOPAGE_INFO_1_8814A			0x0230
+#define REG_FIFOPAGE_INFO_2_8814A			0x0234
+#define REG_FIFOPAGE_INFO_3_8814A			0x0238
+#define REG_FIFOPAGE_INFO_4_8814A			0x023C
+#define REG_FIFOPAGE_INFO_5_8814A			0x0240
+
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_AGG_PG_TH_8814A		0x0280
+#define REG_RXPKT_NUM_8814A				0x0284 // The number of packets in RXPKTBUF.
+#define REG_RXDMA_CONTROL_8814A			0x0286 // ?????? Control the RX DMA.
+#define REG_RXDMA_STATUS_8814A			0x0288
+#define REG_RXDMA_MODE_8814A				0x0290 // ??????
+#define REG_EARLY_MODE_CONTROL_8814A	0x02BC // ??????
+#define REG_RSVD5_8814A					0x02F0 // ??????
+
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG_8814A			0x0300
+#define	REG_INT_MIG_8814A				0x0304	// Interrupt Migration
+#define	REG_BCNQ_TXBD_DESA_8814A		0x0308	// TX Beacon Descriptor Address
+#define	REG_MGQ_TXBD_DESA_8814A			0x0310	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_TXBD_DESA_8814A			0x0318	// TX VO Queue Descriptor Address
+#define	REG_VIQ_TXBD_DESA_8814A			0x0320	// TX VI Queue Descriptor Address
+#define	REG_BEQ_TXBD_DESA_8814A			0x0328	// TX BE Queue Descriptor Address
+#define	REG_BKQ_TXBD_DESA_8814A			0x0330	// TX BK Queue Descriptor Address
+#define	REG_RXQ_RXBD_DESA_8814A			0x0338	// RX Queue	Descriptor Address
+#define REG_HI0Q_TXBD_DESA_8814A		0x0340
+#define REG_HI1Q_TXBD_DESA_8814A		0x0348
+#define REG_HI2Q_TXBD_DESA_8814A		0x0350
+#define REG_HI3Q_TXBD_DESA_8814A		0x0358
+#define REG_HI4Q_TXBD_DESA_8814A		0x0360
+#define REG_HI5Q_TXBD_DESA_8814A		0x0368
+#define REG_HI6Q_TXBD_DESA_8814A		0x0370
+#define REG_HI7Q_TXBD_DESA_8814A		0x0378
+#define	REG_MGQ_TXBD_NUM_8814A			0x0380
+#define	REG_RX_RXBD_NUM_8814A			0x0382
+#define	REG_VOQ_TXBD_NUM_8814A			0x0384
+#define	REG_VIQ_TXBD_NUM_8814A			0x0386
+#define	REG_BEQ_TXBD_NUM_8814A			0x0388
+#define	REG_BKQ_TXBD_NUM_8814A			0x038A
+#define	REG_HI0Q_TXBD_NUM_8814A			0x038C
+#define	REG_HI1Q_TXBD_NUM_8814A			0x038E
+#define	REG_HI2Q_TXBD_NUM_8814A			0x0390
+#define	REG_HI3Q_TXBD_NUM_8814A			0x0392
+#define	REG_HI4Q_TXBD_NUM_8814A			0x0394
+#define	REG_HI5Q_TXBD_NUM_8814A			0x0396
+#define	REG_HI6Q_TXBD_NUM_8814A			0x0398
+#define	REG_HI7Q_TXBD_NUM_8814A			0x039A
+#define	REG_TSFTIMER_HCI_8814A			0x039C
+
+//Read Write Point
+#define	REG_VOQ_TXBD_IDX_8814A			0x03A0
+#define	REG_VIQ_TXBD_IDX_8814A			0x03A4
+#define	REG_BEQ_TXBD_IDX_8814A			0x03A8
+#define	REG_BKQ_TXBD_IDX_8814A			0x03AC
+#define	REG_MGQ_TXBD_IDX_8814A			0x03B0
+#define	REG_RXQ_TXBD_IDX_8814A			0x03B4
+#define	REG_HI0Q_TXBD_IDX_8814A			0x03B8
+#define	REG_HI1Q_TXBD_IDX_8814A			0x03BC
+#define	REG_HI2Q_TXBD_IDX_8814A			0x03C0
+#define	REG_HI3Q_TXBD_IDX_8814A			0x03C4
+#define	REG_HI4Q_TXBD_IDX_8814A			0x03C8
+#define	REG_HI5Q_TXBD_IDX_8814A			0x03CC
+#define	REG_HI6Q_TXBD_IDX_8814A			0x03D0
+#define	REG_HI7Q_TXBD_IDX_8814A			0x03D4
+#define REG_DBG_SEL_V1_8814A				0x03D8
+#define REG_PCIE_HRPWM1_V1_8814A			0x03D9
+#define REG_PCIE_HCPWM1_V1_8814A			0x03DA
+#define REG_PCIE_CTRL2_8814A				0x03DB
+#define REG_PCIE_HRPWM2_V1_8814A			0x03DC
+#define REG_PCIE_HCPWM2_V1_8814A			0x03DE
+#define REG_PCIE_H2C_MSG_V1_8814A		0x03E0
+#define REG_PCIE_C2H_MSG_V1_8814A		0x03E4
+#define REG_DBI_WDATA_V1_8814A			0x03E8
+#define REG_DBI_RDATA_V1_8814A			0x03EC
+#define REG_DBI_FLAG_V1_8814A				0x03F0
+#define REG_MDIO_V1_8814A					0x03F4
+#define REG_PCIE_MIX_CFG_8814A			0x03F8
+#define REG_DBG_8814A						0x03FC
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_VOQ_INFORMATION_8814A		0x0400
+#define REG_VIQ_INFORMATION_8814A		0x0404
+#define REG_BEQ_INFORMATION_8814A		0x0408
+#define REG_BKQ_INFORMATION_8814A		0x040C
+#define REG_MGQ_INFORMATION_8814A		0x0410
+#define REG_HGQ_INFORMATION_8814A		0x0414
+#define REG_BCNQ_INFORMATION_8814A	0x0418
+#define REG_TXPKT_EMPTY_8814A			0x041A
+#define REG_CPU_MGQ_INFORMATION_8814A	0x041C
+#define REG_FWHW_TXQ_CTRL_8814A		0x0420
+#define REG_HWSEQ_CTRL_8814A			0x0423
+#define REG_TXPKTBUF_BCNQ_BDNY_8814A	0x0424
+//#define REG_MGQ_BDNY_8814A				0x0425
+#define REG_LIFETIME_EN_8814A				0x0426
+//#define REG_FW_FREE_TAIL_8814A			0x0427
+#define REG_SPEC_SIFS_8814A				0x0428
+#define REG_RETRY_LIMIT_8814A				0x042A
+#define REG_TXBF_CTRL_8814A				0x042C
+#define REG_DARFRC_8814A				0x0430
+#define REG_RARFRC_8814A				0x0438
+#define REG_RRSR_8814A					0x0440
+#define REG_ARFR0_8814A					0x0444
+#define REG_ARFR1_8814A					0x044C
+#define REG_CCK_CHECK_8814A				0x0454
+#define REG_AMPDU_MAX_TIME_8814A			0x0455
+#define REG_TXPKTBUF_BCNQ1_BDNY_8814A	0x0456
+#define REG_AMPDU_MAX_LENGTH_8814A	0x0458
+#define REG_ACQ_STOP_8814A				0x045C
+#define REG_NDPA_RATE_8814A				0x045D
+#define REG_TX_HANG_CTRL_8814A			0x045E
+#define REG_NDPA_OPT_CTRL_8814A		0x045F
+#define REG_FAST_EDCA_CTRL_8814A		0x0460
+#define REG_RD_RESP_PKT_TH_8814A		0x0463
+#define REG_CMDQ_INFO_8814A 				0x0464
+#define REG_Q4_INFO_8814A 					0x0468
+#define REG_Q5_INFO_8814A 					0x046C
+#define REG_Q6_INFO_8814A 					0x0470
+#define REG_Q7_INFO_8814A 					0x0474
+#define REG_WMAC_LBK_BUF_HD_8814A		0x0478
+#define REG_MGQ_PGBNDY_8814A 				0x047A
+#define REG_INIRTS_RATE_SEL_8814A 			0x0480
+#define REG_BASIC_CFEND_RATE_8814A 		0x0481
+#define REG_STBC_CFEND_RATE_8814A 		0x0482
+#define REG_DATA_SC_8814A					0x0483
+#define REG_MACID_SLEEP3_8814A 			0x0484
+#define REG_MACID_SLEEP1_8814A 			0x0488
+#define REG_ARFR2_8814A 					0x048C
+#define REG_ARFR3_8814A 					0x0494
+#define REG_ARFR4_8814A 					0x049C
+#define REG_ARFR5_8814A 					0x04A4
+#define REG_TXRPT_START_OFFSET_8814A		0x04AC
+#define REG_TRYING_CNT_TH_8814A 			0x04B0
+#define REG_POWER_STAGE1_8814A		0x04B4
+#define REG_POWER_STAGE2_8814A		0x04B8
+#define REG_SW_AMPDU_BURST_MODE_CTRL_8814A	0x04BC
+#define REG_PKT_LIFE_TIME_8814A			0x04C0
+#define REG_PKT_BE_BK_LIFE_TIME_8814A		0x04C2 // ??????
+#define REG_STBC_SETTING_8814A			0x04C4
+#define REG_STBC_8814A						0x04C5
+#define REG_QUEUE_CTRL_8814A 				0x04C6
+#define REG_SINGLE_AMPDU_CTRL_8814A 		0x04C7
+#define REG_PROT_MODE_CTRL_8814A		0x04C8
+#define REG_MAX_AGGR_NUM_8814A		0x04CA
+#define REG_RTS_MAX_AGGR_NUM_8814A	0x04CB
+#define REG_BAR_MODE_CTRL_8814A		0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT_8814A	0x04CF
+#define REG_MACID_SLEEP2_8814A			0x04D0
+#define REG_MACID_SLEEP0_8814A			0x04D4
+#define REG_HW_SEQ0_8814A 				0x04D8
+#define REG_HW_SEQ1_8814A 				0x04DA
+#define REG_HW_SEQ2_8814A 				0x04DC
+#define REG_HW_SEQ3_8814A 				0x04DE
+#define REG_NULL_PKT_STATUS_8814A 			0x04E0
+#define REG_PTCL_ERR_STATUS_8814A 			0x04E2
+#define REG_DROP_PKT_NUM_8814A 			0x04EC
+#define REG_PTCL_TX_RPT_8814A 				0x04F0
+#define REG_Dummy_8814A 					0x04FC
+
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_EDCA_VO_PARAM_8814A			0x0500
+#define REG_EDCA_VI_PARAM_8814A			0x0504
+#define REG_EDCA_BE_PARAM_8814A			0x0508
+#define REG_EDCA_BK_PARAM_8814A			0x050C
+#define REG_BCNTCFG_8814A					0x0510
+#define REG_PIFS_8814A						0x0512
+#define REG_RDG_PIFS_8814A					0x0513
+#define REG_SIFS_CTX_8814A					0x0514
+#define REG_SIFS_TRX_8814A					0x0516
+#define REG_AGGR_BREAK_TIME_8814A			0x051A
+#define REG_SLOT_8814A						0x051B
+#define REG_TX_PTCL_CTRL_8814A				0x0520
+#define REG_TXPAUSE_8814A					0x0522
+#define REG_DIS_TXREQ_CLR_8814A			0x0523
+#define REG_RD_CTRL_8814A					0x0524
+//
+// Format for offset 540h-542h:
+//	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
+//	[7:4]:   Reserved.
+//	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
+//	[23:20]: Reserved
+// Description:
+//	              |
+//     |<--Setup--|--Hold------------>|
+//	--------------|----------------------
+//                |
+//               TBTT
+// Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
+// Described by Designer Tim and Bruce, 2011-01-14.
+//
+#define REG_TBTT_PROHIBIT_8814A			0x0540
+#define REG_RD_NAV_NXT_8814A				0x0544
+#define REG_NAV_PROT_LEN_8814A			0x0546
+#define REG_BCN_CTRL_8814A					0x0550
+#define REG_BCN_CTRL_1_8814A				0x0551
+#define REG_MBID_NUM_8814A				0x0552
+#define REG_DUAL_TSF_RST_8814A				0x0553
+#define REG_MBSSID_BCN_SPACE_8814A		0x0554
+#define REG_DRVERLYINT_8814A				0x0558
+#define REG_BCNDMATIM_8814A				0x0559
+#define REG_ATIMWND_8814A					0x055A
+#define REG_USTIME_TSF_8814A				0x055C
+#define REG_BCN_MAX_ERR_8814A				0x055D
+#define REG_RXTSF_OFFSET_CCK_8814A		0x055E
+#define REG_RXTSF_OFFSET_OFDM_8814A		0x055F
+#define REG_TSFTR_8814A						0x0560
+#define REG_CTWND_8814A					0x0572
+#define REG_SECONDARY_CCA_CTRL_8814A		0x0577 // ??????
+#define REG_PSTIMER_8814A					0x0580
+#define REG_TIMER0_8814A					0x0584
+#define REG_TIMER1_8814A					0x0588
+#define REG_BCN_PREDL_ITV_8814A			0x058F	//Pre download beacon interval
+#define REG_ACMHWCTRL_8814A				0x05C0
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_MAC_CR_8814A					0x0600
+#define REG_TCR_8814A						0x0604
+#define REG_RCR_8814A						0x0608
+#define REG_RX_PKT_LIMIT_8814A				0x060C
+#define REG_RX_DLK_TIME_8814A				0x060D
+#define REG_RX_DRVINFO_SZ_8814A			0x060F
+
+#define REG_MACID_8814A					0x0610
+#define REG_BSSID_8814A						0x0618
+#define REG_MAR_8814A						0x0620
+#define REG_MBIDCAMCFG_8814A				0x0628
+
+#define REG_USTIME_EDCA_8814A				0x0638
+#define REG_MAC_SPEC_SIFS_8814A			0x063A
+#define REG_RESP_SIFP_CCK_8814A			0x063C
+#define REG_RESP_SIFS_OFDM_8814A			0x063E
+#define REG_ACKTO_8814A					0x0640
+#define REG_CTS2TO_8814A					0x0641
+#define REG_EIFS_8814A						0x0642
+
+#define	REG_NAV_UPPER_8814A				0x0652	// unit of 128
+#define REG_TRXPTCL_CTL_8814A				0x0668
+
+// Security
+#define REG_CAMCMD_8814A					0x0670
+#define REG_CAMWRITE_8814A				0x0674
+#define REG_CAMREAD_8814A					0x0678
+#define REG_CAMDBG_8814A					0x067C
+#define REG_SECCFG_8814A					0x0680
+
+// Power
+#define REG_WOW_CTRL_8814A				0x0690
+#define REG_PS_RX_INFO_8814A				0x0692
+#define REG_UAPSD_TID_8814A				0x0693
+#define REG_WKFMCAM_NUM_8814A			0x0698
+#define REG_RXFLTMAP0_8814A				0x06A0
+#define REG_RXFLTMAP1_8814A				0x06A2
+#define REG_RXFLTMAP2_8814A				0x06A4
+#define REG_BCN_PSR_RPT_8814A				0x06A8
+#define REG_BT_COEX_TABLE_8814A			0x06C0
+#define REG_TX_DATA_RSP_RATE_8814A		0x06DE
+#define REG_ASSOCIATED_BFMER0_INFO_8814A	0x06E4
+#define REG_ASSOCIATED_BFMER1_INFO_8814A	0x06EC
+#define REG_CSI_RPT_PARAM_BW20_8814A		0x06F4
+#define REG_CSI_RPT_PARAM_BW40_8814A		0x06F8
+#define REG_CSI_RPT_PARAM_BW80_8814A		0x06FC
+
+// Hardware Port 2
+#define REG_MACID1_8814A					0x0700
+#define REG_BSSID1_8814A					0x0708
+// Hardware Port 3
+#define REG_MACID2_8814A					0x1620
+#define REG_BSSID2_8814A					0x1628
+// Hardware Port 4
+#define REG_MACID3_8814A					0x1630
+#define REG_BSSID3_8814A					0x1638
+// Hardware Port 5
+#define REG_MACID4_8814A					0x1640
+#define REG_BSSID4_8814A					0x1648
+
+#define REG_ASSOCIATED_BFMEE_SEL_8814A	0x0714
+#define REG_SND_PTCL_CTRL_8814A			0x0718
+#define REG_IQ_DUMP_8814A					0x07C0
+
+/**** page 19 ****/
+//TX BeamForming
+#define	REG_BB_TXBF_ANT_SET_BF1				0x19ac
+#define	REG_BB_TXBF_ANT_SET_BF0				0x19b4
+
+//	0x1200h ~ 0x12FFh	DDMA CTRL
+//
+//-----------------------------------------------------
+#define REG_DDMA_CH0SA                   0x1200
+#define REG_DDMA_CH0DA                   0x1204
+#define REG_DDMA_CH0CTRL                0x1208
+#define REG_DDMA_CH1SA                   0x1210
+#define REG_DDMA_CH1DA                	0x1214
+#define REG_DDMA_CH1CTRL                0x1218
+#define REG_DDMA_CH2SA                   0x1220
+#define REG_DDMA_CH2DA                   0x1224
+#define REG_DDMA_CH2CTRL                0x1228
+#define REG_DDMA_CH3SA                   0x1230
+#define REG_DDMA_CH3DA                   0x1234
+#define REG_DDMA_CH3CTRL                0x1238
+#define REG_DDMA_CH4SA                   0x1240
+#define REG_DDMA_CH4DA                   0x1244
+#define REG_DDMA_CH4CTRL                0x1248
+#define REG_DDMA_CH5SA                   0x1250
+#define REG_DDMA_CH5DA                   0x1254
+#define REG_DDMA_CH5CTRL                0x1258
+#define REG_DDMA_INT_MSK                0x12E0
+#define REG_DDMA_CHSTATUS              0x12E8
+#define REG_DDMA_CHKSUM                 0x12F0
+#define REG_DDMA_MONITER                0x12FC
+
+#define DDMA_LEN_MASK              	 	0x0001FFFF
+#define FW_CHKSUM_DUMMY_SZ		8
+#define DDMA_CH_CHKSUM_CNT		BIT(24)
+#define DDMA_RST_CHKSUM_STS		BIT(25)
+#define DDMA_MODE_BLOCK_CPU		BIT(26)
+#define DDMA_CHKSUM_FAIL			BIT(27)
+#define DDMA_DA_W_DISABLE			BIT(28)
+#define DDMA_CHKSUM_EN			BIT(29)
+#define DDMA_CH_OWN                 	BIT(31)
+
+
+//3081 FWDL
+#define FWDL_EN                 BIT0
+#define IMEM_BOOT_DL_RDY        BIT1
+#define IMEM_BOOT_CHKSUM_FAIL   BIT2
+#define IMEM_DL_RDY             BIT3
+#define IMEM_CHKSUM_OK        BIT4
+#define DMEM_DL_RDY             BIT5
+#define DMEM_CHKSUM_OK        BIT6
+#define EMEM_DL_RDY             BIT7
+#define EMEM_CHKSUM_FAIL        BIT8
+#define EMEM_TXBUF_DL_RDY       BIT9
+#define EMEM_TXBUF_CHKSUM_FAIL  BIT10
+#define CPU_CLK_SWITCH_BUSY     BIT11
+#define CPU_CLK_SEL             (BIT12|BIT13)
+#define FWDL_OK                 BIT14
+#define FW_INIT_RDY             BIT15
+#define R_EN_BOOT_FLASH         BIT20
+
+#define OCPBASE_IMEM_3081        0x00000000
+#define OCPBASE_DMEM_3081        0x00200000
+#define OCPBASE_RPTBUF_3081      0x18660000
+#define OCPBASE_RXBUF2_3081      0x18680000
+#define OCPBASE_RXBUF_3081       0x18700000
+#define OCPBASE_TXBUF_3081       0x18780000
+
+
+#define REG_FAST_EDCA_VOVI_SETTING_8814A 0x1448
+#define REG_FAST_EDCA_BEBK_SETTING_8814A 0x144C
+
+
+//-----------------------------------------------------
+//
+
+
+//-----------------------------------------------------
+//
+//	Redifine 8192C register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+#define	EFUSE_CTRL_8814A					REG_EFUSE_CTRL_8814A		// E-Fuse Control.
+#define	EFUSE_TEST_8814A					REG_LDO_EFUSE_CTRL_8814A		// E-Fuse Test.
+#define	MSR_8814A							(REG_CR_8814A + 2)		// Media Status register
+#define	ISR_8814A							REG_HISR0_8814A
+#define	TSFR_8814A							REG_TSFTR_8814A			// Timing Sync Function Timer Register.
+
+#define PBP_8814A							REG_PBP_8814A
+
+// Redifine MACID register, to compatible prior ICs.
+#define	IDR0_8814A							REG_MACID_8814A			// MAC ID Register, Offset 0x0050-0x0053
+#define	IDR4_8814A							(REG_MACID_8814A + 4)	// MAC ID Register, Offset 0x0054-0x0055
+
+
+//
+// 9. Security Control Registers	(Offset: )
+//
+#define	RWCAM_8814A						REG_CAMCMD_8814A		//IN 8190 Data Sheet is called CAMcmd
+#define	WCAMI_8814A						REG_CAMWRITE_8814A		// Software write CAM input content
+#define	RCAMO_8814A						REG_CAMREAD_8814A		// Software read/write CAM config
+#define	CAMDBG_8814A						REG_CAMDBG_8814A
+#define	SECR_8814A							REG_SECCFG_8814A		//Security Configuration Register
+
+
+//----------------------------------------------------------------------------
+//       8195 IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8814A					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8814A					BIT31		// Timeout interrupt 2
+#define	IMR_TIMER1_8814A					BIT30		// Timeout interrupt 1
+#define	IMR_PSTIMEOUT_8814A				BIT29		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8814A					BIT28		// When GTIMER4 expires, this bit is set to 1
+#define	IMR_GTINT3_8814A					BIT27		// When GTIMER3 expires, this bit is set to 1
+#define	IMR_TXBCN0ERR_8814A				BIT26		// Transmit Beacon0 Error
+#define	IMR_TXBCN0OK_8814A					BIT25		// Transmit Beacon0 OK
+#define	IMR_TSF_BIT32_TOGGLE_8814A		BIT24		// TSF Timer BIT32 toggle indication interrupt
+#define	IMR_BCNDMAINT0_8814A				BIT20		// Beacon DMA Interrupt 0
+#define	IMR_BCNDERR0_8814A					BIT16		// Beacon Queue DMA OK0
+#define	IMR_HSISR_IND_ON_INT_8814A		BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8814A				BIT14		// Beacon DMA Interrupt Extension for Win7
+#define	IMR_ATIMEND_8814A					BIT12		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8814A					BIT10		// CPU to Host Command INT Status, Write 1 clear
+#define	IMR_CPWM2_8814A					BIT9			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_CPWM_8814A						BIT8			// CPU power Mode exchange INT Status, Write 1 clear
+#define	IMR_HIGHDOK_8814A					BIT7			// High Queue DMA OK
+#define	IMR_MGNTDOK_8814A					BIT6			// Management Queue DMA OK
+#define	IMR_BKDOK_8814A					BIT5			// AC_BK DMA OK
+#define	IMR_BEDOK_8814A					BIT4			// AC_BE DMA OK
+#define	IMR_VIDOK_8814A					BIT3			// AC_VI DMA OK
+#define	IMR_VODOK_8814A					BIT2			// AC_VO DMA OK
+#define	IMR_RDU_8814A						BIT1			// Rx Descriptor Unavailable
+#define	IMR_ROK_8814A						BIT0			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_MCUERR_8814A						BIT28		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT7_8814A				BIT27		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8814A				BIT26		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8814A				BIT25		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8814A				BIT24		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8814A				BIT23		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8814A				BIT22		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8814A				BIT21		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8814A					BIT20		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8814A					BIT19		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8814A					BIT18		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8814A					BIT17		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8814A					BIT16		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8814A					BIT15		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8814A					BIT14		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8814A				BIT13		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8814A					BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8814A					BIT10		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8814A					BIT9			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8814A					BIT8			// Receive FIFO Overflow
+
+
+#ifdef CONFIG_PCI_HCI
+#define IMR_TX_MASK			(IMR_VODOK_8814A | IMR_VIDOK_8814A | IMR_BEDOK_8814A | IMR_BKDOK_8814A | IMR_MGNTDOK_8814A | IMR_HIGHDOK_8814A)
+
+#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_8814A | IMR_TXBCN0OK_8814A | IMR_TXBCN0ERR_8814A | IMR_BCNDERR0_8814A)
+
+#define RT_AC_INT_MASKS	(IMR_VIDOK_8814A | IMR_VODOK_8814A | IMR_BEDOK_8814A | IMR_BKDOK_8814A)
+#endif
+
+
+/*===================================================================
+=====================================================================
+Here the register defines are for 92C. When the define is as same with 92C,
+we will use the 92C's define for the consistency
+So the following defines for 92C is not entire!!!!!!
+=====================================================================
+=====================================================================*/
+
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+
+//2 Special Option
+#define USB_AGG_EN_8814A			BIT(7)
+#define REG_USB_HRPWM_U3			0xF052
+
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8814A       2048-1	//20130415 KaiYuan add for 8814
+
+#define MACID_NUM_8814A 128
+#define SEC_CAM_ENT_NUM_8814A 64
+#define NSS_NUM_8814A 3
+#define BAND_CAP_8814A (BAND_CAP_2G | BAND_CAP_5G)
+#define BW_CAP_8814A (BW_CAP_20M | BW_CAP_40M | BW_CAP_80M)
+
+#endif //__RTL8814A_SPEC_H__
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_sreset.h
new file mode 100644
index 000000000..eda21fd4c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_sreset.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL88814A_SRESET_H_
+#define _RTL8814A_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+extern void rtl8814_sreset_xmit_status_check(_adapter *padapter);
+extern void rtl8814_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_xmit.h
new file mode 100644
index 000000000..883b91920
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8814a_xmit.h
@@ -0,0 +1,309 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8814A_XMIT_H__
+#define __RTL8814A_XMIT_H__
+
+typedef struct txdescriptor_8814
+{
+	// Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 ls:1;
+}TXDESC_8814, *PTXDESC_8814;
+
+
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+
+
+
+#ifdef CONFIG_SDIO_HCI
+#define SET_TX_DESC_SDIO_TXSEQ_8814A(__pTxDesc, __Value)			SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 16, 8, __Value)
+#endif //CONFIG_SDIO_HCI
+
+//-----------------------------------------------------------------
+//	RTL8814A TX BUFFER DESC
+//-----------------------------------------------------------------
+/*
+- Each TXBD has 4 segment.
+ -- For 32 bit, each segment is 8 bytes.
+ -- For 64 bit, each segment is 16 bytes.
+*/
+#if 0
+#if 1 /* 32 bit */
+#define SET_TX_EXTBUFF_DESC_LEN_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*8), 0, 16, __Value)
+#define SET_TX_EXTBUFF_DESC_ADDR_LOW_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*8)+4, 0, 32, __Value)
+#else /* 64 bit */
+#define SET_TX_EXTBUFF_DESC_LEN_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*16), 0, 16, __Value)
+#define SET_TX_EXTBUFF_DESC_ADDR_LOW_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*16)+4, 0, 32, __Value)
+#endif
+#define SET_TX_EXTBUFF_DESC_ADDR_HIGH_8814A(__pTxDesc, __Value, __Set) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Set*16)+8, 0, 32, __Value)
+#endif
+/*c2h-DWORD 2*/
+#define GET_RX_STATUS_DESC_RPT_SEL_8814A(__pRxDesc)			LE_BITS_TO_4BYTE(__pRxDesc+8, 28, 1)
+
+//=========================================================
+// for Txfilldescroptor8814Ae, fill the desc content.
+#if 1 /* 32 bit */
+#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*8), 0, 16, __Valeu)
+#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*8), 31, 1, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*8)+4, 0, 32, __Valeu)
+#else /* 64 bit */
+#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 0, 16, __Valeu)
+#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16), 31, 1, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+4, 0, 32, __Valeu)
+#endif
+#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+((__Offset)*16)+8, 0, 32, __Valeu)
+
+//=========================================================
+
+//TX buffer
+//=============
+// Dword 0
+#define SET_TX_BUFF_DESC_LEN_0_8814A(__pTxDesc, __Valeu) 			SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Valeu)
+#define SET_TX_BUFF_DESC_PSB_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
+#define SET_TX_BUFF_DESC_OWN_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+#define GET_TX_BUFF_DESC_OWN_8814A(__pTxDesc)				LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
+
+// Dword 1
+#define SET_TX_BUFF_DESC_ADDR_LOW_0_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
+#define GET_TX_BUFF_DESC_ADDR_LOW_0_8814A(__pTxDesc)			LE_BITS_TO_4BYTE(__pTxDesc+4, 0, 32)
+// Dword 2
+#define SET_TX_BUFF_DESC_ADDR_HIGH_0_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
+#define GET_TX_BUFF_DESC_ADDR_HIGH_0_8814A(__pTxDesc)			LE_BITS_TO_4BYTE(__pTxDesc+8, 0, 32)
+// Dword 3 //RESERVED 0
+
+#if 0 /* 64 bit */
+// Dword 4
+#define SET_TX_BUFF_DESC_LEN_1_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 16, __Value)
+#define SET_TX_BUFF_DESC_AMSDU_1_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 31, 1, __Value)
+// Dword 5
+#define SET_TX_BUFF_DESC_ADDR_LOW_1_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 32, __Value)
+// Dword 6
+#define SET_TX_BUFF_DESC_ADDR_HIGH_1_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 32, __Value)
+// Dword 7 //RESERVED 0
+// Dword 8
+#define SET_TX_BUFF_DESC_LEN_2_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 16, __Value)
+#define SET_TX_BUFF_DESC_AMSDU_2_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 31, 1, __Value)
+// Dword 9
+#define SET_TX_BUFF_DESC_ADDR_LOW_2_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 32, __Value)
+// Dword 10
+#define SET_TX_BUFF_DESC_ADDR_HIGH_2_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
+// Dword 11 //RESERVED 0
+// Dword 12
+#define SET_TX_BUFF_DESC_LEN_3_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 16, __Value)
+#define SET_TX_BUFF_DESC_AMSDU_3_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 31, 1, __Value)
+// Dword 13
+#define SET_TX_BUFF_DESC_ADDR_LOW_3_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+52, 0, 32, __Value)
+// Dword 14
+#define SET_TX_BUFF_DESC_ADDR_HIGH_3_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+56, 0, 32, __Value)
+// Dword 15 //RESERVED 0
+#endif
+
+//=====Desc content
+//TX Info
+//=============
+// Dword 0
+#define SET_TX_DESC_PKT_SIZE_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
+#define GET_TX_DESC_PKT_SIZE_8814A(__pTxDesc)									LE_BITS_TO_4BYTE( __pTxDesc, 0, 16)
+#define SET_TX_DESC_OFFSET_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
+#define GET_TX_DESC_OFFSET_8814A(__pTxDesc)									LE_BITS_TO_4BYTE( __pTxDesc, 16, 8)
+#define SET_TX_DESC_BMC_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC_8814A(__pTxDesc, __Value) 								SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_LINIP_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
+#define SET_TX_DESC_AMSDU_PAD_EN_8814A(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
+#define SET_TX_DESC_NO_ACM_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
+#define SET_TX_DESC_GF_8814A(__pTxDesc, __Value) 								SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_DISQSELSEQ_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+
+// Dword 1
+#define SET_TX_DESC_MACID_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT_8814A(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN_8814A(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID_8814A(__pTxDesc, __Value) 							SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 24, 5, __Value)
+#define SET_TX_DESC_MORE_DATA_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 29, 1, __Value)
+#define SET_TX_DESC_TXOP_PS_CAP_8814A(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 30, 1, __Value)
+#define SET_TX_DESC_TXOP_PS_MODE_8814A(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 31, 1, __Value)
+
+
+// Dword 2
+#define SET_TX_DESC_PAID_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 13, 1, __Value)
+#define SET_TX_DESC_NULL_0_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 14, 1, __Value)
+#define SET_TX_DESC_NULL_1_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 15, 1, __Value)
+#define SET_TX_DESC_BK_8814A(__pTxDesc, __Value) 				SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 17, 1, __Value)
+#define GET_TX_DESC_MORE_FRAG_8814A(__pTxDesc)				LE_BITS_TO_4BYTE( __pTxDesc+8, 17, 1)
+#define SET_TX_DESC_RAW_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 18, 1, __Value)
+#define SET_TX_DESC_SPE_RPT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_NULL_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 6, __Value)
+#define SET_TX_DESC_HW_AES_IV_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 31, 1, __Value)
+
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 0, 5, __Value)
+#define SET_TX_DESC_EARLY_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HW_SSN_SEL_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 13, 1, __Value)
+#define SET_TX_DESC_CHECK_EN_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 14, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 0, 7, __Value)
+#define SET_TX_DESC_TRY_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 7, 1, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 24, 5, __Value)
+#define SET_TX_DESC_PCTS_ENABLE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 29, 1, __Value)
+#define SET_TX_DESC_PCTS_MASK_IDX_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+16, 30, 2, __Value)
+
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT_8814A(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 8, 2, __Value)
+#define SET_TX_DESC_CTROL_STBC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 13, 4, __Value)
+#define SET_TX_DESC_SIGNALING_TA_PKT_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 17, 1, __Value)
+#define SET_TX_DESC_PORT_ID_8814A(__pTxDesc,__Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 21, 3, __Value)//20130415 KaiYuan add for 8814
+#define SET_TX_DESC_TX_ANT_8814A(__pTxDesc,__Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 24, 4, __Value)
+#define SET_TX_DESC_TX_POWER_OFFSET_8814A(__pTxDesc,__Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+20, 28, 3, __Value)
+
+// Dword 6
+#define SET_TX_DESC_SW_DEFINE_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_MBSSID_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
+#define SET_TX_DESC_ANTSEL_A_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
+#define SET_TX_DESC_ANTSEL_B_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
+#define SET_TX_DESC_ANT_MAPA_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 2, __Value)
+#define SET_TX_DESC_ANT_MAPB_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 24, 2, __Value)
+#define SET_TX_DESC_ANT_MAPC_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 26, 2, __Value)
+#define SET_TX_DESC_ANT_MAPD_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 28, 2, __Value)
+
+
+// Dword 7
+#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)
+#define SET_TX_DESC_TX_BUFFER_SIZE_8814A(__pTxDesc, __Value) 		SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#else
+#define SET_TX_DESC_TX_DESC_CHECKSUM_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 0, 16, __Value)
+#endif
+#define SET_TX_DESC_NTX_MAP_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 20, 4, __Value)
+#define SET_TX_DESC_USB_TXAGG_NUM_8814A(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 24, 8, __Value)
+
+
+// Dword 8
+#define SET_TX_DESC_RTS_RC_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 0, 6, __Value)
+#define SET_TX_DESC_BAR_RTY_TH_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 6, 2, __Value)
+#define SET_TX_DESC_DATA_RC_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 8, 6, __Value)
+#define SET_TX_DESC_EN_HWEXSEQ_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 14, 1, __Value)
+#define SET_TX_DESC_HWSEQ_EN_8814A(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 15, 1, __Value)
+#if(DEV_BUS_TYPE != RT_SDIO_INTERFACE)
+#define SET_TX_DESC_NEXT_HEAD_PAGE_L_8814A(__pTxDesc,__Value)(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value)
+#else
+#define SET_TX_DESC_SDIO_SEQ_8814A(__pTxDesc,__Value)(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 16, 8, __Value) //20130415 KaiYuan add for 8814AS
+#endif
+#define SET_TX_DESC_TAIL_PAGE_L_8814A(__pTxDesc,__Value)(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+32, 24, 8, __Value)
+
+// Dword 9
+#define SET_TX_DESC_PADDING_LENGTH_8814A(__pTxDesc, __Value) 						SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 0, 11, __Value)
+#define SET_TX_DESC_TXBF_PATH_8814A(__pTxDesc, __Value) 								SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 11, 1, __Value)
+#define SET_TX_DESC_SEQ_8814A(__pTxDesc, __Value) 										SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
+#define SET_TX_DESC_NEXT_HEAD_PAGE_H_8814A(__pTxDesc,__Value)(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 4, __Value)
+#define SET_TX_DESC_TAIL_PAGE_H_8814A(__pTxDesc,__Value)(__pTxDesc, __Value) 			SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 28, 4, __Value)
+
+
+
+#define SET_EARLYMODE_PKTNUM_8814A(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0_8814A(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1_8814A(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2_8814A(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2_8814A(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
+#define SET_EARLYMODE_LEN3_8814A(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+
+void rtl8814a_cal_txdesc_chksum(u8 *ptxdesc);
+void rtl8814a_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,u8 IsPsPoll,u8	IsBTQosNull, u8 bDataFrame);
+void rtl8814a_fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
+void rtl8814a_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
+void rtl8814a_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
+
+#ifdef CONFIG_USB_HCI
+s32 rtl8814au_init_xmit_priv(PADAPTER padapter);
+void rtl8814au_free_xmit_priv(PADAPTER padapter);
+s32 rtl8814au_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8814au_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	 rtl8814au_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtl8814au_xmit_buf_handler(PADAPTER padapter);
+void rtl8814au_xmit_tasklet(void *priv);
+s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+#endif //CONFIG_USB_HCI
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8814ae_init_xmit_priv(PADAPTER padapter);
+void rtl8814ae_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf *rtl8814ae_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+void rtl8814ae_xmitframe_resume(_adapter *padapter);
+s32 rtl8814ae_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8814ae_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8814ae_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtl8814ae_xmit_tasklet(void *priv);
+#endif
+
+void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag, u8 *ptxdesc);
+u8
+SCMapping_8814(
+	IN	PADAPTER		Adapter,
+	IN	struct pkt_attrib	*pattrib
+);
+
+u8
+BWMapping_8814(
+	IN	PADAPTER		Adapter,
+	IN	struct pkt_attrib	*pattrib
+);
+
+
+#endif /* __RTL8814_XMIT_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_spec.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_spec.h
new file mode 100644
index 000000000..01f13826f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_spec.h
@@ -0,0 +1,107 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8821A_SPEC_H__
+#define __RTL8821A_SPEC_H__
+
+#include <drv_conf.h>
+// This file should based on "hal_com_reg.h"
+#include <hal_com_reg.h>
+// Because 8812a and 8821a is the same serial,
+// most of 8821a register definitions are the same as 8812a.
+#include <rtl8812a_spec.h>
+
+
+//============================================================
+//       8821A Regsiter offset definition
+//============================================================
+
+//============================================================
+// MAC register
+//============================================================
+
+//-----------------------------------------------------
+//	0x0000h ~ 0x00FFh	System Configuration
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//-----------------------------------------------------
+#define REG_WOWLAN_WAKE_REASON          REG_MCUTST_WOWLAN
+
+//-----------------------------------------------------
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//	0x0300h ~ 0x03FFh	PCIe
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//-----------------------------------------------------
+
+
+//============================================================
+// SDIO Bus Specification
+//============================================================
+
+//-----------------------------------------------------
+// SDIO CMD Address Mapping
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// I/O bus domain (Host)
+//-----------------------------------------------------
+
+//-----------------------------------------------------
+// SDIO register
+//-----------------------------------------------------
+#undef SDIO_REG_HCPWM1
+#define SDIO_REG_FREE_TXPG2		0x024
+#define SDIO_REG_HCPWM1			0x025
+
+
+//============================================================
+//       Regsiter Bit and Content definition
+//============================================================
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8821A 128
+#define SEC_CAM_ENT_NUM_8821A 64
+#define NSS_NUM_8821A 1
+#define BAND_CAP_8821A (BAND_CAP_2G | BAND_CAP_5G)
+#define BW_CAP_8821A (BW_CAP_20M | BW_CAP_40M | BW_CAP_80M)
+
+#endif /* __RTL8821A_SPEC_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_xmit.h
new file mode 100644
index 000000000..8128f8025
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtl8821a_xmit.h
@@ -0,0 +1,180 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8821A_XMIT_H__
+#define __RTL8821A_XMIT_H__
+
+#include <drv_types.h>
+
+typedef struct txdescriptor_8821a
+{
+	// Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 rsvd0026:1;
+	u32 rsvd0027:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 rsvd0031:1;
+
+	// Offset 4
+	u32 macid:7;
+	u32 rsvd0407:1;
+	u32 qsel:5;
+	u32 rdg_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:5;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 pkt_offset:5; // unit: 8 bytes
+	u32 moredata:1;
+	u32 txop_ps_cap:1;
+	u32 txop_ps_mode:1;
+
+	// Offset 8
+	u32 p_aid:9;
+	u32 rsvd0809:1;
+	u32 cca_rts:2;
+	u32 agg_en:1;
+	u32 rdg_en:1;
+	u32 null_0:1;
+	u32 null_1:1;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 spe_rpt:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 g_id:6;
+	u32 rsvd0830:2;
+
+	// Offset 12
+	u32 wheader_len:4;
+	u32 chk_en:1;
+	u32 early_rate:1;
+	u32 hw_ssn_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 navusehdr:1;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 ndpa:2;
+	u32 ampdu_max_time:8;
+
+	// Offset 16
+	u32 datarate:7;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 rtsrate:5;
+	u32 pcts_en:1;
+	u32 pcts_mask_idx:2;
+
+	// Offset 20
+	u32 data_sc:4;
+	u32 data_short:1;
+	u32 data_bw:2;
+	u32 data_ldpc:1;
+	u32 data_stbc:2;
+	u32 vcs_stbc:2;
+	u32 rts_short:1;
+	u32 rts_sc:4;
+	u32 rsvd2016:7;
+	u32 tx_ant:4;
+	u32 txpwr_offset:3;
+	u32 rsvd2031:1;
+
+	// Offset 24
+	u32 sw_define:12;
+	u32 mbssid:4;
+	u32 antsel_A:3;
+	u32 antsel_B:3;
+	u32 antsel_C:3;
+	u32 antsel_D:3;
+	u32 rsvd2428:4;
+
+	// Offset 28
+	u32 checksum:16;
+	u32 rsvd2816:8;
+	u32 usb_txagg_num:8;
+
+	// Offset 32
+	u32 rts_rc:6;
+	u32 bar_rty_th:2;
+	u32 data_rc:6;
+	u32 rsvd3214:1;
+	u32 en_hwseq:1;
+	u32 nextneadpage:8;
+	u32 tailpage:8;
+
+	// Offset 36
+	u32 padding_len:11;
+	u32 txbf_path:1;
+	u32 seq:12;
+	u32 final_data_rate:8;
+}TXDESC_8821A, *PTXDESC_8821A;
+
+#ifdef CONFIG_SDIO_HCI
+s32 InitXmitPriv8821AS(PADAPTER padapter);
+void FreeXmitPriv8821AS(PADAPTER padapter);
+s32 XmitBufHandler8821AS(PADAPTER padapter);
+s32 MgntXmit8821AS(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	HalXmitNoLock8821AS(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 HalXmit8821AS(PADAPTER padapter, struct xmit_frame *pxmitframe);
+#ifndef CONFIG_SDIO_TX_TASKLET
+thread_return XmitThread8821AS(thread_context context);
+#endif // !CONFIG_SDIO_TX_TASKLET
+#endif // CONFIG_SDIO_HCI
+
+#if 0
+#ifdef CONFIG_USB_HCI
+s32 rtl8821au_init_xmit_priv(PADAPTER padapter);
+void rtl8821au_free_xmit_priv(PADAPTER padapter);
+s32 rtl8821au_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8821au_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32 rtl8821au_hal_xmitframe_enqueue(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8821au_xmit_buf_handler(PADAPTER padapter);
+void rtl8821au_xmit_tasklet(void *priv);
+s32 rtl8821au_xmitframe_complete(PADAPTER padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+#endif // CONFIG_USB_HCI
+
+#ifdef CONFIG_PCI_HCI
+s32 rtl8821e_init_xmit_priv(PADAPTER padapter);
+void rtl8821e_free_xmit_priv(PADAPTER padapter);
+struct xmit_buf* rtl8821e_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+void rtl8821e_xmitframe_resume(PADAPTER padapter);
+s32 rtl8821e_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8821e_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+void rtl8821e_xmit_tasklet(void *priv);
+#endif // CONFIG_PCI_HCI
+#endif
+
+#endif //__RTL8821_XMIT_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_android.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_android.h
new file mode 100644
index 000000000..30b0f92c6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_android.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __RTW_ANDROID_H__
+#define __RTW_ANDROID_H__
+
+enum ANDROID_WIFI_CMD {
+	ANDROID_WIFI_CMD_START,
+	ANDROID_WIFI_CMD_STOP,
+	ANDROID_WIFI_CMD_SCAN_ACTIVE,
+	ANDROID_WIFI_CMD_SCAN_PASSIVE,
+	ANDROID_WIFI_CMD_RSSI,
+	ANDROID_WIFI_CMD_LINKSPEED,
+	ANDROID_WIFI_CMD_RXFILTER_START,
+	ANDROID_WIFI_CMD_RXFILTER_STOP,
+	ANDROID_WIFI_CMD_RXFILTER_ADD,
+	ANDROID_WIFI_CMD_RXFILTER_REMOVE,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_START,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP,
+	ANDROID_WIFI_CMD_BTCOEXMODE,
+	ANDROID_WIFI_CMD_SETSUSPENDOPT,
+	ANDROID_WIFI_CMD_P2P_DEV_ADDR,
+	ANDROID_WIFI_CMD_SETFWPATH,
+	ANDROID_WIFI_CMD_SETBAND,
+	ANDROID_WIFI_CMD_GETBAND,
+	ANDROID_WIFI_CMD_COUNTRY,
+	ANDROID_WIFI_CMD_P2P_SET_NOA,
+	ANDROID_WIFI_CMD_P2P_GET_NOA,
+	ANDROID_WIFI_CMD_P2P_SET_PS,
+	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
+
+	ANDROID_WIFI_CMD_MIRACAST,
+
+#ifdef CONFIG_PNO_SUPPORT
+	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
+	ANDROID_WIFI_CMD_PNOSETUP_SET,
+	ANDROID_WIFI_CMD_PNOENABLE_SET,
+	ANDROID_WIFI_CMD_PNODEBUG_SET,
+#endif
+
+	ANDROID_WIFI_CMD_MACADDR,
+
+	ANDROID_WIFI_CMD_BLOCK_SCAN,
+	ANDROID_WIFI_CMD_BLOCK,
+
+	ANDROID_WIFI_CMD_WFD_ENABLE,
+	ANDROID_WIFI_CMD_WFD_DISABLE,
+
+	ANDROID_WIFI_CMD_WFD_SET_TCPPORT,
+	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT,
+	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE,
+	ANDROID_WIFI_CMD_CHANGE_DTIM,
+	ANDROID_WIFI_CMD_HOSTAPD_SET_MACADDR_ACL,
+	ANDROID_WIFI_CMD_HOSTAPD_ACL_ADD_STA,
+	ANDROID_WIFI_CMD_HOSTAPD_ACL_REMOVE_STA,
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0))
+	ANDROID_WIFI_CMD_GTK_REKEY_OFFLOAD,
+#endif //CONFIG_GTK_OL
+	ANDROID_WIFI_CMD_P2P_DISABLE,
+	ANDROID_WIFI_CMD_DRIVERVERSION,
+	ANDROID_WIFI_CMD_MAX
+};
+
+int rtw_android_cmdstr_to_num(char *cmdstr);
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+int rtw_android_pno_enable(struct net_device *net, int pno_enable);
+int rtw_android_cfg80211_pno_setup(struct net_device *net,
+		struct cfg80211_ssid *ssid, int n_ssids, int interval);
+#endif
+
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+int rtw_android_wifictrl_func_add(void);
+void rtw_android_wifictrl_func_del(void);
+void* wl_android_prealloc(int section, unsigned long size);
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr);
+int wifi_set_power(int on, unsigned long msec);
+int wifi_get_mac_addr(unsigned char *buf);
+void *wifi_get_country_code(char *ccode);
+#else
+static int rtw_android_wifictrl_func_add(void) { return 0; }
+static void rtw_android_wifictrl_func_del(void) {}
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
+#ifdef CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int wifi_configure_gpio(void);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+void wifi_free_gpio(unsigned int gpio);
+#endif //CONFIG_GPIO_WAKEUP
+
+
+#endif //__RTW_ANDROID_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ap.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ap.h
new file mode 100644
index 000000000..e9b1303a0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ap.h
@@ -0,0 +1,80 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_AP_H_
+#define __RTW_AP_H_
+
+
+#ifdef CONFIG_AP_MODE
+
+//external function
+extern void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta);
+extern void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta);
+
+
+void init_mlme_ap_info(_adapter *padapter);
+void free_mlme_ap_info(_adapter *padapter);
+//void update_BCNTIM(_adapter *padapter);
+void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
+void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
+void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, const char *tag);
+#define update_beacon(adapter, ie_id, oui, tx) _update_beacon((adapter), (ie_id), (oui), (tx), __func__)
+void add_RATid(_adapter *padapter, struct sta_info *psta, u8 rssi_level);
+void expire_timeout_chk(_adapter *padapter);
+void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
+void rtw_start_bss_hdl_after_chbw_decided(_adapter *adapter);
+void start_bss_network(_adapter *padapter, struct createbss_parm *parm);
+int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len);
+void rtw_ap_restore_network(_adapter *padapter);
+void rtw_set_macaddr_acl(_adapter *padapter, int mode);
+int rtw_acl_add_sta(_adapter *padapter, u8 *addr);
+int rtw_acl_remove_sta(_adapter *padapter, u8 *addr);
+
+u8 rtw_ap_set_pairwise_key(_adapter *padapter, struct sta_info *psta);
+int rtw_ap_set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid);
+int rtw_ap_set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid, u8 set_tx);
+
+#ifdef CONFIG_NATIVEAP_MLME
+void associated_clients_update(_adapter *padapter, u8 updated, u32 sta_info_type);
+void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta);
+u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta);
+void sta_info_update(_adapter *padapter, struct sta_info *psta);
+void ap_sta_info_defer_update(_adapter *padapter, struct sta_info *psta);
+u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reason, bool enqueue);
+int rtw_sta_flush(_adapter *padapter, bool enqueue);
+int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset);
+void start_ap_mode(_adapter *padapter);
+void stop_ap_mode(_adapter *padapter);
+#endif
+
+void rtw_ap_update_bss_chbw(_adapter *adapter, WLAN_BSSID_EX *bss, u8 ch, u8 bw, u8 offset);
+bool rtw_ap_chbw_decision(_adapter *adapter, u8 req_ch, u8 req_bw, u8 req_offset, u8 *ch, u8 *bw, u8 *offset);
+
+#ifdef CONFIG_AUTO_AP_MODE
+extern void rtw_start_auto_ap(_adapter *adapter);
+#endif //CONFIG_AUTO_AP_MODE
+
+#endif //end of CONFIG_AP_MODE
+
+#endif
+void update_bmc_sta(_adapter *padapter);
+
+void rtw_process_ht_action_smps(_adapter *padapter, u8 *ta, u8 ctrl_field);
+void rtw_process_public_act_bsscoex(_adapter *padapter, u8 *pframe, uint frame_len);
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_beamforming.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_beamforming.h
new file mode 100644
index 000000000..38893dae2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_beamforming.h
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_BEAMFORMING_H_
+#define __RTW_BEAMFORMING_H_
+
+#ifdef CONFIG_BEAMFORMING
+
+#if (BEAMFORMING_SUPPORT == 0) /*for diver defined beamforming*/
+#define BEAMFORMING_ENTRY_NUM		2
+#define GET_BEAMFORM_INFO(_pmlmepriv)	((struct beamforming_info *)(&(_pmlmepriv)->beamforming_info))
+
+
+typedef enum _BEAMFORMING_ENTRY_STATE
+{
+	BEAMFORMING_ENTRY_STATE_UNINITIALIZE,
+	BEAMFORMING_ENTRY_STATE_INITIALIZEING,
+	BEAMFORMING_ENTRY_STATE_INITIALIZED,
+	BEAMFORMING_ENTRY_STATE_PROGRESSING,
+	BEAMFORMING_ENTRY_STATE_PROGRESSED,
+}BEAMFORMING_ENTRY_STATE, *PBEAMFORMING_ENTRY_STATE;
+
+
+typedef enum _BEAMFORMING_STATE
+{
+	BEAMFORMING_STATE_IDLE,
+	BEAMFORMING_STATE_START,
+	BEAMFORMING_STATE_END,
+}BEAMFORMING_STATE, *PBEAMFORMING_STATE;
+
+
+typedef enum _BEAMFORMING_CAP
+{
+	BEAMFORMING_CAP_NONE = 0x0,
+	BEAMFORMER_CAP_HT_EXPLICIT = 0x1,
+	BEAMFORMEE_CAP_HT_EXPLICIT = 0x2,
+	BEAMFORMER_CAP_VHT_SU = 0x4,			// Self has er Cap, because Reg er  & peer ee
+	BEAMFORMEE_CAP_VHT_SU = 0x8, 			// Self has ee Cap, because Reg ee & peer er
+	BEAMFORMER_CAP = 0x10,
+	BEAMFORMEE_CAP = 0x20,
+}BEAMFORMING_CAP, *PBEAMFORMING_CAP;
+
+
+typedef enum _SOUNDING_MODE
+{
+	SOUNDING_SW_VHT_TIMER = 0x0,
+	SOUNDING_SW_HT_TIMER = 0x1,
+	SOUNDING_STOP_All_TIMER = 0x2,
+	SOUNDING_HW_VHT_TIMER = 0x3,
+	SOUNDING_HW_HT_TIMER = 0x4,
+	SOUNDING_STOP_OID_TIMER = 0x5,
+	SOUNDING_AUTO_VHT_TIMER = 0x6,
+	SOUNDING_AUTO_HT_TIMER = 0x7,
+	SOUNDING_FW_VHT_TIMER = 0x8,
+	SOUNDING_FW_HT_TIMER = 0x9,
+}SOUNDING_MODE, *PSOUNDING_MODE;
+
+struct beamforming_entry {
+	BOOLEAN	bUsed;
+	BOOLEAN	bSound;
+	u16	aid;			// Used to construct AID field of NDPA packet.
+	u16	mac_id;		// Used to Set Reg42C in IBSS mode.
+	u16	p_aid;		// Used to fill Reg42C & Reg714 to compare with P_AID of Tx DESC.
+	u16 g_id;
+	u8	mac_addr[6];// Used to fill Reg6E4 to fill Mac address of CSI report frame.
+	CHANNEL_WIDTH	sound_bw;	// Sounding BandWidth
+	u16	sound_period;
+	BEAMFORMING_CAP	beamforming_entry_cap;
+	BEAMFORMING_ENTRY_STATE	beamforming_entry_state;
+	u8				ClockResetTimes;			/*Modified by Jeffery @2015-04-10*/
+	u8				PreLogSeq;				/*Modified by Jeffery @2015-03-30*/
+	u8				LogSeq;					/*Modified by Jeffery @2014-10-29*/
+	u16				LogRetryCnt:3;			/*Modified by Jeffery @2014-10-29*/
+	u16				LogSuccess:2;			/*Modified by Jeffery @2014-10-29*/
+
+	u8	LogStatusFailCnt;
+	u8	PreCsiReport[327];
+	u8	DefaultCsiCnt;
+	BOOLEAN	bDefaultCSI;
+};
+
+struct sounding_info {
+	u8				sound_idx;
+	CHANNEL_WIDTH	sound_bw;
+	SOUNDING_MODE	sound_mode;
+	u16				sound_period;
+};
+
+struct beamforming_info {
+	BEAMFORMING_CAP		beamforming_cap;
+	BEAMFORMING_STATE		beamforming_state;
+	struct beamforming_entry	beamforming_entry[BEAMFORMING_ENTRY_NUM];
+	u8						beamforming_cur_idx;
+	u8						beamforming_in_progress;
+	u8						sounding_sequence;
+	struct sounding_info		sounding_info;
+};
+
+struct rtw_ndpa_sta_info {
+	u16	aid:12;
+	u16	feedback_type:1;
+	u16	nc_index:3;
+};
+
+BEAMFORMING_CAP beamforming_get_entry_beam_cap_by_mac_id(PVOID pmlmepriv ,u8 mac_id);
+void	beamforming_notify(PADAPTER adapter);
+BEAMFORMING_CAP beamforming_get_beamform_cap(struct beamforming_info	*pBeamInfo);
+
+BOOLEAN	beamforming_send_ht_ndpa_packet(PADAPTER Adapter, u8 *ra, CHANNEL_WIDTH bw, u8 qidx);
+BOOLEAN	beamforming_send_vht_ndpa_packet(PADAPTER Adapter, u8 *ra, u16 aid, CHANNEL_WIDTH bw, u8 qidx);
+
+void	beamforming_check_sounding_success(PADAPTER Adapter,BOOLEAN status);
+
+void	beamforming_watchdog(PADAPTER Adapter);
+#endif /*#if (BEAMFORMING_SUPPORT ==0)- for diver defined beamforming*/
+
+enum BEAMFORMING_CTRL_TYPE {
+	BEAMFORMING_CTRL_ENTER = 0,
+	BEAMFORMING_CTRL_LEAVE = 1,
+	BEAMFORMING_CTRL_START_PERIOD = 2,
+	BEAMFORMING_CTRL_END_PERIOD = 3,
+	BEAMFORMING_CTRL_SOUNDING_FAIL = 4,
+	BEAMFORMING_CTRL_SOUNDING_CLK = 5,
+};
+u32	beamforming_get_report_frame(PADAPTER	 Adapter, union recv_frame *precv_frame);
+void	beamforming_get_ndpa_frame(PADAPTER	 Adapter, union recv_frame *precv_frame);
+
+void	beamforming_wk_hdl(_adapter *padapter, u8 type, u8 *pbuf);
+u8	beamforming_wk_cmd(_adapter*padapter, s32 type, u8 *pbuf, s32 size, u8 enqueue);
+void update_attrib_txbf_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);
+
+#endif /*#ifdef CONFIG_BEAMFORMING */
+
+#endif /*__RTW_BEAMFORMING_H_*/
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_br_ext.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_br_ext.h
new file mode 100644
index 000000000..7b424482b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_br_ext.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_BR_EXT_H_
+#define _RTW_BR_EXT_H_
+
+#if 1	// rtw_wifi_driver
+#define CL_IPV6_PASS    	1
+#define MACADDRLEN		6
+#define _DEBUG_ERR		DBG_8192C
+#define _DEBUG_INFO		//DBG_8192C
+#define DEBUG_WARN		DBG_8192C
+#define DEBUG_INFO		//DBG_8192C
+#define DEBUG_ERR		DBG_8192C
+//#define GET_MY_HWADDR		((GET_MIB(priv))->dot11OperationEntry.hwaddr)
+#define GET_MY_HWADDR(padapter)		(adapter_mac_addr(padapter))
+#endif	// rtw_wifi_driver
+
+#define NAT25_HASH_BITS		4
+#define NAT25_HASH_SIZE		(1 << NAT25_HASH_BITS)
+#define NAT25_AGEING_TIME	300
+
+#ifdef CL_IPV6_PASS
+#define MAX_NETWORK_ADDR_LEN	17
+#else
+#define MAX_NETWORK_ADDR_LEN	11
+#endif
+
+struct nat25_network_db_entry
+{
+	struct nat25_network_db_entry	*next_hash;
+	struct nat25_network_db_entry	**pprev_hash;
+	atomic_t						use_count;
+	unsigned char					macAddr[6];
+	unsigned long					ageing_timer;
+	unsigned char    				networkAddr[MAX_NETWORK_ADDR_LEN];
+};
+
+enum NAT25_METHOD {
+	NAT25_MIN,
+	NAT25_CHECK,
+	NAT25_INSERT,
+	NAT25_LOOKUP,
+	NAT25_PARSE,
+	NAT25_MAX
+};
+
+struct br_ext_info {
+	unsigned int	nat25_disable;
+	unsigned int	macclone_enable;
+	unsigned int	dhcp_bcst_disable;
+	int		addPPPoETag;		// 1: Add PPPoE relay-SID, 0: disable
+	unsigned char	nat25_dmzMac[MACADDRLEN];
+	unsigned int	nat25sc_disable;
+};
+
+void nat25_db_cleanup(_adapter *priv);
+
+#endif // _RTW_BR_EXT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_bt_mp.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_bt_mp.h
new file mode 100644
index 000000000..ceb9cf8c3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_bt_mp.h
@@ -0,0 +1,295 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __RTW_BT_MP_H
+#define __RTW_BT_MP_H
+
+
+#if(MP_DRIVER == 1)
+
+#pragma pack(1)
+
+// definition for BT_UP_OP_BT_READY
+#define	MP_BT_NOT_READY						0
+#define	MP_BT_READY							1
+
+// definition for BT_UP_OP_BT_SET_MODE
+typedef enum _MP_BT_MODE{
+	MP_BT_MODE_RF_TXRX_TEST_MODE							= 0,
+	MP_BT_MODE_BT20_DUT_TEST_MODE							= 1,
+	MP_BT_MODE_BT40_DIRECT_TEST_MODE						= 2,
+	MP_BT_MODE_CONNECT_TEST_MODE							= 3,
+	MP_BT_MODE_MAX
+}MP_BT_MODE,*PMP_BT_MODE;
+
+
+// definition for BT_UP_OP_BT_SET_TX_RX_PARAMETER
+typedef struct _BT_TXRX_PARAMETERS{
+    u1Byte		txrxChannel;
+    u4Byte		txrxTxPktCnt;
+    u1Byte		txrxTxPktInterval;
+	u1Byte		txrxPayloadType;
+	u1Byte		txrxPktType;
+	u2Byte		txrxPayloadLen;
+	u4Byte		txrxPktHeader;
+	u1Byte		txrxWhitenCoeff;
+	u1Byte		txrxBdaddr[6];
+	u1Byte		txrxTxGainIndex;
+} BT_TXRX_PARAMETERS, *PBT_TXRX_PARAMETERS;
+
+// txrxPktType
+typedef enum _MP_BT_PKT_TYPE{
+	MP_BT_PKT_DH1							= 0,
+	MP_BT_PKT_DH3							= 1,
+	MP_BT_PKT_DH5							= 2,
+	MP_BT_PKT_2DH1							= 3,
+	MP_BT_PKT_2DH3							= 4,
+	MP_BT_PKT_2DH5							= 5,
+	MP_BT_PKT_3DH1							= 6,
+	MP_BT_PKT_3DH3							= 7,
+	MP_BT_PKT_3DH5							= 8,
+	MP_BT_PKT_LE							= 9,
+	MP_BT_PKT_MAX
+}MP_BT_PKT_TYPE,*PMP_BT_PKT_TYPE;
+// txrxPayloadType
+typedef enum _MP_BT_PAYLOAD_TYPE{
+	MP_BT_PAYLOAD_01010101					= 0,
+	MP_BT_PAYLOAD_ALL_1						= 1,
+	MP_BT_PAYLOAD_ALL_0						= 2,
+	MP_BT_PAYLOAD_11110000					= 3,
+	MP_BT_PAYLOAD_PRBS9						= 4,
+	MP_BT_PAYLOAD_MAX						= 8,
+}MP_BT_PAYLOAD_TYPE,*PMP_BT_PAYLOAD_TYPE;
+
+
+// definition for BT_UP_OP_BT_TEST_CTRL
+typedef enum _MP_BT_TEST_CTRL{
+	MP_BT_TEST_STOP_ALL_TESTS						= 0,
+	MP_BT_TEST_START_RX_TEST						= 1,
+	MP_BT_TEST_START_PACKET_TX_TEST					= 2,
+	MP_BT_TEST_START_CONTINUOUS_TX_TEST 			= 3,
+	MP_BT_TEST_START_INQUIRY_SCAN_TEST				= 4,
+	MP_BT_TEST_START_PAGE_SCAN_TEST					= 5,
+	MP_BT_TEST_START_INQUIRY_PAGE_SCAN_TEST			= 6,
+	MP_BT_TEST_START_LEGACY_CONNECT_TEST			= 7,
+	MP_BT_TEST_START_LE_CONNECT_TEST_INITIATOR 		= 8,
+	MP_BT_TEST_START_LE_CONNECT_TEST_ADVERTISER 	= 9,
+	MP_BT_TEST_MAX
+}MP_BT_TEST_CTRL,*PMP_BT_TEST_CTRL;
+
+
+typedef enum _RTL_EXT_C2H_EVT
+{
+	EXT_C2H_WIFI_FW_ACTIVE_RSP = 0,
+	EXT_C2H_TRIG_BY_BT_FW = 1,
+	MAX_EXT_C2HEVENT
+}RTL_EXT_C2H_EVT;
+
+// OP codes definition between the user layer and driver
+typedef enum _BT_CTRL_OPCODE_UPPER{
+	BT_UP_OP_BT_READY										= 0x00,
+	BT_UP_OP_BT_SET_MODE									= 0x01,
+	BT_UP_OP_BT_SET_TX_RX_PARAMETER 						= 0x02,
+	BT_UP_OP_BT_SET_GENERAL 								= 0x03,
+	BT_UP_OP_BT_GET_GENERAL 								= 0x04,
+	BT_UP_OP_BT_TEST_CTRL									= 0x05,
+	BT_UP_OP_TEST_BT										= 0x06,
+	BT_UP_OP_MAX
+}BT_CTRL_OPCODE_UPPER,*PBT_CTRL_OPCODE_UPPER;
+
+
+typedef enum _BT_SET_GENERAL{
+	BT_GSET_REG 											= 0x00,
+	BT_GSET_RESET											= 0x01,
+	BT_GSET_TARGET_BD_ADDR									= 0x02,
+	BT_GSET_TX_PWR_FINETUNE 								= 0x03,
+	BT_SET_TRACKING_INTERVAL								= 0x04,
+	BT_SET_THERMAL_METER									= 0x05,
+	BT_ENABLE_CFO_TRACKING									= 0x06,
+	BT_GSET_UPDATE_BT_PATCH 								= 0x07,
+	BT_GSET_MAX
+}BT_SET_GENERAL,*PBT_SET_GENERAL;
+
+typedef enum _BT_GET_GENERAL{
+	BT_GGET_REG 											= 0x00,
+	BT_GGET_STATUS											= 0x01,
+	BT_GGET_REPORT											= 0x02,
+	BT_GGET_AFH_MAP 										= 0x03,
+	BT_GGET_AFH_STATUS										= 0x04,
+	BT_GGET_MAX
+}BT_GET_GENERAL,*PBT_GET_GENERAL;
+
+// definition for BT_UP_OP_BT_SET_GENERAL
+typedef enum _BT_REG_TYPE{
+	BT_REG_RF								= 0,
+	BT_REG_MODEM							= 1,
+	BT_REG_BLUEWIZE 						= 2,
+	BT_REG_VENDOR							= 3,
+	BT_REG_LE								= 4,
+	BT_REG_MAX
+}BT_REG_TYPE,*PBT_REG_TYPE;
+
+// definition for BT_LO_OP_GET_AFH_MAP
+typedef enum _BT_AFH_MAP_TYPE{
+	BT_AFH_MAP_RESULT						= 0,
+	BT_AFH_MAP_WIFI_PSD_ONLY				= 1,
+	BT_AFH_MAP_WIFI_CH_BW_ONLY				= 2,
+	BT_AFH_MAP_BT_PSD_ONLY					= 3,
+	BT_AFH_MAP_HOST_CLASSIFICATION_ONLY 	= 4,
+	BT_AFH_MAP_MAX
+}BT_AFH_MAP_TYPE,*PBT_AFH_MAP_TYPE;
+
+// definition for BT_UP_OP_BT_GET_GENERAL
+typedef enum _BT_REPORT_TYPE{
+	BT_REPORT_RX_PACKET_CNT 				= 0,
+	BT_REPORT_RX_ERROR_BITS 				= 1,
+	BT_REPORT_RSSI							= 2,
+	BT_REPORT_CFO_HDR_QUALITY				= 3,
+	BT_REPORT_CONNECT_TARGET_BD_ADDR		= 4,
+	BT_REPORT_MAX
+}BT_REPORT_TYPE,*PBT_REPORT_TYPE;
+
+VOID
+MPTBT_Test(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte		opCode,
+	IN	u1Byte		byte1,
+	IN	u1Byte		byte2,
+	IN	u1Byte		byte3
+	);
+
+NDIS_STATUS
+MPTBT_SendOidBT(
+	IN	PADAPTER		pAdapter,
+	IN	PVOID			InformationBuffer,
+	IN	ULONG			InformationBufferLength,
+	OUT	PULONG			BytesRead,
+	OUT	PULONG			BytesNeeded
+	);
+
+VOID
+MPTBT_FwC2hBtMpCtrl(
+	PADAPTER	Adapter,
+	pu1Byte 	tmpBuf,
+	u1Byte		length
+	);
+
+void MPh2c_timeout_handle(void *FunctionContext);
+
+VOID mptbt_BtControlProcess(
+	PADAPTER	Adapter,
+	PVOID		pInBuf
+	);
+
+#define	BT_H2C_MAX_RETRY								1
+#define	BT_MAX_C2H_LEN								20
+
+typedef struct _BT_REQ_CMD{
+    UCHAR       opCodeVer;
+    UCHAR       OpCode;
+    USHORT      paraLength;
+    UCHAR       pParamStart[100];
+} BT_REQ_CMD, *PBT_REQ_CMD;
+
+typedef struct _BT_RSP_CMD{
+    USHORT      status;
+    USHORT      paraLength;
+    UCHAR       pParamStart[100];
+} BT_RSP_CMD, *PBT_RSP_CMD;
+
+
+typedef struct _BT_H2C{
+	u1Byte	opCodeVer:4;
+	u1Byte	reqNum:4;
+	u1Byte	opCode;
+	u1Byte	buf[100];
+}BT_H2C, *PBT_H2C;
+
+
+
+typedef struct _BT_EXT_C2H{
+	u1Byte	extendId;
+	u1Byte	statusCode:4;
+	u1Byte	retLen:4;
+	u1Byte	opCodeVer:4;
+	u1Byte	reqNum:4;
+	u1Byte	buf[100];
+}BT_EXT_C2H, *PBT_EXT_C2H;
+
+
+typedef enum _BT_OPCODE_STATUS{
+	BT_OP_STATUS_SUCCESS									= 0x00, // Success
+	BT_OP_STATUS_VERSION_MISMATCH							= 0x01,
+	BT_OP_STATUS_UNKNOWN_OPCODE								= 0x02,
+	BT_OP_STATUS_ERROR_PARAMETER							= 0x03,
+	BT_OP_STATUS_MAX
+}BT_OPCODE_STATUS,*PBT_OPCODE_STATUS;
+
+
+
+//OP codes definition between driver and bt fw
+typedef enum _BT_CTRL_OPCODE_LOWER{
+	BT_LO_OP_GET_BT_VERSION 									= 0x00,
+	BT_LO_OP_RESET												= 0x01,
+	BT_LO_OP_TEST_CTRL											= 0x02,
+	BT_LO_OP_SET_BT_MODE										= 0x03,
+	BT_LO_OP_SET_CHNL_TX_GAIN									= 0x04,
+	BT_LO_OP_SET_PKT_TYPE_LEN									= 0x05,
+	BT_LO_OP_SET_PKT_CNT_L_PL_TYPE								= 0x06,
+	BT_LO_OP_SET_PKT_CNT_H_PKT_INTV 							= 0x07,
+	BT_LO_OP_SET_PKT_HEADER 									= 0x08,
+	BT_LO_OP_SET_WHITENCOEFF									= 0x09,
+	BT_LO_OP_SET_BD_ADDR_L										= 0x0a,
+	BT_LO_OP_SET_BD_ADDR_H										= 0x0b,
+	BT_LO_OP_WRITE_REG_ADDR 									= 0x0c,
+	BT_LO_OP_WRITE_REG_VALUE									= 0x0d,
+	BT_LO_OP_GET_BT_STATUS										= 0x0e,
+	BT_LO_OP_GET_BD_ADDR_L										= 0x0f,
+	BT_LO_OP_GET_BD_ADDR_H										= 0x10,
+	BT_LO_OP_READ_REG											= 0x11,
+	BT_LO_OP_SET_TARGET_BD_ADDR_L								= 0x12,
+	BT_LO_OP_SET_TARGET_BD_ADDR_H								= 0x13,
+	BT_LO_OP_SET_TX_POWER_CALIBRATION							= 0x14,
+	BT_LO_OP_GET_RX_PKT_CNT_L									= 0x15,
+	BT_LO_OP_GET_RX_PKT_CNT_H									= 0x16,
+	BT_LO_OP_GET_RX_ERROR_BITS_L								= 0x17,
+	BT_LO_OP_GET_RX_ERROR_BITS_H								= 0x18,
+	BT_LO_OP_GET_RSSI											= 0x19,
+	BT_LO_OP_GET_CFO_HDR_QUALITY_L								= 0x1a,
+	BT_LO_OP_GET_CFO_HDR_QUALITY_H								= 0x1b,
+	BT_LO_OP_GET_TARGET_BD_ADDR_L								= 0x1c,
+	BT_LO_OP_GET_TARGET_BD_ADDR_H								= 0x1d,
+	BT_LO_OP_GET_AFH_MAP_L										= 0x1e,
+	BT_LO_OP_GET_AFH_MAP_M										= 0x1f,
+	BT_LO_OP_GET_AFH_MAP_H										= 0x20,
+	BT_LO_OP_GET_AFH_STATUS 									= 0x21,
+	BT_LO_OP_SET_TRACKING_INTERVAL								= 0x22,
+	BT_LO_OP_SET_THERMAL_METER									= 0x23,
+	BT_LO_OP_ENABLE_CFO_TRACKING								= 0x24,
+	BT_LO_OP_MAX
+}BT_CTRL_OPCODE_LOWER,*PBT_CTRL_OPCODE_LOWER;
+
+
+
+
+#endif  /* #if(MP_DRIVER == 1) */
+
+#endif // #ifndef __INC_MPT_BT_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_btcoex.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_btcoex.h
new file mode 100644
index 000000000..37acf041a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_btcoex.h
@@ -0,0 +1,436 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_BTCOEX_H__
+#define __RTW_BTCOEX_H__
+
+#include <drv_types.h>
+
+/* For H2C: H2C_BT_MP_OPER. Return status definition to the user layer */
+typedef enum _BT_CTRL_STATUS {
+	BT_STATUS_SUCCESS								= 0x00, /* Success */
+	BT_STATUS_BT_OP_SUCCESS							= 0x01, /* bt fw op execution success */
+	BT_STATUS_H2C_SUCCESS							= 0x02, /* H2c success */
+	BT_STATUS_H2C_FAIL								= 0x03, /* H2c fail */
+	BT_STATUS_H2C_LENGTH_EXCEEDED					= 0x04, /* H2c command length exceeded */
+	BT_STATUS_H2C_TIMTOUT							= 0x05, /* H2c timeout */
+	BT_STATUS_H2C_BT_NO_RSP							= 0x06, /* H2c sent, bt no rsp */
+	BT_STATUS_C2H_SUCCESS							= 0x07, /* C2h success */
+	BT_STATUS_C2H_REQNUM_MISMATCH					= 0x08, /* bt fw wrong rsp */
+	BT_STATUS_OPCODE_U_VERSION_MISMATCH				= 0x08, /* Upper layer OP code version mismatch. */
+	BT_STATUS_OPCODE_L_VERSION_MISMATCH				= 0x0a, /* Lower layer OP code version mismatch. */
+	BT_STATUS_UNKNOWN_OPCODE_U						= 0x0b, /* Unknown Upper layer OP code */
+	BT_STATUS_UNKNOWN_OPCODE_L						= 0x0c, /* Unknown Lower layer OP code */
+	BT_STATUS_PARAMETER_FORMAT_ERROR_U				= 0x0d, /* Wrong parameters sent by upper layer. */
+	BT_STATUS_PARAMETER_FORMAT_ERROR_L				= 0x0e, /* bt fw parameter format is not consistency */
+	BT_STATUS_PARAMETER_OUT_OF_RANGE_U				= 0x0f, /* uppery layer parameter value is out of range */
+	BT_STATUS_PARAMETER_OUT_OF_RANGE_L				= 0x10, /* bt fw parameter value is out of range */
+	BT_STATUS_UNKNOWN_STATUS_L						= 0x11, /* bt returned an defined status code */
+	BT_STATUS_UNKNOWN_STATUS_H						= 0x12, /* driver need to do error handle or not handle-well. */
+	BT_STATUS_WRONG_LEVEL							= 0x13, /* should be under passive level */
+	BT_STATUS_NOT_IMPLEMENT						= 0x14, /* op code not implemented yet */
+	BT_STATUS_BT_STACK_OP_SUCCESS					= 0x15, /* bt stack op execution success */
+	BT_STATUS_BT_STACK_NOT_SUPPORT					= 0x16, /* stack version not support this. */
+	BT_STATUS_BT_STACK_SEND_HCI_EVENT_FAIL			= 0x17, /* send hci event fail */
+	BT_STATUS_BT_STACK_NOT_BIND						= 0x18, /* stack not bind wifi driver */
+	BT_STATUS_BT_STACK_NO_RSP						= 0x19, /* stack doesn't have any rsp. */
+	BT_STATUS_MAX
+} BT_CTRL_STATUS, *PBT_CTRL_STATUS;
+
+#define SET_BT_MP_OPER_RET(OpCode, StatusCode)						((OpCode << 8) | StatusCode)
+#define GET_OP_CODE_FROM_BT_MP_OPER_RET(RetCode)					((RetCode & 0xF0) >> 8)
+#define GET_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode)				(RetCode & 0x0F)
+#define CHECK_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode, StatusCode)	(GET_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode) == StatusCode)
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+
+#define NETLINK_USER 31
+#define CONNECT_PORT 30000
+#define CONNECT_PORT_BT 30001
+#define KERNEL_SOCKET_OK 0x01
+#define NETLINK_SOCKET_OK 0x02
+
+#define OTHER 0
+#define RX_ATTEND_ACK 1
+#define RX_LEAVE_ACK 2
+#define RX_BT_LEAVE 3
+#define RX_INVITE_REQ 4
+#define RX_ATTEND_REQ 5
+#define RX_INVITE_RSP 6
+
+#define invite_req "INVITE_REQ"
+#define invite_rsp "INVITE_RSP"
+#define attend_req "ATTEND_REQ"
+#define attend_ack "ATTEND_ACK"
+#define wifi_leave "WIFI_LEAVE"
+#define leave_ack "LEAVE_ACK"
+#define bt_leave "BT_LEAVE"
+
+#define BT_INFO_NOTIFY_CMD 0x0106
+#define BT_INFO_LEN 8
+
+typedef struct _HCI_LINK_INFO{
+	u2Byte					ConnectHandle;
+	u1Byte					IncomingTrafficMode;
+	u1Byte					OutgoingTrafficMode;
+	u1Byte					BTProfile;
+	u1Byte					BTCoreSpec;
+	s1Byte					BT_RSSI;
+	u1Byte					TrafficProfile;
+	u1Byte					linkRole;
+}HCI_LINK_INFO, *PHCI_LINK_INFO;
+
+#define	MAX_BT_ACL_LINK_NUM				8
+
+typedef struct _HCI_EXT_CONFIG{
+	HCI_LINK_INFO				aclLink[MAX_BT_ACL_LINK_NUM];
+	u1Byte					btOperationCode;
+	u2Byte					CurrentConnectHandle;
+	u1Byte					CurrentIncomingTrafficMode;
+	u1Byte					CurrentOutgoingTrafficMode;
+
+	u1Byte					NumberOfACL;
+	u1Byte					NumberOfSCO;
+	u1Byte					CurrentBTStatus;
+	u2Byte					HCIExtensionVer;
+
+	BOOLEAN					bEnableWifiScanNotify;
+}HCI_EXT_CONFIG, *PHCI_EXT_CONFIG;
+
+typedef struct _HCI_PHY_LINK_BSS_INFO{
+	u2Byte						bdCap;			// capability information
+
+	// Qos related. Added by Annie, 2005-11-01.
+	//BSS_QOS						BssQos;
+
+}HCI_PHY_LINK_BSS_INFO, *PHCI_PHY_LINK_BSS_INFO;
+
+typedef enum _BT_CONNECT_TYPE{
+	BT_CONNECT_AUTH_REQ								=0x00,
+	BT_CONNECT_AUTH_RSP								=0x01,
+	BT_CONNECT_ASOC_REQ								=0x02,
+	BT_CONNECT_ASOC_RSP								=0x03,
+	BT_DISCONNECT										=0x04
+}BT_CONNECT_TYPE,*PBT_CONNECT_TYPE;
+
+
+typedef struct _PACKET_IRP_HCIEVENT_DATA {
+	    u8		EventCode;
+	    u8		Length; //total cmd length = extension event length+1(extension event code length)
+	    u8		Data[1]; // byte1 is extension event code
+} rtw_HCI_event;
+
+
+struct btinfo_8761ATV {
+	u8 cid;
+	u8 len;
+
+	u8 bConnection:1;
+	u8 bSCOeSCO:1;
+	u8 bInQPage:1;
+	u8 bACLBusy:1;
+	u8 bSCOBusy:1;
+	u8 bHID:1;
+	u8 bA2DP:1;
+	u8 bFTP:1;
+
+	u8 retry_cnt:4;
+	u8 rsvd_34:1;
+	u8 bPage:1;
+	u8 TRxMask:1;
+	u8 Sniff_attempt:1;
+
+	u8 rssi;
+
+	u8 A2dp_rate:1;
+	u8 ReInit:1;
+	u8 MaxPower:1;
+	u8 bEnIgnoreWlanAct:1;
+	u8 TxPowerLow:1;
+	u8 TxPowerHigh:1;
+	u8 eSCO_SCO:1;
+	u8 Master_Slave:1;
+
+	u8 ACL_TRx_TP_low;
+	u8 ACL_TRx_TP_high;
+};
+
+#define HCIOPCODE(_OCF, _OGF)     ((_OGF)<<10|(_OCF))
+#define HCIOPCODELOW(_OCF, _OGF)	(u8)(HCIOPCODE(_OCF, _OGF)&0x00ff)
+#define HCIOPCODEHIGHT(_OCF, _OGF) (u8)(HCIOPCODE(_OCF, _OGF)>>8)
+#define HCI_OGF(opCode)  (unsigned char)((0xFC00 & (opCode)) >> 10)
+#define HCI_OCF(opCode)  ( 0x3FF & (opCode))
+
+
+typedef enum _HCI_STATUS{
+	HCI_STATUS_SUCCESS										=0x00, //Success
+	HCI_STATUS_UNKNOW_HCI_CMD								=0x01, //Unknown HCI Command
+	HCI_STATUS_UNKNOW_CONNECT_ID							=0X02, //Unknown Connection Identifier
+	HCI_STATUS_HW_FAIL										=0X03, //Hardware Failure
+	HCI_STATUS_PAGE_TIMEOUT									=0X04, //Page Timeout
+	HCI_STATUS_AUTH_FAIL										=0X05, //Authentication Failure
+	HCI_STATUS_PIN_OR_KEY_MISSING							=0X06, //PIN or Key Missing
+	HCI_STATUS_MEM_CAP_EXCEED								=0X07, //Memory Capacity Exceeded
+	HCI_STATUS_CONNECT_TIMEOUT								=0X08, //Connection Timeout
+	HCI_STATUS_CONNECT_LIMIT									=0X09, //Connection Limit Exceeded
+	HCI_STATUS_SYN_CONNECT_LIMIT								=0X0a, //Synchronous Connection Limit To A Device Exceeded
+	HCI_STATUS_ACL_CONNECT_EXISTS							=0X0b, //ACL Connection Already Exists
+	HCI_STATUS_CMD_DISALLOW									=0X0c, //Command Disallowed
+	HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE					=0X0d, //Connection Rejected due to Limited Resources
+	HCI_STATUS_CONNECT_RJT_SEC_REASON						=0X0e, //Connection Rejected Due To Security Reasons
+	HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR				=0X0f, //Connection Rejected due to Unacceptable BD_ADDR
+	HCI_STATUS_CONNECT_ACCEPT_TIMEOUT						=0X10, //Connection Accept Timeout Exceeded
+	HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE				=0X11, //Unsupported Feature or Parameter Value
+	HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE					=0X12, //Invalid HCI Command Parameters
+	HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT				=0X13, //Remote User Terminated Connection
+	HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE			=0X14, //Remote Device Terminated Connection due to Low Resources
+	HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF	=0X15, //Remote Device Terminated Connection due to Power Off
+	HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST				=0X16, //Connection Terminated By Local Host
+	HCI_STATUS_REPEATE_ATTEMPT								=0X17, //Repeated Attempts
+	HCI_STATUS_PAIR_NOT_ALLOW								=0X18, //Pairing Not Allowed
+	HCI_STATUS_UNKNOW_LMP_PDU								=0X19, //Unknown LMP PDU
+	HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE				=0X1a, //Unsupported Remote Feature / Unsupported LMP Feature
+	HCI_STATUS_SOC_OFFSET_REJECT								=0X1b, //SCO Offset Rejected
+	HCI_STATUS_SOC_INTERVAL_REJECT							=0X1c, //SCO Interval Rejected
+	HCI_STATUS_SOC_AIR_MODE_REJECT							=0X1d,//SCO Air Mode Rejected
+	HCI_STATUS_INVALID_LMP_PARA								=0X1e, //Invalid LMP Parameters
+	HCI_STATUS_UNSPECIFIC_ERROR								=0X1f, //Unspecified Error
+	HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE					=0X20, //Unsupported LMP Parameter Value
+	HCI_STATUS_ROLE_CHANGE_NOT_ALLOW						=0X21, //Role Change Not Allowed
+	HCI_STATUS_LMP_RESPONSE_TIMEOUT							=0X22, //LMP Response Timeout
+	HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION				=0X23, //LMP Error Transaction Collision
+	HCI_STATUS_LMP_PDU_NOT_ALLOW							=0X24, //LMP PDU Not Allowed
+	HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW					=0X25, //Encryption Mode Not Acceptable
+	HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE						=0X26, //Link Key Can Not be Changed
+	HCI_STATUS_REQUEST_QOS_NOT_SUPPORT						=0X27, //Requested QoS Not Supported
+	HCI_STATUS_INSTANT_PASSED								=0X28, //Instant Passed
+	HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT					=0X29, //Pairing With Unit Key Not Supported
+	HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION				=0X2a, //Different Transaction Collision
+	HCI_STATUS_RESERVE_1										=0X2b, //Reserved
+	HCI_STATUS_QOS_UNACCEPT_PARA							=0X2c, //QoS Unacceptable Parameter
+	HCI_STATUS_QOS_REJECT										=0X2d, //QoS Rejected
+	HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT				=0X2e, //Channel Classification Not Supported
+	HCI_STATUS_INSUFFICIENT_SECURITY							=0X2f, //Insufficient Security
+	HCI_STATUS_PARA_OUT_OF_RANGE							=0x30, //Parameter Out Of Mandatory Range
+	HCI_STATUS_RESERVE_2										=0X31, //Reserved
+	HCI_STATUS_ROLE_SWITCH_PENDING							=0X32, //Role Switch Pending
+	HCI_STATUS_RESERVE_3										=0X33, //Reserved
+	HCI_STATUS_RESERVE_SOLT_VIOLATION						=0X34, //Reserved Slot Violation
+	HCI_STATUS_ROLE_SWITCH_FAIL								=0X35, //Role Switch Failed
+	HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE				=0X36, //Extended Inquiry Response Too Large
+	HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT				=0X37, //Secure Simple Pairing Not Supported By Host.
+	HCI_STATUS_HOST_BUSY_PAIRING								=0X38, //Host Busy - Pairing
+	HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND			=0X39, //Connection Rejected due to No Suitable Channel Found
+	HCI_STATUS_CONTROLLER_BUSY								=0X3a  //CONTROLLER BUSY
+}RTW_HCI_STATUS;
+
+#define HCI_EVENT_COMMAND_COMPLETE					0x0e
+
+#define OGF_EXTENSION									0X3f
+typedef enum HCI_EXTENSION_COMMANDS{
+	HCI_SET_ACL_LINK_DATA_FLOW_MODE				=0x0010,
+	HCI_SET_ACL_LINK_STATUS							=0x0020,
+	HCI_SET_SCO_LINK_STATUS							=0x0030,
+	HCI_SET_RSSI_VALUE								=0x0040,
+	HCI_SET_CURRENT_BLUETOOTH_STATUS				=0x0041,
+
+	//The following is for RTK8723
+	HCI_EXTENSION_VERSION_NOTIFY					=0x0100,
+	HCI_LINK_STATUS_NOTIFY							=0x0101,
+	HCI_BT_OPERATION_NOTIFY							=0x0102,
+	HCI_ENABLE_WIFI_SCAN_NOTIFY 						=0x0103,
+	HCI_QUERY_RF_STATUS								=0x0104,
+	HCI_BT_ABNORMAL_NOTIFY							=0x0105,
+	HCI_BT_INFO_NOTIFY								=0x0106,
+	HCI_BT_COEX_NOTIFY								=0x0107,
+	HCI_BT_PATCH_VERSION_NOTIFY						=0x0108,
+	HCI_BT_AFH_MAP_NOTIFY							=0x0109,
+	HCI_BT_REGISTER_VALUE_NOTIFY					=0x010a,
+
+	//The following is for IVT
+	HCI_WIFI_CURRENT_CHANNEL						=0x0300,
+	HCI_WIFI_CURRENT_BANDWIDTH						=0x0301,
+	HCI_WIFI_CONNECTION_STATUS						=0x0302
+}RTW_HCI_EXT_CMD;
+
+#define HCI_EVENT_EXTENSION_RTK						0xfe
+typedef enum HCI_EXTENSION_EVENT_RTK{
+	HCI_EVENT_EXT_WIFI_SCAN_NOTIFY								=0x01,
+	HCI_EVENT_EXT_WIFI_RF_STATUS_NOTIFY						=0x02,
+	HCI_EVENT_EXT_BT_INFO_CONTROL								=0x03,
+	HCI_EVENT_EXT_BT_COEX_CONTROL								=0x04
+}RTW_HCI_EXT_EVENT;
+
+typedef enum _BT_TRAFFIC_MODE{
+	BT_MOTOR_EXT_BE		= 0x00, //Best Effort. Default. for HCRP, PAN, SDP, RFCOMM-based profiles like FTP,OPP, SPP, DUN, etc.
+	BT_MOTOR_EXT_GUL		= 0x01, //Guaranteed Latency. This type of traffic is used e.g. for HID and AVRCP.
+	BT_MOTOR_EXT_GUB		= 0X02, //Guaranteed Bandwidth.
+	BT_MOTOR_EXT_GULB	= 0X03  //Guaranteed Latency and Bandwidth. for A2DP and VDP.
+} BT_TRAFFIC_MODE;
+
+typedef enum _BT_TRAFFIC_MODE_PROFILE{
+	BT_PROFILE_NONE,
+	BT_PROFILE_A2DP,
+	BT_PROFILE_PAN	,
+	BT_PROFILE_HID,
+	BT_PROFILE_SCO
+} BT_TRAFFIC_MODE_PROFILE;
+
+typedef enum _HCI_EXT_BT_OPERATION {
+	HCI_BT_OP_NONE				= 0x0,
+	HCI_BT_OP_INQUIRY_START		= 0x1,
+	HCI_BT_OP_INQUIRY_FINISH		= 0x2,
+	HCI_BT_OP_PAGING_START		= 0x3,
+	HCI_BT_OP_PAGING_SUCCESS		= 0x4,
+	HCI_BT_OP_PAGING_UNSUCCESS	= 0x5,
+	HCI_BT_OP_PAIRING_START		= 0x6,
+	HCI_BT_OP_PAIRING_FINISH		= 0x7,
+	HCI_BT_OP_BT_DEV_ENABLE		= 0x8,
+	HCI_BT_OP_BT_DEV_DISABLE		= 0x9,
+	HCI_BT_OP_MAX
+} HCI_EXT_BT_OPERATION, *PHCI_EXT_BT_OPERATION;
+
+typedef struct _BT_MGNT{
+	BOOLEAN				bBTConnectInProgress;
+	BOOLEAN				bLogLinkInProgress;
+	BOOLEAN				bPhyLinkInProgress;
+	BOOLEAN				bPhyLinkInProgressStartLL;
+	u1Byte				BtCurrentPhyLinkhandle;
+	u2Byte				BtCurrentLogLinkhandle;
+	u1Byte				CurrentConnectEntryNum;
+	u1Byte				DisconnectEntryNum;
+	u1Byte				CurrentBTConnectionCnt;
+	BT_CONNECT_TYPE		BTCurrentConnectType;
+	BT_CONNECT_TYPE		BTReceiveConnectPkt;
+	u1Byte				BTAuthCount;
+	u1Byte				BTAsocCount;
+	BOOLEAN				bStartSendSupervisionPkt;
+	BOOLEAN				BtOperationOn;
+	BOOLEAN				BTNeedAMPStatusChg;
+	BOOLEAN				JoinerNeedSendAuth;
+	HCI_PHY_LINK_BSS_INFO	bssDesc;
+	HCI_EXT_CONFIG		ExtConfig;
+	BOOLEAN				bNeedNotifyAMPNoCap;
+	BOOLEAN				bCreateSpportQos;
+	BOOLEAN				bSupportProfile;
+	u1Byte				BTChannel;
+	BOOLEAN				CheckChnlIsSuit;
+	BOOLEAN				bBtScan;
+	BOOLEAN				btLogoTest;
+	BOOLEAN				bRfStatusNotified;
+	BOOLEAN				bBtRsvedPageDownload;
+}BT_MGNT, *PBT_MGNT;
+
+struct bt_coex_info {
+	/* For Kernel Socket */
+	struct socket *udpsock;
+	struct sockaddr_in wifi_sockaddr; /*wifi socket*/
+	struct sockaddr_in bt_sockaddr;/* BT socket  */
+	struct sock *sk_store;/*back up socket for UDP RX int*/
+
+	/* store which socket is OK */
+	u8 sock_open;
+
+	u8 BT_attend;
+	u8 is_exist; /* socket exist */
+	BT_MGNT BtMgnt;
+	struct workqueue_struct *btcoex_wq;
+	struct delayed_work recvmsg_work;
+};
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+
+#define	PACKET_NORMAL			0
+#define	PACKET_DHCP				1
+#define	PACKET_ARP				2
+#define	PACKET_EAPOL			3
+
+void rtw_btcoex_Initialize(PADAPTER);
+void rtw_btcoex_PowerOnSetting(PADAPTER padapter);
+void rtw_btcoex_PreLoadFirmware(PADAPTER padapter);
+void rtw_btcoex_HAL_Initialize(PADAPTER padapter, u8 bWifiOnly);
+void rtw_btcoex_IpsNotify(PADAPTER, u8 type);
+void rtw_btcoex_LpsNotify(PADAPTER, u8 type);
+void rtw_btcoex_ScanNotify(PADAPTER, u8 type);
+void rtw_btcoex_ConnectNotify(PADAPTER, u8 action);
+void rtw_btcoex_MediaStatusNotify(PADAPTER, u8 mediaStatus);
+void rtw_btcoex_SpecialPacketNotify(PADAPTER, u8 pktType);
+void rtw_btcoex_IQKNotify(PADAPTER padapter, u8 state);
+void rtw_btcoex_BtInfoNotify(PADAPTER, u8 length, u8 *tmpBuf);
+void rtw_btcoex_BtMpRptNotify(PADAPTER, u8 length, u8 *tmpBuf);
+void rtw_btcoex_SuspendNotify(PADAPTER, u8 state);
+void rtw_btcoex_HaltNotify(PADAPTER);
+void rtw_btcoex_ScoreBoardStatusNotify(PADAPTER, u8 length, u8 *tmpBuf);
+void rtw_btcoex_SwitchBtTRxMask(PADAPTER);
+void rtw_btcoex_Switch(PADAPTER, u8 enable);
+u8 rtw_btcoex_IsBtDisabled(PADAPTER);
+void rtw_btcoex_Handler(PADAPTER);
+s32 rtw_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
+s32 rtw_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER);
+u32 rtw_btcoex_GetAMPDUSize(PADAPTER);
+void rtw_btcoex_SetManualControl(PADAPTER, u8 bmanual);
+u8 rtw_btcoex_1Ant(PADAPTER);
+u8 rtw_btcoex_IsBtControlLps(PADAPTER);
+u8 rtw_btcoex_IsLpsOn(PADAPTER);
+u8 rtw_btcoex_RpwmVal(PADAPTER);
+u8 rtw_btcoex_LpsVal(PADAPTER);
+void rtw_btcoex_SetBTCoexist(PADAPTER, u8 bBtExist);
+void rtw_btcoex_SetChipType(PADAPTER, u8 chipType);
+void rtw_btcoex_SetPGAntNum(PADAPTER, u8 antNum);
+u8 rtw_btcoex_GetPGAntNum(PADAPTER);
+void rtw_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath);
+u32 rtw_btcoex_GetRaMask(PADAPTER);
+void rtw_btcoex_RecordPwrMode(PADAPTER, u8 *pCmdBuf, u8 cmdLen);
+void rtw_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
+void rtw_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
+u32 rtw_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
+u8 rtw_btcoex_IncreaseScanDeviceNum(PADAPTER);
+u8 rtw_btcoex_IsBtLinkExist(PADAPTER);
+void rtw_btcoex_BTOffOnNotify(PADAPTER padapter, u8 bBTON);
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+void rtw_btcoex_SetBtPatchVersion(PADAPTER padapter,u16 btHciVer, u16 btPatchVer);
+void rtw_btcoex_SetHciVersion(PADAPTER  padapter, u16 hciVersion);
+void rtw_btcoex_StackUpdateProfileInfo(void);
+void rtw_btcoex_init_socket(_adapter *padapter);
+void rtw_btcoex_close_socket(_adapter *padapter);
+void rtw_btcoex_dump_tx_msg(u8 *tx_msg, u8 len, u8 *msg_name);
+u8 rtw_btcoex_sendmsgbysocket(_adapter *padapter, u8 *msg, u8 msg_size, bool force);
+u8 rtw_btcoex_create_kernel_socket(_adapter *padapter);
+void rtw_btcoex_close_kernel_socket(_adapter *padapter);
+void rtw_btcoex_recvmsgbysocket(void *data);
+u16 rtw_btcoex_parse_recv_data(u8 *msg, u8 msg_size);
+u8 rtw_btcoex_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
+void rtw_btcoex_parse_hci_cmd(_adapter *padapter, u8 *cmd, u16 len);
+void rtw_btcoex_SendEventExtBtCoexControl(PADAPTER Adapter, u8 bNeedDbgRsp, u8 dataLen, void *pData);
+void rtw_btcoex_SendEventExtBtInfoControl(PADAPTER Adapter, u8 dataLen, void *pData);
+void rtw_btcoex_SendScanNotify(PADAPTER padapter, u8 scanType);
+#define BT_SendEventExtBtCoexControl(Adapter, bNeedDbgRsp, dataLen, pData) rtw_btcoex_SendEventExtBtCoexControl(Adapter, bNeedDbgRsp, dataLen, pData)
+#define BT_SendEventExtBtInfoControl(Adapter, dataLen, pData) rtw_btcoex_SendEventExtBtInfoControl(Adapter, dataLen, pData)
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+u16 rtw_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
+u16 rtw_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
+
+// ==================================================
+// Below Functions are called by BT-Coex
+// ==================================================
+void rtw_btcoex_rx_ampdu_apply(PADAPTER);
+void rtw_btcoex_LPS_Enter(PADAPTER);
+void rtw_btcoex_LPS_Leave(PADAPTER);
+
+#endif // __RTW_BTCOEX_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_byteorder.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_byteorder.h
new file mode 100644
index 000000000..478e0ee3e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_byteorder.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_BYTEORDER_H_
+#define _RTL871X_BYTEORDER_H_
+
+
+#if defined (CONFIG_LITTLE_ENDIAN) && defined (CONFIG_BIG_ENDIAN)
+#error "Shall be CONFIG_LITTLE_ENDIAN or CONFIG_BIG_ENDIAN, but not both!\n"
+#endif
+
+#if defined (CONFIG_LITTLE_ENDIAN)
+#ifndef CONFIG_PLATFORM_MSTAR389
+#  include <byteorder/little_endian.h>
+#endif
+#elif defined (CONFIG_BIG_ENDIAN)
+#  include <byteorder/big_endian.h>
+#else
+#  error "Must be LITTLE/BIG Endian Host"
+#endif
+
+#endif /* _RTL871X_BYTEORDER_H_ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_cmd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_cmd.h
new file mode 100644
index 000000000..0eb257a87
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_cmd.h
@@ -0,0 +1,1314 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_CMD_H_
+#define __RTW_CMD_H_
+
+
+#define C2H_MEM_SZ (16*1024)
+
+#ifndef CONFIG_RTL8711FW
+
+	#define FREE_CMDOBJ_SZ	128
+
+	#define MAX_CMDSZ	1024
+	#define MAX_RSPSZ	512
+	#define MAX_EVTSZ	1024
+
+#ifdef PLATFORM_OS_CE
+	#define CMDBUFF_ALIGN_SZ 4
+#else
+	#define CMDBUFF_ALIGN_SZ 512
+#endif
+
+	struct cmd_obj {
+		_adapter *padapter;
+		u16	cmdcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	cmdsz;
+		u8	*rsp;
+		u32	rspsz;
+		struct submit_ctx *sctx;
+		u8 no_io;
+		//_sema 	cmd_sem;
+		_list	list;
+	};
+
+	/* cmd flags */
+	enum {
+		RTW_CMDF_DIRECTLY = BIT0,
+		RTW_CMDF_WAIT_ACK = BIT1,
+	};
+
+	struct cmd_priv {
+		_sema	cmd_queue_sema;
+		//_sema	cmd_done_sema;
+		_sema	terminate_cmdthread_sema;
+		_queue	cmd_queue;
+		u8	cmd_seq;
+		u8	*cmd_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*cmd_allocated_buf;
+		u8	*rsp_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*rsp_allocated_buf;
+		u32	cmd_issued_cnt;
+		u32	cmd_done_cnt;
+		u32	rsp_cnt;
+		ATOMIC_T cmdthd_running;
+		//u8 cmdthd_running;
+		u8 stop_req;
+		_adapter *padapter;
+		_mutex sctx_mutex;
+	};
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	struct evt_obj {
+		u16	evtcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	evtsz;
+		_list	list;
+	};
+#endif
+
+	struct	evt_priv {
+#ifdef CONFIG_EVENT_THREAD_MODE
+		_sema	evt_notify;
+		_sema	terminate_evtthread_sema;
+		_queue	evt_queue;
+#endif
+
+#define CONFIG_C2H_WK
+#ifdef CONFIG_C2H_WK
+		_workitem c2h_wk;
+		bool c2h_wk_alive;
+		struct rtw_cbuf *c2h_queue;
+		#define C2H_QUEUE_MAX_LEN 10
+#endif
+
+#ifdef CONFIG_H2CLBK
+		_sema	lbkevt_done;
+		u8	lbkevt_limit;
+		u8	lbkevt_num;
+		u8	*cmdevt_parm;
+#endif
+		ATOMIC_T event_seq;
+		u8	*evt_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*evt_allocated_buf;
+		u32	evt_done_cnt;
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+		u8	*c2h_mem;
+		u8	*allocated_c2h_mem;
+#ifdef PLATFORM_OS_XP
+		PMDL	pc2h_mdl;
+#endif
+#endif
+
+	};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	_rtw_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (u8 *)(pparm);\
+	pcmd->cmdsz = sizeof (*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while(0)
+
+#define init_h2fwcmd_w_parm_no_parm_rsp(pcmd, code) \
+do {\
+	_rtw_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = NULL;\
+	pcmd->cmdsz = 0;\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while(0)
+
+struct c2h_evt_hdr {
+	u8 id:4;
+	u8 plen:4;
+	u8 seq;
+	u8 payload[0];
+};
+
+struct c2h_evt_hdr_88xx {
+	u8 id;
+	u8 seq;
+	u8 payload[12];
+	u8 plen;
+	u8 trigger;
+};
+
+#define c2h_evt_valid(c2h_evt) ((c2h_evt)->id || (c2h_evt)->plen)
+
+struct P2P_PS_Offload_t {
+	u8 Offload_En:1;
+	u8 role:1; // 1: Owner, 0: Client
+	u8 CTWindow_En:1;
+	u8 NoA0_En:1;
+	u8 NoA1_En:1;
+	u8 AllStaSleep:1; // Only valid in Owner
+	u8 discovery:1;
+	u8 rsvd:1;
+};
+
+struct P2P_PS_CTWPeriod_t {
+	u8 CTWPeriod;	//TU
+};
+
+#ifdef CONFIG_P2P_WOWLAN
+
+struct P2P_WoWlan_Offload_t{
+	u8 Disconnect_Wkup_Drv:1;
+	u8 role:2;
+	u8 Wps_Config[2];
+};
+
+#endif //CONFIG_P2P_WOWLAN
+
+extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+extern u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj);
+extern struct evt_obj *rtw_dequeue_evt(_queue *queue);
+extern void rtw_free_evt_obj(struct evt_obj *pcmd);
+#endif
+
+void rtw_stop_cmd_thread(_adapter *adapter);
+thread_return rtw_cmd_thread(thread_context context);
+
+extern u32 rtw_init_cmd_priv (struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_priv (struct cmd_priv *pcmdpriv);
+
+extern u32 rtw_init_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_free_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
+extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
+#ifdef CONFIG_P2P
+u8 p2p_protocol_wk_cmd(_adapter*padapter, int intCmdType );
+#endif //CONFIG_P2P
+
+#else
+	//#include <ieee80211.h>
+#endif	/* CONFIG_RTL8711FW */
+
+enum rtw_drvextra_cmd_id
+{
+	NONE_WK_CID,
+	STA_MSTATUS_RPT_WK_CID,
+	DYNAMIC_CHK_WK_CID,
+	DM_CTRL_WK_CID,
+	PBC_POLLING_WK_CID,
+	POWER_SAVING_CTRL_WK_CID,//IPS,AUTOSuspend
+	LPS_CTRL_WK_CID,
+	ANT_SELECT_WK_CID,
+	P2P_PS_WK_CID,
+	P2P_PROTO_WK_CID,
+	CHECK_HIQ_WK_CID,//for softap mode, check hi queue if empty
+	INTEl_WIDI_WK_CID,
+	C2H_WK_CID,
+	RTP_TIMER_CFG_WK_CID,
+	RESET_SECURITYPRIV, // add for CONFIG_IEEE80211W, none 11w also can use
+	FREE_ASSOC_RESOURCES, // add for CONFIG_IEEE80211W, none 11w also can use
+	DM_IN_LPS_WK_CID,
+	DM_RA_MSK_WK_CID, //add for STA update RAMask when bandwith change.
+	BEAMFORMING_WK_CID,
+	LPS_CHANGE_DTIM_CID,
+	BTINFO_WK_CID,
+	DFS_MASTER_WK_CID,
+	SESSION_TRACKER_WK_CID,
+	EN_HW_UPDATE_TSF_WK_CID,
+	MAX_WK_CID
+};
+
+enum LPS_CTRL_TYPE
+{
+	LPS_CTRL_SCAN=0,
+	LPS_CTRL_JOINBSS=1,
+	LPS_CTRL_CONNECT=2,
+	LPS_CTRL_DISCONNECT=3,
+	LPS_CTRL_SPECIAL_PACKET=4,
+	LPS_CTRL_LEAVE=5,
+	LPS_CTRL_TRAFFIC_BUSY = 6,
+	LPS_CTRL_TX_TRAFFIC_LEAVE = 7,
+	LPS_CTRL_RX_TRAFFIC_LEAVE = 8,
+	LPS_CTRL_ENTER = 9,
+	LPS_CTRL_LEAVE_CFG80211_PWRMGMT = 10,
+};
+
+enum STAKEY_TYPE
+{
+	GROUP_KEY		=0,
+	UNICAST_KEY		=1,
+	TDLS_KEY		=2,
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To enter USB suspend mode
+
+Command Mode
+
+*/
+struct usb_suspend_parm {
+	u32 action;// 1: sleep, 0:resume
+};
+
+/*
+Caller Mode: Infra, Ad-HoC
+
+Notes: To join a known BSS.
+
+Command-Event Mode
+
+*/
+
+/*
+Caller Mode: Infra, Ad-Hoc
+
+Notes: To join the specified bss
+
+Command Event Mode
+
+*/
+struct joinbss_parm {
+	WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To disconnect the current associated BSS
+
+Command Mode
+
+*/
+struct disconnect_parm {
+	u32 deauth_timeout_ms;
+};
+
+/*
+Caller Mode: AP, Ad-HoC(M)
+
+Notes: To create a BSS
+
+Command Mode
+*/
+struct createbss_parm {
+	bool adhoc;
+
+	/* used by AP mode now */
+	s16 req_ch;
+	u8 req_bw;
+	u8 req_offset;
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To set the NIC mode of RTL8711
+
+Command Mode
+
+The definition of mode:
+
+#define IW_MODE_AUTO	0	// Let the driver decides which AP to join
+#define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
+#define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
+#define IW_MODE_MASTER	3	// Synchronisation master or Access Point
+#define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
+#define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
+#define IW_MODE_MONITOR	6	// Passive monitor (listen only)
+
+*/
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To ask RTL8711 performing site-survey
+
+Command-Event Mode
+
+*/
+
+#define RTW_SSID_SCAN_AMOUNT 9 // for WEXT_CSCAN_AMOUNT 9
+#define RTW_CHANNEL_SCAN_AMOUNT (14+37)
+struct sitesurvey_parm {
+	sint scan_mode;	//active: 1, passive: 0
+	/* sint bsslimit;	// 1 ~ 48 */
+	u8 ssid_num;
+	u8 ch_num;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the auth type of RTL8711. open/shared/802.1x
+
+Command Mode
+
+*/
+struct setauth_parm {
+	u8 mode;  //0: legacy open, 1: legacy shared 2: 802.1x
+	u8 _1x;   //0: PSK, 1: TLS
+	u8 rsvd[2];
+};
+
+/*
+Caller Mode: Infra
+
+a. algorithm: wep40, wep104, tkip & aes
+b. keytype: grp key/unicast key
+c. key contents
+
+when shared key ==> keyid is the camid
+when 802.1x ==> keyid [0:1] ==> grp key
+when 802.1x ==> keyid > 2 ==> unicast key
+
+*/
+struct setkey_parm {
+	u8	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
+	u8	keyid;
+	u8 	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
+	u8 	set_tx;		// 1: main tx key for wep. 0: other key.
+	u8	key[16];	// this could be 40 or 104
+};
+
+/*
+When in AP or Ad-Hoc mode, this is used to
+allocate an sw/hw entry for a newly associated sta.
+
+Command
+
+when shared key ==> algorithm/keyid
+
+*/
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	keyid;
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+
+	Command mode
+
+	This is to force fw to del an sta_data entry per driver's request
+
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	u8  	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+#ifdef MP_FIRMWARE_OFFLOAD
+	u32	curr_rateidx;
+#else
+	u8	mac_id;
+	u8	datarates[NumRates];
+#endif
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+
+};
+struct getdatarate_rsp {
+	u8 datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+struct	setphyinfo_parm {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+struct	getphyinfo_parm {
+	u32 rsvd;
+};
+
+struct	getphyinfo_rsp {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+struct	setphy_parm {
+	u8	rfchannel;
+	u8	modem;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_parm {
+	u32 rsvd;
+
+};
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct readMAC_parm {
+	u8 len;
+	u32	addr;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+
+struct Tx_Beacon_param
+{
+	WLAN_BSSID_EX network;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+
+	The rsp layout shall be:
+	rsp: 			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=  	swap32(w1);
+		b0		= 	b1
+		s2		= 	s0 + s1
+		b1		= 	b0
+		w1		=	w0
+
+	mac[0] == 	2
+	==> CMD_EVENT mode, return 	H2C_SUCCESS
+	The event layout shall be:
+	event:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   swap16(s0) - event.mac[2];
+		s1		=   s1 + event.mac[2];
+		w0		=  	swap32(w0);
+		b0		= 	b1
+		s2		= 	s0 + event.mac[2]
+		b1		= 	b0
+		w1		=	swap32(w1) - event.mac[2];
+
+		parm->mac[3] is the total event counts that host requested.
+
+
+	event will be the same with the cmd's param.
+
+*/
+
+#ifdef CONFIG_H2CLBK
+
+struct seth2clbk_parm {
+	u8 mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16  s2;
+	u8	b1;
+	u32	w1;
+};
+
+struct geth2clbk_parm {
+	u32 rsv;
+};
+
+struct geth2clbk_rsp {
+	u8	mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16	s2;
+	u8	b1;
+	u32	w1;
+};
+
+#endif	/* CONFIG_H2CLBK */
+
+// CMD param Formart for driver extra cmd handler
+struct drvextra_cmd_parm {
+	int ec_id; //extra cmd id
+	int type; // Can use this field as the type id or command size
+	int size; //buffer size
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;
+	u8	rx_antset;
+	u8	tx_antenna;
+	u8	rx_antenna;
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;		// 0: pure hw, 1: fw
+};
+
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+
+struct setratable_parm {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+struct getratable_parm {
+                uint rsvd;
+};
+struct getratable_rsp {
+        u8 ss_ForceUp[NumRates];
+        u8 ss_ULevel[NumRates];
+        u8 ss_DLevel[NumRates];
+        u8 count_judge[NumRates];
+};
+
+
+//to get TX,RX retry count
+struct gettxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct gettxretrycnt_rsp{
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct getrxretrycnt_rsp{
+	unsigned long rx_retrycnt;
+};
+
+//to get BCNOK,BCNERR count
+struct getbcnokcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnokcnt_rsp{
+	unsigned long  bcnokcnt;
+};
+
+struct getbcnerrcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp{
+	unsigned long bcnerrcnt;
+};
+
+// to get current TX power level
+struct getcurtxpwrlevel_parm{
+	unsigned int rsvd;
+};
+struct getcurtxpwrlevel_rsp{
+	unsigned short tx_power;
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+
+struct addBaReq_parm
+{
+ 	unsigned int tid;
+	u8	addr[ETH_ALEN];
+};
+
+/*H2C Handler index: 46 */
+struct set_ch_parm {
+	u8 ch;
+	u8 bw;
+	u8 ch_offset;
+};
+
+#ifdef MP_FIRMWARE_OFFLOAD
+/*H2C Handler index: 47 */
+struct SetTxPower_parm
+{
+	u8 TxPower;
+};
+
+/*H2C Handler index: 48 */
+struct SwitchAntenna_parm
+{
+	u16 antenna_tx;
+	u16 antenna_rx;
+//	R_ANTENNA_SELECT_CCK cck_txrx;
+	u8 cck_txrx;
+};
+
+/*H2C Handler index: 49 */
+struct SetCrystalCap_parm
+{
+	u32 curr_crystalcap;
+};
+
+/*H2C Handler index: 50 */
+struct SetSingleCarrierTx_parm
+{
+	u8 bStart;
+};
+
+/*H2C Handler index: 51 */
+struct SetSingleToneTx_parm
+{
+	u8 bStart;
+	u8 curr_rfpath;
+};
+
+/*H2C Handler index: 52 */
+struct SetCarrierSuppressionTx_parm
+{
+	u8 bStart;
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 53 */
+struct SetContinuousTx_parm
+{
+	u8 bStart;
+	u8 CCK_flag; /*1:CCK 2:OFDM*/
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 54 */
+struct SwitchBandwidth_parm
+{
+	u8 curr_bandwidth;
+};
+
+#endif	/* MP_FIRMWARE_OFFLOAD */
+
+/*H2C Handler index: 59 */
+struct SetChannelPlan_param
+{
+	u8 channel_plan;
+};
+
+/*H2C Handler index: 60 */
+struct LedBlink_param
+{
+	PVOID	 pLed;
+};
+
+/*H2C Handler index: 61 */
+struct SetChannelSwitch_param
+{
+	u8 new_ch_no;
+};
+
+/*H2C Handler index: 62 */
+struct TDLSoption_param
+{
+	u8 addr[ETH_ALEN];
+	u8 option;
+};
+
+/*H2C Handler index: 64 */
+struct RunInThread_param
+{
+	void (*func)(void*);
+	void *context;
+};
+
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+
+/*
+
+Result:
+0x00: success
+0x01: sucess, and check Response.
+0x02: cmd ignored due to duplicated sequcne number
+0x03: cmd dropped due to invalid cmd code
+0x04: reserved.
+
+*/
+
+#define H2C_RSP_OFFSET			512
+
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+#define H2C_ENQ_HEAD			0x08
+#define H2C_ENQ_HEAD_FAIL		0x09
+
+extern u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
+extern u8 rtw_setstandby_cmd(_adapter *padapter, uint action);
+u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num, struct rtw_ieee80211_channel *ch, int ch_num);
+
+u8 rtw_create_ibss_cmd(_adapter *adapter, int flags);
+u8 rtw_startbss_cmd(_adapter *adapter, int flags);
+u8 rtw_change_bss_chbw_cmd(_adapter *adapter, int flags, u8 req_ch, u8 req_bw, u8 req_offset);
+
+extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
+
+struct sta_info;
+extern u8 rtw_setstakey_cmd(_adapter  *padapter, struct sta_info *sta, u8 key_type, bool enqueue);
+extern u8 rtw_clearstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 enqueue);
+
+extern u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork);
+u8 rtw_disassoc_cmd(_adapter *padapter, u32 deauth_timeout_ms, bool enqueue);
+extern u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype, bool enqueue);
+extern u8 rtw_setdatarate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 rtw_setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 rtw_getmacreg_cmd(_adapter *padapter, u8 len, u32 addr);
+extern void rtw_usb_catc_trigger_cmd(_adapter *padapter, const char *caller);
+extern u8 rtw_setbbreg_cmd(_adapter * padapter, u8 offset, u8 val);
+extern u8 rtw_setrfreg_cmd(_adapter * padapter, u8 offset, u32 val);
+extern u8 rtw_getbbreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
+extern u8 rtw_getrfreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
+extern u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode);
+extern u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
+extern u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);
+
+extern u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset,u8 *pval);
+extern u8 rtw_setfwdig_cmd(_adapter*padapter, u8 type);
+extern u8 rtw_setfwra_cmd(_adapter*padapter, u8 type);
+
+extern u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr);
+// add for CONFIG_IEEE80211W, none 11w also can use
+extern u8 rtw_reset_securitypriv_cmd(_adapter*padapter);
+extern u8 rtw_free_assoc_resources_cmd(_adapter *padapter);
+extern u8 rtw_dynamic_chk_wk_cmd(_adapter *adapter);
+
+u8 rtw_lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue);
+u8 rtw_dm_in_lps_wk_cmd(_adapter*padapter);
+u8 rtw_lps_change_dtim_cmd(_adapter*padapter, u8 dtim);
+
+#if (RATE_ADAPTIVE_SUPPORT==1)
+u8 rtw_rpt_timer_cfg_cmd(_adapter*padapter, u16 minRptTime);
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+extern  u8 rtw_antenna_select_cmd(_adapter*padapter, u8 antenna,u8 enqueue);
+#endif
+
+u8 rtw_dm_ra_mask_wk_cmd(_adapter*padapter, u8 *psta);
+
+extern u8 rtw_ps_cmd(_adapter*padapter);
+
+#ifdef CONFIG_AP_MODE
+u8 rtw_chk_hi_queue_cmd(_adapter*padapter);
+#ifdef CONFIG_DFS_MASTER
+u8 rtw_dfs_master_cmd(_adapter *adapter, bool enqueue);
+void rtw_dfs_master_timer_hdl(RTW_TIMER_HDL_ARGS);
+void rtw_dfs_master_enable(_adapter *adapter, u8 ch, u8 bw, u8 offset);
+void rtw_dfs_master_disable(_adapter *adapter, bool ld_sta_in_dfs);
+enum {
+	MLME_STA_CONNECTING,
+	MLME_STA_CONNECTED,
+	MLME_STA_DISCONNECTED,
+	MLME_AP_STARTED,
+	MLME_AP_STOPPED,
+};
+void rtw_dfs_master_status_apply(_adapter *adapter, u8 self_action);
+#endif /* CONFIG_DFS_MASTER */
+#endif /* CONFIG_AP_MODE */
+
+#ifdef CONFIG_BT_COEXIST
+u8 rtw_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
+#endif
+
+u8 rtw_set_ch_cmd(_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue);
+u8 rtw_set_chplan_cmd(_adapter *adapter, int flags, u8 chplan, u8 swconfig);
+extern u8 rtw_led_blink_cmd(_adapter*padapter, PVOID pLed);
+extern u8 rtw_set_csa_cmd(_adapter*padapter, u8 new_ch_no);
+extern u8 rtw_tdls_cmd(_adapter*padapter, u8 *addr, u8 option);
+
+//#ifdef CONFIG_C2H_PACKET_EN
+extern u8 rtw_c2h_packet_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
+//#else
+extern u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *c2h_evt);
+//#endif
+
+u8 rtw_run_in_thread_cmd(PADAPTER padapter, void (*func)(void*), void* context);
+
+u8 session_tracker_chk_cmd(_adapter *adapter, struct sta_info *sta);
+u8 session_tracker_add_cmd(_adapter *adapter, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+u8 session_tracker_del_cmd(_adapter *adapter, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+
+u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf);
+
+extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+void rtw_create_ibss_post_hdl(_adapter *padapter, int status);
+extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
+
+extern void rtw_setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_getrttbl_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_getmacreg_cmdrsp_callback(_adapter *padapter,  struct cmd_obj *pcmd);
+
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(_adapter  *padapter, struct cmd_obj *cmd);
+};
+
+enum rtw_h2c_cmd
+{
+	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
+ 	GEN_CMD_CODE(_Write_MACREG) ,
+ 	GEN_CMD_CODE(_Read_BBREG) ,
+ 	GEN_CMD_CODE(_Write_BBREG) ,
+ 	GEN_CMD_CODE(_Read_RFREG) ,
+ 	GEN_CMD_CODE(_Write_RFREG) , /*5*/
+ 	GEN_CMD_CODE(_Read_EEPROM) ,
+ 	GEN_CMD_CODE(_Write_EEPROM) ,
+ 	GEN_CMD_CODE(_Read_EFUSE) ,
+ 	GEN_CMD_CODE(_Write_EFUSE) ,
+
+ 	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
+ 	GEN_CMD_CODE(_Write_CAM) ,
+ 	GEN_CMD_CODE(_setBCNITV),
+ 	GEN_CMD_CODE(_setMBIDCFG),
+ 	GEN_CMD_CODE(_JoinBss),   /*14*/
+ 	GEN_CMD_CODE(_DisConnect) , /*15*/
+ 	GEN_CMD_CODE(_CreateBss) ,
+	GEN_CMD_CODE(_SetOpMode) ,
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+ 	GEN_CMD_CODE(_SetAuth) ,
+
+ 	GEN_CMD_CODE(_SetKey) ,	/*20*/
+ 	GEN_CMD_CODE(_SetStaKey) ,
+ 	GEN_CMD_CODE(_SetAssocSta) ,
+ 	GEN_CMD_CODE(_DelAssocSta) ,
+ 	GEN_CMD_CODE(_SetStaPwrState) ,
+ 	GEN_CMD_CODE(_SetBasicRate) , /*25*/
+ 	GEN_CMD_CODE(_GetBasicRate) ,
+ 	GEN_CMD_CODE(_SetDataRate) ,
+ 	GEN_CMD_CODE(_GetDataRate) ,
+	GEN_CMD_CODE(_SetPhyInfo) ,
+
+ 	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
+	GEN_CMD_CODE(_SetPhy) ,
+ 	GEN_CMD_CODE(_GetPhy) ,
+ 	GEN_CMD_CODE(_readRssi) ,
+ 	GEN_CMD_CODE(_readGain) ,
+ 	GEN_CMD_CODE(_SetAtim) , /*35*/
+ 	GEN_CMD_CODE(_SetPwrMode) ,
+ 	GEN_CMD_CODE(_JoinbssRpt),
+ 	GEN_CMD_CODE(_SetRaTable) ,
+ 	GEN_CMD_CODE(_GetRaTable) ,
+
+ 	GEN_CMD_CODE(_GetCCXReport), /*40*/
+ 	GEN_CMD_CODE(_GetDTMReport),
+ 	GEN_CMD_CODE(_GetTXRateStatistics),
+ 	GEN_CMD_CODE(_SetUsbSuspend),
+ 	GEN_CMD_CODE(_SetH2cLbk),
+ 	GEN_CMD_CODE(_AddBAReq) , /*45*/
+	GEN_CMD_CODE(_SetChannel), /*46*/
+	GEN_CMD_CODE(_SetTxPower),
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+
+	GEN_CMD_CODE(_SetSingleToneTx),/*51*/
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+	GEN_CMD_CODE(_TX_Beacon), /*55*/
+
+	GEN_CMD_CODE(_Set_MLME_EVT), /*56*/
+	GEN_CMD_CODE(_Set_Drv_Extra), /*57*/
+	GEN_CMD_CODE(_Set_H2C_MSG), /*58*/
+
+	GEN_CMD_CODE(_SetChannelPlan), /*59*/
+	GEN_CMD_CODE(_LedBlink), /*60*/
+
+	GEN_CMD_CODE(_SetChannelSwitch), /*61*/
+	GEN_CMD_CODE(_TDLS), /*62*/
+	GEN_CMD_CODE(_ChkBMCSleepq), /*63*/
+
+	GEN_CMD_CODE(_RunInThreadCMD), /*64*/
+
+	MAX_H2CCMD
+};
+
+#define _GetMACReg_CMD_ _Read_MACREG_CMD_
+#define _SetMACReg_CMD_ _Write_MACREG_CMD_
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_ 		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_ 		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_ 		_Write_RFREG_CMD_
+
+#ifdef _RTW_CMD_C_
+struct _cmd_callback 	rtw_cmd_callback[] =
+{
+	{GEN_CMD_CODE(_Read_MACREG), &rtw_getmacreg_cmdrsp_callback}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL},
+	{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+ 	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), NULL},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable) , NULL},
+
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+ 	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+ 	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
+ 	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
+ 	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+ 	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL}, /*51*/
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+	{GEN_CMD_CODE(_TX_Beacon), NULL},/*55*/
+
+	{GEN_CMD_CODE(_Set_MLME_EVT), NULL},/*56*/
+	{GEN_CMD_CODE(_Set_Drv_Extra), NULL},/*57*/
+	{GEN_CMD_CODE(_Set_H2C_MSG), NULL},/*58*/
+	{GEN_CMD_CODE(_SetChannelPlan), NULL},/*59*/
+	{GEN_CMD_CODE(_LedBlink), NULL},/*60*/
+
+	{GEN_CMD_CODE(_SetChannelSwitch), NULL},/*61*/
+	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
+	{GEN_CMD_CODE(_ChkBMCSleepq), NULL}, /*63*/
+
+	{GEN_CMD_CODE(_RunInThreadCMD), NULL},/*64*/
+};
+#endif
+
+#define CMD_FMT "cmd=%d,%d,%d"
+#define CMD_ARG(cmd) \
+	(cmd)->cmdcode, \
+	(cmd)->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ? ((struct drvextra_cmd_parm *)(cmd)->parmbuf)->ec_id : ((cmd)->cmdcode == GEN_CMD_CODE(_Set_MLME_EVT) ? ((struct C2HEvent_Header *)(cmd)->parmbuf)->ID : 0), \
+	(cmd)->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ? ((struct drvextra_cmd_parm *)(cmd)->parmbuf)->type : 0
+
+#endif // _CMD_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_debug.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_debug.h
new file mode 100644
index 000000000..d362fe83a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_debug.h
@@ -0,0 +1,538 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_DEBUG_H__
+#define __RTW_DEBUG_H__
+
+
+#define _drv_always_		1
+#define _drv_emerg_			2
+#define _drv_alert_			3
+#define _drv_crit_			4
+#define _drv_err_			5
+#define	_drv_warning_		6
+#define _drv_notice_		7
+#define _drv_info_			8
+#define _drv_dump_			9
+#define	_drv_debug_			10
+
+
+#define _module_rtl871x_xmit_c_		BIT(0)
+#define _module_xmit_osdep_c_		BIT(1)
+#define _module_rtl871x_recv_c_		BIT(2)
+#define _module_recv_osdep_c_		BIT(3)
+#define _module_rtl871x_mlme_c_		BIT(4)
+#define _module_mlme_osdep_c_		BIT(5)
+#define _module_rtl871x_sta_mgt_c_		BIT(6)
+#define _module_rtl871x_cmd_c_			BIT(7)
+#define _module_cmd_osdep_c_		BIT(8)
+#define _module_rtl871x_io_c_				BIT(9)
+#define _module_io_osdep_c_		BIT(10)
+#define _module_os_intfs_c_			BIT(11)
+#define _module_rtl871x_security_c_		BIT(12)
+#define _module_rtl871x_eeprom_c_			BIT(13)
+#define _module_hal_init_c_		BIT(14)
+#define _module_hci_hal_init_c_		BIT(15)
+#define _module_rtl871x_ioctl_c_		BIT(16)
+#define _module_rtl871x_ioctl_set_c_		BIT(17)
+#define _module_rtl871x_ioctl_query_c_	BIT(18)
+#define _module_rtl871x_pwrctrl_c_			BIT(19)
+#define _module_hci_intfs_c_			BIT(20)
+#define _module_hci_ops_c_			BIT(21)
+#define _module_osdep_service_c_			BIT(22)
+#define _module_mp_			BIT(23)
+#define _module_hci_ops_os_c_			BIT(24)
+#define _module_rtl871x_ioctl_os_c		BIT(25)
+#define _module_rtl8712_cmd_c_		BIT(26)
+//#define _module_efuse_			BIT(27)
+#define	_module_rtl8192c_xmit_c_ BIT(28)
+#define _module_hal_xmit_c_	BIT(28)
+#define _module_efuse_			BIT(29)
+#define _module_rtl8712_recv_c_		BIT(30)
+#define _module_rtl8712_led_c_		BIT(31)
+
+#undef _MODULE_DEFINE_
+
+#if defined _RTW_XMIT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_xmit_c_
+#elif defined _XMIT_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_xmit_osdep_c_
+#elif defined _RTW_RECV_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_recv_c_
+#elif defined _RECV_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_recv_osdep_c_
+#elif defined _RTW_MLME_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_mlme_c_
+#elif defined _MLME_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTW_MLME_EXT_C_
+	#define _MODULE_DEFINE_ 1
+#elif defined _RTW_STA_MGT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_sta_mgt_c_
+#elif defined _RTW_CMD_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_cmd_c_
+#elif defined _CMD_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_cmd_osdep_c_
+#elif defined _RTW_IO_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_io_c_
+#elif defined _IO_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_io_osdep_c_
+#elif defined _OS_INTFS_C_
+	#define	_MODULE_DEFINE_	_module_os_intfs_c_
+#elif defined _RTW_SECURITY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_security_c_
+#elif defined _RTW_EEPROM_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_
+#elif defined _HAL_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hal_init_c_
+#elif (defined _HCI_HAL_INIT_C_) || (defined _SDIO_HALINIT_C_)
+	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
+#elif defined _RTL871X_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_
+#elif defined _RTL871X_IOCTL_SET_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_set_c_
+#elif defined _RTL871X_IOCTL_QUERY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_query_c_
+#elif defined _RTL871X_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_pwrctrl_c_
+#elif defined _RTW_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	1
+#elif defined _HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _HCI_OPS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_c_
+#elif defined _SDIO_OPS_C_
+	#define	_MODULE_DEFINE_ 1
+#elif defined _OSDEP_HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _OSDEP_SERVICE_C_
+	#define	_MODULE_DEFINE_	_module_osdep_service_c_
+#elif defined _HCI_OPS_OS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_os_c_
+#elif defined _RTL871X_IOCTL_LINUX_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_os_c
+#elif defined _RTL8712_CMD_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_cmd_c_
+#elif defined _RTL8192C_XMIT_C_
+	#define	_MODULE_DEFINE_	1
+#elif defined _RTL8723AS_XMIT_C_
+	#define	_MODULE_DEFINE_	1
+#elif defined _RTL8712_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#elif defined _RTL8192CU_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#elif defined _RTL871X_MLME_EXT_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTW_MP_C_
+	#define	_MODULE_DEFINE_	_module_mp_
+#elif defined _RTW_MP_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_mp_
+#elif defined _RTW_EFUSE_C_
+	#define	_MODULE_DEFINE_	_module_efuse_
+#endif
+
+#ifdef PLATFORM_OS_CE
+extern void rtl871x_cedbg(const char *fmt, ...);
+#endif
+
+#define RT_TRACE(_Comp, _Level, Fmt) do{}while(0)
+#define _func_enter_ do{}while(0)
+#define _func_exit_ do{}while(0)
+#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen) do{}while(0)
+
+#ifdef PLATFORM_WINDOWS
+	#define DBG_871X do {} while(0)
+	#define MSG_8192C do {} while(0)
+	#define DBG_8192C do {} while(0)
+	#define DBG_871X_LEVEL do {} while(0)
+#else
+	#define DBG_871X(x, ...) do {} while(0)
+	#define MSG_8192C(x, ...) do {} while(0)
+	#define DBG_8192C(x,...) do {} while(0)
+	#define DBG_871X_LEVEL(x,...) do {} while(0)
+#endif
+
+#undef _dbgdump
+#undef _seqdump
+
+#ifndef _RTL871X_DEBUG_C_
+	extern u32 GlobalDebugLevel;
+	extern u64 GlobalDebugComponents;
+#endif
+
+#if defined(PLATFORM_WINDOWS) && defined(PLATFORM_OS_XP)
+	#define _dbgdump DbgPrint
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#elif defined(PLATFORM_WINDOWS) && defined(PLATFORM_OS_CE)
+	#define _dbgdump rtl871x_cedbg
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#elif defined PLATFORM_LINUX
+	#define _dbgdump printk
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#elif defined PLATFORM_FREEBSD
+	#define _dbgdump printf
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#endif
+
+#define DRIVER_PREFIX "RTL871X: "
+
+#if defined(_dbgdump)
+
+#define DBG_871X_EXP(level, EXP) do { if (level <= GlobalDebugLevel) EXP; } while (0)
+
+/* with driver-defined prefix */
+#undef DBG_871X_LEVEL
+#define DBG_871X_LEVEL(level, fmt, arg...)     \
+	do {\
+		if (level <= GlobalDebugLevel) {\
+			if (level <= _drv_err_ && level > _drv_always_) \
+				_dbgdump(DRIVER_PREFIX"ERROR " fmt, ##arg);\
+			else \
+				_dbgdump(DRIVER_PREFIX fmt, ##arg);\
+		}\
+	}while(0)
+
+/* without driver-defined prefix */
+#undef _DBG_871X_LEVEL
+#define _DBG_871X_LEVEL(level, fmt, arg...)	   \
+	do {\
+		if (level <= GlobalDebugLevel) {\
+			if (level <= _drv_err_ && level > _drv_always_) \
+				_dbgdump("ERROR " fmt, ##arg);\
+			else \
+				_dbgdump(fmt, ##arg);\
+		}\
+	}while(0)
+
+#if defined(_seqdump)
+#define RTW_DBGDUMP 0 /* 'stream' for _dbgdump */
+
+/* dump message to selected 'stream' */
+#define DBG_871X_SEL(sel, fmt, arg...) \
+	do {\
+		if (sel == RTW_DBGDUMP)\
+			_DBG_871X_LEVEL(_drv_always_, fmt, ##arg); \
+		else {\
+			if(_seqdump(sel, fmt, ##arg)) /*rtw_warn_on(1)*/; \
+		} \
+	}while(0)
+
+/* dump message to selected 'stream' with driver-defined prefix */
+#define DBG_871X_SEL_NL(sel, fmt, arg...) \
+	do {\
+		if (sel == RTW_DBGDUMP)\
+			DBG_871X_LEVEL(_drv_always_, fmt, ##arg); \
+		else {\
+			if(_seqdump(sel, fmt, ##arg)) /*rtw_warn_on(1)*/; \
+		} \
+	}while(0)
+
+#endif /* defined(_seqdump) */
+
+#endif /* defined(_dbgdump) */
+
+#ifdef CONFIG_DEBUG
+#if	defined(_dbgdump)
+	#undef DBG_871X
+	#define DBG_871X(...)     do {\
+		_dbgdump(DRIVER_PREFIX __VA_ARGS__);\
+	}while(0)
+
+	#undef MSG_8192C
+	#define MSG_8192C(...)     do {\
+		_dbgdump(DRIVER_PREFIX __VA_ARGS__);\
+	}while(0)
+
+	#undef DBG_8192C
+	#define DBG_8192C(...)     do {\
+		_dbgdump(DRIVER_PREFIX __VA_ARGS__);\
+	}while(0)
+#endif /* defined(_dbgdump) */
+#endif /* CONFIG_DEBUG */
+
+#ifdef CONFIG_DEBUG_RTL871X
+
+#if	defined(_dbgdump) && defined(_MODULE_DEFINE_)
+
+	#undef RT_TRACE
+	#define RT_TRACE(_Comp, _Level, Fmt)\
+	do {\
+		if((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
+			_dbgdump("%s [0x%08x,%d]", DRIVER_PREFIX, (unsigned int)_Comp, _Level);\
+			_dbgdump Fmt;\
+		}\
+	}while(0)
+
+#endif /* defined(_dbgdump) && defined(_MODULE_DEFINE_) */
+
+
+#if	defined(_dbgdump)
+	#undef  _func_enter_
+	#define _func_enter_ \
+	do {	\
+		if (GlobalDebugLevel >= _drv_debug_) \
+		{																	\
+			_dbgdump("\n %s : %s enters at %d\n", DRIVER_PREFIX, __FUNCTION__, __LINE__);\
+		}		\
+	} while(0)
+
+	#undef  _func_exit_
+	#define _func_exit_ \
+	do {	\
+		if (GlobalDebugLevel >= _drv_debug_) \
+		{																	\
+			_dbgdump("\n %s : %s exits at %d\n", DRIVER_PREFIX, __FUNCTION__, __LINE__); \
+		}	\
+	} while(0)
+
+	#undef RT_PRINT_DATA
+	#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
+		if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+		{									\
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			_dbgdump("%s", DRIVER_PREFIX);						\
+			_dbgdump(_TitleString);						\
+			for( __i=0; __i<(int)_HexDataLen; __i++ )				\
+			{								\
+				_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");	\
+				if (((__i + 1) % 16) == 0)	_dbgdump("\n");			\
+			}								\
+			_dbgdump("\n");							\
+		}
+#endif /* defined(_dbgdump) */
+#endif /* CONFIG_DEBUG_RTL871X */
+
+#ifdef CONFIG_DBG_COUNTER
+#define DBG_COUNTER(counter) counter++
+#else
+#define DBG_COUNTER(counter)
+#endif
+
+void dump_drv_version(void *sel);
+void dump_log_level(void *sel);
+void dump_drv_cfg(void *sel);
+
+#ifdef CONFIG_SDIO_HCI
+void sd_f0_reg_dump(void *sel, _adapter *adapter);
+void sdio_local_reg_dump(void *sel, _adapter *adapter);
+#endif /* CONFIG_SDIO_HCI */
+
+void mac_reg_dump(void *sel, _adapter *adapter);
+void bb_reg_dump(void *sel, _adapter *adapter);
+void rf_reg_dump(void *sel, _adapter *adapter);
+
+bool rtw_fwdl_test_trigger_chksum_fail(void);
+bool rtw_fwdl_test_trigger_wintint_rdy_fail(void);
+bool rtw_del_rx_ampdu_test_trigger_no_tx_fail(void);
+
+u32 rtw_get_wait_hiq_empty_ms(void);
+void rtw_sink_rtp_seq_dbg( _adapter *adapter,_pkt *pkt);
+
+struct sta_info;
+void sta_rx_reorder_ctl_dump(void *sel, struct sta_info *sta);
+
+struct dvobj_priv;
+void dump_adapters_status(void *sel, struct dvobj_priv *dvobj);
+
+struct sec_cam_ent;
+void dump_sec_cam_ent(void *sel, struct sec_cam_ent *ent, int id);
+void dump_sec_cam_ent_title(void *sel, u8 has_id);
+void dump_sec_cam(void *sel, _adapter *adapter);
+
+#ifdef CONFIG_PROC_DEBUG
+ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_read_reg(struct seq_file *m, void *v);
+ssize_t proc_set_read_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_fwstate(struct seq_file *m, void *v);
+int proc_get_sec_info(struct seq_file *m, void *v);
+int proc_get_mlmext_state(struct seq_file *m, void *v);
+#ifdef CONFIG_LAYER2_ROAMING
+int proc_get_roam_flags(struct seq_file *m, void *v);
+ssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_roam_param(struct seq_file *m, void *v);
+ssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_LAYER2_ROAMING */
+int proc_get_qos_option(struct seq_file *m, void *v);
+int proc_get_ht_option(struct seq_file *m, void *v);
+int proc_get_rf_info(struct seq_file *m, void *v);
+int proc_get_scan_param(struct seq_file *m, void *v);
+ssize_t proc_set_scan_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_scan_abort(struct seq_file *m, void *v);
+#ifdef CONFIG_SCAN_BACKOP
+int proc_get_backop_flags_sta(struct seq_file *m, void *v);
+ssize_t proc_set_backop_flags_sta(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_backop_flags_ap(struct seq_file *m, void *v);
+ssize_t proc_set_backop_flags_ap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_SCAN_BACKOP */
+int proc_get_survey_info(struct seq_file *m, void *v);
+ssize_t proc_set_survey_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_ap_info(struct seq_file *m, void *v);
+ssize_t proc_reset_trx_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_trx_info(struct seq_file *m, void *v);
+int proc_get_rate_ctl(struct seq_file *m, void *v);
+int proc_get_wifi_spec(struct seq_file *m, void *v);
+ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#ifdef DBG_RX_COUNTER_DUMP
+int proc_get_rx_cnt_dump(struct seq_file *m, void *v);
+ssize_t proc_set_rx_cnt_dump(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif
+int proc_get_dis_pwt(struct seq_file *m, void *v);
+ssize_t proc_set_dis_pwt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_suspend_resume_info(struct seq_file *m, void *v);
+
+ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_del_rx_ampdu_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#ifdef CONFIG_DFS_MASTER
+int proc_get_dfs_master_test_case(struct seq_file *m, void *v);
+ssize_t proc_set_dfs_master_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_DFS_MASTER */
+ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_AP_MODE
+int proc_get_all_sta_info(struct seq_file *m, void *v);
+#endif /* CONFIG_AP_MODE */
+
+#ifdef DBG_MEMORY_LEAK
+int proc_get_malloc_cnt(struct seq_file *m, void *v);
+#endif /* DBG_MEMORY_LEAK */
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+int proc_get_best_channel(struct seq_file *m, void *v);
+ssize_t proc_set_best_channel(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+int proc_get_rx_signal(struct seq_file *m, void *v);
+ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_hw_status(struct seq_file *m, void *v);
+
+#ifdef CONFIG_80211N_HT
+int proc_get_ht_enable(struct seq_file *m, void *v);
+ssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_bw_mode(struct seq_file *m, void *v);
+ssize_t proc_set_bw_mode(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_ampdu_enable(struct seq_file *m, void *v);
+ssize_t proc_set_ampdu_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_mac_rptbuf(struct seq_file *m, void *v);
+
+int proc_get_rx_ampdu(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_rx_stbc(struct seq_file *m, void *v);
+ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+
+int proc_get_rx_ampdu_factor(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu_factor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_rx_ampdu_density(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_tx_ampdu_density(struct seq_file *m, void *v);
+ssize_t proc_set_tx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_80211N_HT */
+
+int proc_get_en_fwps(struct seq_file *m, void *v);
+ssize_t proc_set_en_fwps(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+//int proc_get_two_path_rssi(struct seq_file *m, void *v);
+//int proc_get_rssi_disp(struct seq_file *m, void *v);
+//ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_BT_COEXIST
+int proc_get_btcoex_dbg(struct seq_file *m, void *v);
+ssize_t proc_set_btcoex_dbg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_btcoex_info(struct seq_file *m, void *v);
+#endif /* CONFIG_BT_COEXIST */
+
+#if defined(DBG_CONFIG_ERROR_DETECT)
+int proc_get_sreset(struct seq_file *m, void *v);
+ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* DBG_CONFIG_ERROR_DETECT */
+
+int proc_get_odm_dbg_comp(struct seq_file *m, void *v);
+ssize_t proc_set_odm_dbg_comp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_odm_dbg_level(struct seq_file *m, void *v);
+ssize_t proc_set_odm_dbg_level(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_odm_adaptivity(struct seq_file *m, void *v);
+ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_DBG_COUNTER
+int proc_get_rx_logs(struct seq_file *m, void *v);
+int proc_get_tx_logs(struct seq_file *m, void *v);
+int proc_get_int_logs(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+int proc_get_rx_ring(struct seq_file *m, void *v);
+int proc_get_tx_ring(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+int proc_get_wowlan_gpio_info(struct seq_file *m, void *v);
+ssize_t proc_set_wowlan_gpio_info(struct file *file, const char __user *buffer,
+		size_t count, loff_t *pos, void *data);
+#endif /*CONFIG_GPIO_WAKEUP*/
+
+#ifdef CONFIG_P2P_WOWLAN
+int proc_get_p2p_wowlan_info(struct seq_file *m, void *v);
+#endif /* CONFIG_P2P_WOWLAN */
+
+int proc_get_new_bcn_max(struct seq_file *m, void *v);
+ssize_t proc_set_new_bcn_max(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_POWER_SAVING
+int proc_get_ps_info(struct seq_file *m, void *v);
+#endif //CONFIG_POWER_SAVING
+
+#ifdef CONFIG_TDLS
+int proc_get_tdls_info(struct seq_file *m, void *v);
+#endif
+
+int proc_get_monitor(struct seq_file *m, void *v);
+ssize_t proc_set_monitor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+int proc_get_rtkm_info(struct seq_file *m, void *v);
+#endif /* CONFIG_PREALLOC_RX_SKB_BUFFER */
+
+#ifdef CONFIG_IEEE80211W
+ssize_t proc_set_tx_sa_query(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_sa_query(struct seq_file *m, void *v);
+ssize_t proc_set_tx_deauth(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_deauth(struct seq_file *m, void *v);
+ssize_t proc_set_tx_auth(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_auth(struct seq_file *m, void *v);
+#endif /* CONFIG_IEEE80211W */
+
+#endif /* CONFIG_PROC_DEBUG */
+
+int proc_get_efuse_map(struct seq_file *m, void *v);
+ssize_t proc_set_efuse_map(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#endif	//__RTW_DEBUG_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_eeprom.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_eeprom.h
new file mode 100644
index 000000000..689120184
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_eeprom.h
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_EEPROM_H__
+#define __RTW_EEPROM_H__
+
+
+#define	RTL8712_EEPROM_ID			0x8712
+//#define	EEPROM_MAX_SIZE			256
+
+#define	HWSET_MAX_SIZE_128		128
+#define	HWSET_MAX_SIZE_256		256
+#define	HWSET_MAX_SIZE_512		512
+#define HWSET_MAX_SIZE_1024		1024
+
+#define	EEPROM_MAX_SIZE			HWSET_MAX_SIZE_1024
+
+#define	CLOCK_RATE					50			//100us
+
+//- EEPROM opcodes
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      // Erase/write enable
+#define EEPROM_EWDS_OPCODE		16      // Erase/write disable
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later
+#define JAPAN						0x2 //temp, should be provided later
+
+//
+// Customer ID, note that:
+// This variable is initiailzed through EEPROM or registry,
+// however, its definition may be different with that in EEPROM for
+// EEPROM size consideration. So, we have to perform proper translation between them.
+// Besides, CustomerID of registry has precedence of that of EEPROM.
+// defined below. 060703, by rcnjko.
+//
+typedef enum _RT_CUSTOMER_ID
+{
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6,
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,	// Merge by Jacken, 2008/01/31.
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_CHINA_MOBILE = 15,
+	RT_CID_819x_ALPHA = 16,
+	RT_CID_819x_Sitecom = 17,
+	RT_CID_CCX = 18, // It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17.
+	RT_CID_819x_Lenovo = 19,
+	RT_CID_819x_QMI = 20,
+	RT_CID_819x_Edimax_Belkin = 21,
+	RT_CID_819x_Sercomm_Belkin = 22,
+	RT_CID_819x_CAMEO1 = 23,
+	RT_CID_819x_MSI = 24,
+	RT_CID_819x_Acer = 25,
+	RT_CID_819x_AzWave_ASUS = 26,
+	RT_CID_819x_AzWave = 27, // For AzWave in PCIe, The ID is AzWave use and not only Asus
+	RT_CID_819x_HP = 28,
+	RT_CID_819x_WNC_COREGA = 29,
+	RT_CID_819x_Arcadyan_Belkin = 30,
+	RT_CID_819x_SAMSUNG = 31,
+	RT_CID_819x_CLEVO = 32,
+	RT_CID_819x_DELL = 33,
+	RT_CID_819x_PRONETS = 34,
+	RT_CID_819x_Edimax_ASUS = 35,
+	RT_CID_NETGEAR = 36,
+	RT_CID_PLANEX = 37,
+	RT_CID_CC_C = 38,
+	RT_CID_819x_Xavi = 39,
+	RT_CID_LENOVO_CHINA = 40,
+	RT_CID_INTEL_CHINA = 41,
+	RT_CID_TPLINK_HPWR = 42,
+	RT_CID_819x_Sercomm_Netgear = 43,
+	RT_CID_819x_ALPHA_Dlink = 44,//add by ylb 20121012 for customer led for alpha
+	RT_CID_WNC_NEC = 45,//add by page for NEC
+	RT_CID_DNI_BUFFALO = 46,//add by page for NEC
+}RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;
+
+extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
+extern u16 eeprom_read16(_adapter *padapter, u16 reg);
+extern void read_eeprom_content(_adapter *padapter);
+extern void eeprom_read_sz(_adapter * padapter, u16 reg,u8* data, u32 sz);
+
+extern void read_eeprom_content_by_attrib(_adapter *	padapter	);
+
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+extern int isAdaptorInfoFileValid(void);
+extern int storeAdaptorInfoFile(char *path, u8 *efuse_data);
+extern int retriveAdaptorInfoFile(char *path, u8 *efuse_data);
+#endif //CONFIG_ADAPTOR_INFO_CACHING_FILE
+#endif //PLATFORM_LINUX
+
+#endif  //__RTL871X_EEPROM_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_efuse.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_efuse.h
new file mode 100644
index 000000000..caf3e8a78
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_efuse.h
@@ -0,0 +1,220 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_EFUSE_H__
+#define __RTW_EFUSE_H__
+
+
+#define	EFUSE_ERROE_HANDLE		1
+
+#define	PG_STATE_HEADER 		0x01
+#define	PG_STATE_WORD_0		0x02
+#define	PG_STATE_WORD_1		0x04
+#define	PG_STATE_WORD_2		0x08
+#define	PG_STATE_WORD_3		0x10
+#define	PG_STATE_DATA			0x20
+
+#define	PG_SWBYTE_H			0x01
+#define	PG_SWBYTE_L			0x02
+
+#define	PGPKT_DATA_SIZE		8
+
+#define	EFUSE_WIFI				0
+#define	EFUSE_BT				1
+
+enum _EFUSE_DEF_TYPE {
+	TYPE_EFUSE_MAX_SECTION				= 0,
+	TYPE_EFUSE_REAL_CONTENT_LEN			= 1,
+	TYPE_AVAILABLE_EFUSE_BYTES_BANK		= 2,
+	TYPE_AVAILABLE_EFUSE_BYTES_TOTAL	= 3,
+	TYPE_EFUSE_MAP_LEN					= 4,
+	TYPE_EFUSE_PROTECT_BYTES_BANK		= 5,
+	TYPE_EFUSE_CONTENT_LEN_BANK			= 6,
+};
+
+#define		EFUSE_MAX_MAP_LEN		512
+
+#define		EFUSE_MAX_HW_SIZE		512
+#define		EFUSE_MAX_SECTION_BASE	16
+
+#define EXT_HEADER(header) ((header & 0x1F ) == 0x0F)
+#define ALL_WORDS_DISABLED(wde)	((wde & 0x0F) == 0x0F)
+#define GET_HDR_OFFSET_2_0(header) ( (header & 0xE0) >> 5)
+
+#define		EFUSE_REPEAT_THRESHOLD_			3
+
+#define IS_MASKED_MP(ic, txt, offset) (EFUSE_IsAddressMasked_MP_##ic##txt(offset))
+#define IS_MASKED_TC(ic, txt, offset) (EFUSE_IsAddressMasked_TC_##ic##txt(offset))
+#define GET_MASK_ARRAY_LEN_MP(ic, txt) (EFUSE_GetArrayLen_MP_##ic##txt())
+#define GET_MASK_ARRAY_LEN_TC(ic, txt) (EFUSE_GetArrayLen_TC_##ic##txt())
+#define GET_MASK_ARRAY_MP(ic, txt, offset) (EFUSE_GetMaskArray_MP_##ic##txt(offset))
+#define GET_MASK_ARRAY_TC(ic, txt, offset) (EFUSE_GetMaskArray_TC_##ic##txt(offset))
+
+
+#define IS_MASKED(ic, txt, offset) ( IS_MASKED_MP(ic,txt, offset) )
+#define GET_MASK_ARRAY_LEN(ic, txt) ( GET_MASK_ARRAY_LEN_MP(ic,txt) )
+#define GET_MASK_ARRAY(ic, txt, out) do { GET_MASK_ARRAY_MP(ic,txt, out);} while(0)
+
+//=============================================
+//	The following is for BT Efuse definition
+//=============================================
+#define		EFUSE_BT_MAX_MAP_LEN		1024
+#define		EFUSE_MAX_BANK			4
+#define		EFUSE_MAX_BT_BANK		(EFUSE_MAX_BANK-1)
+//=============================================
+/*--------------------------Define Parameters-------------------------------*/
+#define		EFUSE_MAX_WORD_UNIT			4
+
+/*------------------------------Define structure----------------------------*/
+typedef struct PG_PKT_STRUCT_A{
+	u8 offset;
+	u8 word_en;
+	u8 data[8];
+	u8 word_cnts;
+}PGPKT_STRUCT,*PPGPKT_STRUCT;
+
+typedef enum
+{
+	ERR_SUCCESS = 0,
+	ERR_DRIVER_FAILURE,
+	ERR_IO_FAILURE,
+	ERR_WI_TIMEOUT,
+	ERR_WI_BUSY,
+	ERR_BAD_FORMAT,
+	ERR_INVALID_DATA,
+	ERR_NOT_ENOUGH_SPACE,
+	ERR_WRITE_PROTECT,
+	ERR_READ_BACK_FAIL,
+	ERR_OUT_OF_RANGE
+} ERROR_CODE;
+
+/*------------------------------Define structure----------------------------*/
+typedef struct _EFUSE_HAL{
+	u8	fakeEfuseBank;
+	u32	fakeEfuseUsedBytes;
+	u8	fakeEfuseContent[EFUSE_MAX_HW_SIZE];
+	u8	fakeEfuseInitMap[EFUSE_MAX_MAP_LEN];
+	u8	fakeEfuseModifiedMap[EFUSE_MAX_MAP_LEN];
+	u32	EfuseUsedBytes;
+	u8	EfuseUsedPercentage;
+
+	u16	BTEfuseUsedBytes;
+	u8	BTEfuseUsedPercentage;
+	u8	BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+	u8	BTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
+	u8	BTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];
+
+	u16	fakeBTEfuseUsedBytes;
+	u8	fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+	u8	fakeBTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
+	u8	fakeBTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];
+
+	// EFUSE Configuration, initialized in HAL_CmnInitPGData().
+	const u16  MaxSecNum_WiFi;
+	const u16  MaxSecNum_BT;
+	const u16  WordUnit;
+	const u16  PhysicalLen_WiFi;
+	const u16  PhysicalLen_BT;
+	const u16  LogicalLen_WiFi;
+	const u16  LogicalLen_BT;
+	const u16  BankSize;
+	const u16  TotalBankNum;
+	const u16  BankNum_WiFi;
+	const u16  BankNum_BT;
+	const u16  OOBProtectBytes;
+	const u16  ProtectBytes;
+	const u16  BankAvailBytes;
+	const u16  TotalAvailBytes_WiFi;
+	const u16  TotalAvailBytes_BT;
+	const u16  HeaderRetry;
+	const u16  DataRetry;
+
+	ERROR_CODE 	  Status;
+
+}EFUSE_HAL, *PEFUSE_HAL;
+
+extern u8 maskfileBuffer[32];
+
+/*------------------------Export global variable----------------------------*/
+extern u8 fakeEfuseBank;
+extern u32 fakeEfuseUsedBytes;
+extern u8 fakeEfuseContent[];
+extern u8 fakeEfuseInitMap[];
+extern u8 fakeEfuseModifiedMap[];
+
+extern u32 BTEfuseUsedBytes;
+extern u8 BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+extern u8 BTEfuseInitMap[];
+extern u8 BTEfuseModifiedMap[];
+
+extern u32 fakeBTEfuseUsedBytes;
+extern u8 fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+extern u8 fakeBTEfuseInitMap[];
+extern u8 fakeBTEfuseModifiedMap[];
+/*------------------------Export global variable----------------------------*/
+u8	efuse_bt_GetCurrentSize(PADAPTER padapter, u16 *size);
+u16	efuse_bt_GetMaxSize(PADAPTER padapter);
+
+u8	efuse_GetCurrentSize(PADAPTER padapter, u16 *size);
+u16	efuse_GetMaxSize(PADAPTER padapter);
+u8	rtw_efuse_access(PADAPTER padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
+u8	rtw_efuse_mask_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_BT_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8 	rtw_BT_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+
+u16	Efuse_GetCurrentSize(PADAPTER pAdapter, u8 efuseType, BOOLEAN bPseudoTest);
+u8	Efuse_CalculateWordCnts(u8 word_en);
+void	ReadEFuseByte(PADAPTER Adapter, u16 _offset, u8 *pbuf, BOOLEAN bPseudoTest) ;
+void	EFUSE_GetEfuseDefinition(PADAPTER pAdapter, u8 efuseType, u8 type, void *pOut, BOOLEAN bPseudoTest);
+u8	efuse_OneByteRead(PADAPTER pAdapter, u16 addr, u8 *data, BOOLEAN	 bPseudoTest);
+u8	efuse_OneByteWrite(PADAPTER pAdapter, u16 addr, u8 data, BOOLEAN	 bPseudoTest);
+
+void	BTEfuse_PowerSwitch(PADAPTER pAdapter,u8	bWrite,u8	 PwrState);
+void	Efuse_PowerSwitch(PADAPTER pAdapter,u8	bWrite,u8	 PwrState);
+int 	Efuse_PgPacketRead(PADAPTER pAdapter, u8 offset, u8 *data, BOOLEAN bPseudoTest);
+int 	Efuse_PgPacketWrite(PADAPTER pAdapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
+void	efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata);
+u8	Efuse_WordEnableDataWrite(PADAPTER pAdapter, u16 efuse_addr, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
+
+u8	EFUSE_Read1Byte(PADAPTER pAdapter, u16 Address);
+void	EFUSE_ShadowMapUpdate(PADAPTER pAdapter, u8 efuseType, BOOLEAN bPseudoTest);
+void	EFUSE_ShadowRead(PADAPTER pAdapter, u8 Type, u16 Offset, u32 *Value);
+u8 rtw_efuse_file_read(PADAPTER padapter,u8 *filepatch,u8 *buf, u32 len);
+
+#define MAC_HIDDEN_MAX_BW_NUM 8
+extern const u8 _mac_hidden_max_bw_to_hal_bw_cap[];
+#define mac_hidden_max_bw_to_hal_bw_cap(max_bw) (((max_bw) >= MAC_HIDDEN_MAX_BW_NUM) ? 0 : _mac_hidden_max_bw_to_hal_bw_cap[(max_bw)])
+
+#define MAC_HIDDEN_PROTOCOL_NUM 4
+extern const u8 _mac_hidden_proto_to_hal_proto_cap[];
+#define mac_hidden_proto_to_hal_proto_cap(proto) (((proto) >= MAC_HIDDEN_PROTOCOL_NUM) ? 0 : _mac_hidden_proto_to_hal_proto_cap[(proto)])
+
+u8 mac_hidden_wl_func_to_hal_wl_func(u8 func);
+
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+u32 rtw_read_efuse_from_file(const char *path, u8 *buf);
+u32 rtw_read_macaddr_from_file(const char *path, u8 *buf);
+#endif /* CONFIG_EFUSE_CONFIG_FILE */
+#endif /* PLATFORM_LINUX */
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_event.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_event.h
new file mode 100644
index 000000000..d03983e18
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_event.h
@@ -0,0 +1,140 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_EVENT_H_
+#define _RTW_EVENT_H_
+
+#ifdef CONFIG_H2CLBK
+#include <h2clbk.h>
+#endif
+
+/*
+Used to report a bss has been scanned
+
+*/
+struct survey_event	{
+	WLAN_BSSID_EX bss;
+};
+
+/*
+Used to report that the requested site survey has been done.
+
+bss_cnt indicates the number of bss that has been reported.
+
+
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;
+
+};
+
+/*
+Used to report the link result of joinning the given bss
+
+
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+Used to report a given STA has joinned the created BSS.
+It is used in AP/Ad-HoC(M) mode.
+
+
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+
+};
+
+struct stadel_event {
+ unsigned char macaddr[6];
+ unsigned char rsvd[2]; //for reason
+ int mac_id;
+};
+
+struct addba_event
+{
+ 	unsigned int tid;
+};
+
+struct wmm_event
+{
+ 	unsigned char wmm;
+};
+
+#ifdef CONFIG_H2CLBK
+struct c2hlbk_event{
+	unsigned char mac[6];
+	unsigned short	s0;
+	unsigned short	s1;
+	unsigned int	w0;
+	unsigned char	b0;
+	unsigned short  s2;
+	unsigned char	b1;
+	unsigned int	w1;
+};
+#endif//CONFIG_H2CLBK
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+};
+
+
+#define C2HEVENT_SZ			32
+
+struct event_node{
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	volatile int	head;
+	volatile int	tail;
+	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];
+};
+
+
+#endif // _WLANEVENT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ht.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ht.h
new file mode 100644
index 000000000..d1df6de15
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ht.h
@@ -0,0 +1,221 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_HT_H_
+#define _RTW_HT_H_
+
+
+struct ht_priv
+{
+	u8	ht_option;
+	u8	ampdu_enable;//for enable Tx A-MPDU
+	u8	tx_amsdu_enable;//for enable Tx A-MSDU
+	u8	bss_coexist;//for 20/40 Bss coexist
+
+	//u8	baddbareq_issued[16];
+	u32	tx_amsdu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
+	u32	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
+
+	u8 	rx_ampdu_min_spacing;
+
+	u8	ch_offset;//PRIME_CHNL_OFFSET
+	u8	sgi_20m;
+	u8	sgi_40m;
+
+	//for processing Tx A-MPDU
+	u8	agg_enable_bitmap;
+	//u8	ADDBA_retry_count;
+	u8	candidate_tid_bitmap;
+
+	u8	ldpc_cap;
+	u8	stbc_cap;
+	u8	beamform_cap;
+	u8	smps_cap; /*spatial multiplexing power save mode. 0:static SMPS, 1:dynamic SMPS, 3:SMPS disabled, 2:reserved*/
+
+	struct rtw_ieee80211_ht_cap ht_cap;
+
+};
+
+typedef enum AGGRE_SIZE{
+	HT_AGG_SIZE_8K = 0,
+	HT_AGG_SIZE_16K = 1,
+	HT_AGG_SIZE_32K = 2,
+	HT_AGG_SIZE_64K = 3,
+	VHT_AGG_SIZE_128K = 4,
+	VHT_AGG_SIZE_256K = 5,
+	VHT_AGG_SIZE_512K = 6,
+	VHT_AGG_SIZE_1024K = 7,
+}AGGRE_SIZE_E, *PAGGRE_SIZE_E;
+
+typedef enum _RT_HT_INF0_CAP{
+	RT_HT_CAP_USE_TURBO_AGGR = 0x01,
+	RT_HT_CAP_USE_LONG_PREAMBLE = 0x02,
+	RT_HT_CAP_USE_AMPDU = 0x04,
+	RT_HT_CAP_USE_WOW = 0x8,
+	RT_HT_CAP_USE_SOFTAP = 0x10,
+	RT_HT_CAP_USE_92SE = 0x20,
+	RT_HT_CAP_USE_88C_92C = 0x40,
+	RT_HT_CAP_USE_AP_CLIENT_MODE = 0x80,	// AP team request to reserve this bit, by Emily
+}RT_HT_INF0_CAPBILITY, *PRT_HT_INF0_CAPBILITY;
+
+typedef enum _RT_HT_INF1_CAP{
+	RT_HT_CAP_USE_VIDEO_CLIENT = 0x01,
+	RT_HT_CAP_USE_JAGUAR_BCUT = 0x02,
+	RT_HT_CAP_USE_JAGUAR_CCUT = 0x04,
+}RT_HT_INF1_CAPBILITY, *PRT_HT_INF1_CAPBILITY;
+
+#define	LDPC_HT_ENABLE_RX			BIT0
+#define	LDPC_HT_ENABLE_TX			BIT1
+#define	LDPC_HT_TEST_TX_ENABLE		BIT2
+#define	LDPC_HT_CAP_TX				BIT3
+
+#define	STBC_HT_ENABLE_RX			BIT0
+#define	STBC_HT_ENABLE_TX			BIT1
+#define	STBC_HT_TEST_TX_ENABLE		BIT2
+#define	STBC_HT_CAP_TX				BIT3
+
+#define	BEAMFORMING_HT_BEAMFORMER_ENABLE	BIT0	// Declare our NIC supports beamformer
+#define	BEAMFORMING_HT_BEAMFORMEE_ENABLE	BIT1	// Declare our NIC supports beamformee
+#define	BEAMFORMING_HT_BEAMFORMER_TEST		BIT2	// Transmiting Beamforming no matter the target supports it or not
+#define	BEAMFORMING_HT_BEAMFORMER_STEER_NUM		(BIT4|BIT5)
+#define	BEAMFORMING_HT_BEAMFORMEE_CHNL_EST_CAP	(BIT6|BIT7)
+
+//------------------------------------------------------------
+// The HT Control field
+//------------------------------------------------------------
+#define SET_HT_CTRL_CSI_STEERING(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+2, 6, 2, _val)
+#define SET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+3, 0, 1, _val)
+#define GET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+3, 0, 1)
+
+// 20/40 BSS Coexist
+#define SET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 1, _val)
+#define GET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 1)
+
+/* HT Capabilities Info field */
+#define HT_CAP_ELE_CAP_INFO(_pEleStart)					((u8 *)(_pEleStart))
+#define GET_HT_CAP_ELE_LDPC_CAP(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 1)
+#define GET_HT_CAP_ELE_CHL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 1, 1)
+#define GET_HT_CAP_ELE_SM_PS(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 2, 2)
+#define GET_HT_CAP_ELE_GREENFIELD(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 4, 1)
+#define GET_HT_CAP_ELE_SHORT_GI20M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 5, 1)
+#define GET_HT_CAP_ELE_SHORT_GI40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 6, 1)
+#define GET_HT_CAP_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 7, 1)
+#define GET_HT_CAP_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 0, 2)
+#define GET_HT_CAP_ELE_DELAYED_BA(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 2, 1)
+#define GET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 3, 1)
+#define GET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 4, 1)
+#define GET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 6, 1)
+#define GET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart)	LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 7, 1)
+
+#define SET_HT_CAP_ELE_LDPC_CAP(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 1, _val)
+#define SET_HT_CAP_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 1, 1, _val)
+#define SET_HT_CAP_ELE_SM_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 2, 2, _val)
+#define SET_HT_CAP_ELE_GREENFIELD(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 4, 1, _val)
+#define SET_HT_CAP_ELE_SHORT_GI20M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 5, 1, _val)
+#define SET_HT_CAP_ELE_SHORT_GI40M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 6, 1, _val)
+#define SET_HT_CAP_ELE_TX_STBC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 7, 1, _val)
+#define SET_HT_CAP_ELE_RX_STBC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2, _val)
+#define SET_HT_CAP_ELE_DELAYED_BA(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1, _val)
+#define SET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1, _val)
+#define SET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 4, 1, _val)
+#define SET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 6, 1, _val)
+#define SET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 7, 1, _val)
+
+/* A-MPDU Parameters field */
+#define HT_CAP_ELE_AMPDU_PARA(_pEleStart)				(((u8 *)(_pEleStart))+2)
+#define GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(_pEleStart)	LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+2, 0, 2)
+#define GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+2, 2, 3)
+
+#define HT_AMPDU_PARA_FMT "%02x " \
+	"MAX AMPDU len:%u bytes, MIN MPDU Start Spacing:%u"
+
+#define HT_AMPDU_PARA_ARG(x) \
+	*((u8*)(x)) \
+	, (1 << (13+GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(((u8*)x)-2)))-1 \
+	, GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(((u8*)x)-2)
+
+/* Supported MCS Set field */
+#define HT_CAP_ELE_SUP_MCS_SET(_pEleStart)				(((u8 *)(_pEleStart))+3)
+#define HT_CAP_ELE_RX_MCS_MAP(_pEleStart)				HT_CAP_ELE_SUP_MCS_SET(_pEleStart)
+#define GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(_pEleStart)	LE_BITS_TO_2BYTE(((u8 *)(_pEleStart))+13, 0, 10)
+#define GET_HT_CAP_ELE_TX_MCS_DEF(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 0, 1)
+#define GET_HT_CAP_ELE_TRX_MCS_NEQ(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 1, 1)
+#define GET_HT_CAP_ELE_TX_MAX_SS(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 2, 2)
+#define GET_HT_CAP_ELE_TX_UEQM(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 4, 1)
+
+#define HT_SUP_MCS_SET_FMT "%02x %02x %02x %02x %02x%02x%02x%02x%02x%02x" \
+	/* "\n%02x%02x%02x%02x%02x%02x" */\
+	" %uMbps %s%s%s"
+#define HT_SUP_MCS_SET_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
+	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9] \
+	/*,((u8 *)(x))[10],((u8 *)(x))[11], ((u8 *)(x))[12],((u8 *)(x))[13],((u8 *)(x))[14],((u8 *)(x))[15] */\
+	, GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(((u8 *)x)-3) \
+	, GET_HT_CAP_ELE_TX_MCS_DEF(((u8 *)x)-3) ? "TX_MCS_DEF " : "" \
+	, GET_HT_CAP_ELE_TRX_MCS_NEQ(((u8 *)x)-3) ? "TRX_MCS_NEQ " : "" \
+	, GET_HT_CAP_ELE_TX_UEQM(((u8 *)x)-3) ? "TX_UEQM " : ""
+
+//TXBF Capabilities
+#define SET_HT_CAP_TXBF_RECEIVE_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 3, 1, ((u8)_val))
+#define SET_HT_CAP_TXBF_TRANSMIT_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 4, 1, ((u8)_val))
+#define SET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 10, 1, ((u8)_val))
+#define SET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 15, 2, ((u8)_val))
+#define SET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 23, 2, ((u8)_val))
+#define SET_HT_CAP_TXBF_CHNL_ESTIMATION_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 27, 2, ((u8)_val))
+
+
+#define GET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 10, 1)
+#define GET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 15, 2)
+#define GET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart)		LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 23, 2)
+#define GET_HT_CAP_TXBF_CHNL_ESTIMATION_NUM_ANTENNAS(_pEleStart)		LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 27, 2)
+
+/* HT Operation element */
+
+#define GET_HT_OP_ELE_PRI_CHL(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 8)
+#define SET_HT_OP_ELE_PRI_CHL(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 8, _val)
+
+/* HT Operation Info field */
+#define HT_OP_ELE_OP_INFO(_pEleStart)						(((u8 *)(_pEleStart)) + 1)
+#define GET_HT_OP_ELE_2ND_CHL_OFFSET(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2)
+#define GET_HT_OP_ELE_STA_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1)
+#define GET_HT_OP_ELE_RIFS_MODE(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1)
+#define GET_HT_OP_ELE_HT_PROTECT(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2)
+#define GET_HT_OP_ELE_NON_GREEN_PRESENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 1)
+#define GET_HT_OP_ELE_OBSS_NON_HT_PRESENT(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 4, 1)
+#define GET_HT_OP_ELE_DUAL_BEACON(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 4, 6, 1)
+#define GET_HT_OP_ELE_DUAL_CTS(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 4, 7, 1)
+#define GET_HT_OP_ELE_STBC_BEACON(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 0, 1)
+#define GET_HT_OP_ELE_LSIG_TXOP_PROTECT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 1, 1)
+#define GET_HT_OP_ELE_PCO_ACTIVE(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1)
+#define GET_HT_OP_ELE_PCO_PHASE(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1)
+
+#define SET_HT_OP_ELE_2ND_CHL_OFFSET(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2, _val)
+#define SET_HT_OP_ELE_STA_CHL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1, _val)
+#define SET_HT_OP_ELE_RIFS_MODE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1, _val)
+#define SET_HT_OP_ELE_HT_PROTECT(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2, _val)
+#define SET_HT_OP_ELE_NON_GREEN_PRESENT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 1, _val)
+#define SET_HT_OP_ELE_OBSS_NON_HT_PRESENT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 4, 1, _val)
+#define SET_HT_OP_ELE_DUAL_BEACON(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 4, 6, 1, _val)
+#define SET_HT_OP_ELE_DUAL_CTS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 4, 7, 1, _val)
+#define SET_HT_OP_ELE_STBC_BEACON(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 0, 1, _val)
+#define SET_HT_OP_ELE_LSIG_TXOP_PROTECT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 1, 1, _val)
+#define SET_HT_OP_ELE_PCO_ACTIVE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1, _val)
+#define SET_HT_OP_ELE_PCO_PHASE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1, _val)
+
+#endif	//_RTL871X_HT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_io.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_io.h
new file mode 100644
index 000000000..167bd2697
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_io.h
@@ -0,0 +1,578 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _RTW_IO_H_
+#define _RTW_IO_H_
+
+#define NUM_IOREQ		8
+
+#ifdef PLATFORM_WINDOWS
+#define MAX_PROT_SZ	64
+#endif
+#ifdef PLATFORM_LINUX
+#define MAX_PROT_SZ	(64-16)
+#endif
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+// IO COMMAND TYPE
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+
+/*
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+
+
+
+// IO STATUS TYPE
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+
+
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+
+/*
+
+	Only Sync. burst accessing is provided.
+
+*/
+
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+
+
+
+//below is for the intf_option bit defition...
+
+#define _INTF_ASYNC_	BIT(0)	//support async io
+
+struct intf_priv;
+struct intf_hdl;
+struct io_queue;
+
+struct _io_ops
+{
+		u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+		u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+
+		int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+		int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+
+		int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+
+		void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+
+		u32 (*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);
+
+		u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		u32 (*_write_scsi)(struct intf_hdl *pintfhdl,u32 cnt, u8 *pmem);
+
+		void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
+		void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
+
+#ifdef CONFIG_SDIO_HCI
+		u8 (*_sd_f0_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+		u8 (*_sd_iread8)(struct intf_hdl *pintfhdl, u32 addr);
+		u16 (*_sd_iread16)(struct intf_hdl *pintfhdl, u32 addr);
+		u32 (*_sd_iread32)(struct intf_hdl *pintfhdl, u32 addr);
+		int (*_sd_iwrite8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		int (*_sd_iwrite16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		int (*_sd_iwrite32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+		#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
+#endif
+
+};
+
+struct io_req {
+	_list	list;
+	u32	addr;
+	volatile u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;
+	_sema	sema;
+
+#ifdef PLATFORM_OS_CE
+#ifdef CONFIG_USB_HCI
+	// URB handler for rtw_write_mem
+	USB_TRANSFER usb_transfer_write_mem;
+#endif
+#endif
+
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;
+
+#ifdef PLATFORM_OS_XP
+	PMDL pmdl;
+	PIRP  pirp;
+
+#ifdef CONFIG_SDIO_HCI
+	PSDBUS_REQUEST_PACKET sdrp;
+#endif
+
+#endif
+
+
+};
+
+struct	intf_hdl {
+
+/*
+	u32	intf_option;
+	u32	bus_status;
+	u32	do_flush;
+	u8	*adapter;
+	u8	*intf_dev;
+	struct intf_priv	*pintfpriv;
+	u8	cnt;
+	void (*intf_hdl_init)(u8 *priv);
+	void (*intf_hdl_unload)(u8 *priv);
+	void (*intf_hdl_open)(u8 *priv);
+	void (*intf_hdl_close)(u8 *priv);
+	struct	_io_ops	io_ops;
+	//u8 intf_status;//moved to struct intf_priv
+	u16 len;
+	u16 done_len;
+*/
+	_adapter *padapter;
+	struct dvobj_priv *pintf_dev;//	pointer to &(padapter->dvobjpriv);
+
+	struct _io_ops	io_ops;
+
+};
+
+struct reg_protocol_rd {
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	//u32		Value;
+#else
+
+
+//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;
+
+	u32 Reserved2  :24;
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;
+
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;
+	u32 BurstMode :1 ;
+	u32 FixOrContinuous : 1;
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	//u32		Value;
+
+#endif
+
+};
+
+
+struct reg_protocol_wt {
+
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	u32		Value;
+
+#else
+	//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;
+
+	u32 Reserved2  :24;
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;
+	u32 BurstMode :1 ;
+	u32 FixOrContinuous : 1;
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	u32		Value;
+
+#endif
+
+};
+#ifdef CONFIG_PCI_HCI
+#define MAX_CONTINUAL_IO_ERR 4
+#endif
+
+#ifdef CONFIG_USB_HCI
+#define MAX_CONTINUAL_IO_ERR 4
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#define SD_IO_TRY_CNT (8)
+#define MAX_CONTINUAL_IO_ERR SD_IO_TRY_CNT
+#endif
+
+#ifdef CONFIG_GSPI_HCI
+#define SD_IO_TRY_CNT (8)
+#define MAX_CONTINUAL_IO_ERR SD_IO_TRY_CNT
+#endif
+
+
+int rtw_inc_and_chk_continual_io_error(struct dvobj_priv *dvobj);
+void rtw_reset_continual_io_error(struct dvobj_priv *dvobj);
+
+/*
+Below is the data structure used by _io_handler
+
+*/
+
+struct io_queue {
+	_lock	lock;
+	_list  	free_ioreqs;
+	_list		pending;		//The io_req list that will be served in the single protocol read/write.
+	_list		processing;
+	u8	*free_ioreqs_buf; // 4-byte aligned
+	u8	*pallocated_free_ioreqs_buf;
+	struct	intf_hdl	intf;
+};
+
+struct io_priv{
+
+	_adapter *padapter;
+
+	struct intf_hdl intf;
+
+};
+
+extern uint ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+extern void sync_ioreq_enqueue(struct io_req *preq,struct io_queue *ioqueue);
+extern uint sync_ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+
+
+extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
+extern struct io_req *alloc_ioreq(struct io_queue *pio_q);
+
+extern uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl);
+extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);
+
+extern void _rtw_attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern u8 _rtw_read8(_adapter *adapter, u32 addr);
+extern u16 _rtw_read16(_adapter *adapter, u32 addr);
+extern u32 _rtw_read32(_adapter *adapter, u32 addr);
+extern void _rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_read_port_cancel(_adapter *adapter);
+
+
+extern int _rtw_write8(_adapter *adapter, u32 addr, u8 val);
+extern int _rtw_write16(_adapter *adapter, u32 addr, u16 val);
+extern int _rtw_write32(_adapter *adapter, u32 addr, u32 val);
+extern int _rtw_writeN(_adapter *adapter, u32 addr, u32 length, u8 *pdata);
+
+#ifdef CONFIG_SDIO_HCI
+u8 _rtw_sd_f0_read8(_adapter *adapter, u32 addr);
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+u8 _rtw_sd_iread8(_adapter *adapter, u32 addr);
+u16 _rtw_sd_iread16(_adapter *adapter, u32 addr);
+u32 _rtw_sd_iread32(_adapter *adapter, u32 addr);
+int _rtw_sd_iwrite8(_adapter *adapter, u32 addr, u8 val);
+int _rtw_sd_iwrite16(_adapter *adapter, u32 addr, u16 val);
+int _rtw_sd_iwrite32(_adapter *adapter, u32 addr, u32 val);
+#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
+#endif /* CONFIG_SDIO_HCI */
+
+extern int _rtw_write8_async(_adapter *adapter, u32 addr, u8 val);
+extern int _rtw_write16_async(_adapter *adapter, u32 addr, u16 val);
+extern int _rtw_write32_async(_adapter *adapter, u32 addr, u32 val);
+
+extern void _rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern u32 _rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+u32 _rtw_write_port_and_wait(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem, int timeout_ms);
+extern void _rtw_write_port_cancel(_adapter *adapter);
+
+#ifdef DBG_IO
+bool match_read_sniff_ranges(u32 addr, u16 len);
+bool match_write_sniff_ranges(u32 addr, u16 len);
+bool match_rf_read_sniff_ranges(u8 path, u32 addr, u32 mask);
+bool match_rf_write_sniff_ranges(u8 path, u32 addr, u32 mask);
+
+extern u8 dbg_rtw_read8(_adapter *adapter, u32 addr, const char *caller, const int line);
+extern u16 dbg_rtw_read16(_adapter *adapter, u32 addr, const char *caller, const int line);
+extern u32 dbg_rtw_read32(_adapter *adapter, u32 addr, const char *caller, const int line);
+
+extern int dbg_rtw_write8(_adapter *adapter, u32 addr, u8 val, const char *caller, const int line);
+extern int dbg_rtw_write16(_adapter *adapter, u32 addr, u16 val, const char *caller, const int line);
+extern int dbg_rtw_write32(_adapter *adapter, u32 addr, u32 val, const char *caller, const int line);
+extern int dbg_rtw_writeN(_adapter *adapter, u32 addr ,u32 length , u8 *data, const char *caller, const int line);
+
+#ifdef CONFIG_SDIO_HCI
+u8 dbg_rtw_sd_f0_read8(_adapter *adapter, u32 addr, const char *caller, const int line);
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+u8 dbg_rtw_sd_iread8(_adapter *adapter, u32 addr, const char *caller, const int line);
+u16 dbg_rtw_sd_iread16(_adapter *adapter, u32 addr, const char *caller, const int line);
+u32 dbg_rtw_sd_iread32(_adapter *adapter, u32 addr, const char *caller, const int line);
+int dbg_rtw_sd_iwrite8(_adapter *adapter, u32 addr, u8 val, const char *caller, const int line);
+int dbg_rtw_sd_iwrite16(_adapter *adapter, u32 addr, u16 val, const char *caller, const int line);
+int dbg_rtw_sd_iwrite32(_adapter *adapter, u32 addr, u32 val, const char *caller, const int line);
+#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
+#endif /* CONFIG_SDIO_HCI */
+
+#define rtw_read8(adapter, addr) dbg_rtw_read8((adapter), (addr), __FUNCTION__, __LINE__)
+#define rtw_read16(adapter, addr) dbg_rtw_read16((adapter), (addr), __FUNCTION__, __LINE__)
+#define rtw_read32(adapter, addr) dbg_rtw_read32((adapter), (addr), __FUNCTION__, __LINE__)
+#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
+#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
+#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
+
+#define  rtw_write8(adapter, addr, val) dbg_rtw_write8((adapter), (addr), (val), __FUNCTION__, __LINE__)
+#define  rtw_write16(adapter, addr, val) dbg_rtw_write16((adapter), (addr), (val), __FUNCTION__, __LINE__)
+#define  rtw_write32(adapter, addr, val) dbg_rtw_write32((adapter), (addr), (val), __FUNCTION__, __LINE__)
+#define  rtw_writeN(adapter, addr, length, data) dbg_rtw_writeN((adapter), (addr), (length), (data), __FUNCTION__, __LINE__)
+
+#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
+#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
+#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
+
+#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), addr, cnt, mem)
+#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port(adapter, addr, cnt, mem)
+#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
+#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel(adapter)
+
+#ifdef CONFIG_SDIO_HCI
+#define rtw_sd_f0_read8(adapter, addr) dbg_rtw_sd_f0_read8((adapter), (addr), __func__, __LINE__)
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+#define rtw_sd_iread8(adapter, addr) dbg_rtw_sd_iread8((adapter), (addr), __func__, __LINE__)
+#define rtw_sd_iread16(adapter, addr) dbg_rtw_sd_iread16((adapter), (addr), __func__, __LINE__)
+#define rtw_sd_iread32(adapter, addr) dbg_rtw_sd_iread32((adapter), (addr), __func__, __LINE__)
+#define rtw_sd_iwrite8(adapter, addr, val) dbg_rtw_sd_iwrite8((adapter), (addr), (val), __func__, __LINE__)
+#define rtw_sd_iwrite16(adapter, addr, val) dbg_rtw_sd_iwrite16((adapter), (addr), (val), __func__, __LINE__)
+#define rtw_sd_iwrite32(adapter, addr, val) dbg_rtw_sd_iwrite32((adapter), (addr), (val), __func__, __LINE__)
+#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
+#endif /* CONFIG_SDIO_HCI */
+
+#else /* DBG_IO */
+#define match_read_sniff_ranges(addr, len) _FALSE
+#define match_write_sniff_ranges(addr, len) _FALSE
+#define match_rf_read_sniff_ranges(path, addr, mask) _FALSE
+#define match_rf_write_sniff_ranges(path, addr, mask) _FALSE
+#define rtw_read8(adapter, addr) _rtw_read8((adapter), (addr))
+#define rtw_read16(adapter, addr) _rtw_read16((adapter), (addr))
+#define rtw_read32(adapter, addr) _rtw_read32((adapter), (addr))
+#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
+#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
+#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
+
+#define  rtw_write8(adapter, addr, val) _rtw_write8((adapter), (addr), (val))
+#define  rtw_write16(adapter, addr, val) _rtw_write16((adapter), (addr), (val))
+#define  rtw_write32(adapter, addr, val) _rtw_write32((adapter), (addr), (val))
+#define  rtw_writeN(adapter, addr, length, data) _rtw_writeN((adapter), (addr), (length), (data))
+
+#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
+#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
+#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
+
+#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), (addr), (cnt), (mem))
+#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port((adapter), (addr), (cnt), (mem))
+#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
+#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel((adapter))
+
+#ifdef CONFIG_SDIO_HCI
+#define rtw_sd_f0_read8(adapter, addr) _rtw_sd_f0_read8((adapter), (addr))
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+#define rtw_sd_iread8(adapter, addr) _rtw_sd_iread8((adapter), (addr))
+#define rtw_sd_iread16(adapter, addr) _rtw_sd_iread16((adapter), (addr))
+#define rtw_sd_iread32(adapter, addr) _rtw_sd_iread32((adapter), (addr))
+#define rtw_sd_iwrite8(adapter, addr, val) _rtw_sd_iwrite8((adapter), (addr), (val))
+#define rtw_sd_iwrite16(adapter, addr, val) _rtw_sd_iwrite16((adapter), (addr), (val))
+#define rtw_sd_iwrite32(adapter, addr, val) _rtw_sd_iwrite32((adapter), (addr), (val))
+#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
+#endif /* CONFIG_SDIO_HCI */
+
+#endif /* DBG_IO */
+
+extern void rtw_write_scsi(_adapter *adapter, u32 cnt, u8 *pmem);
+
+//ioreq
+extern void ioreq_read8(_adapter *adapter, u32 addr, u8 *pval);
+extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);
+extern void ioreq_read32(_adapter *adapter, u32 addr, u32 *pval);
+extern void ioreq_write8(_adapter *adapter, u32 addr, u8 val);
+extern void ioreq_write16(_adapter *adapter, u32 addr, u16 val);
+extern void ioreq_write32(_adapter *adapter, u32 addr, u32 val);
+
+
+extern uint async_read8(_adapter *adapter, u32 addr, u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern uint async_read16(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern uint async_read32(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern void async_write8(_adapter *adapter, u32 addr, u8 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write16(_adapter *adapter, u32 addr, u16 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write32(_adapter *adapter, u32 addr, u32 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+
+int rtw_init_io_priv(_adapter *padapter, void (*set_intf_ops)(_adapter *padapter,struct _io_ops *pops));
+
+
+extern uint alloc_io_queue(_adapter *adapter);
+extern void free_io_queue(_adapter *adapter);
+extern void async_bus_io(struct io_queue *pio_q);
+extern void bus_sync_io(struct io_queue *pio_q);
+extern u32 _ioreq2rwmem(struct io_queue *pio_q);
+extern void dev_power_down(_adapter * Adapter, u8 bpwrup);
+
+/*
+#define RTL_R8(reg)		rtw_read8(padapter, reg)
+#define RTL_R16(reg)            rtw_read16(padapter, reg)
+#define RTL_R32(reg)            rtw_read32(padapter, reg)
+#define RTL_W8(reg, val8)       rtw_write8(padapter, reg, val8)
+#define RTL_W16(reg, val16)     rtw_write16(padapter, reg, val16)
+#define RTL_W32(reg, val32)     rtw_write32(padapter, reg, val32)
+*/
+
+/*
+#define RTL_W8_ASYNC(reg, val8) rtw_write32_async(padapter, reg, val8)
+#define RTL_W16_ASYNC(reg, val16) rtw_write32_async(padapter, reg, val16)
+#define RTL_W32_ASYNC(reg, val32) rtw_write32_async(padapter, reg, val32)
+
+#define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(padapter, reg, val32)
+#define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
+*/
+
+#define PlatformEFIOWrite1Byte(_a,_b,_c)		\
+	rtw_write8(_a,_b,_c)
+#define PlatformEFIOWrite2Byte(_a,_b,_c)		\
+	rtw_write16(_a,_b,_c)
+#define PlatformEFIOWrite4Byte(_a,_b,_c)		\
+	rtw_write32(_a,_b,_c)
+
+#define PlatformEFIORead1Byte(_a,_b)		\
+		rtw_read8(_a,_b)
+#define PlatformEFIORead2Byte(_a,_b)		\
+		rtw_read16(_a,_b)
+#define PlatformEFIORead4Byte(_a,_b)		\
+		rtw_read32(_a,_b)
+
+#endif	//_RTL8711_IO_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl.h
new file mode 100644
index 000000000..a355965d9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl.h
@@ -0,0 +1,329 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_IOCTL_H_
+#define _RTW_IOCTL_H_
+
+#ifndef PLATFORM_WINDOWS
+//	00 - Success
+//	11 - Error
+#define STATUS_SUCCESS				(0x00000000L)
+#define STATUS_PENDING				(0x00000103L)
+
+#define STATUS_UNSUCCESSFUL			(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
+#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
+
+#define NDIS_STATUS_SUCCESS			((NDIS_STATUS)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING			((NDIS_STATUS)STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED		((NDIS_STATUS)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED			((NDIS_STATUS)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED		((NDIS_STATUS)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE			((NDIS_STATUS)0x00010007L)
+
+#define NDIS_STATUS_FAILURE			((NDIS_STATUS)STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES			((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING			((NDIS_STATUS)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION			((NDIS_STATUS)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS		((NDIS_STATUS)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND		((NDIS_STATUS)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED			((NDIS_STATUS)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED		((NDIS_STATUS)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL		((NDIS_STATUS)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS		((NDIS_STATUS)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND		((NDIS_STATUS)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED		((NDIS_STATUS)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS		((NDIS_STATUS)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING		((NDIS_STATUS)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED		((NDIS_STATUS)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET		((NDIS_STATUS)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL		((NDIS_STATUS)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY		((NDIS_STATUS)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN		((NDIS_STATUS)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING		((NDIS_STATUS)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH		((NDIS_STATUS)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA		((NDIS_STATUS)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT		((NDIS_STATUS)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID			((NDIS_STATUS)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED		((NDIS_STATUS)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA		((NDIS_STATUS)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE	((NDIS_STATUS)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND		((NDIS_STATUS)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE		((NDIS_STATUS)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED		((NDIS_STATUS)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT		((NDIS_STATUS)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE			((NDIS_STATUS)0xC001001FL)
+
+#define NDIS_STATUS_INVALID_SAP			((NDIS_STATUS)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE			((NDIS_STATUS)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS		((NDIS_STATUS)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED		((NDIS_STATUS)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER		((NDIS_STATUS)0xC0010024L)  // cause 27
+#define NDIS_STATUS_VC_NOT_AVAILABLE		((NDIS_STATUS)0xC0010025L)  // cause 35,45
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE	((NDIS_STATUS)0xC0010026L)  // cause 37
+#define NDIS_STATUS_INCOMPATABLE_QOS		((NDIS_STATUS)0xC0010027L)  // cause 49
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED	((NDIS_STATUS)0xC0010028L)  // cause 93
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION	((NDIS_STATUS)0xC0010029L)  // cause 3
+#endif /* #ifndef PLATFORM_WINDOWS */
+
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+// For DDK-defined OIDs
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+
+#define SZ_OID_NDIS_SEG1		  23
+#define SZ_OID_NDIS_SEG2		    3
+#define SZ_OID_NDIS_SEG3		    6
+#define SZ_OID_NDIS_SEG4		    6
+#define SZ_OID_NDIS_SEG5		    4
+#define SZ_OID_NDIS_SEG6		    8
+#define SZ_OID_NDIS_SEG7		    7
+#define SZ_OID_NDIS_SEG8		  36
+#define SZ_OID_NDIS_SEG9		  24
+#define SZ_OID_NDIS_SEG10		  19
+
+// For Realtek-defined OIDs
+#define OID_MP_SEG1		0xFF871100
+#define OID_MP_SEG2		0xFF818000
+
+#define OID_MP_SEG3		0xFF818700
+#define OID_MP_SEG4		0xFF011100
+
+#define DEBUG_OID(dbg, str)     		\
+       if((!dbg))				    			\
+      	{					    			\
+	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __FUNCTION__, __LINE__, str));	\
+      	}
+
+
+enum oid_type
+{
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; //the starting number for OID
+	unsigned int oid_end; //the ending number for OID
+	struct oid_obj_priv *node_array;
+	unsigned int array_sz; //the size of node_array
+	int query_counter; //count the number of query hits for this segment
+	int set_counter; //count the number of set hits for this segment
+};
+
+struct oid_par_priv
+{
+	void		*adapter_context;
+	NDIS_OID	oid;
+	void		*information_buf;
+	u32		information_buf_len;
+	u32		*bytes_rw;
+	u32		*bytes_needed;
+	enum oid_type	type_of_oid;
+	u32		dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message
+	NDIS_STATUS (*oidfuns)(struct oid_par_priv *poid_par_priv);
+};
+
+#if (defined(CONFIG_MP_INCLUDED) && defined(_RTW_MP_IOCTL_C_)) || \
+	(defined(PLATFORM_WINDOWS) && defined(_RTW_IOCTL_RTL_C_))
+static NDIS_STATUS oid_null_function(struct oid_par_priv* poid_par_priv)
+{
+	_func_enter_;
+	_func_exit_;
+	return NDIS_STATUS_SUCCESS;
+}
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+int TranslateNdisPsToRtPs(IN NDIS_802_11_POWER_MODE	ndisPsMode);
+
+//OID Handler for Segment 1
+NDIS_STATUS oid_gen_supported_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_hardware_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_in_use_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_lookahead_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_frame_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_link_speed_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_transmit_buffer_space_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_receive_buffer_space_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_transmit_block_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_receive_block_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_id_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_description_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_current_packet_filter_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_current_lookahead_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_driver_version_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_total_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_protocol_options_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_mac_options_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_connect_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_send_packets_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_driver_version_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 2
+NDIS_STATUS oid_gen_physical_medium_hdl(struct oid_par_priv* poid_par_priv);
+
+//OID Handler for Segment 3
+NDIS_STATUS oid_gen_xmit_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_xmit_error_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_error_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_no_buffer_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 4
+NDIS_STATUS oid_802_3_permanent_address_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_current_address_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_multicast_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_maximum_list_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_mac_options_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 5
+NDIS_STATUS oid_802_3_rcv_error_alignment_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_one_collision_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_more_collisions_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 6
+NDIS_STATUS oid_802_3_xmit_deferred_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_max_collisions_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_rcv_overrun_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_underrun_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_heartbeat_failure_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_times_crs_lost_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_late_collisions_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 7
+NDIS_STATUS oid_pnp_capabilities_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_set_power_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_query_power_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_add_wake_up_pattern_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_remove_wake_up_pattern_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_wake_up_pattern_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_enable_wake_up_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 8
+NDIS_STATUS oid_802_11_bssid_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_ssid_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_infrastructure_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_add_wep_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_remove_wep_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_disassociate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_authentication_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_privacy_filter_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_bssid_list_scan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_encryption_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_reload_defaults_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_add_key_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_remove_key_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_association_information_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_media_stream_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_capability_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_pmkid_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+
+//OID Handler for Segment 9
+NDIS_STATUS oid_802_11_network_types_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_network_type_in_use_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rssi_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rssi_trigger_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_fragmentation_threshold_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rts_threshold_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_number_of_antennas_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rx_antenna_selected_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_tx_antenna_selected_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_supported_rates_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_desired_rates_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_configuration_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_bssid_list_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 10
+NDIS_STATUS oid_802_11_statistics_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment ED
+NDIS_STATUS oid_rt_mh_vender_id_hdl(struct oid_par_priv* poid_par_priv);
+
+void Set_802_3_MULTICAST_LIST(ADAPTER *pAdapter, UCHAR *MCListbuf, ULONG MCListlen, BOOLEAN bAcceptAllMulticast);
+
+#endif// end of PLATFORM_WINDOWS
+
+#if defined(PLATFORM_LINUX) && defined(CONFIG_WIRELESS_EXT)
+extern struct iw_handler_def  rtw_handlers_def;
+#endif
+
+extern void rtw_request_wps_pbc_event(_adapter *padapter);
+
+extern	NDIS_STATUS drv_query_info(
+	IN	_nic_hdl		MiniportAdapterContext,
+	IN	NDIS_OID		Oid,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32*			BytesWritten,
+	OUT	u32*			BytesNeeded
+	);
+
+extern	NDIS_STATUS 	drv_set_info(
+	IN	_nic_hdl		MiniportAdapterContext,
+	IN	NDIS_OID		Oid,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32*			BytesRead,
+	OUT	u32*			BytesNeeded
+	);
+
+#endif // #ifndef __INC_CEINFO_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_query.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_query.h
new file mode 100644
index 000000000..66eb063fb
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_query.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_IOCTL_QUERY_H_
+#define _RTW_IOCTL_QUERY_H_
+
+
+#ifdef PLATFORM_WINDOWS
+
+u8 query_802_11_capability(_adapter*	padapter,u8*	pucBuf,u32 *	pulOutLen);
+u8 query_802_11_association_information (_adapter * padapter, PNDIS_802_11_ASSOCIATION_INFORMATION pAssocInfo);
+
+#endif
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_rtl.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_rtl.h
new file mode 100644
index 000000000..ea3f6c9c4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_rtl.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_IOCTL_RTL_H_
+#define _RTW_IOCTL_RTL_H_
+
+
+//************** oid_rtl_seg_01_01 **************
+NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);//84
+NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv);	//8a
+NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv);	//8b
+
+NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv);//93
+NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_bcn_intvl_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_dedicate_probe_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_current_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_forced_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+//**************  oid_rtl_seg_01_03 section start **************
+NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv);
+
+// oid_rtl_seg_01_11
+NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv);
+
+//**************  oid_rtl_seg_03_00 section start **************
+NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_set.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_set.h
new file mode 100644
index 000000000..18c03ac00
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_ioctl_set.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_IOCTL_SET_H_
+#define __RTW_IOCTL_SET_H_
+
+
+typedef u8 NDIS_802_11_PMKID_VALUE[16];
+
+typedef struct _BSSIDInfo {
+	NDIS_802_11_MAC_ADDRESS  BSSID;
+	NDIS_802_11_PMKID_VALUE  PMKID;
+} BSSIDInfo, *PBSSIDInfo;
+
+
+#ifdef PLATFORM_OS_XP
+typedef struct _NDIS_802_11_PMKID {
+	u32	Length;
+	u32	BSSIDInfoCount;
+	BSSIDInfo BSSIDInfo[1];
+} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+u8 rtw_set_802_11_reload_defaults(_adapter * padapter, NDIS_802_11_RELOAD_DEFAULTS reloadDefaults);
+u8 rtw_set_802_11_test(_adapter * padapter, NDIS_802_11_TEST * test);
+u8 rtw_set_802_11_pmkid(_adapter *pdapter, NDIS_802_11_PMKID *pmkid);
+
+u8 rtw_pnp_set_power_sleep(_adapter* padapter);
+u8 rtw_pnp_set_power_wakeup(_adapter* padapter);
+
+void rtw_pnp_resume_wk(void *context);
+void rtw_pnp_sleep_wk(void * context);
+
+#endif
+
+u8 rtw_set_802_11_add_key(_adapter * padapter, NDIS_802_11_KEY * key);
+u8 rtw_set_802_11_authentication_mode(_adapter *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
+u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid);
+u8 rtw_set_802_11_add_wep(_adapter * padapter, NDIS_802_11_WEP * wep);
+u8 rtw_set_802_11_disassociate(_adapter * padapter);
+u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, int ssid_max_num);
+u8 rtw_set_802_11_infrastructure_mode(_adapter * padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 rtw_set_802_11_remove_wep(_adapter * padapter, u32 keyindex);
+u8 rtw_set_802_11_ssid(_adapter * padapter, NDIS_802_11_SSID * ssid);
+u8 rtw_set_802_11_connect(_adapter* padapter, u8 *bssid, NDIS_802_11_SSID *ssid);
+u8 rtw_set_802_11_remove_key(_adapter * padapter, NDIS_802_11_REMOVE_KEY * key);
+
+u8 rtw_validate_bssid(u8 *bssid);
+u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);
+
+u16 rtw_get_cur_max_rate(_adapter *adapter);
+int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode);
+int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan);
+int rtw_set_country(_adapter *adapter, const char *country_code);
+int rtw_set_band(_adapter *adapter, u8 band);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_iol.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_iol.h
new file mode 100644
index 000000000..07ba535e1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_iol.h
@@ -0,0 +1,137 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_IOL_H_
+#define __RTW_IOL_H_
+
+
+struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter);
+int rtw_IOL_append_cmds(struct xmit_frame *xmit_frame, u8 *IOL_cmds, u32 cmd_len);
+int rtw_IOL_append_LLT_cmd(struct xmit_frame *xmit_frame, u8 page_boundary);
+int rtw_IOL_exec_cmds_sync(ADAPTER *adapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
+bool rtw_IOL_applied(ADAPTER *adapter);
+int rtw_IOL_append_DELAY_US_cmd(struct xmit_frame *xmit_frame, u16 us);
+int rtw_IOL_append_DELAY_MS_cmd(struct xmit_frame *xmit_frame, u16 ms);
+int rtw_IOL_append_END_cmd(struct xmit_frame *xmit_frame);
+
+
+#ifdef CONFIG_IOL_NEW_GENERATION
+#define IOREG_CMD_END_LEN	4
+
+struct ioreg_cfg{
+	u8 	length;
+	u8 	cmd_id;
+	u16 	address;
+	u32	data;
+	u32  mask;
+};
+enum ioreg_cmd{
+	IOREG_CMD_LLT 			= 0x01,
+	IOREG_CMD_REFUSE 		= 0x02,
+	IOREG_CMD_EFUSE_PATH = 0x03,
+	IOREG_CMD_WB_REG		= 0x04,
+	IOREG_CMD_WW_REG	= 0x05,
+	IOREG_CMD_WD_REG 	= 0x06,
+	IOREG_CMD_W_RF 		= 0x07,
+	IOREG_CMD_DELAY_US 	= 0x10,
+	IOREG_CMD_DELAY_MS	= 0x11,
+	IOREG_CMD_END 		= 0xFF,
+};
+void read_efuse_from_txpktbuf(ADAPTER *adapter, int bcnhead, u8 *content, u16 *size);
+
+int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value, u8 mask);
+int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value, u16 mask);
+int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value, u32 mask);
+int _rtw_IOL_append_WRF_cmd(struct xmit_frame *xmit_frame, u8 rf_path, u16 addr, u32 value, u32 mask);
+#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value,mask) _rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value) ,(mask))
+#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value,mask) _rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value),(mask))
+#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value,mask) _rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value),(mask))
+#define rtw_IOL_append_WRF_cmd(xmit_frame, rf_path, addr, value,mask) _rtw_IOL_append_WRF_cmd((xmit_frame),(rf_path), (addr), (value),(mask))
+
+u8 rtw_IOL_cmd_boundary_handle(struct xmit_frame *pxmit_frame);
+void  rtw_IOL_cmd_buf_dump(ADAPTER *Adapter,int buf_len,u8 *pbuf);
+
+#ifdef CONFIG_IOL_IOREG_CFG_DBG
+	struct cmd_cmp{
+		u16 addr;
+		u32 value;
+	};
+#endif
+
+#else //CONFIG_IOL_NEW_GENERATION
+
+typedef struct _io_offload_cmd {
+	u8 rsvd0;
+	u8 cmd;
+	u16 address;
+	u32 value;
+} IO_OFFLOAD_CMD, IOL_CMD;
+
+#define IOL_CMD_LLT			0x00
+//#define IOL_CMD_R_EFUSE	0x01
+#define IOL_CMD_WB_REG		0x02
+#define IOL_CMD_WW_REG 	0x03
+#define IOL_CMD_WD_REG		0x04
+//#define IOL_CMD_W_RF		0x05
+#define IOL_CMD_DELAY_US	0x80
+#define IOL_CMD_DELAY_MS	0x81
+//#define IOL_CMD_DELAY_S	0x82
+#define IOL_CMD_END			0x83
+
+/*****************************************************
+CMD					Address			Value
+(B1)					(B2/B3:H/L addr)	(B4:B7 : MSB:LSB)
+******************************************************
+IOL_CMD_LLT			-				B7: PGBNDY
+//IOL_CMD_R_EFUSE	-				-
+IOL_CMD_WB_REG		0x0~0xFFFF		B7
+IOL_CMD_WW_REG	0x0~0xFFFF		B6~B7
+IOL_CMD_WD_REG	0x0~0xFFFF		B4~B7
+//IOL_CMD_W_RF		RF Reg			B5~B7
+IOL_CMD_DELAY_US	-				B6~B7
+IOL_CMD_DELAY_MS	-				B6~B7
+//IOL_CMD_DELAY_S	-				B6~B7
+IOL_CMD_END		-				-
+******************************************************/
+int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value);
+int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value);
+int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value);
+
+
+int rtw_IOL_exec_cmd_array_sync(PADAPTER adapter, u8 *IOL_cmds, u32 cmd_num, u32 max_wating_ms);
+int rtw_IOL_exec_empty_cmds_sync(ADAPTER *adapter, u32 max_wating_ms);
+
+#ifdef DBG_IO
+int dbg_rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value, const char *caller, const int line);
+int dbg_rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value, const char *caller, const int line);
+int dbg_rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value, const char *caller, const int line);
+#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value), __FUNCTION__, __LINE__)
+#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value), __FUNCTION__, __LINE__)
+#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value), __FUNCTION__, __LINE__)
+#else
+#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value) _rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value))
+#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value) _rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value))
+#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value) _rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value))
+#endif // DBG_IO
+#endif // CONFIG_IOL_NEW_GENERATION
+
+
+
+#endif //__RTW_IOL_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mem.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mem.h
new file mode 100644
index 000000000..3b7c684eb
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mem.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MEM_H__
+#define __RTW_MEM_H__
+
+#include <drv_conf.h>
+#include <basic_types.h>
+#include <osdep_service.h>
+
+#ifdef CONFIG_PLATFORM_MSTAR_HIGH
+#define MAX_RTKM_RECVBUF_SZ (31744) /* 31k */
+#else
+#define MAX_RTKM_RECVBUF_SZ (15360) /* 15k */
+#endif /* CONFIG_PLATFORM_MSTAR_HIGH */
+#define MAX_RTKM_NR_PREALLOC_RECV_SKB 16
+
+u16 rtw_rtkm_get_buff_size(void);
+u8 rtw_rtkm_get_nr_recv_skb(void);
+struct u8* rtw_alloc_revcbuf_premem(void);
+struct sk_buff *rtw_alloc_skb_premem(u16 in_size);
+int rtw_free_skb_premem(struct sk_buff *pskb);
+
+
+#endif //__RTW_MEM_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme.h
new file mode 100644
index 000000000..9cfd43da5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme.h
@@ -0,0 +1,1070 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MLME_H_
+#define __RTW_MLME_H_
+
+
+#define	MAX_BSS_CNT	128
+//#define   MAX_JOIN_TIMEOUT	2000
+//#define   MAX_JOIN_TIMEOUT	2500
+#define   MAX_JOIN_TIMEOUT	6500
+
+//	Commented by Albert 20101105
+//	Increase the scanning timeout because of increasing the SURVEY_TO value.
+
+#define SCANNING_TIMEOUT 8000
+#ifdef CONFIG_SCAN_BACKOP
+#define CONC_SCANNING_TIMEOUT_SINGLE_BAND 10000
+#define CONC_SCANNING_TIMEOUT_DUAL_BAND 15000
+#endif
+
+#ifdef PALTFORM_OS_WINCE
+#define	SCANQUEUE_LIFETIME 12000000 // unit:us
+#else
+#define	SCANQUEUE_LIFETIME 20000 // 20sec, unit:msec
+#endif
+
+#define WIFI_NULL_STATE					0x00000000
+#define WIFI_ASOC_STATE					0x00000001 /* Linked */
+#define WIFI_REASOC_STATE				0x00000002
+#define WIFI_SLEEP_STATE				0x00000004
+#define WIFI_STATION_STATE				0x00000008
+#define WIFI_AP_STATE					0x00000010
+#define WIFI_ADHOC_STATE				0x00000020
+#define WIFI_ADHOC_MASTER_STATE			0x00000040
+#define WIFI_UNDER_LINKING				0x00000080
+#define WIFI_UNDER_WPS					0x00000100
+/*#define WIFI_UNDEFINED_STATE			0x00000200*/
+#define WIFI_STA_ALIVE_CHK_STATE		0x00000400
+#define WIFI_SITE_MONITOR				0x00000800 /* under site surveying */
+#define WIFI_WDS						0x00001000
+#define WIFI_WDS_RX_BEACON				0x00002000 /* already rx WDS AP beacon */
+#define WIFI_AUTOCONF					0x00004000
+#define WIFI_AUTOCONF_IND				0x00008000
+#define WIFI_MP_STATE					0x00010000
+#define WIFI_MP_CTX_BACKGROUND			0x00020000 /* in continuous tx background */
+#define WIFI_MP_CTX_ST					0x00040000 /* in continuous tx with single-tone */
+#define WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in continuous tx background due to out of skb */
+#define WIFI_MP_CTX_CCK_HW				0x00100000 /* in continuous tx */
+#define WIFI_MP_CTX_CCK_CS				0x00200000 /* in continuous tx with carrier suppression */
+#define WIFI_MP_LPBK_STATE				0x00400000
+#define WIFI_OP_CH_SWITCHING			0x00800000
+/*#define WIFI_UNDEFINED_STATE			0x01000000*/
+/*#define WIFI_UNDEFINED_STATE			0x02000000*/
+/*#define WIFI_UNDEFINED_STATE			0x04000000*/
+/*#define WIFI_UNDEFINED_STATE			0x08000000*/
+/*#define WIFI_UNDEFINED_STATE			0x10000000*/
+/*#define WIFI_UNDEFINED_STATE			0x20000000*/
+/*#define WIFI_UNDEFINED_STATE			0x40000000*/
+#define WIFI_MONITOR_STATE				0x80000000
+
+#define MIRACAST_DISABLED	0
+#define MIRACAST_SOURCE		BIT0
+#define MIRACAST_SINK		BIT1
+
+#define MIRACAST_MODE_REVERSE(mode) \
+	((((mode) & MIRACAST_SOURCE) ? MIRACAST_SINK : 0) | (((mode) & MIRACAST_SINK) ? MIRACAST_SOURCE : 0))
+
+bool is_miracast_enabled(_adapter *adapter);
+bool rtw_chk_miracast_mode(_adapter *adapter, u8 mode);
+const char *get_miracast_mode_str(int mode);
+void rtw_wfd_st_switch(struct sta_info *sta, bool on);
+
+#define MLME_STATE(adapter) get_fwstate(&((adapter)->mlmepriv))
+
+#define MLME_IS_STA(adapter) (MLME_STATE((adapter)) & WIFI_STATION_STATE)
+#define MLME_IS_AP(adapter) (MLME_STATE((adapter)) & WIFI_AP_STATE)
+#define MLME_IS_ADHOC(adapter) (MLME_STATE((adapter)) & WIFI_ADHOC_STATE)
+#define MLME_IS_ADHOC_MASTER(adapter) (MLME_STATE((adapter)) & WIFI_ADHOC_MASTER_STATE)
+#define MLME_IS_MONITOR(adapter) (MLME_STATE((adapter)) & WIFI_MONITOR_STATE)
+#define MLME_IS_MP(adapter) (MLME_STATE((adapter)) & WIFI_MP_STATE)
+#define MLME_IS_GC(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_CLIENT)
+#define MLME_IS_GO(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_GO)
+#define MLME_IS_MSRC(adapter) rtw_chk_miracast_mode((adapter), MIRACAST_SOURCE)
+#define MLME_IS_MSINK(adapter) rtw_chk_miracast_mode((adapter), MIRACAST_SINK)
+
+#define MLME_STATE_FMT "%s%s%s%s%s%s%s%s%s%s%s%s%s%s"
+#define MLME_STATE_ARG(adapter) \
+	MLME_IS_STA((adapter)) ? (MLME_IS_GC((adapter)) ? " GC" : " STA") : "", \
+	MLME_IS_AP((adapter)) ? (MLME_IS_GO((adapter)) ? " GO" : " AP") : "", \
+	MLME_IS_ADHOC((adapter)) ? " ADHOC" : "", \
+	MLME_IS_ADHOC_MASTER((adapter)) ? " ADHOC_M" : "", \
+	MLME_IS_MONITOR((adapter)) ? " MONITOR" : "", \
+	MLME_IS_MP((adapter)) ? " MP" : "", \
+	MLME_IS_MSRC((adapter)) ? " MSRC" : "", \
+	MLME_IS_MSINK((adapter)) ? " MSINK" : "", \
+	(MLME_STATE((adapter)) & WIFI_SITE_MONITOR) ? " SCAN" : "", \
+	(MLME_STATE((adapter)) & WIFI_UNDER_LINKING) ? " LINKING" : "", \
+	(MLME_STATE((adapter)) & WIFI_ASOC_STATE) ? " ASOC" : "", \
+	(MLME_STATE((adapter)) & WIFI_OP_CH_SWITCHING) ? " OP_CH_SW" : "", \
+	(MLME_STATE((adapter)) & WIFI_UNDER_WPS) ? " WPS" : "", \
+	(MLME_STATE((adapter)) & WIFI_SLEEP_STATE) ? " SLEEP" : ""
+
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED			WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+
+enum dot11AuthAlgrthmNum {
+ dot11AuthAlgrthm_Open = 0,
+ dot11AuthAlgrthm_Shared,
+ dot11AuthAlgrthm_8021X,
+ dot11AuthAlgrthm_Auto,
+ dot11AuthAlgrthm_WAPI,
+ dot11AuthAlgrthm_MaxNum
+};
+
+// Scan type including active and passive scan.
+typedef enum _RT_SCAN_TYPE
+{
+	SCAN_PASSIVE,
+	SCAN_ACTIVE,
+	SCAN_MIX,
+}RT_SCAN_TYPE, *PRT_SCAN_TYPE;
+
+#define WIFI_FREQUENCY_BAND_AUTO 0
+#define WIFI_FREQUENCY_BAND_5GHZ 1
+#define WIFI_FREQUENCY_BAND_2GHZ 2
+
+#define rtw_band_valid(band) ((band) <= WIFI_FREQUENCY_BAND_2GHZ)
+
+enum DriverInterface {
+	DRIVER_WEXT =  1,
+	DRIVER_CFG80211 = 2
+};
+
+enum SCAN_RESULT_TYPE
+{
+	SCAN_RESULT_P2P_ONLY = 0,		//	Will return all the P2P devices.
+	SCAN_RESULT_ALL = 1,			//	Will return all the scanned device, include AP.
+	SCAN_RESULT_WFD_TYPE = 2		//	Will just return the correct WFD device.
+									//	If this device is Miracast sink device, it will just return all the Miracast source devices.
+};
+
+/*
+
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+
+
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+
+*/
+
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	sint	traffic_busy;
+	_timer	sitesurvey_ctrl_timer;
+};
+
+typedef struct _RT_LINK_DETECT_T{
+	u32				NumTxOkInPeriod;
+	u32				NumRxOkInPeriod;
+	u32				NumRxUnicastOkInPeriod;
+	BOOLEAN			bBusyTraffic;
+	BOOLEAN			bTxBusyTraffic;
+	BOOLEAN			bRxBusyTraffic;
+	BOOLEAN			bHigherBusyTraffic; // For interrupt migration purpose.
+	BOOLEAN			bHigherBusyRxTraffic; // We may disable Tx interrupt according as Rx traffic.
+	BOOLEAN			bHigherBusyTxTraffic; // We may disable Tx interrupt according as Tx traffic.
+	//u8 TrafficBusyState;
+	u8 TrafficTransitionCount;
+	u32 LowPowerTransitionCount;
+}RT_LINK_DETECT_T, *PRT_LINK_DETECT_T;
+
+struct profile_info {
+	u8	ssidlen;
+	u8	ssid[ WLAN_SSID_MAXLEN ];
+	u8	peermac[ ETH_ALEN ];
+};
+
+struct tx_invite_req_info{
+	u8					token;
+	u8					benable;
+	u8					go_ssid[ WLAN_SSID_MAXLEN ];
+	u8					ssidlen;
+	u8					go_bssid[ ETH_ALEN ];
+	u8					peer_macaddr[ ETH_ALEN ];
+	u8					operating_ch;	//	This information will be set by using the p2p_set op_ch=x
+	u8					peer_ch;		//	The listen channel for peer P2P device
+
+};
+
+struct tx_invite_resp_info{
+	u8					token;	//	Used to record the dialog token of p2p invitation request frame.
+};
+
+#ifdef CONFIG_WFD
+
+struct wifi_display_info{
+	u16							wfd_enable;			//	Eanble/Disable the WFD function.
+	u16							init_rtsp_ctrlport;	/* init value of rtsp_ctrlport when WFD enable */
+	u16							rtsp_ctrlport;		/* TCP port number at which the this WFD device listens for RTSP messages, 0 when WFD disable */
+	u16							tdls_rtsp_ctrlport;	/* rtsp_ctrlport used by tdls, will sync when rtsp_ctrlport is changed by user */
+	u16							peer_rtsp_ctrlport;	//	TCP port number at which the peer WFD device listens for RTSP messages
+													//	This filed should be filled when receiving the gropu negotiation request
+
+	u8							peer_session_avail;	//	WFD session is available or not for the peer wfd device.
+													//	This variable will be set when sending the provisioning discovery request to peer WFD device.
+													//	And this variable will be reset when it is read by using the iwpriv p2p_get wfd_sa command.
+	u8							ip_address[4];
+	u8							peer_ip_address[4];
+	u8							wfd_pc;				//	WFD preferred connection
+													//	0 -> Prefer to use the P2P for WFD connection on peer side.
+													//	1 -> Prefer to use the TDLS for WFD connection on peer side.
+
+	u8							wfd_device_type;	//	WFD Device Type
+													//	0 -> WFD Source Device
+													//	1 -> WFD Primary Sink Device
+	enum	SCAN_RESULT_TYPE	scan_result_type;	//	Used when P2P is enable. This parameter will impact the scan result.
+	u8 op_wfd_mode;
+	u8 stack_wfd_mode;
+};
+#endif //CONFIG_WFD
+
+struct tx_provdisc_req_info{
+	u16					wps_config_method_request;	//	Used when sending the provisioning request frame
+	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
+	NDIS_802_11_SSID	ssid;
+	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	u8					peerIFAddr[ ETH_ALEN ];		//	Peer interface address
+	u8					benable;					//	This provision discovery request frame is trigger to send or not
+};
+
+struct rx_provdisc_req_info{	//When peer device issue prov_disc_req first, we should store the following informations
+	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	u8					strconfig_method_desc_of_prov_disc_req[4];	//	description for the config method located in the provisioning discovery request frame.
+																	//	The UI must know this information to know which config method the remote p2p device is requiring.
+};
+
+struct tx_nego_req_info{
+	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
+	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	u8					benable;					//	This negoitation request frame is trigger to send or not
+	u8					peer_ch;		                   /*   The listen channel for peer P2P device    */
+};
+
+struct group_id_info{
+	u8					go_device_addr[ ETH_ALEN ];	//	The GO's device address of this P2P group
+	u8					ssid[ WLAN_SSID_MAXLEN ];	//	The SSID of this P2P group
+};
+
+struct scan_limit_info{
+	u8					scan_op_ch_only;			//	When this flag is set, the driver should just scan the operation channel
+#ifndef CONFIG_P2P_OP_CHK_SOCIAL_CH
+	u8					operation_ch[2];				//	Store the operation channel of invitation request frame
+#else
+	u8					operation_ch[5];				//	Store additional channel 1,6,11  for Android 4.2 IOT & Nexus 4
+#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
+};
+
+#ifdef CONFIG_IOCTL_CFG80211
+struct cfg80211_wifidirect_info{
+	_timer					remain_on_ch_timer;
+	u8						restore_channel;
+	struct ieee80211_channel	remain_on_ch_channel;
+	enum nl80211_channel_type	remain_on_ch_type;
+	ATOMIC_T ro_ch_cookie_gen;
+	u64 remain_on_ch_cookie;
+	bool is_ro_ch;
+	u32 last_ro_ch_time; /* this will be updated at the beginning and end of ro_ch */
+};
+#endif //CONFIG_IOCTL_CFG80211
+
+#ifdef CONFIG_P2P_WOWLAN
+
+enum P2P_WOWLAN_RECV_FRAME_TYPE
+{
+	P2P_WOWLAN_RECV_NEGO_REQ = 0,
+	P2P_WOWLAN_RECV_INVITE_REQ = 1,
+	P2P_WOWLAN_RECV_PROVISION_REQ = 2,
+};
+
+struct p2p_wowlan_info{
+
+	u8 						is_trigger;
+	enum P2P_WOWLAN_RECV_FRAME_TYPE	wowlan_recv_frame_type;
+	u8 						wowlan_peer_addr[ETH_ALEN];
+	u16						wowlan_peer_wpsconfig;
+	u8						wowlan_peer_is_persistent;
+	u8						wowlan_peer_invitation_type;
+};
+
+#endif //CONFIG_P2P_WOWLAN
+
+struct wifidirect_info{
+	_adapter*				padapter;
+	_timer					find_phase_timer;
+	_timer					restore_p2p_state_timer;
+
+	//	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer.
+	_timer					pre_tx_scan_timer;
+	_timer					reset_ch_sitesurvey;
+	_timer					reset_ch_sitesurvey2;	//	Just for resetting the scan limit function by using p2p nego
+#ifdef CONFIG_CONCURRENT_MODE
+	//	Used to switch the channel between legacy AP and listen state.
+	_timer					ap_p2p_switch_timer;
+#endif
+	struct tx_provdisc_req_info	tx_prov_disc_info;
+	struct rx_provdisc_req_info rx_prov_disc_info;
+	struct tx_invite_req_info	invitereq_info;
+	struct profile_info			profileinfo[ P2P_MAX_PERSISTENT_GROUP_NUM ];	//	Store the profile information of persistent group
+	struct tx_invite_resp_info	inviteresp_info;
+	struct tx_nego_req_info	nego_req_info;
+	struct group_id_info		groupid_info;	//	Store the group id information when doing the group negotiation handshake.
+	struct scan_limit_info		rx_invitereq_info;	//	Used for get the limit scan channel from the Invitation procedure
+	struct scan_limit_info		p2p_info;		//	Used for get the limit scan channel from the P2P negotiation handshake
+#ifdef CONFIG_WFD
+	struct wifi_display_info		*wfd_info;
+#endif
+
+#ifdef CONFIG_P2P_WOWLAN
+	struct p2p_wowlan_info		p2p_wow_info;
+#endif //CONFIG_P2P_WOWLAN
+
+	enum P2P_ROLE			role;
+	enum P2P_STATE			pre_p2p_state;
+	enum P2P_STATE			p2p_state;
+	u8 						device_addr[ETH_ALEN];	//	The device address should be the mac address of this device.
+	u8						interface_addr[ETH_ALEN];
+	u8						social_chan[4];
+	u8						listen_channel;
+	u8						operating_channel;
+	u8						listen_dwell;		//	This value should be between 1 and 3
+	u8						support_rate[8];
+	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
+	u8						intent;		//	should only include the intent value.
+	u8						p2p_peer_interface_addr[ ETH_ALEN ];
+	u8						p2p_peer_device_addr[ ETH_ALEN ];
+	u8						peer_intent;	//	Included the intent value and tie breaker value.
+	u8						device_name[ WPS_MAX_DEVICE_NAME_LEN ];	//	Device name for displaying on searching device screen
+	u8						device_name_len;
+	u8						profileindex;	//	Used to point to the index of profileinfo array
+	u8						peer_operating_ch;
+	u8						find_phase_state_exchange_cnt;
+	u16						device_password_id_for_nego;	//	The device password ID for group negotation
+	u8						negotiation_dialog_token;
+	u8						nego_ssid[ WLAN_SSID_MAXLEN ];	//	SSID information for group negotitation
+	u8						nego_ssidlen;
+	u8 						p2p_group_ssid[WLAN_SSID_MAXLEN];
+	u8 						p2p_group_ssid_len;
+	u8						persistent_supported;		//	Flag to know the persistent function should be supported or not.
+														//	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI.
+														//	0: disable
+														//	1: enable
+	u8						session_available;			//	Flag to set the WFD session available to enable or disable "by Sigma"
+														//	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI.
+														//	0: disable
+														//	1: enable
+
+	u8						wfd_tdls_enable;			//	Flag to enable or disable the TDLS by WFD Sigma
+														//	0: disable
+														//	1: enable
+	u8						wfd_tdls_weaksec;			//	Flag to enable or disable the weak security function for TDLS by WFD Sigma
+														//	0: disable
+														//	In this case, the driver can't issue the tdsl setup request frame.
+														//	1: enable
+														//	In this case, the driver can issue the tdls setup request frame
+														//	even the current security is weak security.
+
+	enum	P2P_WPSINFO		ui_got_wps_info;			//	This field will store the WPS value (PIN value or PBC) that UI had got from the user.
+	u16						supported_wps_cm;			//	This field describes the WPS config method which this driver supported.
+														//	The value should be the combination of config method defined in page104 of WPS v2.0 spec.
+	u8						external_uuid;				// UUID flag
+	u8						uuid[16];					// UUID
+	uint						channel_list_attr_len;		//	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame.
+	u8						channel_list_attr[100];		//	This field will contain the body of P2P Channel List attribute of group negotitation response frame.
+														//	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame.
+	u8						driver_interface;			//	Indicate DRIVER_WEXT or DRIVER_CFG80211
+
+#ifdef CONFIG_CONCURRENT_MODE
+	u16						ext_listen_interval;	//	The interval to be available with legacy AP (ms)
+	u16						ext_listen_period;	//	The time period to be available for P2P listen state (ms)
+#endif
+#ifdef CONFIG_P2P_PS
+	enum P2P_PS_MODE		p2p_ps_mode; // indicate p2p ps mode
+	enum P2P_PS_STATE		p2p_ps_state; // indicate p2p ps state
+	u8						noa_index; // Identifies and instance of Notice of Absence timing.
+	u8						ctwindow; // Client traffic window. A period of time in TU after TBTT.
+	u8						opp_ps; // opportunistic power save.
+	u8						noa_num; // number of NoA descriptor in P2P IE.
+	u8						noa_count[P2P_MAX_NOA_NUM]; // Count for owner, Type of client.
+	u32						noa_duration[P2P_MAX_NOA_NUM]; // Max duration for owner, preferred or min acceptable duration for client.
+	u32						noa_interval[P2P_MAX_NOA_NUM]; // Length of interval for owner, preferred or max acceptable interval of client.
+	u32						noa_start_time[P2P_MAX_NOA_NUM]; // schedule expressed in terms of the lower 4 bytes of the TSF timer.
+#endif // CONFIG_P2P_PS
+};
+
+struct tdls_ss_record{	//signal strength record
+	u8		macaddr[ETH_ALEN];
+	u8		RxPWDBAll;
+	u8		is_tdls_sta;	// _TRUE: direct link sta, _FALSE: else
+};
+
+struct tdls_temp_mgmt{
+	u8	initiator;	// 0: None, 1: we initiate, 2: peer initiate
+	u8	peer_addr[ETH_ALEN];
+};
+
+#ifdef CONFIG_TDLS_CH_SW
+struct tdls_ch_switch{
+	u32	ch_sw_state;
+	ATOMIC_T	chsw_on;
+	u8	addr[ETH_ALEN];
+	u8	off_ch_num;
+	u8	ch_offset;
+	u32	cur_time;
+	u8	delay_switch_back;
+	u8	dump_stack;
+};
+#endif
+
+struct tdls_info{
+	u8					ap_prohibited;
+	u8					ch_switch_prohibited;
+	u8					link_established;
+	u8					sta_cnt;
+	u8					sta_maximum;	/* 1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else; */
+	struct tdls_ss_record	ss_record;
+#ifdef CONFIG_TDLS_CH_SW
+	struct tdls_ch_switch	chsw_info;
+#endif
+
+	u8					ch_sensing;
+	u8					cur_channel;
+	u8					collect_pkt_num[MAX_CHANNEL_NUM];
+	_lock				cmd_lock;
+	_lock				hdl_lock;
+	u8					watchdog_count;
+	u8					dev_discovered;		/* WFD_TDLS: for sigma test */
+	u8					tdls_enable;
+
+	/* Let wpa_supplicant to setup*/
+	u8					driver_setup;
+#ifdef CONFIG_WFD
+	struct wifi_display_info		*wfd_info;
+#endif
+};
+
+struct tdls_txmgmt {
+	u8 peer[ETH_ALEN];
+	u8 action_code;
+	u8 dialog_token;
+	u16 status_code;
+	u8 *buf;
+	size_t len;
+};
+
+/* used for mlme_priv.roam_flags */
+enum {
+	RTW_ROAM_ON_EXPIRED = BIT0,
+	RTW_ROAM_ON_RESUME = BIT1,
+	RTW_ROAM_ACTIVE = BIT2,
+};
+
+struct beacon_keys {
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	u32 ssid_len;
+	u8 bcn_channel;
+	u16 ht_cap_info;
+	u8 ht_info_infos_0_sco; // bit0 & bit1 in infos[0] is second channel offset
+	int encryp_protocol;
+	int pairwise_cipher;
+	int group_cipher;
+	int is_8021x;
+};
+
+struct mlme_priv {
+
+	_lock	lock;
+	sint	fw_state;	//shall we protect this variable? maybe not necessarily...
+	u8 bScanInProcess;
+	u8	to_join; //flag
+	#ifdef CONFIG_LAYER2_ROAMING
+	u8 to_roam; /* roaming trying times */
+	struct wlan_network *roam_network; /* the target of active roam */
+	u8 roam_flags;
+	u8 roam_rssi_diff_th; /* rssi difference threshold for active scan candidate selection */
+	u32 roam_scan_int_ms; /* scan interval for active roam */
+	u32 roam_scanr_exp_ms; /* scan result expire time in ms  for roam */
+	u8 roam_tgt_addr[ETH_ALEN]; /* request to roam to speicific target without other consideration */
+	#endif
+
+	u8	*nic_hdl;
+
+	u8	not_indic_disco;
+	_list		*pscanned;
+	_queue	free_bss_pool;
+	_queue	scanned_queue;
+	u8		*free_bss_buf;
+	u32	num_of_scanned;
+
+	NDIS_802_11_SSID	assoc_ssid;
+	u8	assoc_bssid[6];
+
+	struct wlan_network	cur_network;
+	struct wlan_network *cur_network_scanned;
+
+	// bcn check info
+	struct beacon_keys cur_beacon_keys; // save current beacon keys
+	struct beacon_keys new_beacon_keys; // save new beacon keys
+	u8 new_beacon_cnts; // if new_beacon_cnts >= threshold, ap beacon is changed
+
+#ifdef CONFIG_ARP_KEEP_ALIVE
+	// for arp offload keep alive
+	u8 bGetGateway;
+	u8	gw_mac_addr[6];
+	u8	gw_ip[4];
+#endif
+
+	//uint wireless_mode; no used, remove it
+
+	u32	auto_scan_int_ms;
+
+	_timer assoc_timer;
+
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+
+	_timer scan_to_timer; // driver itself handles scan_timeout status.
+	u32 scan_start_time; // used to evaluate the time spent in scanning
+
+	#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	_timer set_scan_deny_timer;
+	ATOMIC_T set_scan_deny; //0: allowed, 1: deny
+	#endif
+
+	struct qos_priv qospriv;
+
+#ifdef CONFIG_80211N_HT
+
+	/* Number of non-HT AP/stations */
+	int num_sta_no_ht;
+
+	/* Number of HT AP/stations 20 MHz */
+	//int num_sta_ht_20mhz;
+
+
+	int num_FortyMHzIntolerant;
+
+	struct ht_priv	htpriv;
+
+#endif
+
+#ifdef CONFIG_80211AC_VHT
+	struct vht_priv	vhtpriv;
+#endif
+#ifdef CONFIG_BEAMFORMING
+#if (BEAMFORMING_SUPPORT == 0)/*for driver beamforming*/
+	struct beamforming_info	beamforming_info;
+#endif
+#endif
+
+#ifdef CONFIG_DFS
+	u8	handle_dfs;
+#endif
+#ifdef CONFIG_DFS_MASTER
+	/* TODO: move to rfctl */
+	_timer dfs_master_timer;
+#endif
+
+	RT_LINK_DETECT_T	LinkDetectInfo;
+	_timer	dynamic_chk_timer; //dynamic/periodic check timer
+
+	u8	acm_mask; // for wmm acm mask
+	u8	ChannelPlan;
+	RT_SCAN_TYPE 	scan_mode; // active: 1, passive: 0
+
+	u8 *wps_probe_req_ie;
+	u32 wps_probe_req_ie_len;
+
+	u8 ext_capab_ie_data[8];/*currently for ap mode only*/
+	u8 ext_capab_ie_len;
+
+#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
+	 * in 802.11g BSS) */
+	int num_sta_non_erp;
+
+	/* Number of associated stations that do not support Short Slot Time */
+	int num_sta_no_short_slot_time;
+
+	/* Number of associated stations that do not support Short Preamble */
+	int num_sta_no_short_preamble;
+
+	int olbc; /* Overlapping Legacy BSS Condition (Legacy b/g)*/
+
+	/* Number of HT associated stations that do not support greenfield */
+	int num_sta_ht_no_gf;
+
+	/* Number of associated non-HT stations */
+	//int num_sta_no_ht;
+
+	/* Number of HT associated stations 20 MHz */
+	int num_sta_ht_20mhz;
+
+	/* number of associated stations 40MHz intolerant */
+	int num_sta_40mhz_intolerant;
+
+	/* Overlapping BSS information */
+	int olbc_ht;
+
+#ifdef CONFIG_80211N_HT
+	int ht_20mhz_width_req;
+	int ht_intolerant_ch_reported;
+	u16 ht_op_mode;
+	u8 sw_to_20mhz; /*switch to 20Mhz BW*/
+#endif /* CONFIG_80211N_HT */
+
+	u8 *assoc_req;
+	u32 assoc_req_len;
+	u8 *assoc_rsp;
+	u32 assoc_rsp_len;
+
+	u8 *wps_beacon_ie;
+	//u8 *wps_probe_req_ie;
+	u8 *wps_probe_resp_ie;
+	u8 *wps_assoc_resp_ie; // for CONFIG_IOCTL_CFG80211, this IE could include p2p ie / wfd ie
+
+	u32 wps_beacon_ie_len;
+	//u32 wps_probe_req_ie_len;
+	u32 wps_probe_resp_ie_len;
+	u32 wps_assoc_resp_ie_len; // for CONFIG_IOCTL_CFG80211, this IE len could include p2p ie / wfd ie
+
+	u8 *p2p_beacon_ie;
+	u8 *p2p_probe_req_ie;
+	u8 *p2p_probe_resp_ie;
+	u8 *p2p_go_probe_resp_ie; //for GO
+	u8 *p2p_assoc_req_ie;
+	u8 *p2p_assoc_resp_ie;
+
+	u32 p2p_beacon_ie_len;
+	u32 p2p_probe_req_ie_len;
+	u32 p2p_probe_resp_ie_len;
+	u32 p2p_go_probe_resp_ie_len; //for GO
+	u32 p2p_assoc_req_ie_len;
+	u32 p2p_assoc_resp_ie_len;
+
+	_lock	bcn_update_lock;
+	u8		update_bcn;
+
+	u8 ori_ch;
+	u8 ori_bw;
+	u8 ori_offset;
+#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+
+#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
+
+	u8 *wfd_beacon_ie;
+	u8 *wfd_probe_req_ie;
+	u8 *wfd_probe_resp_ie;
+	u8 *wfd_go_probe_resp_ie; //for GO
+	u8 *wfd_assoc_req_ie;
+	u8 *wfd_assoc_resp_ie;
+
+	u32 wfd_beacon_ie_len;
+	u32 wfd_probe_req_ie_len;
+	u32 wfd_probe_resp_ie_len;
+	u32 wfd_go_probe_resp_ie_len; //for GO
+	u32 wfd_assoc_req_ie_len;
+	u32 wfd_assoc_resp_ie_len;
+
+#endif
+
+#ifdef RTK_DMP_PLATFORM
+	// DMP kobject_hotplug function  signal need in passive level
+	_workitem	Linkup_workitem;
+	_workitem	Linkdown_workitem;
+#endif
+
+#ifdef CONFIG_INTEL_WIDI
+	int	widi_state;
+	int	listen_state;
+	_timer	listen_timer;
+	ATOMIC_T	rx_probe_rsp; // 1:receive probe respone from RDS source.
+	u8	*l2sdTaBuffer;
+	u8	channel_idx;
+	u8	group_cnt;	//In WiDi 3.5, they specified another scan algo. for WFD/RDS co-existed
+	u8	sa_ext[L2SDTA_SERVICE_VE_LEN];
+
+	u8	widi_enable;
+	/**
+	 * For WiDi 4; upper layer would set
+	 * p2p_primary_device_type_category_id
+	 * p2p_primary_device_type_sub_category_id
+	 * p2p_secondary_device_type_category_id
+	 * p2p_secondary_device_type_sub_category_id
+	 */
+	u16	p2p_pdt_cid;
+	u16	p2p_pdt_scid;
+	u8	num_p2p_sdt;
+	u16	p2p_sdt_cid[MAX_NUM_P2P_SDT];
+	u16	p2p_sdt_scid[MAX_NUM_P2P_SDT];
+	u8	p2p_reject_disable;	//When starting NL80211 wpa_supplicant/hostapd, it will call netdev_close
+							//such that it will cause p2p disabled. Use this flag to reject.
+#endif // CONFIG_INTEL_WIDI
+
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	scanning_via_buddy_intf;
+#endif
+
+//	u8 	NumOfBcnInfoChkFail;
+//	u32	timeBcnInfoChkStart;
+};
+
+#define mlme_set_scan_to_timer(mlme, ms) \
+	do { \
+		/* DBG_871X("%s set_scan_to_timer(%p, %d)\n", __FUNCTION__, (mlme), (ms)); */ \
+		_set_timer(&(mlme)->scan_to_timer, (ms)); \
+	} while(0)
+
+#define rtw_mlme_set_auto_scan_int(adapter, ms) \
+	do { \
+		adapter->mlmepriv.auto_scan_int_ms = ms; \
+	} while (0)
+
+void rtw_mlme_reset_auto_scan_int(_adapter *adapter);
+
+#ifdef CONFIG_AP_MODE
+
+struct hostapd_priv
+{
+	_adapter *padapter;
+
+#ifdef CONFIG_HOSTAPD_MLME
+	struct net_device *pmgnt_netdev;
+	struct usb_anchor anchored;
+#endif
+
+};
+
+extern int hostapd_mode_init(_adapter *padapter);
+extern void hostapd_mode_unload(_adapter *padapter);
+#endif
+
+
+extern void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf);
+extern void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_surveydone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_atimdone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_wmm_event_callback(PADAPTER padapter, u8 *pbuf);
+#ifdef CONFIG_IEEE80211W
+void rtw_sta_timeout_event_callback(_adapter *adapter, u8 *pbuf);
+#endif /* CONFIG_IEEE80211W */
+extern void rtw_join_timeout_handler(struct timer_list *t);
+extern void _rtw_scan_timeout_handler(struct timer_list *t);
+
+thread_return event_thread(thread_context context);
+
+extern void rtw_free_network_queue(_adapter *adapter,u8 isfreeall);
+extern int rtw_init_mlme_priv(_adapter *adapter);// (struct mlme_priv *pmlmepriv);
+
+extern void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv);
+
+
+extern sint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
+extern sint rtw_set_key(_adapter *adapter,struct security_priv *psecuritypriv,sint keyid, u8 set_tx, bool enqueue);
+extern sint rtw_set_auth(_adapter *adapter,struct security_priv *psecuritypriv);
+
+__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{	//if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid
+	// if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+__inline static sint check_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	if (pmlmepriv->fw_state & state)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+__inline static sint get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+ */
+__inline static void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state |= state;
+	//FOR HW integration
+	if(_FW_UNDER_SURVEY==state){
+		pmlmepriv->bScanInProcess = _TRUE;
+	}
+}
+
+__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state &= ~state;
+	//FOR HW integration
+	if(_FW_UNDER_SURVEY==state){
+		pmlmepriv->bScanInProcess = _FALSE;
+	}
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+__inline static void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	_clr_fwstate_(pmlmepriv, state);
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+__inline static void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned++;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+#ifdef CONFIG_CONCURRENT_MODE
+sint rtw_buddy_adapter_up(_adapter *padapter);
+sint check_buddy_fwstate(_adapter *padapter, sint state);
+u8 rtw_get_buddy_bBusyTraffic(_adapter *padapter);
+#endif //CONFIG_CONCURRENT_MODE
+
+__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned--;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+__inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint val)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned = val;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
+extern void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target);
+extern void rtw_disconnect_hdl_under_linked(_adapter* adapter, struct sta_info *psta, u8 free_assoc);
+extern void rtw_generate_random_ibss(u8 *pibss);
+extern struct wlan_network* rtw_find_network(_queue *scanned_queue, u8 *addr);
+extern struct wlan_network* rtw_get_oldest_wlan_network(_queue *scanned_queue);
+struct wlan_network *_rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
+struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
+
+extern void rtw_free_assoc_resources(_adapter* adapter, int lock_scanned_queue);
+extern void rtw_indicate_disconnect(_adapter* adapter);
+extern void rtw_indicate_connect(_adapter* adapter);
+void rtw_indicate_scan_done( _adapter *padapter, bool aborted);
+
+void rtw_drv_scan_by_self(_adapter *padapter);
+void rtw_scan_wait_completed(_adapter *adapter);
+u32 rtw_scan_abort_timeout(_adapter *adapter, u32 timeout_ms);
+void rtw_scan_abort_no_wait(_adapter *adapter);
+void rtw_scan_abort(_adapter *adapter);
+
+extern int rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie,u8 *out_ie,uint in_len);
+extern int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
+extern void rtw_init_registrypriv_dev_network(_adapter *adapter);
+
+extern void rtw_update_registrypriv_dev_network(_adapter *adapter);
+
+extern void rtw_get_encrypt_decrypt_from_registrypriv(_adapter *adapter);
+
+extern void _rtw_join_timeout_handler(struct timer_list *t);
+extern void rtw_scan_timeout_handler(struct timer_list *t);
+
+extern void rtw_dynamic_check_timer_handler(_adapter *adapter);
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+bool rtw_is_scan_deny(_adapter *adapter);
+void rtw_clear_scan_deny(_adapter *adapter);
+void rtw_set_scan_deny_timer_hdl(_adapter *adapter);
+void rtw_set_scan_deny(_adapter *adapter, u32 ms);
+#else
+#define rtw_is_scan_deny(adapter) _FALSE
+#define rtw_clear_scan_deny(adapter) do {} while (0)
+#define rtw_set_scan_deny_timer_hdl(adapter) do {} while (0)
+#define rtw_set_scan_deny(adapter, ms) do {} while (0)
+#endif
+
+void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv);
+
+#define MLME_BEACON_IE			0
+#define MLME_PROBE_REQ_IE		1
+#define MLME_PROBE_RESP_IE		2
+#define MLME_GO_PROBE_RESP_IE	3
+#define MLME_ASSOC_REQ_IE		4
+#define MLME_ASSOC_RESP_IE		5
+
+#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
+int rtw_mlme_update_wfd_ie_data(struct mlme_priv *mlme, u8 type, u8 *ie, u32 ie_len);
+#endif
+
+extern int _rtw_init_mlme_priv(_adapter *padapter);
+extern void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);
+
+extern int _rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork);
+
+//extern struct wlan_network* _rtw_dequeue_network(_queue *queue);
+
+extern struct wlan_network* _rtw_alloc_network(struct mlme_priv *pmlmepriv);
+
+
+extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall);
+extern void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+
+
+extern struct wlan_network* _rtw_find_network(_queue *scanned_queue, u8 *addr);
+
+extern void _rtw_free_network_queue(_adapter* padapter, u8 isfreeall);
+
+extern sint rtw_if_up(_adapter *padapter);
+
+sint rtw_linked_check(_adapter *padapter);
+
+u8 *rtw_get_capability_from_ie(u8 *ie);
+u8 *rtw_get_timestampe_from_ie(u8 *ie);
+u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
+
+
+void rtw_joinbss_reset(_adapter *padapter);
+
+#ifdef CONFIG_80211N_HT
+void	rtw_ht_use_default_setting(_adapter *padapter);
+void rtw_build_wmm_ie_ht(_adapter *padapter, u8 *out_ie, uint *pout_len);
+unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel);
+void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel);
+void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtw_append_exented_cap(_adapter *padapter, u8 *out_ie, uint *pout_len);
+#endif
+
+int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
+int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst, u8 feature);
+
+#ifdef CONFIG_LAYER2_ROAMING
+#define rtw_roam_flags(adapter) ((adapter)->mlmepriv.roam_flags)
+#define rtw_chk_roam_flags(adapter, flags) ((adapter)->mlmepriv.roam_flags & flags)
+#define rtw_clr_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags &= ~flags); \
+	} while (0)
+
+#define rtw_set_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags |= flags); \
+	} while (0)
+
+#define rtw_assign_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags = flags); \
+	} while (0)
+
+void _rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
+void rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
+void rtw_set_to_roam(_adapter *adapter, u8 to_roam);
+u8 rtw_dec_to_roam(_adapter *adapter);
+u8 rtw_to_roam(_adapter *adapter);
+int rtw_select_roaming_candidate(struct mlme_priv *pmlmepriv);
+#else
+#define rtw_roam_flags(adapter) 0
+#define rtw_chk_roam_flags(adapter, flags) 0
+#define rtw_clr_roam_flags(adapter, flags) do {} while (0)
+#define rtw_set_roam_flags(adapter, flags) do {} while (0)
+#define rtw_assign_roam_flags(adapter, flags) do {} while (0)
+#define _rtw_roaming(adapter, tgt_network) do {} while(0)
+#define rtw_roaming(adapter, tgt_network) do {} while(0)
+#define rtw_set_to_roam(adapter, to_roam) do {} while(0)
+#define rtw_dec_to_roam(adapter) 0
+#define rtw_to_roam(adapter) 0
+#define rtw_select_roaming_candidate(mlme) _FAIL
+#endif /* CONFIG_LAYER2_ROAMING */
+
+bool rtw_adjust_chbw(_adapter *adapter, u8 req_ch, u8 *req_bw, u8 *req_offset);
+
+struct sta_media_status_rpt_cmd_parm {
+	struct sta_info *sta;
+	bool connected;
+};
+
+void rtw_sta_media_status_rpt(_adapter *adapter, struct sta_info *sta, bool connected);
+u8 rtw_sta_media_status_rpt_cmd(_adapter *adapter, struct sta_info *sta, bool connected);
+void rtw_sta_media_status_rpt_cmd_hdl(_adapter *adapter, struct sta_media_status_rpt_cmd_parm *parm);
+
+#ifdef CONFIG_INTEL_PROXIM
+void rtw_proxim_enable(_adapter *padapter);
+void rtw_proxim_disable(_adapter *padapter);
+void rtw_proxim_send_packet(_adapter *padapter,u8 *pbuf,u16 len,u8 hw_rate);
+#endif //CONFIG_INTEL_PROXIM
+
+#define IPV4_SRC(_iphdr)			(((u8 *)(_iphdr)) + 12)
+#define IPV4_DST(_iphdr)			(((u8 *)(_iphdr)) + 16)
+#define GET_IPV4_IHL(_iphdr)		BE_BITS_TO_1BYTE(((u8 *)(_iphdr)) + 0, 0, 4)
+#define GET_IPV4_PROTOCOL(_iphdr)	BE_BITS_TO_1BYTE(((u8 *)(_iphdr)) + 9, 0, 8)
+#define GET_IPV4_SRC(_iphdr)		BE_BITS_TO_4BYTE(((u8 *)(_iphdr)) + 12, 0, 32)
+#define GET_IPV4_DST(_iphdr)		BE_BITS_TO_4BYTE(((u8 *)(_iphdr)) + 16, 0, 32)
+
+#define GET_UDP_SRC(_udphdr)			BE_BITS_TO_2BYTE(((u8 *)(_udphdr)) + 0, 0, 16)
+#define GET_UDP_DST(_udphdr)			BE_BITS_TO_2BYTE(((u8 *)(_udphdr)) + 2, 0, 16)
+
+#define TCP_SRC(_tcphdr)				(((u8 *)(_tcphdr)) + 0)
+#define TCP_DST(_tcphdr)				(((u8 *)(_tcphdr)) + 2)
+#define GET_TCP_SRC(_tcphdr)			BE_BITS_TO_2BYTE(((u8 *)(_tcphdr)) + 0, 0, 16)
+#define GET_TCP_DST(_tcphdr)			BE_BITS_TO_2BYTE(((u8 *)(_tcphdr)) + 2, 0, 16)
+#define GET_TCP_SEQ(_tcphdr)			BE_BITS_TO_4BYTE(((u8 *)(_tcphdr)) + 4, 0, 32)
+#define GET_TCP_ACK_SEQ(_tcphdr)		BE_BITS_TO_4BYTE(((u8 *)(_tcphdr)) + 8, 0, 32)
+#define GET_TCP_DOFF(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 12, 4, 4)
+#define GET_TCP_FIN(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 0, 1)
+#define GET_TCP_SYN(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 1, 1)
+#define GET_TCP_RST(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 2, 1)
+#define GET_TCP_PSH(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 3, 1)
+#define GET_TCP_ACK(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 4, 1)
+#define GET_TCP_URG(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 5, 1)
+#define GET_TCP_ECE(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 6, 1)
+#define GET_TCP_CWR(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 7, 1)
+
+#endif //__RTL871X_MLME_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme_ext.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme_ext.h
new file mode 100644
index 000000000..783afafff
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mlme_ext.h
@@ -0,0 +1,1235 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MLME_EXT_H_
+#define __RTW_MLME_EXT_H_
+
+
+//	Commented by Albert 20101105
+//	Increase the SURVEY_TO value from 100 to 150  ( 100ms to 150ms )
+//	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
+//	So, this driver tried to extend the dwell time for each scanning channel.
+//	This will increase the chance to receive the probe response from SoftAP.
+
+#define SURVEY_TO		(100)
+#define REAUTH_TO		(300) //(50)
+#define REASSOC_TO		(300) //(50)
+//#define DISCONNECT_TO	(3000)
+#define ADDBA_TO			(2000)
+
+#define LINKED_TO (1) //unit:2 sec, 1x2=2 sec
+
+#define REAUTH_LIMIT	(4)
+#define REASSOC_LIMIT	(4)
+#define READDBA_LIMIT	(2)
+
+#ifdef CONFIG_GSPI_HCI
+	#define ROAMING_LIMIT	5
+#else
+	#define ROAMING_LIMIT	8
+#endif
+//#define	IOCMD_REG0		0x10250370
+//#define	IOCMD_REG1		0x10250374
+//#define	IOCMD_REG2		0x10250378
+
+//#define	FW_DYNAMIC_FUN_SWITCH	0x10250364
+
+//#define	WRITE_BB_CMD		0xF0000001
+//#define	SET_CHANNEL_CMD	0xF3000000
+//#define	UPDATE_RA_CMD	0xFD0000A2
+
+#define _HW_STATE_NOLINK_		0x00
+#define _HW_STATE_ADHOC_		0x01
+#define _HW_STATE_STATION_ 	0x02
+#define _HW_STATE_AP_			0x03
+#define _HW_STATE_MONITOR_ 0x04
+
+
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+/********************************************************
+MCS rate definitions
+*********************************************************/
+#define MCS_RATE_1R	(0x000000ff)
+#define MCS_RATE_2R	(0x0000ffff)
+#define MCS_RATE_3R	(0x00ffffff)
+#define MCS_RATE_4R	(0xffffffff)
+#define MCS_RATE_2R_13TO15_OFF	(0x00001fff)
+
+
+extern unsigned char RTW_WPA_OUI[];
+extern unsigned char WMM_OUI[];
+extern unsigned char WPS_OUI[];
+extern unsigned char WFD_OUI[];
+extern unsigned char P2P_OUI[];
+
+extern unsigned char WMM_INFO_OUI[];
+extern unsigned char WMM_PARA_OUI[];
+
+typedef enum _RT_CHANNEL_DOMAIN
+{
+	/* ===== 0x00 ~ 0x1F, legacy channel plan ===== */
+	RTW_CHPLAN_FCC = 0x00,
+	RTW_CHPLAN_IC = 0x01,
+	RTW_CHPLAN_ETSI = 0x02,
+	RTW_CHPLAN_SPAIN = 0x03,
+	RTW_CHPLAN_FRANCE = 0x04,
+	RTW_CHPLAN_MKK = 0x05,
+	RTW_CHPLAN_MKK1 = 0x06,
+	RTW_CHPLAN_ISRAEL = 0x07,
+	RTW_CHPLAN_TELEC = 0x08,
+	RTW_CHPLAN_GLOBAL_DOAMIN = 0x09,
+	RTW_CHPLAN_WORLD_WIDE_13 = 0x0A,
+	RTW_CHPLAN_TAIWAN = 0x0B,
+	RTW_CHPLAN_CHINA = 0x0C,
+	RTW_CHPLAN_SINGAPORE_INDIA_MEXICO = 0x0D,
+	RTW_CHPLAN_KOREA = 0x0E,
+	RTW_CHPLAN_TURKEY = 0x0F,
+	RTW_CHPLAN_JAPAN = 0x10,
+	RTW_CHPLAN_FCC_NO_DFS = 0x11,
+	RTW_CHPLAN_JAPAN_NO_DFS = 0x12,
+	RTW_CHPLAN_WORLD_WIDE_5G = 0x13,
+	RTW_CHPLAN_TAIWAN_NO_DFS = 0x14,
+
+	/* ===== 0x20 ~ 0x7F, new channel plan ===== */
+	RTW_CHPLAN_WORLD_NULL = 0x20,
+	RTW_CHPLAN_ETSI1_NULL = 0x21,
+	RTW_CHPLAN_FCC1_NULL = 0x22,
+	RTW_CHPLAN_MKK1_NULL = 0x23,
+	RTW_CHPLAN_ETSI2_NULL = 0x24,
+	RTW_CHPLAN_FCC1_FCC1 = 0x25,
+	RTW_CHPLAN_WORLD_ETSI1 = 0x26,
+	RTW_CHPLAN_MKK1_MKK1 = 0x27,
+	RTW_CHPLAN_WORLD_KCC1 = 0x28,
+	RTW_CHPLAN_WORLD_FCC2 = 0x29,
+	RTW_CHPLAN_WORLD_FCC3 = 0x30,
+	RTW_CHPLAN_WORLD_FCC4 = 0x31,
+	RTW_CHPLAN_WORLD_FCC5 = 0x32,
+	RTW_CHPLAN_WORLD_FCC6 = 0x33,
+	RTW_CHPLAN_FCC1_FCC7 = 0x34,
+	RTW_CHPLAN_WORLD_ETSI2 = 0x35,
+	RTW_CHPLAN_WORLD_ETSI3 = 0x36,
+	RTW_CHPLAN_MKK1_MKK2 = 0x37,
+	RTW_CHPLAN_MKK1_MKK3 = 0x38,
+	RTW_CHPLAN_FCC1_NCC1 = 0x39,
+	RTW_CHPLAN_FCC1_NCC2 = 0x40,
+	RTW_CHPLAN_GLOBAL_NULL = 0x41,
+	RTW_CHPLAN_ETSI1_ETSI4 = 0x42,
+	RTW_CHPLAN_FCC1_FCC2 = 0x43,
+	RTW_CHPLAN_FCC1_NCC3 = 0x44,
+	RTW_CHPLAN_WORLD_ETSI5 = 0x45,
+	RTW_CHPLAN_FCC1_FCC8 = 0x46,
+	RTW_CHPLAN_WORLD_ETSI6 = 0x47,
+	RTW_CHPLAN_WORLD_ETSI7 = 0x48,
+	RTW_CHPLAN_WORLD_ETSI8 = 0x49,
+	RTW_CHPLAN_WORLD_ETSI9 = 0x50,
+	RTW_CHPLAN_WORLD_ETSI10 = 0x51,
+	RTW_CHPLAN_WORLD_ETSI11 = 0x52,
+	RTW_CHPLAN_FCC1_NCC4 = 0x53,
+	RTW_CHPLAN_WORLD_ETSI12 = 0x54,
+	RTW_CHPLAN_FCC1_FCC9 = 0x55,
+	RTW_CHPLAN_WORLD_ETSI13 = 0x56,
+	RTW_CHPLAN_FCC1_FCC10 = 0x57,
+	RTW_CHPLAN_MKK2_MKK4 = 0x58,
+	RTW_CHPLAN_WORLD_ETSI14 = 0x59,
+
+	RTW_CHPLAN_MAX,
+	RTW_CHPLAN_REALTEK_DEFINE = 0x7F,
+}RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
+
+typedef enum _RT_CHANNEL_DOMAIN_2G
+{
+	RTW_RD_2G_NULL = 0,
+	RTW_RD_2G_WORLD = 1,	/* Worldwird 13 */
+	RTW_RD_2G_ETSI1 = 2,	/* Europe */
+	RTW_RD_2G_FCC1 = 3,		/* US */
+	RTW_RD_2G_MKK1 = 4,		/* Japan */
+	RTW_RD_2G_ETSI2 = 5,	/* France */
+	RTW_RD_2G_GLOBAL = 6,	/* Global domain */
+	RTW_RD_2G_MKK2 = 7,		/* Japan */
+
+	RTW_RD_2G_MAX,
+}RT_CHANNEL_DOMAIN_2G, *PRT_CHANNEL_DOMAIN_2G;
+
+typedef enum _RT_CHANNEL_DOMAIN_5G
+{
+	RTW_RD_5G_NULL = 0,		/*	*/
+	RTW_RD_5G_ETSI1 = 1,	/* Europe */
+	RTW_RD_5G_ETSI2 = 2,	/* Australia, New Zealand */
+	RTW_RD_5G_ETSI3 = 3,	/* Russia */
+	RTW_RD_5G_FCC1 = 4,		/* US */
+	RTW_RD_5G_FCC2 = 5,		/* FCC w/o DFS Channels */
+	RTW_RD_5G_FCC3 = 6,		/* Bolivia, Chile, El Salvador, Venezuela */
+	RTW_RD_5G_FCC4 = 7,		/* Venezuela */
+	RTW_RD_5G_FCC5 = 8,		/* China */
+	RTW_RD_5G_FCC6 = 9,		/*	*/
+	RTW_RD_5G_FCC7 = 10,	/* US Canada(w/o Weather radar) */
+	RTW_RD_5G_KCC1 = 11,	/* Korea */
+	RTW_RD_5G_MKK1 = 12,	/* Japan */
+	RTW_RD_5G_MKK2 = 13,	/* Japan (W52, W53) */
+	RTW_RD_5G_MKK3 = 14,	/* Japan (W56) */
+	RTW_RD_5G_NCC1 = 15,	/* Taiwan, (w/o Weather radar) */
+	RTW_RD_5G_NCC2 = 16,	/* Taiwan, Band2, Band4 */
+	RTW_RD_5G_NCC3 = 17,	/* Taiwan w/o DFS, Band4 only */
+	RTW_RD_5G_ETSI4 = 18,	/* Europe w/o DFS, Band1 only */
+	RTW_RD_5G_ETSI5 = 19,	/* Australia, New Zealand(w/o Weather radar) */
+	RTW_RD_5G_FCC8 = 20,	/* Latin America */
+	RTW_RD_5G_ETSI6 = 21,	/* Israel, Bahrain, Egypt, India, China, Malaysia */
+	RTW_RD_5G_ETSI7 = 22,	/* China */
+	RTW_RD_5G_ETSI8 = 23,	/* Jordan */
+	RTW_RD_5G_ETSI9 = 24,	/* Lebanon */
+	RTW_RD_5G_ETSI10 = 25,	/* Qatar */
+	RTW_RD_5G_ETSI11 = 26,	/* Russia */
+	RTW_RD_5G_NCC4 = 27,	/* Taiwan, (w/o Weather radar) */
+	RTW_RD_5G_ETSI12 = 28,	/* Indonesia */
+	RTW_RD_5G_FCC9 = 29,	/* (w/o Weather radar) */
+	RTW_RD_5G_ETSI13 = 30,	/* (w/o Weather radar) */
+	RTW_RD_5G_FCC10 = 31,	/* Argentina(w/o Weather radar) */
+	RTW_RD_5G_MKK4 = 32,	/* Japan (W52) */
+	RTW_RD_5G_ETSI14 = 33,	/* Russia */
+
+	/* === Below are driver defined for legacy channel plan compatible, DON'T assign index ==== */
+	RTW_RD_5G_OLD_FCC1,
+	RTW_RD_5G_OLD_NCC1,
+	RTW_RD_5G_OLD_KCC1,
+
+	RTW_RD_5G_MAX,
+}RT_CHANNEL_DOMAIN_5G, *PRT_CHANNEL_DOMAIN_5G;
+
+#define rtw_is_channel_plan_valid(chplan) ((chplan) < RTW_CHPLAN_MAX || (chplan) == RTW_CHPLAN_REALTEK_DEFINE)
+#define rtw_is_legacy_channel_plan(chplan) ((chplan) < 0x20)
+bool rtw_chplan_is_empty(u8 id);
+
+typedef struct _RT_CHANNEL_PLAN
+{
+	unsigned char	Channel[MAX_CHANNEL_NUM];
+	unsigned char	Len;
+}RT_CHANNEL_PLAN, *PRT_CHANNEL_PLAN;
+
+typedef struct _RT_CHANNEL_PLAN_2G
+{
+	unsigned char	Channel[MAX_CHANNEL_NUM_2G];
+	unsigned char	Len;
+}RT_CHANNEL_PLAN_2G, *PRT_CHANNEL_PLAN_2G;
+
+typedef struct _RT_CHANNEL_PLAN_5G
+{
+	unsigned char	Channel[MAX_CHANNEL_NUM_5G];
+	unsigned char	Len;
+}RT_CHANNEL_PLAN_5G, *PRT_CHANNEL_PLAN_5G;
+
+typedef struct _RT_CHANNEL_PLAN_MAP
+{
+	u8 Index2G;
+	u8 Index5G;
+	u8 regd; /* value of REGULATION_TXPWR_LMT */
+}RT_CHANNEL_PLAN_MAP, *PRT_CHANNEL_PLAN_MAP;
+
+enum Associated_AP
+{
+	atherosAP	= 0,
+	broadcomAP	= 1,
+	ciscoAP		= 2,
+	marvellAP	= 3,
+	ralinkAP	= 4,
+	realtekAP	= 5,
+	airgocapAP 	= 6,
+	unknownAP	= 7,
+	maxAP,
+};
+
+typedef enum _HT_IOT_PEER
+{
+	HT_IOT_PEER_UNKNOWN 			= 0,
+	HT_IOT_PEER_REALTEK 			= 1,
+	HT_IOT_PEER_REALTEK_92SE 		= 2,
+	HT_IOT_PEER_BROADCOM 		= 3,
+	HT_IOT_PEER_RALINK 			= 4,
+	HT_IOT_PEER_ATHEROS 			= 5,
+	HT_IOT_PEER_CISCO 				= 6,
+	HT_IOT_PEER_MERU 				= 7,
+	HT_IOT_PEER_MARVELL 			= 8,
+	HT_IOT_PEER_REALTEK_SOFTAP 	= 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
+	HT_IOT_PEER_SELF_SOFTAP 		= 10, // Self is SoftAP
+	HT_IOT_PEER_AIRGO 				= 11,
+	HT_IOT_PEER_INTEL 				= 12,
+	HT_IOT_PEER_RTK_APCLIENT 		= 13,
+	HT_IOT_PEER_REALTEK_81XX 		= 14,
+	HT_IOT_PEER_REALTEK_WOW 		= 15,
+	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
+	HT_IOT_PEER_MAX 				= 18
+}HT_IOT_PEER_E, *PHTIOT_PEER_E;
+
+struct mlme_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
+};
+
+struct action_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
+};
+
+enum SCAN_STATE
+{
+	SCAN_DISABLE = 0,
+	SCAN_START = 1,
+	SCAN_PS_ANNC_WAIT = 2,
+	SCAN_ENTER = 3,
+	SCAN_PROCESS = 4,
+
+	/* backop */
+	SCAN_BACKING_OP = 5,
+	SCAN_BACK_OP = 6,
+	SCAN_LEAVING_OP = 7,
+	SCAN_LEAVE_OP = 8,
+
+	/* SW antenna diversity (before linked) */
+	SCAN_SW_ANTDIV_BL = 9,
+
+	/* legacy p2p */
+	SCAN_TO_P2P_LISTEN = 10,
+	SCAN_P2P_LISTEN = 11,
+
+	SCAN_COMPLETE = 12,
+	SCAN_STATE_MAX,
+};
+
+const char *scan_state_str(u8 state);
+
+enum ss_backop_flag {
+	SS_BACKOP_EN = BIT0, /* backop when linked */
+	SS_BACKOP_EN_NL = BIT1, /* backop even when no linked */
+
+	SS_BACKOP_PS_ANNC = BIT4,
+	SS_BACKOP_TX_RESUME = BIT5,
+};
+
+struct ss_res {
+	u8 state;
+	u8 next_state; /* will set to state on next cmd hdl */
+	int	bss_cnt;
+	int	channel_idx;
+	int	scan_mode;
+	u16 scan_ch_ms;
+	u8 rx_ampdu_accept;
+	u8 rx_ampdu_size;
+#ifdef CONFIG_SCAN_BACKOP
+	u8 backop_flags_sta; /* policy for station mode*/
+	u8 backop_flags_ap; /* policy for ap mode */
+	u8 backop_flags; /* per backop runtime decision */
+	u8 scan_cnt;
+	u8 scan_cnt_max;
+	u32 backop_time; /* the start time of backop */
+	u16 backop_ms;
+#endif
+#if defined(CONFIG_ANTENNA_DIVERSITY) || defined(DBG_SCAN_SW_ANTDIV_BL)
+	u8 is_sw_antdiv_bl_scan;
+#endif
+	u8 ssid_num;
+	u8 ch_num;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+//#define AP_MODE				0x0C
+//#define STATION_MODE	0x08
+//#define AD_HOC_MODE		0x04
+//#define NO_LINK_MODE	0x00
+
+#define 	WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
+#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
+#define	WIFI_FW_AP_STATE				_HW_STATE_AP_
+#define	WIFI_FW_ADHOC_STATE			_HW_STATE_ADHOC_
+
+#define	WIFI_FW_AUTH_NULL			0x00000100
+#define	WIFI_FW_AUTH_STATE			0x00000200
+#define	WIFI_FW_AUTH_SUCCESS			0x00000400
+
+#define	WIFI_FW_ASSOC_STATE			0x00002000
+#define	WIFI_FW_ASSOC_SUCCESS		0x00004000
+
+#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS |WIFI_FW_ASSOC_STATE)
+
+#ifdef CONFIG_TDLS
+enum TDLS_option
+{
+	TDLS_ESTABLISHED	= 	1,
+	TDLS_ISSUE_PTI				=	2,
+	TDLS_CH_SW_RESP			=	3,
+	TDLS_CH_SW				=	4,
+	TDLS_CH_SW_BACK			=	5,
+	TDLS_RS_RCR				=	6,
+	TDLS_TEAR_STA				=	7,
+	maxTDLS,
+};
+
+#endif //CONFIG_TDLS
+
+struct FW_Sta_Info
+{
+	struct sta_info	*psta;
+	u32	status;
+	u32	rx_pkt;
+	u32	retry;
+	NDIS_802_11_RATES_EX  SupportedRates;
+};
+
+/*
+ * Usage:
+ * When one iface acted as AP mode and the other iface is STA mode and scanning,
+ * it should switch back to AP's operating channel periodically.
+ * Parameters info:
+ * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
+ * RTW_BACK_OP_CH_MS milliseconds.
+ * Example:
+ * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
+ * RTW_SCAN_NUM_OF_CH is 8, RTW_BACK_OP_CH_MS is 300
+ * When it's STA mode gets set_scan command,
+ * it would
+ * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
+ * 2. Back to channel 1 for 300 milliseconds
+ * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
+ * 4. Back to channel 1 for 300 milliseconds
+ * 5. ... and so on, till survey done.
+ */
+#if defined(CONFIG_ATMEL_RC_PATCH)
+#define RTW_SCAN_NUM_OF_CH 2
+#define RTW_BACK_OP_CH_MS 200
+#else
+#define RTW_SCAN_NUM_OF_CH 3
+#define RTW_BACK_OP_CH_MS 400
+#endif
+
+struct mlme_ext_info
+{
+	u32	state;
+	u32	reauth_count;
+	u32	reassoc_count;
+	u32	link_count;
+	u32	auth_seq;
+	u32	auth_algo;	// 802.11 auth, could be open, shared, auto
+	u32	authModeToggle;
+	u32	enc_algo;//encrypt algorithm;
+	u32	key_index;	// this is only valid for legendary wep, 0~3 for key id.
+	u32	iv;
+	u8	chg_txt[128];
+	u16	aid;
+	u16	bcn_interval;
+	u16	capability;
+	u8	assoc_AP_vendor;
+	u8	slotTime;
+	u8	preamble_mode;
+	u8	WMM_enable;
+	u8	ERP_enable;
+	u8	ERP_IE;
+	u8	HT_enable;
+	u8	HT_caps_enable;
+	u8	HT_info_enable;
+	u8	HT_protection;
+	u8	turboMode_cts2self;
+	u8	turboMode_rtsen;
+	u8	SM_PS;
+	u8	agg_enable_bitmap;
+	u8	ADDBA_retry_count;
+	u8	candidate_tid_bitmap;
+	u8	dialogToken;
+	// Accept ADDBA Request
+	BOOLEAN bAcceptAddbaReq;
+	u8	bwmode_updated;
+	u8	hidden_ssid_mode;
+	u8	VHT_enable;
+
+	struct ADDBA_request		ADDBA_req;
+	struct WMM_para_element	WMM_param;
+	struct HT_caps_element	HT_caps;
+	struct HT_info_element		HT_info;
+	WLAN_BSSID_EX			network;//join network or bss_network, if in ap mode, it is the same to cur_network.network
+	struct FW_Sta_Info		FW_sta_info[NUM_STA];
+};
+
+// The channel information about this channel including joining, scanning, and power constraints.
+typedef struct _RT_CHANNEL_INFO
+{
+	u8				ChannelNum;		// The channel number.
+	RT_SCAN_TYPE	ScanType;		// Scan type such as passive or active scan.
+	//u16				ScanPeriod;		// Listen time in millisecond in this channel.
+	//s32				MaxTxPwrDbm;	// Max allowed tx power.
+	//u32				ExInfo;			// Extended Information for this channel.
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	u32				rx_count;
+#endif
+#ifdef CONFIG_DFS_MASTER
+	u32 non_ocp_end_time;
+#endif
+}RT_CHANNEL_INFO, *PRT_CHANNEL_INFO;
+
+#define DFS_MASTER_TIMER_MS 100
+#define CAC_TIME_MS (60*1000)
+#define CAC_TIME_CE_MS (10*60*1000)
+#define NON_OCP_TIME_MS (30*60*1000)
+
+#ifdef CONFIG_DFS_MASTER
+struct rf_ctl_t;
+#define CH_IS_NON_OCP(rt_ch_info) ((rt_ch_info)->non_ocp_end_time > rtw_get_current_time())
+void rtw_rfctl_reset_cac(struct rf_ctl_t *rfctl);
+bool rtw_is_cac_reset_needed(_adapter *adapter);
+bool _rtw_rfctl_overlap_radar_detect_ch(struct rf_ctl_t *rfctl, u8 ch, u8 bw, u8 offset);
+bool rtw_rfctl_overlap_radar_detect_ch(struct rf_ctl_t *rfctl);
+bool rtw_rfctl_is_tx_blocked_by_cac(struct rf_ctl_t *rfctl);
+bool rtw_chset_is_ch_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
+void rtw_chset_update_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
+void rtw_chset_update_non_ocp_ms(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset, int ms);
+#else
+#define CH_IS_NON_OCP(rt_ch_info) 0
+#define rtw_chset_is_ch_non_ocp(ch_set, ch, bw, offset) _FALSE
+#define rtw_rfctl_is_tx_blocked_by_cac(rfctl) _FALSE
+#endif
+
+enum {
+	RTW_CHF_2G = BIT0,
+	RTW_CHF_5G = BIT1,
+	RTW_CHF_DFS = BIT2,
+	RTW_CHF_LONG_CAC = BIT3,
+	RTW_CHF_NON_DFS = BIT4,
+	RTW_CHF_NON_LONG_CAC = BIT5,
+};
+bool rtw_choose_available_chbw(_adapter *adapter, u8 req_bw, u8 *dec_ch, u8 *dec_bw, u8 *dec_offset, u8 d_flags);
+void dump_chplan_id_list(void *sel);
+void dump_chplan_test(void *sel);
+void dump_chset(void *sel, RT_CHANNEL_INFO *ch_set);
+void dump_cur_chset(void *sel, _adapter *adapter);
+
+int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch);
+bool rtw_mlme_band_check(_adapter *adapter, const u32 ch);
+
+// P2P_MAX_REG_CLASSES - Maximum number of regulatory classes
+#define P2P_MAX_REG_CLASSES 10
+
+// P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class
+#define P2P_MAX_REG_CLASS_CHANNELS 20
+
+//  struct p2p_channels - List of supported channels
+struct p2p_channels {
+	// struct p2p_reg_class - Supported regulatory class
+	struct p2p_reg_class {
+		// reg_class - Regulatory class (IEEE 802.11-2007, Annex J)
+		u8 reg_class;
+
+		// channel - Supported channels
+		u8 channel[P2P_MAX_REG_CLASS_CHANNELS];
+
+		// channels - Number of channel entries in use
+		size_t channels;
+	} reg_class[P2P_MAX_REG_CLASSES];
+
+	// reg_classes - Number of reg_class entries in use
+	size_t reg_classes;
+};
+
+struct p2p_oper_class_map {
+	enum hw_mode {IEEE80211G,IEEE80211A} mode;
+	u8 op_class;
+	u8 min_chan;
+	u8 max_chan;
+	u8 inc;
+	enum { BW20, BW40PLUS, BW40MINUS } bw;
+};
+
+struct mlme_ext_priv
+{
+	_adapter	*padapter;
+	u8	mlmeext_init;
+	ATOMIC_T		event_seq;
+	u16	mgnt_seq;
+#ifdef CONFIG_IEEE80211W
+	u16	sa_query_seq;
+	u64 mgnt_80211w_IPN;
+	u64 mgnt_80211w_IPN_rx;
+#endif //CONFIG_IEEE80211W
+	//struct fw_priv 	fwpriv;
+
+	unsigned char	cur_channel;
+	unsigned char	cur_bwmode;
+	unsigned char	cur_ch_offset;//PRIME_CHNL_OFFSET
+	unsigned char	cur_wireless_mode;	// NETWORK_TYPE
+
+	unsigned char	max_chan_nums;
+	RT_CHANNEL_INFO		channel_set[MAX_CHANNEL_NUM];
+	struct p2p_channels channel_list;
+	unsigned char	basicrate[NumRates];
+	unsigned char	datarate[NumRates];
+#ifdef CONFIG_80211N_HT
+	unsigned char default_supported_mcs_set[16];
+#endif
+
+	struct ss_res		sitesurvey_res;
+	struct mlme_ext_info	mlmext_info;//for sta/adhoc mode, including current scanning/connecting/connected related info.
+                                                     //for ap mode, network includes ap's cap_info
+	_timer		survey_timer;
+	_timer		link_timer;
+
+	//_timer		ADDBA_timer;
+	u32 last_scan_time;
+	u8	scan_abort;
+	u8	tx_rate; // TXRATE when USERATE is set.
+
+	u32	retry; //retry for issue probereq
+
+	u64 TSFValue;
+
+	//for LPS-32K to adaptive bcn early and timeout
+	u8 adaptive_tsf_done;
+	u32 bcn_delay_cnt[9];
+	u32 bcn_delay_ratio[9];
+	u32 bcn_cnt;
+	u8 DrvBcnEarly;
+	u8 DrvBcnTimeOut;
+
+#ifdef CONFIG_AP_MODE
+	unsigned char bstart_bss;
+#endif
+
+#ifdef CONFIG_80211D
+	u8 update_channel_plan_by_ap_done;
+#endif
+	//recv_decache check for Action_public frame
+	u8 action_public_dialog_token;
+	u16 	 action_public_rxseq;
+
+//#ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+	u8 active_keep_alive_check;
+//#endif
+#ifdef DBG_FIXED_CHAN
+	u8 fixed_chan;
+#endif
+
+};
+
+#define mlmeext_msr(mlmeext) ((mlmeext)->mlmext_info.state & 0x03)
+#define mlmeext_scan_state(mlmeext) ((mlmeext)->sitesurvey_res.state)
+#define mlmeext_scan_state_str(mlmeext) scan_state_str((mlmeext)->sitesurvey_res.state)
+#define mlmeext_chk_scan_state(mlmeext, _state) ((mlmeext)->sitesurvey_res.state == (_state))
+#define mlmeext_set_scan_state(mlmeext, _state) \
+	do { \
+		((mlmeext)->sitesurvey_res.state = (_state)); \
+		((mlmeext)->sitesurvey_res.next_state = (_state)); \
+		/* DBG_871X("set_scan_state:%s\n", scan_state_str(_state)); */ \
+	} while (0)
+
+#define mlmeext_scan_next_state(mlmeext) ((mlmeext)->sitesurvey_res.next_state)
+#define mlmeext_set_scan_next_state(mlmeext, _state) \
+	do { \
+		((mlmeext)->sitesurvey_res.next_state = (_state)); \
+		/* DBG_871X("set_scan_next_state:%s\n", scan_state_str(_state)); */ \
+	} while (0)
+
+#ifdef CONFIG_SCAN_BACKOP
+#define mlmeext_scan_backop_flags(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags)
+#define mlmeext_chk_scan_backop_flags(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags & (flags))
+#define mlmeext_assign_scan_backop_flags(mlmeext, flags) \
+		do { \
+			((mlmeext)->sitesurvey_res.backop_flags = (flags)); \
+			DBG_871X("assign_scan_backop_flags:0x%02x\n", (mlmeext)->sitesurvey_res.backop_flags); \
+		} while (0)
+
+#define mlmeext_scan_backop_flags_sta(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_sta)
+#define mlmeext_chk_scan_backop_flags_sta(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_sta & (flags))
+#define mlmeext_assign_scan_backop_flags_sta(mlmeext, flags) \
+	do { \
+		((mlmeext)->sitesurvey_res.backop_flags_sta = (flags)); \
+	} while (0)
+
+#define mlmeext_scan_backop_flags_ap(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_ap)
+#define mlmeext_chk_scan_backop_flags_ap(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_ap & (flags))
+#define mlmeext_assign_scan_backop_flags_ap(mlmeext, flags) \
+	do { \
+		((mlmeext)->sitesurvey_res.backop_flags_ap = (flags)); \
+	} while (0)
+#else
+#define mlmeext_scan_backop_flags(mlmeext) (0)
+#define mlmeext_chk_scan_backop_flags(mlmeext, flags) (0)
+#define mlmeext_assign_scan_backop_flags(mlmeext, flags) do {} while (0)
+
+#define mlmeext_scan_backop_flags_sta(mlmeext) (0)
+#define mlmeext_chk_scan_backop_flags_sta(mlmeext, flags) (0)
+#define mlmeext_assign_scan_backop_flags_sta(mlmeext, flags) do {} while (0)
+
+#define mlmeext_scan_backop_flags_ap(mlmeext) (0)
+#define mlmeext_chk_scan_backop_flags_ap(mlmeext, flags) (0)
+#define mlmeext_assign_scan_backop_flags_ap(mlmeext, flags) do {} while (0)
+#endif
+
+void init_mlme_default_rate_set(_adapter* padapter);
+int init_mlme_ext_priv(_adapter* padapter);
+int init_hw_mlme_ext(_adapter *padapter);
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext);
+extern void init_mlme_ext_timer(_adapter *padapter);
+extern void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta);
+extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
+struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv);
+
+//void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv);
+
+unsigned char networktype_to_raid(_adapter *adapter,struct sta_info *psta);
+unsigned char networktype_to_raid_ex(_adapter *adapter, struct sta_info *psta);
+
+u8 judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen);
+void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
+void set_mcs_rate_by_mask(u8 *mcs_set, u32 mask);
+void UpdateBrateTbl(_adapter *padapter,u8 *mBratesOS);
+void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen);
+void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 ch);
+
+//void Set_NETYPE1_MSR(_adapter *padapter, u8 type);
+//void Set_NETYPE0_MSR(_adapter *padapter, u8 type);
+void Set_MSR(_adapter *padapter, u8 type);
+
+u8 rtw_get_oper_ch(_adapter *adapter);
+void rtw_set_oper_ch(_adapter *adapter, u8 ch);
+u8 rtw_get_oper_bw(_adapter *adapter);
+void rtw_set_oper_bw(_adapter *adapter, u8 bw);
+u8 rtw_get_oper_choffset(_adapter *adapter);
+void rtw_set_oper_choffset(_adapter *adapter, u8 offset);
+u8	rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset);
+u32 rtw_get_on_oper_ch_time(_adapter *adapter);
+u32 rtw_get_on_cur_ch_time(_adapter *adapter);
+
+u8 rtw_get_offset_by_ch(u8 channel);
+
+void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);
+void SelectChannel(_adapter *padapter, unsigned char channel);
+void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
+
+void _clear_cam_entry(_adapter *padapter, u8 entry);
+void write_cam_from_cache(_adapter *adapter, u8 id);
+
+/* modify both HW and cache */
+void write_cam(_adapter *padapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_entry(_adapter *padapter, u8 id);
+
+/* modify cache only */
+void write_cam_cache(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_cache(_adapter *adapter, u8 id);
+
+void invalidate_cam_all(_adapter *padapter);
+void CAM_empty_entry(PADAPTER Adapter, u8 ucIndex);
+
+
+int allocate_fw_sta_entry(_adapter *padapter);
+void flush_all_cam_entry(_adapter *padapter);
+
+BOOLEAN IsLegal5GChannel(PADAPTER Adapter, u8 channel);
+
+void site_survey(_adapter *padapter, u8 survey_channel, RT_SCAN_TYPE ScanType);
+u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
+void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, _adapter * padapter, bool update_ie);
+
+int get_bsstype(unsigned short capability);
+u8* get_my_bssid(WLAN_BSSID_EX *pnetwork);
+u16 get_beacon_interval(WLAN_BSSID_EX *bss);
+
+int is_client_associated_to_ap(_adapter *padapter);
+int is_client_associated_to_ibss(_adapter *padapter);
+int is_IBSS_empty(_adapter *padapter);
+
+unsigned char check_assoc_AP(u8 *pframe, uint len);
+
+int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE);
+#ifdef CONFIG_WFD
+void rtw_process_wfd_ie(_adapter *adapter, u8 *ie, u8 ie_len, const char *tag);
+void rtw_process_wfd_ies(_adapter *adapter, u8 *ies, u8 ies_len, const char *tag);
+#endif
+void WMMOnAssocRsp(_adapter *padapter);
+
+void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HTOnAssocRsp(_adapter *padapter);
+
+void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void VCS_update(_adapter *padapter, struct sta_info *psta);
+void	update_ldpc_stbc_cap(struct sta_info *psta);
+
+int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
+		struct beacon_keys *recv_beacon);
+void rtw_dump_bcn_keys(struct beacon_keys *recv_beacon);
+int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len);
+void update_beacon_info(_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
+#ifdef CONFIG_DFS
+void process_csa_ie(_adapter *padapter, u8 *pframe, uint len);
+#endif //CONFIG_DFS
+void update_capinfo(PADAPTER Adapter, u16 updateCap);
+void update_wireless_mode(_adapter * padapter);
+void update_tx_basic_rate(_adapter *padapter, u8 modulation);
+void update_sta_basic_rate(struct sta_info *psta, u8 wireless_mode);
+int update_sta_support_rate(_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx);
+
+//for sta/adhoc mode
+void update_sta_info(_adapter *padapter, struct sta_info *psta);
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_MCS_rate(struct HT_caps_element *pHT_caps);
+void Update_RA_Entry(_adapter *padapter, struct sta_info *psta);
+void set_sta_rate(_adapter *padapter, struct sta_info *psta);
+
+unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr, unsigned short reason);
+
+unsigned char get_highest_rate_idx(u32 mask);
+int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode);
+unsigned int is_ap_in_tkip(_adapter *padapter);
+unsigned int is_ap_in_wep(_adapter *padapter);
+unsigned int should_forbid_n_rate(_adapter * padapter);
+
+s16 rtw_get_camid(_adapter *adapter, struct sta_info* sta, s16 kid);
+bool _rtw_camctl_chk_cap(_adapter *adapter, u8 cap);
+void _rtw_camctl_set_flags(_adapter *adapter, u32 flags);
+void rtw_camctl_set_flags(_adapter *adapter, u32 flags);
+void _rtw_camctl_clr_flags(_adapter *adapter, u32 flags);
+void rtw_camctl_clr_flags(_adapter *adapter, u32 flags);
+bool _rtw_camctl_chk_flags(_adapter *adapter, u32 flags);
+
+struct sec_cam_bmp;
+void dump_sec_cam_map(void *sel, struct sec_cam_bmp *map, u8 max_num);
+void rtw_sec_cam_map_clr_all(struct sec_cam_bmp *map);
+
+bool _rtw_camid_is_gk(_adapter *adapter, u8 cam_id);
+bool rtw_camid_is_gk(_adapter *adapter, u8 cam_id);
+s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid, s8 gk);
+s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid, bool *used);
+void rtw_camid_free(_adapter *adapter, u8 cam_id);
+
+struct macid_bmp;
+struct macid_ctl_t;
+void dump_macid_map(void *sel, struct macid_bmp *map, u8 max_num);
+bool rtw_macid_is_set(struct macid_bmp *map, u8 id);
+bool rtw_macid_is_used(struct macid_ctl_t *macid_ctl, u8 id);
+bool rtw_macid_is_bmc(struct macid_ctl_t *macid_ctl, u8 id);
+s8 rtw_macid_get_if_g(struct macid_ctl_t *macid_ctl, u8 id);
+s8 rtw_macid_get_ch_g(struct macid_ctl_t *macid_ctl, u8 id);
+void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta);
+void rtw_release_macid(_adapter *padapter, struct sta_info *psta);
+u8 rtw_search_max_mac_id(_adapter *padapter);
+void rtw_macid_ctl_set_h2c_msr(struct macid_ctl_t *macid_ctl, u8 id, u8 h2c_msr);
+void rtw_macid_ctl_init(struct macid_ctl_t *macid_ctl);
+void rtw_macid_ctl_deinit(struct macid_ctl_t *macid_ctl);
+
+void report_join_res(_adapter *padapter, int res);
+void report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
+void report_surveydone_event(_adapter *padapter);
+void report_del_sta_event(_adapter *padapter, unsigned char *MacAddr, unsigned short reason, bool enqueue);
+void report_add_sta_event(_adapter *padapter, unsigned char* MacAddr, int cam_idx);
+bool rtw_port_switch_chk(_adapter *adapter);
+void report_wmm_edca_update(_adapter *padapter);
+
+void beacon_timing_control(_adapter *padapter);
+u8 chk_bmc_sleepq_cmd(_adapter* padapter);
+extern u8 set_tx_beacon_cmd(_adapter*padapter);
+unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame);
+void update_mgnt_tx_rate(_adapter *padapter, u8 rate);
+void update_monitor_frame_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+void update_mgntframe_attrib_addr(_adapter *padapter, struct xmit_frame *pmgntframe);
+void dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
+s32 dump_mgntframe_and_wait(_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);
+s32 dump_mgntframe_and_wait_ack(_adapter *padapter, struct xmit_frame *pmgntframe);
+
+#ifdef CONFIG_P2P
+void issue_probersp_p2p(_adapter *padapter, unsigned char *da);
+void issue_p2p_provision_request( _adapter *padapter, u8* pssid, u8 ussidlen, u8* pdev_raddr);
+void issue_p2p_GO_request(_adapter *padapter, u8* raddr);
+void issue_probereq_p2p(_adapter *padapter, u8 *da);
+int issue_probereq_p2p_ex(_adapter *adapter, u8 *da, int try_cnt, int wait_ms);
+void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken, u8 success);
+void issue_p2p_invitation_request(_adapter *padapter, u8* raddr );
+#endif //CONFIG_P2P
+void issue_beacon(_adapter *padapter, int timeout_ms);
+void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
+void issue_assocreq(_adapter *padapter);
+void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
+void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
+void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da);
+s32 issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8* da, u8 ch, bool append_wps, int try_cnt, int wait_ms);
+int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da, unsigned int power_mode);
+int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
+int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
+int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
+void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset);
+void issue_addba_req(_adapter *adapter, unsigned char *ra, u8 tid);
+void issue_addba_rsp(_adapter *adapter, unsigned char *ra, u8 tid, u16 status, u8 size);
+void issue_del_ba(_adapter *adapter, unsigned char *ra, u8 tid, u16 reason, u8 initiator);
+int issue_del_ba_ex(_adapter *adapter, unsigned char *ra, u8 tid, u16 reason, u8 initiator, int try_cnt, int wait_ms);
+
+#ifdef CONFIG_IEEE80211W
+void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid, u8 key_type);
+int issue_deauth_11w(_adapter *padapter, unsigned char *da, unsigned short reason, u8 key_type);
+extern void init_dot11w_expire_timer(_adapter *padapter, struct sta_info *psta);
+#endif //CONFIG_IEEE80211W
+int issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode);
+int issue_action_SM_PS_wait_ack(_adapter *padapter, unsigned char *raddr, u8 NewMimoPsMode, int try_cnt, int wait_ms);
+
+unsigned int send_delba_sta_tid(_adapter *adapter, u8 initiator, struct sta_info *sta, u8 tid, u8 force);
+unsigned int send_delba_sta_tid_wait_ack(_adapter *adapter, u8 initiator, struct sta_info *sta, u8 tid, u8 force);
+
+unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
+unsigned int send_beacon(_adapter *padapter);
+
+void start_clnt_assoc(_adapter *padapter);
+void start_clnt_auth(_adapter* padapter);
+void start_clnt_join(_adapter* padapter);
+void start_create_ibss(_adapter* padapter);
+
+unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame);
+
+unsigned int on_action_spct(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_qos(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_dls(_adapter *padapter, union recv_frame *precv_frame);
+
+#define RX_AMPDU_ACCEPT_INVALID 0xFF
+#define RX_AMPDU_SIZE_INVALID 0xFF
+
+enum rx_ampdu_reason {
+	RX_AMPDU_DRV_FIXED = 1,
+	RX_AMPDU_BTCOEX = 2, /* not used, because BTCOEX has its own variable management */
+	RX_AMPDU_DRV_SCAN = 3,
+};
+u8 rtw_rx_ampdu_size(_adapter *adapter);
+bool rtw_rx_ampdu_is_accept(_adapter *adapter);
+bool rtw_rx_ampdu_set_size(_adapter *adapter, u8 size, u8 reason);
+bool rtw_rx_ampdu_set_accept(_adapter *adapter, u8 accept, u8 reason);
+u8 rx_ampdu_apply_sta_tid(_adapter *adapter, struct sta_info *sta, u8 tid, u8 accept, u8 size);
+u8 rx_ampdu_apply_sta(_adapter *adapter, struct sta_info *sta, u8 accept, u8 size);
+u16 rtw_rx_ampdu_apply(_adapter *adapter);
+
+unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int on_action_public(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame);
+#ifdef CONFIG_IEEE80211W
+unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame);
+#endif //CONFIG_IEEE80211W
+unsigned int OnAction_wmm(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_vht(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame);
+
+
+void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res);
+void mlmeext_sta_del_event_callback(_adapter *padapter);
+void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta);
+
+void linked_status_chk(_adapter *padapter, u8 from_timer);
+
+void _linked_info_dump(_adapter *padapter);
+
+void survey_timer_hdl (struct timer_list *t);
+void link_timer_hdl (struct timer_list *t);
+void addba_timer_hdl(struct timer_list *t);
+#ifdef CONFIG_IEEE80211W
+void sa_query_timer_hdl(struct timer_list *t);
+#endif //CONFIG_IEEE80211W
+//void reauth_timer_hdl(_adapter *padapter);
+//void reassoc_timer_hdl(_adapter *padapter);
+
+#define set_survey_timer(mlmeext, ms) \
+	do { \
+		/*DBG_871X("%s set_survey_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->survey_timer, (ms)); \
+	} while(0)
+
+#define set_link_timer(mlmeext, ms) \
+	do { \
+		/*DBG_871X("%s set_link_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->link_timer, (ms)); \
+	} while(0)
+
+extern int cckrates_included(unsigned char *rate, int ratelen);
+extern int cckratesonly_included(unsigned char *rate, int ratelen);
+
+extern void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr);
+
+extern void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
+extern void correct_TSF(_adapter *padapter, struct mlme_ext_priv *pmlmeext);
+extern void adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
+extern u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer);
+
+
+#ifdef CONFIG_CONCURRENT_MODE
+sint check_buddy_mlmeinfo_state(_adapter *padapter, u32 state);
+#endif
+
+void rtw_join_done_chk_ch(_adapter *padapter, int join_res);
+
+int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset);
+int rtw_get_ch_setting_union(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset);
+int rtw_get_ch_setting_union_no_self(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset);
+
+void rtw_dev_iface_status(_adapter *adapter, u8 *sta_num, u8 *ld_sta_num, u8 *lg_sta_num
+	, u8 *ap_num, u8 *ld_ap_num);
+void rtw_dev_iface_status_no_self(_adapter *adapter, u8 *sta_num, u8 *ld_sta_num, u8 *lg_sta_num
+	, u8 *ap_num, u8 *ld_ap_num);
+
+struct cmd_hdl {
+	uint	parmsize;
+	u8 (*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);
+};
+
+
+u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+
+
+u8 NULL_hdl(_adapter *padapter, u8 *pbuf);
+u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf);
+u8 disconnect_hdl(_adapter *padapter, u8 *pbuf);
+u8 createbss_hdl(_adapter *padapter, u8 *pbuf);
+u8 setopmode_hdl(_adapter *padapter, u8 *pbuf);
+u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf);
+u8 setauth_hdl(_adapter *padapter, u8 *pbuf);
+u8 setkey_hdl(_adapter *padapter, u8 *pbuf);
+u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf);
+u8 set_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+u8 del_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf);
+
+u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 set_ch_hdl(_adapter *padapter, u8 *pbuf);
+u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 led_blink_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 set_csa_hdl(_adapter *padapter, unsigned char *pbuf);	//Kurt: Handling DFS channel switch announcement ie.
+u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 run_in_thread_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtw_getmacreg_hdl(_adapter *padapter, u8 *pbuf);
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
+#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, cmd},
+
+#ifdef _RTW_CMD_C_
+
+struct cmd_hdl wlancmds[] =
+{
+	GEN_DRV_CMD_HANDLER(sizeof(struct readMAC_parm), rtw_getmacreg) /*0*/
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*10*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct joinbss_parm), join_cmd_hdl) /*14*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct disconnect_parm), disconnect_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct createbss_parm), createbss_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setopmode_parm), setopmode_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct sitesurvey_parm), sitesurvey_cmd_hdl) /*18*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct setauth_parm), setauth_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setkey_parm), setkey_hdl) /*20*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_stakey_parm), set_stakey_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct del_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setstapwrstate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setphyinfo_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getphyinfo_parm), NULL)  /*30*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct setphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)	/*40*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), set_ch_hdl) /* 46 */
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*50*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl) /*55*/
+
+	GEN_MLME_EXT_HANDLER(0, mlme_evt_hdl) /*56*/
+	GEN_MLME_EXT_HANDLER(0, rtw_drvextra_cmd_hdl) /*57*/
+
+	GEN_MLME_EXT_HANDLER(0, h2c_msg_hdl) /*58*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelPlan_param), set_chplan_hdl) /*59*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct LedBlink_param), led_blink_hdl) /*60*/
+
+	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelSwitch_param), set_csa_hdl) /*61*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct TDLSoption_param), tdls_hdl) /*62*/
+	GEN_MLME_EXT_HANDLER(0, chk_bmc_sleepq_hdl) /*63*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct RunInThread_param), run_in_thread_hdl) /*64*/
+};
+
+#endif
+
+struct C2HEvent_Header
+{
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	unsigned int len:16;
+	unsigned int ID:8;
+	unsigned int seq:8;
+
+#elif defined(CONFIG_BIG_ENDIAN)
+
+	unsigned int seq:8;
+	unsigned int ID:8;
+	unsigned int len:16;
+
+#else
+
+#  error "Must be LITTLE or BIG Endian"
+
+#endif
+
+	unsigned int rsvd;
+
+};
+
+void rtw_dummy_event_callback(_adapter *adapter , u8 *pbuf);
+void rtw_fwdbg_event_callback(_adapter *adapter , u8 *pbuf);
+
+enum rtw_c2h_event
+{
+	GEN_EVT_CODE(_Read_MACREG)=0, /*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+ 	GEN_EVT_CODE(_Read_RFREG),
+ 	GEN_EVT_CODE(_Read_EEPROM),
+ 	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),			/*5*/
+ 	GEN_EVT_CODE(_Get_BasicRate),
+ 	GEN_EVT_CODE(_Get_DataRate),
+ 	GEN_EVT_CODE(_Survey),	 /*8*/
+ 	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+
+ 	GEN_EVT_CODE(_JoinBss) , /*10*/
+ 	GEN_EVT_CODE(_AddSTA),
+ 	GEN_EVT_CODE(_DelSTA),
+ 	GEN_EVT_CODE(_AtimDone) ,
+ 	GEN_EVT_CODE(_TX_Report),
+	GEN_EVT_CODE(_CCX_Report),			/*15*/
+ 	GEN_EVT_CODE(_DTM_Report),
+ 	GEN_EVT_CODE(_TX_Rate_Statistics),
+ 	GEN_EVT_CODE(_C2HLBK),
+ 	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB
+	GEN_EVT_CODE(_CloseRF),				//filen: only for PCIE, work around ASPM
+	GEN_EVT_CODE(_WMM),					/*25*/
+#ifdef CONFIG_IEEE80211W
+	GEN_EVT_CODE(_TimeoutSTA),
+#endif /* CONFIG_IEEE80211W */
+ 	MAX_C2HEVT
+};
+
+
+#ifdef _RTW_MLME_EXT_C_
+
+static struct fwevent wlanevents[] =
+{
+	{0, rtw_dummy_event_callback}, 	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_survey_event_callback},		/*8*/
+	{sizeof (struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
+
+	{0, &rtw_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},
+	{0, &rtw_atimdone_event_callback},
+	{0, rtw_dummy_event_callback},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, rtw_fwdbg_event_callback},
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_cpwm_event_callback},
+	{0, NULL},
+	{0, &rtw_wmm_event_callback}, /*25*/
+#ifdef CONFIG_IEEE80211W
+	{sizeof(struct stadel_event), &rtw_sta_timeout_event_callback},
+#endif /* CONFIG_IEEE80211W */
+
+};
+
+#endif//_RTW_MLME_EXT_C_
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp.h
new file mode 100644
index 000000000..b5dceddbd
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp.h
@@ -0,0 +1,860 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_MP_H_
+#define _RTW_MP_H_
+
+#define RTWPRIV_VER_INFO	1
+
+#define MAX_MP_XMITBUF_SZ 	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame
+{
+	_list	list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int frame_tag;
+
+	_adapter *padapter;
+
+#ifdef CONFIG_USB_HCI
+
+	//insert urb, irp, and irpcnt info below...
+	//max frag_cnt = 8
+
+	u8 *mem_addr;
+	u32 sz[8];
+
+#if defined(PLATFORM_OS_XP) || defined(PLATFORM_LINUX)
+	PURB pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PIRP pxmit_irp[8];
+#endif
+
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+	uint irpcnt;
+	uint fragcnt;
+#endif /* CONFIG_USB_HCI */
+
+	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
+};
+
+struct mp_wiparam
+{
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+typedef void(*wi_act_func)(void* padapter);
+
+#ifdef PLATFORM_WINDOWS
+struct mp_wi_cntx
+{
+	u8 bmpdrv_unload;
+
+	// Work Item
+	NDIS_WORK_ITEM mp_wi;
+	NDIS_EVENT mp_wi_evt;
+	_lock mp_wi_lock;
+	u8 bmp_wi_progress;
+	wi_act_func curractfunc;
+	// Variable needed in each implementation of CurrActFunc.
+	struct mp_wiparam param;
+};
+#endif
+
+struct mp_tx
+{
+	u8 stop;
+	u32 count, sended;
+	u8 payload;
+	struct pkt_attrib attrib;
+	//struct tx_desc desc;
+	//u8 resvdtx[7];
+	u8 desc[TXDESC_SIZE];
+	u8 *pallocated_buf;
+	u8 *buf;
+	u32 buf_size, write_size;
+	_thread_hdl_ PktTxThread;
+};
+
+#define MP_MAX_LINES		1000
+#define MP_MAX_LINES_BYTES	256
+#define u1Byte u8
+#define s1Byte s8
+#define u4Byte u32
+#define s4Byte s32
+#define u1Byte		u8
+#define pu1Byte 		u8*
+
+#define u2Byte		u16
+#define pu2Byte 		u16*
+
+#define u4Byte		u32
+#define pu4Byte 		u32*
+
+#define u8Byte		u64
+#define pu8Byte 		u64*
+
+#define s1Byte		s8
+#define ps1Byte 		s8*
+
+#define s2Byte		s16
+#define ps2Byte 		s16*
+
+#define s4Byte		s32
+#define ps4Byte 		s32*
+
+#define s8Byte		s64
+#define ps8Byte 		s64*
+
+#define UCHAR u8
+#define USHORT u16
+#define UINT u32
+#define ULONG u32
+#define PULONG u32*
+
+
+
+typedef VOID (*MPT_WORK_ITEM_HANDLER)(IN PVOID Adapter);
+typedef struct _MPT_CONTEXT
+{
+	// Indicate if we have started Mass Production Test.
+	BOOLEAN			bMassProdTest;
+
+	// Indicate if the driver is unloading or unloaded.
+	BOOLEAN			bMptDrvUnload;
+
+	_sema			MPh2c_Sema;
+	_timer			MPh2c_timeout_timer;
+// Event used to sync H2c for BT control
+
+	BOOLEAN		MptH2cRspEvent;
+	BOOLEAN		MptBtC2hEvent;
+	BOOLEAN		bMPh2c_timeout;
+
+	/* 8190 PCI does not support NDIS_WORK_ITEM. */
+	// Work Item for Mass Production Test.
+	//NDIS_WORK_ITEM	MptWorkItem;
+//	RT_WORK_ITEM		MptWorkItem;
+	// Event used to sync the case unloading driver and MptWorkItem is still in progress.
+//	NDIS_EVENT		MptWorkItemEvent;
+	// To protect the following variables.
+//	NDIS_SPIN_LOCK		MptWorkItemSpinLock;
+	// Indicate a MptWorkItem is scheduled and not yet finished.
+	BOOLEAN			bMptWorkItemInProgress;
+	// An instance which implements function and context of MptWorkItem.
+	MPT_WORK_ITEM_HANDLER	CurrMptAct;
+
+	// 1=Start, 0=Stop from UI.
+	ULONG			MptTestStart;
+	// _TEST_MODE, defined in MPT_Req2.h
+	ULONG			MptTestItem;
+	// Variable needed in each implementation of CurrMptAct.
+	ULONG			MptActType; 	// Type of action performed in CurrMptAct.
+	// The Offset of IO operation is depend of MptActType.
+	ULONG			MptIoOffset;
+	// The Value of IO operation is depend of MptActType.
+	ULONG			MptIoValue;
+	// The RfPath of IO operation is depend of MptActType.
+	ULONG			MptRfPath;
+
+	WIRELESS_MODE		MptWirelessModeToSw;	// Wireless mode to switch.
+	u8			MptChannelToSw; 	// Channel to switch.
+	u8			MptInitGainToSet; 	// Initial gain to set.
+	//ULONG			bMptAntennaA; 		// TRUE if we want to use antenna A.
+	ULONG			MptBandWidth;		// bandwidth to switch.
+	ULONG			MptRateIndex;		// rate index.
+	// Register value kept for Single Carrier Tx test.
+	u8			btMpCckTxPower;
+	// Register value kept for Single Carrier Tx test.
+	u8			btMpOfdmTxPower;
+	// For MP Tx Power index
+	u8			TxPwrLevel[4];	/* rf-A, rf-B*/
+	u32			RegTxPwrLimit;
+	// Content of RCR Regsiter for Mass Production Test.
+	ULONG			MptRCR;
+	// TRUE if we only receive packets with specific pattern.
+	BOOLEAN			bMptFilterPattern;
+ 	// Rx OK count, statistics used in Mass Production Test.
+ 	ULONG			MptRxOkCnt;
+ 	// Rx CRC32 error count, statistics used in Mass Production Test.
+ 	ULONG			MptRxCrcErrCnt;
+
+	BOOLEAN			bCckContTx;	// TRUE if we are in CCK Continuous Tx test.
+ 	BOOLEAN			bOfdmContTx;	// TRUE if we are in OFDM Continuous Tx test.
+	BOOLEAN			bStartContTx; 	// TRUE if we have start Continuous Tx test.
+	// TRUE if we are in Single Carrier Tx test.
+	BOOLEAN			bSingleCarrier;
+	// TRUE if we are in Carrier Suppression Tx Test.
+	BOOLEAN			bCarrierSuppression;
+	//TRUE if we are in Single Tone Tx test.
+	BOOLEAN			bSingleTone;
+
+	// ACK counter asked by K.Y..
+	BOOLEAN			bMptEnableAckCounter;
+	ULONG			MptAckCounter;
+
+	// SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~!
+	//s1Byte		BufOfLines[2][MAX_LINES_HWCONFIG_TXT][MAX_BYTES_LINE_HWCONFIG_TXT];
+	//s1Byte			BufOfLines[2][MP_MAX_LINES][MP_MAX_LINES_BYTES];
+	//s4Byte			RfReadLine[2];
+
+	u8		APK_bound[2];	//for APK	path A/path B
+	BOOLEAN		bMptIndexEven;
+
+	u8		backup0xc50;
+	u8		backup0xc58;
+	u8		backup0xc30;
+	u8 		backup0x52_RF_A;
+	u8 		backup0x52_RF_B;
+
+	u4Byte			backup0x58_RF_A;
+	u4Byte			backup0x58_RF_B;
+
+	u1Byte			h2cReqNum;
+	u1Byte			c2hBuf[32];
+
+    u1Byte          btInBuf[100];
+	ULONG			mptOutLen;
+    u1Byte          mptOutBuf[100];
+
+}MPT_CONTEXT, *PMPT_CONTEXT;
+//#endif
+
+/* E-Fuse */
+#ifdef CONFIG_RTL8188E
+#define EFUSE_MAP_SIZE		512
+#endif
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8814A)
+#define EFUSE_MAP_SIZE		512
+#endif
+#ifdef CONFIG_RTL8192E
+#define EFUSE_MAP_SIZE		512
+#endif
+#ifdef CONFIG_RTL8723B
+#define EFUSE_MAP_SIZE		512
+#endif
+#ifdef CONFIG_RTL8814A
+#define EFUSE_MAP_SIZE		512
+#endif
+#ifdef CONFIG_RTL8703B
+#define EFUSE_MAP_SIZE		512
+#endif
+#ifdef CONFIG_RTL8188F
+#define EFUSE_MAP_SIZE		512
+#endif
+
+#if defined(CONFIG_RTL8814A)
+#define EFUSE_MAX_SIZE		1024
+#elif defined(CONFIG_RTL8188E) || defined(CONFIG_RTL8188F) || defined(CONFIG_RTL8703B)
+#define EFUSE_MAX_SIZE		256
+#else
+#define EFUSE_MAX_SIZE		512
+#endif
+/* end of E-Fuse */
+
+//#define RTPRIV_IOCTL_MP 					( SIOCIWFIRSTPRIV + 0x17)
+enum {
+	WRITE_REG = 1,
+	READ_REG,
+	WRITE_RF,
+	READ_RF,
+	MP_START,
+	MP_STOP,
+	MP_RATE,
+	MP_CHANNEL,
+	MP_BANDWIDTH,
+	MP_TXPOWER,
+	MP_ANT_TX,
+	MP_ANT_RX,
+	MP_CTX,
+	MP_QUERY,
+	MP_ARX,
+	MP_PSD,
+	MP_PWRTRK,
+	MP_THER,
+	MP_IOCTL,
+	EFUSE_GET,
+	EFUSE_SET,
+	MP_RESET_STATS,
+	MP_DUMP,
+	MP_PHYPARA,
+	MP_SetRFPathSwh,
+	MP_QueryDrvStats,
+	MP_SetBT,
+	CTA_TEST,
+	MP_DISABLE_BT_COEXIST,
+	MP_PwrCtlDM,
+	MP_GETVER,
+	MP_MON,
+	EFUSE_MASK,
+	EFUSE_FILE,
+	MP_TX,
+	MP_RX,
+#ifdef CONFIG_WOWLAN
+	MP_WOW_ENABLE,
+	MP_WOW_SET_PATTERN,
+#endif
+#ifdef CONFIG_AP_WOWLAN
+	MP_AP_WOW_ENABLE,
+#endif
+	MP_NULL,
+	MP_GET_TXPOWER_INX,
+
+	MP_SD_IREAD,
+	MP_SD_IWRITE,
+};
+
+struct mp_priv
+{
+	_adapter *papdater;
+
+	//Testing Flag
+	u32 mode;//0 for normal type packet, 1 for loopback packet (16bytes TXCMD)
+
+	u32 prev_fw_state;
+
+	//OID cmd handler
+	struct mp_wiparam workparam;
+//	u8 act_in_progress;
+
+	//Tx Section
+	u8 TID;
+	u32 tx_pktcount;
+	u32 pktInterval;
+	struct mp_tx tx;
+
+	//Rx Section
+	u32 rx_bssidpktcount;
+	u32 rx_pktcount;
+	u32 rx_pktcount_filter_out;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+	BOOLEAN  rx_bindicatePkt;
+	struct recv_stat rxstat;
+
+	//RF/BB relative
+	u8 channel;
+	u8 bandwidth;
+	u8 prime_channel_offset;
+	u8 txpoweridx;
+	u8 rateidx;
+	u32 preamble;
+//	u8 modem;
+	u32 CrystalCap;
+//	u32 curr_crystalcap;
+
+	u16 antenna_tx;
+	u16 antenna_rx;
+//	u8 curr_rfpath;
+
+	u8 check_mp_pkt;
+
+	u8 bSetTxPower;
+//	uint ForcedDataRate;
+	u8 mp_dm;
+	u8 mac_filter[ETH_ALEN];
+	u8 bmac_filter;
+
+	struct wlan_network mp_network;
+	NDIS_802_11_MAC_ADDRESS network_macaddr;
+
+#ifdef PLATFORM_WINDOWS
+	u32 rx_testcnt;
+	u32 rx_testcnt1;
+	u32 rx_testcnt2;
+	u32 tx_testcnt;
+	u32 tx_testcnt1;
+
+	struct mp_wi_cntx wi_cntx;
+
+	u8 h2c_result;
+	u8 h2c_seqnum;
+	u16 h2c_cmdcode;
+	u8 h2c_resp_parambuf[512];
+	_lock h2c_lock;
+	_lock wkitm_lock;
+	u32 h2c_cmdcnt;
+	NDIS_EVENT h2c_cmd_evt;
+	NDIS_EVENT c2h_set;
+	NDIS_EVENT h2c_clr;
+	NDIS_EVENT cpwm_int;
+
+	NDIS_EVENT scsir_full_evt;
+	NDIS_EVENT scsiw_empty_evt;
+#endif
+
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	_queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+	BOOLEAN bSetRxBssid;
+	BOOLEAN bTxBufCkFail;
+	BOOLEAN bRTWSmbCfg;
+	MPT_CONTEXT MptCtx;
+
+	u8		*TXradomBuffer;
+};
+
+typedef struct _IOCMD_STRUCT_ {
+	u8	cmdclass;
+	u16	value;
+	u8	index;
+}IOCMD_STRUCT;
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+
+typedef struct _MP_FIRMWARE {
+	FIRMWARE_SOURCE eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8* 		szFwBuffer;
+#else
+	u8			szFwBuffer[0x8000];
+#endif
+	u32 		ulFwLength;
+} RT_MP_FIRMWARE, *PRT_MP_FIRMWARE;
+
+
+
+
+//=======================================================================
+
+#define LOWER 	_TRUE
+#define RAISE	_FALSE
+
+/* Hardware Registers */
+#if 0
+#if 0
+#define IOCMD_CTRL_REG			0x102502C0
+#define IOCMD_DATA_REG			0x102502C4
+#else
+#define IOCMD_CTRL_REG			0x10250370
+#define IOCMD_DATA_REG			0x10250374
+#endif
+
+#define IOCMD_GET_THERMAL_METER		0xFD000028
+
+#define IOCMD_CLASS_BB_RF		0xF0
+#define IOCMD_BB_READ_IDX		0x00
+#define IOCMD_BB_WRITE_IDX		0x01
+#define IOCMD_RF_READ_IDX		0x02
+#define IOCMD_RF_WRIT_IDX		0x03
+#endif
+#define BB_REG_BASE_ADDR		0x800
+
+/* MP variables */
+#if 0
+#define _2MAC_MODE_	0
+#define _LOOPBOOK_MODE_	1
+#endif
+typedef enum _MP_MODE_ {
+	MP_OFF,
+	MP_ON,
+	MP_ERR,
+	MP_CONTINUOUS_TX,
+	MP_SINGLE_CARRIER_TX,
+	MP_CARRIER_SUPPRISSION_TX,
+	MP_SINGLE_TONE_TX,
+	MP_PACKET_TX,
+	MP_PACKET_RX
+} MP_MODE;
+
+typedef enum _MPT_BANDWIDTH {
+	MPT_BW_20MHZ = 0,
+	MPT_BW_40MHZ_DUPLICATE = 1,
+	MPT_BW_40MHZ_ABOVE = 2,
+	MPT_BW_40MHZ_BELOW = 3,
+	MPT_BW_40MHZ = 4,
+	MPT_BW_80MHZ = 5,
+	MPT_BW_80MHZ_20_ABOVE = 6,
+	MPT_BW_80MHZ_20_BELOW = 7,
+	MPT_BW_80MHZ_20_BOTTOM = 8,
+	MPT_BW_80MHZ_20_TOP = 9,
+	MPT_BW_80MHZ_40_ABOVE = 10,
+	MPT_BW_80MHZ_40_BELOW = 11,
+} MPT_BANDWIDTHE, *PMPT_BANDWIDTH;
+
+#define MAX_RF_PATH_NUMS	RF_PATH_MAX
+
+
+extern u8 mpdatarate[NumRates];
+
+/* MP set force data rate base on the definition. */
+typedef enum _MPT_RATE_INDEX
+{
+	/* CCK rate. */
+	MPT_RATE_1M =0 ,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_MCS16,
+	MPT_RATE_MCS17, // #29
+	MPT_RATE_MCS18,
+	MPT_RATE_MCS19,
+	MPT_RATE_MCS20,
+	MPT_RATE_MCS21,
+	MPT_RATE_MCS22, // #34
+	MPT_RATE_MCS23,
+	MPT_RATE_MCS24,
+	MPT_RATE_MCS25,
+	MPT_RATE_MCS26,
+	MPT_RATE_MCS27, // #39
+	MPT_RATE_MCS28, // #40
+	MPT_RATE_MCS29, // #41
+	MPT_RATE_MCS30, // #42
+	MPT_RATE_MCS31, // #43
+	/* VHT rate. Total: 20*/
+	MPT_RATE_VHT1SS_MCS0,//  #44
+	MPT_RATE_VHT1SS_MCS1, // #
+	MPT_RATE_VHT1SS_MCS2,
+	MPT_RATE_VHT1SS_MCS3,
+	MPT_RATE_VHT1SS_MCS4,
+	MPT_RATE_VHT1SS_MCS5,
+	MPT_RATE_VHT1SS_MCS6, // #
+	MPT_RATE_VHT1SS_MCS7,
+	MPT_RATE_VHT1SS_MCS8,
+	MPT_RATE_VHT1SS_MCS9, //#53
+	MPT_RATE_VHT2SS_MCS0, //#54
+	MPT_RATE_VHT2SS_MCS1,
+	MPT_RATE_VHT2SS_MCS2,
+	MPT_RATE_VHT2SS_MCS3,
+	MPT_RATE_VHT2SS_MCS4,
+	MPT_RATE_VHT2SS_MCS5,
+	MPT_RATE_VHT2SS_MCS6,
+	MPT_RATE_VHT2SS_MCS7,
+	MPT_RATE_VHT2SS_MCS8,
+	MPT_RATE_VHT2SS_MCS9, //#63
+	MPT_RATE_VHT3SS_MCS0,
+	MPT_RATE_VHT3SS_MCS1,
+	MPT_RATE_VHT3SS_MCS2,
+	MPT_RATE_VHT3SS_MCS3,
+	MPT_RATE_VHT3SS_MCS4,
+	MPT_RATE_VHT3SS_MCS5,
+	MPT_RATE_VHT3SS_MCS6, // #126
+	MPT_RATE_VHT3SS_MCS7,
+	MPT_RATE_VHT3SS_MCS8,
+	MPT_RATE_VHT3SS_MCS9,
+	MPT_RATE_VHT4SS_MCS0,
+	MPT_RATE_VHT4SS_MCS1, // #131
+	MPT_RATE_VHT4SS_MCS2,
+	MPT_RATE_VHT4SS_MCS3,
+	MPT_RATE_VHT4SS_MCS4,
+	MPT_RATE_VHT4SS_MCS5,
+	MPT_RATE_VHT4SS_MCS6, // #136
+	MPT_RATE_VHT4SS_MCS7,
+	MPT_RATE_VHT4SS_MCS8,
+	MPT_RATE_VHT4SS_MCS9,
+	MPT_RATE_LAST
+}MPT_RATE_E, *PMPT_RATE_E;
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	// 0x3F
+
+typedef enum _POWER_MODE_ {
+	POWER_LOW = 0,
+	POWER_NORMAL
+}POWER_MODE;
+
+// The following enumeration is used to define the value of Reg0xD00[30:28] or JaguarReg0x914[18:16].
+typedef enum _OFDM_TX_MODE {
+	OFDM_ALL_OFF		= 0,
+	OFDM_ContinuousTx	= 1,
+	OFDM_SingleCarrier	= 2,
+	OFDM_SingleTone 	= 4,
+} OFDM_TX_MODE;
+
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+#define Mac_OFDM_OK 			0x00000000
+#define Mac_OFDM_Fail			0x10000000
+#define Mac_OFDM_FasleAlarm 	0x20000000
+#define Mac_CCK_OK				0x30000000
+#define Mac_CCK_Fail			0x40000000
+#define Mac_CCK_FasleAlarm		0x50000000
+#define Mac_HT_OK				0x60000000
+#define Mac_HT_Fail 			0x70000000
+#define Mac_HT_FasleAlarm		0x90000000
+#define Mac_DropPacket			0xA0000000
+
+typedef enum _ENCRY_CTRL_STATE_ {
+	HW_CONTROL,		//hw encryption& decryption
+	SW_CONTROL,		//sw encryption& decryption
+	HW_ENCRY_SW_DECRY,	//hw encryption & sw decryption
+	SW_ENCRY_HW_DECRY	//sw encryption & hw decryption
+}ENCRY_CTRL_STATE;
+
+typedef enum	_MPT_TXPWR_DEF{
+	MPT_CCK,
+	MPT_OFDM, // L and HT OFDM
+	MPT_OFDM_AND_HT,
+	MPT_HT,
+	MPT_VHT
+}MPT_TXPWR_DEF;
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+
+#if defined(CONFIG_RTL8723B)
+	#define 	REG_RF_BB_GAIN_OFFSET	0x7f
+	#define 	RF_GAIN_OFFSET_MASK 	0xfffff
+#elif defined(CONFIG_RTL8188E)
+	#define 	REG_RF_BB_GAIN_OFFSET	0x55
+	#define 	RF_GAIN_OFFSET_MASK 	0xfffff
+#else
+	#define 	REG_RF_BB_GAIN_OFFSET	0x55
+	#define 	RF_GAIN_OFFSET_MASK 	0xfffff
+#endif	//CONFIG_RTL8723B
+
+#endif //CONFIG_RF_GAIN_OFFSET
+
+//=======================================================================
+//extern struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv);
+//extern int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe);
+
+extern s32 init_mp_priv(PADAPTER padapter);
+extern void free_mp_priv(struct mp_priv *pmp_priv);
+extern s32 MPT_InitializeAdapter(PADAPTER padapter, u8 Channel);
+extern void MPT_DeInitAdapter(PADAPTER padapter);
+extern s32 mp_start_test(PADAPTER padapter);
+extern void mp_stop_test(PADAPTER padapter);
+
+extern u32 _read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask);
+extern void _write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
+
+extern u32 read_macreg(_adapter *padapter, u32 addr, u32 sz);
+extern void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz);
+extern u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask);
+extern void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
+extern u32 read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr);
+extern void write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 val);
+
+void	SetChannel(PADAPTER pAdapter);
+void	SetBandwidth(PADAPTER pAdapter);
+int	SetTxPower(PADAPTER pAdapter);
+void	SetAntenna(PADAPTER pAdapter);
+void	SetDataRate(PADAPTER pAdapter);
+void	SetAntenna(PADAPTER pAdapter);
+s32	SetThermalMeter(PADAPTER pAdapter, u8 target_ther);
+void	GetThermalMeter(PADAPTER pAdapter, u8 *value);
+void	SetContinuousTx(PADAPTER pAdapter, u8 bStart);
+void	SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
+void	SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
+void	SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
+void	PhySetTxPowerLevel(PADAPTER pAdapter);
+void	fill_txdesc_for_mp(PADAPTER padapter, u8 *ptxdesc);
+void	SetPacketTx(PADAPTER padapter);
+void	SetPacketRx(PADAPTER pAdapter, u8 bStartRx, u8 bAB);
+void	ResetPhyRxPktCount(PADAPTER pAdapter);
+u32	GetPhyRxPktReceived(PADAPTER pAdapter);
+u32	GetPhyRxPktCRC32Error(PADAPTER pAdapter);
+s32	SetPowerTracking(PADAPTER padapter, u8 enable);
+void	GetPowerTracking(PADAPTER padapter, u8 *enable);
+u32	mp_query_psd(PADAPTER pAdapter, u8 *data);
+
+
+
+void hal_mpt_SwitchRfSetting(PADAPTER pAdapter);
+s32 hal_mpt_SetPowerTracking(PADAPTER padapter, u8 enable);
+void hal_mpt_GetPowerTracking(PADAPTER padapter, u8 *enable);
+void hal_mpt_CCKTxPowerAdjust(PADAPTER Adapter, BOOLEAN bInCH14);
+void hal_mpt_SetChannel(PADAPTER pAdapter);
+void hal_mpt_SetBandwidth(PADAPTER pAdapter);
+void hal_mpt_SetTxPower(PADAPTER pAdapter);
+void hal_mpt_SetDataRate(PADAPTER pAdapter);
+void hal_mpt_SetAntenna(PADAPTER pAdapter);
+s32 hal_mpt_SetThermalMeter(PADAPTER pAdapter, u8 target_ther);
+void hal_mpt_TriggerRFThermalMeter(PADAPTER pAdapter);
+u8 hal_mpt_ReadRFThermalMeter(PADAPTER pAdapter);
+void hal_mpt_GetThermalMeter(PADAPTER pAdapter, u8 *value);
+void hal_mpt_CCKTxPowerAdjustbyIndex(PADAPTER pAdapter, BOOLEAN beven);
+void hal_mpt_SetContinuousTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetCCKContinuousTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetOFDMContinuousTx(PADAPTER pAdapter, u8 bStart);
+
+void MP_PHY_SetRFPathSwitch(PADAPTER pAdapter , BOOLEAN bMain);
+ULONG mpt_ProQueryCalTxPower(PADAPTER	pAdapter, u8 RfPath);
+void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart);
+u8 MptToMgntRate(u32	MptRateIdx);
+u8 rtw_mpRateParseFunc(PADAPTER pAdapter, u8 *targetStr);
+u32 mp_join(PADAPTER padapter, u8 mode);
+
+int rtw_mp_write_reg(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_read_reg(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_write_rf(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_read_rf(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_start(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_stop(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_rate(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_channel(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_bandwidth(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_txpower_index(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_txpower(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_txpower(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_ant_tx(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_ant_rx(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_set_ctx_destAddr(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_ctx(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_disable_bt_coexist(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_disable_bt_coexist(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_arx(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_trx_query(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_pwrtrk(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_psd(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_thermal(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_reset_stats(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_dump(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_phypara(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_SetRFPath(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_QueryDrv(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_PwrCtlDM(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *wrqu, char *extra);
+int rtw_mp_getver(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_mon(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_efuse_mask_file(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_efuse_file_map(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_SetBT(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_pretx_proc(PADAPTER padapter, u8 bStartTest, char *extra);
+int rtw_mp_tx(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+int rtw_mp_rx(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra);
+
+#endif //_RTW_MP_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_ioctl.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_ioctl.h
new file mode 100644
index 000000000..0d126a9b6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_ioctl.h
@@ -0,0 +1,591 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_MP_IOCTL_H_
+#define _RTW_MP_IOCTL_H_
+
+#include <mp_custom_oid.h>
+#include <rtw_mp.h>
+
+#if 0
+#define TESTFWCMDNUMBER			1000000
+#define TEST_H2CINT_WAIT_TIME		500
+#define TEST_C2HINT_WAIT_TIME		500
+#define HCI_TEST_SYSCFG_HWMASK		1
+#define _BUSCLK_40M			(4 << 2)
+#endif
+//------------------------------------------------------------------------------
+typedef struct CFG_DBG_MSG_STRUCT {
+	u32 DebugLevel;
+	u32 DebugComponent_H32;
+	u32 DebugComponent_L32;
+}CFG_DBG_MSG_STRUCT,*PCFG_DBG_MSG_STRUCT;
+
+typedef struct _RW_REG {
+	u32 offset;
+	u32 width;
+	u32 value;
+}mp_rw_reg,RW_Reg, *pRW_Reg;
+
+//for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM
+typedef struct _EEPROM_RW_PARAM {
+	u32 offset;
+	u16 value;
+}eeprom_rw_param,EEPROM_RWParam, *pEEPROM_RWParam;
+
+typedef struct _EFUSE_ACCESS_STRUCT_ {
+	u16	start_addr;
+	u16	cnts;
+	u8	data[0];
+}EFUSE_ACCESS_STRUCT, *PEFUSE_ACCESS_STRUCT;
+
+typedef struct _BURST_RW_REG {
+	u32 offset;
+	u32 len;
+	u8 Data[256];
+}burst_rw_reg,Burst_RW_Reg, *pBurst_RW_Reg;
+
+typedef struct _USB_VendorReq{
+	u8	bRequest;
+	u16	wValue;
+	u16	wIndex;
+	u16	wLength;
+	u8	u8Dir;//0:OUT, 1:IN
+	u8	u8InData;
+}usb_vendor_req, USB_VendorReq, *pUSB_VendorReq;
+
+typedef struct _DR_VARIABLE_STRUCT_ {
+	u8 offset;
+	u32 variable;
+}DR_VARIABLE_STRUCT;
+
+//int mp_start_joinbss(_adapter *padapter, NDIS_802_11_SSID *pssid);
+
+//void _irqlevel_changed_(_irqL *irqlevel, /*BOOLEAN*/unsigned char bLower);
+#ifdef PLATFORM_OS_XP
+static void _irqlevel_changed_(_irqL *irqlevel, u8 bLower)
+{
+
+	if (bLower == LOWER) {
+		*irqlevel = KeGetCurrentIrql();
+
+		if (*irqlevel > PASSIVE_LEVEL) {
+			KeLowerIrql(PASSIVE_LEVEL);
+		}
+	} else {
+		if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
+			KeRaiseIrql(DISPATCH_LEVEL, irqlevel);
+		}
+	}
+
+}
+#else
+#define _irqlevel_changed_(a,b)
+#endif
+
+//oid_rtl_seg_81_80_00
+NDIS_STATUS oid_rt_pro_set_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_start_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_stop_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_81_80_20
+NDIS_STATUS oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_modulation_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_87
+NDIS_STATUS oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_85
+NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+
+// oid_rtl_seg_87_11_00
+NDIS_STATUS oid_rt_pro8711_join_bss_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_read_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_write_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write16_eeprom_hdl (struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_rd_attrib_mem_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_wr_attrib_mem_hdl (struct oid_par_priv* poid_par_priv);
+NDIS_STATUS  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_poll_rx_status_hdl(struct oid_par_priv* poid_par_priv);
+// oid_rtl_seg_87_11_20
+NDIS_STATUS oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_tssi_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_87_11_50
+NDIS_STATUS oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_87_11_F0
+NDIS_STATUS oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_87_12_00
+NDIS_STATUS oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_add_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_set_bandwidth_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_crystal_cap_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_max_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_get_thermal_meter_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_set_power_down_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_trigger_gpio_hdl(struct oid_par_priv *poid_par_priv);
+
+#ifdef _RTW_MP_IOCTL_C_
+
+const struct oid_obj_priv oid_rtl_seg_81_80_00[] =
+{
+	{1, &oid_null_function},			//0x00	OID_RT_PRO_RESET_DUT
+	{1, &oid_rt_pro_set_data_rate_hdl},		//0x01
+	{1, &oid_rt_pro_start_test_hdl},		//0x02
+	{1, &oid_rt_pro_stop_test_hdl},			//0x03
+	{1, &oid_null_function},			//0x04	OID_RT_PRO_SET_PREAMBLE
+	{1, &oid_null_function},			//0x05	OID_RT_PRO_SET_SCRAMBLER
+	{1, &oid_null_function},			//0x06	OID_RT_PRO_SET_FILTER_BB
+	{1, &oid_null_function},			//0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	//0x08
+	{1, &oid_null_function},			//0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL
+	{1, &oid_null_function},			//0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL
+	{1, &oid_rt_pro_set_continuous_tx_hdl},		//0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	//0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS
+	{1, &oid_null_function},			//0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		//0x0E
+	{1, &oid_null_function},			//0x0F	OID_RT_PRO_SET_CR_SCRAMBLER
+	{1, &oid_null_function},			//0x10	OID_RT_PRO_SET_CR_NEW_FILTER
+	{1, &oid_rt_pro_set_tx_power_control_hdl},	//0x11	OID_RT_PRO_SET_TX_POWER_CONTROL
+	{1, &oid_null_function},			//0x12	OID_RT_PRO_SET_CR_TX_CONFIG
+	{1, &oid_null_function},			//0x13	OID_RT_PRO_GET_TX_POWER_CONTROL
+	{1, &oid_null_function},			//0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x15	OID_RT_PRO_SET_CR_SETPOINT
+	{1, &oid_null_function},			//0x16	OID_RT_PRO_SET_INTEGRATOR
+	{1, &oid_null_function},			//0x17	OID_RT_PRO_SET_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x18	OID_RT_PRO_GET_INTEGRATOR
+	{1, &oid_null_function},			//0x19	OID_RT_PRO_GET_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE
+	{1, &oid_null_function},			//0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS
+	{1, &oid_null_function},			//0x1C	OID_RT_PRO_READ_MAC_ADDRESS
+	{1, &oid_null_function},			//0x1D	OID_RT_PRO_WRITE_CIS_DATA
+	{1, &oid_null_function},			//0x1E	OID_RT_PRO_READ_CIS_DATA
+	{1, &oid_null_function}				//0x1F	OID_RT_PRO_WRITE_POWER_CONTROL
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_20[] =
+{
+	{1, &oid_null_function},			//0x20	OID_RT_PRO_READ_POWER_CONTROL
+	{1, &oid_null_function},			//0x21	OID_RT_PRO_WRITE_EEPROM
+	{1, &oid_null_function},			//0x22	OID_RT_PRO_READ_EEPROM
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	//0x23
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	//0x24
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	//0x25
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	//0x26
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	//0x27
+	{1, &oid_null_function},			//0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS
+	{1, &oid_null_function},			//0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS
+	{1, &oid_null_function},			//0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},//0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX
+	{1, &oid_null_function},			//0x2C	OID_RT_PRO_RECEIVE_PACKET
+	{1, &oid_null_function},			//0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE
+	{1, &oid_null_function},			//0x2E	OID_RT_PRO_READ_EEPROM_BYTE
+	{1, &oid_rt_pro_set_modulation_hdl}		//0x2F
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_40[] =
+{
+	{1, &oid_null_function},			//0x40
+	{1, &oid_null_function},			//0x41
+	{1, &oid_null_function},			//0x42
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	//0x43
+	{1, &oid_null_function},			//0x44
+	{1, &oid_null_function}				//0x45
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_80[] =
+{
+	{1, &oid_null_function},			//0x80	OID_RT_DRIVER_OPTION
+	{1, &oid_null_function},			//0x81	OID_RT_RF_OFF
+	{1, &oid_null_function}				//0x82	OID_RT_AUTH_STATUS
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_85[] =
+{
+	{1, &oid_rt_wireless_mode_hdl}			//0x00	OID_RT_WIRELESS_MODE
+};
+
+struct oid_obj_priv oid_rtl_seg_81_87[] =
+{
+	{1, &oid_null_function},			//0x80	OID_RT_PRO8187_WI_POLL
+	{1, &oid_rt_pro_write_bb_reg_hdl},		//0x81
+	{1, &oid_rt_pro_read_bb_reg_hdl},		//0x82
+	{1, &oid_rt_pro_write_rf_reg_hdl},		//0x82
+	{1, &oid_rt_pro_read_rf_reg_hdl}		//0x83
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_00[] =
+{
+	{1, &oid_rt_pro8711_join_bss_hdl},		//0x00  //S
+	{1, &oid_rt_pro_read_register_hdl},		//0x01
+	{1, &oid_rt_pro_write_register_hdl},		//0x02
+	{1, &oid_rt_pro_burst_read_register_hdl},	//0x03
+	{1, &oid_rt_pro_burst_write_register_hdl},	//0x04
+	{1, &oid_rt_pro_write_txcmd_hdl},		//0x05
+	{1, &oid_rt_pro_read16_eeprom_hdl},		//0x06
+	{1, &oid_rt_pro_write16_eeprom_hdl},		//0x07
+	{1, &oid_null_function},			//0x08	OID_RT_PRO_H2C_SET_COMMAND
+	{1, &oid_null_function},			//0x09	OID_RT_PRO_H2C_QUERY_RESULT
+	{1, &oid_rt_pro8711_wi_poll_hdl},		//0x0A
+	{1, &oid_rt_pro8711_pkt_loss_hdl},		//0x0B
+	{1, &oid_rt_rd_attrib_mem_hdl},			//0x0C
+	{1, &oid_rt_wr_attrib_mem_hdl},			//0x0D
+	{1, &oid_null_function},			//0x0E
+	{1, &oid_null_function},			//0x0F
+	{1, &oid_null_function},			//0x10	OID_RT_PRO_H2C_CMD_MODE
+	{1, &oid_null_function},			//0x11	OID_RT_PRO_H2C_CMD_RSP_MODE
+	{1, &oid_null_function},			//0X12	OID_RT_PRO_WAIT_C2H_EVENT
+	{1, &oid_null_function},			//0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST
+	{1, &oid_null_function},			//0X14	OID_RT_PRO_SCSI_ACCESS_TEST
+	{1, &oid_null_function},			//0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT
+	{1, &oid_null_function},			//0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN
+	{1, &oid_null_function},			//0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL
+	{1, &oid_null_function},			//0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL
+	{1, &oid_null_function},			//0X19	OID_RT_RPO_SET_PWRMGT_TEST
+	{1, &oid_null_function},			//0X1A
+	{1, &oid_null_function},			//0X1B	OID_RT_PRO_QRY_PWRMGT_TEST
+	{1, &oid_null_function},			//0X1C	OID_RT_RPO_ASYNC_RWIO_TEST
+	{1, &oid_null_function},			//0X1D	OID_RT_RPO_ASYNC_RWIO_POLL
+	{1, &oid_rt_pro_set_rf_intfs_hdl},		//0X1E
+	{1, &oid_rt_poll_rx_status_hdl}			//0X1F
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_20[] =
+{
+	{1, &oid_rt_pro_cfg_debug_message_hdl},		//0x20
+	{1, &oid_rt_pro_set_data_rate_ex_hdl},		//0x21
+	{1, &oid_rt_pro_set_basic_rate_hdl},		//0x22
+	{1, &oid_rt_pro_read_tssi_hdl},			//0x23
+	{1, &oid_rt_pro_set_power_tracking_hdl}		//0x24
+};
+
+
+struct oid_obj_priv oid_rtl_seg_87_11_50[] =
+{
+	{1, &oid_rt_pro_qry_pwrstate_hdl},		//0x50
+	{1, &oid_rt_pro_set_pwrstate_hdl}		//0x51
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_80[] =
+{
+	{1, &oid_null_function}				//0x80
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_B0[] =
+{
+	{1, &oid_null_function}				//0xB0
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_F0[] =
+{
+	{1, &oid_null_function},			//0xF0
+	{1, &oid_null_function},			//0xF1
+	{1, &oid_null_function},			//0xF2
+	{1, &oid_null_function},			//0xF3
+	{1, &oid_null_function},			//0xF4
+	{1, &oid_null_function},			//0xF5
+	{1, &oid_null_function},			//0xF6
+	{1, &oid_null_function},			//0xF7
+	{1, &oid_null_function},			//0xF8
+	{1, &oid_null_function},			//0xF9
+	{1, &oid_null_function},			//0xFA
+	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	//0xFB
+	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	//0xFC
+	{1, &oid_null_function},			//0xFD
+	{1, &oid_null_function},			//0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST
+	{1, &oid_null_function}				//0xFF
+
+};
+
+struct oid_obj_priv oid_rtl_seg_87_12_00[]=
+{
+	{1, &oid_rt_pro_encryption_ctrl_hdl},		//0x00	Q&S
+	{1, &oid_rt_pro_add_sta_info_hdl},		//0x01	S
+	{1, &oid_rt_pro_dele_sta_info_hdl},		//0x02	S
+	{1, &oid_rt_pro_query_dr_variable_hdl},		//0x03	Q
+	{1, &oid_rt_pro_rx_packet_type_hdl},		//0x04	Q,S
+	{1, &oid_rt_pro_read_efuse_hdl},		//0x05	Q	OID_RT_PRO_READ_EFUSE
+	{1, &oid_rt_pro_write_efuse_hdl},		//0x06	S	OID_RT_PRO_WRITE_EFUSE
+	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		//0x07	Q,S
+	{1, &oid_rt_get_efuse_current_size_hdl},	//0x08 	Q
+	{1, &oid_rt_set_bandwidth_hdl},			//0x09
+	{1, &oid_rt_set_crystal_cap_hdl},		//0x0a
+	{1, &oid_rt_set_rx_packet_type_hdl},		//0x0b	S
+	{1, &oid_rt_get_efuse_max_size_hdl},		//0x0c
+	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		//0x0d
+	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		//0x0e
+	{1, &oid_null_function},			//0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING
+	{1, &oid_rt_get_thermal_meter_hdl},		//0x10	Q	OID_RT_PRO_GET_THERMAL_METER
+	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	//0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT
+	{1, &oid_rt_get_phy_rx_packet_received_hdl},	//0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED
+	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	//0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR
+	{1, &oid_rt_set_power_down_hdl},		//0x14	Q	OID_RT_SET_POWER_DOWN
+	{1, &oid_rt_get_power_mode_hdl}			//0x15	Q	OID_RT_GET_POWER_MODE
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+struct rwreg_param{
+	u32 offset;
+	u32 width;
+	u32 value;
+};
+
+struct bbreg_param{
+	u32 offset;
+	u32 phymask;
+	u32 value;
+};
+/*
+struct rfchannel_param{
+	u32 ch;
+	u32 modem;
+};
+*/
+struct txpower_param{
+	u32 pwr_index;
+};
+
+
+struct datarate_param{
+	u32 rate_index;
+};
+
+
+struct rfintfs_parm {
+	u32 rfintfs;
+};
+
+typedef struct _mp_xmit_parm_ {
+	u8 enable;
+	u32 count;
+	u16 length;
+	u8 payload_type;
+	u8 da[ETH_ALEN];
+}MP_XMIT_PARM, *PMP_XMIT_PARM;
+
+struct mp_xmit_packet {
+	u32 len;
+	u32 mem[MAX_MP_XMITBUF_SZ >> 2];
+};
+
+struct psmode_param {
+	u32 ps_mode;
+	u32 smart_ps;
+};
+
+//for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM
+struct eeprom_rw_param {
+	u32 offset;
+	u16 value;
+};
+
+struct mp_ioctl_handler {
+	u32 paramsize;
+	u32 (*handler)(struct oid_par_priv* poid_par_priv);
+	u32 oid;
+};
+
+struct mp_ioctl_param{
+	u32 subcode;
+	u32 len;
+	u8 data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START),			/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP),
+	GEN_MP_IOCTL_SUBCODE(READ_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*10*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),
+	GEN_MP_IOCTL_SUBCODE(SET_ANTENNA),
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),
+	GEN_MP_IOCTL_SUBCODE(SC_TX),
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*15*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*20*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),
+	GEN_MP_IOCTL_SUBCODE(EFUSE),
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*30*/
+	GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO),
+	GEN_MP_IOCTL_SUBCODE(SET_DM_BT),		/*32*/
+	GEN_MP_IOCTL_SUBCODE(DEL_BA),			/*33*/
+	GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS),	/*34*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+u32 mp_ioctl_xmit_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+#ifdef _RTW_MP_IOCTL_C_
+
+#define GEN_MP_IOCTL_HANDLER(sz, hdl, oid) {sz, hdl, oid},
+
+#define EXT_MP_IOCTL_HANDLER(sz, subcode, oid) {sz, mp_ioctl_ ## subcode ## _hdl, oid},
+
+
+struct mp_ioctl_handler mp_ioctl_hdl[] = {
+
+/*0*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_start_test_hdl, OID_RT_PRO_START_TEST)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_stop_test_hdl, OID_RT_PRO_STOP_TEST)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_register_hdl, OID_RT_PRO_READ_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_register_hdl, OID_RT_PRO_WRITE_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_read_bb_reg_hdl, OID_RT_PRO_READ_BB_REG)
+/*5*/	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_write_bb_reg_hdl, OID_RT_PRO_WRITE_BB_REG)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rf_reg_param), oid_rt_pro_read_rf_reg_hdl, OID_RT_PRO_RF_READ_REGISTRY)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rf_reg_param), oid_rt_pro_write_rf_reg_hdl, OID_RT_PRO_RF_WRITE_REGISTRY)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_channel_direct_call_hdl, OID_RT_PRO_SET_CHANNEL_DIRECT_CALL)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct txpower_param), oid_rt_pro_set_tx_power_control_hdl, OID_RT_PRO_SET_TX_POWER_CONTROL)
+/*10*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_data_rate_hdl, OID_RT_PRO_SET_DATA_RATE)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_bandwidth_hdl, OID_RT_SET_BANDWIDTH)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_antenna_bb_hdl, OID_RT_PRO_SET_ANTENNA_BB)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_continuous_tx_hdl, OID_RT_PRO_SET_CONTINUOUS_TX)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl, OID_RT_PRO_SET_SINGLE_CARRIER_TX)
+/*15*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl, OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl, OID_RT_PRO_SET_SINGLE_TONE_TX)
+
+	EXT_MP_IOCTL_HANDLER(0, xmit_packet, 0)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_rx_packet_type_hdl, OID_RT_SET_RX_PACKET_TYPE)
+	GEN_MP_IOCTL_HANDLER(0, oid_rt_reset_phy_rx_packet_count_hdl, OID_RT_RESET_PHY_RX_PACKET_COUNT)
+/*20*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl, OID_RT_GET_PHY_RX_PACKET_RECEIVED)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl, OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)
+	GEN_MP_IOCTL_HANDLER(sizeof(EFUSE_ACCESS_STRUCT), oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE)
+/*25*/	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_efuse_map_hdl, OID_RT_PRO_EFUSE_MAP)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_max_size_hdl, OID_RT_GET_EFUSE_MAX_SIZE)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_current_size_hdl, OID_RT_GET_EFUSE_CURRENT_SIZE)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_thermal_meter_hdl, OID_RT_PRO_GET_THERMAL_METER)
+	GEN_MP_IOCTL_HANDLER(sizeof(u8), oid_rt_pro_set_power_tracking_hdl, OID_RT_PRO_SET_POWER_TRACKING)
+/*30*/	GEN_MP_IOCTL_HANDLER(sizeof(u8), oid_rt_set_power_down_hdl, OID_RT_SET_POWER_DOWN)
+/*31*/	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_trigger_gpio_hdl, 0)
+	GEN_MP_IOCTL_HANDLER(0, NULL, 0)
+	GEN_MP_IOCTL_HANDLER(0, NULL, 0)
+	GEN_MP_IOCTL_HANDLER(0, NULL, 0)
+};
+
+#else /* _RTW_MP_IOCTL_C_ */
+
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+
+#endif /* _RTW_MP_IOCTL_C_ */
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_phy_regdef.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_phy_regdef.h
new file mode 100644
index 000000000..be009a979
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_mp_phy_regdef.h
@@ -0,0 +1,1100 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*****************************************************************************
+ *
+ * Module:	__RTW_MP_PHY_REGDEF_H_
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *	Data			Who		Remark
+ *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
+ *						2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __RTW_MP_PHY_REGDEF_H_
+#define __RTW_MP_PHY_REGDEF_H_
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       8192S Regsiter offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+//#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+//#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+//#define rFPGA0_XC_RFTiming        		0x818
+//#define rFPGA0_XD_RFTiming        		0x81c
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rFPGA0_XC_HSSIParameter1		0x830
+#define		rFPGA0_XC_HSSIParameter2		0x834
+#define		rFPGA0_XD_HSSIParameter1		0x838
+#define		rFPGA0_XD_HSSIParameter2		0x83c
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+#define		rFPGA0_XC_LSSIParameter		0x848
+#define		rFPGA0_XD_LSSIParameter		0x84c
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XC_RFInterfaceOE		0x868
+#define		rFPGA0_XD_RFInterfaceOE		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+#define 	rS0S1_PathSwitch			0x948
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+#define		rOFDM0_RxIQExtAnta			0xca0
+
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_Rate18_06				0xe00
+#define		rTxAGC_Rate54_24				0xe04
+#define		rTxAGC_CCK_Mcs32				0xe08
+#define		rTxAGC_Mcs03_Mcs00			0xe10
+#define		rTxAGC_Mcs07_Mcs04			0xe14
+#define		rTxAGC_Mcs11_Mcs08			0xe18
+#define		rTxAGC_Mcs15_Mcs12			0xe1c
+
+// Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register]
+#define 		rRx_Wait_CCCA					0xe70
+#define		rAnapar_Ctrl_BB					0xee0
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define RTL92SE_FPGA_VERIFY 0
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+//#if (RTL92SE_FPGA_VERIFY == 1)
+#define		rZebra1_Channel				0x7	// RF channel switch
+//#else
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1				0x01	//
+#define		RF_IQADJ_G2				0x02	//
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC				0x08	//
+#define		RF_BS_IQGEN				0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_TXBIAS					0x16 //
+#define		RF_POW_ABILITY			0x17	//
+#define		RF_MODE_AG				0x18	//
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1					0x1E	//
+#define		RF_RCK2					0x1F	//
+
+#define		RF_TX_G1					0x20	//
+#define		RF_TX_G2					0x21	//
+#define		RF_TX_G3					0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER					0x24	//
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadAddress          		0x3f000000   //LSSI "Read" Address	// Reg 0x824 rFPGA0_XA_HSSIParameter2
+#else
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+#endif
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadBackData         		0xfff		// Reg 0x8a0 rFPGA0_XA_LSSIReadBack
+#else
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+#endif
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving         		0x80
+#define		bCCKRxPowerSaving         		0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                			0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable      		0x8000
+#define		bCCKFalseAlarmRead        		0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       		0x80000000
+#define		bCCKRxReport_MFOff        		0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      		0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       		0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       		0x4000
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             			0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             			0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               			0x3ff
+#define		bRXIQImb_B               			0xfc00
+#define		bRXIQImb_C               			0x3f0000
+#define		bRXIQImb_D               			0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              			0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              			0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              			0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     		0xe00
+#define		bFrame_Weight_Short      		0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              			0x10000
+#define		bTXIQImb_A               			0x3ff
+#define		bTXIQImb_B               			0xfc00
+#define		bTXIQImb_C               			0x3f0000
+#define		bTXIQImb_D               			0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             			0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED               0x300
+#define		bRxInitialGain           0x7f
+#define		bRxAntDivEn              0x80
+#define		bRxAGCAddressForLNA      0x7f00
+#define		bRxHighPowerFlow         0x8000
+#define		bRxAGCFreezeThres        0xc0000
+#define		bRxFreezeStep_AGC1       0x300000
+#define		bRxFreezeStep_AGC2       0xc00000
+#define		bRxFreezeStep_AGC3       0x3000000
+#define		bRxFreezeStep_AGC0       0xc000000
+#define		bRxRssi_Cmp_En           0x10000000
+#define		bRxQuickAGCEn            0x20000000
+#define		bRxAGCFreezeThresMode    0x40000000
+#define		bRxOverFlowCheckType     0x80000000
+#define		bRxAGCShift              0x7f
+#define		bTRSW_Tri_Only           0x80
+#define		bPowerThres              0x300
+#define		bRxAGCEn                 0x1
+#define		bRxAGCTogetherEn         0x2
+#define		bRxAGCMin                0x4
+#define		bRxHP_Ini                0x7
+#define		bRxHP_TRLNA              0x70
+#define		bRxHP_RSSI               0x700
+#define		bRxHP_BBP1               0x7000
+#define		bRxHP_BBP2               0x70000
+#define		bRxHP_BBP3               0x700000
+#define		bRSSI_H                  0x7f0000     //the threshold for high power
+#define		bRSSI_Gen                0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW           0x7
+#define		bRxSettle_LNA            0x38
+#define		bRxSettle_RSSI           0x1c0
+#define		bRxSettle_BBP            0xe00
+#define		bRxSettle_RxHP           0x7000
+#define		bRxSettle_AntSW_RSSI     0x38000
+#define		bRxSettle_AntSW          0xc0000
+#define		bRxProcessTime_DAGC      0x300000
+#define		bRxSettle_HSSI           0x400000
+#define		bRxProcessTime_BBPPW     0x800000
+#define		bRxAntennaPowerShift     0x3000000
+#define		bRSSITableSelect         0xc000000
+#define		bRxHP_Final              0x7000000
+#define		bRxHTSettle_BBP          0x7
+#define		bRxHTSettle_HSSI         0x8
+#define		bRxHTSettle_RxHP         0x70
+#define		bRxHTSettle_BBPPW        0x80
+#define		bRxHTSettle_Idle         0x300
+#define		bRxHTSettle_Reserved     0x1c00
+#define		bRxHTRxHPEn              0x8000
+#define		bRxHTAGCFreezeThres      0x30000
+#define		bRxHTAGCTogetherEn       0x40000
+#define		bRxHTAGCMin              0x80000
+#define		bRxHTAGCEn               0x100000
+#define		bRxHTDAGCEn              0x200000
+#define		bRxHTRxHP_BBP            0x1c00000
+#define		bRxHTRxHP_Final          0xe0000000
+#define		bRxPWRatioTH             0x3
+#define		bRxPWRatioEn             0x4
+#define		bRxMFHold                0x3800
+#define		bRxPD_Delay_TH1          0x38
+#define		bRxPD_Delay_TH2          0x1c0
+#define		bRxPD_DC_COUNT_MAX       0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH           0x8000
+#define		bRxProcess_Delay         0xf0000
+#define		bRxSearchrange_GI2_Early 0x700000
+#define		bRxFrame_Guard_Counter_L 0x3800000
+#define		bRxSGI_Guard_L           0xc000000
+#define		bRxSGI_Search_L          0x30000000
+#define		bRxSGI_TH                0xc0000000
+#define		bDFSCnt0                 0xff
+#define		bDFSCnt1                 0xff00
+#define		bDFSFlag                 0xf0000
+#define		bMFWeightSum             0x300000
+#define		bMinIdxTH                0x7f000000
+#define		bDAFormat                0x40000
+#define		bTxChEmuEnable           0x01000000
+#define		bTRSWIsolation_A         0x7f
+#define		bTRSWIsolation_B         0x7f00
+#define		bTRSWIsolation_C         0x7f0000
+#define		bTRSWIsolation_D         0x7f000000
+#define		bExtLNAGain              0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn                  0x4	// Useless
+#define		bAntennaMapping          0x10
+#define		bNss                     0x20
+#define		bCFOAntSumD              0x200
+#define		bPHYCounterReset         0x8000000
+#define		bCFOReportGet            0x4000000
+#define		bOFDMContinueTx          0x10000000
+#define		bOFDMSingleCarrier       0x20000000
+#define		bOFDMSingleTone          0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect                0x100
+#define		bCFOEn                   0x10000
+#define		bCFOValue                0xfff00000
+#define		bSigTone_Re              0x3f
+#define		bSigTone_Im              0x7f00
+#define		bCounter_CCA             0xffff
+#define		bCounter_ParityFail      0xffff0000
+#define		bCounter_RateIllegal     0xffff
+#define		bCounter_CRC8Fail        0xffff0000
+#define		bCounter_MCSNoSupport    0xffff
+#define		bCounter_FastSync        0xffff
+#define		bShortCFO                0xfff
+#define		bShortCFOTLength         12   //total
+#define		bShortCFOFLength         11   //fraction
+#define		bLongCFO                 0x7ff
+#define		bLongCFOTLength          11
+#define		bLongCFOFLength          11
+#define		bTailCFO                 0x1fff
+#define		bTailCFOTLength          13
+#define		bTailCFOFLength          12
+#define		bmax_en_pwdB             0xffff
+#define		bCC_power_dB             0xffff0000
+#define		bnoise_pwdB              0xffff
+#define		bPowerMeasTLength        10
+#define		bPowerMeasFLength        3
+#define		bRx_HT_BW                0x1
+#define		bRxSC                    0x6
+#define		bRx_HT                   0x8
+#define		bNB_intf_det_on          0x1
+#define		bIntf_win_len_cfg        0x30
+#define		bNB_Intf_TH_cfg          0x1c0
+#define		bRFGain                  0x3f
+#define		bTableSel                0x40
+#define		bTRSW                    0x80
+#define		bRxSNR_A                 0xff
+#define		bRxSNR_B                 0xff00
+#define		bRxSNR_C                 0xff0000
+#define		bRxSNR_D                 0xff000000
+#define		bSNREVMTLength           8
+#define		bSNREVMFLength           1
+#define		bCSI1st                  0xff
+#define		bCSI2nd                  0xff00
+#define		bRxEVM1st                0xff0000
+#define		bRxEVM2nd                0xff000000
+#define		bSIGEVM                  0xff
+#define		bPWDB                    0xff00
+#define		bSGIEN                   0x10000
+
+#define		bSFactorQAM1             0xf	// Useless
+#define		bSFactorQAM2             0xf0
+#define		bSFactorQAM3             0xf00
+#define		bSFactorQAM4             0xf000
+#define		bSFactorQAM5             0xf0000
+#define		bSFactorQAM6             0xf0000
+#define		bSFactorQAM7             0xf00000
+#define		bSFactorQAM8             0xf000000
+#define		bSFactorQAM9             0xf0000000
+#define		bCSIScheme               0x100000
+
+#define		bNoiseLvlTopSet          0x3	// Useless
+#define		bChSmooth                0x4
+#define		bChSmoothCfg1            0x38
+#define		bChSmoothCfg2            0x1c0
+#define		bChSmoothCfg3            0xe00
+#define		bChSmoothCfg4            0x7000
+#define		bMRCMode                 0x800000
+#define		bTHEVMCfg                0x7000000
+
+#define		bLoopFitType             0x1	// Useless
+#define		bUpdCFO                  0x40
+#define		bUpdCFOOffData           0x80
+#define		bAdvUpdCFO               0x100
+#define		bAdvTimeCtrl             0x800
+#define		bUpdClko                 0x1000
+#define		bFC                      0x6000
+#define		bTrackingMode            0x8000
+#define		bPhCmpEnable             0x10000
+#define		bUpdClkoLTF              0x20000
+#define		bComChCFO                0x40000
+#define		bCSIEstiMode             0x80000
+#define		bAdvUpdEqz               0x100000
+#define		bUChCfg                  0x7000000
+#define		bUpdEqz                  0x8000000
+
+#define		bTxAGCRate18_06			0x7f7f7f7f	// Useless
+#define		bTxAGCRate54_24			0x7f7f7f7f
+#define		bTxAGCRateMCS32			0x7f
+#define		bTxAGCRateCCK			0x7f00
+#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
+#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
+#define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn         0x20000000	// Useless
+#define		bRxPesudoNoise_A         0xff
+#define		bRxPesudoNoise_B         0xff00
+#define		bRxPesudoNoise_C         0xff0000
+#define		bRxPesudoNoise_D         0xff000000
+#define		bPesudoNoiseState_A      0xffff
+#define		bPesudoNoiseState_B      0xffff0000
+#define		bPesudoNoiseState_C      0xffff
+#define		bPesudoNoiseState_D      0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable        0x8		// Useless
+#define		bZebra1_TRxControl        0xc00
+#define		bZebra1_TRxGainSetting    0x07f
+#define		bZebra1_RxCorner          0xc00
+#define		bZebra1_TxChargePump      0x38
+#define		bZebra1_RxChargePump      0x7
+#define		bZebra1_ChannelNum        0xf80
+#define		bZebra1_TxLPFBW           0x400
+#define		bZebra1_RxLPFBW           0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1      0x100	// Useless
+#define		bRTL8256RegModeCtrl0      0x40
+#define		bRTL8256_TxLPFBW          0x18
+#define		bRTL8256_RxLPFBW          0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW          0xc	// Useless
+#define		bRTL8258_RxLPFBW          0xc00
+#define		bRTL8258_RSSILPFBW        0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0                    0x1	// Useless
+#define		bByte1                    0x2
+#define		bByte2                    0x4
+#define		bByte3                    0x8
+#define		bWord0                    0x3
+#define		bWord1                    0xc
+#define		bDWord                    0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1		0xff00
+#define		bMaskByte2		0xff0000
+#define		bMaskByte3		0xff000000
+#define		bMaskHWord	0xffff0000
+#define		bMaskLWord		0x0000ffff
+#define		bMaskDWord	0xffffffff
+#define		bMaskH4Bits		0xf0000000
+#define		bMaskH3Bytes	0xffffff00
+#define 		bMaskOFDM_D	0xffc00000
+#define		bMaskCCK		0x3f3f3f3f
+#define		bMask12Bits		0xfff
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+#if (RTL92SE_FPGA_VERIFY == 1)
+//#define		bMask12Bits               0xfff	// RF Reg mask bits
+//#define		bMask20Bits               0xfff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfff
+#else
+//#define		bMask12Bits               0xfffff	// RF Reg mask bits
+//#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfffff
+#endif
+#define		bEnable                   0x1	// Useless
+#define		bDisable                  0x0
+
+#define		LeftAntenna               0x0	// Useless
+#define		RightAntenna              0x1
+
+#define		tCheckTxStatus            500   //500ms // Useless
+#define		tUpdateRxCounter          100   //100ms
+
+#define		rateCCK     0	// Useless
+#define		rateOFDM    1
+#define		rateHT      2
+
+//define Register-End
+#define		bPMAC_End                 0x1ff	// Useless
+#define		bFPGAPHY0_End             0x8ff
+#define		bFPGAPHY1_End             0x9ff
+#define		bCCKPHY0_End              0xaff
+#define		bOFDMPHY0_End             0xcff
+#define		bOFDMPHY1_End             0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl	0x0		// Useless
+#define		bWMACControl	0x1
+#define		bWNICControl	0x2
+
+#if 0
+#define		ANTENNA_A	0x1	// Useless
+#define		ANTENNA_B	0x2
+#define		ANTENNA_AB	0x3	// ANTENNA_A|ANTENNA_B
+
+#define		ANTENNA_C	0x4
+#define		ANTENNA_D	0x8
+#endif
+
+#define RCR_AAP			BIT(0)				// accept all physical address
+#define RCR_APM			BIT(1)				// accept physical match
+#define RCR_AM			BIT(2)				// accept multicast
+#define RCR_AB			BIT(3)				// accept broadcast
+#define RCR_ACRC32		BIT(5)				// accept error packet
+#define RCR_9356SEL		BIT(6)
+#define RCR_AICV		BIT(9)				// Accept ICV error packet
+#define RCR_RXFTH0		(BIT(13)|BIT(14)|BIT(15))	// Rx FIFO threshold
+#define RCR_ADF			BIT(18)				// Accept Data(frame type) frame
+#define RCR_ACF			BIT(19)				// Accept control frame
+#define RCR_AMF			BIT(20)				// Accept management frame
+#define RCR_ADD3		BIT(21)
+#define RCR_APWRMGT		BIT(22)				// Accept power management packet
+#define RCR_CBSSID		BIT(23)				// Accept BSSID match packet
+#define RCR_ENMARP		BIT(28)				// enable mac auto reset phy
+#define RCR_EnCS1		BIT(29)				// enable carrier sense method 1
+#define RCR_EnCS2		BIT(30)				// enable carrier sense method 2
+#define RCR_OnlyErlPkt		BIT(31)				// Rx Early mode is performed for packet size greater than 1536
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	//__INC_HAL8192SPHYREG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_odm.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_odm.h
new file mode 100644
index 000000000..8375fe14a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_odm.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_ODM_H__
+#define __RTW_ODM_H__
+
+#include <drv_types.h>
+#include "../hal/phydm/phydm_types.h"
+/*
+* This file provides utilities/wrappers for rtw driver to use ODM
+*/
+
+void rtw_odm_dbg_comp_msg(void *sel,_adapter *adapter);
+void rtw_odm_dbg_comp_set(_adapter *adapter, u64 comps);
+void rtw_odm_dbg_level_msg(void *sel,_adapter *adapter);
+void rtw_odm_dbg_level_set(_adapter *adapter, u32 level);
+
+void rtw_odm_ability_msg(void *sel, _adapter *adapter);
+void rtw_odm_ability_set(_adapter *adapter, u32 ability);
+
+void rtw_odm_init_ic_type(_adapter *adapter);
+
+void rtw_odm_adaptivity_config_msg(void *sel, _adapter *adapter);
+
+bool rtw_odm_adaptivity_needed(_adapter *adapter);
+void rtw_odm_adaptivity_parm_msg(void *sel,_adapter *adapter);
+void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff, s8 TH_L2H_ini_mode2, s8 TH_EDCCA_HL_diff_mode2, u8 EDCCA_enable);
+void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter);
+void rtw_odm_acquirespinlock(_adapter *adapter,	RT_SPINLOCK_TYPE type);
+void rtw_odm_releasespinlock(_adapter *adapter,	RT_SPINLOCK_TYPE type);
+
+#ifdef CONFIG_DFS_MASTER
+VOID rtw_odm_radar_detect_reset(_adapter *adapter);
+VOID rtw_odm_radar_detect_disable(_adapter *adapter);
+VOID rtw_odm_radar_detect_enable(_adapter *adapter);
+BOOLEAN rtw_odm_radar_detect(_adapter *adapter);
+#endif /* CONFIG_DFS_MASTER */
+#endif // __RTW_ODM_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_p2p.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_p2p.h
new file mode 100644
index 000000000..b375ce818
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_p2p.h
@@ -0,0 +1,179 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_P2P_H_
+#define __RTW_P2P_H_
+
+
+u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr );
+u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
+u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+#ifdef CONFIG_WFD
+int rtw_init_wifi_display_info(_adapter *padapter);
+void rtw_wfd_enable(_adapter *adapter, bool on);
+void rtw_wfd_set_ctrl_port(_adapter *adapter, u16 port);
+void rtw_tdls_wfd_enable(_adapter *adapter, bool on);
+
+u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled);
+u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+
+u32 rtw_append_beacon_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_probe_req_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_probe_resp_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_assoc_req_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_assoc_resp_wfd_ie(_adapter *adapter, u8 *pbuf);
+#endif /*CONFIG_WFD */
+
+void rtw_xframe_chk_wfd_ie(struct xmit_frame *xframe);
+
+u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
+u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len);
+u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe);
+u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe, uint len );
+u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pframe, uint len );
+u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pframe, uint len );
+u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+int process_p2p_cross_connect_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
+
+void p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType);
+
+#ifdef CONFIG_P2P_PS
+void	process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
+void	p2p_ps_wk_hdl(_adapter *padapter, u8 p2p_ps_state);
+u8	p2p_ps_wk_cmd(_adapter*padapter, u8 p2p_ps_state, u8 enqueue);
+#endif // CONFIG_P2P_PS
+
+#ifdef CONFIG_IOCTL_CFG80211
+void rtw_init_cfg80211_wifidirect_info( _adapter*	padapter);
+int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx);
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+void reset_global_wifidirect_info( _adapter* padapter );
+void rtw_init_wifidirect_timers(_adapter* padapter);
+void rtw_init_wifidirect_addrs(_adapter* padapter, u8 *dev_addr, u8 *iface_addr);
+void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role);
+int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role);
+
+static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	if(wdinfo->p2p_state != state) {
+		//wdinfo->pre_p2p_state = wdinfo->p2p_state;
+		wdinfo->p2p_state = state;
+	}
+}
+static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	if(wdinfo->pre_p2p_state != state) {
+		wdinfo->pre_p2p_state = state;
+	}
+}
+#if 0
+static inline void _rtw_p2p_restore_state(struct wifidirect_info *wdinfo)
+{
+	if(wdinfo->pre_p2p_state != -1) {
+		wdinfo->p2p_state = wdinfo->pre_p2p_state;
+		wdinfo->pre_p2p_state = -1;
+	}
+}
+#endif
+static inline void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+{
+	if(wdinfo->role != role) {
+		wdinfo->role = role;
+	}
+}
+static inline int _rtw_p2p_state(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->p2p_state;
+}
+static inline int _rtw_p2p_pre_state(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->pre_p2p_state;
+}
+static inline int _rtw_p2p_role(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->role;
+}
+static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	return wdinfo->p2p_state == state;
+}
+static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+{
+	return wdinfo->role == role;
+}
+
+#ifdef CONFIG_DBG_P2P
+void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
+void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
+//void dbg_rtw_p2p_restore_state(struct wifidirect_info *wdinfo, const char *caller, int line);
+void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line);
+#define rtw_p2p_set_state(wdinfo, state) dbg_rtw_p2p_set_state(wdinfo, state, __FUNCTION__, __LINE__)
+#define rtw_p2p_set_pre_state(wdinfo, state) dbg_rtw_p2p_set_pre_state(wdinfo, state, __FUNCTION__, __LINE__)
+#define rtw_p2p_set_role(wdinfo, role) dbg_rtw_p2p_set_role(wdinfo, role, __FUNCTION__, __LINE__)
+//#define rtw_p2p_restore_state(wdinfo) dbg_rtw_p2p_restore_state(wdinfo, __FUNCTION__, __LINE__)
+#else //CONFIG_DBG_P2P
+#define rtw_p2p_set_state(wdinfo, state) _rtw_p2p_set_state(wdinfo, state)
+#define rtw_p2p_set_pre_state(wdinfo, state) _rtw_p2p_set_pre_state(wdinfo, state)
+#define rtw_p2p_set_role(wdinfo, role) _rtw_p2p_set_role(wdinfo, role)
+//#define rtw_p2p_restore_state(wdinfo) _rtw_p2p_restore_state(wdinfo)
+#endif //CONFIG_DBG_P2P
+
+#define rtw_p2p_state(wdinfo) _rtw_p2p_state(wdinfo)
+#define rtw_p2p_pre_state(wdinfo) _rtw_p2p_pre_state(wdinfo)
+#define rtw_p2p_role(wdinfo) _rtw_p2p_role(wdinfo)
+#define rtw_p2p_chk_state(wdinfo, state) _rtw_p2p_chk_state(wdinfo, state)
+#define rtw_p2p_chk_role(wdinfo, role) _rtw_p2p_chk_role(wdinfo, role)
+
+#define rtw_p2p_findphase_ex_set(wdinfo, value) \
+	(wdinfo)->find_phase_state_exchange_cnt = (value)
+
+#ifdef CONFIG_P2P
+//is this find phase exchange for social channel scan?
+#define rtw_p2p_findphase_ex_is_social(wdinfo)   \
+	(wdinfo)->find_phase_state_exchange_cnt >= P2P_FINDPHASE_EX_SOCIAL_FIRST
+
+//should we need find phase exchange anymore?
+#define rtw_p2p_findphase_ex_is_needed(wdinfo) \
+	((wdinfo)->find_phase_state_exchange_cnt < P2P_FINDPHASE_EX_MAX && \
+	(wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE && \
+	!(wdinfo)->rx_invitereq_info.scan_op_ch_only && \
+	!(wdinfo)->p2p_info.scan_op_ch_only)
+#else
+#define rtw_p2p_findphase_ex_is_social(wdinfo) 0
+#define rtw_p2p_findphase_ex_is_needed(wdinfo) 0
+#endif /* CONFIG_P2P */
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_pwrctrl.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_pwrctrl.h
new file mode 100644
index 000000000..0299eafd7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_pwrctrl.h
@@ -0,0 +1,515 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_PWRCTRL_H_
+#define __RTW_PWRCTRL_H_
+
+
+#define FW_PWR0	0
+#define FW_PWR1 	1
+#define FW_PWR2 	2
+#define FW_PWR3 	3
+
+
+#define HW_PWR0	7
+#define HW_PWR1 	6
+#define HW_PWR2 	2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+#ifdef CONFIG_BT_COEXIST
+#define BTCOEX_ALIVE	BIT(4)
+#endif // CONFIG_BT_COEXIST
+
+#ifdef CONFIG_WOWLAN
+#define MAX_WKFM_NUM 16	/* Frame Mask Cam number for pattern match */
+#define MAX_WKFM_SIZE	16 /* (16 bytes for WKFM bit mask, 16*8 = 128 bits) */
+#define MAX_WKFM_PATTERN_SIZE	128
+#define WKFMCAM_ADDR_NUM 6
+#define WKFMCAM_SIZE 24 /* each entry need 6*4 bytes */
+enum pattern_type {
+	PATTERN_BROADCAST = 0,
+	PATTERN_MULTICAST,
+	PATTERN_UNICAST,
+	PATTERN_VALID,
+	PATTERN_INVALID,
+};
+
+typedef struct rtl_priv_pattern {
+	int len;
+	char content[MAX_WKFM_PATTERN_SIZE];
+	char mask[MAX_WKFM_SIZE];
+} rtl_priv_pattern_t;
+
+struct rtl_wow_pattern {
+	u16	crc;
+	u8	type;
+	u32	mask[4];
+};
+#endif /* CONFIG_WOWLAN */
+
+enum Power_Mgnt
+{
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,	//PS_MODE_SELF_DEFINED
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM,
+};
+
+#ifdef CONFIG_PNO_SUPPORT
+#define MAX_PNO_LIST_COUNT 16
+#define MAX_SCAN_LIST_COUNT 14	//2.4G only
+#define MAX_HIDDEN_AP 8		//8 hidden AP
+#endif
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define PS_DPS				BIT(0)
+#define PS_LCLK				(PS_DPS)
+#define PS_RF_OFF			BIT(1)
+#define PS_ALL_ON			BIT(2)
+#define PS_ST_ACTIVE		BIT(3)
+
+#define PS_ISR_ENABLE		BIT(4)
+#define PS_IMR_ENABLE		BIT(5)
+#define PS_ACK				BIT(6)
+#define PS_TOGGLE			BIT(7)
+
+#define PS_STATE_MASK		(0x0F)
+#define PS_STATE_HW_MASK	(0x07)
+#define PS_SEQ_MASK			(0xc0)
+
+#define PS_STATE(x)		(PS_STATE_MASK & (x))
+#define PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define PS_SEQ(x)		(PS_SEQ_MASK & (x))
+
+#define PS_STATE_S0		(PS_DPS)
+#define PS_STATE_S1		(PS_LCLK)
+#define PS_STATE_S2		(PS_RF_OFF)
+#define PS_STATE_S3		(PS_ALL_ON)
+#define PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define PS_IS_RF_ON(x)	((x) & (PS_ALL_ON))
+#define PS_IS_ACTIVE(x)	((x) & (PS_ST_ACTIVE))
+#define CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; //the CPWM value
+	unsigned short rsvd;
+};
+
+
+typedef _sema _pwrlock;
+
+
+__inline static void _init_pwrlock(_pwrlock *plock)
+{
+	_rtw_init_sema(plock, 1);
+}
+
+__inline static void _free_pwrlock(_pwrlock *plock)
+{
+	_rtw_free_sema(plock);
+}
+
+
+__inline static void _enter_pwrlock(_pwrlock *plock)
+{
+	_rtw_down_sema(plock);
+}
+
+
+__inline static void _exit_pwrlock(_pwrlock *plock)
+{
+	_rtw_up_sema(plock);
+}
+
+#define LPS_DELAY_TIME	1*HZ // 1 sec
+
+#define EXE_PWR_NONE	0x01
+#define EXE_PWR_IPS		0x02
+#define EXE_PWR_LPS		0x04
+
+// RF state.
+typedef enum _rt_rf_power_state
+{
+	rf_on,		// RF is on after RFSleep or RFOff
+	rf_sleep,	// 802.11 Power Save mode
+	rf_off,		// HW/SW Radio OFF or Inactive Power Save
+	//=====Add the new RF state above this line=====//
+	rf_max
+}rt_rf_power_state;
+
+// RF Off Level for IPS or HW/SW radio off
+#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	// PCI ASPM
+#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	// PCI clock request
+#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	// PCI D3 mode
+#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	// NIC halt, re-initialize hw parameters
+#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	// FW free, re-download the FW
+#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	// FW in 32k
+#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	// Always enable ASPM and Clock Req in initialization.
+#define	RT_RF_LPS_DISALBE_2R			BIT(30)	// When LPS is on, disable 2R if no packet is received or transmittd.
+#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	// LPS with ASPM
+
+#define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? _TRUE : _FALSE)
+#define	RT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)	(ppsc->cur_ps_level &= (~(_PS_FLAG)))
+#define	RT_SET_PS_LEVEL(ppsc, _PS_FLAG)		(ppsc->cur_ps_level |= _PS_FLAG)
+
+// ASPM OSC Control bit, added by Roger, 2013.03.29.
+#define	RT_PCI_ASPM_OSC_IGNORE		0	 // PCI ASPM ignore OSC control in default
+#define	RT_PCI_ASPM_OSC_ENABLE		BIT0 // PCI ASPM controlled by OS according to ACPI Spec 5.0
+#define	RT_PCI_ASPM_OSC_DISABLE		BIT1 // PCI ASPM controlled by driver or BIOS, i.e., force enable ASPM
+
+
+enum _PS_BBRegBackup_ {
+	PSBBREG_RF0 = 0,
+	PSBBREG_RF1,
+	PSBBREG_RF2,
+	PSBBREG_AFE0,
+	PSBBREG_TOTALCNT
+};
+
+enum { // for ips_mode
+	IPS_NONE=0,
+	IPS_NORMAL,
+	IPS_LEVEL_2,
+	IPS_NUM
+};
+
+// Design for pwrctrl_priv.ips_deny, 32 bits for 32 reasons at most
+typedef enum _PS_DENY_REASON
+{
+	PS_DENY_DRV_INITIAL = 0,
+	PS_DENY_SCAN,
+	PS_DENY_JOIN,
+	PS_DENY_DISCONNECT,
+	PS_DENY_SUSPEND,
+	PS_DENY_IOCTL,
+	PS_DENY_MGNT_TX,
+	PS_DENY_DRV_REMOVE = 30,
+	PS_DENY_OTHERS = 31
+} PS_DENY_REASON;
+
+#ifdef CONFIG_PNO_SUPPORT
+typedef struct pno_nlo_info
+{
+	u32 fast_scan_period;				//Fast scan period
+	u8	ssid_num;				//number of entry
+	u8	hidden_ssid_num;
+	u32	slow_scan_period;			//slow scan period
+	u32	fast_scan_iterations;			//Fast scan iterations
+	u8	ssid_length[MAX_PNO_LIST_COUNT];	//SSID Length Array
+	u8	ssid_cipher_info[MAX_PNO_LIST_COUNT];	//Cipher information for security
+	u8	ssid_channel_info[MAX_PNO_LIST_COUNT];	//channel information
+	u8	loc_probe_req[MAX_HIDDEN_AP];		//loc_probeReq
+}pno_nlo_info_t;
+
+typedef struct pno_ssid {
+	u32		SSID_len;
+	u8		SSID[32];
+} pno_ssid_t;
+
+typedef struct pno_ssid_list {
+	pno_ssid_t	node[MAX_PNO_LIST_COUNT];
+}pno_ssid_list_t;
+
+typedef struct pno_scan_channel_info
+{
+	u8	channel;
+	u8	tx_power;
+	u8	timeout;
+	u8	active;				//set 1 means active scan, or pasivite scan.
+}pno_scan_channel_info_t;
+
+typedef struct pno_scan_info
+{
+	u8	enableRFE;			//Enable RFE
+	u8	period_scan_time;		//exclusive with fast_scan_period and slow_scan_period
+	u8	periodScan;			//exclusive with fast_scan_period and slow_scan_period
+	u8	orig_80_offset;			//original channel 80 offset
+	u8	orig_40_offset;			//original channel 40 offset
+	u8	orig_bw;			//original bandwidth
+	u8	orig_ch;			//original channel
+	u8	channel_num;			//number of channel
+	u64	rfe_type;			//rfe_type && 0x00000000000000ff
+	pno_scan_channel_info_t ssid_channel_info[MAX_SCAN_LIST_COUNT];
+}pno_scan_info_t;
+#endif //CONFIG_PNO_SUPPORT
+
+struct pwrctrl_priv
+{
+	_pwrlock	lock;
+	_pwrlock	check_32k_lock;
+	volatile u8 rpwm; // requested power state for fw
+	volatile u8 cpwm; // fw current power state. updated when 1. read from HCPWM 2. driver lowers power level
+	volatile u8 tog; // toggling
+	volatile u8 cpwm_tog; // toggling
+
+	u8	pwr_mode;
+	u8	smart_ps;
+	u8	bcn_ant_mode;
+	u8 	dtim;
+
+	u32	alives;
+	_workitem cpwm_event;
+#ifdef CONFIG_LPS_RPWM_TIMER
+	u8 brpwmtimeout;
+	_workitem rpwmtimeoutwi;
+	_timer pwr_rpwm_timer;
+#endif // CONFIG_LPS_RPWM_TIMER
+	u8	bpower_saving; //for LPS/IPS
+
+	u8	b_hw_radio_off;
+	u8	reg_rfoff;
+	u8	reg_pdnmode; //powerdown mode
+	u32	rfoff_reason;
+
+	//RF OFF Level
+	u32	cur_ps_level;
+	u32	reg_rfps_level;
+
+	uint 	ips_enter_cnts;
+	uint 	ips_leave_cnts;
+	uint 	lps_enter_cnts;
+	uint 	lps_leave_cnts;
+
+	u8	ips_mode;
+	u8	ips_org_mode;
+	u8	ips_mode_req; // used to accept the mode setting request, will update to ipsmode later
+	uint bips_processing;
+	u32 ips_deny_time; /* will deny IPS when system time is smaller than this */
+	u8 pre_ips_type;// 0: default flow, 1: carddisbale flow
+
+	// ps_deny: if 0, power save is free to go; otherwise deny all kinds of power save.
+	// Use PS_DENY_REASON to decide reason.
+	// Don't access this variable directly without control function,
+	// and this variable should be protected by lock.
+	u32 ps_deny;
+
+	u8 ps_processing; /* temporarily used to mark whether in rtw_ps_processor */
+
+	u8 fw_psmode_iface_id;
+	u8	bLeisurePs;
+	u8	LpsIdleCount;
+	u8	power_mgnt;
+	u8	org_power_mgnt;
+	u8	bFwCurrentInPSMode;
+	u32	DelayLPSLastTimeStamp;
+	s32		pnp_current_pwr_state;
+	u8		pnp_bstop_trx;
+
+
+	u8		bInternalAutoSuspend;
+	u8		bInSuspend;
+#ifdef	CONFIG_BT_COEXIST
+	u8		bAutoResume;
+	u8		autopm_cnt;
+#endif
+	u8		bSupportRemoteWakeup;
+	u8		wowlan_wake_reason;
+	u8		wowlan_ap_mode;
+	u8		wowlan_mode;
+	u8		wowlan_p2p_mode;
+	u8		wowlan_pno_enable;
+#ifdef CONFIG_GPIO_WAKEUP
+	u8		is_high_active;
+#endif /* CONFIG_GPIO_WAKEUP */
+#ifdef CONFIG_WOWLAN
+	u8		wowlan_txpause_status;
+	u8		wowlan_pattern;
+	u8		wowlan_pattern_idx;
+	u64		wowlan_fw_iv;
+	struct rtl_priv_pattern	patterns[MAX_WKFM_NUM];
+#ifdef CONFIG_PNO_SUPPORT
+	u8		pno_in_resume;
+	u8		pno_inited;
+	pno_nlo_info_t	*pnlo_info;
+	pno_scan_info_t	*pscan_info;
+	pno_ssid_list_t	*pno_ssid_list;
+#endif /* CONFIG_PNO_SUPPORT */
+#endif /* CONFIG_WOWLAN */
+	_timer 	pwr_state_check_timer;
+	_adapter *adapter;
+	int		pwr_state_check_interval;
+	u8		pwr_state_check_cnts;
+
+	int 		ps_flag; /* used by autosuspend */
+
+	rt_rf_power_state	rf_pwrstate;//cur power state, only for IPS
+	//rt_rf_power_state 	current_rfpwrstate;
+	rt_rf_power_state	change_rfpwrstate;
+
+	u8		bHWPowerdown; /* power down mode selection. 0:radio off, 1:power down */
+	u8		bHWPwrPindetect; /* come from registrypriv.hwpwrp_detect. enable power down function. 0:disable, 1:enable */
+	u8		bkeepfwalive;
+	u8		brfoffbyhw;
+	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];
+
+	#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	struct workqueue_struct *rtw_workqueue;
+	_workitem resume_work;
+	#endif
+
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+	u8 do_late_resume;
+	#endif //CONFIG_HAS_EARLYSUSPEND
+
+	#ifdef CONFIG_ANDROID_POWER
+	android_early_suspend_t early_suspend;
+	u8 do_late_resume;
+	#endif
+
+	#ifdef CONFIG_INTEL_PROXIM
+	u8	stored_power_mgnt;
+	#endif
+};
+
+#define rtw_get_ips_mode_req(pwrctl) \
+	(pwrctl)->ips_mode_req
+
+#define rtw_ips_mode_req(pwrctl, ips_mode) \
+	(pwrctl)->ips_mode_req = (ips_mode)
+
+#define RTW_PWR_STATE_CHK_INTERVAL 2000
+
+#define _rtw_set_pwr_state_check_timer(pwrctl, ms) \
+	do { \
+		/*DBG_871X("%s _rtw_set_pwr_state_check_timer(%p, %d)\n", __FUNCTION__, (pwrctl), (ms));*/ \
+		_set_timer(&(pwrctl)->pwr_state_check_timer, (ms)); \
+	} while(0)
+
+#define rtw_set_pwr_state_check_timer(pwrctl) \
+	_rtw_set_pwr_state_check_timer((pwrctl), (pwrctl)->pwr_state_check_interval)
+
+extern void rtw_init_pwrctrl_priv(_adapter *adapter);
+extern void rtw_free_pwrctrl_priv(_adapter * adapter);
+
+#ifdef CONFIG_LPS_LCLK
+s32 rtw_register_task_alive(PADAPTER, u32 task);
+void rtw_unregister_task_alive(PADAPTER, u32 task);
+extern s32 rtw_register_tx_alive(PADAPTER padapter);
+extern void rtw_unregister_tx_alive(PADAPTER padapter);
+extern s32 rtw_register_rx_alive(PADAPTER padapter);
+extern void rtw_unregister_rx_alive(PADAPTER padapter);
+extern s32 rtw_register_cmd_alive(PADAPTER padapter);
+extern void rtw_unregister_cmd_alive(PADAPTER padapter);
+extern s32 rtw_register_evt_alive(PADAPTER padapter);
+extern void rtw_unregister_evt_alive(PADAPTER padapter);
+extern void cpwm_int_hdl(PADAPTER padapter, struct reportpwrstate_parm *preportpwrstate);
+extern void LPS_Leave_check(PADAPTER padapter);
+#endif
+
+extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
+extern void LeaveAllPowerSaveModeDirect(PADAPTER Adapter);
+#ifdef CONFIG_IPS
+void _ips_enter(_adapter * padapter);
+void ips_enter(_adapter * padapter);
+int _ips_leave(_adapter * padapter);
+int ips_leave(_adapter * padapter);
+#endif
+
+void rtw_ps_processor(_adapter*padapter);
+
+#ifdef CONFIG_AUTOSUSPEND
+int autoresume_enter(_adapter* padapter);
+#endif
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter );
+#endif
+
+
+int rtw_fw_ps_state(PADAPTER padapter);
+
+#ifdef CONFIG_LPS
+s32 LPS_RF_ON_check(PADAPTER padapter, u32 delay_ms);
+void LPS_Enter(PADAPTER padapter, const char *msg);
+void LPS_Leave(PADAPTER padapter, const char *msg);
+void traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets);
+void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);
+void rtw_set_fw_in_ips_mode(PADAPTER padapter, u8 enable);
+void rtw_set_rpwm(_adapter * padapter, u8 val8);
+#endif
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv);
+#endif //CONFIG_RESUME_IN_WORKQUEUE
+
+#if defined(CONFIG_HAS_EARLYSUSPEND ) || defined(CONFIG_ANDROID_POWER)
+bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv);
+bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv);
+void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable);
+void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv);
+void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv);
+#else
+#define rtw_is_earlysuspend_registered(pwrpriv) _FALSE
+#define rtw_is_do_late_resume(pwrpriv) _FALSE
+#define rtw_set_do_late_resume(pwrpriv, enable) do {} while (0)
+#define rtw_register_early_suspend(pwrpriv) do {} while (0)
+#define rtw_unregister_early_suspend(pwrpriv) do {} while (0)
+#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
+
+u8 rtw_interface_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id,u8* val);
+void rtw_set_ips_deny(_adapter *padapter, u32 ms);
+int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller);
+#define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __FUNCTION__)
+#define rtw_pwr_wakeup_ex(adapter, ips_deffer_ms) _rtw_pwr_wakeup(adapter, ips_deffer_ms, __FUNCTION__)
+int rtw_pm_set_ips(_adapter *padapter, u8 mode);
+int rtw_pm_set_lps(_adapter *padapter, u8 mode);
+
+void rtw_ps_deny(PADAPTER padapter, PS_DENY_REASON reason);
+void rtw_ps_deny_cancel(PADAPTER padapter, PS_DENY_REASON reason);
+u32 rtw_ps_deny_get(PADAPTER padapter);
+
+#if defined(CONFIG_WOWLAN)
+void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
+void rtw_get_sec_iv(PADAPTER padapter, u8 *pcur_dot11txpn, u8 *StaAddr);
+void rtw_set_sec_pn(_adapter *padapter);
+bool rtw_check_pattern_valid(u8 *input, u8 len);
+bool rtw_write_to_frame_mask(_adapter *adapter, u8 idx,
+		struct rtl_wow_pattern *content);
+
+bool rtw_read_from_frame_mask(_adapter *adapter, u8 idx);
+void rtw_dump_priv_pattern(_adapter *adapter, u8 idx);
+void rtw_clean_pattern(_adapter *adapter);
+#endif /* CONFIG_WOWLAN */
+#endif  //__RTL871X_PWRCTRL_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_qos.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_qos.h
new file mode 100644
index 000000000..3c689707b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_qos.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef _RTW_QOS_H_
+#define _RTW_QOS_H_
+
+
+
+struct	qos_priv	{
+
+	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...
+
+};
+
+
+#endif	//_RTL871X_QOS_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_recv.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_recv.h
new file mode 100644
index 000000000..3c5d4f784
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_recv.h
@@ -0,0 +1,879 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_RECV_H_
+#define _RTW_RECV_H_
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF 1024//512//128
+	#else
+		#define NR_RECVBUFF (16)
+	#endif
+#elif defined(PLATFORM_OS_CE)
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF (128)
+	#else
+		#define NR_RECVBUFF (4)
+	#endif
+#else //PLATFORM_LINUX /PLATFORM_BSD
+
+	#ifdef CONFIG_SINGLE_RECV_BUF
+		#define NR_RECVBUFF (1)
+	#else
+		#if defined(CONFIG_GSPI_HCI)
+			#define NR_RECVBUFF (32)
+		#elif defined(CONFIG_SDIO_HCI)
+			#define NR_RECVBUFF (8)
+		#else
+			#define NR_RECVBUFF (8)
+		#endif
+	#endif //CONFIG_SINGLE_RECV_BUF
+	#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+		#define NR_PREALLOC_RECV_SKB (rtw_rtkm_get_nr_recv_skb()>>1)
+	#else /*!CONFIG_PREALLOC_RX_SKB_BUFFER */
+		#define NR_PREALLOC_RECV_SKB 8
+	#endif /* CONFIG_PREALLOC_RX_SKB_BUFFER */
+
+#endif
+
+#define NR_RECVFRAME 256
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
+
+#define DRVINFO_SZ	4 // unit is 8bytes
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+#define MAX_CONTINUAL_NORXPACKET_COUNT 1    /*  In MAX_CONTINUAL_NORXPACKET_COUNT*2 sec  , no rx traffict would issue DELBA*/
+
+#define PHY_RSSI_SLID_WIN_MAX				100
+#define PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define RX_MPDU_QUEUE				0
+#define RX_CMD_QUEUE				1
+#define RX_MAX_QUEUE				2
+
+static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+static u8 SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
+static u8 SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; // Datagram Delivery Protocol
+
+static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
+static u8 oui_rfc1042[]= {0x00,0x00,0x00};
+
+#define MAX_SUBFRAME_COUNT	64
+static u8 rtw_rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 rtw_bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+
+//for Rx reordering buffer control
+struct recv_reorder_ctrl
+{
+	_adapter	*padapter;
+	u8 enable;
+	u16 indicate_seq;//=wstart_b, init_value=0xffff
+	u16 wend_b;
+	u8 wsize_b;
+	u8 ampdu_size;
+	_queue pending_recvframe_queue;
+	_timer reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16 	tid_rxseq[16];
+/*
+	unsigned short 	tid0_rxseq;
+	unsigned short 	tid1_rxseq;
+	unsigned short 	tid2_rxseq;
+	unsigned short 	tid3_rxseq;
+	unsigned short 	tid4_rxseq;
+	unsigned short 	tid5_rxseq;
+	unsigned short 	tid6_rxseq;
+	unsigned short 	tid7_rxseq;
+	unsigned short 	tid8_rxseq;
+	unsigned short 	tid9_rxseq;
+	unsigned short 	tid10_rxseq;
+	unsigned short 	tid11_rxseq;
+	unsigned short 	tid12_rxseq;
+	unsigned short 	tid13_rxseq;
+	unsigned short 	tid14_rxseq;
+	unsigned short 	tid15_rxseq;
+*/
+};
+
+
+struct smooth_rssi_data {
+	u32	elements[100];	//array to store values
+	u32	index;			//index to current array to store
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+
+struct signal_stat {
+	u8	update_req;		//used to indicate
+	u8	avg_val;		//avg of valid elements
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+/*
+typedef struct _ODM_Phy_Status_Info_
+{
+	//
+	// Be care, if you want to add any element please insert between
+	// RxPWDBAll & SignalStrength.
+	//
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN))
+	u4Byte		RxPWDBAll;
+#else
+	u1Byte		RxPWDBAll;
+#endif
+
+	u1Byte		SignalQuality;	 		// in 0-100 index.
+	s1Byte		RxMIMOSignalQuality[4];	//per-path's EVM
+	u1Byte		RxMIMOEVMdbm[4]; 		//per-path's EVM dbm
+
+	u1Byte		RxMIMOSignalStrength[4];// in 0~100 index
+
+	u2Byte		Cfo_short[4]; 			// per-path's Cfo_short
+	u2Byte		Cfo_tail[4];			// per-path's Cfo_tail
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+	s1Byte		RxPower;				// in dBm Translate from PWdB
+	s1Byte		RecvSignalPower;		// Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures.
+	u1Byte		BTRxRSSIPercentage;
+	u1Byte		SignalStrength; 		// in 0-100 index.
+
+	u1Byte		RxPwr[4];				//per-path's pwdb
+#endif
+	u1Byte		RxSNR[4];				//per-path's SNR
+	u1Byte		BandWidth;
+	u1Byte		btCoexPwrAdjust;
+}ODM_PHY_INFO_T,*PODM_PHY_INFO_T;
+*/
+
+struct phy_info
+{
+	u8			RxPWDBAll;
+	u8			SignalQuality;				/* in 0-100 index. */
+	s8			RxMIMOSignalQuality[4];		/* per-path's EVM */
+	u8			RxMIMOEVMdbm[4];			/* per-path's EVM dbm */
+	u8			RxMIMOSignalStrength[4];	/* in 0~100 index */
+	s16			Cfo_short[4];				/* per-path's Cfo_short */
+	s16			Cfo_tail[4];					/* per-path's Cfo_tail */
+	s8			RxPower;					/* in dBm Translate from PWdB */
+	s8			RecvSignalPower;			/* Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures. */
+	u8			BTRxRSSIPercentage;
+	u8			SignalStrength;				/* in 0-100 index. */
+	s8			RxPwr[4];					/* per-path's pwdb */
+	s8			RxSNR[4];
+#if (RTL8822B_SUPPORT == 1)
+	u8			RxCount:2;
+	u8			BandWidth:2;
+	u8			rxsc:4;
+#else
+	u8			BandWidth;
+#endif
+	u8			btCoexPwrAdjust;
+#if (RTL8822B_SUPPORT == 1)
+	u8			channel;						/* channel number---*/
+	BOOLEAN		bMuPacket;					/* is MU packet or not---*/
+	BOOLEAN		bBeamformed;
+#endif
+};
+
+#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
+struct rx_raw_rssi
+{
+	u8 data_rate;
+	u8 pwdball;
+	s8 pwr_all;
+
+	u8 mimo_signal_strength[4];/* in 0~100 index */
+	u8 mimo_signal_quality[4];
+
+	s8 ofdm_pwr[4];
+	u8 ofdm_snr[4];
+
+};
+#endif
+
+struct rx_pkt_attrib	{
+	u16	pkt_len;
+	u8	physt;
+	u8	drvinfo_sz;
+	u8	shift_sz;
+	u8	hdrlen; //the WLAN Header Len
+	u8 	to_fr_ds;
+	u8 	amsdu;
+	u8	qos;
+	u8	priority;
+	u8	pw_save;
+	u8	mdata;
+	u16	seq_num;
+	u8	frag_num;
+	u8	mfrag;
+	u8	order;
+	u8	privacy; //in frame_ctrl field
+	u8	bdecrypted;
+	u8	encrypt; //when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	u8	iv_len;
+	u8	icv_len;
+	u8	crc_err;
+	u8	icv_err;
+
+	u16	eth_type;
+
+	u8 	dst[ETH_ALEN];
+	u8 	src[ETH_ALEN];
+	u8 	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+	u8 	bssid[ETH_ALEN];
+
+	u8	ack_policy;
+
+//#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
+	u8	tcpchk_valid; // 0: invalid, 1: valid
+	u8	ip_chkrpt; //0: incorrect, 1: correct
+	u8	tcp_chkrpt; //0: incorrect, 1: correct
+//#endif
+	u8 	key_index;
+
+	u8	data_rate;
+	u8	bw;
+	u8	stbc;
+	u8	ldpc;
+	u8 	sgi;
+	u8 	pkt_rpt_type;
+	u32 tsfl;
+	u32	MacIDValidEntry[2];	// 64 bits present 64 entry.
+
+/*
+	u8	signal_qual;
+	s8	rx_mimo_signal_qual[2];
+	u8	signal_strength;
+	u32	RxPWDBAll;
+	s32	RecvSignalPower;
+*/
+	struct phy_info phy_info;
+};
+
+
+//These definition is used for Rx packet reordering.
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+#define SN_EQUAL(a, b)	(a == b)
+//#define REORDER_WIN_SIZE	128
+//#define REORDER_ENTRY_NUM	128
+#define REORDER_WAIT_TIME	(50) // (ms)
+
+#define RECVBUFF_ALIGN_SZ 8
+
+#if defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A)
+	#ifdef CONFIG_PCI_HCI
+		#define RXDESC_SIZE 16
+		#define RX_WIFI_INFO_SIZE	24
+	#else
+		#define RXDESC_SIZE	24
+	#endif
+#else
+#define RXDESC_SIZE	24
+#endif
+#define RXDESC_OFFSET RXDESC_SIZE
+
+struct recv_stat
+{
+	unsigned int rxdw0;
+
+	unsigned int rxdw1;
+
+#if !((defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A)) && defined(CONFIG_PCI_HCI))  /* exclude 8192ee, 8814ae */
+	unsigned int rxdw2;
+
+	unsigned int rxdw3;
+#endif
+
+#ifndef BUF_DESC_ARCH
+	unsigned int rxdw4;
+
+	unsigned int rxdw5;
+
+#ifdef CONFIG_PCI_HCI
+	unsigned int rxdw6;
+
+	unsigned int rxdw7;
+#endif
+#endif //if BUF_DESC_ARCH is defined, rx_buf_desc occupy 4 double words
+};
+
+#define EOR BIT(30)
+
+#ifdef CONFIG_PCI_HCI
+#define PCI_MAX_RX_QUEUE		1// MSDU packet queue, Rx Command Queue
+#define PCI_MAX_RX_COUNT		128
+
+struct rtw_rx_ring {
+	struct recv_stat	*desc;
+	dma_addr_t		dma;
+	unsigned int		idx;
+	struct sk_buff	*rx_buf[PCI_MAX_RX_COUNT];
+};
+#endif
+
+
+
+/*
+accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv
+{
+	_lock	lock;
+
+#ifdef CONFIG_RECV_THREAD_MODE
+	_sema	recv_sema;
+	_sema	terminate_recvthread_sema;
+#endif
+
+	//_queue	blk_strms[MAX_RX_NUMBLKS];    // keeping the block ack frame until return ack
+	_queue	free_recv_queue;
+	_queue	recv_pending_queue;
+	_queue	uc_swdec_pending_queue;
+
+
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf;
+
+	uint free_recvframe_cnt;
+
+	_adapter	*adapter;
+
+#ifdef PLATFORM_WINDOWS
+	_nic_hdl  RxPktPoolHdl;
+	_nic_hdl  RxBufPoolHdl;
+
+#ifdef PLATFORM_OS_XP
+	PMDL	pbytecnt_mdl;
+#endif
+	uint	counter; //record the number that up-layer will return to drv; only when counter==0 can we  release recv_priv
+	NDIS_EVENT 	recv_resource_evt ;
+#endif
+
+	u32	bIsAnyNonBEPkts;
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+
+#ifdef CONFIG_USB_HCI
+	//u8 *pallocated_urb_buf;
+	_sema allrxreturnevt;
+	uint	ff_hwaddr;
+	ATOMIC_T	rx_pending_cnt;
+
+#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
+#ifdef PLATFORM_LINUX
+	PURB	int_in_urb;
+#endif
+
+	u8	*int_in_buf;
+#endif //CONFIG_USB_INTERRUPT_IN_PIPE
+
+#endif
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)
+#ifdef PLATFORM_FREEBSD
+	struct task irq_prepare_beacon_tasklet;
+	struct task recv_tasklet;
+#else //PLATFORM_FREEBSD
+	struct tasklet_struct irq_prepare_beacon_tasklet;
+	struct tasklet_struct recv_tasklet;
+#endif //PLATFORM_FREEBSD
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+#ifdef CONFIG_RX_INDICATE_QUEUE
+	struct task rx_indicate_tasklet;
+	struct ifqueue rx_indicate_queue;
+#endif	// CONFIG_RX_INDICATE_QUEUE
+
+#endif //defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)
+
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    // 4 alignment
+	_queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI) || defined(CONFIG_USB_HCI)
+	_queue	recv_buf_pending_queue;
+#endif
+
+#ifdef CONFIG_PCI_HCI
+	// Rx
+	struct rtw_rx_ring	rx_ring[PCI_MAX_RX_QUEUE];
+	int 	rxringcount;
+	u16	rxbuffersize;
+#endif
+
+	//For display the phy informatiom
+	u8 is_signal_dbg;	// for debug
+	u8 signal_strength_dbg;	// for debug
+
+	u8 signal_strength;
+	u8 signal_qual;
+	s8 rssi;	//translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.SignalStrength);
+	#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
+	struct rx_raw_rssi raw_rssi_info;
+	#endif
+	//s8 rxpwdb;
+	s16 noise;
+	//int RxSNRdB[2];
+	//s8 RxRssi[2];
+	//int FalseAlmCnt_all;
+
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	_timer signal_stat_timer;
+	u32 signal_stat_sampling_interval;
+	//u32 signal_stat_converging_constant;
+	struct signal_stat signal_qual_data;
+	struct signal_stat signal_strength_data;
+#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	u16 sink_udpport,pre_rtp_rxseq,cur_rtp_rxseq;
+};
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+struct sta_recv_priv {
+
+	_lock	lock;
+	sint	option;
+
+	//_queue	blk_strms[MAX_RX_NUMBLKS];
+	_queue defrag_q;	 //keeping the fragment frame until defrag
+
+	struct	stainfo_rxcache rxcache;
+
+	//uint	sta_rx_bytes;
+	//uint	sta_rx_pkts;
+	//uint	sta_rx_fail;
+
+};
+
+
+struct recv_buf
+{
+	_list list;
+
+	_lock recvbuf_lock;
+
+	u32	ref_cnt;
+
+	PADAPTER adapter;
+
+	u8	*pbuf;
+	u8	*pallocated_buf;
+
+	u32	len;
+	u8	*phead;
+	u8	*pdata;
+	u8	*ptail;
+	u8	*pend;
+
+#ifdef CONFIG_USB_HCI
+
+	#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)||defined(PLATFORM_FREEBSD)
+	PURB	purb;
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+	u32 alloc_sz;
+	#endif
+
+	#ifdef PLATFORM_OS_XP
+	PIRP		pirp;
+	#endif
+
+	#ifdef PLATFORM_OS_CE
+	USB_TRANSFER	usb_transfer_read_port;
+	#endif
+
+	u8  irp_pending;
+	int  transfer_len;
+
+#endif
+
+#ifdef PLATFORM_LINUX
+	_pkt	*pskb;
+#endif
+#ifdef PLATFORM_FREEBSD //skb solution
+	struct sk_buff *pskb;
+#endif //PLATFORM_FREEBSD //skb solution
+};
+
+
+/*
+	head  ----->
+
+		data  ----->
+
+			payload
+
+		tail  ----->
+
+
+	end   ----->
+
+	len = (unsigned int )(tail - data);
+
+*/
+struct recv_frame_hdr
+{
+	_list	list;
+#ifndef CONFIG_BSD_RX_USE_MBUF
+	struct sk_buff	 *pkt;
+	struct sk_buff	 *pkt_newalloc;
+#else // CONFIG_BSD_RX_USE_MBUF
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+#endif // CONFIG_BSD_RX_USE_MBUF
+
+	_adapter  *adapter;
+
+	u8 fragcnt;
+
+	int frame_tag;
+
+	struct rx_pkt_attrib attrib;
+
+	uint  len;
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+
+	void *precvbuf;
+
+
+	//
+	struct sta_info *psta;
+
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl *preorder_ctrl;
+
+#ifdef CONFIG_WAPI_SUPPORT
+	u8 UserPriority;
+	u8 WapiTempPN[16];
+	u8 WapiSrcAddr[6];
+	u8 bWapiCheckPNInDecrypt;
+	u8 bIsWaiPacket;
+#endif
+
+};
+
+
+union recv_frame{
+
+	union{
+		_list list;
+		struct recv_frame_hdr hdr;
+		uint mem[RECVFRAME_HDR_ALIGN>>2];
+	}u;
+
+	//uint mem[MAX_RXSZ>>2];
+
+};
+
+bool rtw_rframe_del_wfd_ie(union recv_frame *rframe, u8 ies_offset);
+
+typedef enum _RX_PACKET_TYPE{
+	NORMAL_RX,//Normal rx packet
+	TX_REPORT1,//CCX
+	TX_REPORT2,//TX RPT
+	HIS_REPORT,// USB HISR RPT
+	C2H_PACKET
+}RX_PACKET_TYPE, *PRX_PACKET_TYPE;
+
+extern union recv_frame *_rtw_alloc_recvframe (_queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern union recv_frame *rtw_alloc_recvframe (_queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern void rtw_init_recvframe(union recv_frame *precvframe ,struct recv_priv *precvpriv);
+extern int	 rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);
+
+#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
+extern int _rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
+extern int rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
+
+extern void rtw_free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue);
+u32 rtw_free_uc_swdec_pending_queue(_adapter *adapter);
+
+sint rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, _queue *queue);
+sint rtw_enqueue_recvbuf(struct recv_buf *precvbuf, _queue *queue);
+struct recv_buf *rtw_dequeue_recvbuf (_queue *queue);
+
+void rtw_reordering_ctrl_timeout_handler(struct timer_list *t);
+
+void rx_query_phy_status(union recv_frame *rframe, u8 *phy_stat);
+int rtw_inc_and_chk_continual_no_rx_packet(struct sta_info *sta, int tid_index);
+void rtw_reset_continual_no_rx_packet(struct sta_info *sta, int tid_index);
+
+__inline static u8 *get_rxmem(union recv_frame *precvframe)
+{
+	//always return rx_head...
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_head;
+}
+
+__inline static u8 *get_rx_status(union recv_frame *precvframe)
+{
+
+	return get_rxmem(precvframe);
+
+}
+
+__inline static u8 *get_recvframe_data(union recv_frame *precvframe)
+{
+
+	//alwasy return rx_data
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_data;
+
+}
+
+__inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
+{
+	// append data before rx_data
+
+	/* add data to the start of recv_frame
+ *
+ *      This function extends the used data area of the recv_frame at the buffer
+ *      start. rx_data must be still larger than rx_head, after pushing.
+ */
+
+	if(precvframe==NULL)
+		return NULL;
+
+
+	precvframe->u.hdr.rx_data -= sz ;
+	if( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
+	{
+		precvframe->u.hdr.rx_data += sz ;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len +=sz;
+
+	return precvframe->u.hdr.rx_data;
+
+}
+
+
+__inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
+{
+	// rx_data += sz; move rx_data sz bytes  hereafter
+
+	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
+
+
+	if(precvframe==NULL)
+		return NULL;
+
+
+	precvframe->u.hdr.rx_data += sz;
+
+	if(precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail)
+	{
+		precvframe->u.hdr.rx_data -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -=sz;
+
+	return precvframe->u.hdr.rx_data;
+
+}
+
+__inline static u8 *recvframe_put(union recv_frame *precvframe, sint sz)
+{
+	// rx_tai += sz; move rx_tail sz bytes  hereafter
+
+	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
+	//after putting, rx_tail must be still larger than rx_end.
+ 	unsigned char * prev_rx_tail;
+
+	/* DBG_871X("recvframe_put: len=%d\n", sz); */
+
+	if(precvframe==NULL)
+		return NULL;
+
+	prev_rx_tail = precvframe->u.hdr.rx_tail;
+
+	precvframe->u.hdr.rx_tail += sz;
+
+	if(precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
+	{
+		precvframe->u.hdr.rx_tail -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len +=sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+__inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
+{
+	// rmv data from rx_tail (by yitsen)
+
+	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
+	//after pulling, rx_end must be still larger than rx_data.
+
+	if(precvframe==NULL)
+		return NULL;
+
+	precvframe->u.hdr.rx_tail -= sz;
+
+	if(precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data)
+	{
+		precvframe->u.hdr.rx_tail += sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -=sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+__inline static _buffer * get_rxbuf_desc(union recv_frame *precvframe)
+{
+	_buffer * buf_desc;
+
+	if(precvframe==NULL)
+		return NULL;
+#ifdef PLATFORM_WINDOWS
+	NdisQueryPacket(precvframe->u.hdr.pkt, NULL, NULL, &buf_desc, NULL);
+#endif
+
+	return buf_desc;
+}
+
+
+__inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
+{
+	//due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame
+	//from any given member of recv_frame.
+	// rxmem indicates the any member/address in recv_frame
+
+	return (union recv_frame*)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
+
+}
+
+__inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
+{
+
+	u8 * buf_star;
+	union recv_frame * precv_frame;
+#ifdef PLATFORM_WINDOWS
+	_buffer * buf_desc;
+	uint len;
+
+	NdisQueryPacket(pkt, NULL, NULL, &buf_desc, &len);
+	NdisQueryBufferSafe(buf_desc, &buf_star, &len, HighPagePriority);
+#endif
+	precv_frame = rxmem_to_recvframe((unsigned char*)buf_star);
+
+	return precv_frame;
+}
+
+__inline static u8 *pkt_to_recvmem(_pkt *pkt)
+{
+	// return the rx_head
+
+	union recv_frame * precv_frame = pkt_to_recvframe(pkt);
+
+	return 	precv_frame->u.hdr.rx_head;
+
+}
+
+__inline static u8 *pkt_to_recvdata(_pkt *pkt)
+{
+	// return the rx_data
+
+	union recv_frame * precv_frame =pkt_to_recvframe(pkt);
+
+	return 	precv_frame->u.hdr.rx_data;
+
+}
+
+
+__inline static sint get_recvframe_len(union recv_frame *precvframe)
+{
+	return precvframe->u.hdr.len;
+}
+
+
+__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
+{
+	s32	SignalPower; // in dBm.
+
+#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+	/* Translate to dBm (x=0.5y-95). */
+	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1);
+	SignalPower -= 95;
+#else
+	/* Translate to dBm (x=y-100) */
+	SignalPower = SignalStrengthIndex - 100;
+#endif
+
+	return SignalPower;
+}
+
+
+struct sta_info;
+
+extern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+
+extern void  mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_rf.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_rf.h
new file mode 100644
index 000000000..dc9bb06b6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_rf.h
@@ -0,0 +1,237 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_RF_H_
+#define __RTW_RF_H_
+
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+
+#define NumRates	(13)
+
+// slot time for 11g
+#define SHORT_SLOT_TIME					9
+#define NON_SHORT_SLOT_TIME				20
+
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+
+//
+// We now define the following channels as the max channels in each channel plan.
+// 2G, total 14 chnls
+// {1,2,3,4,5,6,7,8,9,10,11,12,13,14}
+// 5G, total 24 chnls
+// {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}
+#define	MAX_CHANNEL_NUM_2G				14
+#define	MAX_CHANNEL_NUM_5G				24
+#define	MAX_CHANNEL_NUM					38//14+24
+
+#define CENTER_CH_2G_NUM		14
+#define CENTER_CH_5G_20M_NUM	28	/* 20M center channels */
+#define CENTER_CH_5G_40M_NUM	14	/* 40M center channels */
+#define CENTER_CH_5G_80M_NUM	7	/* 80M center channels */
+#define CENTER_CH_5G_ALL_NUM	(CENTER_CH_5G_20M_NUM + CENTER_CH_5G_40M_NUM + CENTER_CH_5G_80M_NUM)
+
+extern u8 center_ch_5g_20m[CENTER_CH_5G_20M_NUM];
+extern u8 center_ch_5g_40m[CENTER_CH_5G_40M_NUM];
+extern u8 center_ch_5g_80m[CENTER_CH_5G_80M_NUM];
+extern u8 center_ch_5g_all[CENTER_CH_5G_ALL_NUM];
+
+u8 center_chs_5g_num(u8 bw);
+u8 center_chs_5g(u8 bw, u8 id);
+
+//#define NUM_REGULATORYS	21
+#define NUM_REGULATORYS	1
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later
+#define JAPAN						0x2 //temp, should be provided later
+
+struct	regulatory_class {
+	u32	starting_freq;					//MHz,
+	u8	channel_set[MAX_CHANNEL_NUM];
+	u8	channel_cck_power[MAX_CHANNEL_NUM];//dbm
+	u8	channel_ofdm_power[MAX_CHANNEL_NUM];//dbm
+	u8	txpower_limit;  				//dbm
+	u8	channel_spacing;				//MHz
+	u8	modem;
+};
+
+typedef enum _CAPABILITY{
+	cESS			= 0x0001,
+	cIBSS			= 0x0002,
+	cPollable		= 0x0004,
+	cPollReq			= 0x0008,
+	cPrivacy		= 0x0010,
+	cShortPreamble	= 0x0020,
+	cPBCC			= 0x0040,
+	cChannelAgility	= 0x0080,
+	cSpectrumMgnt	= 0x0100,
+	cQos			= 0x0200,	// For HCCA, use with CF-Pollable and CF-PollReq
+	cShortSlotTime	= 0x0400,
+	cAPSD			= 0x0800,
+	cRM				= 0x1000,	// RRM (Radio Request Measurement)
+	cDSSS_OFDM	= 0x2000,
+	cDelayedBA		= 0x4000,
+	cImmediateBA	= 0x8000,
+}CAPABILITY, *PCAPABILITY;
+
+enum	_REG_PREAMBLE_MODE{
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+
+enum _RTL8712_RF_MIMO_CONFIG_{
+ RTL8712_RFCONFIG_1T=0x10,
+ RTL8712_RFCONFIG_2T=0x20,
+ RTL8712_RFCONFIG_1R=0x01,
+ RTL8712_RFCONFIG_2R=0x02,
+ RTL8712_RFCONFIG_1T1R=0x11,
+ RTL8712_RFCONFIG_1T2R=0x12,
+ RTL8712_RFCONFIG_TURBO=0x92,
+ RTL8712_RFCONFIG_2T2R=0x22
+};
+
+typedef enum _RF_PATH {
+	RF_PATH_A = 0,
+	RF_PATH_B = 1,
+	RF_PATH_C = 2,
+	RF_PATH_D = 3,
+} RF_PATH, *PRF_PATH;
+
+#define rf_path_char(path) (((path) >= RF_PATH_MAX) ? 'X' : 'A' + (path))
+
+// Bandwidth Offset
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+
+typedef enum _BAND_TYPE {
+	BAND_ON_2_4G = 0,
+	BAND_ON_5G = 1,
+	BAND_ON_BOTH = 2,
+	BAND_MAX = 3,
+} BAND_TYPE, *PBAND_TYPE;
+
+extern const char * const _band_str[];
+#define band_str(band) (((band) >= BAND_MAX) ? _band_str[BAND_MAX] : _band_str[(band)])
+
+extern const u8 _band_to_band_cap[];
+#define band_to_band_cap(band) (((band) >= BAND_MAX) ? _band_to_band_cap[BAND_MAX] : _band_to_band_cap[(band)])
+
+// Represent Channel Width in HT Capabilities
+//
+typedef enum _CHANNEL_WIDTH{
+	CHANNEL_WIDTH_20 = 0,
+	CHANNEL_WIDTH_40 = 1,
+	CHANNEL_WIDTH_80 = 2,
+	CHANNEL_WIDTH_160 = 3,
+	CHANNEL_WIDTH_80_80 = 4,
+	CHANNEL_WIDTH_MAX = 5,
+}CHANNEL_WIDTH, *PCHANNEL_WIDTH;
+
+extern const char * const _ch_width_str[];
+#define ch_width_str(bw) (((bw) >= CHANNEL_WIDTH_MAX) ? _ch_width_str[CHANNEL_WIDTH_MAX] : _ch_width_str[(bw)])
+
+extern const u8 _ch_width_to_bw_cap[];
+#define ch_width_to_bw_cap(bw) (((bw) >= CHANNEL_WIDTH_MAX) ? _ch_width_to_bw_cap[CHANNEL_WIDTH_MAX] : _ch_width_to_bw_cap[(bw)])
+
+//
+// Represent Extention Channel Offset in HT Capabilities
+// This is available only in 40Mhz mode.
+//
+typedef enum _EXTCHNL_OFFSET{
+	EXTCHNL_OFFSET_NO_EXT = 0,
+	EXTCHNL_OFFSET_UPPER = 1,
+	EXTCHNL_OFFSET_NO_DEF = 2,
+	EXTCHNL_OFFSET_LOWER = 3,
+}EXTCHNL_OFFSET, *PEXTCHNL_OFFSET;
+
+typedef enum _VHT_DATA_SC{
+	VHT_DATA_SC_DONOT_CARE = 0,
+	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
+	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
+	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
+	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
+	VHT_DATA_SC_20_RECV1 = 5,
+	VHT_DATA_SC_20_RECV2 = 6,
+	VHT_DATA_SC_20_RECV3 = 7,
+	VHT_DATA_SC_20_RECV4 = 8,
+	VHT_DATA_SC_40_UPPER_OF_80MHZ = 9,
+	VHT_DATA_SC_40_LOWER_OF_80MHZ = 10,
+}VHT_DATA_SC, *PVHT_DATA_SC_E;
+
+typedef enum _PROTECTION_MODE{
+	PROTECTION_MODE_AUTO = 0,
+	PROTECTION_MODE_FORCE_ENABLE = 1,
+	PROTECTION_MODE_FORCE_DISABLE = 2,
+}PROTECTION_MODE, *PPROTECTION_MODE;
+
+typedef	enum _RT_RF_TYPE_DEFINITION
+{
+	RF_1T2R = 0,
+	RF_2T4R = 1,
+	RF_2T2R = 2,
+	RF_1T1R = 3,
+	RF_2T2R_GREEN = 4,
+	RF_2T3R = 5,
+	RF_3T3R = 6,
+	RF_3T4R	= 7,
+	RF_4T4R	= 8,
+
+	RF_MAX_TYPE = 0xF, /* u1Byte */
+}RT_RF_TYPE_DEF_E;
+
+int rtw_ch2freq(int chan);
+int rtw_freq2ch(int freq);
+bool rtw_chbw_to_freq_range(u8 ch, u8 bw, u8 offset, u32 *hi, u32 *lo);
+
+int rtw_get_chplan_from_country(const char *country_code);
+
+#define BB_GAIN_2G 0
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+#define BB_GAIN_5GLB1 1
+#define BB_GAIN_5GLB2 2
+#define BB_GAIN_5GMB1 3
+#define BB_GAIN_5GMB2 4
+#define BB_GAIN_5GHB 5
+#endif
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+#define BB_GAIN_NUM 6
+#else
+#define BB_GAIN_NUM 1
+#endif
+
+int rtw_ch_to_bb_gain_sel(int ch);
+void rtw_rf_set_tx_gain_offset(_adapter *adapter, u8 path, s8 offset);
+void rtw_rf_apply_tx_gain_offset(_adapter *adapter, u8 ch);
+
+bool rtw_is_dfs_range(u32 hi, u32 lo);
+bool rtw_is_dfs_ch(u8 ch, u8 bw, u8 offset);
+bool rtw_is_long_cac_range(u32 hi, u32 lo);
+bool rtw_is_long_cac_ch(u8 ch, u8 bw, u8 offset);
+
+#endif //_RTL8711_RF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_security.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_security.h
new file mode 100644
index 000000000..19a2f455b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_security.h
@@ -0,0 +1,488 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_SECURITY_H_
+#define __RTW_SECURITY_H_
+
+
+#define _NO_PRIVACY_		0x0
+#define _WEP40_				0x1
+#define _TKIP_				0x2
+#define _TKIP_WTMIC_		0x3
+#define _AES_				0x4
+#define _WEP104_			0x5
+#define _WEP_WPA_MIXED_	0x07  // WEP + WPA
+#define _SMS4_				0x06
+#ifdef CONFIG_IEEE80211W
+#define _BIP_				0x8
+#endif //CONFIG_IEEE80211W
+/* 802.11W use wrong key */
+#define IEEE80211W_RIGHT_KEY	0x0
+#define IEEE80211W_WRONG_KEY	0x1
+#define IEEE80211W_NO_KEY		0x2
+
+#define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
+
+const char *security_type_str(u8 value);
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#define SHA256_MAC_LEN 32
+#define AES_BLOCK_SIZE 16
+#define AES_PRIV_SIZE (4 * 44)
+
+#define RTW_KEK_LEN 16
+#define RTW_KCK_LEN 16
+#define RTW_REPLAY_CTR_LEN 8
+
+typedef enum {
+	ENCRYP_PROTOCOL_OPENSYS,   //open system
+	ENCRYP_PROTOCOL_WEP,       //WEP
+	ENCRYP_PROTOCOL_WPA,       //WPA
+	ENCRYP_PROTOCOL_WPA2,      //WPA2
+	ENCRYP_PROTOCOL_WAPI,      //WAPI: Not support in this version
+	ENCRYP_PROTOCOL_MAX
+}ENCRYP_PROTOCOL_E;
+
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48	{
+
+	u64	val;
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+struct {
+  u8 TSC0;
+  u8 TSC1;
+  u8 TSC2;
+  u8 TSC3;
+  u8 TSC4;
+  u8 TSC5;
+  u8 TSC6;
+  u8 TSC7;
+} _byte_;
+
+#elif defined(CONFIG_BIG_ENDIAN)
+
+struct {
+  u8 TSC7;
+  u8 TSC6;
+  u8 TSC5;
+  u8 TSC4;
+  u8 TSC3;
+  u8 TSC2;
+  u8 TSC1;
+  u8 TSC0;
+} _byte_;
+
+#endif
+
+};
+
+union Keytype {
+        u8   skey[16];
+        u32    lkey[4];
+};
+
+
+typedef struct _RT_PMKID_LIST
+{
+	u8						bUsed;
+	u8 						Bssid[6];
+	u8						PMKID[16];
+	u8						SsidBuf[33];
+	u8*						ssid_octet;
+	u16 						ssid_length;
+} RT_PMKID_LIST, *PRT_PMKID_LIST;
+
+
+struct security_priv
+{
+	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch
+	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+
+	/* WEP */
+	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id. (tx key index)
+	union Keytype dot11DefKey[4];			// this is only valid for def. key
+	u32 	dot11DefKeylen[4];
+	u8 	key_mask; /* use to restore wep key after hal_init */
+
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
+	u32	dot118021XGrpKeyid;		// key id used for Grp Key ( tx key index)
+	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
+	union Keytype	dot118021XGrptxmickey[4];
+	union Keytype	dot118021XGrprxmickey[4];
+	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
+	union pn48		dot11Grprxpn;			// PN48 used for Grp Key recv.
+#ifdef CONFIG_IEEE80211W
+	u32	dot11wBIPKeyid;						// key id used for BIP Key ( tx key index)
+	union Keytype	dot11wBIPKey[6];		// BIP Key, for index4 and index5
+	union pn48		dot11wBIPtxpn;			// PN48 used for Grp Key xmit.
+	union pn48		dot11wBIPrxpn;			// PN48 used for Grp Key recv.
+#endif //CONFIG_IEEE80211W
+#ifdef CONFIG_AP_MODE
+	//extend security capabilities for AP_MODE
+	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;
+#endif
+
+	u8 wps_ie[MAX_WPS_IE_LEN];//added in assoc req
+	int wps_ie_len;
+
+
+	u8	binstallGrpkey;
+#ifdef CONFIG_GTK_OL
+	u8	binstallKCK_KEK;
+#endif //CONFIG_GTK_OL
+#ifdef CONFIG_IEEE80211W
+	u8	binstallBIPkey;
+#endif //CONFIG_IEEE80211W
+	u8	busetkipkey;
+	//_timer tkip_timer;
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+
+	//u8	packet_cnt;//unused, removed
+
+	s32	sw_encrypt;//from registry_priv
+	s32	sw_decrypt;//from registry_priv
+
+	s32 	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
+
+
+	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
+	u32 ndisauthtype;	// NDIS_802_11_AUTHENTICATION_MODE
+	u32 ndisencryptstatus;	// NDIS_802_11_ENCRYPTION_STATUS
+
+	NDIS_802_11_WEP ndiswep;
+#ifdef PLATFORM_WINDOWS
+	u8 KeyMaterial[16];// variable length depending on above field.
+#endif
+
+	u8 assoc_info[600];
+	u8 szofcapability[256]; //for wpa2 usage
+	u8 oidassociation[512]; //for wpa/wpa2 usage
+	u8 authenticator_ie[256];  //store ap security information element
+	u8 supplicant_ie[256];  //store sta security information element
+
+
+	//for tkip countermeasure
+	u32 last_mic_err_time;
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+
+	//---------------------------------------------------------------------------
+	// For WPA2 Pre-Authentication.
+	//---------------------------------------------------------------------------
+	//u8				RegEnablePreAuth;				// Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01.
+	//u8				EnablePreAuthentication;			// Current Value: Pre-Authentication enabled or not.
+	RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	// Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13.
+	u8				PMKIDIndex;
+	//u32				PMKIDCount;						// Added by Annie, 2006-10-13.
+	//u8				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
+
+	u8 bWepDefaultKeyIdxSet;
+
+#define DBG_SW_SEC_CNT
+#ifdef DBG_SW_SEC_CNT
+	u64 wep_sw_enc_cnt_bc;
+	u64 wep_sw_enc_cnt_mc;
+	u64 wep_sw_enc_cnt_uc;
+	u64 wep_sw_dec_cnt_bc;
+	u64 wep_sw_dec_cnt_mc;
+	u64 wep_sw_dec_cnt_uc;
+
+	u64 tkip_sw_enc_cnt_bc;
+	u64 tkip_sw_enc_cnt_mc;
+	u64 tkip_sw_enc_cnt_uc;
+	u64 tkip_sw_dec_cnt_bc;
+	u64 tkip_sw_dec_cnt_mc;
+	u64 tkip_sw_dec_cnt_uc;
+
+	u64 aes_sw_enc_cnt_bc;
+	u64 aes_sw_enc_cnt_mc;
+	u64 aes_sw_enc_cnt_uc;
+	u64 aes_sw_dec_cnt_bc;
+	u64 aes_sw_dec_cnt_mc;
+	u64 aes_sw_dec_cnt_uc;
+#endif /* DBG_SW_SEC_CNT */
+};
+
+struct rtl_sha256_state {
+	u64 length;
+	u32 state[8], curlen;
+	u8 buf[64];
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
+do{\
+	switch(psecuritypriv->dot11AuthAlgrthm)\
+	{\
+		case dot11AuthAlgrthm_Open:\
+		case dot11AuthAlgrthm_Shared:\
+		case dot11AuthAlgrthm_Auto:\
+			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		case dot11AuthAlgrthm_8021X:\
+			if(bmcst)\
+				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
+			else\
+				encry_algo =(u8) psta->dot118021XPrivacy;\
+			break;\
+	     case dot11AuthAlgrthm_WAPI:\
+		     encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+		     break;\
+	}\
+}while(0)
+
+#define _AES_IV_LEN_ 8
+
+#define SET_ICE_IV_LEN( iv_len, icv_len, encrypt)\
+do{\
+	switch(encrypt)\
+	{\
+		case _WEP40_:\
+		case _WEP104_:\
+			iv_len = 4;\
+			icv_len = 4;\
+			break;\
+		case _TKIP_:\
+			iv_len = 8;\
+			icv_len = 4;\
+			break;\
+		case _AES_:\
+			iv_len = 8;\
+			icv_len = 8;\
+			break;\
+		case _SMS4_:\
+			iv_len = 18;\
+			icv_len = 16;\
+			break;\
+		default:\
+			iv_len = 0;\
+			icv_len = 0;\
+			break;\
+	}\
+}while(0)
+
+
+#define GET_TKIP_PN(iv,dot11txpn)\
+do{\
+	dot11txpn._byte_.TSC0=iv[2];\
+	dot11txpn._byte_.TSC1=iv[0];\
+	dot11txpn._byte_.TSC2=iv[4];\
+	dot11txpn._byte_.TSC3=iv[5];\
+	dot11txpn._byte_.TSC4=iv[6];\
+	dot11txpn._byte_.TSC5=iv[7];\
+}while(0)
+
+
+#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
+#define ROR32( A, n ) 	ROL32( (A), 32-(n) )
+
+struct mic_data
+{
+	u32  K0, K1;         // Key
+	u32  L, R;           // Current state
+	u32  M;              // Message accumulator (single word)
+	u32     nBytesInM;      // # bytes in M
+};
+
+extern const u32 Te0[256];
+extern const u32 Te1[256];
+extern const u32 Te2[256];
+extern const u32 Te3[256];
+extern const u32 Te4[256];
+extern const u32 Td0[256];
+extern const u32 Td1[256];
+extern const u32 Td2[256];
+extern const u32 Td3[256];
+extern const u32 Td4[256];
+extern const u32 rcon[10];
+extern const u8 Td4s[256];
+extern const u8 rcons[10];
+
+#define RCON(i) (rcons[(i)] << 24)
+
+static inline u32 rotr(u32 val, int bits)
+{
+	return (val >> bits) | (val << (32 - bits));
+}
+
+#define TE0(i) Te0[((i) >> 24) & 0xff]
+#define TE1(i) rotr(Te0[((i) >> 16) & 0xff], 8)
+#define TE2(i) rotr(Te0[((i) >> 8) & 0xff], 16)
+#define TE3(i) rotr(Te0[(i) & 0xff], 24)
+#define TE41(i) ((Te0[((i) >> 24) & 0xff] << 8) & 0xff000000)
+#define TE42(i) (Te0[((i) >> 16) & 0xff] & 0x00ff0000)
+#define TE43(i) (Te0[((i) >> 8) & 0xff] & 0x0000ff00)
+#define TE44(i) ((Te0[(i) & 0xff] >> 8) & 0x000000ff)
+#define TE421(i) ((Te0[((i) >> 16) & 0xff] << 8) & 0xff000000)
+#define TE432(i) (Te0[((i) >> 8) & 0xff] & 0x00ff0000)
+#define TE443(i) (Te0[(i) & 0xff] & 0x0000ff00)
+#define TE414(i) ((Te0[((i) >> 24) & 0xff] >> 8) & 0x000000ff)
+#define TE4(i) ((Te0[(i)] >> 8) & 0x000000ff)
+
+#define TD0(i) Td0[((i) >> 24) & 0xff]
+#define TD1(i) rotr(Td0[((i) >> 16) & 0xff], 8)
+#define TD2(i) rotr(Td0[((i) >> 8) & 0xff], 16)
+#define TD3(i) rotr(Td0[(i) & 0xff], 24)
+#define TD41(i) (Td4s[((i) >> 24) & 0xff] << 24)
+#define TD42(i) (Td4s[((i) >> 16) & 0xff] << 16)
+#define TD43(i) (Td4s[((i) >> 8) & 0xff] << 8)
+#define TD44(i) (Td4s[(i) & 0xff])
+#define TD0_(i) Td0[(i) & 0xff]
+#define TD1_(i) rotr(Td0[(i) & 0xff], 8)
+#define TD2_(i) rotr(Td0[(i) & 0xff], 16)
+#define TD3_(i) rotr(Td0[(i) & 0xff], 24)
+
+#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ \
+			((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
+
+#define PUTU32(ct, st) { \
+(ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); \
+(ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
+
+#define WPA_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (u8) (((u64) (val)) >> 56);	\
+		(a)[1] = (u8) (((u64) (val)) >> 48);	\
+		(a)[2] = (u8) (((u64) (val)) >> 40);	\
+		(a)[3] = (u8) (((u64) (val)) >> 32);	\
+		(a)[4] = (u8) (((u64) (val)) >> 24);	\
+		(a)[5] = (u8) (((u64) (val)) >> 16);	\
+		(a)[6] = (u8) (((u64) (val)) >> 8);	\
+		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+/* ===== start - public domain SHA256 implementation ===== */
+
+/* This is based on SHA256 implementation in LibTomCrypt that was released into
+ * public domain by Tom St Denis. */
+
+/* the K array */
+static const unsigned long K[64] = {
+	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
+	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
+	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
+	0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
+	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
+	0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
+	0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
+	0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
+	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
+	0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
+	0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
+	0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
+	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
+};
+
+
+/* Various logical functions */
+#define RORc(x, y) \
+( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
+   ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
+#define Ch(x,y,z)       (z ^ (x & (y ^ z)))
+#define Maj(x,y,z)      (((x | y) & z) | (x & y))
+#define S(x, n)         RORc((x), (n))
+#define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
+#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
+#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
+#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
+#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
+#ifndef MIN
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#endif
+#ifdef CONFIG_IEEE80211W
+int omac1_aes_128(u8 *key, u8 *data, size_t data_len, u8 *mac);
+#endif //CONFIG_IEEE80211W
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key );
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b );
+void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes );
+void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst );
+
+void rtw_seccalctkipmic(
+	u8 * key,
+	u8 *header,
+	u8 *data,
+	u32 data_len,
+	u8 *Miccode,
+	u8   priority);
+
+u32 rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe);
+u32 rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe);
+void rtw_wep_encrypt(_adapter *padapter, u8  *pxmitframe);
+
+u32 rtw_aes_decrypt(_adapter *padapter, u8  *precvframe);
+u32 rtw_tkip_decrypt(_adapter *padapter, u8  *precvframe);
+void rtw_wep_decrypt(_adapter *padapter, u8  *precvframe);
+#ifdef CONFIG_IEEE80211W
+u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe);
+#endif //CONFIG_IEEE80211W
+#ifdef CONFIG_TDLS
+void wpa_tdls_generate_tpk(_adapter *padapter, PVOID sta);
+int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
+						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
+						u8 *mic);
+int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason,
+	u8 dialog_token, u8 trans_seq, u8 *ftie, u8 *mic);
+int tdls_verify_mic(u8 *kck, u8 trans_seq,
+						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
+#endif //CONFIG_TDLS
+
+void rtw_sec_restore_wep_key(_adapter *adapter);
+u8 rtw_handle_tkip_countermeasure(_adapter* adapter, const char *caller);
+
+#ifdef CONFIG_WOWLAN
+u16 rtw_calc_crc(u8  *pdata, int length);
+#endif /*CONFIG_WOWLAN*/
+
+#endif	//__RTL871X_SECURITY_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_sreset.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_sreset.h
new file mode 100644
index 000000000..466162472
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_sreset.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_SRESET_H_
+#define _RTW_SRESET_H_
+
+//#include <drv_types.h>
+
+enum {
+	SRESET_TGP_NULL = 0,
+	SRESET_TGP_XMIT_STATUS = 1,
+	SRESET_TGP_LINK_STATUS = 2,
+};
+
+struct sreset_priv {
+	_mutex 	silentreset_mutex;
+	u8 	silent_reset_inprogress;
+	u8	Wifi_Error_Status;
+	unsigned long last_tx_time;
+	unsigned long last_tx_complete_time;
+
+	s32 dbg_trigger_point;
+};
+
+
+
+#define	WIFI_STATUS_SUCCESS 		0
+#define	USB_VEN_REQ_CMD_FAIL 	BIT0
+#define	USB_READ_PORT_FAIL 		BIT1
+#define	USB_WRITE_PORT_FAIL		BIT2
+#define	WIFI_MAC_TXDMA_ERROR 	BIT3
+#define   WIFI_TX_HANG				BIT4
+#define	WIFI_RX_HANG				BIT5
+#define 	WIFI_IF_NOT_EXIST			BIT6
+
+void sreset_init_value(_adapter *padapter);
+void sreset_reset_value(_adapter *padapter);
+u8 sreset_get_wifi_status(_adapter *padapter);
+void sreset_set_wifi_error_status(_adapter *padapter, u32 status);
+void sreset_set_trigger_point(_adapter *padapter, s32 tgp);
+bool sreset_inprogress(_adapter *padapter);
+void sreset_reset(_adapter *padapter);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_tdls.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_tdls.h
new file mode 100644
index 000000000..f38ad2379
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_tdls.h
@@ -0,0 +1,149 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_TDLS_H_
+#define __RTW_TDLS_H_
+
+
+#ifdef CONFIG_TDLS
+/* TDLS STA state */
+
+
+/* TDLS Diect Link Establishment */
+#define	TDLS_STATE_NONE				0x00000000		/* Default state */
+#define	TDLS_INITIATOR_STATE		BIT(28)			/* 0x10000000 */
+#define	TDLS_RESPONDER_STATE		BIT(29)			/* 0x20000000 */
+#define	TDLS_LINKED_STATE			BIT(30)			/* 0x40000000 */
+/* TDLS PU Buffer STA */
+#define	TDLS_WAIT_PTR_STATE			BIT(24)			/* 0x01000000 */	/* Waiting peer's TDLS_PEER_TRAFFIC_RESPONSE frame */
+/* TDLS Check ALive */
+#define	TDLS_ALIVE_STATE			BIT(20)			/* 0x00100000 */	/* Check if peer sta is alived. */
+/* TDLS Channel Switch */
+#define	TDLS_CH_SWITCH_ON_STATE		BIT(16)			/* 0x00010000 */
+#define	TDLS_PEER_AT_OFF_STATE		BIT(17)			/* 0x00020000 */	/* Could send pkt on target ch */
+#define	TDLS_CH_SW_INITIATOR_STATE	BIT(18)			/* 0x00040000 */	/* Avoid duplicated or unconditional ch. switch rsp. */
+#define	TDLS_WAIT_CH_RSP_STATE		BIT(19)			/* 0x00080000 */	/* Wait Ch. response as we are TDLS channel switch initiator */
+
+
+#define	TPK_RESEND_COUNT			1800	/*Unit: seconds */
+#define	CH_SWITCH_TIME				5
+#define	CH_SWITCH_TIMEOUT			20
+#define	TDLS_SIGNAL_THRESH			0x20
+#define	TDLS_WATCHDOG_PERIOD		10	/* Periodically sending tdls discovery request in TDLS_WATCHDOG_PERIOD * 2 sec */
+#define	TDLS_HANDSHAKE_TIME			3000
+#define	TDLS_PTI_TIME				7000
+
+#define TDLS_MIC_LEN 16
+#define WPA_NONCE_LEN 32
+#define TDLS_TIMEOUT_LEN 4
+
+struct wpa_tdls_ftie {
+	u8 ie_type; /* FTIE */
+	u8 ie_len;
+	u8 mic_ctrl[2];
+	u8 mic[TDLS_MIC_LEN];
+	u8 Anonce[WPA_NONCE_LEN]; /* Responder Nonce in TDLS */
+	u8 Snonce[WPA_NONCE_LEN]; /* Initiator Nonce in TDLS */
+	/* followed by optional elements */
+} ;
+
+struct wpa_tdls_lnkid {
+	u8 ie_type; /* Link Identifier IE */
+	u8 ie_len;
+	u8 bssid[ETH_ALEN];
+	u8 init_sta[ETH_ALEN];
+	u8 resp_sta[ETH_ALEN];
+} ;
+
+static u8 TDLS_RSNIE[20]={	0x01, 0x00,	/* Version shall be set to 1 */
+							0x00, 0x0f, 0xac, 0x07,	/* Group sipher suite */
+							0x01, 0x00,	/* Pairwise cipher suite count */
+							0x00, 0x0f, 0xac, 0x04,	/* Pairwise cipher suite list; CCMP only */
+							0x01, 0x00,	/* AKM suite count */
+							0x00, 0x0f, 0xac, 0x07,	/* TPK Handshake */
+							0x0c, 0x02,
+							/* PMKID shall not be present */
+						};
+
+static u8 TDLS_WMMIE[]={0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};	/* Qos info all set zero */
+
+static u8 TDLS_WMM_PARAM_IE[] = {0x00, 0x00, 0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00, 0x42, 0x43, 0x5e, 0x00, 0x62, 0x32, 0x2f, 0x00};
+
+static u8 TDLS_EXT_CAPIE[] = {0x00, 0x00, 0x00, 0x50, 0x20, 0x00, 0x00, 0x00};	/* bit(28), bit(30), bit(37) */
+
+/* SRC: Supported Regulatory Classes */
+static u8 TDLS_SRC[] = { 0x01, 0x01, 0x02, 0x03, 0x04, 0x0c, 0x16, 0x17, 0x18, 0x19, 0x1b, 0x1c, 0x1d, 0x1e, 0x20, 0x21 };
+
+int check_ap_tdls_prohibited(u8 *pframe, u8 pkt_len);
+int check_ap_tdls_ch_switching_prohibited(u8 *pframe, u8 pkt_len);
+void rtw_reset_tdls_info(_adapter* padapter);
+int rtw_init_tdls_info(_adapter* padapter);
+void rtw_free_tdls_info(struct tdls_info *ptdlsinfo);
+int issue_nulldata_to_TDLS_peer_STA(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+void rtw_init_tdls_timer(_adapter *padapter, struct sta_info *psta);
+void	rtw_free_tdls_timer(struct sta_info *psta);
+void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta);
+#ifdef CONFIG_WFD
+int issue_tunneled_probe_req(_adapter *padapter);
+int issue_tunneled_probe_rsp(_adapter *padapter, union recv_frame *precv_frame);
+#endif /* CONFIG_WFD */
+int issue_tdls_dis_req(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_setup_req(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, int wait_ack);
+int issue_tdls_setup_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_setup_cfm(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_dis_rsp(_adapter * padapter, struct tdls_txmgmt *ptxmgmt, u8 privacy);
+int issue_tdls_teardown(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, u8 wait_ack);
+int issue_tdls_peer_traffic_rsp(_adapter *padapter, struct sta_info *psta, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *psta);
+int issue_tdls_ch_switch_req(_adapter *padapter, struct sta_info *ptdls_sta);
+int issue_tdls_ch_switch_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, int wait_ack);
+sint On_TDLS_Dis_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Setup_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Dis_Req(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Peer_Traffic_Indication(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+#ifdef CONFIG_TDLS_CH_SW
+sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame);
+sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+void rtw_build_tdls_ch_switch_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_ch_switch_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+#endif
+void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_setup_cfm_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_teardown_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_dis_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, u8 privacy);
+void rtw_build_tdls_peer_traffic_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_peer_traffic_indication_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tunneled_probe_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
+void rtw_build_tunneled_probe_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
+
+u8	update_sgi_tdls(_adapter *padapter, struct sta_info *psta);
+u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta);
+int rtw_tdls_is_driver_setup(_adapter *padapter);
+void rtw_tdls_set_key(_adapter *padapter, struct sta_info *ptdls_sta);
+const char * rtw_tdls_action_txt(enum TDLS_ACTION_FIELD action);
+#endif /* CONFIG_TDLS */
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_version.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_version.h
new file mode 100644
index 000000000..267095906
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_version.h
@@ -0,0 +1,2 @@
+#define DRIVERVERSION	"v4.3.22.9_16440.20151221_BTCOEX20151214-0700"
+#define BTCOEXVERSION	"BTCOEX20151214-0700"
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_vht.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_vht.h
new file mode 100644
index 000000000..c4c4091a6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_vht.h
@@ -0,0 +1,143 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_VHT_H_
+#define _RTW_VHT_H_
+
+#define	LDPC_VHT_ENABLE_RX			BIT0
+#define	LDPC_VHT_ENABLE_TX			BIT1
+#define	LDPC_VHT_TEST_TX_ENABLE		BIT2
+#define	LDPC_VHT_CAP_TX				BIT3
+
+#define	STBC_VHT_ENABLE_RX			BIT0
+#define	STBC_VHT_ENABLE_TX			BIT1
+#define	STBC_VHT_TEST_TX_ENABLE		BIT2
+#define	STBC_VHT_CAP_TX				BIT3
+
+#define	BEAMFORMING_VHT_BEAMFORMER_ENABLE	BIT0	// Declare our NIC supports beamformer
+#define	BEAMFORMING_VHT_BEAMFORMEE_ENABLE	BIT1	// Declare our NIC supports beamformee
+#define	BEAMFORMING_VHT_MU_MIMO_AP_ENABLE		BIT2			/*Declare our NIC support MU-MIMO AP mode*/
+#define	BEAMFORMING_VHT_MU_MIMO_STA_ENABLE	BIT3			/*Declare our NIC support MU-MIMO STA mode*/
+#define	BEAMFORMING_VHT_BEAMFORMER_TEST		BIT4			/*Transmiting Beamforming no matter the target supports it or not*/
+#define	BEAMFORMING_VHT_BEAMFORMER_STS_CAP		(BIT8|BIT9|BIT10)		/*Asoc rsp cap*/
+#define	BEAMFORMING_VHT_BEAMFORMEE_SOUND_DIM		(BIT12|BIT13|BIT14)		/*Asoc rsp cap*/
+
+
+//VHT capability info
+#define SET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 2, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 5, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 6, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 0, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 3, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_BFER_ANT_SUPP(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 5, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_SOUNDING_DIMENSIONS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 0, 3, _val)
+
+#define SET_VHT_CAPABILITY_ELE_MU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 3, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_MU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 5, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_HTC_VHT(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 6, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart, _val)		SET_BITS_TO_LE_2BYTE((_pEleStart)+2, 7, 3, _val) //B23~B25
+#define SET_VHT_CAPABILITY_ELE_LINK_ADAPTION(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 2, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_MCS_RX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+4, 0, 16, _val)   /* B0~B15 indicate Rx MCS MAP, we write 0 to indicate MCS0~7. by page */
+#define SET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+6, 0, 13, _val)
+#define SET_VHT_CAPABILITY_ELE_MCS_TX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+8, 0, 16, _val)   /* B0~B15 indicate Tx MCS MAP, we write 0 to indicate MCS0~7. by page */
+#define SET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+10, 0, 13, _val)
+
+
+#define GET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
+#define GET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 2, 2)
+#define GET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 4, 1)
+#define GET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 5, 1)
+#define GET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 6, 1)
+#define GET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
+#define GET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 3)
+#define GET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 3, 1)
+#define GET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 4, 1)
+/*phydm-beamforming*/
+#define GET_VHT_CAPABILITY_ELE_SU_BFEE_STS_CAP(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+1, 5, 3)
+#define GET_VHT_CAPABILITY_ELE_SU_BFER_SOUND_DIM_NUM(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 0, 3)
+#define GET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 5, 1)
+#define GET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 7, 3)
+#define GET_VHT_CAPABILITY_ELE_RX_MCS(_pEleStart)					       ((_pEleStart)+4)
+#define GET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+6, 0, 13)
+#define GET_VHT_CAPABILITY_ELE_TX_MCS(_pEleStart)					       ((_pEleStart)+8)
+#define GET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+10, 0, 13)
+
+
+//VHT Operation Information Element
+#define SET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ1(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart+1, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ2(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart+2, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_BASIC_MCS_SET(_pEleStart, _val)			SET_BITS_TO_LE_2BYTE((_pEleStart)+3, 0, 16, _val)
+
+#define GET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart,0,8)
+#define GET_VHT_OPERATION_ELE_CENTER_FREQ1(_pEleStart)	LE_BITS_TO_1BYTE((_pEleStart)+1,0,8)
+#define GET_VHT_OPERATION_ELE_CENTER_FREQ2(_pEleStart)     LE_BITS_TO_1BYTE((_pEleStart)+2,0,8)
+
+//VHT Operating Mode
+#define SET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
+#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 3, _val)
+#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
+#define GET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
+#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 4, 3)
+#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
+
+#define SET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart)+7, 6, 1, _val)
+#define GET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+7, 6, 1)
+
+struct vht_priv
+{
+	u8	vht_option;
+
+	u8	ldpc_cap;
+	u8	stbc_cap;
+	u16	beamform_cap;
+
+	u8	sgi_80m;//short GI
+	u8	ampdu_len;
+
+	u8	vht_op_mode_notify;
+	u8	vht_highest_rate;
+	u8	vht_mcs_map[2];
+
+	u8	vht_cap[32];
+};
+
+u8	rtw_get_vht_highest_rate(u8 *pvht_mcs_map);
+u16	rtw_vht_mcs_to_data_rate(u8 bw, u8 short_GI, u8 vht_mcs_rate);
+u64	rtw_vht_rate_to_bitmap(u8 *pVHTRate);
+void	rtw_vht_use_default_setting(_adapter *padapter);
+u32	rtw_build_vht_operation_ie(_adapter *padapter, u8 *pbuf, u8 channel);
+u32	rtw_build_vht_op_mode_notify_ie(_adapter *padapter, u8 *pbuf, u8 bw);
+u32	rtw_build_vht_cap_ie(_adapter *padapter, u8 *pbuf);
+void	update_sta_vht_info_apmode(_adapter *padapter, PVOID psta);
+void	update_hw_vht_param(_adapter *padapter);
+void	VHT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void	VHT_operation_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void	rtw_process_vht_op_mode_notify(_adapter *padapter, u8 *pframe, PVOID sta);
+u32	rtw_restructure_vht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+void	VHTOnAssocRsp(_adapter *padapter);
+u8	rtw_vht_mcsmap_to_nss(u8 *pvht_mcs_map);
+
+#endif	//_RTW_VHT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_wapi.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_wapi.h
new file mode 100644
index 000000000..15b9212b3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_wapi.h
@@ -0,0 +1,222 @@
+#ifndef __INC_WAPI_H
+#define __INC_WAPI_H
+
+
+#define CONFIG_WAPI_SW_SMS4
+#define WAPI_DEBUG
+
+#define SMS4_MIC_LEN                16
+#define WAPI_EXT_LEN                18
+#define MAX_WAPI_IE_LEN		    256
+#define sMacHdrLng				24		// octets in data header, no WEP
+
+#ifdef WAPI_DEBUG
+
+/* WAPI trace debug */
+extern u32 wapi_debug_component;
+
+static inline void dump_buf(u8 *buf, u32 len)
+{
+	u32 i;
+	printk("-----------------Len %d----------------\n", len);
+	for(i=0; i<len; i++)
+		printk("%2.2x-", *(buf+i));
+	printk("\n");
+}
+
+#define WAPI_TRACE(component, x, args...) \
+do { if(wapi_debug_component & (component)) \
+	printk(KERN_DEBUG "WAPI" ":" x "" , \
+	       ##args);\
+}while(0);
+
+#define WAPI_DATA(component, x, buf, len) \
+do { if(wapi_debug_component & (component)){ \
+	printk("%s:\n", x);\
+	dump_buf((buf), (len));}\
+}while(0);
+
+#define RT_ASSERT_RET(_Exp)								\
+		if(!(_Exp))									\
+		{											\
+			printk("RTWLAN: ");					\
+                	printk( "Assertion failed! %s,%s,line=%d\n", \
+                	#_Exp,__FUNCTION__,__LINE__);          \
+			return;						\
+		}
+#define RT_ASSERT_RET_VALUE(_Exp,Ret)								\
+		if(!(_Exp))									\
+		{											\
+			printk("RTWLAN: ");					\
+                	printk( "Assertion failed! %s,%s,line=%d\n", \
+                	#_Exp,__FUNCTION__,__LINE__);          \
+			return (Ret);						\
+		}
+
+#else
+#define RT_ASSERT_RET(_Exp) do {} while(0)
+#define RT_ASSERT_RET_VALUE(_Exp,Ret) do {} while(0)
+#define WAPI_TRACE(component, x, args...) do {} while(0)
+#define WAPI_DATA(component, x, buf, len) do {} while(0)
+#endif
+
+
+enum WAPI_DEBUG {
+	WAPI_INIT				= 1,
+	WAPI_API				= 1<<1,
+	WAPI_TX				= 1<<2,
+	WAPI_RX				= 1<<3,
+	WAPI_MLME				= 1<<4,
+	WAPI_IOCTL				= 1<<5,
+	WAPI_ERR		        	= 1<<31
+};
+
+#define			WAPI_MAX_BKID_NUM				4
+#define			WAPI_MAX_STAINFO_NUM			4
+#define			WAPI_CAM_ENTRY_NUM			14	// 28/2=14
+
+typedef struct  _RT_WAPI_BKID
+{
+	struct list_head	list;
+	u8				bkid[16];
+}RT_WAPI_BKID,*PRT_WAPI_BKID;
+
+typedef struct  _RT_WAPI_KEY
+{
+	u8			dataKey[16];
+	u8			micKey[16];
+	u8			keyId;
+	bool			bSet;
+	bool             bTxEnable;
+}RT_WAPI_KEY,*PRT_WAPI_KEY;
+
+typedef enum _RT_WAPI_PACKET_TYPE
+{
+	WAPI_NONE = 0,
+	WAPI_PREAUTHENTICATE=1,
+	WAPI_STAKEY_REQUEST=2,
+	WAPI_AUTHENTICATE_ACTIVE=3,
+	WAPI_ACCESS_AUTHENTICATE_REQUEST=4,
+	WAPI_ACCESS_AUTHENTICATE_RESPONSE=5,
+	WAPI_CERTIFICATE_AUTHENTICATE_REQUEST=6,
+	WAPI_CERTIFICATE_AUTHENTICATE_RESPONSE=7,
+	WAPI_USK_REQUEST=8,
+	WAPI_USK_RESPONSE=9,
+	WAPI_USK_CONFIRM=10,
+	WAPI_MSK_NOTIFICATION=11,
+	WAPI_MSK_RESPONSE=12
+}RT_WAPI_PACKET_TYPE;
+
+typedef struct	_RT_WAPI_STA_INFO
+{
+	struct list_head		list;
+	u8					PeerMacAddr[6];
+	RT_WAPI_KEY		      wapiUsk;
+	RT_WAPI_KEY		      wapiUskUpdate;
+	RT_WAPI_KEY		      wapiMsk;
+	RT_WAPI_KEY		      wapiMskUpdate;
+	u8					lastRxUnicastPN[16];
+	u8					lastTxUnicastPN[16];
+	u8					lastRxMulticastPN[16];
+	u8					lastRxUnicastPNBEQueue[16];
+	u8					lastRxUnicastPNBKQueue[16];
+	u8					lastRxUnicastPNVIQueue[16];
+	u8					lastRxUnicastPNVOQueue[16];
+	bool					bSetkeyOk;
+	bool					bAuthenticateInProgress;
+	bool					bAuthenticatorInUpdata;
+}RT_WAPI_STA_INFO,*PRT_WAPI_STA_INFO;
+
+//Added for HW wapi en/decryption
+typedef struct _RT_WAPI_CAM_ENTRY{
+	//RT_LIST_ENTRY		list;
+	u8			IsUsed;
+	u8			entry_idx;//for cam entry
+	u8			keyidx;	// 0 or 1,new or old key
+	u8			PeerMacAddr[6];
+	u8			type;	//should be 110,wapi
+}RT_WAPI_CAM_ENTRY,*PRT_WAPI_CAM_ENTRY;
+
+typedef struct _RT_WAPI_T
+{
+//BKID
+	RT_WAPI_BKID		wapiBKID[WAPI_MAX_BKID_NUM];
+	struct list_head		wapiBKIDIdleList;
+	struct list_head  		wapiBKIDStoreList;
+//Key for Tx Multicast/Broadcast
+	RT_WAPI_KEY		      wapiTxMsk;
+
+//sec related
+	u8				lastTxMulticastPN[16];
+//STA list
+	RT_WAPI_STA_INFO	wapiSta[WAPI_MAX_STAINFO_NUM];
+	struct list_head		wapiSTAIdleList;
+	struct list_head		wapiSTAUsedList;
+//
+	bool				bWapiEnable;
+
+//store WAPI IE
+	u8				wapiIE[256];
+	u8				wapiIELength;
+	bool				bWapiPSK;
+//last sequece number for wai packet
+	u16				wapiSeqnumAndFragNum;
+	int extra_prefix_len;
+	int extra_postfix_len;
+
+	RT_WAPI_CAM_ENTRY	wapiCamEntry[WAPI_CAM_ENTRY_NUM];
+}RT_WAPI_T,*PRT_WAPI_T;
+
+typedef struct _WLAN_HEADER_WAPI_EXTENSION
+{
+    u8      KeyIdx;
+    u8      Reserved;
+    u8      PN[16];
+} WLAN_HEADER_WAPI_EXTENSION, *PWLAN_HEADER_WAPI_EXTENSION;
+
+u32 WapiComparePN(u8 *PN1, u8 *PN2);
+
+
+void rtw_wapi_init(_adapter *padapter);
+
+void rtw_wapi_free(_adapter *padapter);
+
+void rtw_wapi_disable_tx(_adapter *padapter);
+
+u8 rtw_wapi_is_wai_packet(_adapter* padapter,u8 *pkt_data);
+
+void rtw_wapi_update_info(_adapter *padapter, union recv_frame *precv_frame);
+
+u8 rtw_wapi_check_for_drop(_adapter *padapter, union recv_frame *precv_frame);
+
+void rtw_build_probe_resp_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
+
+void rtw_build_beacon_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
+
+void rtw_build_assoc_req_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
+
+void rtw_wapi_on_assoc_ok(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+
+void rtw_wapi_return_one_sta_info(_adapter *padapter, u8 *MacAddr);
+
+void rtw_wapi_return_all_sta_info(_adapter *padapter);
+
+void rtw_wapi_clear_cam_entry(_adapter *padapter, u8 *pMacAddr);
+
+void rtw_wapi_clear_all_cam_entry(_adapter *padapter);
+
+void rtw_wapi_set_key(_adapter *padapter, RT_WAPI_KEY *pWapiKey, RT_WAPI_STA_INFO *pWapiSta, u8 bGroupKey, u8 bUseDefaultKey);
+
+int rtw_wapi_create_event_send(_adapter *padapter, u8 EventId, u8 *MacAddr, u8 *Buff, u16 BufLen);
+
+u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe);
+
+u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe);
+
+void rtw_wapi_get_iv(_adapter *padapter, u8*pRA, u8*IV);
+
+u8 WapiIncreasePN(u8 *PN, u8 AddCount);
+
+bool rtw_wapi_drop_for_key_absent(_adapter *padapter,u8 *pRA);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_wifi_regd.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_wifi_regd.h
new file mode 100644
index 000000000..ef0ab3877
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_wifi_regd.h
@@ -0,0 +1,26 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2010  Realtek Corporation.
+ *
+ *****************************************************************************/
+
+#ifndef __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__
+
+struct country_code_to_enum_rd {
+	u16 countrycode;
+	const char *iso_name;
+};
+
+enum country_code_type_t {
+	COUNTRY_CODE_USER = 0,
+
+	/*add new channel plan above this line */
+	COUNTRY_CODE_MAX
+};
+
+void rtw_regd_init(struct wiphy *wiphy);
+void rtw_reg_notify_by_driver(struct wiphy *wiphy);
+
+#endif /* __RTW_WIFI_REGD_H__ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/rtw_xmit.h b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_xmit.h
new file mode 100644
index 000000000..2617b110b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/rtw_xmit.h
@@ -0,0 +1,865 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_XMIT_H_
+#define _RTW_XMIT_H_
+
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+#ifdef CONFIG_TX_AGGREGATION
+#define MAX_XMITBUF_SZ	(20480)	// 20k
+//#define SDIO_TX_AGG_MAX	5
+#else
+#define MAX_XMITBUF_SZ (1664)
+#define SDIO_TX_AGG_MAX	1
+#endif
+
+#if defined CONFIG_SDIO_HCI
+#define NR_XMITBUFF	(16)
+#endif
+#if defined(CONFIG_GSPI_HCI)
+#define NR_XMITBUFF	(128)
+#endif
+
+#elif defined (CONFIG_USB_HCI)
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+	#if defined(CONFIG_PLATFORM_ARM_SUNxI) || defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I) || defined(CONFIG_PLATFORM_ARM_SUN8I) || defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
+		#define MAX_XMITBUF_SZ (12288)  //12k 1536*8
+	#elif defined (CONFIG_PLATFORM_MSTAR)
+		#define MAX_XMITBUF_SZ	7680	// 7.5k
+	#else
+	#define MAX_XMITBUF_SZ	(20480)	// 20k
+	#endif
+#else
+#define MAX_XMITBUF_SZ	(2048)
+#endif
+
+#ifdef CONFIG_SINGLE_XMIT_BUF
+#define NR_XMITBUFF	(1)
+#else
+#define NR_XMITBUFF	(4)
+#endif //CONFIG_SINGLE_XMIT_BUF
+#elif defined (CONFIG_PCI_HCI)
+#define MAX_XMITBUF_SZ	(1664)
+#define NR_XMITBUFF	(128)
+#endif
+
+#ifdef PLATFORM_OS_CE
+#define XMITBUF_ALIGN_SZ 4
+#else
+#ifdef CONFIG_PCI_HCI
+#define XMITBUF_ALIGN_SZ 4
+#else
+#ifdef USB_XMITBUF_ALIGN_SZ
+#define XMITBUF_ALIGN_SZ (USB_XMITBUF_ALIGN_SZ)
+#else
+#define XMITBUF_ALIGN_SZ 512
+#endif
+#endif
+#endif
+
+// xmit extension buff defination
+#define MAX_XMIT_EXTBUF_SZ	(1536)
+
+#ifdef CONFIG_SINGLE_XMIT_BUF
+#define NR_XMIT_EXTBUFF	(1)
+#else
+#define NR_XMIT_EXTBUFF	(32)
+#endif
+
+#ifdef CONFIG_RTL8812A
+#define MAX_CMDBUF_SZ	(512*12)
+#else
+#define MAX_CMDBUF_SZ	(5120)	//(4096)
+#endif
+
+#define MAX_NUMBLKS		(1)
+
+#define XMIT_VO_QUEUE (0)
+#define XMIT_VI_QUEUE (1)
+#define XMIT_BE_QUEUE (2)
+#define XMIT_BK_QUEUE (3)
+
+#define VO_QUEUE_INX		0
+#define VI_QUEUE_INX		1
+#define BE_QUEUE_INX		2
+#define BK_QUEUE_INX		3
+#define BCN_QUEUE_INX		4
+#define MGT_QUEUE_INX		5
+#define HIGH_QUEUE_INX		6
+#define TXCMD_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#ifdef CONFIG_PCI_HCI
+//#define TXDESC_NUM						64
+#define TXDESC_NUM						128
+#define TXDESC_NUM_BE_QUEUE			128
+#endif
+
+#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+#define HWXMIT_ENTRY	4
+
+// For Buffer Descriptor ring architecture
+#ifdef BUF_DESC_ARCH
+#if defined(CONFIG_RTL8192E)
+#define TX_BUFFER_SEG_NUM	1 /* 0:2 seg, 1: 4 seg, 2: 8 seg. */
+#elif defined(CONFIG_RTL8814A)
+#define TX_BUFFER_SEG_NUM	1 /* 0:2 seg, 1: 4 seg, 2: 8 seg. */
+#endif
+#endif
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8703B) || defined(CONFIG_RTL8188F)
+#define TXDESC_SIZE 40
+#else
+#define TXDESC_SIZE 32 /* old IC (ex: 8188E) */
+#endif
+
+#ifdef CONFIG_TX_EARLY_MODE
+#define EARLY_MODE_INFO_SIZE	8
+#endif
+
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+#define TXDESC_OFFSET TXDESC_SIZE
+#endif
+
+#ifdef CONFIG_USB_HCI
+#ifdef USB_PACKET_OFFSET_SZ
+#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
+#else
+#define PACKET_OFFSET_SZ (8)
+#endif
+#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
+#endif
+
+#ifdef CONFIG_PCI_HCI
+#if defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A)
+/* this section is defined for buffer descriptor ring architecture */
+#define TX_WIFI_INFO_SIZE (TXDESC_SIZE) /* it may add 802.11 hdr or others... */
+/* tx desc and payload are in the same buf */
+#define TXDESC_OFFSET (TX_WIFI_INFO_SIZE)
+#else
+/* tx desc and payload are NOT in the same buf */
+#define TXDESC_OFFSET (0)
+/* 8188ee/8723be/8812ae/8821ae has extra PCI DMA info in tx desc */
+#define TX_DESC_NEXT_DESC_OFFSET	(TXDESC_SIZE + 8)
+#endif
+#endif /* CONFIG_PCI_HCI */
+
+enum TXDESC_SC{
+	SC_DONT_CARE = 0x00,
+	SC_UPPER= 0x01,
+	SC_LOWER=0x02,
+	SC_DUPLICATE=0x03
+};
+
+#ifdef CONFIG_PCI_HCI
+#define TXDESC_64_BYTES
+#elif defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8188F)
+#define TXDESC_40_BYTES
+#endif
+
+#if (defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8814A)) && defined(CONFIG_PCI_HCI) /* 8192ee or 8814ae */
+//8192EE_TODO
+struct tx_desc
+{
+	unsigned int txdw0;
+	unsigned int txdw1;
+	unsigned int txdw2;
+	unsigned int txdw3;
+	unsigned int txdw4;
+	unsigned int txdw5;
+	unsigned int txdw6;
+	unsigned int txdw7;
+};
+#else
+struct tx_desc
+{
+	unsigned int txdw0;
+	unsigned int txdw1;
+	unsigned int txdw2;
+	unsigned int txdw3;
+	unsigned int txdw4;
+	unsigned int txdw5;
+	unsigned int txdw6;
+	unsigned int txdw7;
+
+#if defined(TXDESC_40_BYTES) || defined(TXDESC_64_BYTES)
+	unsigned int txdw8;
+	unsigned int txdw9;
+#endif // TXDESC_40_BYTES
+
+#ifdef TXDESC_64_BYTES
+	unsigned int txdw10;
+	unsigned int txdw11;
+
+	// 2008/05/15 MH Because PCIE HW memory R/W 4K limit. And now,  our descriptor
+	// size is 40 bytes. If you use more than 102 descriptor( 103*40>4096), HW will execute
+	// memoryR/W CRC error. And then all DMA fetch will fail. We must decrease descriptor
+	// number or enlarge descriptor size as 64 bytes.
+	unsigned int txdw12;
+	unsigned int txdw13;
+	unsigned int txdw14;
+	unsigned int txdw15;
+#endif
+};
+#endif
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];
+};
+
+#ifdef CONFIG_PCI_HCI
+#define PCI_MAX_TX_QUEUE_COUNT	8
+
+struct rtw_tx_ring {
+	unsigned char	qid;
+	struct tx_desc	*desc;
+	dma_addr_t	dma;
+	unsigned int	idx;
+	unsigned int	entries;
+	_queue		queue;
+	u32		qlen;
+};
+#endif
+
+struct	hw_xmit	{
+	//_lock xmit_lock;
+	//_list	pending;
+	_queue *sta_queue;
+	//struct hw_txqueue *phwtxqueue;
+	//sint	txcmdcnt;
+	int	accnt;
+};
+
+#if 0
+struct pkt_attrib
+{
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+	u16	ether_type;
+	int	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
+	int	pkt_hdrlen;	//the original 802.3 pkt header len
+	int	hdrlen;		//the WLAN Header Len
+	int	nr_frags;
+	int	last_txcmdsz;
+	int	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	u8	iv[8];
+	int	iv_len;
+	u8	icv[8];
+	int	icv_len;
+	int	priority;
+	int	ack_policy;
+	int	mac_id;
+	int	vcs_mode;	//virtual carrier sense method
+
+	u8 	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+
+	u8	key_idx;
+
+	u8	qos_en;
+	u8	ht_en;
+	u8	raid;//rate adpative id
+	u8	bwmode;
+	u8	ch_offset;//PRIME_CHNL_OFFSET
+	u8	sgi;//short GI
+	u8	ampdu_en;//tx ampdu enable
+	u8	mdata;//more data bit
+	u8	eosp;
+
+	u8	triggered;//for ap mode handling Power Saving sta
+
+	u32	qsel;
+	u16	seqnum;
+
+	struct sta_info * psta;
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	u8	hw_tcp_csum;
+#endif
+};
+#else
+//reduce size
+struct pkt_attrib
+{
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+	u16	ether_type;
+	u16	seqnum;
+	u8 	hw_ssn_sel;	//for HW_SEQ0,1,2,3
+	u16	pkt_hdrlen;	//the original 802.3 pkt header len
+	u16	hdrlen;		//the WLAN Header Len
+	u32	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
+	u32	last_txcmdsz;
+	u8	nr_frags;
+	u8	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	u8	iv_len;
+	u8	icv_len;
+	u8	iv[18];
+	u8	icv[16];
+	u8	priority;
+	u8	ack_policy;
+	u8	mac_id;
+	u8	vcs_mode;	//virtual carrier sense method
+	u8 	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+	u8	key_idx;
+	u8	qos_en;
+	u8	ht_en;
+	u8	raid;//rate adpative id
+	u8	bwmode;
+	u8	ch_offset;//PRIME_CHNL_OFFSET
+	u8	sgi;//short GI
+	u8	ampdu_en;//tx ampdu enable
+	u8	ampdu_spacing; //ampdu_min_spacing for peer sta's rx
+	u8	mdata;//more data bit
+	u8	pctrl;//per packet txdesc control enable
+	u8	triggered;//for ap mode handling Power Saving sta
+	u8	qsel;
+	u8	order;//order bit
+	u8	eosp;
+	u8	rate;
+	u8	intel_proxim;
+	u8 	retry_ctrl;
+	u8   mbssid;
+	u8	ldpc;
+	u8	stbc;
+	struct sta_info * psta;
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	u8	hw_tcp_csum;
+#endif
+
+	u8 rtsen;
+	u8 cts2self;
+	union Keytype	dot11tkiptxmickey;
+	//union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;
+
+#ifdef CONFIG_TDLS
+	u8 direct_link;
+	struct sta_info *ptdls_sta;
+#endif //CONFIG_TDLS
+	u8 key_type;
+
+	u8 icmp_pkt;
+
+#ifdef CONFIG_BEAMFORMING
+	u16 txbf_p_aid;/*beamforming Partial_AID*/
+	u16 txbf_g_id;/*beamforming Group ID*/
+ #endif
+
+};
+#endif
+
+#define WLANHDR_OFFSET	64
+
+#define NULL_FRAMETAG		(0x0)
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+
+#define MP_FRAMETAG		0x07
+
+#define TXAGG_FRAMETAG 	0x08
+
+enum {
+	XMITBUF_DATA = 0,
+	XMITBUF_MGNT = 1,
+	XMITBUF_CMD = 2,
+};
+
+bool rtw_xmit_ac_blocked(_adapter *adapter);
+
+struct  submit_ctx{
+	u32 submit_time; /* */
+	u32 timeout_ms; /* <0: not synchronous, 0: wait forever, >0: up to ms waiting */
+	int status; /* status for operation */
+#ifdef PLATFORM_LINUX
+	struct completion done;
+#endif
+};
+
+enum {
+	RTW_SCTX_SUBMITTED = -1,
+	RTW_SCTX_DONE_SUCCESS = 0,
+	RTW_SCTX_DONE_UNKNOWN,
+	RTW_SCTX_DONE_TIMEOUT,
+	RTW_SCTX_DONE_BUF_ALLOC,
+	RTW_SCTX_DONE_BUF_FREE,
+	RTW_SCTX_DONE_WRITE_PORT_ERR,
+	RTW_SCTX_DONE_TX_DESC_NA,
+	RTW_SCTX_DONE_TX_DENY,
+	RTW_SCTX_DONE_CCX_PKT_FAIL,
+	RTW_SCTX_DONE_DRV_STOP,
+	RTW_SCTX_DONE_DEV_REMOVE,
+	RTW_SCTX_DONE_CMD_ERROR,
+};
+
+
+void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms);
+int rtw_sctx_wait(struct submit_ctx *sctx, const char *msg);
+void rtw_sctx_done_err(struct submit_ctx **sctx, int status);
+void rtw_sctx_done(struct submit_ctx **sctx);
+
+struct xmit_buf
+{
+	_list	list;
+
+	_adapter *padapter;
+
+	u8 *pallocated_buf;
+
+	u8 *pbuf;
+
+	void *priv_data;
+
+	u16 buf_tag; // 0: Normal xmitbuf, 1: extension xmitbuf, 2:cmd xmitbuf
+	u16 flags;
+	u32 alloc_sz;
+
+	u32  len;
+
+	struct submit_ctx *sctx;
+
+#ifdef CONFIG_USB_HCI
+
+	//u32 sz[8];
+	u32	ff_hwaddr;
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)
+	PURB	pxmit_urb[8];
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PIRP		pxmit_irp[8];
+#endif
+
+#ifdef PLATFORM_OS_CE
+	USB_TRANSFER	usb_transfer_write_port;
+#endif
+
+	u8 bpending[8];
+
+	sint last[8];
+
+#endif
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	u32 ff_hwaddr;
+	u8	pg_num;
+	u8	agg_num;
+#ifdef PLATFORM_OS_XP
+	PMDL pxmitbuf_mdl;
+	PIRP  pxmitbuf_irp;
+	PSDBUS_REQUEST_PACKET pxmitbuf_sdrp;
+#endif
+#endif
+
+#ifdef CONFIG_PCI_HCI
+	struct tx_desc *desc;
+#endif
+
+#if defined(DBG_XMIT_BUF )|| defined(DBG_XMIT_BUF_EXT)
+	u8 no;
+#endif
+
+};
+
+
+struct xmit_frame
+{
+	_list	list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int	frame_tag;
+
+	_adapter *padapter;
+
+	u8	*buf_addr;
+
+	struct xmit_buf *pxmitbuf;
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	u8	pg_num;
+	u8	agg_num;
+#endif
+
+#ifdef CONFIG_USB_HCI
+#ifdef CONFIG_USB_TX_AGGREGATION
+	u8	agg_num;
+#endif
+	s8	pkt_offset;
+#endif
+
+#ifdef CONFIG_XMIT_ACK
+	u8 ack_report;
+#endif
+
+	u8 *alloc_addr; /* the actual address this xmitframe allocated */
+	u8 ext_tag; /* 0:data, 1:mgmt */
+
+};
+
+struct tx_servq {
+	_list	tx_pending;
+	_queue	sta_pending;
+	int qcnt;
+};
+
+
+struct sta_xmit_priv
+{
+	_lock	lock;
+	sint	option;
+	sint	apsd_setting;	//When bit mask is on, the associated edca queue supports APSD.
+
+
+	//struct tx_servq blk_q[MAX_NUMBLKS];
+	struct tx_servq	be_q;			//priority == 0,3
+	struct tx_servq	bk_q;			//priority == 1,2
+	struct tx_servq	vi_q;			//priority == 4,5
+	struct tx_servq	vo_q;			//priority == 6,7
+	_list 	legacy_dz;
+	_list  apsd;
+
+	u16 txseq_tid[16];
+
+	//uint	sta_tx_bytes;
+	//u64	sta_tx_pkts;
+	//uint	sta_tx_fail;
+
+
+};
+
+
+struct	hw_txqueue	{
+	volatile sint	head;
+	volatile sint	tail;
+	volatile sint 	free_sz;	//in units of 64 bytes
+	volatile sint      free_cmdsz;
+	volatile sint	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	sint	ac_tag;
+};
+
+struct agg_pkt_info{
+	u16 offset;
+	u16 pkt_len;
+};
+
+enum cmdbuf_type {
+	CMDBUF_BEACON = 0x00,
+	CMDBUF_RSVD,
+	CMDBUF_MAX
+};
+
+u8 rtw_get_hwseq_no(_adapter *padapter);
+
+struct	xmit_priv	{
+
+	_lock	lock;
+
+	_sema	xmit_sema;
+	_sema	terminate_xmitthread_sema;
+
+	//_queue	blk_strms[MAX_NUMBLKS];
+	_queue	be_pending;
+	_queue	bk_pending;
+	_queue	vi_pending;
+	_queue	vo_pending;
+	_queue	bm_pending;
+
+	//_queue	legacy_dz_queue;
+	//_queue	apsd_queue;
+
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+	_queue	free_xmit_queue;
+
+	//uint mapping_addr;
+	//uint pkt_sz;
+
+	u8 *xframe_ext_alloc_addr;
+	u8 *xframe_ext;
+	uint free_xframe_ext_cnt;
+	_queue free_xframe_ext_queue;
+
+	//struct	hw_txqueue	be_txqueue;
+	//struct	hw_txqueue	bk_txqueue;
+	//struct	hw_txqueue	vi_txqueue;
+	//struct	hw_txqueue	vo_txqueue;
+	//struct	hw_txqueue	bmc_txqueue;
+
+	uint	frag_len;
+
+	_adapter	*adapter;
+
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	//u16  rts_thresh;
+
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u64	last_tx_pkts;
+
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+
+	u8	wmm_para_seq[4];//sequence for wmm ac parameter strength from large to small. it's value is 0->vo, 1->vi, 2->be, 3->bk.
+
+#ifdef CONFIG_USB_HCI
+	_sema	tx_retevt;//all tx return event;
+	u8		txirp_cnt;//
+
+#ifdef PLATFORM_OS_CE
+	USB_TRANSFER	usb_transfer_write_port;
+//	USB_TRANSFER	usb_transfer_write_mem;
+#endif
+#ifdef PLATFORM_LINUX
+	struct tasklet_struct xmit_tasklet;
+#endif
+#ifdef PLATFORM_FREEBSD
+	struct task xmit_tasklet;
+#endif
+	//per AC pending irp
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+
+#endif
+
+#ifdef CONFIG_PCI_HCI
+	// Tx
+	struct rtw_tx_ring	tx_ring[PCI_MAX_TX_QUEUE_COUNT];
+	int	txringcount[PCI_MAX_TX_QUEUE_COUNT];
+	u8 	beaconDMAing;		//flag of indicating beacon is transmiting to HW by DMA
+#ifdef PLATFORM_LINUX
+	struct tasklet_struct xmit_tasklet;
+#endif
+#endif
+
+#if defined (CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+#ifdef CONFIG_SDIO_TX_TASKLET
+	#ifdef PLATFORM_LINUX
+	struct tasklet_struct xmit_tasklet;
+	#endif /* PLATFORM_LINUX */
+#else
+	_thread_hdl_	SdioXmitThread;
+	_sema		SdioXmitSema;
+	_sema		SdioXmitTerminateSema;
+#endif /* CONFIG_SDIO_TX_TASKLET */
+#endif /* CONFIG_SDIO_HCI */
+
+	_queue free_xmitbuf_queue;
+	_queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;
+
+	_queue free_xmit_extbuf_queue;
+	u8 *pallocated_xmit_extbuf;
+	u8 *pxmit_extbuf;
+	uint free_xmit_extbuf_cnt;
+
+	struct xmit_buf	pcmd_xmitbuf[CMDBUF_MAX];
+	u8   hw_ssn_seq_no;//mapping to REG_HW_SEQ 0,1,2,3
+	u16	nqos_ssn;
+	#ifdef CONFIG_TX_EARLY_MODE
+
+	#ifdef CONFIG_SDIO_HCI
+	#define MAX_AGG_PKT_NUM 20
+	#else
+	#define MAX_AGG_PKT_NUM 256 //Max tx ampdu coounts
+	#endif
+
+	struct agg_pkt_info agg_pkt[MAX_AGG_PKT_NUM];
+	#endif
+
+#ifdef CONFIG_XMIT_ACK
+	int	ack_tx;
+	_mutex ack_tx_mutex;
+	struct submit_ctx ack_tx_ops;
+	u8 seq_no;
+#endif
+	_lock lock_sctx;
+};
+
+extern struct xmit_frame *__rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv,
+		enum cmdbuf_type buf_type);
+#define rtw_alloc_cmdxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_RSVD)
+#if defined(CONFIG_RTL8192E) && defined(CONFIG_PCI_HCI)
+extern struct xmit_frame *__rtw_alloc_cmdxmitframe_8192ee(struct xmit_priv *pxmitpriv,
+		enum cmdbuf_type buf_type);
+#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe_8192ee(p, CMDBUF_BEACON)
+#else
+#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_BEACON)
+#endif
+
+extern struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+extern struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+void rtw_count_tx_stats(_adapter *padapter, struct xmit_frame *pxmitframe, int sz);
+extern void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len);
+static s32 update_attrib_sec_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);
+static void update_attrib_phy_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);
+extern s32 rtw_make_wlanhdr(_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
+extern s32 rtw_put_snap(u8 *data, u16 h_proto);
+
+extern struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+struct xmit_frame *rtw_alloc_xmitframe_ext(struct xmit_priv *pxmitpriv);
+struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue);
+struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta, sint up, u8 *ac);
+extern s32 rtw_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, sint entry);
+
+extern s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
+#define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
+extern s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
+#ifdef CONFIG_IEEE80211W
+extern s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
+#endif //CONFIG_IEEE80211W
+#ifdef CONFIG_TDLS
+extern struct tdls_txmgmt *ptxmgmt;
+s32 rtw_xmit_tdls_coalesce(_adapter *padapter, struct xmit_frame *pxmitframe, struct tdls_txmgmt *ptxmgmt);
+s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+#endif
+s32 _rtw_init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
+void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+
+
+s32 rtw_txframes_pending(_adapter *padapter);
+s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
+void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry);
+
+
+s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
+void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv);
+
+
+void rtw_alloc_hwxmits(_adapter *padapter);
+void rtw_free_hwxmits(_adapter *padapter);
+
+s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev);
+
+s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
+bool xmitframe_hiq_filter(struct xmit_frame *xmitframe);
+#if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
+sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
+void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
+void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
+void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta);
+#endif
+
+u8	query_ra_short_GI(struct sta_info *psta);
+
+u8	qos_acm(u8 acm_mask, u8 priority);
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+void	enqueue_pending_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+void enqueue_pending_xmitbuf_to_head(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+struct xmit_buf*	dequeue_pending_xmitbuf(struct xmit_priv *pxmitpriv);
+struct xmit_buf*	dequeue_pending_xmitbuf_under_survey(struct xmit_priv *pxmitpriv);
+sint	check_pending_xmitbuf(struct xmit_priv *pxmitpriv);
+thread_return	rtw_xmit_thread(thread_context context);
+#endif
+
+static void do_queue_select(_adapter * padapter, struct pkt_attrib * pattrib);
+u32	rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe);
+
+#ifdef CONFIG_XMIT_ACK
+int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms);
+void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status);
+#endif //CONFIG_XMIT_ACK
+
+
+//include after declaring struct xmit_buf, in order to avoid warning
+#include <xmit_osdep.h>
+
+#endif	//_RTL871X_XMIT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sdio_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_hal.h
new file mode 100644
index 000000000..c0ca55744
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_hal.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_HAL_H__
+#define __SDIO_HAL_H__
+
+
+extern u8 sd_hal_bus_init(PADAPTER padapter);
+extern u8 sd_hal_bus_deinit(PADAPTER padapter);
+
+u8 sd_int_isr(PADAPTER padapter);
+void sd_int_dpc(PADAPTER padapter);
+u8 rtw_set_hal_ops(_adapter *padapter);
+
+#ifdef CONFIG_RTL8188E
+void rtl8188es_set_hal_ops(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8723B
+void rtl8723bs_set_hal_ops(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8821A
+void rtl8821as_set_hal_ops(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8192E
+void rtl8192es_set_hal_ops(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8703B
+void rtl8703bs_set_hal_ops(PADAPTER padapter);
+#endif
+
+#ifdef CONFIG_RTL8188F
+void rtl8188fs_set_hal_ops(PADAPTER padapter);
+#endif
+
+#endif //__SDIO_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops.h b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops.h
new file mode 100644
index 000000000..9b4cd57e9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops.h
@@ -0,0 +1,140 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OPS_H__
+#define __SDIO_OPS_H__
+
+
+#ifdef PLATFORM_LINUX
+#include <sdio_ops_linux.h>
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef PLATFORM_OS_XP
+#include <sdio_ops_xp.h>
+struct async_context
+{
+	PMDL pmdl;
+	PSDBUS_REQUEST_PACKET sdrp;
+	unsigned char* r_buf;
+	unsigned char* padapter;
+};
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <sdio_ops_ce.h>
+#endif
+
+#endif // PLATFORM_WINDOWS
+
+
+extern void sdio_set_intf_ops(_adapter *padapter,struct _io_ops *pops);
+
+//extern void sdio_func1cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+//extern void sdio_func1cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+extern u8 SdioLocalCmd52Read1Byte(PADAPTER padapter, u32 addr);
+extern void SdioLocalCmd52Write1Byte(PADAPTER padapter, u32 addr, u8 v);
+extern s32 _sdio_local_read(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
+extern s32 sdio_local_read(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
+extern s32 _sdio_local_write(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
+extern s32 sdio_local_write(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
+
+u32 _sdio_read32(PADAPTER padapter, u32 addr);
+s32 _sdio_write32(PADAPTER padapter, u32 addr, u32 val);
+
+extern void sd_int_hdl(PADAPTER padapter);
+extern u8 CheckIPSStatus(PADAPTER padapter);
+
+#ifdef CONFIG_RTL8188E
+extern void InitInterrupt8188ESdio(PADAPTER padapter);
+extern void EnableInterrupt8188ESdio(PADAPTER padapter);
+extern void DisableInterrupt8188ESdio(PADAPTER padapter);
+extern void UpdateInterruptMask8188ESdio(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
+extern u8 HalQueryTxBufferStatus8189ESdio(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8189ESdio(PADAPTER padapter);
+extern void ClearInterrupt8188ESdio(PADAPTER padapter);
+#endif // CONFIG_RTL8188E
+
+#ifdef CONFIG_RTL8821A
+extern void InitInterrupt8821AS(PADAPTER padapter);
+extern void EnableInterrupt8821AS(PADAPTER padapter);
+extern void DisableInterrupt8821AS(PADAPTER padapter);
+extern u8 HalQueryTxBufferStatus8821AS(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8821ASdio(PADAPTER padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void ClearInterrupt8821AS(PADAPTER padapter);
+#endif /* defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) */
+#endif /* CONFIG_RTL8821A */
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+extern u8 RecvOnePkt(PADAPTER padapter, u32 size);
+#endif // CONFIG_WOWLAN
+#ifdef CONFIG_RTL8723B
+extern void InitInterrupt8723BSdio(PADAPTER padapter);
+extern void InitSysInterrupt8723BSdio(PADAPTER padapter);
+extern void EnableInterrupt8723BSdio(PADAPTER padapter);
+extern void DisableInterrupt8723BSdio(PADAPTER padapter);
+extern u8 HalQueryTxBufferStatus8723BSdio(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8723BSdio(PADAPTER padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+extern void DisableInterruptButCpwm28723BSdio(PADAPTER padapter);
+extern void ClearInterrupt8723BSdio(PADAPTER padapter);
+#endif //CONFIG_WOWLAN
+#endif
+
+
+#ifdef CONFIG_RTL8192E
+extern void InitInterrupt8192ESdio(PADAPTER padapter);
+extern void EnableInterrupt8192ESdio(PADAPTER padapter);
+extern void DisableInterrupt8192ESdio(PADAPTER padapter);
+extern void UpdateInterruptMask8192ESdio(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
+extern u8 HalQueryTxBufferStatus8192ESdio(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8192ESdio(PADAPTER padapter);
+extern void ClearInterrupt8192ESdio(PADAPTER padapter);
+#endif // CONFIG_RTL8192E
+
+#ifdef CONFIG_RTL8703B
+extern void InitInterrupt8703BSdio(PADAPTER padapter);
+extern void InitSysInterrupt8703BSdio(PADAPTER padapter);
+extern void EnableInterrupt8703BSdio(PADAPTER padapter);
+extern void DisableInterrupt8703BSdio(PADAPTER padapter);
+extern u8 HalQueryTxBufferStatus8703BSdio(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8703BSdio(PADAPTER padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+extern void DisableInterruptButCpwm28703BSdio(PADAPTER padapter);
+extern void ClearInterrupt8703BSdio(PADAPTER padapter);
+#endif //CONFIG_WOWLAN
+#endif
+
+#ifdef CONFIG_RTL8188F
+extern void InitInterrupt8188FSdio(PADAPTER padapter);
+extern void InitSysInterrupt8188FSdio(PADAPTER padapter);
+extern void EnableInterrupt8188FSdio(PADAPTER padapter);
+extern void DisableInterrupt8188FSdio(PADAPTER padapter);
+extern u8 HalQueryTxBufferStatus8188FSdio(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8188FSdio(PADAPTER padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+extern void DisableInterruptButCpwm28188FSdio(PADAPTER padapter);
+extern void ClearInterrupt8188FSdio(PADAPTER padapter);
+#endif /* defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) */
+#endif
+
+#endif // !__SDIO_OPS_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_ce.h b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_ce.h
new file mode 100644
index 000000000..638c920bf
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_ce.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _SDIO_OPS_WINCE_H_
+#define _SDIO_OPS_WINCE_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_OS_CE
+
+
+extern u8 sdbus_cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w_ce(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+
+
+uint sdbus_read_blocks_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+extern uint sdbus_read_bytes_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern u8 sdbus_func1cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_func1cmd52w_ce(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_linux.h b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_linux.h
new file mode 100644
index 000000000..d9d8553d9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_linux.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OPS_LINUX_H__
+#define __SDIO_OPS_LINUX_H__
+
+#define SDIO_ERR_VAL8	0xEA
+#define SDIO_ERR_VAL16	0xEAEA
+#define SDIO_ERR_VAL32	0xEAEAEAEA
+
+u8 sd_f0_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
+void sd_f0_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err);
+
+s32 _sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
+s32 _sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
+s32 sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
+s32 sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
+
+u8 _sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
+u8 sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
+u16 sd_read16(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
+u32 _sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
+u32 sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
+s32 _sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
+s32 sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
+void sd_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err);
+void sd_write16(struct intf_hdl *pintfhdl, u32 addr, u16 v, s32 *err);
+void _sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err);
+void sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err);
+s32 _sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
+s32 sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
+
+
+void rtw_sdio_set_irq_thd(struct dvobj_priv *dvobj, _thread_hdl_ thd_hdl);
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_xp.h b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_xp.h
new file mode 100644
index 000000000..ef883fce6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_ops_xp.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _SDIO_OPS_XP_H_
+#define _SDIO_OPS_XP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_OS_XP
+
+
+extern u8 sdbus_cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w_xp(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+
+
+uint sdbus_read_blocks_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+extern uint sdbus_read_bytes_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern u8 sdbus_func1cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_func1cmd52w_xp(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sdio_osintf.h b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_osintf.h
new file mode 100644
index 000000000..29cdb5ae4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sdio_osintf.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OSINTF_H__
+#define __SDIO_OSINTF_H__
+
+
+
+u8 sd_hal_bus_init(PADAPTER padapter);
+u8 sd_hal_bus_deinit(PADAPTER padapter);
+void sd_c2h_hdl(PADAPTER padapter);
+
+#ifdef PLATFORM_OS_CE
+extern NDIS_STATUS ce_sd_get_dev_hdl(PADAPTER padapter);
+SD_API_STATUS ce_sd_int_callback(SD_DEVICE_HANDLE hDevice, PADAPTER padapter);
+extern void sd_setup_irs(PADAPTER padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/sta_info.h b/drivers/net/wireless/realtek/rtl8723cs/include/sta_info.h
new file mode 100644
index 000000000..8dbaed613
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/sta_info.h
@@ -0,0 +1,589 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+
+#define IBSS_START_MAC_ID	2
+#define NUM_STA MACID_NUM_SW_LIMIT
+#define NUM_ACL 16
+
+#ifdef CONFIG_TDLS
+#define MAX_ALLOWED_TDLS_STA_NUM	4
+#endif
+
+enum sta_info_update_type {
+	STA_INFO_UPDATE_NONE = 0,
+	STA_INFO_UPDATE_BW = BIT(0),
+	STA_INFO_UPDATE_RATE = BIT(1),
+	STA_INFO_UPDATE_PROTECTION_MODE = BIT(2),
+	STA_INFO_UPDATE_CAP = BIT(3),
+	STA_INFO_UPDATE_HT_CAP = BIT(4),
+	STA_INFO_UPDATE_VHT_CAP = BIT(5),
+	STA_INFO_UPDATE_ALL = STA_INFO_UPDATE_BW
+							|STA_INFO_UPDATE_RATE
+							|STA_INFO_UPDATE_PROTECTION_MODE
+							|STA_INFO_UPDATE_CAP
+							|STA_INFO_UPDATE_HT_CAP
+							|STA_INFO_UPDATE_VHT_CAP,
+	STA_INFO_UPDATE_MAX
+};
+
+//if mode ==0, then the sta is allowed once the addr is hit.
+//if mode ==1, then the sta is rejected once the addr is non-hit.
+struct rtw_wlan_acl_node {
+        _list		        list;
+        u8       addr[ETH_ALEN];
+        u8       valid;
+};
+
+//mode=0, disable
+//mode=1, accept unless in deny list
+//mode=2, deny unless in accept list
+struct wlan_acl_pool {
+	int mode;
+	int num;
+	struct rtw_wlan_acl_node aclnode[NUM_ACL];
+	_queue	acl_node_q;
+};
+
+typedef struct _RSSI_STA{
+	s32	UndecoratedSmoothedPWDB;
+	s32	UndecoratedSmoothedCCK;
+	s32	UndecoratedSmoothedOFDM;
+	u32	OFDM_pkt;
+	u64	PacketMap;
+	u8	ValidBit;
+}RSSI_STA, *PRSSI_STA;
+
+struct	stainfo_stats	{
+
+	u64 rx_mgnt_pkts;
+		u64 rx_beacon_pkts;
+		u64 rx_probereq_pkts;
+		u64 rx_probersp_pkts;
+		u64 rx_probersp_bm_pkts;
+		u64 rx_probersp_uo_pkts;
+	u64 rx_ctrl_pkts;
+	u64 rx_data_pkts;
+	u64 rx_data_qos_pkts[TID_NUM];
+	u64	last_rx_mgnt_pkts;
+		u64 last_rx_beacon_pkts;
+		u64 last_rx_probereq_pkts;
+		u64 last_rx_probersp_pkts;
+		u64 last_rx_probersp_bm_pkts;
+		u64 last_rx_probersp_uo_pkts;
+	u64	last_rx_ctrl_pkts;
+	u64	last_rx_data_pkts;
+	u64 last_rx_data_qos_pkts[TID_NUM];
+#ifdef CONFIG_TDLS
+	u64 rx_tdls_disc_rsp_pkts;
+	u64 last_rx_tdls_disc_rsp_pkts;
+#endif
+	u64	rx_bytes;
+	u64	rx_drops;
+
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64  tx_drops;
+};
+
+#ifndef DBG_SESSION_TRACKER
+#define DBG_SESSION_TRACKER 0
+#endif
+
+/* session tracker status */
+#define ST_STATUS_NONE		0
+#define ST_STATUS_CHECK		BIT0
+#define ST_STATUS_ESTABLISH	BIT1
+#define ST_STATUS_EXPIRE	BIT2
+
+#define ST_EXPIRE_MS (10 * 1000)
+
+struct session_tracker {
+	_list list; /* session_tracker_queue */
+	u32 local_naddr;
+	u16 local_port;
+	u32 remote_naddr;
+	u16 remote_port;
+	u32 set_time;
+	u8 status;
+};
+
+/* session tracker cmd */
+#define ST_CMD_ADD 0
+#define ST_CMD_DEL 1
+#define ST_CMD_CHK 2
+
+struct st_cmd_parm {
+	u8 cmd;
+	struct sta_info *sta;
+	u32 local_naddr; /* TODO: IPV6 */
+	u16 local_port;
+	u32 remote_naddr; /* TODO: IPV6 */
+	u16 remote_port;
+};
+
+typedef bool (*st_match_rule)(_adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+
+struct st_register {
+	u8 s_proto;
+	st_match_rule rule;
+};
+
+#define SESSION_TRACKER_REG_ID_WFD 0
+#define SESSION_TRACKER_REG_ID_NUM 1
+
+struct st_ctl_t {
+	struct st_register reg[SESSION_TRACKER_REG_ID_NUM];
+	_queue tracker_q;
+};
+
+void rtw_st_ctl_init(struct st_ctl_t *st_ctl);
+void rtw_st_ctl_deinit(struct st_ctl_t *st_ctl);
+void rtw_st_ctl_register(struct st_ctl_t *st_ctl, u8 st_reg_id, struct st_register *reg);
+void rtw_st_ctl_unregister(struct st_ctl_t *st_ctl, u8 st_reg_id);
+bool rtw_st_ctl_chk_reg_s_proto(struct st_ctl_t *st_ctl, u8 s_proto);
+bool rtw_st_ctl_chk_reg_rule(struct st_ctl_t *st_ctl, _adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+void dump_st_ctl(void *sel, struct st_ctl_t *st_ctl);
+
+#ifdef CONFIG_TDLS
+struct TDLS_PeerKey {
+	u8 kck[16]; /* TPK-KCK */
+	u8 tk[16]; /* TPK-TK; only CCMP will be used */
+} ;
+#endif //CONFIG_TDLS
+
+struct sta_info {
+
+	_lock	lock;
+	_list	list; //free_sta_queue
+	_list	hash_list; //sta_hash
+	//_list asoc_list; //20061114
+	//_list sleep_list;//sleep_q
+	//_list wakeup_list;//wakeup_q
+	_adapter *padapter;
+
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+
+	_queue sleep_q;
+	unsigned int sleepq_len;
+
+	uint state;
+	uint aid;
+	uint mac_id;
+	uint qos_option;
+	u8	hwaddr[ETH_ALEN];
+	u16 hwseq;
+	u8	ra_rpt_linked;
+
+	uint	ieee8021x_blocked;	//0: allowed, 1:blocked
+	uint	dot118021XPrivacy; //aes, tkip...
+	union Keytype	dot11tkiptxmickey;
+	union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;
+	union pn48		dot11txpn;			// PN48 used for Unicast xmit
+#ifdef CONFIG_GTK_OL
+	u8 kek[RTW_KEK_LEN];
+	u8 kck[RTW_KCK_LEN];
+	u8 replay_ctr[RTW_REPLAY_CTR_LEN];
+#endif //CONFIG_GTK_OL
+#ifdef CONFIG_IEEE80211W
+	union pn48		dot11wtxpn;			// PN48 used for Unicast mgmt xmit.
+	_timer dot11w_expire_timer;
+#endif //CONFIG_IEEE80211W
+	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
+
+
+	u8	bssrateset[16];
+	u32	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+
+	u8	cts2self;
+	u8	rtsen;
+
+	u8	raid;
+	u8 	init_rate;
+	u64	ra_mask;
+	u8	wireless_mode;	// NETWORK_TYPE
+	u8	bw_mode;
+
+	u8	ldpc;
+	u8	stbc;
+
+#ifdef CONFIG_BEAMFORMING
+	u16 txbf_paid;
+	u16 txbf_gid;
+#endif
+
+	struct stainfo_stats sta_stats;
+
+#ifdef CONFIG_TDLS
+	u32	tdls_sta_state;
+	u8	SNonce[32];
+	u8	ANonce[32];
+	u32	TDLS_PeerKey_Lifetime;
+	u16	TPK_count;
+	_timer	TPK_timer;
+	struct TDLS_PeerKey	tpk;
+#ifdef CONFIG_TDLS_CH_SW
+	u16	ch_switch_time;
+	u16	ch_switch_timeout;
+	//u8	option;
+	_timer	ch_sw_timer;
+	_timer	delay_timer;
+#endif
+	_timer handshake_timer;
+	u8 alive_count;
+	_timer	pti_timer;
+	u8	TDLS_RSNIE[20];	/* Save peer's RSNIE, used for sending TDLS_SETUP_RSP */
+#endif /* CONFIG_TDLS */
+
+	//for A-MPDU TX, ADDBA timeout check
+	_timer addba_retry_timer;
+
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl recvreorder_ctrl[TID_NUM];
+	ATOMIC_T continual_no_rx_packet[TID_NUM];
+	//for A-MPDU Tx
+	//unsigned char		ampdu_txen_bitmap;
+	u16	BA_starting_seqctrl[16];
+
+
+#ifdef CONFIG_80211N_HT
+	struct ht_priv	htpriv;
+#endif
+
+#ifdef CONFIG_80211AC_VHT
+	struct vht_priv	vhtpriv;
+#endif
+
+	//Notes:
+	//STA_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO
+	//scan_q: AP CAP/INFO
+
+	//AP_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
+	//sta_info: (AP & STA) CAP/INFO
+
+#ifdef CONFIG_AP_MODE
+
+	_list asoc_list;
+	_list auth_list;
+
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+
+	u16 capability;
+	int flags;
+
+	int dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	int wpa_group_cipher;
+	int wpa2_group_cipher;
+	int wpa_pairwise_cipher;
+	int wpa2_pairwise_cipher;
+
+	u8 bpairwise_key_installed;
+
+#ifdef CONFIG_NATIVEAP_MLME
+	u8 wpa_ie[32];
+
+	u8 nonerp_set;
+	u8 no_short_slot_time_set;
+	u8 no_short_preamble_set;
+	u8 no_ht_gf_set;
+	u8 no_ht_set;
+	u8 ht_20mhz_set;
+	u8 ht_40mhz_intolerant;
+#endif	// CONFIG_NATIVEAP_MLME
+
+#ifdef CONFIG_ATMEL_RC_PATCH
+	u8 flag_atmel_rc;
+#endif
+
+	u8 qos_info;
+
+	u8 max_sp_len;
+	u8 uapsd_bk;//BIT(0): Delivery enabled, BIT(1): Trigger enabled
+	u8 uapsd_be;
+	u8 uapsd_vi;
+	u8 uapsd_vo;
+
+	u8 has_legacy_ac;
+	unsigned int sleepq_ac_len;
+
+#ifdef CONFIG_P2P
+	//p2p priv data
+	u8 is_p2p_device;
+	u8 p2p_status_code;
+
+	//p2p client info
+	u8 dev_addr[ETH_ALEN];
+	//u8 iface_addr[ETH_ALEN];//= hwaddr[ETH_ALEN]
+	u8 dev_cap;
+	u16 config_methods;
+	u8 primary_dev_type[8];
+	u8 num_of_secdev_type;
+	u8 secdev_types_list[32];// 32/8 == 4;
+	u16 dev_name_len;
+	u8 dev_name[32];
+#endif //CONFIG_P2P
+
+#ifdef CONFIG_WFD
+	u8 op_wfd_mode;
+#endif
+
+#ifdef CONFIG_TX_MCAST2UNI
+	u8 under_exist_checking;
+#endif	// CONFIG_TX_MCAST2UNI
+
+	u8 keep_alive_trycnt;
+
+#ifdef CONFIG_AUTO_AP_MODE
+	u8 isrc; //this device is rc
+	u16 pid; // pairing id
+#endif
+
+#endif	// CONFIG_AP_MODE
+
+#ifdef CONFIG_IOCTL_CFG80211
+	u8 *passoc_req;
+	u32 assoc_req_len;
+#endif
+
+	//for DM
+	RSSI_STA	 rssi_stat;
+
+	//ODM_STA_INFO_T
+	// ================ODM Relative Info=======================
+	// Please be care, dont declare too much structure here. It will cost memory * STA support num.
+	//
+	//
+	// 2011/10/20 MH Add for ODM STA info.
+	//
+	// Driver Write
+	u8		bValid;				// record the sta status link or not?
+	//u8		WirelessMode;		//
+	u8		IOTPeer;			// Enum value.	HT_IOT_PEER_E
+	// ODM Write
+	//1 PHY_STATUS_INFO
+	u8		RSSI_Path[4];		//
+	u8		RSSI_Ave;
+	u8		RXEVM[4];
+	u8		RXSNR[4];
+
+	u8		rssi_level;			//for Refresh RA mask
+	// ODM Write
+	//1 TX_INFO (may changed by IC)
+	//TX_INFO_T		pTxInfo;				// Define in IC folder. Move lower layer.
+	//
+	// ================ODM Relative Info=======================
+	//
+
+	/* To store the sequence number of received management frame */
+	u16 RxMgmtFrameSeqNum;
+
+	struct st_ctl_t st_ctl;
+};
+
+#define sta_rx_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts \
+	+ sta->sta_stats.rx_ctrl_pkts \
+	+ sta->sta_stats.rx_data_pkts)
+
+#define sta_last_rx_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts \
+	+ sta->sta_stats.last_rx_ctrl_pkts \
+	+ sta->sta_stats.last_rx_data_pkts)
+
+#define sta_rx_data_pkts(sta) \
+	(sta->sta_stats.rx_data_pkts)
+
+#define sta_rx_data_qos_pkts(sta, i) \
+	(sta->sta_stats.rx_data_qos_pkts[i])
+
+#define sta_last_rx_data_pkts(sta) \
+	(sta->sta_stats.last_rx_data_pkts)
+
+#define sta_last_rx_data_qos_pkts(sta, i) \
+	(sta->sta_stats.last_rx_data_qos_pkts[i])
+
+#define sta_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts)
+
+#define sta_last_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts)
+
+#define sta_rx_beacon_pkts(sta) \
+	(sta->sta_stats.rx_beacon_pkts)
+
+#define sta_last_rx_beacon_pkts(sta) \
+	(sta->sta_stats.last_rx_beacon_pkts)
+
+#define sta_rx_probereq_pkts(sta) \
+	(sta->sta_stats.rx_probereq_pkts)
+
+#define sta_last_rx_probereq_pkts(sta) \
+	(sta->sta_stats.last_rx_probereq_pkts)
+
+#define sta_rx_probersp_pkts(sta) \
+	(sta->sta_stats.rx_probersp_pkts)
+
+#define sta_last_rx_probersp_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_pkts)
+
+#define sta_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.rx_probersp_bm_pkts)
+
+#define sta_last_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_bm_pkts)
+
+#define sta_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.rx_probersp_uo_pkts)
+
+#define sta_last_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_uo_pkts)
+
+#define sta_update_last_rx_pkts(sta) \
+	do { \
+		sta->sta_stats.last_rx_mgnt_pkts = sta->sta_stats.rx_mgnt_pkts; \
+		sta->sta_stats.last_rx_beacon_pkts = sta->sta_stats.rx_beacon_pkts; \
+		sta->sta_stats.last_rx_probereq_pkts = sta->sta_stats.rx_probereq_pkts; \
+		sta->sta_stats.last_rx_probersp_pkts = sta->sta_stats.rx_probersp_pkts; \
+		sta->sta_stats.last_rx_probersp_bm_pkts = sta->sta_stats.rx_probersp_bm_pkts; \
+		sta->sta_stats.last_rx_probersp_uo_pkts = sta->sta_stats.rx_probersp_uo_pkts; \
+		sta->sta_stats.last_rx_ctrl_pkts = sta->sta_stats.rx_ctrl_pkts; \
+		sta->sta_stats.last_rx_data_pkts = sta->sta_stats.rx_data_pkts; \
+	} while(0)
+
+#define STA_RX_PKTS_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts
+
+#define STA_LAST_RX_PKTS_ARG(sta) \
+	sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.last_rx_data_pkts
+
+#define STA_RX_PKTS_DIFF_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts - sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts - sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts -sta->sta_stats.last_rx_data_pkts
+
+#define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"
+
+#ifdef CONFIG_WFD
+#define STA_OP_WFD_MODE(sta) (sta)->op_wfd_mode
+#define STA_SET_OP_WFD_MODE(sta, mode) (sta)->op_wfd_mode = (mode)
+#else
+#define STA_OP_WFD_MODE(sta) 0
+#define STA_SET_OP_WFD_MODE(sta, mode) do {} while (0)
+#endif
+
+struct	sta_priv {
+
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	_queue	free_sta_queue;
+
+	_lock sta_hash_lock;
+	_list   sta_hash[NUM_STA];
+	int asoc_sta_count;
+	_queue sleep_q;
+	_queue wakeup_q;
+
+	_adapter *padapter;
+
+
+#ifdef CONFIG_AP_MODE
+	_list asoc_list;
+	_list auth_list;
+	_lock asoc_list_lock;
+	_lock auth_list_lock;
+	u8 asoc_list_cnt;
+	u8 auth_list_cnt;
+
+	unsigned int auth_to;  //sec, time to expire in authenticating.
+	unsigned int assoc_to; //sec, time to expire before associating.
+	unsigned int expire_to; //sec , time to expire after associated.
+
+	/* pointers to STA info; based on allocated AID or NULL if AID free
+	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
+	 * and so on
+	 */
+	struct sta_info *sta_aid[NUM_STA];
+
+	u16 sta_dz_bitmap;//only support 15 stations, staion aid bitmap for sleeping sta.
+	u16 tim_bitmap;//only support 15 stations, aid=0~15 mapping bit0~bit15
+
+	u16 max_num_sta;
+
+	struct wlan_acl_pool acl_list;
+#endif
+
+#ifdef CONFIG_ATMEL_RC_PATCH
+	u8 atmel_rc_pattern [6];
+#endif
+
+};
+
+
+__inline static u32 wifi_mac_hash(u8 *mac)
+{
+        u32 x;
+
+        x = mac[0];
+        x = (x << 2) ^ mac[1];
+        x = (x << 2) ^ mac[2];
+        x = (x << 2) ^ mac[3];
+        x = (x << 2) ^ mac[4];
+        x = (x << 2) ^ mac[5];
+
+        x ^= x >> 8;
+        x  = x & (NUM_STA - 1);
+
+        return x;
+}
+
+
+extern u32	_rtw_init_sta_priv(struct sta_priv *pstapriv);
+extern u32	_rtw_free_sta_priv(struct sta_priv *pstapriv);
+
+#define stainfo_offset_valid(offset) (offset < NUM_STA && offset >= 0)
+int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta);
+struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset);
+
+extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
+extern u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta);
+extern void rtw_free_all_stainfo(_adapter *padapter);
+extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+extern u32 rtw_init_bcmc_stainfo(_adapter* padapter);
+extern struct sta_info* rtw_get_bcmc_stainfo(_adapter* padapter);
+extern u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr);
+
+#endif //_STA_INFO_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/usb_hal.h b/drivers/net/wireless/realtek/rtl8723cs/include/usb_hal.h
new file mode 100644
index 000000000..0e976853b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/usb_hal.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_HAL_H__
+#define __USB_HAL_H__
+
+int usb_init_recv_priv(_adapter *padapter, u16 ini_in_buf_sz);
+void usb_free_recv_priv (_adapter *padapter, u16 ini_in_buf_sz);
+
+u8 rtw_set_hal_ops(_adapter *padapter);
+
+#ifdef CONFIG_RTL8188E
+void rtl8188eu_set_hal_ops(_adapter * padapter);
+#endif
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
+void rtl8812au_set_hal_ops(_adapter * padapter);
+#endif
+
+#ifdef CONFIG_RTL8192E
+void rtl8192eu_set_hal_ops(_adapter * padapter);
+#endif
+
+
+#ifdef CONFIG_RTL8723B
+void rtl8723bu_set_hal_ops(_adapter * padapter);
+#endif
+
+#ifdef CONFIG_RTL8814A
+void rtl8814au_set_hal_ops(_adapter * padapter);
+#endif /* CONFIG_RTL8814A */
+
+#ifdef CONFIG_RTL8188F
+void rtl8188fu_set_hal_ops(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_RTL8703B
+void rtl8703bu_set_hal_ops(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_INTEL_PROXIM
+extern _adapter  *rtw_usb_get_sw_pointer(void);
+#endif	//CONFIG_INTEL_PROXIM
+#endif //__USB_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/usb_ops.h b/drivers/net/wireless/realtek/rtl8723cs/include/usb_ops.h
new file mode 100644
index 000000000..ea9d432e5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/usb_ops.h
@@ -0,0 +1,148 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+
+#define REALTEK_USB_VENQT_READ		0xC0
+#define REALTEK_USB_VENQT_WRITE	0x40
+#define REALTEK_USB_VENQT_CMD_REQ	0x05
+#define REALTEK_USB_VENQT_CMD_IDX	0x00
+#define REALTEK_USB_IN_INT_EP_IDX	1
+
+enum{
+	VENDOR_WRITE = 0x00,
+	VENDOR_READ = 0x01,
+};
+#define ALIGNMENT_UNIT				16
+#define MAX_VENDOR_REQ_CMD_SIZE	254		//8188cu SIE Support
+#define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
+
+#ifdef PLATFORM_LINUX
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms))
+#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
+	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), (timeout_ms))
+#else
+#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size,timeout_ms) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), \
+		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
+#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
+	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), \
+		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
+#endif
+#include <usb_ops_linux.h>
+#endif //PLATFORM_LINUX
+
+#ifdef CONFIG_RTL8188E
+void rtl8188eu_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8188eu_set_intf_ops(struct _io_ops *pops);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8188eu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+#endif
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
+void rtl8812au_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8812au_set_intf_ops(struct _io_ops *pops);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8812au(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+#endif
+
+#ifdef CONFIG_RTL8814A
+void rtl8814au_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8814au_set_intf_ops(struct _io_ops	*pops);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8814au(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+#endif /* CONFIG_RTL8814 */
+
+#ifdef CONFIG_RTL8192E
+void rtl8192eu_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8192eu_set_intf_ops(struct _io_ops *pops);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8192eu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+
+#endif
+
+#ifdef CONFIG_RTL8188F
+void rtl8188fu_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8188fu_set_intf_ops(struct _io_ops *pops);
+void rtl8188fu_recv_tasklet(void *priv);
+void rtl8188fu_xmit_tasklet(void *priv);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8188fu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+#endif
+
+#ifdef CONFIG_RTL8723B
+void rtl8723bu_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8723bu_set_intf_ops(struct _io_ops *pops);
+void rtl8723bu_recv_tasklet(void *priv);
+void rtl8723bu_xmit_tasklet(void *priv);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8723bu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+#endif
+
+#ifdef CONFIG_RTL8703B
+void rtl8703bu_set_hw_type(struct dvobj_priv *pdvobj);
+void rtl8703bu_set_intf_ops(struct _io_ops *pops);
+void rtl8703bu_recv_tasklet(void *priv);
+void rtl8703bu_xmit_tasklet(void *priv);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8703bu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif /* CONFIG_SUPPORT_USB_INT */
+#endif /* CONFIG_RTL8703B */
+
+enum RTW_USB_SPEED {
+	RTW_USB_SPEED_UNKNOWN	= 0,
+	RTW_USB_SPEED_1_1	= 1,
+	RTW_USB_SPEED_2		= 2,
+	RTW_USB_SPEED_3		= 3,
+};
+
+#define IS_FULL_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_1_1)
+#define IS_HIGH_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_2)
+#define IS_SUPER_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_3)
+
+#define USB_SUPER_SPEED_BULK_SIZE	1024	// usb 3.0
+#define USB_HIGH_SPEED_BULK_SIZE	512		// usb 2.0
+#define USB_FULL_SPEED_BULK_SIZE	64		// usb 1.1
+
+static inline u8 rtw_usb_bulk_size_boundary(_adapter * padapter,int buf_len)
+{
+	u8 rst = _TRUE;
+
+	if (IS_SUPER_SPEED_USB(padapter))
+		rst = (0 == (buf_len) % USB_SUPER_SPEED_BULK_SIZE)?_TRUE:_FALSE;
+	if (IS_HIGH_SPEED_USB(padapter))
+		rst = (0 == (buf_len) % USB_HIGH_SPEED_BULK_SIZE)?_TRUE:_FALSE;
+	else
+		rst = (0 == (buf_len) % USB_FULL_SPEED_BULK_SIZE)?_TRUE:_FALSE;
+	return rst;
+}
+
+
+#endif //__USB_OPS_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/usb_ops_linux.h b/drivers/net/wireless/realtek/rtl8723cs/include/usb_ops_linux.h
new file mode 100644
index 000000000..61d53faa9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/usb_ops_linux.h
@@ -0,0 +1,89 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_LINUX_H__
+#define __USB_OPS_LINUX_H__
+
+#define VENDOR_CMD_MAX_DATA_LEN	254
+#define FW_START_ADDRESS	0x1000
+
+#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10//ms
+#define RTW_USB_CONTROL_MSG_TIMEOUT	500//ms
+
+#define RECV_BULK_IN_ADDR		0x80//assign by drv,not real address
+#define RECV_INT_IN_ADDR		0x81//assign by drv,not real address
+
+#define INTERRUPT_MSG_FORMAT_LEN 60
+
+#if defined(CONFIG_VENDOR_REQ_RETRY) && defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+/* vendor req retry should be in the situation when each vendor req is atomically submitted from others */
+#define MAX_USBCTRL_VENDORREQ_TIMES	10
+#else
+#define MAX_USBCTRL_VENDORREQ_TIMES	1
+#endif
+
+#define RTW_USB_BULKOUT_TIMEOUT	5000//ms
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+#define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
+#define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
+#define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
+#define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
+#define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
+#define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
+#endif
+
+#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
+int usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+int usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+int usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
+
+unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr);
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+
+void usb_read_port_cancel(struct intf_hdl *pintfhdl);
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+void usb_write_port_cancel(struct intf_hdl *pintfhdl);
+
+int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
+int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,
+	u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
+
+u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr);
+u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr);
+u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr);
+int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+void usb_recv_tasklet(void *priv);
+
+#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
+void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs);
+u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/usb_osintf.h b/drivers/net/wireless/realtek/rtl8723cs/include/usb_osintf.h
new file mode 100644
index 000000000..cce469008
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/usb_osintf.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include <usb_vendor_req.h>
+
+#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)
+
+
+u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv, RT_USB_BREQUEST brequest, RT_USB_WVALUE wvalue, u8 windex, void* data, u8 datalen, u8 isdirectionin);
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/usb_vendor_req.h b/drivers/net/wireless/realtek/rtl8723cs/include/usb_vendor_req.h
new file mode 100644
index 000000000..e602841bc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/usb_vendor_req.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+//4	Set/Get Register related wIndex/Data
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON				1
+#define	RT_USB_LDO_OFF				0
+
+//4	Set/Get SYSCLK related	wValue or Data
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+
+typedef enum _RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+} RT_USB_BREQUEST;
+
+
+typedef enum _RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO			=	4,
+	RT_USB_BOOT_TYPE	=	5
+} RT_USB_WVALUE;
+
+
+//BOOLEAN usbvendorrequest(PCE_USB_DEVICE	CEdevice, RT_USB_BREQUEST bRequest, RT_USB_WVALUE wValue, UCHAR wIndex, PVOID Data, UCHAR DataLength, BOOLEAN isDirectionIn);
+//BOOLEAN CEusbGetStatusRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT Index, PVOID Data);
+//BOOLEAN CEusbFeatureRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT FeatureSelector, IN USHORT Index);
+//BOOLEAN CEusbGetDescriptorRequest(PCE_USB_DEVICE CEdevice, IN short urbLength, IN UCHAR DescriptorType, IN UCHAR Index, IN USHORT LanguageId, IN PVOID  TransferBuffer, IN ULONG TransferBufferLength);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/wifi.h b/drivers/net/wireless/realtek/rtl8723cs/include/wifi.h
new file mode 100644
index 000000000..2b2fa3f56
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/wifi.h
@@ -0,0 +1,1397 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+
+#ifdef BIT
+//#error	"BIT define occurred earlier elsewhere!\n"
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_WMM_LEN		24
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+// This value is tested by WiFi 11n Test Plan 5.2.3.
+// This test verifies the WLAN NIC can update the NAV through sending the CTS with large duration.
+#define	WiFiNavUpperUs				30000	// 30 ms
+
+#ifdef GREEN_HILL
+#pragma pack(1)
+#endif
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data
+};
+
+enum WIFI_FRAME_SUBTYPE {
+
+    // below is for mgt frame
+    WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+    WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+    WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+    WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+    WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+    WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+    WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+    WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_ACTION_NOACK = (BIT(7) | BIT(6) | BIT(5) | WIFI_MGT_TYPE),
+
+    // below is for control frame
+    WIFI_NDPA         = (BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+    WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+
+    // below is for data frame
+    WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+    WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+    WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	// WPA reason
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	//belowing are Realtek definition
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+	_RSON_TDLS_TEAR_TOOFAR_			= 25,
+	_RSON_TDLS_TEAR_UN_RSN_			= 26,
+};
+
+/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
+#if 0
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#endif
+/* IEEE 802.11h */
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+#if 0
+/* IEEE 802.11i */
+#define WLAN_REASON_INVALID_IE 13
+#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
+#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
+#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
+#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
+#define WLAN_REASON_AKMP_NOT_VALID 20
+#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
+#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
+#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
+#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
+#endif
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_SEC_DISABLED_			= 5,
+	_STATS_NOT_IN_SAME_BSS_		= 7,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+	_STATS_REFUSED_TEMPORARILY_ = 30,
+	_STATS_DECLINE_REQ_			= 37,
+	_STATS_INVALID_PARAMETERS_	= 38,
+	_STATS_INVALID_RSNIE_			= 72,
+};
+
+/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
+#if 0
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+#endif
+//entended
+/* IEEE 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+/* IEEE 802.11h */
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+/* IEEE 802.11g */
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
+#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
+/* IEEE 802.11w */
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+/* IEEE 802.11i */
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+/* IEEE 802.11r */
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC		= 1,
+	DOMAIN_IC		= 2,
+	DOMAIN_ETSI		= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK		= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1		= 8,
+	DOMAIN_MKK2		= 9,
+	DOMAIN_MKK3		= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while(0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while(0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while(0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while(0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while(0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while(0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while(0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while(0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while(0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while(0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while(0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while(0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while(0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while(0)
+
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf,type)	\
+	do { 	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while(0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+#define SetFrameSubType(pbuf,type) \
+	do {    \
+		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+	} while(0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while(0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while(0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+	} while(0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while(0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+
+#define SetEOSP(pbuf, eosp)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (eosp & 1) << 4); \
+	} while(0)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
+	} while(0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
+	} while(0)
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
+
+#define MacAddr_isBcst(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+)
+
+__inline static int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return _TRUE;
+	else
+		return _FALSE;
+}
+
+__inline static unsigned char * get_ra(unsigned char *pframe)
+{
+	unsigned char 	*ra;
+	ra = GetAddr1Ptr(pframe);
+	return ra;
+}
+__inline static unsigned char * get_ta(unsigned char *pframe)
+{
+	unsigned char 	*ta;
+	ta = GetAddr2Ptr(pframe);
+	return ta;
+}
+
+__inline static unsigned char * get_da(unsigned char *pframe)
+{
+	unsigned char 	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			da = GetAddr3Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			da = GetAddr3Ptr(pframe);
+			break;
+	}
+
+	return da;
+}
+
+
+__inline static unsigned char * get_sa(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			sa = GetAddr4Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+__inline static unsigned char * get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char 	*sa = NULL;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr1Ptr(pframe);
+			break;
+		case 0x03:	// ToDs=1, FromDs=1
+			sa = GetAddr1Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+
+__inline static int IsFrameTypeCtrl(unsigned char *pframe)
+{
+	if(WIFI_CTRL_TYPE == GetFrameType(pframe))
+		return _TRUE;
+	else
+		return _FALSE;
+}
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_		2
+#define _PRE_ALLOCMEM_			1
+#define _PRE_ALLOCHDR_			3
+#define _PRE_ALLOCLLCHDR_		4
+#define _PRE_ALLOCICVHDR_		5
+#define _PRE_ALLOCMICHDR_		6
+
+#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A)?16:10)
+#define _ACKCTSLNG_				14	//14 bytes long, including crclng
+#define _CRCLNG_				4
+
+#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+#define _PUBLIC_ACTION_IE_OFFSET_	8
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define _SSID_IE_				0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_				3
+#define _TIM_IE_					5
+#define _IBSS_PARA_IE_			6
+#define _COUNTRY_IE_			7
+#define _CHLGETXT_IE_			16
+#define _SUPPORTED_CH_IE_		36
+#define _CH_SWTICH_ANNOUNCE_	37	//Secondary Channel Offset
+#define _RSN_IE_2_				48
+#define _SSN_IE_1_					221
+#define _ERPINFO_IE_			42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_			45
+#define _FTIE_						55
+#define _TIMEOUT_ITVL_IE_			56
+#define _SRC_IE_				59
+#define _HT_EXTRA_INFO_IE_			61
+#define _HT_ADD_INFO_IE_			61 //_HT_EXTRA_INFO_IE_
+#define _WAPI_IE_					68
+
+
+//#define EID_BSSCoexistence			72 // 20/40 BSS Coexistence
+//#define EID_BSSIntolerantChlReport	73
+#define _RIC_Descriptor_IE_			75
+#ifdef CONFIG_IEEE80211W
+#define _MME_IE_					76 //802.11w Management MIC element
+#endif //CONFIG_IEEE80211W
+#define _LINK_ID_IE_					101
+#define _CH_SWITCH_TIMING_		104
+#define _PTI_BUFFER_STATUS_		106
+#define _EXT_CAP_IE_				127
+#define _VENDOR_SPECIFIC_IE_		221
+
+#define	_RESERVED47_				47
+
+typedef	enum _ELEMENT_ID{
+	EID_SsId					= 0, /* service set identifier (0:32) */
+	EID_SupRates				= 1, /* supported rates (1:8) */
+	EID_FHParms				= 2, /* FH parameter set (5) */
+	EID_DSParms				= 3, /* DS parameter set (1) */
+	EID_CFParms				= 4, /* CF parameter set (6) */
+	EID_Tim						= 5, /* Traffic Information Map (4:254) */
+	EID_IbssParms				= 6, /* IBSS parameter set (2) */
+	EID_Country					= 7, /* */
+
+	// Form 7.3.2: Information elements in 802.11E/D13.0, page 46.
+	EID_QBSSLoad				= 11,
+	EID_EDCAParms				= 12,
+	EID_TSpec					= 13,
+	EID_TClass					= 14,
+	EID_Schedule				= 15,
+	//
+
+	EID_Ctext					= 16, /* challenge text*/
+	EID_POWER_CONSTRAINT		= 32, /* Power Constraint*/
+
+	//vivi for WIFITest, 802.11h AP, 20100427
+	// 2010/12/26 MH The definition we can declare always!!
+	EID_PowerCap				= 33,
+	EID_SupportedChannels		= 36,
+	EID_ChlSwitchAnnounce		= 37,
+
+	EID_MeasureRequest			= 38, // Measurement Request
+	EID_MeasureReport			= 39, // Measurement Report
+
+	EID_ERPInfo 				= 42,
+
+	// Form 7.3.2: Information elements in 802.11E/D13.0, page 46.
+	EID_TSDelay				= 43,
+	EID_TCLASProc				= 44,
+	EID_HTCapability			= 45,
+	EID_QoSCap					= 46,
+	//
+
+	EID_WPA2					= 48,
+	EID_ExtSupRates			= 50,
+
+	EID_FTIE					= 55, // Defined in 802.11r
+	EID_Timeout				= 56, // Defined in 802.11r
+
+	EID_SupRegulatory			= 59, // Supported Requlatory Classes 802.11y
+	EID_HTInfo 					= 61,
+	EID_SecondaryChnlOffset		= 62,
+
+	EID_BSSCoexistence			= 72, // 20/40 BSS Coexistence
+	EID_BSSIntolerantChlReport	= 73,
+	EID_OBSS					= 74, // Overlapping BSS Scan Parameters
+
+	EID_LinkIdentifier			= 101, // Defined in 802.11z
+	EID_WakeupSchedule		= 102, // Defined in 802.11z
+	EID_ChnlSwitchTimeing		= 104, // Defined in 802.11z
+	EID_PTIControl				= 105, // Defined in 802.11z
+	EID_PUBufferStatus			= 106, // Defined in 802.11z
+
+	EID_EXTCapability			= 127, // Extended Capabilities
+	// From S19:Aironet IE and S21:AP IP address IE in CCX v1.13, p16 and p18.
+	EID_Aironet					= 133, // 0x85: Aironet Element for Cisco CCX
+	EID_CiscoIP					= 149, // 0x95: IP Address IE for Cisco CCX
+
+	EID_CellPwr					= 150, // 0x96: Cell Power Limit IE. Ref. 0x96.
+
+	EID_CCKM    					= 156,
+
+	EID_Vendor					= 221, // 0xDD: Vendor Specific
+
+	EID_WAPI					= 68,
+	EID_VHTCapability 			= 191, // Based on 802.11ac D2.0
+	EID_VHTOperation 			= 192, // Based on 802.11ac D2.0
+	EID_AID						= 197, /* Based on 802.11ac D4.0 */
+	EID_OpModeNotification		= 199, // Based on 802.11ac D3.0
+}ELEMENT_ID, *PELEMENT_ID;
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+#define cap_PBCC	BIT(6)
+#define cap_ChAgility	BIT(7)
+#define cap_SpecMgmt	BIT(8)
+#define cap_QoS	BIT(9)
+#define cap_ShortSlot	BIT(10)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1		// WPA
+#define _IEEE8021X_PSK_			2		// WPA with pre-shared key
+
+/*
+#define _NO_PRIVACY_			0
+#define _WEP_40_PRIVACY_		1
+#define _TKIP_PRIVACY_			2
+#define _WRAP_PRIVACY_			3
+#define _CCMP_PRIVACY_			4
+#define _WEP_104_PRIVACY_		5
+#define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
+*/
+
+#ifdef CONFIG_IEEE80211W
+#define _MME_IE_LENGTH_  18
+#endif //CONFIG_IEEE80211W
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  // for WMM STA
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n
+------------------------------------------------------------------------------*/
+
+//#ifdef CONFIG_80211N_HT
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while(0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define ACT_CAT_VENDOR				0x7F/* 127 */
+
+/**
+ * struct rtw_ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+ #if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8712FW)
+struct rtw_ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __attribute__((packed));
+ #endif
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+
+ #if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8712FW) || defined(PLATFORM_FREEBSD)
+
+
+
+ /**
+ * struct rtw_ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+
+struct rtw_ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __attribute__ ((packed));
+
+/**
+ * struct rtw_ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} __attribute__ ((packed));
+
+
+struct HT_caps_element
+{
+	union
+	{
+		struct
+		{
+			unsigned short	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			unsigned short	HT_ext_caps;
+			unsigned int	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	}u;
+} __attribute__ ((packed));
+
+struct HT_info_element
+{
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+}  __attribute__ ((packed));
+
+struct AC_param
+{
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	unsigned short	TXOP_limit;
+}  __attribute__ ((packed));
+
+struct WMM_para_element
+{
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+}  __attribute__ ((packed));
+
+struct ADDBA_request
+{
+	unsigned char		dialog_token;
+	unsigned short	BA_para_set;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+}  __attribute__ ((packed));
+
+
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct rtw_ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+};
+
+
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+};
+
+struct HT_caps_element
+{
+	union
+	{
+		struct
+		{
+			unsigned short	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			unsigned short	HT_ext_caps;
+			unsigned int	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	};
+};
+
+struct HT_info_element
+{
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+};
+
+struct AC_param
+{
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	unsigned short	TXOP_limit;
+};
+
+struct WMM_para_element
+{
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+};
+
+struct ADDBA_request
+{
+	unsigned char		dialog_token;
+	unsigned short	BA_para_set;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+};
+
+
+#pragma pack()
+
+#endif
+
+typedef enum _HT_CAP_AMPDU_FACTOR {
+	MAX_AMPDU_FACTOR_8K		= 0,
+	MAX_AMPDU_FACTOR_16K	= 1,
+	MAX_AMPDU_FACTOR_32K	= 2,
+	MAX_AMPDU_FACTOR_64K	= 3,
+}HT_CAP_AMPDU_FACTOR;
+
+
+typedef enum _HT_CAP_AMPDU_DENSITY {
+	AMPDU_DENSITY_VALUE_0 = 0 , /* For no restriction */
+	AMPDU_DENSITY_VALUE_1 = 1 , /* For 1/4 us */
+	AMPDU_DENSITY_VALUE_2 = 2 , /* For 1/2 us */
+	AMPDU_DENSITY_VALUE_3 = 3 , /* For 1 us */
+	AMPDU_DENSITY_VALUE_4 = 4 , /* For 2 us */
+	AMPDU_DENSITY_VALUE_5 = 5 , /* For 4 us */
+	AMPDU_DENSITY_VALUE_6 = 6 , /* For 8 us */
+	AMPDU_DENSITY_VALUE_7 = 7 , /* For 16 us */
+} HT_CAP_AMPDU_DENSITY;
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_LDPC_CODING		0x0001
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_RX_STBC_1R		0x0100
+#define IEEE80211_HT_CAP_RX_STBC_2R		0x0200
+#define IEEE80211_HT_CAP_RX_STBC_3R		0x0300
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+#define RTW_IEEE80211_HT_CAP_40MHZ_INTOLERANT	((u16) BIT(14))
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT capability TXBF capability */
+#define IEEE80211_HT_CAP_TXBF_RX_NDP		0x00000008
+#define IEEE80211_HT_CAP_TXBF_TX_NDP		0x00000010
+#define IEEE80211_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP	0x00000400
+
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE	 	0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE 		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW 		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF_HT 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+
+#define OP_MODE_PURE                    0
+#define OP_MODE_MAY_BE_LEGACY_STAS      1
+#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
+#define OP_MODE_MIXED                   3
+
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((u8) BIT(2))
+#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
+#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((u8) BIT(4))
+#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((u8) BIT(5))
+
+#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
+		((u16) (0x0001 | 0x0002))
+#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
+#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((u8) BIT(2))
+#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((u8) BIT(3))
+#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((u8) BIT(4))
+
+#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
+#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
+#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
+#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
+#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
+#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))
+
+
+
+//#endif
+
+//	===============WPS Section===============
+//	For WPSv1.0
+#define WPSOUI							0x0050f204
+//	WPS attribute ID
+#define WPS_ATTR_VER1					0x104A
+#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
+#define WPS_ATTR_RESP_TYPE			0x103B
+#define WPS_ATTR_UUID_E				0x1047
+#define WPS_ATTR_MANUFACTURER		0x1021
+#define WPS_ATTR_MODEL_NAME			0x1023
+#define WPS_ATTR_MODEL_NUMBER		0x1024
+#define WPS_ATTR_SERIAL_NUMBER		0x1042
+#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
+#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
+#define WPS_ATTR_DEVICE_NAME			0x1011
+#define WPS_ATTR_CONF_METHOD			0x1008
+#define WPS_ATTR_RF_BANDS				0x103C
+#define WPS_ATTR_DEVICE_PWID			0x1012
+#define WPS_ATTR_REQUEST_TYPE			0x103A
+#define WPS_ATTR_ASSOCIATION_STATE	0x1002
+#define WPS_ATTR_CONFIG_ERROR			0x1009
+#define WPS_ATTR_VENDOR_EXT			0x1049
+#define WPS_ATTR_SELECTED_REGISTRAR	0x1041
+
+//	Value of WPS attribute "WPS_ATTR_DEVICE_NAME
+#define WPS_MAX_DEVICE_NAME_LEN		32
+
+//	Value of WPS Request Type Attribute
+#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
+#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
+#define WPS_REQ_TYPE_REGISTRAR					0x02
+#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
+
+//	Value of WPS Response Type Attribute
+#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
+#define WPS_RESPONSE_TYPE_8021X		0x01
+#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
+#define WPS_RESPONSE_TYPE_AP			0x03
+
+//	Value of WPS WiFi Simple Configuration State Attribute
+#define WPS_WSC_STATE_NOT_CONFIG	0x01
+#define WPS_WSC_STATE_CONFIG			0x02
+
+//	Value of WPS Version Attribute
+#define WPS_VERSION_1					0x10
+
+//	Value of WPS Configuration Method Attribute
+#define WPS_CONFIG_METHOD_FLASH		0x0001
+#define WPS_CONFIG_METHOD_ETHERNET	0x0002
+#define WPS_CONFIG_METHOD_LABEL		0x0004
+#define WPS_CONFIG_METHOD_DISPLAY	0x0008
+#define WPS_CONFIG_METHOD_E_NFC		0x0010
+#define WPS_CONFIG_METHOD_I_NFC		0x0020
+#define WPS_CONFIG_METHOD_NFC		0x0040
+#define WPS_CONFIG_METHOD_PBC		0x0080
+#define WPS_CONFIG_METHOD_KEYPAD	0x0100
+#define WPS_CONFIG_METHOD_VPBC		0x0280
+#define WPS_CONFIG_METHOD_PPBC		0x0480
+#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
+#define WPS_CONFIG_METHOD_PDISPLAY	0x4008
+
+//	Value of Category ID of WPS Primary Device Type Attribute
+#define WPS_PDT_CID_DISPLAYS			0x0007
+#define WPS_PDT_CID_MULIT_MEDIA		0x0008
+#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
+
+//	Value of Sub Category ID of WPS Primary Device Type Attribute
+#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
+#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
+
+//	Value of Device Password ID
+#define WPS_DPID_PIN					0x0000
+#define WPS_DPID_USER_SPEC			0x0001
+#define WPS_DPID_MACHINE_SPEC			0x0002
+#define WPS_DPID_REKEY					0x0003
+#define WPS_DPID_PBC					0x0004
+#define WPS_DPID_REGISTRAR_SPEC		0x0005
+
+//	Value of WPS RF Bands Attribute
+#define WPS_RF_BANDS_2_4_GHZ		0x01
+#define WPS_RF_BANDS_5_GHZ		0x02
+
+//	Value of WPS Association State Attribute
+#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
+#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
+#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
+#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
+#define WPS_ASSOC_STATE_IP_FAILURE				0x04
+
+//	=====================P2P Section=====================
+//	For P2P
+#define	P2POUI							0x506F9A09
+
+//	P2P Attribute ID
+#define	P2P_ATTR_STATUS					0x00
+#define	P2P_ATTR_MINOR_REASON_CODE		0x01
+#define	P2P_ATTR_CAPABILITY				0x02
+#define	P2P_ATTR_DEVICE_ID				0x03
+#define	P2P_ATTR_GO_INTENT				0x04
+#define	P2P_ATTR_CONF_TIMEOUT			0x05
+#define	P2P_ATTR_LISTEN_CH				0x06
+#define	P2P_ATTR_GROUP_BSSID				0x07
+#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
+#define	P2P_ATTR_INTENTED_IF_ADDR		0x09
+#define	P2P_ATTR_MANAGEABILITY			0x0A
+#define	P2P_ATTR_CH_LIST					0x0B
+#define	P2P_ATTR_NOA						0x0C
+#define	P2P_ATTR_DEVICE_INFO				0x0D
+#define	P2P_ATTR_GROUP_INFO				0x0E
+#define	P2P_ATTR_GROUP_ID					0x0F
+#define	P2P_ATTR_INTERFACE				0x10
+#define	P2P_ATTR_OPERATING_CH			0x11
+#define	P2P_ATTR_INVITATION_FLAGS		0x12
+
+//	Value of Status Attribute
+#define	P2P_STATUS_SUCCESS						0x00
+#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
+#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
+#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
+#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
+#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
+#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
+#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
+#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
+#define	P2P_STATUS_FAIL_USER_REJECT				0x0B
+
+//	Value of Inviation Flags Attribute
+#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
+
+#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
+									P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
+									P2P_DEVCAP_CONCURRENT_OPERATION | \
+									P2P_DEVCAP_INVITATION_PROC)
+
+#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
+
+//	Value of Device Capability Bitmap
+#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
+#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
+#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
+#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
+#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
+#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
+
+//	Value of Group Capability Bitmap
+#define	P2P_GRPCAP_GO							BIT(0)
+#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
+#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
+#define	P2P_GRPCAP_INTRABSS					BIT(3)
+#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
+#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
+#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
+
+//	P2P Public Action Frame ( Management Frame )
+#define	P2P_PUB_ACTION_ACTION				0x09
+
+//	P2P Public Action Frame Type
+#define	P2P_GO_NEGO_REQ						0
+#define	P2P_GO_NEGO_RESP						1
+#define	P2P_GO_NEGO_CONF						2
+#define	P2P_INVIT_REQ							3
+#define	P2P_INVIT_RESP							4
+#define	P2P_DEVDISC_REQ						5
+#define	P2P_DEVDISC_RESP						6
+#define	P2P_PROVISION_DISC_REQ				7
+#define	P2P_PROVISION_DISC_RESP				8
+
+//	P2P Action Frame Type
+#define	P2P_NOTICE_OF_ABSENCE	0
+#define	P2P_PRESENCE_REQUEST		1
+#define	P2P_PRESENCE_RESPONSE	2
+#define	P2P_GO_DISC_REQUEST		3
+
+
+#define	P2P_MAX_PERSISTENT_GROUP_NUM		10
+
+#define	P2P_PROVISIONING_SCAN_CNT			3
+
+#define	P2P_WILDCARD_SSID_LEN				7
+
+#define	P2P_FINDPHASE_EX_NONE				0	// default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase
+#define	P2P_FINDPHASE_EX_FULL				1	// used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase
+#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
+#define	P2P_FINDPHASE_EX_MAX					4
+#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
+
+#define	P2P_PROVISION_TIMEOUT				5000	//	5 seconds timeout for sending the provision discovery request
+#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	//	3 seconds timeout for sending the provision discovery request under concurrent mode
+#define	P2P_GO_NEGO_TIMEOUT					5000	//	5 seconds timeout for receiving the group negotation response
+#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	//	3 seconds timeout for sending the negotiation request under concurrent mode
+#define	P2P_TX_PRESCAN_TIMEOUT				100		//	100ms
+#define	P2P_INVITE_TIMEOUT					5000	//	5 seconds timeout for sending the invitation request
+#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	//	3 seconds timeout for sending the invitation request under concurrent mode
+#define	P2P_RESET_SCAN_CH						25000	//	25 seconds timeout to reset the scan channel ( based on channel plan )
+#define	P2P_MAX_INTENT						15
+
+#define	P2P_MAX_NOA_NUM						2
+
+//	WPS Configuration Method
+#define	WPS_CM_NONE							0x0000
+#define	WPS_CM_LABEL							0x0004
+#define	WPS_CM_DISPLYA						0x0008
+#define	WPS_CM_EXTERNAL_NFC_TOKEN			0x0010
+#define	WPS_CM_INTEGRATED_NFC_TOKEN		0x0020
+#define	WPS_CM_NFC_INTERFACE					0x0040
+#define	WPS_CM_PUSH_BUTTON					0x0080
+#define	WPS_CM_KEYPAD						0x0100
+#define	WPS_CM_SW_PUHS_BUTTON				0x0280
+#define	WPS_CM_HW_PUHS_BUTTON				0x0480
+#define	WPS_CM_SW_DISPLAY_PIN				0x2008
+#define	WPS_CM_LCD_DISPLAY_PIN				0x4008
+
+enum P2P_ROLE {
+	P2P_ROLE_DISABLE = 0,
+	P2P_ROLE_DEVICE = 1,
+	P2P_ROLE_CLIENT = 2,
+	P2P_ROLE_GO = 3
+};
+
+enum P2P_STATE {
+	P2P_STATE_NONE = 0,							//	P2P disable
+	P2P_STATE_IDLE = 1,								//	P2P had enabled and do nothing
+	P2P_STATE_LISTEN = 2,							//	In pure listen state
+	P2P_STATE_SCAN = 3,							//	In scan phase
+	P2P_STATE_FIND_PHASE_LISTEN = 4,				//	In the listen state of find phase
+	P2P_STATE_FIND_PHASE_SEARCH = 5,				//	In the search state of find phase
+	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			//	In P2P provisioning discovery
+	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
+	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
+	P2P_STATE_GONEGO_ING = 9,						//	Doing the group owner negoitation handshake
+	P2P_STATE_GONEGO_OK = 10,						//	finish the group negoitation handshake with success
+	P2P_STATE_GONEGO_FAIL = 11,					//	finish the group negoitation handshake with failure
+	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		//	receiving the P2P Inviation request and match with the profile.
+	P2P_STATE_PROVISIONING_ING = 13,				//	Doing the P2P WPS
+	P2P_STATE_PROVISIONING_DONE = 14,			//	Finish the P2P WPS
+	P2P_STATE_TX_INVITE_REQ = 15,					//	Transmit the P2P Invitation request
+	P2P_STATE_RX_INVITE_RESP_OK = 16,				//	Receiving the P2P Invitation response
+	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	//	receiving the P2P Inviation request and dismatch with the profile.
+	P2P_STATE_RECV_INVITE_REQ_GO = 18,			//	receiving the P2P Inviation request and this wifi is GO.
+	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			//	receiving the P2P Inviation request to join an existing P2P Group.
+	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			//	recveing the P2P Inviation response with failure
+	P2P_STATE_RX_INFOR_NOREADY = 21, 			// receiving p2p negoitation response with information is not available
+	P2P_STATE_TX_INFOR_NOREADY = 22, 			// sending p2p negoitation response with information is not available
+};
+
+enum P2P_WPSINFO {
+	P2P_NO_WPSINFO						= 0,
+	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
+	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
+	P2P_GOT_WPSINFO_PBC					= 3,
+};
+
+#define	P2P_PRIVATE_IOCTL_SET_LEN		64
+
+enum P2P_PROTO_WK_ID
+{
+	P2P_FIND_PHASE_WK = 0,
+	P2P_RESTORE_STATE_WK = 1,
+	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
+	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
+	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
+	P2P_AP_P2P_CH_SWITCH_PROCESS_WK =5,
+	P2P_RO_CH_WK = 6,
+};
+
+#ifdef CONFIG_P2P_PS
+enum P2P_PS_STATE
+{
+	P2P_PS_DISABLE = 0,
+	P2P_PS_ENABLE = 1,
+	P2P_PS_SCAN = 2,
+	P2P_PS_SCAN_DONE = 3,
+	P2P_PS_ALLSTASLEEP = 4, // for P2P GO
+};
+
+enum P2P_PS_MODE
+{
+	P2P_PS_NONE = 0,
+	P2P_PS_CTWINDOW = 1,
+	P2P_PS_NOA	 = 2,
+	P2P_PS_MIX = 3, // CTWindow and NoA
+};
+#endif // CONFIG_P2P_PS
+
+//	=====================WFD Section=====================
+//	For Wi-Fi Display
+#define	WFD_ATTR_DEVICE_INFO			0x00
+#define	WFD_ATTR_ASSOC_BSSID			0x01
+#define	WFD_ATTR_COUPLED_SINK_INFO	0x06
+#define	WFD_ATTR_LOCAL_IP_ADDR		0x08
+#define	WFD_ATTR_SESSION_INFO		0x09
+#define	WFD_ATTR_ALTER_MAC			0x0a
+
+//	For WFD Device Information Attribute
+#define	WFD_DEVINFO_SOURCE					0x0000
+#define	WFD_DEVINFO_PSINK					0x0001
+#define	WFD_DEVINFO_SSINK					0x0002
+#define	WFD_DEVINFO_DUAL 					0x0003
+
+#define	WFD_DEVINFO_SESSION_AVAIL			0x0010
+#define	WFD_DEVINFO_WSD						0x0040
+#define	WFD_DEVINFO_PC_TDLS					0x0080
+#define	WFD_DEVINFO_HDCP_SUPPORT			0x0100
+
+#ifdef  CONFIG_TX_MCAST2UNI
+#define IP_MCAST_MAC(mac)		((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
+#define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
+#endif	// CONFIG_TX_MCAST2UNI
+
+#ifdef CONFIG_IOCTL_CFG80211
+/* Regulatroy Domain */
+struct regd_pair_mapping {
+	u16 reg_dmnenum;
+	u16 reg_5ghz_ctl;
+	u16 reg_2ghz_ctl;
+};
+
+struct rtw_regulatory {
+	char alpha2[2];
+	u16 country_code;
+	u16 max_power_level;
+	u32 tp_scale;
+	u16 current_rd;
+	u16 current_rd_ext;
+	int16_t power_limit;
+	struct regd_pair_mapping *regpair;
+};
+#endif
+
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef IW_AUTH_WAPI_VERSION_1
+#define IW_AUTH_WAPI_VERSION_1		0x00000008
+#endif
+#ifndef IW_AUTH_KEY_MGMT_WAPI_PSK
+#define IW_AUTH_KEY_MGMT_WAPI_PSK	0x04
+#endif
+#ifndef IW_AUTH_WAPI_ENABLED
+#define IW_AUTH_WAPI_ENABLED		0x20
+#endif
+#ifndef IW_ENCODE_ALG_SM4
+#define IW_ENCODE_ALG_SM4			0x20
+#endif
+#endif
+
+#endif // _WIFI_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/wlan_bssdef.h b/drivers/net/wireless/realtek/rtl8723cs/include/wlan_bssdef.h
new file mode 100644
index 000000000..d1e735b57
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/wlan_bssdef.h
@@ -0,0 +1,748 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+
+#define MAX_IE_SZ	768
+
+
+#ifdef PLATFORM_LINUX
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
+typedef long    		NDIS_802_11_RSSI;           // in dBm
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+
+typedef  ULONG  NDIS_802_11_KEY_INDEX;
+typedef unsigned long long NDIS_802_11_KEY_RSC;
+
+
+typedef struct _NDIS_802_11_SSID
+{
+  ULONG  SsidLength;
+  UCHAR  Ssid[32];
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+    Ndis802_11FH,
+    Ndis802_11DS,
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+    ULONG           Length;             // Length of structure
+    ULONG           HopPattern;         // As defined by 802.11, MSB set
+    ULONG           HopSet;             // to one if non-802.11
+    ULONG           DwellTime;          // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.
+*/
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+    ULONG           Length;             // Length of structure
+    ULONG           BeaconPeriod;       // units are Kusec
+    ULONG           ATIMWindow;         // units are Kusec
+	ULONG           DSConfig;           /* channel number */
+    NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+    Ndis802_11IBSS,
+    Ndis802_11Infrastructure,
+    Ndis802_11AutoUnknown,
+    Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
+	Ndis802_11APMode,
+	Ndis802_11Monitor,
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+
+
+
+
+typedef struct _NDIS_802_11_FIXED_IEs
+{
+  UCHAR  Timestamp[8];
+  USHORT  BeaconInterval;
+  USHORT  Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+
+
+typedef struct _NDIS_802_11_VARIABLE_IEs
+{
+  UCHAR  ElementID;
+  UCHAR  Length;
+  UCHAR  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+
+
+/*
+
+
+
+Length is the 4 bytes multiples of the sume of
+	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (ULONG)
++   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
++   sizeof (NDIS_802_11_RATES_EX) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+
+*/
+#if 0
+typedef struct _NDIS_WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];//[0]: IS beacon frame, [1]:optimum_antenna=>For antenna diversity;
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+  ULONG  NumberOfItems;
+  NDIS_WLAN_BSSID_EX  Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+#endif
+
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+    Ndis802_11AuthModeOpen,
+    Ndis802_11AuthModeShared,
+    Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+    Ndis802_11AuthModeWAPI,
+    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+    Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+    Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+    Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+    Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent,
+    Ndis802_11_EncrypteionWAPI
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    USHORT Capabilities;
+    USHORT ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    USHORT Capabilities;
+    USHORT StatusCode;
+    USHORT AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    ULONG                   Length;
+    USHORT                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    ULONG                   RequestIELength;
+    ULONG                   OffsetRequestIEs;
+    USHORT                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    ULONG                   ResponseIELength;
+    ULONG                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;
+    ULONG           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    UCHAR           KeyMaterial[32];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    ULONG                   Length;        // Length of this structure
+    ULONG                   KeyIndex;
+    NDIS_802_11_MAC_ADDRESS BSSID;
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP
+{
+    ULONG     Length;        // Length of this structure
+    ULONG     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
+    ULONG     KeyLength;     // length of key in bytes
+    UCHAR     KeyMaterial[16];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    ULONG Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    ULONG Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+// MIC check time, 60 seconds.
+#define MIC_CHECK_TIME	60000000
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+
+typedef struct _NDIS_802_11_TEST
+{
+    ULONG Length;
+    ULONG Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+
+#endif //end of #ifdef PLATFORM_LINUX
+
+#ifdef PLATFORM_FREEBSD
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
+typedef long    		NDIS_802_11_RSSI;           // in dBm
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+
+typedef  ULONG  NDIS_802_11_KEY_INDEX;
+typedef unsigned long long NDIS_802_11_KEY_RSC;
+
+
+typedef struct _NDIS_802_11_SSID
+{
+  ULONG  SsidLength;
+  UCHAR  Ssid[32];
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+    Ndis802_11FH,
+    Ndis802_11DS,
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+    ULONG           Length;             // Length of structure
+    ULONG           HopPattern;         // As defined by 802.11, MSB set
+    ULONG           HopSet;             // to one if non-802.11
+    ULONG           DwellTime;          // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.
+*/
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+    ULONG           Length;             // Length of structure
+    ULONG           BeaconPeriod;       // units are Kusec
+    ULONG           ATIMWindow;         // units are Kusec
+	ULONG           DSConfig;           /* channel number */
+    NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+    Ndis802_11IBSS,
+    Ndis802_11Infrastructure,
+    Ndis802_11AutoUnknown,
+    Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
+    Ndis802_11APMode
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+
+
+
+
+typedef struct _NDIS_802_11_FIXED_IEs
+{
+  UCHAR  Timestamp[8];
+  USHORT  BeaconInterval;
+  USHORT  Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+
+
+typedef struct _NDIS_802_11_VARIABLE_IEs
+{
+  UCHAR  ElementID;
+  UCHAR  Length;
+  UCHAR  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+
+
+/*
+
+
+
+Length is the 4 bytes multiples of the sume of
+	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (ULONG)
++   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
++   sizeof (NDIS_802_11_RATES_EX) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+
+*/
+#if 0
+typedef struct _NDIS_WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];//[0]: IS beacon frame, [1]:optimum_antenna=>For antenna diversity;
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+  ULONG  NumberOfItems;
+  NDIS_WLAN_BSSID_EX  Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+#endif
+
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+    Ndis802_11AuthModeOpen,
+    Ndis802_11AuthModeShared,
+    Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+    Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+    Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+    Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+    Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    USHORT Capabilities;
+    USHORT ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    USHORT Capabilities;
+    USHORT StatusCode;
+    USHORT AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    ULONG                   Length;
+    USHORT                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    ULONG                   RequestIELength;
+    ULONG                   OffsetRequestIEs;
+    USHORT                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    ULONG                   ResponseIELength;
+    ULONG                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;
+    ULONG           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    UCHAR           KeyMaterial[32];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    ULONG                   Length;        // Length of this structure
+    ULONG                   KeyIndex;
+    NDIS_802_11_MAC_ADDRESS BSSID;
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP
+{
+    ULONG     Length;        // Length of this structure
+    ULONG     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
+    ULONG     KeyLength;     // length of key in bytes
+    UCHAR     KeyMaterial[16];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    ULONG Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    ULONG Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+// MIC check time, 60 seconds.
+#define MIC_CHECK_TIME	60000000
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+
+typedef struct _NDIS_802_11_TEST
+{
+    ULONG Length;
+    ULONG Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+
+#endif //PLATFORM_FREEBSD
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+typedef struct _WLAN_PHY_INFO
+{
+	u8	SignalStrength;//(in percentage)
+  	u8	SignalQuality;//(in percentage)
+  	u8	Optimum_antenna;  //for Antenna diversity
+  	u8  	Reserved_0;
+}WLAN_PHY_INFO,*PWLAN_PHY_INFO;
+
+typedef struct _WLAN_BCN_INFO
+{
+	/* these infor get from rtw_get_encrypt_info when
+	 * 	 * translate scan to UI */
+	u8 encryp_protocol;//ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI
+	int group_cipher; //WPA/WPA2 group cipher
+	int pairwise_cipher;////WPA/WPA2/WEP pairwise cipher
+	int is_8021x;
+
+	/* bwmode 20/40 and ch_offset UP/LOW */
+	unsigned short 	ht_cap_info;
+	unsigned char	ht_info_infos_0;
+}WLAN_BCN_INFO,*PWLAN_BCN_INFO;
+
+/* temporally add #pragma pack for structure alignment issue of
+*   WLAN_BSSID_EX and get_WLAN_BSSID_EX_sz()
+*/
+#ifdef PLATFORM_WINDOWS
+#pragma pack(push)
+#pragma pack(1)
+#endif
+typedef struct _WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];//[0]: IS beacon frame
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;//(in dBM,raw data ,get from PHY)
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  WLAN_PHY_INFO	PhyInfo;
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+}
+#ifndef PLATFORM_WINDOWS
+__attribute__((packed))
+#endif
+WLAN_BSSID_EX, *PWLAN_BSSID_EX;
+#ifdef PLATFORM_WINDOWS
+#pragma pack(pop)
+#endif
+
+#define BSS_EX_IES(bss_ex) ((bss_ex)->IEs)
+#define BSS_EX_IES_LEN(bss_ex) ((bss_ex)->IELength)
+#define BSS_EX_FIXED_IE_OFFSET(bss_ex) ((bss_ex)->Reserved[0] == 2 ? 0 : 12)
+#define BSS_EX_TLV_IES(bss_ex) (BSS_EX_IES((bss_ex)) + BSS_EX_FIXED_IE_OFFSET((bss_ex)))
+#define BSS_EX_TLV_IES_LEN(bss_ex) (BSS_EX_IES_LEN((bss_ex)) - BSS_EX_FIXED_IE_OFFSET((bss_ex)))
+
+__inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
+{
+#if 0
+	uint t_len;
+
+	t_len = sizeof (ULONG)
+		+ sizeof (NDIS_802_11_MAC_ADDRESS)
+		+ 2
+		+ sizeof (NDIS_802_11_SSID)
+		+ sizeof (ULONG)
+		+ sizeof (NDIS_802_11_RSSI)
+		+ sizeof (NDIS_802_11_NETWORK_TYPE)
+		+ sizeof (NDIS_802_11_CONFIGURATION)
+		+ sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE)
+		+ sizeof (NDIS_802_11_RATES_EX)
+		//all new member add here
+		+ sizeof(WLAN_PHY_INFO)
+		//all new member add here
+		+ sizeof (ULONG)
+		+ bss->IELength;
+	return t_len;
+#else
+	return (sizeof(WLAN_BSSID_EX) -MAX_IE_SZ + bss->IELength);
+#endif
+}
+
+struct	wlan_network {
+	_list	list;
+	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
+	int	fixed;			// set to fixed when not to be removed as site-surveying
+	unsigned long	last_scanned; //timestamp for the network
+	int	aid;			//will only be valid when a BSS is joinned.
+	int	join_res;
+	WLAN_BSSID_EX	network; //must be the last item
+	WLAN_BCN_INFO	BcnInfo;
+#ifdef PLATFORM_WINDOWS
+	unsigned char  iebuf[MAX_IE_SZ];
+#endif
+
+};
+
+enum VRTL_CARRIER_SENSE
+{
+    DISABLE_VCS,
+    ENABLE_VCS,
+    AUTO_VCS
+};
+
+enum VCS_TYPE
+{
+    NONE_VCS,
+    RTS_CTS,
+    CTS_TO_SELF
+};
+
+
+
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+
+enum UAPSD_MAX_SP
+{
+	NO_LIMIT,
+       TWO_MSDU,
+       FOUR_MSDU,
+       SIX_MSDU
+};
+
+
+//john
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+* 	WPA2
+*/
+
+#ifndef PLATFORM_OS_CE
+typedef struct _PMKID_CANDIDATE {
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    ULONG Flags;
+} PMKID_CANDIDATE, *PPMKID_CANDIDATE;
+
+typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
+{
+    ULONG Version;       // Version of the structure
+    ULONG NumCandidates; // No. of pmkid candidates
+    PMKID_CANDIDATE CandidateList[1];
+} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
+
+
+typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
+{
+	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
+	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
+
+} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
+
+typedef struct _NDIS_802_11_CAPABILITY
+{
+	ULONG  Length;
+	ULONG  Version;
+	ULONG  NoOfPMKIDs;
+	ULONG  NoOfAuthEncryptPairsSupported;
+	NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
+
+} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
+#endif
+
+
+#endif //#ifndef WLAN_BSSDEF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/include/xmit_osdep.h b/drivers/net/wireless/realtek/rtl8723cs/include/xmit_osdep.h
new file mode 100644
index 000000000..22655a0c6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/include/xmit_osdep.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+
+struct pkt_file {
+	_pkt *pkt;
+	SIZE_T pkt_len;	 //the remainder length of the open_file
+	_buffer *cur_buffer;
+	u8 *buf_start;
+	u8 *cur_addr;
+	SIZE_T buf_len;
+};
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef PLATFORM_OS_XP
+#ifdef CONFIG_USB_HCI
+#include <usb.h>
+#include <usbdlib.h>
+#include <usbioctl.h>
+#endif
+#endif
+
+#ifdef CONFIG_GSPI_HCI
+#define NR_XMITFRAME     64
+#else
+#define NR_XMITFRAME     128
+#endif
+
+#define ETH_ALEN	6
+
+extern NDIS_STATUS rtw_xmit_entry(
+IN _nic_hdl		cnxt,
+IN NDIS_PACKET		*pkt,
+IN UINT				flags
+);
+
+#endif
+
+#ifdef PLATFORM_FREEBSD
+#define NR_XMITFRAME	256
+extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+extern void rtw_xmit_entry_wrap (struct ifnet * pifp);
+#endif //PLATFORM_FREEBSD
+
+#ifdef PLATFORM_LINUX
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+extern int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+
+#endif
+
+void rtw_os_xmit_schedule(_adapter *padapter);
+
+int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 alloc_sz, u8 flag);
+void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 free_sz, u8 flag);
+
+extern void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib);
+
+extern uint rtw_remainder_len(struct pkt_file *pfile);
+extern void _rtw_open_pktfile(_pkt *pkt, struct pkt_file *pfile);
+extern uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen);
+extern sint rtw_endofpktfile (struct pkt_file *pfile);
+
+extern void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt);
+extern void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);
+
+void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed);
+
+void dump_os_queue(void *sel, _adapter *padapter);
+
+#endif //__XMIT_OSDEP_H_
+
-- 
2.34.1

