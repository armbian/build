From 2e051406e97b3ff799a1301e5fefd7db09dc1f55 Mon Sep 17 00:00:00 2001
From: leo <leo@localhost.localdomain>
Date: Mon, 7 Feb 2022 15:22:08 +0300
Subject: [PATCH 7/9] drv:net:rtl8723cs:hal: phydm

---
 .../realtek/rtl8723cs/hal/phydm/halhwimg.h    |  123 +
 .../realtek/rtl8723cs/hal/phydm/halphyrf_ap.c | 2504 +++++++++
 .../realtek/rtl8723cs/hal/phydm/halphyrf_ap.h |  162 +
 .../realtek/rtl8723cs/hal/phydm/halphyrf_ce.c |  710 +++
 .../realtek/rtl8723cs/hal/phydm/halphyrf_ce.h |  106 +
 .../rtl8723cs/hal/phydm/halphyrf_win.c        |  716 +++
 .../rtl8723cs/hal/phydm/halphyrf_win.h        |  108 +
 .../realtek/rtl8723cs/hal/phydm/mp_precomp.h  |   20 +
 .../realtek/rtl8723cs/hal/phydm/phydm.c       | 2166 ++++++++
 .../realtek/rtl8723cs/hal/phydm/phydm.h       | 1441 +++++
 .../realtek/rtl8723cs/hal/phydm/phydm_acs.c   | 1306 +++++
 .../realtek/rtl8723cs/hal/phydm/phydm_acs.h   |  129 +
 .../rtl8723cs/hal/phydm/phydm_adaptivity.c    |  940 ++++
 .../rtl8723cs/hal/phydm/phydm_adaptivity.h    |  172 +
 .../rtl8723cs/hal/phydm/phydm_antdect.c       | 1215 +++++
 .../rtl8723cs/hal/phydm/phydm_antdect.h       |   98 +
 .../rtl8723cs/hal/phydm/phydm_antdiv.c        | 4810 +++++++++++++++++
 .../rtl8723cs/hal/phydm/phydm_antdiv.h        |  594 ++
 .../rtl8723cs/hal/phydm/phydm_beamforming.c   | 1939 +++++++
 .../rtl8723cs/hal/phydm/phydm_beamforming.h   |  365 ++
 .../rtl8723cs/hal/phydm/phydm_cfotracking.c   |  347 ++
 .../rtl8723cs/hal/phydm/phydm_cfotracking.h   |   68 +
 .../realtek/rtl8723cs/hal/phydm/phydm_debug.c | 2002 +++++++
 .../realtek/rtl8723cs/hal/phydm/phydm_debug.h |  330 ++
 .../realtek/rtl8723cs/hal/phydm/phydm_dig.c   | 2087 +++++++
 .../realtek/rtl8723cs/hal/phydm/phydm_dig.h   |  327 ++
 .../hal/phydm/phydm_dynamicbbpowersaving.c    |  219 +
 .../hal/phydm/phydm_dynamicbbpowersaving.h    |   63 +
 .../hal/phydm/phydm_dynamictxpower.c          |  633 +++
 .../hal/phydm/phydm_dynamictxpower.h          |   98 +
 .../hal/phydm/phydm_edcaturbocheck.c          |  835 +++
 .../hal/phydm/phydm_edcaturbocheck.h          |  100 +
 .../rtl8723cs/hal/phydm/phydm_features.h      |  119 +
 .../rtl8723cs/hal/phydm/phydm_hwconfig.c      | 3332 ++++++++++++
 .../rtl8723cs/hal/phydm/phydm_hwconfig.h      |  506 ++
 .../rtl8723cs/hal/phydm/phydm_interface.c     | 1014 ++++
 .../rtl8723cs/hal/phydm/phydm_interface.h     |  442 ++
 .../rtl8723cs/hal/phydm/phydm_noisemonitor.c  |  299 +
 .../rtl8723cs/hal/phydm/phydm_noisemonitor.h  |   49 +
 .../rtl8723cs/hal/phydm/phydm_pathdiv.c       | 2311 ++++++++
 .../rtl8723cs/hal/phydm/phydm_pathdiv.h       |  324 ++
 .../hal/phydm/phydm_powertracking_ap.c        | 1050 ++++
 .../hal/phydm/phydm_powertracking_ap.h        |  314 ++
 .../hal/phydm/phydm_powertracking_ce.c        |  670 +++
 .../hal/phydm/phydm_powertracking_ce.h        |  296 +
 .../hal/phydm/phydm_powertracking_win.c       |  687 +++
 .../hal/phydm/phydm_powertracking_win.h       |  265 +
 .../rtl8723cs/hal/phydm/phydm_pre_define.h    |  615 +++
 .../rtl8723cs/hal/phydm/phydm_precomp.h       |  320 ++
 .../rtl8723cs/hal/phydm/phydm_rainfo.c        | 2576 +++++++++
 .../rtl8723cs/hal/phydm/phydm_rainfo.h        |  445 ++
 .../realtek/rtl8723cs/hal/phydm/phydm_reg.h   |  208 +
 .../rtl8723cs/hal/phydm/phydm_regdefine11ac.h |   90 +
 .../rtl8723cs/hal/phydm/phydm_regdefine11n.h  |  199 +
 .../realtek/rtl8723cs/hal/phydm/phydm_rxhp.c  | 1692 ++++++
 .../realtek/rtl8723cs/hal/phydm/phydm_rxhp.h  |  105 +
 .../realtek/rtl8723cs/hal/phydm/phydm_types.h |  258 +
 .../realtek/rtl8723cs/hal/phydm/rtchnlplan.c  |  480 ++
 .../realtek/rtl8723cs/hal/phydm/rtchnlplan.h  |  699 +++
 .../hal/phydm/rtl8703b/halhwimg8703b_bb.c     |  833 +++
 .../hal/phydm/rtl8703b/halhwimg8703b_bb.h     |   59 +
 .../hal/phydm/rtl8703b/halhwimg8703b_fw.c     | 3980 ++++++++++++++
 .../hal/phydm/rtl8703b/halhwimg8703b_fw.h     |   62 +
 .../hal/phydm/rtl8703b/halhwimg8703b_mac.c    |  290 +
 .../hal/phydm/rtl8703b/halhwimg8703b_mac.h    |   39 +
 .../hal/phydm/rtl8703b/halhwimg8703b_rf.c     |  976 ++++
 .../hal/phydm/rtl8703b/halhwimg8703b_rf.h     |   69 +
 .../hal/phydm/rtl8703b/halphyrf_8703b.c       | 2228 ++++++++
 .../hal/phydm/rtl8703b/halphyrf_8703b.h       |  129 +
 .../hal/phydm/rtl8703b/phydm_regconfig8703b.c |  219 +
 .../hal/phydm/rtl8703b/phydm_regconfig8703b.h |  109 +
 .../hal/phydm/rtl8703b/version_rtl8703b.h     |   10 +
 .../rtl8723cs/hal/phydm/txbf/halcomtxbf.c     |  547 ++
 .../rtl8723cs/hal/phydm/txbf/halcomtxbf.h     |  181 +
 .../rtl8723cs/hal/phydm/txbf/haltxbf8192e.c   |  392 ++
 .../rtl8723cs/hal/phydm/txbf/haltxbf8192e.h   |   52 +
 .../rtl8723cs/hal/phydm/txbf/haltxbf8814a.c   |  653 +++
 .../rtl8723cs/hal/phydm/txbf/haltxbf8814a.h   |   70 +
 .../rtl8723cs/hal/phydm/txbf/haltxbf8821b.c   |  400 ++
 .../rtl8723cs/hal/phydm/txbf/haltxbf8821b.h   |   43 +
 .../rtl8723cs/hal/phydm/txbf/haltxbf8822b.c   | 1099 ++++
 .../rtl8723cs/hal/phydm/txbf/haltxbf8822b.h   |   53 +
 .../hal/phydm/txbf/haltxbfinterface.c         | 1384 +++++
 .../hal/phydm/txbf/haltxbfinterface.h         |  158 +
 .../rtl8723cs/hal/phydm/txbf/haltxbfjaguar.c  |  527 ++
 .../rtl8723cs/hal/phydm/txbf/haltxbfjaguar.h  |   67 +
 86 files changed, 60727 insertions(+)
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halhwimg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/mp_precomp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_features.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pre_define.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_precomp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_reg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11ac.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11n.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_types.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/version_rtl8703b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.h

diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halhwimg.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halhwimg.h
new file mode 100644
index 000000000..4c5c88160
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halhwimg.h
@@ -0,0 +1,123 @@
+#pragma once
+#ifndef __INC_HW_IMG_H
+#define __INC_HW_IMG_H
+
+//
+// 2011/03/15 MH Add for different IC HW image file selection. code size consideration.
+//
+#if RT_PLATFORM == PLATFORM_LINUX
+
+	#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)
+	// For 92C
+	#define		RTL8192CE_HWIMG_SUPPORT					1
+	#define		RTL8192CE_TEST_HWIMG_SUPPORT			0
+	#define		RTL8192CU_HWIMG_SUPPORT					0
+	#define		RTL8192CU_TEST_HWIMG_SUPPORT			0
+
+	// For 92D
+	#define		RTL8192DE_HWIMG_SUPPORT					1
+	#define		RTL8192DE_TEST_HWIMG_SUPPORT			0
+	#define		RTL8192DU_HWIMG_SUPPORT					0
+	#define		RTL8192DU_TEST_HWIMG_SUPPORT			0
+
+	// For 8723
+	#define		RTL8723E_HWIMG_SUPPORT					1
+	#define		RTL8723U_HWIMG_SUPPORT					0
+	#define		RTL8723S_HWIMG_SUPPORT					0
+
+	//For 88E
+	#define		RTL8188EE_HWIMG_SUPPORT					0
+	#define		RTL8188EU_HWIMG_SUPPORT					0
+	#define		RTL8188ES_HWIMG_SUPPORT					0
+	
+	#elif (DEV_BUS_TYPE == RT_USB_INTERFACE)
+	// For 92C
+	#define 	RTL8192CE_HWIMG_SUPPORT 				0
+	#define 	RTL8192CE_TEST_HWIMG_SUPPORT			0
+	#define 	RTL8192CU_HWIMG_SUPPORT 				1
+	#define 	RTL8192CU_TEST_HWIMG_SUPPORT			0
+
+	//For 92D
+	#define 	RTL8192DE_HWIMG_SUPPORT 				0
+	#define 	RTL8192DE_TEST_HWIMG_SUPPORT			0
+	#define 	RTL8192DU_HWIMG_SUPPORT 				1
+	#define 	RTL8192DU_TEST_HWIMG_SUPPORT			0
+
+	// For 8723
+	#define 	RTL8723E_HWIMG_SUPPORT					0
+	#define 	RTL8723U_HWIMG_SUPPORT					1
+	#define 	RTL8723S_HWIMG_SUPPORT					0
+
+	//For 88E
+	#define		RTL8188EE_HWIMG_SUPPORT					0
+	#define		RTL8188EU_HWIMG_SUPPORT					0
+	#define		RTL8188ES_HWIMG_SUPPORT					0
+	
+	#elif (DEV_BUS_TYPE == RT_SDIO_INTERFACE)
+	// For 92C
+	#define 	RTL8192CE_HWIMG_SUPPORT 				0
+	#define 	RTL8192CE_TEST_HWIMG_SUPPORT			0
+	#define 	RTL8192CU_HWIMG_SUPPORT 				1
+	#define 	RTL8192CU_TEST_HWIMG_SUPPORT			0
+
+	//For 92D
+	#define 	RTL8192DE_HWIMG_SUPPORT 				0
+	#define 	RTL8192DE_TEST_HWIMG_SUPPORT			0
+	#define 	RTL8192DU_HWIMG_SUPPORT 				1
+	#define 	RTL8192DU_TEST_HWIMG_SUPPORT			0
+
+	// For 8723
+	#define 	RTL8723E_HWIMG_SUPPORT					0
+	#define 	RTL8723U_HWIMG_SUPPORT					0
+	#define 	RTL8723S_HWIMG_SUPPORT					1
+
+	//For 88E
+	#define		RTL8188EE_HWIMG_SUPPORT					0
+	#define		RTL8188EU_HWIMG_SUPPORT					0
+	#define		RTL8188ES_HWIMG_SUPPORT					0
+	#endif
+
+#else	// PLATFORM_WINDOWS & MacOSX
+
+//For 92C
+#define		RTL8192CE_HWIMG_SUPPORT						1
+#define		RTL8192CE_TEST_HWIMG_SUPPORT				1
+#define		RTL8192CU_HWIMG_SUPPORT						1
+#define		RTL8192CU_TEST_HWIMG_SUPPORT				1
+
+// For 92D
+#define		RTL8192DE_HWIMG_SUPPORT					1
+#define		RTL8192DE_TEST_HWIMG_SUPPORT				1
+#define		RTL8192DU_HWIMG_SUPPORT					1
+#define		RTL8192DU_TEST_HWIMG_SUPPORT				1
+
+	#if defined(UNDER_CE)
+	// For 8723
+	#define		RTL8723E_HWIMG_SUPPORT					0
+	#define		RTL8723U_HWIMG_SUPPORT					0
+	#define		RTL8723S_HWIMG_SUPPORT					1
+
+	// For 88E
+	#define		RTL8188EE_HWIMG_SUPPORT					0
+	#define		RTL8188EU_HWIMG_SUPPORT					0
+	#define		RTL8188ES_HWIMG_SUPPORT					0
+
+	#else 
+
+	// For 8723
+	#define		RTL8723E_HWIMG_SUPPORT					1
+	//#define		RTL_8723E_TEST_HWIMG_SUPPORT			1
+	#define		RTL8723U_HWIMG_SUPPORT					1
+	//#define		RTL_8723U_TEST_HWIMG_SUPPORT			1
+	#define		RTL8723S_HWIMG_SUPPORT					1
+	//#define		RTL_8723S_TEST_HWIMG_SUPPORT			1
+
+	//For 88E
+	#define		RTL8188EE_HWIMG_SUPPORT					1
+	#define		RTL8188EU_HWIMG_SUPPORT					1
+	#define		RTL8188ES_HWIMG_SUPPORT					1
+	#endif
+
+#endif
+
+#endif //__INC_HW_IMG_H
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.c
new file mode 100644
index 000000000..142fef12e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.c
@@ -0,0 +1,2504 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+ #include "mp_precomp.h"
+ #include "phydm_precomp.h"
+
+#ifndef index_mapping_NUM_88E
+ #define	index_mapping_NUM_88E	15
+#endif
+
+//#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+#define 	CALCULATE_SWINGTALBE_OFFSET(_offset, _direction, _size, _deltaThermal) \
+					do {\
+						for(_offset = 0; _offset < _size; _offset++)\
+						{\
+							if(_deltaThermal < thermalThreshold[_direction][_offset])\
+							{\
+								if(_offset != 0)\
+									_offset--;\
+								break;\
+							}\
+						}			\
+						if(_offset >= _size)\
+							_offset = _size-1;\
+					} while(0)
+
+
+void ConfigureTxpowerTrack(
+	IN	PVOID		pDM_VOID,
+	OUT	PTXPWRTRACK_CFG	pConfig
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if RTL8812A_SUPPORT
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	//if (IS_HARDWARE_TYPE_8812(pDM_Odm->Adapter))
+	if(pDM_Odm->SupportICType==ODM_RTL8812)
+		ConfigureTxpowerTrack_8812A(pConfig);
+	//else
+#endif
+#endif
+
+#if RTL8814A_SUPPORT
+	if(pDM_Odm->SupportICType== ODM_RTL8814A)
+		ConfigureTxpowerTrack_8814A(pConfig);
+#endif
+
+
+#if RTL8188E_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		ConfigureTxpowerTrack_8188E(pConfig);
+#endif 
+}
+
+#if (RTL8192E_SUPPORT==1) 
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter_92E(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	ThermalValue = 0, delta, delta_IQK, delta_LCK, channel, is_decrease, rf_mimo_mode;
+	u1Byte	ThermalValue_AVG_count = 0;
+    	u1Byte     OFDM_min_index = 10; //OFDM BB Swing should be less than +2.5dB, which is required by Arthur
+	s1Byte	OFDM_index[2], index ;
+    	u4Byte	ThermalValue_AVG = 0, Reg0x18;
+	u4Byte	i = 0, j = 0, rf;
+	s4Byte	value32, CCK_index = 0, ele_A, ele_D, ele_C, X, Y;
+	prtl8192cd_priv 	priv = pDM_Odm->priv;
+
+	rf_mimo_mode = pDM_Odm->RFType;
+	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("%s:%d rf_mimo_mode:%d\n", __FUNCTION__, __LINE__, rf_mimo_mode));
+
+#ifdef MP_TEST
+	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific) {
+		channel = priv->pshare->working_channel;
+		if (priv->pshare->mp_txpwr_tracking == FALSE)
+			return;
+	} else
+#endif
+	{
+		channel = (priv->pmib->dot11RFEntry.dot11channel);
+	}
+
+	ThermalValue = (unsigned char)ODM_GetRFReg(pDM_Odm, RF_PATH_A, ODM_RF_T_METER_92E, 0xfc00);	//0x42: RF Reg[15:10] 88E
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n", ThermalValue, priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther));
+
+
+	switch (rf_mimo_mode) {
+		case MIMO_1T1R:
+			rf = 1;      
+			break;
+		case MIMO_2T2R:
+			rf = 2;
+			break;
+		default:
+			rf = 2;
+			break;
+	}
+
+	//Query OFDM path A default setting 	Bit[31:21]
+	ele_D = PHY_QueryBBReg(priv, rOFDM0_XATxIQImbalance, bMaskOFDM_D);
+	for (i = 0; i < OFDM_TABLE_SIZE_92E; i++) {
+		if (ele_D == (OFDMSwingTable_92E[i] >> 22)) {
+			OFDM_index[0] = (unsigned char)i;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("PathA 0xC80[31:22] = 0x%x, OFDM_index=%d\n", ele_D, OFDM_index[0]));
+			break;
+		}
+	}
+
+	//Query OFDM path B default setting
+	if (rf_mimo_mode == MIMO_2T2R) {
+		ele_D = PHY_QueryBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskOFDM_D);
+		for (i = 0; i < OFDM_TABLE_SIZE_92E; i++) {
+			if (ele_D == (OFDMSwingTable_92E[i] >> 22)) {
+				OFDM_index[1] = (unsigned char)i;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("PathB 0xC88[31:22] = 0x%x, OFDM_index=%d\n", ele_D, OFDM_index[1]));
+				break;
+			}
+		}
+	}
+
+	/* calculate average thermal meter */
+	{
+		priv->pshare->ThermalValue_AVG_88XX[priv->pshare->ThermalValue_AVG_index_88XX] = ThermalValue;
+		priv->pshare->ThermalValue_AVG_index_88XX++;
+		if (priv->pshare->ThermalValue_AVG_index_88XX == AVG_THERMAL_NUM_88XX)
+			priv->pshare->ThermalValue_AVG_index_88XX = 0;
+
+		for (i = 0; i < AVG_THERMAL_NUM_88XX; i++) {
+			if (priv->pshare->ThermalValue_AVG_88XX[i]) {
+				ThermalValue_AVG += priv->pshare->ThermalValue_AVG_88XX[i];
+				ThermalValue_AVG_count++;
+			}
+		}
+
+		if (ThermalValue_AVG_count) {
+			ThermalValue = (unsigned char)(ThermalValue_AVG / ThermalValue_AVG_count);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("AVG Thermal Meter = 0x%x \n", ThermalValue));
+		}
+	}
+
+	/* Initialize */
+	if (!priv->pshare->ThermalValue) {
+		priv->pshare->ThermalValue = priv->pmib->dot11RFEntry.ther;
+		priv->pshare->ThermalValue_IQK = ThermalValue;
+		priv->pshare->ThermalValue_LCK = ThermalValue;
+	}
+
+	if (ThermalValue != priv->pshare->ThermalValue) {
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\n******** START POWER TRACKING ********\n")); 					
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n", ThermalValue, priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther)); 			
+
+		delta = RTL_ABS(ThermalValue, priv->pmib->dot11RFEntry.ther);
+		delta_IQK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_IQK);
+		delta_LCK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_LCK);
+		is_decrease = ((ThermalValue < priv->pmib->dot11RFEntry.ther) ? 1 : 0);
+		
+#ifdef _TRACKING_TABLE_FILE
+		if (priv->pshare->rf_ft_var.pwr_track_file) {				
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Diff: (%s)%d ==> get index from table : %d)\n", (is_decrease?"-":"+"), delta, get_tx_tracking_index(priv, channel, i, delta, is_decrease, 0)));
+        
+            	if (is_decrease) {					
+                	for (i = 0; i < rf; i++) {
+				OFDM_index[i] = priv->pshare->OFDM_index0[i] + get_tx_tracking_index(priv, channel, i, delta, is_decrease, 0);
+				OFDM_index[i] = ((OFDM_index[i] > (OFDM_TABLE_SIZE_92E- 1)) ? (OFDM_TABLE_SIZE_92E - 1) : OFDM_index[i]);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> decrese power ---> new OFDM_INDEX:%d (%d + %d)\n", OFDM_index[i], priv->pshare->OFDM_index0[i], get_tx_tracking_index(priv, channel, i, delta, is_decrease, 0)));
+	                        CCK_index = priv->pshare->CCK_index0 + get_tx_tracking_index(priv, channel, i, delta, is_decrease, 1);                        
+				CCK_index = ((CCK_index > (CCK_TABLE_SIZE_92E - 1)) ? (CCK_TABLE_SIZE_92E - 1) : CCK_index);				
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> Decrese power ---> new CCK_INDEX:%d (%d + %d)\n",  CCK_index, priv->pshare->CCK_index0, get_tx_tracking_index(priv, channel, i, delta, is_decrease, 1)));
+			}
+		} else {
+			for (i = 0; i < rf; i++) {
+				OFDM_index[i] = priv->pshare->OFDM_index0[i] - get_tx_tracking_index(priv, channel, i, delta, is_decrease, 0);
+				OFDM_index[i] = ((OFDM_index[i] < OFDM_min_index) ?  OFDM_min_index : OFDM_index[i]);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> Increse power ---> new OFDM_INDEX:%d (%d - %d)\n", OFDM_index[i], priv->pshare->OFDM_index0[i], get_tx_tracking_index(priv, channel, i, delta, is_decrease, 0)));
+				CCK_index = priv->pshare->CCK_index0 - get_tx_tracking_index(priv, channel, i, delta, is_decrease, 1);						  
+	                        CCK_index = ((CCK_index < 0 )? 0 : CCK_index);  
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> Increse power ---> new CCK_INDEX:%d (%d - %d)\n", CCK_index, priv->pshare->CCK_index0, get_tx_tracking_index(priv, channel, i, delta, is_decrease, 1)));
+			}
+		}
+		}
+#endif //CFG_TRACKING_TABLE_FILE
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("OFDMSwingTable_92E[(unsigned int)OFDM_index[0]] = %x \n",OFDMSwingTable_92E[(unsigned int)OFDM_index[0]]));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("OFDMSwingTable_92E[(unsigned int)OFDM_index[1]] = %x \n",OFDMSwingTable_92E[(unsigned int)OFDM_index[1]]));
+
+		//Adujst OFDM Ant_A according to IQK result
+		ele_D = (OFDMSwingTable_92E[(unsigned int)OFDM_index[0]] & 0xFFC00000) >> 22;
+		X = priv->pshare->RegE94;
+		Y = priv->pshare->RegE9C;
+
+		if (X != 0) {
+			if ((X & 0x00000200) != 0)
+				X = X | 0xFFFFFC00;
+			ele_A = ((X * ele_D) >> 8) & 0x000003FF;
+
+			//new element C = element D x Y
+			if ((Y & 0x00000200) != 0)
+				Y = Y | 0xFFFFFC00;
+			ele_C = ((Y * ele_D) >> 8) & 0x000003FF;
+
+			//wirte new elements A, C, D to regC80 and regC94, element B is always 0
+			value32 = (ele_D << 22) | ((ele_C & 0x3F) << 16) | ele_A;
+			PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
+
+			value32 = (ele_C&0x000003C0)>>6;
+			PHY_SetBBReg(priv, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
+			
+			value32 = ((X * ele_D)>>7)&0x01;
+			PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(24), value32);
+		} else {
+			PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable_92E[(unsigned int)OFDM_index[0]]);
+			PHY_SetBBReg(priv, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
+			PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(24), 0x00);
+		}
+
+		set_CCK_swing_index(priv, CCK_index);
+
+		if (rf == 2) {
+			ele_D = (OFDMSwingTable_92E[(unsigned int)OFDM_index[1]] & 0xFFC00000) >> 22;
+			X = priv->pshare->RegEB4;
+			Y = priv->pshare->RegEBC;
+
+			if (X != 0) {
+				if ((X & 0x00000200) != 0)	//consider minus
+					X = X | 0xFFFFFC00;
+				ele_A = ((X * ele_D) >> 8) & 0x000003FF;
+
+				//new element C = element D x Y
+				if ((Y & 0x00000200) != 0)
+					Y = Y | 0xFFFFFC00;
+				ele_C = ((Y * ele_D) >> 8) & 0x00003FF;
+
+				//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
+				value32 = (ele_D << 22) | ((ele_C & 0x3F) << 16) | ele_A;
+				PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
+				
+				value32 = (ele_C & 0x000003C0) >> 6;
+				PHY_SetBBReg(priv, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
+
+				value32 = ((X * ele_D) >> 7) & 0x01;
+				PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(28), value32);
+			} else {
+				PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable_92E[(unsigned int)OFDM_index[1]]);
+				PHY_SetBBReg(priv, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
+				PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(28), 0x00);
+			}
+
+		}
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("0xc80 = 0x%x \n", PHY_QueryBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord)));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("0xc88 = 0x%x \n", PHY_QueryBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord)));
+
+		if (delta_IQK > 3) {
+			priv->pshare->ThermalValue_IQK = ThermalValue;
+#ifdef MP_TEST
+			if (!(priv->pshare->rf_ft_var.mp_specific && (OPMODE & (WIFI_MP_CTX_BACKGROUND | WIFI_MP_CTX_PACKET))))
+#endif	
+				PHY_IQCalibrate_8192E(pDM_Odm,false);
+		}
+
+		if (delta_LCK > 8) {
+			RTL_W8(0x522, 0xff);
+			Reg0x18 = PHY_QueryRFReg(priv, RF_PATH_A, 0x18, bMask20Bits, 1);
+			PHY_SetRFReg(priv, RF_PATH_A, 0xB4, BIT(14), 1);			
+			PHY_SetRFReg(priv, RF_PATH_A, 0x18, BIT(15), 1);
+			delay_ms(1);
+			PHY_SetRFReg(priv, RF_PATH_A, 0xB4, BIT(14), 0);
+			PHY_SetRFReg(priv, RF_PATH_A, 0x18, bMask20Bits, Reg0x18);		
+			RTL_W8(0x522, 0x0);
+			priv->pshare->ThermalValue_LCK = ThermalValue;
+		}	
+	}
+
+	//update thermal meter value
+	priv->pshare->ThermalValue = ThermalValue;
+	for (i = 0 ; i < rf ; i++)
+		priv->pshare->OFDM_index[i] = OFDM_index[i];
+	priv->pshare->CCK_index = CCK_index;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,  ("\n******** END:%s() ********\n", __FUNCTION__));	
+}
+#endif
+
+#if (RTL8814A_SUPPORT ==1)					
+		
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter_JaguarSeries2(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			ThermalValue = 0, delta, delta_LCK, delta_IQK, channel, is_increase;
+	u1Byte			ThermalValue_AVG_count = 0, p = 0, i = 0;
+	u4Byte			ThermalValue_AVG = 0, Reg0x18;
+	u4Byte 			BBSwingReg[4] = {rA_TxScale_Jaguar,rB_TxScale_Jaguar,rC_TxScale_Jaguar2,rD_TxScale_Jaguar2};
+	s4Byte			ele_D;
+	u4Byte			BBswingIdx;
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+	TXPWRTRACK_CFG 	c;
+	BOOLEAN			bTSSIenable = FALSE;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	//4 1. The following TWO tables decide the final index of OFDM/CCK swing table.
+	pu1Byte			deltaSwingTableIdx_TUP_A = NULL, deltaSwingTableIdx_TDOWN_A = NULL;
+	pu1Byte			deltaSwingTableIdx_TUP_B = NULL, deltaSwingTableIdx_TDOWN_B = NULL;
+	//for 8814 add by Yu Chen
+	pu1Byte			deltaSwingTableIdx_TUP_C = NULL, deltaSwingTableIdx_TDOWN_C = NULL;
+	pu1Byte			deltaSwingTableIdx_TUP_D = NULL, deltaSwingTableIdx_TDOWN_D = NULL;
+
+#ifdef MP_TEST
+	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific) {
+		channel = priv->pshare->working_channel;
+		if (priv->pshare->mp_txpwr_tracking == FALSE)
+			return;
+	} else
+#endif
+	{
+		channel = (priv->pmib->dot11RFEntry.dot11channel);
+	}
+
+	ConfigureTxpowerTrack(pDM_Odm, &c);
+	pRFCalibrateInfo->DefaultOfdmIndex = priv->pshare->OFDM_index0[ODM_RF_PATH_A];
+
+	(*c.GetDeltaSwingTable)(pDM_Odm, (pu1Byte*)&deltaSwingTableIdx_TUP_A, (pu1Byte*)&deltaSwingTableIdx_TDOWN_A,
+									  (pu1Byte*)&deltaSwingTableIdx_TUP_B, (pu1Byte*)&deltaSwingTableIdx_TDOWN_B);
+
+	if(pDM_Odm->SupportICType & ODM_RTL8814A)	// for 8814 path C & D
+	(*c.GetDeltaSwingTable8814only)(pDM_Odm, (pu1Byte*)&deltaSwingTableIdx_TUP_C, (pu1Byte*)&deltaSwingTableIdx_TDOWN_C,
+									  (pu1Byte*)&deltaSwingTableIdx_TUP_D, (pu1Byte*)&deltaSwingTableIdx_TDOWN_D);
+	
+	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00); //0x42: RF Reg[15:10] 88E
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+		("\nReadback Thermal Meter = 0x%x, pre thermal meter 0x%x, EEPROMthermalmeter 0x%x\n", ThermalValue, pDM_Odm->RFCalibrateInfo.ThermalValue, priv->pmib->dot11RFEntry.ther));
+
+	/* Initialize */
+	if (!pDM_Odm->RFCalibrateInfo.ThermalValue) {
+		pDM_Odm->RFCalibrateInfo.ThermalValue = priv->pmib->dot11RFEntry.ther;
+	}
+	
+	if (!pDM_Odm->RFCalibrateInfo.ThermalValue_LCK) {
+		pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = priv->pmib->dot11RFEntry.ther;
+	}
+
+	if (!pDM_Odm->RFCalibrateInfo.ThermalValue_IQK) {
+		pDM_Odm->RFCalibrateInfo.ThermalValue_IQK = priv->pmib->dot11RFEntry.ther;
+	}
+	
+	bTSSIenable = (BOOLEAN)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, rRF_TxGainOffset, BIT7);	// check TSSI enable
+	
+	//4 Query OFDM BB swing default setting 	Bit[31:21]	
+	for(p = ODM_RF_PATH_A ; p < c.RfPathCount ; p++)
+	{
+		ele_D = ODM_GetBBReg(pDM_Odm, BBSwingReg[p], 0xffe00000);	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("0x%x:0x%x ([31:21] = 0x%x)\n", BBSwingReg[p], ODM_GetBBReg(pDM_Odm, BBSwingReg[p], bMaskDWord), ele_D));
+		
+		for (BBswingIdx = 0; BBswingIdx < TXSCALE_TABLE_SIZE; BBswingIdx++) {//4 
+			if (ele_D == TxScalingTable_Jaguar[BBswingIdx]) {
+				pDM_Odm->RFCalibrateInfo.OFDM_index[p] = (u1Byte)BBswingIdx;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					("OFDM_index[%d]=%d\n",p, pDM_Odm->RFCalibrateInfo.OFDM_index[p]));				
+				break;
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("KfreeOffset[%d]=%d\n",p, pRFCalibrateInfo->KfreeOffset[p]));
+		
+	}
+
+	/* calculate average thermal meter */
+	pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index] = ThermalValue;
+	pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index++;
+	if(pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index == c.AverageThermalNum)   //Average times =  c.AverageThermalNum
+		pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index = 0;
+
+	for(i = 0; i < c.AverageThermalNum; i++)
+	{
+		if(pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[i])
+		{
+			ThermalValue_AVG += pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[i];
+			ThermalValue_AVG_count++;
+		}
+	}
+
+	if(ThermalValue_AVG_count)               //Calculate Average ThermalValue after average enough times
+	{
+		ThermalValue = (u1Byte)(ThermalValue_AVG / ThermalValue_AVG_count);
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("AVG Thermal Meter = 0x%X, EEPROMthermalmeter = 0x%X\n", ThermalValue, priv->pmib->dot11RFEntry.ther));					
+	}
+
+	//4 Calculate delta, delta_LCK, delta_IQK.
+	delta = RTL_ABS(ThermalValue, priv->pmib->dot11RFEntry.ther);	
+	delta_LCK = RTL_ABS(ThermalValue, pDM_Odm->RFCalibrateInfo.ThermalValue_LCK);
+	delta_IQK = RTL_ABS(ThermalValue, pDM_Odm->RFCalibrateInfo.ThermalValue_IQK);
+	is_increase = ((ThermalValue < priv->pmib->dot11RFEntry.ther) ? 0 : 1);
+
+	//4 if necessary, do LCK.
+	if (!(pDM_Odm->SupportICType & ODM_RTL8821)) {
+		if (delta_LCK > c.Threshold_IQK) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("delta_LCK(%d) >= Threshold_IQK(%d)\n", delta_LCK, c.Threshold_IQK));
+			pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = ThermalValue;
+			if (c.PHY_LCCalibrate)
+				(*c.PHY_LCCalibrate)(pDM_Odm);
+		}
+	}
+
+	if (delta_IQK > c.Threshold_IQK) 
+	{
+		panic_printk("%s(%d)\n", __FUNCTION__, __LINE__);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("delta_IQK(%d) >= Threshold_IQK(%d)\n", delta_IQK, c.Threshold_IQK));
+		pDM_Odm->RFCalibrateInfo.ThermalValue_IQK = ThermalValue;
+		if(c.DoIQK)
+			(*c.DoIQK)(pDM_Odm, TRUE, 0, 0);
+	} 
+
+	if(!priv->pmib->dot11RFEntry.ther)	/*Don't do power tracking since no calibrated thermal value*/
+		return;
+	
+	 //4 Do Power Tracking
+
+	 if(bTSSIenable == TRUE)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("**********Enter PURE TSSI MODE**********\n"));
+		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+			(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, TSSI_MODE, p, 0);
+	}
+	else if (ThermalValue != pDM_Odm->RFCalibrateInfo.ThermalValue)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("\n******** START POWER TRACKING ********\n")); 					
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n", ThermalValue, pDM_Odm->RFCalibrateInfo.ThermalValue, priv->pmib->dot11RFEntry.ther)); 			
+				
+#ifdef _TRACKING_TABLE_FILE
+		if (priv->pshare->rf_ft_var.pwr_track_file)
+		{				
+			if (is_increase)			// thermal is higher than base
+			{
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 
+				{
+					switch(p)
+					{
+					case ODM_RF_PATH_B:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta])); 						
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = deltaSwingTableIdx_TUP_B[delta];       // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					case ODM_RF_PATH_C:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TUP_C[%d] = %d\n", delta, deltaSwingTableIdx_TUP_C[delta]));								
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = deltaSwingTableIdx_TUP_C[delta];       // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					case ODM_RF_PATH_D:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TUP_D[%d] = %d\n", delta, deltaSwingTableIdx_TUP_D[delta]));							
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = deltaSwingTableIdx_TUP_D[delta];       // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					default:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+							("deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, deltaSwingTableIdx_TUP_A[delta]));						
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = deltaSwingTableIdx_TUP_A[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+					}		
+				}
+			}
+			else					// thermal is lower than base
+			{
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 
+				{
+					switch(p)
+					{
+					case ODM_RF_PATH_B:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));  
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = -1 * deltaSwingTableIdx_TDOWN_B[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p])); 
+					break;
+
+					case ODM_RF_PATH_C:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));  
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = -1 * deltaSwingTableIdx_TDOWN_C[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));   
+					break;
+
+					case ODM_RF_PATH_D:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));  
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = -1 * deltaSwingTableIdx_TDOWN_D[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					default:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));  
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = -1 * deltaSwingTableIdx_TDOWN_A[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+					}		
+				}
+			}
+				
+			if (is_increase)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> increse power ---> \n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 
+				(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, MIX_MODE, p, 0);
+			} 
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> decrese power --->\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 
+				(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, MIX_MODE, p, 0);
+			}
+		}
+#endif		
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\n******** END:%s() ********\n", __FUNCTION__));
+	//update thermal meter value
+	pDM_Odm->RFCalibrateInfo.ThermalValue =  ThermalValue;
+
+	}
+}
+
+#elif(ODM_IC_11AC_SERIES_SUPPORT)
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter_JaguarSeries(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	unsigned char			ThermalValue = 0, delta, delta_LCK, channel, is_decrease;
+	unsigned char			ThermalValue_AVG_count = 0;
+	unsigned int			ThermalValue_AVG = 0, Reg0x18;
+	unsigned int 			BBSwingReg[4]={0xc1c,0xe1c,0x181c,0x1a1c};
+	int 					ele_D, value32;
+	char					OFDM_index[2], index;
+	unsigned int			i = 0, j = 0, rf_path, max_rf_path =2 ,rf;
+	prtl8192cd_priv		priv = pDM_Odm->priv;
+	unsigned char			OFDM_min_index = 7; //OFDM BB Swing should be less than +2.5dB, which is required by Arthur and Mimic
+
+#ifdef MP_TEST
+	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific) {
+		channel = priv->pshare->working_channel;
+		if (priv->pshare->mp_txpwr_tracking == FALSE)
+			return;
+	} else
+#endif
+	{
+		channel = (priv->pmib->dot11RFEntry.dot11channel);
+	}
+
+#if RTL8881A_SUPPORT
+	if (pDM_Odm->SupportICType == ODM_RTL8881A) {
+		max_rf_path = 1;
+		if ((get_bonding_type_8881A() == BOND_8881AM ||get_bonding_type_8881A() == BOND_8881AN) 			
+			&& priv->pshare->rf_ft_var.use_intpa8881A && (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G))			
+			OFDM_min_index = 6;		// intPA - upper bond set to +3 dB (base: -2 dB)ot11RFEntry.phyBandSelect == PHY_BAND_2G))
+		else
+			OFDM_min_index = 10;		//OFDM BB Swing should be less than +1dB, which is required by Arthur and Mimic
+	}
+#endif
+
+
+	ThermalValue = (unsigned char)PHY_QueryRFReg(priv, RF_PATH_A, 0x42, 0xfc00, 1); //0x42: RF Reg[15:10] 88E
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n", ThermalValue, priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther));
+
+
+	//4 Query OFDM BB swing default setting 	Bit[31:21]
+	for(rf_path = 0 ; rf_path < max_rf_path ; rf_path++){
+		ele_D = PHY_QueryBBReg(priv, BBSwingReg[rf_path], 0xffe00000);	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("0x%x:0x%x ([31:21] = 0x%x)\n",BBSwingReg[rf_path], PHY_QueryBBReg(priv, BBSwingReg[rf_path], bMaskDWord),ele_D)); 			
+		for (i = 0; i < OFDM_TABLE_SIZE_8812; i++) {//4 
+			if (ele_D == OFDMSwingTable_8812[i]) {
+				OFDM_index[rf_path] = (unsigned char)i;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("OFDM_index[%d]=%d\n",rf_path, OFDM_index[rf_path]));				
+				break;
+			}
+		}
+	}
+#if 0	
+	//Query OFDM path A default setting 	Bit[31:21]
+	ele_D = PHY_QueryBBReg(priv, 0xc1c, 0xffe00000);	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("0xc1c:0x%x ([31:21] = 0x%x)\n", PHY_QueryBBReg(priv, 0xc1c, bMaskDWord),ele_D)); 			
+	for (i = 0; i < OFDM_TABLE_SIZE_8812; i++) {//4 
+		if (ele_D == OFDMSwingTable_8812[i]) {
+			OFDM_index[0] = (unsigned char)i;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("OFDM_index[0]=%d\n", OFDM_index[0]));				
+			break;
+		}
+	}
+	//Query OFDM path B default setting
+	if (rf == 2) {
+		ele_D = PHY_QueryBBReg(priv, 0xe1c, 0xffe00000);		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("0xe1c:0x%x ([32:21] = 0x%x)\n", PHY_QueryBBReg(priv, 0xe1c, bMaskDWord),ele_D)); 			
+		for (i = 0; i < OFDM_TABLE_SIZE_8812; i++) {
+			if (ele_D == OFDMSwingTable_8812[i]) {
+				OFDM_index[1] = (unsigned char)i;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("OFDM_index[1]=%d\n", OFDM_index[1])); 			
+				break;
+			}
+		}
+	}
+#endif
+	/* Initialize */
+	if (!priv->pshare->ThermalValue) {
+		priv->pshare->ThermalValue = priv->pmib->dot11RFEntry.ther;
+		priv->pshare->ThermalValue_LCK = ThermalValue;
+	}
+
+	/* calculate average thermal meter */
+	{
+		priv->pshare->ThermalValue_AVG_8812[priv->pshare->ThermalValue_AVG_index_8812] = ThermalValue;
+		priv->pshare->ThermalValue_AVG_index_8812++;
+		if (priv->pshare->ThermalValue_AVG_index_8812 == AVG_THERMAL_NUM_8812)
+			priv->pshare->ThermalValue_AVG_index_8812 = 0;
+
+		for (i = 0; i < AVG_THERMAL_NUM_8812; i++) {
+			if (priv->pshare->ThermalValue_AVG_8812[i]) {
+				ThermalValue_AVG += priv->pshare->ThermalValue_AVG_8812[i];
+				ThermalValue_AVG_count++;
+			}
+		}
+
+		if (ThermalValue_AVG_count) {
+			ThermalValue = (unsigned char)(ThermalValue_AVG / ThermalValue_AVG_count);
+			//printk("AVG Thermal Meter = 0x%x \n", ThermalValue);
+		}
+	}
+	
+
+	//4 If necessary,  do power tracking
+
+	if(!priv->pmib->dot11RFEntry.ther) /*Don't do power tracking since no calibrated thermal value*/
+		return;  
+
+	if (ThermalValue != priv->pshare->ThermalValue) {
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\n******** START POWER TRACKING ********\n")); 					
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n", ThermalValue, priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther)); 			
+		delta = RTL_ABS(ThermalValue, priv->pmib->dot11RFEntry.ther);
+		delta_LCK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_LCK);
+		is_decrease = ((ThermalValue < priv->pmib->dot11RFEntry.ther) ? 1 : 0);
+		//if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) 
+		{
+#ifdef _TRACKING_TABLE_FILE
+			if (priv->pshare->rf_ft_var.pwr_track_file) {				
+				for (rf_path = 0; rf_path < max_rf_path; rf_path++) {
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Diff: (%s)%d ==> get index from table : %d)\n", (is_decrease?"-":"+"), delta, get_tx_tracking_index(priv, channel, rf_path, delta, is_decrease, 0)));
+					if (is_decrease) {
+						OFDM_index[rf_path] = priv->pshare->OFDM_index0[rf_path] + get_tx_tracking_index(priv, channel, rf_path, delta, is_decrease, 0);
+						OFDM_index[rf_path] = ((OFDM_index[rf_path] > (OFDM_TABLE_SIZE_8812 - 1)) ? (OFDM_TABLE_SIZE_8812 - 1) : OFDM_index[rf_path]);
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> decrese power ---> new OFDM_INDEX:%d (%d + %d)\n", OFDM_index[rf_path], priv->pshare->OFDM_index0[rf_path], get_tx_tracking_index(priv, channel, rf_path, delta, is_decrease, 0)));
+#if 0// RTL8881A_SUPPORT
+						if (pDM_Odm->SupportICType == ODM_RTL8881A){
+							if(priv->pshare->rf_ft_var.pwrtrk_TxAGC_enable){
+								if(priv->pshare->AddTxAGC){//TxAGC has been added
+									AddTxPower88XX_AC(priv,0); 
+									priv->pshare->AddTxAGC = 0;
+									priv->pshare->AddTxAGC_index = 0;
+								}
+							}
+						}
+#endif				
+					} else {
+
+						OFDM_index[rf_path] = priv->pshare->OFDM_index0[rf_path] - get_tx_tracking_index(priv, channel, rf_path, delta, is_decrease, 0);
+#if 0// RTL8881A_SUPPORT
+						if(pDM_Odm->SupportICType == ODM_RTL8881A){ 
+							if(priv->pshare->rf_ft_var.pwrtrk_TxAGC_enable){
+								if(OFDM_index[i] < OFDM_min_index){
+									priv->pshare->AddTxAGC_index = (OFDM_min_index - OFDM_index[i])/2;  // Calculate Remnant TxAGC Value,  2 index for 1 TxAGC 
+									AddTxPower88XX_AC(priv,priv->pshare->AddTxAGC_index);
+									priv->pshare->AddTxAGC = 1;     //AddTxAGC Flag = 1
+									OFDM_index[i] = OFDM_min_index;
+								}
+								else{
+									if(priv->pshare->AddTxAGC){// TxAGC been added
+										priv->pshare->AddTxAGC = 0;
+										priv->pshare->AddTxAGC_index = 0;
+										AddTxPower88XX_AC(priv,0); //minus the added TPI
+									}
+								}
+							}
+						}
+#else
+						OFDM_index[rf_path] = ((OFDM_index[rf_path] < OFDM_min_index) ?  OFDM_min_index : OFDM_index[rf_path]);
+#endif
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,(">>> increse power ---> new OFDM_INDEX:%d (%d - %d)\n", OFDM_index[rf_path], priv->pshare->OFDM_index0[rf_path], get_tx_tracking_index(priv, channel, rf_path, delta, is_decrease, 0)));
+					}
+				}
+			}
+#endif
+			//4 Set new BB swing index
+			for (rf_path = 0; rf_path < max_rf_path; rf_path++) {
+				PHY_SetBBReg(priv, BBSwingReg[rf_path], 0xffe00000, OFDMSwingTable_8812[(unsigned int)OFDM_index[rf_path]]);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Readback 0x%x[31:21] = 0x%x, OFDM_index:%d\n",BBSwingReg[rf_path], PHY_QueryBBReg(priv, BBSwingReg[rf_path], 0xffe00000), OFDM_index[rf_path]));				
+			}
+
+		}
+		if (delta_LCK > 8) {
+			RTL_W8(0x522, 0xff);
+			Reg0x18 = PHY_QueryRFReg(priv, RF_PATH_A, 0x18, bMask20Bits, 1);
+			PHY_SetRFReg(priv, RF_PATH_A, 0xB4, BIT(14), 1);			
+			PHY_SetRFReg(priv, RF_PATH_A, 0x18, BIT(15), 1);
+            delay_ms(200); // frequency deviation
+			PHY_SetRFReg(priv, RF_PATH_A, 0xB4, BIT(14), 0);
+			PHY_SetRFReg(priv, RF_PATH_A, 0x18, bMask20Bits, Reg0x18);
+			#ifdef CONFIG_RTL_8812_SUPPORT
+			if (GET_CHIP_VER(priv)== VERSION_8812E)			
+				UpdateBBRFVal8812(priv, priv->pmib->dot11RFEntry.dot11channel);	
+			#endif
+			RTL_W8(0x522, 0x0);
+			priv->pshare->ThermalValue_LCK = ThermalValue;
+		}	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("\n******** END:%s() ********\n", __FUNCTION__));
+
+		//update thermal meter value
+		priv->pshare->ThermalValue = ThermalValue;
+		for (rf_path = 0; rf_path < max_rf_path; rf_path++)
+			priv->pshare->OFDM_index[rf_path] = OFDM_index[rf_path];
+	}
+}
+
+#endif
+
+
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+#if (RTL8814A_SUPPORT == 1)		//use this function to do power tracking after 8814 by YuChen
+	if (pDM_Odm->SupportICType & ODM_RTL8814A) {
+		ODM_TXPowerTrackingCallback_ThermalMeter_JaguarSeries2(pDM_Odm);
+		return;
+		}
+#elif ODM_IC_11AC_SERIES_SUPPORT
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_TXPowerTrackingCallback_ThermalMeter_JaguarSeries(pDM_Odm);
+		return;
+	}
+#endif
+
+#if (RTL8192E_SUPPORT == 1)
+	if (pDM_Odm->SupportICType==ODM_RTL8192E) {
+		ODM_TXPowerTrackingCallback_ThermalMeter_92E(pDM_Odm);
+		return;
+	}
+#endif
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	//PMGNT_INFO      		pMgntInfo = &Adapter->MgntInfo;
+#endif
+	
+	u1Byte			ThermalValue = 0, delta, delta_LCK, delta_IQK, offset;
+	u1Byte			ThermalValue_AVG_count = 0;
+	u4Byte			ThermalValue_AVG = 0;	
+//	s4Byte			ele_A=0, ele_D, TempCCk, X, value32;
+//	s4Byte			Y, ele_C=0;
+//	s1Byte			OFDM_index[2], CCK_index=0, OFDM_index_old[2]={0,0}, CCK_index_old=0, index;
+//	s1Byte			deltaPowerIndex = 0;
+	u4Byte			i = 0;//, j = 0;
+	BOOLEAN 		is2T = FALSE;
+//	BOOLEAN 		bInteralPA = FALSE;
+
+	u1Byte			OFDM_max_index = 34, rf = (is2T) ? 2 : 1; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
+	u1Byte			Indexforchannel = 0;/*GetRightChnlPlaceforIQK(pHalData->CurrentChannel)*/
+    enum            _POWER_DEC_INC { POWER_DEC, POWER_INC };
+	#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+	#endif
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	#endif
+
+	TXPWRTRACK_CFG 	c;
+
+
+	//4 1. The following TWO tables decide the final index of OFDM/CCK swing table.
+	s1Byte			deltaSwingTableIdx[2][index_mapping_NUM_88E] = { 
+                        // {{Power decreasing(lower temperature)}, {Power increasing(higher temperature)}}
+                        {0,0,2,3,4,4,5,6,7,7,8,9,10,10,11}, {0,0,1,2,3,4,4,4,4,5,7,8,9,9,10}
+                    };	
+	u1Byte			thermalThreshold[2][index_mapping_NUM_88E]={
+                        // {{Power decreasing(lower temperature)}, {Power increasing(higher temperature)}}
+					    {0,2,4,6,8,10,12,14,16,18,20,22,24,26,27}, {0,2,4,6,8,10,12,14,16,18,20,22,25,25,25}
+                    };		
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+#endif	
+
+	//4 2. Initilization ( 7 steps in total )
+
+	ConfigureTxpowerTrack(pDM_Odm, &c);
+	
+	pDM_Odm->RFCalibrateInfo.TXPowerTrackingCallbackCnt++; //cosa add for debug
+	pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = TRUE;
+    
+#if (MP_DRIVER == 1)      
+    pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = pHalData->TxPowerTrackControl; // <Kordan> We should keep updating the control variable according to HalData.
+    // <Kordan> RFCalibrateInfo.RegA24 will be initialized when ODM HW configuring, but MP configures with para files.
+    pDM_Odm->RFCalibrateInfo.RegA24 = 0x090e1317; 
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP) && defined(MP_TEST)
+	if ((OPMODE & WIFI_MP_STATE) || pDM_Odm->priv->pshare->rf_ft_var.mp_specific) {
+		if(pDM_Odm->priv->pshare->mp_txpwr_tracking == FALSE)
+			return;
+	}
+#endif
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("===>odm_TXPowerTrackingCallback_ThermalMeter_8188E, pDM_Odm->BbSwingIdxCckBase: %d, pDM_Odm->BbSwingIdxOfdmBase: %d \n", pRFCalibrateInfo->BbSwingIdxCckBase, pRFCalibrateInfo->BbSwingIdxOfdmBase));
+/*
+	if (!pDM_Odm->RFCalibrateInfo.TM_Trigger) {
+		ODM_SetRFReg(pDM_Odm, RF_PATH_A, c.ThermalRegAddr, BIT17 | BIT16, 0x3);
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 1;
+		return;
+	}
+*/	
+	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	if( ! ThermalValue || ! pDM_Odm->RFCalibrateInfo.TxPowerTrackControl)
+#else
+	if( ! pDM_Odm->RFCalibrateInfo.TxPowerTrackControl)
+#endif		
+        return;
+
+	//4 3. Initialize ThermalValues of RFCalibrateInfo
+	
+	if( ! pDM_Odm->RFCalibrateInfo.ThermalValue)
+	{
+		pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = ThermalValue;				
+		pDM_Odm->RFCalibrateInfo.ThermalValue_IQK = ThermalValue;										
+	}			
+
+	if(pDM_Odm->RFCalibrateInfo.bReloadtxpowerindex)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));				
+	}
+
+	//4 4. Calculate average thermal meter
+	
+	pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index] = ThermalValue;
+	pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index++;
+	if(pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index == c.AverageThermalNum)
+		pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index = 0;
+
+	for(i = 0; i < c.AverageThermalNum; i++)
+	{
+		if(pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[i])
+		{
+			ThermalValue_AVG += pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[i];
+			ThermalValue_AVG_count++;
+		}
+	}
+
+	if(ThermalValue_AVG_count)
+	{
+		// Give the new thermo value a weighting
+		ThermalValue_AVG += (ThermalValue*4);
+		
+		ThermalValue = (u1Byte)(ThermalValue_AVG / (ThermalValue_AVG_count+4));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("AVG Thermal Meter = 0x%x \n", ThermalValue));					
+	}
+			
+	//4 5. Calculate delta, delta_LCK, delta_IQK.
+	
+	delta 	  = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue):(pDM_Odm->RFCalibrateInfo.ThermalValue - ThermalValue);
+	delta_LCK = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue_LCK)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue_LCK):(pDM_Odm->RFCalibrateInfo.ThermalValue_LCK - ThermalValue);
+	delta_IQK = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue_IQK)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue_IQK):(pDM_Odm->RFCalibrateInfo.ThermalValue_IQK - ThermalValue);
+		
+	//4 6. If necessary, do LCK.	
+	if (!(pDM_Odm->SupportICType & ODM_RTL8821)) {
+	/*if((delta_LCK > pHalData->Delta_LCK) && (pHalData->Delta_LCK != 0))*/
+		if (delta_LCK >= c.Threshold_IQK) { 
+			/*Delta temperature is equal to or larger than 20 centigrade.*/
+			pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = ThermalValue;
+			(*c.PHY_LCCalibrate)(pDM_Odm);
+		}
+	}
+
+	//3 7. If necessary, move the index of swing table to adjust Tx power.	
+	
+	if (delta > 0 && pDM_Odm->RFCalibrateInfo.TxPowerTrackControl)
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))			
+	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);		
+#else
+	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);		
+#endif
+
+
+		//4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset
+		
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))				
+		if(ThermalValue > pHalData->EEPROMThermalMeter) {
+#else
+		if(ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
+#endif
+			CALCULATE_SWINGTALBE_OFFSET(offset, POWER_INC, index_mapping_NUM_88E, delta);
+			pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast = pDM_Odm->RFCalibrateInfo.DeltaPowerIndex;
+			pDM_Odm->RFCalibrateInfo.DeltaPowerIndex =  deltaSwingTableIdx[POWER_INC][offset];
+
+        } else {
+        
+			CALCULATE_SWINGTALBE_OFFSET(offset, POWER_DEC, index_mapping_NUM_88E, delta);
+			pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast = pDM_Odm->RFCalibrateInfo.DeltaPowerIndex;
+			pDM_Odm->RFCalibrateInfo.DeltaPowerIndex = (-1)*deltaSwingTableIdx[POWER_DEC][offset];
+        }
+		
+		if (pDM_Odm->RFCalibrateInfo.DeltaPowerIndex == pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast)
+			pDM_Odm->RFCalibrateInfo.PowerIndexOffset = 0;
+		else
+			pDM_Odm->RFCalibrateInfo.PowerIndexOffset = pDM_Odm->RFCalibrateInfo.DeltaPowerIndex - pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast;
+		
+	    for(i = 0; i < rf; i++) 		
+	    	pDM_Odm->RFCalibrateInfo.OFDM_index[i] = pRFCalibrateInfo->BbSwingIdxOfdmBase + pDM_Odm->RFCalibrateInfo.PowerIndexOffset;
+		pDM_Odm->RFCalibrateInfo.CCK_index = pRFCalibrateInfo->BbSwingIdxCckBase + pDM_Odm->RFCalibrateInfo.PowerIndexOffset;
+
+		pRFCalibrateInfo->BbSwingIdxCck = pDM_Odm->RFCalibrateInfo.CCK_index;	
+		pRFCalibrateInfo->BbSwingIdxOfdm[RF_PATH_A] = pDM_Odm->RFCalibrateInfo.OFDM_index[RF_PATH_A];	
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("The 'CCK' final index(%d) = BaseIndex(%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxCck, pRFCalibrateInfo->BbSwingIdxCckBase, pDM_Odm->RFCalibrateInfo.PowerIndexOffset));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("The 'OFDM' final index(%d) = BaseIndex(%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxOfdm[RF_PATH_A], pRFCalibrateInfo->BbSwingIdxOfdmBase, pDM_Odm->RFCalibrateInfo.PowerIndexOffset));
+
+		//4 7.1 Handle boundary conditions of index.
+		
+		
+		for(i = 0; i < rf; i++)
+		{
+			if(pDM_Odm->RFCalibrateInfo.OFDM_index[i] > OFDM_max_index)
+			{
+				pDM_Odm->RFCalibrateInfo.OFDM_index[i] = OFDM_max_index;
+			}
+			else if (pDM_Odm->RFCalibrateInfo.OFDM_index[i] < 0)
+			{
+				pDM_Odm->RFCalibrateInfo.OFDM_index[i] = 0;
+			}
+		}
+
+		if(pDM_Odm->RFCalibrateInfo.CCK_index > c.SwingTableSize_CCK-1)
+			pDM_Odm->RFCalibrateInfo.CCK_index = c.SwingTableSize_CCK-1;
+		else if (pDM_Odm->RFCalibrateInfo.CCK_index < 0)
+			pDM_Odm->RFCalibrateInfo.CCK_index = 0;
+	}
+	else
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("The thermal meter is unchanged or TxPowerTracking OFF: ThermalValue: %d , pDM_Odm->RFCalibrateInfo.ThermalValue: %d)\n", ThermalValue, pDM_Odm->RFCalibrateInfo.ThermalValue));
+		pDM_Odm->RFCalibrateInfo.PowerIndexOffset = 0;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+		("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", pDM_Odm->RFCalibrateInfo.CCK_index, pRFCalibrateInfo->BbSwingIdxCckBase));
+				
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+		("TxPowerTracking: [OFDM] Swing Current Index: %d, Swing Base Index: %d\n", pDM_Odm->RFCalibrateInfo.OFDM_index[RF_PATH_A], pRFCalibrateInfo->BbSwingIdxOfdmBase));
+	
+	if (pDM_Odm->RFCalibrateInfo.PowerIndexOffset != 0 && pDM_Odm->RFCalibrateInfo.TxPowerTrackControl)
+	{
+		//4 7.2 Configure the Swing Table to adjust Tx Power.
+		
+			pDM_Odm->RFCalibrateInfo.bTxPowerChanged = TRUE; // Always TRUE after Tx Power is adjusted by power tracking.			
+			//
+			// 2012/04/23 MH According to Luke's suggestion, we can not write BB digital
+			// to increase TX power. Otherwise, EVM will be bad.
+			//
+			// 2012/04/25 MH Add for tx power tracking to set tx power in tx agc for 88E.
+			if (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue)
+			{
+				//ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				//	("Temperature Increasing: delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", 
+				//	pDM_Odm->RFCalibrateInfo.PowerIndexOffset, delta, ThermalValue, pHalData->EEPROMThermalMeter, pDM_Odm->RFCalibrateInfo.ThermalValue));	
+			}
+			else if (ThermalValue < pDM_Odm->RFCalibrateInfo.ThermalValue)// Low temperature
+			{
+				//ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				//	("Temperature Decreasing: delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+				//		pDM_Odm->RFCalibrateInfo.PowerIndexOffset, delta, ThermalValue, pHalData->EEPROMThermalMeter, pDM_Odm->RFCalibrateInfo.ThermalValue));				
+			}
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+			if (ThermalValue > pHalData->EEPROMThermalMeter)
+#else
+			if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)
+#endif
+			{
+//				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Temperature(%d) hugher than PG value(%d), increases the power by TxAGC\n", ThermalValue, pHalData->EEPROMThermalMeter));
+				(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, TXAGC, 0, 0);							
+			}
+			else
+			{
+	//			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Temperature(%d) lower than PG value(%d), increases the power by TxAGC\n", ThermalValue, pHalData->EEPROMThermalMeter));
+				(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, RF_PATH_A, Indexforchannel);	
+				if(is2T)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, RF_PATH_B, Indexforchannel);				
+			}
+			
+			pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->BbSwingIdxCck;
+			pRFCalibrateInfo->BbSwingIdxOfdmBase = pRFCalibrateInfo->BbSwingIdxOfdm[RF_PATH_A];
+			pDM_Odm->RFCalibrateInfo.ThermalValue = ThermalValue;
+
+	}
+		
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	// if((delta_IQK > pHalData->Delta_IQK) && (pHalData->Delta_IQK != 0))
+	if ((delta_IQK >= 8)) // Delta temperature is equal to or larger than 20 centigrade.
+		(*c.DoIQK)(pDM_Odm, delta_IQK, ThermalValue, 8);
+#endif		
+			
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("<===dm_TXPowerTrackingCallback_ThermalMeter_8188E\n"));
+	
+	pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
+}
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+
+VOID
+phy_PathAStandBy(
+	IN	PADAPTER	pAdapter
+	)
+{
+	RTPRINT(FINIT, INIT_IQK, ("Path-A standby mode!\n"));
+
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0x0);
+	PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00010000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0x808000);
+}
+
+//1 7.	IQK
+//#define MAX_TOLERANCE		5
+//#define IQK_DELAY_TIME		1		//ms
+
+u1Byte			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+phy_PathA_IQK_8192C(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		configPathB
+	)
+{
+
+	u4Byte regEAC, regE94, regE9C, regEA4;
+	u1Byte result = 0x00;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	RTPRINT(FINIT, INIT_IQK, ("Path A IQK!\n"));
+
+	//path-A IQK setting
+	RTPRINT(FINIT, INIT_IQK, ("Path-A IQK setting!\n"));
+	if(pAdapter->interfaceIndex == 0)
+	{
+		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+	}
+	else
+	{
+		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c22);	
+	}
+
+	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82140102);
+
+	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 : 
+		IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202:0x28160502);
+
+	//path-B IQK setting
+	if(configPathB)
+	{
+		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140102);
+		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x28160202);
+	}
+
+	//LO calibration setting
+	RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
+	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x001028d1);
+
+	//One shot, path A LOK & IQK
+	RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	
+	// delay x ms
+	RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME));
+	PlatformStallExecution(IQK_DELAY_TIME*1000);
+
+	// Check failed
+	regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%x\n", regEAC));
+	regE94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xe94 = 0x%x\n", regE94));
+	regE9C= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xe9c = 0x%x\n", regE9C));
+	regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%x\n", regEA4));
+
+	if(!(regEAC & BIT28) &&		
+		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
+		(((regE9C & 0x03FF0000)>>16) != 0x42) )
+		result |= 0x01;
+	else							//if Tx not OK, ignore Rx
+		return result;
+
+	if(!(regEAC & BIT27) &&		//if Tx is OK, check whether Rx is OK
+		(((regEA4 & 0x03FF0000)>>16) != 0x132) &&
+		(((regEAC & 0x03FF0000)>>16) != 0x36))
+		result |= 0x02;
+	else
+		RTPRINT(FINIT, INIT_IQK, ("Path A Rx IQK fail!!\n"));
+	
+	return result;
+
+
+}
+
+u1Byte				//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+phy_PathB_IQK_8192C(
+	IN	PADAPTER	pAdapter
+	)
+{
+	u4Byte regEAC, regEB4, regEBC, regEC4, regECC;
+	u1Byte	result = 0x00;
+	RTPRINT(FINIT, INIT_IQK, ("Path B IQK!\n"));
+
+	//One shot, path B LOK & IQK
+	RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+
+	// delay x ms
+	RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path B LOK & IQK.\n", IQK_DELAY_TIME));
+	PlatformStallExecution(IQK_DELAY_TIME*1000);
+
+	// Check failed
+	regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%x\n", regEAC));
+	regEB4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xeb4 = 0x%x\n", regEB4));
+	regEBC= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xebc = 0x%x\n", regEBC));
+	regEC4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xec4 = 0x%x\n", regEC4));
+	regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
+	RTPRINT(FINIT, INIT_IQK, ("0xecc = 0x%x\n", regECC));
+
+	if(!(regEAC & BIT31) &&
+		(((regEB4 & 0x03FF0000)>>16) != 0x142) &&
+		(((regEBC & 0x03FF0000)>>16) != 0x42))
+		result |= 0x01;
+	else
+		return result;
+
+	if(!(regEAC & BIT30) &&
+		(((regEC4 & 0x03FF0000)>>16) != 0x132) &&
+		(((regECC & 0x03FF0000)>>16) != 0x36))
+		result |= 0x02;
+	else
+		RTPRINT(FINIT, INIT_IQK, ("Path B Rx IQK fail!!\n"));
+	
+
+	return result;
+
+}
+
+VOID
+phy_PathAFillIQKMatrix(
+	IN	PADAPTER	pAdapter,
+	IN  BOOLEAN    	bIQKOK,
+	IN	s4Byte		result[][8],
+	IN	u1Byte		final_candidate,
+	IN  BOOLEAN		bTxOnly
+	)
+{
+	u4Byte	Oldval_0, X, TX0_A, reg;
+	s4Byte	Y, TX0_C;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	
+	RTPRINT(FINIT, INIT_IQK, ("Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed"));
+
+	if(final_candidate == 0xFF)
+		return;
+
+	else if(bIQKOK)
+	{
+		Oldval_0 = (PHY_QueryBBReg(pAdapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+		X = result[final_candidate][0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;				
+		TX0_A = (X * Oldval_0) >> 8;
+		RTPRINT(FINIT, INIT_IQK, ("X = 0x%x, TX0_A = 0x%x, Oldval_0 0x%x\n", X, TX0_A, Oldval_0));
+		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(31), ((X * Oldval_0>>7) & 0x1));
+     
+		Y = result[final_candidate][1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;		
+
+		//path B IQK result + 3
+		if(pAdapter->interfaceIndex == 1 && pHalData->CurrentBandType == BAND_ON_5G)
+			Y += 3;
+		
+		TX0_C = (Y * Oldval_0) >> 8;
+		RTPRINT(FINIT, INIT_IQK, ("Y = 0x%x, TX = 0x%x\n", Y, TX0_C));
+		PHY_SetBBReg(pAdapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(29), ((Y * Oldval_0>>7) & 0x1));
+
+		if(bTxOnly)
+		{
+			RTPRINT(FINIT, INIT_IQK, ("phy_PathAFillIQKMatrix only Tx OK\n"));		
+			return;
+		}
+
+		reg = result[final_candidate][2];
+		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+	
+		reg = result[final_candidate][3] & 0x3F;
+		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][3] >> 6) & 0xF;
+		PHY_SetBBReg(pAdapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
+	}
+}
+
+VOID
+phy_PathBFillIQKMatrix(
+	IN	PADAPTER	pAdapter,
+	IN  BOOLEAN   	bIQKOK,
+	IN	s4Byte		result[][8],
+	IN	u1Byte		final_candidate,
+	IN	BOOLEAN		bTxOnly			//do Tx only
+	)
+{
+	u4Byte	Oldval_1, X, TX1_A, reg;
+	s4Byte	Y, TX1_C;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	
+	RTPRINT(FINIT, INIT_IQK, ("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed"));
+
+	if(final_candidate == 0xFF)
+		return;
+
+	else if(bIQKOK)
+	{
+		Oldval_1 = (PHY_QueryBBReg(pAdapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+		X = result[final_candidate][4];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;		
+		TX1_A = (X * Oldval_1) >> 8;
+		RTPRINT(FINIT, INIT_IQK, ("X = 0x%x, TX1_A = 0x%x\n", X, TX1_A));
+		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(27), ((X * Oldval_1>>7) & 0x1));
+
+		Y = result[final_candidate][5];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;		
+		if(pHalData->CurrentBandType == BAND_ON_5G)		
+			Y += 3;		//temp modify for preformance
+		TX1_C = (Y * Oldval_1) >> 8;
+		RTPRINT(FINIT, INIT_IQK, ("Y = 0x%x, TX1_C = 0x%x\n", Y, TX1_C));
+		PHY_SetBBReg(pAdapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
+		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(25), ((Y * Oldval_1>>7) & 0x1));
+
+		if(bTxOnly)
+			return;
+
+		reg = result[final_candidate][6];
+		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+	
+		reg = result[final_candidate][7] & 0x3F;
+		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][7] >> 6) & 0xF;
+		PHY_SetBBReg(pAdapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+	}
+}
+
+
+BOOLEAN							
+phy_SimularityCompare_92C(
+	IN	PADAPTER	pAdapter,
+	IN	s4Byte 		result[][8],
+	IN	u1Byte		 c1,
+	IN	u1Byte		 c2
+	)
+{
+	u4Byte		i, j, diff, SimularityBitMap, bound = 0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	u1Byte		final_candidate[2] = {0xFF, 0xFF};	//for path A and path B
+	BOOLEAN		bResult = TRUE, is2T = IS_92C_SERIAL( pHalData->VersionID);
+	
+	if(is2T)
+		bound = 8;
+	else
+		bound = 4;
+
+	SimularityBitMap = 0;
+	
+	for( i = 0; i < bound; i++ )
+	{
+		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
+		if (diff > MAX_TOLERANCE)
+		{
+			if((i == 2 || i == 6) && !SimularityBitMap)
+			{
+				if(result[c1][i]+result[c1][i+1] == 0)
+					final_candidate[(i/4)] = c2;
+				else if (result[c2][i]+result[c2][i+1] == 0)
+					final_candidate[(i/4)] = c1;
+				else
+					SimularityBitMap = SimularityBitMap|(1<<i);					
+			}
+			else
+				SimularityBitMap = SimularityBitMap|(1<<i);
+		}
+	}
+	
+	if ( SimularityBitMap == 0)
+	{
+		for( i = 0; i < (bound/4); i++ )
+		{
+			if(final_candidate[i] != 0xFF)
+			{
+				for( j = i*4; j < (i+1)*4-2; j++)
+					result[3][j] = result[final_candidate[i]][j];
+				bResult = FALSE;
+			}
+		}
+		return bResult;
+	}
+	else if (!(SimularityBitMap & 0x0F))			//path A OK
+	{
+		for(i = 0; i < 4; i++)
+			result[3][i] = result[c1][i];
+		return FALSE;
+	}
+	else if (!(SimularityBitMap & 0xF0) && is2T)	//path B OK
+	{
+		for(i = 4; i < 8; i++)
+			result[3][i] = result[c1][i];
+		return FALSE;
+	}	
+	else		
+		return FALSE;
+	
+}
+
+/*
+return FALSE => do IQK again
+*/
+BOOLEAN							
+phy_SimularityCompare(
+	IN	PADAPTER	pAdapter,
+	IN	s4Byte 		result[][8],
+	IN	u1Byte		 c1,
+	IN	u1Byte		 c2
+	)
+{	
+	return phy_SimularityCompare_92C(pAdapter, result, c1, c2);	
+
+}
+
+VOID	
+phy_IQCalibrate_8192C(
+	IN	PADAPTER	pAdapter,
+	IN	s4Byte 		result[][8],
+	IN	u1Byte		t,
+	IN	BOOLEAN		is2T
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u4Byte			i;
+	u1Byte			PathAOK, PathBOK;
+	u4Byte			ADDA_REG[IQK_ADDA_REG_NUM] = {	
+						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth, 	
+						rRx_Wait_CCA, 		rTx_CCK_RFON,
+						rTx_CCK_BBON, 	rTx_OFDM_RFON, 	
+						rTx_OFDM_BBON, 	rTx_To_Rx,
+						rTx_To_Tx, 		rRx_CCK, 	
+						rRx_OFDM, 		rRx_Wait_RIFS,
+						rRx_TO_Rx, 		rStandby, 	
+						rSleep, 			rPMPD_ANAEN };
+	u4Byte			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE, 		REG_BCN_CTRL,	
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+					
+	//since 92C & 92D have the different define in IQK_BB_REG	
+	u4Byte	IQK_BB_REG_92C[IQK_BB_REG_NUM] = {
+							rOFDM0_TRxPathEnable, 		rOFDM0_TRMuxPar,	
+							rFPGA0_XCD_RFInterfaceSW,	rConfig_AntA,	rConfig_AntB,
+							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,	
+							rFPGA0_XB_RFInterfaceOE,	/*rFPGA0_RFMOD*/ rCCK0_AFESetting	
+							};	
+
+	u4Byte	IQK_BB_REG_92D[IQK_BB_REG_NUM_92D] = {	//for normal
+							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,	
+							rFPGA0_XB_RFInterfaceOE,	rOFDM0_TRMuxPar,
+							rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,	
+							/*rFPGA0_RFMOD*/ rCCK0_AFESetting,			rFPGA0_AnalogParameter4,
+							rOFDM0_XAAGCCore1,		rOFDM0_XBAGCCore1						
+						};		
+#if MP_DRIVER
+	const u4Byte	retryCount = 9;
+#else
+	const u4Byte	retryCount = 2;
+#endif
+	//Neil Chen--2011--05--19--
+       //3 Path Div	
+	u1Byte                 rfPathSwitch=0x0;
+
+	// Note: IQ calibration must be performed after loading 
+	// 		PHY_REG.txt , and radio_a, radio_b.txt	
+	
+	u4Byte bbvalue;
+
+	if(t==0)
+	{
+	 	 //bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
+		//	RTPRINT(FINIT, INIT_IQK, ("phy_IQCalibrate_8192C()==>0x%08x\n",bbvalue));
+
+			RTPRINT(FINIT, INIT_IQK, ("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
+	
+	 	// Save ADDA parameters, turn Path A ADDA on
+	 	phy_SaveADDARegisters(pAdapter, ADDA_REG, pHalData->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pHalData->IQK_MAC_backup);
+		phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92C, pHalData->IQK_BB_backup, IQK_BB_REG_NUM);
+	}
+	
+ 	phy_PathADDAOn(pAdapter, ADDA_REG, TRUE, is2T);
+	
+	if(t==0)
+	{
+		pHalData->bRfPiEnable = (u1Byte)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+	}
+	
+	if(!pHalData->bRfPiEnable){
+		// Switch BB to PI mode to do IQ Calibration.
+		phy_PIModeSwitch(pAdapter, TRUE);
+	}
+	
+	//MAC settings
+	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pHalData->IQK_MAC_backup);
+	
+	//PHY_SetBBReg(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);		
+	PHY_SetBBReg(pAdapter, rCCK0_AFESetting, bMaskDWord, (0x0f000000 | (PHY_QueryBBReg(pAdapter, rCCK0_AFESetting, bMaskDWord))) );
+	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
+	{
+		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
+		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);	
+		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
+		PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);	
+	}
+
+	if(is2T)
+	{
+		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00010000);
+		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
+	}
+
+	{
+		//Page B init
+		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x00080000);
+		
+		if(is2T)
+		{
+			PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x00080000);
+		}
+	}
+	// IQ calibration setting
+	RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));		
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0x808000);
+	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
+
+	for(i = 0 ; i < retryCount ; i++){
+		PathAOK = phy_PathA_IQK_8192C(pAdapter, is2T);
+		if(PathAOK == 0x03){
+			RTPRINT(FINIT, INIT_IQK, ("Path A IQK Success!!\n"));
+				result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][2] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][3] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			break;
+		}
+		else if (i == (retryCount-1) && PathAOK == 0x01)	//Tx IQK OK
+		{
+			RTPRINT(FINIT, INIT_IQK, ("Path A IQK Only  Tx Success!!\n"));
+			
+			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;			
+		}
+	}
+
+	if(0x00 == PathAOK){		
+		RTPRINT(FINIT, INIT_IQK, ("Path A IQK failed!!\n"));		
+	}
+
+	if(is2T){
+		phy_PathAStandBy(pAdapter);
+
+		// Turn Path B ADDA on
+		phy_PathADDAOn(pAdapter, ADDA_REG, FALSE, is2T);
+
+		for(i = 0 ; i < retryCount ; i++){
+			PathBOK = phy_PathB_IQK_8192C(pAdapter);
+			if(PathBOK == 0x03){
+				RTPRINT(FINIT, INIT_IQK, ("Path B IQK Success!!\n"));
+				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				break;
+			}
+			else if (i == (retryCount - 1) && PathBOK == 0x01)	//Tx IQK OK
+			{
+				RTPRINT(FINIT, INIT_IQK, ("Path B Only Tx IQK Success!!\n"));
+				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;				
+			}
+		}
+
+		if(0x00 == PathBOK){		
+			RTPRINT(FINIT, INIT_IQK, ("Path B IQK failed!!\n"));		
+		}
+	}
+
+	//Back to BB mode, load original value
+	RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0);
+
+	if(t!=0)
+	{
+		if(!pHalData->bRfPiEnable){
+			// Switch back BB to SI mode after finish IQ Calibration.
+			phy_PIModeSwitch(pAdapter, FALSE);
+		}
+
+	 	// Reload ADDA power saving parameters
+	 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pHalData->ADDA_backup, IQK_ADDA_REG_NUM);
+
+		// Reload MAC parameters
+		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pHalData->IQK_MAC_backup);
+		
+	 	// Reload BB parameters
+		phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92C, pHalData->IQK_BB_backup, IQK_BB_REG_NUM);
+		
+		/*Restore RX initial gain*/
+		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
+		if (is2T)
+			PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
+		//load 0xe30 IQC default value
+		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);		
+		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);				
+		
+	}
+	RTPRINT(FINIT, INIT_IQK, ("phy_IQCalibrate_8192C() <==\n"));
+	
+}
+
+
+VOID	
+phy_LCCalibrate92C(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		is2T
+	)
+{
+	u1Byte	tmpReg;
+	u4Byte	RF_Amode=0, RF_Bmode=0, LC_Cal;
+//	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	//Check continuous TX and Packet TX
+	tmpReg = PlatformEFIORead1Byte(pAdapter, 0xd03);
+
+	if((tmpReg&0x70) != 0)			//Deal with contisuous TX case
+		PlatformEFIOWrite1Byte(pAdapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
+	else							// Deal with Packet TX case
+		PlatformEFIOWrite1Byte(pAdapter, REG_TXPAUSE, 0xFF);			// block all queues
+
+	if((tmpReg&0x70) != 0)
+	{
+		//1. Read original RF mode
+		//Path-A
+		RF_Amode = PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_AC, bMask12Bits);
+
+		//Path-B
+		if(is2T)
+			RF_Bmode = PHY_QueryRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits);	
+
+		//2. Set RF mode = standby mode
+		//Path-A
+		PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bMask12Bits, (RF_Amode&0x8FFFF)|0x10000);
+
+		//Path-B
+		if(is2T)
+			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits, (RF_Bmode&0x8FFFF)|0x10000);			
+	}
+	
+	//3. Read RF reg18
+	LC_Cal = PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_CHNLBW, bMask12Bits);
+	
+	//4. Set LC calibration begin	bit15
+	PHY_SetRFReg(pAdapter, RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal|0x08000);
+
+	delay_ms(100);		
+
+
+	//Restore original situation
+	if((tmpReg&0x70) != 0)	//Deal with contisuous TX case 
+	{  
+		//Path-A
+		PlatformEFIOWrite1Byte(pAdapter, 0xd03, tmpReg);
+		PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bMask12Bits, RF_Amode);
+		
+		//Path-B
+		if(is2T)
+			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits, RF_Bmode);
+	}
+	else // Deal with Packet TX case
+	{
+		PlatformEFIOWrite1Byte(pAdapter, REG_TXPAUSE, 0x00);	
+	}
+}
+
+
+VOID	
+phy_LCCalibrate(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		is2T
+	)
+{
+	phy_LCCalibrate92C(pAdapter, is2T);
+}
+
+
+
+//Analog Pre-distortion calibration
+#define		APK_BB_REG_NUM	8
+#define		APK_CURVE_REG_NUM 4
+#define		PATH_NUM		2
+
+VOID	
+phy_APCalibrate_8192C(
+	IN	PADAPTER	pAdapter,
+	IN	s1Byte 		delta,
+	IN	BOOLEAN		is2T
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	u4Byte 			regD[PATH_NUM];
+	u4Byte			tmpReg, index, offset, i, apkbound;
+	u1Byte			path, pathbound = PATH_NUM;
+	u4Byte			BB_backup[APK_BB_REG_NUM];
+	u4Byte			BB_REG[APK_BB_REG_NUM] = {	
+						rFPGA1_TxBlock, 	rOFDM0_TRxPathEnable, 
+						rFPGA0_RFMOD, 	rOFDM0_TRMuxPar, 
+						rFPGA0_XCD_RFInterfaceSW,	rFPGA0_XAB_RFInterfaceSW, 
+						rFPGA0_XA_RFInterfaceOE, 	rFPGA0_XB_RFInterfaceOE	};
+	u4Byte			BB_AP_MODE[APK_BB_REG_NUM] = {	
+						0x00000020, 0x00a05430, 0x02040000, 
+						0x000800e4, 0x00204000 };
+	u4Byte			BB_normal_AP_MODE[APK_BB_REG_NUM] = {	
+						0x00000020, 0x00a05430, 0x02040000, 
+						0x000800e4, 0x22204000 };						
+
+	u4Byte			AFE_backup[IQK_ADDA_REG_NUM];
+	u4Byte			AFE_REG[IQK_ADDA_REG_NUM] = {	
+						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth, 	
+						rRx_Wait_CCA, 		rTx_CCK_RFON,
+						rTx_CCK_BBON, 	rTx_OFDM_RFON, 	
+						rTx_OFDM_BBON, 	rTx_To_Rx,
+						rTx_To_Tx, 		rRx_CCK, 	
+						rRx_OFDM, 		rRx_Wait_RIFS,
+						rRx_TO_Rx, 		rStandby, 	
+						rSleep, 			rPMPD_ANAEN };
+
+	u4Byte			MAC_backup[IQK_MAC_REG_NUM];
+	u4Byte			MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE, 		REG_BCN_CTRL,	
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+
+	u4Byte			APK_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x0852c, 0x1852c, 0x5852c, 0x1852c, 0x5852c},
+					{0x2852e, 0x0852e, 0x3852e, 0x0852e, 0x0852e}
+					};	
+
+	u4Byte			APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	//path settings equal to path b settings
+					{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
+					};
+	
+	u4Byte			APK_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x52019, 0x52014, 0x52013, 0x5200f, 0x5208d},
+					{0x5201a, 0x52019, 0x52016, 0x52033, 0x52050}
+					};
+
+	u4Byte			APK_normal_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	//path settings equal to path b settings
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a}
+					};
+#if 0	
+	u4Byte			APK_RF_value_A[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x1adb0, 0x1adb0, 0x1ada0, 0x1ad90, 0x1ad80},		
+					{0x00fb0, 0x00fb0, 0x00fa0, 0x00f90, 0x00f80}						
+					};
+#endif
+	u4Byte			AFE_on_off[PATH_NUM] = {
+					0x04db25a4, 0x0b1b25a4};	//path A on path B off / path A off path B on
+
+	u4Byte			APK_offset[PATH_NUM] = {
+					rConfig_AntA, rConfig_AntB};
+
+	u4Byte			APK_normal_offset[PATH_NUM] = {
+					rConfig_Pmpd_AntA, rConfig_Pmpd_AntB};
+					
+	u4Byte			APK_value[PATH_NUM] = {
+					0x92fc0000, 0x12fc0000};					
+
+	u4Byte			APK_normal_value[PATH_NUM] = {
+					0x92680000, 0x12680000};					
+
+	s1Byte			APK_delta_mapping[APK_BB_REG_NUM][13] = {
+					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},											
+					{-6, -4, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-11, -9, -7, -5, -3, -1, 0, 0, 0, 0, 0, 0, 0}
+					};
+	
+	u4Byte			APK_normal_setting_value_1[13] = {
+					0x01017018, 0xf7ed8f84, 0x1b1a1816, 0x2522201e, 0x322e2b28,
+					0x433f3a36, 0x5b544e49, 0x7b726a62, 0xa69a8f84, 0xdfcfc0b3,
+					0x12680000, 0x00880000, 0x00880000
+					};
+
+	u4Byte			APK_normal_setting_value_2[16] = {
+					0x01c7021d, 0x01670183, 0x01000123, 0x00bf00e2, 0x008d00a3,
+					0x0068007b, 0x004d0059, 0x003a0042, 0x002b0031, 0x001f0025,
+					0x0017001b, 0x00110014, 0x000c000f, 0x0009000b, 0x00070008,
+					0x00050006
+					};
+	
+	u4Byte			APK_result[PATH_NUM][APK_BB_REG_NUM];	//val_1_1a, val_1_2a, val_2a, val_3a, val_4a
+//	u4Byte			AP_curve[PATH_NUM][APK_CURVE_REG_NUM];
+
+	s4Byte			BB_offset, delta_V, delta_offset;
+
+#if MP_DRIVER == 1
+	PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);	
+
+	pMptCtx->APK_bound[0] = 45;
+	pMptCtx->APK_bound[1] = 52;		
+#endif
+
+	RTPRINT(FINIT, INIT_IQK, ("==>phy_APCalibrate_8192C() delta %d\n", delta));
+	RTPRINT(FINIT, INIT_IQK, ("AP Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
+	if(!is2T)
+		pathbound = 1;
+
+	//2 FOR NORMAL CHIP SETTINGS
+
+// Temporarily do not allow normal driver to do the following settings because these offset
+// and value will cause RF internal PA to be unpredictably disabled by HW, such that RF Tx signal
+// will disappear after disable/enable card many times on 88CU. RF SD and DD have not find the
+// root cause, so we remove these actions temporarily. Added by tynli and SD3 Allen. 2010.05.31.
+#if MP_DRIVER != 1
+	return;
+#endif
+	//settings adjust for normal chip
+	for(index = 0; index < PATH_NUM; index ++)
+	{
+		APK_offset[index] = APK_normal_offset[index];
+		APK_value[index] = APK_normal_value[index];
+		AFE_on_off[index] = 0x6fdb25a4;
+	}
+
+	for(index = 0; index < APK_BB_REG_NUM; index ++)
+	{
+		for(path = 0; path < pathbound; path++)
+		{
+			APK_RF_init_value[path][index] = APK_normal_RF_init_value[path][index];
+			APK_RF_value_0[path][index] = APK_normal_RF_value_0[path][index];
+		}
+		BB_AP_MODE[index] = BB_normal_AP_MODE[index];
+	}			
+
+	apkbound = 6;
+	
+	//save BB default value
+	for(index = 0; index < APK_BB_REG_NUM ; index++)
+	{
+		if(index == 0)		//skip 
+			continue;				
+		BB_backup[index] = PHY_QueryBBReg(pAdapter, BB_REG[index], bMaskDWord);
+	}
+	
+	//save MAC default value													
+	phy_SaveMACRegisters(pAdapter, MAC_REG, MAC_backup);
+	
+	//save AFE default value
+	phy_SaveADDARegisters(pAdapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+
+	for(path = 0; path < pathbound; path++)
+	{
+
+
+		if(path == RF_PATH_A)
+		{
+			//path A APK
+			//load APK setting
+			//path-A		
+			offset = rPdp_AntA;
+			for(index = 0; index < 11; index ++)			
+			{
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
+				offset += 0x04;
+			}
+			
+			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
+			
+			offset = rConfig_AntA;
+			for(; index < 13; index ++) 		
+			{
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
+				offset += 0x04;
+			}	
+			
+			//page-B1
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0x400000);
+		
+			//path A
+			offset = rPdp_AntA;
+			for(index = 0; index < 16; index++)
+			{
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);		
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
+				offset += 0x04;
+			}				
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0);							
+		}
+		else if(path == RF_PATH_B)
+		{
+			//path B APK
+			//load APK setting
+			//path-B		
+			offset = rPdp_AntB;
+			for(index = 0; index < 10; index ++)			
+			{
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
+				offset += 0x04;
+			}
+			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntA, bMaskDWord, 0x12680000);
+			
+			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
+			
+			offset = rConfig_AntA;
+			index = 11;
+			for(; index < 13; index ++) //offset 0xb68, 0xb6c		
+			{
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
+				offset += 0x04;
+			}	
+			
+			//page-B1
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0x400000);
+			
+			//path B
+			offset = 0xb60;
+			for(index = 0; index < 16; index++)
+			{
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);		
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
+				offset += 0x04;
+			}				
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0);							
+		}
+	
+		//save RF default value
+		regD[path] = PHY_QueryRFReg(pAdapter, path, RF_TXBIAS_A, bRFRegOffsetMask);
+		
+		//Path A AFE all on, path B AFE All off or vise versa
+		for(index = 0; index < IQK_ADDA_REG_NUM ; index++)
+			PHY_SetBBReg(pAdapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
+		RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0xe70 %x\n", PHY_QueryBBReg(pAdapter, rRx_Wait_CCA, bMaskDWord)));		
+
+		//BB to AP mode
+		if(path == 0)
+		{				
+			for(index = 0; index < APK_BB_REG_NUM ; index++)
+			{
+
+				if(index == 0)		//skip 
+					continue;			
+				else if (index < 5)
+				PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
+				else if (BB_REG[index] == 0x870)
+					PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]|BIT10|BIT26);
+				else
+					PHY_SetBBReg(pAdapter, BB_REG[index], BIT10, 0x0);					
+			}
+
+			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);			
+			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);					
+		}
+		else		//path B
+		{
+			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x01008c00);			
+			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x01008c00);					
+		
+		}
+
+		RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x800 %x\n", PHY_QueryBBReg(pAdapter, 0x800, bMaskDWord)));				
+
+		//MAC settings
+		phy_MACSettingCalibration(pAdapter, MAC_REG, MAC_backup);
+		
+		if(path == RF_PATH_A)	//Path B to standby mode
+		{
+			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);			
+		}
+		else			//Path A to standby mode
+		{
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);			
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);			
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20103);						
+		}
+
+		delta_offset = ((delta+14)/2);
+		if(delta_offset < 0)
+			delta_offset = 0;
+		else if (delta_offset > 12)
+			delta_offset = 12;
+			
+		//AP calibration
+		for(index = 0; index < APK_BB_REG_NUM; index++)
+		{
+			if(index != 1)	//only DO PA11+PAD01001, AP RF setting
+				continue;
+					
+			tmpReg = APK_RF_init_value[path][index];
+#if 1			
+			if(!pHalData->bAPKThermalMeterIgnore)
+			{
+				BB_offset = (tmpReg & 0xF0000) >> 16;
+
+				if(!(tmpReg & BIT15)) //sign bit 0
+				{
+					BB_offset = -BB_offset;
+				}
+
+				delta_V = APK_delta_mapping[index][delta_offset];
+				
+				BB_offset += delta_V;
+
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() APK index %d tmpReg 0x%x delta_V %d delta_offset %d\n", index, tmpReg, delta_V, delta_offset));		
+				
+				if(BB_offset < 0)
+				{
+					tmpReg = tmpReg & (~BIT15);
+					BB_offset = -BB_offset;
+				}
+				else
+				{
+					tmpReg = tmpReg | BIT15;
+				}
+				tmpReg = (tmpReg & 0xFFF0FFFF) | (BB_offset << 16);
+			}
+#endif
+
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+			if(IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID))
+				PHY_SetRFReg(pAdapter, path, RF_IPA_A, bRFRegOffsetMask, 0x894ae);
+			else
+#endif	
+				PHY_SetRFReg(pAdapter, path, RF_IPA_A, bRFRegOffsetMask, 0x8992e);
+			RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0xc %x\n", PHY_QueryRFReg(pAdapter, path, RF_IPA_A, bRFRegOffsetMask)));		
+			PHY_SetRFReg(pAdapter, path, RF_AC, bRFRegOffsetMask, APK_RF_value_0[path][index]);
+			RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x0 %x\n", PHY_QueryRFReg(pAdapter, path, RF_AC, bRFRegOffsetMask)));		
+			PHY_SetRFReg(pAdapter, path, RF_TXBIAS_A, bRFRegOffsetMask, tmpReg);
+			RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0xd %x\n", PHY_QueryRFReg(pAdapter, path, RF_TXBIAS_A, bRFRegOffsetMask)));					
+			
+			// PA11+PAD01111, one shot	
+			i = 0;
+			do
+			{
+				PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0x800000);
+				{
+					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[0]);		
+					RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
+					delay_ms(3);				
+					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[1]);
+					RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
+
+					delay_ms(20);
+				}
+				PHY_SetBBReg(pAdapter, rFPGA0_IQK, 0xffffff00, 0);
+
+				if(path == RF_PATH_A)
+					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0x03E00000);
+				else
+					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0xF8000000);
+				RTPRINT(FINIT, INIT_IQK, ("phy_APCalibrate_8192C() offset 0xbd8[25:21] %x\n", tmpReg));		
+				
+
+				i++;
+			}
+			while(tmpReg > apkbound && i < 4);
+
+			APK_result[path][index] = tmpReg;
+		}
+	}
+
+	//reload MAC default value	
+	phy_ReloadMACRegisters(pAdapter, MAC_REG, MAC_backup);
+	
+	//reload BB default value	
+	for(index = 0; index < APK_BB_REG_NUM ; index++)
+	{
+
+		if(index == 0)		//skip 
+			continue;					
+		PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]);
+	}
+
+	//reload AFE default value
+	phy_ReloadADDARegisters(pAdapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+
+	//reload RF path default value
+	for(path = 0; path < pathbound; path++)
+	{
+		PHY_SetRFReg(pAdapter, path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
+		if(path == RF_PATH_B)
+		{
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);			
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);						
+		}
+
+		//note no index == 0
+		if (APK_result[path][1] > 6)
+			APK_result[path][1] = 6;
+		RTPRINT(FINIT, INIT_IQK, ("apk path %d result %d 0x%x \t", path, 1, APK_result[path][1]));					
+	}
+
+	RTPRINT(FINIT, INIT_IQK, ("\n"));
+	
+
+	for(path = 0; path < pathbound; path++)
+	{
+		PHY_SetRFReg(pAdapter, path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask, 
+		((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (APK_result[path][1] << 5) | APK_result[path][1]));
+		if(path == RF_PATH_A)
+			PHY_SetRFReg(pAdapter, path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask, 
+			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x00 << 5) | 0x05));		
+		else
+		PHY_SetRFReg(pAdapter, path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask, 
+			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));						
+			
+		PHY_SetRFReg(pAdapter, path, RF_BS_PA_APSET_G9_G11, bRFRegOffsetMask, ((0x08 << 15) | (0x08 << 10) | (0x08 << 5) | 0x08));			
+	}
+
+	pHalData->bAPKdone = TRUE;
+
+	RTPRINT(FINIT, INIT_IQK, ("<==phy_APCalibrate_8192C()\n"));
+}
+
+
+VOID
+PHY_IQCalibrate_8192C(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN 	bReCovery
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	s4Byte			result[4][8];	//last is final result
+	u1Byte			i, final_candidate, Indexforchannel;
+	BOOLEAN			bPathAOK, bPathBOK;
+	s4Byte			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
+	BOOLEAN			is12simular, is13simular, is23simular;	
+	BOOLEAN 		bStartContTx = FALSE, bSingleTone = FALSE, bCarrierSuppression = FALSE;
+	u4Byte			IQK_BB_REG_92C[IQK_BB_REG_NUM] = {
+					rOFDM0_XARxIQImbalance, 	rOFDM0_XBRxIQImbalance, 
+					rOFDM0_ECCAThreshold, 	rOFDM0_AGCRSSITable,
+					rOFDM0_XATxIQImbalance, 	rOFDM0_XBTxIQImbalance, 
+					rOFDM0_XCTxAFE, 			rOFDM0_XDTxAFE, 
+					rOFDM0_RxIQExtAnta};
+
+	if (ODM_CheckPowerStatus(pAdapter) == FALSE)
+		return;
+	
+#if MP_DRIVER == 1	
+	bStartContTx = pAdapter->MptCtx.bStartContTx;
+	bSingleTone = pAdapter->MptCtx.bSingleTone;
+	bCarrierSuppression = pAdapter->MptCtx.bCarrierSuppression;	
+#endif
+	
+	//ignore IQK when continuous Tx
+	if(bStartContTx || bSingleTone || bCarrierSuppression)
+		return;
+
+#ifdef DISABLE_BB_RF
+	return;
+#endif
+	if(pAdapter->bSlaveOfDMSP)
+		return;
+
+	if (bReCovery)
+		{
+			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92C, pHalData->IQK_BB_backup_recover, 9);
+			return;		
+
+		}
+
+	RTPRINT(FINIT, INIT_IQK, ("IQK:Start!!!\n"));
+
+	for(i = 0; i < 8; i++)
+	{
+		result[0][i] = 0;
+		result[1][i] = 0;
+		result[2][i] = 0;
+		result[3][i] = 0;
+	}
+	final_candidate = 0xff;
+	bPathAOK = FALSE;
+	bPathBOK = FALSE;
+	is12simular = FALSE;
+	is23simular = FALSE;
+	is13simular = FALSE;
+
+	AcquireCCKAndRWPageAControl(pAdapter);
+	/*RT_TRACE(COMP_INIT,DBG_LOUD,("Acquire Mutex in IQCalibrate\n"));*/
+	for (i=0; i<3; i++)
+	{
+		/*For 88C 1T1R*/
+		phy_IQCalibrate_8192C(pAdapter, result, i, FALSE);
+		
+		if(i == 1)
+		{
+			is12simular = phy_SimularityCompare(pAdapter, result, 0, 1);
+			if(is12simular)
+			{
+				final_candidate = 0;
+				break;
+			}
+		}
+		
+		if(i == 2)
+		{
+			is13simular = phy_SimularityCompare(pAdapter, result, 0, 2);
+			if(is13simular)
+			{
+				final_candidate = 0;			
+				break;
+			}
+			
+			is23simular = phy_SimularityCompare(pAdapter, result, 1, 2);
+			if(is23simular)
+				final_candidate = 1;
+			else
+			{
+				for(i = 0; i < 8; i++)
+					RegTmp += result[3][i];
+
+				if(RegTmp != 0)
+					final_candidate = 3;			
+				else
+					final_candidate = 0xFF;
+			}
+		}
+	}
+//	RT_TRACE(COMP_INIT,DBG_LOUD,("Release Mutex in IQCalibrate \n"));
+	ReleaseCCKAndRWPageAControl(pAdapter);
+
+	for (i=0; i<4; i++)
+	{
+		RegE94 = result[i][0];
+		RegE9C = result[i][1];
+		RegEA4 = result[i][2];
+		RegEAC = result[i][3];
+		RegEB4 = result[i][4];
+		RegEBC = result[i][5];
+		RegEC4 = result[i][6];
+		RegECC = result[i][7];
+		RTPRINT(FINIT, INIT_IQK, ("IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
+	}
+	
+	if(final_candidate != 0xff)
+	{
+		pHalData->RegE94 = RegE94 = result[final_candidate][0];
+		pHalData->RegE9C = RegE9C = result[final_candidate][1];
+		RegEA4 = result[final_candidate][2];
+		RegEAC = result[final_candidate][3];
+		pHalData->RegEB4 = RegEB4 = result[final_candidate][4];
+		pHalData->RegEBC = RegEBC = result[final_candidate][5];
+		RegEC4 = result[final_candidate][6];
+		RegECC = result[final_candidate][7];
+		RTPRINT(FINIT, INIT_IQK, ("IQK: final_candidate is %x\n",final_candidate));
+		RTPRINT(FINIT, INIT_IQK, ("IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
+		bPathAOK = bPathBOK = TRUE;
+	}
+	else
+	{
+		RegE94 = RegEB4 = pHalData->RegE94 = pHalData->RegEB4 = 0x100;	//X default value
+		RegE9C = RegEBC = pHalData->RegE9C = pHalData->RegEBC = 0x0;		//Y default value
+	}
+	
+	if((RegE94 != 0)/*&&(RegEA4 != 0)*/)
+	{
+		if(pHalData->CurrentBandType == BAND_ON_5G)
+			phy_PathAFillIQKMatrix_5G_Normal(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));			
+		else		
+			phy_PathAFillIQKMatrix(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+
+	}
+	
+	if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+	{
+		if((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
+		{
+			if(pHalData->CurrentBandType == BAND_ON_5G)		
+				phy_PathBFillIQKMatrix_5G_Normal(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+			else
+				phy_PathBFillIQKMatrix(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+		}
+	}
+	
+	phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92C, pHalData->IQK_BB_backup_recover, 9);
+
+}
+
+
+VOID
+PHY_LCCalibrate_8192C(
+	IN	PADAPTER	pAdapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	BOOLEAN 		bStartContTx = FALSE, bSingleTone = FALSE, bCarrierSuppression = FALSE;
+	PMGNT_INFO		pMgntInfo=&pAdapter->MgntInfo;
+	PMGNT_INFO		pMgntInfoBuddyAdapter;
+	u4Byte			timeout = 2000, timecount = 0;
+	PADAPTER	BuddyAdapter = pAdapter->BuddyAdapter;
+
+#if MP_DRIVER == 1	
+	bStartContTx = pAdapter->MptCtx.bStartContTx;
+	bSingleTone = pAdapter->MptCtx.bSingleTone;
+	bCarrierSuppression = pAdapter->MptCtx.bCarrierSuppression;		
+#endif
+
+#ifdef DISABLE_BB_RF
+	return;
+#endif
+
+	//ignore LCK when continuous Tx
+	if(bStartContTx || bSingleTone || bCarrierSuppression)
+		return;
+
+	if(BuddyAdapter != NULL &&
+		((pAdapter->interfaceIndex == 0 && pHalData->CurrentBandType == BAND_ON_2_4G) ||
+		(pAdapter->interfaceIndex == 1 && pHalData->CurrentBandType == BAND_ON_5G)))
+	{
+		pMgntInfoBuddyAdapter=&BuddyAdapter->MgntInfo;
+		while(pMgntInfoBuddyAdapter->bScanInProgress && timecount < timeout)
+		{
+			delay_ms(50);
+			timecount += 50;
+		}
+	}
+
+	while(pMgntInfo->bScanInProgress && timecount < timeout)
+	{
+		delay_ms(50);
+		timecount += 50;
+	}	
+	
+	pHalData->bLCKInProgress = TRUE;
+
+	RTPRINT(FINIT, INIT_IQK, ("LCK:Start!!!interface %d currentband %x delay %d ms\n", pAdapter->interfaceIndex, pHalData->CurrentBandType, timecount));
+	
+	//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+	if(IS_2T2R(pHalData->VersionID))
+	{
+		phy_LCCalibrate(pAdapter, TRUE);
+	}
+	else{
+		// For 88C 1T1R
+		phy_LCCalibrate(pAdapter, FALSE);
+	}
+
+	pHalData->bLCKInProgress = FALSE;
+
+	RTPRINT(FINIT, INIT_IQK, ("LCK:Finish!!!interface %d\n", pAdapter->interfaceIndex));
+	
+
+}
+
+VOID
+PHY_APCalibrate_8192C(
+	IN	PADAPTER	pAdapter,
+	IN	s1Byte 		delta	
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	//default disable APK, because Tx NG issue, suggest by Jenyu, 2011.11.25
+	return;
+
+#ifdef DISABLE_BB_RF
+	return;
+#endif
+
+#if FOR_BRAZIL_PRETEST != 1
+	if(pHalData->bAPKdone)
+#endif		
+		return;
+
+	if(IS_92C_SERIAL( pHalData->VersionID)){
+		phy_APCalibrate_8192C(pAdapter, delta, TRUE);
+	}
+	else{
+		// For 88C 1T1R
+		phy_APCalibrate_8192C(pAdapter, delta, FALSE);
+	}
+}
+
+
+#endif
+
+
+//3============================================================
+//3 IQ Calibration
+//3============================================================
+
+VOID
+ODM_ResetIQKResult(
+	IN	PVOID		pDM_VOID 
+)
+{
+	return;
+}
+#if 1//!(DM_ODM_SUPPORT_TYPE & ODM_AP)
+u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
+{
+	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] = 
+	{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+	u1Byte	place = chnl;
+
+	
+	if(chnl > 14)
+	{
+		for(place = 14; place<sizeof(channel_all); place++)
+		{
+			if(channel_all[place] == chnl)
+			{
+				return place-13;
+			}
+		}
+	}	
+	return 0;
+
+}
+#endif
+
+VOID
+odm_IQCalibrate(
+		IN	PDM_ODM_T	pDM_Odm 
+		)
+{
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	if (*pDM_Odm->pIsFcsModeEnable)
+		return;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))		
+	if (!IS_HARDWARE_TYPE_JAGUAR(Adapter))
+		return;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	else if (IS_HARDWARE_TYPE_8812AU(Adapter))
+		return;
+#endif
+#endif
+	
+#if (RTL8821A_SUPPORT == 1)
+	if (pDM_Odm->bLinked) {
+		if ((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess)) {
+			pDM_Odm->preChannel = *pDM_Odm->pChannel;
+			pDM_Odm->LinkedInterval = 0;
+		}
+
+		if (pDM_Odm->LinkedInterval < 3)
+			pDM_Odm->LinkedInterval++;
+		
+		if (pDM_Odm->LinkedInterval == 2) {
+			/*Mark out IQK flow to prevent tx stuck. by Maddest 20130306*/
+			/*Open it verified by James 20130715*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+			PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			PHY_IQCalibrate(Adapter, FALSE);
+#else
+			PHY_IQCalibrate_8821A(Adapter, FALSE);
+#endif
+		}
+	} else
+		pDM_Odm->LinkedInterval = 0;
+#endif
+}
+
+void phydm_rf_init(IN	PVOID		pDM_VOID)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	odm_TXPowerTrackingInit(pDM_Odm);
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_ClearTxPowerTrackingState(pDM_Odm);	
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+#if (RTL8814A_SUPPORT == 1)		
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		PHY_IQCalibrate_8814A_Init(pDM_Odm);
+#endif	
+#endif
+
+}
+
+void phydm_rf_watchdog(IN	PVOID		pDM_VOID)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_TXPowerTrackingCheck(pDM_Odm);
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		odm_IQCalibrate(pDM_Odm);
+#endif
+}
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.h
new file mode 100644
index 000000000..4cacdb54a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ap.h
@@ -0,0 +1,162 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+ #ifndef __HAL_PHY_RF_H__
+ #define __HAL_PHY_RF_H__
+ 
+#include "phydm_powertracking_ap.h"
+#if (RTL8814A_SUPPORT == 1)
+#include "rtl8814a/phydm_iqk_8814a.h"
+#endif
+
+#if (RTL8822B_SUPPORT == 1)
+#include "rtl8822b/phydm_iqk_8822b.h"
+#endif
+
+
+typedef enum _PWRTRACK_CONTROL_METHOD {
+	BBSWING,
+	TXAGC,
+	MIX_MODE,
+	TSSI_MODE
+} PWRTRACK_METHOD;
+
+typedef VOID 	(*FuncSetPwr)(PVOID, PWRTRACK_METHOD, u1Byte, u1Byte);
+typedef VOID(*FuncIQK)(PVOID, u1Byte, u1Byte, u1Byte);
+typedef VOID 	(*FuncLCK)(PVOID);
+				//refine by YuChen for 8814A
+typedef VOID  	(*FuncSwing)(PVOID, pu1Byte*, pu1Byte*, pu1Byte*, pu1Byte*);
+typedef VOID	(*FuncSwing8814only)(PVOID, pu1Byte*, pu1Byte*, pu1Byte*, pu1Byte*);
+
+typedef struct _TXPWRTRACK_CFG {
+	u1Byte 		SwingTableSize_CCK;	
+	u1Byte 		SwingTableSize_OFDM;
+	u1Byte 		Threshold_IQK;
+	u1Byte 		Threshold_DPK;	
+	u1Byte 		AverageThermalNum;
+	u1Byte 		RfPathCount;
+	u4Byte 		ThermalRegAddr;	
+	FuncSetPwr 	ODM_TxPwrTrackSetPwr;
+	FuncIQK 	DoIQK;
+	FuncLCK		PHY_LCCalibrate;
+	FuncSwing	GetDeltaSwingTable;
+	FuncSwing8814only	GetDeltaSwingTable8814only;
+} TXPWRTRACK_CFG, *PTXPWRTRACK_CFG;
+
+VOID 
+ConfigureTxpowerTrack(
+	IN	PVOID		pDM_VOID,
+	OUT	PTXPWRTRACK_CFG	pConfig
+	);
+
+
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	);
+
+#if (RTL8192E_SUPPORT==1) 
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter_92E(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	);
+#endif
+
+#if (RTL8814A_SUPPORT == 1)
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter_JaguarSeries2(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	);
+
+#elif ODM_IC_11AC_SERIES_SUPPORT
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter_JaguarSeries(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN	PVOID		pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	);
+#endif
+
+#define IS_CCK_RATE(_rate) 				(ODM_MGN_1M == _rate || _rate == ODM_MGN_2M || _rate == ODM_MGN_5_5M || _rate == ODM_MGN_11M )
+
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#define MAX_TOLERANCE          5
+#define IQK_DELAY_TIME         1               //ms
+
+ //
+// BB/MAC/RF other monitor API
+//
+
+void	PHY_SetMonitorMode8192C(IN	PADAPTER	pAdapter,
+										IN	BOOLEAN		bEnableMonitorMode	);
+										
+//
+// IQ calibrate
+//
+void	
+PHY_IQCalibrate_8192C(		IN	PADAPTER	pAdapter,	
+							IN	BOOLEAN 	bReCovery);
+							
+//
+// LC calibrate
+//
+void	
+PHY_LCCalibrate_8192C(		IN	PADAPTER	pAdapter);
+
+//
+// AP calibrate
+//
+void	
+PHY_APCalibrate_8192C(		IN	PADAPTER	pAdapter,
+								IN 	s1Byte		delta);
+#endif
+
+#define ODM_TARGET_CHNL_NUM_2G_5G	59
+
+
+VOID
+ODM_ResetIQKResult(
+	IN	PVOID		pDM_VOID
+);
+u1Byte 
+ODM_GetRightChnlPlaceforIQK(
+    IN u1Byte chnl
+);
+
+void phydm_rf_init(IN	PVOID		pDM_VOID);
+void phydm_rf_watchdog(IN	PVOID		pDM_VOID);
+								
+#endif	// #ifndef __HAL_PHY_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.c
new file mode 100644
index 000000000..9e10787b2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.c
@@ -0,0 +1,710 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+
+#define 	CALCULATE_SWINGTALBE_OFFSET(_offset, _direction, _size, _deltaThermal) \
+					do {\
+						for(_offset = 0; _offset < _size; _offset++)\
+						{\
+							if(_deltaThermal < thermalThreshold[_direction][_offset])\
+							{\
+								if(_offset != 0)\
+									_offset--;\
+								break;\
+							}\
+						}			\
+						if(_offset >= _size)\
+							_offset = _size-1;\
+					} while(0)
+
+void ConfigureTxpowerTrack(
+	IN		PVOID					pDM_VOID,
+	OUT	PTXPWRTRACK_CFG	pConfig
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+#if RTL8192E_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8192E)
+		ConfigureTxpowerTrack_8192E(pConfig);
+#endif	
+#if RTL8821A_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8821)
+		ConfigureTxpowerTrack_8821A(pConfig);
+#endif
+#if RTL8812A_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8812)
+		ConfigureTxpowerTrack_8812A(pConfig);
+#endif
+#if RTL8188E_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		ConfigureTxpowerTrack_8188E(pConfig);
+#endif 
+
+#if RTL8723B_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8723B)
+		ConfigureTxpowerTrack_8723B(pConfig);
+#endif
+
+#if RTL8814A_SUPPORT
+	if (pDM_Odm->SupportICType == ODM_RTL8814A)
+		ConfigureTxpowerTrack_8814A(pConfig);
+#endif
+
+#if RTL8703B_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8703B)
+		ConfigureTxpowerTrack_8703B(pConfig);
+#endif
+
+#if RTL8188F_SUPPORT
+	if (pDM_Odm->SupportICType == ODM_RTL8188F)
+		ConfigureTxpowerTrack_8188F(pConfig);
+#endif 
+}
+
+//======================================================================
+// <20121113, Kordan> This function should be called when TxAGC changed.
+// Otherwise the previous compensation is gone, because we record the 
+// delta of temperature between two TxPowerTracking watch dogs.
+//
+// NOTE: If Tx BB swing or Tx scaling is varified during run-time, still 
+//       need to call this function.
+//======================================================================
+VOID
+ODM_ClearTxPowerTrackingState(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+	u1Byte 			p = 0;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	
+	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
+	pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->DefaultCckIndex;
+	pDM_Odm->RFCalibrateInfo.CCK_index = 0;
+	
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
+	{
+		pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+		pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+		pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+
+		pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+		pRFCalibrateInfo->DeltaPowerIndex[p] = 0;
+		pRFCalibrateInfo->DeltaPowerIndexLast[p] = 0;
+		pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+
+		pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = 0;    /* Initial Mix mode power tracking*/
+		pRFCalibrateInfo->Remnant_OFDMSwingIdx[p] = 0;			  
+		pRFCalibrateInfo->KfreeOffset[p] = 0;
+	}
+	
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = FALSE;       /*Initial at Modify Tx Scaling Mode*/
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathB = FALSE;       /*Initial at Modify Tx Scaling Mode*/
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathC = FALSE;       /*Initial at Modify Tx Scaling Mode*/
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathD = FALSE;       /*Initial at Modify Tx Scaling Mode*/
+	pRFCalibrateInfo->Remnant_CCKSwingIdx = 0;
+	pRFCalibrateInfo->ThermalValue = pHalData->EEPROMThermalMeter;
+	
+	pRFCalibrateInfo->Modify_TxAGC_Value_CCK=0;			//modify by Mingzhi.Guo
+	pRFCalibrateInfo->Modify_TxAGC_Value_OFDM=0;		//modify by Mingzhi.Guo
+}
+
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm
+#else
+	IN PADAPTER	Adapter
+#endif
+	)
+{
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+	#endif
+#endif
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	u1Byte			ThermalValue = 0, delta, delta_LCK, delta_IQK, p = 0, i = 0;
+	s1Byte			diff_DPK[4] = {0};
+	u1Byte			ThermalValue_AVG_count = 0;
+	u4Byte			ThermalValue_AVG = 0;	
+
+	u1Byte			OFDM_min_index = 0;  // OFDM BB Swing should be less than +3.0dB, which is required by Arthur
+	u1Byte			Indexforchannel = 0; // GetRightChnlPlaceforIQK(pHalData->CurrentChannel)
+	BOOLEAN			bTSSIenable = FALSE;
+
+	TXPWRTRACK_CFG 	c;
+
+	//4 1. The following TWO tables decide the final index of OFDM/CCK swing table.
+	pu1Byte			deltaSwingTableIdx_TUP_A;
+	pu1Byte			deltaSwingTableIdx_TDOWN_A;
+	pu1Byte			deltaSwingTableIdx_TUP_B;
+	pu1Byte			deltaSwingTableIdx_TDOWN_B;
+	/*for 8814 add by Yu Chen*/
+	pu1Byte			deltaSwingTableIdx_TUP_C;
+	pu1Byte			deltaSwingTableIdx_TDOWN_C;
+	pu1Byte			deltaSwingTableIdx_TUP_D;
+	pu1Byte			deltaSwingTableIdx_TDOWN_D;
+	
+	//4 2. Initilization ( 7 steps in total )
+
+	ConfigureTxpowerTrack(pDM_Odm, &c);
+
+	(*c.GetDeltaSwingTable)(pDM_Odm, (pu1Byte*)&deltaSwingTableIdx_TUP_A, (pu1Byte*)&deltaSwingTableIdx_TDOWN_A,
+									  (pu1Byte*)&deltaSwingTableIdx_TUP_B, (pu1Byte*)&deltaSwingTableIdx_TDOWN_B);	
+	
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)	/*for 8814 path C & D*/
+		(*c.GetDeltaSwingTable8814only)(pDM_Odm, (pu1Byte *)&deltaSwingTableIdx_TUP_C, (pu1Byte *)&deltaSwingTableIdx_TDOWN_C,
+			(pu1Byte *)&deltaSwingTableIdx_TUP_D, (pu1Byte *)&deltaSwingTableIdx_TDOWN_D);
+	
+	
+	pDM_Odm->RFCalibrateInfo.TXPowerTrackingCallbackCnt++; //cosa add for debug
+	pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = TRUE;
+    
+#if (MP_DRIVER == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = pHalData->TxPowerTrackControl; // <Kordan> We should keep updating the control variable according to HalData.
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if (pDM_Odm->mp_mode == TRUE)
+#endif
+		// <Kordan> RFCalibrateInfo.RegA24 will be initialized when ODM HW configuring, but MP configures with para files.
+		pDM_Odm->RFCalibrateInfo.RegA24 = 0x090e1317;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+		("===>ODM_TXPowerTrackingCallback_ThermalMeter Start\n pRFCalibrateInfo->BbSwingIdxCckBase: %d, pRFCalibrateInfo->BbSwingIdxOfdmBase[A]: %d, pRFCalibrateInfo->DefaultOfdmIndex: %d\n", 
+		pRFCalibrateInfo->BbSwingIdxCckBase, pRFCalibrateInfo->BbSwingIdxOfdmBase[ODM_RF_PATH_A], pRFCalibrateInfo->DefaultOfdmIndex));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+		("pDM_Odm->RFCalibrateInfo.TxPowerTrackControl %d,  pHalData->EEPROMThermalMeter %d\n", pDM_Odm->RFCalibrateInfo.TxPowerTrackControl,  pHalData->EEPROMThermalMeter));
+	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
+	if( ! pDM_Odm->RFCalibrateInfo.TxPowerTrackControl || pHalData->EEPROMThermalMeter == 0 || 
+		pHalData->EEPROMThermalMeter == 0xFF)
+		return;
+
+
+	//4 3. Initialize ThermalValues of RFCalibrateInfo
+
+	if(pDM_Odm->RFCalibrateInfo.bReloadtxpowerindex)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));				
+	}
+
+	//4 4. Calculate average thermal meter
+	
+	pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index] = ThermalValue;
+	pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index++;
+	if(pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index == c.AverageThermalNum)   //Average times =  c.AverageThermalNum
+		pDM_Odm->RFCalibrateInfo.ThermalValue_AVG_index = 0;
+
+	for(i = 0; i < c.AverageThermalNum; i++)
+	{
+		if(pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[i])
+		{
+			ThermalValue_AVG += pDM_Odm->RFCalibrateInfo.ThermalValue_AVG[i];
+			ThermalValue_AVG_count++;
+		}
+	}
+
+	if(ThermalValue_AVG_count)               //Calculate Average ThermalValue after average enough times
+	{
+		ThermalValue = (u1Byte)(ThermalValue_AVG / ThermalValue_AVG_count);
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", ThermalValue, pHalData->EEPROMThermalMeter));					
+	}
+			
+	//4 5. Calculate delta, delta_LCK, delta_IQK.
+
+	//"delta" here is used to determine whether thermal value changes or not.
+	delta 	  = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue):(pDM_Odm->RFCalibrateInfo.ThermalValue - ThermalValue);
+	delta_LCK = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue_LCK)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue_LCK):(pDM_Odm->RFCalibrateInfo.ThermalValue_LCK - ThermalValue);
+	delta_IQK = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue_IQK)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue_IQK):(pDM_Odm->RFCalibrateInfo.ThermalValue_IQK - ThermalValue);
+
+	if (pDM_Odm->RFCalibrateInfo.ThermalValue_IQK == 0xff) {	/*no PG, use thermal value for IQK*/
+		pDM_Odm->RFCalibrateInfo.ThermalValue_IQK = ThermalValue;
+		delta_IQK = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue_IQK)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue_IQK):(pDM_Odm->RFCalibrateInfo.ThermalValue_IQK - ThermalValue);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("no PG, use ThermalValue for IQK\n"));
+	}
+	
+	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+		diff_DPK[p] = (s1Byte)ThermalValue - (s1Byte)pDM_Odm->RFCalibrateInfo.DpkThermal[p];
+
+	/*4 6. If necessary, do LCK.*/	
+	if (!(pDM_Odm->SupportICType & ODM_RTL8821)) {
+
+		if (pDM_Odm->RFCalibrateInfo.ThermalValue_LCK == 0xff) {
+			/*no PG , do LCK at initial status*/
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("no PG, do LCK\n"));
+			pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = ThermalValue;
+			if (c.PHY_LCCalibrate)
+				(*c.PHY_LCCalibrate)(pDM_Odm);
+			delta_LCK = (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue_LCK)?(ThermalValue - pDM_Odm->RFCalibrateInfo.ThermalValue_LCK):(pDM_Odm->RFCalibrateInfo.ThermalValue_LCK - ThermalValue);
+		}
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("(delta, delta_LCK, delta_IQK) = (%d, %d, %d)\n", delta, delta_LCK, delta_IQK));
+		/*DBG_871X("(delta, delta_LCK, delta_IQK) = (%d, %d, %d), %d\n", delta, delta_LCK, delta_IQK, c.Threshold_IQK);*/
+		
+		/* 4 6. If necessary, do LCK.*/
+		
+		if (delta_LCK >= c.Threshold_IQK) {
+			/* Delta temperature is equal to or larger than 20 centigrade.*/
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("delta_LCK(%d) >= Threshold_IQK(%d)\n", delta_LCK, c.Threshold_IQK));
+			pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = ThermalValue;
+			if (c.PHY_LCCalibrate)
+				(*c.PHY_LCCalibrate)(pDM_Odm);
+		}
+	}
+	//3 7. If necessary, move the index of swing table to adjust Tx power.	
+	
+	if (delta > 0 && pDM_Odm->RFCalibrateInfo.TxPowerTrackControl)
+	{
+		//"delta" here is used to record the absolute value of differrence.
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))			
+	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);		
+#else
+	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);		
+#endif
+		if (delta >= TXPWR_TRACK_TABLE_SIZE)
+			delta = TXPWR_TRACK_TABLE_SIZE - 1;
+
+		//4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset
+		
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))				
+		if(ThermalValue > pHalData->EEPROMThermalMeter) {
+#else
+		if(ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
+#endif
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)  {
+				pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p] = pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p];	/* recording power index offset */
+				switch (p) {
+				case ODM_RF_PATH_B:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta])); 
+
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_B[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = deltaSwingTableIdx_TUP_B[delta];       /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A]));  
+
+
+				break;
+
+				case ODM_RF_PATH_C:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TUP_C[%d] = %d\n", delta, deltaSwingTableIdx_TUP_C[delta]));
+			
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_C[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_C[delta];       /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is higher and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+				break;
+
+				case ODM_RF_PATH_D:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TUP_D[%d] = %d\n", delta, deltaSwingTableIdx_TUP_D[delta]));
+
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_D[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_D[delta];       /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+				break;
+
+				default:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+						("deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, deltaSwingTableIdx_TUP_A[delta]));
+
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_A[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = deltaSwingTableIdx_TUP_A[delta];        /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is higher and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
+				break;
+				}		
+			}
+		} else {
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
+				pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p] = pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p];	/* recording poer index offset */
+				switch (p) {
+				case ODM_RF_PATH_B:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));  
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_B[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = -1 * deltaSwingTableIdx_TDOWN_B[delta];        /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p])); 
+				break;
+					
+				case ODM_RF_PATH_C:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));  
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_C[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = -1 * deltaSwingTableIdx_TDOWN_C[delta];        /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));   
+				break;
+
+				case ODM_RF_PATH_D:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));  
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_D[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_D[delta];        /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+				break;
+
+				default:
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));  
+					pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_A[delta];
+					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_A[delta];        /* Record delta swing for mix mode power tracking */
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						("******Temp is lower and pDM_Odm->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+				break;
+				}	
+			}
+		}
+		
+		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("\n\n=========================== [Path-%d] Calculating PowerIndexOffset===========================\n", p));  
+			if (pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] == pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p])         /* If Thermal value changes but lookup table value still the same */
+				pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p] = 0;
+			else
+				pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p] = pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] - pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p];      /* Power Index Diff between 2 times Power Tracking */
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("[Path-%d] PowerIndexOffset(%d) = DeltaPowerIndex(%d) - DeltaPowerIndexLast(%d)\n", p, pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p], pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p], pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p]));		
+		
+			pDM_Odm->RFCalibrateInfo.OFDM_index[p] = pRFCalibrateInfo->BbSwingIdxOfdmBase[p] + pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p];
+			pDM_Odm->RFCalibrateInfo.CCK_index = pRFCalibrateInfo->BbSwingIdxCckBase + pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p];
+
+			pRFCalibrateInfo->BbSwingIdxCck = pDM_Odm->RFCalibrateInfo.CCK_index;	
+			pRFCalibrateInfo->BbSwingIdxOfdm[p] = pDM_Odm->RFCalibrateInfo.OFDM_index[p];
+
+
+
+			/* *************Print BB Swing Base and Index Offset************* */
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("The 'CCK' final index(%d) = BaseIndex(%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxCck, pRFCalibrateInfo->BbSwingIdxCckBase, pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p]));
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("The 'OFDM' final index(%d) = BaseIndex[%d](%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxOfdm[p], p, pRFCalibrateInfo->BbSwingIdxOfdmBase[p], pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p]));
+
+		    //4 7.1 Handle boundary conditions of index.
+		
+			if(pDM_Odm->RFCalibrateInfo.OFDM_index[p] > c.SwingTableSize_OFDM-1)
+			{
+				pDM_Odm->RFCalibrateInfo.OFDM_index[p] = c.SwingTableSize_OFDM-1;
+			}
+			else if (pDM_Odm->RFCalibrateInfo.OFDM_index[p] < OFDM_min_index)
+			{
+				pDM_Odm->RFCalibrateInfo.OFDM_index[p] = OFDM_min_index;
+			}
+		}
+		
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("\n\n========================================================================================================\n"));  
+		if(pDM_Odm->RFCalibrateInfo.CCK_index > c.SwingTableSize_CCK-1)
+			pDM_Odm->RFCalibrateInfo.CCK_index = c.SwingTableSize_CCK-1;
+		else if (pDM_Odm->RFCalibrateInfo.CCK_index <= 0)
+			pDM_Odm->RFCalibrateInfo.CCK_index = 0;
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , pDM_Odm->RFCalibrateInfo.ThermalValue: %d\n", 
+			pDM_Odm->RFCalibrateInfo.TxPowerTrackControl, ThermalValue, pDM_Odm->RFCalibrateInfo.ThermalValue));
+		
+	    for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 		
+		    pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p] = 0;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+		("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", 
+		pDM_Odm->RFCalibrateInfo.CCK_index, pRFCalibrateInfo->BbSwingIdxCckBase));       /*Print Swing base & current*/
+			
+	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("TxPowerTracking: [OFDM] Swing Current Index: %d, Swing Base Index[%d]: %d\n",
+			pDM_Odm->RFCalibrateInfo.OFDM_index[p], p, pRFCalibrateInfo->BbSwingIdxOfdmBase[p]));
+	}
+	
+	if ((pDM_Odm->RFCalibrateInfo.PowerIndexOffset[ODM_RF_PATH_A] != 0 ||
+		pDM_Odm->RFCalibrateInfo.PowerIndexOffset[ODM_RF_PATH_B] != 0 ||
+		pDM_Odm->RFCalibrateInfo.PowerIndexOffset[ODM_RF_PATH_C] != 0 ||
+		pDM_Odm->RFCalibrateInfo.PowerIndexOffset[ODM_RF_PATH_D] != 0) && 
+		pDM_Odm->RFCalibrateInfo.TxPowerTrackControl && (pHalData->EEPROMThermalMeter != 0xff))
+	{
+		//4 7.2 Configure the Swing Table to adjust Tx Power.
+		
+		pDM_Odm->RFCalibrateInfo.bTxPowerChanged = TRUE; // Always TRUE after Tx Power is adjusted by power tracking.			
+		//
+		// 2012/04/23 MH According to Luke's suggestion, we can not write BB digital
+		// to increase TX power. Otherwise, EVM will be bad.
+		//
+		// 2012/04/25 MH Add for tx power tracking to set tx power in tx agc for 88E.
+		if (ThermalValue > pDM_Odm->RFCalibrateInfo.ThermalValue)
+		{
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					("Temperature Increasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", 
+					p, pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pDM_Odm->RFCalibrateInfo.ThermalValue));	
+			}
+		}
+		else if (ThermalValue < pDM_Odm->RFCalibrateInfo.ThermalValue)// Low temperature
+		{
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					("Temperature Decreasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+					p, pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pDM_Odm->RFCalibrateInfo.ThermalValue));				
+			}
+		}
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		if (ThermalValue > pHalData->EEPROMThermalMeter)
+#else
+		if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)
+#endif
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+
+			if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8821 ||
+				pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8814A ||
+				pDM_Odm->SupportICType == ODM_RTL8822B || pDM_Odm->SupportICType == ODM_RTL8188F || pDM_Odm->SupportICType == ODM_RTL8703B) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("**********Enter POWER Tracking MIX_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+						(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, MIX_MODE, p, 0);
+			}
+			else 
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("**********Enter POWER Tracking BBSWING_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+						(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
+			}
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
+
+			if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8821 ||
+				pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8814A ||
+				pDM_Odm->SupportICType == ODM_RTL8822B || pDM_Odm->SupportICType == ODM_RTL8188F || pDM_Odm->SupportICType == ODM_RTL8703B) {
+			
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("**********Enter POWER Tracking MIX_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, MIX_MODE, p, Indexforchannel);
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("**********Enter POWER Tracking BBSWING_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
+			}
+			
+		}
+
+		pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->BbSwingIdxCck;    /*Record last time Power Tracking result as base.*/
+		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+				pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->BbSwingIdxOfdm[p];
+
+	 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					("pDM_Odm->RFCalibrateInfo.ThermalValue = %d ThermalValue= %d\n", pDM_Odm->RFCalibrateInfo.ThermalValue, ThermalValue));
+		
+		pDM_Odm->RFCalibrateInfo.ThermalValue = ThermalValue;         /*Record last Power Tracking Thermal Value*/
+
+	}
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		
+	if (!IS_HARDWARE_TYPE_8723B(Adapter) && !IS_HARDWARE_TYPE_8192E(Adapter) && !IS_HARDWARE_TYPE_8703B(Adapter)) {
+		/* Delta temperature is equal to or larger than 20 centigrade (When threshold is 8).*/
+		if (delta_IQK >= c.Threshold_IQK) {
+			if (!pDM_Odm->RFCalibrateInfo.bIQKInProgress) 
+				(*c.DoIQK)(pDM_Odm, delta_IQK, ThermalValue, 8);
+		}
+	}	
+	if (!(pDM_Odm->SupportICType & ODM_RTL8814A)) {
+		if (pDM_Odm->RFCalibrateInfo.DpkThermal[ODM_RF_PATH_A] != 0) {
+			if (diff_DPK[ODM_RF_PATH_A] >= c.Threshold_DPK) { 
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+				ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK));
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+			} else if ((diff_DPK[ODM_RF_PATH_A] <= -1 * c.Threshold_DPK)) {
+				s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK);
+
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+				ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+			} else {
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+				ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+			}
+		}
+		if (pDM_Odm->RFCalibrateInfo.DpkThermal[ODM_RF_PATH_B] != 0) {
+			if (diff_DPK[ODM_RF_PATH_B] >= c.Threshold_DPK) { 
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+				ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK));
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+			} else if ((diff_DPK[ODM_RF_PATH_B] <= -1 * c.Threshold_DPK)) {
+				s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK);	
+				
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+				ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+			} else {
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+				ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
+				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+			}
+		}
+	}
+
+#endif		
+			
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("<===ODM_TXPowerTrackingCallback_ThermalMeter End\n"));
+	
+	pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
+}
+
+
+//3============================================================
+//3 IQ Calibration
+//3============================================================
+
+VOID
+ODM_ResetIQKResult(
+	IN		PVOID					pDM_VOID
+)
+{
+	return;
+
+}
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
+{
+	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] = 
+	{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+	u1Byte	place = chnl;
+
+	
+	if(chnl > 14)
+	{
+		for(place = 14; place<sizeof(channel_all); place++)
+		{
+			if(channel_all[place] == chnl)
+			{
+				return place-13;
+			}
+		}
+	}	
+	return 0;
+
+}
+#endif
+
+VOID
+odm_IQCalibrate(
+		IN	PDM_ODM_T	pDM_Odm 
+		)
+{
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	if (*pDM_Odm->pIsFcsModeEnable)
+		return;
+#endif
+	
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))		
+	if (!IS_HARDWARE_TYPE_JAGUAR(Adapter))
+		return;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	else if (IS_HARDWARE_TYPE_8812AU(Adapter))
+		return;
+#endif
+#endif
+	
+#if (RTL8821A_SUPPORT == 1)
+	if (pDM_Odm->bLinked) {
+		if ((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess)) {
+			pDM_Odm->preChannel = *pDM_Odm->pChannel;
+			pDM_Odm->LinkedInterval = 0;
+		}
+
+		if (pDM_Odm->LinkedInterval < 3)
+			pDM_Odm->LinkedInterval++;
+		
+		if (pDM_Odm->LinkedInterval == 2) {
+			/*Mark out IQK flow to prevent tx stuck. by Maddest 20130306*/
+			/*Open it verified by James 20130715*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+			PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			PHY_IQCalibrate(Adapter, FALSE);
+#else
+			PHY_IQCalibrate_8821A(Adapter, FALSE);
+#endif
+		}
+	} else
+		pDM_Odm->LinkedInterval = 0;
+#endif
+}
+
+void phydm_rf_init(IN	PVOID		pDM_VOID)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	odm_TXPowerTrackingInit(pDM_Odm);
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_ClearTxPowerTrackingState(pDM_Odm);	
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+#if (RTL8814A_SUPPORT == 1)		
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		PHY_IQCalibrate_8814A_Init(pDM_Odm);
+#endif	
+#endif
+
+}
+
+void phydm_rf_watchdog(IN	PVOID		pDM_VOID)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_TXPowerTrackingCheck(pDM_Odm);
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		odm_IQCalibrate(pDM_Odm);
+#endif
+}
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.h
new file mode 100644
index 000000000..2e5f22355
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_ce.h
@@ -0,0 +1,106 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+ #ifndef __HAL_PHY_RF_H__
+ #define __HAL_PHY_RF_H__
+ 
+/*#include "phydm_kfree.h"*/
+#if (RTL8814A_SUPPORT == 1)
+#include "rtl8814a/phydm_iqk_8814a.h"
+#endif
+
+#if (RTL8822B_SUPPORT == 1)
+#include "rtl8822b/phydm_iqk_8822b.h"
+#endif
+#include "phydm_powertracking_ce.h"
+
+
+typedef enum _SPUR_CAL_METHOD {
+	PLL_RESET,
+	AFE_PHASE_SEL
+} SPUR_CAL_METHOD;
+
+typedef enum _PWRTRACK_CONTROL_METHOD {
+	BBSWING,
+	TXAGC,
+	MIX_MODE,
+	TSSI_MODE
+} PWRTRACK_METHOD;
+
+typedef VOID 	(*FuncSetPwr)(PVOID, PWRTRACK_METHOD, u1Byte, u1Byte);
+typedef VOID(*FuncIQK)(PVOID, u1Byte, u1Byte, u1Byte);
+typedef VOID 	(*FuncLCK)(PVOID);
+typedef VOID  	(*FuncSwing)(PVOID, pu1Byte*, pu1Byte*, pu1Byte*, pu1Byte*);
+typedef VOID	(*FuncSwing8814only)(PVOID, pu1Byte*, pu1Byte*, pu1Byte*, pu1Byte*);
+
+typedef struct _TXPWRTRACK_CFG {
+	u1Byte 		SwingTableSize_CCK;	
+	u1Byte 		SwingTableSize_OFDM;
+	u1Byte 		Threshold_IQK;	
+	u1Byte		Threshold_DPK;
+	u1Byte 		AverageThermalNum;
+	u1Byte 		RfPathCount;
+	u4Byte 		ThermalRegAddr;	
+	FuncSetPwr 	ODM_TxPwrTrackSetPwr;
+	FuncIQK 	DoIQK;
+	FuncLCK		PHY_LCCalibrate;
+	FuncSwing	GetDeltaSwingTable;
+	FuncSwing8814only	GetDeltaSwingTable8814only;
+} TXPWRTRACK_CFG, *PTXPWRTRACK_CFG;
+
+void ConfigureTxpowerTrack(
+	IN		PVOID					pDM_VOID,
+	OUT	PTXPWRTRACK_CFG	pConfig
+	);
+
+
+VOID
+ODM_ClearTxPowerTrackingState(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN		PVOID					pDM_VOID
+#else
+	IN PADAPTER	Adapter
+#endif
+	);
+
+
+
+#define ODM_TARGET_CHNL_NUM_2G_5G	59
+
+
+VOID
+ODM_ResetIQKResult(
+	IN		PVOID					pDM_VOID
+);
+u1Byte 
+ODM_GetRightChnlPlaceforIQK(
+    IN u1Byte chnl
+);
+
+void phydm_rf_init(	IN		PVOID					pDM_VOID);
+void phydm_rf_watchdog(	IN		PVOID					pDM_VOID);
+								
+#endif	// #ifndef __HAL_PHY_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.c
new file mode 100644
index 000000000..41087bf36
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.c
@@ -0,0 +1,716 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+ #include "mp_precomp.h"
+ #include "phydm_precomp.h"
+
+//#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+#define 	CALCULATE_SWINGTALBE_OFFSET(_offset, _direction, _size, _deltaThermal) \
+					do {\
+						for(_offset = 0; _offset < _size; _offset++)\
+						{\
+							if(_deltaThermal < thermalThreshold[_direction][_offset])\
+							{\
+								if(_offset != 0)\
+									_offset--;\
+								break;\
+							}\
+						}			\
+						if(_offset >= _size)\
+							_offset = _size-1;\
+					} while(0)
+
+
+void ConfigureTxpowerTrack(
+	IN 	PDM_ODM_T		pDM_Odm,
+	OUT	PTXPWRTRACK_CFG	pConfig
+	)
+{
+#if RTL8192E_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8192E)
+		ConfigureTxpowerTrack_8192E(pConfig);
+#endif	
+#if RTL8821A_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8821)
+		ConfigureTxpowerTrack_8821A(pConfig);
+#endif
+#if RTL8812A_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8812)
+		ConfigureTxpowerTrack_8812A(pConfig);
+#endif
+#if RTL8188E_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		ConfigureTxpowerTrack_8188E(pConfig);
+#endif 
+
+#if RTL8188F_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8188F)
+		ConfigureTxpowerTrack_8188F(pConfig);
+#endif 
+
+#if RTL8723B_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8723B)
+		ConfigureTxpowerTrack_8723B(pConfig);
+#endif
+
+#if RTL8814A_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8814A)
+		ConfigureTxpowerTrack_8814A(pConfig);
+#endif
+
+#if RTL8821B_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8821B)
+		ConfigureTxpowerTrack_8821B(pConfig);
+#endif
+
+#if RTL8703B_SUPPORT
+	if(pDM_Odm->SupportICType==ODM_RTL8703B)
+		ConfigureTxpowerTrack_8703B(pConfig);
+#endif
+
+}
+
+//======================================================================
+// <20121113, Kordan> This function should be called when TxAGC changed.
+// Otherwise the previous compensation is gone, because we record the 
+// delta of temperature between two TxPowerTracking watch dogs.
+//
+// NOTE: If Tx BB swing or Tx scaling is varified during run-time, still 
+//       need to call this function.
+//======================================================================
+VOID
+ODM_ClearTxPowerTrackingState(
+	IN PDM_ODM_T		pDM_Odm
+	)
+{
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+	u1Byte 			p = 0;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	
+	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
+	pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->DefaultCckIndex;
+	pRFCalibrateInfo->CCK_index = 0;
+	
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
+	{
+		pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+		pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+	   	pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+
+		pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+		pRFCalibrateInfo->DeltaPowerIndex[p] = 0;
+		pRFCalibrateInfo->DeltaPowerIndexLast[p] = 0;
+
+		pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = 0;    // Initial Mix mode power tracking
+		pRFCalibrateInfo->Remnant_OFDMSwingIdx[p] = 0;			  
+		pRFCalibrateInfo->KfreeOffset[p] = 0;			  
+	}
+	
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathA= FALSE;       //Initial at Modify Tx Scaling Mode
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathB= FALSE;       //Initial at Modify Tx Scaling Mode
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathC= FALSE;       //Initial at Modify Tx Scaling Mode
+	pRFCalibrateInfo->Modify_TxAGC_Flag_PathD= FALSE;       //Initial at Modify Tx Scaling Mode
+	pRFCalibrateInfo->Remnant_CCKSwingIdx= 0;
+	pRFCalibrateInfo->ThermalValue = pHalData->EEPROMThermalMeter;
+
+	pRFCalibrateInfo->Modify_TxAGC_Value_CCK=0;			//modify by Mingzhi.Guo
+	pRFCalibrateInfo->Modify_TxAGC_Value_OFDM=0;		//modify by Mingzhi.Guo
+
+}
+
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm
+#else
+	IN PADAPTER	Adapter
+#endif
+	)
+{
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm	  = &pHalData->DM_OutSrc;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	
+	u1Byte			ThermalValue = 0, delta, delta_LCK, delta_IQK, p = 0, i = 0, pathName = 0;
+	s1Byte			diff_DPK[4] = {0};
+	u1Byte			ThermalValue_AVG_count = 0;
+	u4Byte			ThermalValue_AVG = 0;	
+
+	u1Byte			OFDM_min_index = 0;  // OFDM BB Swing should be less than +3.0dB, which is required by Arthur
+	u1Byte			Indexforchannel = 0; // GetRightChnlPlaceforIQK(pHalData->CurrentChannel)
+	BOOLEAN			bTSSIenable = FALSE;
+
+	TXPWRTRACK_CFG 	c;
+	
+	//4 1. The following TWO tables decide the final index of OFDM/CCK swing table.
+	pu1Byte			deltaSwingTableIdx_TUP_A, deltaSwingTableIdx_TDOWN_A;
+	pu1Byte			deltaSwingTableIdx_TUP_B, deltaSwingTableIdx_TDOWN_B;
+	//for 8814 add by Yu Chen
+	pu1Byte			deltaSwingTableIdx_TUP_C = NULL, deltaSwingTableIdx_TDOWN_C = NULL;
+	pu1Byte			deltaSwingTableIdx_TUP_D= NULL, deltaSwingTableIdx_TDOWN_D = NULL;
+		
+	//4 2. Initilization ( 7 steps in total )
+
+	ConfigureTxpowerTrack(pDM_Odm, &c);
+	
+	(*c.GetDeltaSwingTable)(pDM_Odm, (pu1Byte*)&deltaSwingTableIdx_TUP_A, (pu1Byte*)&deltaSwingTableIdx_TDOWN_A,
+									  (pu1Byte*)&deltaSwingTableIdx_TUP_B, (pu1Byte*)&deltaSwingTableIdx_TDOWN_B);
+
+	if(pDM_Odm->SupportICType & ODM_RTL8814A)	// for 8814 path C & D
+	(*c.GetDeltaSwingTable8814only)(pDM_Odm, (pu1Byte*)&deltaSwingTableIdx_TUP_C, (pu1Byte*)&deltaSwingTableIdx_TDOWN_C,
+									  (pu1Byte*)&deltaSwingTableIdx_TUP_D, (pu1Byte*)&deltaSwingTableIdx_TDOWN_D);
+	
+	
+	pRFCalibrateInfo->TXPowerTrackingCallbackCnt++; //cosa add for debug
+	pRFCalibrateInfo->bTXPowerTrackingInit = TRUE;
+   
+#if (MP_DRIVER == 1)      
+    /*pRFCalibrateInfo->TxPowerTrackControl = pHalData->TxPowerTrackControl;
+    <Kordan> We should keep updating the control variable according to HalData. 
+    <Kordan> RFCalibrateInfo.RegA24 will be initialized when ODM HW configuring, but MP configures with para files. */
+    pRFCalibrateInfo->RegA24 = 0x090e1317; 
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+		("===>ODM_TXPowerTrackingCallback_ThermalMeter, \
+		 \n pRFCalibrateInfo->BbSwingIdxCckBase: %d, pRFCalibrateInfo->BbSwingIdxOfdmBase[A]: %d, pRFCalibrateInfo->DefaultOfdmIndex: %d\n", 
+		pRFCalibrateInfo->BbSwingIdxCckBase, pRFCalibrateInfo->BbSwingIdxOfdmBase[ODM_RF_PATH_A], pRFCalibrateInfo->DefaultOfdmIndex));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+		("pRFCalibrateInfo->TxPowerTrackControl %d,  pHalData->EEPROMThermalMeter %d\n", pRFCalibrateInfo->TxPowerTrackControl,  pHalData->EEPROMThermalMeter));
+	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
+
+
+	if( ! pRFCalibrateInfo->TxPowerTrackControl )
+        	return;
+
+
+	//4 3. Initialize ThermalValues of RFCalibrateInfo
+
+	if(pRFCalibrateInfo->bReloadtxpowerindex)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));				
+	}
+
+	//4 4. Calculate average thermal meter
+	
+	pRFCalibrateInfo->ThermalValue_AVG[pRFCalibrateInfo->ThermalValue_AVG_index] = ThermalValue;
+	pRFCalibrateInfo->ThermalValue_AVG_index++;
+	if(pRFCalibrateInfo->ThermalValue_AVG_index == c.AverageThermalNum)   //Average times =  c.AverageThermalNum
+		pRFCalibrateInfo->ThermalValue_AVG_index = 0;
+
+	for(i = 0; i < c.AverageThermalNum; i++)
+	{
+		if(pRFCalibrateInfo->ThermalValue_AVG[i])
+		{
+			ThermalValue_AVG += pRFCalibrateInfo->ThermalValue_AVG[i];
+			ThermalValue_AVG_count++;
+		}
+	}
+
+	if(ThermalValue_AVG_count)               //Calculate Average ThermalValue after average enough times
+	{
+		ThermalValue = (u1Byte)(ThermalValue_AVG / ThermalValue_AVG_count);
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", ThermalValue, pHalData->EEPROMThermalMeter));					
+	}
+			
+	//4 5. Calculate delta, delta_LCK, delta_IQK.
+
+	//"delta" here is used to determine whether thermal value changes or not.
+	delta 	  = (ThermalValue > pRFCalibrateInfo->ThermalValue)?(ThermalValue - pRFCalibrateInfo->ThermalValue):(pRFCalibrateInfo->ThermalValue - ThermalValue);
+	delta_LCK = (ThermalValue > pRFCalibrateInfo->ThermalValue_LCK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_LCK):(pRFCalibrateInfo->ThermalValue_LCK - ThermalValue);
+	delta_IQK = (ThermalValue > pRFCalibrateInfo->ThermalValue_IQK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_IQK):(pRFCalibrateInfo->ThermalValue_IQK - ThermalValue);
+
+	if(pRFCalibrateInfo->ThermalValue_IQK == 0xff)	//no PG, use thermal value for IQK
+	{
+		pRFCalibrateInfo->ThermalValue_IQK = ThermalValue;
+		delta_IQK = (ThermalValue > pRFCalibrateInfo->ThermalValue_IQK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_IQK):(pRFCalibrateInfo->ThermalValue_IQK - ThermalValue);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("no PG, use ThermalValue for IQK\n"));
+	}
+	
+	for(p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+		{
+		diff_DPK[p] = (s1Byte)ThermalValue - (s1Byte)pRFCalibrateInfo->DpkThermal[p];
+		}
+
+	//4 6. If necessary, do LCK.	
+
+	if (!(pDM_Odm->SupportICType & ODM_RTL8821)) {
+		/*no PG , do LCK at initial status*/
+		if (pRFCalibrateInfo->ThermalValue_LCK == 0xff) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("no PG, do LCK\n"));
+		pRFCalibrateInfo->ThermalValue_LCK = ThermalValue;
+		if(c.PHY_LCCalibrate)
+			(*c.PHY_LCCalibrate)(pDM_Odm);
+		delta_LCK = (ThermalValue > pRFCalibrateInfo->ThermalValue_LCK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_LCK):(pRFCalibrateInfo->ThermalValue_LCK - ThermalValue);
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("(delta, delta_LCK, delta_IQK) = (%d, %d, %d)\n", delta, delta_LCK, delta_IQK));
+	
+		 /* Delta temperature is equal to or larger than 20 centigrade.*/
+		if (delta_LCK >= c.Threshold_IQK) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("delta_LCK(%d) >= Threshold_IQK(%d)\n", delta_LCK, c.Threshold_IQK));
+		pRFCalibrateInfo->ThermalValue_LCK = ThermalValue;
+		if(c.PHY_LCCalibrate)
+			(*c.PHY_LCCalibrate)(pDM_Odm);
+	}
+	}
+
+	//3 7. If necessary, move the index of swing table to adjust Tx power.	
+	
+	if (delta > 0 && pRFCalibrateInfo->TxPowerTrackControl)
+	{
+		//"delta" here is used to record the absolute value of differrence.
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))			
+	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);		
+#else
+	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);		
+#endif
+		if (delta >= TXPWR_TRACK_TABLE_SIZE)
+			delta = TXPWR_TRACK_TABLE_SIZE - 1;
+
+		//4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset
+		
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))				
+		if(ThermalValue > pHalData->EEPROMThermalMeter) {
+#else
+		if(ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
+#endif
+
+		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 
+			{
+			pRFCalibrateInfo->DeltaPowerIndexLast[p] = pRFCalibrateInfo->DeltaPowerIndex[p];	//recording poer index offset
+			switch(p)
+				{
+					case ODM_RF_PATH_B:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+	                                    	("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta])); 
+						
+						pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_B[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_B[delta];       // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					case ODM_RF_PATH_C:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+	                                    	("deltaSwingTableIdx_TUP_C[%d] = %d\n", delta, deltaSwingTableIdx_TUP_C[delta]));
+						
+						pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_C[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_C[delta];       // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					case ODM_RF_PATH_D:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+	                                   	 ("deltaSwingTableIdx_TUP_D[%d] = %d\n", delta, deltaSwingTableIdx_TUP_D[delta]));
+						
+						pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_D[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_D[delta];       // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					default:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+	                                 	   	("deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, deltaSwingTableIdx_TUP_A[delta]));
+						
+						pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_A[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_A[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+				}	
+				
+			}
+			
+        } 
+		else {
+
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 
+			{
+			pRFCalibrateInfo->DeltaPowerIndexLast[p] = pRFCalibrateInfo->DeltaPowerIndex[p];	//recording poer index offset
+			switch(p)
+				{
+					case ODM_RF_PATH_B:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+               	 				("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));  
+						pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_B[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_B[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p])); 
+					break;
+
+					case ODM_RF_PATH_C:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+               	 				("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));  
+						pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_C[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_C[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));   
+					break;
+
+					case ODM_RF_PATH_D:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+               	 				("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));  
+						pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_D[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_D[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+
+					default:
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+               	 				("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));  
+						pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_A[delta];
+						pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_A[delta];        // Record delta swing for mix mode power tracking
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+					break;
+				}	
+				
+			}
+			
+        }
+		
+	   for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 		
+        	{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("\n\n=========================== [Path-%d] Calculating PowerIndexOffset===========================\n", p));  
+			
+		    if(pRFCalibrateInfo->DeltaPowerIndex[p] == pRFCalibrateInfo->DeltaPowerIndexLast[p])         // If Thermal value changes but lookup table value still the same
+		    	pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+		    else
+		    	pRFCalibrateInfo->PowerIndexOffset[p] = pRFCalibrateInfo->DeltaPowerIndex[p] - pRFCalibrateInfo->DeltaPowerIndexLast[p];      // Power Index Diff between 2 times Power Tracking
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("[Path-%d] PowerIndexOffset(%d) = DeltaPowerIndex(%d) - DeltaPowerIndexLast(%d)\n", p, pRFCalibrateInfo->PowerIndexOffset[p], pRFCalibrateInfo->DeltaPowerIndex[p], pRFCalibrateInfo->DeltaPowerIndexLast[p]));		
+		
+			pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->BbSwingIdxOfdmBase[p] + pRFCalibrateInfo->PowerIndexOffset[p];
+			pRFCalibrateInfo->CCK_index = pRFCalibrateInfo->BbSwingIdxCckBase + pRFCalibrateInfo->PowerIndexOffset[p];
+
+			pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->CCK_index;	
+			pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->OFDM_index[p];	
+
+	           // *************Print BB Swing Base and Index Offset*************
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("The 'CCK' final index(%d) = BaseIndex(%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxCck, pRFCalibrateInfo->BbSwingIdxCckBase, pRFCalibrateInfo->PowerIndexOffset[p]));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("The 'OFDM' final index(%d) = BaseIndex[%d](%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxOfdm[p], p, pRFCalibrateInfo->BbSwingIdxOfdmBase[p], pRFCalibrateInfo->PowerIndexOffset[p]));
+
+		    //4 7.1 Handle boundary conditions of index.
+		
+			if(pRFCalibrateInfo->OFDM_index[p] > c.SwingTableSize_OFDM-1)
+			{
+				pRFCalibrateInfo->OFDM_index[p] = c.SwingTableSize_OFDM-1;
+			}
+			else if (pRFCalibrateInfo->OFDM_index[p] <= OFDM_min_index)
+			{
+				pRFCalibrateInfo->OFDM_index[p] = OFDM_min_index;
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+            ("\n\n========================================================================================================\n"));  
+		if(pRFCalibrateInfo->CCK_index > c.SwingTableSize_CCK-1)
+			pRFCalibrateInfo->CCK_index = c.SwingTableSize_CCK-1;
+		else if (pRFCalibrateInfo->CCK_index <= 0)
+			pRFCalibrateInfo->CCK_index = 0;
+	}
+	else
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , pRFCalibrateInfo->ThermalValue: %d\n", 
+			pRFCalibrateInfo->TxPowerTrackControl, ThermalValue, pRFCalibrateInfo->ThermalValue));
+
+		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) 		
+		    pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+	}
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", 
+			pRFCalibrateInfo->CCK_index, pRFCalibrateInfo->BbSwingIdxCckBase));       //Print Swing base & current
+		
+	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+			("TxPowerTracking: [OFDM] Swing Current Index: %d, Swing Base Index[%d]: %d\n",
+			pRFCalibrateInfo->OFDM_index[p], p, pRFCalibrateInfo->BbSwingIdxOfdmBase[p]));
+	}
+	
+	if ((pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_A] != 0 ||
+		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_B] != 0 ||
+		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_C] != 0 ||
+		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_D] != 0) && 
+     	 	pRFCalibrateInfo->TxPowerTrackControl && (pHalData->EEPROMThermalMeter != 0xff))
+	{
+		//4 7.2 Configure the Swing Table to adjust Tx Power.
+		
+		pRFCalibrateInfo->bTxPowerChanged = TRUE; // Always TRUE after Tx Power is adjusted by power tracking.			
+		//
+		// 2012/04/23 MH According to Luke's suggestion, we can not write BB digital
+		// to increase TX power. Otherwise, EVM will be bad.
+		//
+		// 2012/04/25 MH Add for tx power tracking to set tx power in tx agc for 88E.
+		if (ThermalValue > pRFCalibrateInfo->ThermalValue)
+		{
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+			{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					("Temperature Increasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", 
+					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));	
+			}
+		}
+		
+		else if (ThermalValue < pRFCalibrateInfo->ThermalValue)// Low temperature
+		{
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+			{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					("Temperature Decreasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));				
+			}
+		}				
+		
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		if (ThermalValue > pHalData->EEPROMThermalMeter)
+#else
+		if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)
+#endif
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+
+			if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E ||pDM_Odm->SupportICType == ODM_RTL8821 ||
+				pDM_Odm->SupportICType == ODM_RTL8812  || pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8814A || pDM_Odm->SupportICType == ODM_RTL8703B || pDM_Odm->SupportICType == ODM_RTL8188F)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("**********Enter POWER Tracking MIX_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, MIX_MODE, p, 0);
+			}
+			else 
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("**********Enter POWER Tracking BBSWING_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
+			}
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
+
+			if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8821 ||
+				pDM_Odm->SupportICType == ODM_RTL8812  || pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8814A || pDM_Odm->SupportICType == ODM_RTL8703B || pDM_Odm->SupportICType == ODM_RTL8188F)
+			{
+	            		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("**********Enter POWER Tracking MIX_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, MIX_MODE, p, Indexforchannel);
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("**********Enter POWER Tracking BBSWING_MODE**********\n"));
+				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
+			}
+			
+		}
+
+			pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->BbSwingIdxCck;   // Record last time Power Tracking result as base.
+			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
+				pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->BbSwingIdxOfdm[p];
+
+	 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+				("pRFCalibrateInfo->ThermalValue = %d ThermalValue= %d\n", pRFCalibrateInfo->ThermalValue, ThermalValue));
+		
+			pRFCalibrateInfo->ThermalValue = ThermalValue;         //Record last Power Tracking Thermal Value
+			
+	}
+	
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	
+	if(!IS_HARDWARE_TYPE_8723B(Adapter))
+	{
+		// Delta temperature is equal to or larger than 20 centigrade (When threshold is 8).
+		if ((delta_IQK >= c.Threshold_IQK)) {
+			if ( ! pRFCalibrateInfo->bIQKInProgress) 
+				(*c.DoIQK)(pDM_Odm, delta_IQK, ThermalValue, 8);
+		}
+	}
+	if (pRFCalibrateInfo->DpkThermal[ODM_RF_PATH_A] != 0) {
+		if ((diff_DPK[ODM_RF_PATH_A] >= c.Threshold_DPK)) { 
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK));
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+		} else if ((diff_DPK[ODM_RF_PATH_A] <= -1 * c.Threshold_DPK)) {
+			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK);	
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+		} else {
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+		}
+	}
+	if (pRFCalibrateInfo->DpkThermal[ODM_RF_PATH_B] != 0) {
+		if ((diff_DPK[ODM_RF_PATH_B] >= c.Threshold_DPK)) { 
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK));
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+		} else if ((diff_DPK[ODM_RF_PATH_B] <= -1 * c.Threshold_DPK)) {
+			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK);	
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
+		} else {
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
+			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+		}
+	}
+
+#endif		
+			
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("<===ODM_TXPowerTrackingCallback_ThermalMeter\n"));
+	
+	pRFCalibrateInfo->TXPowercount = 0;
+}
+
+
+
+//3============================================================
+//3 IQ Calibration
+//3============================================================
+
+VOID
+ODM_ResetIQKResult(
+	IN PDM_ODM_T	pDM_Odm 
+)
+{
+	return;
+}
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
+{
+	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] = 
+	{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+	u1Byte	place = chnl;
+
+	
+	if(chnl > 14)
+	{
+		for(place = 14; place<sizeof(channel_all); place++)
+		{
+			if(channel_all[place] == chnl)
+			{
+				return place-13;
+			}
+		}
+	}	
+	return 0;
+
+}
+#endif
+
+VOID
+odm_IQCalibrate(
+		IN	PDM_ODM_T	pDM_Odm 
+		)
+{
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	if (*pDM_Odm->pIsFcsModeEnable)
+		return;
+#endif
+	
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))		
+	if (!IS_HARDWARE_TYPE_JAGUAR(Adapter))
+		return;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	else if (IS_HARDWARE_TYPE_8812AU(Adapter))
+		return;
+#endif
+#endif
+	
+#if (RTL8821A_SUPPORT == 1)
+	if (pDM_Odm->bLinked) {
+		if ((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess)) {
+			pDM_Odm->preChannel = *pDM_Odm->pChannel;
+			pDM_Odm->LinkedInterval = 0;
+		}
+
+		if (pDM_Odm->LinkedInterval < 3)
+			pDM_Odm->LinkedInterval++;
+		
+		if (pDM_Odm->LinkedInterval == 2) {
+			/*Mark out IQK flow to prevent tx stuck. by Maddest 20130306*/
+			/*Open it verified by James 20130715*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+			PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			PHY_IQCalibrate(Adapter, FALSE);
+#else
+			PHY_IQCalibrate_8821A(Adapter, FALSE);
+#endif
+		}
+	} else
+		pDM_Odm->LinkedInterval = 0;
+#endif
+}
+
+void phydm_rf_init(IN		PDM_ODM_T		pDM_Odm)
+{
+
+	odm_TXPowerTrackingInit(pDM_Odm);
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_ClearTxPowerTrackingState(pDM_Odm);	
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+#if (RTL8814A_SUPPORT == 1)		
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		PHY_IQCalibrate_8814A_Init(pDM_Odm);
+#endif	
+#endif
+
+}
+
+void phydm_rf_watchdog(IN		PDM_ODM_T		pDM_Odm)
+{
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_TXPowerTrackingCheck(pDM_Odm);
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		odm_IQCalibrate(pDM_Odm);
+#endif
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.h
new file mode 100644
index 000000000..aa20db1b7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/halphyrf_win.h
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+ #ifndef __HAL_PHY_RF_H__
+ #define __HAL_PHY_RF_H__
+ 
+#include "phydm_kfree.h"
+#if (RTL8814A_SUPPORT == 1)
+#include "rtl8814a/phydm_iqk_8814a.h"
+#endif
+
+#if (RTL8822B_SUPPORT == 1)
+#include "rtl8822b/phydm_iqk_8822b.h"
+#endif
+#include "phydm_powertracking_win.h"
+
+typedef enum _SPUR_CAL_METHOD {
+	PLL_RESET,
+	AFE_PHASE_SEL
+} SPUR_CAL_METHOD;
+
+typedef enum _PWRTRACK_CONTROL_METHOD {
+	BBSWING,
+	TXAGC,
+	MIX_MODE,
+	TSSI_MODE
+} PWRTRACK_METHOD;
+
+typedef VOID 	(*FuncSetPwr)(PDM_ODM_T, PWRTRACK_METHOD, u1Byte, u1Byte);
+typedef VOID(*FuncIQK)(PVOID, u1Byte, u1Byte, u1Byte);
+typedef VOID 	(*FuncLCK)(PDM_ODM_T);
+				//refine by YuChen for 8814A
+typedef VOID  	(*FuncSwing)(PDM_ODM_T, pu1Byte*, pu1Byte*, pu1Byte*, pu1Byte*);
+typedef VOID	(*FuncSwing8814only)(PDM_ODM_T, pu1Byte*, pu1Byte*, pu1Byte*, pu1Byte*);
+
+typedef struct _TXPWRTRACK_CFG {
+	u1Byte 		SwingTableSize_CCK;	
+	u1Byte 		SwingTableSize_OFDM;
+	u1Byte 		Threshold_IQK;
+	u1Byte 		Threshold_DPK;	
+	u1Byte 		AverageThermalNum;
+	u1Byte 		RfPathCount;
+	u4Byte 		ThermalRegAddr;	
+	FuncSetPwr 	ODM_TxPwrTrackSetPwr;
+	FuncIQK 	DoIQK;
+	FuncLCK		PHY_LCCalibrate;
+	FuncSwing	GetDeltaSwingTable;
+	FuncSwing8814only	GetDeltaSwingTable8814only;
+} TXPWRTRACK_CFG, *PTXPWRTRACK_CFG;
+
+VOID 
+ConfigureTxpowerTrack(
+	IN 	PDM_ODM_T		pDM_Odm,
+	OUT	PTXPWRTRACK_CFG	pConfig
+	);
+
+
+VOID
+ODM_ClearTxPowerTrackingState(
+	IN PDM_ODM_T		pDM_Odm
+	);
+
+VOID
+ODM_TXPowerTrackingCallback_ThermalMeter(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm
+#else
+	IN PADAPTER	Adapter
+#endif
+	);
+
+
+
+#define ODM_TARGET_CHNL_NUM_2G_5G	59
+
+
+VOID
+ODM_ResetIQKResult(
+	IN PDM_ODM_T	pDM_Odm 
+);
+u1Byte 
+ODM_GetRightChnlPlaceforIQK(
+    IN u1Byte chnl
+);
+
+VOID odm_IQCalibrate(IN	PDM_ODM_T	pDM_Odm);
+VOID phydm_rf_init(	IN		PDM_ODM_T		pDM_Odm);
+VOID phydm_rf_watchdog(	IN		PDM_ODM_T		pDM_Odm);
+								
+#endif	// #ifndef __HAL_PHY_RF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/mp_precomp.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/mp_precomp.h
new file mode 100644
index 000000000..2e950cb2e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/mp_precomp.h
@@ -0,0 +1,20 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.c
new file mode 100644
index 000000000..afb3345f4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.c
@@ -0,0 +1,2166 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+const u2Byte dB_Invert_Table[12][8] = {
+	{	1,		1,		1,		2,		2,		2,		2,		3},
+	{	3,		3,		4,		4,		4,		5,		6,		6},
+	{	7,		8,		9,		10,		11,		13,		14,		16},
+	{	18,		20,		22,		25,		28,		32,		35,		40},
+	{	45,		50,		56,		63,		71,		79,		89,		100},
+	{	112,		126,		141,		158,		178,		200,		224,		251},
+	{	282,		316,		355,		398,		447,		501,		562,		631},
+	{	708,		794,		891,		1000,	1122,	1259,	1413,	1585},
+	{	1778,	1995,	2239,	2512,	2818,	3162,	3548,	3981},
+	{	4467,	5012,	5623,	6310,	7079,	7943,	8913,	10000},
+	{	11220,	12589,	14125,	15849,	17783,	19953,	22387,	25119},
+	{	28184,	31623,	35481,	39811,	44668,	50119,	56234,	65535}
+};
+
+
+//============================================================
+// Local Function predefine.
+//============================================================
+
+/* START------------COMMON INFO RELATED--------------- */
+
+VOID
+odm_GlobalAdapterCheck(
+	IN		VOID
+	);
+
+//move to odm_PowerTacking.h by YuChen
+
+
+
+VOID
+odm_UpdatePowerTrainingState(
+	IN	PDM_ODM_T	pDM_Odm
+);
+
+//============================================================
+//3 Export Interface
+//============================================================
+
+/*Y = 10*log(X)*/
+s4Byte
+ODM_PWdB_Conversion(
+	IN  s4Byte X,
+	IN  u4Byte TotalBit,
+	IN  u4Byte DecimalBit
+	)
+{
+	s4Byte Y, integer = 0, decimal = 0;
+	u4Byte i;
+
+	if(X == 0)
+		X = 1; // log2(x), x can't be 0
+
+	for(i = (TotalBit-1); i > 0; i--)
+	{
+		if(X & BIT(i))
+		{
+			integer = i;
+			if(i > 0)
+				decimal = (X & BIT(i-1))?2:0; //decimal is 0.5dB*3=1.5dB~=2dB 
+			break;
+		}
+	}
+	
+	Y = 3*(integer-DecimalBit)+decimal; //10*log(x)=3*log2(x), 
+
+	return Y;
+}
+
+s4Byte
+ODM_SignConversion(
+    IN  s4Byte value,
+    IN  u4Byte TotalBit
+    )
+{
+	if(value&BIT(TotalBit-1))
+		value -= BIT(TotalBit);
+	return value;
+}
+
+VOID
+ODM_InitMpDriverStatus(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+	// Decide when compile time
+	#if(MP_DRIVER == 1)
+	pDM_Odm->mp_mode = TRUE;
+	#else
+	pDM_Odm->mp_mode = FALSE;
+	#endif
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+
+	// Update information every period
+	pDM_Odm->mp_mode = (BOOLEAN)Adapter->registrypriv.mp_mode;
+
+#else
+
+	// MP mode is always false at AP side
+	pDM_Odm->mp_mode = FALSE;
+
+#endif
+}
+
+VOID
+ODM_UpdateMpDriverStatus(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+	// Do nothing.
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+
+	// Update information erery period
+	pDM_Odm->mp_mode = (BOOLEAN)Adapter->registrypriv.mp_mode;
+
+#else
+
+	// Do nothing.
+
+#endif
+}
+
+VOID
+PHYDM_InitTRXAntennaSetting(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+#if (RTL8814A_SUPPORT == 1)
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8814A)) {
+		u1Byte	RxAnt = 0, TxAnt = 0;
+
+		RxAnt = (u1Byte)ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH, pDM_Odm), ODM_BIT(BB_RX_PATH, pDM_Odm));
+		TxAnt = (u1Byte)ODM_GetBBReg(pDM_Odm, ODM_REG(BB_TX_PATH, pDM_Odm), ODM_BIT(BB_TX_PATH, pDM_Odm));
+		pDM_Odm->TXAntStatus =  (TxAnt & 0xf);
+		pDM_Odm->RXAntStatus =  (RxAnt & 0xf);
+	}
+#endif
+}
+
+VOID
+phydm_Init_cck_setting(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+	u4Byte value_824,value_82c;
+
+	pDM_Odm->bCckHighPower = (BOOLEAN) ODM_GetBBReg(pDM_Odm, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));
+
+	#if (RTL8192E_SUPPORT == 1)
+	if(pDM_Odm->SupportICType & (ODM_RTL8192E))
+	{
+		/* 0x824[9] = 0x82C[9] = 0xA80[7]  these regiaters settinh should be equal or CCK RSSI report may inaccurate */
+		value_824 = ODM_GetBBReg(pDM_Odm, 0x824, BIT9);
+		value_82c = ODM_GetBBReg(pDM_Odm, 0x82c, BIT9);
+		
+		if(value_824 != value_82c)
+		{
+			ODM_SetBBReg(pDM_Odm, 0x82c , BIT9, value_824);
+		}
+		ODM_SetBBReg(pDM_Odm, 0xa80 , BIT7, value_824);
+		pDM_Odm->cck_agc_report_type = (BOOLEAN)value_824;
+	}
+	#endif
+	
+	#if (RTL8703B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType & (ODM_RTL8703B)) {
+
+		pDM_Odm->cck_agc_report_type = ODM_GetBBReg(pDM_Odm, 0x950, BIT11) ? 1 : 0; /*1: 4bit LNA , 0: 3bit LNA */
+		
+		if (pDM_Odm->cck_agc_report_type != 1) {
+			DbgPrint("[Warning] 8703B CCK should be 4bit LNA, ie. 0x950[11] = 1\n");
+			/**/
+		}
+	}
+	#endif
+	
+}
+
+u1Byte DummyHubUsbMode = 1;/* USB 2.0 */
+void	phydm_hook_dummy_member(
+	IN	PDM_ODM_T		pDM_Odm
+	)
+{
+	if (pDM_Odm->HubUsbMode == NULL)
+		pDM_Odm->HubUsbMode = &DummyHubUsbMode;
+}
+
+
+VOID
+odm_CommonInfoSelfInit(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	phydm_Init_cck_setting(pDM_Odm);
+	pDM_Odm->RFPathRxEnable = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)	
+	pDM_Odm->pbNet_closed = &pDM_Odm->BOOLEAN_temp;
+#endif
+
+	PHYDM_InitDebugSetting(pDM_Odm);
+	ODM_InitMpDriverStatus(pDM_Odm);
+	PHYDM_InitTRXAntennaSetting(pDM_Odm);
+
+	pDM_Odm->TxRate = 0xFF;
+
+	pDM_Odm->number_linked_client = 0;
+	pDM_Odm->pre_number_linked_client = 0;
+	pDM_Odm->number_active_client = 0;
+	pDM_Odm->pre_number_active_client = 0;
+	phydm_hook_dummy_member(pDM_Odm);
+	
+}
+
+VOID
+odm_CommonInfoSelfUpdate(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	u1Byte	EntryCnt = 0, num_active_client = 0;
+	u4Byte	i, OneEntry_MACID = 0, ma_rx_tp = 0;
+	PSTA_INFO_T   	pEntry;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+	PMGNT_INFO	pMgntInfo = &Adapter->MgntInfo;
+
+	pEntry = pDM_Odm->pODM_StaInfo[0];
+	if(pMgntInfo->mAssoc)
+	{
+		pEntry->bUsed=TRUE;
+		for (i=0; i<6; i++)
+			pEntry->MacAddr[i] = pMgntInfo->Bssid[i];
+	}
+	else
+	{
+		pEntry->bUsed=FALSE;
+		for (i=0; i<6; i++)
+			pEntry->MacAddr[i] = 0;
+	}
+
+	//STA mode is linked to AP
+	if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[0]) && !ACTING_AS_AP(Adapter))
+		pDM_Odm->bsta_state = TRUE;
+	else
+		pDM_Odm->bsta_state = FALSE;
+#endif
+
+/* THis variable cannot be used because it is wrong*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+	{
+		if (*(pDM_Odm->pSecChOffset) == 1)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) + 2;
+		else if (*(pDM_Odm->pSecChOffset) == 2)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) - 2;
+	} else if (*(pDM_Odm->pBandWidth) == ODM_BW80M)	{
+		if (*(pDM_Odm->pSecChOffset) == 1)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) + 6;
+		else if (*(pDM_Odm->pSecChOffset) == 2)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) - 6;
+	} else
+		pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
+#else
+	if (*(pDM_Odm->pBandWidth) == ODM_BW40M) {
+		if (*(pDM_Odm->pSecChOffset) == 1)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) - 2;
+		else if (*(pDM_Odm->pSecChOffset) == 2)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) + 2;
+	} else
+		pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
+#endif
+
+	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		pEntry = pDM_Odm->pODM_StaInfo[i];
+		if(IS_STA_VALID(pEntry))
+		{
+			EntryCnt++;
+			if(EntryCnt==1)
+			{
+				OneEntry_MACID=i;
+			}
+
+			#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+				ma_rx_tp =  (pEntry->rx_byte_cnt_LowMAW)<<3; /*  low moving average RX  TP   ( bit /sec)*/
+
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("ClientTP[%d]: ((%d )) bit/sec\n", i, ma_rx_tp));
+				
+				if (ma_rx_tp > ACTIVE_TP_THRESHOLD)
+					num_active_client++;
+			#endif
+                }
+	}
+	
+	if(EntryCnt == 1)
+	{
+		pDM_Odm->bOneEntryOnly = TRUE;
+		pDM_Odm->OneEntry_MACID=OneEntry_MACID;
+	}
+	else
+		pDM_Odm->bOneEntryOnly = FALSE;
+
+	pDM_Odm->pre_number_linked_client = pDM_Odm->number_linked_client;
+	pDM_Odm->pre_number_active_client = pDM_Odm->number_active_client;
+	
+	pDM_Odm->number_linked_client = EntryCnt;
+	pDM_Odm->number_active_client = num_active_client;	
+
+	/* Update MP driver status*/
+	ODM_UpdateMpDriverStatus(pDM_Odm);
+}
+
+VOID
+odm_CommonInfoSelfReset(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	pDM_Odm->PhyDbgInfo.NumQryBeaconPkt = 0;
+#endif
+}
+
+PVOID
+PhyDM_Get_Structure(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Structure_Type
+)
+
+{
+	PVOID	pStruct = NULL;
+#if RTL8195A_SUPPORT
+	switch (Structure_Type){
+		case	PHYDM_FALSEALMCNT:
+			pStruct = &FalseAlmCnt;
+		break;
+		
+		case	PHYDM_CFOTRACK:
+			pStruct = &DM_CfoTrack;
+		break;
+
+		case	PHYDM_ADAPTIVITY:
+			pStruct = &(pDM_Odm->Adaptivity);
+		break;
+		
+		default:
+		break;
+	}
+
+#else
+	switch (Structure_Type){
+		case	PHYDM_FALSEALMCNT:
+			pStruct = &(pDM_Odm->FalseAlmCnt);
+		break;
+		
+		case	PHYDM_CFOTRACK:
+			pStruct = &(pDM_Odm->DM_CfoTrack);
+		break;
+
+		case	PHYDM_ADAPTIVITY:
+			pStruct = &(pDM_Odm->Adaptivity);
+		break;
+		
+		default:
+		break;
+	}
+
+#endif
+	return	pStruct;
+}
+
+VOID
+odm_HWSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+#if (RTL8821A_SUPPORT == 1)
+	if(pDM_Odm->SupportICType & ODM_RTL8821)
+		odm_HWSetting_8821A(pDM_Odm);
+#endif
+
+}
+
+//
+// 2011/09/21 MH Add to describe different team necessary resource allocate??
+//
+VOID
+ODM_DMInit(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	odm_CommonInfoSelfInit(pDM_Odm);
+	odm_DIGInit(pDM_Odm);
+	Phydm_NHMCounterStatisticsInit(pDM_Odm);
+	Phydm_AdaptivityInit(pDM_Odm);
+	phydm_ra_info_init(pDM_Odm);
+	odm_RateAdaptiveMaskInit(pDM_Odm);
+	odm_RA_ParaAdjust_init(pDM_Odm);
+	ODM_CfoTrackingInit(pDM_Odm);
+	ODM_EdcaTurboInit(pDM_Odm);
+	odm_RSSIMonitorInit(pDM_Odm);
+	phydm_rf_init(pDM_Odm);
+	odm_TXPowerTrackingInit(pDM_Odm);
+	odm_AntennaDiversityInit(pDM_Odm);
+	odm_AutoChannelSelectInit(pDM_Odm);
+	odm_PathDiversityInit(pDM_Odm);
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+	phydm_Beamforming_Init(pDM_Odm);
+#endif	
+
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+		odm_DynamicBBPowerSavingInit(pDM_Odm);
+		odm_DynamicTxPowerInit(pDM_Odm);
+
+#if (RTL8188E_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		{
+			odm_PrimaryCCA_Init(pDM_Odm);
+			ODM_RAInfo_Init_all(pDM_Odm);
+		}
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	
+	#if (RTL8723B_SUPPORT == 1)
+		if(pDM_Odm->SupportICType == ODM_RTL8723B)
+			odm_SwAntDetectInit(pDM_Odm);
+	#endif
+
+	#if (RTL8192E_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8192E)
+			odm_PrimaryCCA_Check_Init(pDM_Odm);
+	#endif
+
+#endif
+
+	}
+
+}
+
+VOID
+ODM_DMReset(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pDIG_T pDM_DigTable = &pDM_Odm->DM_DigTable;
+	
+	ODM_AntDivReset(pDM_Odm);	
+	phydm_setEDCCAThresholdAPI(pDM_Odm, pDM_DigTable->CurIGValue);
+}
+
+
+VOID
+phydm_support_ablity_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte			*_used,
+	OUT		char			*output,
+	IN		u4Byte			*_out_len
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			pre_support_ability;
+	u4Byte used = *_used;
+	u4Byte out_len = *_out_len;
+
+	pre_support_ability = pDM_Odm->SupportAbility ;	
+	PHYDM_SNPRINTF((output+used, out_len-used,"\n%s\n", "================================"));
+	if(dm_value[0] == 100)
+	{
+		PHYDM_SNPRINTF((output+used, out_len-used, "[Supportablity] PhyDM Selection\n"));
+		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
+		PHYDM_SNPRINTF((output+used, out_len-used, "00. (( %s ))DIG  \n", ((pDM_Odm->SupportAbility & ODM_BB_DIG)?("V"):(".")) ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "01. (( %s ))RA_MASK  \n", ((pDM_Odm->SupportAbility & ODM_BB_RA_MASK)?("V"):(".")) ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "02. (( %s ))DYNAMIC_TXPWR  \n", ((pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR)?("V"):("."))   ));		
+		PHYDM_SNPRINTF((output+used, out_len-used, "03. (( %s ))FA_CNT  \n", ((pDM_Odm->SupportAbility & ODM_BB_FA_CNT)?("V"):("."))  ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "04. (( %s ))RSSI_MONITOR  \n", ((pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR)?("V"):("."))   ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "05. (( %s ))CCK_PD  \n", ((pDM_Odm->SupportAbility & ODM_BB_CCK_PD)?("V"):("."))   ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "06. (( %s ))ANT_DIV  \n", ((pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)?("V"):("."))  ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "07. (( %s ))PWR_SAVE  \n", ((pDM_Odm->SupportAbility & ODM_BB_PWR_SAVE)?("V"):("."))  ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "08. (( %s ))PWR_TRAIN  \n", ((pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN)?("V"):("."))   ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "09. (( %s ))RATE_ADAPTIVE  \n", ((pDM_Odm->SupportAbility & ODM_BB_RATE_ADAPTIVE)?("V"):("."))   ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "10. (( %s ))PATH_DIV  \n", ((pDM_Odm->SupportAbility & ODM_BB_PATH_DIV)?("V"):("."))));
+		PHYDM_SNPRINTF((output+used, out_len-used, "11. (( %s ))PSD  \n", ((pDM_Odm->SupportAbility & ODM_BB_PSD)?("V"):(".")) ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "12. (( %s ))RXHP  \n", ((pDM_Odm->SupportAbility & ODM_BB_RXHP)?("V"):("."))   ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "13. (( %s ))ADAPTIVITY  \n", ((pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)?("V"):(".")) ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "14. (( %s ))CFO_TRACKING  \n", ((pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING)?("V"):(".")) ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "15. (( %s ))NHM_CNT  \n", ((pDM_Odm->SupportAbility & ODM_BB_NHM_CNT)?("V"):("."))  ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "16. (( %s ))PRIMARY_CCA  \n", ((pDM_Odm->SupportAbility & ODM_BB_PRIMARY_CCA)?("V"):(".")) ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "20. (( %s ))EDCA_TURBO  \n", ((pDM_Odm->SupportAbility & ODM_MAC_EDCA_TURBO)?("V"):("."))  ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "21. (( %s ))EARLY_MODE  \n", ((pDM_Odm->SupportAbility & ODM_MAC_EARLY_MODE)?("V"):(".")) ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "24. (( %s ))TX_PWR_TRACK  \n", ((pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK)?("V"):("."))  ));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "25. (( %s ))RX_GAIN_TRACK  \n", ((pDM_Odm->SupportAbility & ODM_RF_RX_GAIN_TRACK)?("V"):("."))  ));
+		PHYDM_SNPRINTF((output+used, out_len-used, "26. (( %s ))RF_CALIBRATION  \n", ((pDM_Odm->SupportAbility & ODM_RF_CALIBRATION)?("V"):("."))   ));
+		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
+	}
+	/*
+	else if(dm_value[0] == 101)
+	{
+		pDM_Odm->SupportAbility = 0 ;
+		DbgPrint("Disable all SupportAbility components \n");
+		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "Disable all SupportAbility components"));	
+	}
+	*/
+	else
+	{
+
+		if(dm_value[1] == 1) //enable
+		{
+			pDM_Odm->SupportAbility |= BIT(dm_value[0]) ;
+			if(BIT(dm_value[0]) & ODM_BB_PATH_DIV)
+			{
+				odm_PathDiversityInit(pDM_Odm);
+			}
+		}
+		else if(dm_value[1] == 2) //disable
+		{
+			pDM_Odm->SupportAbility &= ~(BIT(dm_value[0])) ;
+		}
+		else
+		{
+			//DbgPrint("\n[Warning!!!]  1:enable,  2:disable \n\n");
+			PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "[Warning!!!]  1:enable,  2:disable"));
+		}
+	}
+	PHYDM_SNPRINTF((output+used, out_len-used,"pre-SupportAbility  =  0x%x\n",  pre_support_ability ));	
+	PHYDM_SNPRINTF((output+used, out_len-used,"Curr-SupportAbility =  0x%x\n", pDM_Odm->SupportAbility ));
+	PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
+}
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+//
+//tmp modify for LC Only
+//
+VOID
+ODM_DMWatchdog_LPS(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{	
+	odm_CommonInfoSelfUpdate(pDM_Odm);
+	odm_FalseAlarmCounterStatistics(pDM_Odm);
+	odm_RSSIMonitorCheck(pDM_Odm);
+	odm_DIGbyRSSI_LPS(pDM_Odm);	
+	odm_CCKPacketDetectionThresh(pDM_Odm);
+	odm_CommonInfoSelfReset(pDM_Odm);
+
+	if(*(pDM_Odm->pbPowerSaving)==TRUE)
+		return;
+}
+#endif
+//
+// 2011/09/20 MH This is the entry pointer for all team to execute HW out source DM.
+// You can not add any dummy function here, be care, you can only use DM structure
+// to perform any new ODM_DM.
+//
+VOID
+ODM_DMWatchdog(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	odm_CommonInfoSelfUpdate(pDM_Odm);
+	phydm_BasicDbgMessage(pDM_Odm);
+	odm_HWSetting(pDM_Odm);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	{
+	prtl8192cd_priv priv		= pDM_Odm->priv;
+	if( (priv->auto_channel != 0) && (priv->auto_channel != 2) )//if ACS running, do not do FA/CCA counter read
+		return;
+	}
+#endif	
+	odm_FalseAlarmCounterStatistics(pDM_Odm);
+	phydm_NoisyDetection(pDM_Odm);
+	
+	odm_RSSIMonitorCheck(pDM_Odm);
+
+	if(*(pDM_Odm->pbPowerSaving) == TRUE)
+	{
+		odm_DIGbyRSSI_LPS(pDM_Odm);
+		{
+			pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+			Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("DMWatchdog in power saving mode\n"));
+		return;
+	}
+	
+	Phydm_CheckAdaptivity(pDM_Odm);
+	odm_UpdatePowerTrainingState(pDM_Odm);
+	odm_DIG(pDM_Odm);
+	{
+		pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+		Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
+	}
+	odm_CCKPacketDetectionThresh(pDM_Odm);
+	phydm_ra_dynamic_retry_limit(pDM_Odm);
+	phydm_ra_dynamic_retry_count(pDM_Odm);
+	odm_RefreshRateAdaptiveMask(pDM_Odm);
+	odm_RefreshBasicRateMask(pDM_Odm);
+	odm_DynamicBBPowerSaving(pDM_Odm);
+	odm_EdcaTurboCheck(pDM_Odm);
+	odm_PathDiversity(pDM_Odm);
+	ODM_CfoTracking(pDM_Odm);
+	odm_DynamicTxPower(pDM_Odm);
+	odm_AntennaDiversity(pDM_Odm);
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+	phydm_Beamforming_Watchdog(pDM_Odm);
+#endif
+
+	phydm_rf_watchdog(pDM_Odm);
+
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+	        
+#if (RTL8188E_SUPPORT == 1)
+	        if(pDM_Odm->SupportICType==ODM_RTL8188E)
+	                odm_DynamicPrimaryCCA(pDM_Odm);	
+#endif
+
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	#if (RTL8192E_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8192E)
+			odm_DynamicPrimaryCCA_Check(pDM_Odm); 
+	#endif
+#endif
+	}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	odm_dtc(pDM_Odm);
+#endif
+
+	odm_CommonInfoSelfReset(pDM_Odm);
+	
+}
+
+
+//
+// Init /.. Fixed HW value. Only init time.
+//
+VOID
+ODM_CmnInfoInit(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		u4Byte			Value	
+	)
+{
+	//
+	// This section is used for init value
+	//
+	switch	(CmnInfo)
+	{
+		//
+		// Fixed ODM value.
+		//
+		case	ODM_CMNINFO_ABILITY:
+			pDM_Odm->SupportAbility = (u4Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RF_TYPE:
+			pDM_Odm->RFType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_PLATFORM:
+			pDM_Odm->SupportPlatform = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_INTERFACE:
+			pDM_Odm->SupportInterface = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_MP_TEST_CHIP:
+			pDM_Odm->bIsMPChip= (u1Byte)Value;
+			break;
+            
+		case	ODM_CMNINFO_IC_TYPE:
+			pDM_Odm->SupportICType = Value;
+			break;
+
+		case	ODM_CMNINFO_CUT_VER:
+			pDM_Odm->CutVersion = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_FAB_VER:
+			pDM_Odm->FabVersion = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RFE_TYPE:
+			pDM_Odm->RFEType = (u1Byte)Value;
+			break;
+
+		case    ODM_CMNINFO_RF_ANTENNA_TYPE:
+			pDM_Odm->AntDivType= (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_BOARD_TYPE:
+			pDM_Odm->BoardType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_PACKAGE_TYPE:
+			pDM_Odm->PackageType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_EXT_LNA:
+			pDM_Odm->ExtLNA = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_5G_EXT_LNA:
+			pDM_Odm->ExtLNA5G = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_EXT_PA:
+			pDM_Odm->ExtPA = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_5G_EXT_PA:
+			pDM_Odm->ExtPA5G = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_GPA:
+			pDM_Odm->TypeGPA = (u2Byte)Value;
+			break;
+		case	ODM_CMNINFO_APA:
+			pDM_Odm->TypeAPA = (u2Byte)Value;
+			break;
+		case	ODM_CMNINFO_GLNA:
+			pDM_Odm->TypeGLNA = (u2Byte)Value;
+			break;
+		case	ODM_CMNINFO_ALNA:
+			pDM_Odm->TypeALNA = (u2Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_EXT_TRSW:
+			pDM_Odm->ExtTRSW = (u1Byte)Value;
+			break;
+		case	ODM_CMNINFO_EXT_LNA_GAIN:
+			pDM_Odm->ExtLNAGain = (u1Byte)Value;
+			break;
+		case 	ODM_CMNINFO_PATCH_ID:
+			pDM_Odm->PatchID = (u1Byte)Value;
+			break;
+		case 	ODM_CMNINFO_BINHCT_TEST:
+			pDM_Odm->bInHctTest = (BOOLEAN)Value;
+			break;
+		case 	ODM_CMNINFO_BWIFI_TEST:
+			pDM_Odm->bWIFITest = (BOOLEAN)Value;
+			break;	
+		case	ODM_CMNINFO_SMART_CONCURRENT:
+			pDM_Odm->bDualMacSmartConcurrent = (BOOLEAN )Value;
+			break;
+		case	ODM_CMNINFO_DOMAIN_CODE_2G:
+			pDM_Odm->odm_Regulation2_4G = (u1Byte)Value;
+			break;
+		case	ODM_CMNINFO_DOMAIN_CODE_5G:
+			pDM_Odm->odm_Regulation5G = (u1Byte)Value;
+			break;
+		case	ODM_CMNINFO_CONFIG_BB_RF:
+			pDM_Odm->ConfigBBRF = (BOOLEAN)Value;
+			break;
+		case	ODM_CMNINFO_IQKFWOFFLOAD:
+			pDM_Odm->IQKFWOffload = (u1Byte)Value;
+			break;
+		//To remove the compiler warning, must add an empty default statement to handle the other values.	
+		default:
+			//do nothing
+			break;	
+		
+	}
+
+}
+
+
+VOID
+ODM_CmnInfoHook(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		PVOID			pValue	
+	)
+{
+	//
+	// Hook call by reference pointer.
+	//
+	switch	(CmnInfo)
+	{
+		//
+		// Dynamic call by reference pointer.
+		//
+		case	ODM_CMNINFO_MAC_PHY_MODE:
+			pDM_Odm->pMacPhyMode = (u1Byte *)pValue;
+			break;
+		
+		case	ODM_CMNINFO_TX_UNI:
+			pDM_Odm->pNumTxBytesUnicast = (u8Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_RX_UNI:
+			pDM_Odm->pNumRxBytesUnicast = (u8Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_WM_MODE:
+			pDM_Odm->pWirelessMode = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_BAND:
+			pDM_Odm->pBandType = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_SEC_CHNL_OFFSET:
+			pDM_Odm->pSecChOffset = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_SEC_MODE:
+			pDM_Odm->pSecurity = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_BW:
+			pDM_Odm->pBandWidth = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_CHNL:
+			pDM_Odm->pChannel = (u1Byte *)pValue;
+			break;
+		
+		case	ODM_CMNINFO_DMSP_GET_VALUE:
+			pDM_Odm->pbGetValueFromOtherMac = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_BUDDY_ADAPTOR:
+			pDM_Odm->pBuddyAdapter = (PADAPTER *)pValue;
+			break;
+
+		case	ODM_CMNINFO_DMSP_IS_MASTER:
+			pDM_Odm->pbMasterOfDMSP = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_SCAN:
+			pDM_Odm->pbScanInProcess = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_POWER_SAVING:
+			pDM_Odm->pbPowerSaving = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_ONE_PATH_CCA:
+			pDM_Odm->pOnePathCCA = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_DRV_STOP:
+			pDM_Odm->pbDriverStopped =  (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_PNP_IN:
+			pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep =  (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_INIT_ON:
+			pDM_Odm->pinit_adpt_in_progress =  (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_ANT_TEST:
+			pDM_Odm->pAntennaTest =  (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_NET_CLOSED:
+			pDM_Odm->pbNet_closed = (BOOLEAN *)pValue;
+			break;
+
+		case 	ODM_CMNINFO_FORCED_RATE:
+			pDM_Odm->pForcedDataRate = (pu2Byte)pValue;
+			break;
+
+		case  ODM_CMNINFO_FORCED_IGI_LB:
+			pDM_Odm->pu1ForcedIgiLb = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_P2P_LINK:
+			pDM_Odm->DM_DigTable.bP2PInProcess = (u1Byte *)pValue;
+			break;
+
+		case 	ODM_CMNINFO_IS1ANTENNA:
+			pDM_Odm->pIs1Antenna = (BOOLEAN *)pValue;
+			break;
+			
+		case 	ODM_CMNINFO_RFDEFAULTPATH:
+			pDM_Odm->pRFDefaultPath= (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_FCS_MODE:
+			pDM_Odm->pIsFcsModeEnable = (BOOLEAN *)pValue;
+			break;
+		/*add by YuChen for beamforming PhyDM*/
+		case	ODM_CMNINFO_HUBUSBMODE:
+			pDM_Odm->HubUsbMode = (u1Byte *)pValue;
+			break;
+		case	ODM_CMNINFO_FWDWRSVDPAGEINPROGRESS:
+			pDM_Odm->pbFwDwRsvdPageInProgress = (BOOLEAN *)pValue;
+			break;
+		case	ODM_CMNINFO_TX_TP:
+			pDM_Odm->pCurrentTxTP = (u4Byte *)pValue;
+			break;
+		case	ODM_CMNINFO_RX_TP:
+			pDM_Odm->pCurrentRxTP = (u4Byte *)pValue;
+			break;
+		case	ODM_CMNINFO_SOUNDING_SEQ:
+			pDM_Odm->pSoundingSeq = (u1Byte *)pValue;
+			break;
+		//case	ODM_CMNINFO_RTSTA_AID:
+		//	pDM_Odm->pAidMap =  (u1Byte *)pValue;
+		//	break;
+
+		//case	ODM_CMNINFO_BT_COEXIST:
+		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;		
+
+		//case	ODM_CMNINFO_STA_STATUS:
+			//pDM_Odm->pODM_StaInfo[] = (PSTA_INFO_T)pValue;
+			//break;
+
+		//case	ODM_CMNINFO_PHY_STATUS:
+		//	pDM_Odm->pPhyInfo = (ODM_PHY_INFO *)pValue;
+		//	break;
+
+		//case	ODM_CMNINFO_MAC_STATUS:
+		//	pDM_Odm->pMacInfo = (ODM_MAC_INFO *)pValue;
+		//	break;
+		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+		default:
+			//do nothing
+			break;
+
+	}
+
+}
+
+
+VOID
+ODM_CmnInfoPtrArrayHook(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		u2Byte			Index,
+	IN		PVOID			pValue	
+	)
+{
+	//
+	// Hook call by reference pointer.
+	//
+	switch	(CmnInfo)
+	{
+		//
+		// Dynamic call by reference pointer.
+		//		
+		case	ODM_CMNINFO_STA_STATUS:
+			pDM_Odm->pODM_StaInfo[Index] = (PSTA_INFO_T)pValue;
+			
+			if (IS_STA_VALID(pDM_Odm->pODM_StaInfo[Index]))
+			#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->AssociatedMacId] = Index; /*AssociatedMacId are unique bttween different Adapter*/
+			#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->aid] = Index;
+			#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->mac_id] = Index;
+			#endif
+			
+			break;		
+		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+		default:
+			//do nothing
+			break;
+	}
+	
+}
+
+
+//
+// Update Band/CHannel/.. The values are dynamic but non-per-packet.
+//
+VOID
+ODM_CmnInfoUpdate(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u4Byte			CmnInfo,
+	IN		u8Byte			Value	
+	)
+{
+	//
+	// This init variable may be changed in run time.
+	//
+	switch	(CmnInfo)
+	{
+		case ODM_CMNINFO_LINK_IN_PROGRESS:
+			pDM_Odm->bLinkInProcess = (BOOLEAN)Value;
+			break;
+		
+		case	ODM_CMNINFO_ABILITY:
+			pDM_Odm->SupportAbility = (u4Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RF_TYPE:
+			pDM_Odm->RFType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_WIFI_DIRECT:
+			pDM_Odm->bWIFI_Direct = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_WIFI_DISPLAY:
+			pDM_Odm->bWIFI_Display = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_LINK:
+			pDM_Odm->bLinked = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_STATION_STATE:
+			pDM_Odm->bsta_state = (BOOLEAN)Value;
+			break;
+			
+		case	ODM_CMNINFO_RSSI_MIN:
+			pDM_Odm->RSSI_Min= (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_DBG_COMP:
+			pDM_Odm->DebugComponents = Value;
+			break;
+
+		case	ODM_CMNINFO_DBG_LEVEL:
+			pDM_Odm->DebugLevel = (u4Byte)Value;
+			break;
+		case	ODM_CMNINFO_RA_THRESHOLD_HIGH:
+			pDM_Odm->RateAdaptive.HighRSSIThresh = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RA_THRESHOLD_LOW:
+			pDM_Odm->RateAdaptive.LowRSSIThresh = (u1Byte)Value;
+			break;
+#if defined(BT_SUPPORT) && (BT_SUPPORT == 1)
+		// The following is for BT HS mode and BT coexist mechanism.
+		case ODM_CMNINFO_BT_ENABLED:
+			pDM_Odm->bBtEnabled = (BOOLEAN)Value;
+			break;
+			
+		case ODM_CMNINFO_BT_HS_CONNECT_PROCESS:
+			pDM_Odm->bBtConnectProcess = (BOOLEAN)Value;
+			break;
+		
+		case ODM_CMNINFO_BT_HS_RSSI:
+			pDM_Odm->btHsRssi = (u1Byte)Value;
+			break;
+			
+		case	ODM_CMNINFO_BT_OPERATION:
+			pDM_Odm->bBtHsOperation = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_BT_LIMITED_DIG:
+			pDM_Odm->bBtLimitedDig = (BOOLEAN)Value;
+			break;	
+
+		case ODM_CMNINFO_BT_DIG:
+			pDM_Odm->btHsDigVal = (u1Byte)Value;
+			break;
+			
+		case	ODM_CMNINFO_BT_BUSY:
+			pDM_Odm->bBtBusy = (BOOLEAN)Value;
+			break;	
+
+		case	ODM_CMNINFO_BT_DISABLE_EDCA:
+			pDM_Odm->bBtDisableEdcaTurbo = (BOOLEAN)Value;
+			break;
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)		// for repeater mode add by YuChen 2014.06.23
+#ifdef UNIVERSAL_REPEATER
+		case	ODM_CMNINFO_VXD_LINK:
+			pDM_Odm->VXD_bLinked= (BOOLEAN)Value;
+			break;
+#endif
+#endif
+
+		case	ODM_CMNINFO_AP_TOTAL_NUM:
+			pDM_Odm->APTotalNum = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_POWER_TRAINING:
+			pDM_Odm->bDisablePowerTraining = (BOOLEAN)Value;
+			break;
+
+/*
+		case	ODM_CMNINFO_OP_MODE:
+			pDM_Odm->OPMode = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_WM_MODE:
+			pDM_Odm->WirelessMode = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_BAND:
+			pDM_Odm->BandType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_SEC_CHNL_OFFSET:
+			pDM_Odm->SecChOffset = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_SEC_MODE:
+			pDM_Odm->Security = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_BW:
+			pDM_Odm->BandWidth = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_CHNL:
+			pDM_Odm->Channel = (u1Byte)Value;
+			break;			
+*/	
+                default:
+			//do nothing
+			break;
+	}
+
+	
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
+{
+
+	PADAPTER		pAdapter = pDM_Odm->Adapter;
+#if USE_WORKITEM
+	#if (RTL8723B_SUPPORT == 1) || (RTL8821A_SUPPORT == 1)
+	ODM_InitializeWorkItem(	pDM_Odm, 
+							&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem_8723B, 
+							(RT_WORKITEM_CALL_BACK)ODM_SW_AntDiv_WorkitemCallback,
+							(PVOID)pAdapter,
+							"AntennaSwitchWorkitem");
+	#endif
+	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+	ODM_InitializeWorkItem(pDM_Odm, 
+						&pDM_Odm->dm_sat_table.hl_smart_antenna_workitem, 
+						(RT_WORKITEM_CALL_BACK)phydm_beam_switch_workitem_callback,
+						(PVOID)pAdapter,
+						"hl_smart_ant_workitem");
+
+	ODM_InitializeWorkItem(pDM_Odm, 
+						&pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem, 
+						(RT_WORKITEM_CALL_BACK)phydm_beam_decision_workitem_callback,
+						(PVOID)pAdapter,
+						"hl_smart_ant_decision_workitem");
+	#endif
+	
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->PathDivSwitchWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback, 
+		(PVOID)pAdapter,
+		"SWAS_WorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->CCKPathDiversityWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback, 
+		(PVOID)pAdapter,
+		"CCKTXPathDiversityWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->MPT_DIGWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback, 
+		(PVOID)pAdapter,
+		"MPT_DIGWorkitem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->RaRptWorkitem), 
+		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback, 
+		(PVOID)pAdapter,
+		"RaRptWorkitem");
+
+#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->FastAntTrainingWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback, 
+		(PVOID)pAdapter,
+		"FastAntTrainingWorkitem");
+#endif
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->DM_RXHP_Table.PSDTimeWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_PSD_RXHPWorkitemCallback, 
+		(PVOID)pAdapter,
+		"PSDRXHP_WorkItem");
+
+#endif /*#if USE_WORKITEM*/
+
+#if (BEAMFORMING_SUPPORT == 1)
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_EnterWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_EnterWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_EnterWorkItem");
+	
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_LeaveWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_LeaveWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_LeaveWorkItem");
+	
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_FwNdpaWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_FwNdpaWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_ClkWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_ClkWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_ClkWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_RateWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_RateWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_RateWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_StatusWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_StatusWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_StatusWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_ResetTxPathWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_ResetTxPathWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_ResetTxPathWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_GetTxRateWorkItem),
+		(RT_WORKITEM_CALL_BACK)halComTxbf_GetTxRateWorkItemCallback,
+		(PVOID)pAdapter,
+		"Txbf_GetTxRateWorkItem");
+#endif
+}
+
+VOID
+ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm )
+{
+#if USE_WORKITEM
+#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
+	ODM_FreeWorkItem(&(pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem_8723B));
+#endif
+#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+	ODM_FreeWorkItem(&(pDM_Odm->dm_sat_table.hl_smart_antenna_workitem));
+
+	ODM_FreeWorkItem(&(pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem));
+#endif
+
+	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));      
+	ODM_FreeWorkItem(&(pDM_Odm->CCKPathDiversityWorkitem));
+#if (defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY)) || (defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY))
+	ODM_FreeWorkItem(&(pDM_Odm->FastAntTrainingWorkitem));
+#endif
+	ODM_FreeWorkItem(&(pDM_Odm->MPT_DIGWorkitem));
+	ODM_FreeWorkItem(&(pDM_Odm->RaRptWorkitem));
+	ODM_FreeWorkItem((&pDM_Odm->DM_RXHP_Table.PSDTimeWorkitem));
+	/*ODM_FreeWorkItem((&pDM_Odm->sbdcnt_workitem));*/
+#endif
+
+#if (BEAMFORMING_SUPPORT == 1)
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_EnterWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_LeaveWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_ClkWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_RateWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_StatusWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_ResetTxPathWorkItem));
+	ODM_FreeWorkItem((&pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_GetTxRateWorkItem));
+#endif
+
+}
+#endif /*#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)*/
+
+/*
+VOID
+odm_FindMinimumRSSI(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	u4Byte	i;
+	u1Byte	RSSI_Min = 0xFF;
+
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+//		if(pDM_Odm->pODM_StaInfo[i] != NULL)
+		if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
+		{
+			if(pDM_Odm->pODM_StaInfo[i]->RSSI_Ave < RSSI_Min)
+			{
+				RSSI_Min = pDM_Odm->pODM_StaInfo[i]->RSSI_Ave;
+			}
+		}
+	}
+
+	pDM_Odm->RSSI_Min = RSSI_Min;
+
+}
+
+VOID
+odm_IsLinked(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	u4Byte i;
+	BOOLEAN Linked = FALSE;
+	
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+			if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
+			{			
+				Linked = TRUE;
+				break;
+			}
+		
+	}
+
+	pDM_Odm->bLinked = Linked;
+}
+*/
+
+VOID
+ODM_InitAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+	ODM_AntDivTimers(pDM_Odm,INIT_ANTDIV_TIMMER);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+#ifdef MP_TEST
+#error InitializeTimer not converted
+	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific) 
+		ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
+			(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");	
+#endif
+#elif(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#error InitializeTimer not converted
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
+		(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#error InitializeTimer not converted
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PSDTimer, 
+		(RT_TIMER_CALL_BACK)dm_PSDMonitorCallback, NULL, "PSDTimer");
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 
+		(RT_TIMER_CALL_BACK)odm_PathDivChkAntSwitchCallback, NULL, "PathDivTimer");
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, 
+		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer");
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer,
+		(RT_TIMER_CALL_BACK)odm_PSD_RXHPCallback, NULL, "PSDRXHPTimer"); 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->sbdcnt_timer,
+		(RT_TIMER_CALL_BACK)phydm_sbd_callback, NULL, "SbdTimer"); 
+#if (BEAMFORMING_SUPPORT == 1)
+#error InitializeTimer not converted
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaTimer,
+		(RT_TIMER_CALL_BACK)halComTxbf_FwNdpaTimerCallback, NULL, "Txbf_FwNdpaTimer");
+#endif
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (BEAMFORMING_SUPPORT == 1)
+#error InitializeTimer not converted
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.BeamformingTimer,
+		(RT_TIMER_CALL_BACK)Beamforming_SWTimerCallback, NULL, "BeamformingTimer");
+#endif
+#endif
+}
+
+VOID
+ODM_CancelAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	//
+	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in 
+	// win7 platform.
+	//
+	HAL_ADAPTER_STS_CHK(pDM_Odm)
+#endif	
+
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+	ODM_AntDivTimers(pDM_Odm,CANCEL_ANTDIV_TIMMER);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+#ifdef MP_TEST
+	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific)
+		ODM_CancelTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+#endif
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->PSDTimer);	
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer);
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer);
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer);
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->sbdcnt_timer);
+#if (BEAMFORMING_SUPPORT == 1)
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaTimer);
+#endif
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (BEAMFORMING_SUPPORT == 1)
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.BeamformingTimer);
+#endif
+#endif
+
+}
+
+
+VOID
+ODM_ReleaseAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+	ODM_AntDivTimers(pDM_Odm,RELEASE_ANTDIV_TIMMER);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+    #ifdef MP_TEST
+	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific)
+		ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+    #endif
+#elif(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->PSDTimer);
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer);
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer);
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer);
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->sbdcnt_timer);
+#if (BEAMFORMING_SUPPORT == 1)
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaTimer);
+#endif
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (BEAMFORMING_SUPPORT == 1)
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.BeamformingTimer);
+#endif
+#endif
+}
+
+
+//3============================================================
+//3 Tx Power Tracking
+//3============================================================
+
+
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+VOID
+ODM_InitAllThreads(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+	#ifdef TPT_THREAD
+	kTPT_task_init(pDM_Odm->priv);
+	#endif
+}
+
+VOID
+ODM_StopAllThreads(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+	#ifdef TPT_THREAD
+	kTPT_task_stop(pDM_Odm->priv);
+	#endif
+}
+#endif	
+
+
+#if( DM_ODM_SUPPORT_TYPE == ODM_WIN) 
+//
+// 2011/07/26 MH Add an API for testing IQK fail case.
+//
+BOOLEAN
+ODM_CheckPowerStatus(
+	IN	PADAPTER		Adapter)
+{
+
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	RT_RF_POWER_STATE 	rtState;
+	PMGNT_INFO			pMgntInfo	= &(Adapter->MgntInfo);
+
+	// 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.
+	if (pMgntInfo->init_adpt_in_progress == TRUE)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter\n"));
+		return	TRUE;
+	}
+	
+	//
+	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
+	//
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
+	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+		Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
+		return	FALSE;
+	}
+	return	TRUE;
+}
+#elif( DM_ODM_SUPPORT_TYPE == ODM_AP)
+BOOLEAN
+ODM_CheckPowerStatus(
+		IN	PADAPTER		Adapter)
+{
+	/*
+	   HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	   PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	   RT_RF_POWER_STATE 	rtState;
+	   PMGNT_INFO			pMgntInfo	= &(Adapter->MgntInfo);
+
+	// 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.
+	if (pMgntInfo->init_adpt_in_progress == TRUE)
+	{
+	ODM_RT_TRACE(pDM_Odm,COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter"));
+	return	TRUE;
+	}
+
+	//
+	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
+	//
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
+	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
+	{
+	ODM_RT_TRACE(pDM_Odm,COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+	Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
+	return	FALSE;
+	}
+	 */
+	return	TRUE;
+}
+#endif
+
+// need to ODM CE Platform
+//move to here for ANT detection mechanism using
+
+#if ((DM_ODM_SUPPORT_TYPE == ODM_WIN)||(DM_ODM_SUPPORT_TYPE == ODM_CE))
+u4Byte
+GetPSDData(
+	IN PDM_ODM_T	pDM_Odm,
+	unsigned int 	point,
+	u1Byte initial_gain_psd)
+{
+	//unsigned int	val, rfval;
+	//int	psd_report;
+	u4Byte	psd_report;
+	
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//Debug Message
+	//val = PHY_QueryBBReg(Adapter,0x908, bMaskDWord);
+	//DbgPrint("Reg908 = 0x%x\n",val);
+	//val = PHY_QueryBBReg(Adapter,0xDF4, bMaskDWord);
+	//rfval = PHY_QueryRFReg(Adapter, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
+	//DbgPrint("RegDF4 = 0x%x, RFReg00 = 0x%x\n",val, rfval);
+	//DbgPrint("PHYTXON = %x, OFDMCCA_PP = %x, CCKCCA_PP = %x, RFReg00 = %x\n",
+		//(val&BIT25)>>25, (val&BIT14)>>14, (val&BIT15)>>15, rfval);
+
+	//Set DCO frequency index, offset=(40MHz/SamplePts)*point
+	ODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);
+
+	//Start PSD calculation, Reg808[22]=0->1
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);
+	//Need to wait for HW PSD report
+	ODM_StallExecution(1000);
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);
+	//Read PSD report, Reg8B4[15:0]
+	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;
+	
+#if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE) && ( (RT_PLATFORM == PLATFORM_LINUX) || (RT_PLATFORM == PLATFORM_MACOSX))
+	psd_report = (u4Byte) (odm_ConvertTo_dB(psd_report))+(u4Byte)(initial_gain_psd-0x1c);
+#else
+	psd_report = (int) (20*log10((double)psd_report))+(int)(initial_gain_psd-0x1c);
+#endif
+
+	return psd_report;
+	
+}
+#endif
+
+u4Byte 
+odm_ConvertTo_dB(
+	u4Byte 	Value)
+{
+	u1Byte i;
+	u1Byte j;
+	u4Byte dB;
+
+	Value = Value & 0xFFFF;
+
+	for (i = 0; i < 12; i++)
+	{
+		if (Value <= dB_Invert_Table[i][7])
+		{
+			break;
+		}
+	}
+
+	if (i >= 12)
+	{
+		return (96);	// maximum 96 dB
+	}
+
+	for (j = 0; j < 8; j++)
+	{
+		if (Value <= dB_Invert_Table[i][j])
+		{
+			break;
+		}
+	}
+
+	dB = (i << 3) + j + 1;
+
+	return (dB);
+}
+
+u4Byte 
+odm_ConvertTo_linear(
+	u4Byte 	Value)
+{
+	u1Byte i;
+	u1Byte j;
+	u4Byte linear;
+	
+	/* 1dB~96dB */
+	
+	Value = Value & 0xFF;
+
+	i = (u1Byte)((Value - 1) >> 3);
+	j = (u1Byte)(Value - 1) - (i << 3);
+
+	linear = dB_Invert_Table[i][j];
+
+	return (linear);
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_UpdateInitRateWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	u1Byte			p = 0;	
+
+	if(pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		ODM_TxPwrTrackSetPwr8821A(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8812A; p++)    //DOn't know how to include &c
+		{
+			ODM_TxPwrTrackSetPwr8812A(pDM_Odm, MIX_MODE, p, 0);
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+			ODM_TxPwrTrackSetPwr_8723B(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8192E; p++)    //DOn't know how to include &c
+		{
+			ODM_TxPwrTrackSetPwr92E(pDM_Odm, MIX_MODE, p, 0);
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+			ODM_TxPwrTrackSetPwr88E(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+	}
+}
+#endif
+
+//
+// ODM multi-port consideration, added by Roger, 2013.10.01.
+//
+VOID
+ODM_AsocEntry_Init(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER pLoopAdapter = GetDefaultAdapter(pDM_Odm->Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pLoopAdapter);
+	PDM_ODM_T		 pDM_OutSrc = &pHalData->DM_OutSrc;
+	u1Byte	TotalAssocEntryNum = 0;
+	u1Byte	index = 0;
+
+
+	ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, 0, &pLoopAdapter->MgntInfo.DefaultPort[0]);
+	pLoopAdapter->MgntInfo.DefaultPort[0].MultiPortStationIdx = TotalAssocEntryNum;
+		
+	pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+	TotalAssocEntryNum +=1;
+
+	while(pLoopAdapter)
+	{
+		for (index = 0; index <ASSOCIATE_ENTRY_NUM; index++)
+		{
+			ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, TotalAssocEntryNum+index, &pLoopAdapter->MgntInfo.AsocEntry[index]);
+			pLoopAdapter->MgntInfo.AsocEntry[index].MultiPortStationIdx = TotalAssocEntryNum+index;				
+		}
+		
+		TotalAssocEntryNum+= index;
+		if(IS_HARDWARE_TYPE_8188E((pDM_Odm->Adapter)))
+			pLoopAdapter->RASupport = TRUE;
+		pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+	}
+#endif
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+/* Justin: According to the current RRSI to adjust Response Frame TX power, 2012/11/05 */
+void odm_dtc(PDM_ODM_T pDM_Odm)
+{
+#ifdef CONFIG_DM_RESP_TXAGC
+	#define DTC_BASE            35	/* RSSI higher than this value, start to decade TX power */
+	#define DTC_DWN_BASE       (DTC_BASE-5)	/* RSSI lower than this value, start to increase TX power */
+
+	/* RSSI vs TX power step mapping: decade TX power */
+	static const u8 dtc_table_down[]={
+		DTC_BASE,
+		(DTC_BASE+5),
+		(DTC_BASE+10),
+		(DTC_BASE+15),
+		(DTC_BASE+20),
+		(DTC_BASE+25)
+	};
+
+	/* RSSI vs TX power step mapping: increase TX power */
+	static const u8 dtc_table_up[]={
+		DTC_DWN_BASE,
+		(DTC_DWN_BASE-5),
+		(DTC_DWN_BASE-10),
+		(DTC_DWN_BASE-15),
+		(DTC_DWN_BASE-15),
+		(DTC_DWN_BASE-20),
+		(DTC_DWN_BASE-20),
+		(DTC_DWN_BASE-25),
+		(DTC_DWN_BASE-25),
+		(DTC_DWN_BASE-30),
+		(DTC_DWN_BASE-35)
+	};
+
+	u8 i;
+	u8 dtc_steps=0;
+	u8 sign;
+	u8 resp_txagc=0;
+
+	#if 0
+	/* As DIG is disabled, DTC is also disable */
+	if(!(pDM_Odm->SupportAbility & ODM_XXXXXX))
+		return;
+	#endif
+
+	if (DTC_BASE < pDM_Odm->RSSI_Min) {
+		/* need to decade the CTS TX power */
+		sign = 1;
+		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++)
+		{
+			if ((dtc_table_down[i] >= pDM_Odm->RSSI_Min) || (dtc_steps >= 6))
+				break;
+			else
+				dtc_steps++;
+		}
+	}
+#if 0
+	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min)
+	{
+		/* needs to increase the CTS TX power */
+		sign = 0;
+		dtc_steps = 1;
+		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++)
+		{
+			if ((dtc_table_up[i] <= pDM_Odm->RSSI_Min) || (dtc_steps>=10))
+				break;
+			else
+				dtc_steps++;
+		}
+	}
+#endif
+	else
+	{
+		sign = 0;
+		dtc_steps = 0;
+	}
+
+	resp_txagc = dtc_steps | (sign << 4);
+	resp_txagc = resp_txagc | (resp_txagc << 5);
+	ODM_Write1Byte(pDM_Odm, 0x06d9, resp_txagc);
+
+	DBG_871X("%s RSSI_Min:%u, set RESP_TXAGC to %s %u\n", 
+		__func__, pDM_Odm->RSSI_Min, sign?"minus":"plus", dtc_steps);
+#endif /* CONFIG_RESP_TXAGC_ADJUST */
+}
+
+#endif /* #if (DM_ODM_SUPPORT_TYPE == ODM_CE) */
+
+VOID
+odm_UpdatePowerTrainingState(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm , PHYDM_FALSEALMCNT);
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	u4Byte						score = 0;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN))
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState()============>\n"));
+	pDM_Odm->bChangeState = FALSE;
+
+	// Debug command
+	if(pDM_Odm->ForcePowerTrainingState)
+	{
+		if(pDM_Odm->ForcePowerTrainingState == 1 && !pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = TRUE;
+		}
+		else if(pDM_Odm->ForcePowerTrainingState == 2 && pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = FALSE;
+		}
+
+		pDM_Odm->PT_score = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): ForcePowerTrainingState = %d\n", 
+			pDM_Odm->ForcePowerTrainingState));
+		return;
+	}
+	
+	if(!pDM_Odm->bLinked)
+		return;
+	
+	// First connect
+	if((pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE))
+	{
+		pDM_Odm->PT_score = 0;
+		pDM_Odm->bChangeState = TRUE;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): First Connect\n"));
+		return;
+	}
+
+	// Compute score
+	if(pDM_Odm->NHM_cnt_0 >= 215)
+		score = 2;
+	else if(pDM_Odm->NHM_cnt_0 >= 190) 
+		score = 1;							// unknow state
+	else
+	{
+		u4Byte	RX_Pkt_Cnt;
+		
+		RX_Pkt_Cnt = (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM) + (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK);
+		
+		if((FalseAlmCnt->Cnt_CCA_all > 31 && RX_Pkt_Cnt > 31) && (FalseAlmCnt->Cnt_CCA_all >= RX_Pkt_Cnt))
+		{
+			if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 1)) <= FalseAlmCnt->Cnt_CCA_all)
+				score = 0;
+			else if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 2)) <= FalseAlmCnt->Cnt_CCA_all)
+				score = 1;
+			else
+				score = 2;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): RX_Pkt_Cnt = %d, Cnt_CCA_all = %d\n", 
+			RX_Pkt_Cnt, FalseAlmCnt->Cnt_CCA_all));
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NumQryPhyStatusOFDM = %d, NumQryPhyStatusCCK = %d\n",
+			(u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM), (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NHM_cnt_0 = %d, score = %d\n", 
+		pDM_Odm->NHM_cnt_0, score));
+
+	// smoothing
+	pDM_Odm->PT_score = (score << 4) + (pDM_Odm->PT_score>>1) + (pDM_Odm->PT_score>>2);
+	score = (pDM_Odm->PT_score + 32) >> 6;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): PT_score = %d, score after smoothing = %d\n", 
+		pDM_Odm->PT_score, score));
+
+	// Mode decision
+	if(score == 2)
+	{
+		if(pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Enable Power Training\n"));
+	}
+	else if(score == 0)
+	{
+		if(!pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = TRUE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Disable Power Training\n"));
+	}
+
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+#endif
+}
+
+
+
+/*===========================================================*/
+/* The following is for compile only*/
+/*===========================================================*/
+/*#define TARGET_CHNL_NUM_2G_5G	59*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+u1Byte GetRightChnlPlaceforIQK(u1Byte chnl)
+{
+	u1Byte	channel_all[TARGET_CHNL_NUM_2G_5G] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 100, 
+		102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 149, 151, 153, 155, 157, 159, 161, 163, 165};
+	u1Byte	place = chnl;
+
+	
+	if (chnl > 14) {
+		for (place = 14; place < sizeof(channel_all); place++) {
+			if (channel_all[place] == chnl)
+				return place-13;
+		}
+	}
+	
+	return 0;
+}
+
+VOID
+FillH2CCmd92C(	
+	IN	PADAPTER		Adapter,
+	IN	u1Byte	ElementID,
+	IN	u4Byte	CmdLen,
+	IN	pu1Byte	pCmdBuffer
+)
+{}
+VOID
+PHY_SetTxPowerLevel8192C(
+	IN	PADAPTER		Adapter,
+	IN	u1Byte			channel
+	)
+{
+}
+#endif
+/*===========================================================*/
+
+VOID
+phydm_NoisyDetection(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+	u4Byte  Total_FA_Cnt, Total_CCA_Cnt;
+	u4Byte  Score = 0, i, Score_Smooth;
+    
+	Total_CCA_Cnt = pDM_Odm->FalseAlmCnt.Cnt_CCA_all;
+	Total_FA_Cnt  = pDM_Odm->FalseAlmCnt.Cnt_all;    
+
+/*
+    if( Total_FA_Cnt*16>=Total_CCA_Cnt*14 )         // 87.5
+    
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*12 )    // 75
+    
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*10 )    // 56.25
+    
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*8 )     // 50
+
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*7 )     // 43.75
+
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*6 )     // 37.5
+
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*5 )     // 31.25%
+        
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*4 )     // 25%
+
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*3 )     // 18.75%
+
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*2 )     // 12.5%
+
+    else if( Total_FA_Cnt*16>=Total_CCA_Cnt*1 )     // 6.25%
+*/
+    for(i=0;i<=16;i++)
+    {
+        if( Total_FA_Cnt*16>=Total_CCA_Cnt*(16-i) )
+        {
+            Score = 16-i;
+            break;
+        }
+    }
+
+    // NoisyDecision_Smooth = NoisyDecision_Smooth>>1 + (Score<<3)>>1;
+    pDM_Odm->NoisyDecision_Smooth = (pDM_Odm->NoisyDecision_Smooth>>1) + (Score<<2);
+
+    // Round the NoisyDecision_Smooth: +"3" comes from (2^3)/2-1
+    Score_Smooth = (Total_CCA_Cnt>=300)?((pDM_Odm->NoisyDecision_Smooth+3)>>3):0;
+
+    pDM_Odm->NoisyDecision = (Score_Smooth>=3)?1:0;
+/*
+    switch(Score_Smooth)
+    {
+        case 0:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=0%%\n"));
+            break;
+        case 1:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=6.25%%\n"));
+            break;
+        case 2:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=12.5%%\n"));
+            break;
+        case 3:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=18.75%%\n"));
+            break;
+        case 4:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=25%%\n"));
+            break;
+        case 5:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=31.25%%\n"));
+            break;
+        case 6:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=37.5%%\n"));
+            break;
+        case 7:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=43.75%%\n"));
+            break;
+        case 8:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=50%%\n"));
+            break;
+        case 9:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=56.25%%\n"));
+            break;
+        case 10:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=62.5%%\n"));
+            break;
+        case 11:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=68.75%%\n"));
+            break;
+        case 12:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=75%%\n"));
+            break;
+        case 13:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=81.25%%\n"));
+            break;
+        case 14:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=87.5%%\n"));
+            break;
+        case 15:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=93.75%%\n"));            
+            break;
+        case 16:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=100%%\n"));
+            break;
+        default:
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("[NoisyDetection] Unknown Value!! Need Check!!\n"));            
+    }
+*/        
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_NOISY_DETECT, ODM_DBG_LOUD,
+	("[NoisyDetection] Total_CCA_Cnt=%d, Total_FA_Cnt=%d, NoisyDecision_Smooth=%d, Score=%d, Score_Smooth=%d, pDM_Odm->NoisyDecision=%d\n",
+	Total_CCA_Cnt, Total_FA_Cnt, pDM_Odm->NoisyDecision_Smooth, Score, Score_Smooth, pDM_Odm->NoisyDecision));
+	
+}
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.h
new file mode 100644
index 000000000..231b9044f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm.h
@@ -0,0 +1,1441 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__HALDMOUTSRC_H__
+#define __HALDMOUTSRC_H__
+
+//============================================================
+// include files
+//============================================================
+#include "phydm_pre_define.h"
+#include "phydm_dig.h"
+#include "phydm_edcaturbocheck.h"
+#include "phydm_pathdiv.h"
+#include "phydm_antdiv.h"
+#include "phydm_antdect.h"
+#include "phydm_dynamicbbpowersaving.h"
+#include "phydm_rainfo.h"
+#include "phydm_dynamictxpower.h"
+#include "phydm_cfotracking.h"
+#include "phydm_acs.h"
+#include "phydm_adaptivity.h"
+
+
+#if (RTL8814A_SUPPORT == 1)
+#include "rtl8814a/phydm_iqk_8814a.h"
+#endif
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+#include "halphyrf_ap.h"
+#include "phydm_powertracking_ap.h"
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+#include "phydm_beamforming.h"
+#include "phydm_noisemonitor.h"
+#include "halphyrf_ce.h"
+#include "phydm_powertracking_ce.h"
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#include "phydm_beamforming.h"
+#include "phydm_rxhp.h"
+#include "halphyrf_win.h"
+#include "phydm_powertracking_win.h"
+#endif
+
+//============================================================
+// Definition 
+//============================================================
+//
+// 2011/09/22 MH Define all team supprt ability.
+//
+
+//
+// 2011/09/22 MH Define for all teams. Please Define the constan in your precomp header.
+//
+//#define		DM_ODM_SUPPORT_AP			0
+//#define		DM_ODM_SUPPORT_ADSL			0
+//#define		DM_ODM_SUPPORT_CE			0
+//#define		DM_ODM_SUPPORT_MP			1
+
+//
+// 2011/09/28 MH Define ODM SW team support flag.
+//
+
+//For SW AntDiv, PathDiv, 8192C AntDiv joint use
+#define	TP_MODE		0
+#define	RSSI_MODE		1
+
+#define	TRAFFIC_LOW	0
+#define	TRAFFIC_HIGH	1
+#define	TRAFFIC_ULTRA_LOW	2
+#define	TRAFFIC_MID	3
+
+
+#define	NONE			0
+
+
+
+
+//8723A High Power IGI Setting
+#define		DM_DIG_HIGH_PWR_IGI_LOWER_BOUND	0x22
+#define  		DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND 0x28
+#define		DM_DIG_HIGH_PWR_THRESHOLD	0x3a
+#define		DM_DIG_LOW_PWR_THRESHOLD	0x14
+
+
+//============================================================
+// structure and define
+//============================================================
+
+//
+// 2011/09/20 MH Add for AP/ADSLpseudo DM structuer requirement.
+// We need to remove to other position???
+//
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+typedef		struct rtl8192cd_priv {
+	u1Byte		temp;
+
+}rtl8192cd_priv, *prtl8192cd_priv;
+#endif
+
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+typedef		struct _ADAPTER{
+	u1Byte		temp;
+	#ifdef AP_BUILD_WORKAROUND
+	HAL_DATA_TYPE*		temp2;
+	prtl8192cd_priv		priv;
+	#endif
+}ADAPTER, *PADAPTER;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+typedef		struct _WLAN_STA{
+	u1Byte		temp;
+} WLAN_STA, *PRT_WLAN_STA;
+
+#endif
+
+typedef struct _Dynamic_Primary_CCA{
+	u1Byte		PriCCA_flag;
+	u1Byte		intf_flag;
+	u1Byte		intf_type;  
+	u1Byte		DupRTS_flag;
+	u1Byte		Monitor_flag;
+	u1Byte		CH_offset;
+	u1Byte  	MF_state;
+}Pri_CCA_T, *pPri_CCA_T;
+
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+
+
+#ifdef ADSL_AP_BUILD_WORKAROUND
+#define MAX_TOLERANCE			5
+#define IQK_DELAY_TIME			1		//ms
+#endif
+#if 0//defined in 8192cd.h
+//
+// Indicate different AP vendor for IOT issue.
+//
+typedef enum _HT_IOT_PEER
+{
+	HT_IOT_PEER_UNKNOWN 			= 0,
+	HT_IOT_PEER_REALTEK 			= 1,
+	HT_IOT_PEER_REALTEK_92SE 		= 2,
+	HT_IOT_PEER_BROADCOM 		= 3,
+	HT_IOT_PEER_RALINK 			= 4,
+	HT_IOT_PEER_ATHEROS 			= 5,
+	HT_IOT_PEER_CISCO 				= 6,
+	HT_IOT_PEER_MERU 				= 7,	
+	HT_IOT_PEER_MARVELL 			= 8,
+	HT_IOT_PEER_REALTEK_SOFTAP 	= 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
+	HT_IOT_PEER_SELF_SOFTAP 		= 10, // Self is SoftAP
+	HT_IOT_PEER_AIRGO 				= 11,
+	HT_IOT_PEER_INTEL 				= 12, 
+	HT_IOT_PEER_RTK_APCLIENT 		= 13, 
+	HT_IOT_PEER_REALTEK_81XX 		= 14,	
+	HT_IOT_PEER_REALTEK_WOW 		= 15,	
+	HT_IOT_PEER_MAX 				= 16
+}HT_IOT_PEER_E, *PHTIOT_PEER_E;
+#endif
+#endif//#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+
+#define		DM_Type_ByFW			0
+#define		DM_Type_ByDriver		1
+
+//
+// Declare for common info
+//
+
+#define IQK_THRESHOLD			8
+#define DPK_THRESHOLD			4
+
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_AP))
+__PACK typedef struct _ODM_Phy_Status_Info_
+{
+	u1Byte		RxPWDBAll;
+	u1Byte		SignalQuality;					/* in 0-100 index. */
+	u1Byte		RxMIMOSignalStrength[4];		/* in 0~100 index */
+	s1Byte		RxMIMOSignalQuality[4];		/* EVM */
+	s1Byte		RxSNR[4];					/* per-path's SNR */
+#if (RTL8822B_SUPPORT == 1)
+	u1Byte		RxCount;						/* RX path counter---*/
+#endif
+	u1Byte		BandWidth;
+
+} __WLAN_ATTRIB_PACK__ ODM_PHY_INFO_T, *PODM_PHY_INFO_T;
+
+typedef struct _ODM_Phy_Status_Info_Append_
+{
+	u1Byte		MAC_CRC32;	
+
+}ODM_PHY_INFO_Append_T,*PODM_PHY_INFO_Append_T;
+
+#else
+
+typedef struct _ODM_Phy_Status_Info_
+{
+	//
+	// Be care, if you want to add any element please insert between 
+	// RxPWDBAll & SignalStrength.
+	//
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN))
+	u4Byte		RxPWDBAll;	
+#else
+	u1Byte		RxPWDBAll;	
+#endif
+	u1Byte		SignalQuality;				/* in 0-100 index. */
+	s1Byte		RxMIMOSignalQuality[4];		/* per-path's EVM */
+	u1Byte		RxMIMOEVMdbm[4];			/* per-path's EVM dbm */
+	u1Byte		RxMIMOSignalStrength[4];	/* in 0~100 index */
+	s2Byte		Cfo_short[4];				/* per-path's Cfo_short */
+	s2Byte		Cfo_tail[4];					/* per-path's Cfo_tail */
+	s1Byte		RxPower;					/* in dBm Translate from PWdB */
+	s1Byte		RecvSignalPower;			/* Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures. */
+	u1Byte		BTRxRSSIPercentage;
+	u1Byte		SignalStrength;				/* in 0-100 index. */
+	s1Byte		RxPwr[4];					/* per-path's pwdb */
+	s1Byte		RxSNR[4];					/* per-path's SNR	*/
+#if (RTL8822B_SUPPORT == 1)
+	u1Byte		RxCount:2;					/* RX path counter---*/
+	u1Byte		BandWidth:2;
+	u1Byte		rxsc:4;						/* sub-channel---*/
+#else
+	u1Byte		BandWidth;
+#endif
+	u1Byte		btCoexPwrAdjust;
+#if (RTL8822B_SUPPORT == 1)
+	u1Byte		channel;						/* channel number---*/
+	BOOLEAN		bMuPacket;					/* is MU packet or not---*/
+	BOOLEAN		bBeamformed;				/* BF packet---*/
+#endif
+}ODM_PHY_INFO_T,*PODM_PHY_INFO_T;
+#endif
+
+typedef struct _ODM_Per_Pkt_Info_
+{
+	//u1Byte		Rate;	
+	u1Byte		DataRate;
+	u1Byte		StationID;
+	BOOLEAN		bPacketMatchBSSID;
+	BOOLEAN		bPacketToSelf;
+	BOOLEAN		bPacketBeacon;
+	BOOLEAN		bToSelf;
+}ODM_PACKET_INFO_T,*PODM_PACKET_INFO_T;
+
+
+typedef struct _ODM_Phy_Dbg_Info_
+{
+	//ODM Write,debug info
+	s1Byte		RxSNRdB[4];
+	u4Byte		NumQryPhyStatus;
+	u4Byte		NumQryPhyStatusCCK;
+	u4Byte		NumQryPhyStatusOFDM;
+#if (RTL8822B_SUPPORT == 1)
+	u4Byte		NumQryMuPkt;
+	u4Byte		NumQryBfPkt;
+#endif
+	u1Byte		NumQryBeaconPkt;
+	//Others
+	s4Byte		RxEVM[4];	
+	
+}ODM_PHY_DBG_INFO_T;
+
+
+typedef struct _ODM_Mac_Status_Info_
+{
+	u1Byte	test;
+	
+}ODM_MAC_INFO;
+
+//
+// 2011/20/20 MH For MP driver RT_WLAN_STA =  STA_INFO_T
+// Please declare below ODM relative info in your STA info structure.
+//
+#if 1
+typedef		struct _ODM_STA_INFO{
+	// Driver Write
+	BOOLEAN		bUsed;				// record the sta status link or not?
+	//u1Byte		WirelessMode;		// 
+	u1Byte		IOTPeer;			// Enum value.	HT_IOT_PEER_E
+
+	// ODM Write
+	//1 PHY_STATUS_INFO
+	u1Byte		RSSI_Path[4];		// 
+	u1Byte		RSSI_Ave;
+	u1Byte		RXEVM[4];
+	u1Byte		RXSNR[4];
+
+	// ODM Write
+	//1 TX_INFO (may changed by IC)
+	//TX_INFO_T		pTxInfo;				// Define in IC folder. Move lower layer.
+#if 0
+	u1Byte		ANTSEL_A;			//in Jagar: 4bit; others: 2bit
+	u1Byte		ANTSEL_B;			//in Jagar: 4bit; others: 2bit
+	u1Byte		ANTSEL_C;			//only in Jagar: 4bit
+	u1Byte		ANTSEL_D;			//only in Jagar: 4bit
+	u1Byte		TX_ANTL;			//not in Jagar: 2bit
+	u1Byte		TX_ANT_HT;			//not in Jagar: 2bit
+	u1Byte		TX_ANT_CCK;			//not in Jagar: 2bit
+	u1Byte		TXAGC_A;			//not in Jagar: 4bit
+	u1Byte		TXAGC_B;			//not in Jagar: 4bit
+	u1Byte		TXPWR_OFFSET;		//only in Jagar: 3bit
+	u1Byte		TX_ANT;				//only in Jagar: 4bit for TX_ANTL/TX_ANTHT/TX_ANT_CCK
+#endif
+
+	//
+	// 	Please use compile flag to disabe the strcutrue for other IC except 88E.
+	//	Move To lower layer.
+	//
+	// ODM Write Wilson will handle this part(said by Luke.Lee)
+	//TX_RPT_T		pTxRpt;				// Define in IC folder. Move lower layer.
+#if 0	
+	//1 For 88E RA (don't redefine the naming)
+	u1Byte		rate_id;
+	u1Byte		rate_SGI;
+	u1Byte		rssi_sta_ra;
+	u1Byte		SGI_enable;
+	u1Byte		Decision_rate;
+	u1Byte		Pre_rate;
+	u1Byte		Active;
+
+	// Driver write Wilson handle.
+	//1 TX_RPT (don't redefine the naming)
+	u2Byte		RTY[4];				// ???
+	u2Byte		TOTAL;				// ???
+	u2Byte		DROP;				// ???
+	//
+	// Please use compile flag to disabe the strcutrue for other IC except 88E.
+	//
+#endif
+
+}ODM_STA_INFO_T, *PODM_STA_INFO_T;
+#endif
+
+//
+// 2011/10/20 MH Define Common info enum for all team.
+//
+typedef enum _ODM_Common_Info_Definition
+{
+//-------------REMOVED CASE-----------//
+	//ODM_CMNINFO_CCK_HP,
+	//ODM_CMNINFO_RFPATH_ENABLE,		// Define as ODM write???	
+	//ODM_CMNINFO_BT_COEXIST,				// ODM_BT_COEXIST_E
+	//ODM_CMNINFO_OP_MODE,				// ODM_OPERATION_MODE_E
+//-------------REMOVED CASE-----------//
+
+	//
+	// Fixed value:
+	//
+
+	//-----------HOOK BEFORE REG INIT-----------//
+	ODM_CMNINFO_PLATFORM = 0,
+	ODM_CMNINFO_ABILITY,					// ODM_ABILITY_E
+	ODM_CMNINFO_INTERFACE,				// ODM_INTERFACE_E
+	ODM_CMNINFO_MP_TEST_CHIP,
+	ODM_CMNINFO_IC_TYPE,					// ODM_IC_TYPE_E
+	ODM_CMNINFO_CUT_VER,					// ODM_CUT_VERSION_E
+	ODM_CMNINFO_FAB_VER,					// ODM_FAB_E
+	ODM_CMNINFO_RF_TYPE,					// ODM_RF_PATH_E or ODM_RF_TYPE_E?
+	ODM_CMNINFO_RFE_TYPE, 
+	ODM_CMNINFO_BOARD_TYPE,				// ODM_BOARD_TYPE_E
+	ODM_CMNINFO_PACKAGE_TYPE,
+	ODM_CMNINFO_EXT_LNA,					// TRUE
+	ODM_CMNINFO_5G_EXT_LNA,	
+	ODM_CMNINFO_EXT_PA,
+	ODM_CMNINFO_5G_EXT_PA,
+	ODM_CMNINFO_GPA,
+	ODM_CMNINFO_APA,
+	ODM_CMNINFO_GLNA,
+	ODM_CMNINFO_ALNA,
+	ODM_CMNINFO_EXT_TRSW,
+	ODM_CMNINFO_EXT_LNA_GAIN,
+	ODM_CMNINFO_PATCH_ID,				//CUSTOMER ID
+	ODM_CMNINFO_BINHCT_TEST,
+	ODM_CMNINFO_BWIFI_TEST,
+	ODM_CMNINFO_SMART_CONCURRENT,
+	ODM_CMNINFO_CONFIG_BB_RF,
+	ODM_CMNINFO_DOMAIN_CODE_2G,
+	ODM_CMNINFO_DOMAIN_CODE_5G,
+	ODM_CMNINFO_IQKFWOFFLOAD,
+	ODM_CMNINFO_HUBUSBMODE,
+	ODM_CMNINFO_FWDWRSVDPAGEINPROGRESS,
+	ODM_CMNINFO_TX_TP,
+	ODM_CMNINFO_RX_TP,
+	ODM_CMNINFO_SOUNDING_SEQ,
+	//-----------HOOK BEFORE REG INIT-----------//	
+
+
+	//
+	// Dynamic value:
+	//
+//--------- POINTER REFERENCE-----------//
+	ODM_CMNINFO_MAC_PHY_MODE,			// ODM_MAC_PHY_MODE_E
+	ODM_CMNINFO_TX_UNI,
+	ODM_CMNINFO_RX_UNI,
+	ODM_CMNINFO_WM_MODE,				// ODM_WIRELESS_MODE_E
+	ODM_CMNINFO_BAND,					// ODM_BAND_TYPE_E
+	ODM_CMNINFO_SEC_CHNL_OFFSET,		// ODM_SEC_CHNL_OFFSET_E
+	ODM_CMNINFO_SEC_MODE,				// ODM_SECURITY_E
+	ODM_CMNINFO_BW,						// ODM_BW_E
+	ODM_CMNINFO_CHNL,
+	ODM_CMNINFO_FORCED_RATE,
+	
+	ODM_CMNINFO_DMSP_GET_VALUE,
+	ODM_CMNINFO_BUDDY_ADAPTOR,
+	ODM_CMNINFO_DMSP_IS_MASTER,
+	ODM_CMNINFO_SCAN,
+	ODM_CMNINFO_POWER_SAVING,
+	ODM_CMNINFO_ONE_PATH_CCA,			// ODM_CCA_PATH_E
+	ODM_CMNINFO_DRV_STOP,
+	ODM_CMNINFO_PNP_IN,
+	ODM_CMNINFO_INIT_ON,
+	ODM_CMNINFO_ANT_TEST,
+	ODM_CMNINFO_NET_CLOSED,
+	//ODM_CMNINFO_RTSTA_AID,				// For win driver only?
+	ODM_CMNINFO_FORCED_IGI_LB,
+	ODM_CMNINFO_P2P_LINK,
+	ODM_CMNINFO_FCS_MODE,
+	ODM_CMNINFO_IS1ANTENNA,
+	ODM_CMNINFO_RFDEFAULTPATH,
+//--------- POINTER REFERENCE-----------//
+
+//------------CALL BY VALUE-------------//
+	ODM_CMNINFO_WIFI_DIRECT,
+	ODM_CMNINFO_WIFI_DISPLAY,
+	ODM_CMNINFO_LINK_IN_PROGRESS,			
+	ODM_CMNINFO_LINK,
+	ODM_CMNINFO_STATION_STATE,
+	ODM_CMNINFO_RSSI_MIN,
+	ODM_CMNINFO_DBG_COMP,				// u8Byte
+	ODM_CMNINFO_DBG_LEVEL,				// u4Byte
+	ODM_CMNINFO_RA_THRESHOLD_HIGH,		// u1Byte
+	ODM_CMNINFO_RA_THRESHOLD_LOW,		// u1Byte
+	ODM_CMNINFO_RF_ANTENNA_TYPE,		// u1Byte
+	ODM_CMNINFO_BT_ENABLED,
+	ODM_CMNINFO_BT_HS_CONNECT_PROCESS,
+	ODM_CMNINFO_BT_HS_RSSI,
+	ODM_CMNINFO_BT_OPERATION,
+	ODM_CMNINFO_BT_LIMITED_DIG,					//Need to Limited Dig or not
+	ODM_CMNINFO_BT_DIG,
+	ODM_CMNINFO_BT_BUSY,					//Check Bt is using or not//neil	
+	ODM_CMNINFO_BT_DISABLE_EDCA,
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)		// for repeater mode add by YuChen 2014.06.23
+#ifdef UNIVERSAL_REPEATER
+	ODM_CMNINFO_VXD_LINK,
+#endif
+#endif
+	ODM_CMNINFO_AP_TOTAL_NUM,
+	ODM_CMNINFO_POWER_TRAINING,
+//------------CALL BY VALUE-------------//
+
+	//
+	// Dynamic ptr array hook itms.
+	//
+	ODM_CMNINFO_STA_STATUS,
+	ODM_CMNINFO_PHY_STATUS,
+	ODM_CMNINFO_MAC_STATUS,
+	
+	ODM_CMNINFO_MAX,
+
+
+}ODM_CMNINFO_E;
+
+//
+// 2011/10/20 MH Define ODM support ability.  ODM_CMNINFO_ABILITY
+//
+typedef enum _ODM_Support_Ability_Definition
+{
+	//
+	// BB ODM section BIT 0-19
+	//
+	ODM_BB_DIG					= BIT0,
+	ODM_BB_RA_MASK				= BIT1,
+	ODM_BB_DYNAMIC_TXPWR		= BIT2,
+	ODM_BB_FA_CNT					= BIT3,
+	ODM_BB_RSSI_MONITOR			= BIT4,
+	ODM_BB_CCK_PD				= BIT5,
+	ODM_BB_ANT_DIV				= BIT6,
+	ODM_BB_PWR_SAVE				= BIT7,
+	ODM_BB_PWR_TRAIN				= BIT8,
+	ODM_BB_RATE_ADAPTIVE			= BIT9,
+	ODM_BB_PATH_DIV				= BIT10,
+	ODM_BB_PSD					= BIT11,
+	ODM_BB_RXHP					= BIT12,
+	ODM_BB_ADAPTIVITY				= BIT13,
+	ODM_BB_CFO_TRACKING			= BIT14,
+	ODM_BB_NHM_CNT				= BIT15,
+	ODM_BB_PRIMARY_CCA			= BIT16,
+	ODM_BB_TXBF				= BIT17,
+	
+	//
+	// MAC DM section BIT 20-23
+	//
+	ODM_MAC_EDCA_TURBO			= BIT20,
+	ODM_MAC_EARLY_MODE			= BIT21,
+	
+	//
+	// RF ODM section BIT 24-31
+	//
+	ODM_RF_TX_PWR_TRACK			= BIT24,
+	ODM_RF_RX_GAIN_TRACK			= BIT25,
+	ODM_RF_CALIBRATION			= BIT26,
+	
+}ODM_ABILITY_E;
+
+//Move some non-DM enum,define, struc. form phydm.h to phydm_types.h by Dino
+
+// ODM_CMNINFO_ONE_PATH_CCA
+typedef enum tag_CCA_Path
+{
+	ODM_CCA_2R			= 0,
+	ODM_CCA_1R_A		= 1,
+	ODM_CCA_1R_B		= 2,
+}ODM_CCA_PATH_E;
+
+//move RAInfo to Phydm_RaInfo.h
+
+//Remove struct  PATHDIV_PARA to odm_PathDiv.h 
+
+//Remove struct to odm_PowerTracking.h by YuChen
+//
+// ODM Dynamic common info value definition
+//
+//Move AntDiv form phydm.h to Phydm_AntDiv.h by Dino
+
+//move PathDiv to Phydm_PathDiv.h
+
+typedef enum _BASEBAND_CONFIG_PHY_REG_PG_VALUE_TYPE{
+	PHY_REG_PG_RELATIVE_VALUE = 0,
+	PHY_REG_PG_EXACT_VALUE = 1
+} PHY_REG_PG_TYPE;
+
+//
+// 2011/09/22 MH Copy from SD4 defined structure. We use to support PHY DM integration.
+//
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (RT_PLATFORM != PLATFORM_LINUX)
+typedef 
+#endif
+	
+struct DM_Out_Source_Dynamic_Mechanism_Structure
+#else// for AP,ADSL,CE Team
+typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
+#endif
+{
+	//RT_TIMER 	FastAntTrainingTimer;
+	//
+	//	Add for different team use temporarily
+	//
+	PADAPTER		Adapter;		// For CE/NIC team
+	prtl8192cd_priv	priv;			// For AP/ADSL team
+	// WHen you use Adapter or priv pointer, you must make sure the pointer is ready.
+	BOOLEAN			odm_ready;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	rtl8192cd_priv		fake_priv;
+#endif
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	// ADSL_AP_BUILD_WORKAROUND
+	ADAPTER			fake_adapter;
+#endif
+	
+	PHY_REG_PG_TYPE		PhyRegPgValueType;
+	u1Byte				PhyRegPgVersion;
+
+	u8Byte			DebugComponents;
+	u4Byte			DebugLevel;
+	
+	u4Byte			NumQryPhyStatusAll; 	//CCK + OFDM
+	u4Byte			LastNumQryPhyStatusAll; 
+	u4Byte			RxPWDBAve;
+	BOOLEAN			MPDIG_2G; 		//off MPDIG
+	u1Byte			Times_2G;
+	
+//------ ODM HANDLE, DRIVER NEEDS NOT TO HOOK------//
+	BOOLEAN			bCckHighPower; 
+	u1Byte			RFPathRxEnable;		// ODM_CMNINFO_RFPATH_ENABLE
+	u1Byte			ControlChannel;
+//------ ODM HANDLE, DRIVER NEEDS NOT TO HOOK------//
+
+//--------REMOVED COMMON INFO----------//
+	//u1Byte				PseudoMacPhyMode;
+	//BOOLEAN			*BTCoexist;
+	//BOOLEAN			PseudoBtCoexist;
+	//u1Byte				OPMode;
+	//BOOLEAN			bAPMode;
+	//BOOLEAN			bClientMode;
+	//BOOLEAN			bAdHocMode;
+	//BOOLEAN			bSlaveOfDMSP;
+//--------REMOVED COMMON INFO----------//
+
+
+//1  COMMON INFORMATION
+
+	//
+	// Init Value
+	//
+//-----------HOOK BEFORE REG INIT-----------//	
+	// ODM Platform info AP/ADSL/CE/MP = 1/2/3/4
+	u1Byte			SupportPlatform;		
+	// ODM Support Ability DIG/RATR/TX_PWR_TRACK/ KK = 1/2/3/K
+	u4Byte			SupportAbility;
+	// ODM PCIE/USB/SDIO = 1/2/3
+	u1Byte			SupportInterface;			
+	// ODM composite or independent. Bit oriented/ 92C+92D+ .... or any other type = 1/2/3/...
+	u4Byte			SupportICType;	
+	// Cut Version TestChip/A-cut/B-cut... = 0/1/2/3/...
+	u1Byte			CutVersion;
+	// Fab Version TSMC/UMC = 0/1
+	u1Byte			FabVersion;
+	// RF Type 4T4R/3T3R/2T2R/1T2R/1T1R/...
+	u1Byte			RFType;
+	u1Byte			RFEType;	
+	// Board Type Normal/HighPower/MiniCard/SLIM/Combo/... = 0/1/2/3/4/...
+	u1Byte			BoardType;
+	u1Byte			PackageType;
+	u2Byte			TypeGLNA;
+	u2Byte			TypeGPA;
+	u2Byte			TypeALNA;
+	u2Byte			TypeAPA;
+	// with external LNA  NO/Yes = 0/1
+	u1Byte			ExtLNA; // 2G
+	u1Byte			ExtLNA5G; //5G
+	// with external PA  NO/Yes = 0/1
+	u1Byte			ExtPA; // 2G
+	u1Byte			ExtPA5G; //5G
+	// with external TRSW  NO/Yes = 0/1
+	u1Byte			ExtTRSW;
+	u1Byte			ExtLNAGain; // 2G
+	u1Byte			PatchID; //Customer ID
+	BOOLEAN			bInHctTest;
+	BOOLEAN			bWIFITest;
+
+	BOOLEAN			bDualMacSmartConcurrent;
+	u4Byte			BK_SupportAbility;
+	u1Byte			AntDivType;
+	BOOLEAN			ConfigBBRF;
+	u1Byte			odm_Regulation2_4G;
+	u1Byte			odm_Regulation5G;
+	u1Byte			IQKFWOffload;
+//-----------HOOK BEFORE REG INIT-----------//	
+
+	//
+	// Dynamic Value
+	//	
+//--------- POINTER REFERENCE-----------//
+
+	u1Byte			u1Byte_temp;
+	BOOLEAN			BOOLEAN_temp;
+	PADAPTER		PADAPTER_temp;
+	
+	// MAC PHY Mode SMSP/DMSP/DMDP = 0/1/2
+	u1Byte			*pMacPhyMode;
+	//TX Unicast byte count
+	u8Byte			*pNumTxBytesUnicast;
+	//RX Unicast byte count
+	u8Byte			*pNumRxBytesUnicast;
+	// Wireless mode B/G/A/N = BIT0/BIT1/BIT2/BIT3
+	u1Byte			*pWirelessMode; //ODM_WIRELESS_MODE_E
+	// Frequence band 2.4G/5G = 0/1
+	u1Byte			*pBandType;
+	// Secondary channel offset don't_care/below/above = 0/1/2
+	u1Byte			*pSecChOffset;
+	// Security mode Open/WEP/AES/TKIP = 0/1/2/3
+	u1Byte			*pSecurity;
+	// BW info 20M/40M/80M = 0/1/2
+	u1Byte			*pBandWidth;
+ 	// Central channel location Ch1/Ch2/....
+	u1Byte			*pChannel;	//central channel number
+	BOOLEAN			DPK_Done;
+	// Common info for 92D DMSP
+	
+	BOOLEAN			*pbGetValueFromOtherMac;
+	PADAPTER		*pBuddyAdapter;
+	BOOLEAN			*pbMasterOfDMSP; //MAC0: master, MAC1: slave
+	// Common info for Status
+	BOOLEAN			*pbScanInProcess;
+	BOOLEAN			*pbPowerSaving;
+	// CCA Path 2-path/path-A/path-B = 0/1/2; using ODM_CCA_PATH_E.
+	u1Byte			*pOnePathCCA;
+	//pMgntInfo->AntennaTest
+	u1Byte			*pAntennaTest;
+	BOOLEAN			*pbNet_closed;
+	//u1Byte			*pAidMap;
+	u1Byte			*pu1ForcedIgiLb;
+	BOOLEAN			*pIsFcsModeEnable;
+/*--------- For 8723B IQK-----------*/
+	BOOLEAN			*pIs1Antenna;
+	u1Byte			*pRFDefaultPath;
+	// 0:S1, 1:S0
+	
+//--------- POINTER REFERENCE-----------//
+	pu2Byte			pForcedDataRate;
+	pu1Byte			HubUsbMode;
+	BOOLEAN			*pbFwDwRsvdPageInProgress;
+	u4Byte			*pCurrentTxTP;
+	u4Byte			*pCurrentRxTP;
+	u1Byte			*pSoundingSeq;
+//------------CALL BY VALUE-------------//
+	BOOLEAN			bLinkInProcess;
+	BOOLEAN			bWIFI_Direct;
+	BOOLEAN			bWIFI_Display;
+	BOOLEAN			bLinked;
+	BOOLEAN			bsta_state;
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)		// for repeater mode add by YuChen 2014.06.23
+#ifdef UNIVERSAL_REPEATER
+	BOOLEAN			VXD_bLinked;
+#endif
+#endif									// for repeater mode add by YuChen 2014.06.23	
+	u1Byte			RSSI_Min;	
+	u1Byte			InterfaceIndex; /*Add for 92D  dual MAC: 0--Mac0 1--Mac1*/
+	BOOLEAN			bIsMPChip;
+	BOOLEAN			bOneEntryOnly;
+	BOOLEAN			mp_mode;
+	u4Byte			OneEntry_MACID;
+	u1Byte			pre_number_linked_client;	
+	u1Byte			number_linked_client;
+	u1Byte			pre_number_active_client;	
+	u1Byte			number_active_client;
+	// Common info for BTDM
+	BOOLEAN			bBtEnabled;			// BT is enabled
+	BOOLEAN			bBtConnectProcess;	// BT HS is under connection progress.
+	u1Byte			btHsRssi;				// BT HS mode wifi rssi value.
+	BOOLEAN			bBtHsOperation;		// BT HS mode is under progress
+	u1Byte			btHsDigVal;			// use BT rssi to decide the DIG value
+	BOOLEAN			bBtDisableEdcaTurbo;	// Under some condition, don't enable the EDCA Turbo
+	BOOLEAN			bBtBusy;   			// BT is busy.
+	BOOLEAN			bBtLimitedDig;   		// BT is busy.
+	BOOLEAN			bDisablePhyApi;
+//------------CALL BY VALUE-------------//
+	u1Byte			RSSI_A;
+	u1Byte			RSSI_B;
+	u1Byte			RSSI_C;
+	u1Byte			RSSI_D;
+	u8Byte			RSSI_TRSW;	
+	u8Byte			RSSI_TRSW_H;
+	u8Byte			RSSI_TRSW_L;	
+	u8Byte			RSSI_TRSW_iso;
+	u1Byte			TXAntStatus;
+	u1Byte			RXAntStatus;
+	u1Byte			cck_lna_idx;
+	u1Byte			cck_vga_idx;
+	u1Byte			ofdm_agc_idx[4];
+
+	u1Byte			RxRate;
+	BOOLEAN			bNoisyState;
+	u1Byte			TxRate;
+	u1Byte			LinkedInterval;
+	u1Byte			preChannel;
+	u4Byte			TxagcOffsetValueA;
+	BOOLEAN			IsTxagcOffsetPositiveA;
+	u4Byte			TxagcOffsetValueB;
+	BOOLEAN			IsTxagcOffsetPositiveB;
+	u8Byte			lastTxOkCnt;
+	u8Byte			lastRxOkCnt;
+	u4Byte			BbSwingOffsetA;
+	BOOLEAN			IsBbSwingOffsetPositiveA;
+	u4Byte			BbSwingOffsetB;
+	BOOLEAN			IsBbSwingOffsetPositiveB;
+	u1Byte			antdiv_rssi;
+	u1Byte			fat_comb_a;
+	u1Byte			fat_comb_b;
+	u1Byte			antdiv_intvl;
+	u1Byte			AntType;
+	u1Byte			pre_AntType;
+	u1Byte			antdiv_period;
+	u1Byte			antdiv_select;
+	u1Byte			path_select;	
+	u1Byte			antdiv_evm_en;
+	u1Byte			bdc_holdstate;
+	u1Byte			NdpaPeriod;
+	BOOLEAN			H2C_RARpt_connect;
+	BOOLEAN			cck_agc_report_type;
+	
+	u1Byte			dm_dig_max_TH;
+	u1Byte 			dm_dig_min_TH;
+	u1Byte 			print_agc;
+
+	//For Adaptivtiy
+	u2Byte			NHM_cnt_0;
+	u2Byte			NHM_cnt_1;
+	s1Byte			TH_L2H_ini;
+	s1Byte			TH_EDCCA_HL_diff;
+	s1Byte			TH_L2H_ini_mode2;
+	s1Byte			TH_EDCCA_HL_diff_mode2;
+	BOOLEAN			Carrier_Sense_enable;
+	u1Byte			Adaptivity_IGI_upper;
+	BOOLEAN			adaptivity_flag;
+	u1Byte			DCbackoff;
+	BOOLEAN			Adaptivity_enable;
+	u1Byte			APTotalNum;
+	BOOLEAN			EDCCA_enable;
+	ADAPTIVITY_STATISTICS	Adaptivity;
+	//For Adaptivtiy
+	u1Byte			LastUSBHub;
+	u1Byte			TxBfDataRate;
+	
+	u1Byte			c2h_cmd_start;
+	u1Byte			fw_debug_trace[60]; 
+	u1Byte			pre_c2h_seq;
+	BOOLEAN			fw_buff_is_enpty;
+	u4Byte			data_frame_num;
+
+	/*for noise detection*/
+	BOOLEAN			NoisyDecision; /*b_noisy*/
+	BOOLEAN			pre_b_noisy;	
+	u4Byte			NoisyDecision_Smooth;
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_CE))
+	ODM_NOISE_MONITOR noise_level;//[ODM_MAX_CHANNEL_NUM];
+#endif
+	//
+	//2 Define STA info.
+	// _ODM_STA_INFO
+	// 2012/01/12 MH For MP, we need to reduce one array pointer for default port.??
+	PSTA_INFO_T		pODM_StaInfo[ODM_ASSOCIATE_ENTRY_NUM];
+	u2Byte			platform2phydm_macid_table[ODM_ASSOCIATE_ENTRY_NUM];		/* platform_macid_table[platform_macid] = phydm_macid */
+
+#if (RATE_ADAPTIVE_SUPPORT == 1)
+	u2Byte 			CurrminRptTime;
+	ODM_RA_INFO_T   RAInfo[ODM_ASSOCIATE_ENTRY_NUM]; //Use MacID as array index. STA MacID=0, VWiFi Client MacID={1, ODM_ASSOCIATE_ENTRY_NUM-1} //YJ,add,120119
+#endif
+	//
+	// 2012/02/14 MH Add to share 88E ra with other SW team.
+	// We need to colelct all support abilit to a proper area.
+	//
+	BOOLEAN				RaSupport88E;
+
+	// Define ...........
+
+	// Latest packet phy info (ODM write)
+	ODM_PHY_DBG_INFO_T	 PhyDbgInfo;
+	//PHY_INFO_88E		PhyInfo;
+
+	// Latest packet phy info (ODM write)
+	ODM_MAC_INFO		*pMacInfo;
+	//MAC_INFO_88E		MacInfo;
+
+	// Different Team independt structure??
+
+	//
+	//TX_RTP_CMN		TX_retrpo;
+	//TX_RTP_88E		TX_retrpo;
+	//TX_RTP_8195		TX_retrpo;
+
+	//
+	//ODM Structure
+	//
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+	#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	BDC_T					DM_BdcTable;
+	#endif
+	
+	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+	SAT_T						dm_sat_table;
+	#endif
+	
+#endif
+	FAT_T						DM_FatTable;
+	DIG_T						DM_DigTable;
+
+	PS_T						DM_PSTable;
+	Pri_CCA_T					DM_PriCCA;
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	RXHP_T						DM_RXHP_Table;
+#endif
+	RA_T						DM_RA_Table;  
+	FALSE_ALARM_STATISTICS		FalseAlmCnt;
+	FALSE_ALARM_STATISTICS		FlaseAlmCntBuddyAdapter;
+	SWAT_T						DM_SWAT_Table;
+	CFO_TRACKING    				DM_CfoTrack;
+	ACS							DM_ACS;
+
+
+#if (RTL8814A_SUPPORT == 1)
+	IQK_INFO	IQK_info;
+#endif /* (RTL8814A_SUPPORT==1) */
+
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	//Path Div Struct
+	PATHDIV_PARA	pathIQK;
+#endif
+#if(defined(CONFIG_PATH_DIVERSITY))
+	PATHDIV_T	DM_PathDiv;
+#endif	
+
+	EDCA_T		DM_EDCA_Table;
+	u4Byte		WMMEDCA_BE;
+
+	// Copy from SD4 structure
+	//
+	// ==================================================
+	//
+
+	//common
+	//u1Byte		DM_Type;	
+	//u1Byte    PSD_Report_RXHP[80];   // Add By Gary
+	//u1Byte    PSD_func_flag;               // Add By Gary
+	//for DIG
+	//u1Byte		bDMInitialGainEnable;
+	//u1Byte		binitialized; // for dm_initial_gain_Multi_STA use.
+	//for Antenna diversity
+	//u8	AntDivCfg;// 0:OFF , 1:ON, 2:by efuse
+	//PSTA_INFO_T RSSI_target;
+
+	BOOLEAN			*pbDriverStopped;
+	BOOLEAN			*pbDriverIsGoingToPnpSetPowerSleep;
+	BOOLEAN			*pinit_adpt_in_progress;
+
+	//PSD
+	BOOLEAN			bUserAssignLevel;
+	RT_TIMER 		PSDTimer;
+	u1Byte			RSSI_BT;			//come from BT
+	BOOLEAN			bPSDinProcess;
+	BOOLEAN			bPSDactive;
+	BOOLEAN			bDMInitialGainEnable;
+
+	//MPT DIG
+	RT_TIMER 		MPT_DIGTimer;
+	
+	//for rate adaptive, in fact,  88c/92c fw will handle this
+	u1Byte			bUseRAMask;
+
+	ODM_RATE_ADAPTIVE	RateAdaptive;
+//#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if(defined(CONFIG_ANT_DETECTION))
+	ANT_DETECTED_INFO	AntDetectedInfo; // Antenna detected information for RSSI tool
+#endif
+	ODM_RF_CAL_T	RFCalibrateInfo;
+
+	
+	//
+	// Dynamic ATC switch
+	//
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))	
+	//
+	// Power Training
+	//
+	u1Byte			ForcePowerTrainingState;
+	BOOLEAN			bChangeState;
+	u4Byte			PT_score;
+	u8Byte			OFDM_RX_Cnt;
+	u8Byte			CCK_RX_Cnt;
+#endif
+	BOOLEAN			bDisablePowerTraining;
+
+	//
+	// ODM system resource.
+	//
+
+	// ODM relative time.
+	RT_TIMER 				PathDivSwitchTimer;
+	//2011.09.27 add for Path Diversity
+	RT_TIMER				CCKPathDiversityTimer;
+	RT_TIMER 	FastAntTrainingTimer;
+#ifdef ODM_EVM_ENHANCE_ANTDIV
+	RT_TIMER 			EVM_FastAntTrainingTimer;
+#endif
+	RT_TIMER		sbdcnt_timer;
+
+	// ODM relative workitem.
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#if USE_WORKITEM
+	RT_WORK_ITEM			PathDivSwitchWorkitem;
+	RT_WORK_ITEM			CCKPathDiversityWorkitem;
+	RT_WORK_ITEM			FastAntTrainingWorkitem;
+	RT_WORK_ITEM			MPT_DIGWorkitem;
+	RT_WORK_ITEM			RaRptWorkitem;
+	RT_WORK_ITEM			sbdcnt_workitem;
+#endif
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (BEAMFORMING_SUPPORT == 1)
+	RT_BEAMFORMING_INFO BeamformingInfo;
+#endif 
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	
+#if (RT_PLATFORM != PLATFORM_LINUX)
+} DM_ODM_T, *PDM_ODM_T;		// DM_Dynamic_Mechanism_Structure
+#else
+};
+#endif	
+
+#else// for AP,ADSL,CE Team
+} DM_ODM_T, *PDM_ODM_T;		// DM_Dynamic_Mechanism_Structure
+#endif
+
+
+typedef enum _PHYDM_STRUCTURE_TYPE{
+	PHYDM_FALSEALMCNT,
+	PHYDM_CFOTRACK,
+	PHYDM_ADAPTIVITY,
+	PHYDM_ROMINFO,
+	
+}PHYDM_STRUCTURE_TYPE;
+
+
+
+ typedef enum _ODM_RF_CONTENT{
+	odm_radioa_txt = 0x1000,
+	odm_radiob_txt = 0x1001,
+	odm_radioc_txt = 0x1002,
+	odm_radiod_txt = 0x1003
+} ODM_RF_CONTENT;
+
+typedef enum _ODM_BB_Config_Type{
+	CONFIG_BB_PHY_REG,   
+	CONFIG_BB_AGC_TAB,   
+	CONFIG_BB_AGC_TAB_2G,
+	CONFIG_BB_AGC_TAB_5G, 
+	CONFIG_BB_PHY_REG_PG,
+	CONFIG_BB_PHY_REG_MP,
+	CONFIG_BB_AGC_TAB_DIFF,
+} ODM_BB_Config_Type, *PODM_BB_Config_Type;
+
+typedef enum _ODM_RF_Config_Type{ 
+	CONFIG_RF_RADIO,
+    CONFIG_RF_TXPWR_LMT,
+} ODM_RF_Config_Type, *PODM_RF_Config_Type;
+
+typedef enum _ODM_FW_Config_Type{
+    CONFIG_FW_NIC,
+    CONFIG_FW_NIC_2,
+    CONFIG_FW_AP,
+    CONFIG_FW_AP_2,
+    CONFIG_FW_MP,
+    CONFIG_FW_WoWLAN,
+    CONFIG_FW_WoWLAN_2,
+    CONFIG_FW_AP_WoWLAN,
+    CONFIG_FW_BT,
+} ODM_FW_Config_Type;
+
+// Status code
+#if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
+typedef enum _RT_STATUS{
+	RT_STATUS_SUCCESS,
+	RT_STATUS_FAILURE,
+	RT_STATUS_PENDING,
+	RT_STATUS_RESOURCE,
+	RT_STATUS_INVALID_CONTEXT,
+	RT_STATUS_INVALID_PARAMETER,
+	RT_STATUS_NOT_SUPPORT,
+	RT_STATUS_OS_API_FAILED,
+}RT_STATUS,*PRT_STATUS;
+#endif // end of RT_STATUS definition
+
+#ifdef REMOVE_PACK
+#pragma pack()
+#endif
+
+//#include "odm_function.h"
+
+//3===========================================================
+//3 DIG
+//3===========================================================
+
+//Remove DIG by Yuchen
+
+//3===========================================================
+//3 AGC RX High Power Mode
+//3===========================================================
+#define          LNA_Low_Gain_1                      0x64
+#define          LNA_Low_Gain_2                      0x5A
+#define          LNA_Low_Gain_3                      0x58
+
+#define          FA_RXHP_TH1                           5000
+#define          FA_RXHP_TH2                           1500
+#define          FA_RXHP_TH3                             800
+#define          FA_RXHP_TH4                             600
+#define          FA_RXHP_TH5                             500
+
+//3===========================================================
+//3 EDCA
+//3===========================================================
+
+//3===========================================================
+//3 Dynamic Tx Power
+//3===========================================================
+//Dynamic Tx Power Control Threshold
+
+//Remove By YuChen
+
+//3===========================================================
+//3 Tx Power Tracking
+//3===========================================================
+
+
+
+//3===========================================================
+//3 Rate Adaptive
+//3===========================================================
+//Remove to odm_RaInfo.h by RS_James
+
+//3===========================================================
+//3 BB Power Save
+//3===========================================================
+
+typedef enum tag_1R_CCA_Type_Definition
+{
+	CCA_1R =0,
+	CCA_2R = 1,
+	CCA_MAX = 2,
+}DM_1R_CCA_E;
+
+typedef enum tag_RF_Type_Definition
+{
+	RF_Save =0,
+	RF_Normal = 1,
+	RF_MAX = 2,
+}DM_RF_E;
+
+
+//
+// Extern Global Variables.
+//
+//PowerTracking move to odm_powerTrakcing.h by YuChen
+//
+// check Sta pointer valid or not
+//
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+#define IS_STA_VALID(pSta)		(pSta && pSta->expire_to)
+#elif (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#define IS_STA_VALID(pSta)		(pSta && pSta->bUsed)
+#else
+#define IS_STA_VALID(pSta)		(pSta)
+#endif
+
+//Remove DIG by yuchen
+
+//Remove BB power saving by Yuchen
+
+//remove PT by yuchen
+
+//ODM_RAStateCheck() Remove by RS_James
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_AP|ODM_ADSL))
+//============================================================
+// function prototype
+//============================================================
+//#define DM_ChangeDynamicInitGainThresh		ODM_ChangeDynamicInitGainThresh
+//void	ODM_ChangeDynamicInitGainThresh(IN	PADAPTER	pAdapter,
+//											IN	INT32		DM_Type,
+//											IN	INT32		DM_Value);
+
+//Remove DIG by yuchen
+
+
+BOOLEAN
+ODM_CheckPowerStatus(
+	IN	PADAPTER		Adapter
+	);
+
+
+//Remove ODM_RateAdaptiveStateApInit() by RS_James
+
+//Remove Edca by YuChen
+
+#endif
+
+
+
+u4Byte odm_ConvertTo_dB(u4Byte Value);
+
+u4Byte odm_ConvertTo_linear(u4Byte Value);
+
+#if((DM_ODM_SUPPORT_TYPE==ODM_WIN)||(DM_ODM_SUPPORT_TYPE==ODM_CE))
+
+u4Byte
+GetPSDData(
+	PDM_ODM_T	pDM_Odm,
+	unsigned int 	point,
+	u1Byte initial_gain_psd);
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+VOID
+ODM_DMWatchdog_LPS(
+	IN		PDM_ODM_T		pDM_Odm
+);
+#endif
+
+
+s4Byte
+ODM_PWdB_Conversion(
+    IN  s4Byte X,
+    IN  u4Byte TotalBit,
+    IN  u4Byte DecimalBit
+    );
+
+s4Byte
+ODM_SignConversion(
+    IN  s4Byte value,
+    IN  u4Byte TotalBit
+    );
+
+VOID 
+ODM_DMInit(
+ IN	PDM_ODM_T	pDM_Odm
+);
+
+VOID
+ODM_DMReset(
+	IN	PDM_ODM_T	pDM_Odm
+	);
+
+VOID
+phydm_support_ablity_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte			*_used,
+	OUT		char				*output,
+	IN		u4Byte			*_out_len
+	);
+
+VOID
+ODM_DMWatchdog(
+	IN		PDM_ODM_T			pDM_Odm			// For common use in the future
+	);
+
+VOID
+ODM_CmnInfoInit(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		u4Byte			Value	
+	);
+
+VOID
+ODM_CmnInfoHook(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		PVOID			pValue	
+	);
+
+VOID
+ODM_CmnInfoPtrArrayHook(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		u2Byte			Index,
+	IN		PVOID			pValue	
+	);
+
+VOID
+ODM_CmnInfoUpdate(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u4Byte			CmnInfo,
+	IN		u8Byte			Value	
+	);
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
+VOID 
+ODM_InitAllThreads(
+    IN PDM_ODM_T	pDM_Odm 
+    );
+
+VOID
+ODM_StopAllThreads(
+	IN PDM_ODM_T	pDM_Odm 
+	);
+#endif
+
+VOID 
+ODM_InitAllTimers(
+    IN PDM_ODM_T	pDM_Odm 
+    );
+
+VOID 
+ODM_CancelAllTimers(
+    IN PDM_ODM_T    pDM_Odm 
+    );
+
+VOID
+ODM_ReleaseAllTimers(
+    IN PDM_ODM_T	pDM_Odm 
+    );
+
+
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm );
+VOID ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm );
+
+
+
+u8Byte
+PlatformDivision64(
+	IN u8Byte	x,
+	IN u8Byte	y
+);
+
+//====================================================
+//3 PathDiV End
+//====================================================
+
+
+#define DM_ChangeDynamicInitGainThresh		ODM_ChangeDynamicInitGainThresh
+//void	ODM_ChangeDynamicInitGainThresh(IN	PADAPTER	pAdapter,
+//											IN	INT32		DM_Type,
+//											IN	INT32		DM_Value);
+//
+// PathDiveristy Remove by RS_James
+
+typedef enum tag_DIG_Connect_Definition
+{
+	DIG_STA_DISCONNECT = 0,	
+	DIG_STA_CONNECT = 1,
+	DIG_STA_BEFORE_CONNECT = 2,
+	DIG_MultiSTA_DISCONNECT = 3,
+	DIG_MultiSTA_CONNECT = 4,
+	DIG_CONNECT_MAX
+}DM_DIG_CONNECT_E;
+
+
+//
+// 2012/01/12 MH Check afapter status. Temp fix BSOD.
+//
+#define	HAL_ADAPTER_STS_CHK(pDM_Odm)\
+	if (pDM_Odm->Adapter == NULL)\
+	{\
+		return;\
+	}\
+
+
+//
+// For new definition in MP temporarily fro power tracking,
+//
+/*
+#define odm_TXPowerTrackingDirectCall(_Adapter)	\
+	IS_HARDWARE_TYPE_8192D(_Adapter) ? odm_TXPowerTrackingCallback_ThermalMeter_92D(_Adapter) : \
+	IS_HARDWARE_TYPE_8192C(_Adapter) ? odm_TXPowerTrackingCallback_ThermalMeter_92C(_Adapter) : \
+	IS_HARDWARE_TYPE_8723A(_Adapter) ? odm_TXPowerTrackingCallback_ThermalMeter_8723A(_Adapter) :\
+	ODM_TXPowerTrackingCallback_ThermalMeter(_Adapter)
+*/
+
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+ODM_AsocEntry_Init(
+	IN		PDM_ODM_T		pDM_Odm
+	);
+
+//Remove ODM_DynamicARFBSelect() by RS_James
+
+PVOID
+PhyDM_Get_Structure(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Structure_Type
+);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN) ||(DM_ODM_SUPPORT_TYPE == ODM_CE)
+/*===========================================================*/
+/* The following is for compile only*/
+/*===========================================================*/
+
+#define	IS_HARDWARE_TYPE_8723A(_Adapter)			FALSE
+#define IS_HARDWARE_TYPE_8723AE(_Adapter)			FALSE
+#define	IS_HARDWARE_TYPE_8192C(_Adapter)			FALSE
+#define	IS_HARDWARE_TYPE_8192D(_Adapter)			FALSE
+#define	RF_T_METER_92D					0x42
+
+
+#define SET_TX_DESC_ANTSEL_A_92C(__pTxDesc, __Value) SET_BITS_TO_LE_1BYTE(__pTxDesc+8+3, 0, 1, __Value)
+#define SET_TX_DESC_TX_ANTL_92C(__pTxDesc, __Value) SET_BITS_TO_LE_1BYTE(__pTxDesc+8+3, 4, 2, __Value)
+#define SET_TX_DESC_TX_ANT_HT_92C(__pTxDesc, __Value) SET_BITS_TO_LE_1BYTE(__pTxDesc+8+3, 6, 2, __Value)
+#define SET_TX_DESC_TX_ANT_CCK_92C(__pTxDesc, __Value) SET_BITS_TO_LE_1BYTE(__pTxDesc+8+3, 2, 2, __Value)
+
+#define GET_RX_STATUS_DESC_RX_MCS(__pRxStatusDesc)				LE_BITS_TO_1BYTE( __pRxStatusDesc+12, 0, 6)
+
+#define		RX_HAL_IS_CCK_RATE_92C(pDesc)\
+			(GET_RX_STATUS_DESC_RX_MCS(pDesc) == DESC_RATE1M ||\
+			GET_RX_STATUS_DESC_RX_MCS(pDesc) == DESC_RATE2M ||\
+			GET_RX_STATUS_DESC_RX_MCS(pDesc) == DESC_RATE5_5M ||\
+			GET_RX_STATUS_DESC_RX_MCS(pDesc) == DESC_RATE11M)
+
+#define		H2C_92C_PSD_RESULT				16
+
+#define		rConfig_ram64x16				0xb2c
+
+#define TARGET_CHNL_NUM_2G_5G	59
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+FillH2CCmd92C(	
+	IN	PADAPTER		Adapter,
+	IN	u1Byte 	ElementID,
+	IN	u4Byte 	CmdLen,
+	IN	pu1Byte	pCmdBuffer
+);
+VOID
+PHY_SetTxPowerLevel8192C(
+	IN	PADAPTER		Adapter,
+	IN	u1Byte			channel
+	);
+u1Byte GetRightChnlPlaceforIQK(u1Byte chnl);
+
+#endif
+
+//===========================================================
+#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+void odm_dtc(PDM_ODM_T pDM_Odm);
+#endif /* #if (DM_ODM_SUPPORT_TYPE == ODM_CE) */
+
+
+VOID phydm_NoisyDetection(IN	PDM_ODM_T	pDM_Odm	);
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.c
new file mode 100644
index 000000000..e18047e75
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.c
@@ -0,0 +1,1306 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+
+u1Byte
+ODM_GetAutoChannelSelectResult(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Band
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS					pACS = &pDM_Odm->DM_ACS;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(Band == ODM_BAND_2_4G)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[ACS] ODM_GetAutoChannelSelectResult(): CleanChannel_2G(%d)\n", pACS->CleanChannel_2G));
+		return (u1Byte)pACS->CleanChannel_2G;	
+	}
+	else
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[ACS] ODM_GetAutoChannelSelectResult(): CleanChannel_5G(%d)\n", pACS->CleanChannel_5G));
+		return (u1Byte)pACS->CleanChannel_5G;	
+	}
+#else
+	return (u1Byte)pACS->CleanChannel_2G;
+#endif
+
+}
+
+VOID
+odm_AutoChannelSelectSetting(
+	IN		PVOID			pDM_VOID,
+	IN		BOOLEAN			IsEnable
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte						period = 0x2710;// 40ms in default
+	u2Byte						NHMType = 0x7;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectSetting()=========> \n"));
+
+	if(IsEnable)
+	{//20 ms
+		period = 0x1388;
+		NHMType = 0x1;
+	}
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		//PHY parameters initialize for ac series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC+2, period);	//0x990[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+		//ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8|BIT9|BIT10, NHMType);	//0x994[9:8]=3			enable CCX
+	}
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+		//PHY parameters initialize for n series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, period);	//0x894[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+		//ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, NHMType);	//0x890[9:8]=3			enable CCX		
+	}
+#endif
+}
+
+VOID
+odm_AutoChannelSelectInit(
+	IN		PVOID			pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS						pACS = &pDM_Odm->DM_ACS;
+	u1Byte						i;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	if(pACS->bForceACSResult)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectInit()=========> \n"));
+
+	pACS->CleanChannel_2G = 1;
+	pACS->CleanChannel_5G = 36;
+
+	for (i = 0; i < ODM_MAX_CHANNEL_2G; ++i)
+	{
+		pACS->Channel_Info_2G[0][i] = 0;
+		pACS->Channel_Info_2G[1][i] = 0;
+	}
+
+	if(pDM_Odm->SupportICType & (ODM_IC_11AC_SERIES|ODM_RTL8192D))
+	{
+		for (i = 0; i < ODM_MAX_CHANNEL_5G; ++i)
+		{
+			pACS->Channel_Info_5G[0][i] = 0;
+			pACS->Channel_Info_5G[1][i] = 0;
+		}
+	}
+#endif
+}
+
+VOID
+odm_AutoChannelSelectReset(
+	IN		PVOID			pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS						pACS = &pDM_Odm->DM_ACS;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	if(pACS->bForceACSResult)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectReset()=========> \n"));
+
+	odm_AutoChannelSelectSetting(pDM_Odm,TRUE);// for 20ms measurement
+	Phydm_NHMCounterStatisticsReset(pDM_Odm);
+#endif
+}
+
+VOID
+odm_AutoChannelSelect(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Channel
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS						pACS = &pDM_Odm->DM_ACS;
+	u1Byte						ChannelIDX = 0, SearchIDX = 0;
+	u2Byte						MaxScore=0;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Return: SupportAbility ODM_BB_NHM_CNT is disabled\n"));
+		return;
+	}
+
+	if(pACS->bForceACSResult)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Force 2G clean channel = %d, 5G clean channel = %d\n",
+			pACS->CleanChannel_2G, pACS->CleanChannel_5G));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Channel = %d=========> \n", Channel));
+
+	Phydm_GetNHMCounterStatistics(pDM_Odm);
+	odm_AutoChannelSelectSetting(pDM_Odm,FALSE);
+
+	if(Channel >=1 && Channel <=14)
+	{
+		ChannelIDX = Channel - 1;
+		pACS->Channel_Info_2G[1][ChannelIDX]++;
+		
+		if(pACS->Channel_Info_2G[1][ChannelIDX] >= 2)
+			pACS->Channel_Info_2G[0][ChannelIDX] = (pACS->Channel_Info_2G[0][ChannelIDX] >> 1) + 
+			(pACS->Channel_Info_2G[0][ChannelIDX] >> 2) + (pDM_Odm->NHM_cnt_0>>2);
+		else
+			pACS->Channel_Info_2G[0][ChannelIDX] = pDM_Odm->NHM_cnt_0;
+	
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): NHM_cnt_0 = %d \n", pDM_Odm->NHM_cnt_0));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Channel_Info[0][%d] = %d, Channel_Info[1][%d] = %d\n", ChannelIDX, pACS->Channel_Info_2G[0][ChannelIDX], ChannelIDX, pACS->Channel_Info_2G[1][ChannelIDX]));
+
+		for(SearchIDX = 0; SearchIDX < ODM_MAX_CHANNEL_2G; SearchIDX++)
+		{
+			if(pACS->Channel_Info_2G[1][SearchIDX] != 0)
+			{
+				if(pACS->Channel_Info_2G[0][SearchIDX] >= MaxScore)
+				{
+					MaxScore = pACS->Channel_Info_2G[0][SearchIDX];
+					pACS->CleanChannel_2G = SearchIDX+1;
+				}
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("(1)odm_AutoChannelSelect(): 2G: CleanChannel_2G = %d, MaxScore = %d \n", 
+			pACS->CleanChannel_2G, MaxScore));
+
+	}
+	else if(Channel >= 36)
+	{
+		// Need to do
+		pACS->CleanChannel_5G = Channel;
+	}
+#endif
+}
+
+#if ( DM_ODM_SUPPORT_TYPE & ODM_AP )
+
+VOID
+phydm_AutoChannelSelectSettingAP(
+    IN  PVOID   pDM_VOID,
+    IN  u4Byte  setting,             // 0: STORE_DEFAULT_NHM_SETTING; 1: RESTORE_DEFAULT_NHM_SETTING, 2: ACS_NHM_SETTING
+    IN  u4Byte  acs_step
+)
+{
+    PDM_ODM_T           pDM_Odm = (PDM_ODM_T)pDM_VOID;
+    prtl8192cd_priv       priv           = pDM_Odm->priv;
+    PACS                    pACS         = &pDM_Odm->DM_ACS;
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectSettingAP()=========> \n"));
+
+    //3 Store Default Setting
+    if(setting == STORE_DEFAULT_NHM_SETTING)
+    {
+        ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("STORE_DEFAULT_NHM_SETTING\n"));
+    
+        if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)     // store Reg0x990, Reg0x994, Reg0x998, Reg0x99C, Reg0x9a0
+        {
+            pACS->Reg0x990 = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC);                // Reg0x990
+            pACS->Reg0x994 = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC);           // Reg0x994
+            pACS->Reg0x998 = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC);       // Reg0x998
+            pACS->Reg0x99C = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC);       // Reg0x99c
+            pACS->Reg0x9A0 = ODM_Read1Byte(pDM_Odm, ODM_REG_NHM_TH8_11AC);                   // Reg0x9a0, u1Byte            
+        }
+        else if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+        {
+            pACS->Reg0x890 = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N);             // Reg0x890
+            pACS->Reg0x894 = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N);                  // Reg0x894
+            pACS->Reg0x898 = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N);         // Reg0x898
+            pACS->Reg0x89C = ODM_Read4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N);         // Reg0x89c
+            pACS->Reg0xE28 = ODM_Read1Byte(pDM_Odm, ODM_REG_NHM_TH8_11N);                     // Reg0xe28, u1Byte    
+        }
+    }
+
+    //3 Restore Default Setting
+    else if(setting == RESTORE_DEFAULT_NHM_SETTING)
+    {
+        ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("RESTORE_DEFAULT_NHM_SETTING\n"));
+        
+        if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)     // store Reg0x990, Reg0x994, Reg0x998, Reg0x99C, Reg0x9a0
+        {
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC,          pACS->Reg0x990);
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC,     pACS->Reg0x994);
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, pACS->Reg0x998);
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, pACS->Reg0x99C);
+            ODM_Write1Byte(pDM_Odm, ODM_REG_NHM_TH8_11AC,             pACS->Reg0x9A0);   
+        }
+        else if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+        {
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N,     pACS->Reg0x890);
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N,          pACS->Reg0x894);
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, pACS->Reg0x898);
+            ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, pACS->Reg0x89C);
+            ODM_Write1Byte(pDM_Odm, ODM_REG_NHM_TH8_11N,             pACS->Reg0xE28); 
+        }        
+    }
+
+    //3 ACS Setting
+    else if(setting == ACS_NHM_SETTING)
+    {        
+        ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("ACS_NHM_SETTING\n"));
+        u2Byte  period;
+        period = 0x61a8;
+        pACS->ACS_Step = acs_step;
+            
+        if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+        {   
+            //4 Set NHM period, 0x990[31:16]=0x61a8, Time duration for NHM unit: 4us, 0x61a8=100ms
+            ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC+2, period);
+            //4 Set NHM ignore_cca=1, ignore_txon=1, ccx_en=0
+            ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC,BIT8|BIT9|BIT10, 3);
+            
+            if(pACS->ACS_Step == 0)
+            {
+                //4 Set IGI
+                ODM_SetBBReg(pDM_Odm,0xc50,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x3E);
+                if (get_rf_mimo_mode(priv) != MIMO_1T1R)
+					ODM_SetBBReg(pDM_Odm,0xe50,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x3E);
+                    
+                //4 Set ACS NHM threshold
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0x82786e64);
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffff8c);
+                ODM_Write1Byte(pDM_Odm, ODM_REG_NHM_TH8_11AC, 0xff);
+                ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC+2, 0xffff);
+                
+            }
+            else if(pACS->ACS_Step == 1)
+            {
+                //4 Set IGI
+                ODM_SetBBReg(pDM_Odm,0xc50,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x2A);
+                if (get_rf_mimo_mode(priv) != MIMO_1T1R)
+					ODM_SetBBReg(pDM_Odm,0xe50,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x2A);
+
+                //4 Set ACS NHM threshold
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0x5a50463c);
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffff64);
+                
+            }
+
+        }
+        else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+        {
+            //4 Set NHM period, 0x894[31:16]=0x61a8, Time duration for NHM unit: 4us, 0x61a8=100ms
+            ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, period);
+            //4 Set NHM ignore_cca=1, ignore_txon=1, ccx_en=0
+            ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N,BIT8|BIT9|BIT10, 3);
+            
+            if(pACS->ACS_Step == 0)
+            {
+                //4 Set IGI
+                ODM_SetBBReg(pDM_Odm,0xc50,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x3E);
+                if (get_rf_mimo_mode(priv) != MIMO_1T1R)
+					ODM_SetBBReg(pDM_Odm,0xc58,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x3E);
+            
+                //4 Set ACS NHM threshold
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0x82786e64);
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffff8c);
+                ODM_Write1Byte(pDM_Odm, ODM_REG_NHM_TH8_11N, 0xff);
+                ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N+2, 0xffff);
+                
+            }
+            else if(pACS->ACS_Step == 1)
+            {
+                //4 Set IGI
+                ODM_SetBBReg(pDM_Odm,0xc50,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x2A);
+                if (get_rf_mimo_mode(priv) != MIMO_1T1R)
+					ODM_SetBBReg(pDM_Odm,0xc58,BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6,0x2A);
+            
+                //4 Set ACS NHM threshold
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0x5a50463c);
+                ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffff64);
+
+            }            
+        }
+    }	
+	
+}
+
+VOID
+phydm_GetNHMStatisticsAP(
+    IN  PVOID       pDM_VOID,
+    IN  u4Byte      idx,                // @ 2G, Real channel number = idx+1
+    IN  u4Byte      acs_step
+)
+{
+    PDM_ODM_T	    pDM_Odm = (PDM_ODM_T)pDM_VOID;
+    prtl8192cd_priv     priv    = pDM_Odm->priv;
+    PACS                  pACS    = &pDM_Odm->DM_ACS;
+    u4Byte                value32 = 0;
+    u1Byte                i;
+
+    pACS->ACS_Step = acs_step;
+
+    if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+    {
+        //4 Check if NHM result is ready        
+        for (i=0; i<20; i++) {
+            
+            ODM_delay_ms(1);
+            if ( ODM_GetBBReg(pDM_Odm,rFPGA0_PSDReport,BIT17) )
+                break;
+        }
+        
+        //4 Get NHM Statistics        
+        if ( pACS->ACS_Step==1 ) {
+            
+            value32 = ODM_Read4Byte(pDM_Odm,ODM_REG_NHM_CNT7_TO_CNT4_11N);
+            
+            pACS->NHM_Cnt[idx][9] = (value32 & bMaskByte1) >> 8;
+            pACS->NHM_Cnt[idx][8] = (value32 & bMaskByte0);
+
+            value32 = ODM_Read4Byte(pDM_Odm,ODM_REG_NHM_CNT_11N);    // ODM_REG_NHM_CNT3_TO_CNT0_11N
+
+            pACS->NHM_Cnt[idx][7] = (value32 & bMaskByte3) >> 24;
+            pACS->NHM_Cnt[idx][6] = (value32 & bMaskByte2) >> 16;
+            pACS->NHM_Cnt[idx][5] = (value32 & bMaskByte1) >> 8;
+
+        } else if (pACS->ACS_Step==2) {
+        
+            value32 = ODM_Read4Byte(pDM_Odm,ODM_REG_NHM_CNT_11N);   // ODM_REG_NHM_CNT3_TO_CNT0_11N
+
+            pACS->NHM_Cnt[idx][4] = ODM_Read1Byte(pDM_Odm, ODM_REG_NHM_CNT7_TO_CNT4_11N);            
+            pACS->NHM_Cnt[idx][3] = (value32 & bMaskByte3) >> 24;
+            pACS->NHM_Cnt[idx][2] = (value32 & bMaskByte2) >> 16;
+            pACS->NHM_Cnt[idx][1] = (value32 & bMaskByte1) >> 8;
+            pACS->NHM_Cnt[idx][0] = (value32 & bMaskByte0);
+        }
+    }
+    else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+    {
+        //4 Check if NHM result is ready        
+        for (i=0; i<20; i++) {
+            
+            ODM_delay_ms(1);
+            if (ODM_GetBBReg(pDM_Odm,ODM_REG_NHM_DUR_READY_11AC,BIT17))
+                break;
+        }
+    
+        if ( pACS->ACS_Step==1 ) {
+            
+            value32 = ODM_Read4Byte(pDM_Odm,ODM_REG_NHM_CNT7_TO_CNT4_11AC);
+            
+            pACS->NHM_Cnt[idx][9] = (value32 & bMaskByte1) >> 8;
+            pACS->NHM_Cnt[idx][8] = (value32 & bMaskByte0);
+
+            value32 = ODM_Read4Byte(pDM_Odm,ODM_REG_NHM_CNT_11AC);     // ODM_REG_NHM_CNT3_TO_CNT0_11AC
+
+            pACS->NHM_Cnt[idx][7] = (value32 & bMaskByte3) >> 24;
+            pACS->NHM_Cnt[idx][6] = (value32 & bMaskByte2) >> 16;
+            pACS->NHM_Cnt[idx][5] = (value32 & bMaskByte1) >> 8;
+
+        } else if (pACS->ACS_Step==2) {
+        
+            value32 = ODM_Read4Byte(pDM_Odm,ODM_REG_NHM_CNT_11AC);      // ODM_REG_NHM_CNT3_TO_CNT0_11AC
+
+            pACS->NHM_Cnt[idx][4] = ODM_Read1Byte(pDM_Odm, ODM_REG_NHM_CNT7_TO_CNT4_11AC);            
+            pACS->NHM_Cnt[idx][3] = (value32 & bMaskByte3) >> 24;
+            pACS->NHM_Cnt[idx][2] = (value32 & bMaskByte2) >> 16;
+            pACS->NHM_Cnt[idx][1] = (value32 & bMaskByte1) >> 8;
+            pACS->NHM_Cnt[idx][0] = (value32 & bMaskByte0);
+        }            
+    }
+
+}
+
+
+//#define ACS_DEBUG_INFO //acs debug default off
+/*
+int phydm_AutoChannelSelectAP( 
+    IN   PVOID   pDM_VOID,
+    IN   u4Byte  ACS_Type,                      // 0: RXCount_Type, 1:NHM_Type
+    IN   u4Byte  available_chnl_num        // amount of all channels
+    )
+{
+    PDM_ODM_T               pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS                    pACS    = &pDM_Odm->DM_ACS;
+    prtl8192cd_priv			priv    = pDM_Odm->priv;
+    
+    static u4Byte           score2G[MAX_2G_CHANNEL_NUM], score5G[MAX_5G_CHANNEL_NUM];
+    u4Byte                  score[MAX_BSS_NUM], use_nhm = 0;
+    u4Byte                  minScore=0xffffffff;
+    u4Byte                  tmpScore, tmpIdx=0;
+    u4Byte                  traffic_check = 0;
+    u4Byte                  fa_count_weighting = 1;
+    int                     i, j, idx=0, idx_2G_end=-1, idx_5G_begin=-1, minChan=0;
+	struct bss_desc *pBss=NULL;
+
+#ifdef _DEBUG_RTL8192CD_
+	char tmpbuf[400];
+	int len=0;
+#endif
+
+	memset(score2G, '\0', sizeof(score2G));
+	memset(score5G, '\0', sizeof(score5G));
+
+	for (i=0; i<priv->available_chnl_num; i++) {
+		if (priv->available_chnl[i] <= 14)
+			idx_2G_end = i;
+		else
+			break;
+	}
+
+	for (i=0; i<priv->available_chnl_num; i++) {
+		if (priv->available_chnl[i] > 14) {
+			idx_5G_begin = i;
+			break;
+		}
+	}
+
+// DELETE
+#ifndef CONFIG_RTL_NEW_AUTOCH
+	for (i=0; i<priv->site_survey->count; i++) {
+		pBss = &priv->site_survey->bss[i];
+		for (idx=0; idx<priv->available_chnl_num; idx++) {
+			if (pBss->channel == priv->available_chnl[idx]) {
+				if (pBss->channel <= 14)
+					setChannelScore(idx, score2G, 0, MAX_2G_CHANNEL_NUM-1);
+				else
+					score5G[idx - idx_5G_begin] += 5;
+				break;
+			}
+		}
+	}
+#endif
+
+	if (idx_2G_end >= 0)
+		for (i=0; i<=idx_2G_end; i++)
+			score[i] = score2G[i];
+	if (idx_5G_begin >= 0)
+		for (i=idx_5G_begin; i<priv->available_chnl_num; i++)
+			score[i] = score5G[i - idx_5G_begin];
+		
+#ifdef CONFIG_RTL_NEW_AUTOCH
+	{
+		u4Byte y, ch_begin=0, ch_end= priv->available_chnl_num;
+
+		u4Byte do_ap_check = 1, ap_ratio = 0;
+		
+		if (idx_2G_end >= 0) 
+			ch_end = idx_2G_end+1;
+		if (idx_5G_begin >= 0)  
+			ch_begin = idx_5G_begin;
+
+#ifdef ACS_DEBUG_INFO//for debug
+		printk("\n");
+		for (y=ch_begin; y<ch_end; y++)
+			printk("1. init: chnl[%d] 20M_rx[%d] 40M_rx[%d] fa_cnt[%d] score[%d]\n",
+				priv->available_chnl[y], 
+				priv->chnl_ss_mac_rx_count[y], 
+				priv->chnl_ss_mac_rx_count_40M[y],
+				priv->chnl_ss_fa_count[y],
+				score[y]);
+		printk("\n");
+#endif
+
+#if defined(CONFIG_RTL_88E_SUPPORT) || defined(CONFIG_WLAN_HAL_8192EE)
+        if( pDM_Odm->SupportICType&(ODM_RTL8188E|ODM_RTL8192E)&& priv->pmib->dot11RFEntry.acs_type )
+		{
+			u4Byte tmp_score[MAX_BSS_NUM];
+			memcpy(tmp_score, score, sizeof(score));
+			if (find_clean_channel(priv, ch_begin, ch_end, tmp_score)) {
+				//memcpy(score, tmp_score, sizeof(score));
+#ifdef _DEBUG_RTL8192CD_
+				printk("!! Found clean channel, select minimum FA channel\n");
+#endif
+				goto USE_CLN_CH;
+			}
+#ifdef _DEBUG_RTL8192CD_
+			printk("!! Not found clean channel, use NHM algorithm\n");
+#endif
+			use_nhm = 1;
+USE_CLN_CH:
+			for (y=ch_begin; y<ch_end; y++) {
+				for (i=0; i<=9; i++) {
+					u4Byte val32 = priv->nhm_cnt[y][i];
+					for (j=0; j<i; j++)
+						val32 *= 3;
+					score[y] += val32;
+				}
+
+#ifdef _DEBUG_RTL8192CD_				
+				printk("nhm_cnt_%d: H<-[ %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d]->L, score: %d\n", 
+					y+1, priv->nhm_cnt[y][9], priv->nhm_cnt[y][8], priv->nhm_cnt[y][7], 
+					priv->nhm_cnt[y][6], priv->nhm_cnt[y][5], priv->nhm_cnt[y][4],
+					priv->nhm_cnt[y][3], priv->nhm_cnt[y][2], priv->nhm_cnt[y][1],
+					priv->nhm_cnt[y][0], score[y]);
+#endif
+			}
+
+			if (!use_nhm)
+				memcpy(score, tmp_score, sizeof(score));
+			
+			goto choose_ch;
+		}
+#endif
+
+            // For each channel, weighting behind channels with MAC RX counter
+            //For each channel, weighting the channel with FA counter
+
+		for (y=ch_begin; y<ch_end; y++) {
+			score[y] += 8 * priv->chnl_ss_mac_rx_count[y];
+			if (priv->chnl_ss_mac_rx_count[y] > 30)
+				do_ap_check = 0;
+			if( priv->chnl_ss_mac_rx_count[y] > MAC_RX_COUNT_THRESHOLD )
+				traffic_check = 1;
+			
+#ifdef RTK_5G_SUPPORT
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+#endif
+			{
+				if ((int)(y-4) >= (int)ch_begin)
+					score[y-4] += 2 * priv->chnl_ss_mac_rx_count[y];				
+				if ((int)(y-3) >= (int)ch_begin)
+					score[y-3] += 8 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y-2) >= (int)ch_begin)
+					score[y-2] += 8 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y-1) >= (int)ch_begin)
+					score[y-1] += 10 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+1) < (int)ch_end)
+					score[y+1] += 10 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+2) < (int)ch_end)
+					score[y+2] += 8 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+3) < (int)ch_end)
+					score[y+3] += 8 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+4) < (int)ch_end)
+					score[y+4] += 2 * priv->chnl_ss_mac_rx_count[y];
+			}
+
+			//this is for CH_LOAD caculation
+			if( priv->chnl_ss_cca_count[y] > priv->chnl_ss_fa_count[y])
+				priv->chnl_ss_cca_count[y]-= priv->chnl_ss_fa_count[y];
+			else
+				priv->chnl_ss_cca_count[y] = 0;
+		}
+
+#ifdef ACS_DEBUG_INFO//for debug
+		printk("\n");
+		for (y=ch_begin; y<ch_end; y++)
+			printk("2. after 20M check: chnl[%d] score[%d]\n",priv->available_chnl[y], score[y]);
+		printk("\n");
+#endif	
+
+		for (y=ch_begin; y<ch_end; y++) {
+			if (priv->chnl_ss_mac_rx_count_40M[y]) {
+				score[y] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+				if (priv->chnl_ss_mac_rx_count_40M[y] > 30)
+					do_ap_check = 0;
+				if( priv->chnl_ss_mac_rx_count_40M[y] > MAC_RX_COUNT_THRESHOLD )
+					traffic_check = 1;
+				
+#ifdef RTK_5G_SUPPORT
+				if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+#endif
+				{
+					if ((int)(y-6) >= (int)ch_begin)
+						score[y-6] += 1 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-5) >= (int)ch_begin)
+						score[y-5] += 4 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-4) >= (int)ch_begin)
+						score[y-4] += 4 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-3) >= (int)ch_begin)
+						score[y-3] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-2) >= (int)ch_begin)
+						score[y-2] += (5 * priv->chnl_ss_mac_rx_count_40M[y])/2;
+					if ((int)(y-1) >= (int)ch_begin)
+						score[y-1] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+1) < (int)ch_end)
+						score[y+1] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+2) < (int)ch_end)
+						score[y+2] += (5 * priv->chnl_ss_mac_rx_count_40M[y])/2;
+					if ((int)(y+3) < (int)ch_end)
+						score[y+3] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+4) < (int)ch_end)
+						score[y+4] += 4 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+5) < (int)ch_end)
+						score[y+5] += 4 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+6) < (int)ch_end)
+						score[y+6] += 1 * priv->chnl_ss_mac_rx_count_40M[y];
+				}
+			}
+		}
+
+#ifdef ACS_DEBUG_INFO//for debug
+		printk("\n");
+		for (y=ch_begin; y<ch_end; y++)
+			printk("3. after 40M check: chnl[%d] score[%d]\n",priv->available_chnl[y], score[y]);
+		printk("\n");
+		printk("4. do_ap_check=%d traffic_check=%d\n", do_ap_check, traffic_check);
+		printk("\n");
+#endif
+
+		if( traffic_check == 0)
+			fa_count_weighting = 5;
+		else
+			fa_count_weighting = 1;
+
+		for (y=ch_begin; y<ch_end; y++) {
+			score[y] += fa_count_weighting * priv->chnl_ss_fa_count[y];
+		}
+
+#ifdef ACS_DEBUG_INFO//for debug
+		printk("\n");
+		for (y=ch_begin; y<ch_end; y++)
+			printk("5. after fa check: chnl[%d] score[%d]\n",priv->available_chnl[y], score[y]);
+		printk("\n");
+#endif			
+
+		if (do_ap_check) {
+			for (i=0; i<priv->site_survey->count; i++) {				
+				pBss = &priv->site_survey->bss[i];
+				for (y=ch_begin; y<ch_end; y++) {
+					if (pBss->channel == priv->available_chnl[y]) {
+						if (pBss->channel <= 14) {
+#ifdef ACS_DEBUG_INFO//for debug
+						printk("\n");
+						printk("chnl[%d] has ap rssi=%d bw[0x%02x]\n",
+							pBss->channel, pBss->rssi, pBss->t_stamp[1]);
+						printk("\n");
+#endif
+							if (pBss->rssi > 60)
+								ap_ratio = 4;
+							else if (pBss->rssi > 35)
+								ap_ratio = 2;
+							else
+								ap_ratio = 1;
+							
+							if ((pBss->t_stamp[1] & 0x6) == 0) {
+								score[y] += 50 * ap_ratio;
+								if ((int)(y-4) >= (int)ch_begin)
+									score[y-4] += 10 * ap_ratio;
+								if ((int)(y-3) >= (int)ch_begin)
+									score[y-3] += 20 * ap_ratio;
+								if ((int)(y-2) >= (int)ch_begin)
+									score[y-2] += 30 * ap_ratio;
+								if ((int)(y-1) >= (int)ch_begin)
+									score[y-1] += 40 * ap_ratio;
+								if ((int)(y+1) < (int)ch_end)
+									score[y+1] += 40 * ap_ratio;
+								if ((int)(y+2) < (int)ch_end)
+									score[y+2] += 30 * ap_ratio;
+								if ((int)(y+3) < (int)ch_end)
+									score[y+3] += 20 * ap_ratio;
+								if ((int)(y+4) < (int)ch_end)
+									score[y+4] += 10 * ap_ratio;
+							}	
+							else if ((pBss->t_stamp[1] & 0x4) == 0) {
+								score[y] += 50 * ap_ratio;
+								if ((int)(y-3) >= (int)ch_begin)
+									score[y-3] += 20 * ap_ratio;
+								if ((int)(y-2) >= (int)ch_begin)
+									score[y-2] += 30 * ap_ratio;
+								if ((int)(y-1) >= (int)ch_begin)
+									score[y-1] += 40 * ap_ratio;
+								if ((int)(y+1) < (int)ch_end)
+									score[y+1] += 50 * ap_ratio;
+								if ((int)(y+2) < (int)ch_end)
+									score[y+2] += 50 * ap_ratio;
+								if ((int)(y+3) < (int)ch_end)
+									score[y+3] += 50 * ap_ratio;
+								if ((int)(y+4) < (int)ch_end)
+									score[y+4] += 50 * ap_ratio;
+								if ((int)(y+5) < (int)ch_end)
+									score[y+5] += 40 * ap_ratio;
+								if ((int)(y+6) < (int)ch_end)
+									score[y+6] += 30 * ap_ratio;
+								if ((int)(y+7) < (int)ch_end)
+									score[y+7] += 20 * ap_ratio;	
+							}	
+							else {
+								score[y] += 50 * ap_ratio;
+								if ((int)(y-7) >= (int)ch_begin)
+									score[y-7] += 20 * ap_ratio;
+								if ((int)(y-6) >= (int)ch_begin)
+									score[y-6] += 30 * ap_ratio;
+								if ((int)(y-5) >= (int)ch_begin)
+									score[y-5] += 40 * ap_ratio;
+								if ((int)(y-4) >= (int)ch_begin)
+									score[y-4] += 50 * ap_ratio;
+								if ((int)(y-3) >= (int)ch_begin)
+									score[y-3] += 50 * ap_ratio;
+								if ((int)(y-2) >= (int)ch_begin)
+									score[y-2] += 50 * ap_ratio;
+								if ((int)(y-1) >= (int)ch_begin)
+									score[y-1] += 50 * ap_ratio;
+								if ((int)(y+1) < (int)ch_end)
+									score[y+1] += 40 * ap_ratio;
+								if ((int)(y+2) < (int)ch_end)
+									score[y+2] += 30 * ap_ratio;
+								if ((int)(y+3) < (int)ch_end)
+									score[y+3] += 20 * ap_ratio;
+							}	
+						}	
+						else {
+							if ((pBss->t_stamp[1] & 0x6) == 0) {
+								score[y] += 500;
+							}
+							else if ((pBss->t_stamp[1] & 0x4) == 0) {
+								score[y] += 500;
+								if ((int)(y+1) < (int)ch_end)
+									score[y+1] += 500;
+							}
+							else {	
+								score[y] += 500;
+								if ((int)(y-1) >= (int)ch_begin)
+									score[y-1] += 500;
+							}
+						}
+						break;
+					}
+				}
+			}
+		}
+
+#ifdef ACS_DEBUG_INFO//for debug
+		printk("\n");
+		for (y=ch_begin; y<ch_end; y++)
+			printk("6. after ap check: chnl[%d]:%d\n", priv->available_chnl[y],score[y]);
+		printk("\n");
+#endif		
+
+#ifdef 	SS_CH_LOAD_PROC
+
+		// caculate noise level -- suggested by wilson
+		for (y=ch_begin; y<ch_end; y++)  {
+			int fa_lv=0, cca_lv=0;
+			if (priv->chnl_ss_fa_count[y]>1000) {
+				fa_lv = 100;
+			} else if (priv->chnl_ss_fa_count[y]>500) {
+				fa_lv = 34 * (priv->chnl_ss_fa_count[y]-500) / 500 + 66;
+			} else if (priv->chnl_ss_fa_count[y]>200) {
+				fa_lv = 33 * (priv->chnl_ss_fa_count[y] - 200) / 300 + 33;
+			} else if (priv->chnl_ss_fa_count[y]>100) {
+				fa_lv = 18 * (priv->chnl_ss_fa_count[y] - 100) / 100 + 15;
+			} else {
+				fa_lv = 15 * priv->chnl_ss_fa_count[y] / 100;
+			} 
+			if (priv->chnl_ss_cca_count[y]>400) {
+				cca_lv = 100;
+			} else if (priv->chnl_ss_cca_count[y]>200) {
+				cca_lv = 34 * (priv->chnl_ss_cca_count[y] - 200) / 200 + 66;
+			} else if (priv->chnl_ss_cca_count[y]>80) {
+				cca_lv = 33 * (priv->chnl_ss_cca_count[y] - 80) / 120 + 33;
+			} else if (priv->chnl_ss_cca_count[y]>40) {
+				cca_lv = 18 * (priv->chnl_ss_cca_count[y] - 40) / 40 + 15;
+			} else {
+				cca_lv = 15 * priv->chnl_ss_cca_count[y] / 40;
+			}
+
+			priv->chnl_ss_load[y] = (((fa_lv > cca_lv)? fa_lv : cca_lv)*75+((score[y]>100)?100:score[y])*25)/100;
+
+			DEBUG_INFO("ch:%d f=%d (%d), c=%d (%d), fl=%d, cl=%d, sc=%d, cu=%d\n", 
+					priv->available_chnl[y],
+					priv->chnl_ss_fa_count[y], fa_thd,
+					priv->chnl_ss_cca_count[y], cca_thd,
+					fa_lv, 
+					cca_lv,
+					score[y],					
+					priv->chnl_ss_load[y]);
+			
+		}		
+#endif		
+	}
+#endif
+
+choose_ch:
+
+#ifdef DFS
+	// heavy weighted DFS channel
+	if (idx_5G_begin >= 0){
+		for (i=idx_5G_begin; i<priv->available_chnl_num; i++) {
+			if (!priv->pmib->dot11DFSEntry.disable_DFS && is_DFS_channel(priv->available_chnl[i]) 
+			&& (score[i]!= 0xffffffff)){
+					score[i] += 1600; 
+		}
+	}
+	}
+#endif
+
+
+//prevent Auto Channel selecting wrong channel in 40M mode-----------------
+	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)
+		&& priv->pshare->is_40m_bw) {
+#if 0
+		if (GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset == 1) {
+			//Upper Primary Channel, cannot select the two lowest channels
+			if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11G) {
+				score[0] = 0xffffffff;
+				score[1] = 0xffffffff;
+				score[2] = 0xffffffff;
+				score[3] = 0xffffffff;
+				score[4] = 0xffffffff;
+
+				score[13] = 0xffffffff;
+				score[12] = 0xffffffff;
+				score[11] = 0xffffffff;
+			}
+
+//			if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11A) {
+//				score[idx_5G_begin] = 0xffffffff;
+//				score[idx_5G_begin + 1] = 0xffffffff;
+//			}
+		}
+		else if (GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset == 2) {
+			//Lower Primary Channel, cannot select the two highest channels
+			if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11G) {
+				score[0] = 0xffffffff;
+				score[1] = 0xffffffff;
+				score[2] = 0xffffffff;
+
+				score[13] = 0xffffffff;
+				score[12] = 0xffffffff;
+				score[11] = 0xffffffff;
+				score[10] = 0xffffffff;
+				score[9] = 0xffffffff;
+			}
+
+//			if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11A) {
+//				score[priv->available_chnl_num - 2] = 0xffffffff;
+//				score[priv->available_chnl_num - 1] = 0xffffffff;
+//			}
+		}
+#endif
+		for (i=0; i<=idx_2G_end; ++i)
+			if (priv->available_chnl[i] == 14)
+				score[i] = 0xffffffff;		// mask chan14
+
+#ifdef RTK_5G_SUPPORT
+		if (idx_5G_begin >= 0) {
+			for (i=idx_5G_begin; i<priv->available_chnl_num; i++) {
+				int ch = priv->available_chnl[i];
+				if(priv->available_chnl[i] > 144) 
+					--ch;
+				if((ch%4) || ch==140 || ch == 164 )	//mask ch 140, ch 165, ch 184...
+					score[i] = 0xffffffff;
+			}
+		}
+#endif
+
+		
+	}
+
+	if (priv->pmib->dot11RFEntry.disable_ch1213) {
+		for (i=0; i<=idx_2G_end; ++i) {
+			int ch = priv->available_chnl[i];
+			if ((ch == 12) || (ch == 13))
+				score[i] = 0xffffffff;
+		}
+	}
+
+	if (((priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_GLOBAL) ||
+			(priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_WORLD_WIDE)) &&
+		 (idx_2G_end >= 11) && (idx_2G_end < 14)) {
+		score[13] = 0xffffffff;	// mask chan14
+		score[12] = 0xffffffff; // mask chan13
+		score[11] = 0xffffffff; // mask chan12
+	}
+	
+//------------------------------------------------------------------
+
+#ifdef _DEBUG_RTL8192CD_
+	for (i=0; i<priv->available_chnl_num; i++) {
+		len += sprintf(tmpbuf+len, "ch%d:%u ", priv->available_chnl[i], score[i]);		
+	}
+	strcat(tmpbuf, "\n");
+	panic_printk("%s", tmpbuf);
+
+#endif
+
+	if ( (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
+		&& (priv->pmib->dot11nConfigEntry.dot11nUse40M == HT_CHANNEL_WIDTH_80)) 
+	{
+		for (i=0; i<priv->available_chnl_num; i++) {
+			if (is80MChannel(priv->available_chnl, priv->available_chnl_num, priv->available_chnl[i])) {
+				tmpScore = 0;
+				for (j=0; j<4; j++) {
+					if ((tmpScore != 0xffffffff) && (score[i+j] != 0xffffffff))
+						tmpScore += score[i+j];
+					else
+						tmpScore = 0xffffffff;
+				}
+				tmpScore = tmpScore / 4;
+				if (minScore > tmpScore) {
+					minScore = tmpScore;
+
+					tmpScore = 0xffffffff;
+					for (j=0; j<4; j++) {
+						if (score[i+j] < tmpScore) {
+							tmpScore = score[i+j];
+							tmpIdx = i+j;
+						}
+					}
+
+					idx = tmpIdx;
+				}
+				i += 3;
+			}
+		}
+		if (minScore == 0xffffffff) {
+			// there is no 80M channels
+			priv->pshare->is_40m_bw = HT_CHANNEL_WIDTH_20;
+			for (i=0; i<priv->available_chnl_num; i++) {
+				if (score[i] < minScore) {
+					minScore = score[i];
+					idx = i;
+				}
+			}
+		}
+	}
+	else if( (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
+			&& (priv->pmib->dot11nConfigEntry.dot11nUse40M == HT_CHANNEL_WIDTH_20_40))
+ 	{
+		for (i=0; i<priv->available_chnl_num; i++) {
+			if(is40MChannel(priv->available_chnl,priv->available_chnl_num,priv->available_chnl[i])) {
+				tmpScore = 0;
+				for(j=0;j<2;j++) {
+					if ((tmpScore != 0xffffffff) && (score[i+j] != 0xffffffff))
+						tmpScore += score[i+j];
+					else
+						tmpScore = 0xffffffff;
+				}
+				tmpScore = tmpScore / 2;
+				if(minScore > tmpScore) {
+					minScore = tmpScore;
+
+					tmpScore = 0xffffffff;
+					for (j=0; j<2; j++) {
+						if (score[i+j] < tmpScore) {
+							tmpScore = score[i+j];
+							tmpIdx = i+j;
+						}
+					}
+
+					idx = tmpIdx;
+				}
+				i += 1;
+			}
+		}
+		if (minScore == 0xffffffff) {
+			// there is no 40M channels
+			priv->pshare->is_40m_bw = HT_CHANNEL_WIDTH_20;
+			for (i=0; i<priv->available_chnl_num; i++) {
+				if (score[i] < minScore) {
+					minScore = score[i];
+					idx = i;
+				}
+			}
+		}
+	}
+	else if( (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+			&& (priv->pmib->dot11nConfigEntry.dot11nUse40M == HT_CHANNEL_WIDTH_20_40)
+			&& (priv->available_chnl_num >= 8) )
+	{
+		u4Byte groupScore[14];
+
+		memset(groupScore, 0xff , sizeof(groupScore));
+		for (i=0; i<priv->available_chnl_num-4; i++) {
+			if (score[i] != 0xffffffff && score[i+4] != 0xffffffff) {
+				groupScore[i] = score[i] + score[i+4];
+				DEBUG_INFO("groupScore, ch %d,%d: %d\n", i+1, i+5, groupScore[i]);
+				if (groupScore[i] < minScore) {
+#ifdef AUTOCH_SS_SPEEDUP
+					if(priv->pmib->miscEntry.autoch_1611_enable)
+					{
+						if(priv->available_chnl[i]==1 || priv->available_chnl[i]==6 || priv->available_chnl[i]==11)
+						{
+							minScore = groupScore[i];
+							idx = i;
+						}
+					}
+					else
+#endif
+					{					
+						minScore = groupScore[i];
+						idx = i;
+					}
+				}
+			}
+		}
+
+		if (score[idx] < score[idx+4]) {
+			GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
+			priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;			
+		} else {
+			idx = idx + 4;
+			GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
+			priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;			
+		}
+	}
+	else 
+	{
+		for (i=0; i<priv->available_chnl_num; i++) {
+			if (score[i] < minScore) {
+#ifdef AUTOCH_SS_SPEEDUP
+				if(priv->pmib->miscEntry.autoch_1611_enable)
+				{
+					if(priv->available_chnl[i]==1 || priv->available_chnl[i]==6 || priv->available_chnl[i]==11)
+					{
+						minScore = score[i];
+						idx = i;
+					}
+				}
+				else
+#endif
+				{				
+					minScore = score[i];
+					idx = i;
+				}
+			}
+		}
+	}
+
+	if (IS_A_CUT_8881A(priv) &&
+		(priv->pmib->dot11nConfigEntry.dot11nUse40M == HT_CHANNEL_WIDTH_80)) {
+		if ((priv->available_chnl[idx] == 36) ||
+			(priv->available_chnl[idx] == 52) ||
+			(priv->available_chnl[idx] == 100) ||
+			(priv->available_chnl[idx] == 116) ||
+			(priv->available_chnl[idx] == 132) ||
+			(priv->available_chnl[idx] == 149) ||
+			(priv->available_chnl[idx] == 165))
+			idx++;
+		else if ((priv->available_chnl[idx] == 48) ||
+			(priv->available_chnl[idx] == 64) ||
+			(priv->available_chnl[idx] == 112) ||
+			(priv->available_chnl[idx] == 128) ||
+			(priv->available_chnl[idx] == 144) ||
+			(priv->available_chnl[idx] == 161) ||
+			(priv->available_chnl[idx] == 177))
+			idx--;
+	}
+
+	minChan = priv->available_chnl[idx];
+
+	// skip channel 14 if don't support ofdm
+	if ((priv->pmib->dot11RFEntry.disable_ch14_ofdm) &&
+			(minChan == 14)) {
+		score[idx] = 0xffffffff;
+		
+		minScore = 0xffffffff;
+		for (i=0; i<priv->available_chnl_num; i++) {
+			if (score[i] < minScore) {
+				minScore = score[i];
+				idx = i;
+			}
+		}
+		minChan = priv->available_chnl[idx];
+	}
+
+#if 0
+	//Check if selected channel available for 80M/40M BW or NOT ?
+	if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
+	{
+		if(priv->pmib->dot11nConfigEntry.dot11nUse40M == HT_CHANNEL_WIDTH_80)
+		{
+			if(!is80MChannel(priv->available_chnl,priv->available_chnl_num,minChan))
+			{
+				//printk("BW=80M, selected channel = %d is unavaliable! reduce to 40M\n", minChan);
+				//priv->pmib->dot11nConfigEntry.dot11nUse40M = HT_CHANNEL_WIDTH_20_40;
+				priv->pshare->is_40m_bw = HT_CHANNEL_WIDTH_20_40;
+			}
+		}
+			
+		if(priv->pmib->dot11nConfigEntry.dot11nUse40M == HT_CHANNEL_WIDTH_20_40)
+		{
+			if(!is40MChannel(priv->available_chnl,priv->available_chnl_num,minChan))
+			{
+				//printk("BW=40M, selected channel = %d is unavaliable! reduce to 20M\n", minChan);
+				//priv->pmib->dot11nConfigEntry.dot11nUse40M = HT_CHANNEL_WIDTH_20;
+				priv->pshare->is_40m_bw = HT_CHANNEL_WIDTH_20;
+			}
+		}
+	}
+#endif
+
+#ifdef CONFIG_RTL_NEW_AUTOCH
+	RTL_W32(RXERR_RPT, RXERR_RPT_RST);
+#endif
+
+// auto adjust contro-sideband
+	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)
+			&& (priv->pshare->is_40m_bw ==1 || priv->pshare->is_40m_bw ==2)) {
+
+#ifdef RTK_5G_SUPPORT
+		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+			if( (minChan>144) ? ((minChan-1)%8) : (minChan%8)) {
+				GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
+				priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;
+			} else {
+				GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
+				priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;
+			}
+
+		} else
+#endif		
+		{
+#if 0
+#ifdef CONFIG_RTL_NEW_AUTOCH
+			unsigned int ch_max;
+
+			if (priv->available_chnl[idx_2G_end] >= 13)
+				ch_max = 13;
+			else
+				ch_max = priv->available_chnl[idx_2G_end];
+
+			if ((minChan >= 5) && (minChan <= (ch_max-5))) {
+				if (score[minChan+4] > score[minChan-4]) { // what if some channels were cancelled?
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;
+				} else {
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;
+				}
+			} else
+#endif
+			{
+				if (minChan < 5) {
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;
+				}
+				else if (minChan > 7) {
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;
+				}
+			}
+#endif
+		}
+	}
+//-----------------------
+
+#if defined(__ECOS) && defined(CONFIG_SDIO_HCI)
+	panic_printk("Auto channel choose ch:%d\n", minChan);
+#else
+#ifdef _DEBUG_RTL8192CD_
+	panic_printk("Auto channel choose ch:%d\n", minChan);
+#endif
+#endif
+#ifdef ACS_DEBUG_INFO//for debug
+	printk("7. minChan:%d 2nd_offset:%d\n", minChan, priv->pshare->offset_2nd_chan);
+#endif
+
+	return minChan;
+}
+*/
+
+#endif
+
+VOID
+phydm_CLMInit(
+	IN		PVOID			pDM_VOID,
+	IN		u2Byte			sampleNum			/*unit : 4us*/
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;		
+
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_TIME_PERIOD_11AC, bMaskLWord, sampleNum);	/*4us sample 1 time*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_11AC, BIT8, 0x1);							/*Enable CCX for CLM*/
+	} else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_TIME_PERIOD_11N, bMaskLWord, sampleNum);	/*4us sample 1 time*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_11N, BIT8, 0x1);								/*Enable CCX for CLM*/	
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[%s] : CLM sampleNum = %d\n", __func__, sampleNum));
+		
+}
+
+VOID
+phydm_CLMtrigger(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_11AC, BIT0, 0x0);	/*Trigger CLM*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_11AC, BIT0, 0x1);
+	} else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_11N, BIT0, 0x0);	/*Trigger CLM*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CLM_11N, BIT0, 0x1);
+	}
+}
+
+BOOLEAN
+phydm_checkCLMready(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			value32 = 0;
+	BOOLEAN			ret = FALSE;
+	
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_CLM_RESULT_11AC, bMaskDWord);				/*make sure CLM calc is ready*/
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_CLM_READY_11N, bMaskDWord);				/*make sure CLM calc is ready*/
+
+	if (value32 & BIT16)
+		ret = TRUE;
+	else
+		ret = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[%s] : CLM ready = %d\n", __func__, ret));
+
+	return ret;
+}
+
+u2Byte
+phydm_getCLMresult(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			value32 = 0;
+	u2Byte			results = 0;
+	
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_CLM_RESULT_11AC, bMaskDWord);				/*read CLM calc result*/
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_CLM_RESULT_11N, bMaskDWord);				/*read CLM calc result*/
+
+	results = (u2Byte)(value32 & bMaskLWord);
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[%s] : CLM result = %d\n", __func__, results));
+	
+	return results;
+/*results are number of CCA times in sampleNum*/
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.h
new file mode 100644
index 000000000..d7eabda84
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_acs.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMACS_H__
+#define    __PHYDMACS_H__
+
+#define ACS_VERSION	"1.0"
+#define CLM_VERSION "1.0"
+
+#define ODM_MAX_CHANNEL_2G			14
+#define ODM_MAX_CHANNEL_5G			24
+
+// For phydm_AutoChannelSelectSettingAP()
+#define STORE_DEFAULT_NHM_SETTING               0
+#define RESTORE_DEFAULT_NHM_SETTING             1
+#define ACS_NHM_SETTING                         2
+
+typedef struct _ACS_
+{
+	BOOLEAN		bForceACSResult;
+	u1Byte		CleanChannel_2G;
+	u1Byte		CleanChannel_5G;
+	u2Byte		Channel_Info_2G[2][ODM_MAX_CHANNEL_2G];		//Channel_Info[1]: Channel Score, Channel_Info[2]:Channel_Scan_Times
+	u2Byte		Channel_Info_5G[2][ODM_MAX_CHANNEL_5G];	
+
+#if ( DM_ODM_SUPPORT_TYPE & ODM_AP )    
+    u1Byte              ACS_Step;
+    // NHM Count 0-11
+    u1Byte              NHM_Cnt[14][11];
+
+    // AC-Series, for storing previous setting
+    u4Byte              Reg0x990; 
+    u4Byte              Reg0x994;
+    u4Byte              Reg0x998;
+    u4Byte              Reg0x99C;
+    u1Byte              Reg0x9A0;   // u1Byte
+
+    // N-Series, for storing previous setting
+    u4Byte              Reg0x890; 
+    u4Byte              Reg0x894;
+    u4Byte              Reg0x898;
+    u4Byte              Reg0x89C;
+    u1Byte              Reg0xE28;   // u1Byte
+#endif
+
+}ACS, *PACS;
+
+
+VOID
+odm_AutoChannelSelectInit(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+odm_AutoChannelSelectReset(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+odm_AutoChannelSelect(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Channel
+);
+
+u1Byte
+ODM_GetAutoChannelSelectResult(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Band
+);
+
+#if ( DM_ODM_SUPPORT_TYPE & ODM_AP )
+
+VOID
+phydm_AutoChannelSelectSettingAP(
+    IN  PVOID   pDM_VOID,
+    IN  u4Byte  Setting,             // 0: STORE_DEFAULT_NHM_SETTING; 1: RESTORE_DEFAULT_NHM_SETTING, 2: ACS_NHM_SETTING
+    IN  u4Byte  acs_step        
+);
+
+VOID
+phydm_GetNHMStatisticsAP(
+    IN  PVOID       pDM_VOID,
+    IN  u4Byte      idx,                // @ 2G, Real channel number = idx+1
+    IN  u4Byte      acs_step
+);
+
+#endif  //#if ( DM_ODM_SUPPORT_TYPE & ODM_AP )
+
+
+VOID
+phydm_CLMInit(
+	IN		PVOID			pDM_VOID,
+	IN		u2Byte			sampleNum
+);
+
+VOID
+phydm_CLMtrigger(
+	IN		PVOID			pDM_VOID
+);
+
+BOOLEAN
+phydm_checkCLMready(
+	IN		PVOID			pDM_VOID
+);
+
+u2Byte
+phydm_getCLMresult(
+	IN		PVOID			pDM_VOID
+);
+
+
+#endif  //#ifndef	__PHYDMACS_H__
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.c
new file mode 100644
index 000000000..ba0afd141
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.c
@@ -0,0 +1,940 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if WPP_SOFTWARE_TRACE
+#include "PhyDM_Adaptivity.tmh"
+#endif
+#endif
+
+
+VOID
+Phydm_CheckAdaptivity(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	
+	if (pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY) {
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if (pDM_Odm->APTotalNum > Adaptivity->APNumTH) {
+			pDM_Odm->Adaptivity_enable = FALSE;
+			pDM_Odm->adaptivity_flag = FALSE;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("AP total num > %d!!, disable adaptivity\n", Adaptivity->APNumTH));
+		} else
+#endif
+		{
+			if (Adaptivity->DynamicLinkAdaptivity == TRUE) {
+				if (pDM_Odm->bLinked && Adaptivity->bCheck == FALSE) {
+					Phydm_NHMCounterStatistics(pDM_Odm);
+					Phydm_CheckEnvironment(pDM_Odm);
+				} else if (!pDM_Odm->bLinked)
+					Adaptivity->bCheck = FALSE;
+			} else {
+				pDM_Odm->Adaptivity_enable = TRUE;
+
+				if (pDM_Odm->SupportICType & (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA))
+					pDM_Odm->adaptivity_flag = FALSE;
+				else
+					pDM_Odm->adaptivity_flag = TRUE;
+			}
+		}
+	} else {
+		pDM_Odm->Adaptivity_enable = FALSE;
+		pDM_Odm->adaptivity_flag = FALSE;
+	}
+
+	
+
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+BOOLEAN
+Phydm_CheckChannelPlan(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	
+	if (pMgntInfo->RegEnableAdaptivity == 2) {
+		if (pDM_Odm->Carrier_Sense_enable == FALSE) {		/*check domain Code for Adaptivity or CarrierSense*/
+			if ((*pDM_Odm->pBandType == ODM_BAND_5G) &&
+			    !(pDM_Odm->odm_Regulation5G == REGULATION_ETSI || pDM_Odm->odm_Regulation5G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity skip 5G domain code : %d\n", pDM_Odm->odm_Regulation5G));
+				pDM_Odm->Adaptivity_enable = FALSE;
+				pDM_Odm->adaptivity_flag = FALSE;
+				return TRUE;
+			} else if ((*pDM_Odm->pBandType == ODM_BAND_2_4G) &&
+				   !(pDM_Odm->odm_Regulation2_4G == REGULATION_ETSI || pDM_Odm->odm_Regulation2_4G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity skip 2.4G domain code : %d\n", pDM_Odm->odm_Regulation2_4G));
+				pDM_Odm->Adaptivity_enable = FALSE;
+				pDM_Odm->adaptivity_flag = FALSE;
+				return TRUE;
+
+			} else if ((*pDM_Odm->pBandType != ODM_BAND_2_4G) && (*pDM_Odm->pBandType != ODM_BAND_5G)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity neither 2G nor 5G band, return\n"));
+				pDM_Odm->Adaptivity_enable = FALSE;
+				pDM_Odm->adaptivity_flag = FALSE;
+				return TRUE;
+			}
+		} else {
+			if ((*pDM_Odm->pBandType == ODM_BAND_5G) &&
+			    !(pDM_Odm->odm_Regulation5G == REGULATION_MKK || pDM_Odm->odm_Regulation5G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense skip 5G domain code : %d\n", pDM_Odm->odm_Regulation5G));
+				pDM_Odm->Adaptivity_enable = FALSE;
+				pDM_Odm->adaptivity_flag = FALSE;
+				return TRUE;
+			}
+
+			else if ((*pDM_Odm->pBandType == ODM_BAND_2_4G) &&
+				   !(pDM_Odm->odm_Regulation2_4G == REGULATION_MKK  || pDM_Odm->odm_Regulation2_4G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense skip 2.4G domain code : %d\n", pDM_Odm->odm_Regulation2_4G));
+				pDM_Odm->Adaptivity_enable = FALSE;
+				pDM_Odm->adaptivity_flag = FALSE;
+				return TRUE;
+
+			} else if ((*pDM_Odm->pBandType != ODM_BAND_2_4G) && (*pDM_Odm->pBandType != ODM_BAND_5G)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense neither 2G nor 5G band, return\n"));
+				pDM_Odm->Adaptivity_enable = FALSE;
+				pDM_Odm->adaptivity_flag = FALSE;
+				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+
+}
+#endif
+
+VOID
+Phydm_NHMCounterStatisticsInit(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		/*PHY parameters initialize for n series*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N + 2, 0xC350);			/*0x894[31:16]=0x0xC350	Time duration for NHM unit: us, 0xc350=200ms*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N + 2, 0xffff);		/*0x890[31:16]=0xffff		th_9, th_10*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff50);		/*0x898=0xffffff52			th_3, th_2, th_1, th_0*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);		/*0x89c=0xffffffff			th_7, th_6, th_5, th_4*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);		/*0xe28[7:0]=0xff			th_8*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10 | BIT9 | BIT8, 0x1);	/*0x890[10:8]=1			ignoreCCA ignore PHYTXON enable CCX*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 0x1);			/*0xc0c[7]=1				max power among all RX ants*/
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		/*PHY parameters initialize for ac series*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC + 2, 0xC350);			/*0x990[31:16]=0xC350	Time duration for NHM unit: us, 0xc350=200ms*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC + 2, 0xffff);		/*0x994[31:16]=0xffff		th_9, th_10*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff50);	/*0x998=0xffffff52			th_3, th_2, th_1, th_0*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffffff);	/*0x99c=0xffffffff			th_7, th_6, th_5, th_4*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH8_11AC, bMaskByte0, 0xff);		/*0x9a0[7:0]=0xff			th_8*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8 | BIT9 | BIT10, 0x1); /*0x994[10:8]=1			ignoreCCA ignore PHYTXON	enable CCX*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_9E8_11AC, BIT0, 0x1);				/*0x9e8[7]=1				max power among all RX ants*/
+
+	}
+#endif
+}
+
+VOID
+Phydm_NHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	/*Get NHM report*/
+	Phydm_GetNHMCounterStatistics(pDM_Odm);
+
+	/*Reset NHM counter*/
+	Phydm_NHMCounterStatisticsReset(pDM_Odm);
+}
+
+VOID
+Phydm_GetNHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte		value32 = 0;
+#if (RTL8195A_SUPPORT == 0)
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11AC, bMaskDWord);
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+#endif
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11N, bMaskDWord);
+
+	pDM_Odm->NHM_cnt_0 = (u1Byte)(value32 & bMaskByte0);
+	pDM_Odm->NHM_cnt_1 = (u1Byte)((value32 & bMaskByte1) >> 8);
+
+}
+
+VOID
+Phydm_NHMCounterStatisticsReset(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 0);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 1);
+	}
+
+#endif
+
+}
+
+VOID
+Phydm_SetEDCCAThreshold(
+	IN	PVOID	pDM_VOID,
+	IN	s1Byte	H2L,
+	IN	s1Byte	L2H
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskByte2|bMaskByte0, (u4Byte)((u1Byte)L2H|(u1Byte)H2L<<16));
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, bMaskLWord, (u2Byte)((u1Byte)L2H|(u1Byte)H2L<<8));
+#endif
+
+}
+
+VOID
+Phydm_SetLNA(
+	IN	PVOID				pDM_VOID,
+	IN	PhyDM_set_LNA	type
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (pDM_Odm->SupportICType & (ODM_RTL8188E | ODM_RTL8192E)) {
+		if (type == PhyDM_disable_LNA) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x0000f);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0x37f82);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			if (pDM_Odm->RFType > ODM_1T1R) {
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x1);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x30, 0xfffff, 0x18000);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x31, 0xfffff, 0x0000f);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x32, 0xfffff, 0x37f82);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x0);
+			}
+		} else if (type == PhyDM_enable_LNA) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x0000f);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0x77f82);	/*back to normal*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			if (pDM_Odm->RFType > ODM_1T1R) {
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x1);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x30, 0xfffff, 0x18000);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x31, 0xfffff, 0x0000f);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x32, 0xfffff, 0x77f82);
+				ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x0);
+			}
+		}
+	} else if (pDM_Odm->SupportICType & ODM_RTL8723B) {
+		if (type == PhyDM_disable_LNA) {
+			/*S0*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x0001f);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0xe6137);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			/*S1*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x00020, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, 0xfffff, 0x3008d);	/*select Rx mode and disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x00020, 0x0);
+		} else if (type == PhyDM_enable_LNA) {
+			/*S0*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x0001f);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0xe6177);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			/*S1*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x00020, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, 0xfffff, 0x300bd);	/*select Rx mode and disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x00020, 0x0);
+		}
+	
+	} else if (pDM_Odm->SupportICType & ODM_RTL8812) {
+		if (type == PhyDM_disable_LNA) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x3f7ff);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0xc22bf);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+				if (pDM_Odm->RFType > ODM_1T1R) {
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x1);
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x31, 0xfffff, 0x3f7ff);
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x32, 0xfffff, 0xc22bf);	/*disable LNA*/
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x0);
+				}
+		} else if (type == PhyDM_enable_LNA) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x3f7ff);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0xc26bf);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+				if (pDM_Odm->RFType > ODM_1T1R) {
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x1);
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x31, 0xfffff, 0x3f7ff);
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x32, 0xfffff, 0xc26bf);	/*disable LNA*/
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xef, 0x80000, 0x0);
+				}
+		}
+	} else if (pDM_Odm->SupportICType & (ODM_RTL8821 | ODM_RTL8881A)) {
+		if (type == PhyDM_disable_LNA) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x0002f);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0xfb09b);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+		} else if (type == PhyDM_enable_LNA) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x31, 0xfffff, 0x0002f);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x32, 0xfffff, 0xfb0bb);	/*disable LNA*/
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);	
+		}
+	}
+}
+
+
+
+VOID
+Phydm_SetTRxMux(
+	IN	PVOID				pDM_VOID,
+	IN	PhyDM_Trx_MUX_Type	txMode,
+	IN	PhyDM_Trx_MUX_Type	rxMode
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N, BIT3 | BIT2 | BIT1, txMode);			/*set TXmod to standby mode to remove outside noise affect*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N, BIT22 | BIT21 | BIT20, rxMode);		/*set RXmod to standby mode to remove outside noise affect*/
+		if (pDM_Odm->RFType > ODM_1T1R) {
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N_B, BIT3 | BIT2 | BIT1, txMode);		/*set TXmod to standby mode to remove outside noise affect*/
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N_B, BIT22 | BIT21 | BIT20, rxMode);	/*set RXmod to standby mode to remove outside noise affect*/
+		}
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC, BIT11 | BIT10 | BIT9 | BIT8, txMode);				/*set TXmod to standby mode to remove outside noise affect*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC, BIT7 | BIT6 | BIT5 | BIT4, rxMode);				/*set RXmod to standby mode to remove outside noise affect*/
+		if (pDM_Odm->RFType > ODM_1T1R) {
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC_B, BIT11 | BIT10 | BIT9 | BIT8, txMode);		/*set TXmod to standby mode to remove outside noise affect*/
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC_B, BIT7 | BIT6 | BIT5 | BIT4, rxMode);			/*set RXmod to standby mode to remove outside noise affect*/
+		}
+	}
+#endif
+
+}
+
+VOID
+Phydm_MACEDCCAState(
+	IN	PVOID					pDM_VOID,
+	IN	PhyDM_MACEDCCA_Type		State
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (State == PhyDM_IGNORE_EDCCA) {
+		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	/*ignore EDCCA	reg520[15]=1*/
+		ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);			/*reg524[11]=0*/
+	} else {	/*don't set MAC ignore EDCCA signal*/
+		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	/*don't ignore EDCCA	 reg520[15]=0*/
+		ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);			/*reg524[11]=1	*/
+	}
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("EDCCA enable State = %d\n", State));
+
+}
+
+BOOLEAN
+Phydm_CalNHMcnt(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte			Base = 0;
+
+	Base = pDM_Odm->NHM_cnt_0 + pDM_Odm->NHM_cnt_1;
+
+	if (Base != 0) {
+		pDM_Odm->NHM_cnt_0 = ((pDM_Odm->NHM_cnt_0) << 8) / Base;
+		pDM_Odm->NHM_cnt_1 = ((pDM_Odm->NHM_cnt_1) << 8) / Base;
+	}
+	if ((pDM_Odm->NHM_cnt_0 - pDM_Odm->NHM_cnt_1) >= 100)
+		return TRUE;			/*clean environment*/
+	else
+		return FALSE;		/*noisy environment*/
+
+}
+
+
+VOID
+Phydm_CheckEnvironment(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	BOOLEAN 	isCleanEnvironment = FALSE;
+
+	if (Adaptivity->bFirstLink == TRUE) {
+		if (pDM_Odm->SupportICType & (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA))
+			pDM_Odm->adaptivity_flag = FALSE;
+		else
+			pDM_Odm->adaptivity_flag = TRUE;
+
+		Adaptivity->bFirstLink = FALSE;
+		return;
+	} else {
+		if (Adaptivity->NHMWait < 3) {		/*Start enter NHM after 4 NHMWait*/
+			Adaptivity->NHMWait++;
+			Phydm_NHMCounterStatistics(pDM_Odm);
+			return;
+		} else {
+			Phydm_NHMCounterStatistics(pDM_Odm);
+			isCleanEnvironment = Phydm_CalNHMcnt(pDM_Odm);
+			if (isCleanEnvironment == TRUE) {
+				pDM_Odm->TH_L2H_ini = Adaptivity->TH_L2H_ini_backup;			/*adaptivity mode*/
+				pDM_Odm->TH_EDCCA_HL_diff = Adaptivity->TH_EDCCA_HL_diff_backup;
+
+				pDM_Odm->Adaptivity_enable = TRUE;
+
+				if (pDM_Odm->SupportICType & (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA))
+					pDM_Odm->adaptivity_flag = FALSE;
+				else
+					pDM_Odm->adaptivity_flag = TRUE;
+			} else {
+				pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_mode2;			/*mode2*/
+				pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_mode2;
+
+				pDM_Odm->adaptivity_flag = FALSE;
+				pDM_Odm->Adaptivity_enable = FALSE;
+			}
+			Adaptivity->NHMWait = 0;
+			Adaptivity->bFirstLink = TRUE;
+			Adaptivity->bCheck = TRUE;
+		}
+
+	}
+
+
+}
+
+VOID
+Phydm_SearchPwdBLowerBound(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	u4Byte			value32 = 0;
+	u1Byte			cnt, IGI = 0x45;		/*IGI = 0x50 for cal EDCCA lower bound*/
+	u1Byte			txEdcca1 = 0, txEdcca0 = 0;
+	BOOLEAN			bAdjust = TRUE;
+	s1Byte 			TH_L2H_dmc, TH_H2L_dmc, IGI_target = 0x32;
+	s1Byte 			Diff;
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8723B | ODM_RTL8188E | ODM_RTL8192E | ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A))
+		Phydm_SetLNA(pDM_Odm, PhyDM_disable_LNA);
+	else {
+		Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+		odm_PauseDIG(pDM_Odm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_0, 0x7e);
+	}
+
+	Diff = IGI_target - (s1Byte)IGI;
+	TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+	if (TH_L2H_dmc > 10)
+		TH_L2H_dmc = 10;
+	TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+	Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+	ODM_delay_ms(5);
+
+	while (bAdjust) {
+		for (cnt = 0; cnt < 20; cnt++) {
+			if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+				value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11N, bMaskDWord);
+#if (RTL8195A_SUPPORT == 0)
+			else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+				value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC, bMaskDWord);
+#endif
+			if (value32 & BIT30 && (pDM_Odm->SupportICType & (ODM_RTL8723A | ODM_RTL8723B | ODM_RTL8188E)))
+				txEdcca1 = txEdcca1 + 1;
+			else if (value32 & BIT29)
+				txEdcca1 = txEdcca1 + 1;
+			else
+				txEdcca0 = txEdcca0 + 1;
+		}
+
+		if (txEdcca1 > 1) {
+			IGI = IGI - 1;
+			TH_L2H_dmc = TH_L2H_dmc + 1;
+			if (TH_L2H_dmc > 10)
+				TH_L2H_dmc = 10;
+			TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+			Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+			if (TH_L2H_dmc == 10) {
+				bAdjust = FALSE;
+				Adaptivity->H2L_lb = TH_H2L_dmc;
+				Adaptivity->L2H_lb = TH_L2H_dmc;
+				pDM_Odm->Adaptivity_IGI_upper = IGI;
+			}
+
+			txEdcca1 = 0;
+			txEdcca0 = 0;
+
+		} else {
+			bAdjust = FALSE;
+			Adaptivity->H2L_lb = TH_H2L_dmc;
+			Adaptivity->L2H_lb = TH_L2H_dmc;
+			pDM_Odm->Adaptivity_IGI_upper = IGI;
+			txEdcca1 = 0;
+			txEdcca0 = 0;
+		}
+	}
+
+	pDM_Odm->Adaptivity_IGI_upper = pDM_Odm->Adaptivity_IGI_upper - pDM_Odm->DCbackoff;
+	Adaptivity->H2L_lb = Adaptivity->H2L_lb + pDM_Odm->DCbackoff;
+	Adaptivity->L2H_lb = Adaptivity->L2H_lb + pDM_Odm->DCbackoff;
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8723B | ODM_RTL8188E | ODM_RTL8192E | ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A))
+		Phydm_SetLNA(pDM_Odm, PhyDM_enable_LNA);
+	else {
+		Phydm_SetTRxMux(pDM_Odm, PhyDM_TX_MODE, PhyDM_RX_MODE);
+		odm_PauseDIG(pDM_Odm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_0, NONE);
+	}
+	
+	Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);				/*resume to no link state*/
+}
+
+VOID
+Phydm_AdaptivityInit(
+	IN 	PVOID	 	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	s1Byte	IGItarget = 0x32;
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	pDM_Odm->Carrier_Sense_enable = (BOOLEAN)pMgntInfo->RegEnableCarrierSense;
+	pDM_Odm->DCbackoff = (u1Byte)pMgntInfo->RegDCbackoff;
+	Adaptivity->DynamicLinkAdaptivity = (BOOLEAN)pMgntInfo->RegDmLinkAdaptivity;
+	Adaptivity->APNumTH = (u1Byte)pMgntInfo->RegAPNumTH;
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pDM_Odm->Carrier_Sense_enable = (pDM_Odm->Adapter->registrypriv.adaptivity_mode != 0) ? TRUE : FALSE;
+	pDM_Odm->DCbackoff = pDM_Odm->Adapter->registrypriv.adaptivity_dc_backoff;
+	Adaptivity->DynamicLinkAdaptivity = (pDM_Odm->Adapter->registrypriv.adaptivity_dml != 0) ? TRUE : FALSE;
+#endif
+
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+
+	if (pDM_Odm->Carrier_Sense_enable == FALSE) {
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if (pMgntInfo->RegL2HForAdaptivity != 0)
+			pDM_Odm->TH_L2H_ini = pMgntInfo->RegL2HForAdaptivity;
+		else
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+		if (pDM_Odm->Adapter->registrypriv.adaptivity_th_l2h_ini != 0)
+			pDM_Odm->TH_L2H_ini = pDM_Odm->Adapter->registrypriv.adaptivity_th_l2h_ini;
+		else
+#endif
+			pDM_Odm->TH_L2H_ini = 0xf5;
+	} else
+			pDM_Odm->TH_L2H_ini = 0xa;
+
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if (pMgntInfo->RegHLDiffForAdaptivity != 0)
+		pDM_Odm->TH_EDCCA_HL_diff = pMgntInfo->RegHLDiffForAdaptivity;
+	else
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if (pDM_Odm->Adapter->registrypriv.adaptivity_th_edcca_hl_diff != 0)
+		pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->Adapter->registrypriv.adaptivity_th_edcca_hl_diff;
+	else
+#endif
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+
+	Adaptivity->TH_L2H_ini_backup = pDM_Odm->TH_L2H_ini;
+	Adaptivity->TH_EDCCA_HL_diff_backup = pDM_Odm->TH_EDCCA_HL_diff;
+
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+
+	if (pDM_Odm->Carrier_Sense_enable) {
+		pDM_Odm->TH_L2H_ini = 0xa;
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+	} else {
+		Adaptivity->TH_L2H_ini_backup = pDM_Odm->TH_L2H_ini;	/*set by mib*/
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+	}
+
+	Adaptivity->TH_EDCCA_HL_diff_backup = pDM_Odm->TH_EDCCA_HL_diff;
+	if (priv->pshare->rf_ft_var.adaptivity_enable == 2)
+		Adaptivity->DynamicLinkAdaptivity = TRUE;
+	else
+		Adaptivity->DynamicLinkAdaptivity = FALSE;
+
+#endif
+
+	pDM_Odm->Adaptivity_IGI_upper = 0;
+	pDM_Odm->Adaptivity_enable = FALSE;	/*use this flag to decide enable or disable*/
+
+	pDM_Odm->EDCCA_enable = TRUE;		/*even no adaptivity, we still enable EDCCA*/
+
+	pDM_Odm->TH_L2H_ini_mode2 = 20;
+	pDM_Odm->TH_EDCCA_HL_diff_mode2 = 8;
+	
+	Adaptivity->IGI_Base = 0x32;
+	Adaptivity->IGI_target = 0x1c;
+	Adaptivity->H2L_lb = 0;
+	Adaptivity->L2H_lb = 0;
+	Adaptivity->NHMWait = 0;
+	Adaptivity->bCheck = FALSE;
+	Adaptivity->bFirstLink = TRUE;
+	Adaptivity->AdajustIGILevel = 0;
+
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+
+	/*Search pwdB lower bound*/
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC, bMaskDWord, 0x209);
+#endif
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_GAIN_IDX_EDCCA) {
+		/*ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_DOWN_OPT_11N, BIT12 | BIT11 | BIT10, 0x7);*/		/*interfernce need > 2^x us, and then EDCCA will be 1*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_DCNF_11N, BIT21 | BIT20, 0x1);		/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+	}
+#if (RTL8195A_SUPPORT == 0)
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_GAIN_IDX_EDCCA) {		/*8814a no need to find pwdB lower bound, maybe*/
+		/*ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_DOWN_OPT, BIT30 | BIT29 | BIT28, 0x7);*/		/*interfernce need > 2^x us, and then EDCCA will be 1*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_ACBB_EDCCA_ENHANCE, BIT29 | BIT28, 0x1);		/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+	}
+
+	if(!(pDM_Odm->SupportICType & (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA)))
+		Phydm_SearchPwdBLowerBound(pDM_Odm);
+#endif
+
+/*we need to consider PwdB upper bound for 8814 later IC*/
+	Adaptivity->AdajustIGILevel = (u1Byte)((pDM_Odm->TH_L2H_ini + IGItarget) - PwdBUpperBound + DFIRloss);	/*IGI = L2H - PwdB - DFIRloss*/
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("TH_L2H_ini = 0x%x, TH_EDCCA_HL_diff = 0x%x, Adaptivity->AdajustIGILevel = 0x%x\n", pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff, Adaptivity->AdajustIGILevel));
+
+}
+
+
+VOID
+Phydm_Adaptivity(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			IGI
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	s1Byte			TH_L2H_dmc, TH_H2L_dmc;
+	s1Byte			Diff = 0, IGI_target;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	BOOLEAN			bFwCurrentInPSMode = FALSE;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));
+
+	/*Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.*/
+	if (bFwCurrentInPSMode)
+		return;
+#endif
+
+	if ((pDM_Odm->EDCCA_enable == FALSE) || (pDM_Odm->bWIFITest == TRUE)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Disable EDCCA!!!\n"));
+		return;
+	}
+
+	if (!(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("adaptivity disable, enable EDCCA mode!!!\n"));
+		pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_mode2;
+		pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_mode2;
+	}
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	else{
+		if (Phydm_CheckChannelPlan(pDM_Odm) || (pDM_Odm->APTotalNum > Adaptivity->APNumTH)) {
+			pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_mode2;
+			pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_mode2;
+		}
+	}
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("odm_Adaptivity() =====>\n"));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d\n",
+			 Adaptivity->IGI_Base, pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff));
+#if (RTL8195A_SUPPORT == 0)
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		/*fix AC series when enable EDCCA hang issue*/
+		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 1);	/*ADC_mask disable*/
+		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 0);	/*ADC_mask enable*/
+	}
+#endif
+	if (*pDM_Odm->pBandWidth == ODM_BW20M)		/*CHANNEL_WIDTH_20*/
+		IGI_target = Adaptivity->IGI_Base;
+	else if (*pDM_Odm->pBandWidth == ODM_BW40M)
+		IGI_target = Adaptivity->IGI_Base + 2;
+#if (RTL8195A_SUPPORT == 0)
+	else if (*pDM_Odm->pBandWidth == ODM_BW80M)
+		IGI_target = Adaptivity->IGI_Base + 2;
+#endif
+	else
+		IGI_target = Adaptivity->IGI_Base;
+	Adaptivity->IGI_target = (u1Byte) IGI_target;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("BandWidth=%s, IGI_target=0x%x, DynamicLinkAdaptivity = %d\n",
+			 (*pDM_Odm->pBandWidth == ODM_BW80M) ? "80M" : ((*pDM_Odm->pBandWidth == ODM_BW40M) ? "40M" : "20M"), IGI_target, Adaptivity->DynamicLinkAdaptivity));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("RSSI_min = %d, Adaptivity->AdajustIGILevel= 0x%x, adaptivity_flag = %d, Adaptivity_enable = %d\n",
+			 pDM_Odm->RSSI_Min, Adaptivity->AdajustIGILevel, pDM_Odm->adaptivity_flag, pDM_Odm->Adaptivity_enable));
+
+	if ((Adaptivity->DynamicLinkAdaptivity == TRUE) && (!pDM_Odm->bLinked) && (pDM_Odm->Adaptivity_enable == FALSE)) {
+		Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("In DynamicLink mode(noisy) and No link, Turn off EDCCA!!\n"));
+		return;
+	}
+
+	if (pDM_Odm->SupportICType & (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA)) {
+		if ((Adaptivity->AdajustIGILevel > IGI) && (pDM_Odm->Adaptivity_enable == TRUE)) 
+			Diff = Adaptivity->AdajustIGILevel - IGI;
+		
+		TH_L2H_dmc = pDM_Odm->TH_L2H_ini - Diff + IGI_target;
+		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else	{
+		Diff = IGI_target - (s1Byte)IGI;
+		TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+		if (TH_L2H_dmc > 10 && (pDM_Odm->Adaptivity_enable == TRUE))
+			TH_L2H_dmc = 10;
+
+		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+		/*replace lower bound to prevent EDCCA always equal 1*/
+		if (TH_H2L_dmc < Adaptivity->H2L_lb)
+			TH_H2L_dmc = Adaptivity->H2L_lb;
+		if (TH_L2H_dmc < Adaptivity->L2H_lb)
+			TH_L2H_dmc = Adaptivity->L2H_lb;
+	}
+#endif
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", IGI, TH_L2H_dmc, TH_H2L_dmc));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity_IGI_upper=0x%x, H2L_lb = 0x%x, L2H_lb = 0x%x\n", pDM_Odm->Adaptivity_IGI_upper, Adaptivity->H2L_lb, Adaptivity->L2H_lb));
+
+	Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+	return;
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+Phydm_AdaptivityBSOD(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter = pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	u1Byte			count = 0;
+	u4Byte			u4Value;
+
+	/*
+	1. turn off RF (TRX Mux in standby mode)
+	2. H2C mac id drop
+	3. ignore EDCCA
+	4. wait for clear FIFO
+	5. don't ignore EDCCA
+	6. turn on RF (TRX Mux in TRx mdoe)
+	7. H2C mac id resume
+	*/
+
+	RT_TRACE(COMP_MLME, DBG_WARNING, ("MAC id drop packet!!!!!\n"));
+
+	pAdapter->dropPktByMacIdCnt++;
+	pMgntInfo->bDropPktInProgress = TRUE;
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_MAX_Q_PAGE_NUM, (pu1Byte)(&u4Value));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("Queue Reserved Page Number = 0x%08x\n", u4Value));
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_AVBL_Q_PAGE_NUM, (pu1Byte)(&u4Value));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("Available Queue Page Number = 0x%08x\n", u4Value));
+
+#if 1
+
+	/*Standby mode*/
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+	ODM_Write_DIG(pDM_Odm, 0x20);
+
+	/*H2C mac id drop*/
+	MacIdIndicateDisconnect(pAdapter);
+
+	/*Ignore EDCCA*/
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+
+	delay_ms(50);
+	count = 5;
+
+#else
+
+	do {
+
+		u8Byte 		diffTime, curTime, oldestTime;
+		u1Byte		queueIdx
+
+		//3 Standby mode
+		Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+		ODM_Write_DIG(pDM_Odm, 0x20);
+
+		//3 H2C mac id drop
+		MacIdIndicateDisconnect(pAdapter);
+
+		//3 Ignore EDCCA
+		Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+
+		count++;
+		delay_ms(10);
+
+		// Check latest packet
+		curTime = PlatformGetCurrentTime();
+		oldestTime = 0xFFFFFFFFFFFFFFFF;
+
+		for (queueIdx = 0; queueIdx < MAX_TX_QUEUE; queueIdx++) {
+			if (!IS_DATA_QUEUE(queueIdx))
+				continue;
+
+			if (!pAdapter->bTcbBusyQEmpty[queueIdx]) {
+				RT_TRACE(COMP_MLME, DBG_WARNING, ("oldestTime = %llu\n", oldestTime));
+				RT_TRACE(COMP_MLME, DBG_WARNING, ("Q[%d] = %llu\n", queueIdx, pAdapter->firstTcbSysTime[queueIdx]));
+				if (pAdapter->firstTcbSysTime[queueIdx] < oldestTime)
+					oldestTime = pAdapter->firstTcbSysTime[queueIdx];
+			}
+		}
+
+		diffTime = curTime - oldestTime;
+
+		RT_TRACE(COMP_MLME, DBG_WARNING, ("diff s = %llu\n", (diffTime / 1000000)));
+
+	} while (((diffTime / 1000000) >= 4) && (oldestTime != 0xFFFFFFFFFFFFFFFF));
+#endif
+
+	/*Resume EDCCA*/
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+
+	/*Turn on TRx mode*/
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_TX_MODE, PhyDM_RX_MODE);
+	ODM_Write_DIG(pDM_Odm, 0x20);
+
+	/*Resume H2C macid*/
+	MacIdRecoverMediaStatus(pAdapter);
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_AVBL_Q_PAGE_NUM, (pu1Byte)(&u4Value));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("Available Queue Page Number = 0x%08x\n", u4Value));
+
+	pMgntInfo->bDropPktInProgress = FALSE;
+	RT_TRACE(COMP_MLME, DBG_WARNING, ("End of MAC id drop packet, spent %dms\n", count * 10));
+
+}
+
+#endif
+
+VOID
+phydm_setEDCCAThresholdAPI(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	IGI
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	s1Byte			TH_L2H_dmc, TH_H2L_dmc;
+	s1Byte			Diff = 0, IGI_target = 0x32;
+
+	if (pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY) {
+
+		if (pDM_Odm->SupportICType & (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA)) {
+			if (Adaptivity->AdajustIGILevel > IGI) 
+				Diff = Adaptivity->AdajustIGILevel - IGI;
+		
+			TH_L2H_dmc = pDM_Odm->TH_L2H_ini - Diff + IGI_target;
+			TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+		}
+#if (RTL8195A_SUPPORT == 0)
+		else	{
+			Diff = IGI_target - (s1Byte)IGI;
+			TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+			if (TH_L2H_dmc > 10)
+				TH_L2H_dmc = 10;
+
+			TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+			/*replace lower bound to prevent EDCCA always equal 1*/
+			if (TH_H2L_dmc < Adaptivity->H2L_lb)
+				TH_H2L_dmc = Adaptivity->H2L_lb;
+			if (TH_L2H_dmc < Adaptivity->L2H_lb)
+				TH_L2H_dmc = Adaptivity->L2H_lb;
+		}
+#endif
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("API :IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", IGI, TH_L2H_dmc, TH_H2L_dmc));
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("API :Adaptivity_IGI_upper=0x%x, H2L_lb = 0x%x, L2H_lb = 0x%x\n", pDM_Odm->Adaptivity_IGI_upper, Adaptivity->H2L_lb, Adaptivity->L2H_lb));
+
+		Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+	}
+
+}
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.h
new file mode 100644
index 000000000..819ea346c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_adaptivity.h
@@ -0,0 +1,172 @@
+
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMADAPTIVITY_H__
+#define    __PHYDMADAPTIVITY_H__
+
+#define ADAPTIVITY_VERSION	"9.0"
+
+#define PwdBUpperBound	7
+#define DFIRloss	5
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+typedef enum _tag_PhyDM_REGULATION_Type {
+	REGULATION_FCC = 0,
+	REGULATION_MKK = 1,
+	REGULATION_ETSI = 2,
+	REGULATION_WW = 3,	
+	
+	MAX_REGULATION_NUM = 4
+} PhyDM_REGULATION_TYPE;
+#endif
+
+typedef enum tag_PhyDM_set_LNA {
+	PhyDM_disable_LNA		= 0,
+	PhyDM_enable_LNA		= 1,
+} PhyDM_set_LNA;
+
+
+typedef enum tag_PhyDM_TRx_MUX_Type
+{
+	PhyDM_SHUTDOWN			= 0,
+	PhyDM_STANDBY_MODE		= 1,
+	PhyDM_TX_MODE			= 2,
+	PhyDM_RX_MODE			= 3
+}PhyDM_Trx_MUX_Type;
+
+typedef enum tag_PhyDM_MACEDCCA_Type
+{
+	PhyDM_IGNORE_EDCCA			= 0,
+	PhyDM_DONT_IGNORE_EDCCA	= 1
+}PhyDM_MACEDCCA_Type;
+
+typedef struct _ADAPTIVITY_STATISTICS {
+	s1Byte			TH_L2H_ini_backup;
+	s1Byte			TH_EDCCA_HL_diff_backup;
+	s1Byte			IGI_Base;
+	u1Byte			IGI_target;
+	u1Byte			NHMWait;
+	s1Byte			H2L_lb;
+	s1Byte			L2H_lb;
+	BOOLEAN			bFirstLink;
+	BOOLEAN			bCheck;
+	BOOLEAN			DynamicLinkAdaptivity;
+	u1Byte			APNumTH;
+	u1Byte			AdajustIGILevel;
+} ADAPTIVITY_STATISTICS, *PADAPTIVITY_STATISTICS;
+
+VOID
+Phydm_CheckAdaptivity(
+	IN		PVOID			pDM_VOID
+	);
+
+VOID
+Phydm_CheckEnvironment(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatisticsInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatistics(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatisticsReset(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+Phydm_GetNHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+Phydm_MACEDCCAState(
+	IN	PVOID					pDM_VOID,
+	IN	PhyDM_MACEDCCA_Type		State
+);
+
+VOID
+Phydm_SetEDCCAThreshold(
+	IN		PVOID		pDM_VOID,
+	IN		s1Byte		H2L,
+	IN		s1Byte		L2H
+);
+
+VOID
+Phydm_SetTRxMux(
+	IN		PVOID			pDM_VOID,
+	IN		PhyDM_Trx_MUX_Type			txMode,
+	IN		PhyDM_Trx_MUX_Type			rxMode
+);	
+
+BOOLEAN
+Phydm_CalNHMcnt(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+Phydm_SearchPwdBLowerBound(
+	IN		PVOID					pDM_VOID
+);
+
+VOID 
+Phydm_AdaptivityInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_Adaptivity(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					IGI
+	);
+
+VOID
+phydm_setEDCCAThresholdAPI(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	IGI
+);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+Phydm_DisableEDCCA(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_DynamicEDCCA(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_AdaptivityBSOD(
+	IN		PVOID					pDM_VOID
+);
+
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.c
new file mode 100644
index 000000000..2204a73a7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.c
@@ -0,0 +1,1215 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+//#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN |ODM_CE))
+#if(defined(CONFIG_ANT_DETECTION))
+
+//IS_ANT_DETECT_SUPPORT_SINGLE_TONE(Adapter)	
+//IS_ANT_DETECT_SUPPORT_RSSI(Adapter)		
+//IS_ANT_DETECT_SUPPORT_PSD(Adapter)
+
+//1 [1. Single Tone Method] ===================================================
+
+
+VOID
+odm_PHY_SaveAFERegisters(
+	IN	PVOID		pDM_VOID,
+	IN	pu4Byte		AFEReg,
+	IN	pu4Byte		AFEBackup,
+	IN	u4Byte		RegisterNum
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	i;
+	
+	//RT_DISP(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
+	for( i = 0 ; i < RegisterNum ; i++){
+		AFEBackup[i] = ODM_GetBBReg(pDM_Odm, AFEReg[i], bMaskDWord);
+	}
+}
+
+VOID
+odm_PHY_ReloadAFERegisters(
+	IN	PVOID		pDM_VOID,
+	IN	pu4Byte		AFEReg,
+	IN	pu4Byte		AFEBackup,
+	IN	u4Byte		RegiesterNum
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	i;
+
+	//RT_DISP(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
+	for(i = 0 ; i < RegiesterNum; i++)
+	{
+	
+		ODM_SetBBReg(pDM_Odm, AFEReg[i], bMaskDWord, AFEBackup[i]);
+	}
+}
+
+//
+// Description:
+//	Set Single/Dual Antenna default setting for products that do not do detection in advance.
+//
+// Added by Joseph, 2012.03.22
+//
+VOID
+ODM_SingleDualAntennaDefaultSetting(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+
+	u1Byte btAntNum=BT_GetPgAntNum(pAdapter);
+	// Set default antenna A and B status
+	if(btAntNum == 2)
+	{
+		pDM_SWAT_Table->ANTA_ON=TRUE;
+		pDM_SWAT_Table->ANTB_ON=TRUE;
+	
+	}
+	else if(btAntNum == 1)
+	{// Set antenna A as default
+		pDM_SWAT_Table->ANTA_ON=TRUE;
+		pDM_SWAT_Table->ANTB_ON=FALSE;
+	
+	}
+	else
+	{
+		RT_ASSERT(FALSE, ("Incorrect antenna number!!\n"));
+	}
+}
+
+
+//2 8723A ANT DETECT
+//
+// Description:
+//	Implement IQK single tone for RF DPK loopback and BB PSD scanning. 
+//	This function is cooperated with BB team Neil. 
+//
+// Added by Roger, 2011.12.15
+//
+BOOLEAN
+ODM_SingleDualAntennaDetection(
+	IN		PVOID		pDM_VOID,
+	IN		u1Byte			mode
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u4Byte		CurrentChannel,RfLoopReg;
+	u1Byte		n;
+	u4Byte		Reg88c, Regc08, Reg874, Regc50, Reg948, Regb2c, Reg92c, Reg930, Reg064, AFE_rRx_Wait_CCA;
+	u1Byte		initial_gain = 0x5a;
+	u4Byte		PSD_report_tmp;
+	u4Byte		AntA_report = 0x0, AntB_report = 0x0, AntO_report = 0x0;
+	BOOLEAN		bResult = TRUE;
+	u4Byte		AFE_Backup[16];
+	u4Byte		AFE_REG_8723A[16] = {
+					rRx_Wait_CCA, 	rTx_CCK_RFON, 
+					rTx_CCK_BBON, 	rTx_OFDM_RFON,
+					rTx_OFDM_BBON, 	rTx_To_Rx,
+					rTx_To_Tx, 		rRx_CCK, 
+					rRx_OFDM, 		rRx_Wait_RIFS, 
+					rRx_TO_Rx,		rStandby,
+					rSleep,			rPMPD_ANAEN, 	
+					rFPGA0_XCD_SwitchControl, rBlue_Tooth};
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection()============> \n"));	
+
+	
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C|ODM_RTL8723B)))
+		return bResult;
+
+	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
+	if(!IS_ANT_DETECT_SUPPORT_SINGLE_TONE(pAdapter))
+		return bResult;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192C)
+	{
+		//Which path in ADC/DAC is turnned on for PSD: both I/Q
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT10|BIT11, 0x3);
+		//Ageraged number: 8
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT12|BIT13, 0x1);
+		//pts = 128;
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+	}
+
+	//1 Backup Current RF/BB Settings	
+	
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
+	RfLoopReg = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		Reg92c = ODM_GetBBReg(pDM_Odm, rDPDT_control, bMaskDWord);	
+		Reg930 = ODM_GetBBReg(pDM_Odm, rfe_ctrl_anta_src, bMaskDWord);
+		Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
+		Regb2c = ODM_GetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord);
+		Reg064 = ODM_GetMACReg(pDM_Odm, rSYM_WLBT_PAPE_SEL, BIT29);
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x1);
+		ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, 0xff, 0x77);
+		ODM_SetMACReg(pDM_Odm, rSYM_WLBT_PAPE_SEL, BIT29, 0x1);  //dbg 7
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0x3c0, 0x0);//dbg 8
+		ODM_SetBBReg(pDM_Odm, rAGC_table_select, BIT31, 0x0);
+	}
+
+	ODM_StallExecution(10);
+	
+	//Store A Path Register 88c, c08, 874, c50
+	Reg88c = ODM_GetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord);
+	Regc08 = ODM_GetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord);
+	Reg874 = ODM_GetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord);
+	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);	
+	
+	// Store AFE Registers
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	odm_PHY_SaveAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		AFE_rRx_Wait_CCA = ODM_GetBBReg(pDM_Odm, rRx_Wait_CCA,bMaskDWord);
+	
+	//Set PSD 128 pts
+	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pts
+	
+	// To SET CH1 to do
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask, 0x7401);     //Channel 1
+	
+	// AFE all on step
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_CCK_RFON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_CCK_BBON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_OFDM_RFON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_OFDM_BBON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_To_Rx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_To_Tx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_CCK, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_OFDM, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_RIFS, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_TO_Rx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rStandby, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rSleep, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rPMPD_ANAEN, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_SwitchControl, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rBlue_Tooth, bMaskDWord, 0x6FDB25A4);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x01c00016);
+	}
+
+	// 3 wire Disable
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, 0xCCF000C0);
+	
+	//BB IQK Setting
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800E4);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+
+	//IQK setting tone@ 4.34Mhz
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x10008C1C);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);	
+
+	//Page B init
+	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00080000);
+	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x0f600000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150008);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150008);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150016);
+		ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150016);
+	}
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x001028d0);	
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7f, initial_gain);
+
+	//RF loop Setting
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x0, 0xFFFFF, 0x50008);	
+	
+	//IQK Single tone start
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x808000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	
+	ODM_StallExecution(10000);
+
+	// PSD report of antenna A
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp >AntA_report)
+			AntA_report=PSD_report_tmp;
+	}
+
+	 // change to Antenna B
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_B); 
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		//ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x2);
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0xfff, 0x280);
+		ODM_SetBBReg(pDM_Odm, rAGC_table_select, BIT31, 0x1);
+	}
+
+	ODM_StallExecution(10);	
+
+	// PSD report of antenna B
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp > AntB_report)
+			AntB_report=PSD_report_tmp;
+	}
+
+	// change to open case
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, 0);  // change to Antenna A
+
+		ODM_StallExecution(10);	
+		
+		// PSD report of open case
+		PSD_report_tmp=0x0;
+		for (n=0;n<2;n++)
+	 	{
+	 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+			if(PSD_report_tmp > AntO_report)
+				AntO_report=PSD_report_tmp;
+		}
+	}
+	//Close IQK Single Tone function
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+
+	//1 Return to antanna A
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		// external DPDT
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, bMaskDWord, Reg92c);
+
+		//internal S0/S1
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
+		ODM_SetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord, Regb2c);
+		ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, bMaskDWord, Reg930);
+		ODM_SetMACReg(pDM_Odm, rSYM_WLBT_PAPE_SEL, BIT29, Reg064);
+	}
+	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, Reg88c);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, Regc08);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, Reg874);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7F, 0x40);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord, Regc50);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,CurrentChannel);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask,RfLoopReg);
+
+	//Reload AFE Registers
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		odm_PHY_ReloadAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, AFE_rRx_Wait_CCA);
+
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+		//2 Test Ant B based on Ant A is ON
+		if(mode==ANTTESTB)
+		{
+			if(AntA_report >=	100)
+			{
+				if(AntB_report > (AntA_report+1))
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
+				}	
+			}
+			else
+			{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+				pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+				bResult = FALSE;
+			}
+		}	
+		//2 Test Ant A and B based on DPDT Open
+		else if(mode==ANTTESTALL)
+		{
+			if((AntO_report >=100) && (AntO_report <=118))
+			{
+				if(AntA_report > (AntO_report+1))
+				{
+					pDM_SWAT_Table->ANTA_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is OFF\n"));
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTA_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is ON\n"));
+				}
+
+				if(AntB_report > (AntO_report+2))
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is OFF\n"));
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is ON\n"));
+				}
+				
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
+				
+				pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
+				pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
+				pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
+				pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
+				
+				}
+			else
+				{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
+				bResult = FALSE;
+			}
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192C)
+	{
+		if(AntA_report >=	100)
+		{
+			if(AntB_report > (AntA_report+2))
+			{
+				pDM_SWAT_Table->ANTA_ON=FALSE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_B);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna B\n"));		
+			}	
+			else if(AntA_report > (AntB_report+2))
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_A);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
+			}	
+			else
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+			}
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+			pDM_SWAT_Table->ANTA_ON=TRUE; // Set Antenna A on as default 
+			pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+			bResult = FALSE;
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
+		
+		//2 Test Ant B based on Ant A is ON
+		if((AntA_report >= 100) && (AntB_report >= 100) && (AntA_report <= 135) && (AntB_report <= 135))
+		{
+			u1Byte TH1=2, TH2=6;
+		
+			if((AntA_report - AntB_report < TH1) || (AntB_report - AntA_report < TH1))
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Dual Antenna\n"));
+			}
+			else if(((AntA_report - AntB_report >= TH1) && (AntA_report - AntB_report <= TH2)) || 
+				((AntB_report - AntA_report >= TH1) && (AntB_report - AntA_report <= TH2)))
+			{
+				pDM_SWAT_Table->ANTA_ON=FALSE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				bResult = FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+			}
+			else
+			{
+				pDM_SWAT_Table->ANTA_ON = TRUE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Single Antenna\n"));
+			}
+			pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
+			pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
+			pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
+			pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
+				
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
+			bResult = FALSE;
+		}
+	}
+	return bResult;
+
+}
+
+
+
+//1 [2. Scan AP RSSI Method] ==================================================
+
+
+
+
+BOOLEAN
+ODM_SwAntDivCheckBeforeLink(
+	IN		PVOID		pDM_VOID
+	)
+{
+
+#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
+
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	s1Byte			Score = 0;
+	PRT_WLAN_BSS	pTmpBssDesc, pTestBssDesc;
+	u1Byte 			power_target = 10, power_target_L = 9, power_target_H = 16;
+	u1Byte			tmp_power_diff = 0,power_diff = 0,avg_power_diff = 0,max_power_diff = 0,min_power_diff = 0xff;
+	u2Byte			index, counter = 0;
+	static u1Byte		ScanChannel;
+	u8Byte			tStamp_diff = 0;		
+	u4Byte			tmp_SWAS_NoLink_BK_Reg948;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ANTA_ON = (( %d )) , ANTB_ON = (( %d )) \n",pDM_Odm->DM_SWAT_Table.ANTA_ON ,pDM_Odm->DM_SWAT_Table.ANTB_ON ));
+
+	//if(HP id)
+	{
+		if(pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult==TRUE && pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("8723B RSSI-based Antenna Detection is done\n"));
+			return FALSE;
+		}
+		
+		if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			if(pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 == 0xff)
+				pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 = ODM_Read4Byte(pDM_Odm, rS0S1_PathSwitch );
+		}
+	}
+
+	if (pDM_Odm->Adapter == NULL)  //For BSOD when plug/unplug fast.  //By YJ,120413
+	{	// The ODM structure is not initialized.
+		return FALSE;
+	}
+
+	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
+	if(!IS_ANT_DETECT_SUPPORT_RSSI(Adapter))
+	{
+		return FALSE;
+	}
+	else
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Antenna Detection: RSSI Method\n"));	
+	}
+
+	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
+	PlatformAcquireSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+				("ODM_SwAntDivCheckBeforeLink(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
+				pMgntInfo->RFChangeInProgress, pHalData->eRFPowerState));
+	
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		
+		return FALSE;
+	}
+	else
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("pDM_SWAT_Table->SWAS_NoLink_State = %d\n", pDM_SWAT_Table->SWAS_NoLink_State));
+	//1 Run AntDiv mechanism "Before Link" part.
+	if(pDM_SWAT_Table->SWAS_NoLink_State == 0)
+	{
+		//1 Prepare to do Scan again to check current antenna state.
+
+		// Set check state to next step.
+		pDM_SWAT_Table->SWAS_NoLink_State = 1;
+	
+		// Copy Current Scan list.
+		pMgntInfo->tmpNumBssDesc = pMgntInfo->NumBssDesc;
+		PlatformMoveMemory((PVOID)Adapter->MgntInfo.tmpbssDesc, (PVOID)pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC);
+		
+		// Go back to scan function again.
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Scan one more time\n"));
+		pMgntInfo->ScanStep=0;
+		pMgntInfo->bScanAntDetect = TRUE;
+		ScanChannel = odm_SwAntDivSelectScanChnl(Adapter);
+
+		
+		if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8821))
+		{
+			if(pDM_FatTable->RxIdleAnt == MAIN_ANT)
+				ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+			else
+				ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+			if(ScanChannel == 0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+					("ODM_SwAntDivCheckBeforeLink(): No AP List Avaiable, Using Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"AUX_ANT":"MAIN_ANT"));
+
+				if(IS_5G_WIRELESS_MODE(pMgntInfo->dot11CurrentWirelessMode))
+				{
+					pDM_SWAT_Table->Ant5G = pDM_FatTable->RxIdleAnt;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant5G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+				}
+				else
+				{
+					pDM_SWAT_Table->Ant2G = pDM_FatTable->RxIdleAnt;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant2G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+				}
+				return FALSE;
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+				("ODM_SwAntDivCheckBeforeLink: Change to %s for testing.\n", ((pDM_FatTable->RxIdleAnt == MAIN_ANT)?"MAIN_ANT":"AUX_ANT")));
+		}
+		else if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8723B))
+		{
+			if(pDM_Odm->SupportICType == ODM_RTL8192C)
+			{
+			// Switch Antenna to another one.
+			pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+			pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?AUX_ANT:MAIN_ANT;
+			
+				pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+			}
+			else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+			{
+				// Switch Antenna to another one.
+				
+				tmp_SWAS_NoLink_BK_Reg948 = ODM_Read4Byte(pDM_Odm, rS0S1_PathSwitch );
+				
+				if( (pDM_SWAT_Table->CurAntenna = MAIN_ANT) && (tmp_SWAS_NoLink_BK_Reg948==0x200))
+				{
+					ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0xfff, 0x280);
+					ODM_SetBBReg(pDM_Odm, rAGC_table_select, BIT31, 0x1);
+					pDM_SWAT_Table->CurAntenna = AUX_ANT;
+			}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Reg[948]= (( %x )) was in wrong state\n", tmp_SWAS_NoLink_BK_Reg948 ));
+					return FALSE;
+				}
+				ODM_StallExecution(10);
+		
+			}
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Change to (( %s-ant))  for testing.\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"MAIN":"AUX"));
+		}
+		
+		odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
+		PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+
+		return TRUE;
+	}
+	else //pDM_SWAT_Table->SWAS_NoLink_State == 1
+	{
+		//1 ScanComple() is called after antenna swiched.
+		//1 Check scan result and determine which antenna is going
+		//1 to be used.
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,(" tmpNumBssDesc= (( %d )) \n",pMgntInfo->tmpNumBssDesc));// debug for Dino
+		
+		for(index = 0; index < pMgntInfo->tmpNumBssDesc; index++)
+		{
+			pTmpBssDesc = &(pMgntInfo->tmpbssDesc[index]); // Antenna 1
+			pTestBssDesc = &(pMgntInfo->bssDesc[index]); // Antenna 2
+
+			if(PlatformCompareMemory(pTestBssDesc->bdBssIdBuf, pTmpBssDesc->bdBssIdBuf, 6)!=0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): ERROR!! This shall not happen.\n"));
+				continue;
+			}
+
+			if(pDM_Odm->SupportICType != ODM_RTL8723B)
+			{
+				if(pTmpBssDesc->ChannelNumber == ScanChannel)
+				{
+			if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
+			{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Compare scan entry: Score++\n"));
+						RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+			
+				Score++;
+				PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
+			}
+			else if(pTmpBssDesc->RecvSignalPower < pTestBssDesc->RecvSignalPower)
+			{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Compare scan entry: Score--\n"));
+						RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+				Score--;
+			}
+					else
+					{
+						if(pTestBssDesc->bdTstamp - pTmpBssDesc->bdTstamp < 5000)
+						{
+							RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("The 2nd Antenna didn't get this AP\n\n"));
+						}
+					}
+				}
+			}
+			else // 8723B
+			{ 
+				if(pTmpBssDesc->ChannelNumber == ScanChannel)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ChannelNumber == ScanChannel -> (( %d )) \n", pTmpBssDesc->ChannelNumber ));
+				
+					if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower) // Pow(Ant1) > Pow(Ant2)
+					{
+						counter++;
+						tmp_power_diff=(u1Byte)(pTmpBssDesc->RecvSignalPower - pTestBssDesc->RecvSignalPower);
+						power_diff = power_diff + tmp_power_diff;	
+						
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);
+
+						//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("tmp_power_diff: (( %d)),max_power_diff: (( %d)),min_power_diff: (( %d))  \n", tmp_power_diff,max_power_diff,min_power_diff));
+						if(tmp_power_diff > max_power_diff)
+							max_power_diff=tmp_power_diff;
+						if(tmp_power_diff < min_power_diff)
+							min_power_diff=tmp_power_diff;
+						//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("max_power_diff: (( %d)),min_power_diff: (( %d))  \n",max_power_diff,min_power_diff));
+						
+						PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
+					}
+					else if(pTestBssDesc->RecvSignalPower > pTmpBssDesc->RecvSignalPower) // Pow(Ant1) < Pow(Ant2)
+					{
+						counter++;
+						tmp_power_diff=(u1Byte)(pTestBssDesc->RecvSignalPower - pTmpBssDesc->RecvSignalPower);
+						power_diff = power_diff + tmp_power_diff;						
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);							
+						if(tmp_power_diff > max_power_diff)
+							max_power_diff=tmp_power_diff;
+						if(tmp_power_diff < min_power_diff)
+							min_power_diff=tmp_power_diff;							
+					}
+					else // Pow(Ant1) = Pow(Ant2)
+					{
+						if(pTestBssDesc->bdTstamp > pTmpBssDesc->bdTstamp) //  Stamp(Ant1) < Stamp(Ant2) 
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("time_diff: %lld\n", (pTestBssDesc->bdTstamp-pTmpBssDesc->bdTstamp)/1000));
+						if(pTestBssDesc->bdTstamp - pTmpBssDesc->bdTstamp > 5000)
+						{
+							counter++;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+							ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
+								ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);
+								min_power_diff = 0;
+						}
+					}
+						else
+						{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Error !!!]: Time_diff: %lld\n", (pTestBssDesc->bdTstamp-pTmpBssDesc->bdTstamp)/1000));
+						}
+				}
+			}
+		}
+		}
+
+		if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8821))
+		{
+			if(pMgntInfo->NumBssDesc!=0 && Score<0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
+							("ODM_SwAntDivCheckBeforeLink(): Using Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+						("ODM_SwAntDivCheckBeforeLink(): Remain Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"AUX_ANT":"MAIN_ANT"));
+
+				if(pDM_FatTable->RxIdleAnt == MAIN_ANT)
+					ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+				else
+					ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+			}
+			
+			if(IS_5G_WIRELESS_MODE(pMgntInfo->dot11CurrentWirelessMode))
+			{
+				pDM_SWAT_Table->Ant5G = pDM_FatTable->RxIdleAnt;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant5G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			}
+			else
+			{
+				pDM_SWAT_Table->Ant2G = pDM_FatTable->RxIdleAnt;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant2G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			}
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			if(counter == 0)
+			{	
+				if(pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec == FALSE)
+				{
+					pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec = TRUE;
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Counter=(( 0 )) , [[ Cannot find any AP with Aux-ant ]] ->  Scan Target-channel again  \n"));	
+
+                                        //3 [ Scan again ]
+					odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
+					PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+					return TRUE;
+				}
+				else// Pre_Aux_FailDetec == TRUE
+				{
+					//2 [ Single Antenna ]
+					pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec = FALSE;
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Counter=(( 0 )) , [[  Still cannot find any AP ]] \n"));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));	
+				}
+				pDM_Odm->DM_SWAT_Table.Aux_FailDetec_Counter++;
+			}
+			else
+			{
+				pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec = FALSE;
+				
+				if(counter==3)
+				{
+					avg_power_diff = ((power_diff-max_power_diff - min_power_diff)>>1)+ ((max_power_diff + min_power_diff)>>2);
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("counter: (( %d )) ,  power_diff: (( %d )) \n", counter, power_diff));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ counter==3 ] Modified avg_power_diff: (( %d )) , max_power_diff: (( %d )) ,  min_power_diff: (( %d )) \n", avg_power_diff,max_power_diff, min_power_diff));
+				}
+				else if(counter>=4)
+				{
+					avg_power_diff=(power_diff-max_power_diff - min_power_diff) / (counter - 2);
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("counter: (( %d )) ,  power_diff: (( %d )) \n", counter, power_diff));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ counter>=4 ] Modified avg_power_diff: (( %d )) , max_power_diff: (( %d )) ,  min_power_diff: (( %d )) \n", avg_power_diff,max_power_diff, min_power_diff));
+					
+				}
+				else//counter==1,2
+				{
+					avg_power_diff=power_diff/counter;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("avg_power_diff: (( %d )) , counter: (( %d )) ,  power_diff: (( %d )) \n", avg_power_diff,counter, power_diff));
+				}
+
+				//2 [ Retry ]
+				if( (avg_power_diff >=power_target_L) && (avg_power_diff <=power_target_H)  )
+				{
+					pDM_Odm->DM_SWAT_Table.Retry_Counter++;
+					
+					if(pDM_Odm->DM_SWAT_Table.Retry_Counter<=3)
+					{
+						pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=FALSE;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[[ Low confidence result ]] avg_power_diff= (( %d ))  ->  Scan Target-channel again ]] \n", avg_power_diff));	
+
+					         //3 [ Scan again ]
+						odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
+						PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+						return TRUE;					         
+					}
+					else
+			{
+						pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[[ Still Low confidence result ]]  (( Retry_Counter > 3 )) \n"));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
+					}
+					
+				}
+				//2 [ Dual Antenna ]
+				else if( (pMgntInfo->NumBssDesc != 0) && (avg_power_diff < power_target_L)   ) 
+				{
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+					if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
+					{
+						pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+						pDM_Odm->DM_SWAT_Table.ANTB_ON = TRUE;
+					}
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SwAntDivCheckBeforeLink(): Dual antenna\n"));
+					pDM_Odm->DM_SWAT_Table.Dual_Ant_Counter++;
+
+					// set bt coexDM from 1ant coexDM to 2ant coexDM
+					BT_SetBtCoexAntNum(Adapter, BT_COEX_ANT_TYPE_DETECTED, 2);
+					
+					//3 [ Init antenna diversity ]
+					pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV; 
+					ODM_AntDivInit(pDM_Odm);
+				}
+				//2 [ Single Antenna ]
+				else if(avg_power_diff > power_target_H)
+				{
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+					if(pDM_Odm->DM_SWAT_Table.ANTB_ON == TRUE)
+					{
+						pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+						pDM_Odm->DM_SWAT_Table.ANTB_ON = FALSE;
+						//BT_SetBtCoexAntNum(Adapter, BT_COEX_ANT_TYPE_DETECTED, 1);
+					}
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
+					pDM_Odm->DM_SWAT_Table.Single_Ant_Counter++;
+				}
+			}
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("bResult=(( %d ))\n",pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Dual_Ant_Counter = (( %d )), Single_Ant_Counter = (( %d )) , Retry_Counter = (( %d )) , Aux_FailDetec_Counter = (( %d ))\n\n\n",
+			pDM_Odm->DM_SWAT_Table.Dual_Ant_Counter,pDM_Odm->DM_SWAT_Table.Single_Ant_Counter,pDM_Odm->DM_SWAT_Table.Retry_Counter,pDM_Odm->DM_SWAT_Table.Aux_FailDetec_Counter));
+
+			//2 recover the antenna setting
+
+			if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
+				ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0xfff, (pDM_SWAT_Table->SWAS_NoLink_BK_Reg948));
+			
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("bResult=(( %d )), Recover  Reg[948]= (( %x )) \n\n",pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult, pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 ));
+
+			
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8192C)
+		{
+			if(pMgntInfo->NumBssDesc!=0 && Score<=0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
+					("ODM_SwAntDivCheckBeforeLink(): Using Ant(%s)\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"MAIN":"AUX"));
+
+				pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+					("ODM_SwAntDivCheckBeforeLink(): Remain Ant(%s)\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"AUX":"MAIN"));
+
+				pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
+
+				//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
+				pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+				PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+			}
+		}
+		
+		// Check state reset to default and wait for next time.
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		pMgntInfo->bScanAntDetect = FALSE;
+
+		return FALSE;
+	}
+
+#else
+		return	FALSE;
+#endif
+
+return FALSE;
+}
+
+
+
+
+
+
+//1 [3. PSD Method] ==========================================================
+
+
+
+
+u4Byte
+odm_GetPSDData(
+	IN 	PVOID			pDM_VOID,
+	IN u2Byte			point,
+	IN u1Byte 		initial_gain)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			psd_report;
+	
+	ODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);  //Start PSD calculation, Reg808[22]=0->1
+	ODM_StallExecution(150);//Wait for HW PSD report
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);//Stop PSD calculation,  Reg808[22]=1->0
+	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;//Read PSD report, Reg8B4[15:0]
+	
+	psd_report = (u4Byte) (odm_ConvertTo_dB(psd_report));//+(u4Byte)(initial_gain);
+	return psd_report;
+}
+
+
+
+VOID
+ODM_SingleDualAntennaDetection_PSD(
+	IN	 PVOID 	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u4Byte	Channel_ori;
+	u1Byte 	initial_gain = 0x36;
+	u1Byte	tone_idx;
+	u1Byte	Tone_lenth_1=7, Tone_lenth_2=4;
+	u2Byte	Tone_idx_1[7]={88, 104, 120, 8, 24, 40, 56};
+	u2Byte	Tone_idx_2[4]={8, 24, 40, 56};
+	u4Byte	PSD_report_Main[11]={0}, PSD_report_Aux[11]={0};
+	//u1Byte	Tone_lenth_1=4, Tone_lenth_2=2;
+	//u2Byte	Tone_idx_1[4]={88, 120, 24, 56};
+	//u2Byte	Tone_idx_2[2]={ 24,  56};
+	//u4Byte	PSD_report_Main[6]={0}, PSD_report_Aux[6]={0};
+
+	u4Byte	PSD_report_temp,MAX_PSD_report_Main=0,MAX_PSD_report_Aux=0;
+	u4Byte	PSD_power_threshold;
+	u4Byte	Main_psd_result=0, Aux_psd_result=0;
+	u4Byte	Regc50, Reg948, Regb2c,Regc14,Reg908;
+	u4Byte	i=0,test_num=8;
+	
+
+	if(pDM_Odm->SupportICType != ODM_RTL8723B)
+		return;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection_PSD()============> \n"));	
+	
+	//2 [ Backup Current RF/BB Settings ]	
+	
+	Channel_ori = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
+	Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
+	Regb2c =  ODM_GetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord);
+	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);
+	Regc14 = ODM_GetBBReg(pDM_Odm, 0xc14, bMaskDWord);
+	Reg908 = ODM_GetBBReg(pDM_Odm, 0x908, bMaskDWord);
+
+	//2 [ Setting for doing PSD function (CH4)]
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0); //disable whole CCK block
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF); // Turn off TX  ->  Pause TX Queue
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0); // [ Set IQK Matrix = 0 ] equivalent to [ Turn off CCA]
+
+	// PHYTXON while loop
+	ODM_SetBBReg(pDM_Odm, 0x908, bMaskDWord, 0x803); 
+	while (ODM_GetBBReg(pDM_Odm, 0xdf4, BIT6)) 
+	{
+		i++;
+		if (i > 1000000) 
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Wait in %s() more than %d times!\n", __FUNCTION__, i));	
+			break;
+		}
+	}
+	
+	ODM_SetBBReg(pDM_Odm, 0xc50, 0x7f, initial_gain);  
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, 0x7ff, 0x04);     // Set RF to CH4 & 40M
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0xf);	// 3 wire Disable    88c[23:20]=0xf
+	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pt	//Set PSD 128 ptss
+	ODM_StallExecution(3000);	
+	
+	
+	//2 [ Doing PSD Function in (CH4)]
+	
+        //Antenna A
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Main-ant   (CH4)\n"));
+	ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x200);
+	ODM_StallExecution(10);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("dbg\n"));
+	for (i=0;i<test_num;i++)
+	{	
+		for (tone_idx=0;tone_idx<Tone_lenth_1;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_1[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Main[tone_idx]  )
+				PSD_report_Main[tone_idx]+=PSD_report_temp;
+		}
+	}
+        //Antenna B
+       ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Aux-ant   (CH4)\n"));
+       ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x280);
+       ODM_StallExecution(10);	
+	for (i=0;i<test_num;i++)
+	{
+		for (tone_idx=0;tone_idx<Tone_lenth_1;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_1[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Aux[tone_idx]  )
+				PSD_report_Aux[tone_idx]+=PSD_report_temp;
+		}
+	}
+	//2 [ Doing PSD Function in (CH8)]
+
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0x0);	// 3 wire enable    88c[23:20]=0x0
+	ODM_StallExecution(3000);	
+	
+	ODM_SetBBReg(pDM_Odm, 0xc50, 0x7f, initial_gain);  
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, 0x7ff, 0x04);     // Set RF to CH8 & 40M
+	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0xf);	// 3 wire Disable    88c[23:20]=0xf
+	ODM_StallExecution(3000);
+
+        //Antenna A
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Main-ant   (CH8)\n"));
+	ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x200);
+	ODM_StallExecution(10);
+
+	for (i=0;i<test_num;i++)
+	{
+		for (tone_idx=0;tone_idx<Tone_lenth_2;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_2[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Main[tone_idx]  )
+				PSD_report_Main[Tone_lenth_1+tone_idx]+=PSD_report_temp;
+		}
+	}
+
+        //Antenna B
+        ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Aux-ant   (CH8)\n"));
+        ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x280);
+	ODM_StallExecution(10);	
+
+	for (i=0;i<test_num;i++)
+	{
+		for (tone_idx=0;tone_idx<Tone_lenth_2;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_2[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Aux[tone_idx]  )
+				PSD_report_Aux[Tone_lenth_1+tone_idx]+=PSD_report_temp;
+		}
+	}
+
+        //2 [ Calculate Result ]
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\nMain PSD Result: (ALL) \n"));
+	for (tone_idx=0;tone_idx<(Tone_lenth_1+Tone_lenth_2);tone_idx++)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Tone-%d]: %d, \n",(tone_idx+1), PSD_report_Main[tone_idx] ));
+		Main_psd_result+= PSD_report_Main[tone_idx];
+		if(PSD_report_Main[tone_idx]>MAX_PSD_report_Main)
+			MAX_PSD_report_Main=PSD_report_Main[tone_idx];
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("--------------------------- \nTotal_Main= (( %d ))\n", Main_psd_result));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("MAX_Main = (( %d ))\n", MAX_PSD_report_Main));
+	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\nAux PSD Result: (ALL) \n"));
+	for (tone_idx=0;tone_idx<(Tone_lenth_1+Tone_lenth_2);tone_idx++)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Tone-%d]: %d, \n",(tone_idx+1), PSD_report_Aux[tone_idx] ));
+		Aux_psd_result+= PSD_report_Aux[tone_idx];
+		if(PSD_report_Aux[tone_idx]>MAX_PSD_report_Aux)
+			MAX_PSD_report_Aux=PSD_report_Aux[tone_idx];
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("--------------------------- \nTotal_Aux= (( %d ))\n", Aux_psd_result));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("MAX_Aux = (( %d ))\n\n", MAX_PSD_report_Aux));
+		
+	//Main_psd_result=Main_psd_result-MAX_PSD_report_Main;
+	//Aux_psd_result=Aux_psd_result-MAX_PSD_report_Aux;
+	PSD_power_threshold=(Main_psd_result*7)>>3;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Main_result , Aux_result ] = [ %d , %d ], PSD_power_threshold=(( %d ))\n", Main_psd_result, Aux_psd_result,PSD_power_threshold));
+	
+	//3 [ Dual Antenna ]
+	 if(Aux_psd_result >= PSD_power_threshold   ) 
+	{
+		if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
+		{
+			pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+			pDM_Odm->DM_SWAT_Table.ANTB_ON = TRUE;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SwAntDivCheckBeforeLink(): Dual antenna\n"));
+		
+		// set bt coexDM from 1ant coexDM to 2ant coexDM
+		//BT_SetBtCoexAntNum(pAdapter, BT_COEX_ANT_TYPE_DETECTED, 2);
+					
+		// Init antenna diversity
+		pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV; 
+		ODM_AntDivInit(pDM_Odm);
+		}
+	//3 [ Single Antenna ]
+	else
+	{
+		if(pDM_Odm->DM_SWAT_Table.ANTB_ON == TRUE)
+		{
+			pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+			pDM_Odm->DM_SWAT_Table.ANTB_ON = FALSE;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
+	}
+
+	//2 [ Recover all parameters ]
+	
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,Channel_ori);	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0x0);	// 3 wire enable    88c[23:20]=0x0
+	ODM_SetBBReg(pDM_Odm, 0xc50, 0x7f, Regc50);  	
+	
+	ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
+	ODM_SetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord, Regb2c);
+
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1); //enable whole CCK block
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x0); //Turn on TX 	// Resume TX Queue
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, Regc14); // [ Set IQK Matrix = 0 ] equivalent to [ Turn on CCA]
+	ODM_SetBBReg(pDM_Odm, 0x908, bMaskDWord, Reg908); 
+	
+	return;
+
+}
+
+#endif
+void
+odm_SwAntDetectInit(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if(defined(CONFIG_ANT_DETECTION))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+	//pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ODM_Read4Byte(pDM_Odm, rDPDT_control);
+	//pDM_SWAT_Table->PreAntenna = MAIN_ANT;
+	//pDM_SWAT_Table->CurAntenna = MAIN_ANT;
+	pDM_SWAT_Table->SWAS_NoLink_State = 0;
+	pDM_SWAT_Table->Pre_Aux_FailDetec = FALSE;
+	pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 = 0xff;
+#endif
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.h
new file mode 100644
index 000000000..f3ccfad34
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdect.h
@@ -0,0 +1,98 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMANTDECT_H__
+#define    __PHYDMANTDECT_H__
+
+#define ANTDECT_VERSION	"2.0" //2014.11.04
+
+#if(defined(CONFIG_ANT_DETECTION))
+//#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN |ODM_CE))
+//ANT Test
+#define		ANTTESTALL		0x00	/*Ant A or B will be Testing*/   
+#define		ANTTESTA		0x01	/*Ant A will be Testing*/	
+#define		ANTTESTB		0x02	/*Ant B will be testing*/
+
+#define	MAX_ANTENNA_DETECTION_CNT	10 
+
+
+typedef struct _ANT_DETECTED_INFO{
+	BOOLEAN			bAntDetected;
+	u4Byte			dBForAntA;
+	u4Byte			dBForAntB;
+	u4Byte			dBForAntO;
+}ANT_DETECTED_INFO, *PANT_DETECTED_INFO;
+
+
+typedef enum tag_SW_Antenna_Switch_Definition
+{
+	Antenna_A = 1,
+	Antenna_B = 2,	
+	Antenna_MAX = 3,
+}DM_SWAS_E;
+
+
+
+//1 [1. Single Tone Method] ===================================================
+
+
+
+VOID
+ODM_SingleDualAntennaDefaultSetting(
+	IN		PVOID		pDM_VOID
+	);
+
+BOOLEAN
+ODM_SingleDualAntennaDetection(
+	IN		PVOID		pDM_VOID,
+	IN		u1Byte			mode
+	);
+
+//1 [2. Scan AP RSSI Method] ==================================================
+
+#define SwAntDivCheckBeforeLink	ODM_SwAntDivCheckBeforeLink
+
+BOOLEAN 
+ODM_SwAntDivCheckBeforeLink(
+	IN		PVOID		pDM_VOID
+	);
+
+
+
+
+//1 [3. PSD Method] ==========================================================
+
+
+VOID
+ODM_SingleDualAntennaDetection_PSD(
+	IN		PVOID		pDM_VOID
+);
+
+#endif
+
+VOID
+odm_SwAntDetectInit(
+	IN		PVOID		pDM_VOID
+	);
+
+
+#endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.c
new file mode 100644
index 000000000..a3757737f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.c
@@ -0,0 +1,4810 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+//======================================================
+// when antenna test utility is on or some testing need to disable antenna diversity
+// call this function to disable all ODM related mechanisms which will switch antenna.
+//======================================================
+VOID
+ODM_StopAntennaSwitchDm(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	// disable ODM antenna diversity
+	pDM_Odm->SupportAbility &= ~ODM_BB_ANT_DIV;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("STOP Antenna Diversity \n"));
+}
+
+VOID
+ODM_SetAntConfig(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte		antSetting	// 0=A, 1=B, 2=C, ....
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if(antSetting == 0)		// ant A
+			ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000000);
+		else if(antSetting == 1)
+			ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
+	}
+}
+
+//======================================================
+
+
+VOID
+ODM_SwAntDivRestAfterLink(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+	u4Byte             i;
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8723B|ODM_RTL8821)) {
+		pDM_SWAT_Table->try_flag = 0xff;
+		pDM_SWAT_Table->RSSI_Trying = 0;
+		pDM_SWAT_Table->Double_chk_flag= 0;
+		
+		pDM_FatTable->RxIdleAnt=MAIN_ANT;
+		
+		for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			pDM_FatTable->MainAnt_Sum[i] = 0;
+			pDM_FatTable->AuxAnt_Sum[i] = 0;
+			pDM_FatTable->MainAnt_Cnt[i] = 0;
+			pDM_FatTable->AuxAnt_Cnt[i] = 0;
+		}
+
+	}
+}
+
+
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+VOID
+odm_AntDiv_on_off( 
+	IN 	PVOID		pDM_VOID ,
+	IN 	u1Byte 		swch
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	
+	if(pDM_FatTable->AntDiv_OnOff != swch)
+	{
+		if(pDM_Odm->AntDivType==S0S1_SW_ANTDIV || pDM_Odm->AntDivType==CGCS_RX_SW_ANTDIV) 
+			return;
+
+		if(pDM_Odm->SupportICType & ODM_N_ANTDIV_SUPPORT)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) N-Series HW-AntDiv block\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
+			ODM_SetBBReg(pDM_Odm, 0xc50 , BIT7, swch); //OFDM AntDiv function block enable
+			ODM_SetBBReg(pDM_Odm, 0xa00 , BIT15, swch); //CCK AntDiv function block enable
+		}
+		else if(pDM_Odm->SupportICType & ODM_AC_ANTDIV_SUPPORT)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) AC-Series HW-AntDiv block\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
+			if (pDM_Odm->SupportICType == ODM_RTL8812) {
+				ODM_SetBBReg(pDM_Odm, 0xc50 , BIT7, swch); //OFDM AntDiv function block enable
+				ODM_SetBBReg(pDM_Odm, 0xa00 , BIT15, swch); //CCK AntDiv function block enable
+			} else {
+				ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, swch); //OFDM AntDiv function block enable
+				
+				if( (pDM_Odm->CutVersion >= ODM_CUT_C) && (pDM_Odm->SupportICType == ODM_RTL8821) && ( pDM_Odm->AntDivType != S0S1_SW_ANTDIV))
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) CCK HW-AntDiv block\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
+					ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, swch); 
+					ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, swch); //CCK AntDiv function block enable
+				}
+		        }
+		}
+	}
+	pDM_FatTable->AntDiv_OnOff =swch;
+	
+}
+
+VOID
+phydm_FastTraining_enable(
+	IN		PVOID		pDM_VOID, 
+	IN 		u1Byte  			swch
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			enable;
+
+	if (swch == FAT_ON)
+		enable=1;
+	else
+		enable=0;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Fast Ant Training_en = ((%d))\n", enable));
+
+	if (pDM_Odm->SupportICType == ODM_RTL8188E) {
+		ODM_SetBBReg(pDM_Odm, 0xe08 , BIT16, enable);	/*enable fast training*/
+		/**/
+	} else if (pDM_Odm->SupportICType == ODM_RTL8192E) {
+		ODM_SetBBReg(pDM_Odm, 0xB34 , BIT28, enable);	/*enable fast training (path-A)*/
+		/*ODM_SetBBReg(pDM_Odm, 0xB34 , BIT29, enable);*/	/*enable fast training (path-B)*/
+	} else if (pDM_Odm->SupportICType == ODM_RTL8821) {
+		ODM_SetBBReg(pDM_Odm, 0x900 , BIT19, enable);	/*enable fast training */
+		/**/
+	}
+}
+
+VOID
+odm_Tx_By_TxDesc_or_Reg( 
+	IN 		PVOID		pDM_VOID, 
+	IN 		u1Byte 			swch
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte enable;
+	
+	if( swch== TX_BY_DESC)
+		enable=1;
+	else
+		enable=0;
+
+	if(pDM_Odm->AntDivType != CGCS_RX_HW_ANTDIV)
+	{
+		if(pDM_Odm->SupportICType & ODM_N_ANTDIV_SUPPORT)
+		{
+				ODM_SetBBReg(pDM_Odm, 0x80c , BIT21, enable); 
+		}	
+		else if(pDM_Odm->SupportICType & ODM_AC_ANTDIV_SUPPORT)
+		{
+				ODM_SetBBReg(pDM_Odm, 0x900 , BIT18, enable); 
+		}
+	}
+}
+
+
+u1Byte
+phydm_traffic_load_decision( 
+	IN		PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u8Byte		curTxOkCnt = 0, curRxOkCnt = 0;
+	u1Byte		traffic;
+	
+	/*---trafic load decision---*/
+	curTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast) - pDM_SWAT_Table->lastTxOkCnt;
+	curRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast) - pDM_SWAT_Table->lastRxOkCnt;
+	pDM_SWAT_Table->lastTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast);
+	pDM_SWAT_Table->lastRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast);
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("TxOkCnt=(( %llu )), RxOkCnt=(( %llu ))\n", 
+		curTxOkCnt, curRxOkCnt));
+	
+	if (curTxOkCnt > 1875000 || curRxOkCnt > 1875000) {/*if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)  ( 1.875M * 8bit ) / 2= 7.5M bits /sec )*/
+	
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[HIGH Traffic]\n"));
+		traffic = TRAFFIC_HIGH;
+	} else if (curTxOkCnt > 300000 || curRxOkCnt > 300000) { /*( 0.3M * 8bit ) / 2 =  1.2M bits /sec )*/
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[MID Traffic]\n"));
+		traffic = TRAFFIC_MID;
+		
+	} else if (curTxOkCnt > 125000 || curRxOkCnt > 125000)  { /*( 0.125M * 8bit ) / 2 =  0.5M bits /sec )*/
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Low Traffic]\n"));
+		traffic = TRAFFIC_LOW;
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Ultra-Low Traffic]\n"));
+		traffic = TRAFFIC_ULTRA_LOW;
+	}
+	return traffic;
+}
+
+VOID
+ODM_UpdateRxIdleAnt(
+	IN 		PVOID 		pDM_VOID, 
+	IN 		u1Byte 		Ant
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	u4Byte	DefaultAnt, OptionalAnt,value32;
+
+	if(pDM_FatTable->RxIdleAnt != Ant)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] RxIdleAnt =%s\n",(Ant==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+
+		if(!(pDM_Odm->SupportICType & ODM_RTL8723B))
+                	pDM_FatTable->RxIdleAnt = Ant;
+
+		if(Ant == MAIN_ANT)
+		{
+			DefaultAnt   =  ANT1_2G; 
+			OptionalAnt =  ANT2_2G; 
+		}
+		else
+		{
+			DefaultAnt  =   ANT2_2G;
+			OptionalAnt =  ANT1_2G;
+		}
+	
+		if(pDM_Odm->SupportICType & ODM_N_ANTDIV_SUPPORT)
+		{
+			if(pDM_Odm->SupportICType==ODM_RTL8192E)
+			{
+				ODM_SetBBReg(pDM_Odm, 0xB38 , BIT5|BIT4|BIT3, DefaultAnt); //Default RX
+				ODM_SetBBReg(pDM_Odm, 0xB38 , BIT8|BIT7|BIT6, OptionalAnt);//Optional RX
+				ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt);//Default TX	
+			}
+			#if (RTL8723B_SUPPORT == 1)
+			else if(pDM_Odm->SupportICType==ODM_RTL8723B)
+			{
+				value32 = ODM_GetBBReg(pDM_Odm, 0x948, 0xFFF);
+			
+				if(value32 !=0x280)
+					ODM_UpdateRxIdleAnt_8723B(pDM_Odm, Ant, DefaultAnt, OptionalAnt);
+				else
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to 0x948 = 0x280\n"));
+			}
+			#endif
+			else //88E
+			{
+				ODM_SetBBReg(pDM_Odm, 0x864 , BIT5|BIT4|BIT3, DefaultAnt);	//Default RX
+				ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, OptionalAnt);	//Optional RX
+				ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt);	        //Default TX	
+			}
+		}
+		else if(pDM_Odm->SupportICType & ODM_AC_ANTDIV_SUPPORT)
+		{
+			u2Byte	value16 = ODM_Read2Byte(pDM_Odm, ODM_REG_TRMUX_11AC+2);
+			//
+			// 2014/01/14 MH/Luke.Lee Add direct write for register 0xc0a to prevnt 
+			// incorrect 0xc08 bit0-15 .We still not know why it is changed.
+			//
+			value16 &= ~(BIT11|BIT10|BIT9|BIT8|BIT7|BIT6|BIT5|BIT4|BIT3);
+			value16 |= ((u2Byte)DefaultAnt <<3);
+			value16 |= ((u2Byte)OptionalAnt <<6);
+			value16 |= ((u2Byte)DefaultAnt <<9);
+			ODM_Write2Byte(pDM_Odm, ODM_REG_TRMUX_11AC+2, value16);
+			/*
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC , BIT21|BIT20|BIT19, DefaultAnt);	 //Default RX
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC , BIT24|BIT23|BIT22, OptionalAnt);//Optional RX
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC , BIT27|BIT26|BIT25, DefaultAnt);	 //Default TX
+			*/
+		}
+
+		if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		{		
+			ODM_SetMACReg(pDM_Odm, 0x6D8 , BIT7|BIT6, DefaultAnt);	//PathA Resp Tx
+		}
+		else
+		{
+			ODM_SetMACReg(pDM_Odm, 0x6D8 , BIT10|BIT9|BIT8, DefaultAnt);	//PathA Resp Tx
+		}	
+
+	}
+	else// pDM_FatTable->RxIdleAnt == Ant
+        {
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Stay in Ori-Ant ]  RxIdleAnt =%s\n",(Ant==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+		pDM_FatTable->RxIdleAnt = Ant;
+	}
+}
+
+VOID
+odm_UpdateTxAnt(
+	IN 		PVOID 		pDM_VOID, 
+	IN 		u1Byte 		Ant, 
+	IN 		u4Byte 		MacId
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	u1Byte	TxAnt;
+
+	if (pDM_Odm->AntDivType==CG_TRX_SMART_ANTDIV)
+	{
+		TxAnt=Ant;
+	}
+	else
+	{
+        	if(Ant == MAIN_ANT)
+        		TxAnt = ANT1_2G;
+        	else
+        		TxAnt = ANT2_2G;
+	}
+	
+	pDM_FatTable->antsel_a[MacId] = TxAnt&BIT0;
+	pDM_FatTable->antsel_b[MacId] = (TxAnt&BIT1)>>1;
+	pDM_FatTable->antsel_c[MacId] = (TxAnt&BIT2)>>2;
+	
+	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Tx from TxInfo]: MacID:(( %d )),  TxAnt = (( %s ))\n", MacId,(Ant==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("antsel_tr_mux=(( 3'b%d%d%d ))\n",pDM_FatTable->antsel_c[MacId] , pDM_FatTable->antsel_b[MacId] , pDM_FatTable->antsel_a[MacId] ));
+	
+}
+
+#ifdef BEAMFORMING_SUPPORT
+#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+VOID
+odm_BDC_Init(
+	IN 		PVOID 		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pBDC_T	pDM_BdcTable=&pDM_Odm->DM_BdcTable;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n[ BDC Initialization......] \n"));
+	pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+	pDM_BdcTable->BDC_Mode=BDC_MODE_NULL;
+	pDM_BdcTable->BDC_Try_flag=0;
+	pDM_BdcTable->BDCcoexType_wBfer=0;
+	pDM_Odm->bdc_holdstate=0xff;
+	
+	if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		ODM_SetBBReg(pDM_Odm, 0xd7c , 0x0FFFFFFF, 0x1081008); 
+		ODM_SetBBReg(pDM_Odm, 0xd80 , 0x0FFFFFFF, 0); 
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x9b0 , 0x0FFFFFFF, 0x1081008);     //0x9b0[30:0] = 01081008
+		ODM_SetBBReg(pDM_Odm, 0x9b4 , 0x0FFFFFFF, 0);                 //0x9b4[31:0] = 00000000
+	}
+	
+}
+
+
+VOID
+odm_CSI_on_off(
+	IN 		PVOID 		pDM_VOID, 
+	IN 		u1Byte 			CSI_en
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(CSI_en==CSI_ON)
+	{
+		if(pDM_Odm->SupportICType == ODM_RTL8192E)
+		{
+			ODM_SetMACReg(pDM_Odm, 0xd84 , BIT11, 1);  //0xd84[11]=1
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8812)
+		{
+			ODM_SetMACReg(pDM_Odm, 0x9b0 , BIT31, 1);  //0x9b0[31]=1
+		}
+	
+	}
+	else if(CSI_en==CSI_OFF)
+	{
+		if(pDM_Odm->SupportICType == ODM_RTL8192E)
+		{
+			ODM_SetMACReg(pDM_Odm, 0xd84 , BIT11, 0);  //0xd84[11]=0
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8812)
+		{
+			ODM_SetMACReg(pDM_Odm, 0x9b0 , BIT31, 0);  //0x9b0[31]=0
+		}
+	}	
+}
+
+VOID
+odm_BDCcoexType_withBferClient(
+	IN 		PVOID 		pDM_VOID, 
+	IN 		u1Byte 			swch
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pBDC_T 	pDM_BdcTable = &pDM_Odm->DM_BdcTable;
+	u1Byte     BDCcoexType_wBfer;
+	
+	if(swch==DIVON_CSIOFF)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[BDCcoexType: 1] {DIV,CSI} ={1,0} \n"));
+		BDCcoexType_wBfer=1;
+
+		if(BDCcoexType_wBfer != pDM_BdcTable->BDCcoexType_wBfer)
+		{
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
+			odm_CSI_on_off(pDM_Odm,CSI_OFF);
+			pDM_BdcTable->BDCcoexType_wBfer=1;
+		}
+	}
+	else if(swch==DIVOFF_CSION)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[BDCcoexType: 2] {DIV,CSI} ={0,1}\n"));
+		BDCcoexType_wBfer=2;
+
+		if(BDCcoexType_wBfer != pDM_BdcTable->BDCcoexType_wBfer)
+		{
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+			odm_CSI_on_off(pDM_Odm,CSI_ON);
+			pDM_BdcTable->BDCcoexType_wBfer=2;
+		}
+	}
+}
+
+VOID
+odm_BF_AntDiv_ModeArbitration(
+	IN 		PVOID 		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pBDC_T 			pDM_BdcTable = &pDM_Odm->DM_BdcTable;
+	u1Byte			current_BDC_Mode;
+
+	#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n"));
+	
+		//2 Mode 1
+		if((pDM_BdcTable->num_Txbfee_Client !=0) && (pDM_BdcTable->num_Txbfer_Client == 0))
+		{
+			current_BDC_Mode=BDC_MODE_1;
+			
+			if(current_BDC_Mode != pDM_BdcTable->BDC_Mode)
+			{
+				pDM_BdcTable->BDC_Mode=BDC_MODE_1;
+				odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF);
+				pDM_BdcTable->BDC_RxIdleUpdate_counter=1;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Change to (( Mode1 ))\n"));
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Antdiv + BF coextance Mode] : (( Mode1 ))\n"));
+		}
+		//2 Mode 2
+		else if((pDM_BdcTable->num_Txbfee_Client ==0) && (pDM_BdcTable->num_Txbfer_Client != 0))
+		{
+			current_BDC_Mode=BDC_MODE_2;
+			
+			if(current_BDC_Mode != pDM_BdcTable->BDC_Mode)
+			{
+				pDM_BdcTable->BDC_Mode=BDC_MODE_2;
+				pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+				pDM_BdcTable->BDC_Try_flag=0;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Change to (( Mode2 ))\n"));
+				
+			}
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Antdiv + BF coextance Mode] : (( Mode2 ))\n"));
+		}
+		//2 Mode 3
+		else if((pDM_BdcTable->num_Txbfee_Client !=0) && (pDM_BdcTable->num_Txbfer_Client != 0))
+		{
+			current_BDC_Mode=BDC_MODE_3;
+			
+			if(current_BDC_Mode != pDM_BdcTable->BDC_Mode)
+			{
+				pDM_BdcTable->BDC_Mode=BDC_MODE_3;
+				pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+				pDM_BdcTable->BDC_Try_flag=0;
+				pDM_BdcTable->BDC_RxIdleUpdate_counter=1;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Change to (( Mode3 ))\n"));
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Antdiv + BF coextance Mode] : (( Mode3 ))\n"));
+		}
+		//2 Mode 4
+		else if((pDM_BdcTable->num_Txbfee_Client ==0) && (pDM_BdcTable->num_Txbfer_Client == 0))
+		{
+			current_BDC_Mode=BDC_MODE_4;
+			
+			if(current_BDC_Mode != pDM_BdcTable->BDC_Mode)
+			{
+				pDM_BdcTable->BDC_Mode=BDC_MODE_4;
+				odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Change to (( Mode4 ))\n"));
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Antdiv + BF coextance Mode] : (( Mode4 ))\n"));
+		}
+	#endif
+
+}
+
+VOID
+odm_DivTrainState_setting( 
+	IN		PVOID 		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pBDC_T	pDM_BdcTable=&pDM_Odm->DM_BdcTable;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n*****[S T A R T ]*****  [2-0. DIV_TRAIN_STATE] \n"));
+	pDM_BdcTable->BDC_Try_counter =2;
+	pDM_BdcTable->BDC_Try_flag=1; 
+	pDM_BdcTable->BDC_state=BDC_BFer_TRAIN_STATE;					
+	odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF);
+}
+
+VOID
+odm_BDCcoex_BFeeRxDiv_Arbitration(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pBDC_T    pDM_BdcTable = &pDM_Odm->DM_BdcTable;
+	BOOLEAN StopBF_flag;
+	u1Byte 	BDC_active_Mode;
+
+
+	#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***{ num_BFee,  num_BFer , num_Client}  = (( %d  ,  %d  ,  %d))  \n",pDM_BdcTable->num_Txbfee_Client,pDM_BdcTable->num_Txbfer_Client,pDM_BdcTable->num_Client));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***{ num_BF_tars,  num_DIV_tars }  = ((  %d  ,  %d ))  \n",pDM_BdcTable->num_BfTar , pDM_BdcTable->num_DivTar ));
+
+		//2 [ MIB control ]
+		if (pDM_Odm->bdc_holdstate==2) 
+		{
+			odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION); 
+			pDM_BdcTable->BDC_state=BDC_BF_HOLD_STATE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Force in [ BF STATE] \n"));
+			return;	
+		}
+		else if (pDM_Odm->bdc_holdstate==1) 
+		{
+			pDM_BdcTable->BDC_state=BDC_DIV_HOLD_STATE;
+			odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF); 
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Force in [ DIV STATE] \n"));
+			return;	
+		}
+
+		//------------------------------------------------------------
+
+
+		
+		//2 Mode 2 & 3
+		if(pDM_BdcTable->BDC_Mode==BDC_MODE_2 ||pDM_BdcTable->BDC_Mode==BDC_MODE_3)
+		{
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n{ Try_flag ,  Try_counter } = {  %d , %d  } \n",pDM_BdcTable->BDC_Try_flag,pDM_BdcTable->BDC_Try_counter));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BDCcoexType = (( %d ))  \n\n", pDM_BdcTable->BDCcoexType_wBfer));
+			
+                        // All Client have Bfer-Cap-------------------------------
+			if(pDM_BdcTable->num_Txbfer_Client == pDM_BdcTable->num_Client) //BFer STA Only?: yes
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BFer STA only?  (( Yes ))\n"));
+				pDM_BdcTable->BDC_Try_flag=0;
+				pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+				odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION);
+				return;
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BFer STA only?  (( No ))\n"));
+			}
+			//
+			if(pDM_BdcTable->bAll_BFSta_Idle==FALSE && pDM_BdcTable->bAll_DivSta_Idle==TRUE)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("All DIV-STA are idle, but BF-STA not\n"));
+				pDM_BdcTable->BDC_Try_flag=0;
+				pDM_BdcTable->BDC_state=BDC_BFer_TRAIN_STATE;
+				odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION);
+				return;
+			}
+			else if(pDM_BdcTable->bAll_BFSta_Idle==TRUE && pDM_BdcTable->bAll_DivSta_Idle==FALSE)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("All BF-STA are idle, but DIV-STA not\n"));
+				pDM_BdcTable->BDC_Try_flag=0;
+				pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+				odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF);
+				return;
+			}
+
+			//Select active mode--------------------------------------
+			if(pDM_BdcTable->num_BfTar ==0) //  Selsect_1,  Selsect_2
+			{
+				if(pDM_BdcTable->num_DivTar ==0)  // Selsect_3
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Select active mode (( 1 )) \n"));
+					pDM_BdcTable->BDC_active_Mode=1;
+				}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Select active mode  (( 2 ))\n"));
+					pDM_BdcTable->BDC_active_Mode=2;
+				}
+				pDM_BdcTable->BDC_Try_flag=0;
+				pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+				odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF);
+				return;
+			}
+			else // num_BfTar > 0
+			{			
+				if(pDM_BdcTable->num_DivTar ==0)  // Selsect_3
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Select active mode (( 3 ))\n"));		
+					pDM_BdcTable->BDC_active_Mode=3;
+					pDM_BdcTable->BDC_Try_flag=0;
+					pDM_BdcTable->BDC_state=BDC_BFer_TRAIN_STATE;
+					odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION);
+					return;
+				}
+				else // Selsect_4
+				{
+					BDC_active_Mode=4;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Select active mode (( 4 ))\n"));	
+					
+					if(BDC_active_Mode!=pDM_BdcTable->BDC_active_Mode)
+					{
+						pDM_BdcTable->BDC_active_Mode=4;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Change to active mode (( 4 ))  &  return!!! \n"));	
+						return;
+					}
+				}
+			}
+
+#if 1
+		if (pDM_Odm->bdc_holdstate==0xff) 
+		{
+			pDM_BdcTable->BDC_state=BDC_DIV_HOLD_STATE;
+			odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF); 
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Force in [ DIV STATE] \n"));	
+			return;
+		}
+#endif
+
+			// Does Client number changed ? -------------------------------
+			if(pDM_BdcTable->num_Client !=pDM_BdcTable->pre_num_Client)
+			{ 
+				pDM_BdcTable->BDC_Try_flag=0;
+				pDM_BdcTable->BDC_state=BDC_DIV_TRAIN_STATE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[  The number of client has been changed !!!]   return to (( BDC_DIV_TRAIN_STATE )) \n"));	
+			}
+			pDM_BdcTable->pre_num_Client=pDM_BdcTable->num_Client;
+
+			if( pDM_BdcTable->BDC_Try_flag==0)
+			{
+				//2 DIV_TRAIN_STATE (Mode 2-0)
+				if(pDM_BdcTable->BDC_state==BDC_DIV_TRAIN_STATE)
+				{
+					odm_DivTrainState_setting( pDM_Odm);
+				}
+				//2 BFer_TRAIN_STATE (Mode 2-1)
+				else if(pDM_BdcTable->BDC_state==BDC_BFer_TRAIN_STATE) 
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*****[2-1. BFer_TRAIN_STATE ]*****  \n"));
+					
+					//if(pDM_BdcTable->num_BfTar==0) 
+					//{
+					//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BF_tars exist?  : (( No )),   [ BDC_BFer_TRAIN_STATE ] >> [BDC_DIV_TRAIN_STATE] \n"));
+					//	odm_DivTrainState_setting( pDM_Odm);
+					//}
+					//else //num_BfTar != 0
+					//{
+						pDM_BdcTable->BDC_Try_counter=2;
+						pDM_BdcTable->BDC_Try_flag=1;
+						pDM_BdcTable->BDC_state=BDC_DECISION_STATE;
+						odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION); 
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BF_tars exist?  : (( Yes )),   [ BDC_BFer_TRAIN_STATE ] >> [BDC_DECISION_STATE] \n"));
+					//}
+				}
+				//2 DECISION_STATE (Mode 2-2)
+				else if(pDM_BdcTable->BDC_state==BDC_DECISION_STATE)
+				{			
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*****[2-2. DECISION_STATE]***** \n"));
+					//if(pDM_BdcTable->num_BfTar==0) 
+					//{
+					//	ODM_AntDiv_Printk(("BF_tars exist?  : (( No )),   [ DECISION_STATE ] >> [BDC_DIV_TRAIN_STATE] \n"));
+					//	odm_DivTrainState_setting( pDM_Odm);
+					//}
+					//else //num_BfTar != 0
+					//{
+						if(pDM_BdcTable->BF_pass==FALSE || pDM_BdcTable->DIV_pass == FALSE)
+							StopBF_flag=TRUE;
+						else
+							StopBF_flag=FALSE;
+						
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BF_tars exist?  : (( Yes )),  {BF_pass, DIV_pass, StopBF_flag }  = { %d, %d, %d } \n" ,pDM_BdcTable->BF_pass,pDM_BdcTable->DIV_pass,StopBF_flag));
+					
+						if(StopBF_flag==TRUE) //DIV_en
+						{
+							pDM_BdcTable->BDC_Hold_counter=10; //20
+							odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF); 
+							pDM_BdcTable->BDC_state=BDC_DIV_HOLD_STATE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ StopBF_flag= ((TRUE)),   BDC_DECISION_STATE ] >> [BDC_DIV_HOLD_STATE] \n"));
+						}
+						else //BF_en
+						{
+							pDM_BdcTable->BDC_Hold_counter=10; //20
+							odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION); 
+							pDM_BdcTable->BDC_state=BDC_BF_HOLD_STATE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[StopBF_flag= ((FALSE)),   BDC_DECISION_STATE ] >> [BDC_BF_HOLD_STATE] \n"));
+						}
+					//}
+				}
+				//2 BF-HOLD_STATE (Mode 2-3)
+				else if(pDM_BdcTable->BDC_state==BDC_BF_HOLD_STATE)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*****[2-3. BF_HOLD_STATE ]*****\n"));	
+
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BDC_Hold_counter = (( %d )) \n",pDM_BdcTable->BDC_Hold_counter ));	
+
+					if(pDM_BdcTable->BDC_Hold_counter==1)
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ BDC_BF_HOLD_STATE ] >> [BDC_DIV_TRAIN_STATE] \n"));	
+						odm_DivTrainState_setting( pDM_Odm);
+					}
+					else
+					{
+						pDM_BdcTable->BDC_Hold_counter--;
+						
+						//if(pDM_BdcTable->num_BfTar==0) 
+						//{
+						//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BF_tars exist?  : (( No )),   [ BDC_BF_HOLD_STATE ] >> [BDC_DIV_TRAIN_STATE] \n"));	
+						//	odm_DivTrainState_setting( pDM_Odm);
+						//}
+						//else //num_BfTar != 0
+						//{
+							//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BF_tars exist?  : (( Yes ))\n"));	
+							pDM_BdcTable->BDC_state=BDC_BF_HOLD_STATE;
+							odm_BDCcoexType_withBferClient( pDM_Odm, DIVOFF_CSION);
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ BDC_BF_HOLD_STATE ] >> [BDC_BF_HOLD_STATE] \n"));	
+						//}
+					}
+				
+				}
+				//2 DIV-HOLD_STATE (Mode 2-4)
+				else if(pDM_BdcTable->BDC_state==BDC_DIV_HOLD_STATE)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*****[2-4. DIV_HOLD_STATE ]*****\n"));	
+					
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("BDC_Hold_counter = (( %d )) \n",pDM_BdcTable->BDC_Hold_counter ));
+					
+					if(pDM_BdcTable->BDC_Hold_counter==1)
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ BDC_DIV_HOLD_STATE ] >> [BDC_DIV_TRAIN_STATE] \n"));	
+						odm_DivTrainState_setting( pDM_Odm);
+					}
+					else
+					{
+						pDM_BdcTable->BDC_Hold_counter--;
+						pDM_BdcTable->BDC_state=BDC_DIV_HOLD_STATE;
+						odm_BDCcoexType_withBferClient( pDM_Odm, DIVON_CSIOFF); 
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ BDC_DIV_HOLD_STATE ] >> [BDC_DIV_HOLD_STATE] \n"));	
+					}
+				
+				}
+				
+			}
+			else if( pDM_BdcTable->BDC_Try_flag==1)
+			{
+				//2 Set Training Counter
+				if(pDM_BdcTable->BDC_Try_counter >1)
+				{
+					pDM_BdcTable->BDC_Try_counter--;
+					if(pDM_BdcTable->BDC_Try_counter ==1)
+						pDM_BdcTable->BDC_Try_flag=0; 
+						
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Training !!\n"));
+					//return ;
+				}
+				
+			}
+			
+		}
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n[end]\n"));
+
+	#endif //#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
+
+
+
+
+	
+
+}
+
+#endif
+#endif //#ifdef BEAMFORMING_SUPPORT
+
+
+#if (RTL8188E_SUPPORT == 1)
+
+
+VOID
+odm_RX_HWAntDiv_Init_88E(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	value32;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+
+	if(pDM_Odm->mp_mode == TRUE)
+	{
+		pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
+		ODM_SetBBReg(pDM_Odm, ODM_REG_IGI_A_11N , BIT7, 0); // disable HW AntDiv 
+		ODM_SetBBReg(pDM_Odm, ODM_REG_LNA_SWITCH_11N , BIT31, 1);  // 1:CG, 0:CS
+        	return;
+	}
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8188E AntDiv_Init =>  AntDivType=[CGCS_RX_HW_ANTDIV]\n"));
+	
+	//MAC Setting
+	value32 = ODM_GetMACReg(pDM_Odm, ODM_REG_ANTSEL_PIN_11N, bMaskDWord);
+	ODM_SetMACReg(pDM_Odm, ODM_REG_ANTSEL_PIN_11N, bMaskDWord, value32|(BIT23|BIT25)); //Reg4C[25]=1, Reg4C[23]=1 for pin output
+	//Pin Settings
+	ODM_SetBBReg(pDM_Odm, ODM_REG_PIN_CTRL_11N , BIT9|BIT8, 0);//Reg870[8]=1'b0, Reg870[9]=1'b0 		//antsel antselb by HW
+	ODM_SetBBReg(pDM_Odm, ODM_REG_RX_ANT_CTRL_11N , BIT10, 0);	//Reg864[10]=1'b0 	//antsel2 by HW
+	ODM_SetBBReg(pDM_Odm, ODM_REG_LNA_SWITCH_11N , BIT22, 1);	//Regb2c[22]=1'b0 	//disable CS/CG switch
+	ODM_SetBBReg(pDM_Odm, ODM_REG_LNA_SWITCH_11N , BIT31, 1);	//Regb2c[31]=1'b1	//output at CG only
+	//OFDM Settings
+	ODM_SetBBReg(pDM_Odm, ODM_REG_ANTDIV_PARA1_11N , bMaskDWord, 0x000000a0);
+	//CCK Settings
+	ODM_SetBBReg(pDM_Odm, ODM_REG_BB_PWR_SAV4_11N , BIT7, 1); //Fix CCK PHY status report issue
+	ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_ANTDIV_PARA2_11N , BIT4, 1); //CCK complete HW AntDiv within 64 samples	
+	
+	ODM_SetBBReg(pDM_Odm, ODM_REG_ANT_MAPPING1_11N , 0xFFFF, 0x0001);	//antenna mapping table
+
+	pDM_FatTable->enable_ctrl_frame_antdiv = 1;
+}
+
+VOID
+odm_TRX_HWAntDiv_Init_88E(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	value32;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	
+	if(pDM_Odm->mp_mode == TRUE)
+	{
+		pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
+		ODM_SetBBReg(pDM_Odm, ODM_REG_IGI_A_11N , BIT7, 0); // disable HW AntDiv 
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RX_ANT_CTRL_11N , BIT5|BIT4|BIT3, 0); //Default RX   (0/1)
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8188E AntDiv_Init =>  AntDivType=[CG_TRX_HW_ANTDIV (SPDT)]\n"));
+	
+	//MAC Setting
+	value32 = ODM_GetMACReg(pDM_Odm, ODM_REG_ANTSEL_PIN_11N, bMaskDWord);
+	ODM_SetMACReg(pDM_Odm, ODM_REG_ANTSEL_PIN_11N, bMaskDWord, value32|(BIT23|BIT25)); //Reg4C[25]=1, Reg4C[23]=1 for pin output
+	//Pin Settings
+	ODM_SetBBReg(pDM_Odm, ODM_REG_PIN_CTRL_11N , BIT9|BIT8, 0);//Reg870[8]=1'b0, Reg870[9]=1'b0 		//antsel antselb by HW
+	ODM_SetBBReg(pDM_Odm, ODM_REG_RX_ANT_CTRL_11N , BIT10, 0);	//Reg864[10]=1'b0 	//antsel2 by HW
+	ODM_SetBBReg(pDM_Odm, ODM_REG_LNA_SWITCH_11N , BIT22, 0);	//Regb2c[22]=1'b0 	//disable CS/CG switch
+	ODM_SetBBReg(pDM_Odm, ODM_REG_LNA_SWITCH_11N , BIT31, 1);	//Regb2c[31]=1'b1	//output at CG only
+	//OFDM Settings
+	ODM_SetBBReg(pDM_Odm, ODM_REG_ANTDIV_PARA1_11N , bMaskDWord, 0x000000a0);
+	//CCK Settings
+	ODM_SetBBReg(pDM_Odm, ODM_REG_BB_PWR_SAV4_11N , BIT7, 1); //Fix CCK PHY status report issue
+	ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_ANTDIV_PARA2_11N , BIT4, 1); //CCK complete HW AntDiv within 64 samples
+
+	//antenna mapping table
+	if(!pDM_Odm->bIsMPChip) //testchip
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RX_DEFUALT_A_11N , BIT10|BIT9|BIT8, 1);	//Reg858[10:8]=3'b001
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RX_DEFUALT_A_11N , BIT13|BIT12|BIT11, 2);	//Reg858[13:11]=3'b010
+	}
+	else //MPchip
+		ODM_SetBBReg(pDM_Odm, ODM_REG_ANT_MAPPING1_11N , bMaskDWord, 0x0201);	/*Reg914=3'b010, Reg915=3'b001*/
+
+	pDM_FatTable->enable_ctrl_frame_antdiv = 1;
+}
+
+
+#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+VOID
+odm_Smart_HWAntDiv_Init_88E(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	value32, i;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8188E AntDiv_Init =>  AntDivType=[CG_TRX_SMART_ANTDIV]\n"));
+    
+	if(pDM_Odm->mp_mode == TRUE)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("pDM_Odm->AntDivType: %d\n", pDM_Odm->AntDivType));
+		return;
+	}
+
+	pDM_FatTable->TrainIdx = 0;
+	pDM_FatTable->FAT_State = FAT_PREPARE_STATE;
+	
+	pDM_Odm->fat_comb_a=5;
+	pDM_Odm->antdiv_intvl = 0x64; // 100ms
+
+	for(i=0; i<6; i++)
+	{
+		pDM_FatTable->Bssid[i] = 0;
+	}
+	for(i=0; i< (pDM_Odm->fat_comb_a) ; i++)
+	{
+		pDM_FatTable->antSumRSSI[i] = 0;
+		pDM_FatTable->antRSSIcnt[i] = 0;
+		pDM_FatTable->antAveRSSI[i] = 0;
+	}
+
+	//MAC Setting
+	value32 = ODM_GetMACReg(pDM_Odm, 0x4c, bMaskDWord);
+	ODM_SetMACReg(pDM_Odm, 0x4c, bMaskDWord, value32|(BIT23|BIT25)); //Reg4C[25]=1, Reg4C[23]=1 for pin output
+	value32 = ODM_GetMACReg(pDM_Odm,  0x7B4, bMaskDWord);
+	ODM_SetMACReg(pDM_Odm, 0x7b4, bMaskDWord, value32|(BIT16|BIT17)); //Reg7B4[16]=1 enable antenna training, Reg7B4[17]=1 enable A2 match
+	//value32 = PlatformEFIORead4Byte(Adapter, 0x7B4);
+	//PlatformEFIOWrite4Byte(Adapter, 0x7b4, value32|BIT18);	//append MACID in reponse packet
+
+	//Match MAC ADDR
+	ODM_SetMACReg(pDM_Odm, 0x7b4, 0xFFFF, 0);
+	ODM_SetMACReg(pDM_Odm, 0x7b0, bMaskDWord, 0);
+	
+	ODM_SetBBReg(pDM_Odm, 0x870 , BIT9|BIT8, 0);//Reg870[8]=1'b0, Reg870[9]=1'b0 		//antsel antselb by HW
+	ODM_SetBBReg(pDM_Odm, 0x864 , BIT10, 0);	//Reg864[10]=1'b0 	//antsel2 by HW
+	ODM_SetBBReg(pDM_Odm, 0xb2c , BIT22, 0);	//Regb2c[22]=1'b0 	//disable CS/CG switch
+	ODM_SetBBReg(pDM_Odm, 0xb2c , BIT31, 0);	//Regb2c[31]=1'b1	//output at CS only
+	ODM_SetBBReg(pDM_Odm, 0xca4 , bMaskDWord, 0x000000a0);
+	
+	//antenna mapping table
+	if(pDM_Odm->fat_comb_a == 2)
+	{
+		if(!pDM_Odm->bIsMPChip) //testchip
+		{
+			ODM_SetBBReg(pDM_Odm, 0x858 , BIT10|BIT9|BIT8, 1);	//Reg858[10:8]=3'b001
+			ODM_SetBBReg(pDM_Odm, 0x858 , BIT13|BIT12|BIT11, 2);	//Reg858[13:11]=3'b010
+		}
+		else //MPchip
+		{
+			ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte0, 1);
+			ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte1, 2);
+		}
+	}
+	else
+	{
+		if(!pDM_Odm->bIsMPChip) //testchip
+		{
+			ODM_SetBBReg(pDM_Odm, 0x858 , BIT10|BIT9|BIT8, 0);	//Reg858[10:8]=3'b000
+			ODM_SetBBReg(pDM_Odm, 0x858 , BIT13|BIT12|BIT11, 1);	//Reg858[13:11]=3'b001
+			ODM_SetBBReg(pDM_Odm, 0x878 , BIT16, 0);
+			ODM_SetBBReg(pDM_Odm, 0x858 , BIT15|BIT14, 2);	//(Reg878[0],Reg858[14:15])=3'b010
+			ODM_SetBBReg(pDM_Odm, 0x878 , BIT19|BIT18|BIT17, 3);//Reg878[3:1]=3b'011
+			ODM_SetBBReg(pDM_Odm, 0x878 , BIT22|BIT21|BIT20, 4);//Reg878[6:4]=3b'100
+			ODM_SetBBReg(pDM_Odm, 0x878 , BIT25|BIT24|BIT23, 5);//Reg878[9:7]=3b'101 
+			ODM_SetBBReg(pDM_Odm, 0x878 , BIT28|BIT27|BIT26, 6);//Reg878[12:10]=3b'110 
+			ODM_SetBBReg(pDM_Odm, 0x878 , BIT31|BIT30|BIT29, 7);//Reg878[15:13]=3b'111
+		}
+		else //MPchip
+		{
+			ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte0, 4);     // 0: 3b'000
+			ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte1, 2);     // 1: 3b'001	
+			ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte2, 0);     // 2: 3b'010
+			ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte3, 1);     // 3: 3b'011
+			ODM_SetBBReg(pDM_Odm, 0x918 , bMaskByte0, 3);     // 4: 3b'100
+			ODM_SetBBReg(pDM_Odm, 0x918 , bMaskByte1, 5);     // 5: 3b'101
+			ODM_SetBBReg(pDM_Odm, 0x918 , bMaskByte2, 6);     // 6: 3b'110
+			ODM_SetBBReg(pDM_Odm, 0x918 , bMaskByte3, 255); // 7: 3b'111
+		}
+	}
+
+	//Default Ant Setting when no fast training
+	ODM_SetBBReg(pDM_Odm, 0x864 , BIT5|BIT4|BIT3, 0);	//Default RX
+	ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, 1);	//Optional RX
+	ODM_SetBBReg(pDM_Odm, 0x860 , BIT14|BIT13|BIT12, 0);//Default TX
+
+	//Enter Traing state
+	ODM_SetBBReg(pDM_Odm, 0x864 , BIT2|BIT1|BIT0, (pDM_Odm->fat_comb_a-1));	//Reg864[2:0]=3'd6	//ant combination=reg864[2:0]+1
+
+	//SW Control
+	//PHY_SetBBReg(Adapter, 0x864 , BIT10, 1);
+	//PHY_SetBBReg(Adapter, 0x870 , BIT9, 1);
+	//PHY_SetBBReg(Adapter, 0x870 , BIT8, 1);
+	//PHY_SetBBReg(Adapter, 0x864 , BIT11, 1);
+	//PHY_SetBBReg(Adapter, 0x860 , BIT9, 0);
+	//PHY_SetBBReg(Adapter, 0x860 , BIT8, 0);
+}
+#endif
+
+#endif //#if (RTL8188E_SUPPORT == 1)
+
+
+#if (RTL8192E_SUPPORT == 1)
+VOID
+odm_RX_HWAntDiv_Init_92E(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	
+	if(pDM_Odm->mp_mode == TRUE)
+	{
+		//pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
+		odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+		ODM_SetBBReg(pDM_Odm, 0xc50 , BIT8, 0); //r_rxdiv_enable_anta  Regc50[8]=1'b0  0: control by c50[9]
+		ODM_SetBBReg(pDM_Odm, 0xc50 , BIT9, 1);  // 1:CG, 0:CS
+		return;
+	}
+	
+	 ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8192E AntDiv_Init =>  AntDivType=[CGCS_RX_HW_ANTDIV]\n"));
+	
+	 //Pin Settings
+	 ODM_SetBBReg(pDM_Odm, 0x870 , BIT8, 0);//Reg870[8]=1'b0,    // "antsel" is controled by HWs
+	 ODM_SetBBReg(pDM_Odm, 0xc50 , BIT8, 1); //Regc50[8]=1'b1  //" CS/CG switching" is controled by HWs
+
+	 //Mapping table
+	 ODM_SetBBReg(pDM_Odm, 0x914 , 0xFFFF, 0x0100); //antenna mapping table
+	  
+	 //OFDM Settings
+	 ODM_SetBBReg(pDM_Odm, 0xca4 , 0x7FF, 0xA0); //thershold
+	 ODM_SetBBReg(pDM_Odm, 0xca4 , 0x7FF000, 0x0); //bias
+	 
+	 //CCK Settings
+	 ODM_SetBBReg(pDM_Odm, 0xa04 , 0xF000000, 0); //Select which path to receive for CCK_1 & CCK_2
+	 ODM_SetBBReg(pDM_Odm, 0xb34 , BIT30, 0); //(92E) ANTSEL_CCK_opt = r_en_antsel_cck? ANTSEL_CCK: 1'b0
+	 ODM_SetBBReg(pDM_Odm, 0xa74 , BIT7, 1); //Fix CCK PHY status report issue
+	 ODM_SetBBReg(pDM_Odm, 0xa0c , BIT4, 1); //CCK complete HW AntDiv within 64 samples 	 
+	 
+	 #ifdef ODM_EVM_ENHANCE_ANTDIV
+	//EVM enhance AntDiv method init----------------------------------------------------------------------
+	pDM_FatTable->EVM_method_enable=0;
+	pDM_FatTable->FAT_State = NORMAL_STATE_MIAN;
+	pDM_Odm->antdiv_intvl = 0x64; 
+	ODM_SetBBReg(pDM_Odm, 0x910 , 0x3f, 0xf );	   
+	pDM_Odm->antdiv_evm_en=1;
+	//pDM_Odm->antdiv_period=1;
+
+	#endif
+	 
+}
+
+VOID
+odm_TRX_HWAntDiv_Init_92E(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	
+	if(pDM_Odm->mp_mode == TRUE)
+	{
+		//pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
+		odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+		ODM_SetBBReg(pDM_Odm, 0xc50 , BIT8, 0); //r_rxdiv_enable_anta  Regc50[8]=1'b0  0: control by c50[9]
+		ODM_SetBBReg(pDM_Odm, 0xc50 , BIT9, 1);  // 1:CG, 0:CS
+		return;
+	}
+
+	 ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8192E AntDiv_Init =>  AntDivType=[ Only for DIR605, CG_TRX_HW_ANTDIV]\n"));
+	
+	//3 --RFE pin setting---------
+	//[MAC]
+	ODM_SetMACReg(pDM_Odm, 0x38, BIT11, 1);            //DBG PAD Driving control (GPIO 8)
+	ODM_SetMACReg(pDM_Odm, 0x4c, BIT23, 0);            //path-A , RFE_CTRL_3 
+	ODM_SetMACReg(pDM_Odm, 0x4c, BIT29, 1);            //path-A , RFE_CTRL_8
+	//[BB]
+	ODM_SetBBReg(pDM_Odm, 0x944 , BIT3, 1);              //RFE_buffer
+	ODM_SetBBReg(pDM_Odm, 0x944 , BIT8, 1);	
+	ODM_SetBBReg(pDM_Odm, 0x940 , BIT7|BIT6, 0x0); // r_rfe_path_sel_   (RFE_CTRL_3)
+	ODM_SetBBReg(pDM_Odm, 0x940 , BIT17|BIT16, 0x0); // r_rfe_path_sel_   (RFE_CTRL_8)
+	ODM_SetBBReg(pDM_Odm, 0x944 , BIT31, 0);     //RFE_buffer
+	ODM_SetBBReg(pDM_Odm, 0x92C , BIT3, 0);     //rfe_inv  (RFE_CTRL_3)
+	ODM_SetBBReg(pDM_Odm, 0x92C , BIT8, 1);     //rfe_inv  (RFE_CTRL_8)
+	ODM_SetBBReg(pDM_Odm, 0x930 , 0xF000, 0x8);           //path-A , RFE_CTRL_3 
+	ODM_SetBBReg(pDM_Odm, 0x934 , 0xF, 0x8);           //path-A , RFE_CTRL_8
+	//3 -------------------------
+	
+	 //Pin Settings
+	ODM_SetBBReg(pDM_Odm, 0xC50 , BIT8, 0);	   //path-A   	//disable CS/CG switch
+
+/* Let it follows PHY_REG for bit9 setting
+	if(pDM_Odm->priv->pshare->rf_ft_var.use_ext_pa || pDM_Odm->priv->pshare->rf_ft_var.use_ext_lna)
+		ODM_SetBBReg(pDM_Odm, 0xC50 , BIT9, 1);//path-A 	//output at CS
+	else
+		ODM_SetBBReg(pDM_Odm, 0xC50 , BIT9, 0);    //path-A 	//output at CG ->normal power
+*/
+
+	ODM_SetBBReg(pDM_Odm, 0x870 , BIT9|BIT8, 0);  //path-A  	//antsel antselb by HW
+	ODM_SetBBReg(pDM_Odm, 0xB38 , BIT10, 0);	   //path-A    	//antsel2 by HW	
+ 
+	//Mapping table
+	 ODM_SetBBReg(pDM_Odm, 0x914 , 0xFFFF, 0x0100); //antenna mapping table
+	  
+	 //OFDM Settings
+	 ODM_SetBBReg(pDM_Odm, 0xca4 , 0x7FF, 0xA0); //thershold
+	 ODM_SetBBReg(pDM_Odm, 0xca4 , 0x7FF000, 0x0); //bias
+	 
+	 //CCK Settings
+	 ODM_SetBBReg(pDM_Odm, 0xa04 , 0xF000000, 0); //Select which path to receive for CCK_1 & CCK_2
+	 ODM_SetBBReg(pDM_Odm, 0xb34 , BIT30, 0); //(92E) ANTSEL_CCK_opt = r_en_antsel_cck? ANTSEL_CCK: 1'b0
+	 ODM_SetBBReg(pDM_Odm, 0xa74 , BIT7, 1); //Fix CCK PHY status report issue
+	 ODM_SetBBReg(pDM_Odm, 0xa0c , BIT4, 1); //CCK complete HW AntDiv within 64 samples 
+
+	 //Timming issue
+	 ODM_SetBBReg(pDM_Odm, 0xE20 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+
+	#ifdef ODM_EVM_ENHANCE_ANTDIV
+	//EVM enhance AntDiv method init----------------------------------------------------------------------
+	pDM_FatTable->EVM_method_enable=0;
+	pDM_FatTable->FAT_State = NORMAL_STATE_MIAN;
+	pDM_Odm->antdiv_intvl = 0x64; 
+	ODM_SetBBReg(pDM_Odm, 0x910 , 0x3f, 0xf );	   
+	pDM_Odm->antdiv_evm_en=1;
+	//pDM_Odm->antdiv_period=1;
+	#endif
+}
+
+#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+VOID
+odm_Smart_HWAntDiv_Init_92E(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8192E AntDiv_Init =>  AntDivType=[CG_TRX_SMART_ANTDIV]\n"));
+}
+#endif
+
+#endif //#if (RTL8192E_SUPPORT == 1)
+
+
+#if (RTL8723B_SUPPORT == 1)
+VOID
+odm_TRX_HWAntDiv_Init_8723B(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8723B AntDiv_Init =>  AntDivType=[CG_TRX_HW_ANTDIV(DPDT)]\n"));
+      
+	//Mapping Table
+	ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte0, 0);
+	ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte1, 1);
+	
+	//OFDM HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , 0x7FF, 0xa0); //thershold
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , 0x7FF000, 0x00); //bias
+		
+	//CCK HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
+	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
+	
+	//BT Coexistence
+	ODM_SetBBReg(pDM_Odm, 0x864, BIT12, 0); //keep antsel_map when GNT_BT = 1
+	ODM_SetBBReg(pDM_Odm, 0x874 , BIT23, 0); //Disable hw antsw & fast_train.antsw when GNT_BT=1
+
+        //Output Pin Settings
+	ODM_SetBBReg(pDM_Odm, 0x870 , BIT8, 0); //
+		
+	ODM_SetBBReg(pDM_Odm, 0x948 , BIT6, 0); //WL_BB_SEL_BTG_TRXG_anta,  (1: HW CTRL  0: SW CTRL)
+	ODM_SetBBReg(pDM_Odm, 0x948 , BIT7, 0);
+		
+	ODM_SetMACReg(pDM_Odm, 0x40 , BIT3, 1);
+	ODM_SetMACReg(pDM_Odm, 0x38 , BIT11, 1);
+	ODM_SetMACReg(pDM_Odm, 0x4C ,  BIT24|BIT23, 2); //select DPDT_P and DPDT_N as output pin
+		
+	ODM_SetBBReg(pDM_Odm, 0x944 , BIT0|BIT1, 3); //in/out
+	ODM_SetBBReg(pDM_Odm, 0x944 , BIT31, 0); //
+
+	ODM_SetBBReg(pDM_Odm, 0x92C , BIT1, 0); //DPDT_P non-inverse
+	ODM_SetBBReg(pDM_Odm, 0x92C , BIT0, 1); //DPDT_N inverse
+
+	ODM_SetBBReg(pDM_Odm, 0x930 , 0xF0, 8); // DPDT_P = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0x930 , 0xF, 8); // DPDT_N = ANTSEL[0]
+
+	//Timming issue
+	ODM_SetBBReg(pDM_Odm, 0xE20 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+
+	//2 [--For HW Bug Setting]
+	if(pDM_Odm->AntType == ODM_AUTO_ANT)
+		ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function block enable
+
+}
+
+	
+
+VOID
+odm_S0S1_SWAntDiv_Init_8723B(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8723B AntDiv_Init => AntDivType=[ S0S1_SW_AntDiv] \n"));
+
+	//Mapping Table
+	ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte0, 0);
+	ODM_SetBBReg(pDM_Odm, 0x914 , bMaskByte1, 1);
+	
+	//Output Pin Settings
+	//ODM_SetBBReg(pDM_Odm, 0x948 , BIT6, 0x1); 
+	ODM_SetBBReg(pDM_Odm, 0x870 , BIT9|BIT8, 0); 
+
+	pDM_FatTable->bBecomeLinked  =FALSE;
+	pDM_SWAT_Table->try_flag = 0xff;	
+	pDM_SWAT_Table->Double_chk_flag = 0;
+	pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
+
+	//Timming issue
+	ODM_SetBBReg(pDM_Odm, 0xE20 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+	
+	//2 [--For HW Bug Setting]
+	ODM_SetBBReg(pDM_Odm, 0x80C , BIT21, 0); //TX Ant  by Reg
+
+}
+
+VOID
+odm_S0S1_SWAntDiv_Reset_8723B(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table 	= &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable 	= &pDM_Odm->DM_FatTable;
+    
+	pDM_FatTable->bBecomeLinked  =FALSE;
+	pDM_SWAT_Table->try_flag = 0xff;	
+	pDM_SWAT_Table->Double_chk_flag = 0;
+	pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_S0S1_SWAntDiv_Reset_8723B(): pDM_FatTable->bBecomeLinked = %d\n", pDM_FatTable->bBecomeLinked));
+}
+
+VOID
+ODM_UpdateRxIdleAnt_8723B(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Ant,
+	IN		u4Byte			DefaultAnt, 
+	IN		u4Byte			OptionalAnt
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	PADAPTER 		pAdapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u1Byte			count=0;
+	u1Byte			u1Temp;
+	u1Byte			H2C_Parameter;
+	
+	if(!pDM_Odm->bLinked)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to no link\n"));
+		return;
+	}
+
+#if 0
+	// Send H2C command to FW
+	// Enable wifi calibration
+	H2C_Parameter = TRUE;
+	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_WIFI_CALIBRATION, 1, &H2C_Parameter);
+
+	// Check if H2C command sucess or not (0x1e6)
+	u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e6);
+	while((u1Temp != 0x1) && (count < 100))
+	{
+		ODM_delay_us(10);	
+		u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e6);
+		count++;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: H2C command status = %d, count = %d\n", u1Temp, count));
+
+	if(u1Temp == 0x1)
+	{
+		// Check if BT is doing IQK (0x1e7)
+		count = 0;
+		u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e7);
+		while((!(u1Temp & BIT0))  && (count < 100))
+		{
+			ODM_delay_us(50);	
+			u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e7);
+			count++;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: BT IQK status = %d, count = %d\n", u1Temp, count));
+
+		if(u1Temp & BIT0)
+		{
+			ODM_SetBBReg(pDM_Odm, 0x948 , BIT6, 0x1);
+			ODM_SetBBReg(pDM_Odm, 0x948 , BIT9, DefaultAnt);	
+			ODM_SetBBReg(pDM_Odm, 0x864 , BIT5|BIT4|BIT3, DefaultAnt);	//Default RX
+			ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, OptionalAnt);	//Optional RX
+			ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt); //Default TX	
+			pDM_FatTable->RxIdleAnt = Ant;
+
+			// Set TX AGC by S0/S1
+			// Need to consider Linux driver
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			 pAdapter->HalFunc.SetTxPowerLevelHandler(pAdapter, pHalData->CurrentChannel);
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+			rtw_hal_set_tx_power_level(pAdapter, pHalData->CurrentChannel);
+#endif
+
+			// Set IQC by S0/S1
+			ODM_SetIQCbyRFpath(pDM_Odm,DefaultAnt);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Sucess to set RX antenna\n"));
+		}
+		else
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to BT IQK\n"));
+	}
+	else
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to H2C command fail\n"));
+
+	// Send H2C command to FW
+	// Disable wifi calibration
+	H2C_Parameter = FALSE;
+	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_WIFI_CALIBRATION, 1, &H2C_Parameter);
+#else
+		ODM_SetBBReg(pDM_Odm, 0x948 , BIT6, 0x1);
+		ODM_SetBBReg(pDM_Odm, 0x948 , BIT9, DefaultAnt);	
+	ODM_SetBBReg(pDM_Odm, 0x864 , BIT5|BIT4|BIT3, DefaultAnt);          /*Default RX*/
+	ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, OptionalAnt);         /*Optional RX*/
+	ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt);        /*Default TX*/
+		pDM_FatTable->RxIdleAnt = Ant;
+
+	/* Set TX AGC by S0/S1 */
+	/* Need to consider Linux driver */
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		 pAdapter->HalFunc.SetTxPowerLevelHandler(pAdapter, pHalData->CurrentChannel);
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+		rtw_hal_set_tx_power_level(pAdapter, pHalData->CurrentChannel);
+#endif
+
+	/* Set IQC by S0/S1 */
+	ODM_SetIQCbyRFpath(pDM_Odm, DefaultAnt);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Success to set RX antenna\n"));
+
+#endif
+}
+
+BOOLEAN
+phydm_IsBtEnable_8723b(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			bt_state;
+	/*u4Byte			reg75;*/
+
+	/*reg75 = ODM_GetBBReg(pDM_Odm, 0x74 , BIT8);*/
+	/*ODM_SetBBReg(pDM_Odm, 0x74 , BIT8, 0x0);*/
+	ODM_SetBBReg(pDM_Odm, 0xa0 , BIT24|BIT25|BIT26, 0x5);
+	bt_state = ODM_GetBBReg(pDM_Odm, 0xa0 , (BIT3|BIT2|BIT1|BIT0));
+	/*ODM_SetBBReg(pDM_Odm, 0x74 , BIT8, reg75);*/
+
+	if ((bt_state == 4) || (bt_state == 7) || (bt_state == 9) || (bt_state == 13))
+		return TRUE;
+	else
+		return FALSE;
+}
+
+#else /*#if (RTL8723B_SUPPORT == 1)*/
+VOID
+ODM_UpdateRxIdleAnt_8723B(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Ant,
+	IN		u4Byte			DefaultAnt, 
+	IN		u4Byte			OptionalAnt
+	){}
+
+#endif //#if (RTL8723B_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+VOID
+phydm_hl_smart_ant_type1_init_8821a(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	u4Byte			value32;
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8821A SmartAnt_Init => AntDivType=[Hong-Lin Smart Ant Type1]\n"));
+	
+	/*----------------------------------------
+	GPIO 2-3 for Beam control 
+	    reg0x66[2]=0
+	    reg0x44[27:26] = 0
+	    reg0x44[23:16] //enable_output for P_GPIO[7:0]
+	    reg0x44[15:8] //output_value for P_GPIO[7:0]
+	    reg0x40[1:0] = 0 //GPIO function
+	------------------------------------------*/
+	
+	/*GPIO Setting*/
+	ODM_SetMACReg(pDM_Odm, 0x64 , BIT18, 0); 
+	ODM_SetMACReg(pDM_Odm, 0x44 , BIT27|BIT26, 0);
+	ODM_SetMACReg(pDM_Odm, 0x44 , BIT19|BIT18, 0x3);	/*enable_output for P_GPIO[3:2]*/
+	/*ODM_SetMACReg(pDM_Odm, 0x44 , BIT11|BIT10, 0);*/ /*output value*/
+	ODM_SetMACReg(pDM_Odm, 0x40 , BIT1|BIT0, 0);		/*GPIO function*/
+
+	/*Hong_lin smart antenna HW Setting*/
+	pdm_sat_table->data_codeword_bit_num  = 24;/*max=32*/
+	pdm_sat_table->beam_patten_num_each_ant = 4;
+
+	#if DEV_BUS_TYPE == RT_SDIO_INTERFACE
+	pdm_sat_table->latch_time = 100; /*mu sec*/
+	#elif DEV_BUS_TYPE == RT_USB_INTERFACE
+	pdm_sat_table->latch_time = 100; /*mu sec*/
+	#endif
+	pdm_sat_table->pkt_skip_statistic_en = 0;
+	
+	pdm_sat_table->ant_num  = 2;/*max=8*/
+
+	pdm_sat_table->fix_beam_pattern_en  = 0;
+	pdm_sat_table->decision_holding_period = 0;
+
+	/*beam training setting*/
+	pdm_sat_table->pkt_counter = 0;
+	pdm_sat_table->per_beam_training_pkt_num = 10;
+
+	/*set default beam*/
+	pdm_sat_table->fast_training_beam_num = 0;
+	pdm_sat_table->pre_fast_training_beam_num = pdm_sat_table->fast_training_beam_num;
+	phydm_set_all_ant_same_beam_num(pDM_Odm);
+
+	pDM_FatTable->FAT_State = FAT_BEFORE_LINK_STATE;
+
+	/*[BB] FAT Setting*/
+	ODM_SetBBReg(pDM_Odm, 0xc08 , BIT18|BIT17|BIT16, pdm_sat_table->ant_num);
+	ODM_SetBBReg(pDM_Odm, 0xc08 , BIT31, 0); /*increase ant num every FAT period 0:+1, 1+2*/
+	ODM_SetBBReg(pDM_Odm, 0x8c4 , BIT2|BIT1, 1); /*change cca antenna timming threshold if no CCA occurred: 0:200ms / 1:100ms / 2:no use / 3: 300*/
+	ODM_SetBBReg(pDM_Odm, 0x8c4 , BIT0, 1); /*FAT_watchdog_en*/
+	
+	value32 = ODM_GetMACReg(pDM_Odm,  0x7B4, bMaskDWord);
+	ODM_SetMACReg(pDM_Odm, 0x7b4, bMaskDWord, value32|(BIT16|BIT17));	/*Reg7B4[16]=1 enable antenna training */
+																		/*Reg7B4[17]=1 enable  match MAC Addr*/
+	ODM_SetMACReg(pDM_Odm, 0x7b4, 0xFFFF, 0);/*Match MAC ADDR*/
+	ODM_SetMACReg(pDM_Odm, 0x7b0, bMaskDWord, 0);
+
+}
+#endif
+
+VOID
+odm_TRX_HWAntDiv_Init_8821A(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8821A AntDiv_Init => AntDivType=[ CG_TRX_HW_ANTDIV (DPDT)] \n"));
+
+	//Output Pin Settings
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT25, 0);
+
+	ODM_SetMACReg(pDM_Odm, 0x64 , BIT29, 1); //PAPE by WLAN control
+	ODM_SetMACReg(pDM_Odm, 0x64 , BIT28, 1); //LNAON by WLAN control
+
+	ODM_SetBBReg(pDM_Odm, 0xCB0 , bMaskDWord, 0x77775745);
+	ODM_SetBBReg(pDM_Odm, 0xCB8 , BIT16, 0);
+	
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT23, 0); //select DPDT_P and DPDT_N as output pin
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT24, 1); //by WLAN control
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , 0xF, 8); // DPDT_P = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , 0xF0, 8); // DPDT_N = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT29, 0); //DPDT_P non-inverse
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT28, 1); //DPDT_N inverse
+
+	//Mapping Table
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte1, 1);
+
+	//OFDM HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF, 0xA0); //thershold
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF000, 0x10); //bias
+		
+	//CCK HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
+	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
+
+	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //ANTSEL_CCK sent to the smart_antenna circuit
+	ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function block enable
+
+	//BT Coexistence
+	ODM_SetBBReg(pDM_Odm, 0xCAC , BIT9, 1); //keep antsel_map when GNT_BT = 1
+	ODM_SetBBReg(pDM_Odm, 0x804 , BIT4, 1); //Disable hw antsw & fast_train.antsw when GNT_BT=1
+
+	//Timming issue
+	ODM_SetBBReg(pDM_Odm, 0x818 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+	ODM_SetBBReg(pDM_Odm, 0x8CC , BIT20|BIT19|BIT18, 3); //settling time of antdiv by RF LNA = 100ns
+
+	//response TX ant by RX ant
+	ODM_SetMACReg(pDM_Odm, 0x668 , BIT3, 1);
+			
+}
+
+VOID
+odm_S0S1_SWAntDiv_Init_8821A(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8821A AntDiv_Init => AntDivType=[ S0S1_SW_AntDiv] \n"));
+
+	//Output Pin Settings
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT25, 0);
+
+	ODM_SetMACReg(pDM_Odm, 0x64 , BIT29, 1); //PAPE by WLAN control
+	ODM_SetMACReg(pDM_Odm, 0x64 , BIT28, 1); //LNAON by WLAN control
+
+	ODM_SetBBReg(pDM_Odm, 0xCB0 , bMaskDWord, 0x77775745);
+	ODM_SetBBReg(pDM_Odm, 0xCB8 , BIT16, 0);
+	
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT23, 0); //select DPDT_P and DPDT_N as output pin
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT24, 1); //by WLAN control
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , 0xF, 8); // DPDT_P = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , 0xF0, 8); // DPDT_N = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT29, 0); //DPDT_P non-inverse
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT28, 1); //DPDT_N inverse
+
+	//Mapping Table
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte1, 1);
+
+	//OFDM HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF, 0xA0); //thershold
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF000, 0x10); //bias
+		
+	//CCK HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
+	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
+
+	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //ANTSEL_CCK sent to the smart_antenna circuit
+	ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function block enable
+
+	//BT Coexistence
+	ODM_SetBBReg(pDM_Odm, 0xCAC , BIT9, 1); //keep antsel_map when GNT_BT = 1
+	ODM_SetBBReg(pDM_Odm, 0x804 , BIT4, 1); //Disable hw antsw & fast_train.antsw when GNT_BT=1
+
+	//Timming issue
+	ODM_SetBBReg(pDM_Odm, 0x818 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+	ODM_SetBBReg(pDM_Odm, 0x8CC , BIT20|BIT19|BIT18, 3); //settling time of antdiv by RF LNA = 100ns
+
+	//response TX ant by RX ant
+	ODM_SetMACReg(pDM_Odm, 0x668 , BIT3, 1);
+
+
+	ODM_SetBBReg(pDM_Odm, 0x900 , BIT18, 0); 
+	
+	pDM_SWAT_Table->try_flag = 0xff;	
+	pDM_SWAT_Table->Double_chk_flag = 0;
+	pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
+	pDM_SWAT_Table->CurAntenna = MAIN_ANT;
+	pDM_SWAT_Table->PreAntenna = MAIN_ANT;
+	pDM_SWAT_Table->SWAS_NoLink_State = 0;
+
+}
+#endif //#if (RTL8821A_SUPPORT == 1)
+
+#if (RTL8881A_SUPPORT == 1)
+VOID
+odm_RX_HWAntDiv_Init_8881A(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8881A AntDiv_Init => AntDivType=[ CGCS_RX_HW_ANTDIV] \n"));
+
+}
+
+VOID
+odm_TRX_HWAntDiv_Init_8881A(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8881A AntDiv_Init => AntDivType=[ CG_TRX_HW_ANTDIV (SPDT)] \n"));
+
+	//Output Pin Settings
+	// [SPDT related]
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT25, 0);
+	ODM_SetMACReg(pDM_Odm, 0x4C , BIT26, 0);
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT31, 0); //delay buffer
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT22, 0); 
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT24, 1);
+	ODM_SetBBReg(pDM_Odm, 0xCB0 , 0xF00, 8); // DPDT_P = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0xCB0 , 0xF0000, 8); // DPDT_N = ANTSEL[0]	
+	
+	//Mapping Table
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte1, 1);
+
+	//OFDM HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF, 0xA0); //thershold
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF000, 0x0); //bias
+	ODM_SetBBReg(pDM_Odm, 0x8CC , BIT20|BIT19|BIT18, 3); //settling time of antdiv by RF LNA = 100ns
+	
+	//CCK HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
+	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
+
+	//Timming issue
+	ODM_SetBBReg(pDM_Odm, 0x818 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+
+	//2 [--For HW Bug Setting]
+
+	ODM_SetBBReg(pDM_Odm, 0x900 , BIT18, 0); //TX Ant  by Reg //  A-cut bug
+}
+
+#endif //#if (RTL8881A_SUPPORT == 1)
+
+
+#if (RTL8812A_SUPPORT == 1)
+VOID
+odm_TRX_HWAntDiv_Init_8812A(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8812A AntDiv_Init => AntDivType=[ CG_TRX_HW_ANTDIV (SPDT)] \n"));
+
+	//3 //3 --RFE pin setting---------
+	//[BB]
+	ODM_SetBBReg(pDM_Odm, 0x900 , BIT10|BIT9|BIT8, 0x0);	  //disable SW switch
+	ODM_SetBBReg(pDM_Odm, 0x900 , BIT17|BIT16, 0x0);	 
+	ODM_SetBBReg(pDM_Odm, 0x974 , BIT7|BIT6, 0x3);     // in/out
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT31, 0); //delay buffer
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT26, 0); 
+	ODM_SetBBReg(pDM_Odm, 0xCB4 , BIT27, 1);
+	ODM_SetBBReg(pDM_Odm, 0xCB0 , 0xF000000, 8); // DPDT_P = ANTSEL[0]
+	ODM_SetBBReg(pDM_Odm, 0xCB0 , 0xF0000000, 8); // DPDT_N = ANTSEL[0]
+	//3 -------------------------
+
+	//Mapping Table
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xCA4 , bMaskByte1, 1);
+
+	//OFDM HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF, 0xA0); //thershold
+	ODM_SetBBReg(pDM_Odm, 0x8D4 , 0x7FF000, 0x0); //bias
+	ODM_SetBBReg(pDM_Odm, 0x8CC , BIT20|BIT19|BIT18, 3); //settling time of antdiv by RF LNA = 100ns
+	
+	//CCK HW AntDiv Parameters
+	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
+	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
+
+	//Timming issue
+	ODM_SetBBReg(pDM_Odm, 0x818 , BIT23|BIT22|BIT21|BIT20, 8); //keep antidx after tx for ACK ( unit x 32 mu sec)
+
+	//2 [--For HW Bug Setting]
+
+	ODM_SetBBReg(pDM_Odm, 0x900 , BIT18, 0); //TX Ant  by Reg //  A-cut bug
+	
+}
+
+#endif //#if (RTL8812A_SUPPORT == 1)
+
+
+
+
+#ifdef ODM_EVM_ENHANCE_ANTDIV
+
+
+
+VOID
+odm_EVM_FastAnt_Reset(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+		
+	pDM_FatTable->EVM_method_enable=0;
+	odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
+	pDM_FatTable->FAT_State = NORMAL_STATE_MIAN;
+	pDM_Odm->antdiv_period=0;
+	ODM_SetMACReg(pDM_Odm, 0x608, BIT8, 0);
+}
+
+
+VOID
+odm_EVM_Enhance_AntDiv(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	Main_RSSI, Aux_RSSI ;
+	u4Byte	Main_CRC_utility=0,Aux_CRC_utility=0,utility_ratio=1;
+	u4Byte	Main_EVM, Aux_EVM,Diff_RSSI=0,diff_EVM=0;	
+	u1Byte	score_EVM=0,score_CRC=0;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	u4Byte	value32, i;
+	BOOLEAN Main_above1=FALSE,Aux_above1=FALSE;
+	BOOLEAN Force_antenna=FALSE;
+	PSTA_INFO_T   	pEntry;
+	pDM_FatTable->TargetAnt_enhance=0xFF;
+	
+	
+	if((pDM_Odm->SupportICType & ODM_EVM_ENHANCE_ANTDIV_SUPPORT_IC))
+	{
+		if(pDM_Odm->bOneEntryOnly)
+		{
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[One Client only] \n"));
+			i = pDM_Odm->OneEntry_MACID;
+
+			Main_RSSI = (pDM_FatTable->MainAnt_Cnt[i]!=0)?(pDM_FatTable->MainAnt_Sum[i]/pDM_FatTable->MainAnt_Cnt[i]):0;
+			Aux_RSSI = (pDM_FatTable->AuxAnt_Cnt[i]!=0)?(pDM_FatTable->AuxAnt_Sum[i]/pDM_FatTable->AuxAnt_Cnt[i]):0;
+
+			if((Main_RSSI==0 && Aux_RSSI !=0 && Aux_RSSI>=FORCE_RSSI_DIFF) || (Main_RSSI!=0 && Aux_RSSI==0 && Main_RSSI>=FORCE_RSSI_DIFF))
+			{
+				Diff_RSSI=FORCE_RSSI_DIFF;
+			}
+			else if(Main_RSSI!=0 && Aux_RSSI !=0)
+			{
+				Diff_RSSI = (Main_RSSI>=Aux_RSSI)?(Main_RSSI-Aux_RSSI):(Aux_RSSI-Main_RSSI); 
+			}
+			
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" Main_Cnt = (( %d ))  , Main_RSSI= ((  %d )) \n", pDM_FatTable->MainAnt_Cnt[i], Main_RSSI));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" Aux_Cnt   = (( %d ))  , Aux_RSSI = ((  %d )) \n" , pDM_FatTable->AuxAnt_Cnt[i] , Aux_RSSI));
+						
+			if(  ((Main_RSSI>=Evm_RSSI_TH_High||Aux_RSSI>=Evm_RSSI_TH_High )|| (pDM_FatTable->EVM_method_enable==1)  )
+				//&& (Diff_RSSI <= FORCE_RSSI_DIFF + 1)
+                                    )
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[> TH_H || EVM_method_enable==1]  && "));
+				
+				if(((Main_RSSI>=Evm_RSSI_TH_Low)||(Aux_RSSI>=Evm_RSSI_TH_Low) ))
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[> TH_L ] \n"));
+
+					//2 [ Normal state Main]
+					if(pDM_FatTable->FAT_State == NORMAL_STATE_MIAN)
+					{
+
+						pDM_FatTable->EVM_method_enable=1;
+						odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+						pDM_Odm->antdiv_period=3;
+
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ start training: MIAN] \n"));
+						pDM_FatTable->MainAntEVM_Sum[i] = 0;
+						pDM_FatTable->AuxAntEVM_Sum[i] = 0;
+						pDM_FatTable->MainAntEVM_Cnt[i] = 0;
+						pDM_FatTable->AuxAntEVM_Cnt[i] = 0;
+
+						pDM_FatTable->FAT_State = NORMAL_STATE_AUX;
+						ODM_SetMACReg(pDM_Odm, 0x608, BIT8, 1); //Accept CRC32 Error packets.
+						ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+						
+						pDM_FatTable->CRC32_Ok_Cnt=0;
+						pDM_FatTable->CRC32_Fail_Cnt=0;
+						ODM_SetTimer(pDM_Odm,&pDM_Odm->EVM_FastAntTrainingTimer, pDM_Odm->antdiv_intvl ); //m
+					}
+					//2 [ Normal state Aux ]
+					else if(pDM_FatTable->FAT_State == NORMAL_STATE_AUX)
+					{
+						pDM_FatTable->MainCRC32_Ok_Cnt=pDM_FatTable->CRC32_Ok_Cnt;
+						pDM_FatTable->MainCRC32_Fail_Cnt=pDM_FatTable->CRC32_Fail_Cnt;
+						
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ start training: AUX] \n"));
+						pDM_FatTable->FAT_State = TRAINING_STATE;
+						ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+
+						pDM_FatTable->CRC32_Ok_Cnt=0;
+						pDM_FatTable->CRC32_Fail_Cnt=0;
+						ODM_SetTimer(pDM_Odm,&pDM_Odm->EVM_FastAntTrainingTimer, pDM_Odm->antdiv_intvl ); //ms
+					}					
+					else if(pDM_FatTable->FAT_State == TRAINING_STATE)
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Training state ] \n"));
+						pDM_FatTable->FAT_State = NORMAL_STATE_MIAN;
+						
+						//3 [CRC32 statistic]
+						pDM_FatTable->AuxCRC32_Ok_Cnt=pDM_FatTable->CRC32_Ok_Cnt;
+						pDM_FatTable->AuxCRC32_Fail_Cnt=pDM_FatTable->CRC32_Fail_Cnt;
+
+						if( (pDM_FatTable->MainCRC32_Ok_Cnt  >= ((pDM_FatTable->AuxCRC32_Ok_Cnt)<<1)) || (Diff_RSSI>=18))
+						{
+							pDM_FatTable->TargetAnt_CRC32=MAIN_ANT;
+							Force_antenna=TRUE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("CRC32 Force Main \n"));
+						}
+						else if((pDM_FatTable->AuxCRC32_Ok_Cnt  >= ((pDM_FatTable->MainCRC32_Ok_Cnt)<<1)) || (Diff_RSSI>=18))
+						{
+							pDM_FatTable->TargetAnt_CRC32=AUX_ANT;
+							Force_antenna=TRUE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("CRC32 Force Aux \n"));
+						}
+						else
+						{
+							if(pDM_FatTable->MainCRC32_Fail_Cnt<=5)
+								pDM_FatTable->MainCRC32_Fail_Cnt=5;
+							
+							if(pDM_FatTable->AuxCRC32_Fail_Cnt<=5)
+								pDM_FatTable->AuxCRC32_Fail_Cnt=5;
+						
+							if(pDM_FatTable->MainCRC32_Ok_Cnt >pDM_FatTable->MainCRC32_Fail_Cnt )
+								Main_above1=TRUE;
+						
+							if(pDM_FatTable->AuxCRC32_Ok_Cnt >pDM_FatTable->AuxCRC32_Fail_Cnt )
+								Aux_above1=TRUE;
+
+							if(Main_above1==TRUE && Aux_above1==FALSE)
+							{
+								Force_antenna=TRUE;
+								pDM_FatTable->TargetAnt_CRC32=MAIN_ANT;
+							}
+							else if(Main_above1==FALSE && Aux_above1==TRUE)
+							{
+								Force_antenna=TRUE;
+								pDM_FatTable->TargetAnt_CRC32=AUX_ANT;
+							}
+							else if(Main_above1==TRUE && Aux_above1==TRUE)
+							{
+								Main_CRC_utility=((pDM_FatTable->MainCRC32_Ok_Cnt)<<7)/pDM_FatTable->MainCRC32_Fail_Cnt;
+								Aux_CRC_utility=((pDM_FatTable->AuxCRC32_Ok_Cnt)<<7)/pDM_FatTable->AuxCRC32_Fail_Cnt;
+								pDM_FatTable->TargetAnt_CRC32 = (Main_CRC_utility==Aux_CRC_utility)?(pDM_FatTable->pre_TargetAnt_enhance):((Main_CRC_utility>=Aux_CRC_utility)?MAIN_ANT:AUX_ANT);
+								
+								if(Main_CRC_utility!=0 && Aux_CRC_utility!=0)
+								{
+									if(Main_CRC_utility>=Aux_CRC_utility)
+										utility_ratio=(Main_CRC_utility<<1)/Aux_CRC_utility;
+									else
+										utility_ratio=(Aux_CRC_utility<<1)/Main_CRC_utility;
+								}
+							}
+							else if(Main_above1==FALSE && Aux_above1==FALSE)
+							{
+								if(pDM_FatTable->MainCRC32_Ok_Cnt==0)
+									pDM_FatTable->MainCRC32_Ok_Cnt=1;
+								if(pDM_FatTable->AuxCRC32_Ok_Cnt==0)
+									pDM_FatTable->AuxCRC32_Ok_Cnt=1;
+								
+								Main_CRC_utility=((pDM_FatTable->MainCRC32_Fail_Cnt)<<7)/pDM_FatTable->MainCRC32_Ok_Cnt;
+								Aux_CRC_utility=((pDM_FatTable->AuxCRC32_Fail_Cnt)<<7)/pDM_FatTable->AuxCRC32_Ok_Cnt;
+								pDM_FatTable->TargetAnt_CRC32 = (Main_CRC_utility==Aux_CRC_utility)?(pDM_FatTable->pre_TargetAnt_enhance):((Main_CRC_utility<=Aux_CRC_utility)?MAIN_ANT:AUX_ANT);	
+
+								if(Main_CRC_utility!=0 && Aux_CRC_utility!=0)
+								{
+									if(Main_CRC_utility>=Aux_CRC_utility)
+										utility_ratio=(Main_CRC_utility<<1)/(Aux_CRC_utility);
+									else
+										utility_ratio=(Aux_CRC_utility<<1)/(Main_CRC_utility);
+								}
+							}
+						}
+						ODM_SetMACReg(pDM_Odm, 0x608, BIT8, 0);//NOT Accept CRC32 Error packets.
+
+						//3 [EVM statistic]			
+						Main_EVM = (pDM_FatTable->MainAntEVM_Cnt[i]!=0)?(pDM_FatTable->MainAntEVM_Sum[i]/pDM_FatTable->MainAntEVM_Cnt[i]):0;
+						Aux_EVM = (pDM_FatTable->AuxAntEVM_Cnt[i]!=0)?(pDM_FatTable->AuxAntEVM_Sum[i]/pDM_FatTable->AuxAntEVM_Cnt[i]):0;
+						pDM_FatTable->TargetAnt_EVM = (Main_EVM==Aux_EVM)?(pDM_FatTable->pre_TargetAnt_enhance):((Main_EVM>=Aux_EVM)?MAIN_ANT:AUX_ANT);
+
+						if((Main_EVM==0 || Aux_EVM==0))
+							diff_EVM=0;
+						else if(Main_EVM>=Aux_EVM)
+							diff_EVM=Main_EVM-Aux_EVM;
+						else
+							diff_EVM=Aux_EVM-Main_EVM;
+
+						//2 [ Decision state ]					
+						if(pDM_FatTable->TargetAnt_EVM ==pDM_FatTable->TargetAnt_CRC32 )
+						{
+							if( (utility_ratio<2 && Force_antenna==FALSE)  && diff_EVM<=2)
+								pDM_FatTable->TargetAnt_enhance=pDM_FatTable->pre_TargetAnt_enhance;
+							else
+								pDM_FatTable->TargetAnt_enhance=pDM_FatTable->TargetAnt_EVM;
+						}
+						else if(diff_EVM<=2 && (utility_ratio > 4 && Force_antenna==FALSE)) 
+						{
+							pDM_FatTable->TargetAnt_enhance=pDM_FatTable->TargetAnt_CRC32;
+						}
+						else if(diff_EVM>=20) // 
+						{
+							pDM_FatTable->TargetAnt_enhance=pDM_FatTable->TargetAnt_EVM;
+						}
+						else if(utility_ratio>=6 && Force_antenna==FALSE) // utility_ratio>3
+						{
+							pDM_FatTable->TargetAnt_enhance=pDM_FatTable->TargetAnt_CRC32;
+						}
+						else
+						{
+							if(Force_antenna==TRUE)
+								score_CRC=3;
+							else if(utility_ratio>=4) //>2
+								score_CRC=2;
+					else if(utility_ratio>=3) //>1.5
+						score_CRC=1;
+					else
+						score_CRC=0;
+					
+					if(diff_EVM>=10)
+						score_EVM=2;
+					else if(diff_EVM>=5)
+						score_EVM=1;
+					else
+						score_EVM=0;
+
+					if(score_CRC>score_EVM)
+						pDM_FatTable->TargetAnt_enhance=pDM_FatTable->TargetAnt_CRC32;
+					else if(score_CRC<score_EVM)
+						pDM_FatTable->TargetAnt_enhance=pDM_FatTable->TargetAnt_EVM;
+					else
+						pDM_FatTable->TargetAnt_enhance=pDM_FatTable->pre_TargetAnt_enhance;
+				}
+				pDM_FatTable->pre_TargetAnt_enhance=pDM_FatTable->TargetAnt_enhance;
+
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] : MainEVM_Cnt = (( %d ))  , Main_EVM= ((  %d )) \n",i, pDM_FatTable->MainAntEVM_Cnt[i], Main_EVM));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] : AuxEVM_Cnt   = (( %d ))  , Aux_EVM = ((  %d )) \n" ,i, pDM_FatTable->AuxAntEVM_Cnt[i] , Aux_EVM));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** TargetAnt_EVM = (( %s ))\n", ( pDM_FatTable->TargetAnt_EVM  ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("M_CRC_Ok = (( %d ))  , M_CRC_Fail = ((  %d )), Main_CRC_utility = (( %d )) \n" , pDM_FatTable->MainCRC32_Ok_Cnt, pDM_FatTable->MainCRC32_Fail_Cnt,Main_CRC_utility));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("A_CRC_Ok  = (( %d ))  , A_CRC_Fail = ((  %d )), Aux_CRC_utility   = ((  %d )) \n" , pDM_FatTable->AuxCRC32_Ok_Cnt, pDM_FatTable->AuxCRC32_Fail_Cnt,Aux_CRC_utility));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** TargetAnt_CRC32 = (( %s ))\n", ( pDM_FatTable->TargetAnt_CRC32 ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("****** TargetAnt_enhance = (( %s ))******\n", ( pDM_FatTable->TargetAnt_enhance ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+				
+					
+					}
+				}
+				else // RSSI< = Evm_RSSI_TH_Low
+				{ 
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ <TH_L: escape from > TH_L ] \n"));
+					odm_EVM_FastAnt_Reset(pDM_Odm);
+				}
+			}
+			else 
+			{ 
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[escape from> TH_H || EVM_method_enable==1] \n"));
+				odm_EVM_FastAnt_Reset(pDM_Odm);
+			}
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[multi-Client] \n"));
+			odm_EVM_FastAnt_Reset(pDM_Odm);
+		}			
+	}
+}
+
+VOID
+odm_EVM_FastAntTrainingCallback(struct timer_list *t)
+{
+	PDM_ODM_T *pDM_Odm =
+		from_timer(pDM_Odm, t, DM_SWAT_Table.EVM_FastAntTrainingTimer);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("******odm_EVM_FastAntTrainingCallback****** \n"));
+	odm_HW_AntDiv(pDM_Odm);
+}
+#endif
+
+VOID
+odm_HW_AntDiv(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte	i,MinMaxRSSI=0xFF,  AntDivMaxRSSI=0, MaxRSSI=0, LocalMaxRSSI;
+	u4Byte	Main_RSSI, Aux_RSSI;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;	
+	u1Byte	RxIdleAnt = pDM_FatTable->RxIdleAnt, TargetAnt = 7;
+	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PSTA_INFO_T   	pEntry;
+
+	#ifdef BEAMFORMING_SUPPORT
+	#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+	pBDC_T    pDM_BdcTable = &pDM_Odm->DM_BdcTable;
+	u4Byte	TH1=500000;
+	u4Byte	TH2=10000000; 
+	u4Byte	MA_rx_Temp, degrade_TP_temp, improve_TP_temp;
+	u1Byte	Monitor_RSSI_threshold=30;
+
+	pDM_BdcTable->BF_pass=TRUE;
+	pDM_BdcTable->DIV_pass=TRUE;
+	pDM_BdcTable->bAll_DivSta_Idle=TRUE;
+	pDM_BdcTable->bAll_BFSta_Idle=TRUE;
+	pDM_BdcTable->num_BfTar=0 ;
+	pDM_BdcTable->num_DivTar=0;
+	pDM_BdcTable->num_Client=0;
+	#endif
+	#endif
+
+	if(!pDM_Odm->bLinked) //bLinked==False
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[No Link!!!]\n"));
+		
+		if(pDM_FatTable->bBecomeLinked == TRUE)
+		{
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+			ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , REG);
+			pDM_Odm->antdiv_period=0;
+
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+		return;
+	}	
+	else
+	{
+		if(pDM_FatTable->bBecomeLinked ==FALSE)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Linked !!!]\n"));
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , TX_BY_DESC);
+			
+			//if(pDM_Odm->SupportICType == ODM_RTL8821 )
+				//ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function disable
+				
+			//#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
+			//else if(pDM_Odm->SupportICType == ODM_RTL8881A)
+			//	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function disable
+			//#endif
+			
+			//else if(pDM_Odm->SupportICType == ODM_RTL8723B ||pDM_Odm->SupportICType == ODM_RTL8812)
+				//ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function disable
+			
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+
+			if(pDM_Odm->SupportICType==ODM_RTL8723B && pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
+			{
+				ODM_SetBBReg(pDM_Odm, 0x930 , 0xF0, 8); // DPDT_P = ANTSEL[0]   // for 8723B AntDiv function patch.  BB  Dino  130412	
+				ODM_SetBBReg(pDM_Odm, 0x930 , 0xF, 8); // DPDT_N = ANTSEL[0]
+			}
+			
+			//2 BDC Init
+			#ifdef BEAMFORMING_SUPPORT
+			#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+				odm_BDC_Init(pDM_Odm);
+			#endif
+			#endif
+			
+			#ifdef ODM_EVM_ENHANCE_ANTDIV
+				odm_EVM_FastAnt_Reset(pDM_Odm);
+			#endif
+		}	
+	}	
+
+	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n AntDiv Start =>\n"));
+
+	#ifdef ODM_EVM_ENHANCE_ANTDIV
+	if(pDM_Odm->antdiv_evm_en==1)
+	{
+		odm_EVM_Enhance_AntDiv(pDM_Odm);
+		if(pDM_FatTable->FAT_State !=NORMAL_STATE_MIAN)
+			return;
+	}
+	else
+	{
+		odm_EVM_FastAnt_Reset(pDM_Odm);
+	}
+	#endif
+	
+	//2 BDC Mode Arbitration
+	#ifdef BEAMFORMING_SUPPORT
+	#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+	if(pDM_Odm->antdiv_evm_en == 0 ||pDM_FatTable->EVM_method_enable==0)
+	{
+		odm_BF_AntDiv_ModeArbitration(pDM_Odm);
+	}
+	#endif
+	#endif
+
+	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		pEntry = pDM_Odm->pODM_StaInfo[i];
+		if(IS_STA_VALID(pEntry))
+		{
+			//2 Caculate RSSI per Antenna
+			Main_RSSI = (pDM_FatTable->MainAnt_Cnt[i]!=0)?(pDM_FatTable->MainAnt_Sum[i]/pDM_FatTable->MainAnt_Cnt[i]):0;
+			Aux_RSSI = (pDM_FatTable->AuxAnt_Cnt[i]!=0)?(pDM_FatTable->AuxAnt_Sum[i]/pDM_FatTable->AuxAnt_Cnt[i]):0;
+			TargetAnt = (Main_RSSI==Aux_RSSI)?pDM_FatTable->RxIdleAnt:((Main_RSSI>=Aux_RSSI)?MAIN_ANT:AUX_ANT);
+		
+			//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** SupportICType=[%d] \n",pDM_Odm->SupportICType));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] : Main_Cnt = (( %d ))  , Main_RSSI= ((  %d )) \n",i, pDM_FatTable->MainAnt_Cnt[i], Main_RSSI));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] : Aux_Cnt   = (( %d ))  , Aux_RSSI = ((  %d )) \n" ,i, pDM_FatTable->AuxAnt_Cnt[i] , Aux_RSSI));
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** MAC ID:[ %d ] , TargetAnt = (( %s )) \n", i ,( TargetAnt ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** Phy_AntSel_A=[ %d, %d, %d] \n",((pDM_Odm->DM_FatTable.antsel_rx_keep_0)&BIT2)>>2,
+			//	                                                                              ((pDM_Odm->DM_FatTable.antsel_rx_keep_0)&BIT1) >>1, ((pDM_Odm->DM_FatTable.antsel_rx_keep_0)&BIT0)));
+
+			LocalMaxRSSI = (Main_RSSI>Aux_RSSI)?Main_RSSI:Aux_RSSI;
+			//2 Select MaxRSSI for DIG
+			if((LocalMaxRSSI > AntDivMaxRSSI) && (LocalMaxRSSI < 40))
+				AntDivMaxRSSI = LocalMaxRSSI;
+			if(LocalMaxRSSI > MaxRSSI)
+				MaxRSSI = LocalMaxRSSI;
+
+			//2 Select RX Idle Antenna
+			if ( (LocalMaxRSSI != 0) &&  (LocalMaxRSSI < MinMaxRSSI) )
+			{
+				RxIdleAnt = TargetAnt;
+				MinMaxRSSI = LocalMaxRSSI;
+			}
+
+			#ifdef ODM_EVM_ENHANCE_ANTDIV
+			if(pDM_Odm->antdiv_evm_en==1)
+			{
+				if(pDM_FatTable->TargetAnt_enhance!=0xFF)
+				{
+					TargetAnt=pDM_FatTable->TargetAnt_enhance;
+					RxIdleAnt = pDM_FatTable->TargetAnt_enhance;
+				}
+			}
+			#endif
+
+			//2 Select TX Antenna
+			if(pDM_Odm->AntDivType != CGCS_RX_HW_ANTDIV)
+			{
+				#ifdef BEAMFORMING_SUPPORT
+				#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+					if(pDM_BdcTable->w_BFee_Client[i]==0)
+				#endif	
+				#endif
+					{
+						odm_UpdateTxAnt(pDM_Odm, TargetAnt, i);
+					}
+			}
+
+			//------------------------------------------------------------
+
+			#ifdef BEAMFORMING_SUPPORT
+			#if(DM_ODM_SUPPORT_TYPE  == ODM_AP) 
+
+			pDM_BdcTable->num_Client++;
+
+			if(pDM_BdcTable->BDC_Mode==BDC_MODE_2 ||pDM_BdcTable->BDC_Mode==BDC_MODE_3)
+			{
+				//2 Byte Counter
+
+				MA_rx_Temp=  (pEntry->rx_byte_cnt_LowMAW)<<3 ; //  RX  TP   ( bit /sec)
+				
+				if(pDM_BdcTable->BDC_state==BDC_BFer_TRAIN_STATE)
+				{
+					pDM_BdcTable->MA_rx_TP_DIV[i]=  MA_rx_Temp ;
+				}
+				else
+				{
+					pDM_BdcTable->MA_rx_TP[i] =MA_rx_Temp ;
+				}
+
+				if( (MA_rx_Temp < TH2)   &&  (MA_rx_Temp > TH1) && (LocalMaxRSSI<=Monitor_RSSI_threshold))
+				{
+					if(pDM_BdcTable->w_BFer_Client[i]==1) // Bfer_Target
+					{
+						pDM_BdcTable->num_BfTar++;
+						
+						if(pDM_BdcTable->BDC_state==BDC_DECISION_STATE && pDM_BdcTable->BDC_Try_flag==0)
+						{
+						        improve_TP_temp = (pDM_BdcTable->MA_rx_TP_DIV[i] * 9)>>3 ; //* 1.125
+					        	pDM_BdcTable->BF_pass = (pDM_BdcTable->MA_rx_TP[i] > improve_TP_temp)?TRUE:FALSE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] :  { MA_rx_TP,improve_TP_temp , MA_rx_TP_DIV,  BF_pass}={ %d,  %d, %d , %d }  \n" ,i,pDM_BdcTable->MA_rx_TP[i],improve_TP_temp,pDM_BdcTable->MA_rx_TP_DIV[i], pDM_BdcTable->BF_pass ));
+						}		
+					}		
+					else// DIV_Target
+					{
+						pDM_BdcTable->num_DivTar++;
+						
+						if(pDM_BdcTable->BDC_state==BDC_DECISION_STATE && pDM_BdcTable->BDC_Try_flag==0)
+						{
+					        	degrade_TP_temp=(pDM_BdcTable->MA_rx_TP_DIV[i]*5)>>3;//* 0.625
+					        	pDM_BdcTable->DIV_pass = (pDM_BdcTable->MA_rx_TP[i] >degrade_TP_temp)?TRUE:FALSE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] :  { MA_rx_TP, degrade_TP_temp , MA_rx_TP_DIV,  DIV_pass}=\n{ %d,  %d, %d , %d }  \n" ,i,pDM_BdcTable->MA_rx_TP[i],degrade_TP_temp,pDM_BdcTable->MA_rx_TP_DIV[i], pDM_BdcTable->DIV_pass ));
+						}							
+					}
+				}
+
+				if(MA_rx_Temp > TH1)
+				{
+					if(pDM_BdcTable->w_BFer_Client[i]==1) // Bfer_Target
+					{
+						pDM_BdcTable->bAll_BFSta_Idle=FALSE;
+					}		
+					else// DIV_Target
+					{
+						pDM_BdcTable->bAll_DivSta_Idle=FALSE;
+					}
+				}
+		
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] :  { BFmeeCap , BFmerCap}  = { %d , %d } \n" ,i, pDM_BdcTable->w_BFee_Client[i] , pDM_BdcTable->w_BFer_Client[i]));
+
+				if(pDM_BdcTable->BDC_state==BDC_BFer_TRAIN_STATE)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] :    MA_rx_TP_DIV = (( %d ))  \n",i,pDM_BdcTable->MA_rx_TP_DIV[i]  ));
+					
+				}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Client[ %d ] :    MA_rx_TP = (( %d ))  \n",i,pDM_BdcTable->MA_rx_TP[i]  ));
+				}
+			
+			}
+			#endif
+			#endif
+
+		}
+
+		#ifdef BEAMFORMING_SUPPORT
+		#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+		if(pDM_BdcTable->BDC_Try_flag==0)
+		#endif
+		#endif	
+		{
+        		pDM_FatTable->MainAnt_Sum[i] = 0;
+        		pDM_FatTable->AuxAnt_Sum[i] = 0;
+        		pDM_FatTable->MainAnt_Cnt[i] = 0;
+         		pDM_FatTable->AuxAnt_Cnt[i] = 0;
+                }
+	}
+       
+
+	
+	//2 Set RX Idle Antenna & TX Antenna(Because of HW Bug )	
+	#if(DM_ODM_SUPPORT_TYPE  == ODM_AP ) 
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** RxIdleAnt = (( %s ))\n\n", ( RxIdleAnt ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+		
+		#ifdef BEAMFORMING_SUPPORT
+		#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+			if(pDM_BdcTable->BDC_Mode==BDC_MODE_1 ||pDM_BdcTable->BDC_Mode==BDC_MODE_3)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** BDC_RxIdleUpdate_counter = (( %d ))\n", pDM_BdcTable->BDC_RxIdleUpdate_counter));
+			
+				if(pDM_BdcTable->BDC_RxIdleUpdate_counter==1)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***Update RxIdle Antenna!!! \n"));
+					pDM_BdcTable->BDC_RxIdleUpdate_counter=30;
+					ODM_UpdateRxIdleAnt(pDM_Odm, RxIdleAnt);
+				}
+				else
+				{
+					pDM_BdcTable->BDC_RxIdleUpdate_counter--;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***NOT update RxIdle Antenna because of BF  ( need to fix TX-ant)\n"));
+				}
+			}
+			else
+		#endif
+		#endif	
+				ODM_UpdateRxIdleAnt(pDM_Odm, RxIdleAnt);
+	#else
+	
+		ODM_UpdateRxIdleAnt(pDM_Odm, RxIdleAnt);
+	
+	#endif//#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
+
+
+
+	//2 BDC Main Algorithm
+	#ifdef BEAMFORMING_SUPPORT
+	#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+	if(pDM_Odm->antdiv_evm_en ==0 ||pDM_FatTable->EVM_method_enable==0)
+	{
+		odm_BDCcoex_BFeeRxDiv_Arbitration(pDM_Odm);
+	}
+	#endif
+	#endif
+
+	if(AntDivMaxRSSI == 0)
+		pDM_DigTable->AntDiv_RSSI_max = pDM_Odm->RSSI_Min;
+	else
+		pDM_DigTable->AntDiv_RSSI_max = AntDivMaxRSSI;
+	
+	pDM_DigTable->RSSI_max = MaxRSSI;
+}
+
+
+
+#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+VOID
+odm_S0S1_SwAntDiv(
+	IN		PVOID			pDM_VOID,	
+	IN		u1Byte			Step
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			i,MinMaxRSSI=0xFF, LocalMaxRSSI,LocalMinRSSI;
+	u4Byte			Main_RSSI, Aux_RSSI;
+	u1Byte			reset_period=10, SWAntDiv_threshold=35;
+	u1Byte			HighTraffic_TrainTime_U=0x32,HighTraffic_TrainTime_L=0,Train_time_temp;
+	u1Byte			LowTraffic_TrainTime_U=200,LowTraffic_TrainTime_L=0;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;	
+	u1Byte			RxIdleAnt = pDM_SWAT_Table->PreAntenna, TargetAnt, nextAnt=0;
+	PSTA_INFO_T		pEntry=NULL;
+	//static u1Byte		reset_idx;
+	u4Byte			value32;
+	PADAPTER		Adapter	 =  pDM_Odm->Adapter;
+	u8Byte			curTxOkCnt=0, curRxOkCnt=0,TxCntOffset, RxCntOffset;
+	
+	if(!pDM_Odm->bLinked) //bLinked==False
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[No Link!!!]\n"));
+		if(pDM_FatTable->bBecomeLinked == TRUE)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Set REG 948[9:6]=0x0 \n"));
+			if(pDM_Odm->SupportICType == ODM_RTL8723B)
+				ODM_SetBBReg(pDM_Odm, 0x948 , BIT9|BIT8|BIT7|BIT6, 0x0); 
+			
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+		return;
+	}
+	else
+	{
+		if(pDM_FatTable->bBecomeLinked ==FALSE)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Linked !!!]\n"));
+			
+			if(pDM_Odm->SupportICType == ODM_RTL8723B)
+			{
+				value32 = ODM_GetBBReg(pDM_Odm, 0x864, BIT5|BIT4|BIT3);
+				
+				if (value32==0x0)
+					ODM_UpdateRxIdleAnt_8723B(pDM_Odm, MAIN_ANT, ANT1_2G, ANT2_2G);
+				else if (value32==0x1)
+					ODM_UpdateRxIdleAnt_8723B(pDM_Odm, AUX_ANT, ANT2_2G, ANT1_2G);
+				
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("8723B: First link! Force antenna to  %s\n",(value32 == 0x0?"MAIN":"AUX") ));
+			}
+
+			pDM_SWAT_Table->lastTxOkCnt = 0; 
+			pDM_SWAT_Table->lastRxOkCnt =0; 
+			TxCntOffset =  *(pDM_Odm->pNumTxBytesUnicast);
+			RxCntOffset =  *(pDM_Odm->pNumRxBytesUnicast);
+			
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+		else
+		{
+			TxCntOffset = 0;
+			RxCntOffset = 0;
+		}
+	}
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[%d] { try_flag=(( %d )), Step=(( %d )), Double_chk_flag = (( %d )) }\n",
+		__LINE__,pDM_SWAT_Table->try_flag,Step,pDM_SWAT_Table->Double_chk_flag));
+
+	// Handling step mismatch condition.
+	// Peak step is not finished at last time. Recover the variable and check again.
+	if(	Step != pDM_SWAT_Table->try_flag	)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Step != try_flag]    Need to Reset After Link\n"));
+		ODM_SwAntDivRestAfterLink(pDM_Odm);
+	}
+
+	if(pDM_SWAT_Table->try_flag == 0xff) 
+	{	
+		pDM_SWAT_Table->try_flag = 0;
+		pDM_SWAT_Table->Train_time_flag=0;
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("[set try_flag = 0]  Prepare for peak!\n\n"));
+		return;
+	}	
+	else//if( try_flag != 0xff ) 
+	{
+		//1 Normal State (Begin Trying)
+		if(pDM_SWAT_Table->try_flag == 0) 
+		{
+		
+			//---trafic decision---
+			curTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast) - pDM_SWAT_Table->lastTxOkCnt - TxCntOffset;
+			curRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast) - pDM_SWAT_Table->lastRxOkCnt - RxCntOffset;
+			pDM_SWAT_Table->lastTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast);
+			pDM_SWAT_Table->lastRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast);
+			
+			if (curTxOkCnt > 1875000 || curRxOkCnt > 1875000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)  ( 1.875M * 8bit ) / 2= 7.5M bits /sec )
+			{
+				pDM_SWAT_Table->TrafficLoad = TRAFFIC_HIGH;
+				Train_time_temp = pDM_SWAT_Table->Train_time ;
+				
+				if(pDM_SWAT_Table->Train_time_flag==3)
+				{
+					HighTraffic_TrainTime_L=0xa;
+					
+					if(Train_time_temp<=16)
+						Train_time_temp=HighTraffic_TrainTime_L;
+					else
+						Train_time_temp-=16;
+					
+				}				
+				else if(pDM_SWAT_Table->Train_time_flag==2)
+				{
+					Train_time_temp-=8;
+					HighTraffic_TrainTime_L=0xf;
+				}	
+				else if(pDM_SWAT_Table->Train_time_flag==1)
+				{
+					Train_time_temp-=4;
+					HighTraffic_TrainTime_L=0x1e;
+				}
+				else if(pDM_SWAT_Table->Train_time_flag==0)
+				{
+					Train_time_temp+=8;
+					HighTraffic_TrainTime_L=0x28;
+				}
+
+				
+				//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** Train_time_temp = ((%d))\n",Train_time_temp));
+
+				//--
+				if(Train_time_temp > HighTraffic_TrainTime_U)
+					Train_time_temp=HighTraffic_TrainTime_U;
+				
+				else if(Train_time_temp < HighTraffic_TrainTime_L)
+					Train_time_temp=HighTraffic_TrainTime_L;
+
+				pDM_SWAT_Table->Train_time = Train_time_temp; //50ms~10ms
+				
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("  Train_time_flag=((%d)) , Train_time=((%d)) \n",pDM_SWAT_Table->Train_time_flag, pDM_SWAT_Table->Train_time));
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("  [HIGH Traffic]  \n" ));
+			}
+			else if (curTxOkCnt > 125000 || curRxOkCnt > 125000) // ( 0.125M * 8bit ) / 2 =  0.5M bits /sec )
+			{
+				pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
+				Train_time_temp=pDM_SWAT_Table->Train_time ;
+				
+				if(pDM_SWAT_Table->Train_time_flag==3)
+				{
+					LowTraffic_TrainTime_L=10;
+					if(Train_time_temp<50)
+						Train_time_temp=LowTraffic_TrainTime_L;
+					else
+						Train_time_temp-=50;
+				}				
+				else if(pDM_SWAT_Table->Train_time_flag==2)
+				{
+					Train_time_temp-=30;
+					LowTraffic_TrainTime_L=36;
+				}	
+				else if(pDM_SWAT_Table->Train_time_flag==1)
+				{
+					Train_time_temp-=10;
+					LowTraffic_TrainTime_L=40;
+				}
+				else
+					Train_time_temp+=10;	
+				
+				//--
+				if(Train_time_temp >= LowTraffic_TrainTime_U)
+					Train_time_temp=LowTraffic_TrainTime_U;
+				
+				else if(Train_time_temp <= LowTraffic_TrainTime_L)
+					Train_time_temp=LowTraffic_TrainTime_L;
+
+				pDM_SWAT_Table->Train_time = Train_time_temp; //50ms~20ms
+				
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Train_time_flag=((%d)) , Train_time=((%d))\n", pDM_SWAT_Table->Train_time_flag, pDM_SWAT_Table->Train_time));
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Low Traffic]\n"));
+			}
+			else
+			{
+				pDM_SWAT_Table->TrafficLoad = TRAFFIC_ULTRA_LOW;
+				pDM_SWAT_Table->Train_time = 0xc8; //200ms
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Ultra-Low Traffic]\n"));
+			}
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("TxOkCnt=(( %llu )), RxOkCnt=(( %llu ))\n", 
+				curTxOkCnt ,curRxOkCnt ));
+				
+			//-----------------
+		
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,(" Current MinMaxRSSI is ((%d)) \n",pDM_FatTable->MinMaxRSSI));
+
+                        //---reset index---
+			if(pDM_SWAT_Table->reset_idx>=reset_period)
+			{
+				pDM_FatTable->MinMaxRSSI=0; //
+				pDM_SWAT_Table->reset_idx=0;
+			}
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("reset_idx = (( %d )) \n",pDM_SWAT_Table->reset_idx ));
+			//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("reset_idx=%d\n",pDM_SWAT_Table->reset_idx));
+			pDM_SWAT_Table->reset_idx++;
+
+			//---double check flag---
+			if(pDM_FatTable->MinMaxRSSI > SWAntDiv_threshold && pDM_SWAT_Table->Double_chk_flag== 0)
+			{			
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,(" MinMaxRSSI is ((%d)), and > %d \n",
+					pDM_FatTable->MinMaxRSSI,SWAntDiv_threshold));
+
+				pDM_SWAT_Table->Double_chk_flag =1;
+				pDM_SWAT_Table->try_flag = 1; 
+				pDM_SWAT_Table->RSSI_Trying = 0;
+
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" Test the current Ant for (( %d )) ms again \n", pDM_SWAT_Table->Train_time));
+				ODM_UpdateRxIdleAnt(pDM_Odm, pDM_FatTable->RxIdleAnt);
+				ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer_8723B, pDM_SWAT_Table->Train_time ); //ms	
+				return;
+			}
+			
+			nextAnt = (pDM_FatTable->RxIdleAnt == MAIN_ANT)? AUX_ANT : MAIN_ANT;
+
+			pDM_SWAT_Table->try_flag = 1;
+			
+			if(pDM_SWAT_Table->reset_idx<=1)
+				pDM_SWAT_Table->RSSI_Trying = 2;
+			else
+				pDM_SWAT_Table->RSSI_Trying = 1;
+
+			odm_S0S1_SwAntDivByCtrlFrame(pDM_Odm, SWAW_STEP_PEEK);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[set try_flag=1]  Normal State:  Begin Trying!!\n"));			
+		}
+	
+		else if(pDM_SWAT_Table->try_flag == 1 && pDM_SWAT_Table->Double_chk_flag== 0)
+		{	
+			nextAnt = (pDM_FatTable->RxIdleAnt  == MAIN_ANT)? AUX_ANT : MAIN_ANT;		
+			pDM_SWAT_Table->RSSI_Trying--;
+		}
+		
+		//1 Decision State
+		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0) )
+		{
+			BOOLEAN bByCtrlFrame = FALSE;
+			u8Byte	pkt_cnt_total = 0;
+		
+			for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+			{
+				pEntry = pDM_Odm->pODM_StaInfo[i];
+				if(IS_STA_VALID(pEntry))
+				{
+					//2 Caculate RSSI per Antenna
+					Main_RSSI = (pDM_FatTable->MainAnt_Cnt[i]!=0)?(pDM_FatTable->MainAnt_Sum[i]/pDM_FatTable->MainAnt_Cnt[i]):0;
+					Aux_RSSI = (pDM_FatTable->AuxAnt_Cnt[i]!=0)?(pDM_FatTable->AuxAnt_Sum[i]/pDM_FatTable->AuxAnt_Cnt[i]):0;
+					
+					if(pDM_FatTable->MainAnt_Cnt[i]<=1 && pDM_FatTable->CCK_counter_main>=1)
+						Main_RSSI=0;	
+					
+					if(pDM_FatTable->AuxAnt_Cnt[i]<=1 && pDM_FatTable->CCK_counter_aux>=1)
+						Aux_RSSI=0;
+					
+					TargetAnt = (Main_RSSI==Aux_RSSI)?pDM_SWAT_Table->PreAntenna:((Main_RSSI>=Aux_RSSI)?MAIN_ANT:AUX_ANT);
+					LocalMaxRSSI = (Main_RSSI>=Aux_RSSI) ? Main_RSSI : Aux_RSSI;
+					LocalMinRSSI = (Main_RSSI>=Aux_RSSI) ? Aux_RSSI : Main_RSSI;
+					
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  CCK_counter_main = (( %d ))  , CCK_counter_aux= ((  %d )) \n", pDM_FatTable->CCK_counter_main, pDM_FatTable->CCK_counter_aux));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  OFDM_counter_main = (( %d ))  , OFDM_counter_aux= ((  %d )) \n", pDM_FatTable->OFDM_counter_main, pDM_FatTable->OFDM_counter_aux));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  Main_Cnt = (( %d ))  , Main_RSSI= ((  %d )) \n", pDM_FatTable->MainAnt_Cnt[i], Main_RSSI));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  Aux_Cnt   = (( %d ))  , Aux_RSSI = ((  %d )) \n", pDM_FatTable->AuxAnt_Cnt[i]  , Aux_RSSI ));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** MAC ID:[ %d ] , TargetAnt = (( %s )) \n", i ,( TargetAnt ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+					
+					//2 Select RX Idle Antenna
+					
+					if (LocalMaxRSSI != 0 && LocalMaxRSSI < MinMaxRSSI)
+					{
+						RxIdleAnt = TargetAnt;
+						MinMaxRSSI = LocalMaxRSSI;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** LocalMaxRSSI-LocalMinRSSI = ((%d))\n",(LocalMaxRSSI-LocalMinRSSI)));
+				
+						if((LocalMaxRSSI-LocalMinRSSI)>8)
+						{
+							if(LocalMinRSSI != 0)
+								pDM_SWAT_Table->Train_time_flag=3;
+							else
+							{
+								if(MinMaxRSSI > SWAntDiv_threshold)
+									pDM_SWAT_Table->Train_time_flag=0;
+								else
+									pDM_SWAT_Table->Train_time_flag=3;
+							}
+						}
+						else if((LocalMaxRSSI-LocalMinRSSI)>5)
+							pDM_SWAT_Table->Train_time_flag=2;
+						else if((LocalMaxRSSI-LocalMinRSSI)>2)
+							pDM_SWAT_Table->Train_time_flag=1;
+						else
+							pDM_SWAT_Table->Train_time_flag=0;
+							
+					}
+					
+					//2 Select TX Antenna
+					if(TargetAnt == MAIN_ANT)
+						pDM_FatTable->antsel_a[i] = ANT1_2G;
+					else
+						pDM_FatTable->antsel_a[i] = ANT2_2G;
+			
+				}
+				pDM_FatTable->MainAnt_Sum[i] = 0;
+				pDM_FatTable->AuxAnt_Sum[i] = 0;
+				pDM_FatTable->MainAnt_Cnt[i] = 0;
+				pDM_FatTable->AuxAnt_Cnt[i] = 0;
+			}
+
+			if(pDM_SWAT_Table->bSWAntDivByCtrlFrame)
+			{
+				odm_S0S1_SwAntDivByCtrlFrame(pDM_Odm, SWAW_STEP_DETERMINE);
+				bByCtrlFrame = TRUE;
+			}
+
+			pkt_cnt_total = pDM_FatTable->CCK_counter_main + pDM_FatTable->CCK_counter_aux + 
+			pDM_FatTable->OFDM_counter_main + pDM_FatTable->OFDM_counter_aux;
+			pDM_FatTable->CCK_counter_main=0;
+			pDM_FatTable->CCK_counter_aux=0;
+			pDM_FatTable->OFDM_counter_main=0;
+			pDM_FatTable->OFDM_counter_aux=0;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Control frame packet counter = %d, Data frame packet counter = %llu\n", 
+				pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame, pkt_cnt_total));
+			
+			if(MinMaxRSSI == 0xff || ((pkt_cnt_total < (pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame >> 1)) && pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 2))
+			{	
+				MinMaxRSSI = 0;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Check RSSI of control frame because MinMaxRSSI == 0xff\n"));
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("bByCtrlFrame = %d\n", bByCtrlFrame));
+				
+				if(bByCtrlFrame)
+				{
+					Main_RSSI = (pDM_FatTable->MainAnt_CtrlFrame_Cnt!=0)?(pDM_FatTable->MainAnt_CtrlFrame_Sum/pDM_FatTable->MainAnt_CtrlFrame_Cnt):0;
+					Aux_RSSI = (pDM_FatTable->AuxAnt_CtrlFrame_Cnt!=0)?(pDM_FatTable->AuxAnt_CtrlFrame_Sum/pDM_FatTable->AuxAnt_CtrlFrame_Cnt):0;
+					
+					if(pDM_FatTable->MainAnt_CtrlFrame_Cnt<=1 && pDM_FatTable->CCK_CtrlFrame_Cnt_main>=1)
+						Main_RSSI=0;	
+					
+					if(pDM_FatTable->AuxAnt_CtrlFrame_Cnt<=1 && pDM_FatTable->CCK_CtrlFrame_Cnt_aux>=1)
+						Aux_RSSI=0;
+
+					if (Main_RSSI != 0 || Aux_RSSI != 0)
+					{
+						RxIdleAnt = (Main_RSSI==Aux_RSSI)?pDM_SWAT_Table->PreAntenna:((Main_RSSI>=Aux_RSSI)?MAIN_ANT:AUX_ANT);
+						LocalMaxRSSI = (Main_RSSI>=Aux_RSSI) ? Main_RSSI : Aux_RSSI;
+						LocalMinRSSI = (Main_RSSI>=Aux_RSSI) ? Aux_RSSI : Main_RSSI;
+
+						if((LocalMaxRSSI-LocalMinRSSI)>8)
+							pDM_SWAT_Table->Train_time_flag=3;
+						else if((LocalMaxRSSI-LocalMinRSSI)>5)
+							pDM_SWAT_Table->Train_time_flag=2;
+						else if((LocalMaxRSSI-LocalMinRSSI)>2)
+							pDM_SWAT_Table->Train_time_flag=1;
+						else
+							pDM_SWAT_Table->Train_time_flag=0;
+
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Control frame: Main_RSSI = %d, Aux_RSSI = %d\n", Main_RSSI, Aux_RSSI));
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("RxIdleAnt decided by control frame = %s\n", (RxIdleAnt == MAIN_ANT?"MAIN":"AUX")));
+					}
+				}
+			}
+
+			pDM_FatTable->MinMaxRSSI = MinMaxRSSI;
+			pDM_SWAT_Table->try_flag = 0;
+						
+			if( pDM_SWAT_Table->Double_chk_flag==1)
+			{
+				pDM_SWAT_Table->Double_chk_flag=0;
+				if(pDM_FatTable->MinMaxRSSI > SWAntDiv_threshold)
+				{
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,(" [Double check] MinMaxRSSI ((%d)) > %d again!! \n",
+						pDM_FatTable->MinMaxRSSI,SWAntDiv_threshold));
+					
+					ODM_UpdateRxIdleAnt(pDM_Odm, RxIdleAnt);	
+					
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("[reset try_flag = 0] Training accomplished !!!] \n\n\n"));
+					return;
+				}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,(" [Double check] MinMaxRSSI ((%d)) <= %d !! \n",
+						pDM_FatTable->MinMaxRSSI,SWAntDiv_threshold));
+
+					nextAnt = (pDM_FatTable->RxIdleAnt  == MAIN_ANT)? AUX_ANT : MAIN_ANT;
+					pDM_SWAT_Table->try_flag = 0; 
+					pDM_SWAT_Table->reset_idx=reset_period;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("[set try_flag=0]  Normal State:  Need to tryg again!! \n\n\n"));
+					return;
+				}
+			}
+			else
+			{
+				if(pDM_FatTable->MinMaxRSSI < SWAntDiv_threshold)
+					pDM_SWAT_Table->reset_idx=reset_period;
+				
+				pDM_SWAT_Table->PreAntenna =RxIdleAnt;
+				ODM_UpdateRxIdleAnt(pDM_Odm, RxIdleAnt );
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("[reset try_flag = 0] Training accomplished !!!] \n\n\n"));
+				return;
+			}
+			
+		}
+
+	}
+
+	//1 4.Change TRX antenna
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("RSSI_Trying = (( %d )),    Ant: (( %s )) >>> (( %s )) \n",
+		pDM_SWAT_Table->RSSI_Trying, (pDM_FatTable->RxIdleAnt  == MAIN_ANT?"MAIN":"AUX"),(nextAnt == MAIN_ANT?"MAIN":"AUX")));
+		
+	ODM_UpdateRxIdleAnt(pDM_Odm, nextAnt);
+
+	//1 5.Reset Statistics
+
+	pDM_FatTable->RxIdleAnt  = nextAnt;
+
+	//1 6.Set next timer   (Trying State)
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" Test ((%s)) Ant for (( %d )) ms \n", (nextAnt == MAIN_ANT?"MAIN":"AUX"), pDM_SWAT_Table->Train_time));
+	ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer_8723B, pDM_SWAT_Table->Train_time ); //ms
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_SW_AntDiv_Callback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	pSWAT_T			pDM_SWAT_Table = &pHalData->DM_OutSrc.DM_SWAT_Table;
+
+	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+		#if USE_WORKITEM
+			ODM_ScheduleWorkItem(&pDM_SWAT_Table->SwAntennaSwitchWorkitem_8723B);
+		#else
+			{
+			//DbgPrint("SW_antdiv_Callback");
+			odm_S0S1_SwAntDiv(&pHalData->DM_OutSrc, SWAW_STEP_DETERMINE);
+			}
+		#endif
+	#else
+	ODM_ScheduleWorkItem(&pDM_SWAT_Table->SwAntennaSwitchWorkitem_8723B);
+	#endif
+}
+VOID
+ODM_SW_AntDiv_WorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER		pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	
+	//DbgPrint("SW_antdiv_Workitem_Callback");
+	odm_S0S1_SwAntDiv(&pHalData->DM_OutSrc, SWAW_STEP_DETERMINE);
+}
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+VOID
+ODM_SW_AntDiv_WorkitemCallback(
+	IN PVOID	pContext
+)
+{
+	PADAPTER
+	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE
+	*pHalData = GET_HAL_DATA(pAdapter);
+
+	/*DbgPrint("SW_antdiv_Workitem_Callback");*/
+	odm_S0S1_SwAntDiv(&pHalData->odmpriv, SWAW_STEP_DETERMINE);
+}
+
+VOID
+ODM_SW_AntDiv_Callback(struct timer_list *t)
+{
+	PDM_ODM_T *pDM_Odm =
+		from_timer(pDM_Odm, t, DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
+	PADAPTER	padapter = pDM_Odm->Adapter;
+	if(padapter->net_closed == _TRUE)
+		return;
+	
+	#if 0 /* Can't do I/O in timer callback*/
+	odm_S0S1_SwAntDiv(pDM_Odm, SWAW_STEP_DETERMINE);
+	#else
+	rtw_run_in_thread_cmd(padapter, ODM_SW_AntDiv_WorkitemCallback, padapter);
+	#endif
+}
+
+
+#endif
+
+VOID
+odm_S0S1_SwAntDivByCtrlFrame(
+	IN		PVOID			pDM_VOID,	
+	IN		u1Byte			Step
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSWAT_T	pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+	
+	switch(Step)
+	{
+		case SWAW_STEP_PEEK:
+			pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame = 0;
+			pDM_SWAT_Table->bSWAntDivByCtrlFrame = TRUE;
+			pDM_FatTable->MainAnt_CtrlFrame_Cnt = 0;
+			pDM_FatTable->AuxAnt_CtrlFrame_Cnt = 0;
+			pDM_FatTable->MainAnt_CtrlFrame_Sum = 0;
+			pDM_FatTable->AuxAnt_CtrlFrame_Sum = 0;
+			pDM_FatTable->CCK_CtrlFrame_Cnt_main = 0;
+			pDM_FatTable->CCK_CtrlFrame_Cnt_aux = 0;
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_main = 0;
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_aux = 0;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("odm_S0S1_SwAntDivForAPMode(): Start peak and reset counter\n"));
+			break;
+		case SWAW_STEP_DETERMINE:
+			pDM_SWAT_Table->bSWAntDivByCtrlFrame = FALSE;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("odm_S0S1_SwAntDivForAPMode(): Stop peak\n"));
+			break;
+		default:
+			pDM_SWAT_Table->bSWAntDivByCtrlFrame = FALSE;
+			break;
+	}			
+}
+
+VOID
+odm_AntselStatisticsOfCtrlFrame(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			RxPWDBAll
+	
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	if(antsel_tr_mux == ANT1_2G)
+	{
+		pDM_FatTable->MainAnt_CtrlFrame_Sum+=RxPWDBAll;
+		pDM_FatTable->MainAnt_CtrlFrame_Cnt++;
+	}
+	else
+	{
+		pDM_FatTable->AuxAnt_CtrlFrame_Sum+=RxPWDBAll;
+		pDM_FatTable->AuxAnt_CtrlFrame_Cnt++;
+	}
+}
+
+VOID
+odm_S0S1_SwAntDivByCtrlFrame_ProcessRSSI(
+	IN		PVOID			pDM_VOID,	
+	IN		PVOID			p_phy_info_void,
+	IN		PVOID			p_pkt_info_void
+	//IN		PODM_PHY_INFO_T		pPhyInfo,
+	//IN		PODM_PACKET_INFO_T		pPktinfo
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_PHY_INFO_T	 pPhyInfo=(PODM_PHY_INFO_T)p_phy_info_void;
+	PODM_PACKET_INFO_T 	pPktinfo=(PODM_PACKET_INFO_T)p_pkt_info_void;
+	pSWAT_T	pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+	BOOLEAN		isCCKrate;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+		return;
+
+	if(pDM_Odm->AntDivType != S0S1_SW_ANTDIV)
+		return;
+
+	// In try state
+	if(!pDM_SWAT_Table->bSWAntDivByCtrlFrame)
+		return;
+
+	// No HW error and match receiver address
+	if(!pPktinfo->bToSelf)
+		return;
+	
+	pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame++;
+	isCCKrate = ((pPktinfo->DataRate >= DESC_RATE1M ) && (pPktinfo->DataRate <= DESC_RATE11M ))?TRUE :FALSE;
+
+	if(isCCKrate)
+	{
+	 	pDM_FatTable->antsel_rx_keep_0 = (pDM_FatTable->RxIdleAnt == MAIN_ANT) ? ANT1_2G : ANT2_2G;
+
+		if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
+			pDM_FatTable->CCK_CtrlFrame_Cnt_main++;
+		else
+			pDM_FatTable->CCK_CtrlFrame_Cnt_aux++;
+
+		odm_AntselStatisticsOfCtrlFrame(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A]);
+	}
+	else
+	{
+		if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_main++;
+		else
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_aux++;
+
+		odm_AntselStatisticsOfCtrlFrame(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPhyInfo->RxPWDBAll);
+	}
+}
+
+#endif //#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
+
+
+
+
+VOID
+odm_SetNextMACAddrTarget(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	PSTA_INFO_T   	pEntry;
+	u4Byte			value32, i;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_SetNextMACAddrTarget() ==>\n"));
+	
+	if (pDM_Odm->bLinked)
+	{
+		for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+			
+			if ((pDM_FatTable->TrainIdx+1) == ODM_ASSOCIATE_ENTRY_NUM)
+				pDM_FatTable->TrainIdx = 0;
+			else
+				pDM_FatTable->TrainIdx++;
+			
+			pEntry = pDM_Odm->pODM_StaInfo[pDM_FatTable->TrainIdx];
+			
+			if (IS_STA_VALID(pEntry)) {
+				
+				/*Match MAC ADDR*/
+				#if (DM_ODM_SUPPORT_TYPE & (ODM_AP | ODM_CE))
+				value32 = (pEntry->hwaddr[5]<<8)|pEntry->hwaddr[4];
+				#else
+				value32 = (pEntry->MacAddr[5]<<8)|pEntry->MacAddr[4];
+				#endif
+				
+				ODM_SetMACReg(pDM_Odm, 0x7b4, 0xFFFF, value32);/*0x7b4~0x7b5*/
+				
+				#if (DM_ODM_SUPPORT_TYPE & (ODM_AP | ODM_CE))
+				value32 = (pEntry->hwaddr[3]<<24)|(pEntry->hwaddr[2]<<16) |(pEntry->hwaddr[1]<<8) |pEntry->hwaddr[0];
+				#else
+				value32 = (pEntry->MacAddr[3]<<24)|(pEntry->MacAddr[2]<<16) |(pEntry->MacAddr[1]<<8) |pEntry->MacAddr[0];
+				#endif
+				ODM_SetMACReg(pDM_Odm, 0x7b0, bMaskDWord, value32);/*0x7b0~0x7b3*/
+
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_FatTable->TrainIdx=%d\n", pDM_FatTable->TrainIdx));
+				
+				#if (DM_ODM_SUPPORT_TYPE & (ODM_AP | ODM_CE))
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Training MAC Addr = %x:%x:%x:%x:%x:%x\n",
+					pEntry->hwaddr[5], pEntry->hwaddr[4], pEntry->hwaddr[3], pEntry->hwaddr[2], pEntry->hwaddr[1], pEntry->hwaddr[0]));
+				#else
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Training MAC Addr = %x:%x:%x:%x:%x:%x\n",
+					pEntry->MacAddr[5], pEntry->MacAddr[4], pEntry->MacAddr[3], pEntry->MacAddr[2], pEntry->MacAddr[1], pEntry->MacAddr[0]));
+				#endif
+
+				break;
+			}
+		}
+	}
+
+#if 0
+	//
+	//2012.03.26 LukeLee: This should be removed later, the MAC address is changed according to MACID in turn
+	//
+	#if( DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	{		
+		PADAPTER	Adapter =  pDM_Odm->Adapter;
+		PMGNT_INFO	pMgntInfo = &Adapter->MgntInfo;
+
+		for (i=0; i<6; i++)
+		{
+			Bssid[i] = pMgntInfo->Bssid[i];
+			//DbgPrint("Bssid[%d]=%x\n", i, Bssid[i]);
+		}
+	}
+	#endif
+
+	//odm_SetNextMACAddrTarget(pDM_Odm);
+	
+	//1 Select MAC Address Filter
+	for (i=0; i<6; i++)
+	{
+		if(Bssid[i] != pDM_FatTable->Bssid[i])
+		{
+			bMatchBSSID = FALSE;
+			break;
+		}
+	}
+	if(bMatchBSSID == FALSE)
+	{
+		//Match MAC ADDR
+		value32 = (Bssid[5]<<8)|Bssid[4];
+		ODM_SetMACReg(pDM_Odm, 0x7b4, 0xFFFF, value32);
+		value32 = (Bssid[3]<<24)|(Bssid[2]<<16) |(Bssid[1]<<8) |Bssid[0];
+		ODM_SetMACReg(pDM_Odm, 0x7b0, bMaskDWord, value32);
+	}
+
+	return bMatchBSSID;
+#endif
+				
+}
+
+#if (defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY)) || (defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY))
+
+VOID
+odm_FastAntTraining(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	u4Byte	MaxRSSI_pathA=0, Pckcnt_pathA=0;
+	u1Byte	i,TargetAnt_pathA=0;
+	BOOLEAN	bPktFilterMacth_pathA = FALSE;
+	#if(RTL8192E_SUPPORT == 1)
+	u4Byte	MaxRSSI_pathB=0, Pckcnt_pathB=0;
+	u1Byte	TargetAnt_pathB=0;
+	BOOLEAN	bPktFilterMacth_pathB = FALSE;
+	#endif
+
+
+	if(!pDM_Odm->bLinked) //bLinked==False
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[No Link!!!]\n"));
+		
+		if(pDM_FatTable->bBecomeLinked == TRUE)
+		{
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+			phydm_FastTraining_enable(pDM_Odm , FAT_OFF);
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , REG);
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+		return;
+	}
+	else
+	{
+		if(pDM_FatTable->bBecomeLinked ==FALSE)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Linked!!!]\n"));
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , TX_BY_DESC);
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+	}
+
+		
+        if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+           ODM_SetBBReg(pDM_Odm, 0x864 , BIT2|BIT1|BIT0, ((pDM_Odm->fat_comb_a)-1));
+        }
+	#if(RTL8192E_SUPPORT == 1)
+        else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+        {
+           ODM_SetBBReg(pDM_Odm, 0xB38 , BIT2|BIT1|BIT0, ((pDM_Odm->fat_comb_a)-1) );	   //path-A  // ant combination=regB38[2:0]+1
+	   ODM_SetBBReg(pDM_Odm, 0xB38 , BIT18|BIT17|BIT16, ((pDM_Odm->fat_comb_b)-1) );  //path-B  // ant combination=regB38[18:16]+1
+        }
+	#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("==>odm_FastAntTraining()\n"));
+
+	//1 TRAINING STATE
+	if(pDM_FatTable->FAT_State == FAT_TRAINING_STATE)
+	{
+		//2 Caculate RSSI per Antenna
+
+                //3 [path-A]---------------------------
+		for (i=0; i<(pDM_Odm->fat_comb_a); i++) // i : antenna index
+		{
+			if(pDM_FatTable->antRSSIcnt[i] == 0)
+				pDM_FatTable->antAveRSSI[i] = 0;
+			else
+			{
+			pDM_FatTable->antAveRSSI[i] = pDM_FatTable->antSumRSSI[i] /pDM_FatTable->antRSSIcnt[i];
+				bPktFilterMacth_pathA = TRUE;
+			}
+			
+			if(pDM_FatTable->antAveRSSI[i] > MaxRSSI_pathA)
+			{
+				MaxRSSI_pathA = pDM_FatTable->antAveRSSI[i];
+                                Pckcnt_pathA = pDM_FatTable ->antRSSIcnt[i];
+				TargetAnt_pathA =  i ; 
+			}
+                        else if(pDM_FatTable->antAveRSSI[i] == MaxRSSI_pathA)
+			{
+				if(  (pDM_FatTable->antRSSIcnt[i] )   >   Pckcnt_pathA)
+			{
+					MaxRSSI_pathA = pDM_FatTable->antAveRSSI[i];
+					Pckcnt_pathA = pDM_FatTable ->antRSSIcnt[i];
+				        TargetAnt_pathA = i ;
+			        }
+			}
+
+			ODM_RT_TRACE("*** Ant-Index : [ %d ],      Counter = (( %d )),     Avg RSSI = (( %d )) \n", i, pDM_FatTable->antRSSIcnt[i],  pDM_FatTable->antAveRSSI[i] );
+		}
+
+
+		/*
+		#if(RTL8192E_SUPPORT == 1)
+		//3 [path-B]---------------------------
+		for (i=0; i<(pDM_Odm->fat_comb_b); i++)
+		{
+			if(pDM_FatTable->antRSSIcnt_pathB[i] == 0)
+				pDM_FatTable->antAveRSSI_pathB[i] = 0;				
+			else // (antRSSIcnt[i] != 0)
+			{
+				pDM_FatTable->antAveRSSI_pathB[i] = pDM_FatTable->antSumRSSI_pathB[i] /pDM_FatTable->antRSSIcnt_pathB[i];
+				bPktFilterMacth_pathB = TRUE;
+			}
+			if(pDM_FatTable->antAveRSSI_pathB[i] > MaxRSSI_pathB)
+			{
+				MaxRSSI_pathB = pDM_FatTable->antAveRSSI_pathB[i];
+                                Pckcnt_pathB = pDM_FatTable ->antRSSIcnt_pathB[i];
+				TargetAnt_pathB = (u1Byte) i; 
+			}
+                        if(pDM_FatTable->antAveRSSI_pathB[i] == MaxRSSI_pathB)
+			{
+				if(pDM_FatTable ->antRSSIcnt_pathB > Pckcnt_pathB)
+		{
+					MaxRSSI_pathB = pDM_FatTable->antAveRSSI_pathB[i];
+					TargetAnt_pathB = (u1Byte) i;
+				} 
+		}
+			if (pDM_Odm->fat_print_rssi==1)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***{Path-B}: Sum RSSI[%d] = (( %d )),      cnt RSSI [%d] = (( %d )),     Avg RSSI[%d] = (( %d )) \n",
+				i, pDM_FatTable->antSumRSSI_pathB[i], i, pDM_FatTable->antRSSIcnt_pathB[i], i, pDM_FatTable->antAveRSSI_pathB[i]));
+			}
+		}
+		#endif
+		*/
+
+	//1 DECISION STATE
+
+		//2 Select TRX Antenna
+
+		phydm_FastTraining_enable(pDM_Odm, FAT_OFF);
+
+		//3 [path-A]---------------------------
+		if(bPktFilterMacth_pathA  == FALSE)
+		{
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("{Path-A}: None Packet is matched\n"));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("{Path-A}: None Packet is matched\n"));
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+		}
+		else
+		{
+			ODM_RT_TRACE("TargetAnt_pathA = (( %d )) , MaxRSSI_pathA = (( %d )) \n",TargetAnt_pathA,MaxRSSI_pathA);
+
+			//3 [ update RX-optional ant ]        Default RX is Omni, Optional RX is the best decision by FAT
+			if(pDM_Odm->SupportICType == ODM_RTL8188E)
+			{
+				ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, TargetAnt_pathA);	
+			}
+			else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+			{
+				ODM_SetBBReg(pDM_Odm, 0xB38 , BIT8|BIT7|BIT6, TargetAnt_pathA);//Optional RX [pth-A]
+			}
+			//3 [ update TX ant ]
+			odm_UpdateTxAnt(pDM_Odm, TargetAnt_pathA, (pDM_FatTable->TrainIdx)); 
+
+			if(TargetAnt_pathA == 0)
+				odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+		}
+		/*
+		#if(RTL8192E_SUPPORT == 1)
+		//3 [path-B]---------------------------
+		if(bPktFilterMacth_pathB == FALSE)
+		{
+			if (pDM_Odm->fat_print_rssi==1)
+			{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***[%d]{Path-B}: None Packet is matched\n\n\n",__LINE__));
+			}
+		}
+		else
+		{
+			if (pDM_Odm->fat_print_rssi==1)
+			{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+				(" ***TargetAnt_pathB = (( %d )) *** MaxRSSI = (( %d ))***\n\n\n",TargetAnt_pathB,MaxRSSI_pathB));
+			}
+			ODM_SetBBReg(pDM_Odm, 0xB38 , BIT21|BIT20|BIT19, TargetAnt_pathB);	//Default RX is Omni, Optional RX is the best decision by FAT		
+			ODM_SetBBReg(pDM_Odm, 0x80c , BIT21, 1); //Reg80c[21]=1'b1		//from TX Info
+
+			pDM_FatTable->antsel_pathB[pDM_FatTable->TrainIdx] = TargetAnt_pathB;
+		}
+		#endif
+		*/
+
+		//2 Reset Counter
+		for(i=0; i<(pDM_Odm->fat_comb_a); i++)
+		{
+			pDM_FatTable->antSumRSSI[i] = 0;
+			pDM_FatTable->antRSSIcnt[i] = 0;
+		}
+		/*
+		#if(RTL8192E_SUPPORT == 1)
+		for(i=0; i<=(pDM_Odm->fat_comb_b); i++)
+		{
+			pDM_FatTable->antSumRSSI_pathB[i] = 0;
+			pDM_FatTable->antRSSIcnt_pathB[i] = 0;
+		}
+		#endif
+		*/
+		
+		pDM_FatTable->FAT_State = FAT_PREPARE_STATE;
+		return;
+	}
+
+	//1 NORMAL STATE
+	if (pDM_FatTable->FAT_State == FAT_PREPARE_STATE)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Start Prepare State ]\n"));
+
+		odm_SetNextMACAddrTarget(pDM_Odm);
+
+		//2 Prepare Training
+		pDM_FatTable->FAT_State = FAT_TRAINING_STATE;
+		phydm_FastTraining_enable(pDM_Odm , FAT_ON);
+		odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);		//enable HW AntDiv
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Start Training State]\n"));
+
+		ODM_SetTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer, pDM_Odm->antdiv_intvl ); //ms
+	}
+		
+}
+
+VOID
+odm_FastAntTrainingCallback(struct timer_list *t)
+{
+	PDM_ODM_T *pDM_Odm =
+		from_timer(pDM_Odm, t, DM_SWAT_Table.FastAntTrainingTimer);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER	padapter = pDM_Odm->Adapter;
+	if(padapter->net_closed == _TRUE)
+	    return;
+	//if(*pDM_Odm->pbNet_closed == TRUE)
+	   // return;
+#endif
+
+#if USE_WORKITEM
+	ODM_ScheduleWorkItem(&pDM_Odm->FastAntTrainingWorkitem);
+#else
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("******odm_FastAntTrainingCallback****** \n"));
+	odm_FastAntTraining(pDM_Odm);
+#endif
+}
+
+VOID
+odm_FastAntTrainingWorkItemCallback(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("******odm_FastAntTrainingWorkItemCallback****** \n"));
+	odm_FastAntTraining(pDM_Odm);
+}
+
+#endif
+
+#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+
+u4Byte
+phydm_construct_hl_beam_codeword(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*beam_pattern_idx,
+	IN		u4Byte		ant_num
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte		codeword = 0;
+	u4Byte		data_tmp;
+	u1Byte		i;
+
+	if (ant_num < 8) {
+		for (i = 0; i < ant_num; i++) {
+			/*ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("beam_pattern_num[%x] = %x\n",i,beam_pattern_num[i] ));*/
+			if (beam_pattern_idx[i] == 0) {
+				data_tmp = 0x1;
+				/**/
+			} else if (beam_pattern_idx[i] == 1) {
+				data_tmp = 0x2;
+				/**/
+			} else if (beam_pattern_idx[i] == 2) {
+				data_tmp = 0x4;
+				/**/
+			} else if (beam_pattern_idx[i] == 3) {
+				data_tmp = 0x8;
+				/**/
+			}  
+			codeword |= (data_tmp<<(i*4));
+		}
+	}
+
+	return codeword;
+}
+
+VOID
+phydm_update_beam_pattern(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		codeword,
+	IN		u4Byte		codeword_length
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	u1Byte			i;
+	BOOLEAN			beam_ctrl_signal;
+	u4Byte			one = 0x1;
+	u4Byte			reg44_tmp_p, reg44_tmp_n, reg44_ori;
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Set Beam Pattern =0x%x\n", codeword));
+	
+	reg44_ori = ODM_GetMACReg(pDM_Odm, 0x44, bMaskDWord);
+	/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("reg44_ori =0x%x\n", reg44_ori));*/
+	
+	for (i = 0; i <= (codeword_length-1); i++) {
+		beam_ctrl_signal = (BOOLEAN)((codeword&BIT(i)) >> i);
+
+		if (pDM_Odm->DebugComponents & ODM_COMP_ANT_DIV) {
+			
+			if (i == (codeword_length-1)) {
+				DbgPrint("%d ]\n", beam_ctrl_signal);
+				/**/
+			} else if (i == 0) {
+				DbgPrint("Send codeword[1:24] ---> [ %d ", beam_ctrl_signal);	
+				/**/
+			} else if ((i % 4) == 3) {
+				DbgPrint("%d  |  ", beam_ctrl_signal);	
+				/**/
+			} else {
+				DbgPrint("%d ", beam_ctrl_signal);
+				/**/
+			}
+		}
+		
+		#if 1
+		reg44_tmp_p = reg44_ori & (~(BIT11|BIT10)); /*clean bit 10 & 11*/
+		reg44_tmp_p |= ((1<<11) | (beam_ctrl_signal<<10));
+		reg44_tmp_n = reg44_ori & (~(BIT11|BIT10));
+
+		/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("reg44_tmp_p =(( 0x%x )), reg44_tmp_n = (( 0x%x ))\n", reg44_tmp_p, reg44_tmp_n));*/
+		ODM_SetMACReg(pDM_Odm, 0x44 , bMaskDWord, reg44_tmp_p);
+		ODM_SetMACReg(pDM_Odm, 0x44 , bMaskDWord, reg44_tmp_n); 
+		#else
+		ODM_SetMACReg(pDM_Odm, 0x44 , BIT11|BIT10, ((1<<1) | beam_ctrl_signal));
+		ODM_SetMACReg(pDM_Odm, 0x44 , BIT11, 0); 
+		#endif
+
+	}
+}
+
+VOID
+phydm_update_rx_idle_beam(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	u4Byte			i;
+
+	pdm_sat_table->update_beam_codeword = phydm_construct_hl_beam_codeword(pDM_Odm, &(pdm_sat_table->rx_idle_beam[0]), pdm_sat_table->ant_num);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Set target beam_pattern codeword = (( 0x%x ))\n", pdm_sat_table->update_beam_codeword));
+
+	for (i = 0; i < (pdm_sat_table->ant_num); i++) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Beam ] RxIdleBeam[%d] =%d\n", i, pdm_sat_table->rx_idle_beam[i]));
+		/**/
+	}
+	
+	#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+	phydm_update_beam_pattern(pDM_Odm, pdm_sat_table->update_beam_codeword, pdm_sat_table->data_codeword_bit_num);
+	#else
+	ODM_ScheduleWorkItem(&pdm_sat_table->hl_smart_antenna_workitem);
+	/*ODM_StallExecution(1);*/
+	#endif
+
+	pdm_sat_table->pre_codeword = pdm_sat_table->update_beam_codeword;
+}
+
+VOID
+phydm_hl_smart_ant_cmd(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte		*_used,
+	OUT		char			*output,
+	IN		u4Byte		*_out_len
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);	
+	u4Byte			used = *_used;
+	u4Byte			out_len = *_out_len;
+	u4Byte			one = 0x1;
+	u4Byte			codeword_length = pdm_sat_table->data_codeword_bit_num;
+	u4Byte			beam_ctrl_signal, i;
+	
+	if (dm_value[0] == 1) { /*fix beam pattern*/
+		
+		pdm_sat_table->fix_beam_pattern_en = dm_value[1];
+		
+		if (pdm_sat_table->fix_beam_pattern_en == 1) {
+			
+			pdm_sat_table->fix_beam_pattern_codeword = dm_value[2];
+
+			if (pdm_sat_table->fix_beam_pattern_codeword  > (one<<codeword_length)) {
+				
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Codeword overflow, Current codeword is ((0x%x)), and should be less than ((%d))bit\n", 
+					pdm_sat_table->fix_beam_pattern_codeword, codeword_length));
+				(pdm_sat_table->fix_beam_pattern_codeword) &= 0xffffff;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Auto modify to (0x%x)\n", pdm_sat_table->fix_beam_pattern_codeword));
+			}
+			
+			pdm_sat_table->update_beam_codeword = pdm_sat_table->fix_beam_pattern_codeword;
+
+			/*---------------------------------------------------------*/
+			PHYDM_SNPRINTF((output+used, out_len-used, "Fix Beam Pattern\n"));
+			for (i = 0; i <= (codeword_length-1); i++) {
+				beam_ctrl_signal = (BOOLEAN)((pdm_sat_table->update_beam_codeword&BIT(i)) >> i);
+				
+				if (i == (codeword_length-1)) {
+					PHYDM_SNPRINTF((output+used, out_len-used, "%d]\n", beam_ctrl_signal));
+					/**/
+				} else if (i == 0) {
+					PHYDM_SNPRINTF((output+used, out_len-used, "Send Codeword[1:24] to RFU -> [%d", beam_ctrl_signal));
+					/**/
+				} else if ((i % 4) == 3) {
+					PHYDM_SNPRINTF((output+used, out_len-used, "%d|", beam_ctrl_signal));
+					/**/
+				} else {
+					PHYDM_SNPRINTF((output+used, out_len-used, "%d", beam_ctrl_signal));
+					/**/
+				}
+			}
+			/*---------------------------------------------------------*/
+
+			
+			#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+			phydm_update_beam_pattern(pDM_Odm, pdm_sat_table->update_beam_codeword, pdm_sat_table->data_codeword_bit_num);
+			#else
+			ODM_ScheduleWorkItem(&pdm_sat_table->hl_smart_antenna_workitem);
+			/*ODM_StallExecution(1);*/
+			#endif
+		} else if (pdm_sat_table->fix_beam_pattern_en == 0) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Smart Antenna: Enable\n"));
+		}
+		
+	} else if (dm_value[0] == 2) { /*set latch time*/
+		
+		pdm_sat_table->latch_time = dm_value[1];
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ]  latch_time =0x%x\n", pdm_sat_table->latch_time));
+	} else if (dm_value[0] == 3) {
+	
+		pdm_sat_table->fix_training_num_en = dm_value[1];
+		
+		if (pdm_sat_table->fix_training_num_en == 1) {
+			pdm_sat_table->per_beam_training_pkt_num = dm_value[2];
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ]  Fix per_beam_training_pkt_num = (( 0x%x ))\n", pdm_sat_table->per_beam_training_pkt_num));
+		} else if (pdm_sat_table->fix_training_num_en == 0) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ]  AUTO per_beam_training_pkt_num\n"));
+			/**/
+		}
+	}
+		
+}
+
+
+void
+phydm_set_all_ant_same_beam_num(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+
+	if (pDM_Odm->AntDivType == HL_SW_SMART_ANT_TYPE1) { /*2Ant for 8821A*/
+		
+		pdm_sat_table->rx_idle_beam[0] = pdm_sat_table->fast_training_beam_num;
+		pdm_sat_table->rx_idle_beam[1] = pdm_sat_table->fast_training_beam_num;
+	}
+	
+	pdm_sat_table->update_beam_codeword = phydm_construct_hl_beam_codeword(pDM_Odm, &(pdm_sat_table->rx_idle_beam[0]), pdm_sat_table->ant_num);
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Set all ant beam_pattern: codeword = (( 0x%x ))\n", pdm_sat_table->update_beam_codeword));
+
+	#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+	phydm_update_beam_pattern(pDM_Odm, pdm_sat_table->update_beam_codeword, pdm_sat_table->data_codeword_bit_num);
+	#else
+	ODM_ScheduleWorkItem(&pdm_sat_table->hl_smart_antenna_workitem);
+	/*ODM_StallExecution(1);*/
+	#endif
+}
+
+#if 0
+void
+phydm_hl_smart_antenna_test(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSAT_T		pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	pFAT_T		pDM_FatTable	= &(pDM_Odm->DM_FatTable);
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+
+	pdm_sat_table->rx_idle_beam[0] = 0;
+	pdm_sat_table->rx_idle_beam[1] = 0;
+	codeword = phydm_construct_hl_beam_codeword(pDM_Odm, &(pdm_sat_table->rx_idle_beam[0]), pdm_sat_table->ant_num);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("1-beam_pattern = %x\n", codeword));
+	phydm_update_beam_pattern(pDM_Odm, codeword, pdm_sat_table->data_codeword_bit_num);
+
+	pdm_sat_table->rx_idle_beam[0] = 1;
+	pdm_sat_table->rx_idle_beam[1] = 1;
+	codeword = phydm_construct_hl_beam_codeword(pDM_Odm, &(pdm_sat_table->rx_idle_beam[0]), pdm_sat_table->ant_num);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("2-beam_pattern = %x\n", codeword));
+	phydm_update_beam_pattern(pDM_Odm, codeword, pdm_sat_table->data_codeword_bit_num);
+
+	pdm_sat_table->rx_idle_beam[0] = 2;
+	pdm_sat_table->rx_idle_beam[1] = 2;
+	codeword = phydm_construct_hl_beam_codeword(pDM_Odm, &(pdm_sat_table->rx_idle_beam[0]), pdm_sat_table->ant_num);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("3-beam_pattern = %x\n", codeword));
+	phydm_update_beam_pattern(pDM_Odm, codeword, pdm_sat_table->data_codeword_bit_num);
+
+	
+	pdm_sat_table->rx_idle_beam[0] = 3;
+	pdm_sat_table->rx_idle_beam[1] = 3;
+	codeword = phydm_construct_hl_beam_codeword(pDM_Odm, &(pdm_sat_table->rx_idle_beam[0]), pdm_sat_table->ant_num);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("4-beam_pattern = %x\n", codeword));
+	phydm_update_beam_pattern(pDM_Odm, codeword, pdm_sat_table->data_codeword_bit_num);	
+}
+#endif
+
+VOID
+odm_FastAntTraining_hl_smart_antenna_type1(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pSAT_T		pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	pFAT_T		pDM_FatTable	 = &(pDM_Odm->DM_FatTable);
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u4Byte		codeword = 0, i, j;
+	u4Byte		TargetAnt;
+	u4Byte		avg_rssi_tmp;
+	u4Byte		target_ant_beam_max_rssi[SUPPORT_RF_PATH_NUM] = {0};
+	u4Byte		max_beam_ant_rssi = 0;
+	u4Byte		target_ant_beam[SUPPORT_RF_PATH_NUM] = {0};
+	u4Byte		beam_tmp;
+	u1Byte		traffic_state;
+
+
+	if (!pDM_Odm->bLinked) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[No Link!!!]\n"));
+				
+		if (pDM_FatTable->bBecomeLinked == TRUE) {
+			
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Link -> no Link\n"));
+			pDM_FatTable->FAT_State = FAT_BEFORE_LINK_STATE;
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , REG);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("change to (( %d )) FAT_state\n", pDM_FatTable->FAT_State));
+			
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+		return;
+		
+	} else {
+		if (pDM_FatTable->bBecomeLinked == FALSE) {
+			
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Linked !!!]\n"));
+			
+			pDM_FatTable->FAT_State = FAT_PREPARE_STATE;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("change to (( %d )) FAT_state\n", pDM_FatTable->FAT_State));
+			
+			/*pdm_sat_table->fast_training_beam_num = 0;*/
+			/*phydm_set_all_ant_same_beam_num(pDM_Odm);*/
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm, TX_BY_DESC);
+			
+			pDM_SWAT_Table->lastTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast);
+			pDM_SWAT_Table->lastRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast);
+
+			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
+		}
+	}
+
+	/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("HL Smart Ant Training: State (( %d ))\n", pDM_FatTable->FAT_State));*/
+
+	/* [DECISION STATE] */
+	/*=======================================================================================*/
+	if (pDM_FatTable->FAT_State == FAT_DECISION_STATE) {
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 3. In Decision State]\n"));
+		phydm_FastTraining_enable(pDM_Odm , FAT_OFF);
+		
+		/*compute target beam in each antenna*/
+		for (i = 0; i < (pdm_sat_table->ant_num); i++) {
+			for (j = 0; j < (pdm_sat_table->beam_patten_num_each_ant); j++) {
+
+				if (pdm_sat_table->pkt_rssi_cnt[i][j] == 0) {
+					avg_rssi_tmp = pdm_sat_table->pkt_rssi_pre[i][j];
+					/**/
+				} else {
+					avg_rssi_tmp = (pdm_sat_table->pkt_rssi_sum[i][j]) / (pdm_sat_table->pkt_rssi_cnt[i][j]);
+					pdm_sat_table->pkt_rssi_pre[i][j] = avg_rssi_tmp;
+					/**/
+				}
+
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ant[%d], Beam[%d]: pkt_num=(( %d )), avg_rssi=(( %d ))\n", i, j, pdm_sat_table->pkt_rssi_cnt[i][j], avg_rssi_tmp));
+				
+				if (avg_rssi_tmp > target_ant_beam_max_rssi[i]) {
+					target_ant_beam[i] = j;
+					target_ant_beam_max_rssi[i] = avg_rssi_tmp;
+				}
+
+				/*reset counter value*/
+				pdm_sat_table->pkt_rssi_sum[i][j] = 0;
+				pdm_sat_table->pkt_rssi_cnt[i][j] = 0;	
+					
+			}
+			pdm_sat_table->rx_idle_beam[i] = target_ant_beam[i];
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("---------> Target of Ant[%d]: Beam_num-(( %d )) RSSI= ((%d))\n", 
+					i,  target_ant_beam[i], target_ant_beam_max_rssi[i]));
+
+			if (target_ant_beam_max_rssi[i] > max_beam_ant_rssi) {
+				TargetAnt = i;
+				max_beam_ant_rssi = target_ant_beam_max_rssi[i];
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Target of Ant = (( %d )) max_beam_ant_rssi = (( %d ))\n", 
+					TargetAnt,  max_beam_ant_rssi));
+			}
+		}
+
+		if (TargetAnt == 0) 
+			TargetAnt = MAIN_ANT;
+		else if (TargetAnt == 1)
+			TargetAnt = AUX_ANT;
+
+		/* [ update RX ant ]*/
+		ODM_UpdateRxIdleAnt(pDM_Odm, (u1Byte)TargetAnt);
+
+		/* [ update TX ant ]*/
+		odm_UpdateTxAnt(pDM_Odm, (u1Byte)TargetAnt, (pDM_FatTable->TrainIdx));
+		
+		/*set beam in each antenna*/
+		phydm_update_rx_idle_beam(pDM_Odm);
+
+		phydm_FastTraining_enable(pDM_Odm , FAT_OFF);
+		odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);		
+		pDM_FatTable->FAT_State = FAT_PREPARE_STATE;
+
+	} 
+	/* [TRAINING STATE] */
+	else if (pDM_FatTable->FAT_State == FAT_TRAINING_STATE) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2. In Training State]\n"));
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("fat_beam_n = (( %d )), pre_fat_beam_n = (( %d ))\n", 
+			pdm_sat_table->fast_training_beam_num, pdm_sat_table->pre_fast_training_beam_num));
+		
+		if (pdm_sat_table->fast_training_beam_num > pdm_sat_table->pre_fast_training_beam_num) {
+			
+			pdm_sat_table->force_update_beam_en = 0;
+
+		} else {
+		
+			pdm_sat_table->force_update_beam_en = 1;
+			
+			pdm_sat_table->pkt_counter = 0;
+			beam_tmp = pdm_sat_table->fast_training_beam_num;
+			if (pdm_sat_table->fast_training_beam_num >= (pdm_sat_table->beam_patten_num_each_ant-1)) {
+				
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Timeout Update]  Beam_num (( %d )) -> (( decision ))\n", pdm_sat_table->fast_training_beam_num));	
+				phydm_FastTraining_enable(pDM_Odm , FAT_OFF);
+				pDM_FatTable->FAT_State = FAT_DECISION_STATE;					
+				odm_FastAntTraining_hl_smart_antenna_type1(pDM_Odm);
+
+			} else {
+				pdm_sat_table->fast_training_beam_num++;
+				
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Timeout Update]  Beam_num (( %d )) -> (( %d ))\n", beam_tmp, pdm_sat_table->fast_training_beam_num));
+				phydm_set_all_ant_same_beam_num(pDM_Odm);
+				pDM_FatTable->FAT_State = FAT_TRAINING_STATE;	
+				
+			}
+		}
+		pdm_sat_table->pre_fast_training_beam_num = pdm_sat_table->fast_training_beam_num;
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Update Pre_Beam =(( %d ))\n", pdm_sat_table->pre_fast_training_beam_num));
+	}
+	/*  [Prepare State] */
+	/*=======================================================================================*/
+	else if (pDM_FatTable->FAT_State == FAT_PREPARE_STATE) {
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\n\n[ 1. In Prepare State]\n"));
+
+		traffic_state = phydm_traffic_load_decision(pDM_Odm);
+
+		if (pdm_sat_table->pre_traffic_state == traffic_state) {
+			if (pdm_sat_table->decision_holding_period != 0) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Holding_period = (( %d )), return!!!\n", pdm_sat_table->decision_holding_period));
+				pdm_sat_table->decision_holding_period--;
+				return;
+			}
+		}
+		
+		pdm_sat_table->pre_traffic_state = traffic_state;
+		
+		
+		/* Set training packet number*/
+		if (pdm_sat_table->fix_training_num_en == 0) {
+
+			switch (traffic_state) {
+
+			case TRAFFIC_HIGH: 
+				pdm_sat_table->per_beam_training_pkt_num = 20;
+				pdm_sat_table->decision_holding_period = 0;
+				break;
+			case TRAFFIC_MID: 
+				pdm_sat_table->per_beam_training_pkt_num = 10;
+				pdm_sat_table->decision_holding_period = 1;
+				break;
+			case TRAFFIC_LOW: 
+				pdm_sat_table->per_beam_training_pkt_num = 5; /*ping 60000*/
+				pdm_sat_table->decision_holding_period = 3;
+				break;
+			case TRAFFIC_ULTRA_LOW: 
+				pdm_sat_table->per_beam_training_pkt_num = 2;
+				pdm_sat_table->decision_holding_period = 5;
+				break;
+			default:
+				break;			
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Fix_training_num = (( %d )), per_beam_training_pkt_num = (( %d ))\n",
+			pdm_sat_table->fix_training_num_en , pdm_sat_table->per_beam_training_pkt_num));
+		
+		/* Set training MAC Addr. of target */
+		odm_SetNextMACAddrTarget(pDM_Odm);
+
+		phydm_FastTraining_enable(pDM_Odm , FAT_ON);
+		odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+		pdm_sat_table->pkt_counter = 0;
+		pdm_sat_table->fast_training_beam_num = 0;
+		phydm_set_all_ant_same_beam_num(pDM_Odm);
+		pdm_sat_table->pre_fast_training_beam_num = pdm_sat_table->fast_training_beam_num;
+		pDM_FatTable->FAT_State = FAT_TRAINING_STATE;
+	}
+		
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+phydm_beam_switch_workitem_callback(
+	IN	PVOID	pContext
+	)
+{
+	PADAPTER		pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+
+	#if DEV_BUS_TYPE != RT_PCI_INTERFACE
+	pdm_sat_table->pkt_skip_statistic_en = 1;
+	#endif
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Beam Switch Workitem Callback, pkt_skip_statistic_en = (( %d ))\n", pdm_sat_table->pkt_skip_statistic_en));
+	
+	phydm_update_beam_pattern(pDM_Odm, pdm_sat_table->update_beam_codeword, pdm_sat_table->data_codeword_bit_num);
+
+	#if DEV_BUS_TYPE != RT_PCI_INTERFACE
+	/*ODM_StallExecution(pdm_sat_table->latch_time);*/
+	pdm_sat_table->pkt_skip_statistic_en = 0;
+	#endif
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pkt_skip_statistic_en = (( %d )), latch_time = (( %d ))\n", pdm_sat_table->pkt_skip_statistic_en, pdm_sat_table->latch_time));
+}
+
+VOID
+phydm_beam_decision_workitem_callback(
+	IN	PVOID	pContext
+	)
+{
+	PADAPTER		pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] Beam decision Workitem Callback\n"));
+	odm_FastAntTraining_hl_smart_antenna_type1(pDM_Odm);
+}
+#endif
+
+#endif /*#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1*/
+
+VOID
+ODM_AntDivInit(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!]   Not Support Antenna Diversity Function\n"));
+		return;
+	}
+        //---
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	if(pDM_FatTable->AntDiv_2G_5G == ODM_ANTDIV_2G)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[2G AntDiv Init]: Only Support 2G Antenna Diversity Function\n"));
+		if(!(pDM_Odm->SupportICType & ODM_ANTDIV_2G_SUPPORT_IC))
+			return;
+	}
+	else 	if(pDM_FatTable->AntDiv_2G_5G == ODM_ANTDIV_5G)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[5G AntDiv Init]: Only Support 5G Antenna Diversity Function\n"));
+		if(!(pDM_Odm->SupportICType & ODM_ANTDIV_5G_SUPPORT_IC))
+			return;
+	}
+	else 	if(pDM_FatTable->AntDiv_2G_5G == (ODM_ANTDIV_2G|ODM_ANTDIV_5G))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[2G & 5G AntDiv Init]:Support Both 2G & 5G Antenna Diversity Function\n"));
+	}
+
+#endif	
+	//---
+
+	//2 [--General---]
+	pDM_Odm->antdiv_period=0;
+
+	pDM_FatTable->bBecomeLinked =FALSE;
+	pDM_FatTable->AntDiv_OnOff =0xff;
+
+	//3       -   AP   -
+	#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	
+		#ifdef BEAMFORMING_SUPPORT
+		#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+		odm_BDC_Init(pDM_Odm);
+		#endif
+		#endif
+		
+	//3     -   WIN   -
+	#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		pDM_SWAT_Table->Ant5G = MAIN_ANT;
+		pDM_SWAT_Table->Ant2G = MAIN_ANT;
+		pDM_FatTable->CCK_counter_main=0;
+		pDM_FatTable->CCK_counter_aux=0;
+		pDM_FatTable->OFDM_counter_main=0;
+		pDM_FatTable->OFDM_counter_aux=0;
+	#endif
+
+	//2 [---Set MAIN_ANT as default antenna if Auto-Ant enable---]
+	odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+
+	pDM_Odm->AntType = ODM_AUTO_ANT;
+
+	pDM_FatTable->RxIdleAnt = ANTDIV_INIT;
+	ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+		
+	//2 [---Set TX Antenna---]
+	odm_Tx_By_TxDesc_or_Reg(pDM_Odm , REG);
+
+		
+	//2 [--88E---]
+	if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+	#if (RTL8188E_SUPPORT == 1)
+		//pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+		//pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+		//pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+
+		if( (pDM_Odm->AntDivType != CGCS_RX_HW_ANTDIV)  && (pDM_Odm->AntDivType != CG_TRX_HW_ANTDIV) && (pDM_Odm->AntDivType != CG_TRX_SMART_ANTDIV))
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!]  88E Not Supprrt This AntDiv Type\n"));
+			pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+			return;
+		}
+		
+		if(pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV)
+			odm_RX_HWAntDiv_Init_88E(pDM_Odm);
+		else if(pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
+			odm_TRX_HWAntDiv_Init_88E(pDM_Odm);
+		#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+		else if(pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV)
+			odm_Smart_HWAntDiv_Init_88E(pDM_Odm);
+	        #endif	
+	#endif
+	}
+	
+	//2 [--92E---]
+	#if (RTL8192E_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{	
+		//pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+		//pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+		//pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+
+		if( (pDM_Odm->AntDivType != CGCS_RX_HW_ANTDIV) && (pDM_Odm->AntDivType != CG_TRX_HW_ANTDIV)   && (pDM_Odm->AntDivType != CG_TRX_SMART_ANTDIV))
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!]  8192E Not Supprrt This AntDiv Type\n"));
+			pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+			return;
+		}
+		
+		if(pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV)
+			odm_RX_HWAntDiv_Init_92E(pDM_Odm);
+		else if(pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
+			odm_TRX_HWAntDiv_Init_92E(pDM_Odm);
+		#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+		else if(pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV)
+			odm_Smart_HWAntDiv_Init_92E(pDM_Odm);
+		#endif
+	
+	}
+	#endif	
+	
+	//2 [--8723B---]
+	#if (RTL8723B_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{		
+		//pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+		//pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+
+		if(pDM_Odm->AntDivType != S0S1_SW_ANTDIV && pDM_Odm->AntDivType != CG_TRX_HW_ANTDIV)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!] 8723B  Not Supprrt This AntDiv Type\n"));
+			pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+			return;
+		}
+			
+		if( pDM_Odm->AntDivType==S0S1_SW_ANTDIV)
+			odm_S0S1_SWAntDiv_Init_8723B(pDM_Odm);
+		else if(pDM_Odm->AntDivType==CG_TRX_HW_ANTDIV)
+			odm_TRX_HWAntDiv_Init_8723B(pDM_Odm);		
+	}
+	#endif
+	
+	//2 [--8811A 8821A---]
+	#if (RTL8821A_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+		pDM_Odm->AntDivType = HL_SW_SMART_ANT_TYPE1;
+		
+		if (pDM_Odm->AntDivType == HL_SW_SMART_ANT_TYPE1) {
+			
+			odm_TRX_HWAntDiv_Init_8821A(pDM_Odm);
+			phydm_hl_smart_ant_type1_init_8821a(pDM_Odm);
+		} else 
+		#endif
+		{
+			/*pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;*/
+			pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+				
+			if (pDM_Odm->AntDivType != CG_TRX_HW_ANTDIV && pDM_Odm->AntDivType != S0S1_SW_ANTDIV) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Return!!!] 8821A & 8811A  Not Supprrt This AntDiv Type\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+				return;
+			}
+			if (pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)	
+				odm_TRX_HWAntDiv_Init_8821A(pDM_Odm);
+			else if (pDM_Odm->AntDivType == S0S1_SW_ANTDIV)
+				odm_S0S1_SWAntDiv_Init_8821A(pDM_Odm);
+		}
+	}
+	#endif
+	
+	//2 [--8881A---]
+	#if (RTL8881A_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8881A)
+	{
+			//pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+			//pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+			
+			if(pDM_Odm->AntDivType != CGCS_RX_HW_ANTDIV && pDM_Odm->AntDivType != CG_TRX_HW_ANTDIV)
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!] 8881A  Not Supprrt This AntDiv Type\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+				return;
+			}
+			if(pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV)
+				odm_RX_HWAntDiv_Init_8881A(pDM_Odm);
+			else if(pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
+				odm_TRX_HWAntDiv_Init_8881A(pDM_Odm);	
+	}
+	#endif
+	
+	//2 [--8812---]
+	#if (RTL8812A_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{	
+			//pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+			
+			if( pDM_Odm->AntDivType != CG_TRX_HW_ANTDIV)
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!] 8812A  Not Supprrt This AntDiv Type\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+				return;
+			}
+			odm_TRX_HWAntDiv_Init_8812A(pDM_Odm);
+	}
+	#endif
+	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** SupportICType=[%lu] \n",pDM_Odm->SupportICType));
+	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** AntDiv SupportAbility=[%lu] \n",(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)>>6));
+	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** AntDiv Type=[%d] \n",pDM_Odm->AntDivType));
+
+}
+
+VOID
+ODM_AntDiv(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	#endif
+
+	if(*pDM_Odm->pBandType == ODM_BAND_5G )
+	{
+		if(pDM_FatTable->idx_AntDiv_counter_5G <  pDM_Odm->antdiv_period )
+		{
+			pDM_FatTable->idx_AntDiv_counter_5G++;
+			return;
+		}
+		else
+			pDM_FatTable->idx_AntDiv_counter_5G=0;
+	}
+	else 	if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+	{
+		if(pDM_FatTable->idx_AntDiv_counter_2G <  pDM_Odm->antdiv_period )
+		{
+			pDM_FatTable->idx_AntDiv_counter_2G++;
+			return;
+		}
+		else
+			pDM_FatTable->idx_AntDiv_counter_2G=0;
+	}
+	
+	//----------
+	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[Return!!!]   Not Support Antenna Diversity Function\n"));
+		return;
+	}
+
+	//----------
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	if (pDM_FatTable->enable_ctrl_frame_antdiv) {
+		
+		if ((pDM_Odm->data_frame_num <= 10) && (pDM_Odm->bLinked))
+			pDM_FatTable->use_ctrl_frame_antdiv = 1;
+		else
+			pDM_FatTable->use_ctrl_frame_antdiv = 0;
+		
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("use_ctrl_frame_antdiv = (( %d )), data_frame_num = (( %d ))\n", pDM_FatTable->use_ctrl_frame_antdiv, pDM_Odm->data_frame_num));
+		pDM_Odm->data_frame_num = 0;
+	}
+
+	if(pAdapter->MgntInfo.AntennaTest)
+		return;
+	
+        {
+	#if (BEAMFORMING_SUPPORT == 1)			
+	        BEAMFORMING_CAP		BeamformCap = (pDM_Odm->BeamformingInfo.BeamformCap);
+
+		if( BeamformCap & BEAMFORMEE_CAP ) //  BFmee On  &&   Div On ->  Div Off
+		{	
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[ AntDiv : OFF ]   BFmee ==1 \n"));
+			if(pDM_FatTable->fix_ant_bfee == 0)
+			{
+				odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+				pDM_FatTable->fix_ant_bfee = 1;
+			}
+			return;
+		}
+		else // BFmee Off   &&   Div Off ->  Div On
+		{
+			if((pDM_FatTable->fix_ant_bfee == 1)  &&  pDM_Odm->bLinked) 
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ AntDiv : ON ]   BFmee ==0\n"));
+				if((pDM_Odm->AntDivType!=S0S1_SW_ANTDIV) )
+					odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
+
+				pDM_FatTable->fix_ant_bfee = 0;
+			}
+		}
+	#endif	
+	}
+#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	//----------just for fool proof
+
+	if(pDM_Odm->antdiv_rssi)
+		pDM_Odm->DebugComponents |= ODM_COMP_ANT_DIV;
+	else
+		pDM_Odm->DebugComponents &= ~ODM_COMP_ANT_DIV;
+
+	if(pDM_FatTable->AntDiv_2G_5G == ODM_ANTDIV_2G)
+	{
+		//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[ 2G AntDiv Running ]\n"));
+		if(!(pDM_Odm->SupportICType & ODM_ANTDIV_2G_SUPPORT_IC))
+			return;
+	}
+	else if(pDM_FatTable->AntDiv_2G_5G == ODM_ANTDIV_5G)
+	{
+		//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[ 5G AntDiv Running ]\n"));
+		if(!(pDM_Odm->SupportICType & ODM_ANTDIV_5G_SUPPORT_IC))
+			return;
+	}
+	//else 	if(pDM_FatTable->AntDiv_2G_5G == (ODM_ANTDIV_2G|ODM_ANTDIV_5G))
+	//{
+		//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("[ 2G & 5G AntDiv Running ]\n"));
+	//}
+#endif
+
+	//----------
+
+	if (pDM_Odm->antdiv_select==1)
+		pDM_Odm->AntType = ODM_FIX_MAIN_ANT;
+	else if (pDM_Odm->antdiv_select==2)
+		pDM_Odm->AntType = ODM_FIX_AUX_ANT;
+	else  //if (pDM_Odm->antdiv_select==0)
+		pDM_Odm->AntType = ODM_AUTO_ANT;
+
+	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("AntType= (( %d )) , pre_AntType= (( %d ))  \n",pDM_Odm->AntType,pDM_Odm->pre_AntType));
+	
+	if(pDM_Odm->AntType != ODM_AUTO_ANT)
+	{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Fix Antenna at (( %s ))\n",(pDM_Odm->AntType == ODM_FIX_MAIN_ANT)?"MAIN":"AUX"));
+			
+		if(pDM_Odm->AntType != pDM_Odm->pre_AntType)
+		{
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , REG);
+						
+			if(pDM_Odm->AntType == ODM_FIX_MAIN_ANT)
+				ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+			else if(pDM_Odm->AntType == ODM_FIX_AUX_ANT)
+				ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+		}
+		pDM_Odm->pre_AntType=pDM_Odm->AntType; 
+		return;
+	}
+	else
+	{
+		if(pDM_Odm->AntType != pDM_Odm->pre_AntType)
+		{
+			odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
+			odm_Tx_By_TxDesc_or_Reg(pDM_Odm , TX_BY_DESC);
+		}
+		pDM_Odm->pre_AntType=pDM_Odm->AntType;
+	}
+	 
+	
+	//3 -----------------------------------------------------------------------------------------------------------
+	//2 [--88E---]
+	if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		#if (RTL8188E_SUPPORT == 1)
+		if(pDM_Odm->AntDivType==CG_TRX_HW_ANTDIV ||pDM_Odm->AntDivType==CGCS_RX_HW_ANTDIV)
+			odm_HW_AntDiv(pDM_Odm);
+
+		#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+		else if (pDM_Odm->AntDivType==CG_TRX_SMART_ANTDIV)
+			odm_FastAntTraining(pDM_Odm);	
+		#endif
+		
+		#endif
+
+	}
+	//2 [--92E---]	
+	#if (RTL8192E_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		if(pDM_Odm->AntDivType==CGCS_RX_HW_ANTDIV || pDM_Odm->AntDivType==CG_TRX_HW_ANTDIV)
+			odm_HW_AntDiv(pDM_Odm);
+		
+		#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+		else if (pDM_Odm->AntDivType==CG_TRX_SMART_ANTDIV)
+			odm_FastAntTraining(pDM_Odm);	
+		#endif
+		
+	}
+	#endif
+
+	#if (RTL8723B_SUPPORT == 1)	
+	//2 [--8723B---]
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if (phydm_IsBtEnable_8723b(pDM_Odm)) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[BT is enable!!!] AntDiv: OFF\n"));
+			if (pDM_FatTable->bBecomeLinked == TRUE) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Set REG 948[9:6]=0x0\n"));
+				if (pDM_Odm->SupportICType == ODM_RTL8723B)
+					ODM_SetBBReg(pDM_Odm, 0x948 , BIT9|BIT8|BIT7|BIT6, 0x0); 
+				
+				pDM_FatTable->bBecomeLinked = FALSE;
+			}
+		} else {
+			if (pDM_Odm->AntDivType == S0S1_SW_ANTDIV) {
+				
+				#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+				odm_S0S1_SwAntDiv(pDM_Odm, SWAW_STEP_PEEK);
+				#endif
+			} else if (pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
+				odm_HW_AntDiv(pDM_Odm);
+		}
+	}
+	#endif
+	
+	//2 [--8821A---]
+	#if (RTL8821A_SUPPORT == 1)
+	else if (pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+		if (pDM_Odm->AntDivType == HL_SW_SMART_ANT_TYPE1) {
+
+			if (pdm_sat_table->fix_beam_pattern_en != 0) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" [ SmartAnt ] Fix SmartAnt Pattern = 0x%x\n", pdm_sat_table->fix_beam_pattern_codeword));
+				/*return;*/
+			} else {
+				/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ SmartAnt ] AntDivType = HL_SW_SMART_ANT_TYPE1\n"));*/
+				odm_FastAntTraining_hl_smart_antenna_type1(pDM_Odm);
+			}
+
+		} else 
+		#endif
+		{
+			if (!pDM_Odm->bBtEnabled)  /*BT disabled*/
+			{
+				if (pDM_Odm->AntDivType == S0S1_SW_ANTDIV) {
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" [S0S1_SW_ANTDIV]  ->  [CG_TRX_HW_ANTDIV]\n"));
+					/*ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, 1); */
+					if (pDM_FatTable->bBecomeLinked == TRUE)
+						odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
+				}
+				
+			} else { /*BT enabled*/
+			
+				if (pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV) {
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, (" [CG_TRX_HW_ANTDIV]  ->  [S0S1_SW_ANTDIV]\n"));
+					/*ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, 0);*/
+					odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
+				}	
+			}
+
+			if (pDM_Odm->AntDivType == S0S1_SW_ANTDIV) {
+
+				#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+				odm_S0S1_SwAntDiv(pDM_Odm, SWAW_STEP_PEEK);
+				#endif
+			} else if (pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
+				odm_HW_AntDiv(pDM_Odm);
+		}
+	}
+	#endif
+	
+	//2 [--8881A---]
+	#if (RTL8881A_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8881A)		
+		odm_HW_AntDiv(pDM_Odm);
+	#endif
+	
+	//2 [--8812A---]
+	#if (RTL8812A_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8812)
+		odm_HW_AntDiv(pDM_Odm);
+	#endif
+}
+
+
+VOID
+odm_AntselStatistics(
+	IN		PVOID			pDM_VOID,	
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			MacId,
+	IN		u4Byte			utility,
+	IN            u1Byte			method
+
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	if(method==RSSI_METHOD)
+	{
+		if(antsel_tr_mux == ANT1_2G)
+		{
+			pDM_FatTable->MainAnt_Sum[MacId]+=utility;
+			pDM_FatTable->MainAnt_Cnt[MacId]++;
+		}
+		else
+		{
+			pDM_FatTable->AuxAnt_Sum[MacId]+=utility;
+			pDM_FatTable->AuxAnt_Cnt[MacId]++;
+		}
+	}
+	#ifdef ODM_EVM_ENHANCE_ANTDIV
+	else if(method==EVM_METHOD)
+	{
+		if(antsel_tr_mux == ANT1_2G)
+		{
+			pDM_FatTable->MainAntEVM_Sum[MacId]+=(utility<<5);
+			pDM_FatTable->MainAntEVM_Cnt[MacId]++;
+		}
+		else
+		{
+			pDM_FatTable->AuxAntEVM_Sum[MacId]+=(utility<<5);
+			pDM_FatTable->AuxAntEVM_Cnt[MacId]++;
+		}
+	}
+	else if(method==CRC32_METHOD)
+	{
+		if(utility==0)
+			pDM_FatTable->CRC32_Fail_Cnt++;
+		else
+			pDM_FatTable->CRC32_Ok_Cnt+=utility;
+	}
+	#endif
+}
+
+
+VOID
+ODM_Process_RSSIForAntDiv(	
+	IN OUT		PVOID			pDM_VOID,	
+	IN			PVOID			p_phy_info_void,
+	IN			PVOID			p_pkt_info_void
+	//IN		PODM_PHY_INFO_T				pPhyInfo,
+	//IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_PHY_INFO_T 	pPhyInfo=(PODM_PHY_INFO_T)p_phy_info_void;
+	PODM_PACKET_INFO_T	 pPktinfo=(PODM_PACKET_INFO_T)p_pkt_info_void;
+	u1Byte			isCCKrate=0,CCKMaxRate=ODM_RATE11M;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+	pSAT_T			pdm_sat_table = &(pDM_Odm->dm_sat_table);
+	u4Byte			beam_tmp;
+	#endif
+
+	#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN))
+	u4Byte			RxPower_Ant0, RxPower_Ant1;	
+	u4Byte			RxEVM_Ant0, RxEVM_Ant1;
+	#else
+	u1Byte			RxPower_Ant0, RxPower_Ant1;	
+	u1Byte			RxEVM_Ant0, RxEVM_Ant1;
+	#endif
+
+	CCKMaxRate=ODM_RATE11M;
+	isCCKrate = (pPktinfo->DataRate <= CCKMaxRate)?TRUE:FALSE;
+		
+	if ((pDM_Odm->SupportICType & (ODM_RTL8192E|ODM_RTL8812)) && (pPktinfo->DataRate > CCKMaxRate))
+	{
+		RxPower_Ant0 = pPhyInfo->RxMIMOSignalStrength[0];
+		RxPower_Ant1= pPhyInfo->RxMIMOSignalStrength[1];
+
+		RxEVM_Ant0 =pPhyInfo->RxMIMOSignalQuality[0];
+		RxEVM_Ant1 =pPhyInfo->RxMIMOSignalQuality[1];
+	}
+	else
+		RxPower_Ant0=pPhyInfo->RxPWDBAll;
+
+	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+	if (pDM_Odm->AntDivType == HL_SW_SMART_ANT_TYPE1)
+	{
+		if ((pDM_Odm->SupportICType & ODM_HL_SMART_ANT_TYPE1_SUPPORT) && 
+			(pPktinfo->bPacketToSelf)   && 
+			(pDM_FatTable->FAT_State == FAT_TRAINING_STATE)
+			) {
+			
+			if (pdm_sat_table->pkt_skip_statistic_en == 0) {
+				/*
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("StaID[%d]:  antsel_pathA = ((%d)), hw_antsw_occur = ((%d)), Beam_num = ((%d)), RSSI = ((%d))\n",
+					pPktinfo->StationID, pDM_FatTable->antsel_rx_keep_0, pDM_FatTable->hw_antsw_occur, pdm_sat_table->fast_training_beam_num, RxPower_Ant0));
+				*/
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("StaID[%d]:  antsel_pathA = ((%d)), bPacketToSelf = ((%d)), Beam_num = ((%d)), RSSI = ((%d))\n",
+					pPktinfo->StationID, pDM_FatTable->antsel_rx_keep_0, pPktinfo->bPacketToSelf, pdm_sat_table->fast_training_beam_num, RxPower_Ant0));
+
+				
+				pdm_sat_table->pkt_rssi_sum[pDM_FatTable->antsel_rx_keep_0][pdm_sat_table->fast_training_beam_num] += RxPower_Ant0;
+				pdm_sat_table->pkt_rssi_cnt[pDM_FatTable->antsel_rx_keep_0][pdm_sat_table->fast_training_beam_num]++;
+				pdm_sat_table->pkt_counter++;
+			
+				/*swich beam every N pkt*/
+				if ((pdm_sat_table->pkt_counter) >= (pdm_sat_table->per_beam_training_pkt_num)) {
+
+					pdm_sat_table->pkt_counter = 0;
+					beam_tmp = pdm_sat_table->fast_training_beam_num;
+									
+					if (pdm_sat_table->fast_training_beam_num >= (pdm_sat_table->beam_patten_num_each_ant-1)) {
+						
+						pDM_FatTable->FAT_State = FAT_DECISION_STATE;
+						
+						#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+						odm_FastAntTraining_hl_smart_antenna_type1(pDM_Odm);
+						#else
+						ODM_ScheduleWorkItem(&pdm_sat_table->hl_smart_antenna_decision_workitem);
+						#endif
+
+
+					} else {
+						pdm_sat_table->fast_training_beam_num++;
+						phydm_set_all_ant_same_beam_num(pDM_Odm);
+						
+						pDM_FatTable->FAT_State = FAT_TRAINING_STATE;	
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Update  Beam_num (( %d )) -> (( %d ))\n", beam_tmp, pdm_sat_table->fast_training_beam_num));
+					}
+				}
+			}
+		}
+	} else 
+	#endif
+	if (pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV) {
+		if( (pDM_Odm->SupportICType & ODM_SMART_ANT_SUPPORT) &&  (pPktinfo->bPacketToSelf)   && (pDM_FatTable->FAT_State == FAT_TRAINING_STATE) )//(pPktinfo->bPacketMatchBSSID && (!pPktinfo->bPacketBeacon))
+		{
+			u1Byte	antsel_tr_mux;
+			antsel_tr_mux = (pDM_FatTable->antsel_rx_keep_2<<2) |(pDM_FatTable->antsel_rx_keep_1 <<1) |pDM_FatTable->antsel_rx_keep_0;
+			pDM_FatTable->antSumRSSI[antsel_tr_mux] += RxPower_Ant0;
+			pDM_FatTable->antRSSIcnt[antsel_tr_mux]++;
+		}
+	}
+	else //AntDivType != CG_TRX_SMART_ANTDIV 
+	{
+		if ((pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT) && (pPktinfo->bPacketToSelf || pDM_FatTable->use_ctrl_frame_antdiv))
+		{
+			if(pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E)
+			{
+				odm_AntselStatistics(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPktinfo->StationID,RxPower_Ant0,RSSI_METHOD);
+
+				#ifdef ODM_EVM_ENHANCE_ANTDIV
+				if(!isCCKrate)
+				{
+					odm_AntselStatistics(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPktinfo->StationID,RxEVM_Ant0,EVM_METHOD);
+				}
+				#endif
+			}
+			else// SupportICType == ODM_RTL8821 and ODM_RTL8723B and ODM_RTL8812)
+			{
+				if(isCCKrate && (pDM_Odm->AntDivType == S0S1_SW_ANTDIV))
+				{
+				 	pDM_FatTable->antsel_rx_keep_0 = (pDM_FatTable->RxIdleAnt == MAIN_ANT) ? ANT1_2G : ANT2_2G;
+
+
+					if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
+						pDM_FatTable->CCK_counter_main++;
+					else// if(pDM_FatTable->antsel_rx_keep_0==ANT2_2G)
+						pDM_FatTable->CCK_counter_aux++;
+
+					odm_AntselStatistics(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPktinfo->StationID, RxPower_Ant0,RSSI_METHOD);
+				}
+				else
+				{
+					if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
+						pDM_FatTable->OFDM_counter_main++;
+					else// if(pDM_FatTable->antsel_rx_keep_0==ANT2_2G)
+						pDM_FatTable->OFDM_counter_aux++;
+					odm_AntselStatistics(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPktinfo->StationID, RxPower_Ant0,RSSI_METHOD);
+				}
+			}
+		}
+	}
+	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("isCCKrate=%d, PWDB_ALL=%d\n",isCCKrate, pPhyInfo->RxPWDBAll));
+	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("antsel_tr_mux=3'b%d%d%d\n",pDM_FatTable->antsel_rx_keep_2, pDM_FatTable->antsel_rx_keep_1, pDM_FatTable->antsel_rx_keep_0));
+}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+VOID
+ODM_SetTxAntByTxInfo(
+	IN		PVOID			pDM_VOID,	
+	IN		pu1Byte			pDesc,
+	IN		u1Byte			macId	
+
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	if (!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+		return;
+
+	if (pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV)
+		return;
+
+
+	if (pDM_Odm->SupportICType == ODM_RTL8723B) {
+#if (RTL8723B_SUPPORT == 1)
+		SET_TX_DESC_ANTSEL_A_8723B(pDesc, pDM_FatTable->antsel_a[macId]);
+		/*ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[8723B] SetTxAntByTxInfo_WIN: MacID=%d, antsel_tr_mux=3'b%d%d%d\n", 
+			macId, pDM_FatTable->antsel_c[macId], pDM_FatTable->antsel_b[macId], pDM_FatTable->antsel_a[macId]));*/
+#endif
+	} else if (pDM_Odm->SupportICType == ODM_RTL8821) {
+#if (RTL8821A_SUPPORT == 1)
+		SET_TX_DESC_ANTSEL_A_8812(pDesc, pDM_FatTable->antsel_a[macId]);
+		/*ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[8821A] SetTxAntByTxInfo_WIN: MacID=%d, antsel_tr_mux=3'b%d%d%d\n", 
+			macId, pDM_FatTable->antsel_c[macId], pDM_FatTable->antsel_b[macId], pDM_FatTable->antsel_a[macId]));*/
+#endif
+	} else if (pDM_Odm->SupportICType == ODM_RTL8188E) {
+#if (RTL8188E_SUPPORT == 1)
+		SET_TX_DESC_ANTSEL_A_88E(pDesc, pDM_FatTable->antsel_a[macId]);
+		SET_TX_DESC_ANTSEL_B_88E(pDesc, pDM_FatTable->antsel_b[macId]);
+		SET_TX_DESC_ANTSEL_C_88E(pDesc, pDM_FatTable->antsel_c[macId]);
+		/*ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[8188E] SetTxAntByTxInfo_WIN: MacID=%d, antsel_tr_mux=3'b%d%d%d\n", 
+			macId, pDM_FatTable->antsel_c[macId], pDM_FatTable->antsel_b[macId], pDM_FatTable->antsel_a[macId]));*/
+#endif
+	}
+}
+#elif(DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+VOID
+ODM_SetTxAntByTxInfo(
+	struct	rtl8192cd_priv		*priv,
+	struct	tx_desc	*pdesc,
+	unsigned short			aid	
+)
+{
+	pFAT_T		pDM_FatTable = &priv->pshare->_dmODM.DM_FatTable;
+	u4Byte		SupportICType = priv->pshare->_dmODM.SupportICType;
+
+	if (SupportICType == ODM_RTL8881A) {
+		/*panic_printk("[%s] [%d]   ******ODM_SetTxAntByTxInfo_8881E******\n",__FUNCTION__,__LINE__);	*/
+		pdesc->Dword6 &= set_desc(~(BIT(18)|BIT(17)|BIT(16)));	
+		pdesc->Dword6 |= set_desc(pDM_FatTable->antsel_a[aid]<<16);
+	} else if (SupportICType == ODM_RTL8192E) {
+		/*panic_printk("[%s] [%d]   ******ODM_SetTxAntByTxInfo_8192E******\n",__FUNCTION__,__LINE__);	*/
+		pdesc->Dword6 &= set_desc(~(BIT(18)|BIT(17)|BIT(16)));	
+		pdesc->Dword6 |= set_desc(pDM_FatTable->antsel_a[aid]<<16);
+	} else if (SupportICType == ODM_RTL8188E) {
+		/*panic_printk("[%s] [%d]   ******ODM_SetTxAntByTxInfo_8188E******\n",__FUNCTION__,__LINE__);*/
+		pdesc->Dword2 &= set_desc(~BIT(24));
+		pdesc->Dword2 &= set_desc(~BIT(25));
+		pdesc->Dword7 &= set_desc(~BIT(29));
+
+		pdesc->Dword2 |= set_desc(pDM_FatTable->antsel_a[aid]<<24);
+		pdesc->Dword2 |= set_desc(pDM_FatTable->antsel_b[aid]<<25);
+		pdesc->Dword7 |= set_desc(pDM_FatTable->antsel_c[aid]<<29);
+			
+		
+	} else if (SupportICType == ODM_RTL8812) {
+		/*[path-A]*/
+		/*panic_printk("[%s] [%d]   ******ODM_SetTxAntByTxInfo_8881E******\n",__FUNCTION__,__LINE__);*/
+			
+		pdesc->Dword6 &= set_desc(~BIT(16));
+		pdesc->Dword6 &= set_desc(~BIT(17));
+		pdesc->Dword6 &= set_desc(~BIT(18));
+
+		pdesc->Dword6 |= set_desc(pDM_FatTable->antsel_a[aid]<<16);
+		pdesc->Dword6 |= set_desc(pDM_FatTable->antsel_b[aid]<<17);
+		pdesc->Dword6 |= set_desc(pDM_FatTable->antsel_c[aid]<<18);
+			
+	}
+}
+#endif
+
+
+VOID
+ODM_AntDiv_Config(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("WIN Config Antenna Diversity\n"));
+		if(pDM_Odm->SupportICType==ODM_RTL8723B)
+		{
+			if((!pDM_Odm->DM_SWAT_Table.ANTA_ON || !pDM_Odm->DM_SWAT_Table.ANTB_ON))
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		}
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("CE Config Antenna Diversity\n"));
+		if(pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT)
+		{
+			pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;	
+		}
+		
+		if(pDM_Odm->SupportICType==ODM_RTL8723B)
+		{
+			pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+		}				
+
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("AP Config Antenna Diversity\n"));
+
+	//2 [ NOT_SUPPORT_ANTDIV ]
+	#if(defined(CONFIG_NOT_SUPPORT_ANTDIV)) 
+		pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Disable AntDiv function] : Not Support 2.4G & 5G Antenna Diversity\n"));
+		
+		//2 [ 2G&5G_SUPPORT_ANTDIV ]
+	#elif(defined(CONFIG_2G5G_SUPPORT_ANTDIV))
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : 2.4G & 5G Support Antenna Diversity Simultaneously \n"));
+		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_2G|ODM_ANTDIV_5G);
+
+		if(pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT)
+			pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
+		if(*pDM_Odm->pBandType == ODM_BAND_5G )
+		{
+				#if ( defined(CONFIG_5G_CGCS_RX_DIVERSITY) )
+					pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV; 
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
+					panic_printk("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n");
+				#elif( defined(CONFIG_5G_CG_TRX_DIVERSITY)||defined(CONFIG_2G5G_CG_TRX_DIVERSITY_8881A))
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));				
+					panic_printk("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n");
+				#elif( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_5G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}		
+		else if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+		 {
+				#if ( defined(CONFIG_2G_CGCS_RX_DIVERSITY) )
+						pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));		
+				#elif( defined(CONFIG_2G_CG_TRX_DIVERSITY) || defined(CONFIG_2G5G_CG_TRX_DIVERSITY_8881A))
+						pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+						pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}
+		
+		//2 [ 5G_SUPPORT_ANTDIV ]
+	#elif(defined(CONFIG_5G_SUPPORT_ANTDIV))
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : Only 5G Support Antenna Diversity\n"));
+		panic_printk("[ Enable AntDiv function] : Only 5G Support Antenna Diversity\n");
+		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_5G);
+		if(*pDM_Odm->pBandType == ODM_BAND_5G )
+		{
+				if(pDM_Odm->SupportICType & ODM_ANTDIV_5G_SUPPORT_IC)
+				pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;	
+				#if ( defined(CONFIG_5G_CGCS_RX_DIVERSITY) )
+					pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
+					panic_printk("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n");
+				#elif( defined(CONFIG_5G_CG_TRX_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					panic_printk("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n");
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
+				#elif( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_5G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}
+		else if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+		{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Not Support 2G AntDivType\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		}
+		
+		//2 [ 2G_SUPPORT_ANTDIV ]
+	#elif(defined(CONFIG_2G_SUPPORT_ANTDIV)) 
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : Only 2.4G Support Antenna Diversity\n"));
+		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_2G);
+		if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+		{
+				if(pDM_Odm->SupportICType & ODM_ANTDIV_2G_SUPPORT_IC)
+					pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
+				#if ( defined(CONFIG_2G_CGCS_RX_DIVERSITY) )
+					pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));		
+				#elif( defined(CONFIG_2G_CG_TRX_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}
+		else if(*pDM_Odm->pBandType == ODM_BAND_5G )
+		{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Not Support 5G AntDivType\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		}
+	#endif	
+#endif	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SupportAbility = (( %x ))\n", pDM_Odm->SupportAbility ));
+
+}
+
+
+VOID
+ODM_AntDivTimers(
+	IN		PVOID		pDM_VOID,	
+	IN 		u1Byte		state
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(state==INIT_ANTDIV_TIMMER)
+	{
+		#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+			ODM_InitializeTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B,
+			(RT_TIMER_CALL_BACK)ODM_SW_AntDiv_Callback, NULL, "SwAntennaSwitchTimer_8723B");
+		#elif ( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+			ODM_InitializeTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer,
+			(RT_TIMER_CALL_BACK)odm_FastAntTrainingCallback, NULL, "FastAntTrainingTimer");
+		#endif
+
+		#ifdef ODM_EVM_ENHANCE_ANTDIV
+			ODM_InitializeTimer(pDM_Odm,&pDM_Odm->EVM_FastAntTrainingTimer,
+			(RT_TIMER_CALL_BACK)odm_EVM_FastAntTrainingCallback, NULL, "EVM_FastAntTrainingTimer");
+		#endif
+	}
+	else if(state==CANCEL_ANTDIV_TIMMER)
+	{
+		#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+			ODM_CancelTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
+		#elif ( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+			ODM_CancelTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer);
+		#endif
+
+		#ifdef ODM_EVM_ENHANCE_ANTDIV
+			ODM_CancelTimer(pDM_Odm,&pDM_Odm->EVM_FastAntTrainingTimer);
+		#endif
+	}
+	else if(state==RELEASE_ANTDIV_TIMMER)
+	{
+		#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+			ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
+		#elif ( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+			ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer);
+		#endif
+
+		#ifdef ODM_EVM_ENHANCE_ANTDIV
+			ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->EVM_FastAntTrainingTimer);
+		#endif
+	}
+
+}
+
+#endif /*#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))*/
+
+VOID
+ODM_AntDivReset(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//2 [--8723B---]
+#if (RTL8723B_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+		odm_S0S1_SWAntDiv_Reset_8723B(pDM_Odm);
+		#endif
+	}
+#endif
+}
+
+VOID
+odm_AntennaDiversityInit(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(pDM_Odm->mp_mode == TRUE)
+		return;
+
+	#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+		ODM_AntDiv_Config(pDM_Odm);
+		ODM_AntDivInit(pDM_Odm);
+	#endif
+}
+
+VOID
+odm_AntennaDiversity(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(pDM_Odm->mp_mode == TRUE)
+		return;
+
+	#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+		ODM_AntDiv(pDM_Odm);
+	#endif
+}
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.h
new file mode 100644
index 000000000..4377bca14
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_antdiv.h
@@ -0,0 +1,594 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__PHYDMANTDIV_H__
+#define    __PHYDMANTDIV_H__
+
+/*#define ANTDIV_VERSION	"2.0"  //2014.11.04*/
+/*#define ANTDIV_VERSION	"2.1"  //2015.01.13  Dino*/
+/*#define ANTDIV_VERSION	"2.2"  2015.01.16  Dino*/
+/*#define ANTDIV_VERSION	"3.1"  2015.07.29  YuChen, remove 92c 92d 8723a*/
+/*#define ANTDIV_VERSION	"3.2"  2015.08.11  Stanley, disable antenna diversity when BT is enable for 8723B*/
+#define ANTDIV_VERSION	"3.3"  /*2015.08.12  Stanley. 8723B does not need to check the antenna is control by BT, 
+because antenna diversity only works when BT is disable or radio off*/
+
+//1 ============================================================
+//1  Definition 
+//1 ============================================================
+
+#define	ANTDIV_INIT		0xff
+#define	MAIN_ANT	1		//Ant A or Ant Main
+#define	AUX_ANT		2		//AntB or Ant Aux
+#define	MAX_ANT		3		// 3 for AP using
+
+#define ANT1_2G 0 // = ANT2_5G
+#define ANT2_2G 1 // = ANT1_5G
+/*smart antenna*/
+#define SUPPORT_RF_PATH_NUM 4
+#define SUPPORT_BEAM_PATTERN_NUM 4
+
+
+//Antenna Diversty Control Type
+#define	ODM_AUTO_ANT	0
+#define	ODM_FIX_MAIN_ANT	1
+#define	ODM_FIX_AUX_ANT	2
+
+#define ODM_ANTDIV_SUPPORT		(ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8821|ODM_RTL8881A|ODM_RTL8812)
+#define ODM_N_ANTDIV_SUPPORT		(ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B)
+#define ODM_AC_ANTDIV_SUPPORT		(ODM_RTL8821|ODM_RTL8881A|ODM_RTL8812)
+#define ODM_SMART_ANT_SUPPORT		(ODM_RTL8188E|ODM_RTL8192E)
+#define ODM_HL_SMART_ANT_TYPE1_SUPPORT		(ODM_RTL8821)
+
+#define ODM_ANTDIV_2G_SUPPORT_IC			(ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8881A)
+#define ODM_ANTDIV_5G_SUPPORT_IC			(ODM_RTL8821|ODM_RTL8881A|ODM_RTL8812)
+
+#define ODM_EVM_ENHANCE_ANTDIV_SUPPORT_IC	(ODM_RTL8192E)
+
+#define ODM_ANTDIV_2G	BIT0
+#define ODM_ANTDIV_5G	BIT1
+
+#define ANTDIV_ON 1
+#define ANTDIV_OFF 0
+
+#define FAT_ON 1
+#define FAT_OFF 0
+
+#define TX_BY_DESC 1
+#define REG 0
+
+#define RSSI_METHOD 0
+#define EVM_METHOD 1
+#define CRC32_METHOD 2
+
+#define INIT_ANTDIV_TIMMER 0
+#define CANCEL_ANTDIV_TIMMER 1
+#define RELEASE_ANTDIV_TIMMER 2
+
+#define CRC32_FAIL 1
+#define CRC32_OK 0
+
+#define Evm_RSSI_TH_High 25
+#define Evm_RSSI_TH_Low 20
+
+#define NORMAL_STATE_MIAN 1
+#define NORMAL_STATE_AUX 2
+#define TRAINING_STATE 3
+
+#define FORCE_RSSI_DIFF 10
+
+#define CSI_ON 1
+#define CSI_OFF 0
+
+#define DIVON_CSIOFF 1
+#define DIVOFF_CSION 2
+
+#define BDC_DIV_TRAIN_STATE 0
+#define BDC_BFer_TRAIN_STATE 1
+#define BDC_DECISION_STATE 2
+#define BDC_BF_HOLD_STATE 3
+#define BDC_DIV_HOLD_STATE 4
+
+#define BDC_MODE_1 1
+#define BDC_MODE_2 2
+#define BDC_MODE_3 3
+#define BDC_MODE_4 4
+#define BDC_MODE_NULL 0xff
+
+#define SWAW_STEP_PEEK		0
+#define SWAW_STEP_DETERMINE	1
+
+#define HL_SMTANT_2WIRE_DATA_LEN 24
+
+//1 ============================================================
+//1  structure
+//1 ============================================================
+
+
+typedef struct _SW_Antenna_Switch_
+{
+	u1Byte		Double_chk_flag;
+	u1Byte		try_flag;
+	s4Byte		PreRSSI;
+	u1Byte		CurAntenna;
+	u1Byte		PreAntenna;
+	u1Byte		RSSI_Trying;
+	u1Byte		TestMode;
+	u1Byte		bTriggerAntennaSwitch;
+	u1Byte		SelectAntennaMap;
+	u1Byte		RSSI_target;	
+	u1Byte 		reset_idx;
+	u2Byte		Single_Ant_Counter;
+	u2Byte		Dual_Ant_Counter;
+	u2Byte          Aux_FailDetec_Counter;
+	u2Byte          Retry_Counter;
+
+	// Before link Antenna Switch check
+	u1Byte		SWAS_NoLink_State;
+	u4Byte		SWAS_NoLink_BK_Reg860;
+	u4Byte		SWAS_NoLink_BK_Reg92c;
+	u4Byte		SWAS_NoLink_BK_Reg948;
+	BOOLEAN		ANTA_ON;	//To indicate Ant A is or not
+	BOOLEAN		ANTB_ON;	//To indicate Ant B is on or not
+	BOOLEAN		Pre_Aux_FailDetec;
+	BOOLEAN		RSSI_AntDect_bResult;	
+	u1Byte		Ant5G;
+	u1Byte		Ant2G;
+
+	s4Byte		RSSI_sum_A;
+	s4Byte		RSSI_sum_B;
+	s4Byte		RSSI_cnt_A;
+	s4Byte		RSSI_cnt_B;
+
+	u8Byte		lastTxOkCnt;
+	u8Byte		lastRxOkCnt;
+	u8Byte 		TXByteCnt_A;
+	u8Byte 		TXByteCnt_B;
+	u8Byte 		RXByteCnt_A;
+	u8Byte 		RXByteCnt_B;
+	u1Byte 		TrafficLoad;
+	u1Byte		Train_time;
+	u1Byte		Train_time_flag;
+	RT_TIMER 	SwAntennaSwitchTimer;
+#if (RTL8723B_SUPPORT == 1) || (RTL8821A_SUPPORT == 1) || (RTL8188F_SUPPORT == 1)
+	RT_TIMER 	SwAntennaSwitchTimer_8723B;
+	u4Byte		PktCnt_SWAntDivByCtrlFrame;
+	BOOLEAN		bSWAntDivByCtrlFrame;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	#if USE_WORKITEM
+	RT_WORK_ITEM			SwAntennaSwitchWorkitem;
+	#if (RTL8723B_SUPPORT == 1) || (RTL8821A_SUPPORT == 1)	
+	RT_WORK_ITEM			SwAntennaSwitchWorkitem_8723B;	
+	#endif
+	#endif
+#endif
+
+#ifdef CONFIG_PHYDM_ANTENNA_DIVERSITY
+	//Hybrid Antenna Diversity
+	u4Byte		CCK_Ant1_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte		CCK_Ant2_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte		OFDM_Ant1_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte		OFDM_Ant2_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte		RSSI_Ant1_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte		RSSI_Ant2_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u1Byte		TxAnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u1Byte		TargetSTA;
+	u1Byte		antsel;
+	u1Byte		RxIdleAnt;
+
+#endif
+	
+}SWAT_T, *pSWAT_T;
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+typedef struct _BF_DIV_COEX_
+{
+	BOOLEAN w_BFer_Client[ODM_ASSOCIATE_ENTRY_NUM];
+	BOOLEAN w_BFee_Client[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	MA_rx_TP[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	MA_rx_TP_DIV[ODM_ASSOCIATE_ENTRY_NUM];
+
+	u1Byte  BDCcoexType_wBfer;
+	u1Byte num_Txbfee_Client;
+	u1Byte num_Txbfer_Client;
+	u1Byte BDC_Try_counter;
+	u1Byte BDC_Hold_counter;
+	u1Byte BDC_Mode;
+	u1Byte BDC_active_Mode;
+	u1Byte BDC_state;
+	u1Byte BDC_RxIdleUpdate_counter;
+	u1Byte num_Client;
+	u1Byte pre_num_Client;
+	u1Byte num_BfTar;
+	u1Byte num_DivTar;
+	
+	BOOLEAN bAll_DivSta_Idle;
+	BOOLEAN bAll_BFSta_Idle;
+	BOOLEAN BDC_Try_flag;
+	BOOLEAN BF_pass;
+	BOOLEAN DIV_pass;	
+}BDC_T,*pBDC_T;
+#endif
+#endif
+
+#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+typedef struct _SMART_ANTENNA_TRAINNING_ {
+	u4Byte	latch_time;
+	BOOLEAN	pkt_skip_statistic_en;
+	u4Byte	fix_beam_pattern_en;
+	u4Byte	fix_training_num_en;
+	u4Byte	fix_beam_pattern_codeword;
+	u4Byte	update_beam_codeword;
+	u4Byte	ant_num; /*number of smart beam antenna*/
+	u4Byte	beam_patten_num_each_ant;/*number of  beam can be switched in each antenna*/
+	u4Byte	data_codeword_bit_num;
+	u4Byte	per_beam_training_pkt_num;
+	u1Byte	pre_traffic_state;
+	u1Byte	decision_holding_period;
+	u4Byte	pkt_counter;
+	u4Byte	fast_training_beam_num;
+	u4Byte	pre_fast_training_beam_num;	
+	u4Byte	pkt_rssi_pre[SUPPORT_RF_PATH_NUM][SUPPORT_BEAM_PATTERN_NUM];
+	u4Byte	pkt_rssi_sum[8][SUPPORT_BEAM_PATTERN_NUM];
+	u4Byte	pkt_rssi_cnt[8][SUPPORT_BEAM_PATTERN_NUM];
+	u4Byte	rx_idle_beam[SUPPORT_RF_PATH_NUM];
+	u4Byte	pre_codeword;
+	BOOLEAN	force_update_beam_en;
+
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	RT_WORK_ITEM	hl_smart_antenna_workitem;
+	RT_WORK_ITEM	hl_smart_antenna_decision_workitem;	
+	#endif
+
+} SAT_T, *pSAT_T;
+#endif
+
+typedef struct _FAST_ANTENNA_TRAINNING_
+{
+	u1Byte	Bssid[6];
+	u1Byte	antsel_rx_keep_0;
+	u1Byte	antsel_rx_keep_1;
+	u1Byte	antsel_rx_keep_2;
+	u1Byte	antsel_rx_keep_3;
+	u4Byte	antSumRSSI[7];
+	u4Byte	antRSSIcnt[7];
+	u4Byte	antAveRSSI[7];
+	u1Byte	FAT_State;
+	u4Byte	TrainIdx;
+	u1Byte	antsel_a[ODM_ASSOCIATE_ENTRY_NUM];
+	u1Byte	antsel_b[ODM_ASSOCIATE_ENTRY_NUM];
+	u1Byte	antsel_c[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	MainAnt_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	AuxAnt_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	MainAnt_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	AuxAnt_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u1Byte	RxIdleAnt;
+	u1Byte	AntDiv_OnOff;
+	BOOLEAN	bBecomeLinked;
+	u4Byte	MinMaxRSSI;
+	u1Byte	idx_AntDiv_counter_2G;
+	u1Byte	idx_AntDiv_counter_5G;
+	u1Byte	AntDiv_2G_5G;
+	u4Byte    CCK_counter_main;
+	u4Byte    CCK_counter_aux;	
+	u4Byte    OFDM_counter_main;
+	u4Byte    OFDM_counter_aux;
+
+	#ifdef ODM_EVM_ENHANCE_ANTDIV
+	u4Byte	MainAntEVM_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	AuxAntEVM_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	MainAntEVM_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	AuxAntEVM_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	BOOLEAN	EVM_method_enable;
+	u1Byte	TargetAnt_EVM;
+	u1Byte	TargetAnt_CRC32;
+	u1Byte	TargetAnt_enhance;
+	u1Byte	pre_TargetAnt_enhance;
+	u2Byte	Main_MPDU_OK_cnt;
+	u2Byte	Aux_MPDU_OK_cnt;	
+
+	u4Byte	CRC32_Ok_Cnt;
+	u4Byte	CRC32_Fail_Cnt;
+	u4Byte	MainCRC32_Ok_Cnt;
+	u4Byte	AuxCRC32_Ok_Cnt;
+	u4Byte	MainCRC32_Fail_Cnt;
+	u4Byte	AuxCRC32_Fail_Cnt;
+	#endif	
+	#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	u4Byte    CCK_CtrlFrame_Cnt_main;
+	u4Byte    CCK_CtrlFrame_Cnt_aux;
+	u4Byte    OFDM_CtrlFrame_Cnt_main;
+	u4Byte    OFDM_CtrlFrame_Cnt_aux;
+	u4Byte	MainAnt_CtrlFrame_Sum;
+	u4Byte	AuxAnt_CtrlFrame_Sum;
+	u4Byte	MainAnt_CtrlFrame_Cnt;
+	u4Byte	AuxAnt_CtrlFrame_Cnt;
+	#endif
+	BOOLEAN	fix_ant_bfee;
+	BOOLEAN	enable_ctrl_frame_antdiv;
+	BOOLEAN	use_ctrl_frame_antdiv;
+	u1Byte	hw_antsw_occur;
+}FAT_T,*pFAT_T;
+
+
+//1 ============================================================
+//1  enumeration
+//1 ============================================================
+
+
+
+typedef enum _FAT_STATE /*Fast antenna training*/
+{
+	FAT_BEFORE_LINK_STATE = 0,
+	FAT_PREPARE_STATE = 1,
+	FAT_TRAINING_STATE = 2,
+	FAT_DECISION_STATE = 3
+}FAT_STATE_E, *PFAT_STATE_E;
+
+typedef enum _ANT_DIV_TYPE
+{
+	NO_ANTDIV			= 0xFF,	
+	CG_TRX_HW_ANTDIV		= 0x01,
+	CGCS_RX_HW_ANTDIV 	= 0x02,
+	FIXED_HW_ANTDIV		= 0x03,
+	CG_TRX_SMART_ANTDIV	= 0x04,
+	CGCS_RX_SW_ANTDIV	= 0x05,
+	S0S1_SW_ANTDIV          = 0x06, /*8723B intrnal switch S0 S1*/
+	HL_SW_SMART_ANT_TYPE1          = 0x10 /*Hong-Lin Smart antenna use for 8821AE which is a 2 Ant. entitys, and each Ant. is equipped with 4 antenna patterns*/
+}ANT_DIV_TYPE_E, *PANT_DIV_TYPE_E;
+
+
+//1 ============================================================
+//1  function prototype
+//1 ============================================================
+
+
+VOID
+ODM_StopAntennaSwitchDm(
+	IN	PVOID	pDM_VOID
+	);
+VOID
+ODM_SetAntConfig(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte		antSetting	// 0=A, 1=B, 2=C, ....
+	);
+
+
+#define SwAntDivRestAfterLink	ODM_SwAntDivRestAfterLink
+VOID ODM_SwAntDivRestAfterLink(	
+	IN	PVOID	pDM_VOID
+	);
+
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+
+VOID
+ODM_UpdateRxIdleAnt(
+	IN		PVOID		pDM_VOID, 
+	IN		 u1Byte		Ant
+);
+
+#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_SW_AntDiv_Callback(
+	IN 	PRT_TIMER		pTimer
+	);
+
+VOID
+ODM_SW_AntDiv_WorkitemCallback(
+	IN	PVOID	pContext
+	);
+
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+VOID
+ODM_SW_AntDiv_WorkitemCallback(
+	IN PVOID	pContext
+);
+
+VOID
+ODM_SW_AntDiv_Callback(
+	void 		*FunctionContext
+	);
+
+#endif
+
+VOID
+odm_S0S1_SwAntDivByCtrlFrame(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Step
+);
+
+VOID
+odm_AntselStatisticsOfCtrlFrame(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			RxPWDBAll
+);
+
+VOID
+odm_S0S1_SwAntDivByCtrlFrame_ProcessRSSI(
+	IN		PVOID				pDM_VOID,
+	IN		PVOID		p_phy_info_void,
+	IN		PVOID		p_pkt_info_void
+);
+
+#endif
+
+#ifdef ODM_EVM_ENHANCE_ANTDIV
+VOID
+odm_EVM_FastAntTrainingCallback(
+	IN		PVOID		pDM_VOID
+);
+#endif
+
+VOID
+odm_HW_AntDiv(
+	IN		PVOID		pDM_VOID
+);
+
+#if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+VOID
+odm_FastAntTraining(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_FastAntTrainingCallback(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_FastAntTrainingWorkItemCallback(
+	IN		PVOID		pDM_VOID
+);
+#endif
+
+
+#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+phydm_beam_switch_workitem_callback(
+	IN	PVOID	pContext
+	);
+
+VOID
+phydm_beam_decision_workitem_callback(
+	IN	PVOID	pContext
+	);
+
+#endif
+
+VOID
+phydm_update_beam_pattern(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		codeword,
+	IN		u4Byte		codeword_length
+	);
+
+void
+phydm_set_all_ant_same_beam_num(
+	IN		PVOID		pDM_VOID
+	);
+
+VOID
+phydm_hl_smart_ant_cmd(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte		*_used,
+	OUT		char			*output,
+	IN		u4Byte		*_out_len
+);
+
+#endif/*#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1*/
+
+VOID
+ODM_AntDivInit(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+ODM_AntDiv(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_AntselStatistics(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			MacId,
+	IN		u4Byte			utility,
+	IN		u1Byte			method
+);
+
+VOID
+ODM_Process_RSSIForAntDiv(	
+	IN OUT	PVOID		pDM_VOID,
+	IN		PVOID		p_phy_info_void,
+	IN		PVOID		p_pkt_info_void
+);
+
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+VOID
+ODM_SetTxAntByTxInfo(
+	IN		PVOID			pDM_VOID,
+	IN		pu1Byte			pDesc,
+	IN		u1Byte			macId	
+);
+
+#elif(DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+VOID
+ODM_SetTxAntByTxInfo(
+	struct	rtl8192cd_priv		*priv,
+	struct 	tx_desc			*pdesc,
+	unsigned short			aid	
+);
+
+#endif
+
+
+VOID
+ODM_AntDiv_Config(
+	IN		PVOID		pDM_VOID
+);
+
+
+VOID
+ODM_UpdateRxIdleAnt_8723B(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Ant,
+	IN		u4Byte			DefaultAnt, 
+	IN		u4Byte			OptionalAnt
+);
+
+VOID
+ODM_AntDivTimers(
+	IN		PVOID		pDM_VOID,
+	IN 		u1Byte		state
+);
+
+#endif /*#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))*/
+
+VOID
+ODM_AntDivReset(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_AntennaDiversityInit(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_AntennaDiversity(
+	IN		PVOID		pDM_VOID
+);
+
+
+#endif //#ifndef	__ODMANTDIV_H__
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.c
new file mode 100644
index 000000000..ae4678691
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.c
@@ -0,0 +1,1939 @@
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#if WPP_SOFTWARE_TRACE
+#include "phydm_beamforming.tmh"
+#endif
+#endif
+
+#if (BEAMFORMING_SUPPORT == 1)
+
+PRT_BEAMFORM_STAINFO
+phydm_staInfoInit(
+	IN PDM_ODM_T		pDM_Odm,
+	IN u2Byte			staIdx
+	)
+{
+	PRT_BEAMFORMING_INFO		pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORM_STAINFO		pEntry = &(pBeamInfo->BeamformSTAinfo);
+	PSTA_INFO_T					pSTA = pDM_Odm->pODM_StaInfo[staIdx];
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PMGNT_INFO					pMgntInfo = &Adapter->MgntInfo;
+	PRT_HIGH_THROUGHPUT		pHTInfo = GET_HT_INFO(pMgntInfo);
+	PRT_VERY_HIGH_THROUGHPUT	pVHTInfo = GET_VHT_INFO(pMgntInfo);
+
+	ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, Adapter->CurrentAddress, 6);
+	
+	pEntry->HtBeamformCap = pHTInfo->HtBeamformCap;
+	pEntry->VhtBeamformCap = pVHTInfo->VhtBeamformCap;
+
+	/*IBSS, AP mode*/
+	if (staIdx != 0) {
+		pEntry->AID = pSTA->AID;
+		pEntry->RA = pSTA->MacAddr;
+		pEntry->MacID = pSTA->AssociatedMacId;
+		pEntry->WirelessMode = pSTA->WirelessMode;
+		pEntry->BW = pSTA->BandWidth;
+		pEntry->CurBeamform = pSTA->HTInfo.HtCurBeamform;
+	} else {/*client mode*/
+		pEntry->AID = pMgntInfo->mAId;
+		pEntry->RA = pMgntInfo->Bssid;
+		pEntry->MacID = pMgntInfo->mMacId;
+		pEntry->WirelessMode = pMgntInfo->dot11CurrentWirelessMode;
+		pEntry->BW = pMgntInfo->dot11CurrentChannelBandWidth;
+		pEntry->CurBeamform = pHTInfo->HtCurBeamform;
+	}	
+
+	if ((pEntry->WirelessMode & WIRELESS_MODE_AC_5G) || (pEntry->WirelessMode & WIRELESS_MODE_AC_24G)) {
+		if (staIdx != 0)
+			pEntry->CurBeamformVHT = pSTA->VHTInfo.VhtCurBeamform;
+		else
+			pEntry->CurBeamformVHT = pVHTInfo->VhtCurBeamform;	
+		}
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("pSTA->wireless_mode = 0x%x, staidx = %d\n", pSTA->WirelessMode, staIdx));
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+	if (!IS_STA_VALID(pSTA)) {
+		rtw_warn_on(1);
+		DBG_871X("%s => sta_info(mac_id:%d) failed\n", __func__, staIdx);
+		return pEntry;
+	}
+	
+	ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, adapter_mac_addr(pSTA->padapter), 6);
+	pEntry->HtBeamformCap = pSTA->htpriv.beamform_cap;
+
+	pEntry->AID = pSTA->aid;
+	pEntry->RA = pSTA->hwaddr;
+	pEntry->MacID = pSTA->mac_id;
+	pEntry->WirelessMode = pSTA->wireless_mode;
+	pEntry->BW = pSTA->bw_mode;
+
+	pEntry->CurBeamform = pSTA->htpriv.beamform_cap;
+#if	ODM_IC_11AC_SERIES_SUPPORT
+	if ((pEntry->WirelessMode & WIRELESS_MODE_AC_5G) || (pEntry->WirelessMode & WIRELESS_MODE_AC_24G)) {
+		pEntry->CurBeamformVHT = pSTA->vhtpriv.beamform_cap;
+		pEntry->VhtBeamformCap = pSTA->vhtpriv.beamform_cap;
+	}
+#endif
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("pSTA->wireless_mode = 0x%x, staidx = %d\n", pSTA->wireless_mode, staIdx));
+#endif
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("pEntry->CurBeamform = 0x%x, pEntry->CurBeamformVHT = 0x%x\n", pEntry->CurBeamform, pEntry->CurBeamformVHT));
+	return pEntry;
+
+}
+void phydm_staInfoUpdate(
+	IN PDM_ODM_T			pDM_Odm,
+	IN u2Byte				staIdx,
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry
+	)
+{
+	PSTA_INFO_T pSTA = pDM_Odm->pODM_StaInfo[staIdx];
+	
+	if (!IS_STA_VALID(pSTA))
+		return;
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pSTA->txbf_paid = pBeamformEntry->P_AID;
+	pSTA->txbf_gid = pBeamformEntry->G_ID;
+#endif	
+}
+	
+
+u1Byte
+Beamforming_GetHTNDPTxRate(
+	IN	PVOID	pDM_VOID,
+	u1Byte	CompSteeringNumofBFer
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte Nr_index = 0;
+	u1Byte NDPTxRate;
+	/*Find Nr*/
+	
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), CompSteeringNumofBFer);
+	else
+		Nr_index = TxBF_Nr(1, CompSteeringNumofBFer);
+	
+	switch (Nr_index) {
+	case 1:
+	NDPTxRate = MGN_MCS8;
+	break;
+
+	case 2:
+	NDPTxRate = MGN_MCS16;
+	break;
+
+	case 3:
+	NDPTxRate = MGN_MCS24;
+	break;
+			
+	default:
+	NDPTxRate = MGN_MCS8;
+	break;
+	}
+
+return NDPTxRate;
+
+}
+
+u1Byte
+Beamforming_GetVHTNDPTxRate(
+	IN	PVOID	pDM_VOID,
+	u1Byte	CompSteeringNumofBFer
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte Nr_index = 0;
+	u1Byte NDPTxRate;
+	/*Find Nr*/
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), CompSteeringNumofBFer);
+	else
+		Nr_index = TxBF_Nr(1, CompSteeringNumofBFer);
+	
+	switch (Nr_index) {
+	case 1:
+	NDPTxRate = MGN_VHT2SS_MCS0;
+	break;
+
+	case 2:
+	NDPTxRate = MGN_VHT3SS_MCS0;
+	break;
+
+	case 3:
+	NDPTxRate = MGN_VHT4SS_MCS0;
+	break;
+			
+	default:
+	NDPTxRate = MGN_VHT2SS_MCS0;
+	break;
+	}
+
+return NDPTxRate;
+
+}
+
+
+PRT_BEAMFORMEE_ENTRY
+phydm_Beamforming_GetBFeeEntryByAddr(
+	IN	PVOID		pDM_VOID,
+	IN	pu1Byte		RA,
+	OUT	pu1Byte		Idx
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i = 0;
+	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
+	
+	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+		if (pBeamInfo->BeamformeeEntry[i].bUsed && (eqMacAddr(RA, pBeamInfo->BeamformeeEntry[i].MacAddr))) {
+			*Idx = i;
+			return &(pBeamInfo->BeamformeeEntry[i]);
+		}
+	}
+
+	return NULL;
+}
+
+PRT_BEAMFORMER_ENTRY
+phydm_Beamforming_GetBFerEntryByAddr(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte 	TA,
+	OUT	pu1Byte	Idx
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte		i = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	
+	for (i = 0; i < BEAMFORMER_ENTRY_NUM; i++) {
+		if (pBeamInfo->BeamformerEntry[i].bUsed &&  (eqMacAddr(TA, pBeamInfo->BeamformerEntry[i].MacAddr))) {
+			*Idx = i;
+			return &(pBeamInfo->BeamformerEntry[i]);
+		}
+	}
+
+	return NULL;
+}
+
+
+PRT_BEAMFORMEE_ENTRY
+phydm_Beamforming_GetEntryByMacId(
+	IN	PVOID		pDM_VOID,
+	IN	u1Byte		MacId,
+	OUT	pu1Byte		Idx
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i = 0;
+	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
+	
+	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+		if (pBeamInfo->BeamformeeEntry[i].bUsed && (MacId == pBeamInfo->BeamformeeEntry[i].MacId)) {
+			*Idx = i;
+			return &(pBeamInfo->BeamformeeEntry[i]);
+		}
+	}
+
+	return NULL;
+}
+
+
+BEAMFORMING_CAP
+phydm_Beamforming_GetEntryBeamCapByMacId(
+	IN	PVOID		pDM_VOID,
+	IN	u1Byte		MacId
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	BEAMFORMING_CAP			BeamformEntryCap = BEAMFORMING_CAP_NONE;
+	
+	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+		if (pBeamInfo->BeamformeeEntry[i].bUsed && (MacId == pBeamInfo->BeamformeeEntry[i].MacId)) {
+			BeamformEntryCap =  pBeamInfo->BeamformeeEntry[i].BeamformEntryCap;
+			i = BEAMFORMEE_ENTRY_NUM;
+		}
+	}
+
+	return BeamformEntryCap;
+}
+
+
+PRT_BEAMFORMEE_ENTRY
+phydm_Beamforming_GetFreeBFeeEntry(
+	IN	PVOID		pDM_VOID,
+	OUT	pu1Byte		Idx
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i = 0;
+	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+		if (pBeamInfo->BeamformeeEntry[i].bUsed == FALSE) {
+			*Idx = i;
+			return &(pBeamInfo->BeamformeeEntry[i]);
+		}	
+	}
+	return NULL;
+}
+
+PRT_BEAMFORMER_ENTRY
+phydm_Beamforming_GetFreeBFerEntry(
+	IN	PVOID		pDM_VOID,
+	OUT	pu1Byte		Idx
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i = 0;
+	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s ===>\n", __func__));
+
+	for (i = 0; i < BEAMFORMER_ENTRY_NUM; i++) {
+		if (pBeamInfo->BeamformerEntry[i].bUsed == FALSE) {
+			*Idx = i;
+			return &(pBeamInfo->BeamformerEntry[i]);
+		}	
+	}
+	return NULL;
+}
+
+/*
+// Description: Get the first entry index of MU Beamformee.
+//
+// Return Value: Index of the first MU sta.
+//
+// 2015.05.25. Created by tynli.
+//
+*/
+u1Byte
+phydm_Beamforming_GetFirstMUBFeeEntryIdx(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					idx = 0xFF;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	BOOLEAN					bFound = FALSE;
+
+	for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {
+		if (pBeamInfo->BeamformeeEntry[idx].bUsed && pBeamInfo->BeamformeeEntry[idx].is_mu_sta) {			
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] idx=%d!\n", __func__, idx));
+			bFound = TRUE;
+			break;
+		}	
+	}
+
+	if (!bFound)
+		idx = 0xFF;
+
+	return idx;
+}
+
+
+/*Add SU BFee and MU BFee*/
+PRT_BEAMFORMEE_ENTRY
+Beamforming_AddBFeeEntry(
+	IN	PVOID				pDM_VOID,
+	IN	PRT_BEAMFORM_STAINFO	pSTA,
+	IN	BEAMFORMING_CAP	BeamformCap,
+	IN	u1Byte				NumofSoundingDim,
+	IN	u1Byte				CompSteeringNumofBFer,
+	OUT	pu1Byte				Idx
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMEE_ENTRY	pEntry = phydm_Beamforming_GetFreeBFeeEntry(pDM_Odm, Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (pEntry != NULL) {	
+		pEntry->bUsed = TRUE;
+		pEntry->AID = pSTA->AID;
+		pEntry->MacId = pSTA->MacID;
+		pEntry->SoundBW = pSTA->BW;
+		ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, pSTA->MyMacAddr, 6);
+		
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) {
+			/*BSSID[44:47] xor BSSID[40:43]*/
+			u2Byte BSSID = ((pSTA->MyMacAddr[5] & 0xf0) >> 4) ^ (pSTA->MyMacAddr[5] & 0xf);
+			/*(dec(A) + dec(B)*32) mod 512*/
+			pEntry->P_AID = (pSTA->AID + BSSID * 32) & 0x1ff;
+			pEntry->G_ID = 63;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BFee P_AID addressed to STA=%d\n", __func__, pEntry->P_AID));
+		} else if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS)) {
+			/*ad hoc mode*/
+			pEntry->P_AID = 0;
+			pEntry->G_ID = 63;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BFee P_AID as IBSS=%d\n", __func__, pEntry->P_AID));
+		} else {
+			/*client mode*/
+			pEntry->P_AID =  pSTA->RA[5];
+			/*BSSID[39:47]*/
+			pEntry->P_AID = (pEntry->P_AID << 1) | (pSTA->RA[4] >> 7);
+			pEntry->G_ID = 0;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BFee P_AID addressed to AP=0x%X\n", __func__, pEntry->P_AID));
+		}
+		cpMacAddr(pEntry->MacAddr, pSTA->RA);
+		pEntry->bTxBF = FALSE;
+		pEntry->bSound = FALSE;
+		pEntry->SoundPeriod = 400;
+		pEntry->BeamformEntryCap = BeamformCap;
+		pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;
+
+/*		pEntry->LogSeq = 0xff;				Move to Beamforming_AddBFerEntry*/
+/*		pEntry->LogRetryCnt = 0;			Move to Beamforming_AddBFerEntry*/
+/*		pEntry->LogSuccessCnt = 0;		Move to Beamforming_AddBFerEntry*/
+
+		pEntry->LogStatusFailCnt = 0;
+
+		pEntry->NumofSoundingDim = NumofSoundingDim;
+		pEntry->CompSteeringNumofBFer = CompSteeringNumofBFer;
+
+		if (BeamformCap & BEAMFORMER_CAP_VHT_MU) {
+			pDM_Odm->BeamformingInfo.beamformee_mu_cnt += 1;
+			pEntry->is_mu_sta = TRUE;
+			pDM_Odm->BeamformingInfo.FirstMUBFeeIndex = phydm_Beamforming_GetFirstMUBFeeEntryIdx(pDM_Odm);
+		} else if  (BeamformCap & BEAMFORMER_CAP_VHT_SU) {
+			pDM_Odm->BeamformingInfo.beamformee_su_cnt += 1;
+			pEntry->is_mu_sta = FALSE;
+		}
+
+		return pEntry;
+	}
+	else
+		return NULL;
+}
+
+/*Add SU BFee and MU BFer*/
+PRT_BEAMFORMER_ENTRY
+Beamforming_AddBFerEntry(
+	IN	PVOID				pDM_VOID,
+	IN	PRT_BEAMFORM_STAINFO	pSTA,
+	IN	BEAMFORMING_CAP	BeamformCap,
+	IN	u1Byte				NumofSoundingDim,
+	OUT	pu1Byte				Idx
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMER_ENTRY	pEntry = phydm_Beamforming_GetFreeBFerEntry(pDM_Odm, Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (pEntry != NULL) {
+		pEntry->bUsed = TRUE;
+		ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, pSTA->MyMacAddr, 6);
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) {
+			/*BSSID[44:47] xor BSSID[40:43]*/
+			u2Byte BSSID = ((pSTA->MyMacAddr[5] & 0xf0) >> 4) ^ (pSTA->MyMacAddr[5] & 0xf);
+			
+			pEntry->P_AID = (pSTA->AID + BSSID * 32) & 0x1ff;
+			pEntry->G_ID = 63;
+			/*(dec(A) + dec(B)*32) mod 512*/
+		} else if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS)) {
+			pEntry->P_AID = 0;
+			pEntry->G_ID = 63;
+		} else {
+			pEntry->P_AID =  pSTA->RA[5];
+			/*BSSID[39:47]*/
+			pEntry->P_AID = (pEntry->P_AID << 1) | (pSTA->RA[4] >> 7);
+			pEntry->G_ID = 0;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: P_AID addressed to AP=0x%X\n", __func__, pEntry->P_AID));
+		}
+		
+		cpMacAddr(pEntry->MacAddr, pSTA->RA);
+		pEntry->BeamformEntryCap = BeamformCap;
+
+		pEntry->PreLogSeq = 0;	/*Modified by Jeffery @2015-04-13*/
+		pEntry->LogSeq = 0;		/*Modified by Jeffery @2014-10-29*/
+		pEntry->LogRetryCnt = 0;	/*Modified by Jeffery @2014-10-29*/
+		pEntry->LogSuccess = 0;	/*LogSuccess is NOT needed to be accumulated, so  LogSuccessCnt->LogSuccess, 2015-04-13, Jeffery*/
+		pEntry->ClockResetTimes = 0;	/*Modified by Jeffery @2015-04-13*/
+
+		pEntry->NumofSoundingDim = NumofSoundingDim;
+
+		if (BeamformCap & BEAMFORMEE_CAP_VHT_MU) {
+			pDM_Odm->BeamformingInfo.beamformer_mu_cnt += 1;
+			pEntry->is_mu_ap = TRUE;
+			pEntry->AID = pSTA->AID;
+		} else if (BeamformCap & BEAMFORMEE_CAP_VHT_SU) {
+			pDM_Odm->BeamformingInfo.beamformer_su_cnt += 1;
+			pEntry->is_mu_ap = FALSE;
+		}
+
+		return pEntry;
+	}
+	else
+		return NULL;
+}
+
+#if 0
+BOOLEAN
+Beamforming_RemoveEntry(
+	IN	PADAPTER			Adapter,
+	IN	pu1Byte		RA,
+	OUT	pu1Byte		Idx
+	)
+{
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T				pDM_Odm = &pHalData->DM_OutSrc;
+
+	PRT_BEAMFORMER_ENTRY	pBFerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, RA, Idx);
+	PRT_BEAMFORMEE_ENTRY	pEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, Idx);
+	BOOLEAN ret = FALSE;
+    
+	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s Start!\n", __func__));
+	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s, pBFerEntry=0x%x\n", __func__, pBFerEntry));
+	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s, pEntry=0x%x\n", __func__, pEntry));
+	
+	if (pEntry != NULL) {	
+		pEntry->bUsed = FALSE;
+		pEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
+		/*pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;*/
+		pEntry->bBeamformingInProgress = FALSE;
+		ret = TRUE;
+	} 
+	if (pBFerEntry != NULL) {
+		pBFerEntry->bUsed = FALSE;
+		pBFerEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
+		ret = TRUE;
+	}
+	return ret;
+
+}
+#endif
+
+/* Used for BeamformingStart_V1  */
+VOID
+phydm_Beamforming_NDPARate(
+	IN	PVOID		pDM_VOID,
+	CHANNEL_WIDTH 	BW, 
+	u1Byte			Rate
+)
+{
+	u2Byte			NDPARate = Rate;
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (NDPARate == 0) {
+		if(pDM_Odm->RSSI_Min > 30) // link RSSI > 30%
+			NDPARate = ODM_RATE24M;
+		else
+			NDPARate = ODM_RATE6M;
+	}
+
+	if (NDPARate < ODM_RATEMCS0)
+		BW = (CHANNEL_WIDTH)ODM_BW20M;
+
+	NDPARate = (NDPARate << 8) | BW;
+	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_RATE, (pu1Byte)&NDPARate);
+
+}
+
+
+/* Used for BeamformingStart_SW and  BeamformingStart_FW */
+VOID
+phydm_Beamforming_DymNDPARate(
+	IN	PVOID		pDM_VOID
+)
+{
+	u2Byte			NDPARate = ODM_RATE6M, BW;
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (pDM_Odm->RSSI_Min > 30)	/*link RSSI > 30%*/
+		NDPARate = ODM_RATE24M;
+	else
+		NDPARate = ODM_RATE6M;
+
+	BW = ODM_BW20M;
+	NDPARate = NDPARate << 8 | BW;
+	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_RATE, (pu1Byte)&NDPARate);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s End, NDPA Rate = 0x%X\n", __func__, NDPARate));
+}
+
+/*	
+*	SW Sounding : SW Timer unit 1ms 
+*				 HW Timer unit (1/32000) s  32k is clock. 
+*	FW Sounding : FW Timer unit 10ms
+*/
+VOID
+Beamforming_DymPeriod(
+	IN	PVOID		pDM_VOID,
+	IN  u8          status
+)
+{
+	u1Byte 					Idx;
+	BOOLEAN					bChangePeriod = FALSE;	
+	u2Byte					SoundPeriod_SW, SoundPeriod_FW;
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_SOUNDING_INFO		pSoundInfo = &(pBeamInfo->SoundingInfo);
+
+	PRT_BEAMFORMEE_ENTRY	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+	
+	//3 TODO  per-client throughput caculation.
+
+	if ((*(pDM_Odm->pCurrentTxTP) + *(pDM_Odm->pCurrentRxTP) > 2) && ((pEntry->LogStatusFailCnt <= 20) || status)) {
+		SoundPeriod_SW = 40;	/* 40ms */
+		SoundPeriod_FW = 40;	/* From  H2C cmd, unit = 10ms */
+	} else {
+		SoundPeriod_SW = 4000;/* 4s */
+		SoundPeriod_FW = 400;
+	}
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]SoundPeriod_SW=%d, SoundPeriod_FW=%d\n",	__func__, SoundPeriod_SW, SoundPeriod_FW));
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		pBeamformEntry = pBeamInfo->BeamformeeEntry+Idx;
+		
+		if (pBeamformEntry->DefaultCSICnt > 20) {
+			/*Modified by David*/
+			SoundPeriod_SW = 4000;
+			SoundPeriod_FW = 400;
+		}
+		
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Period = %d\n", __func__, SoundPeriod_SW));		
+		if (pBeamformEntry->BeamformEntryCap & (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMER_CAP_VHT_SU)) {
+			if (pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER) {				
+				if (pBeamformEntry->SoundPeriod != SoundPeriod_FW) {
+					pBeamformEntry->SoundPeriod = SoundPeriod_FW;
+					bChangePeriod = TRUE;		/*Only FW sounding need to send H2C packet to change sound period. */
+				}
+			} else if (pBeamformEntry->SoundPeriod != SoundPeriod_SW) {
+				pBeamformEntry->SoundPeriod = SoundPeriod_SW;
+			}
+		}
+	}
+
+	if (bChangePeriod)
+		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_FW_NDPA, (pu1Byte)&Idx);
+}
+
+
+
+
+BOOLEAN
+Beamforming_SendHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW,
+	IN	u1Byte			QIdx
+	)
+{
+	BOOLEAN		ret = TRUE;
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (QIdx == BEACON_QUEUE)
+		ret = SendFWHTNDPAPacket(pDM_Odm, RA, BW);
+	else
+		ret = SendSWHTNDPAPacket(pDM_Odm, RA, BW);
+
+	return ret;
+}
+
+
+
+BOOLEAN
+Beamforming_SendVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW,
+	IN	u1Byte			QIdx
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	BOOLEAN		ret = TRUE;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+
+	HalComTxbf_Set(pDM_Odm, TXBF_SET_GET_TX_RATE, NULL);
+
+	if ((pDM_Odm->TxBfDataRate >= ODM_RATEVHTSS3MCS7) && (pDM_Odm->TxBfDataRate <= ODM_RATEVHTSS3MCS9)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("@%s: 3SS VHT 789 don't sounding\n", __func__));
+
+	} else  {
+		if (QIdx == BEACON_QUEUE) /* Send to reserved page => FW NDPA */
+			ret = SendFWVHTNDPAPacket(pDM_Odm, RA, AID, BW);
+		else {
+#ifdef SUPPORT_MU_BF
+		#if (SUPPORT_MU_BF == 1)
+			pBeamInfo->is_mu_sounding = TRUE;
+			ret = SendSWVHTMUNDPAPacket(pDM_Odm, BW);
+		#else
+			pBeamInfo->is_mu_sounding = FALSE;
+			ret = SendSWVHTNDPAPacket(pDM_Odm, RA, AID, BW);
+		#endif
+#else
+			pBeamInfo->is_mu_sounding = FALSE;
+			ret = SendSWVHTNDPAPacket(pDM_Odm, RA, AID, BW);
+#endif
+		}
+	}
+		return ret;
+}
+
+
+BEAMFORMING_NOTIFY_STATE
+phydm_beamfomring_bSounding(
+	IN	PVOID				pDM_VOID,
+	PRT_BEAMFORMING_INFO 	pBeamInfo,
+	pu1Byte					Idx
+	)
+{
+	BEAMFORMING_NOTIFY_STATE	bSounding = BEAMFORMING_NOTIFY_NONE;
+	RT_BEAMFORMING_OID_INFO	BeamOidInfo = pBeamInfo->BeamformingOidInfo;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	/*if(( Beamforming_GetBeamCap(pBeamInfo) & BEAMFORMER_CAP) == 0)*/
+	/*bSounding = BEAMFORMING_NOTIFY_RESET;*/
+	if (BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER)
+		bSounding = BEAMFORMING_NOTIFY_RESET;
+	else {
+		u1Byte i;
+
+		for (i = 0 ; i < BEAMFORMEE_ENTRY_NUM ; i++) {
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("@%s: BFee Entry %d bUsed=%d, bSound=%d\n", __func__, i, pBeamInfo->BeamformeeEntry[i].bUsed, pBeamInfo->BeamformeeEntry[i].bSound));
+			if (pBeamInfo->BeamformeeEntry[i].bUsed && (!pBeamInfo->BeamformeeEntry[i].bSound)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Add BFee entry %d\n", __func__, i));
+				*Idx = i;
+				if (pBeamInfo->BeamformeeEntry[i].is_mu_sta)
+					bSounding = BEAMFORMEE_NOTIFY_ADD_MU;
+				else
+					bSounding = BEAMFORMEE_NOTIFY_ADD_SU;
+			}
+
+			if ((!pBeamInfo->BeamformeeEntry[i].bUsed) && pBeamInfo->BeamformeeEntry[i].bSound) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Delete BFee entry %d\n", __func__, i));
+				*Idx = i;
+				if (pBeamInfo->BeamformeeEntry[i].is_mu_sta)
+					bSounding = BEAMFORMEE_NOTIFY_DELETE_MU;
+				else
+					bSounding = BEAMFORMEE_NOTIFY_DELETE_SU;
+			}
+		}
+	}
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s End, bSounding = %d\n", __func__, bSounding));
+	return bSounding;
+}
+
+
+//This function is unused
+u1Byte
+phydm_beamforming_SoundingIdx(
+	IN	PVOID				pDM_VOID,
+	PRT_BEAMFORMING_INFO 		pBeamInfo
+	)
+{
+	u1Byte					Idx = 0;
+	RT_BEAMFORMEE_ENTRY	BeamEntry;
+	RT_BEAMFORMING_OID_INFO	BeamOidInfo = pBeamInfo->BeamformingOidInfo;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (BeamOidInfo.SoundOidMode == SOUNDING_SW_HT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_SW_VHT_TIMER ||
+		BeamOidInfo.SoundOidMode == SOUNDING_HW_HT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_VHT_TIMER)
+		Idx = BeamOidInfo.SoundOidIdx;
+	else {
+		u1Byte	i;
+		for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+			if (pBeamInfo->BeamformeeEntry[i].bUsed && (FALSE == pBeamInfo->BeamformeeEntry[i].bSound)) {
+				Idx = i;
+				break;
+			}
+		}
+	}
+
+	return Idx;
+}
+
+
+SOUNDING_MODE
+phydm_beamforming_SoundingMode(
+	IN	PVOID				pDM_VOID,
+	PRT_BEAMFORMING_INFO 	pBeamInfo,
+	u1Byte					Idx
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte 			SupportInterface = pDM_Odm->SupportInterface;
+
+	RT_BEAMFORMEE_ENTRY		BeamEntry = pBeamInfo->BeamformeeEntry[Idx];
+	RT_BEAMFORMING_OID_INFO	BeamOidInfo = pBeamInfo->BeamformingOidInfo;
+	SOUNDING_MODE				Mode = BeamOidInfo.SoundOidMode;
+
+	if (BeamOidInfo.SoundOidMode == SOUNDING_SW_VHT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_VHT_TIMER) {
+		if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
+			Mode = BeamOidInfo.SoundOidMode;
+		else 
+			Mode = SOUNDING_STOP_All_TIMER;
+	} else if (BeamOidInfo.SoundOidMode == SOUNDING_SW_HT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_HT_TIMER) {
+		if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)
+			Mode = BeamOidInfo.SoundOidMode;
+		else
+			Mode = SOUNDING_STOP_All_TIMER;
+	} else if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_VHT_SU) {
+		if ((SupportInterface == ODM_ITRF_USB) && !(pDM_Odm->SupportICType & (ODM_RTL8814A | ODM_RTL8822B)))
+			Mode = SOUNDING_FW_VHT_TIMER;
+		else
+			Mode = SOUNDING_SW_VHT_TIMER;
+	} else if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT) {
+		if ((SupportInterface == ODM_ITRF_USB) && !(pDM_Odm->SupportICType & (ODM_RTL8814A | ODM_RTL8822B)))
+			Mode = SOUNDING_FW_HT_TIMER;
+		else
+			Mode = SOUNDING_SW_HT_TIMER;
+	} else 
+		Mode = SOUNDING_STOP_All_TIMER;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SupportInterface=%d, Mode=%d\n", __func__, SupportInterface, Mode));
+
+	return Mode;
+}
+
+
+u2Byte
+phydm_beamforming_SoundingTime(
+	IN	PVOID				pDM_VOID,
+	PRT_BEAMFORMING_INFO 	pBeamInfo,
+	SOUNDING_MODE			Mode,
+	u1Byte					Idx
+	)
+{
+	u2Byte						SoundingTime = 0xffff;
+	RT_BEAMFORMEE_ENTRY		BeamEntry = pBeamInfo->BeamformeeEntry[Idx];
+	RT_BEAMFORMING_OID_INFO	BeamOidInfo = pBeamInfo->BeamformingOidInfo;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_HW_VHT_TIMER)
+		SoundingTime = BeamOidInfo.SoundOidPeriod * 32;
+	else if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_SW_VHT_TIMER)
+		/*Modified by David*/
+		SoundingTime = BeamEntry.SoundPeriod;	/*BeamOidInfo.SoundOidPeriod;*/
+	else
+		SoundingTime = BeamEntry.SoundPeriod;
+
+	return SoundingTime;
+}
+
+
+CHANNEL_WIDTH
+phydm_beamforming_SoundingBW(
+	IN	PVOID				pDM_VOID,
+	PRT_BEAMFORMING_INFO 	pBeamInfo,
+	SOUNDING_MODE			Mode,
+	u1Byte					Idx
+	)
+{
+	CHANNEL_WIDTH				SoundingBW = CHANNEL_WIDTH_20;
+	RT_BEAMFORMEE_ENTRY		BeamEntry = pBeamInfo->BeamformeeEntry[Idx];
+	RT_BEAMFORMING_OID_INFO	BeamOidInfo = pBeamInfo->BeamformingOidInfo;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_HW_VHT_TIMER)
+		SoundingBW = BeamOidInfo.SoundOidBW;
+	else if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_SW_VHT_TIMER)
+		/*Modified by David*/
+		SoundingBW = BeamEntry.SoundBW;		/*BeamOidInfo.SoundOidBW;*/
+	else 
+		SoundingBW = BeamEntry.SoundBW;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, SoundingBW=0x%X\n", __func__, SoundingBW));
+
+	return SoundingBW;
+}
+
+
+BOOLEAN
+phydm_Beamforming_SelectBeamEntry(
+	IN	PVOID				pDM_VOID,
+	PRT_BEAMFORMING_INFO 	pBeamInfo
+	)
+{
+	PRT_SOUNDING_INFO		pSoundInfo = &(pBeamInfo->SoundingInfo);
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	/*pEntry.bSound is different between first and latter NDPA, and should not be used as BFee entry selection*/
+	/*BTW, latter modification should sync to the selection mechanism of AP/ADSL instead of the fixed SoundIdx.*/
+	pSoundInfo->SoundIdx = phydm_beamforming_SoundingIdx(pDM_Odm, pBeamInfo);
+	/*pSoundInfo->SoundIdx = 0;*/
+
+	if (pSoundInfo->SoundIdx < BEAMFORMEE_ENTRY_NUM)
+		pSoundInfo->SoundMode = phydm_beamforming_SoundingMode(pDM_Odm, pBeamInfo, pSoundInfo->SoundIdx);
+	else
+		pSoundInfo->SoundMode = SOUNDING_STOP_All_TIMER;
+	
+	if (SOUNDING_STOP_All_TIMER == pSoundInfo->SoundMode) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Return because of SOUNDING_STOP_All_TIMER\n", __func__));
+		return FALSE;
+	} else {
+		pSoundInfo->SoundBW = phydm_beamforming_SoundingBW(pDM_Odm, pBeamInfo, pSoundInfo->SoundMode, pSoundInfo->SoundIdx );
+		pSoundInfo->SoundPeriod = phydm_beamforming_SoundingTime(pDM_Odm, pBeamInfo, pSoundInfo->SoundMode, pSoundInfo->SoundIdx );
+		return TRUE;
+	}
+}
+
+/*SU BFee Entry Only*/
+BOOLEAN
+phydm_beamforming_StartPeriod(
+	IN	PVOID				pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	BOOLEAN						Ret = TRUE;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo); 
+	
+	phydm_Beamforming_DymNDPARate(pDM_Odm);
+
+	phydm_Beamforming_SelectBeamEntry(pDM_Odm, pBeamInfo);		// Modified
+
+	if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
+		ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);
+	else if (pSoundInfo->SoundMode == SOUNDING_HW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_HW_HT_TIMER ||
+			pSoundInfo->SoundMode == SOUNDING_AUTO_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_AUTO_HT_TIMER) {
+		HAL_HW_TIMER_TYPE TimerType = HAL_TIMER_TXBF;
+		u4Byte	val = (pSoundInfo->SoundPeriod | (TimerType<<16));
+
+		//HW timer stop: All IC has the same setting
+		Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_HW_REG_TIMER_STOP,  (pu1Byte)(&TimerType));
+		//ODM_Write1Byte(pDM_Odm, 0x15F, 0);
+		//HW timer init: All IC has the same setting, but 92E & 8812A only write 2 bytes
+		Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_HW_REG_TIMER_INIT,  (pu1Byte)(&val));
+		//ODM_Write1Byte(pDM_Odm, 0x164, 1);
+		//ODM_Write4Byte(pDM_Odm, 0x15C, val);
+		//HW timer start: All IC has the same setting
+		Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_HW_REG_TIMER_START,  (pu1Byte)(&TimerType));
+		//ODM_Write1Byte(pDM_Odm, 0x15F, 0x5);
+	} else if (pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER)
+		Ret = BeamformingStart_FW(pDM_Odm, pSoundInfo->SoundIdx);
+	else
+		Ret = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SoundIdx=%d, SoundMode=%d, SoundBW=%d, SoundPeriod=%d\n", __func__, 
+			pSoundInfo->SoundIdx, pSoundInfo->SoundMode, pSoundInfo->SoundBW, pSoundInfo->SoundPeriod));
+
+	return Ret;
+}
+
+// Used after Beamforming_Leave, and will clear the setting of the "already deleted" entry
+/*SU BFee Entry Only*/
+VOID
+phydm_beamforming_EndPeriod_SW(
+	IN	PVOID				pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	u1Byte						Idx = 0;
+	PRT_BEAMFORMEE_ENTRY		pBeamformEntry;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
+	
+	HAL_HW_TIMER_TYPE TimerType = HAL_TIMER_TXBF;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
+		ODM_CancelTimer(pDM_Odm, &pBeamInfo->BeamformingTimer);
+	else if (pSoundInfo->SoundMode == SOUNDING_HW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_HW_HT_TIMER ||
+				pSoundInfo->SoundMode == SOUNDING_AUTO_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_AUTO_HT_TIMER)
+		/*HW timer stop: All IC has the same setting*/
+		Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_HW_REG_TIMER_STOP,  (pu1Byte)(&TimerType));
+		/*ODM_Write1Byte(pDM_Odm, 0x15F, 0);*/
+}
+
+VOID
+phydm_beamforming_EndPeriod_FW(
+	IN	PVOID				pDM_VOID
+	)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte				Idx = 0;
+
+	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_FW_NDPA, (pu1Byte)&Idx);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]\n", __func__));
+}
+
+
+/*SU BFee Entry Only*/
+VOID 
+phydm_beamforming_ClearEntry_SW(
+	IN	PVOID			pDM_VOID,
+	BOOLEAN				IsDelete,
+	u1Byte				DeleteIdx
+	)
+{
+	u1Byte						Idx = 0;
+	PRT_BEAMFORMEE_ENTRY		pBeamformEntry = NULL;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	if (IsDelete) {
+		if (DeleteIdx < BEAMFORMEE_ENTRY_NUM) {
+			pBeamformEntry = pBeamInfo->BeamformeeEntry + DeleteIdx;
+			if (!((!pBeamformEntry->bUsed) && pBeamformEntry->bSound)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SW DeleteIdx is wrong!!!!!\n", __func__));
+				return;
+			}
+		}
+
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SW delete BFee entry %d\n", __func__, DeleteIdx));
+		if (pBeamformEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING) {
+			pBeamformEntry->bBeamformingInProgress = FALSE;
+			pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;
+		} else if (pBeamformEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			pBeamformEntry->BeamformEntryState  = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;
+			HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&DeleteIdx);
+		}
+		pBeamformEntry->bSound = FALSE;
+	} else {
+		for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+			pBeamformEntry = pBeamInfo->BeamformeeEntry+Idx;
+
+			/*Used after bSounding=RESET, and will clear the setting of "ever sounded" entry, which is not necessarily be deleted.*/
+			/*This function is mainly used in case "BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER".*/
+			/*However, setting oid doesn't delete entries (bUsed is still TRUE), new entries may fail to be added in.*/
+		
+			if (pBeamformEntry->bSound) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SW reset BFee entry %d\n", __func__, Idx));
+				/*	
+				*	If End procedure is 
+				*	1. Between (Send NDPA, C2H packet return), reset state to initialized.
+				*	After C2H packet return , status bit will be set to zero. 
+				*
+				*	2. After C2H packet, then reset state to initialized and clear status bit.
+				*/
+
+				if (pBeamformEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING)
+					phydm_Beamforming_End_SW(pDM_Odm, 0);
+				else if (pBeamformEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+					pBeamformEntry->BeamformEntryState  = BEAMFORMING_ENTRY_STATE_INITIALIZED;
+					HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);
+				}
+
+				pBeamformEntry->bSound = FALSE;
+			}
+		}
+	}
+}
+
+VOID
+phydm_beamforming_ClearEntry_FW(
+	IN	PVOID			pDM_VOID,
+	BOOLEAN				IsDelete,
+	u1Byte				DeleteIdx
+	)
+{
+	u1Byte						Idx = 0;
+	PRT_BEAMFORMEE_ENTRY		pBeamformEntry = NULL;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	if (IsDelete) {
+		if (DeleteIdx < BEAMFORMEE_ENTRY_NUM) {
+			pBeamformEntry = pBeamInfo->BeamformeeEntry + DeleteIdx;
+
+			if (!((!pBeamformEntry->bUsed) && pBeamformEntry->bSound)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] FW DeleteIdx is wrong!!!!!\n", __func__));
+				return;
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: FW delete BFee entry %d\n", __func__, DeleteIdx));
+		pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;
+		pBeamformEntry->bSound = FALSE;
+	} else {
+		for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+			pBeamformEntry = pBeamInfo->BeamformeeEntry+Idx;
+
+			/*Used after bSounding=RESET, and will clear the setting of "ever sounded" entry, which is not necessarily be deleted.*/
+			/*This function is mainly used in case "BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER".*/
+			/*However, setting oid doesn't delete entries (bUsed is still TRUE), new entries may fail to be added in.*/
+		
+			if (pBeamformEntry->bSound) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]FW reset BFee entry %d\n", __func__, Idx));
+				/*	
+				*	If End procedure is 
+				*	1. Between (Send NDPA, C2H packet return), reset state to initialized.
+				*	After C2H packet return , status bit will be set to zero. 
+				*
+				*	2. After C2H packet, then reset state to initialized and clear status bit.
+				*/
+				
+				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
+				pBeamformEntry->bSound = FALSE;
+			}
+		}
+	}
+}
+
+/*
+* 	Called : 
+*	1. Add and delete entry : Beamforming_Enter/Beamforming_Leave
+*	2. FW trigger :  Beamforming_SetTxBFen
+*	3. Set OID_RT_BEAMFORMING_PERIOD : BeamformingControl_V2
+*/
+VOID
+phydm_Beamforming_Notify(
+	IN	PVOID			pDM_VOID
+	)
+{
+	u1Byte						Idx=BEAMFORMEE_ENTRY_NUM;
+	BEAMFORMING_NOTIFY_STATE	bSounding = BEAMFORMING_NOTIFY_NONE;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	bSounding = phydm_beamfomring_bSounding(pDM_Odm, pBeamInfo, &Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, Before notify, bSounding=%d, Idx=%d\n", __func__, bSounding, Idx));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: pBeamInfo->beamformee_su_cnt = %d\n", __func__, pBeamInfo->beamformee_su_cnt));
+	
+
+	switch (bSounding) {
+	case BEAMFORMEE_NOTIFY_ADD_SU:
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BEAMFORMEE_NOTIFY_ADD_SU\n", __func__));
+		phydm_beamforming_StartPeriod(pDM_Odm);
+	break;
+
+	case BEAMFORMEE_NOTIFY_DELETE_SU:
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BEAMFORMEE_NOTIFY_DELETE_SU\n", __func__));
+		if (pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER) {
+			phydm_beamforming_ClearEntry_FW(pDM_Odm, TRUE, Idx);
+			if (pBeamInfo->beamformee_su_cnt == 0) { /* For 2->1 entry, we should not cancel SW timer */
+				phydm_beamforming_EndPeriod_FW(pDM_Odm);
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: No BFee left\n", __func__));
+			}
+		} else {
+			phydm_beamforming_ClearEntry_SW(pDM_Odm, TRUE, Idx);
+			if (pBeamInfo->beamformee_su_cnt == 0) { /* For 2->1 entry, we should not cancel SW timer */
+				phydm_beamforming_EndPeriod_SW(pDM_Odm);
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: No BFee left\n", __func__));
+			}
+		}
+	break;
+
+	case BEAMFORMEE_NOTIFY_ADD_MU:
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BEAMFORMEE_NOTIFY_ADD_MU\n", __func__));
+		if (pBeamInfo->beamformee_mu_cnt == 2) {
+			/*if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
+				ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);*/
+			ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, 1000); /*Do MU sounding every 1sec*/
+		} else
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Less or larger than 2 MU STAs, not to set timer\n", __func__));
+	break;
+
+	case BEAMFORMEE_NOTIFY_DELETE_MU:
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: BEAMFORMEE_NOTIFY_DELETE_MU\n", __func__));
+		if (pBeamInfo->beamformee_mu_cnt == 1) {
+			/*if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)*/{
+				ODM_CancelTimer(pDM_Odm, &pBeamInfo->BeamformingTimer);
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Less than 2 MU STAs, stop sounding\n", __func__));
+			}
+		}
+	break;
+
+	case BEAMFORMING_NOTIFY_RESET:
+		if (pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER) {	
+			phydm_beamforming_ClearEntry_FW(pDM_Odm, FALSE, Idx);
+			phydm_beamforming_EndPeriod_FW(pDM_Odm);
+		} else {
+			phydm_beamforming_ClearEntry_SW(pDM_Odm, FALSE, Idx);
+			phydm_beamforming_EndPeriod_SW(pDM_Odm);
+		}
+
+	break;
+
+	default:
+	break;
+	}
+
+}
+
+
+
+BOOLEAN
+Beamforming_InitEntry(
+	IN	PVOID		pDM_VOID,
+	IN	u2Byte		staIdx,
+	pu1Byte			BFerBFeeIdx
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMEE_ENTRY		pBeamformEntry = NULL;
+	PRT_BEAMFORMER_ENTRY		pBeamformerEntry = NULL;
+	PRT_BEAMFORM_STAINFO		pSTA = NULL;
+	BEAMFORMING_CAP			BeamformCap = BEAMFORMING_CAP_NONE;
+	u1Byte						BFerIdx=0xF, BFeeIdx=0xF;
+	u1Byte						NumofSoundingDim = 0, CompSteeringNumofBFer = 0;
+
+	pSTA = phydm_staInfoInit(pDM_Odm, staIdx);
+
+	/*The current setting does not support Beaforming*/
+	if (BEAMFORMING_CAP_NONE == pSTA->HtBeamformCap && BEAMFORMING_CAP_NONE == pSTA->VhtBeamformCap) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("The configuration disabled Beamforming! Skip...\n"));		
+		return FALSE;
+	}
+
+	if (pSTA->WirelessMode < WIRELESS_MODE_N_24G)
+		return FALSE;
+	else {	/*HT*/
+		/*We are Beamformee because the STA is Beamformer*/
+		if (TEST_FLAG(pSTA->CurBeamform, BEAMFORMING_HT_BEAMFORMER_ENABLE)) {
+			BeamformCap =(BEAMFORMING_CAP)(BeamformCap |BEAMFORMEE_CAP_HT_EXPLICIT);
+			NumofSoundingDim = (pSTA->CurBeamform&BEAMFORMING_HT_BEAMFORMEE_CHNL_EST_CAP)>>6;
+		}
+		/*We are Beamformer because the STA is Beamformee*/
+		if (TEST_FLAG(pSTA->CurBeamform, BEAMFORMING_HT_BEAMFORMEE_ENABLE) ||
+			TEST_FLAG(pSTA->HtBeamformCap, BEAMFORMING_HT_BEAMFORMER_TEST)) {
+			BeamformCap =(BEAMFORMING_CAP)(BeamformCap | BEAMFORMER_CAP_HT_EXPLICIT);
+			CompSteeringNumofBFer = (pSTA->CurBeamform & BEAMFORMING_HT_BEAMFORMER_STEER_NUM)>>4;
+		}
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] HT CurBeamform=0x%X, BeamformCap=0x%X\n", __func__, pSTA->CurBeamform, BeamformCap));
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] HT NumofSoundingDim=%d, CompSteeringNumofBFer=%d\n", __func__, NumofSoundingDim, CompSteeringNumofBFer));
+#if	(ODM_IC_11AC_SERIES_SUPPORT == 1)
+		if (pSTA->WirelessMode & WIRELESS_MODE_AC_5G || pSTA->WirelessMode & WIRELESS_MODE_AC_24G) {	/*VHT*/	
+
+			/* We are Beamformee because the STA is SU Beamformer*/
+			if (TEST_FLAG(pSTA->CurBeamformVHT, BEAMFORMING_VHT_BEAMFORMER_ENABLE)) {
+				BeamformCap =(BEAMFORMING_CAP)(BeamformCap |BEAMFORMEE_CAP_VHT_SU);
+				NumofSoundingDim = (pSTA->CurBeamformVHT & BEAMFORMING_VHT_BEAMFORMEE_SOUND_DIM)>>12;
+			}
+			/* We are Beamformer because the STA is SU Beamformee*/
+			if (TEST_FLAG(pSTA->CurBeamformVHT, BEAMFORMING_VHT_BEAMFORMEE_ENABLE) ||
+				TEST_FLAG(pSTA->VhtBeamformCap, BEAMFORMING_VHT_BEAMFORMER_TEST)) {
+				BeamformCap =(BEAMFORMING_CAP)(BeamformCap |BEAMFORMER_CAP_VHT_SU);
+				CompSteeringNumofBFer = (pSTA->CurBeamformVHT & BEAMFORMING_VHT_BEAMFORMER_STS_CAP)>>8;
+			}
+			/* We are Beamformee because the STA is MU Beamformer*/
+			if (TEST_FLAG(pSTA->CurBeamformVHT, BEAMFORMING_VHT_MU_MIMO_AP_ENABLE)) {
+				BeamformCap = (BEAMFORMING_CAP)(BeamformCap | BEAMFORMEE_CAP_VHT_MU);
+				NumofSoundingDim = (pSTA->CurBeamformVHT & BEAMFORMING_VHT_BEAMFORMEE_SOUND_DIM)>>12;
+			}
+			/* We are Beamformer because the STA is MU Beamformee*/
+			if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) { /* Only AP mode supports to act an MU beamformer */
+				if (TEST_FLAG(pSTA->CurBeamformVHT, BEAMFORMING_VHT_MU_MIMO_STA_ENABLE) ||
+					TEST_FLAG(pSTA->VhtBeamformCap, BEAMFORMING_VHT_BEAMFORMER_TEST)) {
+					BeamformCap = (BEAMFORMING_CAP)(BeamformCap | BEAMFORMER_CAP_VHT_MU);
+					CompSteeringNumofBFer = (pSTA->CurBeamformVHT & BEAMFORMING_VHT_BEAMFORMER_STS_CAP)>>8;
+				}
+			}
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]VHT CurBeamformVHT=0x%X, BeamformCap=0x%X\n", __func__, pSTA->CurBeamformVHT, BeamformCap));
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]VHT NumofSoundingDim=0x%X, CompSteeringNumofBFer=0x%X\n", __func__, NumofSoundingDim, CompSteeringNumofBFer));
+			
+		}
+#endif
+	}
+
+
+	if(BeamformCap == BEAMFORMING_CAP_NONE)
+		return FALSE;
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Self BF Entry Cap = 0x%02X\n", __func__, BeamformCap));
+
+	/*We are BFee, so the entry is BFer*/
+	if (BeamformCap & (BEAMFORMEE_CAP_VHT_MU | BEAMFORMEE_CAP_VHT_SU | BEAMFORMEE_CAP_HT_EXPLICIT)) {
+		pBeamformerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, pSTA->RA, &BFerIdx);
+		
+		if (pBeamformerEntry == NULL) {
+			pBeamformerEntry = Beamforming_AddBFerEntry(pDM_Odm, pSTA, BeamformCap, NumofSoundingDim , &BFerIdx);
+			if (pBeamformerEntry == NULL)
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Not enough BFer entry!!!!!\n", __func__));
+		}
+	}
+
+	/*We are BFer, so the entry is BFee*/
+	if (BeamformCap & (BEAMFORMER_CAP_VHT_MU | BEAMFORMER_CAP_VHT_SU | BEAMFORMER_CAP_HT_EXPLICIT)) {
+		pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, pSTA->RA, &BFeeIdx);
+
+		/*pGBFeeIdx = 0xF hNeentrySPMACIDb*/
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Get BFee entry 0x%X by address\n", __func__, BFeeIdx));
+		if (pBeamformEntry == NULL) {
+			pBeamformEntry = Beamforming_AddBFeeEntry(pDM_Odm, pSTA, BeamformCap, NumofSoundingDim, CompSteeringNumofBFer, &BFeeIdx);
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]: pSTA->AID=%d, pSTA->MacID=%d\n", __func__, pSTA->AID, pSTA->MacID));
+
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]: Add BFee entry %d\n", __func__, BFeeIdx));
+
+			if (pBeamformEntry == NULL)
+				return FALSE;
+			else
+				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZEING;
+		} else {
+			/*Entry has been created. If entry is initialing or progressing then errors occur.*/
+			if (pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED && 
+				pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+				return FALSE;
+			} else
+				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZEING;
+		}
+		pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
+		phydm_staInfoUpdate(pDM_Odm, staIdx, pBeamformEntry);
+	}
+
+	*BFerBFeeIdx = (BFerIdx<<4) | BFeeIdx;
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End: BFerIdx=0x%X, BFeeIdx=0x%X, BFerBFeeIdx=0x%X\n", __func__, BFerIdx, BFeeIdx, *BFerBFeeIdx));
+
+	return TRUE;
+}
+
+
+VOID
+Beamforming_DeInitEntry(
+	IN	PVOID		pDM_VOID,
+	pu1Byte			RA
+	)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte				Idx = 0;
+
+	PRT_BEAMFORMER_ENTRY	pBFerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, RA, &Idx);
+	PRT_BEAMFORMEE_ENTRY	pBFeeEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+	BOOLEAN ret = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n",  __func__));
+	
+	if (pBFeeEntry != NULL) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, pBFeeEntry\n", __func__));
+		pBFeeEntry->bUsed = FALSE;
+		pBFeeEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
+		pBFeeEntry->bBeamformingInProgress = FALSE;
+		if (pBFeeEntry->is_mu_sta) {
+			pDM_Odm->BeamformingInfo.beamformee_mu_cnt -= 1;
+			pDM_Odm->BeamformingInfo.FirstMUBFeeIndex = phydm_Beamforming_GetFirstMUBFeeEntryIdx(pDM_Odm);
+		} else {
+			pDM_Odm->BeamformingInfo.beamformee_su_cnt -= 1;
+		}
+		ret = TRUE;
+	} 
+	
+	if (pBFerEntry != NULL) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, pBFerEntry\n", __func__));
+		pBFerEntry->bUsed = FALSE;
+		pBFerEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
+		if (pBFerEntry->is_mu_ap)
+			pDM_Odm->BeamformingInfo.beamformer_mu_cnt -= 1;
+		else
+			pDM_Odm->BeamformingInfo.beamformer_su_cnt -= 1;
+		ret = TRUE;
+	}
+
+	if (ret == TRUE)
+		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_LEAVE, (pu1Byte)&Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s End, Idx = 0x%X\n", __func__, Idx));
+}
+
+
+VOID
+Beamforming_Reset(
+	IN	PVOID				pDM_VOID
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					Idx = 0;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &(pDM_Odm->BeamformingInfo);
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		if (pBeamformingInfo->BeamformeeEntry[Idx].bUsed == TRUE) {
+			pBeamformingInfo->BeamformeeEntry[Idx].bUsed = FALSE;
+			pBeamformingInfo->BeamformeeEntry[Idx].BeamformEntryCap = BEAMFORMING_CAP_NONE;
+			/*pBeamformingInfo->BeamformeeEntry[Idx].BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;*/
+			/*Modified by David*/
+			pBeamformingInfo->BeamformeeEntry[Idx].bBeamformingInProgress = FALSE;
+			HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_LEAVE, (pu1Byte)&Idx);
+		}
+	}
+
+	for (Idx = 0; Idx < BEAMFORMER_ENTRY_NUM; Idx++) {
+		pBeamformingInfo->BeamformerEntry[Idx].bUsed = FALSE;
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Idx=%d, bUsed=%d\n", __func__, Idx, pBeamformingInfo->BeamformerEntry[Idx].bUsed));
+	}
+
+}
+
+
+BOOLEAN
+BeamformingStart_V1(
+	IN	PVOID		pDM_VOID,
+	pu1Byte			RA,
+	BOOLEAN			Mode,
+	CHANNEL_WIDTH	BW,
+	u1Byte			Rate
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					Idx = 0;
+	PRT_BEAMFORMEE_ENTRY	pEntry;
+	BOOLEAN					ret = TRUE;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	
+	pEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	if (pEntry->bUsed == FALSE) {
+		pEntry->bBeamformingInProgress = FALSE;
+		return FALSE;
+	} else {
+		if (pEntry->bBeamformingInProgress)
+			return FALSE;
+
+		pEntry->bBeamformingInProgress = TRUE;
+
+		if (Mode == 1) {	
+			if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)) {
+				pEntry->bBeamformingInProgress = FALSE;
+				return FALSE;
+			}
+		} else if (Mode == 0) {
+			if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)) {
+				pEntry->bBeamformingInProgress = FALSE;
+				return FALSE;
+			}
+		}
+
+		if (pEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED && pEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			pEntry->bBeamformingInProgress = FALSE;
+			return FALSE;
+		} else {
+			pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSING;
+			pEntry->bSound = TRUE;
+		}
+	}
+
+	pEntry->SoundBW = BW;
+	pBeamInfo->BeamformeeCurIdx = Idx;
+	phydm_Beamforming_NDPARate(pDM_Odm, BW, Rate);
+	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);
+
+	if (Mode == 1)
+		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA, BW, NORMAL_QUEUE);	
+	else
+		ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA, pEntry->AID, BW, NORMAL_QUEUE);
+
+	if (ret == FALSE) {
+		Beamforming_Leave(pDM_Odm, RA);
+		pEntry->bBeamformingInProgress = FALSE;
+		return FALSE;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s  Idx %d\n", __func__, Idx));
+	return TRUE;
+}
+
+
+BOOLEAN
+BeamformingStart_SW(
+	IN	PVOID		pDM_VOID,
+	u1Byte			Idx,
+	u1Byte			Mode, 
+	CHANNEL_WIDTH	BW
+	)
+{
+	pu1Byte					RA = NULL;
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMEE_ENTRY	pEntry;
+	BOOLEAN					ret = TRUE;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+
+	pEntry = &(pBeamInfo->BeamformeeEntry[Idx]);
+
+	if (pEntry->bUsed == FALSE) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Skip Beamforming, no entry for Idx =%d\n", Idx));
+		pEntry->bBeamformingInProgress = FALSE;
+		return FALSE;
+	} else {
+		if (pEntry->bBeamformingInProgress) {
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("bBeamformingInProgress, skip...\n"));
+			return FALSE;
+		}
+
+		pEntry->bBeamformingInProgress = TRUE;
+		RA = pEntry->MacAddr;
+		
+		if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER) {	
+			if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)) {
+				pEntry->bBeamformingInProgress = FALSE;
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Return by not support BEAMFORMER_CAP_HT_EXPLICIT <==\n", __func__));
+				return FALSE;
+			}
+		} else if (Mode == SOUNDING_SW_VHT_TIMER || Mode == SOUNDING_HW_VHT_TIMER || Mode == SOUNDING_AUTO_VHT_TIMER) {
+			if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)) {
+				pEntry->bBeamformingInProgress = FALSE;
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Return by not support BEAMFORMER_CAP_VHT_SU <==\n", __func__));
+				return FALSE;
+			}
+		}
+		if (pEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED && pEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			pEntry->bBeamformingInProgress = FALSE;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Return by incorrect BeamformEntryState(%d) <==\n", __func__, pEntry->BeamformEntryState));
+			return FALSE;
+		} else {
+			pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSING;
+			pEntry->bSound = TRUE;
+		}
+	}
+
+	pBeamInfo->BeamformeeCurIdx = Idx;
+	/*2014.12.22 Luke: Need to be checked*/
+	/*GET_TXBF_INFO(Adapter)->fTxbfSet(Adapter, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);*/
+
+	if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER)
+		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA , BW, NORMAL_QUEUE);	
+	else
+		ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA , pEntry->AID, BW, NORMAL_QUEUE);
+
+	if (ret == FALSE) {
+		Beamforming_Leave(pDM_Odm, RA);
+		pEntry->bBeamformingInProgress = FALSE;
+		return FALSE;
+	}
+
+	
+	/*--------------------------
+	// Send BF Report Poll for MU BF
+	--------------------------*/
+#ifdef SUPPORT_MU_BF
+#if (SUPPORT_MU_BF == 1)
+{
+	u1Byte				idx, PollSTACnt = 0;
+	BOOLEAN				bGetFirstBFee = FALSE;
+	
+	if (pBeamInfo->beamformee_mu_cnt > 1) { /* More than 1 MU STA*/
+	
+		for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {
+			pEntry = &(pBeamInfo->BeamformeeEntry[idx]);
+			if (pEntry->is_mu_sta) {
+				if (bGetFirstBFee) {
+					PollSTACnt++;
+					if (PollSTACnt == (pBeamInfo->beamformee_mu_cnt - 1))/* The last STA*/
+						SendSWVHTBFReportPoll(pDM_Odm, pEntry->MacAddr, TRUE);
+					else
+						SendSWVHTBFReportPoll(pDM_Odm, pEntry->MacAddr, FALSE);
+				} else {
+					bGetFirstBFee = TRUE;
+				}
+			}
+		}
+	}
+}
+#endif
+#endif
+	return TRUE;
+}
+
+
+BOOLEAN
+BeamformingStart_FW(
+	IN PVOID		pDM_VOID,
+	u1Byte			Idx
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pu1Byte					RA = NULL;
+	PRT_BEAMFORMEE_ENTRY	pEntry;
+	BOOLEAN					ret = TRUE;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+
+	pEntry = &(pBeamInfo->BeamformeeEntry[Idx]);
+	if (pEntry->bUsed == FALSE) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Skip Beamforming, no entry for Idx =%d\n", Idx));
+		return FALSE;
+	}
+
+	pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSING;
+	pEntry->bSound = TRUE;
+	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_FW_NDPA, (pu1Byte)&Idx);
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End, Idx=0x%X\n", __func__, Idx));
+	return TRUE;
+}
+
+VOID
+Beamforming_CheckSoundingSuccess(
+	IN PVOID			pDM_VOID,
+	BOOLEAN			Status	
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[David]@%s Start!\n", __func__));
+
+	if (Status == 1) {
+		if (pEntry->LogStatusFailCnt == 21)
+			Beamforming_DymPeriod(pDM_Odm, Status);
+		pEntry->LogStatusFailCnt = 0;
+	} else if (pEntry->LogStatusFailCnt <= 20) {
+		pEntry->LogStatusFailCnt++;
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s LogStatusFailCnt %d\n", __func__, pEntry->LogStatusFailCnt));
+	}
+	if (pEntry->LogStatusFailCnt > 20) {
+		pEntry->LogStatusFailCnt = 21;
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s LogStatusFailCnt > 20, Stop SOUNDING\n", __func__));
+		Beamforming_DymPeriod(pDM_Odm, Status);
+	}
+}
+
+VOID
+phydm_Beamforming_End_SW(
+	IN PVOID		pDM_VOID,
+	BOOLEAN			Status	
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO 	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
+
+	if (pEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_PROGRESSING) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] BeamformStatus %d\n", __func__, pEntry->BeamformEntryState));
+		return;
+	}
+
+	if ((pDM_Odm->TxBfDataRate >= ODM_RATEVHTSS3MCS7) && (pDM_Odm->TxBfDataRate <= ODM_RATEVHTSS3MCS9)) {
+		ODM_RT_TRACE(pDM_Odm, BEAMFORMING_DEBUG, ODM_DBG_LOUD, ("[%s] VHT3SS 7,8,9, do not apply V matrix.\n", __func__));
+		pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
+		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&(pBeamInfo->BeamformeeCurIdx));
+	} else if (Status == 1) {
+		pEntry->LogStatusFailCnt = 0;
+		pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSED;
+		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&(pBeamInfo->BeamformeeCurIdx));
+	} else {
+		pEntry->LogStatusFailCnt++;
+		pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
+		HalComTxbf_Set(pDM_Odm, TXBF_SET_TX_PATH_RESET, (pu1Byte)&(pBeamInfo->BeamformeeCurIdx));
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] LogStatusFailCnt %d\n", __func__, pEntry->LogStatusFailCnt));
+	}
+	
+	if (pEntry->LogStatusFailCnt > 30) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s LogStatusFailCnt > 50, Stop SOUNDING\n", __func__));
+		pEntry->bSound = FALSE;
+		Beamforming_DeInitEntry(pDM_Odm, pEntry->MacAddr); 
+
+		/*Modified by David - Every action of deleting entry should follow by Notify*/
+		phydm_Beamforming_Notify(pDM_Odm);
+	}	
+	pEntry->bBeamformingInProgress = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Status=%d\n", __func__, Status));
+}	
+
+
+VOID
+Beamforming_TimerCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN PVOID			pDM_VOID
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	IN PVOID            pContext
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER					Adapter = (PADAPTER)pContext;
+	PHAL_DATA_TYPE				pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T					pDM_Odm = &pHalData->odmpriv;
+#endif
+	BOOLEAN						ret = FALSE;
+	PRT_BEAMFORMING_INFO		pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY		pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
+	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	if (pEntry->bBeamformingInProgress) {
+	 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("bBeamformingInProgress, reset it\n"));
+		phydm_Beamforming_End_SW(pDM_Odm, 0);
+	 }
+
+	ret = phydm_Beamforming_SelectBeamEntry(pDM_Odm, pBeamInfo);
+#if (SUPPORT_MU_BF == 1)
+	if (ret && pBeamInfo->beamformee_mu_cnt > 1)
+		ret = 1;
+	else
+		ret = 0;
+#endif
+	if (ret)
+		ret = BeamformingStart_SW(pDM_Odm, pSoundInfo->SoundIdx, pSoundInfo->SoundMode, pSoundInfo->SoundBW);
+	else
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, Error value return from BeamformingStart_V2\n", __func__));
+
+	if ((pBeamInfo->beamformee_su_cnt != 0) || (pBeamInfo->beamformee_mu_cnt > 1)) {
+		if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
+			ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);
+		else {
+			u4Byte	val = (pSoundInfo->SoundPeriod << 16) | HAL_TIMER_TXBF;
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_HW_REG_TIMER_RESTART, (pu1Byte)(&val));
+		}
+	}
+}
+
+
+VOID
+Beamforming_SWTimerCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PRT_TIMER		pTimer
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	void *FunctionContext
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+	Beamforming_TimerCallback(pDM_Odm);
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)FunctionContext;
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	if (Adapter->net_closed == TRUE)
+		return;
+	rtw_run_in_thread_cmd(Adapter, Beamforming_TimerCallback, Adapter);
+#endif
+	
+}
+
+
+VOID
+phydm_Beamforming_Init(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PHAL_TXBF_INFO				pTxbfInfo = &pBeamInfo->TxbfInfo;
+	PRT_BEAMFORMING_OID_INFO	pBeamOidInfo = &(pBeamInfo->BeamformingOidInfo);
+	
+	pBeamOidInfo->SoundOidMode = SOUNDING_STOP_OID_TIMER;
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Mode (%d)\n", __func__, pBeamOidInfo->SoundOidMode));
+
+	pBeamInfo->beamformee_su_cnt = 0;
+	pBeamInfo->beamformer_su_cnt = 0;
+	pBeamInfo->beamformee_mu_cnt = 0;
+	pBeamInfo->beamformer_mu_cnt = 0;
+	pBeamInfo->beamformee_mu_reg_maping = 0;
+	pBeamInfo->mu_ap_index = 0;
+	pBeamInfo->is_mu_sounding = FALSE;
+	pBeamInfo->FirstMUBFeeIndex = 0xFF;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	pBeamInfo->SourceAdapter = pDM_Odm->Adapter;
+#endif
+	halComTxbf_beamformInit(pDM_Odm);
+}	
+
+
+VOID
+Beamforming_Enter(
+	IN PVOID			pDM_VOID,
+	IN u2Byte		staIdx
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			BFerBFeeIdx = 0xff;
+	
+	if (Beamforming_InitEntry(pDM_Odm, staIdx, &BFerBFeeIdx))
+		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_ENTER, (pu1Byte)&BFerBFeeIdx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End!\n", __func__));
+}
+
+
+VOID
+Beamforming_Leave(
+	IN PVOID			pDM_VOID,
+	pu1Byte			RA
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (RA == NULL)
+		Beamforming_Reset(pDM_Odm);
+	else
+		Beamforming_DeInitEntry(pDM_Odm, RA);
+
+	phydm_Beamforming_Notify(pDM_Odm);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End!!\n", __func__));
+}
+
+#if 0
+//Nobody calls this function
+VOID
+phydm_Beamforming_SetTxBFen(
+	IN	PVOID		pDM_VOID,
+	u1Byte			MacId,
+	BOOLEAN			bTxBF
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					Idx = 0;
+	PRT_BEAMFORMEE_ENTRY	pEntry;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	pEntry = phydm_Beamforming_GetEntryByMacId(pDM_Odm, MacId, &Idx);
+
+	if(pEntry == NULL)
+		return;
+	else
+		pEntry->bTxBF = bTxBF;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s MacId %d TxBF %d\n", __func__, pEntry->MacId, pEntry->bTxBF));
+
+	phydm_Beamforming_Notify(pDM_Odm);
+}
+#endif
+
+BEAMFORMING_CAP
+phydm_Beamforming_GetBeamCap(
+	IN PVOID						pDM_VOID,
+	IN PRT_BEAMFORMING_INFO 	pBeamInfo
+	)
+{
+	u1Byte					i;
+	BOOLEAN 				bSelfBeamformer = FALSE;
+	BOOLEAN 				bSelfBeamformee = FALSE;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	BEAMFORMING_CAP 		BeamformCap = BEAMFORMING_CAP_NONE;
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+		BeamformeeEntry = pBeamInfo->BeamformeeEntry[i];
+
+		if (BeamformeeEntry.bUsed) {
+			bSelfBeamformer = TRUE;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] BFee entry %d bUsed=TRUE\n", __func__, i));
+			break;
+		}
+	}
+
+	for (i = 0; i < BEAMFORMER_ENTRY_NUM; i++) {
+		BeamformerEntry = pBeamInfo->BeamformerEntry[i];
+
+		if (BeamformerEntry.bUsed) {
+			bSelfBeamformee = TRUE;
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]: BFer entry %d bUsed=TRUE\n", __func__, i));
+			break;
+		}
+	}
+
+	if (bSelfBeamformer)
+		BeamformCap = (BEAMFORMING_CAP)(BeamformCap | BEAMFORMER_CAP);
+	if (bSelfBeamformee)
+		BeamformCap = (BEAMFORMING_CAP)(BeamformCap | BEAMFORMEE_CAP);
+
+	return BeamformCap;
+}
+
+
+BOOLEAN
+BeamformingControl_V1(
+	IN PVOID			pDM_VOID,
+	pu1Byte			RA,
+	u1Byte			AID,
+	u1Byte			Mode, 
+	CHANNEL_WIDTH	BW,
+	u1Byte			Rate
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	BOOLEAN		ret = TRUE;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("AID (%d), Mode (%d), BW (%d)\n", AID, Mode, BW));
+
+	switch (Mode) {	
+	case 0:
+	ret = BeamformingStart_V1(pDM_Odm, RA, 0, BW, Rate);
+	break;
+	case 1:
+	ret = BeamformingStart_V1(pDM_Odm, RA, 1, BW, Rate);
+	break;
+	case 2:
+	phydm_Beamforming_NDPARate(pDM_Odm, BW, Rate);
+	ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA, AID, BW, NORMAL_QUEUE);
+	break;
+	case 3:
+	phydm_Beamforming_NDPARate(pDM_Odm, BW, Rate);
+	ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA, BW, NORMAL_QUEUE);
+	break;
+	}
+	return ret;
+}
+
+/*Only OID uses this function*/
+BOOLEAN
+phydm_BeamformingControl_V2(
+	IN	PVOID		pDM_VOID,
+	u1Byte			Idx,
+	u1Byte			Mode, 
+	CHANNEL_WIDTH	BW,
+	u2Byte			Period
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO		pBeamInfo =  &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMING_OID_INFO	pBeamOidInfo = &(pBeamInfo->BeamformingOidInfo);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Idx (%d), Mode (%d), BW (%d), Period (%d)\n", Idx, Mode, BW, Period));
+
+	pBeamOidInfo->SoundOidIdx = Idx;
+	pBeamOidInfo->SoundOidMode = (SOUNDING_MODE) Mode;
+	pBeamOidInfo->SoundOidBW = BW;
+	pBeamOidInfo->SoundOidPeriod = Period;
+
+	phydm_Beamforming_Notify(pDM_Odm);
+
+	return TRUE;
+}
+
+
+VOID
+phydm_Beamforming_Watchdog(
+	IN	PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_TRACE, ("%s Start!\n", __func__));
+
+	if (pBeamInfo->beamformee_su_cnt == 0)
+		return;
+
+	Beamforming_DymPeriod(pDM_Odm,0);
+	phydm_Beamforming_DymNDPARate(pDM_Odm);
+
+}
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.h
new file mode 100644
index 000000000..c01f0819e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_beamforming.h
@@ -0,0 +1,365 @@
+#ifndef __INC_BEAMFORMING_H
+#define __INC_BEAMFORMING_H
+
+#ifndef BEAMFORMING_SUPPORT
+#define	BEAMFORMING_SUPPORT		0
+#endif
+
+/*Beamforming Related*/
+#include "txbf/halcomtxbf.h"
+#include "txbf/haltxbfjaguar.h"
+#include "txbf/haltxbf8192e.h"
+#include "txbf/haltxbf8814a.h"
+#include "txbf/haltxbf8821b.h"
+#include "txbf/haltxbf8822b.h"
+#include "txbf/haltxbfinterface.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+
+#define MAX_BEAMFORMEE_SU	2
+#define MAX_BEAMFORMER_SU	2
+#if (RTL8822B_SUPPORT == 1)
+#define MAX_BEAMFORMEE_MU	6
+#define MAX_BEAMFORMER_MU	1
+#else
+#define MAX_BEAMFORMEE_MU	0
+#define MAX_BEAMFORMER_MU	0
+#endif
+
+#define BEAMFORMEE_ENTRY_NUM		(MAX_BEAMFORMEE_SU + MAX_BEAMFORMEE_MU)
+#define BEAMFORMER_ENTRY_NUM		(MAX_BEAMFORMER_SU + MAX_BEAMFORMER_MU)
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+/*for different naming between WIN and CE*/
+#define BEACON_QUEUE	BCN_QUEUE_INX
+#define NORMAL_QUEUE	MGT_QUEUE_INX
+#define RT_DISABLE_FUNC RTW_DISABLE_FUNC
+#define RT_ENABLE_FUNC RTW_ENABLE_FUNC
+#endif
+
+typedef enum _BEAMFORMING_ENTRY_STATE {
+	BEAMFORMING_ENTRY_STATE_UNINITIALIZE, 
+	BEAMFORMING_ENTRY_STATE_INITIALIZEING, 
+	BEAMFORMING_ENTRY_STATE_INITIALIZED, 
+	BEAMFORMING_ENTRY_STATE_PROGRESSING, 
+	BEAMFORMING_ENTRY_STATE_PROGRESSED 
+} BEAMFORMING_ENTRY_STATE, *PBEAMFORMING_ENTRY_STATE;
+
+
+typedef enum _BEAMFORMING_NOTIFY_STATE {
+	BEAMFORMING_NOTIFY_NONE,
+	BEAMFORMING_NOTIFY_ADD,
+	BEAMFORMING_NOTIFY_DELETE,
+	BEAMFORMEE_NOTIFY_ADD_SU,
+	BEAMFORMEE_NOTIFY_DELETE_SU,
+	BEAMFORMEE_NOTIFY_ADD_MU,
+	BEAMFORMEE_NOTIFY_DELETE_MU,
+	BEAMFORMING_NOTIFY_RESET
+} BEAMFORMING_NOTIFY_STATE, *PBEAMFORMING_NOTIFY_STATE;
+
+typedef enum _BEAMFORMING_CAP {
+	BEAMFORMING_CAP_NONE = 0x0,
+	BEAMFORMER_CAP_HT_EXPLICIT = BIT1, 
+	BEAMFORMEE_CAP_HT_EXPLICIT = BIT2, 
+	BEAMFORMER_CAP_VHT_SU = BIT5,			/* Self has er Cap, because Reg er  & peer ee */
+	BEAMFORMEE_CAP_VHT_SU = BIT6,			/* Self has ee Cap, because Reg ee & peer er */
+	BEAMFORMER_CAP_VHT_MU = BIT7,			/* Self has er Cap, because Reg er  & peer ee */
+	BEAMFORMEE_CAP_VHT_MU = BIT8,			/* Self has ee Cap, because Reg ee & peer er */
+	BEAMFORMER_CAP = BIT9,
+	BEAMFORMEE_CAP = BIT10,
+}BEAMFORMING_CAP, *PBEAMFORMING_CAP;
+
+
+typedef enum _SOUNDING_MODE {
+	SOUNDING_SW_VHT_TIMER = 0x0,
+	SOUNDING_SW_HT_TIMER = 0x1, 
+	SOUNDING_STOP_All_TIMER = 0x2, 
+	SOUNDING_HW_VHT_TIMER = 0x3,			
+	SOUNDING_HW_HT_TIMER = 0x4,
+	SOUNDING_STOP_OID_TIMER = 0x5, 
+	SOUNDING_AUTO_VHT_TIMER = 0x6,
+	SOUNDING_AUTO_HT_TIMER = 0x7,
+	SOUNDING_FW_VHT_TIMER = 0x8,
+	SOUNDING_FW_HT_TIMER = 0x9,
+}SOUNDING_MODE, *PSOUNDING_MODE;
+
+typedef struct _RT_BEAMFORM_STAINFO {
+	pu1Byte						RA; 
+	u2Byte						AID; 
+	u2Byte						MacID;
+	u1Byte						MyMacAddr[6];
+	WIRELESS_MODE				WirelessMode;
+	CHANNEL_WIDTH				BW;
+	BEAMFORMING_CAP			BeamformCap;
+	u1Byte						HtBeamformCap;
+	u2Byte						VhtBeamformCap;
+	u1Byte						CurBeamform; 
+	u2Byte						CurBeamformVHT;
+} RT_BEAMFORM_STAINFO, *PRT_BEAMFORM_STAINFO;
+
+
+typedef struct _RT_BEAMFORMEE_ENTRY {
+	BOOLEAN bUsed;
+	BOOLEAN	bTxBF;
+	BOOLEAN bSound;
+	u2Byte	AID;				/*Used to construct AID field of NDPA packet.*/
+	u2Byte	MacId;				/*Used to Set Reg42C in IBSS mode. */
+	u2Byte	P_AID;				/*Used to fill Reg42C & Reg714 to compare with P_AID of Tx DESC. */
+	u2Byte	G_ID;				/*Used to fill Tx DESC*/
+	u1Byte	MyMacAddr[6];
+	u1Byte	MacAddr[6];			/*Used to fill Reg6E4 to fill Mac address of CSI report frame.*/
+	CHANNEL_WIDTH			SoundBW;		/*Sounding BandWidth*/
+	u2Byte					SoundPeriod;
+	BEAMFORMING_CAP			BeamformEntryCap;
+	BEAMFORMING_ENTRY_STATE	BeamformEntryState;	
+	BOOLEAN						bBeamformingInProgress;
+	/*u1Byte	LogSeq;									// Move to _RT_BEAMFORMER_ENTRY*/
+	/*u2Byte	LogRetryCnt:3;		// 0~4				// Move to _RT_BEAMFORMER_ENTRY*/
+	/*u2Byte	LogSuccessCnt:2;		// 0~2				// Move to _RT_BEAMFORMER_ENTRY*/
+	u2Byte	LogStatusFailCnt:5;	// 0~21
+	u2Byte	DefaultCSICnt:5;		// 0~21
+	u1Byte	CSIMatrix[327];
+	u2Byte	CSIMatrixLen;
+	u1Byte	NumofSoundingDim;
+	u1Byte	CompSteeringNumofBFer;
+	u1Byte	su_reg_index;
+	/*For MU-MIMO*/
+	BOOLEAN	is_mu_sta;
+	u1Byte	mu_reg_index;
+	u1Byte	gid_valid[8];
+	u1Byte	user_position[16];
+} RT_BEAMFORMEE_ENTRY, *PRT_BEAMFORMEE_ENTRY;
+
+typedef struct _RT_BEAMFORMER_ENTRY {
+	BOOLEAN 			bUsed;
+	/*P_AID of BFer entry is probably not used*/
+	u2Byte				P_AID;					/*Used to fill Reg42C & Reg714 to compare with P_AID of Tx DESC. */
+	u2Byte				G_ID;
+	u1Byte				MyMacAddr[6];
+	u1Byte				MacAddr[6];
+	BEAMFORMING_CAP	BeamformEntryCap;
+	u1Byte				NumofSoundingDim;
+	u1Byte				ClockResetTimes;		/*Modified by Jeffery @2015-04-10*/
+	u1Byte				PreLogSeq;				/*Modified by Jeffery @2015-03-30*/
+	u1Byte				LogSeq;					/*Modified by Jeffery @2014-10-29*/
+	u2Byte				LogRetryCnt:3;			/*Modified by Jeffery @2014-10-29*/
+	u2Byte				LogSuccess:2;			/*Modified by Jeffery @2014-10-29*/
+	u1Byte				su_reg_index;
+	 /*For MU-MIMO*/
+	BOOLEAN				is_mu_ap;
+	u1Byte				gid_valid[8];
+	u1Byte				user_position[16];
+	u2Byte				AID;
+} RT_BEAMFORMER_ENTRY, *PRT_BEAMFORMER_ENTRY;
+
+typedef struct _RT_SOUNDING_INFO {
+	u1Byte			SoundIdx;
+	CHANNEL_WIDTH	SoundBW;
+	SOUNDING_MODE	SoundMode; 
+	u2Byte			SoundPeriod;
+} RT_SOUNDING_INFO, *PRT_SOUNDING_INFO;
+
+
+
+typedef struct _RT_BEAMFORMING_OID_INFO {
+	u1Byte			SoundOidIdx;
+	CHANNEL_WIDTH	SoundOidBW;	
+	SOUNDING_MODE	SoundOidMode;
+	u2Byte			SoundOidPeriod;
+} RT_BEAMFORMING_OID_INFO, *PRT_BEAMFORMING_OID_INFO;
+
+
+typedef struct _RT_BEAMFORMING_INFO {
+	BEAMFORMING_CAP			BeamformCap;
+	RT_BEAMFORMEE_ENTRY		BeamformeeEntry[BEAMFORMEE_ENTRY_NUM];
+	RT_BEAMFORMER_ENTRY		BeamformerEntry[BEAMFORMER_ENTRY_NUM];
+	RT_BEAMFORM_STAINFO		BeamformSTAinfo;
+	u1Byte					BeamformeeCurIdx;
+	RT_TIMER					BeamformingTimer;
+	RT_TIMER					mu_timer;
+	RT_SOUNDING_INFO			SoundingInfo;
+	RT_BEAMFORMING_OID_INFO	BeamformingOidInfo;
+	HAL_TXBF_INFO			TxbfInfo;
+	u1Byte					SoundingSequence;
+	u1Byte					beamformee_su_cnt;
+	u1Byte					beamformer_su_cnt;
+	u4Byte					beamformee_su_reg_maping;
+	u4Byte					beamformer_su_reg_maping;
+	/*For MU-MINO*/
+	u1Byte					beamformee_mu_cnt;
+	u1Byte					beamformer_mu_cnt;
+	u4Byte					beamformee_mu_reg_maping;
+	u1Byte					mu_ap_index;
+	BOOLEAN					is_mu_sounding;
+	u1Byte					FirstMUBFeeIndex;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER				SourceAdapter;
+#endif
+	/* Control register */
+	u4Byte					RegMUTxCtrl;		/* For USB/SDIO interfaces aync I/O  */
+} RT_BEAMFORMING_INFO, *PRT_BEAMFORMING_INFO;
+
+
+typedef struct _RT_NDPA_STA_INFO {
+	u2Byte	AID:12;	
+	u2Byte	FeedbackType:1;
+	u2Byte	NcIndex:3;	
+} RT_NDPA_STA_INFO, *PRT_NDPA_STA_INFO;
+
+
+BEAMFORMING_CAP
+phydm_Beamforming_GetEntryBeamCapByMacId(
+	IN	PVOID	pDM_VOID,
+	IN 	u1Byte 	MacId
+ );
+
+PRT_BEAMFORMEE_ENTRY
+phydm_Beamforming_GetBFeeEntryByAddr(
+	IN	PVOID		pDM_VOID,
+	IN	pu1Byte		RA,
+	OUT	pu1Byte		Idx
+	);
+
+PRT_BEAMFORMER_ENTRY
+phydm_Beamforming_GetBFerEntryByAddr(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte	TA,
+	OUT	pu1Byte	Idx
+	);
+
+u1Byte
+Beamforming_GetHTNDPTxRate(
+	IN	PVOID	pDM_VOID,
+	u1Byte	CompSteeringNumofBFer
+);
+
+u1Byte
+Beamforming_GetVHTNDPTxRate(
+	IN	PVOID	pDM_VOID,
+	u1Byte	CompSteeringNumofBFer
+);
+
+VOID
+phydm_Beamforming_Notify(
+	IN	PVOID	pDM_VOID
+	);
+
+
+VOID
+Beamforming_Enter(
+	IN PVOID		pDM_VOID,
+	IN u2Byte	staIdx
+	);
+
+VOID
+Beamforming_Leave(
+	IN PVOID		pDM_VOID,
+	pu1Byte			RA
+	);
+
+BOOLEAN
+BeamformingStart_FW(
+	IN PVOID			pDM_VOID,
+	u1Byte			Idx
+	);
+
+VOID
+Beamforming_CheckSoundingSuccess(
+	IN PVOID			pDM_VOID,
+	BOOLEAN			Status	
+);
+
+VOID
+phydm_Beamforming_End_SW(
+	IN PVOID		pDM_VOID,
+	BOOLEAN			Status	
+	);
+
+VOID
+Beamforming_TimerCallback(
+	IN PVOID			pDM_VOID
+	);
+
+VOID
+phydm_Beamforming_Init(
+	IN	PVOID		pDM_VOID
+	);
+
+
+
+BEAMFORMING_CAP
+phydm_Beamforming_GetBeamCap(
+	IN PVOID			pDM_VOID,
+	IN PRT_BEAMFORMING_INFO 	pBeamInfo
+	);
+
+
+BOOLEAN
+BeamformingControl_V1(
+	IN PVOID			pDM_VOID,
+	pu1Byte			RA,
+	u1Byte			AID,
+	u1Byte			Mode,
+	CHANNEL_WIDTH	BW,
+	u1Byte			Rate
+	);
+
+
+BOOLEAN
+phydm_BeamformingControl_V2(
+	IN	PVOID		pDM_VOID,
+	u1Byte			Idx,
+	u1Byte			Mode, 
+	CHANNEL_WIDTH	BW,
+	u2Byte			Period
+	);
+
+VOID
+phydm_Beamforming_Watchdog(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+Beamforming_SWTimerCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PRT_TIMER		pTimer
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	void *FunctionContext
+#endif
+	);
+
+BOOLEAN
+Beamforming_SendHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW, 
+	IN	u1Byte			QIdx
+	);
+
+
+BOOLEAN
+Beamforming_SendVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW,
+	IN	u1Byte			QIdx
+	);
+
+#else
+#define Beamforming_GidPAid(Adapter, pTcb)
+#define Beamforming_Enter(pDM_Odm, staIdx)
+#define Beamforming_Leave(pDM_Odm, RA)
+#define Beamforming_End_FW(pDMOdm)
+#define BeamformingControl_V1(pDM_Odm, RA, AID, Mode, BW, Rate)		TRUE
+#define BeamformingControl_V2(pDM_Odm, Idx, Mode, BW, Period)		TRUE
+#define phydm_Beamforming_End_SW(pDM_Odm, _Status)
+#define Beamforming_TimerCallback(pDM_Odm)
+#define phydm_Beamforming_Init(pDM_Odm)
+#define phydm_BeamformingControl_V2(pDM_Odm, _Idx, _Mode, _BW, _Period)	FALSE
+#define Beamforming_Watchdog(pDM_Odm)
+#define phydm_Beamforming_Watchdog(pDM_Odm)
+
+
+#endif
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.c
new file mode 100644
index 000000000..0aa78f17e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.c
@@ -0,0 +1,347 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+VOID
+odm_SetCrystalCap(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					CrystalCap
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	BOOLEAN 					bEEPROMCheck;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+
+	bEEPROMCheck = (pHalData->EEPROMVersion >= 0x01)?TRUE:FALSE;
+#else
+	bEEPROMCheck = TRUE;
+#endif
+
+	if(pCfoTrack->CrystalCap == CrystalCap)
+		return;
+
+	pCfoTrack->CrystalCap = CrystalCap;
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8188E | ODM_RTL8188F)) {
+		/* write 0x24[22:17] = 0x24[16:11] = CrystalCap */
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_AFE_XTAL_CTRL, 0x007ff800, (CrystalCap|(CrystalCap << 6)));
+	} else if (pDM_Odm->SupportICType & ODM_RTL8812) {
+		/* write 0x2C[30:25] = 0x2C[24:19] = CrystalCap */
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x7FF80000, (CrystalCap|(CrystalCap << 6)));
+	} else if (((pDM_Odm->SupportICType & ODM_RTL8723A) && bEEPROMCheck) ||
+		(pDM_Odm->SupportICType & (ODM_RTL8703B|ODM_RTL8723B|ODM_RTL8192E|ODM_RTL8821))) {
+		/* 0x2C[23:18] = 0x2C[17:12] = CrystalCap */
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x00FFF000, (CrystalCap|(CrystalCap << 6)));	
+	} else if (pDM_Odm->SupportICType & ODM_RTL8821B) {
+		/* write 0x28[6:1] = 0x24[30:25] = CrystalCap */
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_AFE_XTAL_CTRL, 0x7E000000, CrystalCap);
+		ODM_SetBBReg(pDM_Odm, REG_AFE_PLL_CTRL, 0x7E, CrystalCap);
+	} else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
+		/* write 0x2C[26:21] = 0x2C[20:15] = CrystalCap */
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x07FF8000, (CrystalCap|(CrystalCap << 6)));
+	} else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
+		/* write 0x24[30:25] = 0x28[6:1] = CrystalCap */
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_AFE_XTAL_CTRL, 0x7e000000, CrystalCap);
+		ODM_SetBBReg(pDM_Odm, REG_AFE_PLL_CTRL, 0x7e, CrystalCap);
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("odm_SetCrystalCap(): Use default setting.\n"));
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0xFFF000, (CrystalCap|(CrystalCap << 6)));
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("odm_SetCrystalCap(): CrystalCap = 0x%x\n", CrystalCap));
+#endif
+}
+
+u1Byte
+odm_GetDefaultCrytaltalCap(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte						CrystalCap = 0x20;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+
+	CrystalCap = pHalData->CrystalCap;
+#else
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+
+	if(priv->pmib->dot11RFEntry.xcap > 0)
+		CrystalCap = priv->pmib->dot11RFEntry.xcap;
+#endif
+
+	CrystalCap = CrystalCap & 0x3f;
+
+	return CrystalCap;
+}
+
+VOID
+odm_SetATCStatus(
+	IN		PVOID					pDM_VOID,
+	IN		BOOLEAN					ATCStatus
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+
+	if(pCfoTrack->bATCStatus == ATCStatus)
+		return;
+	
+	ODM_SetBBReg(pDM_Odm, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm), ATCStatus);
+	pCfoTrack->bATCStatus = ATCStatus;
+}
+
+BOOLEAN
+odm_GetATCStatus(
+	IN		PVOID					pDM_VOID
+)
+{
+	BOOLEAN						ATCStatus;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ATCStatus = (BOOLEAN)ODM_GetBBReg(pDM_Odm, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm));
+	return ATCStatus;
+}
+
+VOID
+ODM_CfoTrackingReset(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+
+	pCfoTrack->DefXCap = odm_GetDefaultCrytaltalCap(pDM_Odm);
+	pCfoTrack->bAdjust = TRUE;
+
+	if(pCfoTrack->CrystalCap > pCfoTrack->DefXCap)
+	{
+		odm_SetCrystalCap(pDM_Odm, pCfoTrack->CrystalCap - 1);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD,
+			("ODM_CfoTrackingReset(): approch default value (0x%x)\n", pCfoTrack->CrystalCap));
+	} else if (pCfoTrack->CrystalCap < pCfoTrack->DefXCap)
+	{
+		odm_SetCrystalCap(pDM_Odm, pCfoTrack->CrystalCap + 1);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD,
+			("ODM_CfoTrackingReset(): approch default value (0x%x)\n", pCfoTrack->CrystalCap));
+	}
+
+	#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	odm_SetATCStatus(pDM_Odm, TRUE);
+	#endif
+}
+
+VOID
+ODM_CfoTrackingInit(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+
+	pCfoTrack->DefXCap = pCfoTrack->CrystalCap = odm_GetDefaultCrytaltalCap(pDM_Odm);
+	pCfoTrack->bATCStatus = odm_GetATCStatus(pDM_Odm);
+	pCfoTrack->bAdjust = TRUE;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking_init()=========> \n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking_init(): bATCStatus = %d, CrystalCap = 0x%x \n",pCfoTrack->bATCStatus, pCfoTrack->DefXCap));
+}
+
+VOID
+ODM_CfoTracking(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	int							CFO_kHz_A, CFO_kHz_B, CFO_ave = 0;
+	int							CFO_ave_diff;
+	int							CrystalCap = (int)pCfoTrack->CrystalCap;
+	u1Byte						Adjust_Xtal = 1;
+
+	//4 Support ability
+	if(!(pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Return: SupportAbility ODM_BB_CFO_TRACKING is disabled\n"));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking()=========> \n"));
+
+	if(!pDM_Odm->bLinked || !pDM_Odm->bOneEntryOnly)
+	{	
+		//4 No link or more than one entry
+		ODM_CfoTrackingReset(pDM_Odm);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Reset: bLinked = %d, bOneEntryOnly = %d\n", 
+			pDM_Odm->bLinked, pDM_Odm->bOneEntryOnly));
+	}
+	else
+	{
+		//3 1. CFO Tracking
+		//4 1.1 No new packet
+		if(pCfoTrack->packetCount == pCfoTrack->packetCount_pre)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): packet counter doesn't change\n"));
+			return;
+		}
+		pCfoTrack->packetCount_pre = pCfoTrack->packetCount;
+	
+		//4 1.2 Calculate CFO
+		CFO_kHz_A =  (int)((pCfoTrack->CFO_tail[0] * 3125)  / 10)>>7; /* CFO_tail[1:0] is S(8,7),    (num_subcarrier>>7) x 312.5K = CFO value(K Hz)   */
+		CFO_kHz_B =  (int)((pCfoTrack->CFO_tail[1] * 3125)  / 10)>>7;
+		
+		if(pDM_Odm->RFType < ODM_2T2R)
+			CFO_ave = CFO_kHz_A;
+		else
+			CFO_ave = (int)(CFO_kHz_A + CFO_kHz_B) >> 1;
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): CFO_kHz_A = %dkHz, CFO_kHz_B = %dkHz, CFO_ave = %dkHz\n", 
+						CFO_kHz_A, CFO_kHz_B, CFO_ave));
+
+		//4 1.3 Avoid abnormal large CFO
+		CFO_ave_diff = (pCfoTrack->CFO_ave_pre >= CFO_ave)?(pCfoTrack->CFO_ave_pre - CFO_ave):(CFO_ave - pCfoTrack->CFO_ave_pre);
+		if(CFO_ave_diff > 20 && pCfoTrack->largeCFOHit == 0 && !pCfoTrack->bAdjust)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): first large CFO hit\n"));
+			pCfoTrack->largeCFOHit = 1;
+			return;
+		}
+		else
+			pCfoTrack->largeCFOHit = 0;
+		pCfoTrack->CFO_ave_pre = CFO_ave;
+
+		//4 1.4 Dynamic Xtal threshold
+		if(pCfoTrack->bAdjust == FALSE)
+		{
+			if(CFO_ave > CFO_TH_XTAL_HIGH || CFO_ave < (-CFO_TH_XTAL_HIGH))
+				pCfoTrack->bAdjust = TRUE;
+		}
+		else
+		{
+			if(CFO_ave < CFO_TH_XTAL_LOW && CFO_ave > (-CFO_TH_XTAL_LOW))
+				pCfoTrack->bAdjust = FALSE;
+		}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		//4 1.5 BT case: Disable CFO tracking
+		if(pDM_Odm->bBtEnabled)
+		{
+			pCfoTrack->bAdjust = FALSE;
+			odm_SetCrystalCap(pDM_Odm, pCfoTrack->DefXCap);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Disable CFO tracking for BT!!\n"));
+		}
+/*
+		//4 1.6 Big jump 
+		if(pCfoTrack->bAdjust)
+		{
+			if(CFO_ave > CFO_TH_XTAL_LOW)
+				Adjust_Xtal =  Adjust_Xtal + ((CFO_ave - CFO_TH_XTAL_LOW) >> 2);
+			else if(CFO_ave < (-CFO_TH_XTAL_LOW))
+				Adjust_Xtal =  Adjust_Xtal + ((CFO_TH_XTAL_LOW - CFO_ave) >> 2);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Crystal cap offset = %d\n", Adjust_Xtal));
+		}
+*/
+#endif
+		
+		//4 1.7 Adjust Crystal Cap.
+		if(pCfoTrack->bAdjust)
+		{
+			if(CFO_ave > CFO_TH_XTAL_LOW)
+				CrystalCap = CrystalCap + Adjust_Xtal;
+			else if(CFO_ave < (-CFO_TH_XTAL_LOW))
+				CrystalCap = CrystalCap - Adjust_Xtal;
+
+			if(CrystalCap > 0x3f)
+				CrystalCap = 0x3f;
+			else if (CrystalCap < 0)
+				CrystalCap = 0;
+
+			odm_SetCrystalCap(pDM_Odm, (u1Byte)CrystalCap);
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Crystal cap = 0x%x, Default Crystal cap = 0x%x\n", 
+			pCfoTrack->CrystalCap, pCfoTrack->DefXCap));
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+			return;
+		
+		//3 2. Dynamic ATC switch
+		if(CFO_ave < CFO_TH_ATC && CFO_ave > -CFO_TH_ATC)
+		{
+			odm_SetATCStatus(pDM_Odm, FALSE);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Disable ATC!!\n"));
+		}
+		else
+		{
+			odm_SetATCStatus(pDM_Odm, TRUE);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Enable ATC!!\n"));
+		}
+#endif
+	}
+}
+
+VOID
+ODM_ParsingCFO(
+	IN		PVOID			pDM_VOID,
+	IN		PVOID			pPktinfo_VOID,
+	IN		s1Byte* 			pcfotail
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_PACKET_INFO_T		pPktinfo = (PODM_PACKET_INFO_T)pPktinfo_VOID;
+	PCFO_TRACKING			pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	u1Byte					i;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING))
+		return;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(pPktinfo->bPacketMatchBSSID)
+#else
+	if(pPktinfo->StationID != 0)
+#endif
+	{				
+		//3 Update CFO report for path-A & path-B
+		// Only paht-A and path-B have CFO tail and short CFO
+		for(i = ODM_RF_PATH_A; i <= ODM_RF_PATH_B; i++)   
+		{
+			pCfoTrack->CFO_tail[i] = (int)pcfotail[i];
+	 	}
+
+		//3 Update packet counter
+		if(pCfoTrack->packetCount == 0xffffffff)
+			pCfoTrack->packetCount = 0;
+		else
+	 		pCfoTrack->packetCount++;
+	}
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.h
new file mode 100644
index 000000000..7eca3f6e9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_cfotracking.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__PHYDMCFOTRACK_H__
+#define    __PHYDMCFOTRACK_H__
+
+#define CFO_TRACKING_VERSION	"1.2" /*2015.06.17*/
+
+#define		CFO_TH_XTAL_HIGH			20			// kHz
+#define		CFO_TH_XTAL_LOW			10			// kHz
+#define		CFO_TH_ATC					80			// kHz
+
+typedef struct _CFO_TRACKING_
+{
+	BOOLEAN			bATCStatus;
+	BOOLEAN			largeCFOHit;
+	BOOLEAN			bAdjust;
+	u1Byte			CrystalCap;
+	u1Byte			DefXCap;
+	int				CFO_tail[2];
+	int				CFO_ave_pre;
+	u4Byte			packetCount;
+	u4Byte			packetCount_pre;
+
+	BOOLEAN			bForceXtalCap;
+	BOOLEAN			bReset;
+}CFO_TRACKING, *PCFO_TRACKING;
+
+VOID
+ODM_CfoTrackingReset(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+ODM_CfoTrackingInit(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+ODM_CfoTracking(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+ODM_ParsingCFO(
+	IN		PVOID					pDM_VOID,
+	IN		PVOID					pPktinfo_VOID,
+	IN     	s1Byte* 					pcfotail
+);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.c
new file mode 100644
index 000000000..a9e3e0c53
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.c
@@ -0,0 +1,2002 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+
+VOID
+PHYDM_InitDebugSetting(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+	pDM_Odm->DebugLevel = ODM_DBG_TRACE;
+
+	pDM_Odm->DebugComponents			=
+		\
+#if DBG
+//BB Functions
+//									ODM_COMP_DIG					|
+//									ODM_COMP_RA_MASK				|
+//									ODM_COMP_DYNAMIC_TXPWR		|
+//									ODM_COMP_FA_CNT				|
+//									ODM_COMP_RSSI_MONITOR			|
+//									ODM_COMP_CCK_PD				|
+/*									ODM_COMP_ANT_DIV				|*/
+//									ODM_COMP_PWR_SAVE				|
+//									ODM_COMP_PWR_TRAIN			|
+//									ODM_COMP_RATE_ADAPTIVE		|
+//									ODM_COMP_PATH_DIV				|
+//									ODM_COMP_DYNAMIC_PRICCA		|
+//									ODM_COMP_RXHP					|
+//									ODM_COMP_MP 					|
+//									ODM_COMP_CFO_TRACKING		|
+//									ODM_COMP_ACS					|
+//									PHYDM_COMP_ADAPTIVITY			|
+//									PHYDM_COMP_RA_DBG				|
+/*									PHYDM_COMP_TXBF					|*/
+//MAC Functions
+//									ODM_COMP_EDCA_TURBO			|
+//									ODM_COMP_EARLY_MODE			|
+/*									ODM_FW_DEBUG_TRACE				|*/
+//RF Functions
+//									ODM_COMP_TX_PWR_TRACK		|
+//									ODM_COMP_RX_GAIN_TRACK		|
+//									ODM_COMP_CALIBRATION			|
+//Common
+/*									ODM_PHY_CONFIG					|*/
+//									ODM_COMP_COMMON				|
+//									ODM_COMP_INIT					|
+//									ODM_COMP_PSD					|
+/*									ODM_COMP_NOISY_DETECT			|*/
+#endif
+		0;
+
+	pDM_Odm->fw_buff_is_enpty = TRUE;
+	pDM_Odm->pre_c2h_seq = 0;
+}
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+static u1Byte	BbDbgBuf[BB_TMP_BUF_SIZE];
+
+VOID
+phydm_BB_RxHang_Info(IN PDM_ODM_T pDM_Odm)
+{
+	u4Byte	value32 = 0;
+
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		return;
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF80 , bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rptreg of sc/bw/ht/...", value32);
+	DCMD_Printf(BbDbgBuf);
+
+	/* dbg_port = state machine */
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0x007);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "state machine", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = CCA-related*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0x204);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "CCA-related", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+
+	/* dbg_port = edcca/rxd*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0x278);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "edcca/rxd", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = rx_state/mux_state/ADC_MASK_OFDM*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0x290);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rx_state/mux_state/ADC_MASK_OFDM", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = bf-related*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0x2B2);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "bf-related", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = bf-related*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0x2B8);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "bf-related", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = txon/rxd*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xA03);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "txon/rxd", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = l_rate/l_length*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xA0B);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "l_rate/l_length", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = rxd/rxd_hit*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xA0D);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rxd/rxd_hit", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = dis_cca*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xAA0);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "dis_cca", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+
+	/* dbg_port = tx*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xAB0);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "tx", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	/* dbg_port = rx plcp*/
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xAD0);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rx plcp", (value32));
+		DCMD_Printf(BbDbgBuf);
+
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xAD1);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rx plcp", (value32));
+		DCMD_Printf(BbDbgBuf);
+
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xAD2);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rx plcp", (value32));
+		DCMD_Printf(BbDbgBuf);
+
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord, 0xAD3);
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8fc", value32);
+		DCMD_Printf(BbDbgBuf);
+
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC , bMaskDWord);
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "rx plcp", (value32));
+		DCMD_Printf(BbDbgBuf);
+	}
+
+}
+
+VOID
+phydm_BB_Debug_Info(IN PDM_ODM_T pDM_Odm)
+{
+
+	u1Byte	RX_HT_BW, RX_VHT_BW, RXSC, RX_HT, RX_BW;
+	static u1Byte vRX_BW ;
+	u4Byte	value32, value32_1, value32_2, value32_3;
+	s4Byte	SFO_A, SFO_B, SFO_C, SFO_D;
+	s4Byte	LFO_A, LFO_B, LFO_C, LFO_D;
+	static u1Byte	MCSS, Tail, Parity, rsv, vrsv, idx, smooth, htsound, agg, stbc, vstbc, fec, fecext, sgi, sgiext, htltf, vgid, vNsts, vtxops, vrsv2, vbrsv, bf, vbcrc;
+	static u2Byte	HLength, htcrc8, Length;
+	static u2Byte vpaid;
+	static u2Byte	vLength, vhtcrc8, vMCSS, vTail, vbTail;
+	static u1Byte	HMCSS, HRX_BW;
+
+
+	u1Byte    pwDB;
+	s1Byte    RXEVM_0, RXEVM_1, RXEVM_2 ;
+	u1Byte    RF_gain_pathA, RF_gain_pathB, RF_gain_pathC, RF_gain_pathD;
+	u1Byte    RX_SNR_pathA, RX_SNR_pathB, RX_SNR_pathC, RX_SNR_pathD;
+	s4Byte    sig_power;
+	const char *RXHT_table[3] = {"legacy", "HT", "VHT"};
+	const char *BW_table[3] = {"20M", "40M", "80M"};
+	const char *RXSC_table[7] = {"duplicate/full bw", "usc20-1", "lsc20-1", "usc20-2", "lsc20-2",  "usc40", "lsc40"};
+
+	const char *L_rate[8] = {"6M", "9M", "12M", "18M", "24M", "36M", "48M", "54M"};
+
+
+	/*
+	const double evm_comp_20M = 0.579919469776867; //10*log10(64.0/56.0)
+	const double evm_comp_40M = 0.503051183113957; //10*log10(128.0/114.0)
+	const double evm_comp_80M = 0.244245993314183; //10*log10(256.0/242.0)
+	const double evm_comp_160M = 0.244245993314183; //10*log10(512.0/484.0)
+	   */
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		return;
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s\n", "BB Report Info");
+	DCMD_Printf(BbDbgBuf);
+
+	/*BW & Mode Detection*/
+	
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf80 , bMaskDWord);
+	value32_2 = value32;
+	RX_HT_BW = (u1Byte)(value32 & 0x1);
+	RX_VHT_BW = (u1Byte)((value32 >> 1) & 0x3);
+	RXSC = (u1Byte)(value32 & 0x78);
+	value32_1 = (value32 & 0x180) >> 7;
+	RX_HT = (u1Byte)(value32_1);
+	/*
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "F80", value32_2);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_HT_BW", RX_HT_BW);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_VHT_BW", RX_VHT_BW);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_SC", RXSC);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_HT", RX_HT);
+	DCMD_Printf(BbDbgBuf);
+	*/
+
+	/*rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  RX_HT:%s ", RXHT_table[RX_HT]);*/
+	/*DCMD_Printf(BbDbgBuf);*/
+	RX_BW = 0;
+
+	if (RX_HT == 2) {
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  Mode: VHT Mode");
+		DCMD_Printf(BbDbgBuf);
+		if (RX_VHT_BW == 0) {
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=20M");
+			DCMD_Printf(BbDbgBuf);
+		} else if (RX_VHT_BW == 1) {
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=40M");
+			DCMD_Printf(BbDbgBuf);
+		} else {
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=80M");
+			DCMD_Printf(BbDbgBuf);
+		}
+		RX_BW = RX_VHT_BW;
+	} else if (RX_HT == 1) {
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  Mode: HT Mode");
+		DCMD_Printf(BbDbgBuf);
+		if (RX_HT_BW == 0) {
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=20M");
+			DCMD_Printf(BbDbgBuf);
+		} else if (RX_HT_BW == 1) {
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=40M");
+			DCMD_Printf(BbDbgBuf);
+		}
+		RX_BW = RX_HT_BW;
+	} else {
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  Mode: Legeacy Mode");
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	if (RX_HT != 0) {
+		if (RXSC == 0)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  duplicate/full bw");
+		else if (RXSC == 1)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  usc20-1");
+		else if (RXSC == 2)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  lsc20-1");
+		else if (RXSC == 3)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  usc20-2");
+		else if (RXSC == 4)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  lsc20-2");
+		else if (RXSC == 9)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  usc40");
+		else if (RXSC == 10)
+			rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  lsc40");
+		DCMD_Printf(BbDbgBuf);
+	}
+	/*
+	if(RX_HT == 2){
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "  BW:%s", BW_table[RX_VHT_BW]);
+		RX_BW = RX_VHT_BW;
+		}
+	else if(RX_HT == 1){
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "  BW:%s", BW_table[RX_HT_BW]);
+		RX_BW = RX_HT_BW;
+		}
+	else
+		rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE,  "");
+	
+	DCMD_Printf(BbDbgBuf);	
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "  RXSC:%s", RXSC_table[RXSC]);
+	DCMD_Printf(BbDbgBuf);
+	*/
+
+
+/*	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "dB Conversion: 10log(65)", ODM_PWdB_Conversion(65,10,0));*/
+/*	DCMD_Printf(BbDbgBuf);*/
+
+	/* RX signal power and AGC related info*/
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF90 , bMaskDWord);
+	pwDB = (u1Byte)((value32 & bMaskByte1) >> 8);
+	pwDB = pwDB >> 1;
+	sig_power = -110 + pwDB;
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "OFDM RX Signal Power(dB)", sig_power);
+	DCMD_Printf(BbDbgBuf);
+
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd14 , bMaskDWord);
+	RX_SNR_pathA = (u1Byte)(value32 & 0xFF) >> 1;
+	RF_gain_pathA = (s1Byte)((value32 & bMaskByte1) >> 8);
+	RF_gain_pathA *= 2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd54 , bMaskDWord);
+	RX_SNR_pathB = (u1Byte)(value32 & 0xFF) >> 1;
+	RF_gain_pathB = (s1Byte)((value32 & bMaskByte1) >> 8);
+	RF_gain_pathB *= 2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd94 , bMaskDWord);
+	RX_SNR_pathC = (u1Byte)(value32 & 0xFF) >> 1;
+	RF_gain_pathC = (s1Byte)((value32 & bMaskByte1) >> 8);
+	RF_gain_pathC *= 2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xdd4 , bMaskDWord);
+	RX_SNR_pathD = (u1Byte)(value32 & 0xFF) >> 1;
+	RF_gain_pathD = (s1Byte)((value32 & bMaskByte1) >> 8);
+	RF_gain_pathD *= 2;
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "OFDM RX RF Gain(A/B/C/D)", RF_gain_pathA, RF_gain_pathA, RF_gain_pathC, RF_gain_pathD);
+	DCMD_Printf(BbDbgBuf);
+
+
+	/* RX Counter related info*/
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF08, bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "OFDM CCA Counter", ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+	
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFD0, bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "OFDM SBD Fail Counter", value32&0xFFFF);
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFC4, bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "VHT SIGA/SIGB CRC8 Fail Counter", value32&0xFFFF, ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFCC, bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "CCK CCA Counter", value32&0xFFFF);
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFBC, bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "LSIG (\"Parity Fail\"/\"Rate Illegal\") Counter", value32&0xFFFF, ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xFC8, bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xFC0, bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "HT/VHT MCS NOT SUPPORT counter", ((value32_2&0xFFFF0000)>>16), value32_1&0xFFFF);
+	DCMD_Printf(BbDbgBuf);
+
+
+	/* PostFFT related info*/
+
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF8c , bMaskDWord);
+	RXEVM_0 = (s1Byte)((value32 & bMaskByte2) >> 16);
+	RXEVM_0 /= 2;
+	if (RXEVM_0 < -63)
+		RXEVM_0 = 0;
+
+	DCMD_Printf(BbDbgBuf);
+	RXEVM_1 = (s1Byte)((value32 & bMaskByte3) >> 24);
+	RXEVM_1 /= 2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF88 , bMaskDWord);
+	RXEVM_2 = (s1Byte)((value32 & bMaskByte2) >> 16);
+	RXEVM_2 /= 2;
+
+	if (RXEVM_1 < -63)
+		RXEVM_1 = 0;
+	if (RXEVM_2 < -63)
+		RXEVM_2 = 0;
+
+	/*
+	if(RX_BW == 0){
+		RXEVM_0 -= evm_comp_20M;
+		RXEVM_1 -= evm_comp_20M;
+		RXEVM_2 -= evm_comp_20M;
+		}
+	else if(RX_BW == 1){
+		RXEVM_0 -= evm_comp_40M;
+		RXEVM_1 -= evm_comp_40M;
+		RXEVM_2 -= evm_comp_40M;
+		}
+	else if (RX_BW == 2){
+		RXEVM_0 -= evm_comp_80M;
+		RXEVM_1 -= evm_comp_80M;
+		RXEVM_2 -= evm_comp_80M;
+		}
+		*/
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d", "RXEVM (1ss/2ss/3ss)", RXEVM_0, RXEVM_1, RXEVM_2);
+	DCMD_Printf(BbDbgBuf);
+
+/*	value32 = ODM_GetBBReg(pDM_Odm, 0xD14 ,bMaskDWord);*/
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "RXSNR(A/B/C/D, dB)", RX_SNR_pathA, RX_SNR_pathB, RX_SNR_pathC, RX_SNR_pathD);
+	DCMD_Printf(BbDbgBuf);
+/*	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "B_RXSNR", (value32&0xFF00)>>9);*/
+/*	DCMD_Printf(BbDbgBuf);*/
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF8C , bMaskDWord);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "CSI_1st /CSI_2nd", value32&0xFFFF, ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+
+
+	//BW & Mode Detection
+
+	//Reset Page F Counter
+	ODM_SetBBReg(pDM_Odm, 0xB58 , BIT0, 1);
+	ODM_SetBBReg(pDM_Odm, 0xB58 , BIT0, 0);
+
+	//CFO Report Info
+	//Short CFO
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd0c , bMaskDWord);
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xd4c , bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xd8c , bMaskDWord);
+	value32_3 = ODM_GetBBReg(pDM_Odm, 0xdcc , bMaskDWord);
+
+	SFO_A = (s4Byte)(value32 & bMask12Bits);
+	SFO_B = (s4Byte)(value32_1 & bMask12Bits);
+	SFO_C = (s4Byte)(value32_2 & bMask12Bits);
+	SFO_D = (s4Byte)(value32_3 & bMask12Bits);
+
+	LFO_A = (s4Byte)(value32 >> 16);
+	LFO_B = (s4Byte)(value32_1 >> 16);
+	LFO_C = (s4Byte)(value32_2 >> 16);
+	LFO_D = (s4Byte)(value32_3 >> 16);
+
+	//SFO 2's to dec
+	if (SFO_A > 2047)
+		SFO_A = SFO_A - 4096;
+	SFO_A = (SFO_A * 312500) / 2048;
+
+	if (SFO_B > 2047)
+		SFO_B = SFO_B - 4096;
+	SFO_B = (SFO_B * 312500) / 2048;
+	if (SFO_C > 2047)
+		SFO_C = SFO_C - 4096;
+	SFO_C = (SFO_C * 312500) / 2048;
+	if (SFO_D > 2047)
+		SFO_D = SFO_D - 4096;
+	SFO_D = (SFO_D * 312500) / 2048;
+
+	//LFO 2's to dec
+
+	if (LFO_A > 4095)
+		LFO_A = LFO_A - 8192;
+
+	if (LFO_B > 4095)
+		LFO_B = LFO_B - 8192;
+
+	if (LFO_C > 4095)
+		LFO_C = LFO_C - 8192;
+
+	if (LFO_D > 4095)
+		LFO_D = LFO_D - 8192;
+	LFO_A = LFO_A * 312500 / 4096;
+	LFO_B = LFO_B * 312500 / 4096;
+	LFO_C = LFO_C * 312500 / 4096;
+	LFO_D = LFO_D * 312500 / 4096;
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "CFO Report Info");
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  Short CFO(Hz) <A/B/C/D>", SFO_A, SFO_B, SFO_C, SFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  Long CFO(Hz) <A/B/C/D>", LFO_A, LFO_B, LFO_C, LFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	//SCFO
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd10 , bMaskDWord);
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xd50 , bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xd90 , bMaskDWord);
+	value32_3 = ODM_GetBBReg(pDM_Odm, 0xdd0 , bMaskDWord);
+
+	SFO_A = (s4Byte)(value32 & 0x7ff);
+	SFO_B = (s4Byte)(value32_1 & 0x7ff);
+	SFO_C = (s4Byte)(value32_2 & 0x7ff);
+	SFO_D = (s4Byte)(value32_3 & 0x7ff);
+
+	if (SFO_A > 1023)
+		SFO_A = SFO_A - 2048;
+
+	if (SFO_B > 2047)
+		SFO_B = SFO_B - 4096;
+
+	if (SFO_C > 2047)
+		SFO_C = SFO_C - 4096;
+
+	if (SFO_D > 2047)
+		SFO_D = SFO_D - 4096;
+
+	SFO_A = SFO_A * 312500 / 1024;
+	SFO_B = SFO_B * 312500 / 1024;
+	SFO_C = SFO_C * 312500 / 1024;
+	SFO_D = SFO_D * 312500 / 1024;
+
+	LFO_A = (s4Byte)(value32 >> 16);
+	LFO_B = (s4Byte)(value32_1 >> 16);
+	LFO_C = (s4Byte)(value32_2 >> 16);
+	LFO_D = (s4Byte)(value32_3 >> 16);
+
+	if (LFO_A > 4095)
+		LFO_A = LFO_A - 8192;
+
+	if (LFO_B > 4095)
+		LFO_B = LFO_B - 8192;
+
+	if (LFO_C > 4095)
+		LFO_C = LFO_C - 8192;
+
+	if (LFO_D > 4095)
+		LFO_D = LFO_D - 8192;
+	LFO_A = LFO_A * 312500 / 4096;
+	LFO_B = LFO_B * 312500 / 4096;
+	LFO_C = LFO_C * 312500 / 4096;
+	LFO_D = LFO_D * 312500 / 4096;
+	
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  Value SCFO(Hz) <A/B/C/D>", SFO_A, SFO_B, SFO_C, SFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  ACQ CFO(Hz) <A/B/C/D>", LFO_A, LFO_B, LFO_C, LFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd14 , bMaskDWord);
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xd54 , bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xd94 , bMaskDWord);
+	value32_3 = ODM_GetBBReg(pDM_Odm, 0xdd4 , bMaskDWord);
+
+	LFO_A = (s4Byte)(value32 >> 16);
+	LFO_B = (s4Byte)(value32_1 >> 16);
+	LFO_C = (s4Byte)(value32_2 >> 16);
+	LFO_D = (s4Byte)(value32_3 >> 16);
+
+	if (LFO_A > 4095)
+		LFO_A = LFO_A - 8192;
+
+	if (LFO_B > 4095)
+		LFO_B = LFO_B - 8192;
+
+	if (LFO_C > 4095)
+		LFO_C = LFO_C - 8192;
+
+	if (LFO_D > 4095)
+		LFO_D = LFO_D - 8192;
+
+	LFO_A = LFO_A * 312500 / 4096;
+	LFO_B = LFO_B * 312500 / 4096;
+	LFO_C = LFO_C * 312500 / 4096;
+	LFO_D = LFO_D * 312500 / 4096;
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  End CFO(Hz) <A/B/C/D>", LFO_A, LFO_B, LFO_C, LFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf20 , bMaskDWord);  /*L SIG*/
+
+	Tail = (u1Byte)((value32 & 0xfc0000) >> 16);
+	Parity = (u1Byte)((value32 & 0x20000) >> 16);
+	Length = (u2Byte)((value32 & 0x1ffe00) >> 8);
+	rsv = (u1Byte)(value32 & 0x10);
+	MCSS = (u1Byte)(value32 & 0x0f);
+
+	switch (MCSS) {
+	case 0x0b:
+		idx = 0;
+		break;
+	case 0x0f:
+		idx = 1;
+		break;
+	case 0x0a:
+		idx = 2;
+		break;
+	case 0x0e:
+		idx = 3;
+		break;
+	case 0x09:
+		idx = 4;
+		break;
+	case 0x08:
+		idx = 5;
+		break;
+	case 0x0c:
+		idx = 6;
+		break;
+	default:
+		idx = 6;
+		break;
+
+	}
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "L-SIG");
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n   Rate:%s", L_rate[idx]);		
+	DCMD_Printf(BbDbgBuf);	
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x/ %x /%x", "  Rsv/Length/Parity", rsv, RX_BW, Length);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "HT-SIG1");
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf2c , bMaskDWord);  /*HT SIG*/
+	if (RX_HT == 1) {
+
+		HMCSS = (u1Byte)(value32 & 0x7F);
+		HRX_BW = (u1Byte)(value32 & 0x80);
+		HLength = (u2Byte)((value32 >> 8) & 0xffff);
+	}
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x", "  MCS/BW/Length", HMCSS, HRX_BW, HLength);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "HT-SIG2");
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf30 , bMaskDWord);  /*HT SIG*/
+
+	if (RX_HT == 1) {
+		smooth = (u1Byte)(value32 & 0x01);
+		htsound = (u1Byte)(value32 & 0x02);
+		rsv = (u1Byte)(value32 & 0x04);
+		agg = (u1Byte)(value32 & 0x08);
+		stbc = (u1Byte)(value32 & 0x30);
+		fec = (u1Byte)(value32 & 0x40);
+		sgi = (u1Byte)(value32 & 0x80);
+		htltf = (u1Byte)((value32 & 0x300) >> 8);
+		htcrc8 = (u2Byte)((value32 & 0x3fc00) >> 8);
+		Tail = (u1Byte)((value32 & 0xfc0000) >> 16);
+
+
+	}
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/ %x/ %x", "  Smooth/NoSound/Rsv/Aggregate/STBC/LDPC", smooth, htsound, rsv, agg, stbc, fec);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x", "  SGI/E-HT-LTFs/CRC/Tail", sgi, htltf, htcrc8, Tail);
+	DCMD_Printf(BbDbgBuf);
+
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "VHT-SIG-A1");
+	DCMD_Printf(BbDbgBuf);
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf2c , bMaskDWord);  /*VHT SIG A1*/
+	if (RX_HT == 2) {
+		/* value32 = ODM_GetBBReg(pDM_Odm, 0xf2c ,bMaskDWord);*/
+		vRX_BW = (u1Byte)(value32 & 0x03);
+		vrsv = (u1Byte)(value32 & 0x04);
+		vstbc = (u1Byte)(value32 & 0x08);
+		vgid = (u1Byte)((value32 & 0x3f0) >> 4);
+		vNsts = (u1Byte)(((value32 & 0x1c00) >> 8) + 1);
+		vpaid = (u2Byte)(value32 & 0x3fe);
+		vtxops = (u1Byte)((value32 & 0x400000) >> 20);
+		vrsv2 = (u1Byte)((value32 & 0x800000) >> 20);
+	}
+
+	/*rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x", "F2C", value32);*/
+	/*DCMD_Printf(BbDbgBuf);*/
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/ %x/ %x /%x /%x", "  BW/Rsv1/STBC/GID/Nsts/PAID/TXOPPS/Rsv2", vRX_BW, vrsv, vstbc, vgid, vNsts, vpaid, vtxops, vrsv2);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "VHT-SIG-A2");
+	DCMD_Printf(BbDbgBuf);
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf30 , bMaskDWord);  /*VHT SIG*/
+
+
+	if (RX_HT == 2) {
+		/*value32 = ODM_GetBBReg(pDM_Odm, 0xf30 ,bMaskDWord); */  /*VHT SIG*/
+
+		//sgi=(u1Byte)(value32&0x01);
+		sgiext = (u1Byte)(value32 & 0x03);
+		//fec = (u1Byte)(value32&0x04);
+		fecext = (u1Byte)(value32 & 0x0C);
+
+		vMCSS = (u1Byte)(value32 & 0xf0);
+		bf = (u1Byte)((value32 & 0x100) >> 8);
+		vrsv = (u1Byte)((value32 & 0x200) >> 8);
+		vhtcrc8 = (u2Byte)((value32 & 0x3fc00) >> 8);
+		vTail = (u1Byte)((value32 & 0xfc0000) >> 16);
+	}
+	/*rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x", "F30", value32);*/
+	/*DCMD_Printf(BbDbgBuf);*/
+	
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/ %x/ %x/ %x", "  SGI/FEC/MCS/BF/Rsv/CRC/Tail", sgiext, fecext, vMCSS, bf, vrsv, vhtcrc8, vTail);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "VHT-SIG-B");
+	DCMD_Printf(BbDbgBuf);
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf34 , bMaskDWord);  /*VHT SIG*/
+	{
+		vLength = (u2Byte)(value32 & 0x1fffff);
+		vbrsv = (u1Byte)((value32 & 0x600000) >> 20);
+		vbTail = (u2Byte)((value32 & 0x1f800000) >> 20);
+		vbcrc = (u1Byte)((value32 & 0x80000000) >> 28);
+
+	}
+	/*rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x", "F34", value32);*/
+	/*DCMD_Printf(BbDbgBuf);*/
+	rsprintf((char *)BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/", "  Length/Rsv/Tail/CRC", vLength, vbrsv, vbTail, vbcrc);
+	DCMD_Printf(BbDbgBuf);
+
+
+}
+
+void phydm_sbd_check(
+	IN	PDM_ODM_T					pDM_Odm
+)
+{
+	static u4Byte	pkt_cnt = 0;
+	static BOOLEAN sbd_state = 0;
+	u4Byte	sym_count, count, value32;
+
+	if (sbd_state == 0) {
+		pkt_cnt++;
+		if (pkt_cnt % 5 == 0) { /*read SBD conter once every 5 packets*/
+			ODM_SetTimer(pDM_Odm, &pDM_Odm->sbdcnt_timer, 0); /*ms*/
+			sbd_state = 1;
+		}
+	} else { /*read counter*/
+		value32 = ODM_GetBBReg(pDM_Odm, 0xF98, bMaskDWord);
+		sym_count = (value32 & 0x7C000000) >> 26;
+		count = (value32 & 0x3F00000) >> 20;
+		DbgPrint("#SBD#    sym_count   %d   count   %d\n", sym_count, count);
+		sbd_state = 0;
+	}
+}
+
+void phydm_sbd_callback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+#if USE_WORKITEM
+	ODM_ScheduleWorkItem(&pDM_Odm->sbdcnt_workitem);
+#else
+	phydm_sbd_check(pDM_Odm);
+#endif
+}
+
+void phydm_sbd_workitem_callback(
+	IN PVOID            pContext
+)
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	phydm_sbd_check(pDM_Odm);
+}
+#endif
+VOID
+phydm_BasicDbgMessage
+(
+	IN		PVOID			pDM_VOID
+)
+{
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure(pDM_Odm , PHYDM_FALSEALMCNT);
+	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+	u1Byte	legacy_table[12] = {1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54};
+	u1Byte	vht_en = ((pDM_Odm->RxRate) >= ODM_RATEVHTSS1MCS0) ? 1 : 0;
+
+	if (pDM_Odm->RxRate <= ODM_RATE11M) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("[CCK AGC Report] LNA_idx = 0x%x, VGA_idx = 0x%x\n",
+			pDM_Odm->cck_lna_idx, pDM_Odm->cck_vga_idx));		
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("[OFDM AGC Report] { 0x%x, 0x%x, 0x%x, 0x%x }\n",
+			pDM_Odm->ofdm_agc_idx[0], pDM_Odm->ofdm_agc_idx[1], pDM_Odm->ofdm_agc_idx[2], pDM_Odm->ofdm_agc_idx[3]));	
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("RSSI: { %d,  %d,  %d,  %d },    RxRate: { %s%s%s%s%d%s}\n",
+		(pDM_Odm->RSSI_A == 0xff) ? 0 : pDM_Odm->RSSI_A , 
+		(pDM_Odm->RSSI_B == 0xff) ? 0 : pDM_Odm->RSSI_B , 
+		(pDM_Odm->RSSI_C == 0xff) ? 0 : pDM_Odm->RSSI_C, 
+		(pDM_Odm->RSSI_D == 0xff) ? 0 : pDM_Odm->RSSI_D,
+		((pDM_Odm->RxRate >= ODM_RATEVHTSS1MCS0) && (pDM_Odm->RxRate <= ODM_RATEVHTSS1MCS9)) ? "VHT 1ss  " : "",
+		((pDM_Odm->RxRate >= ODM_RATEVHTSS2MCS0) && (pDM_Odm->RxRate <= ODM_RATEVHTSS2MCS9)) ? "VHT 2ss " : "",
+		((pDM_Odm->RxRate >= ODM_RATEVHTSS3MCS0) && (pDM_Odm->RxRate <= ODM_RATEVHTSS3MCS9)) ? "VHT 3ss " : "",
+		(pDM_Odm->RxRate >= ODM_RATEMCS0) ? "MCS " : "",
+		(vht_en) ? ((pDM_Odm->RxRate - ODM_RATEVHTSS1MCS0)%10) : ((pDM_Odm->RxRate >= ODM_RATEMCS0) ? (pDM_Odm->RxRate - ODM_RATEMCS0) : ((pDM_Odm->RxRate <= ODM_RATE54M)?legacy_table[pDM_Odm->RxRate]:0)),
+		(pDM_Odm->RxRate >= ODM_RATEMCS0) ? "" : "M"));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("[CCA Cnt] {CCK, OFDM, Total} = {%d, %d, %d}\n",	
+		FalseAlmCnt->Cnt_CCK_CCA, FalseAlmCnt->Cnt_OFDM_CCA, FalseAlmCnt->Cnt_CCA_all));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("[FA Cnt] {CCK, OFDM, Total} = {%d, %d, %d}\n",	
+		FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_all));
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("[OFDM FA Detail] Parity_Fail = (( %d )), Rate_Illegal = (( %d )), CRC8_fail = (( %d )), Mcs_fail = (( %d )), Fast_Fsync = (( %d )), SB_Search_fail = (( %d ))\n",	
+		FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal, FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail, FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail));
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bLinked = %d, RSSI_Min = %d, CurrentIGI = 0x%x, bNoisy=%d\n\n",
+		pDM_Odm->bLinked, pDM_Odm->RSSI_Min, pDM_DigTable->CurIGValue, pDM_Odm->NoisyDecision));    
+/*
+	temp_reg = ODM_GetBBReg(pDM_Odm, 0xDD0, bMaskByte0);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("0xDD0 = 0x%x\n",temp_reg));
+		
+	temp_reg = ODM_GetBBReg(pDM_Odm, 0xDDc, bMaskByte1);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("0xDDD = 0x%x\n",temp_reg));
+	
+	temp_reg = ODM_GetBBReg(pDM_Odm, 0xc50, bMaskByte0);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("0xC50 = 0x%x\n",temp_reg));
+
+	temp_reg = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x0, 0x3fe0);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RF 0x0[13:5] = 0x%x\n\n",temp_reg));
+*/	
+
+#endif
+}
+
+
+VOID phydm_BasicProfile(
+	IN		PVOID			pDM_VOID,
+	IN		u4Byte			*_used,
+	OUT		char				*output,
+	IN		u4Byte			*_out_len
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	char  *Cut = NULL;
+	char *ICType = NULL;
+	u4Byte used = *_used;
+	u4Byte out_len = *_out_len;
+	u4Byte	commit_ver = 0;
+	u4Byte	date = 0;
+	char	*commit_by = NULL;
+	u4Byte	release_ver = 0;
+
+	PHYDM_SNPRINTF((output + used, out_len - used, "%-35s\n", "% Basic Profile %"));
+
+	if (pDM_Odm->SupportICType == ODM_RTL8192C)			
+		ICType = "RTL8192C";
+	else if (pDM_Odm->SupportICType == ODM_RTL8192D)
+		ICType = "RTL8192D";
+	else if (pDM_Odm->SupportICType == ODM_RTL8723A)
+		ICType = "RTL8723A";
+	else if (pDM_Odm->SupportICType == ODM_RTL8188E)
+		ICType = "RTL8188E";
+	else if (pDM_Odm->SupportICType == ODM_RTL8812)
+		ICType = "RTL8812A";
+	else if (pDM_Odm->SupportICType == ODM_RTL8821)
+		ICType = "RTL8821A";
+	else if (pDM_Odm->SupportICType == ODM_RTL8192E)
+		ICType = "RTL8192E";
+	else if (pDM_Odm->SupportICType == ODM_RTL8723B)
+		ICType = "RTL8723B";
+	else if (pDM_Odm->SupportICType == ODM_RTL8814A)
+		ICType = "RTL8814A";
+	else if (pDM_Odm->SupportICType == ODM_RTL8881A)
+		ICType = "RTL8881A";
+	else if (pDM_Odm->SupportICType == ODM_RTL8821B)
+		ICType = "RTL8821B";
+	else if (pDM_Odm->SupportICType == ODM_RTL8822B)
+		ICType = "RTL8822B";
+#if (RTL8703B_SUPPORT == 1)
+	else if (pDM_Odm->SupportICType == ODM_RTL8703B) {
+		ICType = "RTL8703B";
+		date = RELEASE_DATE_8703B;
+		commit_by = COMMIT_BY_8703B;
+		release_ver = RELEASE_VERSION_8703B;
+	} 
+#endif
+	else if (pDM_Odm->SupportICType == ODM_RTL8195A)
+		ICType = "RTL8195A";
+	else if (pDM_Odm->SupportICType == ODM_RTL8188F)
+		ICType = "RTL8188F";
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s (MP Chip: %s)\n", "IC Type", ICType, pDM_Odm->bIsMPChip ? "Yes" : "No"));
+
+	if (pDM_Odm->CutVersion == ODM_CUT_A)			
+		Cut = "A";
+	else if (pDM_Odm->CutVersion == ODM_CUT_B)            
+		Cut = "B";
+	else if (pDM_Odm->CutVersion == ODM_CUT_C)            
+		Cut = "C";
+	else if (pDM_Odm->CutVersion == ODM_CUT_D)            
+		Cut = "D";
+	else if (pDM_Odm->CutVersion == ODM_CUT_E)            
+		Cut = "E";
+	else if (pDM_Odm->CutVersion == ODM_CUT_F)            
+		Cut = "F";
+	else if (pDM_Odm->CutVersion == ODM_CUT_I)            
+		Cut = "I";
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Cut Version", Cut));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %d\n", "PHY Parameter Version", ODM_GetHWImgVersion(pDM_Odm)));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %d\n", "PHY Parameter Commit date", date));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "PHY Parameter Commit by", commit_by));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %d\n", "PHY Parameter Release Version", release_ver));
+	
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	{
+		PADAPTER		       Adapter = pDM_Odm->Adapter;
+		PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %d (Subversion: %d)\n", "FW Version", Adapter->MgntInfo.FirmwareVersion, Adapter->MgntInfo.FirmwareSubVersion));
+	}
+#elif (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	{
+		struct rtl8192cd_priv *priv = pDM_Odm->priv;
+		PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %d (Subversion: %d)\n", "FW Version", priv->pshare->fw_version, priv->pshare->fw_sub_version));
+	}
+#else
+	{
+		PADAPTER		       Adapter = pDM_Odm->Adapter;
+		HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+		PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %d (Subversion: %d)\n", "FW Version", pHalData->FirmwareVersion, pHalData->FirmwareSubVersion));
+	}
+#endif
+	//1 PHY DM Version List
+	PHYDM_SNPRINTF((output + used, out_len - used, "%-35s\n", "% PHYDM Version %"));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Adaptivity", ADAPTIVITY_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "DIG", DIG_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Dynamic BB PowerSaving", DYNAMIC_BBPWRSAV_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "CFO Tracking", CFO_TRACKING_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Antenna Diversity", ANTDIV_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Power Tracking", POWRTRACKING_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Dynamic TxPower", DYNAMIC_TXPWR_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "RA Info", RAINFO_VERSION));
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Antenna Detection", ANTDECT_VERSION));
+#endif
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Auto Channel Selection", ACS_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "EDCA Turbo", EDCATURBO_VERSION));
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "Path Diversity", PATHDIV_VERSION));
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "RxHP", RXHP_VERSION));
+#endif
+#if (RTL8822B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s: %s\n", "PHY config 8822B", PHY_CONFIG_VERSION_8822B));
+	
+#endif
+	*_used = used;
+	*_out_len = out_len;
+
+}
+
+VOID
+phydm_fw_trace_en_h2c(
+	IN	PVOID	pDM_VOID,
+	IN	BOOLEAN		enable,
+	IN	u4Byte		monitor_mode,
+	IN	u4Byte		macid
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte			H2C_Parameter[3] = {0};
+
+	H2C_Parameter[0] = enable;
+	H2C_Parameter[1] = (u1Byte)monitor_mode;
+	H2C_Parameter[2] = (u1Byte)macid;
+	ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("---->\n"));
+	if (monitor_mode == 0){
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[H2C] FW_debug_en: (( %d ))\n", enable));
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[H2C] FW_debug_en: (( %d )), mode: (( %d )), macid: (( %d ))\n", enable, monitor_mode, macid));
+	}
+	ODM_FillH2CCmd(pDM_Odm, PHYDM_H2C_FW_TRACE_EN, 3, H2C_Parameter);
+}
+
+VOID
+phydm_get_per_path_txagc(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			path,
+	IN		u4Byte			*_used,
+	OUT		char				*output,
+	IN		u4Byte			*_out_len
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			rate_idx;
+	u1Byte			txagc;
+	u4Byte			used = *_used;
+	u4Byte			out_len = *_out_len;
+
+#if (RTL8822B_SUPPORT == 1)
+	if ((pDM_Odm->SupportICType & ODM_RTL8822B) && (path <= ODM_RF_PATH_B)) {
+		for (rate_idx = 0; rate_idx <= 0x53; rate_idx++) {
+			if (rate_idx == ODM_RATE1M)
+				PHYDM_SNPRINTF((output + used, out_len - used, "  %-35s\n", "CCK====>"));
+			else if (rate_idx == ODM_RATE6M)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "OFDM====>"));
+			else if (rate_idx == ODM_RATEMCS0)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "HT 1ss====>"));
+			else if (rate_idx == ODM_RATEMCS8)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "HT 2ss====>"));
+			else if (rate_idx == ODM_RATEMCS16)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "HT 3ss====>"));
+			else if (rate_idx == ODM_RATEMCS24)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "HT 4ss====>"));
+			else if (rate_idx == ODM_RATEVHTSS1MCS0)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "VHT 1ss====>"));
+			else if (rate_idx == ODM_RATEVHTSS2MCS0)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "VHT 2ss====>"));
+			else if (rate_idx == ODM_RATEVHTSS3MCS0)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "VHT 3ss====>"));
+			else if (rate_idx == ODM_RATEVHTSS4MCS0)
+				PHYDM_SNPRINTF((output + used, out_len - used, "\n  %-35s\n", "VHT 4ss====>"));
+			
+			txagc = config_phydm_read_txagc_8822b(pDM_Odm, path, rate_idx);
+			if (config_phydm_read_txagc_check_8822b(txagc))
+				PHYDM_SNPRINTF((output + used, out_len - used, "  0x%02x    ", txagc));
+			else
+				PHYDM_SNPRINTF((output + used, out_len - used, "  0x%s    ", "xx"));
+		}
+	}
+#endif
+}
+
+
+VOID
+phydm_get_txagc(
+	IN		PVOID			pDM_VOID,
+	IN		u4Byte			*_used,
+	OUT		char				*output,
+	IN		u4Byte			*_out_len
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			used = *_used;
+	u4Byte			out_len = *_out_len;
+	
+	/* Path-A */
+	PHYDM_SNPRINTF((output + used, out_len - used, "%-35s\n", "Path-A===================="));
+	phydm_get_per_path_txagc(pDM_Odm, ODM_RF_PATH_A, _used, output, _out_len);
+	
+	/* Path-B */
+	PHYDM_SNPRINTF((output + used, out_len - used, "\n%-35s\n", "Path-B===================="));
+	phydm_get_per_path_txagc(pDM_Odm, ODM_RF_PATH_B, _used, output, _out_len);
+
+	/* Path-C */
+	PHYDM_SNPRINTF((output + used, out_len - used, "\n%-35s\n", "Path-C===================="));
+	phydm_get_per_path_txagc(pDM_Odm, ODM_RF_PATH_C, _used, output, _out_len);
+
+	/* Path-D */
+	PHYDM_SNPRINTF((output + used, out_len - used, "\n%-35s\n", "Path-D===================="));
+	phydm_get_per_path_txagc(pDM_Odm, ODM_RF_PATH_D, _used, output, _out_len);
+
+}
+
+VOID
+phydm_set_txagc(
+	IN		PVOID			pDM_VOID,
+	IN		u4Byte			*const dm_value,
+	IN		u4Byte			*_used,
+	OUT		char				*output,
+	IN		u4Byte			*_out_len
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			used = *_used;
+	u4Byte			out_len = *_out_len;
+
+#if (RTL8822B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType & ODM_RTL8822B) {
+		if (dm_value[0] <= 1) {
+			if (phydm_write_txagc_1byte_8822b(pDM_Odm, dm_value[2], dm_value[0], (u1Byte)dm_value[1]))
+				PHYDM_SNPRINTF((output + used, out_len - used, "  %s%d   %s%x%s%x\n", "Write path-", dm_value[0], "rate index-0x", dm_value[1], " = 0x", dm_value[2]));
+			else
+				PHYDM_SNPRINTF((output + used, out_len - used, "  %s%d   %s%x%s\n", "Write path-", (dm_value[0] & 0x1), "rate index-0x", (dm_value[1] & 0x7f), " fail"));
+		} else {
+			PHYDM_SNPRINTF((output + used, out_len - used, "  %s%d   %s%x%s\n", "Write path-", (dm_value[0] & 0x1), "rate index-0x", (dm_value[1] & 0x7f), " fail"));
+		}
+	}
+#endif
+}
+
+VOID
+odm_debug_trace(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte		*_used,
+	OUT		char		*output,
+	IN		u4Byte		*_out_len
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u8Byte			pre_debug_components, one = 1;
+	u4Byte used = *_used;
+	u4Byte out_len = *_out_len;
+
+	pre_debug_components = pDM_Odm->DebugComponents;
+
+	PHYDM_SNPRINTF((output + used, out_len - used, "\n%s\n", "================================"));
+	if (dm_value[0] == 100) {
+		PHYDM_SNPRINTF((output + used, out_len - used, "%s\n", "[Debug Message] PhyDM Selection"));
+		PHYDM_SNPRINTF((output + used, out_len - used, "%s\n", "================================"));
+		PHYDM_SNPRINTF((output + used, out_len - used, "00. (( %s ))DIG\n", ((pDM_Odm->DebugComponents & ODM_COMP_DIG) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "01. (( %s ))RA_MASK\n", ((pDM_Odm->DebugComponents & ODM_COMP_RA_MASK) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "02. (( %s ))DYNAMIC_TXPWR\n", ((pDM_Odm->DebugComponents & ODM_COMP_DYNAMIC_TXPWR) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "03. (( %s ))FA_CNT\n", ((pDM_Odm->DebugComponents & ODM_COMP_FA_CNT) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "04. (( %s ))RSSI_MONITOR\n", ((pDM_Odm->DebugComponents & ODM_COMP_RSSI_MONITOR) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "05. (( %s ))CCK_PD\n", ((pDM_Odm->DebugComponents & ODM_COMP_CCK_PD) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "06. (( %s ))ANT_DIV\n", ((pDM_Odm->DebugComponents & ODM_COMP_ANT_DIV) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "07. (( %s ))PWR_SAVE\n", ((pDM_Odm->DebugComponents & ODM_COMP_PWR_SAVE) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "08. (( %s ))PWR_TRAIN\n", ((pDM_Odm->DebugComponents & ODM_COMP_PWR_TRAIN) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "09. (( %s ))RATE_ADAPTIVE\n", ((pDM_Odm->DebugComponents & ODM_COMP_RATE_ADAPTIVE) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "10. (( %s ))PATH_DIV\n", ((pDM_Odm->DebugComponents & ODM_COMP_PATH_DIV) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "11. (( %s ))PSD\n", ((pDM_Odm->DebugComponents & ODM_COMP_PSD) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "12. (( %s ))DYNAMIC_PRICCA\n", ((pDM_Odm->DebugComponents & ODM_COMP_DYNAMIC_PRICCA) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "13. (( %s ))RXHP\n", ((pDM_Odm->DebugComponents & ODM_COMP_RXHP) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "14. (( %s ))MP\n", ((pDM_Odm->DebugComponents & ODM_COMP_MP) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "15. (( %s ))CFO_TRACKING\n", ((pDM_Odm->DebugComponents & ODM_COMP_CFO_TRACKING) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "16. (( %s ))ACS\n", ((pDM_Odm->DebugComponents & ODM_COMP_ACS) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "17. (( %s ))ADAPTIVITY\n", ((pDM_Odm->DebugComponents & PHYDM_COMP_ADAPTIVITY) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "18. (( %s ))RA_DBG\n", ((pDM_Odm->DebugComponents & PHYDM_COMP_RA_DBG) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "20. (( %s ))EDCA_TURBO\n", ((pDM_Odm->DebugComponents & ODM_COMP_EDCA_TURBO) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "21. (( %s ))EARLY_MODE\n", ((pDM_Odm->DebugComponents & ODM_COMP_EARLY_MODE) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "22. (( %s ))FW_DEBUG_TRACE\n", ((pDM_Odm->DebugComponents & ODM_FW_DEBUG_TRACE) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "24. (( %s ))TX_PWR_TRACK\n", ((pDM_Odm->DebugComponents & ODM_COMP_TX_PWR_TRACK) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "25. (( %s ))RX_GAIN_TRACK\n", ((pDM_Odm->DebugComponents & ODM_COMP_RX_GAIN_TRACK) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "26. (( %s ))CALIBRATION\n", ((pDM_Odm->DebugComponents & ODM_COMP_CALIBRATION) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "28. (( %s ))PHY_CONFIG\n", ((pDM_Odm->DebugComponents & ODM_PHY_CONFIG) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "29. (( %s ))BEAMFORMING_DEBUG\n", ((pDM_Odm->DebugComponents & BEAMFORMING_DEBUG) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "30. (( %s ))COMMON\n", ((pDM_Odm->DebugComponents & ODM_COMP_COMMON) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "31. (( %s ))INIT\n", ((pDM_Odm->DebugComponents & ODM_COMP_INIT) ? ("V") : ("."))));
+		PHYDM_SNPRINTF((output + used, out_len - used, "%s\n", "================================"));
+
+	} else if (dm_value[0] == 101) {
+		pDM_Odm->DebugComponents = 0;
+		PHYDM_SNPRINTF((output + used, out_len - used, "%s\n", "Disable all debug components"));
+	} else {
+		if (dm_value[1] == 1) { /*enable*/
+			pDM_Odm->DebugComponents |= (one << dm_value[0]);
+
+			if (dm_value[0] == 22) { /*FW trace function*/
+				phydm_fw_trace_en_h2c(pDM_Odm, 1, dm_value[2], dm_value[3]); /*H2C to enable C2H Msg*/
+			}
+		} else if (dm_value[1] == 2) { /*disable*/
+			pDM_Odm->DebugComponents &= ~(one << dm_value[0]);
+
+			if (dm_value[0] == 22) { /*FW trace function*/
+				phydm_fw_trace_en_h2c(pDM_Odm, 0, dm_value[2], dm_value[3]); /*H2C to disable C2H Msg*/
+			}
+		} else
+			PHYDM_SNPRINTF((output + used, out_len - used, "%s\n", "[Warning!!!]  1:enable,  2:disable"));
+	}
+	PHYDM_SNPRINTF((output + used, out_len - used, "pre-DbgComponents = 0x%x\n", (u4Byte)pre_debug_components));
+	PHYDM_SNPRINTF((output + used, out_len - used, "Curr-DbgComponents = 0x%x\n", ((u4Byte)pDM_Odm->DebugComponents)));
+	PHYDM_SNPRINTF((output + used, out_len - used, "%s\n", "================================"));
+}
+
+VOID
+phydm_DumpBbReg(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			Addr = 0;
+	
+	/* BB Reg */
+	for (Addr = 0x800; Addr < 0xfff; Addr += 4)
+		DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8822B|ODM_RTL8814A)) {
+
+		if (pDM_Odm->RFType > ODM_2T2R) {
+			for (Addr = 0x1800; Addr < 0x18ff; Addr += 4)
+				DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+		}
+
+		if (pDM_Odm->RFType > ODM_3T3R) {
+			for (Addr = 0x1a00; Addr < 0x1aff; Addr += 4)
+				DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+		}
+
+		for (Addr = 0x1900; Addr < 0x19ff; Addr += 4)
+			DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+
+		for (Addr = 0x1c00; Addr < 0x1cff; Addr += 4)
+			DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+
+		for (Addr = 0x1f00; Addr < 0x1fff; Addr += 4)
+			DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+	}
+}
+
+VOID
+phydm_DumpAllReg(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			Addr = 0;
+
+	/* dump MAC register */
+	DbgPrint("MAC==========\n");
+	for (Addr = 0; Addr < 0x7ff; Addr += 4)
+		DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+
+	for (Addr = 1000; Addr < 0x17ff; Addr += 4)
+		DbgPrint("%04x %08x\n", Addr, ODM_GetBBReg(pDM_Odm, Addr, bMaskDWord));
+
+	/* dump BB register */
+	DbgPrint("BB==========\n");
+	phydm_DumpBbReg(pDM_Odm);
+
+	/* dump RF register */
+	DbgPrint("RF-A==========\n");
+	for (Addr = 0; Addr < 0xFF; Addr++)
+		DbgPrint("%02x %05x\n", Addr, ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, Addr, bRFRegOffsetMask));
+
+	if (pDM_Odm->RFType > ODM_1T1R) {
+		DbgPrint("RF-B==========\n");
+		for (Addr = 0; Addr < 0xFF; Addr++)
+			DbgPrint("%02x %05x\n", Addr, ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, Addr, bRFRegOffsetMask));
+	}
+
+	if (pDM_Odm->RFType > ODM_2T2R) {
+		DbgPrint("RF-C==========\n");
+		for (Addr = 0; Addr < 0xFF; Addr++)
+			DbgPrint("%02x %05x\n", Addr, ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_C, Addr, bRFRegOffsetMask));
+	}
+
+	if (pDM_Odm->RFType > ODM_3T3R) {
+		DbgPrint("RF-D==========\n");
+		for (Addr = 0; Addr < 0xFF; Addr++)
+			DbgPrint("%02x %05x\n", Addr, ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_D, Addr, bRFRegOffsetMask));
+	}
+}
+
+struct _PHYDM_COMMAND {
+	char name[16];
+	u1Byte id;
+};
+
+enum PHYDM_CMD_ID {
+	PHYDM_DEMO,
+	PHYDM_RA,
+	PHYDM_PROFILE,
+	PHYDM_PATHDIV,
+	PHYDM_DEBUG,
+	PHYDM_SUPPORT_ABILITY,
+	PHYDM_GET_TXAGC,
+	PHYDM_SET_TXAGC,
+	PHYDM_SMART_ANT,
+	PHYDM_API,
+	PHYDM_TRX_PATH,
+	PHYDM_LA_MODE,
+	PHYDM_DUMP_REG
+};
+
+struct _PHYDM_COMMAND phy_dm_ary[] = {
+	{"demo", PHYDM_DEMO},
+	{"ra", PHYDM_RA},
+	{"profile", PHYDM_PROFILE},
+	{"pathdiv", PHYDM_PATHDIV},
+	{"dbg", PHYDM_DEBUG},
+	{"ability", PHYDM_SUPPORT_ABILITY},
+	{"get_txagc", PHYDM_GET_TXAGC},
+	{"set_txagc", PHYDM_SET_TXAGC},
+	{"smtant", PHYDM_SMART_ANT},
+	{"api", PHYDM_API},
+	{"trxpath", PHYDM_TRX_PATH},
+	{"lamode", PHYDM_LA_MODE},
+	{"dumpreg", PHYDM_DUMP_REG}
+};
+
+VOID
+phydm_cmd_parser(
+	IN PDM_ODM_T	pDM_Odm,
+	IN char		input[][MAX_ARGV],
+	IN u4Byte	input_num,
+	IN u1Byte	flag,
+	OUT char	*output,
+	IN u4Byte	out_len
+)
+{
+	u4Byte used = 0;
+	u1Byte id = 0;
+	int var1[5] = {0};
+	int i, input_idx = 0;
+
+	if (flag == 0) {
+		PHYDM_SNPRINTF((output + used, out_len - used, "GET, nothing to print\n"));
+		return;
+	}
+
+	PHYDM_SNPRINTF((output + used, out_len - used, "\n"));
+
+	//Parsing Cmd ID
+	if (input_num) {
+		int n, i;
+
+		n = sizeof(phy_dm_ary) / sizeof(struct _PHYDM_COMMAND);
+		for (i = 0; i < n; i++) {
+			if (strcmp(phy_dm_ary[i].name, input[0]) == 0) {
+				id = phy_dm_ary[i].id;
+				break;
+			}
+		}
+		if (i == n) {
+			PHYDM_SNPRINTF((output + used, out_len - used, "SET, command not found!\n"));
+			return;
+		}
+	}
+
+	switch (id) {
+	case PHYDM_DEMO: /*echo demo 10 0x3a z abcde >cmd*/
+			{
+				u4Byte   directory = 0;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_AP))				
+				char   char_temp;
+#else
+				u4Byte char_temp = ' ';
+#endif
+		PHYDM_SSCANF(input[1], DCMD_DECIMAL, &directory);
+		PHYDM_SNPRINTF((output + used, out_len - used, "Decimal Value = %d\n", directory));
+		PHYDM_SSCANF(input[2], DCMD_HEX, &directory);
+		PHYDM_SNPRINTF((output + used, out_len - used, "Hex Value = 0x%x\n", directory));
+		PHYDM_SSCANF(input[3], DCMD_CHAR, &char_temp);
+		PHYDM_SNPRINTF((output + used, out_len - used, "Char = %c\n", char_temp));
+		PHYDM_SNPRINTF((output + used, out_len - used, "String = %s\n", input[4]));
+	}
+	break;
+
+	case PHYDM_RA:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+
+				PHYDM_SNPRINTF((output + used, out_len - used, "new SET, RA_var[%d]= (( %d ))\n", i , var1[i]));
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			/*PHYDM_SNPRINTF((output+used, out_len-used, "odm_RA_debug\n"));*/
+#if (defined(CONFIG_RA_DBG_CMD))
+			odm_RA_debug((PVOID)pDM_Odm, var1);
+#endif
+		}
+
+
+		break;
+
+	case PHYDM_PATHDIV:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+
+				/*PHYDM_SNPRINTF((output+used, out_len-used, "new SET, PATHDIV_var[%d]= (( %d ))\n", i , var1[i]));*/
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			/*PHYDM_SNPRINTF((output+used, out_len-used, "odm_PATHDIV_debug\n"));*/
+#if (defined(CONFIG_PATH_DIVERSITY))
+			odm_pathdiv_debug(pDM_Odm, (u4Byte *)var1, &used, output, &out_len);
+#endif
+		}
+
+		break;
+
+	case PHYDM_DEBUG:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+
+				/*PHYDM_SNPRINTF((output+used, out_len-used, "new SET, Debug_var[%d]= (( %d ))\n", i , var1[i]));*/
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			/*PHYDM_SNPRINTF((output+used, out_len-used, "odm_debug_comp\n"));*/
+			odm_debug_trace(pDM_Odm, (u4Byte *)var1, &used, output, &out_len);
+		}
+
+
+		break;
+
+	case PHYDM_SUPPORT_ABILITY:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+
+				/*PHYDM_SNPRINTF((output+used, out_len-used, "new SET, support ablity_var[%d]= (( %d ))\n", i , var1[i]));*/
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			/*PHYDM_SNPRINTF((output+used, out_len-used, "support ablity\n"));*/
+			phydm_support_ablity_debug(pDM_Odm, (u4Byte *)var1, &used, output, &out_len);
+		}
+
+		break;
+		
+	case PHYDM_SMART_ANT:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+			#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
+			phydm_hl_smart_ant_cmd(pDM_Odm, (u4Byte *)var1, &used, output, &out_len);
+			#endif
+			#endif
+		}
+
+		break;
+
+	case PHYDM_API:
+#if (RTL8822B_SUPPORT == 1)
+	{
+		if (pDM_Odm->SupportICType & ODM_RTL8822B) {
+			BOOLEAN	bEnableDbgMode;
+			u1Byte central_ch, primary_ch_idx, bandwidth;
+			
+			for (i = 0; i < 4; i++) {
+				if (input[i + 1])
+					PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+			}
+			
+			bEnableDbgMode = (BOOLEAN)var1[0];
+			central_ch = (u1Byte) var1[1];
+			primary_ch_idx = (u1Byte) var1[2];
+			bandwidth = (ODM_BW_E) var1[3];
+
+			if (bEnableDbgMode) {
+				pDM_Odm->bDisablePhyApi = FALSE;
+			config_phydm_switch_channel_bw_8822b(pDM_Odm, central_ch, primary_ch_idx, bandwidth);
+				pDM_Odm->bDisablePhyApi = TRUE;
+			PHYDM_SNPRINTF((output+used, out_len-used, "central_ch = %d, primary_ch_idx = %d, bandwidth = %d\n", central_ch, primary_ch_idx, bandwidth));
+			} else {
+				pDM_Odm->bDisablePhyApi = FALSE;
+				PHYDM_SNPRINTF((output+used, out_len-used, "Disable API debug mode\n"));
+			}
+		} else
+			PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support PHYDM API function\n"));
+	}
+#else
+		PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support PHYDM API function\n"));
+#endif
+		break;	
+		
+	case PHYDM_PROFILE: /*echo profile, >cmd*/
+		phydm_BasicProfile(pDM_Odm, &used, output, &out_len);
+		break;
+
+	case PHYDM_GET_TXAGC:
+		phydm_get_txagc(pDM_Odm, &used, output, &out_len);
+		break;
+		
+	case PHYDM_SET_TXAGC:
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+
+				/*PHYDM_SNPRINTF((output+used, out_len-used, "new SET, support ablity_var[%d]= (( %d ))\n", i , var1[i]));*/
+				input_idx++;
+			}
+		}
+		
+		phydm_set_txagc(pDM_Odm, (u4Byte *)var1, &used, output, &out_len);
+		break;
+		
+	case PHYDM_TRX_PATH:
+#if (RTL8822B_SUPPORT == 1)
+	{
+		if (pDM_Odm->SupportICType & ODM_RTL8822B) {
+			u1Byte		TxPath, RxPath;
+			BOOLEAN		bEnableDbgMode, bTx2Path;
+			
+			for (i = 0; i < 4; i++) {
+				if (input[i + 1])
+					PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+			}
+
+			bEnableDbgMode = (BOOLEAN)var1[0];
+			TxPath = (u1Byte) var1[1];
+			RxPath = (u1Byte) var1[2];
+			bTx2Path = (BOOLEAN) var1[3];
+
+			if (bEnableDbgMode) {
+				pDM_Odm->bDisablePhyApi = FALSE;
+				config_phydm_trx_mode_8822b(pDM_Odm, TxPath, RxPath, bTx2Path);
+				pDM_Odm->bDisablePhyApi = TRUE;
+				PHYDM_SNPRINTF((output+used, out_len-used, "TxPath = 0x%x, RxPath = 0x%x, bTx2Path = %d\n", TxPath, RxPath, bTx2Path));
+			} else {
+				pDM_Odm->bDisablePhyApi = FALSE;
+				PHYDM_SNPRINTF((output+used, out_len-used, "Disable API debug mode\n"));
+			}
+		} else
+			PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support PHYDM API function\n"));
+	}
+#else
+		PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support PHYDM API function\n"));
+#endif
+		break;
+
+	case PHYDM_LA_MODE:
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if ((RTL8822B_SUPPORT == 1) || (RTL8814A_SUPPORT == 1))
+	{
+		if (pDM_Odm->SupportICType & (ODM_RTL8814A | ODM_RTL8822B)) {
+			u2Byte		PollingTime;
+			u1Byte		TrigSel, TrigSigSel, DmaDataSigSel, TriggerTime;
+			BOOLEAN		bEnableLaMode;
+
+			for (i = 0; i < 6; i++) {
+				if (input[i + 1])
+					PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL, &var1[i]);
+			}
+
+			bEnableLaMode = (BOOLEAN)var1[0];
+			if (bEnableLaMode) {
+				TrigSel = (u1Byte)var1[1];
+				TrigSigSel = (u1Byte)var1[2];
+				DmaDataSigSel = (u1Byte)var1[3];
+				TriggerTime = (u1Byte)var1[4];
+				PollingTime = (((u1Byte)var1[5]) << 6);
+
+				ADCSmp_Set(pDM_Odm->Adapter, TrigSel, TrigSigSel, DmaDataSigSel, TriggerTime, PollingTime);
+				PHYDM_SNPRINTF((output+used, out_len-used, "TrigSel = %d, TrigSigSel = %d, DmaDataSigSel = %d\n", TrigSel, TrigSigSel, DmaDataSigSel));
+				PHYDM_SNPRINTF((output+used, out_len-used, "TriggerTime = %d, PollingTime = %d\n", TriggerTime, PollingTime));
+			} else {
+				ADCSmp_Stop(pDM_Odm->Adapter);
+				PHYDM_SNPRINTF((output+used, out_len-used, "Disable LA mode\n"));
+			}
+		} else
+			PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support LA mode\n"));
+	}
+#else
+		PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support LA mode\n"));
+#endif
+#else
+		PHYDM_SNPRINTF((output+used, out_len-used, "This IC doesn't support LA mode\n"));
+#endif
+		break;
+
+	case PHYDM_DUMP_REG:
+	{
+		u1Byte	type = 0;
+		
+		if (input[1]) {
+			PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+			type = (u1Byte)var1[0];
+		}
+
+		if (type == 0)
+			phydm_DumpBbReg(pDM_Odm);
+		else if (type == 1)
+			phydm_DumpAllReg(pDM_Odm);
+	}
+		break;
+	default:
+		PHYDM_SNPRINTF((output + used, out_len - used, "SET, unknown command!\n"));
+		break;
+
+	}
+}
+
+#ifdef __ECOS
+char *strsep(char **s, const char *ct)
+{
+	char *sbegin = *s;
+	char *end;
+
+	if (sbegin == NULL)
+		return NULL;
+
+	end = strpbrk(sbegin, ct);
+	if (end)
+		*end++ = '\0';
+	*s = end;
+	return sbegin;
+}
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_AP))
+s4Byte
+phydm_cmd(
+	IN PDM_ODM_T	pDM_Odm,
+	IN char		*input,
+	IN u4Byte	in_len,
+	IN u1Byte	flag,
+	OUT char	*output,
+	IN u4Byte	out_len
+)
+{
+	char *token;
+	u4Byte	Argc = 0;
+	char		Argv[MAX_ARGC][MAX_ARGV];
+
+	do {
+		token = strsep(&input, ", ");
+		if (token) {
+			strcpy(Argv[Argc], token);
+			Argc++;
+		} else
+			break;
+	} while (Argc < MAX_ARGC);
+
+	if (Argc == 1)
+		Argv[0][strlen(Argv[0]) - 1] = '\0';
+
+	phydm_cmd_parser(pDM_Odm, Argv, Argc, flag, output, out_len);
+
+	return 0;
+}
+#endif
+
+
+VOID
+phydm_fw_trace_handler(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte	CmdBuf,
+	IN	u1Byte	CmdLen
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	/*u1Byte	debug_trace_11byte[60];*/
+	u1Byte		freg_num, c2h_seq, buf_0 = 0;
+
+	if (CmdLen > 12)
+		return;
+
+	buf_0 = CmdBuf[0];
+	freg_num = (buf_0 & 0xf);
+	c2h_seq = (buf_0 & 0xf0) >> 4;
+	/*ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW debug message] freg_num = (( %d )), c2h_seq = (( %d ))\n", freg_num,c2h_seq ));*/
+
+	/*strncpy(debug_trace_11byte,&CmdBuf[1],(CmdLen-1));*/
+	/*debug_trace_11byte[CmdLen-1] = '\0';*/
+	/*ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW debug message] %s\n", debug_trace_11byte));*/
+	/*ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW debug message] CmdLen = (( %d ))\n", CmdLen));*/
+	/*ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW debug message] c2h_cmd_start  = (( %d ))\n", pDM_Odm->c2h_cmd_start));*/
+
+
+
+	/*ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("pre_seq = (( %d )), current_seq = (( %d ))\n", pDM_Odm->pre_c2h_seq, c2h_seq));*/
+	/*ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("fw_buff_is_enpty = (( %d ))\n", pDM_Odm->fw_buff_is_enpty));*/
+
+	if ((c2h_seq != pDM_Odm->pre_c2h_seq)  &&  pDM_Odm->fw_buff_is_enpty == FALSE) {
+		pDM_Odm->fw_debug_trace[pDM_Odm->c2h_cmd_start] = '\0';
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW Dbg Queue Overflow] %s\n", pDM_Odm->fw_debug_trace));
+		pDM_Odm->c2h_cmd_start = 0;
+	}
+
+	if ((CmdLen - 1) > (60 - pDM_Odm->c2h_cmd_start)) {
+		pDM_Odm->fw_debug_trace[pDM_Odm->c2h_cmd_start] = '\0';
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW Dbg Queue error: wrong C2H length] %s\n", pDM_Odm->fw_debug_trace));
+		pDM_Odm->c2h_cmd_start = 0;
+		return;
+	}
+
+	strncpy((char *)&(pDM_Odm->fw_debug_trace[pDM_Odm->c2h_cmd_start]), (char *)&CmdBuf[1], (CmdLen-1));
+	pDM_Odm->c2h_cmd_start += (CmdLen - 1);
+	pDM_Odm->fw_buff_is_enpty = FALSE;	
+	
+	if (freg_num == 0 || pDM_Odm->c2h_cmd_start >= 60) {
+		if (pDM_Odm->c2h_cmd_start < 60)
+			pDM_Odm->fw_debug_trace[pDM_Odm->c2h_cmd_start] = '\0';
+		else
+			pDM_Odm->fw_debug_trace[59] = '\0';
+
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW DBG Msg] %s\n", pDM_Odm->fw_debug_trace));
+		/*DbgPrint("[FW DBG Msg] %s\n", pDM_Odm->fw_debug_trace);*/
+		pDM_Odm->c2h_cmd_start = 0;
+		pDM_Odm->fw_buff_is_enpty = TRUE;
+	}
+
+	pDM_Odm->pre_c2h_seq = c2h_seq;
+}
+
+VOID
+phydm_fw_trace_handler_code(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte	Buffer,
+	IN	u1Byte	CmdLen
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	function = Buffer[0];
+	u1Byte	dbg_num = Buffer[1];
+	u2Byte	content_0 = (((u2Byte)Buffer[3])<<8)|((u2Byte)Buffer[2]);
+	u2Byte	content_1 = (((u2Byte)Buffer[5])<<8)|((u2Byte)Buffer[4]);		
+	u2Byte	content_2 = (((u2Byte)Buffer[7])<<8)|((u2Byte)Buffer[6]);	
+	u2Byte	content_3 = (((u2Byte)Buffer[9])<<8)|((u2Byte)Buffer[8]);
+	u2Byte	content_4 = (((u2Byte)Buffer[11])<<8)|((u2Byte)Buffer[10]);
+
+	if(CmdLen >12) {
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW Msg] Invalid cmd length (( %d )) >12 \n", CmdLen));
+	}
+	
+	//ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW Msg] Func=((%d)),  num=((%d)), ct_0=((%d)), ct_1=((%d)), ct_2=((%d)), ct_3=((%d)), ct_4=((%d))\n", 
+	//	function, dbg_num, content_0, content_1, content_2, content_3, content_4));
+	
+	/*--------------------------------------------*/
+	if(function == RATE_DECISION) {
+		if(dbg_num == 0) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin] RA_CNT=((%d))  Max_device=((%d))--------------------------->\n", content_1, content_2));
+			} else if(content_0 == 2) {
+				 ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin] Check RA macid= ((%d)), MediaStatus=((%d)), Dis_RA=((%d)),  try_bit=((0x%x))\n", content_1, content_2, content_3, content_4));
+			} else if(content_0 == 3) {
+				 ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDecisoin] Check RA  total=((%d)),  drop=((0x%x)), TXRPT_TRY_bit=((%x)), bNoisy=((%x))\n", content_1, content_2, content_3, content_4));
+			}
+		} else if(dbg_num == 1) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin] RTY[0,1,2,3]=[ %d,  %d,  %d,  %d ] \n", content_1, content_2, content_3, content_4));
+			} else if(content_0 == 2) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin] RTY[4]=[ %d ], drop=((%d)), total=((%d)),  current_rate=((0x%x))\n", content_1, content_2, content_3, content_4));
+			} else if(content_0 == 3) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin] penality_idx=((%d ))\n", content_1));
+			}
+		}
+		
+		else if(dbg_num == 3) {
+			if (content_0 == 1)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDecisoin] Fast_RA (( DOWN ))  total=((%d)),  total>>1=((%d)), R4+R3+R2 = ((%d)), RateDownHold = ((%d))\n", content_1, content_2, content_3, content_4));
+			else if (content_0 == 2)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDecisoin] Fast_RA (( UP ))  total_acc=((%d)),  total_acc>>1=((%d)), R4+R3+R2 = ((%d)), RateDownHold = ((%d))\n", content_1, content_2, content_3, content_4));
+			else if (content_0 == 3)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDecisoin] Fast_RA (( UP )) ((Rate Down Hold))  RA_CNT=((%d))\n", content_1));
+			else if (content_0 == 4)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDecisoin] Fast_RA (( UP )) ((tota_accl<5 skip))  RA_CNT=((%d))\n", content_1));
+			else if (content_0 == 8)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDecisoin] Fast_RA (( Reset Tx Rpt )) RA_CNT=((%d))\n", content_1));
+		}
+		
+		else if(dbg_num == 5) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin]  (( UP))  Nsc=((%d)), N_High=((%d))\n", content_1, content_2));
+			} else if(content_0 == 2) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin]  ((DOWN))  Nsc=((%d)), N_Low=((%d))\n", content_1, content_2));
+			} else if(content_0 == 3) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin]  ((HOLD))  Nsc=((%d)), N_High=((%d)), N_Low=((%d)), Reset_CNT=((%d))\n", content_1, content_2, content_3, content_4));
+			}
+		}
+		else if(dbg_num == 0x60) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin]  ((AP RPT))  macid=((%d)), BUPDATE[macid]=((%d))\n", content_1, content_2));
+			} else if(content_0 == 4) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin]  ((AP RPT))  pass=((%d)), rty_num=((%d)), drop=((%d)), total=((%d))\n", content_1, content_2, content_3, content_4));
+			} else if(content_0 == 5) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("[FW][RateDecisoin]  ((AP RPT))  PASS=((%d)), RTY_NUM=((%d)), DROP=((%d)), TOTAL=((%d))\n", content_1, content_2, content_3, content_4));
+			}
+		}
+		else if(dbg_num == 0xff) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE,ODM_DBG_LOUD,("\n\n"));
+			} 
+		}
+		
+	} 
+	/*--------------------------------------------*/
+	else if (function == INIT_RA_TABLE){
+		if(dbg_num == 3) {
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][INIT_RA_INFO] Ra_init, RA_SKIP_CNT = (( %d ))\n", content_0));
+		}
+		
+	} 
+	/*--------------------------------------------*/
+	else if (function == RATE_UP) {
+		if(dbg_num == 2) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateUp]  ((Highest rate -> return)), macid=((%d))  Nsc=((%d))\n", content_1, content_2));
+			}
+		} else if(dbg_num == 5) {
+			if (content_0 == 0)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateUp]  ((Rate UP)), up_rate_tmp=((0x%x)), rate_idx=((0x%x)), SGI_en=((%d)),  SGI=((%d))\n", content_1, content_2, content_3, content_4));
+			else if (content_0 == 1)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateUp]  ((Rate UP)), rate_1=((0x%x)), rate_2=((0x%x)), BW=((%d)), Try_Bit=((%d))\n", content_1, content_2, content_3, content_4));
+		}
+		
+	} 
+	/*--------------------------------------------*/
+	else if (function == RATE_DOWN) {
+		 if(dbg_num == 5) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][RateDownStep]  ((Rate Down)), macid=((%d)),  rate=((0x%x)),  BW=((%d))\n", content_1, content_2, content_3));
+			}
+		}
+	} else if (function == TRY_DONE) {
+		if (dbg_num == 1) {
+			if (content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][Try Done]  ((try succsess )) macid=((%d)), Try_Done_cnt=((%d))\n", content_1, content_2));
+				/**/
+			}
+		} else if (dbg_num == 2) {
+			if (content_0 == 1)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][Try Done]  ((try fail )) macid=((%d)), Try_Done_cnt=((%d)),  multi_try_rate=((%d))\n", content_1, content_2, content_3));
+		}
+	}
+	/*--------------------------------------------*/
+	else if (function == F_RATE_AP_RPT) {
+		 if(dbg_num == 1) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][AP RPT]  ((1)), SPE_STATIS=((0x%x))---------->\n", content_3));				
+			} 
+		} else if(dbg_num == 2) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][AP RPT]  RTY_all=((%d))\n", content_1));				
+			} 
+		} else if(dbg_num == 3) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][AP RPT]  MACID1[%d], TOTAL=((%d)),  RTY=((%d))\n", content_3, content_1, content_2));
+			} 
+		} else if(dbg_num == 4) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][AP RPT]  MACID2[%d], TOTAL=((%d)),  RTY=((%d))\n", content_3, content_1, content_2));
+			} 
+		} else if(dbg_num == 5) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][AP RPT]  MACID1[%d], PASS=((%d)),  DROP=((%d))\n", content_3, content_1, content_2));
+			} 
+		} else if(dbg_num == 6) {
+			if(content_0 == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW][AP RPT]  MACID2[%d],, PASS=((%d)),  DROP=((%d))\n", content_3, content_1, content_2));
+			} 
+		}
+	}
+	/*--------------------------------------------*/
+		
+
+}
+
+VOID
+phydm_fw_trace_handler_8051(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte	Buffer,
+	IN	u1Byte	CmdLen
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if 0
+	if (CmdLen >= 3)
+		CmdBuf[CmdLen - 1] = '\0';
+	ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW DBG Msg] %s\n", &(CmdBuf[3])));
+#else
+
+	int i = 0;
+	u1Byte	Extend_c2hSubID = 0, Extend_c2hDbgLen = 0, Extend_c2hDbgSeq = 0;
+	u1Byte	fw_debug_trace[100];
+	pu1Byte	Extend_c2hDbgContent = 0;
+
+	Extend_c2hSubID = Buffer[0];
+	Extend_c2hDbgLen = Buffer[1];
+	Extend_c2hDbgContent = Buffer + 2; /*DbgSeq+DbgContent  for show HEX*/
+
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	RT_DISP(FC2H, C2H_Summary, ("[Extend C2H packet], Extend_c2hSubId=0x%x, Extend_c2hDbgLen=%d\n", 
+			Extend_c2hSubID, Extend_c2hDbgLen));
+	
+	RT_DISP_DATA(FC2H, C2H_Summary, "[Extend C2H packet], Content Hex:", Extend_c2hDbgContent, CmdLen-2);
+	#endif
+
+GoBackforAggreDbgPkt:
+	i = 0;
+	Extend_c2hDbgSeq = Buffer[2];
+	Extend_c2hDbgContent = Buffer + 3;
+	
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	RT_DISP(FC2H, C2H_Summary, ("[RTKFW, SEQ= %d] :", Extend_c2hDbgSeq));
+	#endif	
+
+	for (; ; i++) {
+		fw_debug_trace[i] = Extend_c2hDbgContent[i];
+		if (Extend_c2hDbgContent[i + 1] == '\0') {
+			fw_debug_trace[i + 1] = '\0';
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW DBG Msg] %s", &(fw_debug_trace[0])));
+			break;
+		} else if (Extend_c2hDbgContent[i] == '\n') {
+			fw_debug_trace[i + 1] = '\0';
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("[FW DBG Msg] %s", &(fw_debug_trace[0])));
+			Buffer = Extend_c2hDbgContent + i + 3;
+			goto GoBackforAggreDbgPkt;
+		}
+	}
+
+
+#endif
+}
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.h
new file mode 100644
index 000000000..60e84e424
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_debug.h
@@ -0,0 +1,330 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__ODM_DBG_H__
+#define __ODM_DBG_H__
+
+#define DEBUG_VERSION	"1.0"  /*2015.01.13 Dino*/
+//-----------------------------------------------------------------------------
+//	Define the debug levels
+//
+//	1.	DBG_TRACE and DBG_LOUD are used for normal cases.
+//	So that, they can help SW engineer to develope or trace states changed 
+//	and also help HW enginner to trace every operation to and from HW, 
+//	e.g IO, Tx, Rx. 
+//
+//	2.	DBG_WARNNING and DBG_SERIOUS are used for unusual or error cases, 
+//	which help us to debug SW or HW.
+//
+//-----------------------------------------------------------------------------
+//
+//	Never used in a call to ODM_RT_TRACE()!
+//
+#define ODM_DBG_OFF					1
+
+//
+//	Fatal bug. 
+//	For example, Tx/Rx/IO locked up, OS hangs, memory access violation, 
+//	resource allocation failed, unexpected HW behavior, HW BUG and so on.
+//
+#define ODM_DBG_SERIOUS				2
+
+//
+//	Abnormal, rare, or unexpeted cases.
+//	For example, IRP/Packet/OID canceled, device suprisely unremoved and so on.
+//
+#define ODM_DBG_WARNING				3
+
+//
+//	Normal case with useful information about current SW or HW state. 
+//	For example, Tx/Rx descriptor to fill, Tx/Rx descriptor completed status, 
+//	SW protocol state change, dynamic mechanism state change and so on.
+//
+#define ODM_DBG_LOUD					4
+
+//
+//	Normal case with detail execution flow or information.
+//
+#define ODM_DBG_TRACE					5
+
+/*FW DBG MSG*/
+#define	RATE_DECISION	BIT0
+#define	INIT_RA_TABLE	BIT1
+#define	RATE_UP			BIT2
+#define	RATE_DOWN		BIT3
+#define	TRY_DONE		BIT4
+#define	F_RATE_AP_RPT	BIT7
+
+//-----------------------------------------------------------------------------
+// Define the tracing components
+//
+//-----------------------------------------------------------------------------
+//BB Functions
+#define	ODM_COMP_DIG					BIT0	
+#define	ODM_COMP_RA_MASK				BIT1	
+#define	ODM_COMP_DYNAMIC_TXPWR		BIT2
+#define	ODM_COMP_FA_CNT				BIT3
+#define	ODM_COMP_RSSI_MONITOR		BIT4
+#define	ODM_COMP_CCK_PD				BIT5
+#define	ODM_COMP_ANT_DIV				BIT6
+#define	ODM_COMP_PWR_SAVE			BIT7
+#define	ODM_COMP_PWR_TRAIN			BIT8
+#define	ODM_COMP_RATE_ADAPTIVE		BIT9
+#define	ODM_COMP_PATH_DIV			BIT10
+#define	ODM_COMP_PSD					BIT11
+#define	ODM_COMP_DYNAMIC_PRICCA		BIT12
+#define	ODM_COMP_RXHP					BIT13
+#define	ODM_COMP_MP					BIT14
+#define	ODM_COMP_CFO_TRACKING		BIT15
+#define	ODM_COMP_ACS					BIT16
+#define	PHYDM_COMP_ADAPTIVITY		BIT17
+#define	PHYDM_COMP_RA_DBG			BIT18
+#define	PHYDM_COMP_TXBF				BIT19
+//MAC Functions
+#define	ODM_COMP_EDCA_TURBO			BIT20
+#define	ODM_COMP_EARLY_MODE			BIT21
+#define	ODM_FW_DEBUG_TRACE			BIT22
+//RF Functions
+#define	ODM_COMP_TX_PWR_TRACK		BIT24
+#define	ODM_COMP_RX_GAIN_TRACK		BIT25
+#define	ODM_COMP_CALIBRATION			BIT26
+//Common Functions
+#define	ODM_PHY_CONFIG				BIT28
+#define	BEAMFORMING_DEBUG				BIT29
+#define	ODM_COMP_COMMON				BIT30
+#define	ODM_COMP_INIT					BIT31
+#define	ODM_COMP_NOISY_DETECT		BIT32
+
+/*------------------------Export Marco Definition---------------------------*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#define RT_PRINTK				DbgPrint
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#define DbgPrint	printk
+	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
+	#define	RT_DISP(dbgtype, dbgflag, printstr)
+#else
+	#define DbgPrint	panic_printk
+	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
+#endif
+
+#ifndef ASSERT
+	#define ASSERT(expr)
+#endif
+
+#if DBG
+#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)									\
+	do {	\
+		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel || level == ODM_DBG_SERIOUS))	\
+		{																			\
+			if(pDM_Odm->SupportICType == ODM_RTL8192C)								\
+				DbgPrint("[ODM-92C] ");												\
+			else if(pDM_Odm->SupportICType == ODM_RTL8192D)							\
+				DbgPrint("[ODM-92D] ");												\
+			else if(pDM_Odm->SupportICType == ODM_RTL8723A)							\
+				DbgPrint("[ODM-8723A] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8188E)							\
+				DbgPrint("[ODM-8188E] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8192E) 						\
+				DbgPrint("[ODM-8192E] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8812)							\
+				DbgPrint("[ODM-8812] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8821)							\
+				DbgPrint("[ODM-8821] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8814A)							\
+				DbgPrint("[ODM-8814] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8703B)							\
+				DbgPrint("[ODM-8703B] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8822B)							\
+				DbgPrint("[ODM-8822] ");											\
+			else if (pDM_Odm->SupportICType == ODM_RTL8188F)							\
+				DbgPrint("[ODM-8188F] ");											\
+			RT_PRINTK fmt;															\
+		}	\
+	} while (0)
+	
+#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)									\
+		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
+		{																			\
+			RT_PRINTK fmt;															\
+		}
+
+#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)											\
+		if(!(expr)) {																	\
+			DbgPrint( "Assertion failed! %s at ......\n", #expr);								\
+			DbgPrint( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);			\
+			RT_PRINTK fmt;															\
+			ASSERT(FALSE);															\
+		}
+#define ODM_dbg_enter() { DbgPrint("==> %s\n", __FUNCTION__); }
+#define ODM_dbg_exit() { DbgPrint("<== %s\n", __FUNCTION__); }
+#define ODM_dbg_trace(str) { DbgPrint("%s:%s\n", __FUNCTION__, str); }
+
+#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)							\
+			if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	__ptr = (pu1Byte)ptr;											\
+				DbgPrint("[ODM] ");													\
+				DbgPrint(title_str);													\
+				DbgPrint(" ");														\
+				for( __i=0; __i<6; __i++ )												\
+					DbgPrint("%02X%s", __ptr[__i], (__i==5)?"":"-");						\
+				DbgPrint("\n");														\
+			}
+#else
+#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)
+#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)
+#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)
+#define ODM_dbg_enter()
+#define ODM_dbg_exit()
+#define ODM_dbg_trace(str)
+#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)
+#endif
+
+
+VOID 
+PHYDM_InitDebugSetting(IN		PDM_ODM_T		pDM_Odm);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID phydm_BB_RxHang_Info(IN PDM_ODM_T pDM_Odm);
+#endif
+
+#define	BB_TMP_BUF_SIZE		100
+VOID phydm_BB_Debug_Info(IN PDM_ODM_T pDM_Odm);
+VOID phydm_BasicDbgMessage(	IN		PVOID			pDM_VOID);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#define	PHYDM_DBGPRINT		0
+#define	PHYDM_SSCANF(x, y, z)	DCMD_Scanf(x, y, z)
+#if (PHYDM_DBGPRINT == 1)
+#define	PHYDM_SNPRINTF(msg)	\
+		do {\
+			rsprintf msg;\
+			DbgPrint(output);\
+		} while (0)
+#else
+#define	PHYDM_SNPRINTF(msg)	\
+		do {\
+			rsprintf msg;\
+			DCMD_Printf(output);\
+		} while (0)
+#endif
+#else
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#define	PHYDM_DBGPRINT		0
+#else
+#define	PHYDM_DBGPRINT		1
+#endif
+#define	MAX_ARGC				20
+#define	MAX_ARGV				16
+#define	DCMD_DECIMAL			"%d"
+#define	DCMD_CHAR				"%c"
+#define	DCMD_HEX				"%x"
+
+#define	PHYDM_SSCANF(x, y, z)	sscanf(x, y, z)
+#if (PHYDM_DBGPRINT == 1)
+#define	PHYDM_SNPRINTF(msg)\
+		do {\
+			snprintf msg;\
+			DbgPrint(output);\
+		} while (0)
+#else
+#define	PHYDM_SNPRINTF(msg)\
+		do {\
+			if(out_len > used)\
+				used+=snprintf msg;\
+		} while (0)
+#endif
+#endif
+
+
+VOID phydm_BasicProfile(
+	IN		PVOID			pDM_VOID,
+	IN		u4Byte			*_used,
+	OUT		char				*output,
+	IN		u4Byte			*_out_len
+	);
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_AP))
+s4Byte
+phydm_cmd(
+	IN PDM_ODM_T	pDM_Odm,
+	IN char		*input,
+	IN u4Byte	in_len,
+	IN u1Byte	flag,
+	OUT char	*output,
+	IN u4Byte	out_len
+);
+#endif
+VOID
+phydm_cmd_parser(
+	IN PDM_ODM_T	pDM_Odm,
+	IN char		input[][16],
+	IN u4Byte	input_num,
+	IN u1Byte	flag,
+	OUT char	*output,
+	IN u4Byte	out_len
+);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+void phydm_sbd_check(
+	IN	PDM_ODM_T					pDM_Odm
+	);
+
+void phydm_sbd_callback(
+	PRT_TIMER		pTimer
+	);
+
+void phydm_sbd_workitem_callback(
+    IN PVOID            pContext
+	);
+#endif
+
+VOID
+phydm_fw_trace_en_h2c(
+	IN	PVOID	pDM_VOID,
+	IN	BOOLEAN		enable,
+	IN	u4Byte		monitor_mode,
+	IN	u4Byte		macid
+);
+
+VOID
+phydm_fw_trace_handler(
+	IN		PVOID	pDM_VOID,
+	IN		pu1Byte	CmdBuf,
+	IN		u1Byte	CmdLen
+);
+
+VOID
+phydm_fw_trace_handler_code(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte	Buffer,
+	IN	u1Byte	CmdLen
+);
+
+VOID
+phydm_fw_trace_handler_8051(
+	IN	PVOID	pDM_VOID,
+	IN	pu1Byte	CmdBuf,
+	IN	u1Byte	CmdLen
+);
+
+#endif	// __ODM_DBG_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.c
new file mode 100644
index 000000000..268e970fc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.c
@@ -0,0 +1,2087 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+
+VOID
+ODM_ChangeDynamicInitGainThresh(
+	IN	PVOID		pDM_VOID,
+	IN	u4Byte		DM_Type,
+	IN	u4Byte		DM_Value
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	if (DM_Type == DIG_TYPE_THRESH_HIGH)
+	{
+		pDM_DigTable->RssiHighThresh = DM_Value;		
+	}
+	else if (DM_Type == DIG_TYPE_THRESH_LOW)
+	{
+		pDM_DigTable->RssiLowThresh = DM_Value;
+	}
+	else if (DM_Type == DIG_TYPE_ENABLE)
+	{
+		pDM_DigTable->Dig_Enable_Flag	= TRUE;
+	}	
+	else if (DM_Type == DIG_TYPE_DISABLE)
+	{
+		pDM_DigTable->Dig_Enable_Flag = FALSE;
+	}	
+	else if (DM_Type == DIG_TYPE_BACKOFF)
+	{
+		if(DM_Value > 30)
+			DM_Value = 30;
+		pDM_DigTable->BackoffVal = (u1Byte)DM_Value;
+	}
+	else if(DM_Type == DIG_TYPE_RX_GAIN_MIN)
+	{
+		if(DM_Value == 0)
+			DM_Value = 0x1;
+		pDM_DigTable->rx_gain_range_min = (u1Byte)DM_Value;
+	}
+	else if(DM_Type == DIG_TYPE_RX_GAIN_MAX)
+	{
+		if(DM_Value > 0x50)
+			DM_Value = 0x50;
+		pDM_DigTable->rx_gain_range_max = (u1Byte)DM_Value;
+	}
+}	// DM_ChangeDynamicInitGainThresh //
+
+int 
+getIGIForDiff(int value_IGI)
+{
+	#define ONERCCA_LOW_TH		0x30
+	#define ONERCCA_LOW_DIFF		8
+
+	if (value_IGI < ONERCCA_LOW_TH) {
+		if ((ONERCCA_LOW_TH - value_IGI) < ONERCCA_LOW_DIFF)
+			return ONERCCA_LOW_TH;
+		else
+			return value_IGI + ONERCCA_LOW_DIFF;
+	} else {
+		return value_IGI;
+	}
+}
+
+VOID
+odm_FAThresholdCheck(
+	IN		PVOID			pDM_VOID,
+	IN		BOOLEAN			bDFSBand,
+	IN		BOOLEAN			bPerformance,
+	IN		u4Byte			RxTp,
+	IN		u4Byte			TxTp,
+	OUT		u4Byte*			dm_FA_thres
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if(pDM_Odm->bLinked && (bPerformance||bDFSBand))
+	{
+		if(pDM_Odm->SupportICType == ODM_RTL8192D)
+		{
+			// 8192D special case
+			dm_FA_thres[0] = DM_DIG_FA_TH0_92D;
+			dm_FA_thres[1] = DM_DIG_FA_TH1_92D;
+			dm_FA_thres[2] = DM_DIG_FA_TH2_92D;
+		}
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		else if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
+		{
+			// For AP
+			if((RxTp>>2) > TxTp && RxTp < 10000 && RxTp > 500)			// 10Mbps & 0.5Mbps
+			{
+				dm_FA_thres[0] = 0x080;
+				dm_FA_thres[1] = 0x100;
+				dm_FA_thres[2] = 0x200;			
+			}
+			else
+			{
+				dm_FA_thres[0] = 0x100;
+				dm_FA_thres[1] = 0x200;
+				dm_FA_thres[2] = 0x300;	
+			}
+		}
+#else
+		else if(pDM_Odm->SupportICType == ODM_RTL8723A && pDM_Odm->bBtLimitedDig)
+		{
+			// 8723A BT special case
+			dm_FA_thres[0] = DM_DIG_FA_TH0;
+			dm_FA_thres[1] = 0x250;
+			dm_FA_thres[2] = 0x300;
+		}
+#endif
+		else
+		{
+			// For NIC
+			dm_FA_thres[0] = DM_DIG_FA_TH0;
+			dm_FA_thres[1] = DM_DIG_FA_TH1;
+			dm_FA_thres[2] = DM_DIG_FA_TH2;
+		}
+	}
+	else
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		if(bDFSBand)
+		{
+			// For DFS band and no link
+			dm_FA_thres[0] = 250;
+			dm_FA_thres[1] = 1000;
+			dm_FA_thres[2] = 2000;
+		}
+		else
+#endif
+		{
+			dm_FA_thres[0] = 2000;
+			dm_FA_thres[1] = 4000;
+			dm_FA_thres[2] = 5000;
+		}
+	}
+	return;
+}
+
+u1Byte
+odm_ForbiddenIGICheck(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			DIG_Dynamic_MIN,
+	IN		u1Byte			CurrentIGI
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PFALSE_ALARM_STATISTICS 	pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u1Byte						rx_gain_range_min = pDM_DigTable->rx_gain_range_min;
+
+	if(pFalseAlmCnt->Cnt_all > 10000)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnormally false alarm case. \n"));
+
+		if(pDM_DigTable->LargeFAHit != 3)
+			pDM_DigTable->LargeFAHit++;
+		
+		if(pDM_DigTable->ForbiddenIGI < CurrentIGI)//if(pDM_DigTable->ForbiddenIGI < pDM_DigTable->CurIGValue)
+		{
+			pDM_DigTable->ForbiddenIGI = CurrentIGI;//pDM_DigTable->ForbiddenIGI = pDM_DigTable->CurIGValue;
+			pDM_DigTable->LargeFAHit = 1;
+		}
+
+		if(pDM_DigTable->LargeFAHit >= 3)
+		{
+			if((pDM_DigTable->ForbiddenIGI + 2) > pDM_DigTable->rx_gain_range_max)
+				rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
+			else
+				rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 2);
+			pDM_DigTable->Recover_cnt = 1800;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnormally false alarm case: Recover_cnt = %d \n", pDM_DigTable->Recover_cnt));
+		}
+	}
+	else
+	{
+		if(pDM_DigTable->Recover_cnt != 0)
+		{
+			pDM_DigTable->Recover_cnt --;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: Recover_cnt = %d \n", pDM_DigTable->Recover_cnt));
+		}
+		else
+		{
+			if(pDM_DigTable->LargeFAHit < 3)
+			{
+				if((pDM_DigTable->ForbiddenIGI - 2) < DIG_Dynamic_MIN) //DM_DIG_MIN)
+				{
+					pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN; //DM_DIG_MIN;
+					rx_gain_range_min = DIG_Dynamic_MIN; //DM_DIG_MIN;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: At Lower Bound\n"));
+				}
+				else
+				{
+					pDM_DigTable->ForbiddenIGI -= 2;
+					rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 2);
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: Approach Lower Bound\n"));
+				}
+			}
+			else
+			{
+				pDM_DigTable->LargeFAHit = 0;
+			}
+		}
+	}
+	
+	return rx_gain_range_min;
+
+}
+
+VOID
+odm_InbandNoiseCalculate (	
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+	u1Byte				IGIBackup, TimeCnt = 0, ValidCnt = 0;
+	BOOLEAN				bTimeout = TRUE;
+	s1Byte				sNoise_A, sNoise_B;
+	s4Byte				NoiseRpt_A = 0,NoiseRpt_B = 0;
+	u4Byte				tmp = 0;
+	static	u1Byte		failCnt = 0;
+
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8192E)))
+		return;
+
+	if(pDM_Odm->RFType == ODM_1T1R || *(pDM_Odm->pOnePathCCA) != ODM_CCA_2R)
+		return;
+
+	if(!pDM_DigTable->bNoiseEst)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_InbandNoiseEstimate()========>\n"));
+	
+	//1 Set initial gain.
+	IGIBackup = pDM_DigTable->CurIGValue;
+	pDM_DigTable->IGIOffset_A = 0;
+	pDM_DigTable->IGIOffset_B = 0;
+	ODM_Write_DIG(pDM_Odm, 0x24);
+
+	//1 Update idle time power report	
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TX_ANT_CTRL_11N, BIT25, 0x0);
+
+	delay_ms(2);
+
+	//1 Get noise power level
+	while(1)
+	{
+		//2 Read Noise Floor Report
+		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+			tmp = ODM_GetBBReg(pDM_Odm, 0x8f8, bMaskLWord);
+
+		sNoise_A = (s1Byte)(tmp & 0xff);
+		sNoise_B = (s1Byte)((tmp & 0xff00)>>8);
+
+		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("sNoise_A = %d, sNoise_B = %d\n",sNoise_A, sNoise_B));
+
+		if((sNoise_A < 20 && sNoise_A >= -70) && (sNoise_B < 20 && sNoise_B >= -70))
+		{
+			ValidCnt++;
+			NoiseRpt_A += sNoise_A;
+			NoiseRpt_B += sNoise_B;
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("sNoise_A = %d, sNoise_B = %d\n",sNoise_A, sNoise_B));
+		}
+
+		TimeCnt++;
+		bTimeout = (TimeCnt >= 150)?TRUE:FALSE;
+		
+		if(ValidCnt == 20 || bTimeout)
+			break;
+
+		delay_ms(2);
+		
+	}
+
+	//1 Keep idle time power report	
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TX_ANT_CTRL_11N, BIT25, 0x1);
+
+	//1 Recover IGI
+	ODM_Write_DIG(pDM_Odm, IGIBackup);
+	
+	//1 Calculate Noise Floor
+	if(ValidCnt != 0)
+	{
+		NoiseRpt_A  /= (ValidCnt<<1);
+		NoiseRpt_B  /= (ValidCnt<<1);
+	}
+	
+	if(bTimeout)
+	{
+		NoiseRpt_A = 0;
+		NoiseRpt_B = 0;
+
+		failCnt ++;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Noise estimate fail time = %d\n", failCnt));
+		
+		if(failCnt == 3)
+		{
+			failCnt = 0;
+			pDM_DigTable->bNoiseEst = FALSE;
+		}
+	}
+	else
+	{
+		NoiseRpt_A = -110 + 0x24 + NoiseRpt_A -6;
+		NoiseRpt_B = -110 + 0x24 + NoiseRpt_B -6;
+		pDM_DigTable->bNoiseEst = FALSE;
+		failCnt = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("NoiseRpt_A = %d, NoiseRpt_B = %d\n", NoiseRpt_A, NoiseRpt_B));
+	}
+
+	//1 Calculate IGI Offset
+	if(NoiseRpt_A > NoiseRpt_B)
+	{
+		pDM_DigTable->IGIOffset_A = NoiseRpt_A - NoiseRpt_B;
+		pDM_DigTable->IGIOffset_B = 0;
+	}
+	else
+	{
+		pDM_DigTable->IGIOffset_A = 0;
+		pDM_DigTable->IGIOffset_B = NoiseRpt_B - NoiseRpt_A;
+	}
+
+#endif
+	return;
+}
+
+VOID
+odm_DigForBtHsMode(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T					pDM_DigTable=&pDM_Odm->DM_DigTable;
+	u1Byte					digForBtHs=0;
+	u1Byte					digUpBound=0x5a;
+	
+	if(pDM_Odm->bBtConnectProcess)
+	{
+		if(pDM_Odm->SupportICType&(ODM_RTL8723A))
+			digForBtHs = 0x28;
+		else
+			digForBtHs = 0x22;
+	}
+	else
+	{
+		//
+		// Decide DIG value by BT HS RSSI.
+		//
+		digForBtHs = pDM_Odm->btHsRssi+4;
+		
+		//DIG Bound
+		if(pDM_Odm->SupportICType&(ODM_RTL8723A))
+			digUpBound = 0x3e;
+		
+		if(digForBtHs > digUpBound)
+			digForBtHs = digUpBound;
+		if(digForBtHs < 0x1c)
+			digForBtHs = 0x1c;
+
+		// update Current IGI
+		pDM_DigTable->BT30_CurIGI = digForBtHs;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DigForBtHsMode() : set DigValue=0x%x\n", digForBtHs));
+#endif
+}
+
+VOID
+ODM_Write_DIG(
+	IN	PVOID			pDM_VOID,
+	IN	u1Byte			CurrentIGI
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	if (pDM_DigTable->bStopDIG) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_Write_DIG(): Stop Writing IGI\n"));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_TRACE, ("ODM_Write_DIG(): ODM_REG(IGI_A,pDM_Odm)=0x%x, ODM_BIT(IGI,pDM_Odm)=0x%x\n",
+		ODM_REG(IGI_A,pDM_Odm),ODM_BIT(IGI,pDM_Odm)));
+
+	//1 Check initial gain by upper bound		
+	if ((!pDM_DigTable->bPSDInProgress) && pDM_Odm->bLinked)
+	{
+		if (CurrentIGI > pDM_DigTable->rx_gain_range_max) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_TRACE, ("ODM_Write_DIG(): CurrentIGI(0x%02x) is larger than upper bound !!\n", CurrentIGI));
+			CurrentIGI = pDM_DigTable->rx_gain_range_max;
+		}
+		if (pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY && pDM_Odm->adaptivity_flag == TRUE)
+		{
+			if(CurrentIGI > pDM_Odm->Adaptivity_IGI_upper)
+				CurrentIGI = pDM_Odm->Adaptivity_IGI_upper;
+	
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_Write_DIG(): Adaptivity case: Force upper bound to 0x%x !!!!!!\n", CurrentIGI));
+		}
+	}
+
+	if(pDM_DigTable->CurIGValue != CurrentIGI)
+	{
+
+		/*Add by YuChen for USB IO too slow issue*/
+		if ((pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY) && (CurrentIGI > pDM_DigTable->CurIGValue))
+			Phydm_Adaptivity(pDM_Odm, CurrentIGI);
+
+		//1 Set IGI value
+		if(pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE))
+		{ 
+			ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+			if(pDM_Odm->RFType > ODM_1T1R)
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+			if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+			{
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_C,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_D,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+			}
+		}
+		else if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
+		{
+			switch(*(pDM_Odm->pOnePathCCA))
+			{
+				case ODM_CCA_2R:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+					if(pDM_Odm->RFType > ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					
+					if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+					{
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_C,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_D,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					}
+					break;
+				case ODM_CCA_1R_A:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					if(pDM_Odm->RFType != ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
+					break;
+				case ODM_CCA_1R_B:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
+					if(pDM_Odm->RFType != ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					break;
+			}
+		}
+		pDM_DigTable->CurIGValue = CurrentIGI;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_TRACE, ("ODM_Write_DIG(): CurrentIGI(0x%02x).\n", CurrentIGI));
+	
+}
+
+VOID
+odm_PauseDIG(
+	IN		PVOID					pDM_VOID,
+	IN		PHYDM_PAUSE_TYPE		PauseType,
+	IN		PHYDM_PAUSE_LEVEL		pause_level,
+	IN		u1Byte					IGIValue
+)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG()=========> level = %d\n", pause_level));
+
+	if ((pDM_DigTable->pause_dig_level == 0) && (!(pDM_Odm->SupportAbility & ODM_BB_DIG) || !(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, 
+			("odm_PauseDIG(): Return: SupportAbility DIG or FA is disabled !!\n"));
+		return;
+	}
+
+	if (pause_level > DM_DIG_MAX_PAUSE_TYPE) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, 
+			("odm_PauseDIG(): Return: Wrong pause level !!\n"));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): pause level = 0x%x, Current value = 0x%x\n", pDM_DigTable->pause_dig_level, IGIValue));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
+		pDM_DigTable->pause_dig_value[7], pDM_DigTable->pause_dig_value[6], pDM_DigTable->pause_dig_value[5], pDM_DigTable->pause_dig_value[4],
+		pDM_DigTable->pause_dig_value[3], pDM_DigTable->pause_dig_value[2], pDM_DigTable->pause_dig_value[1], pDM_DigTable->pause_dig_value[0]));
+	
+	switch (PauseType) {
+	/* Pause DIG */
+	case PHYDM_PAUSE:
+	{
+		/* Disable DIG */
+		ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility & (~ODM_BB_DIG));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Pause DIG !!\n"));
+		
+		/* Backup IGI value */
+		if (pDM_DigTable->pause_dig_level == 0) {
+			pDM_DigTable->IGIBackup = pDM_DigTable->CurIGValue;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Backup IGI  = 0x%x, new IGI = 0x%x\n", pDM_DigTable->IGIBackup, IGIValue));
+		}
+
+		/* Record IGI value */
+		pDM_DigTable->pause_dig_value[pause_level] = IGIValue;
+
+		/* Update pause level */
+		pDM_DigTable->pause_dig_level = (pDM_DigTable->pause_dig_level | BIT(pause_level));
+
+		/* Write new IGI value */
+		if (BIT(pause_level + 1) > pDM_DigTable->pause_dig_level) {
+			ODM_Write_DIG(pDM_Odm, IGIValue);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): IGI of higher level = 0x%x\n",  IGIValue));
+		}
+		break;
+	}
+	/* Resume DIG */
+	case PHYDM_RESUME:
+	{
+		/* check if the level is illegal or not */
+		if ((pDM_DigTable->pause_dig_level & (BIT(pause_level))) != 0) {
+			pDM_DigTable->pause_dig_level = pDM_DigTable->pause_dig_level & (~(BIT(pause_level)));
+			pDM_DigTable->pause_dig_value[pause_level] = 0;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Resume DIG !!\n"));
+		} else {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Wrong resume level !!\n"));
+			break;
+		}
+
+		/* Resume DIG */
+		if (pDM_DigTable->pause_dig_level == 0) {
+			/* Write backup IGI value */
+			ODM_Write_DIG(pDM_Odm, pDM_DigTable->IGIBackup);
+			pDM_DigTable->bIgnoreDIG = TRUE;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Write original IGI = 0x%x\n", pDM_DigTable->IGIBackup));
+
+			/* Enable DIG */
+			ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility | ODM_BB_DIG);	
+			break;
+		}
+
+		if (BIT(pause_level) > pDM_DigTable->pause_dig_level) {
+			u1Byte		max_level;
+		
+			/* Calculate the maximum level now */
+			for (max_level = (pause_level - 1); max_level >= 0; max_level--) {
+				if ((pDM_DigTable->pause_dig_level & BIT(max_level)) > 0)
+					break;
+			}
+		
+			/* write IGI of lower level */
+			ODM_Write_DIG(pDM_Odm, pDM_DigTable->pause_dig_value[max_level]);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Write IGI (0x%x) of level (%d)\n",  
+				 pDM_DigTable->pause_dig_value[max_level], max_level));
+			break;
+		}
+		break;
+	}
+	default:
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Wrong  type !!\n"));
+		break;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): pause level = 0x%x, Current value = 0x%x\n", pDM_DigTable->pause_dig_level, IGIValue));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
+		pDM_DigTable->pause_dig_value[7], pDM_DigTable->pause_dig_value[6], pDM_DigTable->pause_dig_value[5], pDM_DigTable->pause_dig_value[4],
+		pDM_DigTable->pause_dig_value[3], pDM_DigTable->pause_dig_value[2], pDM_DigTable->pause_dig_value[1], pDM_DigTable->pause_dig_value[0]));
+
+}
+
+BOOLEAN 
+odm_DigAbort(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+#endif
+
+	//SupportAbility
+	if(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: SupportAbility ODM_BB_FA_CNT is disabled\n"));
+		return	TRUE;
+	}
+
+	//SupportAbility
+	if(!(pDM_Odm->SupportAbility & ODM_BB_DIG))
+	{	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: SupportAbility ODM_BB_DIG is disabled\n"));
+		return	TRUE;
+	}
+
+	//ScanInProcess
+	if(*(pDM_Odm->pbScanInProcess))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: In Scan Progress \n"));
+	    	return	TRUE;
+	}
+
+	if(pDM_DigTable->bIgnoreDIG)
+	{
+		pDM_DigTable->bIgnoreDIG = FALSE;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: Ignore DIG \n"));
+	    	return	TRUE;
+	}
+
+	//add by Neil Chen to avoid PSD is processing
+	if(pDM_Odm->bDMInitialGainEnable == FALSE)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: PSD is Processing \n"));
+		return	TRUE;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#if OS_WIN_FROM_WIN7(OS_VERSION)
+	if(IsAPModeExist( pAdapter) && pAdapter->bInHctTest)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: Is AP mode or In HCT Test \n"));
+	    	return	TRUE;
+	}
+	#endif
+
+	if(pDM_Odm->bBtHsOperation)
+	{
+		odm_DigForBtHsMode(pDM_Odm);
+	}	
+
+	if(!(pDM_Odm->SupportICType &(ODM_RTL8723A|ODM_RTL8188E)))
+	{
+		if(pRX_HP_Table->RXHP_flag == 1)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: In RXHP Operation \n"));
+			return	TRUE;	
+		}
+	}
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV	
+	if((pDM_Odm->bLinked) && (pDM_Odm->Adapter->registrypriv.force_igi !=0))
+	{	
+		printk("pDM_Odm->RSSI_Min=%d \n",pDM_Odm->RSSI_Min);
+		ODM_Write_DIG(pDM_Odm,pDM_Odm->Adapter->registrypriv.force_igi);
+		return	TRUE;
+	}
+	#endif
+#else
+	if (!(priv->up_time > 5))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: Not In DIG Operation Period \n"));
+		return	TRUE;
+	}
+#endif
+
+	return	FALSE;
+}
+
+VOID
+odm_DIGInit(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+#endif
+
+	pDM_DigTable->bStopDIG = FALSE;
+	pDM_DigTable->bIgnoreDIG = FALSE;
+	pDM_DigTable->bPSDInProgress = FALSE;
+	pDM_DigTable->CurIGValue = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm));
+	pDM_DigTable->RssiLowThresh 	= DM_DIG_THRESH_LOW;
+	pDM_DigTable->RssiHighThresh 	= DM_DIG_THRESH_HIGH;
+	pDM_DigTable->FALowThresh	= DM_FALSEALARM_THRESH_LOW;
+	pDM_DigTable->FAHighThresh	= DM_FALSEALARM_THRESH_HIGH;
+	pDM_DigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
+	pDM_DigTable->BackoffVal_range_max = DM_DIG_BACKOFF_MAX;
+	pDM_DigTable->BackoffVal_range_min = DM_DIG_BACKOFF_MIN;
+	pDM_DigTable->PreCCK_CCAThres = 0xFF;
+	pDM_DigTable->CurCCK_CCAThres = 0x83;
+	pDM_DigTable->ForbiddenIGI = DM_DIG_MIN_NIC;
+	pDM_DigTable->LargeFAHit = 0;
+	pDM_DigTable->Recover_cnt = 0;
+	pDM_DigTable->bMediaConnect_0 = FALSE;
+	pDM_DigTable->bMediaConnect_1 = FALSE;
+
+	//To Initialize pDM_Odm->bDMInitialGainEnable == FALSE to avoid DIG error
+	pDM_Odm->bDMInitialGainEnable = TRUE;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	pDM_DigTable->DIG_Dynamic_MIN_0 = 0x25;
+	pDM_DigTable->DIG_Dynamic_MIN_1 = 0x25;
+
+	// For AP\ ADSL modified DIG
+	pDM_DigTable->bTpTarget = FALSE;
+	pDM_DigTable->bNoiseEst = TRUE;
+	pDM_DigTable->IGIOffset_A = 0;
+	pDM_DigTable->IGIOffset_B = 0;
+	pDM_DigTable->TpTrainTH_min = 0;
+
+	// For RTL8881A
+	FalseAlmCnt->Cnt_Ofdm_fail_pre = 0;
+
+	//Dyanmic EDCCA
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		ODM_SetBBReg(pDM_Odm, 0xC50, 0xFFFF0000, 0xfafd);
+	}
+#else
+	pDM_DigTable->DIG_Dynamic_MIN_0 = DM_DIG_MIN_NIC;
+	pDM_DigTable->DIG_Dynamic_MIN_1 = DM_DIG_MIN_NIC;
+
+	//To Initi BT30 IGI
+	pDM_DigTable->BT30_CurIGI=0x32;
+
+	ODM_Memory_Set(pDM_Odm, pDM_DigTable->pause_dig_value, 0, (DM_DIG_MAX_PAUSE_TYPE + 1));
+	pDM_DigTable->pause_dig_level = 0;
+	ODM_Memory_Set(pDM_Odm, pDM_DigTable->pause_cckpd_value, 0, (DM_DIG_MAX_PAUSE_TYPE + 1));
+	pDM_DigTable->pause_cckpd_level = 0;
+#endif
+
+	if(pDM_Odm->BoardType & (ODM_BOARD_EXT_PA|ODM_BOARD_EXT_LNA))
+	{
+		pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
+		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;
+	}
+	else
+	{
+		pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
+		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;
+	}
+	
+}
+
+
+VOID 
+odm_DIG(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER					pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv				priv = pDM_Odm->priv;
+	PSTA_INFO_T   				pEntry;
+#endif
+
+	// Common parameters
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	BOOLEAN						FirstConnect,FirstDisConnect;
+	u1Byte						DIG_MaxOfMin, DIG_Dynamic_MIN;
+	u1Byte						dm_dig_max, dm_dig_min;
+	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
+	u1Byte						offset;
+	u4Byte						dm_FA_thres[3];
+	u4Byte						TxTp = 0, RxTp = 0;
+	BOOLEAN						bDFSBand = FALSE;
+	BOOLEAN						bPerformance = TRUE, bFirstTpTarget = FALSE, bFirstCoverage = FALSE;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	u4Byte						TpTrainTH_MIN = DM_DIG_TP_Target_TH0;
+	static		u1Byte			TimeCnt = 0;
+	u1Byte						i;
+#endif
+
+	if(odm_DigAbort(pDM_Odm) == TRUE)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG()===========================>\n\n"));
+	
+
+	//1 Update status
+#if (RTL8192D_SUPPORT==1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
+		{
+			if(*(pDM_Odm->pbMasterOfDMSP))
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
+			}
+			else
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
+			}
+		}
+		else
+		{
+			if(*(pDM_Odm->pBandType) == ODM_BAND_5G)
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
+			}
+			else
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
+			}
+		}
+	}
+	else
+#endif
+	{	
+		DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
+		FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+		FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	//1 Noise Floor Estimate
+	//pDM_DigTable->bNoiseEst = (FirstConnect)?TRUE:pDM_DigTable->bNoiseEst;
+	//odm_InbandNoiseCalculate (pDM_Odm);
+	
+	//1 Mode decision
+	if(pDM_Odm->bLinked)
+	{
+		//2 Calculate total TP
+		for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			pEntry = pDM_Odm->pODM_StaInfo[i];
+			if(IS_STA_VALID(pEntry))
+			{
+				RxTp += (u4Byte)(pEntry->rx_byte_cnt_LowMAW>>7);
+				TxTp += (u4Byte)(pEntry->tx_byte_cnt_LowMAW>>7);			//Kbps
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TX TP = %dkbps, RX TP = %dkbps\n", TxTp, RxTp));
+	}
+
+	switch(pDM_Odm->priv->pshare->rf_ft_var.dig_cov_enable)
+	{
+		case 0:
+		{
+			bPerformance = TRUE;
+			break;
+		}
+		case 1:
+		{
+			bPerformance = FALSE;
+			break;
+		}
+		case 2:
+		{
+			if(pDM_Odm->bLinked)
+			{
+				if(pDM_DigTable->TpTrainTH_min > DM_DIG_TP_Target_TH0)
+					TpTrainTH_MIN = pDM_DigTable->TpTrainTH_min;
+
+				if(pDM_DigTable->TpTrainTH_min > DM_DIG_TP_Target_TH1)
+					TpTrainTH_MIN = DM_DIG_TP_Target_TH1;
+
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TP training mode lower bound = %dkbps\n", TpTrainTH_MIN));
+
+				//2 Decide DIG mode by total TP
+				if((TxTp + RxTp) > DM_DIG_TP_Target_TH1)			// change to performance mode
+				{
+					bFirstTpTarget = (!pDM_DigTable->bTpTarget)?TRUE:FALSE;
+					pDM_DigTable->bTpTarget = TRUE;
+					bPerformance = TRUE;
+				}
+				else if((TxTp + RxTp) < TpTrainTH_MIN)	// change to coverage mode
+				{
+					bFirstCoverage = (pDM_DigTable->bTpTarget)?TRUE:FALSE;
+					
+					if(TimeCnt < DM_DIG_TP_Training_Period)
+					{
+						pDM_DigTable->bTpTarget = FALSE;
+						bPerformance = FALSE;
+						TimeCnt++;
+					}
+					else
+					{
+						pDM_DigTable->bTpTarget = TRUE;
+						bPerformance = TRUE;
+						bFirstTpTarget = TRUE;
+						TimeCnt = 0;
+					}
+				}
+				else										// remain previous mode
+				{
+					bPerformance = pDM_DigTable->bTpTarget;
+
+					if(!bPerformance)
+					{
+						if(TimeCnt < DM_DIG_TP_Training_Period)
+							TimeCnt++;
+						else
+						{
+							pDM_DigTable->bTpTarget = TRUE;
+							bPerformance = TRUE;
+							bFirstTpTarget = TRUE;
+							TimeCnt = 0;
+						}
+					}
+				}
+
+				if(!bPerformance)
+					pDM_DigTable->TpTrainTH_min = RxTp + TxTp;
+
+			}
+			else
+			{
+				bPerformance = FALSE;
+				pDM_DigTable->TpTrainTH_min = 0;
+			}
+			break;
+		}
+		default:
+			bPerformance = TRUE;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("====== DIG mode = %d  ======\n", pDM_Odm->priv->pshare->rf_ft_var.dig_cov_enable));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("====== bPerformance = %d ======\n", bPerformance));
+#endif
+
+	//1 Boundary Decision
+#if (RTL8192C_SUPPORT==1) 
+	if((pDM_Odm->SupportICType & ODM_RTL8192C) && (pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA)))
+	{
+		//2 High power case
+		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
+		{
+			dm_dig_max = DM_DIG_MAX_AP_HP;
+			dm_dig_min = DM_DIG_MIN_AP_HP;
+		}
+		else
+		{
+			dm_dig_max = DM_DIG_MAX_NIC_HP;
+			dm_dig_min = DM_DIG_MIN_NIC_HP;
+		}
+		DIG_MaxOfMin = DM_DIG_MAX_AP_HP;
+	}
+	else
+#endif
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		//2 For AP\ADSL
+		if(!bPerformance)
+		{
+			dm_dig_max = DM_DIG_MAX_AP_COVERAGR;
+			dm_dig_min = DM_DIG_MIN_AP_COVERAGE;
+			DIG_MaxOfMin = DM_DIG_MAX_OF_MIN_COVERAGE;
+		}
+		else
+		{
+			dm_dig_max = DM_DIG_MAX_AP;
+			dm_dig_min = DM_DIG_MIN_AP;
+			DIG_MaxOfMin = DM_DIG_MAX_OF_MIN;
+		}
+
+		//4 DFS band
+		if (((*pDM_Odm->pChannel>= 52) &&(*pDM_Odm->pChannel <= 64)) ||
+			((*pDM_Odm->pChannel >= 100) &&	(*pDM_Odm->pChannel <= 140)))
+		{
+			bDFSBand = TRUE;
+			if (*pDM_Odm->pBandWidth == ODM_BW20M){
+				dm_dig_min = DM_DIG_MIN_AP_DFS+2;
+			}
+			else{
+				dm_dig_min = DM_DIG_MIN_AP_DFS;
+			}
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): ====== In DFS band ======\n"));
+		}
+		
+		//4 TX2path
+		if (priv->pmib->dot11RFEntry.tx2path && !bDFSBand && (*(pDM_Odm->pWirelessMode) == ODM_WM_B))
+				dm_dig_max = 0x2A;
+
+#if RTL8192E_SUPPORT
+#ifdef HIGH_POWER_EXT_LNA
+		if ((pDM_Odm->SupportICType & (ODM_RTL8192E)) && (pDM_Odm->ExtLNA))
+			dm_dig_max = 0x42;						
+#endif
+#endif
+
+#else
+		//2 For WIN\CE
+		if(pDM_Odm->SupportICType >= ODM_RTL8188E)
+			dm_dig_max = 0x5A;
+		else
+			dm_dig_max = DM_DIG_MAX_NIC;
+		
+		if(pDM_Odm->SupportICType != ODM_RTL8821)
+			dm_dig_min = DM_DIG_MIN_NIC;
+		else
+			dm_dig_min = 0x1C;
+
+		DIG_MaxOfMin = DM_DIG_MAX_AP;
+#endif	
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Absolutly upper bound = 0x%x, lower bound = 0x%x\n",dm_dig_max, dm_dig_min));
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	// for P2P case
+	if(0 < *pDM_Odm->pu1ForcedIgiLb)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): P2P case: Force IGI lb to: %u !!!!!!\n", *pDM_Odm->pu1ForcedIgiLb));
+		dm_dig_min = *pDM_Odm->pu1ForcedIgiLb;
+		dm_dig_max = (dm_dig_min <= dm_dig_max) ? (dm_dig_max) : (dm_dig_min + 1);
+	}
+#endif
+
+	//1 Adjust boundary by RSSI
+	if(pDM_Odm->bLinked && bPerformance)
+	{
+		//2 Modify DIG upper bound
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		offset = 15;
+#else
+		//4 Modify DIG upper bound for 92E, 8723A\B, 8821 & 8812 BT
+		if((pDM_Odm->SupportICType & (ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8812|ODM_RTL8821|ODM_RTL8723A)) && (pDM_Odm->bBtLimitedDig==1))
+		{
+			offset = 10;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Coex. case: Force upper bound to RSSI + %d !!!!!!\n", offset));		
+		}
+		else
+			offset = 15;
+#endif
+
+		if((pDM_Odm->RSSI_Min + offset) > dm_dig_max )
+			pDM_DigTable->rx_gain_range_max = dm_dig_max;
+		else if((pDM_Odm->RSSI_Min + offset) < dm_dig_min )
+			pDM_DigTable->rx_gain_range_max = dm_dig_min;
+		else
+			pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + offset;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		//2 Modify DIG lower bound
+		//if(pDM_Odm->bOneEntryOnly)
+		{
+			if(pDM_Odm->RSSI_Min < dm_dig_min)
+				DIG_Dynamic_MIN = dm_dig_min;
+			else if (pDM_Odm->RSSI_Min > DIG_MaxOfMin)
+				DIG_Dynamic_MIN = DIG_MaxOfMin;
+			else
+				DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
+		}
+#else
+		{
+			//4 For AP
+#ifdef __ECOS
+			HAL_REORDER_BARRIER();
+#else
+			rmb();
+#endif
+			if (bDFSBand)
+			{
+				DIG_Dynamic_MIN = dm_dig_min;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DFS band: Force lower bound to 0x%x after link !!!!!!\n", dm_dig_min));
+			}
+			else 
+			{
+				if(pDM_Odm->RSSI_Min < dm_dig_min)
+					DIG_Dynamic_MIN = dm_dig_min;
+				else if (pDM_Odm->RSSI_Min > DIG_MaxOfMin)
+					DIG_Dynamic_MIN = DIG_MaxOfMin;
+				else
+					DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
+			}
+		}
+#endif
+	}
+	else
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		if(bPerformance && bDFSBand)
+		{
+			pDM_DigTable->rx_gain_range_max = 0x28;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DFS band: Force upper bound to 0x%x before link !!!!!!\n", pDM_DigTable->rx_gain_range_max));
+		}
+		else
+#endif
+		{
+			pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_OF_MIN;
+		}
+		DIG_Dynamic_MIN = dm_dig_min;
+	}
+	
+	//1 Force Lower Bound for AntDiv
+	if(pDM_Odm->bLinked && !pDM_Odm->bOneEntryOnly)
+	{
+		if((pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT) && (pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+		{
+			if (pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV || pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV) {
+				if (pDM_DigTable->AntDiv_RSSI_max > DIG_MaxOfMin)
+					DIG_Dynamic_MIN = DIG_MaxOfMin;
+				else
+					DIG_Dynamic_MIN = (u1Byte) pDM_DigTable->AntDiv_RSSI_max;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Antenna diversity case: Force lower bound to 0x%x !!!!!!\n", DIG_Dynamic_MIN));
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Antenna diversity case: RSSI_max = 0x%x !!!!!!\n", pDM_DigTable->AntDiv_RSSI_max));
+			}
+		}
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adjust boundary by RSSI Upper bound = 0x%x, Lower bound = 0x%x\n",
+		pDM_DigTable->rx_gain_range_max, DIG_Dynamic_MIN));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Link status: bLinked = %d, RSSI = %d, bFirstConnect = %d, bFirsrDisConnect = %d\n\n",
+		pDM_Odm->bLinked, pDM_Odm->RSSI_Min, FirstConnect, FirstDisConnect));
+
+	//1 Modify DIG lower bound, deal with abnormal case
+	//2 Abnormal false alarm case
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	if(bDFSBand)
+	{
+		pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
+	}
+	else
+#endif
+	{
+		if(!pDM_Odm->bLinked)
+		{
+			pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
+
+			if (FirstDisConnect)
+				pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;
+		}
+		else
+			pDM_DigTable->rx_gain_range_min = odm_ForbiddenIGICheck(pDM_Odm, DIG_Dynamic_MIN, CurrentIGI);
+	}
+
+	//2 Abnormal # beacon case
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(pDM_Odm->bLinked && !FirstConnect)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("Beacon Num (%d)\n", pDM_Odm->PhyDbgInfo.NumQryBeaconPkt));
+		if((pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 5) && (pDM_Odm->bsta_state))
+		{
+			pDM_DigTable->rx_gain_range_min = dm_dig_min;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnrormal #beacon (%d) case in STA mode: Force lower bound to 0x%x !!!!!!\n\n",
+				pDM_Odm->PhyDbgInfo.NumQryBeaconPkt, pDM_DigTable->rx_gain_range_min));
+		}
+	}
+#endif
+
+	//2 Abnormal lower bound case
+	if(pDM_DigTable->rx_gain_range_min > pDM_DigTable->rx_gain_range_max)
+	{
+		pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnrormal lower bound case: Force lower bound to 0x%x !!!!!!\n\n",pDM_DigTable->rx_gain_range_min));
+	}
+
+	
+	//1 False alarm threshold decision
+	odm_FAThresholdCheck(pDM_Odm, bDFSBand, bPerformance, RxTp, TxTp, dm_FA_thres);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): False alarm threshold = %d, %d, %d \n\n", dm_FA_thres[0], dm_FA_thres[1], dm_FA_thres[2]));
+
+	//1 Adjust initial gain by false alarm
+	if(pDM_Odm->bLinked && bPerformance)
+	{
+		//2 After link
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adjust IGI after link\n"));
+
+		if(bFirstTpTarget || (FirstConnect && bPerformance))
+		{	
+			pDM_DigTable->LargeFAHit = 0;
+			
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+			if(bDFSBand)
+			{
+				if(pDM_Odm->RSSI_Min > 0x28)
+					CurrentIGI = 0x28;
+				else
+					CurrentIGI = pDM_Odm->RSSI_Min;
+				ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DFS band: One-shot to 0x28 upmost!!!!!!\n"));
+			}
+			else
+#endif
+			{
+				if(pDM_Odm->RSSI_Min < DIG_MaxOfMin)
+				{
+					if(CurrentIGI < pDM_Odm->RSSI_Min)
+						CurrentIGI = pDM_Odm->RSSI_Min;
+				}
+				else
+				{
+					if(CurrentIGI < DIG_MaxOfMin)
+						CurrentIGI = DIG_MaxOfMin;
+				}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+#if (RTL8812A_SUPPORT==1) 
+				if(pDM_Odm->SupportICType == ODM_RTL8812)
+					ODM_ConfigBBWithHeaderFile(pDM_Odm, CONFIG_BB_AGC_TAB_DIFF);
+#endif
+#endif
+			}
+
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First connect case: IGI does on-shot to 0x%x\n", CurrentIGI));
+
+		}
+		else
+		{
+			if(pFalseAlmCnt->Cnt_all > dm_FA_thres[2])
+				CurrentIGI = CurrentIGI + 4;
+			else if (pFalseAlmCnt->Cnt_all > dm_FA_thres[1])
+				CurrentIGI = CurrentIGI + 2;
+			else if(pFalseAlmCnt->Cnt_all < dm_FA_thres[0])
+				CurrentIGI = CurrentIGI - 2;
+
+			//4 Abnormal # beacon case
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+			if((pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 5) && (pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH1) && (pDM_Odm->bsta_state))
+			{						
+				CurrentIGI = pDM_DigTable->rx_gain_range_min;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnormal #beacon (%d) case: IGI does one-shot to 0x%x\n", 
+					pDM_Odm->PhyDbgInfo.NumQryBeaconPkt, CurrentIGI));
+			}
+#endif
+		}
+	}	
+	else
+	{
+		//2 Before link
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adjust IGI before link\n"));
+		
+		if(FirstDisConnect || bFirstCoverage)
+		{
+			CurrentIGI = dm_dig_min;
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First disconnect case: IGI does on-shot to lower bound\n"));
+		}
+		else
+		{
+			if(pFalseAlmCnt->Cnt_all > dm_FA_thres[2])
+				CurrentIGI = CurrentIGI + 4;
+			else if (pFalseAlmCnt->Cnt_all > dm_FA_thres[1])
+				CurrentIGI = CurrentIGI + 2;
+			else if(pFalseAlmCnt->Cnt_all < dm_FA_thres[0])
+				CurrentIGI = CurrentIGI - 2;
+		}
+	}
+
+	//1 Check initial gain by upper/lower bound
+	if(CurrentIGI < pDM_DigTable->rx_gain_range_min)
+		CurrentIGI = pDM_DigTable->rx_gain_range_min;
+	
+	if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
+		CurrentIGI = pDM_DigTable->rx_gain_range_max;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x, TotalFA = %d\n\n", CurrentIGI, pFalseAlmCnt->Cnt_all));	
+
+	//1 High power RSSI threshold
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	if((pDM_Odm->SupportICType == ODM_RTL8723A)&& (pHalData->UndecoratedSmoothedPWDB > DM_DIG_HIGH_PWR_THRESHOLD))
+	{
+		// High power IGI lower bound
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): UndecoratedSmoothedPWDB(%#x)\n", pHalData->UndecoratedSmoothedPWDB));
+		if(CurrentIGI < DM_DIG_HIGH_PWR_IGI_LOWER_BOUND)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue(%#x)\n", pDM_DigTable->CurIGValue));
+			//pDM_DigTable->CurIGValue = DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
+			CurrentIGI=DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
+		}
+	}
+	if((pDM_Odm->SupportICType & ODM_RTL8723A) && IS_WIRELESS_MODE_G(pAdapter))
+	{
+		if(pHalData->UndecoratedSmoothedPWDB > 0x28)
+		{
+			if(CurrentIGI < DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND)
+			{
+			 	//pDM_DigTable->CurIGValue = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
+				CurrentIGI = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
+			}	
+		} 
+	}
+#endif
+
+	//1 Update status
+#if (RTL8192D_SUPPORT==1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		//sherry  delete DualMacSmartConncurrent 20110517
+		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
+		{
+			ODM_Write_DIG_DMSP(pDM_Odm, CurrentIGI);//ODM_Write_DIG_DMSP(pDM_Odm, pDM_DigTable->CurIGValue);
+			if(*(pDM_Odm->pbMasterOfDMSP))
+			{
+				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				pDM_DigTable->bMediaConnect_1 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
+			}
+		}
+		else
+		{
+			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
+			if(*(pDM_Odm->pBandType) == ODM_BAND_5G)
+			{
+				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				pDM_DigTable->bMediaConnect_1 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
+			}
+		}
+	}
+	else
+#endif
+	{
+#if ((DM_ODM_SUPPORT_TYPE & ODM_WIN) || ((DM_ODM_SUPPORT_TYPE & ODM_CE) && (ODM_CONFIG_BT_COEXIST == 1)))
+		if(pDM_Odm->bBtHsOperation)
+		{
+			if(pDM_Odm->bLinked)
+			{
+				if(pDM_DigTable->BT30_CurIGI > (CurrentIGI))
+					ODM_Write_DIG(pDM_Odm, CurrentIGI);
+				else
+					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);
+					
+				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				if(pDM_Odm->bLinkInProcess)
+					ODM_Write_DIG(pDM_Odm, 0x1c);
+				else if(pDM_Odm->bBtConnectProcess)
+					ODM_Write_DIG(pDM_Odm, 0x28);
+				else
+					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);	
+			}
+		}
+		else		// BT is not using
+#endif
+		{
+			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
+			pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+			pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+		}
+	}
+}
+
+VOID
+odm_DIGbyRSSI_LPS(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+
+	u1Byte	RSSI_Lower=DM_DIG_MIN_NIC;   //0x1E or 0x1C
+	u1Byte	CurrentIGI=pDM_Odm->RSSI_Min;
+
+	if(odm_DigAbort(pDM_Odm) == TRUE)
+		return;
+
+	CurrentIGI=CurrentIGI+RSSI_OFFSET_DIG;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS()==>\n"));
+
+	// Using FW PS mode to make IGI
+	//Adjust by  FA in LPS MODE
+	if(pFalseAlmCnt->Cnt_all> DM_DIG_FA_TH2_LPS)
+		CurrentIGI = CurrentIGI+4;
+	else if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_LPS)
+		CurrentIGI = CurrentIGI+2;
+	else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_LPS)
+		CurrentIGI = CurrentIGI-2;	
+
+
+	//Lower bound checking
+
+	//RSSI Lower bound check
+	if((pDM_Odm->RSSI_Min-10) > DM_DIG_MIN_NIC)
+		RSSI_Lower =(pDM_Odm->RSSI_Min-10);
+	else
+		RSSI_Lower =DM_DIG_MIN_NIC;
+
+	//Upper and Lower Bound checking
+	 if(CurrentIGI > DM_DIG_MAX_NIC)
+	 	CurrentIGI=DM_DIG_MAX_NIC;
+	 else if(CurrentIGI < RSSI_Lower)
+		CurrentIGI =RSSI_Lower;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS(): pFalseAlmCnt->Cnt_all = %d\n",pFalseAlmCnt->Cnt_all));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS(): pDM_Odm->RSSI_Min = %d\n",pDM_Odm->RSSI_Min));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS(): CurrentIGI = 0x%x\n",CurrentIGI));
+
+	ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
+#endif
+}
+
+//3============================================================
+//3 FASLE ALARM CHECK
+//3============================================================
+
+VOID 
+odm_FalseAlarmCounterStatistics(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u4Byte 						ret_value;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+//Mark there, and check this in odm_DMWatchDog
+#if 0 //(DM_ODM_SUPPORT_TYPE == ODM_AP)
+	prtl8192cd_priv priv		= pDM_Odm->priv;
+	if( (priv->auto_channel != 0) && (priv->auto_channel != 2) )
+		return;
+#endif
+#endif
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics()======>\n"));
+
+#if (ODM_IC_11N_SERIES_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+
+		//hold ofdm counter
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1); //hold page C counter
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1); //hold page D counter
+	
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);
+		FalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);		
+
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_OFDM_CCA = (ret_value&0xffff); 
+		FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);	
+
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);
+		FalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
+
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);
+
+		FalseAlmCnt->Cnt_Ofdm_fail = 	FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal +
+								FalseAlmCnt->Cnt_Crc8_fail + FalseAlmCnt->Cnt_Mcs_fail +
+								FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail;
+
+#if (RTL8188E_SUPPORT==1)
+		if(pDM_Odm->SupportICType == ODM_RTL8188E)
+		{
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_SC_CNT_11N, bMaskDWord);
+			FalseAlmCnt->Cnt_BW_LSC = (ret_value&0xffff);
+			FalseAlmCnt->Cnt_BW_USC = ((ret_value&0xffff0000)>>16);
+		}
+#endif
+
+#if (RTL8192D_SUPPORT==1) 
+		if(pDM_Odm->SupportICType == ODM_RTL8192D)
+		{
+			odm_GetCCKFalseAlarm_92D(pDM_Odm);
+		}
+		else
+#endif
+		{
+			//hold cck counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT12, 1); 
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT14, 1); 
+		
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);
+			FalseAlmCnt->Cnt_Cck_fail = ret_value;
+
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_MSB_11N, bMaskByte3);
+			FalseAlmCnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
+
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord);
+			FalseAlmCnt->Cnt_CCK_CCA = ((ret_value&0xFF)<<8) |((ret_value&0xFF00)>>8);
+		}
+	
+		FalseAlmCnt->Cnt_all = (	FalseAlmCnt->Cnt_Fast_Fsync + 
+							FalseAlmCnt->Cnt_SB_Search_fail +
+							FalseAlmCnt->Cnt_Parity_Fail +
+							FalseAlmCnt->Cnt_Rate_Illegal +
+							FalseAlmCnt->Cnt_Crc8_fail +
+							FalseAlmCnt->Cnt_Mcs_fail +
+							FalseAlmCnt->Cnt_Cck_fail);	
+
+		FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
+
+#if (RTL8192C_SUPPORT==1)
+		if(pDM_Odm->SupportICType == ODM_RTL8192C)
+			odm_ResetFACounter_92C(pDM_Odm);
+#endif
+
+#if (RTL8192D_SUPPORT==1)
+		if(pDM_Odm->SupportICType == ODM_RTL8192D)
+			odm_ResetFACounter_92D(pDM_Odm);
+#endif
+
+		if(pDM_Odm->SupportICType >=ODM_RTL8723A)
+		{
+			//reset false alarm counter registers
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 1);
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 0);
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 1);
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 0);
+
+			//update ofdm counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 0); //update page C counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 0); //update page D counter
+
+			//reset CCK CCA counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 0); 
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 2); 
+			//reset CCK FA counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 0); 
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 2); 
+		}
+		
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Fast_Fsync=%d, Cnt_SB_Search_fail=%d\n",
+			FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Parity_Fail=%d, Cnt_Rate_Illegal=%d\n",
+			FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Crc8_fail=%d, Cnt_Mcs_fail=%d\n",
+		FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail));
+	}
+#endif
+
+#if (ODM_IC_11AC_SERIES_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		u4Byte CCKenable;
+		
+		/* read OFDM FA counter */
+		FalseAlmCnt->Cnt_Ofdm_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_11AC, bMaskLWord);
+		FalseAlmCnt->Cnt_SB_Search_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE2_11AC, bMaskLWord);
+		FalseAlmCnt->Cnt_Ofdm_fail = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_SB_Search_fail;
+
+		/* Read CCK FA counter */
+		FalseAlmCnt->Cnt_Cck_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_11AC, bMaskLWord);
+
+		/* read CCK/OFDM CCA counter */
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11AC, bMaskDWord);
+		FalseAlmCnt->Cnt_OFDM_CCA = (ret_value & 0xffff0000) >> 16;
+		FalseAlmCnt->Cnt_CCK_CCA = ret_value & 0xffff;
+
+#if (RTL8881A_SUPPORT==1) 
+		/* For 8881A */
+		if(pDM_Odm->SupportICType == ODM_RTL8881A)
+		{
+			u4Byte Cnt_Ofdm_fail_temp = 0;
+		
+			if(FalseAlmCnt->Cnt_Ofdm_fail >= FalseAlmCnt->Cnt_Ofdm_fail_pre)
+			{
+				Cnt_Ofdm_fail_temp = FalseAlmCnt->Cnt_Ofdm_fail_pre;
+				FalseAlmCnt->Cnt_Ofdm_fail_pre = FalseAlmCnt->Cnt_Ofdm_fail;
+				FalseAlmCnt->Cnt_Ofdm_fail = FalseAlmCnt->Cnt_Ofdm_fail - Cnt_Ofdm_fail_temp;
+			}
+			else
+				FalseAlmCnt->Cnt_Ofdm_fail_pre = FalseAlmCnt->Cnt_Ofdm_fail;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Ofdm_fail=%d\n",	FalseAlmCnt->Cnt_Ofdm_fail_pre));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Ofdm_fail_pre=%d\n",	Cnt_Ofdm_fail_temp));
+			
+			/* Reset FA counter by enable/disable OFDM */
+			if(FalseAlmCnt->Cnt_Ofdm_fail_pre >= 0x7fff)
+			{
+				// reset OFDM
+				ODM_SetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT29,0);
+				ODM_SetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT29,1);
+				FalseAlmCnt->Cnt_Ofdm_fail_pre = 0;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Reset false alarm counter\n"));
+			}
+		}
+#endif
+
+		/* reset OFDM FA coutner */
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 1);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 0);
+
+		/* reset CCK FA counter */
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 0);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 1);
+
+		/* reset CCA counter */
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RST_RPT_11AC, BIT0, 1);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RST_RPT_11AC, BIT0, 0);
+
+		CCKenable =  ODM_GetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT28);
+		if(CCKenable)//if(*pDM_Odm->pBandType == ODM_BAND_2_4G)
+		{
+			FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_Cck_fail;
+			FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_CCK_CCA + FalseAlmCnt->Cnt_OFDM_CCA;
+		}
+		else
+		{
+			FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail;
+			FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA;
+		}
+
+	}
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_OFDM_CCA=%d\n", FalseAlmCnt->Cnt_OFDM_CCA));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_CCK_CCA=%d\n", FalseAlmCnt->Cnt_CCK_CCA));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_CCA_all=%d\n", FalseAlmCnt->Cnt_CCA_all));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Ofdm_fail=%d\n", FalseAlmCnt->Cnt_Ofdm_fail));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Cck_fail=%d\n", FalseAlmCnt->Cnt_Cck_fail));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Cnt_Ofdm_fail=%d\n", FalseAlmCnt->Cnt_Ofdm_fail));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("odm_FalseAlarmCounterStatistics(): Total False Alarm=%d\n\n", FalseAlmCnt->Cnt_all));
+}
+
+//3============================================================
+//3 CCK Packet Detect Threshold
+//3============================================================
+
+VOID
+odm_PauseCCKPacketDetection(
+	IN		PVOID					pDM_VOID,
+	IN		PHYDM_PAUSE_TYPE		PauseType,
+	IN		PHYDM_PAUSE_LEVEL		pause_level,
+	IN		u1Byte					CCKPDThreshold
+)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection()=========> level = %d\n", pause_level));
+
+	if ((pDM_DigTable->pause_cckpd_level == 0) && (!(pDM_Odm->SupportAbility & ODM_BB_CCK_PD) || !(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Return: SupportAbility ODM_BB_CCK_PD or ODM_BB_FA_CNT is disabled\n"));
+		return;
+	}
+
+	if (pause_level > DM_DIG_MAX_PAUSE_TYPE) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, 
+			("odm_PauseCCKPacketDetection(): Return: Wrong pause level !!\n"));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): pause level = 0x%x, Current value = 0x%x\n", pDM_DigTable->pause_cckpd_level, CCKPDThreshold));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
+		pDM_DigTable->pause_cckpd_value[7], pDM_DigTable->pause_cckpd_value[6], pDM_DigTable->pause_cckpd_value[5], pDM_DigTable->pause_cckpd_value[4],
+		pDM_DigTable->pause_cckpd_value[3], pDM_DigTable->pause_cckpd_value[2], pDM_DigTable->pause_cckpd_value[1], pDM_DigTable->pause_cckpd_value[0]));
+
+	switch (PauseType) {
+	/* Pause CCK Packet Detection Threshold */
+	case PHYDM_PAUSE:
+	{
+		/* Disable CCK PD */
+		ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility & (~ODM_BB_CCK_PD));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): Pause CCK packet detection threshold !!\n"));
+
+		/* Backup original CCK PD threshold decided by CCK PD mechanism */
+		if (pDM_DigTable->pause_cckpd_level == 0) {
+			pDM_DigTable->CCKPDBackup = pDM_DigTable->CurCCK_CCAThres;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, 
+				("odm_PauseCCKPacketDetection(): Backup CCKPD  = 0x%x, new CCKPD = 0x%x\n", pDM_DigTable->CCKPDBackup, CCKPDThreshold));
+		}
+
+		/* Update pause level */
+		pDM_DigTable->pause_cckpd_level = (pDM_DigTable->pause_cckpd_level | BIT(pause_level));
+
+		/* Record CCK PD threshold */
+		pDM_DigTable->pause_cckpd_value[pause_level] = CCKPDThreshold;
+		
+		/* Write new CCK PD threshold */
+		if (BIT(pause_level + 1) > pDM_DigTable->pause_cckpd_level) {
+			ODM_Write_CCK_CCA_Thres(pDM_Odm, CCKPDThreshold);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): CCKPD of higher level = 0x%x\n", CCKPDThreshold));
+		}
+		break;
+	}
+	/* Resume CCK Packet Detection Threshold */
+	case PHYDM_RESUME:
+	{	
+		/* check if the level is illegal or not */
+		if ((pDM_DigTable->pause_cckpd_level & (BIT(pause_level))) != 0) {
+			pDM_DigTable->pause_cckpd_level = pDM_DigTable->pause_cckpd_level & (~(BIT(pause_level)));
+			pDM_DigTable->pause_cckpd_value[pause_level] = 0;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): Resume CCK PD !!\n"));
+		} else {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): Wrong resume level !!\n"));
+			break;
+		}
+
+		/* Resume DIG */
+		if (pDM_DigTable->pause_cckpd_level == 0) {
+			/* Write backup IGI value */
+			ODM_Write_CCK_CCA_Thres(pDM_Odm, pDM_DigTable->CCKPDBackup);
+			/* pDM_DigTable->bIgnoreDIG = TRUE; */
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): Write original CCKPD = 0x%x\n", pDM_DigTable->CCKPDBackup));
+
+			/* Enable DIG */
+			ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility | ODM_BB_CCK_PD);	
+			break;
+		}
+
+		if (BIT(pause_level) > pDM_DigTable->pause_cckpd_level) {
+			u1Byte	max_level;
+		
+			/* Calculate the maximum level now */
+			for (max_level = (pause_level - 1); max_level >= 0; max_level--) {
+				if ((pDM_DigTable->pause_cckpd_level & BIT(max_level)) > 0)
+					break;
+			}
+		
+			/* write CCKPD of lower level */
+			ODM_Write_CCK_CCA_Thres(pDM_Odm, pDM_DigTable->pause_cckpd_value[max_level]);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): Write CCKPD (0x%x) of level (%d)\n", 
+				pDM_DigTable->pause_cckpd_value[max_level], max_level));
+			break;
+		}
+		break;
+	}
+	default:
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): Wrong  type !!\n"));
+		break;
+	}	
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): pause level = 0x%x, Current value = 0x%x\n", pDM_DigTable->pause_cckpd_level, CCKPDThreshold));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
+		pDM_DigTable->pause_cckpd_value[7], pDM_DigTable->pause_cckpd_value[6], pDM_DigTable->pause_cckpd_value[5], pDM_DigTable->pause_cckpd_value[4],
+		pDM_DigTable->pause_cckpd_value[3], pDM_DigTable->pause_cckpd_value[2], pDM_DigTable->pause_cckpd_value[1], pDM_DigTable->pause_cckpd_value[0]));
+}
+
+
+VOID 
+odm_CCKPacketDetectionThresh(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u1Byte						CurCCK_CCAThres, RSSI_thd = 55;
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+//modify by Guo.Mingzhi 2011-12-29
+	if (pDM_Odm->bDualMacSmartConcurrent == TRUE)
+//	if (pDM_Odm->bDualMacSmartConcurrent == FALSE)
+		return;
+	if(pDM_Odm->bBtHsOperation)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh() write 0xcd for BT HS mode!!\n"));
+		ODM_Write_CCK_CCA_Thres(pDM_Odm, 0xcd);
+		return;
+	}
+#endif
+
+	if((!(pDM_Odm->SupportAbility & ODM_BB_CCK_PD)) ||(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh()  return==========\n"));
+#ifdef MCR_WIRELESS_EXTEND
+		ODM_Write_CCK_CCA_Thres(pDM_Odm, 0x43);
+#endif
+		return;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(pDM_Odm->ExtLNA)
+		return;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh()  ==========>\n"));
+
+	if (pDM_Odm->bLinked)
+	{
+		if (pDM_Odm->RSSI_Min > RSSI_thd)
+			CurCCK_CCAThres = 0xcd;
+		else if ((pDM_Odm->RSSI_Min <= RSSI_thd) && (pDM_Odm->RSSI_Min > 10))
+			CurCCK_CCAThres = 0x83;
+		else
+		{
+			if(FalseAlmCnt->Cnt_Cck_fail > 1000)
+				CurCCK_CCAThres = 0x83;
+			else
+				CurCCK_CCAThres = 0x40;
+		}
+	} else {
+		if(FalseAlmCnt->Cnt_Cck_fail > 1000)
+			CurCCK_CCAThres = 0x83;
+		else
+			CurCCK_CCAThres = 0x40;
+	}
+	
+#if (RTL8192D_SUPPORT==1) 
+	if((pDM_Odm->SupportICType == ODM_RTL8192D) && (*pDM_Odm->pBandType == ODM_BAND_2_4G))
+		ODM_Write_CCK_CCA_Thres_92D(pDM_Odm, CurCCK_CCAThres);
+	else
+#endif
+		ODM_Write_CCK_CCA_Thres(pDM_Odm, CurCCK_CCAThres);
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh()  CurCCK_CCAThres = 0x%x\n",CurCCK_CCAThres));
+}
+
+VOID
+ODM_Write_CCK_CCA_Thres(
+	IN	PVOID			pDM_VOID,
+	IN	u1Byte			CurCCK_CCAThres
+	)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	if(pDM_DigTable->CurCCK_CCAThres!=CurCCK_CCAThres)		//modify by Guo.Mingzhi 2012-01-03
+	{
+		ODM_Write1Byte(pDM_Odm, ODM_REG(CCK_CCA,pDM_Odm), CurCCK_CCAThres);
+	}
+	pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
+	pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+// <20130108, Kordan> E.g., With LNA used, we make the Rx power smaller to have a better EVM. (Asked by Willis)
+VOID
+odm_RFEControl(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN  u8Byte		RSSIVal
+	)
+{
+	PADAPTER		Adapter = (PADAPTER)pDM_Odm->Adapter;
+    HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	static u1Byte 	TRSW_HighPwr = 0;
+	 
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("===> odm_RFEControl, RSSI = %d, TRSW_HighPwr = 0x%X, pHalData->RFEType = %d\n",
+		         RSSIVal, TRSW_HighPwr, pHalData->RFEType ));
+
+    if (pHalData->RFEType == 3) {	   
+		
+        pDM_Odm->RSSI_TRSW = RSSIVal;
+
+        if (pDM_Odm->RSSI_TRSW >= pDM_Odm->RSSI_TRSW_H) 
+		{				 
+            TRSW_HighPwr = 1; // Switch to
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT1|BIT0, 0x1);  // Set ANTSW=1/ANTSWB=0  for SW control
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT9|BIT8, 0x3);  // Set ANTSW=1/ANTSWB=0  for SW control
+            
+        } 
+		else if (pDM_Odm->RSSI_TRSW <= pDM_Odm->RSSI_TRSW_L) 
+        {	  
+            TRSW_HighPwr = 0; // Switched back
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT1|BIT0, 0x1);  // Set ANTSW=1/ANTSWB=0  for SW control
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT9|BIT8, 0x0);  // Set ANTSW=1/ANTSWB=0  for SW control
+
+        }
+    }  
+
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("(pDM_Odm->RSSI_TRSW_H, pDM_Odm->RSSI_TRSW_L) = (%d, %d)\n", pDM_Odm->RSSI_TRSW_H, pDM_Odm->RSSI_TRSW_L));		
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("(RSSIVal, RSSIVal, pDM_Odm->RSSI_TRSW_iso) = (%d, %d, %d)\n", 
+				 RSSIVal, pDM_Odm->RSSI_TRSW_iso, pDM_Odm->RSSI_TRSW));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("<=== odm_RFEControl, RSSI = %d, TRSW_HighPwr = 0x%X\n", RSSIVal, TRSW_HighPwr));	
+}
+
+VOID
+odm_MPT_DIGWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	ODM_MPT_DIG(pDM_Odm);
+}
+
+VOID
+odm_MPT_DIGCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	  PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+
+	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+		#if USE_WORKITEM
+			PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
+		#else
+			ODM_MPT_DIG(pDM_Odm);
+		#endif
+	#else
+		PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
+	#endif
+
+}
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+VOID
+odm_MPT_DIGCallback(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if USE_WORKITEM
+	PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
+#else
+	ODM_MPT_DIG(pDM_Odm);
+#endif
+}
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)
+VOID
+odm_MPT_Write_DIG(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					CurIGValue
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_A,pDM_Odm), CurIGValue);
+
+	if(pDM_Odm->RFType > ODM_1T1R)
+		ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_B,pDM_Odm), CurIGValue);
+
+	if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+	{
+		ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_C,pDM_Odm), CurIGValue);
+		ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_D,pDM_Odm), CurIGValue);	
+	}
+
+	pDM_DigTable->CurIGValue = CurIGValue;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("CurIGValue = 0x%x\n", CurIGValue));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("pDM_Odm->RFType = 0x%x\n", pDM_Odm->RFType));
+}
+
+VOID
+ODM_MPT_DIG(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
+	u1Byte						DIG_Upper = 0x40, DIG_Lower = 0x20;
+	u4Byte						RXOK_cal;
+	u4Byte						RxPWDBAve_final;
+	u1Byte						IGI_A = 0x20, IGI_B = 0x20;
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	#if ODM_FIX_2G_DIG
+	IGI_A = 0x22;
+	IGI_B = 0x24;		
+	#endif
+	
+#else
+	if (!(pDM_Odm->priv->pshare->rf_ft_var.mp_specific && pDM_Odm->priv->pshare->mp_dig_on))
+		return;
+
+	if (*pDM_Odm->pBandType == ODM_BAND_5G)
+		DIG_Lower = 0x22;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("===> ODM_MPT_DIG, pBandType = %d\n", *pDM_Odm->pBandType));
+	
+#if (ODM_FIX_2G_DIG || (DM_ODM_SUPPORT_TYPE & ODM_AP))
+	if (*pDM_Odm->pBandType == ODM_BAND_5G || (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8822B))) // for 5G or 8814
+#else
+	if (1) // for both 2G/5G
+#endif
+		{
+		odm_FalseAlarmCounterStatistics(pDM_Odm);
+
+		RXOK_cal = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM;
+		RxPWDBAve_final = (RXOK_cal != 0)?pDM_Odm->RxPWDBAve/RXOK_cal:0;
+
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+		pDM_Odm->RxPWDBAve = 0;
+		pDM_Odm->MPDIG_2G = FALSE;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		pDM_Odm->Times_2G = 0;
+#endif
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("RX OK = %d\n", RXOK_cal));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("RSSI = %d\n", RxPWDBAve_final));
+	
+		if (RXOK_cal >= 70 && RxPWDBAve_final <= 40)
+		{
+			if (CurrentIGI > 0x24)
+				odm_MPT_Write_DIG(pDM_Odm, 0x24);
+		}
+		else
+		{
+			if(pFalseAlmCnt->Cnt_all > 1000){
+				CurrentIGI = CurrentIGI + 8;
+			}
+			else if(pFalseAlmCnt->Cnt_all > 200){
+				CurrentIGI = CurrentIGI + 4;
+			}
+			else if (pFalseAlmCnt->Cnt_all > 50){
+				CurrentIGI = CurrentIGI + 2;
+			}
+			else if (pFalseAlmCnt->Cnt_all < 2){
+				CurrentIGI = CurrentIGI - 2;
+			}
+			
+			if (CurrentIGI < DIG_Lower ){
+				CurrentIGI = DIG_Lower;
+			}
+
+			if(CurrentIGI > DIG_Upper){
+				CurrentIGI = DIG_Upper;
+			}
+
+			odm_MPT_Write_DIG(pDM_Odm, CurrentIGI);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("DIG = 0x%x, Cnt_all = %d, Cnt_Ofdm_fail = %d, Cnt_Cck_fail = %d\n", 
+				CurrentIGI, pFalseAlmCnt->Cnt_all, pFalseAlmCnt->Cnt_Ofdm_fail, pFalseAlmCnt->Cnt_Cck_fail));
+		}
+	}
+	else
+	{
+		if(pDM_Odm->MPDIG_2G == FALSE)
+		{
+			if((pDM_Odm->SupportPlatform & ODM_WIN) && !(pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8822B)))
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("===> Fix IGI\n"));
+				ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_A,pDM_Odm), IGI_A);
+				ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_B,pDM_Odm), IGI_B);
+				pDM_DigTable->CurIGValue = IGI_B;
+			}
+			else
+				odm_MPT_Write_DIG(pDM_Odm, IGI_A);
+		}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		pDM_Odm->Times_2G++;
+
+		if (pDM_Odm->Times_2G == 3)
+#endif
+		{
+			pDM_Odm->MPDIG_2G = TRUE;
+		}
+	}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+		odm_RFEControl(pDM_Odm, RxPWDBAve_final);
+#endif
+
+	ODM_SetTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 700);
+}
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.h
new file mode 100644
index 000000000..e7c89edb7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dig.h
@@ -0,0 +1,327 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMDIG_H__
+#define    __PHYDMDIG_H__
+
+#define DIG_VERSION	"1.8"	/*2015.07.01*/
+
+/* Pause DIG & CCKPD */
+#define		DM_DIG_MAX_PAUSE_TYPE		0x7
+
+typedef struct _Dynamic_Initial_Gain_Threshold_
+{
+	BOOLEAN		bStopDIG;		// for debug
+	BOOLEAN		bIgnoreDIG;
+	BOOLEAN		bPSDInProgress;
+
+	u1Byte		Dig_Enable_Flag;
+	u1Byte		Dig_Ext_Port_Stage;
+	
+	int		   	RssiLowThresh;
+	int		    	RssiHighThresh;
+
+	u4Byte		FALowThresh;
+	u4Byte		FAHighThresh;
+
+	u1Byte		CurSTAConnectState;
+	u1Byte		PreSTAConnectState;
+	u1Byte		CurMultiSTAConnectState;
+
+	u1Byte		PreIGValue;
+	u1Byte		CurIGValue;
+	u1Byte		BackupIGValue;		//MP DIG
+	u1Byte		BT30_CurIGI;
+	u1Byte		IGIBackup;
+
+	s1Byte		BackoffVal;
+	s1Byte		BackoffVal_range_max;
+	s1Byte		BackoffVal_range_min;
+	u1Byte		rx_gain_range_max;
+	u1Byte		rx_gain_range_min;
+	u1Byte		Rssi_val_min;
+
+	u1Byte		PreCCK_CCAThres;
+	u1Byte		CurCCK_CCAThres;
+	u1Byte		PreCCKPDState;
+	u1Byte		CurCCKPDState;
+	u1Byte		CCKPDBackup;
+	u1Byte		pause_cckpd_level;
+	u1Byte		pause_cckpd_value[DM_DIG_MAX_PAUSE_TYPE + 1];
+
+	u1Byte		LargeFAHit;
+	u1Byte		ForbiddenIGI;
+	u4Byte		Recover_cnt;
+
+	u1Byte		DIG_Dynamic_MIN_0;
+	u1Byte		DIG_Dynamic_MIN_1;
+	BOOLEAN		bMediaConnect_0;
+	BOOLEAN		bMediaConnect_1;
+
+	u4Byte		AntDiv_RSSI_max;
+	u4Byte		RSSI_max;
+
+	u1Byte		*bP2PInProcess;
+
+	u1Byte		pause_dig_level;
+	u1Byte		pause_dig_value[DM_DIG_MAX_PAUSE_TYPE + 1];
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	BOOLEAN		bTpTarget;
+	BOOLEAN		bNoiseEst;
+	u4Byte		TpTrainTH_min;
+	u1Byte		IGIOffset_A;
+	u1Byte		IGIOffset_B;
+#endif
+}DIG_T,*pDIG_T;
+
+typedef struct _FALSE_ALARM_STATISTICS{
+	u4Byte	Cnt_Parity_Fail;
+	u4Byte	Cnt_Rate_Illegal;
+	u4Byte	Cnt_Crc8_fail;
+	u4Byte	Cnt_Mcs_fail;
+	u4Byte	Cnt_Ofdm_fail;
+	u4Byte	Cnt_Ofdm_fail_pre;	//For RTL8881A
+	u4Byte	Cnt_Cck_fail;
+	u4Byte	Cnt_all;
+	u4Byte	Cnt_Fast_Fsync;
+	u4Byte	Cnt_SB_Search_fail;
+	u4Byte	Cnt_OFDM_CCA;
+	u4Byte	Cnt_CCK_CCA;
+	u4Byte	Cnt_CCA_all;
+	u4Byte	Cnt_BW_USC;	//Gary
+	u4Byte	Cnt_BW_LSC;	//Gary
+}FALSE_ALARM_STATISTICS, *PFALSE_ALARM_STATISTICS;
+
+typedef enum tag_Dynamic_Init_Gain_Operation_Type_Definition
+{
+	DIG_TYPE_THRESH_HIGH	= 0,
+	DIG_TYPE_THRESH_LOW	= 1,
+	DIG_TYPE_BACKOFF		= 2,
+	DIG_TYPE_RX_GAIN_MIN	= 3,
+	DIG_TYPE_RX_GAIN_MAX	= 4,
+	DIG_TYPE_ENABLE 		= 5,
+	DIG_TYPE_DISABLE 		= 6,	
+	DIG_OP_TYPE_MAX
+}DM_DIG_OP_E;
+
+/*
+typedef enum tag_CCK_Packet_Detection_Threshold_Type_Definition
+{
+	CCK_PD_STAGE_LowRssi = 0,
+	CCK_PD_STAGE_HighRssi = 1,
+	CCK_PD_STAGE_MAX = 3,
+}DM_CCK_PDTH_E;
+
+typedef enum tag_DIG_EXT_PORT_ALGO_Definition
+{
+	DIG_EXT_PORT_STAGE_0 = 0,
+	DIG_EXT_PORT_STAGE_1 = 1,
+	DIG_EXT_PORT_STAGE_2 = 2,
+	DIG_EXT_PORT_STAGE_3 = 3,
+	DIG_EXT_PORT_STAGE_MAX = 4,
+}DM_DIG_EXT_PORT_ALG_E;
+
+typedef enum tag_DIG_Connect_Definition
+{
+	DIG_STA_DISCONNECT = 0,	
+	DIG_STA_CONNECT = 1,
+	DIG_STA_BEFORE_CONNECT = 2,
+	DIG_MultiSTA_DISCONNECT = 3,
+	DIG_MultiSTA_CONNECT = 4,
+	DIG_CONNECT_MAX
+}DM_DIG_CONNECT_E;
+
+
+#define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;}
+
+#define DM_MultiSTA_InitGainChangeNotify_CONNECT(_ADAPTER)	\
+	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_CONNECT)
+
+#define DM_MultiSTA_InitGainChangeNotify_DISCONNECT(_ADAPTER)	\
+	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_DISCONNECT)
+*/
+
+typedef enum tag_PHYDM_Pause_Type {
+	PHYDM_PAUSE = BIT0,
+	PHYDM_RESUME = BIT1
+} PHYDM_PAUSE_TYPE;
+
+typedef enum tag_PHYDM_Pause_Level {
+/* number of pause level can't exceed DM_DIG_MAX_PAUSE_TYPE */
+	PHYDM_PAUSE_LEVEL_0 = 0,
+	PHYDM_PAUSE_LEVEL_1 = 1,
+	PHYDM_PAUSE_LEVEL_2 = 2,
+	PHYDM_PAUSE_LEVEL_3 = 3,
+	PHYDM_PAUSE_LEVEL_4 = 4,
+	PHYDM_PAUSE_LEVEL_5 = 5,
+	PHYDM_PAUSE_LEVEL_6 = 6,
+	PHYDM_PAUSE_LEVEL_7 = DM_DIG_MAX_PAUSE_TYPE		/* maximum level */
+} PHYDM_PAUSE_LEVEL;
+
+
+#define		DM_DIG_THRESH_HIGH			40
+#define		DM_DIG_THRESH_LOW			35
+
+#define		DM_FALSEALARM_THRESH_LOW	400
+#define		DM_FALSEALARM_THRESH_HIGH	1000
+
+#define		DM_DIG_MAX_NIC				0x3e
+#define		DM_DIG_MIN_NIC				0x1e //0x22//0x1c
+#define		DM_DIG_MAX_OF_MIN_NIC		0x3e
+
+#define		DM_DIG_MAX_AP					0x3e
+#define		DM_DIG_MIN_AP					0x1c
+#define		DM_DIG_MAX_OF_MIN			0x2A	//0x32
+#define		DM_DIG_MIN_AP_DFS				0x20
+
+#define		DM_DIG_MAX_NIC_HP			0x46
+#define		DM_DIG_MIN_NIC_HP				0x2e
+
+#define		DM_DIG_MAX_AP_HP				0x42
+#define		DM_DIG_MIN_AP_HP				0x30
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+#define		DM_DIG_MAX_AP_COVERAGR		0x26
+#define		DM_DIG_MIN_AP_COVERAGE		0x1c
+#define		DM_DIG_MAX_OF_MIN_COVERAGE	0x22
+
+#define		DM_DIG_TP_Target_TH0			500
+#define		DM_DIG_TP_Target_TH1			1000
+#define		DM_DIG_TP_Training_Period		10
+#endif
+
+//vivi 92c&92d has different definition, 20110504
+//this is for 92c
+#if (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+	#define		DM_DIG_FA_TH0				0x80//0x20
+	#else
+	#define		DM_DIG_FA_TH0				0x200//0x20
+	#endif
+#else
+	#define		DM_DIG_FA_TH0				0x200//0x20
+#endif
+
+#define		DM_DIG_FA_TH1					0x300
+#define		DM_DIG_FA_TH2					0x400
+//this is for 92d
+#define		DM_DIG_FA_TH0_92D				0x100
+#define		DM_DIG_FA_TH1_92D				0x400
+#define		DM_DIG_FA_TH2_92D				0x600
+
+#define		DM_DIG_BACKOFF_MAX			12
+#define		DM_DIG_BACKOFF_MIN			-4
+#define		DM_DIG_BACKOFF_DEFAULT		10
+
+#define 		DM_DIG_FA_TH0_LPS				4 //-> 4 in lps
+#define 		DM_DIG_FA_TH1_LPS				15 //-> 15 lps
+#define 		DM_DIG_FA_TH2_LPS				30 //-> 30 lps
+#define 		RSSI_OFFSET_DIG				0x05
+
+VOID
+ODM_ChangeDynamicInitGainThresh(
+	IN		PVOID					pDM_VOID,
+	IN		u4Byte  					DM_Type,
+	IN		u4Byte 					DM_Value
+	);
+
+VOID
+ODM_Write_DIG(
+	IN		PVOID					pDM_VOID, 	
+	IN		u1Byte					CurrentIGI
+	);
+
+VOID
+odm_PauseDIG(
+	IN		PVOID					pDM_VOID,
+	IN		PHYDM_PAUSE_TYPE		PauseType,
+	IN		PHYDM_PAUSE_LEVEL		pause_level,
+	IN		u1Byte					IGIValue
+	);
+
+VOID
+odm_DIGInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID	
+odm_DIG(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_DIGbyRSSI_LPS(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_FalseAlarmCounterStatistics(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_PauseCCKPacketDetection(
+	IN		PVOID					pDM_VOID,
+	IN		PHYDM_PAUSE_TYPE		PauseType,
+	IN		PHYDM_PAUSE_LEVEL		pause_level,
+	IN		u1Byte					CCKPDThreshold
+	);
+
+VOID 
+odm_CCKPacketDetectionThresh(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+ODM_Write_CCK_CCA_Thres(
+	IN		PVOID					pDM_VOID, 
+	IN		u1Byte					CurCCK_CCAThres
+	);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+odm_MPT_DIGCallback(
+	PRT_TIMER						pTimer
+);
+
+VOID
+odm_MPT_DIGWorkItemCallback(
+    IN 		PVOID            			pContext
+    );
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+VOID
+odm_MPT_DIGCallback(
+	IN		PVOID					pDM_VOID
+);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)
+VOID
+ODM_MPT_DIG(
+	IN		PVOID					pDM_VOID
+);
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.c
new file mode 100644
index 000000000..ab01c4760
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.c
@@ -0,0 +1,219 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+VOID 
+odm_DynamicBBPowerSavingInit(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
+
+	pDM_PSTable->PreCCAState = CCA_MAX;
+	pDM_PSTable->CurCCAState = CCA_MAX;
+	pDM_PSTable->PreRFState = RF_MAX;
+	pDM_PSTable->CurRFState = RF_MAX;
+	pDM_PSTable->Rssi_val_min = 0;
+	pDM_PSTable->initialize = 0;
+}
+
+
+VOID
+odm_DynamicBBPowerSaving(
+	IN		PVOID					pDM_VOID
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	if (pDM_Odm->SupportICType != ODM_RTL8723A)
+		return;
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_SAVE))
+		return;
+	if(!(pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE)))
+		return;
+	
+	//1 2.Power Saving for 92C
+	if((pDM_Odm->SupportICType == ODM_RTL8192C) &&(pDM_Odm->RFType == ODM_2T2R))
+	{
+		odm_1R_CCA(pDM_Odm);
+	}
+	
+	// 20100628 Joseph: Turn off BB power save for 88CE because it makesthroughput unstable.
+	// 20100831 Joseph: Turn ON BB power save again after modifying AGC delay from 900ns ot 600ns.
+	//1 3.Power Saving for 88C
+	else
+	{
+		ODM_RF_Saving(pDM_Odm, FALSE);
+	}
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	
+}
+
+VOID
+odm_1R_CCA(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
+
+	if(pDM_Odm->RSSI_Min!= 0xFF)
+	{
+		 
+		if(pDM_PSTable->PreCCAState == CCA_2R)
+		{
+			if(pDM_Odm->RSSI_Min >= 35)
+				pDM_PSTable->CurCCAState = CCA_1R;
+			else
+				pDM_PSTable->CurCCAState = CCA_2R;
+			
+		}
+		else{
+			if(pDM_Odm->RSSI_Min <= 30)
+				pDM_PSTable->CurCCAState = CCA_2R;
+			else
+				pDM_PSTable->CurCCAState = CCA_1R;
+		}
+	}
+	else{
+		pDM_PSTable->CurCCAState=CCA_MAX;
+	}
+	
+	if(pDM_PSTable->PreCCAState != pDM_PSTable->CurCCAState)
+	{
+		if(pDM_PSTable->CurCCAState == CCA_1R)
+		{
+			if(  pDM_Odm->RFType ==ODM_2T2R )
+			{
+				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x13);
+				//PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20);
+			}
+			else
+			{
+				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x23);
+				//PHY_SetBBReg(pAdapter, 0xe70, 0x7fc00000, 0x10c); // Set RegE70[30:22] = 9b'100001100
+			}
+		}
+		else
+		{
+			ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x33);
+			//PHY_SetBBReg(pAdapter,0xe70, bMaskByte3, 0x63);
+		}
+		pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
+	}
+}
+
+void
+ODM_RF_Saving(
+	IN		PVOID					pDM_VOID,
+	IN	u1Byte		bForceInNormal 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
+	u1Byte	Rssi_Up_bound = 30 ;
+	u1Byte	Rssi_Low_bound = 25;
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if(pDM_Odm->PatchID == 40 ) //RT_CID_819x_FUNAI_TV
+	{
+		Rssi_Up_bound = 50 ;
+		Rssi_Low_bound = 45;
+	}
+#endif
+	if(pDM_PSTable->initialize == 0){
+		
+		pDM_PSTable->Reg874 = (ODM_GetBBReg(pDM_Odm, 0x874, bMaskDWord)&0x1CC000)>>14;
+		pDM_PSTable->RegC70 = (ODM_GetBBReg(pDM_Odm, 0xc70, bMaskDWord)&BIT3)>>3;
+		pDM_PSTable->Reg85C = (ODM_GetBBReg(pDM_Odm, 0x85c, bMaskDWord)&0xFF000000)>>24;
+		pDM_PSTable->RegA74 = (ODM_GetBBReg(pDM_Odm, 0xa74, bMaskDWord)&0xF000)>>12;
+		//Reg818 = PHY_QueryBBReg(pAdapter, 0x818, bMaskDWord);
+		pDM_PSTable->initialize = 1;
+	}
+
+	if(!bForceInNormal)
+	{
+		if(pDM_Odm->RSSI_Min != 0xFF)
+		{			 
+			if(pDM_PSTable->PreRFState == RF_Normal)
+			{
+				if(pDM_Odm->RSSI_Min >= Rssi_Up_bound)
+					pDM_PSTable->CurRFState = RF_Save;
+				else
+					pDM_PSTable->CurRFState = RF_Normal;
+			}
+			else{
+				if(pDM_Odm->RSSI_Min <= Rssi_Low_bound)
+					pDM_PSTable->CurRFState = RF_Normal;
+				else
+					pDM_PSTable->CurRFState = RF_Save;
+			}
+		}
+		else
+			pDM_PSTable->CurRFState=RF_MAX;
+	}
+	else
+	{
+		pDM_PSTable->CurRFState = RF_Normal;
+	}
+	
+	if(pDM_PSTable->PreRFState != pDM_PSTable->CurRFState)
+	{
+		if(pDM_PSTable->CurRFState == RF_Save)
+		{
+			// <tynli_note> 8723 RSSI report will be wrong. Set 0x874[5]=1 when enter BB power saving mode.
+			// Suggested by SD3 Yu-Nan. 2011.01.20.
+			if(pDM_Odm->SupportICType == ODM_RTL8723A)
+			{
+				ODM_SetBBReg(pDM_Odm, 0x874  , BIT5, 0x1); //Reg874[5]=1b'1
+			}
+			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1C0000, 0x2); //Reg874[20:18]=3'b010
+			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, 0); //RegC70[3]=1'b0
+			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, 0x63); //Reg85C[31:24]=0x63
+			ODM_SetBBReg(pDM_Odm, 0x874, 0xC000, 0x2); //Reg874[15:14]=2'b10
+			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, 0x3); //RegA75[7:4]=0x3
+			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0); //Reg818[28]=1'b0
+			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x1); //Reg818[28]=1'b1
+		}
+		else
+		{
+			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1CC000, pDM_PSTable->Reg874); 
+			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, pDM_PSTable->RegC70); 
+			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, pDM_PSTable->Reg85C);
+			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, pDM_PSTable->RegA74); 
+			ODM_SetBBReg(pDM_Odm,0x818, BIT28, 0x0);  
+
+			if(pDM_Odm->SupportICType == ODM_RTL8723A)
+			{
+				ODM_SetBBReg(pDM_Odm,0x874  , BIT5, 0x0); //Reg874[5]=1b'0
+			}
+		}
+		pDM_PSTable->PreRFState =pDM_PSTable->CurRFState;
+	}
+#endif	
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.h
new file mode 100644
index 000000000..365c17181
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamicbbpowersaving.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMDYNAMICBBPOWERSAVING_H__
+#define    __PHYDMDYNAMICBBPOWERSAVING_H__
+
+#define DYNAMIC_BBPWRSAV_VERSION	"1.0"
+
+typedef struct _Dynamic_Power_Saving_
+{
+	u1Byte		PreCCAState;
+	u1Byte		CurCCAState;
+
+	u1Byte		PreRFState;
+	u1Byte		CurRFState;
+
+	int		    Rssi_val_min;
+	
+	u1Byte		initialize;
+	u4Byte		Reg874,RegC70,Reg85C,RegA74;
+	
+}PS_T,*pPS_T;
+
+#define dm_RF_Saving	ODM_RF_Saving
+
+void ODM_RF_Saving(
+	IN		PVOID					pDM_VOID,
+	IN	u1Byte		bForceInNormal
+);
+
+VOID 
+odm_DynamicBBPowerSavingInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicBBPowerSaving(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_1R_CCA(
+	IN		PVOID					pDM_VOID
+	);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.c
new file mode 100644
index 000000000..7a9d3ec83
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.c
@@ -0,0 +1,633 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+VOID 
+odm_DynamicTxPowerInit(
+	IN		PVOID					pDM_VOID	
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+
+	#if DEV_BUS_TYPE==RT_USB_INTERFACE					
+	if(RT_GetInterfaceSelection(Adapter) == INTF_SEL1_USB_High_Power)
+	{
+		odm_DynamicTxPowerSavePowerIndex(pDM_Odm);
+		pMgntInfo->bDynamicTxPowerEnable = TRUE;
+	}		
+	else	
+	#else
+	//so 92c pci do not need dynamic tx power? vivi check it later
+	if(IS_HARDWARE_TYPE_8192D(Adapter))
+		pMgntInfo->bDynamicTxPowerEnable = TRUE;
+	else
+		pMgntInfo->bDynamicTxPowerEnable = FALSE;
+	#endif
+	
+
+	pHalData->LastDTPLvl = TxHighPwrLevel_Normal;
+	pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+
+#endif
+	
+}
+
+VOID
+odm_DynamicTxPowerSavePowerIndex(
+	IN		PVOID					pDM_VOID	
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	u1Byte		index;
+	u4Byte		Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	for(index = 0; index< 6; index++)
+		pHalData->PowerIndex_backup[index] = PlatformEFIORead1Byte(Adapter, Power_Index_REG[index]);
+	
+	
+#endif
+#endif
+}
+
+VOID
+odm_DynamicTxPowerRestorePowerIndex(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	u1Byte			index;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	for(index = 0; index< 6; index++)
+		PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], pHalData->PowerIndex_backup[index]);
+
+
+#endif
+#endif
+}
+
+VOID
+odm_DynamicTxPowerWritePowerIndex(
+	IN		PVOID					pDM_VOID, 
+	IN 	u1Byte		Value)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			index;
+	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+	for(index = 0; index< 6; index++)
+		//PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], Value);
+		ODM_Write1Byte(pDM_Odm, Power_Index_REG[index], Value);
+
+}
+
+
+VOID 
+odm_DynamicTxPower(
+	IN		PVOID					pDM_VOID
+	)
+{
+	// 
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+	//PADAPTER		pAdapter = pDM_Odm->Adapter;
+//	prtl8192cd_priv	priv		= pDM_Odm->priv;
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))
+		return;
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+		case	ODM_CE:
+			odm_DynamicTxPowerNIC(pDM_Odm);
+			break;	
+		case	ODM_AP:
+			odm_DynamicTxPowerAP(pDM_Odm);
+			break;		
+
+		case	ODM_ADSL:
+			//odm_DIGAP(pDM_Odm);
+			break;	
+	}
+
+	
+}
+
+
+VOID 
+odm_DynamicTxPowerNIC(
+	IN		PVOID					pDM_VOID
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))
+		return;
+	
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192C)	
+	{
+		odm_DynamicTxPower_92C(pDM_Odm);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		odm_DynamicTxPower_92D(pDM_Odm);
+	}
+	else if (pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+		PADAPTER		Adapter	 =  pDM_Odm->Adapter;
+		PMGNT_INFO		pMgntInfo = GetDefaultMgntInfo(Adapter);
+
+		if (pMgntInfo->RegRspPwr == 1)
+		{
+			if(pDM_Odm->RSSI_Min > 60)
+			{
+				ODM_SetMACReg(pDM_Odm, ODM_REG_RESP_TX_11AC, BIT20|BIT19|BIT18, 1); // Resp TXAGC offset = -3dB
+
+			}
+			else if(pDM_Odm->RSSI_Min < 55)
+			{
+				ODM_SetMACReg(pDM_Odm, ODM_REG_RESP_TX_11AC, BIT20|BIT19|BIT18, 0); // Resp TXAGC offset = 0dB
+			}
+		}
+#endif
+	}
+#endif	
+}
+
+VOID 
+odm_DynamicTxPowerAP(
+	IN		PVOID					pDM_VOID
+
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+//#if ((RTL8192C_SUPPORT==1) || (RTL8192D_SUPPORT==1) || (RTL8188E_SUPPORT==1) || (RTL8812E_SUPPORT==1))
+
+
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+	s4Byte i;
+	s2Byte pwr_thd = TX_POWER_NEAR_FIELD_THRESH_AP;
+
+	if(!priv->pshare->rf_ft_var.tx_pwr_ctrl)
+		return;
+	
+#if ((RTL8812E_SUPPORT==1) || (RTL8881A_SUPPORT==1) || (RTL8814A_SUPPORT==1))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812 | ODM_RTL8881A | ODM_RTL8814A))
+		pwr_thd = TX_POWER_NEAR_FIELD_THRESH_8812;
+#endif
+
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_92C_SUPPORT)
+	if(CHIP_VER_92X_SERIES(priv))
+	{
+#ifdef HIGH_POWER_EXT_PA
+	if(pDM_Odm->ExtPA)
+		tx_power_control(priv);
+#endif		
+	}
+#endif	
+	/*
+	 *	Check if station is near by to use lower tx power
+	 */
+
+	if ((priv->up_time % 3) == 0 )  {
+		int disable_pwr_ctrl = ((pDM_Odm->FalseAlmCnt.Cnt_all > 1000 ) || ((pDM_Odm->FalseAlmCnt.Cnt_all > 300 ) && ((RTL_R8(0xc50) & 0x7f) >= 0x32))) ? 1 : 0;
+			
+		for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++){
+			PSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];
+			if(IS_STA_VALID(pstat) ) {
+					if(disable_pwr_ctrl)
+						pstat->hp_level = 0;
+					 else if ((pstat->hp_level == 0) && (pstat->rssi > pwr_thd))
+					pstat->hp_level = 1;
+						else if ((pstat->hp_level == 1) && (pstat->rssi < (pwr_thd-8)))
+					pstat->hp_level = 0;
+			}
+		}
+
+#if defined(CONFIG_WLAN_HAL_8192EE)
+		if (GET_CHIP_VER(priv) == VERSION_8192E) {
+			if( !disable_pwr_ctrl && (pDM_Odm->RSSI_Min != 0xff) ) {
+				if(pDM_Odm->RSSI_Min > pwr_thd)
+					RRSR_power_control_11n(priv,  1 );
+				else if(pDM_Odm->RSSI_Min < (pwr_thd-8))
+					RRSR_power_control_11n(priv,  0 );
+			} else {
+					RRSR_power_control_11n(priv,  0 );
+			}
+		}
+#endif			
+
+#ifdef CONFIG_WLAN_HAL_8814AE
+		if (GET_CHIP_VER(priv) == VERSION_8814A) {
+			if (!disable_pwr_ctrl && (pDM_Odm->RSSI_Min != 0xff)) {
+				if (pDM_Odm->RSSI_Min > pwr_thd)
+					RRSR_power_control_14(priv,  1);
+				else if (pDM_Odm->RSSI_Min < (pwr_thd-8))
+					RRSR_power_control_14(priv,  0);
+			} else {
+					RRSR_power_control_14(priv,  0);
+			}
+		}
+#endif		
+
+	}
+//#endif	
+
+#endif	
+}
+
+
+VOID 
+odm_DynamicTxPower_92C(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	s4Byte				UndecoratedSmoothedPWDB;
+
+	// 2012/01/12 MH According to Luke's suggestion, only high power will support the feature.
+	if (pDM_Odm->ExtPA == FALSE)
+		return;
+
+	// STA not connected and AP not connected
+	if((!pMgntInfo->bMediaConnect) &&	
+		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("Not connected to any \n"));
+		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+		//the LastDTPlvl should reset when disconnect, 
+		//otherwise the tx power level wouldn't change when disconnect and connect again.
+		// Maddest 20091220.
+		 pHalData->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+
+#if (INTEL_PROXIMITY_SUPPORT == 1)
+	// Intel set fixed tx power 
+	if(pMgntInfo->IntelProximityModeInfo.PowerOutput > 0)
+	{
+		switch(pMgntInfo->IntelProximityModeInfo.PowerOutput){
+			case 1:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_100\n"));
+				break;
+			case 2:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_70;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_70\n"));
+				break;
+			case 3:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_50;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_50\n"));
+				break;
+			case 4:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_35;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_35\n"));
+				break;
+			case 5:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_15;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_15\n"));
+				break;
+			default:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_100\n"));
+				break;
+		}		
+	}
+	else
+#endif		
+	{ 
+		if(	(pMgntInfo->bDynamicTxPowerEnable != TRUE) ||
+			pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		}
+		else
+		{
+			if(pMgntInfo->bMediaConnect)	// Default port
+			{
+				if(ACTING_AS_AP(Adapter) || ACTING_AS_IBSS(Adapter))
+				{
+					UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+				}
+				else
+				{
+					UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+				}
+			}
+			else // associated entry pwdb
+			{	
+				UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+			}
+				
+			if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+			{
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+			}
+			else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+				(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+			{
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+			}
+			else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+			{
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+			}
+		}
+	}
+	if( pHalData->DynamicTxHighPowerLvl != pHalData->LastDTPLvl )
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192C() Channel = %d \n" , pHalData->CurrentChannel));
+		PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+		if(	(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal) &&
+			(pHalData->LastDTPLvl == TxHighPwrLevel_Level1 || pHalData->LastDTPLvl == TxHighPwrLevel_Level2)) //TxHighPwrLevel_Normal
+			odm_DynamicTxPowerRestorePowerIndex(pDM_Odm);
+		else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
+			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x14);
+		else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
+			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x10);
+	}
+	pHalData->LastDTPLvl = pHalData->DynamicTxHighPowerLvl;
+
+	
+
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+}
+
+
+VOID 
+odm_DynamicTxPower_92D(
+	IN		PVOID					pDM_VOID
+	)
+{
+#if (RTL8192D_SUPPORT==1)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	s4Byte				UndecoratedSmoothedPWDB;
+
+	PADAPTER	BuddyAdapter = Adapter->BuddyAdapter;
+	BOOLEAN		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(Adapter);
+	u1Byte		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
+
+	// 2012/01/12 MH According to Luke's suggestion, only high power will support the feature.
+	if (pDM_Odm->ExtPA == FALSE)
+		return;
+
+	// If dynamic high power is disabled.
+	if( (pMgntInfo->bDynamicTxPowerEnable != TRUE) ||
+		pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)
+	{
+		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		return;
+	}
+
+	// STA not connected and AP not connected
+	if((!pMgntInfo->bMediaConnect) &&	
+		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("Not connected to any \n"));
+		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+		//the LastDTPlvl should reset when disconnect, 
+		//otherwise the tx power level wouldn't change when disconnect and connect again.
+		// Maddest 20091220.
+		 pHalData->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+	
+	if(pMgntInfo->bMediaConnect)	// Default port
+	{
+		if(ACTING_AS_AP(Adapter) || pMgntInfo->mIbss)
+		{
+			UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+	}
+	else // associated entry pwdb
+	{	
+		UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+	}
+	
+	if(IS_HARDWARE_TYPE_8192D(Adapter) && GET_HAL_DATA(Adapter)->CurrentBandType == 1){
+		if(UndecoratedSmoothedPWDB >= 0x33)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB <0x33) &&
+			(UndecoratedSmoothedPWDB >= 0x2b) )
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < 0x2b)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
+		}
+
+	}
+	else
+	
+	{
+		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+		}
+
+	}
+
+//sherry  delete flag 20110517
+	if(bGetValueFromBuddyAdapter)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 1 \n"));
+		if(Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() change value \n"));
+			HighPowerLvlBackForMac0 = pHalData->DynamicTxHighPowerLvl;
+			pHalData->DynamicTxHighPowerLvl = Adapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP;
+			PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+			pHalData->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
+			Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = FALSE;
+		}						
+	}
+
+	if( (pHalData->DynamicTxHighPowerLvl != pHalData->LastDTPLvl) )
+	{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192S() Channel = %d \n" , pHalData->CurrentChannel));
+			if(Adapter->DualMacSmartConcurrent == TRUE)
+			{
+				if(BuddyAdapter == NULL)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter == NULL case \n"));
+					if(!Adapter->bSlaveOfDMSP)
+					{
+						PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+					}
+				}
+				else
+				{
+					if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMSP \n"));
+						if(Adapter->bSlaveOfDMSP)
+						{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() bslave case  \n"));
+							BuddyAdapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = TRUE;
+							BuddyAdapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP = pHalData->DynamicTxHighPowerLvl;
+						}
+						else
+						{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() master case  \n"));					
+							if(!bGetValueFromBuddyAdapter)
+							{
+								ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 0 \n"));
+								PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+							}
+						}
+					}
+					else
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMDP\n"));
+						PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+					}
+				}
+			}
+			else
+			{
+				PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+			}
+
+		}
+	pHalData->LastDTPLvl = pHalData->DynamicTxHighPowerLvl;
+
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#endif
+}
+
+VOID 
+odm_DynamicTxPower_8821(
+	IN		PVOID			pDM_VOID,	
+	IN		pu1Byte			pDesc,
+	IN		u1Byte			macId	
+	)
+{
+#if (RTL8821A_SUPPORT == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PSTA_INFO_T		pEntry;
+	u1Byte			reg0xc56_byte;
+	u1Byte			reg0xe56_byte;
+	u1Byte			txpwr_offset = 0;
+	
+	pEntry = pDM_Odm->pODM_StaInfo[macId];	
+
+	reg0xc56_byte = ODM_Read1Byte(pDM_Odm, 0xc56);
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("reg0xc56_byte=%d\n", reg0xc56_byte));
+
+	if (pEntry[macId].rssi_stat.UndecoratedSmoothedPWDB > 85) {
+
+		/* Avoid TXAGC error after TX power offset is applied.
+		For example: Reg0xc56=0x6, if txpwr_offset=3( reduce 11dB )
+		Total power = 6-11= -5( overflow!! ), PA may be burned !
+		so txpwr_offset should be adjusted by Reg0xc56*/
+		
+		if (reg0xc56_byte < 7)
+			txpwr_offset = 1;
+		else if (reg0xc56_byte < 11)
+			txpwr_offset = 2;
+		else
+			txpwr_offset = 3;
+		
+		SET_TX_DESC_TX_POWER_OFFSET_8812(pDesc, txpwr_offset);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("odm_DynamicTxPower_8821: RSSI=%d, txpwr_offset=%d\n", pEntry[macId].rssi_stat.UndecoratedSmoothedPWDB, txpwr_offset));
+
+	} else{
+		SET_TX_DESC_TX_POWER_OFFSET_8812(pDesc, txpwr_offset);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("odm_DynamicTxPower_8821: RSSI=%d, txpwr_offset=%d\n", pEntry[macId].rssi_stat.UndecoratedSmoothedPWDB, txpwr_offset));
+
+	}
+#endif	/*#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)*/
+#endif	/*#if (RTL8821A_SUPPORT==1)*/
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.h
new file mode 100644
index 000000000..db61bf85d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_dynamictxpower.h
@@ -0,0 +1,98 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMDYNAMICTXPOWER_H__
+#define    __PHYDMDYNAMICTXPOWER_H__
+
+/*#define DYNAMIC_TXPWR_VERSION	"1.0"*/
+#define DYNAMIC_TXPWR_VERSION	"1.1" /*2015.01.13*/
+
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
+#define		TX_POWER_NEAR_FIELD_THRESH_AP		0x3F
+#define		TX_POWER_NEAR_FIELD_THRESH_8812	60
+
+#define		TxHighPwrLevel_Normal		0	
+#define		TxHighPwrLevel_Level1		1
+#define		TxHighPwrLevel_Level2		2
+#define		TxHighPwrLevel_BT1			3
+#define		TxHighPwrLevel_BT2			4
+#define		TxHighPwrLevel_15			5
+#define		TxHighPwrLevel_35			6
+#define		TxHighPwrLevel_50			7
+#define		TxHighPwrLevel_70			8
+#define		TxHighPwrLevel_100			9
+
+VOID 
+odm_DynamicTxPowerInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_DynamicTxPowerRestorePowerIndex(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPowerNIC(
+	IN		PVOID					pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+VOID
+odm_DynamicTxPowerSavePowerIndex(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_DynamicTxPowerWritePowerIndex(
+	IN		PVOID					pDM_VOID, 
+	IN 	u1Byte		Value);
+
+VOID 
+odm_DynamicTxPower_92C(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPower_92D(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPower_8821(
+	IN		PVOID					pDM_VOID,	
+	IN		pu1Byte					pDesc,
+	IN		u1Byte					macId
+	);
+
+#endif
+
+VOID 
+odm_DynamicTxPower(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPowerAP(
+	IN		PVOID					pDM_VOID
+	);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.c
new file mode 100644
index 000000000..6d3dc6d38
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.c
@@ -0,0 +1,835 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+VOID
+ODM_EdcaTurboInit(
+	IN 	PVOID	 	pDM_VOID)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
+	PADAPTER	Adapter = NULL;
+	HAL_DATA_TYPE	*pHalData = NULL;
+
+	if(pDM_Odm->Adapter==NULL)	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EdcaTurboInit fail!!!\n"));
+		return;
+	}
+
+	Adapter=pDM_Odm->Adapter;
+	pHalData=GET_HAL_DATA(Adapter);
+
+	pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;	
+	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = FALSE;
+	pHalData->bIsAnyNonBEPkts = FALSE;
+	
+#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
+	PADAPTER	Adapter = pDM_Odm->Adapter;	
+	pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;	
+	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = FALSE;
+	Adapter->recvpriv.bIsAnyNonBEPkts =FALSE;
+
+#endif	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VO PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VO_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VI PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VI_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BK PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BK_PARAM)));
+
+	
+}	// ODM_InitEdcaTurbo
+
+VOID
+odm_EdcaTurboCheck(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	// 
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("odm_EdcaTurboCheck========================>\n"));
+
+	if(!(pDM_Odm->SupportAbility& ODM_MAC_EDCA_TURBO ))
+		return;
+
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+			odm_EdcaTurboCheckMP(pDM_Odm);
+#endif
+			break;
+
+		case	ODM_CE:
+#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
+			odm_EdcaTurboCheckCE(pDM_Odm);
+#endif
+			break;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("<========================odm_EdcaTurboCheck\n"));
+
+}	// odm_CheckEdcaTurbo
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
+
+
+VOID
+odm_EdcaTurboCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	u32	EDCA_BE_UL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[pMgntInfo->IOTPeer];
+	u32	EDCA_BE_DL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[pMgntInfo->IOTPeer];
+	u32	ICType=pDM_Odm->SupportICType;
+	u32	IOTPeer=0;
+	u8	WirelessMode=0xFF;                   //invalid value
+	u32 	trafficIndex;
+	u32	edca_param;
+	u64	cur_tx_bytes = 0;
+	u64	cur_rx_bytes = 0;
+	u8	bbtchange = _FALSE;
+	u8	bBiasOnRx = _FALSE;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	struct dvobj_priv		*pdvobjpriv = adapter_to_dvobj(Adapter);
+	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
+	struct recv_priv		*precvpriv = &(Adapter->recvpriv);
+	struct registry_priv	*pregpriv = &Adapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(pDM_Odm->bLinked != _TRUE)
+	{
+		precvpriv->bIsAnyNonBEPkts = _FALSE;
+		return;
+	}
+
+	if ((pregpriv->wifi_spec == 1) )//|| (pmlmeinfo->HT_enable == 0))
+	{
+		precvpriv->bIsAnyNonBEPkts = _FALSE;
+		return;
+	}
+
+	if(pDM_Odm->pWirelessMode!=NULL)
+		WirelessMode=*(pDM_Odm->pWirelessMode);
+
+	IOTPeer = pmlmeinfo->assoc_AP_vendor;
+
+	if (IOTPeer >=  HT_IOT_PEER_MAX)
+	{
+		precvpriv->bIsAnyNonBEPkts = _FALSE;
+		return;
+	}
+
+	if(	(pDM_Odm->SupportICType == ODM_RTL8192C) ||
+		(pDM_Odm->SupportICType == ODM_RTL8723A) ||
+		(pDM_Odm->SupportICType == ODM_RTL8188E))
+	{
+		if((IOTPeer == HT_IOT_PEER_RALINK)||(IOTPeer == HT_IOT_PEER_ATHEROS))
+			bBiasOnRx = _TRUE;
+	}
+
+	// Check if the status needs to be changed.
+	if((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
+	{
+		cur_tx_bytes = pdvobjpriv->traffic_stat.cur_tx_bytes;
+		cur_rx_bytes = pdvobjpriv->traffic_stat.cur_rx_bytes;
+
+		//traffic, TX or RX
+		if(bBiasOnRx)
+		{
+			if (cur_tx_bytes > (cur_rx_bytes << 2))
+			{ // Uplink TP is present.
+				trafficIndex = UP_LINK; 
+			}
+			else
+			{ // Balance TP is present.
+				trafficIndex = DOWN_LINK;
+			}
+		}
+		else
+		{
+			if (cur_rx_bytes > (cur_tx_bytes << 2))
+			{ // Downlink TP is present.
+				trafficIndex = DOWN_LINK;
+			}
+			else
+			{ // Balance TP is present.
+				trafficIndex = UP_LINK;
+			}
+		}
+
+		//if ((pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex) || (!pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA))
+		{
+			if (ICType == ODM_RTL8192D) {
+				// Single PHY
+				if (pDM_Odm->RFType == ODM_2T2R) {
+					EDCA_BE_UL = 0x60a42b;    //0x5ea42b;
+					EDCA_BE_DL = 0x60a42b;    //0x5ea42b;
+			} else {
+					EDCA_BE_UL = 0x6ea42b;
+					EDCA_BE_DL = 0x6ea42b;
+			}
+			}
+			else
+			{
+				if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE) {
+					if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R)) {
+						EDCA_BE_UL = 0x60a42b;
+						EDCA_BE_DL = 0x60a42b;
+					} else {
+						EDCA_BE_UL = 0x6ea42b;
+						EDCA_BE_DL = 0x6ea42b;
+					}
+				}
+			}
+		
+			//92D txop can't be set to 0x3e for cisco1250
+			if((ICType!=ODM_RTL8192D) && (IOTPeer== HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
+			{
+				EDCA_BE_DL = edca_setting_DL[IOTPeer];
+				EDCA_BE_UL = edca_setting_UL[IOTPeer];
+			}
+			//merge from 92s_92c_merge temp brunch v2445    20120215 
+			else if((IOTPeer == HT_IOT_PEER_CISCO) &&((WirelessMode==ODM_WM_G)||(WirelessMode==(ODM_WM_B|ODM_WM_G))||(WirelessMode==ODM_WM_A)||(WirelessMode==ODM_WM_B)))
+			{
+				EDCA_BE_DL = edca_setting_DL_GMode[IOTPeer];
+			}
+			else if((IOTPeer== HT_IOT_PEER_AIRGO )&& ((WirelessMode==ODM_WM_G)||(WirelessMode==ODM_WM_A)))
+			{
+				EDCA_BE_DL = 0xa630;
+			}
+			else if(IOTPeer == HT_IOT_PEER_MARVELL)
+			{
+				EDCA_BE_DL = edca_setting_DL[IOTPeer];
+				EDCA_BE_UL = edca_setting_UL[IOTPeer];
+			}
+			else if(IOTPeer == HT_IOT_PEER_ATHEROS)
+			{
+				// Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. 
+				EDCA_BE_DL = edca_setting_DL[IOTPeer];
+			}
+
+			if((ICType==ODM_RTL8812)||(ICType==ODM_RTL8821)||(ICType==ODM_RTL8192E))           //add 8812AU/8812AE
+			{
+				EDCA_BE_UL = 0x5ea42b;
+				EDCA_BE_DL = 0x5ea42b;
+
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8812A: EDCA_BE_UL=0x%x EDCA_BE_DL =0x%x",EDCA_BE_UL,EDCA_BE_DL));
+			}
+
+			if (trafficIndex == DOWN_LINK)
+				edca_param = EDCA_BE_DL;
+			else
+				edca_param = EDCA_BE_UL;
+
+			rtw_write32(Adapter, REG_EDCA_BE_PARAM, edca_param);
+
+			pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
+		}
+		
+		pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = _TRUE;
+	}
+	else
+	{
+		//
+		// Turn Off EDCA turbo here.
+		// Restore original EDCA according to the declaration of AP.
+		//
+		 if(pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)
+		{
+			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
+			pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = _FALSE;
+		}
+	}
+
+}
+
+
+#elif(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+VOID
+odm_EdcaTurboCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+
+	PADAPTER 			pDefaultAdapter = GetDefaultAdapter(Adapter);
+	PADAPTER 			pExtAdapter = GetFirstExtAdapter(Adapter);//NULL;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	PSTA_QOS			pStaQos = Adapter->MgntInfo.pStaQos;
+	//[Win7 Count Tx/Rx statistic for Extension Port] odm_CheckEdcaTurbo's Adapter is always Default. 2009.08.20, by Bohn
+	u8Byte				Ext_curTxOkCnt = 0;
+	u8Byte				Ext_curRxOkCnt = 0;	
+	//For future Win7  Enable Default Port to modify AMPDU size dynamically, 2009.08.20, Bohn.	
+	u1Byte TwoPortStatus = (u1Byte)TWO_PORT_STATUS__WITHOUT_ANY_ASSOCIATE;
+
+	// Keep past Tx/Rx packet count for RT-to-RT EDCA turbo.
+	u8Byte				curTxOkCnt = 0;
+	u8Byte				curRxOkCnt = 0;	
+	u4Byte				EDCA_BE_UL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[pMgntInfo->IOTPeer];
+	u4Byte				EDCA_BE_DL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[pMgntInfo->IOTPeer];
+	u4Byte                         EDCA_BE = 0x5ea42b;
+	u1Byte                         IOTPeer=0;
+	BOOLEAN                      *pbIsCurRDLState=NULL;
+	BOOLEAN                      bLastIsCurRDLState=FALSE;
+	BOOLEAN				 bBiasOnRx=FALSE;
+	BOOLEAN				bEdcaTurboOn=FALSE;
+	u1Byte				TxRate = 0xFF;
+	u8Byte				value64;	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("odm_EdcaTurboCheckMP========================>"));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
+
+////===============================
+////list paramter for different platform
+////===============================
+	bLastIsCurRDLState=pDM_Odm->DM_EDCA_Table.bIsCurRDLState;
+	pbIsCurRDLState=&(pDM_Odm->DM_EDCA_Table.bIsCurRDLState);	
+
+	//2012/09/14 MH Add 
+	if (pMgntInfo->NumNonBePkt > pMgntInfo->RegEdcaThresh && !Adapter->MgntInfo.bWiFiConfg)
+		pHalData->bIsAnyNonBEPkts = TRUE;
+
+	pMgntInfo->NumNonBePkt = 0;
+
+       // Caculate TX/RX TP:
+	//curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pMgntInfo->lastTxOkCnt;
+	//curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pMgntInfo->lastRxOkCnt;
+	curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pDM_Odm->lastTxOkCnt;
+	curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pDM_Odm->lastRxOkCnt;
+	pDM_Odm->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
+	pDM_Odm->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+
+	if(pExtAdapter == NULL) 
+		pExtAdapter = pDefaultAdapter;
+
+	Ext_curTxOkCnt = pExtAdapter->TxStats.NumTxBytesUnicast - pMgntInfo->Ext_lastTxOkCnt;
+	Ext_curRxOkCnt = pExtAdapter->RxStats.NumRxBytesUnicast - pMgntInfo->Ext_lastRxOkCnt;
+	GetTwoPortSharedResource(Adapter,TWO_PORT_SHARED_OBJECT__STATUS,NULL,&TwoPortStatus);
+	//For future Win7  Enable Default Port to modify AMPDU size dynamically, 2009.08.20, Bohn.
+	if(TwoPortStatus == TWO_PORT_STATUS__EXTENSION_ONLY)
+	{
+		curTxOkCnt = Ext_curTxOkCnt ;
+		curRxOkCnt = Ext_curRxOkCnt ;
+	}
+	//
+	IOTPeer=pMgntInfo->IOTPeer;
+	bBiasOnRx=(pMgntInfo->IOTAction & HT_IOT_ACT_EDCA_BIAS_ON_RX)?TRUE:FALSE;
+	bEdcaTurboOn=((!pHalData->bIsAnyNonBEPkts))?TRUE:FALSE;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("bIsAnyNonBEPkts : 0x%lx  \n",pHalData->bIsAnyNonBEPkts));
+
+
+////===============================
+////check if edca turbo is disabled
+////===============================
+	if(odm_IsEdcaTurboDisable(pDM_Odm))
+	{
+		pHalData->bIsAnyNonBEPkts = FALSE;
+		pMgntInfo->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
+		pMgntInfo->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+		pMgntInfo->Ext_lastTxOkCnt = pExtAdapter->TxStats.NumTxBytesUnicast;
+		pMgntInfo->Ext_lastRxOkCnt = pExtAdapter->RxStats.NumRxBytesUnicast;
+
+	}
+
+////===============================
+////remove iot case out
+////===============================
+	ODM_EdcaParaSelByIot(pDM_Odm, &EDCA_BE_UL, &EDCA_BE_DL);
+
+
+////===============================
+////Check if the status needs to be changed.
+////===============================
+	if(bEdcaTurboOn)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("bEdcaTurboOn : 0x%x bBiasOnRx : 0x%x\n",bEdcaTurboOn,bBiasOnRx));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("curTxOkCnt : 0x%lx \n",curTxOkCnt));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("curRxOkCnt : 0x%lx \n",curRxOkCnt));
+		if(bBiasOnRx)
+			odm_EdcaChooseTrafficIdx(pDM_Odm,curTxOkCnt, curRxOkCnt,   TRUE,  pbIsCurRDLState);
+		else
+			odm_EdcaChooseTrafficIdx(pDM_Odm,curTxOkCnt, curRxOkCnt,   FALSE,  pbIsCurRDLState);
+
+//modify by Guo.Mingzhi 2011-12-29
+			EDCA_BE=((*pbIsCurRDLState)==TRUE)?EDCA_BE_DL:EDCA_BE_UL;
+			if(IS_HARDWARE_TYPE_8821U(Adapter))
+			{
+				if(pMgntInfo->RegTxDutyEnable)
+				{
+					//2013.01.23 LukeLee: debug for 8811AU thermal issue (reduce Tx duty cycle)
+					if(!pMgntInfo->ForcedDataRate) //auto rate
+					{
+						if(pDM_Odm->TxRate != 0xFF)
+							TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate); 
+					}
+					else //force rate
+					{
+						TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
+					}
+
+					value64 = (curRxOkCnt<<2);
+					if(curTxOkCnt < value64) //Downlink
+						ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+					else //Uplink
+					{
+						/*DbgPrint("pRFCalibrateInfo->ThermalValue = 0x%X\n", pRFCalibrateInfo->ThermalValue);*/
+						/*if(pRFCalibrateInfo->ThermalValue < pHalData->EEPROMThermalMeter)*/
+						if((pDM_Odm->RFCalibrateInfo.ThermalValue < 0x2c) || (*pDM_Odm->pBandType == BAND_ON_2_4G))
+							ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+						else
+						{
+							switch (TxRate)
+							{
+								case MGN_VHT1SS_MCS6:
+								case MGN_VHT1SS_MCS5:
+								case MGN_MCS6:
+								case MGN_MCS5:
+								case MGN_48M:
+								case MGN_54M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0x1ea42b);
+								break;
+								case MGN_VHT1SS_MCS4:
+								case MGN_MCS4:
+								case MGN_36M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa42b);
+								break;
+								case MGN_VHT1SS_MCS3:
+								case MGN_MCS3:
+								case MGN_24M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa47f);
+								break;
+								case MGN_VHT1SS_MCS2:
+								case MGN_MCS2:
+								case MGN_18M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa57f);
+								break;
+								case MGN_VHT1SS_MCS1:
+								case MGN_MCS1:
+								case MGN_9M:
+								case MGN_12M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa77f);
+								break;
+								case MGN_VHT1SS_MCS0:
+								case MGN_MCS0:
+								case MGN_6M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa87f);
+								break;
+								default:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+								break;
+							}
+						}
+					}				
+				}
+				else
+				{
+					ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+				}
+
+			}
+			else if (IS_HARDWARE_TYPE_8812AU(Adapter)){
+				if(pMgntInfo->RegTxDutyEnable)
+				{
+					//2013.07.26 Wilson: debug for 8812AU thermal issue (reduce Tx duty cycle)
+					// it;s the same issue as 8811AU
+					if(!pMgntInfo->ForcedDataRate) //auto rate
+					{
+						if(pDM_Odm->TxRate != 0xFF)
+							TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate); 
+					}
+					else //force rate
+					{
+						TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
+					}
+
+					value64 = (curRxOkCnt<<2);
+					if(curTxOkCnt < value64) //Downlink
+						ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+					else //Uplink
+					{
+						/*DbgPrint("pRFCalibrateInfo->ThermalValue = 0x%X\n", pRFCalibrateInfo->ThermalValue);*/
+						/*if(pRFCalibrateInfo->ThermalValue < pHalData->EEPROMThermalMeter)*/
+						if((pDM_Odm->RFCalibrateInfo.ThermalValue < 0x2c) || (*pDM_Odm->pBandType == BAND_ON_2_4G))
+							ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+						else
+						{
+							switch (TxRate)
+							{
+								case MGN_VHT2SS_MCS9:
+								case MGN_VHT1SS_MCS9:									
+								case MGN_VHT1SS_MCS8:
+								case MGN_MCS15:
+								case MGN_MCS7:									
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0x1ea44f);							
+								case MGN_VHT2SS_MCS8:
+								case MGN_VHT1SS_MCS7:
+								case MGN_MCS14:
+								case MGN_MCS6:
+								case MGN_54M:									
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa44f);
+								case MGN_VHT2SS_MCS7:
+								case MGN_VHT2SS_MCS6:
+								case MGN_VHT1SS_MCS6:
+								case MGN_VHT1SS_MCS5:
+								case MGN_MCS13:
+								case MGN_MCS5:
+								case MGN_48M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa630);
+								break;
+								case MGN_VHT2SS_MCS5:
+								case MGN_VHT2SS_MCS4:
+								case MGN_VHT1SS_MCS4:
+								case MGN_VHT1SS_MCS3:	
+								case MGN_MCS12:
+								case MGN_MCS4:	
+								case MGN_MCS3:	
+								case MGN_36M:
+								case MGN_24M:	
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa730);
+								break;
+								case MGN_VHT2SS_MCS3:
+								case MGN_VHT2SS_MCS2:
+								case MGN_VHT2SS_MCS1:
+								case MGN_VHT1SS_MCS2:
+								case MGN_VHT1SS_MCS1:	
+								case MGN_MCS11:	
+								case MGN_MCS10:	
+								case MGN_MCS9:		
+								case MGN_MCS2:	
+								case MGN_MCS1:
+								case MGN_18M:	
+								case MGN_12M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa830);
+								break;
+								case MGN_VHT2SS_MCS0:
+								case MGN_VHT1SS_MCS0:
+								case MGN_MCS0:	
+								case MGN_MCS8:
+								case MGN_9M:	
+								case MGN_6M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa87f);
+								break;
+								default:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+								break;
+							}
+						}
+					}				
+				}
+				else
+				{
+					ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+				}
+			}
+			else
+				ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EDCA Turbo on: EDCA_BE:0x%lx\n",EDCA_BE));
+
+		pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = TRUE;
+		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EDCA_BE_DL : 0x%lx  EDCA_BE_UL : 0x%lx  EDCA_BE : 0x%lx  \n",EDCA_BE_DL,EDCA_BE_UL,EDCA_BE));
+
+	}
+	else
+	{
+		// Turn Off EDCA turbo here.
+		// Restore original EDCA according to the declaration of AP.
+		 if(pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)
+		{
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_AC_PARAM, GET_WMM_PARAM_ELE_SINGLE_AC_PARAM(pStaQos->WMMParamEle, AC0_BE) );
+
+			pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Restore EDCA BE: 0x%lx  \n",pDM_Odm->WMMEDCA_BE));
+
+		}
+	}
+
+}
+
+
+//check if edca turbo is disabled
+BOOLEAN
+odm_IsEdcaTurboDisable(
+	IN 	PVOID	 	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	u4Byte				IOTPeer=pMgntInfo->IOTPeer;
+
+	if(pDM_Odm->bBtDisableEdcaTurbo)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("EdcaTurboDisable for BT!!\n"));
+		return TRUE;
+	}
+
+	if((!(pDM_Odm->SupportAbility& ODM_MAC_EDCA_TURBO ))||
+		(pDM_Odm->bWIFITest)||
+		(IOTPeer>= HT_IOT_PEER_MAX))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("EdcaTurboDisable\n"));
+		return TRUE;
+	}
+
+
+	// 1. We do not turn on EDCA turbo mode for some AP that has IOT issue
+	// 2. User may disable EDCA Turbo mode with OID settings.
+	if(pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO){
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("IOTAction:EdcaTurboDisable\n"));
+		return	TRUE;
+		}
+		
+	return	FALSE;
+	
+
+}
+
+//add iot case here: for MP/CE
+VOID 
+ODM_EdcaParaSelByIot(
+	IN 	PVOID	 	pDM_VOID,
+	OUT	u4Byte		*EDCA_BE_UL,
+	OUT u4Byte		*EDCA_BE_DL
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte                         IOTPeer=0;
+	u4Byte                         ICType=pDM_Odm->SupportICType;
+	u1Byte                         WirelessMode=0xFF;                   //invalid value
+	u4Byte				RFType=pDM_Odm->RFType;
+	u4Byte                         IOTPeerSubType = 0;
+
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	u1Byte 				TwoPortStatus = (u1Byte)TWO_PORT_STATUS__WITHOUT_ANY_ASSOCIATE;
+
+	if(pDM_Odm->pWirelessMode!=NULL)
+		WirelessMode=*(pDM_Odm->pWirelessMode);
+		
+///////////////////////////////////////////////////////////
+////list paramter for different platform
+
+	IOTPeer=pMgntInfo->IOTPeer;
+	IOTPeerSubType=pMgntInfo->IOTPeerSubtype;
+	GetTwoPortSharedResource(Adapter,TWO_PORT_SHARED_OBJECT__STATUS,NULL,&TwoPortStatus);
+
+
+	if(ICType==ODM_RTL8192D)
+	{      
+		// Single PHY
+		if(pDM_Odm->RFType==ODM_2T2R)
+		{
+			(*EDCA_BE_UL) = 0x60a42b;    //0x5ea42b;
+			(*EDCA_BE_DL) = 0x60a42b;    //0x5ea42b;
+
+		}
+		else
+		{
+			(*EDCA_BE_UL) = 0x6ea42b;
+			(*EDCA_BE_DL) = 0x6ea42b;
+		}
+
+	}
+////============================
+/// IOT case for MP
+////============================	
+
+	else
+	{
+
+		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE){
+			if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R))			{
+				(*EDCA_BE_UL) = 0x60a42b;
+				(*EDCA_BE_DL) = 0x60a42b;
+			}
+			else
+			{
+				(*EDCA_BE_UL) = 0x6ea42b;
+				(*EDCA_BE_DL) = 0x6ea42b;
+			}
+		}
+	}
+ 
+	if(TwoPortStatus == TWO_PORT_STATUS__EXTENSION_ONLY)
+	{
+		(*EDCA_BE_UL) = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[ExtAdapter->MgntInfo.IOTPeer];
+		(*EDCA_BE_DL) = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[ExtAdapter->MgntInfo.IOTPeer];
+	}
+     
+	#if (INTEL_PROXIMITY_SUPPORT == 1)
+	if(pMgntInfo->IntelClassModeInfo.bEnableCA == TRUE)
+	{
+		(*EDCA_BE_UL) = (*EDCA_BE_DL) = 0xa44f;
+	}
+	else
+	#endif		
+	{
+		if((pMgntInfo->IOTAction & (HT_IOT_ACT_FORCED_ENABLE_BE_TXOP|HT_IOT_ACT_AMSDU_ENABLE)))
+		{// To check whether we shall force turn on TXOP configuration.
+			if(!((*EDCA_BE_UL) & 0xffff0000))
+				(*EDCA_BE_UL) |= 0x005e0000; // Force TxOP limit to 0x005e for UL.
+			if(!((*EDCA_BE_DL) & 0xffff0000))
+				(*EDCA_BE_DL) |= 0x005e0000; // Force TxOP limit to 0x005e for DL.
+		}
+		
+		//92D txop can't be set to 0x3e for cisco1250
+		if((ICType!=ODM_RTL8192D) && (IOTPeer== HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
+		{
+			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
+			(*EDCA_BE_UL) = edca_setting_UL[IOTPeer];
+		}
+		//merge from 92s_92c_merge temp brunch v2445    20120215 
+		else if((IOTPeer == HT_IOT_PEER_CISCO) &&((WirelessMode==ODM_WM_G)||(WirelessMode==(ODM_WM_B|ODM_WM_G))||(WirelessMode==ODM_WM_A)||(WirelessMode==ODM_WM_B)))
+		{
+			(*EDCA_BE_DL) = edca_setting_DL_GMode[IOTPeer];
+		}
+		else if((IOTPeer== HT_IOT_PEER_AIRGO )&& ((WirelessMode==ODM_WM_G)||(WirelessMode==ODM_WM_A)))
+		{
+			(*EDCA_BE_DL) = 0xa630;
+		}
+
+		else if(IOTPeer == HT_IOT_PEER_MARVELL)
+		{
+			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
+			(*EDCA_BE_UL) = edca_setting_UL[IOTPeer];
+		}
+		else if(IOTPeer == HT_IOT_PEER_ATHEROS && IOTPeerSubType != HT_IOT_PEER_TPLINK_AC1750)
+		{
+			// Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. 
+			if(WirelessMode==ODM_WM_G)
+				(*EDCA_BE_DL) = edca_setting_DL_GMode[IOTPeer];
+			else
+				(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
+
+			if(ICType == ODM_RTL8821)
+				 (*EDCA_BE_DL) = 0x5ea630;
+			
+		}
+	}
+
+    	if((ICType == ODM_RTL8192D)&&(IOTPeerSubType == HT_IOT_PEER_LINKSYS_E4200_V1)&&((WirelessMode==ODM_WM_N5G)))
+	{
+		(*EDCA_BE_DL) = 0x432b;
+		(*EDCA_BE_UL) = 0x432b;
+	}		
+
+
+
+	if((ICType==ODM_RTL8812)||(ICType==ODM_RTL8192E))           //add 8812AU/8812AE
+	{
+		(*EDCA_BE_UL) = 0x5ea42b;
+		(*EDCA_BE_DL) = 0x5ea42b;
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8812A: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx\n",(*EDCA_BE_UL),(*EDCA_BE_DL)));
+	}
+
+	if((ICType==ODM_RTL8814A) && (IOTPeer == HT_IOT_PEER_REALTEK))           /*8814AU and 8814AR*/
+	{
+		(*EDCA_BE_UL) = 0x5ea42b;
+		(*EDCA_BE_DL) = 0xa42b;
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8814A: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx\n",(*EDCA_BE_UL),(*EDCA_BE_DL)));
+	}
+
+	
+
+	// Revised for Atheros DIR-655 IOT issue to improve down link TP, added by Roger, 2013.03.22.
+	if((ICType == ODM_RTL8723A) && (IOTPeerSubType== HT_IOT_PEER_ATHEROS_DIR655) && 
+		(pMgntInfo->dot11CurrentChannelNumber == 6))
+	{
+		(*EDCA_BE_DL) = 0xa92b;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Special: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx, IOTPeer = %d\n",(*EDCA_BE_UL),(*EDCA_BE_DL), IOTPeer));
+
+}
+
+
+VOID
+odm_EdcaChooseTrafficIdx( 
+	IN 	PVOID	 	pDM_VOID,
+	IN	u8Byte  			cur_tx_bytes,  
+	IN	u8Byte  			cur_rx_bytes, 
+	IN	BOOLEAN 		bBiasOnRx,
+	OUT BOOLEAN 		*pbIsCurRDLState
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if(bBiasOnRx)
+	{
+	  
+		if(cur_tx_bytes>(cur_rx_bytes*4))
+		{
+			*pbIsCurRDLState=FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Uplink Traffic\n "));
+
+		}
+		else
+		{
+			*pbIsCurRDLState=TRUE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Balance Traffic\n"));
+
+		}
+	}
+	else
+	{
+		if(cur_rx_bytes>(cur_tx_bytes*4))
+		{
+			*pbIsCurRDLState=TRUE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Downlink	Traffic\n"));
+
+		}
+		else
+		{
+			*pbIsCurRDLState=FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Balance Traffic\n"));
+		}
+	}
+
+	return ;
+}
+
+#endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.h
new file mode 100644
index 000000000..d4cd8d841
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_edcaturbocheck.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMEDCATURBOCHECK_H__
+#define    __PHYDMEDCATURBOCHECK_H__
+
+/*#define EDCATURBO_VERSION	"2.1"*/
+#define EDCATURBO_VERSION	"2.2"	/*2015.01.13*/
+
+typedef struct _EDCA_TURBO_
+{
+	BOOLEAN bCurrentTurboEDCA;
+	BOOLEAN bIsCurRDLState;
+
+	#if(DM_ODM_SUPPORT_TYPE == ODM_CE	)
+	u4Byte	prv_traffic_idx; // edca turbo
+	#endif
+
+}EDCA_T,*pEDCA_T;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+static u4Byte edca_setting_UL[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU        MARVELL	92U_AP		SELF_AP(DownLink/Tx)
+{ 0x5e4322, 		0xa44f, 		0x5e4322,		0x5ea32b,  		0x5ea422, 	0x5ea322,	0x3ea430,	0x5ea42b, 0x5ea44f,	0x5e4322,	0x5e4322};
+
+
+static u4Byte edca_setting_DL[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU,       MARVELL	92U_AP		SELF_AP(UpLink/Rx)
+{ 0xa44f, 		0x5ea44f, 	0x5e4322, 		0x5ea42b, 		0xa44f, 		0xa630, 		0x5ea630,	0x5ea42b, 0xa44f,		0xa42b,		0xa42b};
+
+static u4Byte edca_setting_DL_GMode[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU,       MARVELL	92U_AP		SELF_AP
+{ 0x4322, 		0xa44f, 		0x5e4322,		0xa42b, 			0x5e4322, 	0x4322, 		0xa42b,		0x5ea42b, 0xa44f,		0x5e4322,	0x5ea42b};
+
+#endif
+
+
+
+VOID
+odm_EdcaTurboCheck(
+	IN 	PVOID	 	pDM_VOID
+	);
+VOID
+ODM_EdcaTurboInit(
+	IN 	PVOID	 	pDM_VOID
+);
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+VOID
+odm_EdcaTurboCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+//check if edca turbo is disabled
+BOOLEAN
+odm_IsEdcaTurboDisable(
+	IN 	PVOID	 	pDM_VOID
+);
+//choose edca paramter for special IOT case
+VOID 
+ODM_EdcaParaSelByIot(
+	IN		PVOID					pDM_VOID,
+	OUT	u4Byte		*EDCA_BE_UL,
+	OUT u4Byte		*EDCA_BE_DL
+	);
+//check if it is UL or DL
+VOID
+odm_EdcaChooseTrafficIdx( 
+	IN 	PVOID	 	pDM_VOID,
+	IN	u8Byte  			cur_tx_bytes,  
+	IN	u8Byte  			cur_rx_bytes, 
+	IN	BOOLEAN 		bBiasOnRx,
+	OUT BOOLEAN 		*pbIsCurRDLState
+	);
+
+#elif (DM_ODM_SUPPORT_TYPE==ODM_CE)
+VOID
+odm_EdcaTurboCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	);
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_features.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_features.h
new file mode 100644
index 000000000..639668e49
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_features.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__PHYDM_FEATURES_H__
+#define __PHYDM_FEATURES
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	/*Antenna Diversity*/
+	#define CONFIG_PHYDM_ANTENNA_DIVERSITY
+	#ifdef CONFIG_PHYDM_ANTENNA_DIVERSITY
+	
+		#if (RTL8723B_SUPPORT == 1) || (RTL8821A_SUPPORT == 1) || (RTL8188F_SUPPORT == 1)
+		#define	CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+		#endif
+		
+		#if (RTL8821A_SUPPORT == 1)
+		/*#define CONFIG_HL_SMART_ANTENNA_TYPE1*/
+		#endif
+	#endif
+
+	/*#define CONFIG_PATH_DIVERSITY*/
+	/*#define CONFIG_RA_DYNAMIC_RTY_LIMIT*/
+	#define CONFIG_ANT_DETECTION
+	#define CONFIG_RA_DBG_CMD
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+	/*  [ Configure RA Debug H2C CMD ]*/
+	#define CONFIG_RA_DBG_CMD
+	
+	/*#define CONFIG_PATH_DIVERSITY*/
+	/*#define CONFIG_RA_DYNAMIC_RTY_LIMIT*/
+	#define CONFIG_RA_DYNAMIC_RATE_ID
+	
+	/* [ Configure Antenna Diversity ] */
+	#if defined(CONFIG_RTL_8881A_ANT_SWITCH) || defined(CONFIG_SLOT_0_ANT_SWITCH) || defined(CONFIG_SLOT_1_ANT_SWITCH)
+		#define CONFIG_PHYDM_ANTENNA_DIVERSITY 
+		#define ODM_EVM_ENHANCE_ANTDIV
+
+		/*----------*/
+		
+		#if (!defined(CONFIG_NO_2G_DIVERSITY) && !defined(CONFIG_2G5G_CG_TRX_DIVERSITY_8881A) && !defined(CONFIG_2G_CGCS_RX_DIVERSITY) && !defined(CONFIG_2G_CG_TRX_DIVERSITY) && !defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY))
+			#define CONFIG_NO_2G_DIVERSITY
+		#endif
+
+		#ifdef CONFIG_NO_5G_DIVERSITY_8881A
+			#define CONFIG_NO_5G_DIVERSITY
+		#elif defined(CONFIG_5G_CGCS_RX_DIVERSITY_8881A)
+			#define CONFIG_5G_CGCS_RX_DIVERSITY
+		#elif defined(CONFIG_5G_CG_TRX_DIVERSITY_8881A)
+			#define CONFIG_5G_CG_TRX_DIVERSITY
+		#elif defined(CONFIG_2G5G_CG_TRX_DIVERSITY_8881A)
+			#define CONFIG_2G5G_CG_TRX_DIVERSITY
+		#endif
+		#if (!defined(CONFIG_NO_5G_DIVERSITY) && !defined(CONFIG_5G_CGCS_RX_DIVERSITY) && !defined(CONFIG_5G_CG_TRX_DIVERSITY) && !defined(CONFIG_2G5G_CG_TRX_DIVERSITY) && !defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY))
+			#define CONFIG_NO_5G_DIVERSITY
+		#endif	
+		 /*----------*/
+		#if (defined(CONFIG_NO_2G_DIVERSITY) && defined(CONFIG_NO_5G_DIVERSITY))
+			#define CONFIG_NOT_SUPPORT_ANTDIV 
+		#elif (!defined(CONFIG_NO_2G_DIVERSITY) && defined(CONFIG_NO_5G_DIVERSITY))
+			#define CONFIG_2G_SUPPORT_ANTDIV
+		#elif (defined(CONFIG_NO_2G_DIVERSITY) && !defined(CONFIG_NO_5G_DIVERSITY))
+			#define CONFIG_5G_SUPPORT_ANTDIV
+		#elif ((!defined(CONFIG_NO_2G_DIVERSITY) && !defined(CONFIG_NO_5G_DIVERSITY)) || defined(CONFIG_2G5G_CG_TRX_DIVERSITY))
+			#define CONFIG_2G5G_SUPPORT_ANTDIV 
+		#endif
+		 /*----------*/
+	#endif
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+	/*Antenna Diversity*/
+	#ifdef CONFIG_ANTENNA_DIVERSITY
+		#define CONFIG_PHYDM_ANTENNA_DIVERSITY
+		
+		#ifdef CONFIG_PHYDM_ANTENNA_DIVERSITY
+		
+			#if (RTL8723B_SUPPORT == 1) || (RTL8821A_SUPPORT == 1) || (RTL8188F_SUPPORT == 1)
+			#define	CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+			#endif
+			
+			#if (RTL8821A_SUPPORT == 1)
+			/*#define CONFIG_HL_SMART_ANTENNA_TYPE1*/
+			#endif
+		#endif
+	#endif
+	
+	/*#define CONFIG_RA_DBG_CMD*/
+	/*#define CONFIG_ANT_DETECTION*/
+	/*#define CONFIG_PATH_DIVERSITY*/
+	/*#define CONFIG_RA_DYNAMIC_RTY_LIMIT*/
+
+	#ifdef CONFIG_BT_COEXIST
+		#define BT_SUPPORT	1
+	#endif
+
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.c
new file mode 100644
index 000000000..dd5cce46d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.c
@@ -0,0 +1,3332 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#define READ_AND_CONFIG_MP(ic, txt) (ODM_ReadAndConfig_MP_##ic##txt(pDM_Odm))
+#define READ_AND_CONFIG_TC(ic, txt) (ODM_ReadAndConfig_TC_##ic##txt(pDM_Odm))
+
+
+#if (PHYDM_TESTCHIP_SUPPORT == 1)
+#define READ_AND_CONFIG(ic, txt) do {\
+                                            if (pDM_Odm->bIsMPChip)\
+                                    		    READ_AND_CONFIG_MP(ic,txt);\
+                                            else\
+                                                READ_AND_CONFIG_TC(ic,txt);\
+                                    } while(0)
+#else
+  #define READ_AND_CONFIG     READ_AND_CONFIG_MP
+#endif
+
+
+#define READ_FIRMWARE_MP(ic, txt) 		(ODM_ReadFirmware_MP_##ic##txt(pDM_Odm, pFirmware, pSize))
+#define READ_FIRMWARE_TC(ic, txt) 		(ODM_ReadFirmware_TC_##ic##txt(pDM_Odm, pFirmware, pSize))		
+
+#if (PHYDM_TESTCHIP_SUPPORT == 1)
+#define READ_FIRMWARE(ic, txt) do {\
+						if (pDM_Odm->bIsMPChip)\
+							READ_FIRMWARE_MP(ic,txt);\
+						else\
+							READ_FIRMWARE_TC(ic,txt);\
+					} while(0) 
+#else
+#define READ_FIRMWARE     READ_FIRMWARE_MP
+#endif
+						
+#define GET_VERSION_MP(ic, txt) 		(ODM_GetVersion_MP_##ic##txt())
+#define GET_VERSION_TC(ic, txt) 		(ODM_GetVersion_TC_##ic##txt())
+#define GET_VERSION(ic, txt) (pDM_Odm->bIsMPChip?GET_VERSION_MP(ic,txt):GET_VERSION_TC(ic,txt))
+
+u1Byte
+odm_QueryRxPwrPercentage(
+	IN		s1Byte		AntPower
+	)
+{
+	if ((AntPower <= -100) || (AntPower >= 20))
+	{
+		return	0;
+	}
+	else if (AntPower >= 0)
+	{
+		return	100;
+	}
+	else
+	{
+		return	(100+AntPower);
+	}
+	
+}
+
+
+//
+// 2012/01/12 MH MOve some signal strength smooth method to MP HAL layer.
+// IF other SW team do not support the feature, remove this section.??
+//
+s4Byte
+odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	s4Byte CurrSig 
+)
+{	
+	s4Byte RetSig = 0;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	//if(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) 
+	{
+		// Step 1. Scale mapping.
+		// 20100611 Joseph: Re-tunning RSSI presentation for Lenovo.
+		// 20100426 Joseph: Modify Signal strength mapping.
+		// This modification makes the RSSI indication similar to Intel solution.
+		// 20100414 Joseph: Tunning RSSI for Lenovo according to RTL8191SE.
+		if(CurrSig >= 54 && CurrSig <= 100)
+		{
+			RetSig = 100;
+		}
+		else if(CurrSig>=42 && CurrSig <= 53 )
+		{
+			RetSig = 95;
+		}
+		else if(CurrSig>=36 && CurrSig <= 41 )
+		{
+			RetSig = 74 + ((CurrSig - 36) *20)/6;
+		}
+		else if(CurrSig>=33 && CurrSig <= 35 )
+		{
+			RetSig = 65 + ((CurrSig - 33) *8)/2;
+		}
+		else if(CurrSig>=18 && CurrSig <= 32 )
+		{
+			RetSig = 62 + ((CurrSig - 18) *2)/15;
+		}
+		else if(CurrSig>=15 && CurrSig <= 17 )
+		{
+			RetSig = 33 + ((CurrSig - 15) *28)/2;
+		}
+		else if(CurrSig>=10 && CurrSig <= 14 )
+		{
+			RetSig = 39;
+		}
+		else if(CurrSig>=8 && CurrSig <= 9 )
+		{
+			RetSig = 33;
+		}
+		else if(CurrSig <= 8 )
+		{
+			RetSig = 19;
+		}
+	}
+#endif //ENDIF (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	return RetSig;
+}
+
+s4Byte
+odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	s4Byte CurrSig 
+)
+{
+	s4Byte RetSig = 0;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	//if(pDM_Odm->SupportInterface  == ODM_ITRF_USB)
+	{
+		// Netcore request this modification because 2009.04.13 SU driver use it. 
+		if(CurrSig >= 31 && CurrSig <= 100)
+		{
+			RetSig = 100;
+		}	
+		else if(CurrSig >= 21 && CurrSig <= 30)
+		{
+			RetSig = 90 + ((CurrSig - 20) / 1);
+		}
+		else if(CurrSig >= 11 && CurrSig <= 20)
+		{
+			RetSig = 80 + ((CurrSig - 10) / 1);
+		}
+		else if(CurrSig >= 7 && CurrSig <= 10)
+		{
+			RetSig = 69 + (CurrSig - 7);
+		}
+		else if(CurrSig == 6)
+		{
+			RetSig = 54;
+		}
+		else if(CurrSig == 5)
+		{
+			RetSig = 45;
+		}
+		else if(CurrSig == 4)
+		{
+			RetSig = 36;
+		}
+		else if(CurrSig == 3)
+		{
+			RetSig = 27;
+		}
+		else if(CurrSig == 2)
+		{
+			RetSig = 18;
+		}
+		else if(CurrSig == 1)
+		{
+			RetSig = 9;
+		}
+		else
+		{
+			RetSig = CurrSig;
+		}
+	}
+#endif //ENDIF (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	return RetSig;
+}
+
+
+s4Byte
+odm_SignalScaleMapping_92CSeries(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	IN s4Byte CurrSig 
+)
+{
+	s4Byte RetSig = 0; 
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) 
+	if(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) 
+	{
+		// Step 1. Scale mapping.
+		if(CurrSig >= 61 && CurrSig <= 100)
+		{
+			RetSig = 90 + ((CurrSig - 60) / 4);
+		}
+		else if(CurrSig >= 41 && CurrSig <= 60)
+		{
+			RetSig = 78 + ((CurrSig - 40) / 2);
+		}
+		else if(CurrSig >= 31 && CurrSig <= 40)
+		{
+			RetSig = 66 + (CurrSig - 30);
+		}
+		else if(CurrSig >= 21 && CurrSig <= 30)
+		{
+			RetSig = 54 + (CurrSig - 20);
+		}
+		else if(CurrSig >= 5 && CurrSig <= 20)
+		{
+			RetSig = 42 + (((CurrSig - 5) * 2) / 3);
+		}
+		else if(CurrSig == 4)
+		{
+			RetSig = 36;
+		}
+		else if(CurrSig == 3)
+		{
+			RetSig = 27;
+		}
+		else if(CurrSig == 2)
+		{
+			RetSig = 18;
+		}
+		else if(CurrSig == 1)
+		{
+			RetSig = 9;
+		}
+		else
+		{
+			RetSig = CurrSig;
+		}
+	}
+#endif
+
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) ||(DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+	if((pDM_Odm->SupportInterface  == ODM_ITRF_USB) || (pDM_Odm->SupportInterface  == ODM_ITRF_SDIO))
+	{
+		if(CurrSig >= 51 && CurrSig <= 100)
+		{
+			RetSig = 100;
+		}
+		else if(CurrSig >= 41 && CurrSig <= 50)
+		{
+			RetSig = 80 + ((CurrSig - 40)*2);
+		}
+		else if(CurrSig >= 31 && CurrSig <= 40)
+		{
+			RetSig = 66 + (CurrSig - 30);
+		}
+		else if(CurrSig >= 21 && CurrSig <= 30)
+		{
+			RetSig = 54 + (CurrSig - 20);
+		}
+		else if(CurrSig >= 10 && CurrSig <= 20)
+		{
+			RetSig = 42 + (((CurrSig - 10) * 2) / 3);
+		}
+		else if(CurrSig >= 5 && CurrSig <= 9)
+		{
+			RetSig = 22 + (((CurrSig - 5) * 3) / 2);
+		}
+		else if(CurrSig >= 1 && CurrSig <= 4)
+		{
+			RetSig = 6 + (((CurrSig - 1) * 3) / 2);
+		}
+		else
+		{
+			RetSig = CurrSig;
+		}
+	}
+
+#endif
+	return RetSig;
+}
+s4Byte
+odm_SignalScaleMapping(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	IN	s4Byte CurrSig 
+)
+{	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if(	(pDM_Odm->SupportPlatform == ODM_WIN) && 
+		(pDM_Odm->SupportInterface  != ODM_ITRF_PCIE) && //USB & SDIO
+		(pDM_Odm->PatchID==10))//pMgntInfo->CustomerID == RT_CID_819x_Netcore
+	{
+		return odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(pDM_Odm,CurrSig);
+	}
+	else if(	(pDM_Odm->SupportPlatform == ODM_WIN) && 
+			(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) &&
+			(pDM_Odm->PatchID==19))//pMgntInfo->CustomerID == RT_CID_819x_Lenovo)
+	{
+		return odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(pDM_Odm, CurrSig);
+	}else
+#endif
+        {		
+		return odm_SignalScaleMapping_92CSeries(pDM_Odm,CurrSig);
+	}
+	
+}
+
+
+
+static u1Byte odm_SQ_process_patch_RT_CID_819x_Lenovo(
+	IN PDM_ODM_T	pDM_Odm,
+	IN u1Byte 		isCCKrate,
+	IN u1Byte 		PWDB_ALL,
+	IN u1Byte 		path,
+	IN u1Byte 		RSSI
+)
+{
+	u1Byte	SQ = 0;
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)			
+
+	if(isCCKrate){
+		
+		if(IS_HARDWARE_TYPE_8723AE(pDM_Odm->Adapter))
+		{
+
+			//
+			// <Roger_Notes> Expected signal strength and bars indication at Lenovo lab. 2013.04.11
+			// 802.11n, 802.11b, 802.11g only at channel 6
+			//
+			//		Attenuation (dB)	OS Signal Bars	RSSI by Xirrus (dBm)
+			//			50				5			-52
+			//			55				5			-54
+			//			60				5			-55
+			//			65				5			-59
+			//			70				5			-63
+			//			75				5			-66
+			//			80				4			-72
+			//			85				3			-75
+			//			90				3			-80
+			//			95				2			-85
+			//			100				1			-89
+			//			102				1			-90
+			//			104				1			-91
+			//
+			RT_TRACE(COMP_DBG, DBG_WARNING, ("odm_SQ_process_patch_RT_CID_819x_Lenovo\n"));
+			
+#if OS_WIN_FROM_WIN8(OS_VERSION)	
+			if(PWDB_ALL >= 50)
+				SQ = 100;
+			else if(PWDB_ALL >= 23 && PWDB_ALL < 50)				
+				SQ = 80;
+			else if(PWDB_ALL >= 18 && PWDB_ALL < 23)
+				SQ = 60;
+			else if(PWDB_ALL >= 8 && PWDB_ALL < 18)
+				SQ = 40;
+			else
+				SQ = 10;
+#else
+			if(PWDB_ALL >= 34)
+				SQ = 100;
+			else if(PWDB_ALL >= 23 && PWDB_ALL < 34)				
+				SQ = 80;
+			else if(PWDB_ALL >= 18 && PWDB_ALL < 23)
+				SQ = 60;
+			else if(PWDB_ALL >= 8 && PWDB_ALL < 18)
+				SQ = 40;
+			else
+				SQ = 10;	
+
+			if(PWDB_ALL == 0)// Abnormal case, do not indicate the value above 20 on Win7
+				SQ = 20;
+#endif		
+
+		}
+		else if(IS_HARDWARE_TYPE_8192E(pDM_Odm->Adapter)){
+
+			//
+			// <Roger_Notes> Expected signal strength and bars indication at Lenovo lab. 2013.04.11
+			// 802.11n, 802.11b, 802.11g only at channel 6
+			//
+			//		Attenuation (dB)	OS Signal Bars	RSSI by Xirrus (dBm)
+			//			50				5			-49
+			//			55				5			-49
+			//			60				5			-50
+			//			65				5			-51
+			//			70				5			-52
+			//			75				5			-54
+			//			80				5			-55
+			//			85				4			-60
+			//			90				3			-63
+			//			95				3			-65
+			//			100				2			-67
+			//			102				2			-67
+			//			104				1			-70
+			//			
+
+			if(PWDB_ALL >= 50)
+				SQ = 100;
+			else if(PWDB_ALL >= 35 && PWDB_ALL < 50)				
+				SQ = 80;
+			else if(PWDB_ALL >= 31 && PWDB_ALL < 35)
+				SQ = 60;
+			else if(PWDB_ALL >= 22 && PWDB_ALL < 31)
+				SQ = 40;
+			else if(PWDB_ALL >= 18 && PWDB_ALL < 22)
+				SQ = 20;
+			else
+				SQ = 10;
+		} else {
+			if (PWDB_ALL >= 50)
+				SQ = 100;
+			else if (PWDB_ALL >= 35 && PWDB_ALL < 50)				
+				SQ = 80;
+			else if (PWDB_ALL >= 22 && PWDB_ALL < 35)
+				SQ = 60;
+			else if (PWDB_ALL >= 18 && PWDB_ALL < 22)
+				SQ = 40;
+			else
+				SQ = 10;
+		}
+		
+	}
+	else
+	{//OFDM rate		
+
+		if(IS_HARDWARE_TYPE_8723AE(pDM_Odm->Adapter) ||
+			IS_HARDWARE_TYPE_8192E(pDM_Odm->Adapter))
+		{
+			if(RSSI >= 45)
+				SQ = 100;
+			else if(RSSI >= 22 && RSSI < 45)
+				SQ = 80;
+			else if(RSSI >= 18 && RSSI < 22)
+				SQ = 40;
+			else
+			SQ = 20;
+		} else {
+			if(RSSI >= 45)
+			SQ = 100;
+			else if(RSSI >= 22 && RSSI < 45)
+			SQ = 80;
+		else if(RSSI >= 18 && RSSI < 22)
+			SQ = 40;
+		else
+			SQ = 20;			
+		}
+	}
+
+	RT_TRACE(COMP_DBG, DBG_TRACE, ("isCCKrate(%#d), PWDB_ALL(%#d), RSSI(%#d), SQ(%#d)\n", isCCKrate, PWDB_ALL, RSSI, SQ));
+	
+#endif
+	return SQ;
+}
+
+static u1Byte odm_SQ_process_patch_RT_CID_819x_Acer(
+	IN PDM_ODM_T	pDM_Odm,
+	IN u1Byte 		isCCKrate,
+	IN u1Byte 		PWDB_ALL,
+	IN u1Byte 		path,
+	IN u1Byte 		RSSI
+)
+{
+	u1Byte	SQ = 0;
+	
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)			
+
+	if(isCCKrate){
+
+			RT_TRACE(COMP_DBG, DBG_WARNING, ("odm_SQ_process_patch_RT_Acer\n"));
+			
+#if OS_WIN_FROM_WIN8(OS_VERSION)	
+
+			if(PWDB_ALL >= 50)
+				SQ = 100;
+			else if(PWDB_ALL >= 35 && PWDB_ALL < 50)				
+				SQ = 80;
+			else if(PWDB_ALL >= 30 && PWDB_ALL < 35)
+				SQ = 60;
+			else if(PWDB_ALL >= 25 && PWDB_ALL < 30)
+				SQ = 40;
+			else if(PWDB_ALL >= 20 && PWDB_ALL < 25)
+				SQ = 20;
+			else
+				SQ = 10;	
+#else
+			if(PWDB_ALL >= 50)
+				SQ = 100;
+			else if(PWDB_ALL >= 35 && PWDB_ALL < 50)				
+				SQ = 80;
+			else if(PWDB_ALL >= 30 && PWDB_ALL < 35)
+				SQ = 60;
+			else if(PWDB_ALL >= 25 && PWDB_ALL < 30)
+				SQ = 40;
+			else if(PWDB_ALL >= 20 && PWDB_ALL < 25)
+				SQ = 20;
+			else
+				SQ = 10;	
+
+			if(PWDB_ALL == 0)// Abnormal case, do not indicate the value above 20 on Win7
+				SQ = 20;
+#endif		
+
+		
+		
+	}
+	else
+	{//OFDM rate		
+
+		if(IS_HARDWARE_TYPE_8723AE(pDM_Odm->Adapter) ||
+			IS_HARDWARE_TYPE_8192E(pDM_Odm->Adapter))
+		{
+			if(RSSI >= 45)
+				SQ = 100;
+			else if(RSSI >= 22 && RSSI < 45)
+				SQ = 80;
+			else if(RSSI >= 18 && RSSI < 22)
+				SQ = 40;
+			else
+			SQ = 20;
+	}
+		else
+		{
+			if(RSSI >= 35)
+			SQ = 100;
+			else if(RSSI >= 30 && RSSI < 35)
+			SQ = 80;
+		else if(RSSI >= 25 && RSSI < 30)
+			SQ = 40;
+		else
+			SQ = 20;			
+	}
+	}
+
+	RT_TRACE(COMP_DBG, DBG_LOUD, ("isCCKrate(%#d), PWDB_ALL(%#d), RSSI(%#d), SQ(%#d)\n", isCCKrate, PWDB_ALL, RSSI, SQ));
+	
+#endif
+	return SQ;
+}
+			
+static u1Byte 
+odm_EVMdbToPercentage(
+    IN		s1Byte Value
+    )
+{
+	//
+	// -33dB~0dB to 0%~99%
+	//
+	s1Byte ret_val;
+    
+	ret_val = Value;
+	ret_val /= 2;
+
+	/*DbgPrint("Value=%d\n", Value);*/
+	/*ODM_RT_DISP(FRX, RX_PHY_SQ, ("EVMdbToPercentage92C Value=%d / %x\n", ret_val, ret_val));*/
+#ifdef ODM_EVM_ENHANCE_ANTDIV
+	if (ret_val >= 0)
+		ret_val = 0;
+
+	if (ret_val <= -40)
+		ret_val = -40;
+
+	ret_val = 0 - ret_val;
+	ret_val *= 3;
+#else
+	if (ret_val >= 0)
+		ret_val = 0;
+
+	if (ret_val <= -33)
+		ret_val = -33;
+
+	ret_val = 0 - ret_val;
+	ret_val *= 3;
+
+	if (ret_val == 99)
+		ret_val = 100;
+#endif
+
+	return (u1Byte)ret_val;
+}
+			
+static u1Byte 
+odm_EVMdbm_JaguarSeries(
+	IN  s1Byte Value
+	)
+{
+	s1Byte ret_val = Value;
+	
+	// -33dB~0dB to 33dB ~ 0dB
+	if(ret_val == -128)
+		ret_val = 127;
+	else if (ret_val < 0)
+		ret_val = 0 - ret_val;
+	
+	ret_val  = ret_val >> 1;
+	return (u1Byte)ret_val;
+}
+
+static s2Byte
+odm_Cfo(
+  IN s1Byte Value
+)
+{
+	s2Byte  ret_val;
+
+	if (Value < 0)
+	{
+		ret_val = 0 - Value;
+		ret_val = (ret_val << 1) + (ret_val >> 1) ;  //  *2.5~=312.5/2^7
+		ret_val = ret_val | BIT12;  // set bit12 as 1 for negative cfo
+	}
+	else
+	{
+		ret_val = Value;
+		ret_val = (ret_val << 1) + (ret_val>>1) ;  //  *2.5~=312.5/2^7
+	}
+	return ret_val;
+}
+
+#if(ODM_IC_11N_SERIES_SUPPORT == 1)
+
+s1Byte
+odm_CCKRSSI_8703B(
+	IN		u2Byte	LNA_idx,
+	IN		u1Byte	VGA_idx
+	)
+{
+	s1Byte	rx_pwr_all = 0x00;
+	
+	switch (LNA_idx) {
+	case 0xf:
+		rx_pwr_all = -48 - (2 * VGA_idx);
+		break;		
+	case 0xb:
+		rx_pwr_all = -42 - (2 * VGA_idx); /*TBD*/
+		break;
+	case 0xa:
+		rx_pwr_all = -36 - (2 * VGA_idx);
+		break;
+	case 8:
+		rx_pwr_all = -32 - (2 * VGA_idx);
+		break;
+	case 7:	
+		rx_pwr_all = -19 - (2 * VGA_idx);
+		break;
+	case 4:	
+		rx_pwr_all = -6 - (2 * VGA_idx);
+		break;
+	case 0:	
+		rx_pwr_all = -2 - (2 * VGA_idx);
+		break;
+	default:
+	/*rx_pwr_all = -53+(2*(31-VGA_idx));*/
+	/*DbgPrint("wrong LNA index\n");*/
+		break;
+			
+	}
+	return	rx_pwr_all;
+}
+
+VOID
+odm_RxPhyStatus92CSeries_Parsing(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	OUT		PODM_PHY_INFO_T			pPhyInfo,		
+	IN 		pu1Byte						pPhyStatus,
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{							
+	SWAT_T				*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u1Byte				i, Max_spatial_stream;
+	s1Byte				rx_pwr[4], rx_pwr_all=0;
+	u1Byte				EVM, PWDB_ALL = 0, PWDB_ALL_BT;
+	u1Byte				RSSI, total_rssi=0;
+	BOOLEAN				isCCKrate=FALSE;	
+	u1Byte				rf_rx_num = 0;
+	u1Byte				cck_highpwr = 0;
+	u1Byte				LNA_idx = 0;
+	u1Byte				VGA_idx = 0;
+	PPHY_STATUS_RPT_8192CD_T pPhyStaRpt = (PPHY_STATUS_RPT_8192CD_T)pPhyStatus;
+
+	isCCKrate = (pPktinfo->DataRate <= ODM_RATE11M) ? TRUE : FALSE;
+	pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_A] = -1;
+	pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_B] = -1;
+
+
+	if(isCCKrate)
+	{
+		u1Byte report;
+		u1Byte cck_agc_rpt;
+		
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK++;
+		// 
+		// (1)Hardware does not provide RSSI for CCK
+		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		//
+
+		//if(pHalData->eRFPowerState == eRfOn)
+			cck_highpwr = pDM_Odm->bCckHighPower;
+		//else
+		//	cck_highpwr = FALSE;
+
+		cck_agc_rpt =  pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a ;
+		
+		//2011.11.28 LukeLee: 88E use different LNA & VGA gain table
+		//The RSSI formula should be modified according to the gain table
+		//In 88E, cck_highpwr is always set to 1
+		if (pDM_Odm->SupportICType & (ODM_RTL8703B)) {
+			
+			#if (RTL8703B_SUPPORT == 1)
+			if (pDM_Odm->cck_agc_report_type == 1) {  /*4 bit LNA*/
+
+				u1Byte cck_agc_rpt_b = (pPhyStaRpt->cck_rpt_b_ofdm_cfosho_b & BIT7) ? 1 : 0;
+								
+				LNA_idx = (cck_agc_rpt_b << 3) | ((cck_agc_rpt & 0xE0) >> 5);
+				VGA_idx = (cck_agc_rpt & 0x1F);
+				
+				rx_pwr_all = odm_CCKRSSI_8703B(LNA_idx, VGA_idx);
+				PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+				if (PWDB_ALL > 100)
+					PWDB_ALL = 100;	
+			
+			}
+			#endif
+		} else if (pDM_Odm->SupportICType & (ODM_RTL8188E | ODM_RTL8192E | ODM_RTL8723B | ODM_RTL8188F)) /*3 bit LNA*/
+		{
+			LNA_idx = ((cck_agc_rpt & 0xE0) >>5);
+			VGA_idx = (cck_agc_rpt & 0x1F); 
+			if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8192E))
+			{
+				if(pDM_Odm->cck_agc_report_type == 0 && (pDM_Odm->SupportICType & ODM_RTL8192E) )
+				{
+					switch(LNA_idx)
+					{
+						case 7:
+							rx_pwr_all = -45  - 2*(VGA_idx);
+							break;
+						case 6:
+							rx_pwr_all = -43 -2*(VGA_idx); 
+							break;
+						case 5:
+							rx_pwr_all = -27 - 2*(VGA_idx); 
+							break;
+						case 4:
+							rx_pwr_all = -21 - 2*(VGA_idx); 
+							break;
+						case 3:
+							rx_pwr_all = -18 - 2*(VGA_idx); 
+							break;
+						case 2:
+							rx_pwr_all = -6 - 2*(VGA_idx);
+							break;
+						case 1:
+							rx_pwr_all = 9 -2*(VGA_idx);
+							break;
+						case 0:
+							rx_pwr_all = 15 -2*(VGA_idx);
+							break;
+						default:
+
+							break;
+					}
+
+					if(pDM_Odm->BoardType & ODM_BOARD_EXT_LNA)
+					{
+						rx_pwr_all -= pDM_Odm->ExtLNAGain;
+					}
+					
+					PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+				}
+				else
+				{					
+					switch(LNA_idx)
+					{
+						case 7:
+							if(VGA_idx <= 27)
+								rx_pwr_all = -100 + 2*(27-VGA_idx); //VGA_idx = 27~2
+							else
+							rx_pwr_all = -100;
+							break;
+						case 6:
+							rx_pwr_all = -48 + 2*(2-VGA_idx); //VGA_idx = 2~0
+							break;
+						case 5:
+							rx_pwr_all = -42 + 2*(7-VGA_idx); //VGA_idx = 7~5
+							break;
+						case 4:
+							rx_pwr_all = -36 + 2*(7-VGA_idx); //VGA_idx = 7~4
+							break;
+						case 3:
+							//rx_pwr_all = -28 + 2*(7-VGA_idx); //VGA_idx = 7~0
+							rx_pwr_all = -24 + 2*(7-VGA_idx); //VGA_idx = 7~0
+							break;
+						case 2:
+							if(cck_highpwr)
+								rx_pwr_all = -12 + 2*(5-VGA_idx); //VGA_idx = 5~0
+							else
+								rx_pwr_all = -6+ 2*(5-VGA_idx);
+							break;
+						case 1:
+								rx_pwr_all = 8-2*VGA_idx;
+							break;
+						case 0:
+							rx_pwr_all = 14-2*VGA_idx;
+							break;
+						default:
+							//DbgPrint("CCK Exception default\n");
+							break;
+					}
+					rx_pwr_all += 8;
+
+					//2012.10.08 LukeLee: Modify for 92E CCK RSSI
+					if(pDM_Odm->SupportICType == ODM_RTL8192E)
+						rx_pwr_all += 8;
+					
+					PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+					if(cck_highpwr == FALSE)
+					{
+						if(PWDB_ALL >= 80)
+							PWDB_ALL = ((PWDB_ALL-80)<<1)+((PWDB_ALL-80)>>1)+80;
+						else if((PWDB_ALL <= 78) && (PWDB_ALL >= 20))
+							PWDB_ALL += 3;
+						if(PWDB_ALL>100)
+							PWDB_ALL = 100;
+					}
+				}
+			}
+			else if(pDM_Odm->SupportICType & (ODM_RTL8723B))
+			{
+#if (RTL8723B_SUPPORT == 1)			
+				rx_pwr_all = odm_CCKRSSI_8723B(LNA_idx,VGA_idx);
+				PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+				if(PWDB_ALL>100)
+					PWDB_ALL = 100;	
+#endif				
+			} else if (pDM_Odm->SupportICType & (ODM_RTL8188F)) {
+#if (RTL8188F_SUPPORT == 1)
+				rx_pwr_all = odm_CCKRSSI_8188F(LNA_idx, VGA_idx);
+				PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+				if (PWDB_ALL > 100)
+					PWDB_ALL = 100;
+#endif
+			}
+		}
+		else
+		{
+			if(!cck_highpwr)
+			{			
+				report =( cck_agc_rpt & 0xc0 )>>6;
+				switch(report)
+				{
+					// 03312009 modified by cosa
+					// Modify the RF RNA gain value to -40, -20, -2, 14 by Jenyu's suggestion
+					// Note: different RF with the different RNA gain.
+					case 0x3:
+						rx_pwr_all = -46 - (cck_agc_rpt & 0x3e);
+						break;
+					case 0x2:
+						rx_pwr_all = -26 - (cck_agc_rpt & 0x3e);
+						break;
+					case 0x1:
+						rx_pwr_all = -12 - (cck_agc_rpt & 0x3e);
+						break;
+					case 0x0:
+						rx_pwr_all = 16 - (cck_agc_rpt & 0x3e);
+						break;
+				}
+			}
+			else
+			{
+				//report = pDrvInfo->cfosho[0] & 0x60;			
+				//report = pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a& 0x60;
+				
+				report = (cck_agc_rpt & 0x60)>>5;
+				switch(report)
+				{
+					case 0x3:
+						rx_pwr_all = -46 - ((cck_agc_rpt & 0x1f)<<1) ;
+						break;
+					case 0x2:
+						rx_pwr_all = -26 - ((cck_agc_rpt & 0x1f)<<1);
+						break;
+					case 0x1:
+						rx_pwr_all = -12 - ((cck_agc_rpt & 0x1f)<<1) ;
+						break;
+					case 0x0:
+						rx_pwr_all = 16 - ((cck_agc_rpt & 0x1f)<<1) ;
+						break;
+				}
+			}
+
+			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+
+			//Modification for ext-LNA board
+			if(pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA))
+			{
+				if((cck_agc_rpt>>7) == 0){
+					PWDB_ALL = (PWDB_ALL>94)?100:(PWDB_ALL +6);
+				}
+				else	
+	                   {
+					if(PWDB_ALL > 38)
+						PWDB_ALL -= 16;
+					else
+						PWDB_ALL = (PWDB_ALL<=16)?(PWDB_ALL>>2):(PWDB_ALL -12);
+				}             
+
+				//CCK modification
+				if(PWDB_ALL > 25 && PWDB_ALL <= 60)
+					PWDB_ALL += 6;
+				//else if (PWDB_ALL <= 25)
+				//	PWDB_ALL += 8;
+			}
+			else//Modification for int-LNA board
+			{
+				if(PWDB_ALL > 99)
+				  	PWDB_ALL -= 8;
+				else if(PWDB_ALL > 50 && PWDB_ALL <= 68)
+					PWDB_ALL += 4;
+			}
+		}
+
+		pDM_Odm->cck_lna_idx = LNA_idx;
+		pDM_Odm->cck_vga_idx = VGA_idx;
+		pPhyInfo->RxPWDBAll = PWDB_ALL;
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+		pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
+		pPhyInfo->RecvSignalPower = rx_pwr_all;
+#endif		
+		//
+		// (3) Get Signal Quality (EVM)
+		//
+		//if(pPktinfo->bPacketMatchBSSID)
+		{
+			u1Byte	SQ,SQ_rpt;			
+			
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)			
+			if((pDM_Odm->SupportPlatform == ODM_WIN) &&
+				(pDM_Odm->PatchID==RT_CID_819x_Lenovo)){
+				SQ = odm_SQ_process_patch_RT_CID_819x_Lenovo(pDM_Odm,isCCKrate,PWDB_ALL,0,0);
+			}else if((pDM_Odm->SupportPlatform == ODM_WIN) &&
+				(pDM_Odm->PatchID==RT_CID_819x_Acer))
+			{
+				SQ = odm_SQ_process_patch_RT_CID_819x_Acer(pDM_Odm,isCCKrate,PWDB_ALL,0,0);
+			}else 
+#endif
+			if(pPhyInfo->RxPWDBAll > 40 && !pDM_Odm->bInHctTest){
+				SQ = 100;
+			}
+			else{						
+				SQ_rpt = pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all;
+					
+				if(SQ_rpt > 64)
+					SQ = 0;
+				else if (SQ_rpt < 20)
+					SQ = 100;
+				else
+					SQ = ((64-SQ_rpt) * 100) / 44;
+			
+			}
+			
+			//DbgPrint("cck SQ = %d\n", SQ);
+			pPhyInfo->SignalQuality = SQ;
+			pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_A] = SQ;
+			pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_B] = -1;
+		}
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX; i++) {
+			if (i == 0)
+				pPhyInfo->RxMIMOSignalStrength[0] = PWDB_ALL;
+			else
+				pPhyInfo->RxMIMOSignalStrength[1] = 0;
+		}
+	}
+	else //2 is OFDM rate
+	{
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM++;
+
+		// 
+		// (1)Get RSSI for HT rate
+		//
+		
+       	 for(i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX; i++)   
+		{
+			// 2008/01/30 MH we will judge RF RX path now.
+			if (pDM_Odm->RFPathRxEnable & BIT(i))
+				rf_rx_num++;
+			//else
+				//continue;
+
+			rx_pwr[i] = ((pPhyStaRpt->path_agc[i].gain& 0x3F)*2) - 110;
+			pDM_Odm->ofdm_agc_idx[i] = (pPhyStaRpt->path_agc[i].gain & 0x3F);
+
+		#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+			pPhyInfo->RxPwr[i] = rx_pwr[i];
+		#endif	
+
+			/* Translate DBM to percentage. */
+			RSSI = odm_QueryRxPwrPercentage(rx_pwr[i]);
+			total_rssi += RSSI;
+			//RT_DISP(FRX, RX_PHY_SS, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], RSSI));
+
+
+			if(pDM_Odm->SupportICType&ODM_RTL8192C)
+			{	
+			        //Modification for ext-LNA board	
+				if(pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA))
+				{
+					if((pPhyStaRpt->path_agc[i].trsw) == 1)
+						RSSI = (RSSI>94)?100:(RSSI +6);
+					else
+						RSSI = (RSSI<=16)?(RSSI>>3):(RSSI -16);
+
+					if((RSSI <= 34) && (RSSI >=4))
+						RSSI -= 4;
+				}		
+			}
+		
+			pPhyInfo->RxMIMOSignalStrength[i] =(u1Byte) RSSI;
+
+		#if (DM_ODM_SUPPORT_TYPE &  (/*ODM_WIN|*/ODM_CE|ODM_AP))
+			//Get Rx snr value in DB		
+			pPhyInfo->RxSNR[i] = pDM_Odm->PhyDbgInfo.RxSNRdB[i] = (s4Byte)(pPhyStaRpt->path_rxsnr[i]/2);
+		#endif
+		
+			/* Record Signal Strength for next packet */
+			//if(pPktinfo->bPacketMatchBSSID)
+			{				
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)				
+				if((pDM_Odm->SupportPlatform == ODM_WIN) &&
+					(pDM_Odm->PatchID==RT_CID_819x_Lenovo))
+				{
+					if(i==ODM_RF_PATH_A)
+						pPhyInfo->SignalQuality = odm_SQ_process_patch_RT_CID_819x_Lenovo(pDM_Odm,isCCKrate,PWDB_ALL,i,RSSI);
+				
+				}		
+				else if((pDM_Odm->SupportPlatform == ODM_WIN) &&
+					(pDM_Odm->PatchID==RT_CID_819x_Acer))
+				{
+					pPhyInfo->SignalQuality = odm_SQ_process_patch_RT_CID_819x_Acer(pDM_Odm,isCCKrate,PWDB_ALL,0,RSSI);
+				}	
+#endif				
+			}
+		}
+		
+		
+		//
+		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		//
+		rx_pwr_all = (((pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all) >> 1 )& 0x7f) -110;		
+		
+		PWDB_ALL_BT = PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);	
+	
+	
+		pPhyInfo->RxPWDBAll = PWDB_ALL;
+		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_RSSI_MONITOR, ODM_DBG_LOUD, ("ODM OFDM RSSI=%d\n",pPhyInfo->RxPWDBAll));
+	#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+		pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
+		pPhyInfo->RxPower = rx_pwr_all;
+		pPhyInfo->RecvSignalPower = rx_pwr_all;
+	#endif
+		
+		if((pDM_Odm->SupportPlatform == ODM_WIN) &&(pDM_Odm->PatchID==19)){
+			//do nothing	
+		}else if((pDM_Odm->SupportPlatform == ODM_WIN) &&(pDM_Odm->PatchID==25)){
+			//do nothing	
+		}
+		else{//pMgntInfo->CustomerID != RT_CID_819x_Lenovo
+			//
+			// (3)EVM of HT rate
+			//
+			if(pPktinfo->DataRate >=ODM_RATEMCS8 && pPktinfo->DataRate <=ODM_RATEMCS15)
+				Max_spatial_stream = 2; //both spatial stream make sense
+			else
+				Max_spatial_stream = 1; //only spatial stream 1 makes sense
+
+			for(i=0; i<Max_spatial_stream; i++)
+			{
+				// Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
+				// fill most significant bit to "zero" when doing shifting operation which may change a negative 
+				// value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.			
+				EVM = odm_EVMdbToPercentage( (pPhyStaRpt->stream_rxevm[i] ));	//dbm
+
+				//GET_RX_STATUS_DESC_RX_MCS(pDesc), pDrvInfo->rxevm[i], "%", EVM));
+				
+				//if(pPktinfo->bPacketMatchBSSID)
+				{
+					if(i==ODM_RF_PATH_A) // Fill value in RFD, Get the first spatial stream only
+					{						
+						pPhyInfo->SignalQuality = (u1Byte)(EVM & 0xff);
+					}					
+					pPhyInfo->RxMIMOSignalQuality[i] = (u1Byte)(EVM & 0xff);
+				}
+			}
+		}
+
+		ODM_ParsingCFO(pDM_Odm, pPktinfo, pPhyStaRpt->path_cfotail);
+		
+	}
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+	//UI BSS List signal strength(in percentage), make it good looking, from 0~100.
+	//It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
+	if(isCCKrate)
+	{		
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
+		pPhyInfo->SignalStrength = SignalScaleProc(pDM_Odm->Adapter, PWDB_ALL, TRUE, TRUE);
+#else
+	#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+		pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, PWDB_ALL));/*PWDB_ALL;*/
+	#else
+		pPhyInfo->SignalStrength = (u1Byte)PWDB_ALL;
+	#endif
+#endif /*#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)*/
+	}
+	else
+	{	
+		if (rf_rx_num != 0)
+		{			
+		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
+			pPhyInfo->SignalStrength = SignalScaleProc(pDM_Odm->Adapter, (total_rssi /= rf_rx_num), TRUE, FALSE);
+		#else
+			#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+			pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, total_rssi /= rf_rx_num));
+			#else
+			total_rssi/=rf_rx_num;
+			pPhyInfo->SignalStrength = (u1Byte)total_rssi;
+			#endif
+		#endif
+		}
+	}
+#endif /*#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))*/
+
+	//DbgPrint("isCCKrate = %d, pPhyInfo->RxPWDBAll = %d, pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a = 0x%x\n", 
+		//isCCKrate, pPhyInfo->RxPWDBAll, pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a);
+
+	//For 92C/92D HW (Hybrid) Antenna Diversity
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))	
+	pDM_SWAT_Table->antsel = pPhyStaRpt->ant_sel;
+	//For 88E HW Antenna Diversity
+	pDM_Odm->DM_FatTable.antsel_rx_keep_0 = pPhyStaRpt->ant_sel;
+	pDM_Odm->DM_FatTable.antsel_rx_keep_1 = pPhyStaRpt->ant_sel_b;
+	pDM_Odm->DM_FatTable.antsel_rx_keep_2 = pPhyStaRpt->antsel_rx_keep_2;
+#endif
+}
+#endif
+
+#if	ODM_IC_11AC_SERIES_SUPPORT
+
+VOID
+odm_RxPhyBWJaguarSeries_Parsing(
+	OUT		PODM_PHY_INFO_T			pPhyInfo,
+	IN		PODM_PACKET_INFO_T			pPktinfo,
+	IN		PPHY_STATUS_RPT_8812_T		pPhyStaRpt
+)
+{
+
+	if(pPktinfo->DataRate <= ODM_RATE54M) {
+		switch (pPhyStaRpt->r_RFMOD) {
+		case 1:
+			if (pPhyStaRpt->sub_chnl == 0)
+				pPhyInfo->BandWidth = 1;
+			else
+				pPhyInfo->BandWidth = 0;
+			break;
+
+		case 2:
+			if (pPhyStaRpt->sub_chnl == 0)
+				pPhyInfo->BandWidth = 2;
+			else if (pPhyStaRpt->sub_chnl == 9 || pPhyStaRpt->sub_chnl == 10)
+				pPhyInfo->BandWidth = 1;
+			else
+				pPhyInfo->BandWidth = 0;
+			break;
+
+		default:
+		case 0:
+			pPhyInfo->BandWidth = 0;
+			break;
+		}
+	}
+
+}
+
+VOID
+odm_RxPhyStatusJaguarSeries_Parsing(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	OUT		PODM_PHY_INFO_T			pPhyInfo,
+	IN 		pu1Byte						pPhyStatus,
+	IN		PODM_PACKET_INFO_T			pPktinfo
+)
+{
+	u1Byte					i, Max_spatial_stream;
+	s1Byte					rx_pwr[4], rx_pwr_all = 0;
+	u1Byte					EVM, EVMdbm, PWDB_ALL = 0, PWDB_ALL_BT;
+	u1Byte					RSSI, avg_rssi = 0, best_rssi = 0, second_rssi = 0;
+	u1Byte					isCCKrate = 0;	
+	u1Byte					rf_rx_num = 0;
+	u1Byte					cck_highpwr = 0;
+	u1Byte					LNA_idx, VGA_idx;
+	PPHY_STATUS_RPT_8812_T pPhyStaRpt = (PPHY_STATUS_RPT_8812_T)pPhyStatus;
+	pFAT_T					pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	odm_RxPhyBWJaguarSeries_Parsing(pPhyInfo, pPktinfo, pPhyStaRpt);
+
+	if (pPktinfo->DataRate <= ODM_RATE11M)
+		isCCKrate = TRUE;
+	else
+		isCCKrate = FALSE;
+
+	pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_A] = -1;
+	pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_B] = -1;
+	pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_C] = -1;
+	pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_D] = -1;
+
+	if (isCCKrate) {
+		u1Byte cck_agc_rpt;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK++;
+
+		/*(1)Hardware does not provide RSSI for CCK*/
+		/*(2)PWDB, Average PWDB calculated by hardware (for rate adaptive)*/
+
+		/*if(pHalData->eRFPowerState == eRfOn)*/
+		cck_highpwr = pDM_Odm->bCckHighPower;
+		/*else*/
+		/*cck_highpwr = FALSE;*/
+
+		cck_agc_rpt =  pPhyStaRpt->cfosho[0] ;
+		LNA_idx = ((cck_agc_rpt & 0xE0) >> 5);
+		VGA_idx = (cck_agc_rpt & 0x1F);
+
+		if (pDM_Odm->SupportICType == ODM_RTL8812) {
+			switch (LNA_idx) {
+			case 7:
+				if (VGA_idx <= 27)
+					rx_pwr_all = -100 + 2 * (27 - VGA_idx); /*VGA_idx = 27~2*/
+				else
+					rx_pwr_all = -100;
+				break;
+			case 6:
+				rx_pwr_all = -48 + 2 * (2 - VGA_idx); /*VGA_idx = 2~0*/
+				break;
+			case 5:
+				rx_pwr_all = -42 + 2 * (7 - VGA_idx); /*VGA_idx = 7~5*/
+				break;
+			case 4:
+				rx_pwr_all = -36 + 2 * (7 - VGA_idx); /*VGA_idx = 7~4*/
+				break;
+			case 3:
+				/*rx_pwr_all = -28 + 2*(7-VGA_idx); VGA_idx = 7~0*/
+				rx_pwr_all = -24 + 2 * (7 - VGA_idx); /*VGA_idx = 7~0*/
+				break;
+			case 2:
+				if (cck_highpwr)
+					rx_pwr_all = -12 + 2 * (5 - VGA_idx); /*VGA_idx = 5~0*/
+				else
+					rx_pwr_all = -6 + 2 * (5 - VGA_idx);
+				break;
+			case 1:
+				rx_pwr_all = 8 - 2 * VGA_idx;
+				break;
+			case 0:
+				rx_pwr_all = 14 - 2 * VGA_idx;
+				break;
+			default:
+				/*DbgPrint("CCK Exception default\n");*/
+				break;
+			}
+			rx_pwr_all += 6;
+			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+
+			if (cck_highpwr == FALSE) {
+				if (PWDB_ALL >= 80)
+					PWDB_ALL = ((PWDB_ALL - 80) << 1) + ((PWDB_ALL - 80) >> 1) + 80;
+				else if ((PWDB_ALL <= 78) && (PWDB_ALL >= 20))
+					PWDB_ALL += 3;
+				if (PWDB_ALL > 100)
+					PWDB_ALL = 100;
+			}
+		} else if (pDM_Odm->SupportICType & (ODM_RTL8821 | ODM_RTL8881A)) {
+			s1Byte Pout = -6;
+
+			switch (LNA_idx) {
+			case 5:
+				rx_pwr_all = Pout - 32 - (2 * VGA_idx);
+				break;
+			case 4:
+				rx_pwr_all = Pout - 24 - (2 * VGA_idx);
+				break;
+			case 2:
+				rx_pwr_all = Pout - 11 - (2 * VGA_idx);
+				break;
+			case 1:
+				rx_pwr_all = Pout + 5 - (2 * VGA_idx);
+				break;
+			case 0:
+				rx_pwr_all = Pout + 21 - (2 * VGA_idx);
+				break;
+			}
+			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+		} else if (pDM_Odm->SupportICType == ODM_RTL8814A || pDM_Odm->SupportICType == ODM_RTL8822B) {
+			s1Byte Pout = -6;
+
+			switch (LNA_idx) {
+			/*CCK only use LNA: 2, 3, 5, 7*/
+			case 7:
+				rx_pwr_all = Pout - 32 - (2 * VGA_idx);
+				break;
+			case 5:
+				rx_pwr_all = Pout - 22 - (2 * VGA_idx);
+				break;
+			case 3:
+				rx_pwr_all = Pout - 2 - (2 * VGA_idx);
+				break;
+			case 2:
+				rx_pwr_all = Pout + 5 - (2 * VGA_idx);
+				break;
+			/*case 6:*/
+			/*rx_pwr_all = Pout -26 - (2*VGA_idx);*/
+			/*break;*/
+			/*case 4:*/
+			/*rx_pwr_all = Pout - 8 - (2*VGA_idx);*/
+			/*break;*/
+			/*case 1:*/
+			/*rx_pwr_all = Pout + 21 - (2*VGA_idx);*/
+			/*break;*/
+			/*case 0:*/
+			/*rx_pwr_all = Pout + 10 - (2*VGA_idx);*/
+/*			//	break;*/
+			default:
+/*				//DbgPrint("CCK Exception default\n");*/
+				break;
+			}
+			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+		}
+
+		pPhyInfo->RxPWDBAll = PWDB_ALL;
+/*		//if(pPktinfo->StationID == 0)*/
+/*		//{*/
+/*		//	DbgPrint("CCK: LNA_idx = %d, VGA_idx = %d, pPhyInfo->RxPWDBAll = %d\n",*/
+/*		//		LNA_idx, VGA_idx, pPhyInfo->RxPWDBAll);*/
+/*		//}*/
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+		pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
+		pPhyInfo->RecvSignalPower = rx_pwr_all;
+#endif
+		/*(3) Get Signal Quality (EVM)*/
+		if (pPktinfo->bPacketMatchBSSID) {
+			u1Byte	SQ, SQ_rpt;
+
+			if ((pDM_Odm->SupportPlatform == ODM_WIN) &&
+				(pDM_Odm->PatchID == RT_CID_819x_Lenovo)) {
+				SQ = odm_SQ_process_patch_RT_CID_819x_Lenovo(pDM_Odm, isCCKrate, PWDB_ALL, 0, 0);
+			} else if (pPhyInfo->RxPWDBAll > 40 && !pDM_Odm->bInHctTest) {
+				SQ = 100;
+			} else {
+				SQ_rpt = pPhyStaRpt->pwdb_all;
+
+				if (SQ_rpt > 64)
+					SQ = 0;
+				else if (SQ_rpt < 20)
+					SQ = 100;
+				else
+					SQ = ((64 - SQ_rpt) * 100) / 44;
+			}
+
+/*			//DbgPrint("cck SQ = %d\n", SQ);*/
+			pPhyInfo->SignalQuality = SQ;
+			pPhyInfo->RxMIMOSignalQuality[ODM_RF_PATH_A] = SQ;
+		}
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+			if (i == 0)
+				pPhyInfo->RxMIMOSignalStrength[0] = PWDB_ALL;
+			else
+				pPhyInfo->RxMIMOSignalStrength[i] = 0;
+		}
+	} else {		 
+		/*is OFDM rate*/
+		pDM_FatTable->hw_antsw_occur = pPhyStaRpt->hw_antsw_occur;
+		
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM++;
+
+		/*(1)Get RSSI for OFDM rate*/
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+			/*2008/01/30 MH we will judge RF RX path now.*/
+/*			//DbgPrint("pDM_Odm->RFPathRxEnable = %x\n", pDM_Odm->RFPathRxEnable);*/
+			if (pDM_Odm->RFPathRxEnable & BIT(i))
+				rf_rx_num++;
+/*			//else*/
+/*			//continue;*/
+			/*2012.05.25 LukeLee: Testchip AGC report is wrong, it should be restored back to old formula in MP chip*/
+/*			//if((pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) && (!pDM_Odm->bIsMPChip))*/
+			if (i < ODM_RF_PATH_C)
+				rx_pwr[i] = (pPhyStaRpt->gain_trsw[i] & 0x7F) - 110;
+			else
+				rx_pwr[i] = (pPhyStaRpt->gain_trsw_cd[i - 2] & 0x7F) - 110;
+/*			//else*/
+			/*rx_pwr[i] = ((pPhyStaRpt->gain_trsw[i]& 0x3F)*2) - 110;  OLD FORMULA*/
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+			pPhyInfo->RxPwr[i] = rx_pwr[i];
+#endif
+
+			/* Translate DBM to percentage. */
+			RSSI = odm_QueryRxPwrPercentage(rx_pwr[i]);	
+		
+			/*total_rssi += RSSI;*/
+			/*Get the best two RSSI*/
+			if (RSSI > best_rssi && RSSI > second_rssi) {
+				second_rssi = best_rssi;
+				best_rssi = RSSI;
+			} else if (RSSI > second_rssi && RSSI <= best_rssi)
+				second_rssi = RSSI;
+
+			/*RT_DISP(FRX, RX_PHY_SS, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], RSSI));*/
+
+			pPhyInfo->RxMIMOSignalStrength[i] = (u1Byte) RSSI;
+
+
+			/*Get Rx snr value in DB*/
+			if (i < ODM_RF_PATH_C)
+				pPhyInfo->RxSNR[i] = pDM_Odm->PhyDbgInfo.RxSNRdB[i] = pPhyStaRpt->rxsnr[i] / 2;
+			else if (pDM_Odm->SupportICType & (ODM_RTL8814A | ODM_RTL8822B))
+				pPhyInfo->RxSNR[i] = pDM_Odm->PhyDbgInfo.RxSNRdB[i] = pPhyStaRpt->csi_current[i - 2] / 2;
+
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+			/*(2) CFO_short  & CFO_tail*/
+			if (i < ODM_RF_PATH_C) {
+				pPhyInfo->Cfo_short[i] = odm_Cfo((pPhyStaRpt->cfosho[i]));
+				pPhyInfo->Cfo_tail[i] = odm_Cfo((pPhyStaRpt->cfotail[i]));
+			}
+#endif
+			/* Record Signal Strength for next packet */
+			if (pPktinfo->bPacketMatchBSSID) {
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+				if ((pDM_Odm->SupportPlatform == ODM_WIN) &&
+					(pDM_Odm->PatchID == RT_CID_819x_Lenovo)) {
+					if (i == ODM_RF_PATH_A)
+						pPhyInfo->SignalQuality = odm_SQ_process_patch_RT_CID_819x_Lenovo(pDM_Odm, isCCKrate, PWDB_ALL, i, RSSI);
+
+				}
+#endif
+			}
+		}
+
+		/*(3)PWDB, Average PWDB calculated by hardware (for rate adaptive)*/
+
+		/*2012.05.25 LukeLee: Testchip AGC report is wrong, it should be restored back to old formula in MP chip*/
+		if ((pDM_Odm->SupportICType & (ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A)) && (!pDM_Odm->bIsMPChip))
+			rx_pwr_all = (pPhyStaRpt->pwdb_all & 0x7f) - 110;
+		else
+			rx_pwr_all = (((pPhyStaRpt->pwdb_all) >> 1) & 0x7f) - 110;	 /*OLD FORMULA*/
+
+		PWDB_ALL_BT = PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+
+		pPhyInfo->RxPWDBAll = PWDB_ALL;
+		/*ODM_RT_TRACE(pDM_Odm,ODM_COMP_RSSI_MONITOR, ODM_DBG_LOUD, ("ODM OFDM RSSI=%d\n",pPhyInfo->RxPWDBAll));*/
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+		pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
+		pPhyInfo->RxPower = rx_pwr_all;
+		pPhyInfo->RecvSignalPower = rx_pwr_all;
+#endif
+
+		if ((pDM_Odm->SupportPlatform == ODM_WIN) && (pDM_Odm->PatchID == 19)) {
+			/*do nothing*/
+		} else {
+			/*pMgntInfo->CustomerID != RT_CID_819x_Lenovo*/
+
+			/*(4)EVM of OFDM rate*/
+			
+			if ((pPktinfo->DataRate >= ODM_RATEMCS8) &&
+				(pPktinfo->DataRate <= ODM_RATEMCS15))
+				Max_spatial_stream = 2;
+			else if ((pPktinfo->DataRate >= ODM_RATEVHTSS2MCS0) &&
+					 (pPktinfo->DataRate <= ODM_RATEVHTSS2MCS9))
+				Max_spatial_stream = 2;
+			else if ((pPktinfo->DataRate >= ODM_RATEMCS16) &&
+					 (pPktinfo->DataRate <= ODM_RATEMCS23))
+				Max_spatial_stream = 3;
+			else if ((pPktinfo->DataRate >= ODM_RATEVHTSS3MCS0) &&
+					 (pPktinfo->DataRate <= ODM_RATEVHTSS3MCS9))
+				Max_spatial_stream = 3;
+			else
+				Max_spatial_stream = 1;
+
+			if (pPktinfo->bPacketMatchBSSID) {
+				/*DbgPrint("pPktinfo->DataRate = %d\n", pPktinfo->DataRate);*/
+
+				for (i = 0; i < Max_spatial_stream; i++) {
+					/*Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment*/
+					/*fill most significant bit to "zero" when doing shifting operation which may change a negative*/
+					/*value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.*/
+
+					if (pPktinfo->DataRate >= ODM_RATE6M && pPktinfo->DataRate <= ODM_RATE54M) {
+						if (i == ODM_RF_PATH_A) {
+							EVM = odm_EVMdbToPercentage((pPhyStaRpt->sigevm));	/*dbm*/
+							EVM += 20;
+							if (EVM > 100)
+								EVM = 100;
+						}
+					} else {
+						if (i < ODM_RF_PATH_C) {
+							if (pPhyStaRpt->rxevm[i] == -128)
+								pPhyStaRpt->rxevm[i] = -25;
+							EVM = odm_EVMdbToPercentage((pPhyStaRpt->rxevm[i]));	/*dbm*/
+						} else {
+							if (pPhyStaRpt->rxevm_cd[i - 2] == -128){
+								pPhyStaRpt->rxevm_cd[i - 2] = -25;
+							}
+							EVM = odm_EVMdbToPercentage((pPhyStaRpt->rxevm_cd[i - 2]));	/*dbm*/
+						}
+					}
+
+					if (i < ODM_RF_PATH_C)
+						EVMdbm = odm_EVMdbm_JaguarSeries(pPhyStaRpt->rxevm[i]);
+					else
+						EVMdbm = odm_EVMdbm_JaguarSeries(pPhyStaRpt->rxevm_cd[i - 2]);
+					/*RT_DISP(FRX, RX_PHY_SQ, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",*/
+					/*pPktinfo->DataRate, pPhyStaRpt->rxevm[i], "%", EVM));*/
+
+					{
+						if (i == ODM_RF_PATH_A) { 
+							/*Fill value in RFD, Get the first spatial stream only*/
+							pPhyInfo->SignalQuality = EVM;
+						}
+						pPhyInfo->RxMIMOSignalQuality[i] = EVM;
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+						pPhyInfo->RxMIMOEVMdbm[i] = EVMdbm;
+#endif
+					}
+				}
+			}
+		}
+
+		ODM_ParsingCFO(pDM_Odm, pPktinfo, pPhyStaRpt->cfotail);
+
+	}
+/*	//DbgPrint("isCCKrate= %d, pPhyInfo->SignalStrength=%d % PWDB_AL=%d rf_rx_num=%d\n", isCCKrate, pPhyInfo->SignalStrength, PWDB_ALL, rf_rx_num);*/
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+	/*UI BSS List signal strength(in percentage), make it good looking, from 0~100.*/
+	/*It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().*/
+	if (isCCKrate) {
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		/*2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/*/
+		pPhyInfo->SignalStrength = SignalScaleProc(pDM_Odm->Adapter, PWDB_ALL, FALSE, TRUE);
+#else
+		pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, PWDB_ALL));/*PWDB_ALL;*/
+#endif
+	} else {	
+		if (rf_rx_num != 0) {
+			/* 2015/01 Sean, use the best two RSSI only, suggested by Ynlin and ChenYu.*/
+			if (rf_rx_num == 1)
+				avg_rssi = best_rssi;
+			else
+				avg_rssi = (best_rssi + second_rssi)/2;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			/* 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/*/	
+			pPhyInfo->SignalStrength = SignalScaleProc(pDM_Odm->Adapter, avg_rssi, FALSE, FALSE);
+#else
+			pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, avg_rssi));
+#endif
+		}
+	}
+#endif
+	pDM_Odm->RxPWDBAve = pDM_Odm->RxPWDBAve + pPhyInfo->RxPWDBAll;
+
+	pDM_Odm->DM_FatTable.antsel_rx_keep_0 = pPhyStaRpt->antidx_anta;
+	pDM_Odm->DM_FatTable.antsel_rx_keep_1 = pPhyStaRpt->antidx_antb;
+	pDM_Odm->DM_FatTable.antsel_rx_keep_2 = pPhyStaRpt->antidx_antc;
+	pDM_Odm->DM_FatTable.antsel_rx_keep_3 = pPhyStaRpt->antidx_antd;
+	/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("StaID[%d]:  antidx_anta = ((%d)), MatchBSSID =  ((%d))\n", pPktinfo->StationID, pPhyStaRpt->antidx_anta, pPktinfo->bPacketMatchBSSID));*/
+
+
+/*		DbgPrint("pPhyStaRpt->antidx_anta = %d, pPhyStaRpt->antidx_antb = %d\n",*/
+/*			pPhyStaRpt->antidx_anta, pPhyStaRpt->antidx_antb);*/
+/*		DbgPrint("----------------------------\n");*/
+/*		DbgPrint("pPktinfo->StationID=%d, pPktinfo->DataRate=0x%x\n",pPktinfo->StationID, pPktinfo->DataRate);*/
+/*		DbgPrint("pPhyStaRpt->r_RFMOD = %d\n", pPhyStaRpt->r_RFMOD);*/
+/*		DbgPrint("pPhyStaRpt->gain_trsw[0]=0x%x, pPhyStaRpt->gain_trsw[1]=0x%x\n",*/
+/*				pPhyStaRpt->gain_trsw[0],pPhyStaRpt->gain_trsw[1]);*/
+/*		DbgPrint("pPhyStaRpt->gain_trsw[2]=0x%x, pPhyStaRpt->gain_trsw[3]=0x%x\n",*/
+/*				pPhyStaRpt->gain_trsw_cd[0],pPhyStaRpt->gain_trsw_cd[1]);*/
+/*		DbgPrint("pPhyStaRpt->pwdb_all = 0x%x, pPhyInfo->RxPWDBAll = %d\n", pPhyStaRpt->pwdb_all, pPhyInfo->RxPWDBAll);*/
+/*		DbgPrint("pPhyStaRpt->cfotail[i] = 0x%x, pPhyStaRpt->CFO_tail[i] = 0x%x\n", pPhyStaRpt->cfotail[0], pPhyStaRpt->cfotail[1]);*/
+/*		DbgPrint("pPhyStaRpt->rxevm[0] = %d, pPhyStaRpt->rxevm[1] = %d\n", pPhyStaRpt->rxevm[0], pPhyStaRpt->rxevm[1]);*/
+/*		DbgPrint("pPhyStaRpt->rxevm[2] = %d, pPhyStaRpt->rxevm[3] = %d\n", pPhyStaRpt->rxevm_cd[0], pPhyStaRpt->rxevm_cd[1]);*/
+/*		DbgPrint("pPhyInfo->RxMIMOSignalStrength[0]=%d, pPhyInfo->RxMIMOSignalStrength[1]=%d, RxPWDBAll=%d\n",*/
+/*				pPhyInfo->RxMIMOSignalStrength[0], pPhyInfo->RxMIMOSignalStrength[1], pPhyInfo->RxPWDBAll);*/
+/*		DbgPrint("pPhyInfo->RxMIMOSignalStrength[2]=%d, pPhyInfo->RxMIMOSignalStrength[3]=%d\n",*/
+/*				pPhyInfo->RxMIMOSignalStrength[2], pPhyInfo->RxMIMOSignalStrength[3]);*/
+/*		DbgPrint("ppPhyInfo->RxMIMOSignalQuality[0]=%d, pPhyInfo->RxMIMOSignalQuality[1]=%d\n",*/
+/*				pPhyInfo->RxMIMOSignalQuality[0], pPhyInfo->RxMIMOSignalQuality[1]);*/
+/*		DbgPrint("ppPhyInfo->RxMIMOSignalQuality[2]=%d, pPhyInfo->RxMIMOSignalQuality[3]=%d\n",*/
+/*				pPhyInfo->RxMIMOSignalQuality[2], pPhyInfo->RxMIMOSignalQuality[3]);*/
+
+}
+
+#endif
+
+VOID
+odm_Init_RSSIForDM(
+	IN OUT	PDM_ODM_T	pDM_Odm
+	)
+{
+
+}
+
+VOID
+odm_Process_RSSIForDM(	
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	IN		PODM_PHY_INFO_T				pPhyInfo,
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{
+	
+	s4Byte			UndecoratedSmoothedPWDB, UndecoratedSmoothedCCK, UndecoratedSmoothedOFDM, RSSI_Ave;
+	u1Byte			i, isCCKrate=0;	
+	u1Byte			RSSI_max, RSSI_min;
+	u4Byte			OFDM_pkt=0; 
+	u4Byte			Weighting=0;
+	PSTA_INFO_T           	pEntry;
+	#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))	
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	#endif
+
+	if (pPktinfo->StationID >= ODM_ASSOCIATE_ENTRY_NUM)
+		return;
+
+	#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
+	odm_S0S1_SwAntDivByCtrlFrame_ProcessRSSI(pDM_Odm, pPhyInfo, pPktinfo);
+	#endif
+
+	//
+	// 2012/05/30 MH/Luke.Lee Add some description 
+	// In windows driver: AP/IBSS mode STA
+	//
+	//if (pDM_Odm->SupportPlatform == ODM_WIN)
+	//{
+	//	pEntry = pDM_Odm->pODM_StaInfo[pDM_Odm->pAidMap[pPktinfo->StationID-1]];			
+	//}
+	//else
+		pEntry = pDM_Odm->pODM_StaInfo[pPktinfo->StationID];							
+
+	if(!IS_STA_VALID(pEntry) )
+	{		
+		return;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))	
+	if ((pDM_Odm->SupportAbility & ODM_BB_ANT_DIV) &&
+		(pDM_FatTable->enable_ctrl_frame_antdiv)
+	)
+	{
+		if (pPktinfo->bPacketMatchBSSID)
+			pDM_Odm->data_frame_num++;
+				
+		if ((pDM_FatTable->use_ctrl_frame_antdiv)) {
+			if (!pPktinfo->bToSelf)/*data frame + CTRL frame*/
+				return;
+		} else {
+			if ((!pPktinfo->bPacketMatchBSSID))/*data frame only*/
+				return;
+		}	
+	} else
+#endif
+	{
+		if ((!pPktinfo->bPacketMatchBSSID))/*data frame only*/
+			return;
+	}
+
+	if(pPktinfo->bPacketBeacon)
+		pDM_Odm->PhyDbgInfo.NumQryBeaconPkt++;
+	
+	isCCKrate = (pPktinfo->DataRate <= ODM_RATE11M )?TRUE :FALSE;
+	pDM_Odm->RxRate = pPktinfo->DataRate;
+
+	//--------------Statistic for antenna/path diversity------------------
+	if(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)
+	{
+		#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+			ODM_Process_RSSIForAntDiv(pDM_Odm,pPhyInfo,pPktinfo);
+		#endif
+	}
+	#if(defined(CONFIG_PATH_DIVERSITY))
+	else if(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV)
+	{
+		phydm_process_rssi_for_path_div(pDM_Odm,pPhyInfo,pPktinfo);
+	}
+	#endif
+	//-----------------Smart Antenna Debug Message------------------//
+	
+	UndecoratedSmoothedCCK =  pEntry->rssi_stat.UndecoratedSmoothedCCK;
+	UndecoratedSmoothedOFDM = pEntry->rssi_stat.UndecoratedSmoothedOFDM;
+	UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;	
+	
+	if(pPktinfo->bPacketToSelf || pPktinfo->bPacketBeacon)
+	{
+
+		if(!isCCKrate)//ofdm rate
+		{
+#if (RTL8814A_SUPPORT == 1) || (RTL8822B_SUPPORT == 1)
+			if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8822B)) {
+				u1Byte RX_count = 0;
+				u4Byte RSSI_linear = 0;
+
+				if (pDM_Odm->RXAntStatus & ODM_RF_A) {
+					pDM_Odm->RSSI_A = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+					RX_count++;
+					RSSI_linear += odm_ConvertTo_linear(pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A]);
+				} else
+					pDM_Odm->RSSI_A = 0;
+
+				if (pDM_Odm->RXAntStatus & ODM_RF_B) {
+					pDM_Odm->RSSI_B = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B];
+					RX_count++;
+					RSSI_linear += odm_ConvertTo_linear(pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B]);
+				} else
+					pDM_Odm->RSSI_B = 0;
+				
+				if (pDM_Odm->RXAntStatus & ODM_RF_C) {
+					pDM_Odm->RSSI_C = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_C];
+					RX_count++;
+					RSSI_linear += odm_ConvertTo_linear(pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_C]);
+				} else
+					pDM_Odm->RSSI_C = 0;
+
+				if (pDM_Odm->RXAntStatus & ODM_RF_D) {
+					pDM_Odm->RSSI_D = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_D];
+					RX_count++;
+					RSSI_linear += odm_ConvertTo_linear(pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_D]);
+				} else
+					pDM_Odm->RSSI_D = 0;
+
+				/* Calculate average RSSI */
+				switch (RX_count) {
+				case 2:
+					RSSI_linear = (RSSI_linear >> 1);
+					break;
+				case 3:
+					RSSI_linear = ((RSSI_linear) + (RSSI_linear << 1) + (RSSI_linear << 3)) >> 5;	/* RSSI_linear/3 ~ RSSI_linear*11/32 */
+					break;
+				case 4:
+					RSSI_linear = (RSSI_linear >> 2);
+					break;
+				}			
+				RSSI_Ave = odm_ConvertTo_dB(RSSI_linear);
+			} else
+#endif
+			{
+				if (pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B] == 0) {
+					RSSI_Ave = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+					pDM_Odm->RSSI_A = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+					pDM_Odm->RSSI_B = 0;
+				} else {
+					/*DbgPrint("pRfd->Status.RxMIMOSignalStrength[0] = %d, pRfd->Status.RxMIMOSignalStrength[1] = %d\n",*/ 
+						/*pRfd->Status.RxMIMOSignalStrength[0], pRfd->Status.RxMIMOSignalStrength[1]);*/
+					pDM_Odm->RSSI_A =  pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+					pDM_Odm->RSSI_B = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B];
+				
+					if (pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A] > pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B]) {
+						RSSI_max = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+						RSSI_min = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B];
+					} else {
+						RSSI_max = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B];
+						RSSI_min = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+					}
+					if ((RSSI_max - RSSI_min) < 3)
+						RSSI_Ave = RSSI_max;
+					else if ((RSSI_max - RSSI_min) < 6)
+						RSSI_Ave = RSSI_max - 1;
+					else if ((RSSI_max - RSSI_min) < 10)
+						RSSI_Ave = RSSI_max - 2;
+					else
+						RSSI_Ave = RSSI_max - 3;
+				}
+			}
+					
+			//1 Process OFDM RSSI
+			if(UndecoratedSmoothedOFDM <= 0)	// initialize
+			{
+				UndecoratedSmoothedOFDM = pPhyInfo->RxPWDBAll;
+			}
+			else
+			{
+				if(pPhyInfo->RxPWDBAll > (u4Byte)UndecoratedSmoothedOFDM)
+				{
+					UndecoratedSmoothedOFDM = 	
+							( ((UndecoratedSmoothedOFDM)*(Rx_Smooth_Factor-1)) + 
+							(RSSI_Ave)) /(Rx_Smooth_Factor);
+					UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM + 1;
+				}
+				else
+				{
+					UndecoratedSmoothedOFDM = 	
+							( ((UndecoratedSmoothedOFDM)*(Rx_Smooth_Factor-1)) + 
+							(RSSI_Ave)) /(Rx_Smooth_Factor);
+				}
+			}				
+			if (pEntry->rssi_stat.OFDM_pkt != 64) {
+				i = 63;
+				pEntry->rssi_stat.OFDM_pkt -= (u4Byte)(((pEntry->rssi_stat.PacketMap>>i)&BIT0)-1);
+			}
+			pEntry->rssi_stat.PacketMap = (pEntry->rssi_stat.PacketMap<<1) | BIT0;			
+										
+		}
+		else
+		{
+			RSSI_Ave = pPhyInfo->RxPWDBAll;
+			pDM_Odm->RSSI_A = (u1Byte) pPhyInfo->RxPWDBAll;
+			pDM_Odm->RSSI_B = 0xFF;
+			pDM_Odm->RSSI_C = 0xFF;
+			pDM_Odm->RSSI_D = 0xFF;
+
+			//1 Process CCK RSSI
+			if(UndecoratedSmoothedCCK <= 0)	// initialize
+			{
+				UndecoratedSmoothedCCK = pPhyInfo->RxPWDBAll;
+			}
+			else
+			{
+				if(pPhyInfo->RxPWDBAll > (u4Byte)UndecoratedSmoothedCCK)
+				{
+					UndecoratedSmoothedCCK = 	
+							( ((UndecoratedSmoothedCCK)*(Rx_Smooth_Factor-1)) + 
+							(pPhyInfo->RxPWDBAll)) /(Rx_Smooth_Factor);
+					UndecoratedSmoothedCCK = UndecoratedSmoothedCCK + 1;
+				}
+				else
+				{
+					UndecoratedSmoothedCCK = 	
+							( ((UndecoratedSmoothedCCK)*(Rx_Smooth_Factor-1)) + 
+							(pPhyInfo->RxPWDBAll)) /(Rx_Smooth_Factor);
+				}
+			}
+			i = 63;
+			pEntry->rssi_stat.OFDM_pkt -= (u4Byte)((pEntry->rssi_stat.PacketMap>>i)&BIT0);			
+			pEntry->rssi_stat.PacketMap = pEntry->rssi_stat.PacketMap<<1;			
+		}
+
+		//if(pEntry)
+		{
+			//2011.07.28 LukeLee: modified to prevent unstable CCK RSSI
+			if (pEntry->rssi_stat.OFDM_pkt == 64) { /* speed up when all packets are OFDM*/
+				UndecoratedSmoothedPWDB = UndecoratedSmoothedOFDM;
+			} else {
+				if (pEntry->rssi_stat.ValidBit < 64)
+					pEntry->rssi_stat.ValidBit++;
+
+				if (pEntry->rssi_stat.ValidBit == 64) {
+					Weighting = ((pEntry->rssi_stat.OFDM_pkt<<4) > 64)?64:(pEntry->rssi_stat.OFDM_pkt<<4);
+					UndecoratedSmoothedPWDB = (Weighting*UndecoratedSmoothedOFDM+(64-Weighting)*UndecoratedSmoothedCCK)>>6;
+				} else {
+					if (pEntry->rssi_stat.ValidBit != 0)
+						UndecoratedSmoothedPWDB = (pEntry->rssi_stat.OFDM_pkt*UndecoratedSmoothedOFDM+(pEntry->rssi_stat.ValidBit-pEntry->rssi_stat.OFDM_pkt)*UndecoratedSmoothedCCK)/pEntry->rssi_stat.ValidBit;
+					else
+						UndecoratedSmoothedPWDB = 0;
+				}
+			}
+			#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+			if (pEntry->rssi_stat.UndecoratedSmoothedPWDB == -1)
+				phydm_ra_rssi_rpt_wk(pDM_Odm);
+			#endif
+			pEntry->rssi_stat.UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
+			pEntry->rssi_stat.UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM;
+			pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+
+			//DbgPrint("OFDM_pkt=%d, Weighting=%d\n", OFDM_pkt, Weighting);
+			//DbgPrint("UndecoratedSmoothedOFDM=%d, UndecoratedSmoothedPWDB=%d, UndecoratedSmoothedCCK=%d\n", 
+			//	UndecoratedSmoothedOFDM, UndecoratedSmoothedPWDB, UndecoratedSmoothedCCK);
+			
+		}
+	
+	}
+}
+
+
+#if(ODM_IC_11N_SERIES_SUPPORT ==1)
+//
+// Endianness before calling this API
+//
+VOID
+ODM_PhyStatusQuery_92CSeries(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	OUT		PODM_PHY_INFO_T				pPhyInfo,
+	IN 		pu1Byte						pPhyStatus,	
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{
+	odm_RxPhyStatus92CSeries_Parsing(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
+	odm_Process_RSSIForDM(pDM_Odm, pPhyInfo, pPktinfo);
+}
+#endif
+
+
+//
+// Endianness before calling this API
+//
+#if	ODM_IC_11AC_SERIES_SUPPORT
+
+VOID
+ODM_PhyStatusQuery_JaguarSeries(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	OUT		PODM_PHY_INFO_T			pPhyInfo,
+	IN 		pu1Byte						pPhyStatus,	
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{
+	odm_RxPhyStatusJaguarSeries_Parsing(
+							pDM_Odm,
+							pPhyInfo,
+							pPhyStatus,
+							pPktinfo);
+	
+	odm_Process_RSSIForDM(pDM_Odm,pPhyInfo,pPktinfo);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	//phydm_sbd_check(pDM_Odm);
+#endif
+}
+#endif
+
+VOID
+ODM_PhyStatusQuery(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	OUT		PODM_PHY_INFO_T			pPhyInfo,
+	IN 		pu1Byte						pPhyStatus,	
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{
+#if (RTL8822B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType & ODM_RTL8822B) {
+		phydm_RxPhyStatusJaguarSeries2(pDM_Odm, pPhyStatus, pPktinfo, pPhyInfo);
+		return;
+	}
+#endif
+
+#if	ODM_IC_11AC_SERIES_SUPPORT
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_PhyStatusQuery_JaguarSeries(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
+#endif
+
+#if	ODM_IC_11N_SERIES_SUPPORT
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES )
+		ODM_PhyStatusQuery_92CSeries(pDM_Odm,pPhyInfo,pPhyStatus,pPktinfo);
+#endif
+}
+	
+// For future use.
+VOIDODM_MacStatusQuery(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	IN 		pu1Byte						pMacStatus,
+	IN		u1Byte						MacID,	
+	IN		BOOLEAN						bPacketMatchBSSID,
+	IN		BOOLEAN						bPacketToSelf,
+	IN		BOOLEAN						bPacketBeacon
+	)
+{
+	// 2011/10/19 Driver team will handle in the future.
+	
+}
+
+
+//
+// If you want to add a new IC, Please follow below template and generate a new one.
+// 
+//
+
+HAL_STATUS
+ODM_ConfigRFWithHeaderFile(
+	IN 	PDM_ODM_T	        	pDM_Odm,
+	IN 	ODM_RF_Config_Type 		ConfigType,
+	IN 	ODM_RF_RADIO_PATH_E 	eRFPath
+    )
+{
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)	
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);	
+#endif
+
+   ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
+		 		("===>ODM_ConfigRFWithHeaderFile (%s)\n", (pDM_Odm->bIsMPChip) ? "MPChip" : "TestChip"));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
+				("pDM_Odm->SupportPlatform: 0x%X, pDM_Odm->SupportInterface: 0x%X, pDM_Odm->BoardType: 0x%X\n",
+				pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface, pDM_Odm->BoardType));
+
+//1 AP doesn't use PHYDM power tracking table in these ICs
+#if (DM_ODM_SUPPORT_TYPE !=  ODM_AP)
+#if (RTL8723A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+		if(ConfigType == CONFIG_RF_RADIO) {
+			if(eRFPath == ODM_RF_PATH_A)
+				READ_AND_CONFIG_MP(8723A,_RadioA);
+		}
+	}
+#endif
+#if (RTL8812A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		if(ConfigType == CONFIG_RF_RADIO) {
+			if(eRFPath == ODM_RF_PATH_A){
+				READ_AND_CONFIG_MP(8812A,_RadioA);
+			}
+			else if(eRFPath == ODM_RF_PATH_B){
+				READ_AND_CONFIG_MP(8812A,_RadioB);
+			}
+		}
+		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
+			#if (DM_ODM_SUPPORT_TYPE & ODM_WIN) && (DEV_BUS_TYPE == RT_PCI_INTERFACE)
+			HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+			if ((pHalData->EEPROMSVID == 0x17AA && pHalData->EEPROMSMID == 0xA811) ||
+				(pHalData->EEPROMSVID == 0x10EC && pHalData->EEPROMSMID == 0xA812) ||
+				(pHalData->EEPROMSVID == 0x10EC && pHalData->EEPROMSMID == 0x8812))
+				READ_AND_CONFIG_MP(8812A,_TXPWR_LMT_HM812A03);
+			else
+			#endif				
+			READ_AND_CONFIG_MP(8812A,_TXPWR_LMT);
+		}
+	}
+#endif
+#if (RTL8821A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		if(ConfigType == CONFIG_RF_RADIO) {
+	 		if(eRFPath == ODM_RF_PATH_A){
+				READ_AND_CONFIG_MP(8821A,_RadioA);
+			}
+		}
+		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
+			if (pDM_Odm->SupportInterface == ODM_ITRF_USB) {
+				if (pDM_Odm->ExtPA5G || pDM_Odm->ExtLNA5G)
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8811AU_FEM);
+				else
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8811AU_IPA);				
+			} 
+			else {
+				#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+				if (pMgntInfo->CustomerID == RT_CID_8821AE_ASUS_MB)
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8821A_SAR_8mm);
+				else if (pMgntInfo->CustomerID == RT_CID_ASUS_NB)
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8821A_SAR_5mm);
+				else
+				#endif
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8821A);			
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("<===8821_ODM_ConfigRFWithHeaderFile\n"));
+	}
+#endif
+
+#if (RTL8723B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if(ConfigType == CONFIG_RF_RADIO)
+			READ_AND_CONFIG_MP(8723B,_RadioA);
+		else if(ConfigType == CONFIG_RF_TXPWR_LMT)
+			READ_AND_CONFIG_MP(8723B,_TXPWR_LMT);
+	}
+#endif
+
+#if (RTL8192E_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		if(ConfigType == CONFIG_RF_RADIO) {
+		 	if(eRFPath == ODM_RF_PATH_A)
+				READ_AND_CONFIG_MP(8192E,_RadioA);
+			else if(eRFPath == ODM_RF_PATH_B)
+				READ_AND_CONFIG_MP(8192E,_RadioB);
+		} else if (ConfigType == CONFIG_RF_TXPWR_LMT) {
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN) && (DEV_BUS_TYPE == RT_PCI_INTERFACE)	/*Refine by Vincent Lan for 5mm SAR pwr limit*/
+			HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+			if ((pHalData->EEPROMSVID == 0x11AD && pHalData->EEPROMSMID == 0x8192) || 
+				(pHalData->EEPROMSVID == 0x11AD && pHalData->EEPROMSMID == 0x8193))
+				READ_AND_CONFIG_MP(8192E, _TXPWR_LMT_8192E_SAR_5mm);
+			else
+#endif	
+			READ_AND_CONFIG_MP(8192E,_TXPWR_LMT);
+	}
+	}
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE !=  ODM_AP)
+
+//1 All platforms support
+#if (RTL8188E_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		if(ConfigType == CONFIG_RF_RADIO) {
+			if(eRFPath == ODM_RF_PATH_A)
+					READ_AND_CONFIG_MP(8188E,_RadioA);
+		}
+		else if(ConfigType == CONFIG_RF_TXPWR_LMT)
+			READ_AND_CONFIG_MP(8188E,_TXPWR_LMT);
+	}
+#endif
+#if (RTL8814A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8814A)
+	{
+		if(ConfigType == CONFIG_RF_RADIO) {
+		 	if(eRFPath == ODM_RF_PATH_A)
+				READ_AND_CONFIG_MP(8814A,_RadioA);
+			else if(eRFPath == ODM_RF_PATH_B)
+				READ_AND_CONFIG_MP(8814A,_RadioB);
+			else if(eRFPath == ODM_RF_PATH_C)
+				READ_AND_CONFIG_MP(8814A,_RadioC);
+			else if(eRFPath == ODM_RF_PATH_D)
+				READ_AND_CONFIG_MP(8814A,_RadioD);
+		}	
+		else if(ConfigType == CONFIG_RF_TXPWR_LMT) 
+			READ_AND_CONFIG_MP(8814A,_TXPWR_LMT);
+	}
+#endif
+#if (RTL8703B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8703B) {
+		if (ConfigType == CONFIG_RF_RADIO) {
+			if (eRFPath == ODM_RF_PATH_A)
+				READ_AND_CONFIG_MP(8703B, _RadioA);
+		}	
+	}
+#endif
+
+#if (RTL8188F_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8188F) {
+		if (ConfigType == CONFIG_RF_RADIO) {
+			if (eRFPath == ODM_RF_PATH_A)
+				READ_AND_CONFIG_MP(8188F, _RadioA);
+		} else if (ConfigType == CONFIG_RF_TXPWR_LMT)
+			READ_AND_CONFIG_MP(8188F, _TXPWR_LMT);
+	}
+#endif
+
+//1 New ICs (WIN only)
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+#if (RTL8821B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8821B)
+	{
+		if (ConfigType == CONFIG_RF_RADIO) {
+	 		if (eRFPath == ODM_RF_PATH_A)
+				READ_AND_CONFIG(8821B, _RadioA);
+		} else if (ConfigType == CONFIG_RF_TXPWR_LMT)
+			READ_AND_CONFIG(8821B, _TXPWR_LMT);
+	}
+#endif
+#if (RTL8822B_SUPPORT == 1)
+		if (pDM_Odm->SupportICType == ODM_RTL8822B)
+		{
+			if(ConfigType == CONFIG_RF_RADIO) {
+				if(eRFPath == ODM_RF_PATH_A)
+					READ_AND_CONFIG_MP(8822B, _RadioA);
+				else if(eRFPath == ODM_RF_PATH_B)
+					READ_AND_CONFIG_MP(8822B, _RadioB);
+			}	
+		}
+#endif
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+#if (RTL8188F_SUPPORT == 1)
+		if (pDM_Odm->SupportICType == ODM_RTL8188F)
+		{
+			if(ConfigType == CONFIG_RF_RADIO) {
+				if(eRFPath == ODM_RF_PATH_A)
+					READ_AND_CONFIG_TC(8188F,_RadioA);
+			}	
+		}
+#endif
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+
+	return HAL_STATUS_SUCCESS;
+}
+
+HAL_STATUS
+ODM_ConfigRFWithTxPwrTrackHeaderFile(
+	IN 	PDM_ODM_T	        	pDM_Odm
+    )
+{
+   	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
+		 		 ("===>ODM_ConfigRFWithTxPwrTrackHeaderFile (%s)\n", (pDM_Odm->bIsMPChip) ? "MPChip" : "TestChip"));
+   	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
+				 ("pDM_Odm->SupportPlatform: 0x%X, pDM_Odm->SupportInterface: 0x%X, pDM_Odm->BoardType: 0x%X\n",
+				 pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface, pDM_Odm->BoardType));
+
+
+//1 AP doesn't use PHYDM power tracking table in these ICs
+#if (DM_ODM_SUPPORT_TYPE !=  ODM_AP)
+#if RTL8821A_SUPPORT
+	if(pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
+			READ_AND_CONFIG_MP(8821A,_TxPowerTrack_PCIE);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
+			READ_AND_CONFIG_MP(8821A,_TxPowerTrack_USB);			
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
+			READ_AND_CONFIG_MP(8821A,_TxPowerTrack_SDIO);
+	}
+#endif	
+#if RTL8812A_SUPPORT	
+	if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
+			READ_AND_CONFIG_MP(8812A,_TxPowerTrack_PCIE);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB) {
+			if (pDM_Odm->RFEType == 3 && pDM_Odm->bIsMPChip) 
+				READ_AND_CONFIG_MP(8812A,_TxPowerTrack_RFE3);	
+			else
+				READ_AND_CONFIG_MP(8812A,_TxPowerTrack_USB);	
+		}
+		
+	}
+#endif	
+#if RTL8192E_SUPPORT 	
+	if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
+			READ_AND_CONFIG_MP(8192E,_TxPowerTrack_PCIE);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
+			READ_AND_CONFIG_MP(8192E,_TxPowerTrack_USB); 
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
+			READ_AND_CONFIG_MP(8192E,_TxPowerTrack_SDIO); 
+	}
+#endif
+#if RTL8723B_SUPPORT 	
+	if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
+			READ_AND_CONFIG_MP(8723B,_TxPowerTrack_PCIE);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
+			READ_AND_CONFIG_MP(8723B,_TxPowerTrack_USB);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
+			READ_AND_CONFIG_MP(8723B,_TxPowerTrack_SDIO); 			
+	}
+#endif	
+#if RTL8188E_SUPPORT 	
+	if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
+			READ_AND_CONFIG_MP(8188E,_TxPowerTrack_PCIE);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
+			READ_AND_CONFIG_MP(8188E,_TxPowerTrack_USB);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
+			READ_AND_CONFIG_MP(8188E,_TxPowerTrack_SDIO);
+	}
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE !=  ODM_AP)
+
+//1 All platforms support
+#if RTL8814A_SUPPORT
+	if(pDM_Odm->SupportICType == ODM_RTL8814A) 
+	{
+		if(pDM_Odm->RFEType == 0)
+			READ_AND_CONFIG_MP(8814A,_TxPowerTrack_Type0);
+		else if(pDM_Odm->RFEType == 2)
+			READ_AND_CONFIG_MP(8814A,_TxPowerTrack_Type2);
+		else if (pDM_Odm->RFEType == 5)
+			READ_AND_CONFIG_MP(8814A, _TxPowerTrack_Type5);
+		else
+			READ_AND_CONFIG_MP(8814A,_TxPowerTrack);
+	}
+#endif	
+#if RTL8703B_SUPPORT
+	if (pDM_Odm->SupportICType == ODM_RTL8703B) {
+		if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
+			READ_AND_CONFIG_MP(8703B, _TxPowerTrack_USB);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
+			READ_AND_CONFIG_MP(8703B, _TxPowerTrack_SDIO);		
+	}
+#endif
+
+#if RTL8188F_SUPPORT
+	if (pDM_Odm->SupportICType == ODM_RTL8188F) {
+		if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
+			READ_AND_CONFIG_MP(8188F, _TxPowerTrack_USB);
+		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
+			READ_AND_CONFIG_MP(8188F, _TxPowerTrack_SDIO);
+	}
+#endif
+
+//1 New ICs (WIN only)
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+#if RTL8821B_SUPPORT
+	if(pDM_Odm->SupportICType == ODM_RTL8821B)
+			READ_AND_CONFIG(8821B,_TxPowerTrack);			
+#endif	
+#if RTL8822B_SUPPORT
+/*	if(pDM_Odm->SupportICType == ODM_RTL8822B)
+			READ_AND_CONFIG_MP(8822B, _TxPowerTrack);			*/
+#endif	
+
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+#if RTL8188F_SUPPORT
+	if(pDM_Odm->SupportICType == ODM_RTL8188F)
+			READ_AND_CONFIG_TC(8188F,_TxPowerTrack_PCIE);			
+#endif	
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+
+
+	return HAL_STATUS_SUCCESS;
+}
+
+HAL_STATUS
+ODM_ConfigBBWithHeaderFile(
+	IN 	PDM_ODM_T	             	pDM_Odm,
+	IN 	ODM_BB_Config_Type 		ConfigType
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)	
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);	
+#endif
+
+//1 AP doesn't use PHYDM initialization in these ICs
+#if (DM_ODM_SUPPORT_TYPE !=  ODM_AP)	
+#if (RTL8723A_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG){
+			READ_AND_CONFIG_MP(8723A,_PHY_REG);
+		}else if(ConfigType == CONFIG_BB_AGC_TAB){
+			READ_AND_CONFIG_MP(8723A,_AGC_TAB);
+		}		
+	}		
+#endif
+#if (RTL8812A_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG){
+			READ_AND_CONFIG_MP(8812A,_PHY_REG);
+		}else if(ConfigType == CONFIG_BB_AGC_TAB){
+			READ_AND_CONFIG_MP(8812A,_AGC_TAB);
+		}
+		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
+		{
+			if (pDM_Odm->RFEType == 3 && pDM_Odm->bIsMPChip) 
+				READ_AND_CONFIG_MP(8812A,_PHY_REG_PG_ASUS);
+			#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+			else if (pMgntInfo->CustomerID == RT_CID_WNC_NEC && pDM_Odm->bIsMPChip) 
+				READ_AND_CONFIG_MP(8812A,_PHY_REG_PG_NEC);
+			#endif			
+			else
+				READ_AND_CONFIG_MP(8812A,_PHY_REG_PG);
+		}
+		else if(ConfigType == CONFIG_BB_PHY_REG_MP){
+			READ_AND_CONFIG_MP(8812A,_PHY_REG_MP);
+		}
+		else if(ConfigType == CONFIG_BB_AGC_TAB_DIFF)
+		{
+			if ((36 <= *pDM_Odm->pChannel)  && (*pDM_Odm->pChannel  <= 64)) 
+				AGC_DIFF_CONFIG_MP(8812A,LB);
+			else if (100 <= *pDM_Odm->pChannel) 
+				AGC_DIFF_CONFIG_MP(8812A,HB);
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:Rtl8812AGCTABArray\n"));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() agc:Rtl8812PHY_REGArray\n"));
+	}		
+#endif
+#if (RTL8821A_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG){
+			READ_AND_CONFIG_MP(8821A,_PHY_REG);
+		}else if(ConfigType == CONFIG_BB_AGC_TAB){
+			READ_AND_CONFIG_MP(8821A,_AGC_TAB);
+		}else if(ConfigType == CONFIG_BB_PHY_REG_PG){
+			READ_AND_CONFIG_MP(8821A,_PHY_REG_PG);
+		}		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:Rtl8821AGCTABArray\n"));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() agc:Rtl8821PHY_REGArray\n"));
+	}		
+#endif
+#if (RTL8723B_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG){
+			READ_AND_CONFIG_MP(8723B,_PHY_REG);
+		}else if(ConfigType == CONFIG_BB_AGC_TAB){
+			READ_AND_CONFIG_MP(8723B,_AGC_TAB);
+		}else if(ConfigType == CONFIG_BB_PHY_REG_PG){
+			READ_AND_CONFIG_MP(8723B,_PHY_REG_PG);
+		}
+	}
+#endif
+#if (RTL8192E_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG){
+			READ_AND_CONFIG_MP(8192E,_PHY_REG);
+		}else if(ConfigType == CONFIG_BB_AGC_TAB){
+			READ_AND_CONFIG_MP(8192E,_AGC_TAB);
+		}else if(ConfigType == CONFIG_BB_PHY_REG_PG){
+			READ_AND_CONFIG_MP(8192E,_PHY_REG_PG);
+		}
+	}
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE !=  ODM_AP)
+
+
+//1 All platforms support
+#if (RTL8188E_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG)
+			READ_AND_CONFIG_MP(8188E,_PHY_REG);
+		else if(ConfigType == CONFIG_BB_AGC_TAB)
+			READ_AND_CONFIG_MP(8188E,_AGC_TAB);
+		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
+			READ_AND_CONFIG_MP(8188E,_PHY_REG_PG);
+	}
+#endif
+#if (RTL8814A_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8814A)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG){
+			READ_AND_CONFIG_MP(8814A,_PHY_REG);
+		}else if(ConfigType == CONFIG_BB_AGC_TAB){
+			READ_AND_CONFIG_MP(8814A,_AGC_TAB);
+		}else if(ConfigType == CONFIG_BB_PHY_REG_PG){
+			READ_AND_CONFIG_MP(8814A,_PHY_REG_PG);
+		}else if(ConfigType == CONFIG_BB_PHY_REG_MP){
+			READ_AND_CONFIG_MP(8814A,_PHY_REG_MP);
+		}
+	}
+#endif
+#if (RTL8703B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8703B) {
+		if (ConfigType == CONFIG_BB_PHY_REG)
+			READ_AND_CONFIG_MP(8703B, _PHY_REG);
+		else if (ConfigType == CONFIG_BB_AGC_TAB)
+			READ_AND_CONFIG_MP(8703B, _AGC_TAB);
+		else if (ConfigType == CONFIG_BB_PHY_REG_PG)
+			READ_AND_CONFIG_MP(8703B, _PHY_REG_PG);
+	}
+#endif
+
+#if (RTL8188F_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8188F) {
+		if (ConfigType == CONFIG_BB_PHY_REG) 
+			READ_AND_CONFIG_MP(8188F, _PHY_REG);
+		else if (ConfigType == CONFIG_BB_AGC_TAB) 
+			READ_AND_CONFIG_MP(8188F, _AGC_TAB);
+		else if (ConfigType == CONFIG_BB_PHY_REG_PG) 
+			READ_AND_CONFIG_MP(8188F, _PHY_REG_PG);
+	}
+#endif
+
+//1 New ICs (WIN only)
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+#if (RTL8821B_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8821B)
+	{
+		if (ConfigType == CONFIG_BB_PHY_REG) {
+			READ_AND_CONFIG(8821B,_PHY_REG);
+		} else if (ConfigType == CONFIG_BB_AGC_TAB) { 
+		    READ_AND_CONFIG(8821B,_AGC_TAB);
+		} else if (ConfigType == CONFIG_BB_PHY_REG_PG) {
+			READ_AND_CONFIG(8821B,_PHY_REG_PG);
+		}
+	}		
+#endif
+#if (RTL8822B_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8822B)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG)
+			READ_AND_CONFIG_MP(8822B, _PHY_REG);
+		else if(ConfigType == CONFIG_BB_AGC_TAB)
+			READ_AND_CONFIG_MP(8822B, _AGC_TAB);
+/*		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
+			READ_AND_CONFIG_MP(8822B, _PHY_REG_PG);
+		else if(ConfigType == CONFIG_BB_PHY_REG_MP)
+			READ_AND_CONFIG_MP(8822B, _PHY_REG_MP); */
+	}
+#endif
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+#if (RTL8188F_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8188F)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG)
+			READ_AND_CONFIG_TC(8188F,_PHY_REG);
+		else if(ConfigType == CONFIG_BB_AGC_TAB)
+			READ_AND_CONFIG_TC(8188F,_AGC_TAB);
+		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
+			READ_AND_CONFIG_TC(8188F,_PHY_REG_PG);
+	}
+#endif
+#endif
+#if (RTL8195A_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8195A)
+	{
+		if(ConfigType == CONFIG_BB_PHY_REG)
+			READ_AND_CONFIG(8195A,_PHY_REG);
+		else if(ConfigType == CONFIG_BB_AGC_TAB)
+			READ_AND_CONFIG(8195A,_AGC_TAB);
+		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
+			READ_AND_CONFIG(8195A,_PHY_REG_PG);
+	}
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+
+	return HAL_STATUS_SUCCESS; 
+}                 
+
+HAL_STATUS
+ODM_ConfigMACWithHeaderFile(
+	IN 	PDM_ODM_T	pDM_Odm
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)	
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);	
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
+		 		("===>ODM_ConfigMACWithHeaderFile (%s)\n", (pDM_Odm->bIsMPChip) ? "MPChip" : "TestChip"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
+				("pDM_Odm->SupportPlatform: 0x%X, pDM_Odm->SupportInterface: 0x%X, pDM_Odm->BoardType: 0x%X\n",
+				pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface, pDM_Odm->BoardType));
+
+//1 AP doesn't use PHYDM initialization in these ICs
+#if (DM_ODM_SUPPORT_TYPE !=  ODM_AP)	
+#if (RTL8723A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8723A){
+		READ_AND_CONFIG_MP(8723A,_MAC_REG);
+	}
+#endif
+#if (RTL8812A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8812){
+		READ_AND_CONFIG_MP(8812A,_MAC_REG);
+	}
+#endif
+#if (RTL8821A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8821){
+		READ_AND_CONFIG_MP(8821A,_MAC_REG);
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("<===8821_ODM_ConfigMACwithHeaderFile\n"));
+	}
+#endif
+#if (RTL8723B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8723B){
+		READ_AND_CONFIG_MP(8723B,_MAC_REG);
+	}
+#endif
+#if (RTL8192E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8192E){
+		READ_AND_CONFIG_MP(8192E,_MAC_REG);
+	}
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE !=  ODM_AP)
+
+//1 All platforms support
+#if (RTL8188E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188E){
+		READ_AND_CONFIG_MP(8188E,_MAC_REG);
+	}
+#endif
+#if (RTL8814A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8814A){
+		READ_AND_CONFIG_MP(8814A,_MAC_REG);
+	}
+#endif
+#if (RTL8703B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8703B)
+		READ_AND_CONFIG_MP(8703B, _MAC_REG);
+#endif
+
+#if (RTL8188F_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188F) 
+		READ_AND_CONFIG_MP(8188F, _MAC_REG);
+#endif
+
+//1 New ICs (WIN only)
+#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)
+#if (RTL8821B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8821B){
+		READ_AND_CONFIG(8821B,_MAC_REG);
+	}
+#endif
+#if (RTL8822B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8822B)
+		READ_AND_CONFIG_MP(8822B, _MAC_REG);
+#endif
+
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+#if (RTL8188F_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188F)
+		READ_AND_CONFIG_TC(8188F,_MAC_REG);
+#endif
+#endif
+#if (RTL8195A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8195A)
+		READ_AND_CONFIG_MP(8195A,_MAC_REG);
+#endif
+#endif /*#if (DM_ODM_SUPPORT_TYPE &  ODM_WIN)*/
+
+	return HAL_STATUS_SUCCESS;    
+} 
+
+HAL_STATUS
+ODM_ConfigFWWithHeaderFile(
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN 	ODM_FW_Config_Type 	ConfigType,
+	OUT u1Byte				*pFirmware,
+	OUT u4Byte				*pSize
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+
+#if (RTL8188E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+	#ifdef CONFIG_SFW_SUPPORTED
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8188E_T,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8188E_T,_FW_WoWLAN);
+		else if(ConfigType == CONFIG_FW_NIC_2)
+			READ_FIRMWARE_MP(8188E_S,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN_2)
+			READ_FIRMWARE_MP(8188E_S,_FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		if (ConfigType == CONFIG_FW_AP)
+			READ_FIRMWARE_MP(8188E_T,_FW_AP);
+		else if (ConfigType == CONFIG_FW_AP_2)
+			READ_FIRMWARE_MP(8188E_S,_FW_AP);
+		#endif //CONFIG_AP_WOWLAN
+	#else
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8188E_T,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8188E_T,_FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP)
+			READ_FIRMWARE_MP(8188E_T,_FW_AP);
+		#endif //CONFIG_AP_WOWLAN
+	#endif
+	}
+#endif
+#if (RTL8723B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8723B,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8723B,_FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE(8723B,_FW_AP_WoWLAN);
+		#endif
+		
+	}
+#endif //#if (RTL8723B_SUPPORT == 1)  
+#if (RTL8812A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8812A,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8812A,_FW_WoWLAN);
+		else if (ConfigType == CONFIG_FW_BT)
+			READ_FIRMWARE_MP(8812A,_FW_NIC_BT);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE(8812A,_FW_AP);
+		#endif
+	}
+#endif
+#if (RTL8821A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8821){
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8821A,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8821A,_FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE_MP(8821A , _FW_AP);
+		#endif /*CONFIG_AP_WOWLAN*/
+		else if (ConfigType == CONFIG_FW_BT)
+			READ_FIRMWARE_MP(8821A,_FW_NIC_BT);
+	}
+#endif
+#if (RTL8192E_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8192E,_FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8192E,_FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE_MP(8192E,_FW_AP);
+		#endif
+	}
+#endif
+#if (RTL8814A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8814A)
+	{
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8814A,_FW_NIC);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE_MP(8814A,_FW_AP);
+		#endif
+	}
+#endif
+#if (RTL8703B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8703B) {
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8703B, _FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8703B, _FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE(8703B, _FW_AP_WoWLAN);
+		#endif
+	}
+#endif
+
+#if (RTL8188F_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8188F) {
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8188F, _FW_NIC);
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+			READ_FIRMWARE_MP(8188F, _FW_WoWLAN);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP)
+			READ_FIRMWARE_MP(8188F,_FW_AP);
+		#endif
+	}
+#endif
+
+//1 New ICs (WIN only)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#if (RTL8821B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8821B)
+	{
+	}
+#endif
+#if (RTL8822B_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8822B)
+	{
+		/*
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8822B,_FW_NIC);
+		#ifdef CONFIG_AP_WOWLAN
+		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
+			READ_FIRMWARE(8822B,_FW_AP);
+		#endif */
+	}
+#endif
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+#if (RTL8188F_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8188F)
+	{
+		if (ConfigType == CONFIG_FW_NIC)
+			READ_FIRMWARE_MP(8188F,_FW_NIC);
+	}
+#endif
+#endif
+#endif//(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#endif//(DM_ODM_SUPPORT_TYPE != ODM_AP)
+	return HAL_STATUS_SUCCESS;    
+} 
+
+u4Byte 
+ODM_GetHWImgVersion(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+    u4Byte  Version=0;
+
+//1 AP doesn't use PHYDM initialization in these ICs
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+#if (RTL8723A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8723A)
+		Version = GET_VERSION_MP(8723A,_MAC_REG);
+#endif
+#if (RTL8723B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8723B)
+		Version = GET_VERSION_MP(8723B,_MAC_REG);
+#endif
+#if (RTL8821A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8821)
+		Version = GET_VERSION_MP(8821A,_MAC_REG);
+#endif
+#if (RTL8192E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8192E)
+		Version = GET_VERSION_MP(8192E,_MAC_REG);
+#endif
+#if (RTL8812A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+		Version = GET_VERSION_MP(8812A,_MAC_REG);
+#endif
+#endif //(DM_ODM_SUPPORT_TYPE != ODM_AP)
+
+/*1 All platforms support*/
+#if (RTL8188E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188E)
+		Version = GET_VERSION_MP(8188E,_MAC_REG);
+#endif
+#if (RTL8814A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8814A)
+		Version = GET_VERSION_MP(8814A,_MAC_REG);
+#endif
+#if (RTL8703B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8703B)
+		Version = GET_VERSION_MP(8703B, _MAC_REG);
+#endif
+#if (RTL8188F_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188F)
+		Version = GET_VERSION_MP(8188F, _MAC_REG);
+#endif
+
+//1 New ICs (WIN only)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#if (RTL8821B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8821B)
+		Version = GET_VERSION(8821B,_MAC_REG);
+#endif
+#if (RTL8822B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8822B)
+		Version = GET_VERSION(8822B, _MAC_REG);
+#endif
+#if ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+#if (RTL8188F_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188F)
+		Version = GET_VERSION_TC(8188F, _MAC_REG);
+#endif
+#endif
+#endif //(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	return Version;
+}
+
+#if (RTL8822B_SUPPORT == 1)
+/* For 8822B only!! need to move to FW finally */
+/*==============================================*/
+
+VOID
+phydm_ResetPhyInfo(
+	IN		PDM_ODM_T					pPhydm,
+	OUT		PODM_PHY_INFO_T			pPhyInfo
+)
+{
+	pPhyInfo->RxPWDBAll = 0;
+	pPhyInfo->SignalQuality = 0;
+	pPhyInfo->BandWidth = 0;
+#if (RTL8822B_SUPPORT == 1)
+	pPhyInfo->RxCount = 0;
+#endif
+	ODM_Memory_Set(pPhydm, pPhyInfo->RxMIMOSignalQuality, 0 , 4);
+	ODM_Memory_Set(pPhydm, pPhyInfo->RxMIMOSignalStrength, 0, 4);
+	ODM_Memory_Set(pPhydm, pPhyInfo->RxSNR, 0, 4);
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))	
+	pPhyInfo->RxPower = -110;
+	pPhyInfo->RecvSignalPower = -110;
+	pPhyInfo->BTRxRSSIPercentage = 0;
+	pPhyInfo->SignalStrength = 0;
+	pPhyInfo->btCoexPwrAdjust = 0;
+#if (RTL8822B_SUPPORT == 1)
+	pPhyInfo->channel = 0;
+	pPhyInfo->bMuPacket = 0;
+	pPhyInfo->bBeamformed = 0;
+	pPhyInfo->rxsc = 0;
+#endif
+	ODM_Memory_Set(pPhydm, pPhyInfo->RxPwr, -110, 4);
+	ODM_Memory_Set(pPhydm, pPhyInfo->RxMIMOEVMdbm, 0, 4);
+	ODM_Memory_Set(pPhydm, pPhyInfo->Cfo_short, 0, 8);
+	ODM_Memory_Set(pPhydm, pPhyInfo->Cfo_tail, 0, 8);
+#endif
+}
+
+VOID
+phydm_SetPerPathPhyInfo(
+	IN		u1Byte							RxPath,
+	IN		s1Byte							RxPwr,
+	IN		s1Byte							RxEVM,
+	IN		s1Byte							Cfo_tail,
+	IN		s1Byte							RxSNR,
+	OUT		PODM_PHY_INFO_T				pPhyInfo
+)
+{
+	u1Byte			EVMdBm = 0;
+	u1Byte			EVMPercentage = 0;
+
+	/* SNR is S(8,1), EVM is S(8,1), CFO is S(8,7) */
+	
+	if (RxEVM < 0) {
+		/* Calculate EVM in dBm */
+		EVMdBm = ((u1Byte)(0 - RxEVM) >> 1);
+
+		/* Calculate EVM in percentage */
+		if (EVMdBm >= 33)
+			EVMPercentage = 100;
+		else 
+			EVMPercentage = (EVMdBm << 1) + (EVMdBm);
+	}
+	
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+	pPhyInfo->RxPwr[RxPath] = RxPwr;
+	pPhyInfo->RxMIMOEVMdbm[RxPath] = EVMdBm;
+
+	/* CFO = CFO_tail * 312.5 / 2^7 ~= CFO tail * 39/512 (kHz)*/
+	pPhyInfo->Cfo_tail[RxPath] = Cfo_tail;
+	pPhyInfo->Cfo_tail[RxPath] = ((pPhyInfo->Cfo_tail[RxPath] << 5) + (pPhyInfo->Cfo_tail[RxPath] << 2) +
+		(pPhyInfo->Cfo_tail[RxPath] << 1) + (pPhyInfo->Cfo_tail[RxPath])) >> 9;
+#endif
+
+	pPhyInfo->RxMIMOSignalStrength[RxPath] = odm_QueryRxPwrPercentage(RxPwr);
+	pPhyInfo->RxMIMOSignalQuality[RxPath] = EVMPercentage;
+	pPhyInfo->RxSNR[RxPath] = RxSNR >> 1;
+
+/*
+	//if (pPktinfo->bPacketMatchBSSID) 
+	{
+		DbgPrint("Path (%d)--------\n", RxPath);
+		DbgPrint("RxPwr = %d, Signal strength = %d\n", pPhyInfo->RxPwr[RxPath], pPhyInfo->RxMIMOSignalStrength[RxPath]);
+		DbgPrint("EVMdBm = %d, Signal quality = %d\n", pPhyInfo->RxMIMOEVMdbm[RxPath], pPhyInfo->RxMIMOSignalQuality[RxPath]);
+		DbgPrint("CFO = %d, SNR = %d\n", pPhyInfo->Cfo_tail[RxPath], pPhyInfo->RxSNR[RxPath]);
+	}	
+*/
+}
+
+VOID
+phydm_SetCommonPhyInfo(
+	IN		s1Byte							RxPower,
+	IN		u1Byte							channel,
+	IN		BOOLEAN							bBeamformed,
+	IN		BOOLEAN							bMuPacket,
+	IN		u1Byte							bandwidth,
+	IN		u1Byte							signalQuality,
+	IN		u1Byte							rxsc,
+	OUT		PODM_PHY_INFO_T				pPhyInfo
+)
+{
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
+	pPhyInfo->RxPower = RxPower;											/* RSSI in dB */
+	pPhyInfo->RecvSignalPower = RxPower;										/* RSSI in dB */
+	pPhyInfo->channel = channel;												/* channel number */
+	pPhyInfo->bBeamformed = bBeamformed;									/* apply BF */
+	pPhyInfo->bMuPacket = bMuPacket;										/* MU packet */
+	pPhyInfo->rxsc = rxsc;
+#endif
+	pPhyInfo->RxPWDBAll = odm_QueryRxPwrPercentage(RxPower);				/* RSSI in percentage */
+	pPhyInfo->SignalQuality = signalQuality;										/* signal quality */
+	pPhyInfo->BandWidth = bandwidth;											/* bandwidth */
+
+/*
+	//if (pPktinfo->bPacketMatchBSSID)
+	{
+		DbgPrint("RxPWDBAll = %d, RxPower = %d, RecvSignalPower = %d\n", pPhyInfo->RxPWDBAll, pPhyInfo->RxPower, pPhyInfo->RecvSignalPower);
+		DbgPrint("SignalQuality = %d\n", pPhyInfo->SignalQuality);
+		DbgPrint("bBeamformed = %d, bMuPacket = %d, RxCount = %d\n", pPhyInfo->bBeamformed, pPhyInfo->bMuPacket, pPhyInfo->RxCount + 1);
+		DbgPrint("channel = %d, rxsc = %d, BandWidth = %d\n", channel, rxsc, bandwidth);
+	}
+*/
+}
+
+VOID
+phydm_GetRxPhyStatusType0(
+	IN		PDM_ODM_T						pDM_Odm,
+	IN		pu1Byte							pPhyStatus,
+	IN		PODM_PACKET_INFO_T				pPktinfo,
+	OUT		PODM_PHY_INFO_T				pPhyInfo
+)
+{
+	/* Type 0 is used for cck packet */
+	
+	PPHY_STATUS_RPT_JAGUAR2_TYPE0	pPhyStaRpt = (PPHY_STATUS_RPT_JAGUAR2_TYPE0)pPhyStatus;
+	u1Byte							i, SQ = 0;
+
+	/* Calculate Signal Quality*/
+	if (pPktinfo->bPacketMatchBSSID) {
+		if (pPhyStaRpt->signal_quality >= 64)
+			SQ = 0;
+		else if (pPhyStaRpt->signal_quality <= 20)
+			SQ = 100;
+		else {
+			/* mapping to 2~99% */
+			SQ = 64 - pPhyStaRpt->signal_quality;
+			SQ = ((SQ << 3) + SQ) >> 2;
+		}
+	}
+
+	/* Update CCK packet counter */
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK++;
+
+	/* Update Common information */
+	phydm_SetCommonPhyInfo((pPhyStaRpt->pwdb - 110), pPhyStaRpt->channel, FALSE, 
+		FALSE, ODM_BW20M, SQ, pPhyStaRpt->rxsc, pPhyInfo);
+
+	/* Update CCK pwdb */
+	phydm_SetPerPathPhyInfo(ODM_RF_PATH_A, (pPhyStaRpt->pwdb - 110), 0, 0, 0, pPhyInfo);					/* Update per-path information */
+
+/*
+	//if (pPktinfo->bPacketMatchBSSID)
+	{
+		DbgPrint("pwdb = 0x%x, MP gain index = 0x%x, TRSW = 0x%x\n", pPhyStaRpt->pwdb, pPhyStaRpt->gain, pPhyStaRpt->trsw);
+		DbgPrint("channel = %d, band = %d, rxsc = %d\n", pPhyStaRpt->channel, pPhyStaRpt->band, pPhyStaRpt->rxsc);
+		DbgPrint("agc_table = 0x%x, agc_rpt 0x%x, bb_power = 0x%x\n", pPhyStaRpt->agc_table, pPhyStaRpt->agc_rpt, pPhyStaRpt->bb_power);
+		DbgPrint("length = %d, SQ = %d\n", pPhyStaRpt->length, pPhyStaRpt->signal_quality);
+		DbgPrint("antidx a = 0x%x, b = 0x%x, c = 0x%x, d = 0x%x\n", pPhyStaRpt->antidx_a, pPhyStaRpt->antidx_b, pPhyStaRpt->antidx_c, pPhyStaRpt->antidx_d);
+		DbgPrint("rsvd_0 = 0x%x, rsvd_1 = 0x%x, rsvd_2 = 0x%x\n", pPhyStaRpt->rsvd_0, pPhyStaRpt->rsvd_1, pPhyStaRpt->rsvd_2);
+		DbgPrint("rsvd_3 = 0x%x, rsvd_4 = 0x%x, rsvd_5 = 0x%x\n", pPhyStaRpt->rsvd_3, pPhyStaRpt->rsvd_4, pPhyStaRpt->rsvd_5);
+		DbgPrint("rsvd_6 = 0x%x, rsvd_7 = 0x%x, rsvd_8 = 0x%x\n", pPhyStaRpt->rsvd_6, pPhyStaRpt->rsvd_7, pPhyStaRpt->rsvd_8);
+	}
+*/
+}
+
+VOID
+phydm_GetRxPhyStatusType1(
+	IN		PDM_ODM_T						pDM_Odm,
+	IN		pu1Byte							pPhyStatus,
+	IN		PODM_PACKET_INFO_T				pPktinfo,
+	OUT		PODM_PHY_INFO_T				pPhyInfo
+)
+{
+	/* Type 1 is used for ofdm packet */
+
+	PPHY_STATUS_RPT_JAGUAR2_TYPE1	pPhyStaRpt = (PPHY_STATUS_RPT_JAGUAR2_TYPE1)pPhyStatus;
+	s1Byte							rx_pwr_db = -120;
+	u1Byte							i, rxsc, bw, RxCount = 0;
+	BOOLEAN							bMU;
+
+	/* Update OFDM packet counter */
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM++;
+
+	/* Update per-path information */
+	for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+		if (pDM_Odm->RXAntStatus & BIT(i)) {
+			s1Byte	rx_path_pwr_db;
+
+			/* RX path counter */
+			RxCount++;
+
+			/* Update per-path information (RSSI_dB RSSI_percentage EVM SNR CFO SQ) */
+			/* EVM report is reported by stream, not path */
+			rx_path_pwr_db = pPhyStaRpt->pwdb[i] - 110;					/* per-path pwdb in dB domain */
+			phydm_SetPerPathPhyInfo(i, rx_path_pwr_db, pPhyStaRpt->rxevm[RxCount - 1], 
+				pPhyStaRpt->cfo_tail[i], pPhyStaRpt->rxsnr[i], pPhyInfo);
+
+			/* search maximum pwdb */
+			if (rx_path_pwr_db > rx_pwr_db)
+				rx_pwr_db = rx_path_pwr_db;
+		}
+	}
+
+	/* mapping RX counter from 1~4 to 0~3 */
+	if (RxCount > 0)
+		pPhyInfo->RxCount = RxCount - 1;
+	
+	/* Check if MU packet or not */
+	if ((pPhyStaRpt->gid != 0) && (pPhyStaRpt->gid != 63)) {
+		bMU = TRUE;
+		pDM_Odm->PhyDbgInfo.NumQryMuPkt++;
+	} else
+		bMU = FALSE;
+
+	/* Count BF packet */
+	pDM_Odm->PhyDbgInfo.NumQryBfPkt = pDM_Odm->PhyDbgInfo.NumQryBfPkt + pPhyStaRpt->beamformed;
+
+	/* Check sub-channel */
+	if ((pPktinfo->DataRate > ODM_RATE11M) && (pPktinfo->DataRate < ODM_RATEMCS0))
+		rxsc = pPhyStaRpt->l_rxsc;
+	else
+		rxsc = pPhyStaRpt->ht_rxsc;
+
+	/* Check RX bandwidth */
+	if ((rxsc >= 1) && (rxsc <= 8))
+		bw = ODM_BW20M;
+	else if ((rxsc >= 9) && (rxsc <= 12))
+		bw = ODM_BW40M;
+	else if (rxsc >= 13)
+		bw = ODM_BW80M;
+	else
+		bw = pPhyStaRpt->rf_mode;
+
+	/* Update packet information */
+	phydm_SetCommonPhyInfo(rx_pwr_db, pPhyStaRpt->channel, (BOOLEAN)pPhyStaRpt->beamformed,
+		bMU, bw, odm_EVMdbToPercentage(pPhyStaRpt->rxevm[0]), rxsc, pPhyInfo);
+
+/*
+	//if (pPktinfo->bPacketMatchBSSID)
+	{
+		DbgPrint("channel = %d, band = %d, l_rxsc = %d, ht_rxsc = %d, rf_mode = %d\n", pPhyStaRpt->channel, pPhyStaRpt->band, pPhyStaRpt->l_rxsc, pPhyStaRpt->ht_rxsc, pPhyStaRpt->rf_mode);
+		DbgPrint("Antidx A = %d, B = %d, C = %d, D = %d\n", pPhyStaRpt->antidx_a, pPhyStaRpt->antidx_b, pPhyStaRpt->antidx_c, pPhyStaRpt->antidx_d);
+		DbgPrint("pwdb A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->pwdb[0], pPhyStaRpt->pwdb[1], pPhyStaRpt->pwdb[2], pPhyStaRpt->pwdb[3]);
+		DbgPrint("EVM  A: %d, B: %d, C: %d, D: %d\n", pPhyStaRpt->rxevm[0], pPhyStaRpt->rxevm[1], pPhyStaRpt->rxevm[2], pPhyStaRpt->rxevm[3]);
+		DbgPrint("SNR  A: %d, B: %d, C: %d, D: %d\n", pPhyStaRpt->rxsnr[0], pPhyStaRpt->rxsnr[1], pPhyStaRpt->rxsnr[2], pPhyStaRpt->rxsnr[3]);
+		DbgPrint("CFO  A: %d, B: %d, C: %d, D: %d\n", pPhyStaRpt->cfo_tail[0], pPhyStaRpt->cfo_tail[1], pPhyStaRpt->cfo_tail[2], pPhyStaRpt->cfo_tail[3]);
+		DbgPrint("paid = %d, gid = %d, length = %d\n", (pPhyStaRpt->paid + (pPhyStaRpt->paid_msb<<8)), pPhyStaRpt->gid, pPhyStaRpt->lsig_length);
+		DbgPrint("ldpc: %d, stbc: %d, bf: %d, gnt_bt: %d, antsw: %d\n", pPhyStaRpt->ldpc, pPhyStaRpt->stbc, pPhyStaRpt->beamformed, pPhyStaRpt->gnt_bt, pPhyStaRpt->hw_antsw_occu);
+		DbgPrint("NBI: %d, pos: %d\n", pPhyStaRpt->nb_intf_flag, (pPhyStaRpt->intf_pos + (pPhyStaRpt->intf_pos_msb<<8)));
+		DbgPrint("rsvd_0 = %d, rsvd_1 = %d, rsvd_2 = %d, rsvd_3 = %d, rsvd_4 = %d, rsvd_5 = %d\n", pPhyStaRpt->rsvd_0, pPhyStaRpt->rsvd_1, pPhyStaRpt->rsvd_2, pPhyStaRpt->rsvd_3, pPhyStaRpt->rsvd_4, pPhyStaRpt->rsvd_5);
+	}
+	DbgPrint("phydm_GetRxPhyStatusType1   pPktinfo->bPacketMatchBSSID = %d\n", pPktinfo->bPacketMatchBSSID);
+	DbgPrint("pPktinfo->DataRate = 0x%x\n", pPktinfo->DataRate);
+*/
+}
+
+VOID
+phydm_GetRxPhyStatusType2(
+	IN		PDM_ODM_T						pDM_Odm,
+	IN		pu1Byte							pPhyStatus,
+	IN		PODM_PACKET_INFO_T				pPktinfo,
+	OUT		PODM_PHY_INFO_T				pPhyInfo
+)
+{
+	PPHY_STATUS_RPT_JAGUAR2_TYPE2	pPhyStaRpt = (PPHY_STATUS_RPT_JAGUAR2_TYPE2)pPhyStatus;
+	s1Byte							rx_pwr_db = -120;
+	u1Byte							i, rxsc, bw, RxCount = 0;
+
+	/* Update OFDM packet counter */
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM++;
+
+	/* Update per-path information */
+	for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+		if (pDM_Odm->RXAntStatus & BIT(i)) {
+			s1Byte	rx_path_pwr_db;
+
+			/* RX path counter */
+			RxCount++;
+
+			/* Update per-path information (RSSI_dB RSSI_percentage EVM SNR CFO SQ) */
+			rx_path_pwr_db = pPhyStaRpt->pwdb[i] - 110;					/* per-path pwdb in dB domain */
+			phydm_SetPerPathPhyInfo(i, rx_path_pwr_db, 0, 0, 0, pPhyInfo);
+
+			/* search maximum pwdb */
+			if (rx_path_pwr_db > rx_pwr_db)
+				rx_pwr_db = rx_path_pwr_db;
+		}
+	}
+
+	/* mapping RX counter from 1~4 to 0~3 */
+	if (RxCount > 0)
+		pPhyInfo->RxCount = RxCount - 1;
+	
+	/* Check RX sub-channel */
+	if ((pPktinfo->DataRate > ODM_RATE11M) && (pPktinfo->DataRate < ODM_RATEMCS0))
+		rxsc = pPhyStaRpt->l_rxsc;
+	else
+		rxsc = pPhyStaRpt->ht_rxsc;
+
+	/* Check RX bandwidth */
+	/* the BW information of sc=0 is useless, because there is no information of RF mode*/
+	if ((rxsc >= 1) && (rxsc <= 8))
+		bw = ODM_BW20M;
+	else if ((rxsc >= 9) && (rxsc <= 12))
+		bw = ODM_BW40M;
+	else if (rxsc >= 13)
+		bw = ODM_BW80M;
+	else
+		bw = ODM_BW20M;
+
+	/* Update packet information */
+	phydm_SetCommonPhyInfo(rx_pwr_db, pPhyStaRpt->channel, (BOOLEAN)pPhyStaRpt->beamformed,
+		FALSE, bw, 0, rxsc, pPhyInfo);
+
+/*
+	//if (pPktinfo->bPacketMatchBSSID)
+	{
+		DbgPrint("channel = %d, band = %d, l_rxsc = %d, ht_rxsc = %d\n", pPhyStaRpt->channel, pPhyStaRpt->band, pPhyStaRpt->l_rxsc, pPhyStaRpt->ht_rxsc);
+		DbgPrint("pwdb A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->pwdb[0], pPhyStaRpt->pwdb[1], pPhyStaRpt->pwdb[2], pPhyStaRpt->pwdb[3]);
+		DbgPrint("Agc table A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->agc_table_a, pPhyStaRpt->agc_table_b, pPhyStaRpt->agc_table_c, pPhyStaRpt->agc_table_d);
+		DbgPrint("Gain A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->gain_a, pPhyStaRpt->gain_b, pPhyStaRpt->gain_c, pPhyStaRpt->gain_d);
+		DbgPrint("TRSW A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->trsw_a, pPhyStaRpt->trsw_b, pPhyStaRpt->trsw_c, pPhyStaRpt->trsw_d);
+		DbgPrint("AAGC step A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->aagc_step_a, pPhyStaRpt->aagc_step_b, pPhyStaRpt->aagc_step_c, pPhyStaRpt->aagc_step_d);
+		DbgPrint("HT AAGC gain A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->ht_aagc_gain[0], pPhyStaRpt->ht_aagc_gain[1], pPhyStaRpt->ht_aagc_gain[2], pPhyStaRpt->ht_aagc_gain[3]);
+		DbgPrint("DAGC gain A: 0x%x, B: 0x%x, C: 0x%x, D: 0x%x\n", pPhyStaRpt->dagc_gain[0], pPhyStaRpt->dagc_gain[1], pPhyStaRpt->dagc_gain[2], pPhyStaRpt->dagc_gain[3]);
+		DbgPrint("ldpc: %d, stbc: %d, bf: %d, gnt_bt: %d, antsw: %d\n", pPhyStaRpt->ldpc, pPhyStaRpt->stbc, pPhyStaRpt->beamformed, pPhyStaRpt->gnt_bt, pPhyStaRpt->hw_antsw_occu);
+		DbgPrint("counter: %d, syn_count: %d\n", pPhyStaRpt->counter, pPhyStaRpt->syn_count);
+		DbgPrint("cnt_cca2agc_rdy: %d, cnt_pw2cca: %d, shift_l_map\n", pPhyStaRpt->cnt_cca2agc_rdy, pPhyStaRpt->cnt_pw2cca, pPhyStaRpt->shift_l_map);
+		DbgPrint("rsvd_0 = %d, rsvd_1 = %d, rsvd_2 = %d, rsvd_3 = %d, rsvd_4 = %d, rsvd_5 = %d\n", pPhyStaRpt->rsvd_0, pPhyStaRpt->rsvd_1, pPhyStaRpt->rsvd_2, pPhyStaRpt->rsvd_3, pPhyStaRpt->rsvd_4);
+		DbgPrint("rsvd_5 = %d, rsvd_6 = %d, rsvd_6 = %d\n", pPhyStaRpt->rsvd_5, pPhyStaRpt->rsvd_6, pPhyStaRpt->rsvd_7);
+	}
+*/
+}
+
+VOID
+phydm_GetRxPhyStatusType5(
+	IN		pu1Byte				pPhyStatus
+)
+{
+/*
+	DbgPrint("DW0: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 3), *(pPhyStatus + 2), *(pPhyStatus + 1), *(pPhyStatus + 0));
+	DbgPrint("DW1: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 7), *(pPhyStatus + 6), *(pPhyStatus + 5), *(pPhyStatus + 4));
+	DbgPrint("DW2: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 11), *(pPhyStatus + 10), *(pPhyStatus + 9), *(pPhyStatus + 8));
+	DbgPrint("DW3: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 15), *(pPhyStatus + 14), *(pPhyStatus + 13), *(pPhyStatus + 12));
+	DbgPrint("DW4: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 19), *(pPhyStatus + 18), *(pPhyStatus + 17), *(pPhyStatus + 16));
+	DbgPrint("DW5: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 23), *(pPhyStatus + 22), *(pPhyStatus + 21), *(pPhyStatus + 20));
+	DbgPrint("DW6: 0x%02x%02x%02x%02x\n", *(pPhyStatus + 27), *(pPhyStatus + 26), *(pPhyStatus + 25), *(pPhyStatus + 24));
+*/
+}
+
+VOID
+phydm_Process_RSSIForDM_Jaguar2(	
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	IN		PODM_PHY_INFO_T			pPhyInfo,
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	)
+{
+	u4Byte				UndecoratedSmoothedPWDB, RSSI_Ave;
+	u1Byte				i;
+	PSTA_INFO_T			pEntry;
+
+	if (pPktinfo->StationID >= ODM_ASSOCIATE_ENTRY_NUM)
+		return;
+
+	pEntry = pDM_Odm->pODM_StaInfo[pPktinfo->StationID];							
+
+	if (!IS_STA_VALID(pEntry))
+		return;
+
+	if ((!pPktinfo->bPacketMatchBSSID))/*data frame only*/
+		return;
+
+	if (pPktinfo->bPacketBeacon)
+		pDM_Odm->PhyDbgInfo.NumQryBeaconPkt++;
+	
+	if (pPktinfo->bPacketToSelf || pPktinfo->bPacketBeacon) {
+		u4Byte RSSI_linear = 0;
+
+		UndecoratedSmoothedPWDB = (u4Byte)pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+		pDM_Odm->RSSI_A = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
+		pDM_Odm->RSSI_B = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B];
+		pDM_Odm->RSSI_C = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_C];
+		pDM_Odm->RSSI_D = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_D];
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+			if (pPhyInfo->RxMIMOSignalStrength[i] != 0)
+				RSSI_linear += odm_ConvertTo_linear(pPhyInfo->RxMIMOSignalStrength[i]);
+		}
+
+		switch (pPhyInfo->RxCount + 1) {
+		case 2:
+			RSSI_linear = (RSSI_linear >> 1);
+			break;
+		case 3:
+			RSSI_linear = ((RSSI_linear) + (RSSI_linear << 1) + (RSSI_linear << 3)) >> 5;	/* RSSI_linear/3 ~ RSSI_linear*11/32 */
+			break;
+		case 4:
+			RSSI_linear = (RSSI_linear >> 2);
+			break;
+		}
+		RSSI_Ave = odm_ConvertTo_dB(RSSI_linear);
+
+		if (UndecoratedSmoothedPWDB <= 0)
+			UndecoratedSmoothedPWDB = pPhyInfo->RxPWDBAll;
+		else
+			UndecoratedSmoothedPWDB = (RSSI_Ave + ((UndecoratedSmoothedPWDB<<4) - UndecoratedSmoothedPWDB))>>4;
+
+		#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+		if (pEntry->rssi_stat.UndecoratedSmoothedPWDB == -1)
+			phydm_ra_rssi_rpt_wk(pDM_Odm);
+		#endif
+
+		pEntry->rssi_stat.UndecoratedSmoothedPWDB = (s4Byte)UndecoratedSmoothedPWDB;
+	}
+}
+
+VOID
+phydm_RxPhyStatusJaguarSeries2(
+	IN		PDM_ODM_T					pPhydm,
+	IN		pu1Byte						pPhyStatus,
+	IN		PODM_PACKET_INFO_T			pPktinfo,
+	OUT		PODM_PHY_INFO_T			pPhyInfo
+)
+{
+	u1Byte		phy_status_type = (*pPhyStatus & 0xf);
+
+	/*DbgPrint("phydm_RxPhyStatusJaguarSeries2================> (page: %d)\n", phy_status_type);*/
+	
+	/* Memory reset */
+	phydm_ResetPhyInfo(pPhydm, pPhyInfo);
+
+	/* Phy status parsing */
+	switch (phy_status_type) {
+	case 0:
+	{
+		phydm_GetRxPhyStatusType0(pPhydm, pPhyStatus, pPktinfo, pPhyInfo);
+		break;
+	}
+	case 1:
+	{
+		phydm_GetRxPhyStatusType1(pPhydm, pPhyStatus, pPktinfo, pPhyInfo);
+		break;
+	}
+	case 2:
+	{
+		phydm_GetRxPhyStatusType2(pPhydm, pPhyStatus, pPktinfo, pPhyInfo);
+		break;
+	}
+	case 5:
+	{
+		phydm_GetRxPhyStatusType5(pPhyStatus);
+		return;
+	}
+	default:
+		return;
+	}
+
+	/* Update signal strength to UI, and pPhyInfo->RxPWDBAll is the maximum RSSI of all path */
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	pPhyInfo->SignalStrength = SignalScaleProc(pPhydm->Adapter, pPhyInfo->RxPWDBAll, FALSE, FALSE);
+#else
+	pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pPhydm, pPhyInfo->RxPWDBAll));
+#endif
+
+	/* Calculate average RSSI and smoothed RSSI */
+	phydm_Process_RSSIForDM_Jaguar2(pPhydm, pPhyInfo, pPktinfo);
+
+}
+/*==============================================*/
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.h
new file mode 100644
index 000000000..2fb26401e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_hwconfig.h
@@ -0,0 +1,506 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__HALHWOUTSRC_H__
+#define __HALHWOUTSRC_H__
+
+
+/*--------------------------Define -------------------------------------------*/ 
+
+#define AGC_DIFF_CONFIG_MP(ic, band) (ODM_ReadAndConfig_MP_##ic##_AGC_TAB_DIFF(pDM_Odm, Array_MP_##ic##_AGC_TAB_DIFF_##band, \
+                                                                              sizeof(Array_MP_##ic##_AGC_TAB_DIFF_##band)/sizeof(u4Byte)))
+#define AGC_DIFF_CONFIG_TC(ic, band) (ODM_ReadAndConfig_TC_##ic##_AGC_TAB_DIFF(pDM_Odm, Array_TC_##ic##_AGC_TAB_DIFF_##band, \
+                                                                              sizeof(Array_TC_##ic##_AGC_TAB_DIFF_##band)/sizeof(u4Byte)))
+
+#define AGC_DIFF_CONFIG(ic, band) do {\
+                                            if (pDM_Odm->bIsMPChip)\
+                                    		    AGC_DIFF_CONFIG_MP(ic,band);\
+                                            else\
+                                                AGC_DIFF_CONFIG_TC(ic,band);\
+                                    } while(0)
+
+
+//============================================================
+// structure and define
+//============================================================
+
+__PACK typedef struct _Phy_Rx_AGC_Info
+{
+	#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)	
+		u1Byte	gain:7,trsw:1;			
+	#else			
+		u1Byte	trsw:1,gain:7;
+	#endif
+} __WLAN_ATTRIB_PACK__ PHY_RX_AGC_INFO_T, *pPHY_RX_AGC_INFO_T;
+
+__PACK typedef struct _Phy_Status_Rpt_8192cd {
+	PHY_RX_AGC_INFO_T path_agc[2];
+	u1Byte	ch_corr[2];
+	u1Byte	cck_sig_qual_ofdm_pwdb_all;
+	u1Byte	cck_agc_rpt_ofdm_cfosho_a;
+	u1Byte	cck_rpt_b_ofdm_cfosho_b;
+	u1Byte	rsvd_1;/*ch_corr_msb;*/
+	u1Byte	noise_power_db_msb;
+	s1Byte	path_cfotail[2];
+	u1Byte	pcts_mask[2];
+	s1Byte	stream_rxevm[2];
+	u1Byte	path_rxsnr[2];
+	u1Byte	noise_power_db_lsb;
+	u1Byte	rsvd_2[3];
+	u1Byte	stream_csi[2];
+	u1Byte	stream_target_csi[2];
+	s1Byte	sig_evm;
+	u1Byte	rsvd_3;
+
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte	antsel_rx_keep_2: 1;	/*ex_intf_flg:1;*/
+	u1Byte	sgi_en: 1;
+	u1Byte	rxsc: 2;
+	u1Byte	idle_long: 1;
+	u1Byte	r_ant_train_en: 1;
+	u1Byte	ant_sel_b: 1;
+	u1Byte	ant_sel: 1;
+#else	/*_BIG_ENDIAN_	*/
+	u1Byte	ant_sel: 1;
+	u1Byte	ant_sel_b: 1;
+	u1Byte	r_ant_train_en: 1;
+	u1Byte	idle_long: 1;
+	u1Byte	rxsc: 2;
+	u1Byte	sgi_en: 1;
+	u1Byte	antsel_rx_keep_2: 1;/*ex_intf_flg:1;*/
+#endif
+} __WLAN_ATTRIB_PACK__ PHY_STATUS_RPT_8192CD_T, *PPHY_STATUS_RPT_8192CD_T;
+
+
+typedef struct _Phy_Status_Rpt_8812 {
+/*	DWORD 0*/
+	u1Byte			gain_trsw[2];							/*path-A and path-B {TRSW, gain[6:0] }*/
+	u1Byte			chl_num_LSB;							/*channel number[7:0]*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte			chl_num_MSB: 2;							/*channel number[9:8]*/
+	u1Byte			sub_chnl: 4;								/*sub-channel location[3:0]*/
+	u1Byte			r_RFMOD: 2;								/*RF mode[1:0]*/
+#else	/*_BIG_ENDIAN_	*/
+	u1Byte			r_RFMOD: 2;
+	u1Byte			sub_chnl: 4;
+	u1Byte			chl_num_MSB: 2;
+#endif
+
+/*	DWORD 1*/
+	u1Byte			pwdb_all;								/*CCK signal quality / OFDM pwdb all*/
+	s1Byte			cfosho[2];		/*DW1 byte 1 DW1 byte2	CCK AGC report and CCK_BB_Power / OFDM Path-A and Path-B short CFO*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	/*this should be checked again because the definition of 8812 and 8814 is different*/
+/*	u1Byte			r_cck_rx_enable_pathc:2;					cck rx enable pathc[1:0]*/
+/*	u1Byte			cck_rx_path:4;							cck rx path[3:0]*/
+	u1Byte			resvd_0: 6;
+	u1Byte			bt_RF_ch_MSB: 2;						/*8812A:2'b0			8814A: bt rf channel keep[7:6]*/
+#else	/*_BIG_ENDIAN_*/
+	u1Byte			bt_RF_ch_MSB: 2;
+	u1Byte			resvd_0: 6;
+#endif
+
+/*	DWORD 2*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte			ant_div_sw_a: 1;							/*8812A: ant_div_sw_a    8814A: 1'b0*/
+	u1Byte			ant_div_sw_b: 1;							/*8812A: ant_div_sw_b    8814A: 1'b0*/
+	u1Byte			bt_RF_ch_LSB: 6;						/*8812A: 6'b0                   8814A: bt rf channel keep[5:0]*/
+#else	/*_BIG_ENDIAN_	*/
+	u1Byte			bt_RF_ch_LSB: 6;
+	u1Byte			ant_div_sw_b: 1;
+	u1Byte			ant_div_sw_a: 1;
+#endif
+	s1Byte			cfotail[2];		   /*DW2 byte 1 DW2 byte 2	path-A and path-B CFO tail*/
+	u1Byte			PCTS_MSK_RPT_0;						/*PCTS mask report[7:0]*/
+	u1Byte			PCTS_MSK_RPT_1;						/*PCTS mask report[15:8]*/
+
+/*	DWORD 3*/
+	s1Byte			rxevm[2];	         /*DW3 byte 1 DW3 byte 2	stream 1 and stream 2 RX EVM*/
+	s1Byte			rxsnr[2];	         /*DW3 byte 3 DW4 byte 0	path-A and path-B RX SNR*/
+
+/*	DWORD 4*/
+	u1Byte			PCTS_MSK_RPT_2;						/*PCTS mask report[23:16]*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte			PCTS_MSK_RPT_3: 6;						/*PCTS mask report[29:24]*/
+	u1Byte			pcts_rpt_valid: 1;							/*pcts_rpt_valid*/
+	u1Byte			resvd_1: 1;								/*1'b0*/
+#else	/*_BIG_ENDIAN_*/
+	u1Byte			resvd_1: 1;
+	u1Byte			pcts_rpt_valid: 1;
+	u1Byte			PCTS_MSK_RPT_3: 6;
+#endif
+	s1Byte			rxevm_cd[2];	   /*DW 4 byte 3 DW5 byte 0  8812A: 16'b0	8814A: stream 3 and stream 4 RX EVM*/
+
+/*	DWORD 5*/
+	u1Byte			csi_current[2];	   /*DW5 byte 1 DW5 byte 2	8812A: stream 1 and 2 CSI	8814A:  path-C and path-D RX SNR*/
+	u1Byte			gain_trsw_cd[2];	   /*DW5 byte 3 DW6 byte 0	path-C and path-D {TRSW, gain[6:0] }*/
+
+/*	DWORD 6*/
+	s1Byte			sigevm;									/*signal field EVM*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte			antidx_antc: 3;							/*8812A: 3'b0		8814A: antidx_antc[2:0]*/
+	u1Byte			antidx_antd: 3;							/*8812A: 3'b0		8814A: antidx_antd[2:0]*/
+	u1Byte			dpdt_ctrl_keep: 1;						/*8812A: 1'b0		8814A: dpdt_ctrl_keep*/
+	u1Byte			GNT_BT_keep: 1;							/*8812A: 1'b0		8814A: GNT_BT_keep*/
+#else	/*_BIG_ENDIAN_*/
+	u1Byte			GNT_BT_keep: 1;
+	u1Byte			dpdt_ctrl_keep: 1;
+	u1Byte			antidx_antd: 3;
+	u1Byte			antidx_antc: 3;
+#endif
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte			antidx_anta: 3;							/*antidx_anta[2:0]*/
+	u1Byte			antidx_antb: 3;							/*antidx_antb[2:0]*/
+	u1Byte			hw_antsw_occur: 2;								/*1'b0*/
+#else	/*_BIG_ENDIAN_*/
+	u1Byte			hw_antsw_occur: 2;
+	u1Byte			antidx_antb: 3;
+	u1Byte			antidx_anta: 3;
+#endif
+} PHY_STATUS_RPT_8812_T, *PPHY_STATUS_RPT_8812_T;
+
+VOID
+odm_Init_RSSIForDM(
+	IN OUT	PDM_ODM_T	pDM_Odm
+	);
+
+VOID
+ODM_PhyStatusQuery(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	OUT		PODM_PHY_INFO_T			pPhyInfo,
+	IN 		pu1Byte						pPhyStatus,	
+	IN		PODM_PACKET_INFO_T			pPktinfo
+	);
+
+VOID
+ODM_MacStatusQuery(
+	IN OUT	PDM_ODM_T					pDM_Odm,
+	IN 		pu1Byte						pMacStatus,
+	IN		u1Byte						MacID,	
+	IN		BOOLEAN						bPacketMatchBSSID,
+	IN		BOOLEAN						bPacketToSelf,
+	IN		BOOLEAN						bPacketBeacon
+	);
+
+HAL_STATUS
+ODM_ConfigRFWithTxPwrTrackHeaderFile(
+	IN 	PDM_ODM_T	        	pDM_Odm
+    );
+    
+HAL_STATUS
+ODM_ConfigRFWithHeaderFile(
+	IN 	PDM_ODM_T	        	pDM_Odm,
+	IN 	ODM_RF_Config_Type 		ConfigType,
+	IN 	ODM_RF_RADIO_PATH_E 	eRFPath
+	);
+
+HAL_STATUS
+ODM_ConfigBBWithHeaderFile(
+	IN  	PDM_ODM_T	                pDM_Odm,
+	IN	ODM_BB_Config_Type		ConfigType
+    );
+
+HAL_STATUS
+ODM_ConfigMACWithHeaderFile(
+	IN  	PDM_ODM_T	pDM_Odm
+    );
+
+HAL_STATUS
+ODM_ConfigFWWithHeaderFile(
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN 	ODM_FW_Config_Type 	ConfigType,
+	OUT u1Byte				*pFirmware,
+	OUT u4Byte				*pSize
+	);
+
+u4Byte 
+ODM_GetHWImgVersion(
+	IN	PDM_ODM_T	pDM_Odm
+	);
+
+s4Byte
+odm_SignalScaleMapping(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	IN	s4Byte CurrSig 
+	);
+
+#if (RTL8822B_SUPPORT == 1)
+/*For 8822B only!! need to move to FW finally */
+/*==============================================*/
+VOID
+phydm_RxPhyStatusJaguarSeries2(
+	IN		PDM_ODM_T					pPhydm,
+	IN		pu1Byte						pPhyStatus,
+	IN		PODM_PACKET_INFO_T			pPktinfo,
+	OUT		PODM_PHY_INFO_T			pPhyInfo
+);
+
+typedef struct _Phy_Status_Rpt_Jaguar2_Type0 {
+	/* DW0 */
+	u1Byte		page_num;
+	u1Byte		pwdb;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		gain: 6;
+	u1Byte		rsvd_0: 1;
+	u1Byte		trsw: 1;
+#else
+	u1Byte		trsw: 1;
+	u1Byte		rsvd_0: 1;
+	u1Byte		gain: 6;
+#endif
+	u1Byte		rsvd_1;
+
+	/* DW1 */
+	u1Byte		rsvd_2;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		rxsc: 4;
+	u1Byte		agc_table: 4;
+#else
+	u1Byte		agc_table: 4;
+	u1Byte		rxsc: 4;
+#endif
+	u1Byte		channel;
+	u1Byte		band;
+
+	/* DW2 */
+	u2Byte		length;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		antidx_a: 3;
+	u1Byte		antidx_b: 3;
+	u1Byte		rsvd_3: 2;
+	u1Byte		antidx_c: 3;
+	u1Byte		antidx_d: 3;
+	u1Byte		rsvd_4:2;
+#else
+	u1Byte		rsvd_3: 2;
+	u1Byte		antidx_b: 3;
+	u1Byte		antidx_a: 3;
+	u1Byte		rsvd_4:2;
+	u1Byte		antidx_d: 3;
+	u1Byte		antidx_c: 3;
+#endif
+
+	/* DW3 */
+	u1Byte		signal_quality;
+	u1Byte		agc_rpt;
+	u1Byte		bb_power;
+	u1Byte		rsvd_5;
+
+	/* DW4 */
+	u4Byte		rsvd_6;
+
+	/* DW5 */
+	u4Byte		rsvd_7;
+
+	/* DW6 */
+	u4Byte		rsvd_8;
+} PHY_STATUS_RPT_JAGUAR2_TYPE0, *PPHY_STATUS_RPT_JAGUAR2_TYPE0;
+
+typedef struct _Phy_Status_Rpt_Jaguar2_Type1 {
+	/* DW0 and DW1 */
+	u1Byte		page_num;
+	u1Byte		pwdb[4];
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		l_rxsc: 4;
+	u1Byte		ht_rxsc: 4;
+#else
+	u1Byte		ht_rxsc: 4;
+	u1Byte		l_rxsc: 4;
+#endif
+	u1Byte		channel;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		band: 2;
+	u1Byte		rsvd_0: 1;
+	u1Byte		hw_antsw_occu: 1;
+	u1Byte		gnt_bt: 1;
+	u1Byte		ldpc: 1;
+	u1Byte		stbc: 1;
+	u1Byte		beamformed: 1;
+#else
+	u1Byte		beamformed: 1;
+	u1Byte		stbc: 1;
+	u1Byte		ldpc: 1;
+	u1Byte		gnt_bt: 1;
+	u1Byte		hw_antsw_occu: 1;
+	u1Byte		rsvd_0: 1;
+	u1Byte		band: 2;
+#endif
+
+	/* DW2 */
+	u2Byte		lsig_length;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		antidx_a: 3;
+	u1Byte		antidx_b: 3;
+	u1Byte		rsvd_1: 2;
+	u1Byte		antidx_c: 3;
+	u1Byte		antidx_d: 3;
+	u1Byte		rsvd_2: 2;
+#else
+	u1Byte		rsvd_1: 2;
+	u1Byte		antidx_b: 3;
+	u1Byte		antidx_a: 3;
+	u1Byte		rsvd_2: 2;
+	u1Byte		antidx_d: 3;
+	u1Byte		antidx_c: 3;
+#endif
+
+	/* DW3 */
+	u1Byte		paid;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		paid_msb: 1;
+	u1Byte		gid: 6;
+	u1Byte		rsvd_3: 1;
+#else
+	u1Byte		rsvd_3: 1;
+	u1Byte		gid: 6;
+	u1Byte		paid_msb: 1;
+#endif
+	u1Byte		intf_pos;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		intf_pos_msb: 1;
+	u1Byte		rsvd_4: 2;
+	u1Byte		nb_intf_flag: 1;
+	u1Byte		rf_mode: 2;
+	u1Byte		rsvd_5: 2;
+#else
+	u1Byte		rsvd_5: 2;
+	u1Byte		rf_mode: 2;
+	u1Byte		nb_intf_flag: 1;
+	u1Byte		rsvd_4: 2;
+	u1Byte		intf_pos_msb: 1;
+#endif
+
+	/* DW4 */
+	s1Byte		rxevm[4];			/* s(8,1) */
+
+	/* DW5 */
+	s1Byte		cfo_tail[4];			/* s(8,7) */
+
+	/* DW6 */
+	s1Byte		rxsnr[4];			/* s(8,1) */
+} PHY_STATUS_RPT_JAGUAR2_TYPE1, *PPHY_STATUS_RPT_JAGUAR2_TYPE1;
+
+typedef struct _Phy_Status_Rpt_Jaguar2_Type2 {
+	/* DW0 ane DW1 */
+	u1Byte		page_num;
+	u1Byte		pwdb[4];
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)	
+	u1Byte		l_rxsc: 4;
+	u1Byte		ht_rxsc: 4;
+#else
+	u1Byte		ht_rxsc: 4;
+	u1Byte		l_rxsc: 4;
+#endif
+	u1Byte		channel;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		band: 2;
+	u1Byte		rsvd_0: 1;
+	u1Byte		hw_antsw_occu: 1;
+	u1Byte		gnt_bt: 1;
+	u1Byte		ldpc: 1;
+	u1Byte		stbc: 1;
+	u1Byte		beamformed: 1;
+#else
+	u1Byte		beamformed: 1;
+	u1Byte		stbc: 1;
+	u1Byte		ldpc: 1;
+	u1Byte		gnt_bt: 1;
+	u1Byte		hw_antsw_occu: 1;
+	u1Byte		rsvd_0: 1;
+	u1Byte		band: 2;
+#endif
+
+	/* DW2 */
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		shift_l_map: 6;
+	u1Byte		rsvd_1: 2;
+#else
+	u1Byte		rsvd_1: 2;
+	u1Byte		shift_l_map: 6;
+#endif
+	u1Byte		cnt_pw2cca;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		agc_table_a: 4;
+	u1Byte		agc_table_b: 4;
+	u1Byte		agc_table_c: 4;
+	u1Byte		agc_table_d: 4;
+#else
+	u1Byte		agc_table_b: 4;
+	u1Byte		agc_table_a: 4;
+	u1Byte		agc_table_d: 4;
+	u1Byte		agc_table_c: 4;
+#endif
+
+	/* DW3 ~ DW6*/
+	u1Byte		cnt_cca2agc_rdy;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		gain_a: 6;
+	u1Byte		rsvd_2: 1;
+	u1Byte		trsw_a: 1;
+	u1Byte		gain_b: 6;
+	u1Byte		rsvd_3: 1;
+	u1Byte		trsw_b: 1;
+	u1Byte		gain_c: 6;
+	u1Byte		rsvd_4: 1;
+	u1Byte		trsw_c: 1;
+	u1Byte		gain_d: 6;
+	u1Byte		rsvd_5: 1;
+	u1Byte		trsw_d: 1;
+	u1Byte		aagc_step_a: 2;
+	u1Byte		aagc_step_b: 2;
+	u1Byte		aagc_step_c: 2;
+	u1Byte		aagc_step_d: 2;
+#else
+	u1Byte		trsw_a: 1;
+	u1Byte		rsvd_2: 1;
+	u1Byte		gain_a: 6;
+	u1Byte		trsw_b: 1;
+	u1Byte		rsvd_3: 1;
+	u1Byte		gain_b: 6;
+	u1Byte		trsw_c: 1;
+	u1Byte		rsvd_4: 1;
+	u1Byte		gain_c: 6;
+	u1Byte		trsw_d: 1;
+	u1Byte		rsvd_5: 1;
+	u1Byte		gain_d: 6;
+	u1Byte		aagc_step_d: 2;
+	u1Byte		aagc_step_c: 2;
+	u1Byte		aagc_step_b: 2;
+	u1Byte		aagc_step_a: 2;
+#endif
+	u1Byte		ht_aagc_gain[4];
+	u1Byte		dagc_gain[4];
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u1Byte		counter: 6;
+	u1Byte		rsvd_6: 2;
+	u1Byte		syn_count: 5;
+	u1Byte		rsvd_7:3;
+#else
+	u1Byte		rsvd_6: 2;
+	u1Byte		counter: 6;
+	u1Byte		rsvd_7:3;
+	u1Byte		syn_count: 5;
+#endif
+} PHY_STATUS_RPT_JAGUAR2_TYPE2, *PPHY_STATUS_RPT_JAGUAR2_TYPE2;
+/*==============================================*/
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.c
new file mode 100644
index 000000000..8f2ad7c83
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.c
@@ -0,0 +1,1014 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+//
+// ODM IO Relative API.
+//
+
+u1Byte
+ODM_Read1Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	return	RTL_R8(RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return rtw_read8(Adapter,RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return	PlatformEFIORead1Byte(Adapter, RegAddr);
+#endif	
+
+}
+
+
+u2Byte
+ODM_Read2Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	return	RTL_R16(RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return rtw_read16(Adapter,RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return	PlatformEFIORead2Byte(Adapter, RegAddr);
+#endif	
+
+}
+
+
+u4Byte
+ODM_Read4Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	return	RTL_R32(RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return rtw_read32(Adapter,RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return	PlatformEFIORead4Byte(Adapter, RegAddr);
+#endif	
+
+}
+
+
+VOID
+ODM_Write1Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	RTL_W8(RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	rtw_write8(Adapter,RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformEFIOWrite1Byte(Adapter, RegAddr, Data);
+#endif
+	
+}
+
+
+VOID
+ODM_Write2Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u2Byte			Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	RTL_W16(RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	rtw_write16(Adapter,RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformEFIOWrite2Byte(Adapter, RegAddr, Data);
+#endif	
+
+}
+
+
+VOID
+ODM_Write4Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	RTL_W32(RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	rtw_write32(Adapter,RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformEFIOWrite4Byte(Adapter, RegAddr, Data);
+#endif	
+
+}
+
+
+VOID
+ODM_SetMACReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask,
+	IN	u4Byte		Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PHY_SetBBReg(pDM_Odm->priv, RegAddr, BitMask, Data);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
+#endif	
+}
+
+
+u4Byte 
+ODM_GetMACReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return PHY_QueryBBReg(pDM_Odm->priv, RegAddr, BitMask);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	return PHY_QueryMacReg(pDM_Odm->Adapter, RegAddr, BitMask);
+#endif	
+}
+
+
+VOID
+ODM_SetBBReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask,
+	IN	u4Byte		Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PHY_SetBBReg(pDM_Odm->priv, RegAddr, BitMask, Data);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
+#endif	
+}
+
+
+u4Byte 
+ODM_GetBBReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return PHY_QueryBBReg(pDM_Odm->priv, RegAddr, BitMask);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return PHY_QueryBBReg(Adapter, RegAddr, BitMask);
+#endif	
+}
+
+
+VOID
+ODM_SetRFReg(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	ODM_RF_RADIO_PATH_E	eRFPath,
+	IN	u4Byte				RegAddr,
+	IN	u4Byte				BitMask,
+	IN	u4Byte				Data
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	PHY_SetRFReg(pDM_Odm->priv, eRFPath, RegAddr, BitMask, Data);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
+	ODM_delay_us(2);
+	
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PHY_SetRFReg(pDM_Odm->Adapter, eRFPath, RegAddr, BitMask, Data);
+#endif	
+}
+
+
+u4Byte 
+ODM_GetRFReg(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	ODM_RF_RADIO_PATH_E	eRFPath,
+	IN	u4Byte				RegAddr,
+	IN	u4Byte				BitMask
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return PHY_QueryRFReg(pDM_Odm->priv, eRFPath, RegAddr, BitMask, 1);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
+#endif	
+}
+
+
+
+
+//
+// ODM Memory relative API.
+//
+VOID
+ODM_AllocateMemory(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	OUT	PVOID		*pPtr,
+	IN	u4Byte		length
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	*pPtr = kmalloc(length, GFP_ATOMIC);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )
+	*pPtr = rtw_zvmalloc(length);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformAllocateMemory(Adapter, pPtr, length);
+#endif	
+}
+
+// length could be ignored, used to detect memory leakage.
+VOID
+ODM_FreeMemory(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	OUT	PVOID		pPtr,
+	IN	u4Byte		length
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	kfree(pPtr);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )	
+	rtw_vmfree(pPtr, length);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	//PADAPTER    Adapter = pDM_Odm->Adapter;
+	PlatformFreeMemory(pPtr, length);
+#endif	
+}
+
+VOID
+ODM_MoveMemory(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	OUT PVOID		pDest,
+	IN  PVOID		pSrc,
+	IN  u4Byte		Length
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	memcpy(pDest, pSrc, Length);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )	
+	_rtw_memcpy(pDest, pSrc, Length);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformMoveMemory(pDest, pSrc, Length);
+#endif	
+}
+
+void ODM_Memory_Set(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	PVOID		pbuf,
+	IN	s1Byte		value,
+	IN	u4Byte		length
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	memset(pbuf, value, length);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )	
+	_rtw_memset(pbuf,value, length);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformFillMemory(pbuf,length,value);
+#endif
+}
+s4Byte ODM_CompareMemory(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PVOID           pBuf1,
+	IN	PVOID           pBuf2,
+	IN	u4Byte          length
+       )
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return memcmp(pBuf1,pBuf2,length);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )	
+	return _rtw_memcmp(pBuf1,pBuf2,length);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+	return PlatformCompareMemory(pBuf1,pBuf2,length);
+#endif	
+}
+
+
+
+//
+// ODM MISC relative API.
+//
+VOID
+ODM_AcquireSpinLock(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	RT_SPINLOCK_TYPE	type
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	rtw_odm_acquirespinlock(Adapter, type);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformAcquireSpinLock(Adapter, type);
+#endif	
+}
+VOID
+ODM_ReleaseSpinLock(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	RT_SPINLOCK_TYPE	type
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	rtw_odm_releasespinlock(Adapter, type);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformReleaseSpinLock(Adapter, type);
+#endif	
+}
+
+//
+// Work item relative API. FOr MP driver only~!
+//
+VOID
+ODM_InitializeWorkItem(	
+	IN 	PDM_ODM_T					pDM_Odm,
+	IN	PRT_WORK_ITEM				pRtWorkItem,
+	IN	RT_WORKITEM_CALL_BACK		RtWorkItemCallback,
+	IN	PVOID						pContext,
+	IN	const char*					szID
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformInitializeWorkItem(Adapter, pRtWorkItem, RtWorkItemCallback, pContext, szID);
+#endif	
+}
+
+
+VOID
+ODM_StartWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformStartWorkItem(pRtWorkItem);
+#endif	
+}
+
+
+VOID
+ODM_StopWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformStopWorkItem(pRtWorkItem);
+#endif	
+}
+
+
+VOID
+ODM_FreeWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformFreeWorkItem(pRtWorkItem);
+#endif	
+}
+
+
+VOID
+ODM_ScheduleWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformScheduleWorkItem(pRtWorkItem);
+#endif	
+}
+
+
+VOID
+ODM_IsWorkItemScheduled(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformIsWorkItemScheduled(pRtWorkItem);
+#endif	
+}
+
+
+
+//
+// ODM Timer relative API.
+//
+VOID
+ODM_StallExecution(	
+	IN	u4Byte	usDelay
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	rtw_udelay_os(usDelay);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformStallExecution(usDelay);
+#endif	
+}
+
+VOID
+ODM_delay_ms(IN u4Byte	ms)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	delay_ms(ms);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	rtw_mdelay_os(ms);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	delay_ms(ms);
+#endif			
+}
+
+VOID
+ODM_delay_us(IN u4Byte	us)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	delay_us(us);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	rtw_udelay_os(us);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformStallExecution(us);
+#endif			
+}
+
+VOID
+ODM_sleep_ms(IN u4Byte	ms)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	rtw_msleep_os(ms);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+#endif		
+}
+
+VOID
+ODM_sleep_us(IN u4Byte	us)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	rtw_usleep_os(us);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+#endif		
+}
+
+VOID
+ODM_SetTimer(	
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PRT_TIMER 		pTimer, 
+	IN	u4Byte 			msDelay
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	mod_timer(pTimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(msDelay));
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	_set_timer(pTimer,msDelay ); //ms
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformSetTimer(Adapter, pTimer, msDelay);
+#endif	
+
+}
+
+VOID
+ODM_InitializeTimer(
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	PRT_TIMER 			pTimer, 
+	IN	RT_TIMER_CALL_BACK	CallBackFunc, 
+	IN	PVOID				pContext,
+	IN	const char*			szID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	init_timer(pTimer);
+	pTimer->function = CallBackFunc;
+	pTimer->data = (unsigned long)pDM_Odm;
+	mod_timer(pTimer, jiffies+RTL_MILISECONDS_TO_JIFFIES(10));	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	timer_setup(pTimer, CallBackFunc, 0);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	PlatformInitializeTimer(Adapter, pTimer, CallBackFunc,pContext,szID);
+#endif	
+}
+
+
+VOID
+ODM_CancelTimer(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PRT_TIMER		pTimer
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	del_timer(pTimer);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	_cancel_timer_ex(pTimer);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	PlatformCancelTimer(Adapter, pTimer);
+#endif
+}
+
+
+VOID
+ODM_ReleaseTimer(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PRT_TIMER		pTimer
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+	PADAPTER Adapter = pDM_Odm->Adapter;
+
+    // <20120301, Kordan> If the initilization fails, InitializeAdapterXxx will return regardless of InitHalDm. 
+    // Hence, uninitialized timers cause BSOD when the driver releases resources since the init fail.
+    if (pTimer == 0) 
+    {
+        ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_SERIOUS, ("=====>ODM_ReleaseTimer(), The timer is NULL! Please check it!\n"));
+        return;
+    }
+        
+	PlatformReleaseTimer(Adapter, pTimer);
+#endif
+}
+
+BOOLEAN
+phydm_actingDetermine(
+	IN PDM_ODM_T		pDM_Odm,
+	IN PHYDM_ACTING_TYPE	type
+	)
+{
+	BOOLEAN		ret = FALSE;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->BeamformingInfo.SourceAdapter;
+#else
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	if (type == PhyDM_ACTING_AS_AP)
+		ret = ACTING_AS_AP(Adapter);
+	else if (type == PhyDM_ACTING_AS_IBSS)
+		ret = ACTING_AS_IBSS(Adapter);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	struct mlme_priv			*pmlmepriv = &(Adapter->mlmepriv);
+
+	if (type == PhyDM_ACTING_AS_AP)
+		ret = check_fwstate(pmlmepriv, WIFI_AP_STATE);
+	else if (type == PhyDM_ACTING_AS_IBSS)
+		ret = check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+#endif
+
+	return ret;
+
+}
+
+
+u1Byte
+phydm_trans_h2c_id(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	u1Byte		phydm_h2c_id
+)
+{
+	u1Byte platform_h2c_id=0xff;
+
+	
+	switch(phydm_h2c_id)
+	{
+		//1 [0]
+		case ODM_H2C_RSSI_REPORT:
+
+			#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				if(pDM_Odm->SupportICType == ODM_RTL8188E)
+				{
+					platform_h2c_id = H2C_88E_RSSI_REPORT;
+				}
+				else if(pDM_Odm->SupportICType == ODM_RTL8814A)
+				{
+					platform_h2c_id =H2C_8814A_RSSI_REPORT;                            
+				}
+				else
+				{
+					platform_h2c_id = H2C_RSSI_REPORT;
+				}
+				
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+				platform_h2c_id = H2C_RSSI_SETTING;
+
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)
+				#if ((RTL8881A_SUPPORT == 1) || (RTL8192E_SUPPORT == 1) || (RTL8814A_SUPPORT == 1) || (RTL8822B_SUPPORT == 1))
+					if (pDM_Odm->SupportICType == ODM_RTL8881A || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8814A || (pDM_Odm->SupportICType == ODM_RTL8822B)) 
+					{
+						platform_h2c_id =H2C_88XX_RSSI_REPORT;				
+						/*ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[H2C] H2C_88XX_RSSI_REPORT CMD_ID = (( %d ))\n", platform_h2c_id));*/
+					} else
+				#endif
+				#if(RTL8812A_SUPPORT==1) 
+					if(pDM_Odm->SupportICType == ODM_RTL8812)
+					{
+						platform_h2c_id = H2C_8812_RSSI_REPORT;
+					} else
+				#endif				
+					{}
+			#endif
+			
+				break;
+
+		//1 [3]	
+		case ODM_H2C_WIFI_CALIBRATION:
+			#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+					platform_h2c_id =H2C_WIFI_CALIBRATION;
+			
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+				#if(RTL8723B_SUPPORT==1) 
+					platform_h2c_id = H2C_8723B_BT_WLAN_CALIBRATION;
+				#endif
+				
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)
+
+			
+			#endif
+			
+				break;		
+	
+			
+		//1 [4]
+		case ODM_H2C_IQ_CALIBRATION:
+			#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				platform_h2c_id =H2C_IQ_CALIBRATION;
+			
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+				#if((RTL8812A_SUPPORT==1) ||(RTL8821A_SUPPORT==1))
+				platform_h2c_id = H2C_8812_IQ_CALIBRATION;
+				#endif
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)
+
+			
+			#endif
+			
+				break;
+		//1 [5]
+		case ODM_H2C_RA_PARA_ADJUST:
+
+			#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				if (pDM_Odm->SupportICType & (ODM_RTL8814A | ODM_RTL8822B))
+					platform_h2c_id = H2C_8814A_RA_PARA_ADJUST;
+				else
+					platform_h2c_id = H2C_RA_PARA_ADJUST;
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+				#if((RTL8812A_SUPPORT==1) ||(RTL8821A_SUPPORT==1))
+					platform_h2c_id = H2C_8812_RA_PARA_ADJUST;
+				#elif ((RTL8814A_SUPPORT == 1) || (RTL8822B_SUPPORT == 1))
+					platform_h2c_id = H2C_RA_PARA_ADJUST;
+				#elif(RTL8192E_SUPPORT==1)
+					platform_h2c_id =H2C_8192E_RA_PARA_ADJUST;
+				#elif(RTL8723B_SUPPORT==1) 
+					platform_h2c_id =H2C_8723B_RA_PARA_ADJUST;
+				#endif
+				
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)
+				#if ((RTL8881A_SUPPORT == 1) || (RTL8192E_SUPPORT == 1) || (RTL8814A_SUPPORT == 1) || (RTL8822B_SUPPORT == 1)) 
+					if (pDM_Odm->SupportICType == ODM_RTL8881A || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8814A || (pDM_Odm->SupportICType == ODM_RTL8822B)) {
+						platform_h2c_id =H2C_88XX_RA_PARA_ADJUST;				
+						/*ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[H2C] H2C_88XX_RA_PARA_ADJUST CMD_ID = (( %d ))\n", platform_h2c_id));*/
+					} else
+				#endif
+				#if(RTL8812A_SUPPORT==1) 
+					if(pDM_Odm->SupportICType == ODM_RTL8812)
+					{
+						platform_h2c_id = H2C_8812_RA_PARA_ADJUST;
+					} else
+				#endif
+					{}
+			#endif
+			
+				break;
+
+
+		//1 [6]
+		case PHYDM_H2C_DYNAMIC_TX_PATH:
+
+			#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				if(pDM_Odm->SupportICType == ODM_RTL8814A)
+				{
+					platform_h2c_id =H2C_8814A_DYNAMIC_TX_PATH;
+				}
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+				#if (RTL8814A_SUPPORT == 1)
+				if (pDM_Odm->SupportICType == ODM_RTL8814A)
+					platform_h2c_id = H2C_DYNAMIC_TX_PATH;
+				#endif
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)
+				#if(RTL8814A_SUPPORT==1)
+					if( pDM_Odm->SupportICType == ODM_RTL8814A)
+					{
+						platform_h2c_id = H2C_88XX_DYNAMIC_TX_PATH;				
+					} 
+				#endif
+
+			#endif
+			
+				break;
+
+		/* [7]*/
+		case PHYDM_H2C_FW_TRACE_EN:
+
+			#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8822B))
+					platform_h2c_id = H2C_8814A_FW_TRACE_EN;
+				else 
+					platform_h2c_id = H2C_FW_TRACE_EN;
+				
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+				
+			#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)
+				#if ((RTL8881A_SUPPORT == 1) || (RTL8192E_SUPPORT == 1) || (RTL8814A_SUPPORT == 1) || (RTL8822B_SUPPORT == 1))
+					if (pDM_Odm->SupportICType == ODM_RTL8881A || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8814A || (pDM_Odm->SupportICType == ODM_RTL8822B))
+						platform_h2c_id  = H2C_88XX_FW_TRACE_EN;
+					else
+				#endif
+				#if (RTL8812A_SUPPORT == 1) 
+					if (pDM_Odm->SupportICType == ODM_RTL8812) {
+						platform_h2c_id = H2C_8812_FW_TRACE_EN;
+					} else
+				#endif
+					{}
+
+			#endif
+			
+				break;
+
+		case PHYDM_H2C_TXBF:
+#if ((RTL8192E_SUPPORT == 1) || (RTL8812A_SUPPORT == 1))
+			platform_h2c_id  = 0x41;	/*H2C_TxBF*/
+#endif
+		break;
+
+		default:
+			platform_h2c_id=0xff;
+			break;	
+	}	
+	
+	return platform_h2c_id;
+	
+}
+
+//
+// ODM FW relative API.
+//
+
+VOID
+ODM_FillH2CCmd(
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	u1Byte 			phydm_h2c_id,
+	IN	u4Byte 			CmdLen,
+	IN	pu1Byte			pCmdBuffer
+)
+{
+	PADAPTER 	Adapter = pDM_Odm->Adapter;
+	u1Byte		platform_h2c_id;
+
+	platform_h2c_id=phydm_trans_h2c_id(pDM_Odm, phydm_h2c_id);
+
+	if(platform_h2c_id==0xff)
+	{
+		ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[H2C] Wrong H2C CMD-ID !! platform_h2c_id==0xff ,  PHYDM_ElementID=((%d )) \n",phydm_h2c_id));
+		return;
+	}
+
+	#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+		if (pDM_Odm->SupportICType == ODM_RTL8188E)		
+			if (!pDM_Odm->RaSupport88E)
+				FillH2CCmd88E(Adapter, platform_h2c_id, CmdLen, pCmdBuffer);		
+		else if (pDM_Odm->SupportICType == ODM_RTL8192C)		
+			FillH2CCmd92C(Adapter, platform_h2c_id, CmdLen, pCmdBuffer);		
+		else if (pDM_Odm->SupportICType == ODM_RTL8814A)		
+			FillH2CCmd8814A(Adapter, platform_h2c_id, CmdLen, pCmdBuffer);		
+		else if (pDM_Odm->SupportICType == ODM_RTL8822B)		
+#if (RTL8822B_SUPPORT == 1)
+			FillH2CCmd8822B(Adapter, platform_h2c_id, CmdLen, pCmdBuffer);
+#endif		
+		else				
+			FillH2CCmd(Adapter, platform_h2c_id, CmdLen, pCmdBuffer);
+		
+	#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+		rtw_hal_fill_h2c_cmd(Adapter, platform_h2c_id, CmdLen, pCmdBuffer);
+
+	#elif(DM_ODM_SUPPORT_TYPE & ODM_AP)	
+		#if((RTL8881A_SUPPORT==1)||(RTL8192E_SUPPORT==1)||(RTL8814A_SUPPORT==1)) 
+			if(pDM_Odm->SupportICType == ODM_RTL8881A || pDM_Odm->SupportICType == ODM_RTL8192E|| pDM_Odm->SupportICType == ODM_RTL8814A) 
+			{
+				GET_HAL_INTERFACE(pDM_Odm->priv)->FillH2CCmdHandler(pDM_Odm->priv, platform_h2c_id, CmdLen, pCmdBuffer);
+				//FillH2CCmd88XX(pDM_Odm->priv, platform_h2c_id, CmdLen, pCmdBuffer);				
+			} else
+		#endif
+		#if(RTL8812A_SUPPORT==1) 
+			if(pDM_Odm->SupportICType == ODM_RTL8812)
+			{
+				FillH2CCmd8812(pDM_Odm->priv, platform_h2c_id, CmdLen, pCmdBuffer);
+			} else
+		#endif
+			{}
+	#endif
+}
+
+u1Byte
+phydm_c2H_content_parsing(
+	IN	PVOID			pDM_VOID,
+	IN	u1Byte			c2hCmdId,
+	IN	u1Byte			c2hCmdLen,
+	IN	pu1Byte			tmpBuf
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	#endif
+	u1Byte	Extend_c2hSubID = 0;
+	u1Byte	find_c2h_cmd = TRUE;
+
+	switch (c2hCmdId) {
+	case PHYDM_C2H_DBG:
+		if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8822B))
+			phydm_fw_trace_handler(pDM_Odm, tmpBuf, c2hCmdLen);
+		
+		break;
+
+	case PHYDM_C2H_RA_RPT:
+		phydm_c2h_ra_report_handler(pDM_Odm, tmpBuf, c2hCmdLen);
+		break;
+
+	case PHYDM_C2H_RA_PARA_RPT:
+		ODM_C2HRaParaReportHandler(pDM_Odm, tmpBuf, c2hCmdLen);
+		break;
+		
+	case PHYDM_C2H_DYNAMIC_TX_PATH_RPT:
+		if (pDM_Odm->SupportICType & (ODM_RTL8814A))
+			phydm_c2h_dtp_handler(pDM_Odm, tmpBuf, c2hCmdLen);
+		
+		break;
+		
+	case PHYDM_C2H_IQK_FINISH:
+		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		
+		if (pDM_Odm->SupportICType & (ODM_RTL8812 | ODM_RTL8821)) {
+			
+			RT_TRACE(COMP_MP, DBG_LOUD, ("== FW IQK Finish ==\n"));
+			PlatformAcquireSpinLock(Adapter, RT_IQK_SPINLOCK);
+			pDM_Odm->RFCalibrateInfo.bIQKInProgress = FALSE;
+			PlatformReleaseSpinLock(Adapter, RT_IQK_SPINLOCK);
+			pDM_Odm->RFCalibrateInfo.IQK_ProgressingTime = 0;
+			pDM_Odm->RFCalibrateInfo.IQK_ProgressingTime = ODM_GetProgressingTime(pDM_Odm, pDM_Odm->RFCalibrateInfo.IQK_StartTime);
+		}
+		
+		#endif
+		break;
+
+	case PHYDM_C2H_DBG_CODE:
+		phydm_fw_trace_handler_code(pDM_Odm, tmpBuf, c2hCmdLen);
+		break;	
+
+	case PHYDM_C2H_EXTEND:
+		Extend_c2hSubID = tmpBuf[0];
+		if (Extend_c2hSubID == PHYDM_EXTEND_C2H_DBG_PRINT)
+			phydm_fw_trace_handler_8051(pDM_Odm, tmpBuf, c2hCmdLen);
+		
+		break;
+
+	default:
+		find_c2h_cmd = FALSE;
+		break;
+	}
+
+	return find_c2h_cmd;
+
+}
+
+u8Byte
+ODM_GetCurrentTime(	
+	IN 	PDM_ODM_T		pDM_Odm
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return  0;
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	return (u8Byte)rtw_get_current_time();
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+	return  PlatformGetCurrentTime();
+#endif
+}
+
+u8Byte
+ODM_GetProgressingTime(	
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u8Byte			Start_Time
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return  0;
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	return rtw_get_passing_time_ms((u4Byte)Start_Time);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	return   ((PlatformGetCurrentTime() - Start_Time)>>10);
+#endif
+}
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.h
new file mode 100644
index 000000000..342c493e8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_interface.h
@@ -0,0 +1,442 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__ODM_INTERFACE_H__
+#define __ODM_INTERFACE_H__
+
+#define INTERFACE_VERSION	"1.0"		/*2015.01.13  Dino*/
+
+//
+// =========== Constant/Structure/Enum/... Define
+//
+
+
+
+//
+// =========== Macro Define
+//
+
+#define _reg_all(_name)			ODM_##_name
+#define _reg_ic(_name, _ic)		ODM_##_name##_ic
+#define _bit_all(_name)			BIT_##_name
+#define _bit_ic(_name, _ic)		BIT_##_name##_ic
+
+// _cat: implemented by Token-Pasting Operator.
+#if 0
+#define _cat(_name, _ic_type, _func)								\
+	( 															\
+		_func##_all(_name)										\
+	)
+#endif
+
+/*===================================
+
+#define ODM_REG_DIG_11N		0xC50
+#define ODM_REG_DIG_11AC	0xDDD
+
+ODM_REG(DIG,_pDM_Odm)
+=====================================*/
+
+#define _reg_11N(_name)			ODM_REG_##_name##_11N 
+#define _reg_11AC(_name)		ODM_REG_##_name##_11AC
+#define _bit_11N(_name)			ODM_BIT_##_name##_11N 
+#define _bit_11AC(_name)		ODM_BIT_##_name##_11AC
+
+#ifdef __ECOS
+#define _rtk_cat(_name, _ic_type, _func)		\
+	( 					\
+		((_ic_type) & ODM_IC_11N_SERIES)? _func##_11N(_name):		\
+		_func##_11AC(_name)	\
+	)
+#else
+
+#define _cat(_name, _ic_type, _func)									\
+	( 															\
+		((_ic_type) & ODM_IC_11N_SERIES)? _func##_11N(_name):		\
+		_func##_11AC(_name)									\
+	)
+#endif
+/* 
+// only sample code
+//#define _cat(_name, _ic_type, _func)									\
+//	( 															\
+//		((_ic_type) & ODM_RTL8192C)? _func##_ic(_name, _8192C):		\
+//		((_ic_type) & ODM_RTL8192D)? _func##_ic(_name, _8192D):		\
+//		((_ic_type) & ODM_RTL8192S)? _func##_ic(_name, _8192S):		\
+//		((_ic_type) & ODM_RTL8723A)? _func##_ic(_name, _8723A):		\
+//		((_ic_type) & ODM_RTL8188E)? _func##_ic(_name, _8188E):		\
+//		_func##_ic(_name, _8195)									\
+//	)
+*/
+
+// _name: name of register or bit.
+// Example: "ODM_REG(R_A_AGC_CORE1, pDM_Odm)" 
+//        gets "ODM_R_A_AGC_CORE1" or "ODM_R_A_AGC_CORE1_8192C", depends on SupportICType.
+#ifdef __ECOS
+#define ODM_REG(_name, _pDM_Odm)	_rtk_cat(_name, _pDM_Odm->SupportICType, _reg)
+#define ODM_BIT(_name, _pDM_Odm)	_rtk_cat(_name, _pDM_Odm->SupportICType, _bit)
+#else
+#define ODM_REG(_name, _pDM_Odm)	_cat(_name, _pDM_Odm->SupportICType, _reg)
+#define ODM_BIT(_name, _pDM_Odm)	_cat(_name, _pDM_Odm->SupportICType, _bit)
+#endif
+typedef enum _PHYDM_H2C_CMD {
+	ODM_H2C_RSSI_REPORT = 0,
+	ODM_H2C_PSD_RESULT = 1,	
+	ODM_H2C_PathDiv = 2,
+	ODM_H2C_WIFI_CALIBRATION = 3,
+	ODM_H2C_IQ_CALIBRATION = 4,
+	ODM_H2C_RA_PARA_ADJUST = 5,
+	PHYDM_H2C_DYNAMIC_TX_PATH = 6,
+	PHYDM_H2C_FW_TRACE_EN = 7,
+	PHYDM_H2C_TXBF = 8,
+	ODM_MAX_H2CCMD
+} PHYDM_H2C_CMD;
+
+typedef enum _PHYDM_C2H_EVT {
+	PHYDM_C2H_DBG = 0,
+	PHYDM_C2H_LB = 1,
+	PHYDM_C2H_XBF = 2,
+	PHYDM_C2H_TX_REPORT = 3,
+	PHYDM_C2H_INFO = 9,
+	PHYDM_C2H_BT_MP = 11,
+	PHYDM_C2H_RA_RPT = 12,
+	PHYDM_C2H_RA_PARA_RPT = 14,
+	PHYDM_C2H_DYNAMIC_TX_PATH_RPT = 15,
+	PHYDM_C2H_IQK_FINISH = 17, /*0x11*/
+	PHYDM_C2H_DBG_CODE = 0xFE,
+	PHYDM_C2H_EXTEND = 0xFF,
+} PHYDM_C2H_EVT;
+
+typedef enum _PHYDM_EXTEND_C2H_EVT {
+	PHYDM_EXTEND_C2H_DBG_PRINT = 0
+
+} PHYDM_EXTEND_C2H_EVT;
+
+typedef enum _PHYDM_ACTING_TYPE {
+	PhyDM_ACTING_AS_IBSS = 0,
+	PhyDM_ACTING_AS_AP = 1
+} PHYDM_ACTING_TYPE;
+
+
+//
+// 2012/02/17 MH For non-MP compile pass only. Linux does not support workitem.
+// Suggest HW team to use thread instead of workitem. Windows also support the feature.
+//
+#if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
+typedef  void *PRT_WORK_ITEM ;
+typedef  void RT_WORKITEM_HANDLE,*PRT_WORKITEM_HANDLE;
+typedef VOID (*RT_WORKITEM_CALL_BACK)(PVOID pContext);
+
+#if 0
+typedef struct tasklet_struct RT_WORKITEM_HANDLE, *PRT_WORKITEM_HANDLE;
+
+typedef struct _RT_WORK_ITEM
+{
+	
+	RT_WORKITEM_HANDLE			Handle;			// Platform-dependent handle for this workitem, e.g. Ndis Workitem object.
+	PVOID						Adapter;		// Pointer to Adapter object.
+	PVOID						pContext;		// Parameter to passed to CallBackFunc(). 
+	RT_WORKITEM_CALL_BACK		CallbackFunc;	// Callback function of the workitem.
+	u1Byte						RefCount;		// 0: driver is going to unload, 1: No such workitem scheduled, 2: one workitem is schedueled. 
+	PVOID						pPlatformExt;	// Pointer to platform-dependent extension.	
+	BOOLEAN						bFree;
+	char						szID[36];		// An identity string of this workitem.
+}RT_WORK_ITEM, *PRT_WORK_ITEM;
+
+#endif
+
+
+#endif
+
+//
+// =========== Extern Variable ??? It should be forbidden.
+//
+
+
+//
+// =========== EXtern Function Prototype
+//
+
+
+u1Byte
+ODM_Read1Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	);
+
+u2Byte
+ODM_Read2Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	);
+
+u4Byte
+ODM_Read4Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	);
+
+VOID
+ODM_Write1Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+
+VOID
+ODM_Write2Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u2Byte			Data
+	);
+
+VOID
+ODM_Write4Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			Data
+	);
+
+VOID
+ODM_SetMACReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask,
+	IN	u4Byte		Data
+	);
+
+u4Byte 
+ODM_GetMACReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask
+	);
+
+VOID
+ODM_SetBBReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask,
+	IN	u4Byte		Data
+	);
+
+u4Byte 
+ODM_GetBBReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask
+	);
+
+VOID
+ODM_SetRFReg(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	ODM_RF_RADIO_PATH_E	eRFPath,
+	IN	u4Byte				RegAddr,
+	IN	u4Byte				BitMask,
+	IN	u4Byte				Data
+	);
+
+u4Byte 
+ODM_GetRFReg(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	ODM_RF_RADIO_PATH_E	eRFPath,
+	IN	u4Byte				RegAddr,
+	IN	u4Byte				BitMask
+	);
+
+
+//
+// Memory Relative Function.
+//
+VOID
+ODM_AllocateMemory(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	OUT	PVOID		*pPtr,
+	IN	u4Byte		length
+	);
+VOID
+ODM_FreeMemory(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	OUT	PVOID		pPtr,
+	IN	u4Byte		length
+	);
+
+VOID
+ODM_MoveMemory(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	OUT PVOID		pDest,
+	IN  PVOID		pSrc,
+	IN  u4Byte		Length
+	);
+
+s4Byte ODM_CompareMemory(
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	PVOID           pBuf1,
+      IN	PVOID           pBuf2,
+      IN	u4Byte          length
+       );
+
+void ODM_Memory_Set
+	(IN 	PDM_ODM_T	pDM_Odm,
+		IN  PVOID	pbuf,
+		IN  s1Byte	value,
+		IN  u4Byte	length);
+	
+//
+// ODM MISC-spin lock relative API.
+//
+VOID
+ODM_AcquireSpinLock(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	RT_SPINLOCK_TYPE	type
+	);
+
+VOID
+ODM_ReleaseSpinLock(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	RT_SPINLOCK_TYPE	type
+	);
+
+
+//
+// ODM MISC-workitem relative API.
+//
+VOID
+ODM_InitializeWorkItem(	
+	IN 	PDM_ODM_T					pDM_Odm,
+	IN	PRT_WORK_ITEM				pRtWorkItem,
+	IN	RT_WORKITEM_CALL_BACK		RtWorkItemCallback,
+	IN	PVOID						pContext,
+	IN	const char*					szID
+	);
+
+VOID
+ODM_StartWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	);
+
+VOID
+ODM_StopWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	);
+
+VOID
+ODM_FreeWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	);
+
+VOID
+ODM_ScheduleWorkItem(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	);
+
+VOID
+ODM_IsWorkItemScheduled(	
+	IN	PRT_WORK_ITEM	pRtWorkItem
+	);
+
+//
+// ODM Timer relative API.
+//
+VOID
+ODM_StallExecution(	
+	IN	u4Byte	usDelay
+	);
+
+VOID
+ODM_delay_ms(IN u4Byte	ms);
+
+
+
+VOID
+ODM_delay_us(IN u4Byte	us);
+
+VOID
+ODM_sleep_ms(IN u4Byte	ms);
+
+VOID
+ODM_sleep_us(IN u4Byte	us);
+
+VOID
+ODM_SetTimer(	
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PRT_TIMER 		pTimer, 
+	IN	u4Byte 			msDelay
+	);
+
+VOID
+ODM_InitializeTimer(
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	PRT_TIMER 			pTimer, 
+	IN	RT_TIMER_CALL_BACK	CallBackFunc, 
+	IN	PVOID				pContext,
+	IN	const char*			szID
+	);
+
+VOID
+ODM_CancelTimer(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PRT_TIMER		pTimer
+	);
+
+VOID
+ODM_ReleaseTimer(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	PRT_TIMER		pTimer
+	);
+
+BOOLEAN
+phydm_actingDetermine(
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	PHYDM_ACTING_TYPE	type
+	);
+
+//
+// ODM FW relative API.
+//
+VOID
+ODM_FillH2CCmd(
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	u1Byte 			ElementID,
+	IN	u4Byte 			CmdLen,
+	IN	pu1Byte			pCmdBuffer
+);
+
+u1Byte
+phydm_c2H_content_parsing(
+	IN	PVOID			pDM_VOID,
+	IN	u1Byte			c2hCmdId,
+	IN	u1Byte			c2hCmdLen,
+	IN	pu1Byte			tmpBuf
+);
+
+u8Byte
+ODM_GetCurrentTime(	
+	IN 	PDM_ODM_T		pDM_Odm
+	);
+u8Byte
+ODM_GetProgressingTime(	
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u8Byte			Start_Time
+	);
+
+#endif	// __ODM_INTERFACE_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.c
new file mode 100644
index 000000000..647709cb5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.c
@@ -0,0 +1,299 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+//#include "mp_precomp.h"
+#include "phydm_precomp.h"
+#include "phydm_noisemonitor.h"
+
+//=================================================
+// This function is for inband noise test utility only
+// To obtain the inband noise level(dbm), do the following.
+// 1. disable DIG and Power Saving 
+// 2. Set initial gain = 0x1a
+// 3. Stop updating idle time pwer report (for driver read)
+//	- 0x80c[25]
+//
+//=================================================
+
+#define Valid_Min				-35
+#define Valid_Max			10
+#define ValidCnt				5	
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_CE))
+
+s2Byte odm_InbandNoise_Monitor_NSeries(PDM_ODM_T	pDM_Odm,u8 bPauseDIG,u8 IGIValue,u32 max_time)
+{
+	u4Byte				tmp4b;	
+	u1Byte				max_rf_path=0,rf_path;	
+	u1Byte				reg_c50, reg_c58,valid_done=0;	
+	struct noise_level		noise_data;
+	u32 start  = 0, 	func_start=0,	func_end = 0;
+
+	func_start = ODM_GetCurrentTime(pDM_Odm);
+	pDM_Odm->noise_level.noise_all = 0;
+	
+	if((pDM_Odm->RFType == ODM_1T2R) ||(pDM_Odm->RFType == ODM_2T2R))	
+		max_rf_path = 2;
+	else
+		max_rf_path = 1;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("odm_DebugControlInbandNoise_Nseries() ==> \n"));
+
+	ODM_Memory_Set(pDM_Odm,&noise_data,0,sizeof(struct noise_level));
+	
+	//
+	// Step 1. Disable DIG && Set initial gain.
+	//
+	
+	if(bPauseDIG)
+	{
+		odm_PauseDIG(pDM_Odm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_1, IGIValue);
+	}
+	//
+	// Step 2. Disable all power save for read registers
+	//
+	//dcmd_DebugControlPowerSave(pAdapter, PSDisable);
+
+	//
+	// Step 3. Get noise power level
+	//
+	start = ODM_GetCurrentTime(pDM_Odm);
+	while(1)
+	{
+		
+		//Stop updating idle time pwer report (for driver read)
+		ODM_SetBBReg(pDM_Odm, rFPGA0_TxGainStage, BIT25, 1);	
+		
+		//Read Noise Floor Report
+		tmp4b = ODM_GetBBReg(pDM_Odm, 0x8f8,bMaskDWord );
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("Noise Floor Report (0x8f8) = 0x%08x\n", tmp4b));
+		
+		//ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, TestInitialGain);
+		//if(max_rf_path == 2)
+		//	ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, TestInitialGain);
+		
+		//update idle time pwer report per 5us
+		ODM_SetBBReg(pDM_Odm, rFPGA0_TxGainStage, BIT25, 0);
+		
+		noise_data.value[ODM_RF_PATH_A] = (u1Byte)(tmp4b&0xff);		
+		noise_data.value[ODM_RF_PATH_B]  = (u1Byte)((tmp4b&0xff00)>>8);
+	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("value_a = 0x%x(%d), value_b = 0x%x(%d)\n", 
+			noise_data.value[ODM_RF_PATH_A], noise_data.value[ODM_RF_PATH_A], noise_data.value[ODM_RF_PATH_B], noise_data.value[ODM_RF_PATH_B]));
+
+		 for(rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++) 
+		 {
+		 	noise_data.sval[rf_path] = (s1Byte)noise_data.value[rf_path];
+			noise_data.sval[rf_path] /= 2;
+		 }	
+		 	
+		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("sval_a = %d, sval_b = %d\n", 
+			noise_data.sval[ODM_RF_PATH_A], noise_data.sval[ODM_RF_PATH_B]));
+		//ODM_delay_ms(10);
+		//ODM_sleep_ms(10);
+
+		for(rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++) 
+		{
+			if( (noise_data.valid_cnt[rf_path] < ValidCnt) && (noise_data.sval[rf_path] < Valid_Max && noise_data.sval[rf_path] >= Valid_Min))
+			{
+				noise_data.valid_cnt[rf_path]++;
+				noise_data.sum[rf_path] += noise_data.sval[rf_path];
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("RF_Path:%d Valid sval = %d\n", rf_path,noise_data.sval[rf_path]));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("Sum of sval = %d, \n", noise_data.sum[rf_path]));
+				if(noise_data.valid_cnt[rf_path] == ValidCnt)
+				{				
+					valid_done++;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("After divided, RF_Path:%d ,sum = %d \n", rf_path,noise_data.sum[rf_path]));
+				}				
+			
+			}
+			
+		}
+
+		//printk("####### valid_done:%d #############\n",valid_done);
+		if ((valid_done==max_rf_path) || (ODM_GetProgressingTime(pDM_Odm,start) > max_time))
+		{
+			for(rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++)
+			{ 
+				//printk("%s PATH_%d - sum = %d, valid_cnt = %d \n",__FUNCTION__,rf_path,noise_data.sum[rf_path], noise_data.valid_cnt[rf_path]);
+				if(noise_data.valid_cnt[rf_path])
+					noise_data.sum[rf_path] /= noise_data.valid_cnt[rf_path];		
+				else
+					noise_data.sum[rf_path]  = 0;
+			}
+			break;
+		}
+	}
+	reg_c50 = (s4Byte)ODM_GetBBReg(pDM_Odm,rOFDM0_XAAGCCore1,bMaskByte0);
+	reg_c50 &= ~BIT7;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("0x%x = 0x%02x(%d)\n", rOFDM0_XAAGCCore1, reg_c50, reg_c50));
+	pDM_Odm->noise_level.noise[ODM_RF_PATH_A] = -110 + reg_c50 + noise_data.sum[ODM_RF_PATH_A];
+	pDM_Odm->noise_level.noise_all += pDM_Odm->noise_level.noise[ODM_RF_PATH_A];
+		
+	if(max_rf_path == 2){
+		reg_c58 = (s4Byte)ODM_GetBBReg(pDM_Odm,rOFDM0_XBAGCCore1,bMaskByte0);
+		reg_c58 &= ~BIT7;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("0x%x = 0x%02x(%d)\n", rOFDM0_XBAGCCore1, reg_c58, reg_c58));
+		pDM_Odm->noise_level.noise[ODM_RF_PATH_B] = -110 + reg_c58 + noise_data.sum[ODM_RF_PATH_B];
+		pDM_Odm->noise_level.noise_all += pDM_Odm->noise_level.noise[ODM_RF_PATH_B];
+	}
+	pDM_Odm->noise_level.noise_all /= max_rf_path;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("noise_a = %d, noise_b = %d\n", 
+		pDM_Odm->noise_level.noise[ODM_RF_PATH_A],
+		pDM_Odm->noise_level.noise[ODM_RF_PATH_B]));
+
+	//
+	// Step 4. Recover the Dig
+	//
+	if(bPauseDIG)
+	{
+		odm_PauseDIG(pDM_Odm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_1, IGIValue);
+	}	
+	func_end = ODM_GetProgressingTime(pDM_Odm,func_start) ;	
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_DebugControlInbandNoise_Nseries() <==\n"));
+	return pDM_Odm->noise_level.noise_all;
+
+}
+
+s2Byte	
+odm_InbandNoise_Monitor_ACSeries(PDM_ODM_T	pDM_Odm, u8 bPauseDIG, u8 IGIValue, u32 max_time
+	)
+{
+	s4Byte          rxi_buf_anta, rxq_buf_anta; /*rxi_buf_antb, rxq_buf_antb;*/
+	s4Byte	        value32, pwdb_A = 0, sval, noise, sum;
+	BOOLEAN	        pd_flag;
+	u1Byte			i, valid_cnt;
+	u32 start = 0, func_start = 0, func_end = 0;
+
+
+	if (!(pDM_Odm->SupportICType & (ODM_RTL8812 | ODM_RTL8821)))
+		return 0;
+	
+	func_start = ODM_GetCurrentTime(pDM_Odm);
+	pDM_Odm->noise_level.noise_all = 0;
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_InbandNoise_Monitor_ACSeries() ==>\n"));
+	
+	/* Step 1. Disable DIG && Set initial gain. */
+	if (bPauseDIG)
+		odm_PauseDIG(pDM_Odm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_1, IGIValue);
+
+	/* Step 2. Disable all power save for read registers */
+	/*dcmd_DebugControlPowerSave(pAdapter, PSDisable); */
+
+	/* Step 3. Get noise power level */
+	start = ODM_GetCurrentTime(pDM_Odm);
+
+	/* reset counters */
+	sum = 0;
+	valid_cnt = 0;
+
+	/* Step 3. Get noise power level */
+	while (1) {
+		/*Set IGI=0x1C */
+		ODM_Write_DIG(pDM_Odm, 0x1C);
+		/*stop CK320&CK88 */
+		ODM_SetBBReg(pDM_Odm, 0x8B4, BIT6, 1);
+		/*Read Path-A */
+		ODM_SetBBReg(pDM_Odm, 0x8FC, bMaskDWord, 0x200); /*set debug port*/
+		value32 = ODM_GetBBReg(pDM_Odm, 0xFA0, bMaskDWord); /*read debug port*/
+		
+		rxi_buf_anta = (value32 & 0xFFC00) >> 10; /*rxi_buf_anta=RegFA0[19:10]*/
+		rxq_buf_anta = value32 & 0x3FF; /*rxq_buf_anta=RegFA0[19:10]*/
+
+		pd_flag = (BOOLEAN) ((value32 & BIT31) >> 31);
+
+		/*Not in packet detection period or Tx state */
+		if ((!pd_flag) || (rxi_buf_anta != 0x200)) {
+			/*sign conversion*/
+			rxi_buf_anta = ODM_SignConversion(rxi_buf_anta, 10);
+			rxq_buf_anta = ODM_SignConversion(rxq_buf_anta, 10);
+
+			pwdb_A = ODM_PWdB_Conversion(rxi_buf_anta * rxi_buf_anta + rxq_buf_anta * rxq_buf_anta, 20, 18); /*S(10,9)*S(10,9)=S(20,18)*/
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pwdb_A= %d dB, rxi_buf_anta= 0x%x, rxq_buf_anta= 0x%x\n", pwdb_A, rxi_buf_anta & 0x3FF, rxq_buf_anta & 0x3FF));
+		}
+
+		/*BB Reset*/
+		ODM_Write1Byte(pDM_Odm, 0x02, ODM_Read1Byte(pDM_Odm, 0x02) & (~BIT0));
+		ODM_Write1Byte(pDM_Odm, 0x02, ODM_Read1Byte(pDM_Odm, 0x02) | BIT0);
+
+		/*Start CK320&CK88*/
+		ODM_SetBBReg(pDM_Odm, 0x8B4, BIT6, 0);
+
+		sval = pwdb_A;
+
+		if (sval < 0 && sval >= -27) {
+			if (valid_cnt < ValidCnt) {
+				valid_cnt++;
+				sum += sval;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("Valid sval = %d\n", sval));
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("Sum of sval = %d,\n", sum));
+				if ((valid_cnt >= ValidCnt) || (ODM_GetProgressingTime(pDM_Odm, start) > max_time)) {
+					sum /= valid_cnt;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("After divided, sum = %d\n", sum)); 
+					break;
+				}
+			}
+		}
+	}
+
+	/*ADC backoff is 12dB,*/ 
+	/*Ptarget=0x1C-110=-82dBm*/
+	noise = sum + 12 + 0x1C - 110; 
+	
+	/*Offset*/
+	noise = noise - 3;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("noise = %d\n", noise));
+	pDM_Odm->noise_level.noise_all = (s2Byte)noise;
+
+	/* Step 4. Recover the Dig*/
+	if (bPauseDIG)
+		odm_PauseDIG(pDM_Odm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_1, IGIValue);
+	
+	func_end = ODM_GetProgressingTime(pDM_Odm, func_start);
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_InbandNoise_Monitor_ACSeries() <==\n"));
+
+	return pDM_Odm->noise_level.noise_all;
+}
+
+
+
+s2Byte
+ODM_InbandNoise_Monitor(PVOID pDM_VOID, u8 bPauseDIG, u8 IGIValue, u32 max_time)
+{
+
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		return odm_InbandNoise_Monitor_ACSeries(pDM_Odm, bPauseDIG, IGIValue, max_time);
+	else
+		return odm_InbandNoise_Monitor_NSeries(pDM_Odm, bPauseDIG, IGIValue, max_time);
+}
+
+#endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.h
new file mode 100644
index 000000000..022cefe28
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_noisemonitor.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ *****************************************************************************/
+#ifndef	__ODMNOISEMONITOR_H__
+#define __ODMNOISEMONITOR_H__
+
+#define	ODM_MAX_CHANNEL_NUM					38//14+24
+struct noise_level
+{
+	//u1Byte				value_a, value_b;
+	u1Byte				value[MAX_RF_PATH];
+	//s1Byte				sval_a, sval_b;
+	s1Byte				sval[MAX_RF_PATH];
+	
+	//s4Byte				noise_a=0, noise_b=0,sum_a=0, sum_b=0;
+	//s4Byte				noise[ODM_RF_PATH_MAX];
+	s4Byte				sum[MAX_RF_PATH];
+	//u1Byte				valid_cnt_a=0, valid_cnt_b=0, 
+	u1Byte				valid[MAX_RF_PATH];
+	u1Byte				valid_cnt[MAX_RF_PATH];
+
+};
+
+
+typedef struct _ODM_NOISE_MONITOR_
+{
+	s1Byte			noise[MAX_RF_PATH];
+	s2Byte			noise_all;	
+}ODM_NOISE_MONITOR;
+
+s2Byte ODM_InbandNoise_Monitor(PVOID pDM_VOID,u8 bPauseDIG,u8 IGIValue,u32 max_time);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.c
new file mode 100644
index 000000000..f1a8f1122
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.c
@@ -0,0 +1,2311 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#if(defined(CONFIG_PATH_DIVERSITY))
+#if RTL8814A_SUPPORT
+
+VOID
+phydm_dtp_fix_tx_path(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	path
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
+	u1Byte			i,num_enable_path=0;
+
+	if(path==pDM_PathDiv->pre_tx_path)
+	{
+		return;
+	}
+	else
+	{
+		pDM_PathDiv->pre_tx_path=path;
+	}
+
+	ODM_SetBBReg( pDM_Odm, 0x93c, BIT18|BIT19, 3);
+
+	for(i=0; i<4; i++)
+	{
+		if(path&BIT(i))
+			num_enable_path++;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Number of trun-on path : (( %d ))\n", num_enable_path));
+
+	if(num_enable_path == 1)
+	{
+		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
+	
+		if(path==PHYDM_A)//1-1
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A ))\n"));
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+		}
+		else 	if(path==PHYDM_B)//1-2
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( B ))\n"));
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
+		}
+		else 	if(path==PHYDM_C)//1-3
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( C ))\n"));
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 0);
+
+		}
+		else 	if(path==PHYDM_D)//1-4
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( D ))\n"));
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 0);
+		}
+
+	}
+	else 	if(num_enable_path == 2)
+	{
+		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
+		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0, path);
+	
+		if(path==PHYDM_AB)//2-1
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);			
+		}
+		else 	if(path==PHYDM_AC)//2-2
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A C ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);	
+		}
+		else 	if(path==PHYDM_AD)//2-3
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A D ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+		}
+		else 	if(path==PHYDM_BC)//2-4
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( B C ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);	
+		}
+		else 	if(path==PHYDM_BD)//2-5
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( B D ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+		}
+		else 	if(path==PHYDM_CD)//2-6
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( C D ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+		}
+
+	}
+	else 	if(num_enable_path == 3)
+	{
+		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
+		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0, path);
+		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0000, path);
+	
+		if(path==PHYDM_ABC)//3-1
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B C))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 2);			
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 2);
+			//set for 3ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT21|BIT20, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT23|BIT22, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT25|BIT24, 2);
+		}
+		else 	if(path==PHYDM_ABD)//3-2
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B D ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);		
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);		
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 2);
+			//set for 3ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT21|BIT20, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT23|BIT22, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT27|BIT26, 2);
+
+		}
+		else 	if(path==PHYDM_ACD)//3-3
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A C D ))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);			
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 2);
+			//set for 3ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT21|BIT20, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT25|BIT24, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT27|BIT26, 2);
+		}
+		else 	if(path==PHYDM_BCD)//3-4
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( B C D))\n"));
+			//set for 1ss
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);			
+			//set for 2ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 2);
+			//set for 3ss
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT23|BIT22, 0);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT25|BIT24, 1);
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT27|BIT26, 2);
+		}
+	}
+	else 	if(num_enable_path == 4)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path ((A  B C D))\n"));
+	}
+
+}
+
+VOID
+phydm_find_default_path(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
+	u4Byte	rssi_avg_a=0, rssi_avg_b=0, rssi_avg_c=0, rssi_avg_d=0, rssi_avg_bcd=0;
+	u4Byte	rssi_total_a=0, rssi_total_b=0, rssi_total_c=0, rssi_total_d=0;
+
+	//2 Default Path Selection By RSSI
+
+	rssi_avg_a = (pDM_PathDiv->path_a_cnt_all > 0)? (pDM_PathDiv->path_a_sum_all / pDM_PathDiv->path_a_cnt_all) :0 ;
+	rssi_avg_b = (pDM_PathDiv->path_b_cnt_all > 0)? (pDM_PathDiv->path_b_sum_all / pDM_PathDiv->path_b_cnt_all) :0 ;
+	rssi_avg_c = (pDM_PathDiv->path_c_cnt_all > 0)? (pDM_PathDiv->path_c_sum_all / pDM_PathDiv->path_c_cnt_all) :0 ;
+	rssi_avg_d = (pDM_PathDiv->path_d_cnt_all > 0)? (pDM_PathDiv->path_d_sum_all / pDM_PathDiv->path_d_cnt_all) :0 ;
+
+
+	pDM_PathDiv->path_a_sum_all = 0;
+ 	pDM_PathDiv->path_a_cnt_all = 0;
+	pDM_PathDiv->path_b_sum_all = 0;
+ 	pDM_PathDiv->path_b_cnt_all = 0;
+	pDM_PathDiv->path_c_sum_all = 0;
+ 	pDM_PathDiv->path_c_cnt_all = 0;
+	pDM_PathDiv->path_d_sum_all = 0;
+ 	pDM_PathDiv->path_d_cnt_all = 0;
+
+	if(pDM_PathDiv->use_path_a_as_default_ant == 1)
+	{
+		rssi_avg_bcd=(rssi_avg_b+rssi_avg_c+rssi_avg_d)/3;
+
+		if( (rssi_avg_a + ANT_DECT_RSSI_TH) > rssi_avg_bcd  )
+		{
+			pDM_PathDiv->is_pathA_exist=TRUE;
+			pDM_PathDiv->default_path=PATH_A;
+		}
+		else
+		{
+			pDM_PathDiv->is_pathA_exist=FALSE;
+		}
+	}
+	else
+	{
+		if( (rssi_avg_a >=rssi_avg_b) && (rssi_avg_a >=rssi_avg_c)&&(rssi_avg_a >=rssi_avg_d))
+			pDM_PathDiv->default_path=PATH_A;
+		else if(  (rssi_avg_b >=rssi_avg_c)&&(rssi_avg_b >=rssi_avg_d))
+			pDM_PathDiv->default_path=PATH_B;
+		else if(  rssi_avg_c >=rssi_avg_d)
+			pDM_PathDiv->default_path=PATH_C;
+		else
+			pDM_PathDiv->default_path=PATH_D;
+	}
+
+
+}
+
+
+VOID
+phydm_candidate_dtp_update(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
+
+	pDM_PathDiv->num_candidate=3;
+	
+	if(pDM_PathDiv->use_path_a_as_default_ant == 1)
+	{
+		if(pDM_PathDiv->num_tx_path==3)
+		{
+			if(pDM_PathDiv->is_pathA_exist)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD;
+			}
+			else // use path BCD 
+			{
+				pDM_PathDiv->num_candidate=1;
+				phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BCD);
+				return;
+			}
+		}
+		else 	if(pDM_PathDiv->num_tx_path==2)
+		{
+			if(pDM_PathDiv->is_pathA_exist)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD; 
+			}
+			else
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_BC; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD; 
+			}	
+		}
+	}
+	else
+	{
+		//2 3 TX Mode 
+		if(pDM_PathDiv->num_tx_path==3)//choose 3 ant form 4 
+		{
+			if(pDM_PathDiv->default_path == PATH_A) //choose 2 ant form 3
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD; 
+			}
+			else if(pDM_PathDiv->default_path==PATH_B)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+			}
+			else if(pDM_PathDiv->default_path == PATH_C)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+			}
+			else if(pDM_PathDiv->default_path == PATH_D)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABD; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+			}
+		}
+		
+		//2 2 TX Mode 
+		else if(pDM_PathDiv->num_tx_path==2)//choose 2 ant form 4 
+		{
+			if(pDM_PathDiv->default_path == PATH_A) //choose 2 ant form 3
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD; 
+			}
+			else if(pDM_PathDiv->default_path==PATH_B)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BD; 
+			}
+			else if(pDM_PathDiv->default_path == PATH_C)
+			{
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AC; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC; 
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD; 
+			}
+			else if(pDM_PathDiv->default_path == PATH_D)
+			{
+				pDM_PathDiv->ant_candidate_1=  PHYDM_AD; 
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD; 
+				pDM_PathDiv->ant_candidate_3=  PHYDM_CD; 
+			}
+		}
+	}
+}
+
+
+VOID
+phydm_dynamic_tx_path(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;	
+	
+	PSTA_INFO_T   	pEntry;
+	u4Byte	i;
+	u1Byte	num_client=0;
+	u1Byte	H2C_Parameter[6] ={0};
+
+
+	if(!pDM_Odm->bLinked) //bLinked==False
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("DTP_8814 [No Link!!!]\n"));
+		
+		if(pDM_PathDiv->bBecomeLinked == TRUE)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" [Be disconnected]----->\n"));
+			pDM_PathDiv->bBecomeLinked = pDM_Odm->bLinked;
+		}
+		return;
+	}	
+	else
+	{
+		if(pDM_PathDiv->bBecomeLinked ==FALSE)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" [Be Linked !!!]----->\n"));
+			pDM_PathDiv->bBecomeLinked = pDM_Odm->bLinked;
+		}	
+	}	
+	
+	//2 [Period CTRL]
+	if(pDM_PathDiv->dtp_period >=2)
+	{
+		pDM_PathDiv->dtp_period=0;	
+	}
+	else
+	{	
+		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("Phydm_Dynamic_Tx_Path_8814A()  Stay = (( %d ))\n",pDM_PathDiv->dtp_period));
+		pDM_PathDiv->dtp_period++;		
+		return;
+	}
+	
+
+	//2 [Fix Path]
+	if (pDM_Odm->path_select != PHYDM_AUTO_PATH)
+	{
+		return;
+	}
+	
+	//2 [Check Bfer]	
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#if (BEAMFORMING_SUPPORT == 1)
+	{
+		BEAMFORMING_CAP		BeamformCap = (pDM_Odm->BeamformingInfo.BeamformCap);
+
+		if( BeamformCap & BEAMFORMER_CAP ) //  BFmer On  &&   Div On ->  Div Off
+		{	
+			if( pDM_PathDiv->fix_path_bfer == 0) 
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("[ PathDiv : OFF ]   BFmer ==1  \n"));
+				pDM_PathDiv->fix_path_bfer = 1 ;			
+			}
+			return;
+		}
+		else // BFmer Off   &&   Div Off ->  Div On
+		{
+			if( pDM_PathDiv->fix_path_bfer == 1 ) 
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("[ PathDiv : ON ]   BFmer ==0 \n"));
+				pDM_PathDiv->fix_path_bfer = 0;
+			}
+		}
+	}
+	#endif	
+	#endif
+
+	if(pDM_PathDiv->use_path_a_as_default_ant ==1)
+	{
+		phydm_find_default_path(pDM_Odm);
+		phydm_candidate_dtp_update(pDM_Odm);	
+	}
+	else
+	{
+		if( pDM_PathDiv->dtp_state == PHYDM_DTP_INIT)
+		{
+			phydm_find_default_path(pDM_Odm);
+			phydm_candidate_dtp_update(pDM_Odm);
+			pDM_PathDiv->dtp_state = PHYDM_DTP_RUNNING_1;
+		}
+		
+		else 	if( pDM_PathDiv->dtp_state == PHYDM_DTP_RUNNING_1)
+		{
+			pDM_PathDiv->dtp_check_patha_counter++;
+			
+			if(pDM_PathDiv->dtp_check_patha_counter>=NUM_RESET_DTP_PERIOD)
+			{
+				pDM_PathDiv->dtp_check_patha_counter=0;
+				pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;
+			}
+			//2 Search space update		
+			else
+			{
+				// 1.  find the worst candidate
+				
+
+				// 2. repalce the worst candidate
+			}
+		}
+	}
+
+	//2 Dynamic Path Selection H2C
+
+	if(pDM_PathDiv->num_candidate == 1)
+	{
+		return;
+	}
+	else
+	{	
+		H2C_Parameter[0] =  pDM_PathDiv->num_candidate;
+		H2C_Parameter[1] =  pDM_PathDiv->num_tx_path;	
+		H2C_Parameter[2] =  pDM_PathDiv->ant_candidate_1; 
+		H2C_Parameter[3] =  pDM_PathDiv->ant_candidate_2; 
+		H2C_Parameter[4] =  pDM_PathDiv->ant_candidate_3; 
+
+		ODM_FillH2CCmd(pDM_Odm, PHYDM_H2C_DYNAMIC_TX_PATH, 6, H2C_Parameter);
+	}
+
+}
+
+
+
+VOID
+phydm_dynamic_tx_path_init(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T		pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
+	PADAPTER		pAdapter = pDM_Odm->Adapter;
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	USB_MODE_MECH	*pUsbModeMech = &pAdapter->UsbModeMechanism;
+	#endif
+	u1Byte 			search_space_2[NUM_CHOOSE2_FROM4]= {PHYDM_AB, PHYDM_AC, PHYDM_AD, PHYDM_BC, PHYDM_BD, PHYDM_CD };
+	u1Byte 			search_space_3[NUM_CHOOSE3_FROM4]= {PHYDM_BCD, PHYDM_ACD,  PHYDM_ABD, PHYDM_ABC};
+
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		pDM_PathDiv->is_u3_mode = (pUsbModeMech->CurUsbMode==USB_MODE_U3)? 1 : 0 ;
+	#else
+		pDM_PathDiv->is_u3_mode = 1;
+	#endif
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("Dynamic TX Path Init 8814\n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("is_u3_mode = (( %d ))\n", pDM_PathDiv->is_u3_mode));
+
+	memcpy(&(pDM_PathDiv->search_space_2[0]), &(search_space_2[0]), NUM_CHOOSE2_FROM4);
+	memcpy(&(pDM_PathDiv->search_space_3[0]), &(search_space_3[0]), NUM_CHOOSE3_FROM4);
+
+	pDM_PathDiv->use_path_a_as_default_ant= 1;
+	pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;	
+	pDM_Odm->path_select = PHYDM_AUTO_PATH;
+	pDM_PathDiv->path_div_type = PHYDM_4R_PATH_DIV;
+
+	
+	if(pDM_PathDiv->is_u3_mode )
+	{
+		pDM_PathDiv->num_tx_path=3;
+		phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BCD);/* 3TX  Set Init TX Path*/
+		
+	}
+	else
+	{
+		pDM_PathDiv->num_tx_path=2;
+		phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BC);/* 2TX // Set Init TX Path*/
+	}
+	
+}
+
+
+VOID
+phydm_process_rssi_for_path_div(	
+	IN OUT		PVOID			pDM_VOID,	
+	IN			PVOID			p_phy_info_void,
+	IN			PVOID			p_pkt_info_void
+	)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_PHY_INFO_T 		pPhyInfo=(PODM_PHY_INFO_T)p_phy_info_void;
+	PODM_PACKET_INFO_T	 pPktinfo=(PODM_PACKET_INFO_T)p_pkt_info_void;
+	pPATHDIV_T			pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
+
+	if(pPktinfo->bPacketToSelf || pPktinfo->bPacketMatchBSSID)
+	{
+		if(pPktinfo->DataRate > ODM_RATE11M)
+		{
+			if(pDM_PathDiv->path_div_type == PHYDM_4R_PATH_DIV)
+			{
+				#if RTL8814A_SUPPORT
+				if(pDM_Odm->SupportICType & ODM_RTL8814A)
+				{
+					pDM_PathDiv->path_a_sum_all+=pPhyInfo->RxMIMOSignalStrength[0];
+					pDM_PathDiv->path_a_cnt_all++;
+					
+					pDM_PathDiv->path_b_sum_all+=pPhyInfo->RxMIMOSignalStrength[1];
+					pDM_PathDiv->path_b_cnt_all++;
+					
+					pDM_PathDiv->path_c_sum_all+=pPhyInfo->RxMIMOSignalStrength[2];
+					pDM_PathDiv->path_c_cnt_all++;
+					
+					pDM_PathDiv->path_d_sum_all+=pPhyInfo->RxMIMOSignalStrength[3];
+					pDM_PathDiv->path_d_cnt_all++;
+				}
+				#endif
+			}
+			else
+			{
+				pDM_PathDiv->PathA_Sum[pPktinfo->StationID]+=pPhyInfo->RxMIMOSignalStrength[0];
+				pDM_PathDiv->PathA_Cnt[pPktinfo->StationID]++;
+
+				pDM_PathDiv->PathB_Sum[pPktinfo->StationID]+=pPhyInfo->RxMIMOSignalStrength[1];
+				pDM_PathDiv->PathB_Cnt[pPktinfo->StationID]++;
+			}
+		}
+	}
+	
+	
+}
+
+#endif //#if RTL8814A_SUPPORT
+
+VOID
+odm_pathdiv_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte		*_used,
+	OUT		char			*output,
+	IN		u4Byte		*_out_len
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T			pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
+	u4Byte used = *_used;
+	u4Byte out_len = *_out_len;
+	
+	pDM_Odm->path_select = (dm_value[0] & 0xf);
+	PHYDM_SNPRINTF((output+used, out_len-used,"Path_select = (( 0x%x ))\n",pDM_Odm->path_select ));
+	
+	//2 [Fix Path]
+	if (pDM_Odm->path_select != PHYDM_AUTO_PATH)
+	{
+		PHYDM_SNPRINTF((output+used, out_len-used,"Trun on path  [%s%s%s%s]\n",
+			((pDM_Odm->path_select) & 0x1)?"A":"",
+			((pDM_Odm->path_select) & 0x2)?"B":"",
+			((pDM_Odm->path_select) & 0x4)?"C":"",
+			((pDM_Odm->path_select) & 0x8)?"D":"" ));
+		
+		phydm_dtp_fix_tx_path( pDM_Odm, pDM_Odm->path_select );
+	}
+	else
+	{
+		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n","Auto Path"));
+	}
+}
+
+#endif // #if(defined(CONFIG_PATH_DIVERSITY))
+
+VOID
+phydm_c2h_dtp_handler(
+ IN	PVOID	pDM_VOID,
+ IN 	pu1Byte   CmdBuf,
+ IN 	u1Byte	CmdLen
+)
+{
+#if(defined(CONFIG_PATH_DIVERSITY))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPATHDIV_T		pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
+
+	u1Byte  macid = CmdBuf[0]; 
+	u1Byte  target = CmdBuf[1];	
+	u1Byte  nsc_1 = CmdBuf[2];
+	u1Byte  nsc_2 = CmdBuf[3];
+	u1Byte  nsc_3 = CmdBuf[4];
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Target_candidate = (( %d ))\n", target));
+	/*
+	if( (nsc_1 >= nsc_2) &&  (nsc_1 >= nsc_3))
+	{
+		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_1);
+	}
+	else 	if( nsc_2 >= nsc_3)
+	{
+		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_2);
+	}
+	else
+	{
+		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_3);	
+	}
+	*/
+#endif	
+}
+
+VOID
+odm_PathDiversity(
+	IN	PVOID	pDM_VOID
+)
+{
+#if(defined(CONFIG_PATH_DIVERSITY))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Return: Not Support PathDiv\n"));
+		return;
+	}
+
+	#if RTL8812A_SUPPORT
+
+	if(pDM_Odm->SupportICType & ODM_RTL8812)
+			ODM_PathDiversity_8812A(pDM_Odm);
+		else
+	#endif
+
+	#if RTL8814A_SUPPORT
+		if(pDM_Odm->SupportICType & ODM_RTL8814A)
+			phydm_dynamic_tx_path(pDM_Odm);
+		else
+	#endif
+    		{}
+#endif
+}
+
+VOID
+odm_PathDiversityInit(
+	IN	PVOID	pDM_VOID
+)
+{
+#if(defined(CONFIG_PATH_DIVERSITY))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	/*pDM_Odm->SupportAbility |= ODM_BB_PATH_DIV;*/
+	
+	if(pDM_Odm->mp_mode == TRUE)
+		return;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Return: Not Support PathDiv\n"));
+		return;
+	}
+
+#if RTL8812A_SUPPORT
+		if(pDM_Odm->SupportICType & ODM_RTL8812)
+			ODM_PathDiversityInit_8812A(pDM_Odm);
+		else
+	#endif
+
+	#if RTL8814A_SUPPORT
+		if(pDM_Odm->SupportICType & ODM_RTL8814A)
+			phydm_dynamic_tx_path_init(pDM_Odm);
+		else
+	#endif	
+		{}
+#endif
+}
+
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+//
+// 2011/12/02 MH Copy from MP oursrc for temporarily test.
+//
+#if RTL8192C_SUPPORT
+BOOLEAN
+odm_IsConnected_92C(
+	IN	PADAPTER	Adapter
+)
+{
+	PRT_WLAN_STA	pEntry;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	u4Byte		i;
+	BOOLEAN		bConnected=FALSE;
+	
+	if(pMgntInfo->mAssoc)
+	{
+		bConnected = TRUE;
+	}
+	else
+	{
+		for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+				pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+			else
+				pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+			if(pEntry!=NULL)
+			{
+				if(pEntry->bAssociated)
+				{
+					bConnected = TRUE;
+					break;
+				}
+			}
+			else
+			{
+				break;
+			}
+		}
+	}
+	return	bConnected;
+}
+
+BOOLEAN
+ODM_PathDiversityBeforeLink92C(
+	//IN	PADAPTER	Adapter
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE*	pHalData = NULL;
+	PMGNT_INFO		pMgntInfo = NULL;
+	//pSWAT_T		pDM_SWAT_Table = &Adapter->DM_SWAT_Table;
+	pPD_T			pDM_PDTable = NULL;
+
+	s1Byte			Score = 0;
+	PRT_WLAN_BSS	pTmpBssDesc;
+	PRT_WLAN_BSS	pTestBssDesc;
+
+	u1Byte			target_chnl = 0;
+	u2Byte			index;
+
+	if (pDM_Odm->Adapter == NULL)  //For BSOD when plug/unplug fast.  //By YJ,120413
+	{	// The ODM structure is not initialized.
+		return FALSE;
+	}
+	pHalData = GET_HAL_DATA(Adapter);
+	pMgntInfo = &Adapter->MgntInfo;
+	pDM_PDTable = &Adapter->DM_PDTable;
+	
+	// Condition that does not need to use path diversity.
+	if((!(pHalData->CVID_Version==VERSION_1_BEFORE_8703B && IS_92C_SERIAL(pHalData->VersionID))) || (pHalData->PathDivCfg!=1) || pMgntInfo->AntennaTest )
+	{
+		RT_TRACE(COMP_INIT, DBG_LOUD, 
+				("ODM_PathDiversityBeforeLink92C(): No PathDiv Mechanism before link.\n"));
+		return FALSE;
+	}
+
+	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
+	PlatformAcquireSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	
+		RT_TRACE(COMP_INIT, DBG_LOUD, 
+				("ODM_PathDiversityBeforeLink92C(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
+				pMgntInfo->RFChangeInProgress,
+				pHalData->eRFPowerState));
+	
+		//pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		pDM_PDTable->PathDiv_NoLink_State = 0;
+		
+		return FALSE;
+	}
+	else
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	}
+
+	//1 Run AntDiv mechanism "Before Link" part.
+	//if(pDM_SWAT_Table->SWAS_NoLink_State == 0)
+	if(pDM_PDTable->PathDiv_NoLink_State == 0)
+	{
+		//1 Prepare to do Scan again to check current antenna state.
+
+		// Set check state to next step.
+		//pDM_SWAT_Table->SWAS_NoLink_State = 1;
+		pDM_PDTable->PathDiv_NoLink_State = 1;
+	
+		// Copy Current Scan list.
+		Adapter->MgntInfo.tmpNumBssDesc = pMgntInfo->NumBssDesc;
+		PlatformMoveMemory((PVOID)Adapter->MgntInfo.tmpbssDesc, (PVOID)pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC);
+
+		// Switch Antenna to another one.
+		if(pDM_PDTable->DefaultRespPath == 0)
+		{
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x05); // TRX path = PathB
+			odm_SetRespPath_92C(Adapter, 1);
+			pDM_PDTable->OFDMTXPath = 0xFFFFFFFF;
+			pDM_PDTable->CCKTXPath = 0xFFFFFFFF;
+		}
+		else
+		{
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x00); // TRX path = PathA
+			odm_SetRespPath_92C(Adapter, 0);
+			pDM_PDTable->OFDMTXPath = 0x0;
+			pDM_PDTable->CCKTXPath = 0x0;
+		}
+#if 0	
+
+		pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+		pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==Antenna_A)?Antenna_B:Antenna_A;
+		
+		RT_TRACE(COMP_INIT, DBG_LOUD, 
+			("ODM_SwAntDivCheckBeforeLink: Change to Ant(%s) for testing.\n", (pDM_SWAT_Table->CurAntenna==Antenna_A)?"A":"B"));
+		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
+		pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+		PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+#endif
+
+		// Go back to scan function again.
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Scan one more time\n"));
+		pMgntInfo->ScanStep=0;
+		target_chnl = odm_SwAntDivSelectScanChnl(Adapter);
+		odm_SwAntDivConstructScanChnl(Adapter, target_chnl);
+		PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+
+		return TRUE;
+	}
+	else
+	{
+		//1 ScanComple() is called after antenna swiched.
+		//1 Check scan result and determine which antenna is going
+		//1 to be used.
+
+		for(index=0; index<Adapter->MgntInfo.tmpNumBssDesc; index++)
+		{
+			pTmpBssDesc = &(Adapter->MgntInfo.tmpbssDesc[index]);
+			pTestBssDesc = &(pMgntInfo->bssDesc[index]);
+
+			if(PlatformCompareMemory(pTestBssDesc->bdBssIdBuf, pTmpBssDesc->bdBssIdBuf, 6)!=0)
+			{
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C(): ERROR!! This shall not happen.\n"));
+				continue;
+			}
+
+			if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
+			{
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Compare scan entry: Score++\n"));
+				RT_PRINT_STR(COMP_INIT, DBG_LOUD, "SSID: ", pTestBssDesc->bdSsIdBuf, pTestBssDesc->bdSsIdLen);
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+			
+				Score++;
+				PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
+			}
+			else if(pTmpBssDesc->RecvSignalPower < pTestBssDesc->RecvSignalPower)
+			{
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Compare scan entry: Score--\n"));
+				RT_PRINT_STR(COMP_INIT, DBG_LOUD, "SSID: ", pTestBssDesc->bdSsIdBuf, pTestBssDesc->bdSsIdLen);
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+				Score--;
+			}
+
+		}
+
+		if(pMgntInfo->NumBssDesc!=0 && Score<=0)
+		{
+			RT_TRACE(COMP_INIT, DBG_LOUD,
+				("ODM_PathDiversityBeforeLink92C(): DefaultRespPath=%d\n", pDM_PDTable->DefaultRespPath));
+
+			//pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+		}
+		else
+		{
+			RT_TRACE(COMP_INIT, DBG_LOUD, 
+				("ODM_PathDiversityBeforeLink92C(): DefaultRespPath=%d\n", pDM_PDTable->DefaultRespPath));
+
+			if(pDM_PDTable->DefaultRespPath == 0)
+			{
+				pDM_PDTable->OFDMTXPath = 0xFFFFFFFF;
+				pDM_PDTable->CCKTXPath = 0xFFFFFFFF;
+				odm_SetRespPath_92C(Adapter, 1);
+			}
+			else
+			{
+				pDM_PDTable->OFDMTXPath = 0x0;
+				pDM_PDTable->CCKTXPath = 0x0;
+				odm_SetRespPath_92C(Adapter, 0);
+			}
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x01); // RX path = PathAB
+
+			//pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
+
+			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
+			//pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+		}
+
+		// Check state reset to default and wait for next time.
+		//pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		pDM_PDTable->PathDiv_NoLink_State = 0;
+
+		return FALSE;
+	}
+#else
+		return	FALSE;
+#endif
+	
+}
+
+
+
+VOID
+odm_PathDiversityAfterLink_92C(
+	IN	PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pPD_T		pDM_PDTable = &Adapter->DM_PDTable;
+	u1Byte		DefaultRespPath=0;
+
+	if((!(pHalData->CVID_Version==VERSION_1_BEFORE_8703B && IS_92C_SERIAL(pHalData->VersionID))) || (pHalData->PathDivCfg != 1) || (pHalData->eRFPowerState == eRfOff))
+	{
+		if(pHalData->PathDivCfg == 0)
+		{
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("No ODM_TXPathDiversity()\n"));
+		}
+		else
+		{
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("2T ODM_TXPathDiversity()\n"));
+		}
+		return;
+	}
+	if(!odm_IsConnected_92C(Adapter))
+	{
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity(): No Connections\n"));
+		return;
+	}
+	
+	
+	if(pDM_PDTable->TrainingState == 0)
+	{
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity() ==>\n"));
+		odm_OFDMTXPathDiversity_92C(Adapter);
+
+		if((pDM_PDTable->CCKPathDivEnable == TRUE) && (pDM_PDTable->OFDM_Pkt_Cnt < 100))
+		{
+			//RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=0\n"));
+			
+			if(pDM_PDTable->CCK_Pkt_Cnt > 300)
+				pDM_PDTable->Timer = 20;
+			else if(pDM_PDTable->CCK_Pkt_Cnt > 100)
+				pDM_PDTable->Timer = 60;
+			else
+				pDM_PDTable->Timer = 250;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: timer=%d\n",pDM_PDTable->Timer));
+
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x00); // RX path = PathA
+			pDM_PDTable->TrainingState = 1;
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, pDM_PDTable->Timer); //ms
+		}
+		else
+		{
+			pDM_PDTable->CCKTXPath = pDM_PDTable->OFDMTXPath;
+			DefaultRespPath = pDM_PDTable->OFDMDefaultRespPath;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: Skip odm_CCKTXPathDiversity_92C, DefaultRespPath is OFDM\n"));
+			odm_SetRespPath_92C(Adapter, DefaultRespPath);
+			odm_ResetPathDiversity_92C(Adapter);
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity() <==\n"));
+		}
+	}
+	else if(pDM_PDTable->TrainingState == 1)
+	{		
+		//RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=1\n"));
+		PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x05); // RX path = PathB
+		pDM_PDTable->TrainingState = 2;
+		ODM_SetTimer( pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, pDM_PDTable->Timer); //ms
+	}
+	else
+	{
+		//RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=2\n"));
+		pDM_PDTable->TrainingState = 0;	
+		odm_CCKTXPathDiversity_92C(Adapter); 
+		if(pDM_PDTable->OFDM_Pkt_Cnt != 0)
+		{
+			DefaultRespPath = pDM_PDTable->OFDMDefaultRespPath;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: DefaultRespPath is OFDM\n"));
+		}
+		else
+		{
+			DefaultRespPath = pDM_PDTable->CCKDefaultRespPath;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: DefaultRespPath is CCK\n"));
+		}
+		odm_SetRespPath_92C(Adapter, DefaultRespPath);
+		odm_ResetPathDiversity_92C(Adapter);
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity() <==\n"));
+	}
+
+}
+
+VOID
+odm_SetRespPath_92C(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte	DefaultRespPath
+	)
+{
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+
+	RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: Select Response Path=%d\n",DefaultRespPath));
+	if(DefaultRespPath != pDM_PDTable->DefaultRespPath)
+	{
+		if(DefaultRespPath == 0)
+		{
+			PlatformEFIOWrite1Byte(Adapter, 0x6D8, (PlatformEFIORead1Byte(Adapter, 0x6D8)&0xc0)|0x15);	
+		}
+		else
+		{
+			PlatformEFIOWrite1Byte(Adapter, 0x6D8, (PlatformEFIORead1Byte(Adapter, 0x6D8)&0xc0)|0x2A);
+		}	
+	}
+	pDM_PDTable->DefaultRespPath = DefaultRespPath;
+}
+
+VOID
+odm_OFDMTXPathDiversity_92C(
+	IN	PADAPTER	Adapter)
+{
+//	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	PRT_WLAN_STA	pEntry;
+	u1Byte	i, DefaultRespPath = 0;
+	s4Byte	MinRSSI = 0xFF;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+	pDM_PDTable->OFDMTXPath = 0;
+	
+	//1 Default Port
+	if(pMgntInfo->mAssoc)
+	{
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port RSSI[0]=%d, RSSI[1]=%d\n",
+			Adapter->RxStats.RxRSSIPercentage[0], Adapter->RxStats.RxRSSIPercentage[1]));
+		if(Adapter->RxStats.RxRSSIPercentage[0] > Adapter->RxStats.RxRSSIPercentage[1])
+		{
+			pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath & (~BIT0);
+			MinRSSI =  Adapter->RxStats.RxRSSIPercentage[1];
+			DefaultRespPath = 0;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port Select Path-0\n"));
+		}
+		else
+		{
+			pDM_PDTable->OFDMTXPath =  pDM_PDTable->OFDMTXPath | BIT0;
+			MinRSSI =  Adapter->RxStats.RxRSSIPercentage[0];
+			DefaultRespPath = 1;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port Select Path-1\n"));
+		}
+			//RT_TRACE(	COMP_INIT, DBG_LOUD, ("pDM_PDTable->OFDMTXPath =0x%x\n",pDM_PDTable->OFDMTXPath));
+	}
+	//1 Extension Port
+	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+		else
+			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+		if(pEntry!=NULL)
+		{
+			if(pEntry->bAssociated)
+			{
+				RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d, RSSI_0=%d, RSSI_1=%d\n", 
+					pEntry->AssociatedMacId, pEntry->rssi_stat.RxRSSIPercentage[0], pEntry->rssi_stat.RxRSSIPercentage[1]));
+				
+				if(pEntry->rssi_stat.RxRSSIPercentage[0] > pEntry->rssi_stat.RxRSSIPercentage[1])
+				{
+					pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath & ~(BIT(pEntry->AssociatedMacId));
+					//pHalData->TXPath = pHalData->TXPath & ~(1<<(pEntry->AssociatedMacId));
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d Select Path-0\n", pEntry->AssociatedMacId));
+					if(pEntry->rssi_stat.RxRSSIPercentage[1] < MinRSSI)
+					{
+						MinRSSI = pEntry->rssi_stat.RxRSSIPercentage[1];
+						DefaultRespPath = 0;
+					}
+				}
+				else
+				{
+					pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath | BIT(pEntry->AssociatedMacId);
+					//pHalData->TXPath = pHalData->TXPath | (1 << (pEntry->AssociatedMacId));
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d Select Path-1\n", pEntry->AssociatedMacId));
+					if(pEntry->rssi_stat.RxRSSIPercentage[0] < MinRSSI)
+					{
+						MinRSSI = pEntry->rssi_stat.RxRSSIPercentage[0];
+						DefaultRespPath = 1;
+					}
+				}
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	pDM_PDTable->OFDMDefaultRespPath = DefaultRespPath;
+}
+
+
+VOID
+odm_CCKTXPathDiversity_92C(
+	IN	PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	PRT_WLAN_STA	pEntry;
+	s4Byte	MinRSSI = 0xFF;
+	u1Byte	i, DefaultRespPath = 0;
+//	BOOLEAN	bBModePathDiv = FALSE;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+
+	//1 Default Port
+	if(pMgntInfo->mAssoc)
+	{
+		if(pHalData->OFDM_Pkt_Cnt == 0)
+		{
+			for(i=0; i<2; i++)
+			{
+				if(pDM_PDTable->RSSI_CCK_Path_cnt[i] > 1) //Because the first packet is discarded
+					pDM_PDTable->RSSI_CCK_Path[i] = pDM_PDTable->RSSI_CCK_Path[i] / (pDM_PDTable->RSSI_CCK_Path_cnt[i]-1);
+				else
+					pDM_PDTable->RSSI_CCK_Path[i] = 0;
+			}
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: pDM_PDTable->RSSI_CCK_Path[0]=%d, pDM_PDTable->RSSI_CCK_Path[1]=%d\n",
+				pDM_PDTable->RSSI_CCK_Path[0], pDM_PDTable->RSSI_CCK_Path[1]));
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: pDM_PDTable->RSSI_CCK_Path_cnt[0]=%d, pDM_PDTable->RSSI_CCK_Path_cnt[1]=%d\n",
+				pDM_PDTable->RSSI_CCK_Path_cnt[0], pDM_PDTable->RSSI_CCK_Path_cnt[1]));
+		
+			if(pDM_PDTable->RSSI_CCK_Path[0] > pDM_PDTable->RSSI_CCK_Path[1])
+			{
+				pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & (~BIT0);
+				MinRSSI =  pDM_PDTable->RSSI_CCK_Path[1];
+				DefaultRespPath = 0;
+				RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-0\n"));
+			}
+			else if(pDM_PDTable->RSSI_CCK_Path[0] < pDM_PDTable->RSSI_CCK_Path[1])
+			{
+				pDM_PDTable->CCKTXPath =  pDM_PDTable->CCKTXPath | BIT0;
+				MinRSSI =  pDM_PDTable->RSSI_CCK_Path[0];
+				DefaultRespPath = 1;
+				RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-1\n"));
+			}
+			else
+			{
+				if((pDM_PDTable->RSSI_CCK_Path[0] != 0) && (pDM_PDTable->RSSI_CCK_Path[0] < MinRSSI))
+				{
+					pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & (~BIT0);
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-0\n"));
+					MinRSSI =  pDM_PDTable->RSSI_CCK_Path[1];
+					DefaultRespPath = 0;
+				}
+				else
+				{
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port unchange CCK Path\n"));
+				}
+			}
+		}
+		else //Follow OFDM decision
+		{
+			pDM_PDTable->CCKTXPath = (pDM_PDTable->CCKTXPath & (~BIT0)) | (pDM_PDTable->OFDMTXPath &BIT0);
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Follow OFDM decision, Default port Select CCK Path-%d\n",
+				pDM_PDTable->CCKTXPath &BIT0));
+		}
+	}
+	//1 Extension Port
+	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+		else
+			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+		if(pEntry!=NULL)
+		{
+			if(pEntry->bAssociated)
+			{
+				if(pEntry->rssi_stat.OFDM_Pkt_Cnt == 0)
+				{
+					u1Byte j=0;
+					for(j=0; j<2; j++)
+					{
+						if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[j] > 1)
+							pEntry->rssi_stat.RSSI_CCK_Path[j] = pEntry->rssi_stat.RSSI_CCK_Path[j] / (pEntry->rssi_stat.RSSI_CCK_Path_cnt[j]-1);
+						else
+							pEntry->rssi_stat.RSSI_CCK_Path[j] = 0;
+					}
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d, RSSI_CCK0=%d, RSSI_CCK1=%d\n", 
+						pEntry->AssociatedMacId, pEntry->rssi_stat.RSSI_CCK_Path[0], pEntry->rssi_stat.RSSI_CCK_Path[1]));
+					
+					if(pEntry->rssi_stat.RSSI_CCK_Path[0] >pEntry->rssi_stat.RSSI_CCK_Path[1])
+					{
+						pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & ~(BIT(pEntry->AssociatedMacId));
+						RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-0\n", pEntry->AssociatedMacId));
+						if(pEntry->rssi_stat.RSSI_CCK_Path[1] < MinRSSI)
+						{
+							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[1];
+							DefaultRespPath = 0;
+						}
+					}
+					else if(pEntry->rssi_stat.RSSI_CCK_Path[0] <pEntry->rssi_stat.RSSI_CCK_Path[1])
+					{
+						pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath | BIT(pEntry->AssociatedMacId);
+						RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-1\n", pEntry->AssociatedMacId));
+						if(pEntry->rssi_stat.RSSI_CCK_Path[0] < MinRSSI)
+						{
+							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[0];
+							DefaultRespPath = 1;
+						}
+					}
+					else
+					{
+						if((pEntry->rssi_stat.RSSI_CCK_Path[0] != 0) && (pEntry->rssi_stat.RSSI_CCK_Path[0] < MinRSSI))
+						{
+							pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & ~(BIT(pEntry->AssociatedMacId));
+							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[1];
+							DefaultRespPath = 0;
+							RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-0\n", pEntry->AssociatedMacId));
+						}
+						else
+						{
+							RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d unchange CCK Path\n", pEntry->AssociatedMacId));
+						}
+					}
+				}
+				else //Follow OFDM decision
+				{
+					pDM_PDTable->CCKTXPath = (pDM_PDTable->CCKTXPath & (~(BIT(pEntry->AssociatedMacId)))) | (pDM_PDTable->OFDMTXPath & BIT(pEntry->AssociatedMacId));
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Follow OFDM decision, MACID=%d Select CCK Path-%d\n",
+						pEntry->AssociatedMacId, (pDM_PDTable->CCKTXPath & BIT(pEntry->AssociatedMacId))>>(pEntry->AssociatedMacId)));
+				}
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C:MinRSSI=%d\n",MinRSSI));
+
+	if(MinRSSI == 0xFF)
+		DefaultRespPath = pDM_PDTable->CCKDefaultRespPath;
+
+	pDM_PDTable->CCKDefaultRespPath = DefaultRespPath;
+}
+
+
+VOID
+odm_ResetPathDiversity_92C(
+		IN	PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+	PRT_WLAN_STA	pEntry;
+	u4Byte	i,j;
+
+	pDM_PDTable->CCK_Pkt_Cnt = 0;
+	pDM_PDTable->OFDM_Pkt_Cnt = 0;
+	pHalData->CCK_Pkt_Cnt =0;
+	pHalData->OFDM_Pkt_Cnt =0;
+	
+	if(pDM_PDTable->CCKPathDivEnable == TRUE)	
+		PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x01); //RX path = PathAB
+
+	for(i=0; i<2; i++)
+	{
+		pDM_PDTable->RSSI_CCK_Path_cnt[i]=0;
+		pDM_PDTable->RSSI_CCK_Path[i] = 0;
+	}
+	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+		else
+			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+		if(pEntry!=NULL)
+		{
+			pEntry->rssi_stat.CCK_Pkt_Cnt = 0;
+			pEntry->rssi_stat.OFDM_Pkt_Cnt = 0;
+			for(j=0; j<2; j++)
+			{
+				pEntry->rssi_stat.RSSI_CCK_Path_cnt[j] = 0;
+				pEntry->rssi_stat.RSSI_CCK_Path[j] = 0;
+			}
+		}
+		else
+			break;
+	}
+}
+
+
+
+
+
+VOID
+odm_CCKTXPathDiversityCallback(
+	PRT_TIMER		pTimer
+)
+{
+#if USE_WORKITEM
+       PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
+       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	   PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
+#endif
+
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+#if USE_WORKITEM
+	PlatformScheduleWorkItem(&pDM_Odm->CCKPathDiversityWorkitem);
+#else
+	odm_PathDiversityAfterLink_92C(Adapter);
+#endif
+#else
+	PlatformScheduleWorkItem(&pDM_Odm->CCKPathDiversityWorkitem);
+#endif
+
+}
+
+
+VOID
+odm_CCKTXPathDiversityWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+
+	odm_CCKTXPathDiversity_92C(Adapter);
+}
+
+//
+// 20100514 Luke/Joseph:
+// Callback function for 500ms antenna test trying.
+//
+VOID
+odm_PathDivChkAntSwitchCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+
+#if USE_WORKITEM
+	PlatformScheduleWorkItem(&pDM_Odm->PathDivSwitchWorkitem);
+#else
+	odm_PathDivChkAntSwitch(pDM_Odm);
+#endif
+#else
+	PlatformScheduleWorkItem(&pDM_Odm->PathDivSwitchWorkitem);
+#endif
+
+//odm_SwAntDivChkAntSwitch(Adapter, SWAW_STEP_DETERMINE);
+
+}
+
+
+VOID
+odm_PathDivChkAntSwitchWorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	odm_PathDivChkAntSwitch(pDM_Odm);
+}
+
+
+ //MAC0_ACCESS_PHY1
+
+// 2011-06-22 Neil Chen & Gary Hsin
+// Refer to Jr.Luke's SW ANT DIV
+// 92D Path Diversity Main function
+// refer to 88C software antenna diversity
+// 
+VOID
+odm_PathDivChkAntSwitch(
+	PDM_ODM_T		pDM_Odm
+	//PADAPTER		Adapter,
+	//u1Byte			Step
+)
+{
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+
+
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	s4Byte			curRSSI=100, RSSI_A, RSSI_B;
+	u1Byte			nextAntenna=AUX_ANT;
+	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	u8Byte			curTxOkCnt, curRxOkCnt;
+	static u8Byte		TXByteCnt_A=0, TXByteCnt_B=0, RXByteCnt_A=0, RXByteCnt_B=0;
+	u8Byte			CurByteCnt=0, PreByteCnt=0;
+	static u1Byte		TrafficLoad = TRAFFIC_LOW;
+	u1Byte			Score_A=0, Score_B=0;
+	u1Byte			i=0x0;
+       // Neil Chen
+       static u1Byte        pathdiv_para=0x0;     
+       static u1Byte        switchfirsttime=0x00;
+	// u1Byte                 regB33 = (u1Byte) PHY_QueryBBReg(Adapter, 0xB30,BIT27);
+	u1Byte			regB33 = (u1Byte)ODM_GetBBReg(pDM_Odm, PATHDIV_REG, BIT27);
+
+
+       //u1Byte                 reg637 =0x0;   
+       static u1Byte        fw_value=0x0;         
+	//u8Byte			curTxOkCnt_tmp, curRxOkCnt_tmp;
+       PADAPTER            BuddyAdapter = Adapter->BuddyAdapter;     // another adapter MAC
+        // Path Diversity   //Neil Chen--2011--06--22
+
+	//u1Byte                 PathDiv_Trigger = (u1Byte) PHY_QueryBBReg(Adapter, 0xBA0,BIT31);
+	u1Byte                 PathDiv_Trigger = (u1Byte) ODM_GetBBReg(pDM_Odm, PATHDIV_TRI,BIT31);
+	u1Byte                 PathDiv_Enable = pHalData->bPathDiv_Enable;
+
+
+	//DbgPrint("Path Div PG Value:%x \n",PathDiv_Enable);	
+       if((BuddyAdapter==NULL)||(!PathDiv_Enable)||(PathDiv_Trigger)||(pHalData->CurrentBandType == BAND_ON_2_4G))
+       {
+           return;
+       }
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD,("===================>odm_PathDivChkAntSwitch()\n"));
+
+       // The first time to switch path excluding 2nd, 3rd, ....etc....
+	if(switchfirsttime==0)
+	{
+	    if(regB33==0)
+	    {
+	       pDM_SWAT_Table->CurAntenna = MAIN_ANT;    // Default MAC0_5G-->Path A (current antenna)     
+	    }	    
+	}
+
+	// Condition that does not need to use antenna diversity.
+	if(pDM_Odm->SupportICType != ODM_RTL8192D)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_PathDiversityMechanims(): No PathDiv Mechanism.\n"));
+		return;
+	}
+
+	// Radio off: Status reset to default and return.
+	if(pHalData->eRFPowerState==eRfOff)
+	{
+		//ODM_SwAntDivRestAfterLink(Adapter);
+		return;
+	}
+
+       /*
+	// Handling step mismatch condition.
+	// Peak step is not finished at last time. Recover the variable and check again.
+	if(	Step != pDM_SWAT_Table->try_flag	)
+	{
+		ODM_SwAntDivRestAfterLink(Adapter);
+	} */
+	
+	if(pDM_SWAT_Table->try_flag == 0xff)
+	{
+		// Select RSSI checking target
+		if(pMgntInfo->mAssoc && !ACTING_AS_AP(Adapter))
+		{
+			// Target: Infrastructure mode AP.
+			pHalData->RSSI_target = NULL;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_PathDivMechanism(): RSSI_target is DEF AP!\n"));
+		}
+		else
+		{
+			u1Byte			index = 0;
+			PRT_WLAN_STA	pEntry = NULL;
+			PADAPTER		pTargetAdapter = NULL;
+		
+			if(	pMgntInfo->mIbss || ACTING_AS_AP(Adapter) )
+			{
+				// Target: AP/IBSS peer.
+				pTargetAdapter = Adapter;
+			}
+			else if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			{
+				// Target: VWIFI peer.
+				pTargetAdapter = GetFirstExtAdapter(Adapter);
+			}
+
+			if(pTargetAdapter != NULL)
+			{
+				for(index=0; index<ODM_ASSOCIATE_ENTRY_NUM; index++)
+				{
+					pEntry = AsocEntry_EnumStation(pTargetAdapter, index);
+					if(pEntry != NULL)
+					{
+						if(pEntry->bAssociated)
+							break;			
+					}
+				}
+			}
+
+			if(pEntry == NULL)
+			{
+				ODM_PathDivRestAfterLink(pDM_Odm);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): No Link.\n"));
+				return;
+			}
+			else
+			{
+				pHalData->RSSI_target = pEntry;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): RSSI_target is PEER STA\n"));
+			}
+		}
+			
+		pHalData->RSSI_cnt_A = 0;
+		pHalData->RSSI_cnt_B = 0;
+		pDM_SWAT_Table->try_flag = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): Set try_flag to 0 prepare for peak!\n"));
+		return;
+	}
+	else
+	{
+	       // 1st step
+		curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - lastTxOkCnt;
+		curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - lastRxOkCnt;
+		lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
+		lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+	
+		if(pDM_SWAT_Table->try_flag == 1)   // Training State
+		{
+			if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+			{
+				TXByteCnt_A += curTxOkCnt;
+				RXByteCnt_A += curRxOkCnt;
+			}
+			else
+			{
+				TXByteCnt_B += curTxOkCnt;
+				RXByteCnt_B += curRxOkCnt;
+			}
+		
+			nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
+			pDM_SWAT_Table->RSSI_Trying--;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_Trying = %d\n",pDM_SWAT_Table->RSSI_Trying));
+			if(pDM_SWAT_Table->RSSI_Trying == 0)
+			{
+				CurByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (TXByteCnt_A+RXByteCnt_A) : (TXByteCnt_B+RXByteCnt_B);
+				PreByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (TXByteCnt_B+RXByteCnt_B) : (TXByteCnt_A+RXByteCnt_A);
+				
+				if(TrafficLoad == TRAFFIC_HIGH)
+				{
+					//CurByteCnt = PlatformDivision64(CurByteCnt, 9);
+					PreByteCnt =PreByteCnt*9;
+				}
+				else if(TrafficLoad == TRAFFIC_LOW)
+				{
+					//CurByteCnt = PlatformDivision64(CurByteCnt, 2);
+					PreByteCnt =PreByteCnt*2;
+				}
+				if(pHalData->RSSI_cnt_A > 0)
+					RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
+				else
+					RSSI_A = 0;
+				if(pHalData->RSSI_cnt_B > 0)
+					RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
+		             else
+					RSSI_B = 0;
+				curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
+				pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_B : RSSI_A;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: PreRSSI = %d, CurRSSI = %d\n",pDM_SWAT_Table->PreRSSI, curRSSI));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: preAntenna= %s, curAntenna= %s \n", 
+				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
+					RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B));
+			}
+
+		}
+		else   // try_flag=0
+		{
+		
+			if(pHalData->RSSI_cnt_A > 0)
+				RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
+			else
+				RSSI_A = 0;
+			if(pHalData->RSSI_cnt_B > 0)
+				RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
+			else
+				RSSI_B = 0;	
+			curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
+			pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->PreAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: PreRSSI = %d, CurRSSI = %d\n", pDM_SWAT_Table->PreRSSI, curRSSI));
+		       ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: preAntenna= %s, curAntenna= %s \n", 
+			(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
+				RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B));
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Ekul:curTxOkCnt = %d\n", curTxOkCnt));
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Ekul:curRxOkCnt = %d\n", curRxOkCnt));
+		}
+
+		//1 Trying State
+		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0))
+		{
+
+			if(pDM_SWAT_Table->TestMode == TP_MODE)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: TestMode = TP_MODE"));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH= TRY:CurByteCnt = %"i64fmt"d,", CurByteCnt));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH= TRY:PreByteCnt = %"i64fmt"d\n",PreByteCnt));		
+				if(CurByteCnt < PreByteCnt)
+				{
+					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
+					else
+						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
+				}
+				else
+				{
+					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
+					else
+						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
+				}
+				for (i= 0; i<8; i++)
+				{
+					if(((pDM_SWAT_Table->SelectAntennaMap>>i)&BIT0) == 1)
+						Score_A++;
+					else
+						Score_B++;
+				}
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("SelectAntennaMap=%x\n ",pDM_SWAT_Table->SelectAntennaMap));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Score_A=%d, Score_B=%d\n", Score_A, Score_B));
+			
+				if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+				{
+					nextAntenna = (Score_A >= Score_B)?MAIN_ANT:AUX_ANT;
+				}
+				else
+				{
+					nextAntenna = (Score_B >= Score_A)?AUX_ANT:MAIN_ANT;
+				}
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: nextAntenna=%s\n",(nextAntenna==MAIN_ANT)?"MAIN":"AUX"));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: preAntenna= %s, curAntenna= %s \n", 
+				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
+
+				if(nextAntenna != pDM_SWAT_Table->CurAntenna)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Switch back to another antenna"));
+				}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: current anntena is good\n"));
+				}	
+			}
+
+                    
+			if(pDM_SWAT_Table->TestMode == RSSI_MODE)
+			{	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: TestMode = RSSI_MODE"));
+				pDM_SWAT_Table->SelectAntennaMap=0xAA;
+				if(curRSSI < pDM_SWAT_Table->PreRSSI) //Current antenna is worse than previous antenna
+				{
+					//RT_TRACE(COMP_INIT, DBG_LOUD, ("SWAS: Switch back to another antenna"));
+					nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)?AUX_ANT : MAIN_ANT;
+				}
+				else // current anntena is good
+				{
+					nextAntenna =pDM_SWAT_Table->CurAntenna;
+					//RT_TRACE(COMP_INIT, DBG_LOUD, ("SWAS: current anntena is good\n"));
+				}
+			}
+			
+			pDM_SWAT_Table->try_flag = 0;
+			pHalData->RSSI_sum_A = 0;
+			pHalData->RSSI_cnt_A = 0;
+			pHalData->RSSI_sum_B = 0;
+			pHalData->RSSI_cnt_B = 0;
+			TXByteCnt_A = 0;
+			TXByteCnt_B = 0;
+			RXByteCnt_A = 0;
+			RXByteCnt_B = 0;
+			
+		}
+
+		//1 Normal State
+		else if(pDM_SWAT_Table->try_flag == 0)
+		{
+			if(TrafficLoad == TRAFFIC_HIGH)
+			{
+				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
+					TrafficLoad = TRAFFIC_HIGH;
+				else
+					TrafficLoad = TRAFFIC_LOW;
+			}
+			else if(TrafficLoad == TRAFFIC_LOW)
+				{
+				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
+					TrafficLoad = TRAFFIC_HIGH;
+				else
+					TrafficLoad = TRAFFIC_LOW;
+			}
+			if(TrafficLoad == TRAFFIC_HIGH)
+				pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Normal:TrafficLoad = %llu\n", curTxOkCnt+curRxOkCnt));
+
+			//Prepare To Try Antenna		
+				nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
+				pDM_SWAT_Table->try_flag = 1;
+			if((curRxOkCnt+curTxOkCnt) > 1000)
+			{
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+	                    pDM_SWAT_Table->RSSI_Trying = 4;                           
+#else
+	                    pDM_SWAT_Table->RSSI_Trying = 2;
+#endif
+				pDM_SWAT_Table->TestMode = TP_MODE;
+			}
+			else
+			{
+				pDM_SWAT_Table->RSSI_Trying = 2;
+				pDM_SWAT_Table->TestMode = RSSI_MODE;
+
+			}
+                          
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("SWAS: Normal State -> Begin Trying!\n"));			
+			pHalData->RSSI_sum_A = 0;
+			pHalData->RSSI_cnt_A = 0;
+			pHalData->RSSI_sum_B = 0;
+			pHalData->RSSI_cnt_B = 0;
+		} // end of try_flag=0
+	}
+	
+	//1 4.Change TRX antenna
+	if(nextAntenna != pDM_SWAT_Table->CurAntenna)
+	{
+	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Change TX Antenna!\n "));
+		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, nextAntenna); for 88C
+		if(nextAntenna==MAIN_ANT)
+		{
+		    ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Next Antenna is RF PATH A\n "));
+		    pathdiv_para = 0x02;   //02 to switchback to RF path A
+		    fw_value = 0x03;
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+                 odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+#else
+                 ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+#endif
+		}	
+	       else if(nextAntenna==AUX_ANT)
+	       {
+	           ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Next Antenna is RF PATH B\n "));
+	           if(switchfirsttime==0)  // First Time To Enter Path Diversity
+	           {
+	               switchfirsttime=0x01;
+                      pathdiv_para = 0x00;
+			  fw_value=0x00;    // to backup RF Path A Releated Registers		  
+					  
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+#else
+                     ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+                     //for(u1Byte n=0; n<80,n++)
+                     //{
+                     //delay_us(500);
+			  ODM_delay_ms(500);
+                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+			 		 
+			 fw_value=0x01;   	// to backup RF Path A Releated Registers		 
+                     ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+#endif	
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: FIRST TIME To DO PATH SWITCH!\n "));	
+	           }		   
+		    else
+		    {
+		        pathdiv_para = 0x01;
+			 fw_value = 0x02;	
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+#else
+                     ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+#endif	
+		    }		
+	       }
+           //   odm_PathDiversity_8192D(Adapter, pathdiv_para);
+	}
+
+	//1 5.Reset Statistics
+	pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+	pDM_SWAT_Table->CurAntenna = nextAntenna;
+	pDM_SWAT_Table->PreRSSI = curRSSI;
+
+	//1 6.Set next timer
+
+	if(pDM_SWAT_Table->RSSI_Trying == 0)
+		return;
+
+	if(pDM_SWAT_Table->RSSI_Trying%2 == 0)
+	{
+		if(pDM_SWAT_Table->TestMode == TP_MODE)
+		{
+			if(TrafficLoad == TRAFFIC_HIGH)
+			{
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 10 ); //ms
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 10 ms\n"));
+#else
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 20 ); //ms
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 20 ms\n"));
+#endif				
+			}
+			else if(TrafficLoad == TRAFFIC_LOW)
+			{
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 50 ); //ms
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 50 ms\n"));
+			}
+		}
+		else   // TestMode == RSSI_MODE
+		{
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 500 ); //ms
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 500 ms\n"));
+		}
+	}
+	else
+	{
+		if(pDM_SWAT_Table->TestMode == TP_MODE)
+		{
+			if(TrafficLoad == TRAFFIC_HIGH)
+				
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 90 ); //ms
+				//ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 90 ms\n"));
+#else		
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 180); //ms
+#endif				
+			else if(TrafficLoad == TRAFFIC_LOW)
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 100 ); //ms
+		}
+		else
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 500 ); //ms
+	}
+}
+
+
+
+VOID
+ODM_CCKPathDiversityChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd,
+	pu1Byte			pDesc
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			bCount = FALSE;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+	//BOOLEAN	isCCKrate = RX_HAL_IS_CCK_RATE_92C(pDesc);
+#if DEV_BUS_TYPE != RT_SDIO_INTERFACE
+	BOOLEAN	isCCKrate = RX_HAL_IS_CCK_RATE(Adapter, pDesc);
+#else  //below code would be removed if we have verified SDIO
+	BOOLEAN	isCCKrate = IS_HARDWARE_TYPE_8188E(Adapter) ? RX_HAL_IS_CCK_RATE_88E(pDesc) : RX_HAL_IS_CCK_RATE_92C(pDesc);
+#endif
+
+	if ((pHalData->PathDivCfg != 1))
+		return;
+		
+	if(pHalData->RSSI_target==NULL && bIsDefPort && bMatchBSSID)
+		bCount = TRUE;
+	else if(pHalData->RSSI_target!=NULL && pEntry!=NULL && pHalData->RSSI_target==pEntry)
+		bCount = TRUE;
+
+	if(bCount && isCCKrate)
+	{
+		if(pDM_PDTable->TrainingState == 1 )
+		{
+			if(pEntry)
+			{
+				if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[0] != 0)
+					pEntry->rssi_stat.RSSI_CCK_Path[0] += pRfd->Status.RxPWDBAll;
+				pEntry->rssi_stat.RSSI_CCK_Path_cnt[0]++;
+			}
+			else
+			{
+				if(pDM_PDTable->RSSI_CCK_Path_cnt[0] != 0)
+					pDM_PDTable->RSSI_CCK_Path[0] += pRfd->Status.RxPWDBAll;
+				pDM_PDTable->RSSI_CCK_Path_cnt[0]++;
+			}
+		}
+		else if(pDM_PDTable->TrainingState == 2 )
+		{
+			if(pEntry)
+			{
+				if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[1] != 0)
+					pEntry->rssi_stat.RSSI_CCK_Path[1] += pRfd->Status.RxPWDBAll;
+				pEntry->rssi_stat.RSSI_CCK_Path_cnt[1]++;
+			}
+			else
+			{
+				if(pDM_PDTable->RSSI_CCK_Path_cnt[1] != 0)
+					pDM_PDTable->RSSI_CCK_Path[1] += pRfd->Status.RxPWDBAll;
+				pDM_PDTable->RSSI_CCK_Path_cnt[1]++;
+			}
+		}
+	}
+}
+
+
+
+
+//Neil Chen---2011--06--22
+//----92D Path Diversity----//
+//#ifdef PathDiv92D
+//==================================
+//3 Path Diversity 
+//==================================
+//
+// 20100514 Luke/Joseph:
+// Add new function for antenna diversity after link.
+// This is the main function of antenna diversity after link.
+// This function is called in HalDmWatchDog() and ODM_SwAntDivChkAntSwitchCallback().
+// HalDmWatchDog() calls this function with SWAW_STEP_PEAK to initialize the antenna test.
+// In SWAW_STEP_PEAK, another antenna and a 500ms timer will be set for testing.
+// After 500ms, ODM_SwAntDivChkAntSwitchCallback() calls this function to compare the signal just
+// listened on the air with the RSSI of original antenna.
+// It chooses the antenna with better RSSI.
+// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting 
+// penalty to get next try.
+//
+//
+// 20100503 Joseph:
+// Add new function SwAntDivCheck8192C().
+// This is the main function of Antenna diversity function before link.
+// Mainly, it just retains last scan result and scan again.
+// After that, it compares the scan result to see which one gets better RSSI.
+// It selects antenna with better receiving power and returns better scan result.
+//
+
+
+//
+// 20100514 Luke/Joseph:
+// This function is used to gather the RSSI information for antenna testing.
+// It selects the RSSI of the peer STA that we want to know.
+//
+VOID
+ODM_PathDivChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	BOOLEAN			bCount = FALSE;
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+	if(pHalData->RSSI_target==NULL && bIsDefPort && bMatchBSSID)
+		bCount = TRUE;
+	else if(pHalData->RSSI_target!=NULL && pEntry!=NULL && pHalData->RSSI_target==pEntry)
+		bCount = TRUE;
+
+	if(bCount)
+	{
+		//1 RSSI for SW Antenna Switch
+		if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+		{
+			pHalData->RSSI_sum_A += pRfd->Status.RxPWDBAll;
+			pHalData->RSSI_cnt_A++;
+		}
+		else
+		{
+			pHalData->RSSI_sum_B += pRfd->Status.RxPWDBAll;
+			pHalData->RSSI_cnt_B++;
+
+		}
+	}
+}
+
+
+//
+// 20100514 Luke/Joseph:
+// Add new function to reset antenna diversity state after link.
+//
+VOID
+ODM_PathDivRestAfterLink(
+	IN	PDM_ODM_T		pDM_Odm
+	)
+{
+	PADAPTER		Adapter=pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+	pHalData->RSSI_cnt_A = 0;
+	pHalData->RSSI_cnt_B = 0;
+	pDM_SWAT_Table->try_flag = 0x0;       // NOT 0xff
+	pDM_SWAT_Table->RSSI_Trying = 0;
+	pDM_SWAT_Table->SelectAntennaMap=0xAA;
+	pDM_SWAT_Table->CurAntenna = MAIN_ANT;  
+}
+
+
+//==================================================
+//3 PathDiv End
+//==================================================
+
+
+VOID
+ODM_FillTXPathInTXDESC(
+		IN	PADAPTER	Adapter,
+		IN	PRT_TCB		pTcb,
+		IN	pu1Byte		pDesc
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte	TXPath;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+
+	//2011.09.05  Add by Luke Lee for path diversity
+	if(pHalData->PathDivCfg == 1)
+	{	
+		TXPath = (pDM_PDTable->OFDMTXPath >> pTcb->macId) & BIT0;
+		//RT_TRACE(	COMP_INIT, DBG_LOUD, ("Fill TXDESC: macID=%d, TXPath=%d\n", pTcb->macId, TXPath));
+		//SET_TX_DESC_TX_ANT_CCK(pDesc,TXPath);
+		if(TXPath == 0)
+		{
+			SET_TX_DESC_TX_ANTL_92C(pDesc,1);
+			SET_TX_DESC_TX_ANT_HT_92C(pDesc,1);
+		}
+		else
+		{
+			SET_TX_DESC_TX_ANTL_92C(pDesc,2);
+			SET_TX_DESC_TX_ANT_HT_92C(pDesc,2);
+		}
+		TXPath = (pDM_PDTable->CCKTXPath >> pTcb->macId) & BIT0;
+		if(TXPath == 0)
+		{
+			SET_TX_DESC_TX_ANT_CCK_92C(pDesc,1);
+		}
+		else
+		{
+			SET_TX_DESC_TX_ANT_CCK_92C(pDesc,2);
+		}
+	}
+}
+
+//Only for MP //Neil Chen--2012--0502--
+VOID
+odm_PathDivInit_92D(
+IN	PDM_ODM_T 	pDM_Odm)
+{
+	pPATHDIV_PARA	pathIQK = &pDM_Odm->pathIQK;
+
+	pathIQK->org_2g_RegC14=0x0;
+	pathIQK->org_2g_RegC4C=0x0;
+	pathIQK->org_2g_RegC80=0x0;
+	pathIQK->org_2g_RegC94=0x0;
+	pathIQK->org_2g_RegCA0=0x0;
+	pathIQK->org_5g_RegC14=0x0;
+	pathIQK->org_5g_RegCA0=0x0;
+	pathIQK->org_5g_RegE30=0x0;
+	pathIQK->swt_2g_RegC14=0x0;
+	pathIQK->swt_2g_RegC4C=0x0;
+	pathIQK->swt_2g_RegC80=0x0;
+	pathIQK->swt_2g_RegC94=0x0;
+	pathIQK->swt_2g_RegCA0=0x0;
+	pathIQK->swt_5g_RegC14=0x0;
+	pathIQK->swt_5g_RegCA0=0x0;
+	pathIQK->swt_5g_RegE30=0x0;
+
+}
+
+
+u1Byte
+odm_SwAntDivSelectScanChnl(
+	IN	PADAPTER	Adapter
+	)
+{
+#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
+	PHAL_DATA_TYPE		pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO			pMgntInfo = &(Adapter->MgntInfo);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	u2Byte 				i;
+	u1Byte				j, ScanChannel = 0, ChannelNum = 0;
+	PRT_CHANNEL_LIST	pChannelList = GET_RT_CHANNEL_LIST(pMgntInfo);
+	u1Byte 				EachChannelSTAs[MAX_SCAN_CHANNEL_NUM] = {0};
+
+	if(pMgntInfo->tmpNumBssDesc == 0)
+		return 0;
+
+	for(i = 0; i < pMgntInfo->tmpNumBssDesc; i++)
+	{		
+		ChannelNum = pMgntInfo->tmpbssDesc[i].ChannelNumber;
+		for(j = 0; j < pChannelList->ChannelLen; j++)
+		{
+			if(pChannelList->ChnlListEntry[j].ChannelNum == ChannelNum)
+			{
+				EachChannelSTAs[j]++;
+				break;
+			}
+		}
+	}
+	
+	for(i = 0; i < MAX_SCAN_CHANNEL_NUM; i++)
+		{
+		if(EachChannelSTAs[i] > EachChannelSTAs[ScanChannel])
+			ScanChannel = (u1Byte)i;
+		}
+
+	if(EachChannelSTAs[ScanChannel] == 0)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("odm_SwAntDivSelectScanChnl(): Scan List is empty.\n"));
+		return 0;
+	}
+	
+	ScanChannel = pChannelList->ChnlListEntry[ScanChannel].ChannelNum;
+
+	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, 
+		("odm_SwAntDivSelectScanChnl(): Channel (( %d )) is select as scan channel.\n", ScanChannel));
+
+	return ScanChannel;
+#else
+	return	0;
+#endif	
+}
+
+
+VOID
+odm_SwAntDivConstructScanChnl(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte		ScanChnl
+	)
+{
+
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+
+	if(ScanChnl == 0)
+	{
+		u1Byte				i;		
+		PRT_CHANNEL_LIST	pChannelList = GET_RT_CHANNEL_LIST(pMgntInfo);
+	
+		// 20100519 Joseph: Original antenna scanned nothing. 
+		// Test antenna shall scan all channel with half period in this condition.
+
+		RT_TRACE_F(COMP_SCAN, DBG_TRACE, (" RT_CHNL_LIST_ACTION_CONSTRUCT chnl %d \n", ScanChnl));
+
+		RtActChannelList(Adapter, RT_CHNL_LIST_ACTION_CONSTRUCT_SCAN_LIST, NULL, NULL);
+		for(i = 0; i < pChannelList->ChannelLen; i++)
+			pChannelList->ChnlListEntry[i].ScanPeriod /= 2;
+	}
+	else
+	{
+		// The using of this CustomizedScanRequest is a trick to rescan the two channels 
+		//	under the NORMAL scanning process. It will not affect MGNT_INFO.CustomizedScanRequest.
+		CUSTOMIZED_SCAN_REQUEST CustomScanReq;
+
+		CustomScanReq.bEnabled = TRUE;
+		CustomScanReq.Channels[0] = ScanChnl;
+		CustomScanReq.Channels[1] = pMgntInfo->dot11CurrentChannelNumber;
+		CustomScanReq.nChannels = 2;
+		CustomScanReq.ScanType = SCAN_ACTIVE;
+		CustomScanReq.Duration = DEFAULT_PASSIVE_SCAN_PERIOD;
+
+		RT_TRACE_F(COMP_SCAN, DBG_TRACE, (" RT_CHNL_LIST_ACTION_CONSTRUCT chnl %d \n", ScanChnl));
+
+		RtActChannelList(Adapter, RT_CHNL_LIST_ACTION_CONSTRUCT_SCAN_LIST, &CustomScanReq, NULL);
+	}
+
+}
+#else
+
+VOID
+odm_PathDivChkAntSwitchCallback(
+	PRT_TIMER		pTimer
+)
+{
+}
+
+VOID
+odm_PathDivChkAntSwitchWorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+}
+
+VOID
+odm_CCKTXPathDiversityCallback(
+	PRT_TIMER		pTimer
+)
+{
+}
+
+VOID
+odm_CCKTXPathDiversityWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+}
+u1Byte
+odm_SwAntDivSelectScanChnl(
+	IN	PADAPTER	Adapter
+	)
+{
+	return	0;
+}
+VOID
+odm_SwAntDivConstructScanChnl(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte		ScanChnl
+	)
+{
+}
+
+
+#endif
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.h
new file mode 100644
index 000000000..020288ea4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pathdiv.h
@@ -0,0 +1,324 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMPATHDIV_H__
+#define    __PHYDMPATHDIV_H__
+/*#define PATHDIV_VERSION "2.0" //2014.11.04*/
+#define PATHDIV_VERSION	"3.0" /*2015.01.13 Dino*/
+
+#if(defined(CONFIG_PATH_DIVERSITY))
+#define USE_PATH_A_AS_DEFAULT_ANT   //for 8814 dynamic TX path selection
+
+#define	NUM_RESET_DTP_PERIOD 5
+#define	ANT_DECT_RSSI_TH 3 
+
+#define PATH_A 1
+#define PATH_B 2
+#define PATH_C 3
+#define PATH_D 4
+
+#define PHYDM_AUTO_PATH	0
+#define PHYDM_FIX_PATH		1
+
+#define NUM_CHOOSE2_FROM4 6
+#define NUM_CHOOSE3_FROM4 4
+
+
+#define		PHYDM_A		 BIT0
+#define		PHYDM_B		 BIT1
+#define		PHYDM_C		 BIT2
+#define		PHYDM_D		 BIT3
+#define		PHYDM_AB	 (BIT0 | BIT1)  // 0
+#define		PHYDM_AC	 (BIT0 | BIT2)  // 1
+#define		PHYDM_AD	 (BIT0 | BIT3)  // 2
+#define		PHYDM_BC	 (BIT1 | BIT2)  // 3
+#define		PHYDM_BD	 (BIT1 | BIT3)  // 4
+#define		PHYDM_CD	 (BIT2 | BIT3)  // 5
+
+#define		PHYDM_ABC	 (BIT0 | BIT1 | BIT2) /* 0*/
+#define		PHYDM_ABD	 (BIT0 | BIT1 | BIT3) /* 1*/
+#define		PHYDM_ACD	 (BIT0 | BIT2 | BIT3) /* 2*/
+#define		PHYDM_BCD	 (BIT1 | BIT2 | BIT3) /* 3*/
+
+#define		PHYDM_ABCD	 (BIT0 | BIT1 | BIT2 | BIT3)
+
+
+typedef enum dtp_state
+{
+	PHYDM_DTP_INIT=1,
+	PHYDM_DTP_RUNNING_1
+
+}PHYDM_DTP_STATE;
+
+typedef enum path_div_type
+{
+	PHYDM_2R_PATH_DIV = 1,
+	PHYDM_4R_PATH_DIV = 2
+}PHYDM_PATH_DIV_TYPE;
+
+VOID
+phydm_process_rssi_for_path_div(	
+	IN OUT		PVOID			pDM_VOID,	
+	IN			PVOID			p_phy_info_void,
+	IN			PVOID			p_pkt_info_void
+	);
+
+typedef struct _ODM_PATH_DIVERSITY_
+{
+	u1Byte	RespTxPath;
+	u1Byte	PathSel[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	PathA_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u4Byte	PathB_Sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u2Byte	PathA_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u2Byte	PathB_Cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u1Byte	path_div_type;
+  #if RTL8814A_SUPPORT
+	
+	u4Byte	path_a_sum_all;
+	u4Byte	path_b_sum_all;
+	u4Byte	path_c_sum_all;
+	u4Byte	path_d_sum_all;
+
+	u4Byte	path_a_cnt_all;
+	u4Byte	path_b_cnt_all;
+	u4Byte	path_c_cnt_all;
+	u4Byte	path_d_cnt_all;
+	
+	u1Byte	dtp_period;
+	BOOLEAN	bBecomeLinked;
+	BOOLEAN	is_u3_mode;
+	u1Byte	num_tx_path;
+	u1Byte	default_path;
+	u1Byte	num_candidate;
+	u1Byte	ant_candidate_1;
+	u1Byte	ant_candidate_2;
+	u1Byte	ant_candidate_3;
+	u1Byte     dtp_state;
+	u1Byte	dtp_check_patha_counter;
+	BOOLEAN	fix_path_bfer;
+	u1Byte	search_space_2[NUM_CHOOSE2_FROM4];
+	u1Byte	search_space_3[NUM_CHOOSE3_FROM4];
+	
+	u1Byte	pre_tx_path;
+	u1Byte	use_path_a_as_default_ant;
+	BOOLEAN is_pathA_exist;
+
+  #endif
+}PATHDIV_T, *pPATHDIV_T;
+
+
+#endif //#if(defined(CONFIG_PATH_DIVERSITY))
+
+VOID
+phydm_c2h_dtp_handler(
+	 IN	PVOID	pDM_VOID,
+	 IN 	pu1Byte   CmdBuf,
+	 IN 	u1Byte	CmdLen
+	);
+
+VOID
+odm_PathDiversityInit(
+	IN	PVOID	pDM_VOID
+	);
+
+VOID
+odm_PathDiversity(
+	IN	PVOID	pDM_VOID
+	);
+
+VOID
+odm_pathdiv_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value,
+	IN		u4Byte		*_used,
+	OUT		char		*output,
+	IN		u4Byte		*_out_len
+	);
+
+
+
+//1 [OLD IC]--------------------------------------------------------------------------------
+
+
+
+
+
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+
+//#define   PATHDIV_ENABLE 	 1
+#define dm_PathDiv_RSSI_Check	ODM_PathDivChkPerPktRssi
+#define PathDivCheckBeforeLink8192C	ODM_PathDiversityBeforeLink92C
+
+
+
+
+typedef struct _PathDiv_Parameter_define_
+{
+	u4Byte org_5g_RegE30;
+	u4Byte org_5g_RegC14;
+	u4Byte org_5g_RegCA0;
+	u4Byte swt_5g_RegE30;
+	u4Byte swt_5g_RegC14;
+	u4Byte swt_5g_RegCA0;
+	//for 2G IQK information
+	u4Byte org_2g_RegC80;
+	u4Byte org_2g_RegC4C;
+	u4Byte org_2g_RegC94;
+	u4Byte org_2g_RegC14;
+	u4Byte org_2g_RegCA0;
+
+	u4Byte swt_2g_RegC80;
+	u4Byte swt_2g_RegC4C;
+	u4Byte swt_2g_RegC94;
+	u4Byte swt_2g_RegC14;
+	u4Byte swt_2g_RegCA0;
+}PATHDIV_PARA,*pPATHDIV_PARA;
+
+VOID	
+odm_PathDiversityInit_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_2TPathDiversityInit_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_1TPathDiversityInit_92C(	
+	IN	PADAPTER	Adapter
+	);
+
+BOOLEAN
+odm_IsConnected_92C(
+	IN	PADAPTER	Adapter
+	);
+
+BOOLEAN 
+ODM_PathDiversityBeforeLink92C(
+	//IN	PADAPTER	Adapter
+	IN		PDM_ODM_T		pDM_Odm
+	);
+
+VOID	
+odm_PathDiversityAfterLink_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+odm_SetRespPath_92C(	
+	IN	PADAPTER	Adapter, 	
+	IN	u1Byte	DefaultRespPath
+	);
+
+VOID	
+odm_OFDMTXPathDiversity_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_CCKTXPathDiversity_92C(	
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_ResetPathDiversity_92C(	
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+odm_CCKTXPathDiversityCallback(
+	PRT_TIMER		pTimer
+	);
+
+VOID
+odm_CCKTXPathDiversityWorkItemCallback(
+	IN PVOID            pContext
+	);
+
+VOID
+odm_PathDivChkAntSwitchCallback(
+	PRT_TIMER		pTimer
+	);
+
+VOID
+odm_PathDivChkAntSwitchWorkitemCallback(
+	IN PVOID            pContext
+	);
+
+
+VOID 
+odm_PathDivChkAntSwitch(
+	PDM_ODM_T    pDM_Odm
+	);
+
+VOID
+ODM_CCKPathDiversityChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd,
+	pu1Byte			pDesc
+	);
+
+VOID 
+ODM_PathDivChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd	
+	);
+
+VOID
+ODM_PathDivRestAfterLink(
+	IN	PDM_ODM_T		pDM_Odm
+	);
+
+VOID
+ODM_FillTXPathInTXDESC(
+		IN	PADAPTER	Adapter,
+		IN	PRT_TCB		pTcb,
+		IN	pu1Byte		pDesc
+	);
+
+VOID
+odm_PathDivInit_92D(
+	IN	PDM_ODM_T 	pDM_Odm
+	);
+
+u1Byte
+odm_SwAntDivSelectScanChnl(
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+odm_SwAntDivConstructScanChnl(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte		ScanChnl
+	);
+	
+ #endif       //#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+ 
+ 
+ #endif		 //#ifndef  __ODMPATHDIV_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.c
new file mode 100644
index 000000000..4f8623958
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.c
@@ -0,0 +1,1050 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#if !defined(_OUTSRC_COEXIST)
+//============================================================
+// Global var
+//============================================================
+
+
+u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE_92D] = {
+	0x0b40002d, // 0,  -15.0dB	
+	0x0c000030, // 1,  -14.5dB
+	0x0cc00033, // 2,  -14.0dB
+	0x0d800036, // 3,  -13.5dB
+	0x0e400039, // 4,  -13.0dB    
+	0x0f00003c, // 5,  -12.5dB
+	0x10000040, // 6,  -12.0dB
+	0x11000044, // 7,  -11.5dB
+	0x12000048, // 8,  -11.0dB
+	0x1300004c, // 9,  -10.5dB
+	0x14400051, // 10, -10.0dB
+	0x15800056, // 11, -9.5dB
+	0x16c0005b, // 12, -9.0dB
+	0x18000060, // 13, -8.5dB
+	0x19800066, // 14, -8.0dB
+	0x1b00006c, // 15, -7.5dB
+	0x1c800072, // 16, -7.0dB
+	0x1e400079, // 17, -6.5dB
+	0x20000080, // 18, -6.0dB
+	0x22000088, // 19, -5.5dB
+	0x24000090, // 20, -5.0dB
+	0x26000098, // 21, -4.5dB
+	0x288000a2, // 22, -4.0dB
+	0x2ac000ab, // 23, -3.5dB
+	0x2d4000b5, // 24, -3.0dB
+	0x300000c0, // 25, -2.5dB
+	0x32c000cb, // 26, -2.0dB
+	0x35c000d7, // 27, -1.5dB
+	0x390000e4, // 28, -1.0dB
+	0x3c8000f2, // 29, -0.5dB
+	0x40000100, // 30, +0dB
+	0x43c0010f, // 31, +0.5dB
+	0x47c0011f, // 32, +1.0dB
+	0x4c000130, // 33, +1.5dB
+	0x50800142, // 34, +2.0dB
+	0x55400155, // 35, +2.5dB
+	0x5a400169, // 36, +3.0dB
+	0x5fc0017f, // 37, +3.5dB
+	0x65400195, // 38, +4.0dB
+	0x6b8001ae, // 39, +4.5dB
+	0x71c001c7, // 40, +5.0dB
+	0x788001e2, // 41, +5.5dB
+	0x7f8001fe  // 42, +6.0dB
+};               
+
+u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 14, -9.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 18, -7.0dB 
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 19, -6.5dB
+    	{0x1c, 0x1a, 0x18, 0x12, 0x0e, 0x08, 0x04, 0x02},	// 20, -6.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 22, -5.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 24, -4.0dB 
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 25, -3.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 26, -3.0dB
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 28, -2.0dB 
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 30, -1.0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 31, -0.5dB
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	// 32, +0dB
+};                                                                  
+
+
+u1Byte CCKSwingTable_Ch14_New[CCK_TABLE_SIZE][8]= {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 14, -9.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 18, -7.0dB  
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 19, -6.5dB 
+	{0x1c, 0x1a, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 20, -6.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 22, -5.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 24, -4.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 25, -3.5dB  
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 26, -3.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 28, -2.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 30, -1.0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 31, -0.5dB 
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	// 32, +0dB	
+};
+
+u4Byte OFDMSwingTable[OFDM_TABLE_SIZE_92D] = {
+	0x0b40002d, // 0,  -15.0dB	
+	0x0c000030, // 1,  -14.5dB
+	0x0cc00033, // 2,  -14.0dB
+	0x0d800036, // 3,  -13.5dB
+	0x0e400039, // 4,  -13.0dB    
+	0x0f00003c, // 5,  -12.5dB
+	0x10000040, // 6,  -12.0dB
+	0x11000044, // 7,  -11.5dB
+	0x12000048, // 8,  -11.0dB
+	0x1300004c, // 9,  -10.5dB
+	0x14400051, // 10, -10.0dB
+	0x15800056, // 11, -9.5dB
+	0x16c0005b, // 12, -9.0dB
+	0x18000060, // 13, -8.5dB
+	0x19800066, // 14, -8.0dB
+	0x1b00006c, // 15, -7.5dB
+	0x1c800072, // 16, -7.0dB
+	0x1e400079, // 17, -6.5dB
+	0x20000080, // 18, -6.0dB
+	0x22000088, // 19, -5.5dB
+	0x24000090, // 20, -5.0dB
+	0x26000098, // 21, -4.5dB
+	0x288000a2, // 22, -4.0dB
+	0x2ac000ab, // 23, -3.5dB
+	0x2d4000b5, // 24, -3.0dB
+	0x300000c0, // 25, -2.5dB
+	0x32c000cb, // 26, -2.0dB
+	0x35c000d7, // 27, -1.5dB
+	0x390000e4, // 28, -1.0dB
+	0x3c8000f2, // 29, -0.5dB
+	0x40000100, // 30, +0dB
+	0x43c0010f, // 31, +0.5dB
+	0x47c0011f, // 32, +1.0dB
+	0x4c000130, // 33, +1.5dB
+	0x50800142, // 34, +2.0dB
+	0x55400155, // 35, +2.5dB
+	0x5a400169, // 36, +3.0dB
+	0x5fc0017f, // 37, +3.5dB
+	0x65400195, // 38, +4.0dB
+	0x6b8001ae, // 39, +4.5dB
+	0x71c001c7, // 40, +5.0dB
+	0x788001e2, // 41, +5.5dB
+	0x7f8001fe  // 42, +6.0dB
+};               
+
+
+u1Byte CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 14, -9.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 18, -7.0dB 
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 19, -6.5dB
+    	{0x1c, 0x1a, 0x18, 0x12, 0x0e, 0x08, 0x04, 0x02},	// 20, -6.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 22, -5.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 24, -4.0dB 
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 25, -3.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 26, -3.0dB
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 28, -2.0dB 
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 30, -1.0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 31, -0.5dB
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	// 32, +0dB
+};                                                                  
+
+
+u1Byte CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8]= {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 14, -9.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 18, -7.0dB  
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 19, -6.5dB 
+	{0x1c, 0x1a, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 20, -6.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 22, -5.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 24, -4.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 25, -3.5dB  
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 26, -3.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 28, -2.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 30, -1.0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 31, -0.5dB 
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	// 32, +0dB	
+};
+
+u1Byte CCKSwingTable_Ch1_Ch14_88F[CCK_TABLE_SIZE_88F][16] = {
+{0x16, 0x15, 0x13, 0x10, 0xD, 0x9, 0x6, 0x3, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 0  -16dB */
+{0x18, 0x17, 0x15, 0x12, 0xE, 0xA, 0x7, 0x4, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 1  -15.5dB */
+{0x1B, 0x1A, 0x18, 0x14, 0x10, 0xB, 0x7, 0x4, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 2  -15dB */
+{0x1F, 0x1E, 0x1B, 0x17, 0x12, 0xD, 0x8, 0x5, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 3  -14.5dB */
+{0x22, 0x21, 0x1E, 0x19, 0x14, 0xE, 0x9, 0x5, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 4  -14dB */
+{0x26, 0x25, 0x22, 0x1C, 0x16, 0x10, 0xA, 0x6, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 5  -13.5dB */
+{0x2B, 0x2A, 0x26, 0x20, 0x19, 0x12, 0xC, 0x7, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 6  -13dB */
+{0x30, 0x2F, 0x2A, 0x24, 0x1C, 0x14, 0xD, 0x8, 0x4, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 7  -12.5dB */
+{0x36, 0x34, 0x2F, 0x28, 0x1F, 0x17, 0xF, 0x9, 0x4, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 8  -12dB */
+{0x3D, 0x3B, 0x35, 0x2D, 0x23, 0x19, 0x11, 0xA, 0x5, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 9  -11.5dB */
+{0x44, 0x42, 0x3C, 0x33, 0x28, 0x1C, 0x13, 0xB, 0x5, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 10  -11dB */
+{0x4D, 0x4A, 0x43, 0x39, 0x2C, 0x20, 0x15, 0xC, 0x6, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 11  -10.5dB */
+{0x56, 0x53, 0x4B, 0x40, 0x32, 0x24, 0x17, 0xE, 0x6, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 12  -10dB */
+{0x60, 0x5D, 0x54, 0x47, 0x38, 0x28, 0x1A, 0xF, 0x7, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 13  -9.5dB */
+{0x6C, 0x69, 0x5F, 0x50, 0x3F, 0x2D, 0x1E, 0x11, 0x8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 14  -9dB */
+{0x79, 0x76, 0x6A, 0x5A, 0x46, 0x33, 0x21, 0x13, 0x9, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 15  -8.5dB */
+{0x88, 0x84, 0x77, 0x65, 0x4F, 0x39, 0x25, 0x15, 0xA, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 16  -8dB */
+{0x99, 0x94, 0x86, 0x71, 0x58, 0x40, 0x2A, 0x18, 0xB, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 17  -7.5dB */
+{0xAC, 0xA6, 0x96, 0x7F, 0x63, 0x47, 0x2F, 0x1B, 0xD, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 18  -7dB */
+{0xC1, 0xBA, 0xA8, 0x8F, 0x6F, 0x50, 0x35, 0x1E, 0xE, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},        /* 19  -6.5dB */
+{0xD8, 0xD1, 0xBD, 0xA0, 0x7D, 0x5A, 0x3B, 0x22, 0x10, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}      /* 20  -6dB */
+};
+
+
+#if 0
+u4Byte OFDMSwingTable_92E[OFDM_TABLE_SIZE_92E] = {
+	/* Index0   6  dB */ 0x7fc001ff,
+	/* Index1   5.7dB */ 0x7b4001ed,
+	/* Index2   5.4dB */ 0x774001dd,
+	/* Index3   5.1dB */ 0x734001cd,
+	/* Index4   4.8dB */ 0x6f4001bd,
+	/* Index5   4.5dB */ 0x6b8001ae,
+	/* Index6   4.2dB */ 0x67c0019f,
+	/* Index7   3.9dB */ 0x64400191,
+	/* Index8   3.6dB */ 0x60c00183,
+	/* Index9   3.3dB */ 0x5d800176,
+	/* Index10  3  dB */ 0x5a80016a,
+	/* Index11  2.7dB */ 0x5740015d,
+	/* Index12  2.4dB */ 0x54400151,
+	/* Index13  2.1dB */ 0x51800146,
+	/* Index14  1.8dB */ 0x4ec0013b,
+	/* Index15  1.5dB */ 0x4c000130,
+	/* Index16  1.2dB */ 0x49800126,
+	/* Index17  0.9dB */ 0x4700011c,
+	/* Index18  0.6dB */ 0x44800112,
+	/* Index19  0.3dB */ 0x42000108,
+	/* Index20  0  dB */ 0x40000100, // 20 This is OFDM base index
+	/* Index21 -0.3dB */ 0x3dc000f7,
+	/* Index22 -0.6dB */ 0x3bc000ef,
+	/* Index23 -0.9dB */ 0x39c000e7,
+	/* Index24 -1.2dB */ 0x37c000df,
+	/* Index25 -1.5dB */ 0x35c000d7,
+	/* Index26 -1.8dB */ 0x340000d0,
+	/* Index27 -2.1dB */ 0x324000c9,
+	/* Index28 -2.4dB */ 0x308000c2,
+	/* Index29 -2.7dB */ 0x2f0000bc,
+	/* Index30 -3  dB */ 0x2d4000b5,
+	/* Index31 -3.3dB */ 0x2bc000af,
+	/* Index32 -3.6dB */ 0x2a4000a9,
+	/* Index33 -3.9dB */ 0x28c000a3,
+	/* Index34 -4.2dB */ 0x2780009e,
+	/* Index35 -4.5dB */ 0x26000098,
+	/* Index36 -4.8dB */ 0x24c00093,
+	/* Index37 -5.1dB */ 0x2380008e,
+	/* Index38 -5.4dB */ 0x22400089,
+	/* Index39 -5.7dB */ 0x21400085,
+	/* Index40 -6  dB */ 0x20000080,
+	/* Index41 -6.3dB */ 0x1f00007c,
+	/* Index42 -6.6dB */ 0x1e000078,
+	/* Index43 -6.9dB */ 0x1d000074,
+	/* Index44 -7.2dB */ 0x1c000070,
+	/* Index45 -7.5dB */ 0x1b00006c,
+	/* Index46 -7.8dB */ 0x1a000068,
+	/* Index47 -8.1dB */ 0x19400065,
+	/* Index48 -8.4dB */ 0x18400061,
+	/* Index49 -8.7dB */ 0x1780005e,
+	/* Index50 -9  dB */ 0x16c0005b,
+	/* Index51 -9.3dB */ 0x16000058,
+	/* Index52 -9.6dB */ 0x15400055,
+	/* Index53 -9.9dB */ 0x14800052
+};
+u1Byte CCKSwingTable_Ch1_Ch13_92E[CCK_TABLE_SIZE_92E][8] = {
+	/* Index0    0  dB */    {0x36, 0x34 , 0x2E , 0x26 , 0x1C , 0x12 , 0x08 , 0x04},
+	/* Index1   -0.3dB */    {0x34, 0x32 , 0x2C , 0x25 , 0x1B , 0x11 , 0x08 , 0x04},
+	/* Index2   -0.6dB */    {0x32, 0x30 , 0x2B , 0x23 , 0x1A , 0x11 , 0x07 , 0x04},
+	/* Index3   -0.9dB */    {0x31, 0x2F , 0x29 , 0x22 , 0x19 , 0x10 , 0x07 , 0x04},
+	/* Index4   -1.2dB */    {0x2F, 0x2D , 0x28 , 0x21 , 0x18 , 0x10 , 0x07 , 0x03},
+	/* Index5   -1.5dB */    {0x2D, 0x2C , 0x27 , 0x20 , 0x18 , 0x0F , 0x07 , 0x03},
+	/* Index6   -1.8dB */    {0x2C, 0x2A , 0x25 , 0x1F , 0x17 , 0x0F , 0x06 , 0x03},
+	/* Index7   -2.1dB */    {0x2A, 0x29 , 0x24 , 0x1E , 0x16 , 0x0E , 0x06 , 0x03},
+	/* Index8   -2.4dB */    {0x29, 0x27 , 0x23 , 0x1D , 0x15 , 0x0E , 0x06 , 0x03},
+	/* Index9   -2.7dB */    {0x27, 0x26 , 0x22 , 0x1C , 0x14 , 0x0D , 0x06 , 0x03},
+	/* Index10  -3  dB */    {0x26, 0x25 , 0x20 , 0x1B , 0x14 , 0x0D , 0x06 , 0x03},
+	/* Index11  -3.3dB */    {0x25, 0x23 , 0x1F , 0x1A , 0x13 , 0x0C , 0x05 , 0x03},
+	/* Index12  -3.6dB */    {0x24, 0x22 , 0x1E , 0x19 , 0x12 , 0x0C , 0x05 , 0x03},
+	/* Index13  -3.9dB */    {0x22, 0x21 , 0x1D , 0x18 , 0x12 , 0x0B , 0x05 , 0x03},
+	/* Index14  -4.2dB */    {0x21, 0x20 , 0x1C , 0x17 , 0x11 , 0x0B , 0x05 , 0x02},
+	/* Index15  -4.5dB */    {0x20, 0x1F , 0x1B , 0x17 , 0x11 , 0x0B , 0x05 , 0x02},
+	/* Index16  -4.8dB */    {0x1F, 0x1E , 0x1A , 0x16 , 0x10 , 0x0A , 0x05 , 0x02},
+	/* Index17  -5.1dB */    {0x1E, 0x1D , 0x1A , 0x15 , 0x10 , 0x0A , 0x04 , 0x02},
+	/* Index18  -5.4dB */    {0x1D, 0x1C , 0x19 , 0x14 , 0x0F , 0x0A , 0x04 , 0x02},
+	/* Index19  -5.7dB */    {0x1C, 0x1B , 0x18 , 0x14 , 0x0E , 0x09 , 0x04 , 0x02},
+	/* Index20  -6.0dB */    {0x1B, 0x1A , 0x17 , 0x13 , 0x0E , 0x09 , 0x04 , 0x02}, // 20 This is CCK base index
+	/* Index21  -6.3dB */    {0x1A, 0x19 , 0x16 , 0x12 , 0x0E , 0x09 , 0x04 , 0x02},
+	/* Index22  -6.6dB */    {0x19, 0x18 , 0x15 , 0x12 , 0x0D , 0x08 , 0x04 , 0x02},
+	/* Index23  -6.9dB */    {0x18, 0x17 , 0x15 , 0x11 , 0x0D , 0x08 , 0x04 , 0x02},
+	/* Index24  -7.2dB */    {0x18, 0x17 , 0x14 , 0x11 , 0x0C , 0x08 , 0x03 , 0x02},
+	/* Index25  -7.5dB */    {0x17, 0x16 , 0x13 , 0x10 , 0x0C , 0x08 , 0x03 , 0x02},
+	/* Index26  -7.8dB */    {0x16, 0x15 , 0x13 , 0x0F , 0x0B , 0x07 , 0x03 , 0x02},
+	/* Index27  -8.1dB */    {0x15, 0x14 , 0x12 , 0x0F , 0x0B , 0x07 , 0x03 , 0x02},
+	/* Index28  -8.4dB */    {0x14, 0x14 , 0x11 , 0x0E , 0x0B , 0x07 , 0x03 , 0x02},
+	/* Index29  -8.7dB */    {0x14, 0x13 , 0x11 , 0x0E , 0x0A , 0x07 , 0x03 , 0x01},
+	/* Index30  -9.0dB */    {0x13, 0x12 , 0x10 , 0x0D , 0x0A , 0x06 , 0x03 , 0x01}, // 30 This is hp CCK base index
+	/* Index31  -9.3dB */    {0x12, 0x12 , 0x0F , 0x0D , 0x0A , 0x06 , 0x03 , 0x01},
+	/* Index32  -9.6dB */    {0x12, 0x11 , 0x0F , 0x0D , 0x09 , 0x06 , 0x03 , 0x01},
+	/* Index33  -9.9dB */    {0x11, 0x11 , 0x0F , 0x0C , 0x09 , 0x06 , 0x03 , 0x01},
+	/* Index34 -10.2dB */    {0x11, 0x11 , 0x0E , 0x0C , 0x09 , 0x06 , 0x02 , 0x01},
+	/* Index35 -10.5dB */    {0x10, 0x0F , 0x0E , 0x0B , 0x08 , 0x05 , 0x02 , 0x01},
+	/* Index36 -10.8dB */    {0x10, 0x0F , 0x0D , 0x0B , 0x08 , 0x05 , 0x02 , 0x01},
+	/* Index37 -11.1dB */    {0x0F, 0x0E , 0x0D , 0x0A , 0x08 , 0x05 , 0x02 , 0x01},
+	/* Index38 -11.4dB */    {0x0E, 0x0E , 0x0C , 0x0A , 0x07 , 0x05 , 0x02 , 0x01},
+	/* Index39 -11.7dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x07 , 0x05 , 0x02 , 0x01},
+	/* Index40 -12  dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x07 , 0x05 , 0x02 , 0x01},
+	/* Index41 -12.3dB */    {0x0D, 0x0D , 0x0B , 0x09 , 0x07 , 0x04 , 0x02 , 0x01},
+	/* Index42 -12.6dB */    {0x0D, 0x0C , 0x0B , 0x09 , 0x07 , 0x04 , 0x02 , 0x01},
+	/* Index43 -12.9dB */    {0x0C, 0x0C , 0x0A , 0x09 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index44 -13.2dB */    {0x0C, 0x0B , 0x0A , 0x08 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index45 -13.5dB */    {0x0B, 0x0B , 0x0A , 0x08 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index46 -13.8dB */    {0x0B, 0x0B , 0x09 , 0x08 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index47 -14.1dB */    {0x0B, 0x0A , 0x09 , 0x07 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index48 -14.4dB */    {0x0A, 0x0A , 0x09 , 0x07 , 0x05 , 0x03 , 0x02 , 0x01},
+	/* Index49 -14.7dB */    {0x0A, 0x0A , 0x08 , 0x07 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index50 -15  dB */    {0x0A, 0x09 , 0x08 , 0x07 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index51 -15.3dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index52 -15.6dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index53 -15.9dB */    {0x09, 0x08 , 0x07 , 0x06 , 0x04 , 0x03 , 0x01 , 0x01}
+};
+u1Byte CCKSwingTable_Ch14_92E[CCK_TABLE_SIZE_92E][8] = {
+	/* Index0    0  dB */    {0x36, 0x34 , 0x2E , 0x26 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index1   -0.3dB */    {0x34, 0x32 , 0x2C , 0x25 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index2   -0.6dB */    {0x32, 0x30 , 0x2B , 0x23 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index3   -0.9dB */    {0x31, 0x2F , 0x29 , 0x22 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index4   -1.2dB */    {0x2F, 0x2D , 0x28 , 0x21 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index5   -1.5dB */    {0x2D, 0x2C , 0x27 , 0x20 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index6   -1.8dB */    {0x2C, 0x2A , 0x25 , 0x1F , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index7   -2.1dB */    {0x2A, 0x29 , 0x24 , 0x1E , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index8   -2.4dB */    {0x29, 0x27 , 0x23 , 0x1D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index9   -2.7dB */    {0x27, 0x26 , 0x22 , 0x1C , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index10  -3  dB */    {0x26, 0x25 , 0x20 , 0x1B , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index11  -3.3dB */    {0x25, 0x23 , 0x1F , 0x1A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index12  -3.6dB */    {0x24, 0x22 , 0x1E , 0x19 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index13  -3.9dB */    {0x22, 0x21 , 0x1D , 0x18 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index14  -4.2dB */    {0x21, 0x20 , 0x1C , 0x17 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index15  -4.5dB */    {0x20, 0x1F , 0x1B , 0x17 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index16  -4.8dB */    {0x1F, 0x1E , 0x1A , 0x16 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index17  -5.1dB */    {0x1E, 0x1D , 0x1A , 0x15 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index18  -5.4dB */    {0x1D, 0x1C , 0x19 , 0x14 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index19  -5.7dB */    {0x1C, 0x1B , 0x18 , 0x14 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index20  -6  dB */     {0x1B, 0x1A , 0x17 , 0x13 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index21  -6.3dB */    {0x1A, 0x19 , 0x16 , 0x12 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index22  -6.6dB */    {0x19, 0x18 , 0x15 , 0x12 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index23  -6.9dB */    {0x18, 0x17 , 0x15 , 0x11 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index24  -7.2dB */    {0x18, 0x17 , 0x14 , 0x11 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index25  -7.5dB */    {0x17, 0x16 , 0x13 , 0x10 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index26  -7.8dB */    {0x16, 0x15 , 0x13 , 0x0F , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index27  -8.1dB */    {0x15, 0x14 , 0x12 , 0x0F , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index28  -8.4dB */    {0x14, 0x14 , 0x11 , 0x0E , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index29  -8.7dB */    {0x14, 0x13 , 0x11 , 0x0E , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index30  -9  dB */    {0x13, 0x12 , 0x10 , 0x0D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index31  -9.3dB */    {0x12, 0x12 , 0x0F , 0x0D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index32  -9.6dB */    {0x12, 0x11 , 0x0F , 0x0D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index33  -9.9dB */    {0x11, 0x11 , 0x0F , 0x0C , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index34 -10.2dB */    {0x11, 0x11 , 0x0E , 0x0C , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index35 -10.5dB */    {0x10, 0x0F , 0x0E , 0x0B , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index36 -10.8dB */    {0x10, 0x0F , 0x0D , 0x0B , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index37 -11.1dB */    {0x0F, 0x0E , 0x0D , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index38 -11.4dB */    {0x0E, 0x0E , 0x0C , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index39 -11.7dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index40 -12  dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index41 -12.3dB */    {0x0D, 0x0D , 0x0B , 0x09 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index42 -12.6dB */    {0x0D, 0x0C , 0x0B , 0x09 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index43 -12.9dB */    {0x0C, 0x0C , 0x0A , 0x09 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index44 -13.2dB */    {0x0C, 0x0B , 0x0A , 0x08 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index45 -13.5dB */    {0x0B, 0x0B , 0x0A , 0x08 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index46 -13.8dB */    {0x0B, 0x0B , 0x09 , 0x08 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index47 -14.1dB */    {0x0B, 0x0A , 0x09 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index48 -14.4dB */    {0x0A, 0x0A , 0x09 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index49 -14.7dB */    {0x0A, 0x0A , 0x08 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index50 -15  dB */    {0x0A, 0x09 , 0x08 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index51 -15.3dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index52 -15.6dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index53 -15.9dB */    {0x09, 0x08 , 0x07 , 0x06 , 0x00 , 0x00 , 0x00 , 0x00}
+};
+#endif
+
+#ifdef AP_BUILD_WORKAROUND
+
+unsigned int TxPwrTrk_OFDM_SwingTbl[TxPwrTrk_OFDM_SwingTbl_Len] = {
+	/*  +6.0dB */ 0x7f8001fe,
+	/*  +5.5dB */ 0x788001e2,
+	/*  +5.0dB */ 0x71c001c7,
+	/*  +4.5dB */ 0x6b8001ae,
+	/*  +4.0dB */ 0x65400195,
+	/*  +3.5dB */ 0x5fc0017f,
+	/*  +3.0dB */ 0x5a400169,
+	/*  +2.5dB */ 0x55400155,
+	/*  +2.0dB */ 0x50800142,
+	/*  +1.5dB */ 0x4c000130,
+	/*  +1.0dB */ 0x47c0011f,
+	/*  +0.5dB */ 0x43c0010f,
+	/*   0.0dB */ 0x40000100,
+	/*  -0.5dB */ 0x3c8000f2,
+	/*  -1.0dB */ 0x390000e4,
+	/*  -1.5dB */ 0x35c000d7,
+	/*  -2.0dB */ 0x32c000cb,
+	/*  -2.5dB */ 0x300000c0,
+	/*  -3.0dB */ 0x2d4000b5,
+	/*  -3.5dB */ 0x2ac000ab,
+	/*  -4.0dB */ 0x288000a2,
+	/*  -4.5dB */ 0x26000098,
+	/*  -5.0dB */ 0x24000090,
+	/*  -5.5dB */ 0x22000088,
+	/*  -6.0dB */ 0x20000080,
+	/*  -6.5dB */ 0x1a00006c,
+	/*  -7.0dB */ 0x1c800072,
+	/*  -7.5dB */ 0x18000060,
+	/*  -8.0dB */ 0x19800066,
+	/*  -8.5dB */ 0x15800056,
+	/*  -9.0dB */ 0x26c0005b,
+	/*  -9.5dB */ 0x14400051,
+	/* -10.0dB */ 0x24400051,
+	/* -10.5dB */ 0x1300004c,
+	/* -11.0dB */ 0x12000048,
+	/* -11.5dB */ 0x11000044,
+	/* -12.0dB */ 0x10000040
+};
+#endif
+
+#endif
+
+
+u1Byte DeltaSwingTableIdx_2GA_P_DEFAULT[DELTA_SWINGIDX_SIZE] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3
+, 4, 4, 4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+u1Byte DeltaSwingTableIdx_2GA_N_DEFAULT[DELTA_SWINGIDX_SIZE] = {0, 0, 0, 2, 2, 3, 3, 4, 4, 4
+, 4, 5, 5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11}; 
+
+
+#ifdef CONFIG_WLAN_HAL_8192EE
+u4Byte OFDMSwingTable_92E[OFDM_TABLE_SIZE_92E] = {
+	/* Index0   6  dB */ 0x7fc001ff,
+	/* Index1   5.7dB */ 0x7b4001ed,
+	/* Index2   5.4dB */ 0x774001dd,
+	/* Index3   5.1dB */ 0x734001cd,
+	/* Index4   4.8dB */ 0x6f4001bd,
+	/* Index5   4.5dB */ 0x6b8001ae,
+	/* Index6   4.2dB */ 0x67c0019f,
+	/* Index7   3.9dB */ 0x64400191,
+	/* Index8   3.6dB */ 0x60c00183,
+	/* Index9   3.3dB */ 0x5d800176,
+	/* Index10  3  dB */ 0x5a80016a,
+	/* Index11  2.7dB */ 0x5740015d,
+	/* Index12  2.4dB */ 0x54400151,
+	/* Index13  2.1dB */ 0x51800146,
+	/* Index14  1.8dB */ 0x4ec0013b,
+	/* Index15  1.5dB */ 0x4c000130,
+	/* Index16  1.2dB */ 0x49800126,
+	/* Index17  0.9dB */ 0x4700011c,
+	/* Index18  0.6dB */ 0x44800112,
+	/* Index19  0.3dB */ 0x42000108,
+	/* Index20  0  dB */ 0x40000100, // 20 This is OFDM base index
+	/* Index21 -0.3dB */ 0x3dc000f7,
+	/* Index22 -0.6dB */ 0x3bc000ef,
+	/* Index23 -0.9dB */ 0x39c000e7,
+	/* Index24 -1.2dB */ 0x37c000df,
+	/* Index25 -1.5dB */ 0x35c000d7,
+	/* Index26 -1.8dB */ 0x340000d0,
+	/* Index27 -2.1dB */ 0x324000c9,
+	/* Index28 -2.4dB */ 0x308000c2,
+	/* Index29 -2.7dB */ 0x2f0000bc,
+	/* Index30 -3  dB */ 0x2d4000b5,
+	/* Index31 -3.3dB */ 0x2bc000af,
+	/* Index32 -3.6dB */ 0x2a4000a9,
+	/* Index33 -3.9dB */ 0x28c000a3,
+	/* Index34 -4.2dB */ 0x2780009e,
+	/* Index35 -4.5dB */ 0x26000098,
+	/* Index36 -4.8dB */ 0x24c00093,
+	/* Index37 -5.1dB */ 0x2380008e,
+	/* Index38 -5.4dB */ 0x22400089,
+	/* Index39 -5.7dB */ 0x21400085,
+	/* Index40 -6  dB */ 0x20000080,
+	/* Index41 -6.3dB */ 0x1f00007c,
+	/* Index42 -6.6dB */ 0x1e000078,
+	/* Index43 -6.9dB */ 0x1d000074,
+	/* Index44 -7.2dB */ 0x1c000070,
+	/* Index45 -7.5dB */ 0x1b00006c,
+	/* Index46 -7.8dB */ 0x1a000068,
+	/* Index47 -8.1dB */ 0x19400065,
+	/* Index48 -8.4dB */ 0x18400061,
+	/* Index49 -8.7dB */ 0x1780005e,
+	/* Index50 -9  dB */ 0x16c0005b,
+	/* Index51 -9.3dB */ 0x16000058,
+	/* Index52 -9.6dB */ 0x15400055,
+	/* Index53 -9.9dB */ 0x14800052
+};
+u1Byte CCKSwingTable_Ch1_Ch13_92E[CCK_TABLE_SIZE_92E][8] = {
+	/* Index0    0  dB */    {0x36, 0x34 , 0x2E , 0x26 , 0x1C , 0x12 , 0x08 , 0x04},
+	/* Index1   -0.3dB */    {0x34, 0x32 , 0x2C , 0x25 , 0x1B , 0x11 , 0x08 , 0x04},
+	/* Index2   -0.6dB */    {0x32, 0x30 , 0x2B , 0x23 , 0x1A , 0x11 , 0x07 , 0x04},
+	/* Index3   -0.9dB */    {0x31, 0x2F , 0x29 , 0x22 , 0x19 , 0x10 , 0x07 , 0x04},
+	/* Index4   -1.2dB */    {0x2F, 0x2D , 0x28 , 0x21 , 0x18 , 0x10 , 0x07 , 0x03},
+	/* Index5   -1.5dB */    {0x2D, 0x2C , 0x27 , 0x20 , 0x18 , 0x0F , 0x07 , 0x03},
+	/* Index6   -1.8dB */    {0x2C, 0x2A , 0x25 , 0x1F , 0x17 , 0x0F , 0x06 , 0x03},
+	/* Index7   -2.1dB */    {0x2A, 0x29 , 0x24 , 0x1E , 0x16 , 0x0E , 0x06 , 0x03},
+	/* Index8   -2.4dB */    {0x29, 0x27 , 0x23 , 0x1D , 0x15 , 0x0E , 0x06 , 0x03},
+	/* Index9   -2.7dB */    {0x27, 0x26 , 0x22 , 0x1C , 0x14 , 0x0D , 0x06 , 0x03},
+	/* Index10  -3  dB */    {0x26, 0x25 , 0x20 , 0x1B , 0x14 , 0x0D , 0x06 , 0x03},
+	/* Index11  -3.3dB */    {0x25, 0x23 , 0x1F , 0x1A , 0x13 , 0x0C , 0x05 , 0x03},
+	/* Index12  -3.6dB */    {0x24, 0x22 , 0x1E , 0x19 , 0x12 , 0x0C , 0x05 , 0x03},
+	/* Index13  -3.9dB */    {0x22, 0x21 , 0x1D , 0x18 , 0x12 , 0x0B , 0x05 , 0x03},
+	/* Index14  -4.2dB */    {0x21, 0x20 , 0x1C , 0x17 , 0x11 , 0x0B , 0x05 , 0x02},
+	/* Index15  -4.5dB */    {0x20, 0x1F , 0x1B , 0x17 , 0x11 , 0x0B , 0x05 , 0x02},
+	/* Index16  -4.8dB */    {0x1F, 0x1E , 0x1A , 0x16 , 0x10 , 0x0A , 0x05 , 0x02},
+	/* Index17  -5.1dB */    {0x1E, 0x1D , 0x1A , 0x15 , 0x10 , 0x0A , 0x04 , 0x02},
+	/* Index18  -5.4dB */    {0x1D, 0x1C , 0x19 , 0x14 , 0x0F , 0x0A , 0x04 , 0x02},
+	/* Index19  -5.7dB */    {0x1C, 0x1B , 0x18 , 0x14 , 0x0E , 0x09 , 0x04 , 0x02},
+	/* Index20  -6.0dB */    {0x1B, 0x1A , 0x17 , 0x13 , 0x0E , 0x09 , 0x04 , 0x02}, // 20 This is CCK base index
+	/* Index21  -6.3dB */    {0x1A, 0x19 , 0x16 , 0x12 , 0x0E , 0x09 , 0x04 , 0x02},
+	/* Index22  -6.6dB */    {0x19, 0x18 , 0x15 , 0x12 , 0x0D , 0x08 , 0x04 , 0x02},
+	/* Index23  -6.9dB */    {0x18, 0x17 , 0x15 , 0x11 , 0x0D , 0x08 , 0x04 , 0x02},
+	/* Index24  -7.2dB */    {0x18, 0x17 , 0x14 , 0x11 , 0x0C , 0x08 , 0x03 , 0x02},
+	/* Index25  -7.5dB */    {0x17, 0x16 , 0x13 , 0x10 , 0x0C , 0x08 , 0x03 , 0x02},
+	/* Index26  -7.8dB */    {0x16, 0x15 , 0x13 , 0x0F , 0x0B , 0x07 , 0x03 , 0x02},
+	/* Index27  -8.1dB */    {0x15, 0x14 , 0x12 , 0x0F , 0x0B , 0x07 , 0x03 , 0x02},
+	/* Index28  -8.4dB */    {0x14, 0x14 , 0x11 , 0x0E , 0x0B , 0x07 , 0x03 , 0x02},
+	/* Index29  -8.7dB */    {0x14, 0x13 , 0x11 , 0x0E , 0x0A , 0x07 , 0x03 , 0x01},
+	/* Index30  -9.0dB */    {0x13, 0x12 , 0x10 , 0x0D , 0x0A , 0x06 , 0x03 , 0x01}, // 30 This is hp CCK base index
+	/* Index31  -9.3dB */    {0x12, 0x12 , 0x0F , 0x0D , 0x0A , 0x06 , 0x03 , 0x01},
+	/* Index32  -9.6dB */    {0x12, 0x11 , 0x0F , 0x0D , 0x09 , 0x06 , 0x03 , 0x01},
+	/* Index33  -9.9dB */    {0x11, 0x11 , 0x0F , 0x0C , 0x09 , 0x06 , 0x03 , 0x01},
+	/* Index34 -10.2dB */    {0x11, 0x11 , 0x0E , 0x0C , 0x09 , 0x06 , 0x02 , 0x01},
+	/* Index35 -10.5dB */    {0x10, 0x0F , 0x0E , 0x0B , 0x08 , 0x05 , 0x02 , 0x01},
+	/* Index36 -10.8dB */    {0x10, 0x0F , 0x0D , 0x0B , 0x08 , 0x05 , 0x02 , 0x01},
+	/* Index37 -11.1dB */    {0x0F, 0x0E , 0x0D , 0x0A , 0x08 , 0x05 , 0x02 , 0x01},
+	/* Index38 -11.4dB */    {0x0E, 0x0E , 0x0C , 0x0A , 0x07 , 0x05 , 0x02 , 0x01},
+	/* Index39 -11.7dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x07 , 0x05 , 0x02 , 0x01},
+	/* Index40 -12  dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x07 , 0x05 , 0x02 , 0x01},
+	/* Index41 -12.3dB */    {0x0D, 0x0D , 0x0B , 0x09 , 0x07 , 0x04 , 0x02 , 0x01},
+	/* Index42 -12.6dB */    {0x0D, 0x0C , 0x0B , 0x09 , 0x07 , 0x04 , 0x02 , 0x01},
+	/* Index43 -12.9dB */    {0x0C, 0x0C , 0x0A , 0x09 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index44 -13.2dB */    {0x0C, 0x0B , 0x0A , 0x08 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index45 -13.5dB */    {0x0B, 0x0B , 0x0A , 0x08 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index46 -13.8dB */    {0x0B, 0x0B , 0x09 , 0x08 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index47 -14.1dB */    {0x0B, 0x0A , 0x09 , 0x07 , 0x06 , 0x04 , 0x02 , 0x01},
+	/* Index48 -14.4dB */    {0x0A, 0x0A , 0x09 , 0x07 , 0x05 , 0x03 , 0x02 , 0x01},
+	/* Index49 -14.7dB */    {0x0A, 0x0A , 0x08 , 0x07 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index50 -15  dB */    {0x0A, 0x09 , 0x08 , 0x07 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index51 -15.3dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index52 -15.6dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x05 , 0x03 , 0x01 , 0x01},
+	/* Index53 -15.9dB */    {0x09, 0x08 , 0x07 , 0x06 , 0x04 , 0x03 , 0x01 , 0x01}
+};
+u1Byte CCKSwingTable_Ch14_92E[CCK_TABLE_SIZE_92E][8] = {
+	/* Index0    0  dB */    {0x36, 0x34 , 0x2E , 0x26 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index1   -0.3dB */    {0x34, 0x32 , 0x2C , 0x25 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index2   -0.6dB */    {0x32, 0x30 , 0x2B , 0x23 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index3   -0.9dB */    {0x31, 0x2F , 0x29 , 0x22 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index4   -1.2dB */    {0x2F, 0x2D , 0x28 , 0x21 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index5   -1.5dB */    {0x2D, 0x2C , 0x27 , 0x20 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index6   -1.8dB */    {0x2C, 0x2A , 0x25 , 0x1F , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index7   -2.1dB */    {0x2A, 0x29 , 0x24 , 0x1E , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index8   -2.4dB */    {0x29, 0x27 , 0x23 , 0x1D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index9   -2.7dB */    {0x27, 0x26 , 0x22 , 0x1C , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index10  -3  dB */    {0x26, 0x25 , 0x20 , 0x1B , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index11  -3.3dB */    {0x25, 0x23 , 0x1F , 0x1A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index12  -3.6dB */    {0x24, 0x22 , 0x1E , 0x19 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index13  -3.9dB */    {0x22, 0x21 , 0x1D , 0x18 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index14  -4.2dB */    {0x21, 0x20 , 0x1C , 0x17 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index15  -4.5dB */    {0x20, 0x1F , 0x1B , 0x17 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index16  -4.8dB */    {0x1F, 0x1E , 0x1A , 0x16 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index17  -5.1dB */    {0x1E, 0x1D , 0x1A , 0x15 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index18  -5.4dB */    {0x1D, 0x1C , 0x19 , 0x14 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index19  -5.7dB */    {0x1C, 0x1B , 0x18 , 0x14 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index20  -6  dB */     {0x1B, 0x1A , 0x17 , 0x13 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index21  -6.3dB */    {0x1A, 0x19 , 0x16 , 0x12 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index22  -6.6dB */    {0x19, 0x18 , 0x15 , 0x12 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index23  -6.9dB */    {0x18, 0x17 , 0x15 , 0x11 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index24  -7.2dB */    {0x18, 0x17 , 0x14 , 0x11 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index25  -7.5dB */    {0x17, 0x16 , 0x13 , 0x10 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index26  -7.8dB */    {0x16, 0x15 , 0x13 , 0x0F , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index27  -8.1dB */    {0x15, 0x14 , 0x12 , 0x0F , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index28  -8.4dB */    {0x14, 0x14 , 0x11 , 0x0E , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index29  -8.7dB */    {0x14, 0x13 , 0x11 , 0x0E , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index30  -9  dB */    {0x13, 0x12 , 0x10 , 0x0D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index31  -9.3dB */    {0x12, 0x12 , 0x0F , 0x0D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index32  -9.6dB */    {0x12, 0x11 , 0x0F , 0x0D , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index33  -9.9dB */    {0x11, 0x11 , 0x0F , 0x0C , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index34 -10.2dB */    {0x11, 0x11 , 0x0E , 0x0C , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index35 -10.5dB */    {0x10, 0x0F , 0x0E , 0x0B , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index36 -10.8dB */    {0x10, 0x0F , 0x0D , 0x0B , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index37 -11.1dB */    {0x0F, 0x0E , 0x0D , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index38 -11.4dB */    {0x0E, 0x0E , 0x0C , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index39 -11.7dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index40 -12  dB */    {0x0E, 0x0D , 0x0C , 0x0A , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index41 -12.3dB */    {0x0D, 0x0D , 0x0B , 0x09 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index42 -12.6dB */    {0x0D, 0x0C , 0x0B , 0x09 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index43 -12.9dB */    {0x0C, 0x0C , 0x0A , 0x09 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index44 -13.2dB */    {0x0C, 0x0B , 0x0A , 0x08 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index45 -13.5dB */    {0x0B, 0x0B , 0x0A , 0x08 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index46 -13.8dB */    {0x0B, 0x0B , 0x09 , 0x08 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index47 -14.1dB */    {0x0B, 0x0A , 0x09 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index48 -14.4dB */    {0x0A, 0x0A , 0x09 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index49 -14.7dB */    {0x0A, 0x0A , 0x08 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index50 -15  dB */    {0x0A, 0x09 , 0x08 , 0x07 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index51 -15.3dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index52 -15.6dB */    {0x09, 0x09 , 0x08 , 0x06 , 0x00 , 0x00 , 0x00 , 0x00},
+	/* Index53 -15.9dB */    {0x09, 0x08 , 0x07 , 0x06 , 0x00 , 0x00 , 0x00 , 0x00}
+};
+#endif
+
+#if(RTL8814A_SUPPORT == 1)
+u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE] =
+{
+	0x081, // 0,  -12.0dB
+	0x088, // 1,  -11.5dB
+	0x090, // 2,  -11.0dB
+	0x099, // 3,  -10.5dB
+	0x0A2, // 4,  -10.0dB
+	0x0AC, // 5,  -9.5dB
+	0x0B6, // 6,  -9.0dB
+	0x0C0, // 7,  -8.5dB
+	0x0CC, // 8,  -8.0dB
+	0x0D8, // 9,  -7.5dB
+	0x0E5, // 10, -7.0dB
+	0x0F2, // 11, -6.5dB
+	0x101, // 12, -6.0dB
+	0x110, // 13, -5.5dB
+	0x120, // 14, -5.0dB
+	0x131, // 15, -4.5dB
+	0x143, // 16, -4.0dB
+	0x156, // 17, -3.5dB
+	0x16A, // 18, -3.0dB
+	0x180, // 19, -2.5dB
+	0x197, // 20, -2.0dB
+	0x1AF, // 21, -1.5dB
+	0x1C8, // 22, -1.0dB
+	0x1E3, // 23, -0.5dB
+	0x200, // 24, +0  dB
+	0x21E, // 25, +0.5dB
+	0x23E, // 26, +1.0dB
+	0x261, // 27, +1.5dB
+	0x285, // 28, +2.0dB
+	0x2AB, // 29, +2.5dB
+	0x2D3, // 30, +3.0dB
+	0x2FE, // 31, +3.5dB
+	0x32B, // 32, +4.0dB
+	0x35C, // 33, +4.5dB
+	0x38E, // 34, +5.0dB
+	0x3C4, // 35, +5.5dB
+	0x3FE  // 36, +6.0dB	
+};
+#elif(ODM_IC_11AC_SERIES_SUPPORT)
+u4Byte OFDMSwingTable_8812[OFDM_TABLE_SIZE_8812] = {	
+	0x3FE, // 0,  (6dB) 
+	0x3C4, // 1,  (5.5dB) 
+	0x38E, // 2,  (5dB)
+	0x35C, // 3,  (4.5dB)
+	0x32B, // 4,  (4dB)
+	0x2FE, // 5,  (3.5dB)
+	0x2D3, // 6,  (3dB)
+	0x2AB, // 7,  (2.5dB)
+	0x285, // 8,  (2dB)
+	0x261, // 9,  (1.5dB
+	0x23E, // 10, (1dB)
+	0x21E, // 11, (0.5dB)
+	0x200, // 12, (0dB)		8814 int PA 2G default
+	0x1E3, // 13, (-0.5dB)
+	0x1C8, // 14, (-1dB)
+	0x1AF, // 15, (-1.5dB)
+	0x197, // 16, (-2dB)
+	0x180, // 17, (-2.5dB)
+	0x16A, // 18, (-3dB)		8812 / 8814 int PA 5G / 8814 ext PA 2G5G default
+	0x156, // 19, (-3.5dB)
+	0x143, // 20, (-4dB)		8812 HP default
+	0x131, // 21, (-4.5dB)
+	0x120, // 22, (-5dB)
+	0x110, // 23, (-5.5dB)
+	0x101, // 24, (-6dB)
+	0x0F2, // 25, (-6.5dB)
+	0x0E5, // 26, (-7dB)
+	0x0D8, // 27, (-7.5dB)
+	0x0CC, // 28, (-8dB)
+	0x0C0, // 29, (-8.5dB)
+	0x0B6, // 30, (-9dB)
+	0x0AC, // 31, (-9.5dB)
+	0x0A2, // 32, (-10dB)
+	0x099, // 33, (-10.5dB)
+	0x090, // 34, (-11dB)
+	0x088, // 35, (-11.5dB)
+	0x081, // 36, (-12dB)	
+	0x079, // 37, (-12.5dB)
+	0x072, // 38, (-13dB)
+	0x06c, // 39, (-13.5dB)
+	0x066, // 40, (-14dB)
+	0x060, // 41, (-14.5dB)
+	0x05B  // 42, (-15dB)
+};
+#endif
+
+//#endif
+//3============================================================
+//3 Tx Power Tracking
+//3============================================================
+
+VOID
+odm_TXPowerTrackingInit(
+	IN	PVOID		pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_IC_11N_SERIES)))
+		return;
+#endif
+
+	odm_TXPowerTrackingThermalMeterInit(pDM_Odm);
+}	
+
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN	PVOID		pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	u1Byte p;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO      	pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	
+	pMgntInfo->bTXPowerTracking = TRUE;
+	pHalData->TXPowercount       = 0;
+	pHalData->bTXPowerTrackingInit = FALSE;
+
+	if(pDM_Odm->mp_mode == FALSE)
+		pHalData->TxPowerTrackControl = TRUE;
+	ODM_RT_TRACE(pDM_Odm,COMP_POWER_TRACKING, DBG_LOUD, ("pMgntInfo->bTXPowerTracking = %d\n", pMgntInfo->bTXPowerTracking));
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#ifdef CONFIG_RTL8188E
+	{
+		pDM_Odm->RFCalibrateInfo.bTXPowerTracking = _TRUE;
+		pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
+		pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = _FALSE;
+
+		if(pDM_Odm->mp_mode == FALSE)
+			pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
+		
+		MSG_8192C("pDM_Odm TxPowerTrackControl = %d\n", pDM_Odm->RFCalibrateInfo.TxPowerTrackControl);
+	}
+	#else
+	{
+		PADAPTER		Adapter = pDM_Odm->Adapter;
+		HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+		struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+		//if(IS_HARDWARE_TYPE_8192C(pHalData))
+		{
+			pdmpriv->bTXPowerTracking = _TRUE;
+			pdmpriv->TXPowercount = 0;
+			pdmpriv->bTXPowerTrackingInit = _FALSE;
+
+			if(pDM_Odm->mp_mode == FALSE)		//for mp driver, turn off txpwrtracking as default
+				pdmpriv->TxPowerTrackControl = _TRUE;
+
+		}
+		MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
+	
+	}	
+	#endif//endif (CONFIG_RTL8188E==1)	
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+
+	#ifdef RTL8188E_SUPPORT
+	{
+		pDM_Odm->RFCalibrateInfo.bTXPowerTracking = _TRUE;
+		pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
+		pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = _FALSE;
+		pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 0;
+	}
+	#endif
+#endif
+
+       pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = TRUE;
+	pDM_Odm->RFCalibrateInfo.DeltaPowerIndex = 0;
+	pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast = 0;
+	pDM_Odm->RFCalibrateInfo.PowerIndexOffset = 0;
+	pDM_Odm->RFCalibrateInfo.ThermalValue = 0;
+	pRFCalibrateInfo->DefaultOfdmIndex = 28;
+
+	
+#if RTL8188E_SUPPORT	
+	pRFCalibrateInfo->DefaultCckIndex = 20;	// -6 dB	
+#elif RTL8192E_SUPPORT
+	pRFCalibrateInfo->DefaultCckIndex = 8;	// -12 dB
+#endif
+	pRFCalibrateInfo->BbSwingIdxOfdmBase = pRFCalibrateInfo->DefaultOfdmIndex;
+	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
+	pDM_Odm->RFCalibrateInfo.CCK_index = pRFCalibrateInfo->DefaultCckIndex;
+	for(p = 0; p < MAX_RF_PATH; p++)
+	{
+ 	pDM_Odm->RFCalibrateInfo.OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;		
+	pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->DefaultOfdmIndex;
+	pRFCalibrateInfo->KfreeOffset[p] = 0; // for 8814 kfree
+	}
+	pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->DefaultCckIndex;
+	
+}
+
+
+VOID
+ODM_TXPowerTrackingCheck(
+	IN	PVOID		pDM_VOID
+	)
+{
+	// 
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+
+
+	if (!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))
+		return;
+
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+			odm_TXPowerTrackingCheckMP(pDM_Odm);
+			break;
+
+		case	ODM_CE:
+			odm_TXPowerTrackingCheckCE(pDM_Odm);
+			break;
+
+		case	ODM_AP:
+			odm_TXPowerTrackingCheckAP(pDM_Odm);		
+			break;		
+		default:
+			break;
+	}
+
+}
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN	PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	#if(RTL8188E_SUPPORT==1)
+
+	//if(!pMgntInfo->bTXPowerTracking /*|| (!pdmpriv->TxPowerTrackControl && pdmpriv->bAPKdone)*/)
+	if(!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))
+	{
+		return;
+	}
+
+	if(!pDM_Odm->RFCalibrateInfo.TM_Trigger)		//at least delay 1 sec
+	{
+		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
+		ODM_SetRFReg(pDM_Odm, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		//DBG_8192C("Trigger 92C Thermal Meter!!\n");
+		
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 1;
+		return;
+		
+	}
+	else
+	{
+		//DBG_8192C("Schedule TxPowerTracking direct call!!\n");
+		odm_TXPowerTrackingCallback_ThermalMeter_8188E(Adapter);
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 0;
+	}
+	#endif
+	
+#endif	
+}
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN	PVOID		pDM_VOID 
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	if (ODM_CheckPowerStatus(Adapter) == FALSE)
+		return;
+
+	if(!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE)
+		odm_TXPowerTrackingThermalMeterCheck(Adapter);
+#endif
+	
+}
+
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+
+#if ((RTL8188E_SUPPORT == 1) || (RTL8192E_SUPPORT == 1) || (RTL8812A_SUPPORT == 1) || (RTL8881A_SUPPORT == 1) || (RTL8814A_SUPPORT == 1))	
+	if (pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8812|ODM_RTL8881A|ODM_RTL8814A))
+		ODM_TXPowerTrackingCallback_ThermalMeter(pDM_Odm);
+	else
+#endif
+	{
+	}
+#endif	
+
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	)
+{
+#ifndef AP_BUILD_WORKAROUND
+#if (HAL_CODE_BASE==RTL8192_C)
+	PMGNT_INFO      		pMgntInfo = &Adapter->MgntInfo;
+	//HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	static u1Byte			TM_Trigger = 0;
+	//u1Byte					TxPowerCheckCnt = 5;	//10 sec
+
+	if(!pMgntInfo->bTXPowerTracking /*|| (!pHalData->TxPowerTrackControl && pHalData->bAPKdone)*/)
+	{
+		return;
+	}
+
+	if(!TM_Trigger)		//at least delay 1 sec
+	{
+		if (IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_8812(Adapter))
+			PHY_SetRFReg(Adapter, RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);
+		else
+			PHY_SetRFReg(Adapter, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger 92C Thermal Meter!!\n"));
+		
+		TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));		
+		odm_TXPowerTrackingDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
+		TM_Trigger = 0;
+	}
+#endif
+#endif
+}
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.h
new file mode 100644
index 000000000..8c7c2867e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ap.h
@@ -0,0 +1,314 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMPOWERTRACKING_H__
+#define    __PHYDMPOWERTRACKING_H__
+
+#define POWRTRACKING_VERSION	"1.1"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+#ifdef RTK_AC_SUPPORT
+#define ODM_IC_11AC_SERIES_SUPPORT		1
+#else
+#define ODM_IC_11AC_SERIES_SUPPORT		0
+#endif
+#else
+#define ODM_IC_11AC_SERIES_SUPPORT		1
+#endif
+
+#define		DPK_DELTA_MAPPING_NUM	13
+#define		index_mapping_HP_NUM	15
+#define		DELTA_SWINGIDX_SIZE     30
+#define		BAND_NUM 				3
+#define		MAX_RF_PATH	4
+#define 		TXSCALE_TABLE_SIZE 		37
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+#define IQK_BB_REG_NUM_MAX	10
+
+#define IQK_BB_REG_NUM		9
+
+#define HP_THERMAL_NUM		8
+
+#define AVG_THERMAL_NUM		8
+#define IQK_Matrix_REG_NUM	8
+//#define IQK_Matrix_Settings_NUM	1+24+21
+#define IQK_Matrix_Settings_NUM	(14+24+21) // Channels_2_4G_NUM + Channels_5G_20M_NUM + Channels_5G
+
+#if !defined(_OUTSRC_COEXIST)
+#define	OFDM_TABLE_SIZE_92D 	43
+#define	OFDM_TABLE_SIZE 	37
+#define	CCK_TABLE_SIZE		33
+#define	CCK_TABLE_SIZE_88F	21
+
+
+
+//#define	OFDM_TABLE_SIZE_92E 	54
+//#define 	CCK_TABLE_SIZE_92E     	54
+extern	u4Byte OFDMSwingTable[OFDM_TABLE_SIZE_92D];
+extern	u1Byte CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8];
+
+
+extern	u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE_92D];
+extern	u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14_New [CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch1_Ch14_88F[CCK_TABLE_SIZE_88F][16];
+
+#endif
+
+#define	ODM_OFDM_TABLE_SIZE 	37
+#define	ODM_CCK_TABLE_SIZE		33
+// <20140613, YuChen> In case fail to read TxPowerTrack.txt, we use the table of 88E as the default table.
+extern u1Byte DeltaSwingTableIdx_2GA_P_DEFAULT[DELTA_SWINGIDX_SIZE];
+extern u1Byte DeltaSwingTableIdx_2GA_N_DEFAULT[DELTA_SWINGIDX_SIZE]; 
+
+
+//extern	u4Byte OFDMSwingTable_92E[OFDM_TABLE_SIZE_92E];
+//extern	u1Byte CCKSwingTable_Ch1_Ch13_92E[CCK_TABLE_SIZE_92E][8];
+//extern	u1Byte CCKSwingTable_Ch14_92E[CCK_TABLE_SIZE_92E][8];
+
+#ifdef CONFIG_WLAN_HAL_8192EE
+#define	OFDM_TABLE_SIZE_92E 	54
+#define	CCK_TABLE_SIZE_92E     	54
+extern	u4Byte OFDMSwingTable_92E[OFDM_TABLE_SIZE_92E];
+extern	u1Byte CCKSwingTable_Ch1_Ch13_92E[CCK_TABLE_SIZE_92E][8];
+extern	u1Byte CCKSwingTable_Ch14_92E[CCK_TABLE_SIZE_92E][8];
+#endif
+
+#define	OFDM_TABLE_SIZE_8812 	43
+#define	AVG_THERMAL_NUM_8812	4
+
+#if(RTL8814A_SUPPORT == 1)
+extern u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE];
+#elif(ODM_IC_11AC_SERIES_SUPPORT)
+extern unsigned int OFDMSwingTable_8812[OFDM_TABLE_SIZE_8812];
+#endif
+
+#define dm_CheckTXPowerTracking 	ODM_TXPowerTrackingCheck
+
+typedef struct _IQK_MATRIX_REGS_SETTING{
+	BOOLEAN 	bIQKDone;
+	s4Byte		Value[1][IQK_Matrix_REG_NUM];
+}IQK_MATRIX_REGS_SETTING,*PIQK_MATRIX_REGS_SETTING;
+
+typedef struct ODM_RF_Calibration_Structure
+{
+	//for tx power tracking
+	
+	u4Byte	RegA24; // for TempCCK
+	s4Byte	RegE94;
+	s4Byte 	RegE9C;
+	s4Byte	RegEB4;
+	s4Byte	RegEBC;	
+
+	//u1Byte bTXPowerTracking;
+	u1Byte  	TXPowercount;
+	BOOLEAN bTXPowerTrackingInit; 
+	BOOLEAN bTXPowerTracking;
+	u1Byte  	TxPowerTrackControl; //for mp mode, turn off txpwrtracking as default
+	u1Byte  	TM_Trigger;
+    	u1Byte  	InternalPA5G[2];	//pathA / pathB
+	
+	u1Byte  	ThermalMeter[2];    // ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u1Byte  	ThermalValue;
+	u1Byte  	ThermalValue_LCK;
+	u1Byte  	ThermalValue_IQK;
+	u1Byte	ThermalValue_DPK;		
+	u1Byte	ThermalValue_AVG[AVG_THERMAL_NUM];
+	u1Byte	ThermalValue_AVG_index;		
+	u1Byte	ThermalValue_RxGain;
+	u1Byte	ThermalValue_Crystal;
+	u1Byte	ThermalValue_DPKstore;
+	u1Byte	ThermalValue_DPKtrack;
+	BOOLEAN	TxPowerTrackingInProgress;
+	BOOLEAN	bDPKenable;
+	
+	BOOLEAN	bReloadtxpowerindex;	
+	u1Byte 	bRfPiEnable;
+	u4Byte 	TXPowerTrackingCallbackCnt; //cosa add for debug
+
+	u1Byte 	bCCKinCH14;
+	u1Byte 	CCK_index;
+	u1Byte 	OFDM_index[MAX_RF_PATH];
+	s1Byte	PowerIndexOffset;
+	s1Byte	DeltaPowerIndex;
+	s1Byte	DeltaPowerIndexLast;	
+	BOOLEAN bTxPowerChanged;
+		
+	u1Byte 	ThermalValue_HP[HP_THERMAL_NUM];
+	u1Byte 	ThermalValue_HP_index;
+	IQK_MATRIX_REGS_SETTING IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
+	BOOLEAN bNeedIQK;
+	u1Byte	Delta_IQK;
+	u1Byte	Delta_LCK;
+	u1Byte  DeltaSwingTableIdx_2GCCKA_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKA_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKB_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKB_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKC_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKC_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKD_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKD_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GB_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GB_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GC_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GC_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GD_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GD_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GA_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GA_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GB_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GB_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GC_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GC_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GD_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GD_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_P_8188E[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_N_8188E[DELTA_SWINGIDX_SIZE];
+	
+	u1Byte			BbSwingIdxOfdm[MAX_RF_PATH];
+	u1Byte			BbSwingIdxOfdmCurrent;
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))	
+	u1Byte			BbSwingIdxOfdmBase[MAX_RF_PATH];
+#else
+	u1Byte			BbSwingIdxOfdmBase;
+#endif
+	BOOLEAN			BbSwingFlagOfdm;
+	u1Byte			BbSwingIdxCck;
+	u1Byte			BbSwingIdxCckCurrent;
+	u1Byte			BbSwingIdxCckBase;
+	u1Byte			DefaultOfdmIndex;
+	u1Byte			DefaultCckIndex;	
+	BOOLEAN			BbSwingFlagCck;
+	
+	s1Byte			Absolute_OFDMSwingIdx[MAX_RF_PATH];   
+	s1Byte			Remnant_OFDMSwingIdx[MAX_RF_PATH];   
+	s1Byte			Remnant_CCKSwingIdx;
+	s1Byte			Modify_TxAGC_Value;       /*Remnat compensate value at TxAGC */
+	BOOLEAN			Modify_TxAGC_Flag_PathA;
+	BOOLEAN			Modify_TxAGC_Flag_PathB;
+	BOOLEAN			Modify_TxAGC_Flag_PathC;
+	BOOLEAN			Modify_TxAGC_Flag_PathD;
+	BOOLEAN			Modify_TxAGC_Flag_PathA_CCK;
+	
+	s1Byte			KfreeOffset[MAX_RF_PATH];
+    
+	//--------------------------------------------------------------------//	
+	
+	//for IQK	
+	u4Byte 	RegC04;
+	u4Byte 	Reg874;
+	u4Byte 	RegC08;
+	u4Byte 	RegB68;
+	u4Byte 	RegB6C;
+	u4Byte 	Reg870;
+	u4Byte 	Reg860;
+	u4Byte 	Reg864;
+	
+	BOOLEAN	bIQKInitialized;
+	BOOLEAN bLCKInProgress;
+	BOOLEAN	bAntennaDetected;
+	u4Byte	ADDA_backup[IQK_ADDA_REG_NUM];
+	u4Byte	IQK_MAC_backup[IQK_MAC_REG_NUM];
+	u4Byte	IQK_BB_backup_recover[9];
+	u4Byte	IQK_BB_backup[IQK_BB_REG_NUM];	
+
+	//for APK
+	u4Byte 	APKoutput[2][2]; //path A/B; output1_1a/output1_2a
+	u1Byte 	bAPKdone;
+	u1Byte 	bAPKThermalMeterIgnore;
+	u1Byte 	bDPdone;
+	u1Byte 	bDPPathAOK;
+	u1Byte 	bDPPathBOK;
+
+	/*Add by Yuchen for Kfree Phydm*/
+	u1Byte			RegRfKFreeEnable;	/*for registry*/
+	u1Byte			RfKFreeEnable;		/*for efuse enable check*/
+	
+}ODM_RF_CAL_T,*PODM_RF_CAL_T;
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+ODM_TXPowerTrackingCheck(
+	IN	PVOID		pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingInit(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN	PVOID		pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN	PVOID		pDM_VOID
+	);
+
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+
+VOID 
+odm_TXPowerTrackingCallbackThermalMeter92C(
+            IN PADAPTER	Adapter
+            );
+
+VOID
+odm_TXPowerTrackingCallbackRXGainThermalMeter92D(
+	IN PADAPTER 	Adapter
+	);
+
+VOID
+odm_TXPowerTrackingCallbackThermalMeter92D(
+            IN PADAPTER	Adapter
+            );
+
+VOID
+odm_TXPowerTrackingDirectCall92C(
+            IN	PADAPTER		Adapter
+            );
+
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	);
+
+#endif
+
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.c
new file mode 100644
index 000000000..b8fe78407
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.c
@@ -0,0 +1,670 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*============================================================	*/
+/* include files												*/
+/*============================================================	*/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+//============================================================
+// Global var
+//============================================================
+
+u4Byte	OFDMSwingTable[OFDM_TABLE_SIZE] = {
+	0x7f8001fe,	// 0, +6.0dB
+	0x788001e2,	// 1, +5.5dB
+	0x71c001c7,	// 2, +5.0dB
+	0x6b8001ae,	// 3, +4.5dB
+	0x65400195,	// 4, +4.0dB
+	0x5fc0017f,	// 5, +3.5dB
+	0x5a400169,	// 6, +3.0dB
+	0x55400155,	// 7, +2.5dB
+	0x50800142,	// 8, +2.0dB
+	0x4c000130,	// 9, +1.5dB
+	0x47c0011f,	// 10, +1.0dB
+	0x43c0010f,	// 11, +0.5dB
+	0x40000100,	// 12, +0dB
+	0x3c8000f2,	// 13, -0.5dB
+	0x390000e4,	// 14, -1.0dB
+	0x35c000d7,	// 15, -1.5dB
+	0x32c000cb,	// 16, -2.0dB
+	0x300000c0,	// 17, -2.5dB
+	0x2d4000b5,	// 18, -3.0dB
+	0x2ac000ab,	// 19, -3.5dB
+	0x288000a2,	// 20, -4.0dB
+	0x26000098,	// 21, -4.5dB
+	0x24000090,	// 22, -5.0dB
+	0x22000088,	// 23, -5.5dB
+	0x20000080,	// 24, -6.0dB
+	0x1e400079,	// 25, -6.5dB
+	0x1c800072,	// 26, -7.0dB
+	0x1b00006c,	// 27. -7.5dB
+	0x19800066,	// 28, -8.0dB
+	0x18000060,	// 29, -8.5dB
+	0x16c0005b,	// 30, -9.0dB
+	0x15800056,	// 31, -9.5dB
+	0x14400051,	// 32, -10.0dB
+	0x1300004c,	// 33, -10.5dB
+	0x12000048,	// 34, -11.0dB
+	0x11000044,	// 35, -11.5dB
+	0x10000040,	// 36, -12.0dB
+};
+
+u1Byte	CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB 
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB <== default
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB 
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 22, -11.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	// 23, -11.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	// 24, -12.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	// 25, -12.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	// 26, -13.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	// 27, -13.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	// 28, -14.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	// 29, -14.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	// 30, -15.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	// 31, -15.5dB
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	// 32, -16.0dB
+};
+
+
+u1Byte	CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB 
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB  
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB  <== default
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB 
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB  
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 22, -11.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 23, -11.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 24, -12.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	// 25, -12.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 26, -13.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 27, -13.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 28, -14.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 29, -14.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
+};
+
+
+u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE] = {
+	0x0b40002d, // 0,  -15.0dB	
+	0x0c000030, // 1,  -14.5dB
+	0x0cc00033, // 2,  -14.0dB
+	0x0d800036, // 3,  -13.5dB
+	0x0e400039, // 4,  -13.0dB    
+	0x0f00003c, // 5,  -12.5dB
+	0x10000040, // 6,  -12.0dB
+	0x11000044, // 7,  -11.5dB
+	0x12000048, // 8,  -11.0dB
+	0x1300004c, // 9,  -10.5dB
+	0x14400051, // 10, -10.0dB
+	0x15800056, // 11, -9.5dB
+	0x16c0005b, // 12, -9.0dB
+	0x18000060, // 13, -8.5dB
+	0x19800066, // 14, -8.0dB
+	0x1b00006c, // 15, -7.5dB
+	0x1c800072, // 16, -7.0dB
+	0x1e400079, // 17, -6.5dB
+	0x20000080, // 18, -6.0dB
+	0x22000088, // 19, -5.5dB
+	0x24000090, // 20, -5.0dB
+	0x26000098, // 21, -4.5dB
+	0x288000a2, // 22, -4.0dB
+	0x2ac000ab, // 23, -3.5dB
+	0x2d4000b5, // 24, -3.0dB
+	0x300000c0, // 25, -2.5dB
+	0x32c000cb, // 26, -2.0dB
+	0x35c000d7, // 27, -1.5dB
+	0x390000e4, // 28, -1.0dB
+	0x3c8000f2, // 29, -0.5dB
+	0x40000100, // 30, +0dB
+	0x43c0010f, // 31, +0.5dB
+	0x47c0011f, // 32, +1.0dB
+	0x4c000130, // 33, +1.5dB
+	0x50800142, // 34, +2.0dB
+	0x55400155, // 35, +2.5dB
+	0x5a400169, // 36, +3.0dB
+	0x5fc0017f, // 37, +3.5dB
+	0x65400195, // 38, +4.0dB
+	0x6b8001ae, // 39, +4.5dB
+	0x71c001c7, // 40, +5.0dB
+	0x788001e2, // 41, +5.5dB
+	0x7f8001fe  // 42, +6.0dB
+};               
+
+
+u1Byte CCKSwingTable_Ch1_Ch14_88F[CCK_TABLE_SIZE_88F][16] = {
+{0x44, 0x42, 0x3C, 0x33, 0x28, 0x1C, 0x13, 0x0B, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-16dB*/
+{0x48, 0x46, 0x3F, 0x36, 0x2A, 0x1E, 0x14, 0x0B, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-15.5dB*/
+{0x4D, 0x4A, 0x43, 0x39, 0x2C, 0x20, 0x15, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-15dB*/
+{0x51, 0x4F, 0x47, 0x3C, 0x2F, 0x22, 0x16, 0x0D, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-14.5dB*/
+{0x56, 0x53, 0x4B, 0x40, 0x32, 0x24, 0x17, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-14dB*/
+{0x5B, 0x58, 0x50, 0x43, 0x35, 0x26, 0x19, 0x0E, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-13.5dB*/
+{0x60, 0x5D, 0x54, 0x47, 0x38, 0x28, 0x1A, 0x0F, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-13dB*/
+{0x66, 0x63, 0x59, 0x4C, 0x3B, 0x2B, 0x1C, 0x10, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-12.5dB*/
+{0x6C, 0x69, 0x5F, 0x50, 0x3F, 0x2D, 0x1E, 0x11, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-12dB*/
+{0x73, 0x6F, 0x64, 0x55, 0x42, 0x30, 0x1F, 0x12, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-11.5dB*/
+{0x79, 0x76, 0x6A, 0x5A, 0x46, 0x33, 0x21, 0x13, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-11dB*/
+{0x81, 0x7C, 0x71, 0x5F, 0x4A, 0x36, 0x23, 0x14, 0x0A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-10.5dB*/
+{0x88, 0x84, 0x77, 0x65, 0x4F, 0x39, 0x25, 0x15, 0x0A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-10dB*/
+{0x90, 0x8C, 0x7E, 0x6B, 0x54, 0x3C, 0x27, 0x17, 0x0B, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-9.5dB*/
+{0x99, 0x94, 0x86, 0x71, 0x58, 0x40, 0x2A, 0x18, 0x0B, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-9dB*/
+{0xA2, 0x9D, 0x8E, 0x78, 0x5E, 0x43, 0x2C, 0x19, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-8.5dB*/
+{0xAC, 0xA6, 0x96, 0x7F, 0x63, 0x47, 0x2F, 0x1B, 0x0D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-8dB*/
+{0xB6, 0xB0, 0x9F, 0x87, 0x69, 0x4C, 0x32, 0x1D, 0x0D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-7.5dB*/
+{0xC1, 0xBA, 0xA8, 0x8F, 0x6F, 0x50, 0x35, 0x1E, 0x0E, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-7dB*/
+{0xCC, 0xC5, 0xB2, 0x97, 0x76, 0x55, 0x38, 0x20, 0x0F, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-6.5dB*/
+{0xD8, 0xD1, 0xBD, 0xA0, 0x7D, 0x5A, 0x3B, 0x22, 0x10, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}     /*-6dB*/
+};
+
+
+u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 14, -9.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 18, -7.0dB 
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 19, -6.5dB
+    {0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 20, -6.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 22, -5.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 24, -4.0dB 
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 25, -3.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 26, -3.0dB
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 28, -2.0dB 
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 30, -1.0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 31, -0.5dB
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	// 32, +0dB
+};                                                                  
+
+
+u1Byte CCKSwingTable_Ch14_New[CCK_TABLE_SIZE][8]= {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 14, -9.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 18, -7.0dB  
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 19, -6.5dB 
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 20, -6.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 22, -5.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 24, -4.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 25, -3.5dB  
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 26, -3.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 28, -2.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 30, -1.0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 31, -0.5dB 
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	// 32, +0dB	
+};
+
+u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE] =
+{
+	0x081, // 0,  -12.0dB
+	0x088, // 1,  -11.5dB
+	0x090, // 2,  -11.0dB
+	0x099, // 3,  -10.5dB
+	0x0A2, // 4,  -10.0dB
+	0x0AC, // 5,  -9.5dB
+	0x0B6, // 6,  -9.0dB
+	0x0C0, // 7,  -8.5dB
+	0x0CC, // 8,  -8.0dB
+	0x0D8, // 9,  -7.5dB
+	0x0E5, // 10, -7.0dB
+	0x0F2, // 11, -6.5dB
+	0x101, // 12, -6.0dB
+	0x110, // 13, -5.5dB
+	0x120, // 14, -5.0dB
+	0x131, // 15, -4.5dB
+	0x143, // 16, -4.0dB
+	0x156, // 17, -3.5dB
+	0x16A, // 18, -3.0dB
+	0x180, // 19, -2.5dB
+	0x197, // 20, -2.0dB
+	0x1AF, // 21, -1.5dB
+	0x1C8, // 22, -1.0dB
+	0x1E3, // 23, -0.5dB
+	0x200, // 24, +0  dB
+	0x21E, // 25, +0.5dB
+	0x23E, // 26, +1.0dB
+	0x261, // 27, +1.5dB
+	0x285, // 28, +2.0dB
+	0x2AB, // 29, +2.5dB
+	0x2D3, // 30, +3.0dB
+	0x2FE, // 31, +3.5dB
+	0x32B, // 32, +4.0dB
+	0x35C, // 33, +4.5dB
+	0x38E, // 34, +5.0dB
+	0x3C4, // 35, +5.5dB
+	0x3FE  // 36, +6.0dB	
+};
+
+#ifdef AP_BUILD_WORKAROUND
+
+unsigned int TxPwrTrk_OFDM_SwingTbl[TxPwrTrk_OFDM_SwingTbl_Len] = {
+	/*  +6.0dB */ 0x7f8001fe,
+	/*  +5.5dB */ 0x788001e2,
+	/*  +5.0dB */ 0x71c001c7,
+	/*  +4.5dB */ 0x6b8001ae,
+	/*  +4.0dB */ 0x65400195,
+	/*  +3.5dB */ 0x5fc0017f,
+	/*  +3.0dB */ 0x5a400169,
+	/*  +2.5dB */ 0x55400155,
+	/*  +2.0dB */ 0x50800142,
+	/*  +1.5dB */ 0x4c000130,
+	/*  +1.0dB */ 0x47c0011f,
+	/*  +0.5dB */ 0x43c0010f,
+	/*   0.0dB */ 0x40000100,
+	/*  -0.5dB */ 0x3c8000f2,
+	/*  -1.0dB */ 0x390000e4,
+	/*  -1.5dB */ 0x35c000d7,
+	/*  -2.0dB */ 0x32c000cb,
+	/*  -2.5dB */ 0x300000c0,
+	/*  -3.0dB */ 0x2d4000b5,
+	/*  -3.5dB */ 0x2ac000ab,
+	/*  -4.0dB */ 0x288000a2,
+	/*  -4.5dB */ 0x26000098,
+	/*  -5.0dB */ 0x24000090,
+	/*  -5.5dB */ 0x22000088,
+	/*  -6.0dB */ 0x20000080,
+	/*  -6.5dB */ 0x1a00006c,
+	/*  -7.0dB */ 0x1c800072,
+	/*  -7.5dB */ 0x18000060,
+	/*  -8.0dB */ 0x19800066,
+	/*  -8.5dB */ 0x15800056,
+	/*  -9.0dB */ 0x26c0005b,
+	/*  -9.5dB */ 0x14400051,
+	/* -10.0dB */ 0x24400051,
+	/* -10.5dB */ 0x1300004c,
+	/* -11.0dB */ 0x12000048,
+	/* -11.5dB */ 0x11000044,
+	/* -12.0dB */ 0x10000040
+};
+#endif
+
+
+
+VOID
+odm_TXPowerTrackingInit(
+	IN	PVOID	pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_IC_11N_SERIES)))
+		return;
+#endif
+
+	odm_TXPowerTrackingThermalMeterInit(pDM_Odm);
+}	
+
+u1Byte 
+getSwingIndex(
+	IN	PVOID	pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u1Byte 			i = 0;
+	u4Byte 			bbSwing;
+	u4Byte 			swingTableSize;
+	pu4Byte 			pSwingTable;
+
+	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B
+		|| pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188F || pDM_Odm->SupportICType == ODM_RTL8703B
+	) {
+		bbSwing = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, 0xFFC00000);
+
+		pSwingTable = OFDMSwingTable_New;
+		swingTableSize = OFDM_TABLE_SIZE;
+	} else {
+#if ((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
+		if (pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821)
+		{
+			bbSwing = PHY_GetTxBBSwing_8812A(Adapter, pHalData->CurrentBandType, ODM_RF_PATH_A);
+			pSwingTable = TxScalingTable_Jaguar;
+			swingTableSize = TXSCALE_TABLE_SIZE;
+		}
+		else
+#endif
+		{
+			bbSwing = 0;
+			pSwingTable = OFDMSwingTable;
+			swingTableSize = OFDM_TABLE_SIZE;
+		}
+	}
+
+	for (i = 0; i < swingTableSize; ++i) {
+		u4Byte tableValue = pSwingTable[i];
+		
+		if (tableValue >= 0x100000 )
+			tableValue >>= 22;
+		if (bbSwing == tableValue)
+			break;
+	}
+	return i;
+}
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte defaultSwingIndex = getSwingIndex(pDM_Odm);
+	u1Byte 			p = 0;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	if(pDM_Odm->mp_mode == FALSE)
+		pHalData->TxPowerTrackControl = TRUE;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	pRFCalibrateInfo->bTXPowerTracking = _TRUE;
+	pRFCalibrateInfo->TXPowercount = 0;
+	pRFCalibrateInfo->bTXPowerTrackingInit = _FALSE;
+
+	if(pDM_Odm->mp_mode == FALSE)
+		pRFCalibrateInfo->TxPowerTrackControl = _TRUE;
+	else
+		pRFCalibrateInfo->TxPowerTrackControl = _FALSE;	
+
+	if(pDM_Odm->mp_mode == FALSE)
+		pRFCalibrateInfo->TxPowerTrackControl = _TRUE;
+
+
+	MSG_8192C("pDM_Odm TxPowerTrackControl = %d\n", pRFCalibrateInfo->TxPowerTrackControl);
+	
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	#ifdef RTL8188E_SUPPORT
+	{
+		pRFCalibrateInfo->bTXPowerTracking = _TRUE;
+		pRFCalibrateInfo->TXPowercount = 0;
+		pRFCalibrateInfo->bTXPowerTrackingInit = _FALSE;
+		pRFCalibrateInfo->TxPowerTrackControl = _TRUE;
+	}
+	#endif
+#endif
+
+	//pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = TRUE;
+	pRFCalibrateInfo->ThermalValue = pHalData->EEPROMThermalMeter;
+	pRFCalibrateInfo->ThermalValue_IQK = pHalData->EEPROMThermalMeter;
+	pRFCalibrateInfo->ThermalValue_LCK = pHalData->EEPROMThermalMeter;	
+
+	// The index of "0 dB" in SwingTable.
+	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
+		pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8703B) {
+		pRFCalibrateInfo->DefaultOfdmIndex = (defaultSwingIndex >= OFDM_TABLE_SIZE) ? 30 : defaultSwingIndex;
+		pRFCalibrateInfo->DefaultCckIndex = 20;	
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8188F)          //add by Mingzhi.Guo  2015-03-23
+	{
+		pRFCalibrateInfo->DefaultOfdmIndex =28;							//OFDM: -1dB
+		pRFCalibrateInfo->DefaultCckIndex =20;							//CCK:-6dB
+	}
+	else
+	{
+		pRFCalibrateInfo->DefaultOfdmIndex = (defaultSwingIndex >= TXSCALE_TABLE_SIZE) ? 24 : defaultSwingIndex;
+		pRFCalibrateInfo->DefaultCckIndex = 24;	
+	}
+
+	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
+	pRFCalibrateInfo->CCK_index = pRFCalibrateInfo->DefaultCckIndex;
+	
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
+	{
+		pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->DefaultOfdmIndex;		
+		pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;		
+		pRFCalibrateInfo->DeltaPowerIndex[p] = 0;
+		pRFCalibrateInfo->DeltaPowerIndexLast[p] = 0;
+		pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+	}
+	pRFCalibrateInfo->Modify_TxAGC_Value_OFDM=0;			//add by Mingzhi.Guo
+	pRFCalibrateInfo->Modify_TxAGC_Value_CCK=0;			//add by Mingzhi.Guo
+
+}
+
+
+VOID
+ODM_TXPowerTrackingCheck(
+	IN	PVOID	pDM_VOID
+	)
+{
+	/* 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	at the same time. In the stage2/3, we need to prive universal interface and merge all
+	HW dynamic mechanism. */
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+			odm_TXPowerTrackingCheckMP(pDM_Odm);
+			break;
+
+		case	ODM_CE:
+			odm_TXPowerTrackingCheckCE(pDM_Odm);
+			break;
+
+		case	ODM_AP:
+			odm_TXPowerTrackingCheckAP(pDM_Odm);		
+			break;		
+
+		default:
+			break;	
+	}
+
+}
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	if (!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))
+		return;
+
+	if(!pDM_Odm->RFCalibrateInfo.TM_Trigger)		//at least delay 1 sec
+	{
+		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
+		if (IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_8188F(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter)
+			|| IS_HARDWARE_TYPE_8723B(Adapter)
+			|| IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8814A(Adapter)
+			|| IS_HARDWARE_TYPE_8703B(Adapter)
+		) {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_NEW, (BIT17 | BIT16), 0x03);
+		} else {
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_OLD, bRFRegOffsetMask, 0x60);
+		}
+		
+		//DBG_871X("Trigger Thermal Meter!!\n");
+		
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		//DBG_871X("Schedule TxPowerTracking direct call!!\n");
+		ODM_TXPowerTrackingCallback_ThermalMeter(Adapter);
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 0;
+	}
+	
+#endif	
+}
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	if (ODM_CheckPowerStatus(Adapter) == FALSE) 
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("===>ODM_CheckPowerStatus() return FALSE\n"));
+		return;
+	}
+
+	if(!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE)
+		odm_TXPowerTrackingThermalMeterCheck(Adapter);
+	else {
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE\n"));
+	}
+#endif
+	
+}
+
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+
+	return;
+
+#endif
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	)
+{
+#ifndef AP_BUILD_WORKAROUND
+	static u1Byte			TM_Trigger = 0;
+
+	if(!(GET_HAL_DATA(Adapter)->DM_OutSrc.SupportAbility & ODM_RF_TX_PWR_TRACK))
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,
+			("===>odm_TXPowerTrackingThermalMeterCheck(),pMgntInfo->bTXPowerTracking is FALSE, return!!\n"));
+		return;
+	}
+
+	if(!TM_Trigger)		//at least delay 1 sec
+	{
+		if (IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter) ||
+			    IS_HARDWARE_TYPE_8723B(Adapter) || IS_HARDWARE_TYPE_8814A(Adapter) || IS_HARDWARE_TYPE_8188F(Adapter) 
+			    || IS_HARDWARE_TYPE_8703B(Adapter))
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);
+		else
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger Thermal Meter!!\n"));
+		
+		TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));		
+		odm_TXPowerTrackingDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
+		TM_Trigger = 0;
+	}
+#endif
+}
+#endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.h
new file mode 100644
index 000000000..c068b7479
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_ce.h
@@ -0,0 +1,296 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMPOWERTRACKING_H__
+#define    __PHYDMPOWERTRACKING_H__
+
+#define POWRTRACKING_VERSION	"1.1"
+
+#define		DPK_DELTA_MAPPING_NUM	13
+#define		index_mapping_HP_NUM	15	
+#define	OFDM_TABLE_SIZE 	43
+#define	CCK_TABLE_SIZE			33
+#define	CCK_TABLE_SIZE_88F	21
+#define TXSCALE_TABLE_SIZE 		37
+#define TXPWR_TRACK_TABLE_SIZE 	30
+#define DELTA_SWINGIDX_SIZE     30
+#define BAND_NUM 				4
+
+#define AVG_THERMAL_NUM		8
+#define HP_THERMAL_NUM		8
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+#define IQK_BB_REG_NUM_MAX	10
+
+#define IQK_BB_REG_NUM		9
+
+
+
+#define IQK_Matrix_REG_NUM	8
+#define IQK_Matrix_Settings_NUM	14+24+21 // Channels_2_4G_NUM + Channels_5G_20M_NUM + Channels_5G
+
+extern	u4Byte OFDMSwingTable[OFDM_TABLE_SIZE];
+extern	u1Byte CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8];
+
+extern	u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE];
+extern	u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14_New [CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch1_Ch14_88F[CCK_TABLE_SIZE_88F][16];
+
+
+extern  u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE];
+
+// <20121018, Kordan> In case fail to read TxPowerTrack.txt, we use the table of 88E as the default table.
+static u1Byte DeltaSwingTableIdx_2GA_P_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+static u1Byte DeltaSwingTableIdx_2GA_N_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11}; 
+
+#define dm_CheckTXPowerTracking 	ODM_TXPowerTrackingCheck
+
+typedef struct _IQK_MATRIX_REGS_SETTING{
+	BOOLEAN 	bIQKDone;
+	s4Byte		Value[3][IQK_Matrix_REG_NUM];
+	BOOLEAN 	bBWIqkResultSaved[3];	
+}IQK_MATRIX_REGS_SETTING,*PIQK_MATRIX_REGS_SETTING;
+
+typedef struct ODM_RF_Calibration_Structure
+{
+	//for tx power tracking
+	
+	u4Byte	RegA24; // for TempCCK
+	s4Byte	RegE94;
+	s4Byte 	RegE9C;
+	s4Byte	RegEB4;
+	s4Byte	RegEBC;	
+
+	u1Byte  	TXPowercount;
+	BOOLEAN bTXPowerTrackingInit; 
+	BOOLEAN bTXPowerTracking;
+	u1Byte  	TxPowerTrackControl; //for mp mode, turn off txpwrtracking as default
+	u1Byte  	TM_Trigger;
+    	u1Byte  	InternalPA5G[2];	//pathA / pathB
+	
+	u1Byte  	ThermalMeter[2];    // ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u1Byte  	ThermalValue;
+	u1Byte  	ThermalValue_LCK;
+	u1Byte  	ThermalValue_IQK;
+	u1Byte	ThermalValue_DPK;		
+	u1Byte	ThermalValue_AVG[AVG_THERMAL_NUM];
+	u1Byte	ThermalValue_AVG_index;		
+	u1Byte	ThermalValue_RxGain;
+	u1Byte	ThermalValue_Crystal;
+	u1Byte	ThermalValue_DPKstore;
+	u1Byte	ThermalValue_DPKtrack;
+	BOOLEAN	TxPowerTrackingInProgress;
+	
+	BOOLEAN	bReloadtxpowerindex;	
+	u1Byte 	bRfPiEnable;
+	u4Byte 	TXPowerTrackingCallbackCnt; //cosa add for debug
+
+
+	//------------------------- Tx power Tracking -------------------------//
+	u1Byte 	bCCKinCH14;
+	u1Byte 	CCK_index;
+	u1Byte 	OFDM_index[MAX_RF_PATH];
+	s1Byte	PowerIndexOffset[MAX_RF_PATH];
+	s1Byte	DeltaPowerIndex[MAX_RF_PATH];
+	s1Byte	DeltaPowerIndexLast[MAX_RF_PATH];	
+	BOOLEAN bTxPowerChanged;
+		
+	u1Byte 	ThermalValue_HP[HP_THERMAL_NUM];
+	u1Byte 	ThermalValue_HP_index;
+	IQK_MATRIX_REGS_SETTING IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
+	u1Byte	Delta_LCK;
+	s1Byte  BBSwingDiff2G, BBSwingDiff5G; // Unit: dB
+	u1Byte  DeltaSwingTableIdx_2GCCKA_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKA_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKB_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKB_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKC_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKC_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKD_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKD_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GB_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GB_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GC_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GC_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GD_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GD_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GA_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GA_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GB_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GB_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GC_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GC_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GD_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GD_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_P_8188E[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_N_8188E[DELTA_SWINGIDX_SIZE];
+    
+	u1Byte			BbSwingIdxOfdm[MAX_RF_PATH];
+	u1Byte			BbSwingIdxOfdmCurrent;
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))	
+	u1Byte			BbSwingIdxOfdmBase[MAX_RF_PATH];
+#else
+	u1Byte			BbSwingIdxOfdmBase;
+#endif
+	BOOLEAN			BbSwingFlagOfdm;
+	u1Byte			BbSwingIdxCck;
+	u1Byte			BbSwingIdxCckCurrent;
+	u1Byte			BbSwingIdxCckBase;
+	u1Byte			DefaultOfdmIndex;
+	u1Byte			DefaultCckIndex;	
+	BOOLEAN			BbSwingFlagCck;
+	
+	s1Byte			Absolute_OFDMSwingIdx[MAX_RF_PATH];   
+	s1Byte			Remnant_OFDMSwingIdx[MAX_RF_PATH];   
+	s1Byte			Remnant_CCKSwingIdx;
+	s1Byte			Modify_TxAGC_Value;       /*Remnat compensate value at TxAGC */
+	BOOLEAN			Modify_TxAGC_Flag_PathA;
+	BOOLEAN			Modify_TxAGC_Flag_PathB;
+	BOOLEAN			Modify_TxAGC_Flag_PathC;
+	BOOLEAN			Modify_TxAGC_Flag_PathD;
+	BOOLEAN			Modify_TxAGC_Flag_PathA_CCK;
+	
+	s1Byte			KfreeOffset[MAX_RF_PATH];
+    
+	//--------------------------------------------------------------------//	
+	
+	//for IQK	
+	u4Byte 	RegC04;
+	u4Byte 	Reg874;
+	u4Byte 	RegC08;
+	u4Byte 	RegB68;
+	u4Byte 	RegB6C;
+	u4Byte 	Reg870;
+	u4Byte 	Reg860;
+	u4Byte 	Reg864;
+	
+	BOOLEAN	bIQKInitialized;
+	BOOLEAN bLCKInProgress;
+	BOOLEAN	bAntennaDetected;
+	BOOLEAN	bNeedIQK;
+	BOOLEAN	bIQKInProgress;	
+	u1Byte	Delta_IQK;
+	u4Byte	ADDA_backup[IQK_ADDA_REG_NUM];
+	u4Byte	IQK_MAC_backup[IQK_MAC_REG_NUM];
+	u4Byte	IQK_BB_backup_recover[9];
+	u4Byte	IQK_BB_backup[IQK_BB_REG_NUM];	
+	u4Byte 	TxIQC_8723B[2][3][2]; // { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}
+	u4Byte 	RxIQC_8723B[2][2][2]; // { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}
+	u4Byte	TxIQC_8703B[3][2];	/* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}*/
+	u4Byte	RxIQC_8703B[2][2];	/* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}*/
+
+	
+
+	// <James> IQK time measurement 
+	u8Byte	IQK_StartTime;
+	u8Byte	IQK_ProgressingTime;
+	u4Byte  LOK_Result;
+
+	//for APK
+	u4Byte 	APKoutput[2][2]; //path A/B; output1_1a/output1_2a
+	u1Byte 	bAPKdone;
+	u1Byte 	bAPKThermalMeterIgnore;
+	
+	// DPK
+	BOOLEAN bDPKFail;	
+	u1Byte 	bDPdone;
+	u1Byte 	bDPPathAOK;
+	u1Byte 	bDPPathBOK;
+
+	u4Byte	TxLOK[2];
+	u4Byte  DpkTxAGC;
+	s4Byte  DpkGain;
+	u4Byte  DpkThermal[4];
+	s1Byte Modify_TxAGC_Value_OFDM;
+	s1Byte Modify_TxAGC_Value_CCK;
+}ODM_RF_CAL_T,*PODM_RF_CAL_T;
+
+
+VOID	
+ODM_TXPowerTrackingCheck(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+
+VOID 
+odm_TXPowerTrackingCallbackThermalMeter92C(
+            IN PADAPTER	Adapter
+            );
+
+VOID
+odm_TXPowerTrackingCallbackRXGainThermalMeter92D(
+	IN PADAPTER 	Adapter
+	);
+
+VOID
+odm_TXPowerTrackingCallbackThermalMeter92D(
+            IN PADAPTER	Adapter
+            );
+
+VOID
+odm_TXPowerTrackingDirectCall92C(
+            IN	PADAPTER		Adapter
+            );
+
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	);
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.c
new file mode 100644
index 000000000..acf2147c8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.c
@@ -0,0 +1,687 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+//============================================================
+// Global var
+//============================================================
+
+u4Byte	OFDMSwingTable[OFDM_TABLE_SIZE] = {
+	0x7f8001fe,	// 0, +6.0dB
+	0x788001e2,	// 1, +5.5dB
+	0x71c001c7,	// 2, +5.0dB
+	0x6b8001ae,	// 3, +4.5dB
+	0x65400195,	// 4, +4.0dB
+	0x5fc0017f,	// 5, +3.5dB
+	0x5a400169,	// 6, +3.0dB
+	0x55400155,	// 7, +2.5dB
+	0x50800142,	// 8, +2.0dB
+	0x4c000130,	// 9, +1.5dB
+	0x47c0011f,	// 10, +1.0dB
+	0x43c0010f,	// 11, +0.5dB
+	0x40000100,	// 12, +0dB
+	0x3c8000f2,	// 13, -0.5dB
+	0x390000e4,	// 14, -1.0dB
+	0x35c000d7,	// 15, -1.5dB
+	0x32c000cb,	// 16, -2.0dB
+	0x300000c0,	// 17, -2.5dB
+	0x2d4000b5,	// 18, -3.0dB
+	0x2ac000ab,	// 19, -3.5dB
+	0x288000a2,	// 20, -4.0dB
+	0x26000098,	// 21, -4.5dB
+	0x24000090,	// 22, -5.0dB
+	0x22000088,	// 23, -5.5dB
+	0x20000080,	// 24, -6.0dB
+	0x1e400079,	// 25, -6.5dB
+	0x1c800072,	// 26, -7.0dB
+	0x1b00006c,	// 27. -7.5dB
+	0x19800066,	// 28, -8.0dB
+	0x18000060,	// 29, -8.5dB
+	0x16c0005b,	// 30, -9.0dB
+	0x15800056,	// 31, -9.5dB
+	0x14400051,	// 32, -10.0dB
+	0x1300004c,	// 33, -10.5dB
+	0x12000048,	// 34, -11.0dB
+	0x11000044,	// 35, -11.5dB
+	0x10000040,	// 36, -12.0dB
+};
+
+u1Byte	CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB 
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB <== default
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB 
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 22, -11.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	// 23, -11.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	// 24, -12.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	// 25, -12.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	// 26, -13.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	// 27, -13.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	// 28, -14.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	// 29, -14.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	// 30, -15.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	// 31, -15.5dB
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	// 32, -16.0dB
+};
+
+
+u1Byte	CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB 
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB  
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB  <== default
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB 
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB  
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 22, -11.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 23, -11.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 24, -12.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	// 25, -12.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 26, -13.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 27, -13.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 28, -14.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 29, -14.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
+};
+
+
+u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE] = {
+	0x0b40002d, // 0,  -15.0dB	
+	0x0c000030, // 1,  -14.5dB
+	0x0cc00033, // 2,  -14.0dB
+	0x0d800036, // 3,  -13.5dB
+	0x0e400039, // 4,  -13.0dB    
+	0x0f00003c, // 5,  -12.5dB
+	0x10000040, // 6,  -12.0dB
+	0x11000044, // 7,  -11.5dB
+	0x12000048, // 8,  -11.0dB
+	0x1300004c, // 9,  -10.5dB
+	0x14400051, // 10, -10.0dB
+	0x15800056, // 11, -9.5dB
+	0x16c0005b, // 12, -9.0dB
+	0x18000060, // 13, -8.5dB
+	0x19800066, // 14, -8.0dB
+	0x1b00006c, // 15, -7.5dB
+	0x1c800072, // 16, -7.0dB
+	0x1e400079, // 17, -6.5dB
+	0x20000080, // 18, -6.0dB
+	0x22000088, // 19, -5.5dB
+	0x24000090, // 20, -5.0dB
+	0x26000098, // 21, -4.5dB
+	0x288000a2, // 22, -4.0dB
+	0x2ac000ab, // 23, -3.5dB
+	0x2d4000b5, // 24, -3.0dB
+	0x300000c0, // 25, -2.5dB
+	0x32c000cb, // 26, -2.0dB
+	0x35c000d7, // 27, -1.5dB
+	0x390000e4, // 28, -1.0dB
+	0x3c8000f2, // 29, -0.5dB
+	0x40000100, // 30, +0dB
+	0x43c0010f, // 31, +0.5dB
+	0x47c0011f, // 32, +1.0dB
+	0x4c000130, // 33, +1.5dB
+	0x50800142, // 34, +2.0dB
+	0x55400155, // 35, +2.5dB
+	0x5a400169, // 36, +3.0dB
+	0x5fc0017f, // 37, +3.5dB
+	0x65400195, // 38, +4.0dB
+	0x6b8001ae, // 39, +4.5dB
+	0x71c001c7, // 40, +5.0dB
+	0x788001e2, // 41, +5.5dB
+	0x7f8001fe  // 42, +6.0dB
+};               
+
+
+u1Byte CCKSwingTable_Ch1_Ch14_88F[CCK_TABLE_SIZE_88F][16] = {
+{0x44, 0x42, 0x3C, 0x33, 0x28, 0x1C, 0x13, 0x0B, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-16dB*/
+{0x48, 0x46, 0x3F, 0x36, 0x2A, 0x1E, 0x14, 0x0B, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-15.5dB*/
+{0x4D, 0x4A, 0x43, 0x39, 0x2C, 0x20, 0x15, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-15dB*/
+{0x51, 0x4F, 0x47, 0x3C, 0x2F, 0x22, 0x16, 0x0D, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-14.5dB*/
+{0x56, 0x53, 0x4B, 0x40, 0x32, 0x24, 0x17, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-14dB*/
+{0x5B, 0x58, 0x50, 0x43, 0x35, 0x26, 0x19, 0x0E, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-13.5dB*/
+{0x60, 0x5D, 0x54, 0x47, 0x38, 0x28, 0x1A, 0x0F, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-13dB*/
+{0x66, 0x63, 0x59, 0x4C, 0x3B, 0x2B, 0x1C, 0x10, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-12.5dB*/
+{0x6C, 0x69, 0x5F, 0x50, 0x3F, 0x2D, 0x1E, 0x11, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-12dB*/
+{0x73, 0x6F, 0x64, 0x55, 0x42, 0x30, 0x1F, 0x12, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-11.5dB*/
+{0x79, 0x76, 0x6A, 0x5A, 0x46, 0x33, 0x21, 0x13, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-11dB*/
+{0x81, 0x7C, 0x71, 0x5F, 0x4A, 0x36, 0x23, 0x14, 0x0A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-10.5dB*/
+{0x88, 0x84, 0x77, 0x65, 0x4F, 0x39, 0x25, 0x15, 0x0A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-10dB*/
+{0x90, 0x8C, 0x7E, 0x6B, 0x54, 0x3C, 0x27, 0x17, 0x0B, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-9.5dB*/
+{0x99, 0x94, 0x86, 0x71, 0x58, 0x40, 0x2A, 0x18, 0x0B, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-9dB*/
+{0xA2, 0x9D, 0x8E, 0x78, 0x5E, 0x43, 0x2C, 0x19, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-8.5dB*/
+{0xAC, 0xA6, 0x96, 0x7F, 0x63, 0x47, 0x2F, 0x1B, 0x0D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-8dB*/
+{0xB6, 0xB0, 0x9F, 0x87, 0x69, 0x4C, 0x32, 0x1D, 0x0D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-7.5dB*/
+{0xC1, 0xBA, 0xA8, 0x8F, 0x6F, 0x50, 0x35, 0x1E, 0x0E, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-7dB*/
+{0xCC, 0xC5, 0xB2, 0x97, 0x76, 0x55, 0x38, 0x20, 0x0F, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /*-6.5dB*/
+{0xD8, 0xD1, 0xBD, 0xA0, 0x7D, 0x5A, 0x3B, 0x22, 0x10, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}     /*-6dB*/
+};
+
+
+u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 14, -9.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 18, -7.0dB 
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 19, -6.5dB
+    {0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 20, -6.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 22, -5.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 24, -4.0dB 
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 25, -3.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 26, -3.0dB
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 28, -2.0dB 
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 30, -1.0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 31, -0.5dB
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	// 32, +0dB
+};                                                                  
+
+
+u1Byte CCKSwingTable_Ch14_New[CCK_TABLE_SIZE][8]= {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 14, -9.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 18, -7.0dB  
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 19, -6.5dB 
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 20, -6.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 22, -5.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 24, -4.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 25, -3.5dB  
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 26, -3.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 28, -2.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 30, -1.0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 31, -0.5dB 
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	// 32, +0dB	
+};
+
+u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE] =
+{
+	0x081, // 0,  -12.0dB
+	0x088, // 1,  -11.5dB
+	0x090, // 2,  -11.0dB
+	0x099, // 3,  -10.5dB
+	0x0A2, // 4,  -10.0dB
+	0x0AC, // 5,  -9.5dB
+	0x0B6, // 6,  -9.0dB
+	0x0C0, // 7,  -8.5dB
+	0x0CC, // 8,  -8.0dB
+	0x0D8, // 9,  -7.5dB
+	0x0E5, // 10, -7.0dB
+	0x0F2, // 11, -6.5dB
+	0x101, // 12, -6.0dB
+	0x110, // 13, -5.5dB
+	0x120, // 14, -5.0dB
+	0x131, // 15, -4.5dB
+	0x143, // 16, -4.0dB
+	0x156, // 17, -3.5dB
+	0x16A, // 18, -3.0dB
+	0x180, // 19, -2.5dB
+	0x197, // 20, -2.0dB
+	0x1AF, // 21, -1.5dB
+	0x1C8, // 22, -1.0dB
+	0x1E3, // 23, -0.5dB
+	0x200, // 24, +0  dB
+	0x21E, // 25, +0.5dB
+	0x23E, // 26, +1.0dB
+	0x261, // 27, +1.5dB
+	0x285, // 28, +2.0dB
+	0x2AB, // 29, +2.5dB
+	0x2D3, // 30, +3.0dB
+	0x2FE, // 31, +3.5dB
+	0x32B, // 32, +4.0dB
+	0x35C, // 33, +4.5dB
+	0x38E, // 34, +5.0dB
+	0x3C4, // 35, +5.5dB
+	0x3FE  // 36, +6.0dB	
+};
+
+#ifdef AP_BUILD_WORKAROUND
+
+unsigned int TxPwrTrk_OFDM_SwingTbl[TxPwrTrk_OFDM_SwingTbl_Len] = {
+	/*  +6.0dB */ 0x7f8001fe,
+	/*  +5.5dB */ 0x788001e2,
+	/*  +5.0dB */ 0x71c001c7,
+	/*  +4.5dB */ 0x6b8001ae,
+	/*  +4.0dB */ 0x65400195,
+	/*  +3.5dB */ 0x5fc0017f,
+	/*  +3.0dB */ 0x5a400169,
+	/*  +2.5dB */ 0x55400155,
+	/*  +2.0dB */ 0x50800142,
+	/*  +1.5dB */ 0x4c000130,
+	/*  +1.0dB */ 0x47c0011f,
+	/*  +0.5dB */ 0x43c0010f,
+	/*   0.0dB */ 0x40000100,
+	/*  -0.5dB */ 0x3c8000f2,
+	/*  -1.0dB */ 0x390000e4,
+	/*  -1.5dB */ 0x35c000d7,
+	/*  -2.0dB */ 0x32c000cb,
+	/*  -2.5dB */ 0x300000c0,
+	/*  -3.0dB */ 0x2d4000b5,
+	/*  -3.5dB */ 0x2ac000ab,
+	/*  -4.0dB */ 0x288000a2,
+	/*  -4.5dB */ 0x26000098,
+	/*  -5.0dB */ 0x24000090,
+	/*  -5.5dB */ 0x22000088,
+	/*  -6.0dB */ 0x20000080,
+	/*  -6.5dB */ 0x1a00006c,
+	/*  -7.0dB */ 0x1c800072,
+	/*  -7.5dB */ 0x18000060,
+	/*  -8.0dB */ 0x19800066,
+	/*  -8.5dB */ 0x15800056,
+	/*  -9.0dB */ 0x26c0005b,
+	/*  -9.5dB */ 0x14400051,
+	/* -10.0dB */ 0x24400051,
+	/* -10.5dB */ 0x1300004c,
+	/* -11.0dB */ 0x12000048,
+	/* -11.5dB */ 0x11000044,
+	/* -12.0dB */ 0x10000040
+};
+
+#endif
+
+VOID
+odm_TXPowerTrackingInit(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_IC_11N_SERIES|ODM_RTL8822B)))
+		return;
+#endif
+
+	odm_TXPowerTrackingThermalMeterInit(pDM_Odm);
+}	
+
+u1Byte 
+getSwingIndex(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u1Byte 			i = 0;
+	u4Byte 			bbSwing;
+	u4Byte 			swingTableSize;
+	pu4Byte 			pSwingTable;
+
+	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
+		pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188F || pDM_Odm->SupportICType == ODM_RTL8703B) 
+	{
+		bbSwing = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, 0xFFC00000);
+
+		pSwingTable = OFDMSwingTable_New;
+		swingTableSize = OFDM_TABLE_SIZE;
+	} else {
+		bbSwing = PHY_GetTxBBSwing_8812A(Adapter, pHalData->CurrentBandType, ODM_RF_PATH_A);
+		pSwingTable = TxScalingTable_Jaguar;
+		swingTableSize = TXSCALE_TABLE_SIZE;		
+	}
+
+	for (i = 0; i < swingTableSize; ++i) {
+		u4Byte tableValue = pSwingTable[i];
+		
+		if (tableValue >= 0x100000 )
+			tableValue >>= 22;
+		if (bbSwing == tableValue)
+			break;
+	}
+	return i;
+}
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte defaultSwingIndex = getSwingIndex(pDM_Odm);
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u1Byte 			p = 0;
+
+	if(pDM_Odm->mp_mode == FALSE)
+		pRFCalibrateInfo->TxPowerTrackControl = TRUE;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#ifdef CONFIG_RTL8188E
+	{
+		pRFCalibrateInfo->bTXPowerTracking = _TRUE;
+		pRFCalibrateInfo->TXPowercount = 0;
+		pRFCalibrateInfo->bTXPowerTrackingInit = _FALSE;
+
+		if(pDM_Odm->mp_mode == FALSE)
+			pRFCalibrateInfo->TxPowerTrackControl = _TRUE;
+		
+		MSG_8192C("pDM_Odm TxPowerTrackControl = %d\n", pRFCalibrateInfo->TxPowerTrackControl);
+	}
+	#else
+	{
+		PADAPTER		Adapter = pDM_Odm->Adapter;
+		HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+		struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+		pdmpriv->bTXPowerTracking = _TRUE;
+		pdmpriv->TXPowercount = 0;
+		pdmpriv->bTXPowerTrackingInit = _FALSE;
+
+		if(pDM_Odm->mp_mode == FALSE)
+			pdmpriv->TxPowerTrackControl = _TRUE;
+
+		MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
+	
+	}	
+	#endif//endif (CONFIG_RTL8188E==1)	
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	#ifdef RTL8188E_SUPPORT
+	{
+		pRFCalibrateInfo->bTXPowerTracking = _TRUE;
+		pRFCalibrateInfo->TXPowercount = 0;
+		pRFCalibrateInfo->bTXPowerTrackingInit = _FALSE;
+		pRFCalibrateInfo->TxPowerTrackControl = _TRUE;
+	}
+	#endif
+#endif
+
+	pRFCalibrateInfo->TxPowerTrackControl = TRUE;
+	pRFCalibrateInfo->ThermalValue 		= pHalData->EEPROMThermalMeter;
+	pRFCalibrateInfo->ThermalValue_IQK 	= pHalData->EEPROMThermalMeter;
+	pRFCalibrateInfo->ThermalValue_LCK 	= pHalData->EEPROMThermalMeter;	
+
+	// The index of "0 dB" in SwingTable.
+	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
+		pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8703B) 
+	{
+		pRFCalibrateInfo->DefaultOfdmIndex = (defaultSwingIndex >= OFDM_TABLE_SIZE) ? 30 : defaultSwingIndex;
+		pRFCalibrateInfo->DefaultCckIndex = 20;	
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8188F)          //add by Mingzhi.Guo  2015-03-23
+	{
+		pRFCalibrateInfo->DefaultOfdmIndex =28;							//OFDM: -1dB
+		pRFCalibrateInfo->DefaultCckIndex =20;							//CCK:-6dB
+	}
+	else
+	{
+		pRFCalibrateInfo->DefaultOfdmIndex = (defaultSwingIndex >= TXSCALE_TABLE_SIZE) ? 24 : defaultSwingIndex;
+		pRFCalibrateInfo->DefaultCckIndex = 24;	
+	}
+
+	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
+	pRFCalibrateInfo->CCK_index = pRFCalibrateInfo->DefaultCckIndex;
+	
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
+	{
+		pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->DefaultOfdmIndex;		
+	   	pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;		
+		pRFCalibrateInfo->DeltaPowerIndex[p] = 0;
+		pRFCalibrateInfo->DeltaPowerIndexLast[p] = 0;
+		pRFCalibrateInfo->PowerIndexOffset[p] = 0;
+		pRFCalibrateInfo->KfreeOffset[p] = 0;
+	}
+	pRFCalibrateInfo->Modify_TxAGC_Value_OFDM=0;			//add by Mingzhi.Guo
+	pRFCalibrateInfo->Modify_TxAGC_Value_CCK=0;			//add by Mingzhi.Guo
+
+}
+
+
+VOID
+ODM_TXPowerTrackingCheck(
+	IN	PVOID		pDM_VOID
+	)
+{
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+			odm_TXPowerTrackingCheckMP(pDM_Odm);
+			break;
+
+		case	ODM_CE:
+			odm_TXPowerTrackingCheckCE(pDM_Odm);
+			break;
+
+		case	ODM_AP:
+			odm_TXPowerTrackingCheckAP(pDM_Odm);		
+			break;		
+
+		default:
+			break;	
+	}
+
+}
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	#if ((RTL8188F_SUPPORT == 1))
+	rtl8192c_odm_CheckTXPowerTracking(Adapter);
+	#endif
+
+	#if(RTL8188E_SUPPORT==1)
+
+	if(!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))
+	{
+		return;
+	}
+
+	if(!pRFCalibrateInfo->TM_Trigger)		//at least delay 1 sec
+	{
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		//DBG_8192C("Trigger 92C Thermal Meter!!\n");
+		
+		pRFCalibrateInfo->TM_Trigger = 1;
+		return;
+		
+	}
+	else
+	{
+		//DBG_8192C("Schedule TxPowerTracking direct call!!\n");
+		odm_TXPowerTrackingCallback_ThermalMeter_8188E(Adapter);
+		pRFCalibrateInfo->TM_Trigger = 0;
+	}
+	#endif
+#endif	
+}
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN	PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	if(*pDM_Odm->pIsFcsModeEnable)
+		return;
+
+	if (ODM_CheckPowerStatus(Adapter) == FALSE) 
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("===>ODM_CheckPowerStatus() return FALSE\n"));
+		return;
+	}
+
+	if(IS_HARDWARE_TYPE_8821B(Adapter)) // TODO: Don't Do PowerTracking
+		return;
+	
+//	#if(RTL8192D_SUPPORT==1)
+//	if(!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE)
+	if (IS_HARDWARE_TYPE_8814A(Adapter) || IS_HARDWARE_TYPE_8188F(Adapter))
+		odm_TXPowerTrackingThermalMeterCheck(Adapter);
+	else {
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE\n"));
+	}
+//	#endif
+#endif
+	
+}
+
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN	PVOID		pDM_VOID
+	)
+{
+return;
+
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+odm_TXPowerTrackingDirectCall(
+	IN	PADAPTER		Adapter
+	)
+{
+	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(Adapter);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	
+	ODM_TXPowerTrackingCallback_ThermalMeter(Adapter);
+}
+
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	)
+{
+#ifndef AP_BUILD_WORKAROUND
+	static u1Byte			TM_Trigger = 0;
+
+	if(!(GET_HAL_DATA(Adapter)->DM_OutSrc.SupportAbility & ODM_RF_TX_PWR_TRACK))
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,
+			("===>odm_TXPowerTrackingThermalMeterCheck(),pMgntInfo->bTXPowerTracking is FALSE, return!!\n"));
+		return;
+	}
+
+	if(!TM_Trigger)		//at least delay 1 sec
+	{
+		if (IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter) ||
+			    IS_HARDWARE_TYPE_8723B(Adapter) || IS_HARDWARE_TYPE_8814A(Adapter) || IS_HARDWARE_TYPE_8188F(Adapter) || IS_HARDWARE_TYPE_8703B(Adapter))
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);
+		else
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger Thermal Meter!!\n"));
+		
+		TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));		
+		odm_TXPowerTrackingDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
+		TM_Trigger = 0;
+	}
+#endif
+}
+
+#endif //end #ifMP
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.h
new file mode 100644
index 000000000..0ecb3179b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_powertracking_win.h
@@ -0,0 +1,265 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMPOWERTRACKING_H__
+#define    __PHYDMPOWERTRACKING_H__
+
+#define POWRTRACKING_VERSION	"1.1"
+
+#define	DPK_DELTA_MAPPING_NUM	13
+#define	index_mapping_HP_NUM	15	
+#define	TXSCALE_TABLE_SIZE 		37
+#define	TXPWR_TRACK_TABLE_SIZE 	30
+#define	DELTA_SWINGIDX_SIZE     30
+#define	BAND_NUM 				3
+#define	MAX_RF_PATH	4
+#define	CCK_TABLE_SIZE_88F	21
+
+
+#define	dm_CheckTXPowerTracking 	ODM_TXPowerTrackingCheck
+
+#define IQK_Matrix_Settings_NUM	14+24+21 // Channels_2_4G_NUM + Channels_5G_20M_NUM + Channels_5G
+#define	AVG_THERMAL_NUM		8
+#define	HP_THERMAL_NUM		8
+#define	IQK_Matrix_REG_NUM	8
+#define	IQK_MAC_REG_NUM		4
+#define	IQK_ADDA_REG_NUM		16
+
+#define	IQK_BB_REG_NUM		9
+
+
+extern	u4Byte OFDMSwingTable[OFDM_TABLE_SIZE];
+extern	u1Byte CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8];
+
+extern	u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE];
+extern	u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14_New [CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch1_Ch14_88F[CCK_TABLE_SIZE_88F][16];
+
+extern  u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE];
+
+// <20121018, Kordan> In case fail to read TxPowerTrack.txt, we use the table of 88E as the default table.
+static u1Byte DeltaSwingTableIdx_2GA_P_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+static u1Byte DeltaSwingTableIdx_2GA_N_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11}; 
+
+VOID
+ODM_TXPowerTrackingCheck(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingInit(
+	IN	PVOID		pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN	PVOID		pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN	PVOID		pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+
+
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	);
+
+#endif
+
+typedef struct _IQK_MATRIX_REGS_SETTING{
+	BOOLEAN 	bIQKDone;
+	s4Byte		Value[3][IQK_Matrix_REG_NUM];
+	BOOLEAN 	bBWIqkResultSaved[3];	
+}IQK_MATRIX_REGS_SETTING,*PIQK_MATRIX_REGS_SETTING;
+
+typedef struct ODM_RF_Calibration_Structure
+{
+	//for tx power tracking
+	
+	u4Byte	RegA24; // for TempCCK
+	s4Byte	RegE94;
+	s4Byte 	RegE9C;
+	s4Byte	RegEB4;
+	s4Byte	RegEBC;	
+	//u1Byte bTXPowerTracking;
+	u1Byte  	TXPowercount;
+	BOOLEAN bTXPowerTrackingInit; 
+	BOOLEAN bTXPowerTracking;
+	u1Byte  	TxPowerTrackControl; //for mp mode, turn off txpwrtracking as default
+	u1Byte  	TM_Trigger;
+    	u1Byte  	InternalPA5G[2];	//pathA / pathB
+	
+	u1Byte  	ThermalMeter[2];    // ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u1Byte  	ThermalValue;
+	u1Byte  	ThermalValue_LCK;
+	u1Byte  	ThermalValue_IQK;
+	u1Byte	ThermalValue_AVG[AVG_THERMAL_NUM];
+	u1Byte	ThermalValue_AVG_index;		
+	u1Byte	ThermalValue_RxGain;
+	
+	BOOLEAN	bReloadtxpowerindex;	
+	u1Byte 	bRfPiEnable;
+	u4Byte 	TXPowerTrackingCallbackCnt; //cosa add for debug
+
+
+	//------------------------- Tx power Tracking -------------------------//
+	u1Byte 	bCCKinCH14;
+	u1Byte 	CCK_index;
+	u1Byte 	OFDM_index[MAX_RF_PATH];
+	s1Byte	PowerIndexOffset[MAX_RF_PATH];
+	s1Byte	DeltaPowerIndex[MAX_RF_PATH];
+	s1Byte	DeltaPowerIndexLast[MAX_RF_PATH];	
+	BOOLEAN bTxPowerChanged;
+		
+	u1Byte 	ThermalValue_HP[HP_THERMAL_NUM];
+	u1Byte 	ThermalValue_HP_index;
+	IQK_MATRIX_REGS_SETTING IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
+	u1Byte	Delta_LCK;
+	s1Byte  BBSwingDiff2G, BBSwingDiff5G; // Unit: dB
+	u1Byte  DeltaSwingTableIdx_2GCCKA_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKA_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKB_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKB_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKC_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKC_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKD_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GCCKD_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GB_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GB_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GC_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GC_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GD_P[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GD_N[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GA_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GA_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GB_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GB_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GC_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GC_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GD_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_5GD_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_P_8188E[DELTA_SWINGIDX_SIZE];
+	u1Byte  DeltaSwingTableIdx_2GA_N_8188E[DELTA_SWINGIDX_SIZE];
+	
+	u1Byte			BbSwingIdxOfdm[MAX_RF_PATH];
+	u1Byte			BbSwingIdxOfdmCurrent;
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))	
+	u1Byte			BbSwingIdxOfdmBase[MAX_RF_PATH];
+#else
+	u1Byte			BbSwingIdxOfdmBase;
+#endif
+	BOOLEAN			BbSwingFlagOfdm;
+	u1Byte			BbSwingIdxCck;
+	u1Byte			BbSwingIdxCckCurrent;
+	u1Byte			BbSwingIdxCckBase;
+	u1Byte			DefaultOfdmIndex;
+	u1Byte			DefaultCckIndex;	
+	BOOLEAN			BbSwingFlagCck;
+	
+	s1Byte			Absolute_OFDMSwingIdx[MAX_RF_PATH];   
+	s1Byte			Remnant_OFDMSwingIdx[MAX_RF_PATH];   
+	s1Byte			Remnant_CCKSwingIdx;
+	s1Byte			Modify_TxAGC_Value;       /*Remnat compensate value at TxAGC */
+	BOOLEAN			Modify_TxAGC_Flag_PathA;
+	BOOLEAN			Modify_TxAGC_Flag_PathB;
+	BOOLEAN			Modify_TxAGC_Flag_PathC;
+	BOOLEAN			Modify_TxAGC_Flag_PathD;
+	BOOLEAN			Modify_TxAGC_Flag_PathA_CCK;
+	
+	s1Byte			KfreeOffset[MAX_RF_PATH];
+    
+	//--------------------------------------------------------------------//	
+	
+	//for IQK	
+	u4Byte 	RegC04;
+	u4Byte 	Reg874;
+	u4Byte 	RegC08;
+	u4Byte 	RegB68;
+	u4Byte 	RegB6C;
+	u4Byte 	Reg870;
+	u4Byte 	Reg860;
+	u4Byte 	Reg864;
+	
+	BOOLEAN	bIQKInitialized;
+	BOOLEAN bLCKInProgress;
+	BOOLEAN	bAntennaDetected;
+	BOOLEAN	bNeedIQK;
+	BOOLEAN	bIQKInProgress;	
+	u1Byte	Delta_IQK;
+	u4Byte	ADDA_backup[IQK_ADDA_REG_NUM];
+	u4Byte	IQK_MAC_backup[IQK_MAC_REG_NUM];
+	u4Byte	IQK_BB_backup_recover[9];
+	u4Byte	IQK_BB_backup[IQK_BB_REG_NUM];	
+	u4Byte	TxIQC_8723B[2][3][2]; /* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}} */
+	u4Byte	RxIQC_8723B[2][2][2]; /* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}} */
+	u4Byte	TxIQC_8703B[3][2];	/* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}*/
+	u4Byte	RxIQC_8703B[2][2];	/* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}*/
+	
+	
+
+	// <James> IQK time measurement 
+	u8Byte	IQK_StartTime;
+	u8Byte	IQK_ProgressingTime;
+	u4Byte  LOK_Result;
+
+	//for APK
+	u4Byte 	APKoutput[2][2]; //path A/B; output1_1a/output1_2a
+	u1Byte 	bAPKdone;
+	u1Byte 	bAPKThermalMeterIgnore;
+	
+	// DPK
+	BOOLEAN bDPKFail;	
+	u1Byte 	bDPdone;
+	u1Byte 	bDPPathAOK;
+	u1Byte 	bDPPathBOK;
+
+	u4Byte	TxLOK[2];
+	u4Byte  DpkTxAGC;
+	s4Byte  DpkGain;
+	u4Byte  DpkThermal[4];	
+
+	s1Byte Modify_TxAGC_Value_OFDM;
+	s1Byte Modify_TxAGC_Value_CCK;
+}ODM_RF_CAL_T,*PODM_RF_CAL_T;
+
+
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pre_define.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pre_define.h
new file mode 100644
index 000000000..c64e0d40f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_pre_define.h
@@ -0,0 +1,615 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__PHYDMPREDEFINE_H__
+#define    __PHYDMPREDEFINE_H__
+
+//1 ============================================================
+//1  Definition 
+//1 ============================================================
+
+//Max path of IC
+#define MAX_PATH_NUM_92CS		2
+#define MAX_PATH_NUM_8188E		1
+#define MAX_PATH_NUM_8192E		2
+#define MAX_PATH_NUM_8723B		1
+#define MAX_PATH_NUM_8812A		2
+#define MAX_PATH_NUM_8821A		1
+#define MAX_PATH_NUM_8814A		4
+#define MAX_PATH_NUM_8822B		2
+#define MAX_PATH_NUM_8821B		2
+#define MAX_PATH_NUM_8703B		1
+#define MAX_PATH_NUM_8188F		1
+
+//Max RF path
+#define ODM_RF_PATH_MAX 2
+#define ODM_RF_PATH_MAX_JAGUAR 4
+
+//number of entry
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	#define	ASSOCIATE_ENTRY_NUM					MACID_NUM_SW_LIMIT  /* Max size of AsocEntry[].*/
+	#define	ODM_ASSOCIATE_ENTRY_NUM				ASSOCIATE_ENTRY_NUM
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	#define ASSOCIATE_ENTRY_NUM					NUM_STAT
+	#define	ODM_ASSOCIATE_ENTRY_NUM				(ASSOCIATE_ENTRY_NUM+1)
+#else
+	#define ODM_ASSOCIATE_ENTRY_NUM				((ASSOCIATE_ENTRY_NUM*3)+1)
+#endif
+
+/* -----MGN rate--------------------------------- */
+
+#define	ODM_MGN_1M			0x02
+#define	ODM_MGN_2M			0x04
+#define	ODM_MGN_5_5M			0x0b
+#define	ODM_MGN_11M			0x16
+
+#define	ODM_MGN_6M			0x0c
+#define	ODM_MGN_9M			0x12
+#define	ODM_MGN_12M			0x18
+#define	ODM_MGN_18M			0x24
+#define	ODM_MGN_24M			0x30
+#define	ODM_MGN_36M			0x48
+#define	ODM_MGN_48M			0x60
+#define	ODM_MGN_54M			0x6c
+
+/*TxHT = 1*/
+#define	ODM_MGN_MCS0			0x80
+#define	ODM_MGN_MCS1			0x81
+#define	ODM_MGN_MCS2			0x82
+#define	ODM_MGN_MCS3			0x83
+#define	ODM_MGN_MCS4			0x84
+#define	ODM_MGN_MCS5			0x85
+#define	ODM_MGN_MCS6			0x86
+#define	ODM_MGN_MCS7			0x87
+#define	ODM_MGN_MCS8			0x88
+#define	ODM_MGN_MCS9			0x89
+#define	ODM_MGN_MCS10		0x8a
+#define	ODM_MGN_MCS11		0x8b
+#define	ODM_MGN_MCS12		0x8c
+#define	ODM_MGN_MCS13		0x8d
+#define	ODM_MGN_MCS14		0x8e
+#define	ODM_MGN_MCS15		0x8f
+#define	ODM_MGN_VHT1SS_MCS0	0x90
+#define	ODM_MGN_VHT1SS_MCS1	0x91
+#define	ODM_MGN_VHT1SS_MCS2	0x92
+#define	ODM_MGN_VHT1SS_MCS3	0x93
+#define	ODM_MGN_VHT1SS_MCS4	0x94
+#define	ODM_MGN_VHT1SS_MCS5	0x95
+#define	ODM_MGN_VHT1SS_MCS6	0x96
+#define	ODM_MGN_VHT1SS_MCS7	0x97
+#define	ODM_MGN_VHT1SS_MCS8	0x98
+#define	ODM_MGN_VHT1SS_MCS9	0x99
+#define	ODM_MGN_VHT2SS_MCS0	0x9a
+#define	ODM_MGN_VHT2SS_MCS1	0x9b
+#define	ODM_MGN_VHT2SS_MCS2	0x9c
+#define	ODM_MGN_VHT2SS_MCS3	0x9d
+#define	ODM_MGN_VHT2SS_MCS4	0x9e
+#define	ODM_MGN_VHT2SS_MCS5	0x9f
+#define	ODM_MGN_VHT2SS_MCS6	0xa0
+#define	ODM_MGN_VHT2SS_MCS7	0xa1
+#define	ODM_MGN_VHT2SS_MCS8	0xa2
+#define	ODM_MGN_VHT2SS_MCS9	0xa3
+
+#define	ODM_MGN_MCS0_SG		0xc0
+#define	ODM_MGN_MCS1_SG		0xc1
+#define	ODM_MGN_MCS2_SG		0xc2
+#define	ODM_MGN_MCS3_SG		0xc3
+#define	ODM_MGN_MCS4_SG		0xc4
+#define	ODM_MGN_MCS5_SG		0xc5
+#define	ODM_MGN_MCS6_SG		0xc6
+#define	ODM_MGN_MCS7_SG		0xc7
+#define	ODM_MGN_MCS8_SG		0xc8
+#define	ODM_MGN_MCS9_SG		0xc9
+#define	ODM_MGN_MCS10_SG		0xca
+#define	ODM_MGN_MCS11_SG		0xcb
+#define	ODM_MGN_MCS12_SG		0xcc
+#define	ODM_MGN_MCS13_SG		0xcd
+#define	ODM_MGN_MCS14_SG		0xce
+#define	ODM_MGN_MCS15_SG		0xcf
+
+/* -----DESC rate--------------------------------- */
+
+#define ODM_RATEMCS15_SG		0x1c
+#define ODM_RATEMCS32			0x20
+
+
+// CCK Rates, TxHT = 0
+#define ODM_RATE1M				0x00
+#define ODM_RATE2M				0x01
+#define ODM_RATE5_5M			0x02
+#define ODM_RATE11M				0x03
+// OFDM Rates, TxHT = 0
+#define ODM_RATE6M				0x04
+#define ODM_RATE9M				0x05
+#define ODM_RATE12M				0x06
+#define ODM_RATE18M				0x07
+#define ODM_RATE24M				0x08
+#define ODM_RATE36M				0x09
+#define ODM_RATE48M				0x0A
+#define ODM_RATE54M				0x0B
+// MCS Rates, TxHT = 1
+#define ODM_RATEMCS0			0x0C
+#define ODM_RATEMCS1			0x0D
+#define ODM_RATEMCS2			0x0E
+#define ODM_RATEMCS3			0x0F
+#define ODM_RATEMCS4			0x10
+#define ODM_RATEMCS5			0x11
+#define ODM_RATEMCS6			0x12
+#define ODM_RATEMCS7			0x13
+#define ODM_RATEMCS8			0x14
+#define ODM_RATEMCS9			0x15
+#define ODM_RATEMCS10			0x16
+#define ODM_RATEMCS11			0x17
+#define ODM_RATEMCS12			0x18
+#define ODM_RATEMCS13			0x19
+#define ODM_RATEMCS14			0x1A
+#define ODM_RATEMCS15			0x1B
+#define ODM_RATEMCS16			0x1C
+#define ODM_RATEMCS17			0x1D
+#define ODM_RATEMCS18			0x1E
+#define ODM_RATEMCS19			0x1F
+#define ODM_RATEMCS20			0x20
+#define ODM_RATEMCS21			0x21
+#define ODM_RATEMCS22			0x22
+#define ODM_RATEMCS23			0x23
+#define ODM_RATEMCS24			0x24
+#define ODM_RATEMCS25			0x25
+#define ODM_RATEMCS26			0x26
+#define ODM_RATEMCS27			0x27
+#define ODM_RATEMCS28			0x28
+#define ODM_RATEMCS29			0x29
+#define ODM_RATEMCS30			0x2A
+#define ODM_RATEMCS31			0x2B
+#define ODM_RATEVHTSS1MCS0		0x2C
+#define ODM_RATEVHTSS1MCS1		0x2D
+#define ODM_RATEVHTSS1MCS2		0x2E
+#define ODM_RATEVHTSS1MCS3		0x2F
+#define ODM_RATEVHTSS1MCS4		0x30
+#define ODM_RATEVHTSS1MCS5		0x31
+#define ODM_RATEVHTSS1MCS6		0x32
+#define ODM_RATEVHTSS1MCS7		0x33
+#define ODM_RATEVHTSS1MCS8		0x34
+#define ODM_RATEVHTSS1MCS9		0x35
+#define ODM_RATEVHTSS2MCS0		0x36
+#define ODM_RATEVHTSS2MCS1		0x37
+#define ODM_RATEVHTSS2MCS2		0x38
+#define ODM_RATEVHTSS2MCS3		0x39
+#define ODM_RATEVHTSS2MCS4		0x3A
+#define ODM_RATEVHTSS2MCS5		0x3B
+#define ODM_RATEVHTSS2MCS6		0x3C
+#define ODM_RATEVHTSS2MCS7		0x3D
+#define ODM_RATEVHTSS2MCS8		0x3E
+#define ODM_RATEVHTSS2MCS9		0x3F
+#define ODM_RATEVHTSS3MCS0		0x40
+#define ODM_RATEVHTSS3MCS1		0x41
+#define ODM_RATEVHTSS3MCS2		0x42
+#define ODM_RATEVHTSS3MCS3		0x43
+#define ODM_RATEVHTSS3MCS4		0x44
+#define ODM_RATEVHTSS3MCS5		0x45
+#define ODM_RATEVHTSS3MCS6		0x46
+#define ODM_RATEVHTSS3MCS7		0x47
+#define ODM_RATEVHTSS3MCS8		0x48
+#define ODM_RATEVHTSS3MCS9		0x49
+#define ODM_RATEVHTSS4MCS0		0x4A
+#define ODM_RATEVHTSS4MCS1		0x4B
+#define ODM_RATEVHTSS4MCS2		0x4C
+#define ODM_RATEVHTSS4MCS3		0x4D
+#define ODM_RATEVHTSS4MCS4		0x4E
+#define ODM_RATEVHTSS4MCS5		0x4F
+#define ODM_RATEVHTSS4MCS6		0x50
+#define ODM_RATEVHTSS4MCS7		0x51
+#define ODM_RATEVHTSS4MCS8		0x52
+#define ODM_RATEVHTSS4MCS9		0x53
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#define ODM_NUM_RATE_IDX (ODM_RATEVHTSS4MCS9+1)
+#else
+	#if (RTL8192E_SUPPORT == 1)
+		#define ODM_NUM_RATE_IDX (ODM_RATEMCS15+1)
+	#elif (RTL8723B_SUPPORT == 1) || (RTL8188E_SUPPORT == 1) || (RTL8188F_SUPPORT == 1) 
+		#define ODM_NUM_RATE_IDX (ODM_RATEMCS7+1)
+	#elif (RTL8821A_SUPPORT == 1) || (RTL8881A_SUPPORT == 1) 
+		#define ODM_NUM_RATE_IDX (ODM_RATEVHTSS1MCS9+1)
+	#elif (RTL8812A_SUPPORT == 1)
+		#define ODM_NUM_RATE_IDX (ODM_RATEVHTSS2MCS9+1)
+	#elif(RTL8814A_SUPPORT == 1)
+		#define ODM_NUM_RATE_IDX (ODM_RATEVHTSS3MCS9+1)
+	#else
+		#define ODM_NUM_RATE_IDX (ODM_RATEVHTSS4MCS9+1)
+	#endif
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#define CONFIG_SFW_SUPPORTED
+#endif
+
+//1 ============================================================
+//1  enumeration
+//1 ============================================================
+
+
+//	ODM_CMNINFO_INTERFACE
+typedef enum tag_ODM_Support_Interface_Definition
+{
+	ODM_ITRF_PCIE 	=	0x1,
+	ODM_ITRF_USB 	=	0x2,
+	ODM_ITRF_SDIO 	=	0x4,
+	ODM_ITRF_ALL 	=	0x7,
+}ODM_INTERFACE_E;
+
+// ODM_CMNINFO_IC_TYPE
+typedef enum tag_ODM_Support_IC_Type_Definition
+{
+	ODM_RTL8192S 	=	BIT0,
+	ODM_RTL8192C 	=	BIT1,
+	ODM_RTL8192D 	=	BIT2,
+	ODM_RTL8723A 	=	BIT3,
+	ODM_RTL8188E 	=	BIT4,
+	ODM_RTL8812 	=	BIT5,
+	ODM_RTL8821 	=	BIT6,
+	ODM_RTL8192E 	=	BIT7,	
+	ODM_RTL8723B	=	BIT8,
+	ODM_RTL8814A	=	BIT9,	
+	ODM_RTL8881A 	=	BIT10,
+	ODM_RTL8821B 	=	BIT11,
+	ODM_RTL8822B 	=	BIT12,
+	ODM_RTL8703B 	=	BIT13,
+	ODM_RTL8195A	=	BIT14,
+	ODM_RTL8188F 	=	BIT15
+}ODM_IC_TYPE_E;
+
+
+
+
+#define ODM_IC_11N_SERIES		(ODM_RTL8192S|ODM_RTL8192C|ODM_RTL8192D|ODM_RTL8723A|ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8703B|ODM_RTL8188F)
+#define ODM_IC_11AC_SERIES		(ODM_RTL8812|ODM_RTL8821|ODM_RTL8814A|ODM_RTL8881A|ODM_RTL8821B|ODM_RTL8822B)
+#define ODM_IC_TXBF_SUPPORT		(ODM_RTL8192E|ODM_RTL8812|ODM_RTL8821|ODM_RTL8814A|ODM_RTL8881A|ODM_RTL8822B)
+#define ODM_IC_11N_GAIN_IDX_EDCCA		(ODM_RTL8195A|ODM_RTL8703B|ODM_RTL8188F)
+#define ODM_IC_11AC_GAIN_IDX_EDCCA		(ODM_RTL8814A|ODM_RTL8822B)
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+#ifdef RTK_AC_SUPPORT
+#define ODM_IC_11AC_SERIES_SUPPORT		1
+#else
+#define ODM_IC_11AC_SERIES_SUPPORT		0
+#endif
+
+#define ODM_IC_11N_SERIES_SUPPORT			1
+#define ODM_CONFIG_BT_COEXIST				0
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#define ODM_IC_11AC_SERIES_SUPPORT		1
+#define ODM_IC_11N_SERIES_SUPPORT			1
+#define ODM_CONFIG_BT_COEXIST				1
+
+#else 
+
+#if((RTL8192C_SUPPORT == 1) || (RTL8192D_SUPPORT == 1) || (RTL8723A_SUPPORT == 1) || (RTL8188E_SUPPORT == 1) ||\
+(RTL8723B_SUPPORT == 1) || (RTL8192E_SUPPORT == 1) || (RTL8195A_SUPPORT == 1) || (RTL8703B_SUPPORT == 1) || \
+(RTL8188F_SUPPORT == 1))
+#define ODM_IC_11N_SERIES_SUPPORT			1
+#define ODM_IC_11AC_SERIES_SUPPORT		0
+#else
+#define ODM_IC_11N_SERIES_SUPPORT			0
+#define ODM_IC_11AC_SERIES_SUPPORT		1
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+#define ODM_CONFIG_BT_COEXIST				1
+#else
+#define ODM_CONFIG_BT_COEXIST				0
+#endif
+
+#endif
+
+
+//ODM_CMNINFO_CUT_VER
+typedef enum tag_ODM_Cut_Version_Definition
+{
+	ODM_CUT_A 		=	0,
+	ODM_CUT_B 		=	1,
+	ODM_CUT_C 		=	2,
+	ODM_CUT_D 		=	3,
+	ODM_CUT_E 		=	4,
+	ODM_CUT_F 		=	5,
+
+	ODM_CUT_I 		=	8,
+	ODM_CUT_J 		=	9,
+	ODM_CUT_K 		=	10,	
+	ODM_CUT_TEST 	=	15,
+}ODM_CUT_VERSION_E;
+
+// ODM_CMNINFO_FAB_VER
+typedef enum tag_ODM_Fab_Version_Definition
+{
+	ODM_TSMC 	=	0,
+	ODM_UMC 	=	1,
+}ODM_FAB_E;
+
+// ODM_CMNINFO_RF_TYPE
+//
+// For example 1T2R (A+AB = BIT0|BIT4|BIT5)
+//
+typedef enum tag_ODM_RF_Path_Bit_Definition
+{
+	ODM_RF_A = BIT0,
+	ODM_RF_B = BIT1,
+	ODM_RF_C = BIT2,
+	ODM_RF_D = BIT3,
+}ODM_RF_PATH_E;
+
+typedef enum tag_PHYDM_RF_TX_NUM {
+	ODM_1T	=	1,
+	ODM_2T	=	2,
+	ODM_3T	=	3,
+	ODM_4T	=	4,
+} ODM_RF_TX_NUM_E;
+
+typedef enum tag_ODM_RF_Type_Definition {
+	ODM_1T1R,
+	ODM_1T2R,
+	ODM_2T2R,
+	ODM_2T2R_GREEN,
+	ODM_2T3R,
+	ODM_2T4R,
+	ODM_3T3R,
+	ODM_3T4R,
+	ODM_4T4R,
+	ODM_XTXR
+}ODM_RF_TYPE_E;
+
+
+typedef enum tag_ODM_MAC_PHY_Mode_Definition
+{
+	ODM_SMSP	= 0,
+	ODM_DMSP	= 1,
+	ODM_DMDP	= 2,
+}ODM_MAC_PHY_MODE_E;
+
+
+typedef enum tag_BT_Coexist_Definition
+{	
+	ODM_BT_BUSY 		= 1,
+	ODM_BT_ON 			= 2,
+	ODM_BT_OFF 		= 3,
+	ODM_BT_NONE 		= 4,
+}ODM_BT_COEXIST_E;
+
+// ODM_CMNINFO_OP_MODE
+typedef enum tag_Operation_Mode_Definition
+{
+	ODM_NO_LINK 		= BIT0,
+	ODM_LINK 			= BIT1,
+	ODM_SCAN 			= BIT2,
+	ODM_POWERSAVE 	= BIT3,
+	ODM_AP_MODE 		= BIT4,
+	ODM_CLIENT_MODE	= BIT5,
+	ODM_AD_HOC 		= BIT6,
+	ODM_WIFI_DIRECT	= BIT7,
+	ODM_WIFI_DISPLAY	= BIT8,
+}ODM_OPERATION_MODE_E;
+
+// ODM_CMNINFO_WM_MODE
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+typedef enum tag_Wireless_Mode_Definition
+{
+	ODM_WM_UNKNOW	= 0x0,
+	ODM_WM_B			= BIT0,
+	ODM_WM_G			= BIT1,
+	ODM_WM_A			= BIT2,
+	ODM_WM_N24G		= BIT3,
+	ODM_WM_N5G		= BIT4,
+	ODM_WM_AUTO		= BIT5,
+	ODM_WM_AC		= BIT6,
+}ODM_WIRELESS_MODE_E;
+#else
+typedef enum tag_Wireless_Mode_Definition
+{
+	ODM_WM_UNKNOWN	= 0x00,/*0x0*/
+	ODM_WM_A			= BIT0, /* 0x1*/
+	ODM_WM_B			= BIT1, /* 0x2*/
+	ODM_WM_G			= BIT2,/* 0x4*/
+	ODM_WM_AUTO		= BIT3,/* 0x8*/
+	ODM_WM_N24G		= BIT4,/* 0x10*/
+	ODM_WM_N5G		= BIT5,/* 0x20*/
+	ODM_WM_AC_5G		= BIT6,/* 0x40*/
+	ODM_WM_AC_24G	= BIT7,/* 0x80*/
+	ODM_WM_AC_ONLY	= BIT8,/* 0x100*/
+	ODM_WM_MAX		= BIT11/* 0x800*/
+
+}ODM_WIRELESS_MODE_E;
+#endif
+
+// ODM_CMNINFO_BAND
+typedef enum tag_Band_Type_Definition
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	ODM_BAND_2_4G 	= BIT0,
+	ODM_BAND_5G 		= BIT1,
+#else
+	ODM_BAND_2_4G = 0,
+	ODM_BAND_5G,
+	ODM_BAND_ON_BOTH,
+	ODM_BANDMAX
+#endif
+}ODM_BAND_TYPE_E;
+
+
+// ODM_CMNINFO_SEC_CHNL_OFFSET
+typedef enum tag_Secondary_Channel_Offset_Definition
+{
+	ODM_DONT_CARE 	= 0,
+	ODM_BELOW 		= 1,
+	ODM_ABOVE 			= 2
+}ODM_SEC_CHNL_OFFSET_E;
+
+// ODM_CMNINFO_SEC_MODE
+typedef enum tag_Security_Definition
+{
+	ODM_SEC_OPEN 			= 0,
+	ODM_SEC_WEP40 		= 1,
+	ODM_SEC_TKIP 			= 2,
+	ODM_SEC_RESERVE 		= 3,
+	ODM_SEC_AESCCMP 		= 4,
+	ODM_SEC_WEP104 		= 5,
+	ODM_WEP_WPA_MIXED    = 6, // WEP + WPA
+	ODM_SEC_SMS4 			= 7,
+}ODM_SECURITY_E;
+
+// ODM_CMNINFO_BW
+typedef enum tag_Bandwidth_Definition
+{	
+	ODM_BW20M 		= 0,
+	ODM_BW40M 		= 1,
+	ODM_BW80M 		= 2,
+	ODM_BW160M 		= 3,
+	ODM_BW5M			= 4,
+	ODM_BW10M			= 5,
+	ODM_BW_MAX		= 6
+}ODM_BW_E;
+
+// ODM_CMNINFO_CHNL
+
+// ODM_CMNINFO_BOARD_TYPE
+typedef enum tag_Board_Definition
+{
+    ODM_BOARD_DEFAULT  	= 0, 	  // The DEFAULT case.
+    ODM_BOARD_MINICARD  = BIT(0), // 0 = non-mini card, 1= mini card.
+    ODM_BOARD_SLIM      = BIT(1), // 0 = non-slim card, 1 = slim card
+    ODM_BOARD_BT        = BIT(2), // 0 = without BT card, 1 = with BT
+    ODM_BOARD_EXT_PA    = BIT(3), // 0 = no 2G ext-PA, 1 = existing 2G ext-PA
+    ODM_BOARD_EXT_LNA   = BIT(4), // 0 = no 2G ext-LNA, 1 = existing 2G ext-LNA
+    ODM_BOARD_EXT_TRSW  = BIT(5), // 0 = no ext-TRSW, 1 = existing ext-TRSW
+    ODM_BOARD_EXT_PA_5G	= BIT(6), // 0 = no 5G ext-PA, 1 = existing 5G ext-PA
+    ODM_BOARD_EXT_LNA_5G= BIT(7), // 0 = no 5G ext-LNA, 1 = existing 5G ext-LNA
+}ODM_BOARD_TYPE_E;
+
+typedef enum tag_ODM_Package_Definition
+{
+    ODM_PACKAGE_DEFAULT  	 = 0, 	  
+    ODM_PACKAGE_QFN68        = BIT(0), 
+    ODM_PACKAGE_TFBGA90      = BIT(1), 
+    ODM_PACKAGE_TFBGA79      = BIT(2),	
+}ODM_Package_TYPE_E;
+
+typedef enum tag_ODM_TYPE_GPA_Definition {
+	TYPE_GPA0 = 0x0000,
+	TYPE_GPA1 = 0x0055,
+	TYPE_GPA2 = 0x00AA,
+	TYPE_GPA3 = 0x00FF,
+	TYPE_GPA4 = 0x5500,
+	TYPE_GPA5 = 0x5555,
+	TYPE_GPA6 = 0x55AA,
+	TYPE_GPA7 = 0x55FF,
+	TYPE_GPA8 = 0xAA00,
+	TYPE_GPA9 = 0xAA55,
+	TYPE_GPA10 = 0xAAAA,
+	TYPE_GPA11 = 0xAAFF,
+	TYPE_GPA12 = 0xFF00,
+	TYPE_GPA13 = 0xFF55,
+	TYPE_GPA14 = 0xFFAA,
+	TYPE_GPA15 = 0xFFFF,
+}ODM_TYPE_GPA_E;
+
+typedef enum tag_ODM_TYPE_APA_Definition {
+	TYPE_APA0 = 0x0000,
+	TYPE_APA1 = 0x0055,
+	TYPE_APA2 = 0x00AA,
+	TYPE_APA3 = 0x00FF,
+	TYPE_APA4 = 0x5500,
+	TYPE_APA5 = 0x5555,
+	TYPE_APA6 = 0x55AA,
+	TYPE_APA7 = 0x55FF,
+	TYPE_APA8 = 0xAA00,
+	TYPE_APA9 = 0xAA55,
+	TYPE_APA10 = 0xAAAA,
+	TYPE_APA11 = 0xAAFF,
+	TYPE_APA12 = 0xFF00,
+	TYPE_APA13 = 0xFF55,
+	TYPE_APA14 = 0xFFAA,
+	TYPE_APA15 = 0xFFFF,
+}ODM_TYPE_APA_E;
+
+typedef enum tag_ODM_TYPE_GLNA_Definition {
+	TYPE_GLNA0 = 0x0000,
+	TYPE_GLNA1 = 0x0055,
+	TYPE_GLNA2 = 0x00AA,
+	TYPE_GLNA3 = 0x00FF,
+	TYPE_GLNA4 = 0x5500,
+	TYPE_GLNA5 = 0x5555,
+	TYPE_GLNA6 = 0x55AA,
+	TYPE_GLNA7 = 0x55FF,
+	TYPE_GLNA8 = 0xAA00,
+	TYPE_GLNA9 = 0xAA55,
+	TYPE_GLNA10 = 0xAAAA,
+	TYPE_GLNA11 = 0xAAFF,
+	TYPE_GLNA12 = 0xFF00,
+	TYPE_GLNA13 = 0xFF55,
+	TYPE_GLNA14 = 0xFFAA,
+	TYPE_GLNA15 = 0xFFFF,
+}ODM_TYPE_GLNA_E;
+
+typedef enum tag_ODM_TYPE_ALNA_Definition {
+	TYPE_ALNA0 = 0x0000,
+	TYPE_ALNA1 = 0x0055,
+	TYPE_ALNA2 = 0x00AA,
+	TYPE_ALNA3 = 0x00FF,
+	TYPE_ALNA4 = 0x5500,
+	TYPE_ALNA5 = 0x5555,
+	TYPE_ALNA6 = 0x55AA,
+	TYPE_ALNA7 = 0x55FF,
+	TYPE_ALNA8 = 0xAA00,
+	TYPE_ALNA9 = 0xAA55,
+	TYPE_ALNA10 = 0xAAAA,
+	TYPE_ALNA11 = 0xAAFF,
+	TYPE_ALNA12 = 0xFF00,
+	TYPE_ALNA13 = 0xFF55,
+	TYPE_ALNA14 = 0xFFAA,
+	TYPE_ALNA15 = 0xFFFF,
+}ODM_TYPE_ALNA_E;
+
+
+typedef enum _ODM_RF_RADIO_PATH {
+    ODM_RF_PATH_A = 0,   //Radio Path A
+    ODM_RF_PATH_B = 1,   //Radio Path B
+    ODM_RF_PATH_C = 2,   //Radio Path C
+    ODM_RF_PATH_D = 3,   //Radio Path D
+    ODM_RF_PATH_AB,
+    ODM_RF_PATH_AC,
+    ODM_RF_PATH_AD,
+    ODM_RF_PATH_BC,
+    ODM_RF_PATH_BD,
+    ODM_RF_PATH_CD,
+    ODM_RF_PATH_ABC,
+    ODM_RF_PATH_ACD,
+    ODM_RF_PATH_BCD,
+    ODM_RF_PATH_ABCD,
+  //  ODM_RF_PATH_MAX,    //Max RF number 90 support
+} ODM_RF_RADIO_PATH_E, *PODM_RF_RADIO_PATH_E;
+
+typedef enum _ODM_PARAMETER_INIT {
+	ODM_PRE_SETTING = 0,
+	ODM_POST_SETTING = 1,
+} ODM_PARAMETER_INIT_E;
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_precomp.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_precomp.h
new file mode 100644
index 000000000..99f96a771
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_precomp.h
@@ -0,0 +1,320 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__ODM_PRECOMP_H__
+#define __ODM_PRECOMP_H__
+
+#include "phydm_types.h"
+#include "phydm_features.h"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#include "Precomp.h"		// We need to include mp_precomp.h due to batch file setting.
+#else
+#define		TEST_FALG___		1
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE ==ODM_CE) 
+#define 	RTL8192CE_SUPPORT 				0
+#define 	RTL8192CU_SUPPORT 				0
+#define 	RTL8192C_SUPPORT 				0	
+
+#define 	RTL8192DE_SUPPORT 				0
+#define 	RTL8192DU_SUPPORT 				0
+#define 	RTL8192D_SUPPORT 				0	
+
+#define 	RTL8723AU_SUPPORT				0
+#define 	RTL8723AS_SUPPORT				0
+#define 	RTL8723AE_SUPPORT				0
+#define 	RTL8723A_SUPPORT				0
+#define 	RTL8723_FPGA_VERIFICATION		0
+#endif
+
+//2 Config Flags and Structs - defined by each ODM Type
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	#include "../8192cd_cfg.h"
+	#include "../odm_inc.h"
+
+	#include "../8192cd.h"
+	#include "../8192cd_util.h"
+	#ifdef _BIG_ENDIAN_
+	#define	ODM_ENDIAN_TYPE				ODM_ENDIAN_BIG
+	#else
+	#define	ODM_ENDIAN_TYPE				ODM_ENDIAN_LITTLE
+	#endif
+
+	#ifdef AP_BUILD_WORKAROUND
+	#include "../8192cd_headers.h"
+	#include "../8192cd_debug.h"		
+	#endif
+
+#elif (DM_ODM_SUPPORT_TYPE ==ODM_CE)
+	#define __PACK
+	#define __WLAN_ATTRIB_PACK__
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#include "mp_precomp.h"
+	#define	ODM_ENDIAN_TYPE				ODM_ENDIAN_LITTLE
+	#define __PACK
+	#define __WLAN_ATTRIB_PACK__
+#endif
+
+//2 OutSrc Header Files
+ 
+#include "phydm.h" 
+#include "phydm_hwconfig.h"
+#include "phydm_debug.h"
+#include "phydm_regdefine11ac.h"
+#include "phydm_regdefine11n.h"
+#include "phydm_interface.h"
+#include "phydm_reg.h"
+
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_CE)
+#define RTL8821B_SUPPORT		0
+#define RTL8822B_SUPPORT		0
+
+VOID
+PHY_SetTxPowerLimit(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	u8	*Regulation,
+	IN	u8	*Band,
+	IN	u8	*Bandwidth,
+	IN	u8	*RateSection,
+	IN	u8	*RfPath,
+	IN	u8	*Channel,
+	IN	u8	*PowerLimit
+);
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+#define RTL8821B_SUPPORT		0
+#define RTL8822B_SUPPORT		0
+#define RTL8703B_SUPPORT		0
+#define RTL8188F_SUPPORT		0
+#endif
+
+#if RTL8188E_SUPPORT == 1
+#define RTL8188E_T_SUPPORT 1
+#ifdef CONFIG_SFW_SUPPORTED
+#define RTL8188E_S_SUPPORT 1
+#else
+#define RTL8188E_S_SUPPORT 0
+#endif
+#endif
+
+#if (RTL8188E_SUPPORT==1) 
+#include "rtl8188e/hal8188erateadaptive.h"//for  RA,Power training
+#include "rtl8188e/halhwimg8188e_mac.h"
+#include "rtl8188e/halhwimg8188e_rf.h"
+#include "rtl8188e/halhwimg8188e_bb.h"
+#include "rtl8188e/halhwimg8188e_t_fw.h"
+#include "rtl8188e/halhwimg8188e_s_fw.h"
+#include "rtl8188e/phydm_regconfig8188e.h"
+#include "rtl8188e/phydm_rtl8188e.h"
+#include "rtl8188e/hal8188ereg.h"
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#include "rtl8188e_hal.h" 
+	#include "rtl8188e/halphyrf_8188e_ce.h"
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#include "rtl8188e/halphyrf_8188e_win.h"
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	#include "rtl8188e/halphyrf_8188e_ap.h"
+#endif
+#endif  //88E END
+
+#if (RTL8192E_SUPPORT==1) 
+
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		#include "rtl8192e/halphyrf_8192e_win.h" /*FOR_8192E_IQK*/
+	#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+		#include "rtl8192e/halphyrf_8192e_ap.h" /*FOR_8192E_IQK*/
+	#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+		#include "rtl8192e/halphyrf_8192e_ce.h" /*FOR_8192E_IQK*/
+	#endif
+	
+#include "rtl8192e/phydm_rtl8192e.h" //FOR_8192E_IQK
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+	#include "rtl8192e/halhwimg8192e_bb.h"
+	#include "rtl8192e/halhwimg8192e_mac.h"
+	#include "rtl8192e/halhwimg8192e_rf.h"
+	#include "rtl8192e/phydm_regconfig8192e.h"
+	#include "rtl8192e/halhwimg8192e_fw.h"
+	#include "rtl8192e/hal8192ereg.h"
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#include "rtl8192e_hal.h"
+#endif
+#endif  //92E END
+
+#if (RTL8812A_SUPPORT==1)
+
+    #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+        #include "rtl8812a/halphyrf_8812a_win.h"
+    #elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+        #include "rtl8812a/halphyrf_8812a_ap.h"
+    #elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+        #include "rtl8812a/halphyrf_8812a_ce.h"
+    #endif
+
+    //#include "rtl8812a/HalPhyRf_8812A.h" //FOR_8812_IQK
+    #if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+        #include "rtl8812a/halhwimg8812a_bb.h"
+        #include "rtl8812a/halhwimg8812a_mac.h"
+        #include "rtl8812a/halhwimg8812a_rf.h"
+        #include "rtl8812a/phydm_regconfig8812a.h"
+        #include "rtl8812a/halhwimg8812a_fw.h"
+        #include "rtl8812a/phydm_rtl8812a.h"
+    #endif
+
+    #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	    #include "rtl8812a_hal.h"
+    #endif
+
+#endif //8812 END
+
+#if (RTL8814A_SUPPORT==1)
+
+#include "rtl8814a/halhwimg8814a_mac.h"
+#include "rtl8814a/halhwimg8814a_rf.h"
+#include "rtl8814a/halhwimg8814a_bb.h"
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+	#include "rtl8814a/halhwimg8814a_fw.h"
+	#include "rtl8814a/phydm_rtl8814a.h"
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#include "rtl8814a/halphyrf_8814a_win.h"
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#include "rtl8814a/halphyrf_8814a_ce.h"
+#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	#include "rtl8814a/halphyrf_8814a_ap.h"
+#endif
+	#include "rtl8814a/phydm_regconfig8814a.h"
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#include "rtl8814a_hal.h"
+	#include "rtl8814a/phydm_iqk_8814a.h"
+#endif
+#endif //8814 END
+
+#if (RTL8881A_SUPPORT==1)//FOR_8881_IQK
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#include "rtl8821a/phydm_iqk_8821a_win.h"
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#include "rtl8821a/phydm_iqk_8821a_ce.h"
+#else
+#include "rtl8821a/phydm_iqk_8821a_ap.h"
+#endif
+//#include "rtl8881a/HalHWImg8881A_BB.h"
+//#include "rtl8881a/HalHWImg8881A_MAC.h"
+//#include "rtl8881a/HalHWImg8881A_RF.h"
+//#include "rtl8881a/odm_RegConfig8881A.h"
+#endif
+
+#if (RTL8723B_SUPPORT==1) 
+#include "rtl8723b/halhwimg8723b_mac.h"
+#include "rtl8723b/halhwimg8723b_rf.h"
+#include "rtl8723b/halhwimg8723b_bb.h"
+#include "rtl8723b/halhwimg8723b_fw.h"
+#include "rtl8723b/phydm_regconfig8723b.h"
+#include "rtl8723b/phydm_rtl8723b.h"
+#include "rtl8723b/hal8723breg.h"
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+    #include "rtl8723b/halphyrf_8723b_win.h"
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+    #include "rtl8723b/halphyrf_8723b_ce.h"
+    #include "rtl8723b/halhwimg8723b_mp.h"
+    #include "rtl8723b_hal.h"
+#endif
+#endif
+
+#if (RTL8821A_SUPPORT==1) 
+#include "rtl8821a/halhwimg8821a_mac.h"
+#include "rtl8821a/halhwimg8821a_rf.h"
+#include "rtl8821a/halhwimg8821a_bb.h"
+#include "rtl8821a/halhwimg8821a_fw.h"
+#include "rtl8821a/phydm_regconfig8821a.h"
+#include "rtl8821a/phydm_rtl8821a.h"
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#include "rtl8821a/halphyrf_8821a_win.h"
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#include "rtl8821a/halphyrf_8821a_ce.h"
+	#include "rtl8821a/phydm_iqk_8821a_ce.h"/*for IQK*/
+	#include "rtl8812a/halphyrf_8812a_ce.h"/*for IQK,LCK,Power-tracking*/
+	#include "rtl8812a_hal.h"
+#else
+#endif
+#endif
+
+#if (RTL8821B_SUPPORT==1) 
+#include "rtl8821b/halhwimg8821b_mac.h"
+#include "rtl8821b/halhwimg8821b_rf.h"
+#include "rtl8821b/halhwimg8821b_bb.h"
+#include "rtl8821b/halhwimg8821b_fw.h"
+#include "rtl8821b/phydm_regconfig8821b.h"
+#include "rtl8821b/halhwimg8821b_testchip_mac.h"
+#include "rtl8821b/halhwimg8821b_testchip_rf.h"
+#include "rtl8821b/halhwimg8821b_testchip_bb.h"
+#include "rtl8821b/halhwimg8821b_testchip_fw.h"
+#include "rtl8821b/halphyrf_8821b.h"
+#endif
+
+#if (RTL8822B_SUPPORT==1) 
+#include "rtl8822b/halhwimg8822b_mac.h"
+#include "rtl8822b/halhwimg8822b_rf.h"
+#include "rtl8822b/halhwimg8822b_bb.h"
+/*#include "rtl8822b/halhwimg8822b_fw.h"*/
+#include "rtl8822b/phydm_regconfig8822b.h"
+#include "rtl8822b/halphyrf_8822b.h"
+#include "rtl8822b/phydm_rtl8822b.h"
+#include "rtl8822b/phydm_hal_api8822b.h"
+#include "rtl8822b/version_rtl8822b.h"
+#endif
+
+#if (RTL8703B_SUPPORT==1) 
+#include "rtl8703b/phydm_regconfig8703b.h"
+#include "rtl8703b/halhwimg8703b_mac.h"
+#include "rtl8703b/halhwimg8703b_rf.h"
+#include "rtl8703b/halhwimg8703b_bb.h"
+#include "rtl8703b/halhwimg8703b_fw.h"
+#include "rtl8703b/halphyrf_8703b.h"
+#include "rtl8703b/version_rtl8703b.h"
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#include "rtl8703b_hal.h"
+#endif
+#endif
+
+#if (RTL8188F_SUPPORT == 1) 
+#include "rtl8188f/halhwimg8188f_mac.h"
+#include "rtl8188f/halhwimg8188f_rf.h"
+#include "rtl8188f/halhwimg8188f_bb.h"
+#include "rtl8188f/halhwimg8188f_fw.h"
+#include "rtl8188f/hal8188freg.h"
+#include "rtl8188f/phydm_rtl8188f.h"
+#include "rtl8188f/phydm_regconfig8188f.h"
+#include "rtl8188f/halphyrf_8188f.h" /* for IQK,LCK,Power-tracking */
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#include "rtl8188f_hal.h"
+#endif
+#endif
+
+#endif	// __ODM_PRECOMP_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.c
new file mode 100644
index 000000000..df946d15d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.c
@@ -0,0 +1,2576 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#if (defined(CONFIG_RA_DBG_CMD))
+VOID
+ODM_C2HRaParaReportHandler(
+	IN	PVOID	pDM_VOID,
+	IN pu1Byte   CmdBuf,
+	IN u1Byte   CmdLen
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		    pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	u1Byte  para_idx = CmdBuf[0]; //Retry Penalty, NH, NL
+	u1Byte  RateTypeStart = CmdBuf[1];
+	u1Byte  RateTypeLength = CmdLen - 2;
+	u1Byte  i;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[ From FW C2H RA Para ]  CmdBuf[0]= (( %d ))\n", CmdBuf[0]));
+
+	if (para_idx == RADBG_RTY_PENALTY) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" |Rate Index|   |RTY Penality Index| \n"));
+
+		for (i = 0 ; i < (RateTypeLength) ; i++) {
+			if (pRA_Table->is_ra_dbg_init)
+				pRA_Table->RTY_P_default[RateTypeStart + i] = CmdBuf[2 + i];
+
+			pRA_Table->RTY_P[RateTypeStart + i] = CmdBuf[2 + i];
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("%8d  %15d \n", (RateTypeStart + i), pRA_Table->RTY_P[RateTypeStart + i]));
+		}
+
+	} else	if (para_idx == RADBG_N_HIGH) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" |Rate Index|    |N-High| \n"));
+
+
+	} else	if (para_idx == RADBG_N_LOW){
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" |Rate Index|   |N-Low| \n"));
+
+	}
+	else	 if (para_idx == RADBG_RATE_UP_RTY_RATIO) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" |Rate Index|   |Rate Up RTY Ratio| \n"));
+
+		for (i = 0 ; i < (RateTypeLength) ; i++) {
+			if (pRA_Table->is_ra_dbg_init)
+				pRA_Table->RATE_UP_RTY_RATIO_default[RateTypeStart + i] = CmdBuf[2 + i];
+
+			pRA_Table->RATE_UP_RTY_RATIO[RateTypeStart + i] = CmdBuf[2 + i];
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("%8d  %15d \n", (RateTypeStart + i), pRA_Table->RATE_UP_RTY_RATIO[RateTypeStart + i]));
+		}
+	} else	 if (para_idx == RADBG_RATE_DOWN_RTY_RATIO) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" |Rate Index|   |Rate Down RTY Ratio| \n"));
+
+		for (i = 0 ; i < (RateTypeLength) ; i++) {
+			if (pRA_Table->is_ra_dbg_init)
+				pRA_Table->RATE_DOWN_RTY_RATIO_default[RateTypeStart + i] = CmdBuf[2 + i];
+
+			pRA_Table->RATE_DOWN_RTY_RATIO[RateTypeStart + i] = CmdBuf[2 + i];
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("%8d  %15d \n", (RateTypeStart + i), pRA_Table->RATE_DOWN_RTY_RATIO[RateTypeStart + i]));
+		}
+	} else	 if (para_idx == RADBG_DEBUG_MONITOR1) {
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("-------------------------------\n"));
+		if (pDM_Odm->SupportICType & PHYDM_IC_3081_SERIES) {
+
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "RSSI =", CmdBuf[1]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "Rate =", CmdBuf[2] & 0x7f));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "SGI =", (CmdBuf[2] & 0x80) >> 7));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "BW =", CmdBuf[3]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "BW_max =", CmdBuf[4]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "multi_rate0 =", CmdBuf[5]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "multi_rate1 =", CmdBuf[6]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "DISRA =",	CmdBuf[7]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "VHT_EN =", CmdBuf[8]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "SGI_support =",	CmdBuf[9]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "try_ness =", CmdBuf[10]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "pre_rate =", CmdBuf[11]));
+		} else {
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "RSSI =", CmdBuf[1]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %x \n", "BW =", CmdBuf[2]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "DISRA =", CmdBuf[3]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "VHT_EN =", CmdBuf[4]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "Hightest Rate =", CmdBuf[5]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "Lowest Rate =", CmdBuf[6]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "SGI_support =", CmdBuf[7]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "Rate_ID =",	CmdBuf[8]));;
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("-------------------------------\n"));
+	} else	 if (para_idx == RADBG_DEBUG_MONITOR2) {
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("-------------------------------\n"));
+		if (pDM_Odm->SupportICType & PHYDM_IC_3081_SERIES) {
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %d \n", "RateID =", CmdBuf[1]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "highest_rate =", CmdBuf[2]));
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  0x%x \n", "lowest_rate =", CmdBuf[3]));
+
+			for (i = 4 ; i <= 11 ; i++)
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("RAMASK =  0x%x \n", CmdBuf[i]));
+		} else {
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  %x%x  %x%x  %x%x  %x%x \n", "RA Mask:",
+						 CmdBuf[8], CmdBuf[7], CmdBuf[6], CmdBuf[5], CmdBuf[4], CmdBuf[3], CmdBuf[2], CmdBuf[1]));
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("-------------------------------\n"));
+	} else	 if (para_idx == RADBG_DEBUG_MONITOR3) {
+
+		for (i = 0 ; i < (CmdLen - 1) ; i++)
+			ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("content[%d] =  %d \n", i, CmdBuf[1 + i]));
+	} else	 if (para_idx == RADBG_DEBUG_MONITOR4)
+		ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("%5s  {%d.%d} \n", "RA Version =", CmdBuf[1], CmdBuf[2]));
+
+}
+
+VOID
+odm_RA_ParaAdjust_Send_H2C(
+	IN	PVOID	pDM_VOID
+)
+{
+
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte			H2C_Parameter[6] = {0};
+
+	H2C_Parameter[0] =  RA_FIRST_MACID;
+
+	//ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("RA_Para_feedback_req= (( %d ))  \n",pRA_Table->RA_Para_feedback_req ));
+	if (pRA_Table->RA_Para_feedback_req) { //H2C_Parameter[5]=1 ; ask FW for all RA parameters
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[H2C] Ask FW for RA parameter \n"));
+		H2C_Parameter[5] |= BIT1; //ask FW to report RA parameters
+		H2C_Parameter[1] =  pRA_Table->para_idx; //pRA_Table->para_idx;
+		pRA_Table->RA_Para_feedback_req = 0;
+	} else {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[H2C] Send H2C to FW for modifying RA parameter \n"));
+
+		H2C_Parameter[1] =  pRA_Table->para_idx;
+		H2C_Parameter[2] =  pRA_Table->rate_idx;
+		//1 [8 bit]
+		if (pRA_Table->para_idx == RADBG_RTY_PENALTY || pRA_Table->para_idx == RADBG_RATE_UP_RTY_RATIO || pRA_Table->para_idx == RADBG_RATE_DOWN_RTY_RATIO) {
+			H2C_Parameter[3] = pRA_Table->value;
+			H2C_Parameter[4] = 0;
+		}
+		//1 [16 bit]
+		else { //if ((pRA_Table->rate_idx==RADBG_N_HIGH)||(pRA_Table->rate_idx==RADBG_N_LOW))
+			H2C_Parameter[3] = (u1Byte)(((pRA_Table->value_16) & 0xf0) >> 4); //byte1
+			H2C_Parameter[4] = (u1Byte)((pRA_Table->value_16) & 0x0f);	   //byte0
+		}
+	}
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" H2C_Parameter[1] = 0x%x  \n", H2C_Parameter[1]));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" H2C_Parameter[2] = 0x%x  \n", H2C_Parameter[2]));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" H2C_Parameter[3] = 0x%x  \n", H2C_Parameter[3]));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" H2C_Parameter[4] = 0x%x  \n", H2C_Parameter[4]));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" H2C_Parameter[5] = 0x%x  \n", H2C_Parameter[5]));
+
+	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RA_PARA_ADJUST, 6, H2C_Parameter);
+
+}
+
+
+VOID
+odm_RA_ParaAdjust(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte			para_idx = pRA_Table->para_idx;
+	u1Byte			rate_idx = pRA_Table->rate_idx;
+	u1Byte			value = pRA_Table->value;
+	u1Byte			Pre_value = 0xff;
+
+	BOOLEAN			sign = 0;
+
+	if (pRA_Table->para_idx == RADBG_RTY_PENALTY) {
+		Pre_value = pRA_Table->RTY_P[rate_idx];
+		pRA_Table->RTY_P[rate_idx] = value;
+		pRA_Table->RTY_P_modify_note[rate_idx] = 1;
+	} else 	if (pRA_Table->para_idx == RADBG_N_HIGH) {
+
+	} else 	if (pRA_Table->para_idx == RADBG_N_LOW) {
+
+	} else	 if (pRA_Table->para_idx == RADBG_RATE_UP_RTY_RATIO) {
+		Pre_value = pRA_Table->RATE_UP_RTY_RATIO[rate_idx];
+		pRA_Table->RATE_UP_RTY_RATIO[rate_idx] = value;
+		pRA_Table->RATE_UP_RTY_RATIO_modify_note[rate_idx] = 1;
+	} else	 if (pRA_Table->para_idx == RADBG_RATE_DOWN_RTY_RATIO) {
+		Pre_value = pRA_Table->RATE_DOWN_RTY_RATIO[rate_idx];
+		pRA_Table->RATE_DOWN_RTY_RATIO[rate_idx] = value;
+		pRA_Table->RATE_DOWN_RTY_RATIO_modify_note[rate_idx] = 1;
+	}
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("  Change RA Papa[%d], Rate[ %d ],   ((%d))  ->  ((%d)) \n", pRA_Table->para_idx, rate_idx, Pre_value, value));
+	odm_RA_ParaAdjust_Send_H2C(pDM_Odm);
+}
+
+
+VOID
+phydm_ra_print_msg(
+	IN		PVOID		pDM_VOID,
+	IN		u1Byte		*value,
+	IN		u1Byte		*value_default,
+	IN		u1Byte		*modify_note
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+	u4Byte i;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" |Rate index| |Current-value| |Default-value| |Modify?| \n"));
+	for (i = 0 ; i <= (pRA_Table->rate_length); i++) {
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("     [ %d ]  %20d  %25d  %20s \n", i, value[i], value_default[i], ((modify_note[i] == 1) ? "V" : " .  ")));
+#else
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("     [ %d ]  %10d  %14d  %14s \n", i, value[i], value_default[i], ((modify_note[i] == 1) ? "V" : " .  ")));
+#endif
+	}
+
+}
+
+VOID
+odm_RA_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	pRA_Table->is_ra_dbg_init = FALSE;
+
+	if (dm_value[0] == 100) { /*1 Print RA Parameters*/
+		u1Byte	default_pointer_value;
+		u1Byte	*pvalue;
+		u1Byte	*pvalue_default;
+		u1Byte	*pmodify_note;
+
+		pvalue = pvalue_default = pmodify_note = &default_pointer_value;
+
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("\n------------------------------------------------------------------------------------\n"));
+
+		if (dm_value[1] == RADBG_RTY_PENALTY) { /* [1]*/
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" [1] RTY_PENALTY\n"));
+			pvalue		=	&(pRA_Table->RTY_P[0]);
+			pvalue_default	=	&(pRA_Table->RTY_P_default[0]);
+			pmodify_note	=	(u1Byte *)&(pRA_Table->RTY_P_modify_note[0]);
+		} else if (dm_value[1] == RADBG_N_HIGH) { /* [2]*/
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" [2] N_HIGH\n"));
+
+		} else if (dm_value[1] == RADBG_N_LOW) { /*[3]*/
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" [3] N_LOW\n"));
+
+		} else if (dm_value[1] == RADBG_RATE_UP_RTY_RATIO) { /* [8]*/
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" [8] RATE_UP_RTY_RATIO\n"));
+			pvalue		=	&(pRA_Table->RATE_UP_RTY_RATIO[0]);
+			pvalue_default	=	&(pRA_Table->RATE_UP_RTY_RATIO_default[0]);
+			pmodify_note	=	(u1Byte *)&(pRA_Table->RATE_UP_RTY_RATIO_modify_note[0]);
+		} else if (dm_value[1] == RADBG_RATE_DOWN_RTY_RATIO) { /* [9]*/
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" [9] RATE_DOWN_RTY_RATIO\n"));
+			pvalue		=	&(pRA_Table->RATE_DOWN_RTY_RATIO[0]);
+			pvalue_default	=	&(pRA_Table->RATE_DOWN_RTY_RATIO_default[0]);
+			pmodify_note	=	(u1Byte *)&(pRA_Table->RATE_DOWN_RTY_RATIO_modify_note[0]);
+		}
+
+		phydm_ra_print_msg(pDM_Odm, pvalue, pvalue_default, pmodify_note);
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("\n------------------------------------------------------------------------------------\n\n"));
+
+	} else if (dm_value[0] == 101) {
+		pRA_Table->para_idx = (u1Byte)dm_value[1];
+
+		pRA_Table->RA_Para_feedback_req = 1;
+		odm_RA_ParaAdjust_Send_H2C(pDM_Odm);
+	} else {
+		pRA_Table->para_idx = (u1Byte)dm_value[0];
+		pRA_Table->rate_idx  = (u1Byte)dm_value[1];
+		pRA_Table->value = (u1Byte)dm_value[2];
+
+		odm_RA_ParaAdjust(pDM_Odm);
+	}
+
+}
+
+VOID
+odm_RA_ParaAdjust_init(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		        pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte			i;
+	u1Byte			ra_para_pool_u8[3] = { RADBG_RTY_PENALTY,  RADBG_RATE_UP_RTY_RATIO, RADBG_RATE_DOWN_RTY_RATIO};
+	/*
+		RTY_PENALTY		=	1,  //u8
+		N_HIGH 				=	2,
+		N_LOW				=	3,
+		RATE_UP_TABLE		=	4,
+		RATE_DOWN_TABLE	=	5,
+		TRYING_NECESSARY	=	6,
+		DROPING_NECESSARY =	7,
+		RATE_UP_RTY_RATIO	=	8, //u8
+		RATE_DOWN_RTY_RATIO=	9, //u8
+		ALL_PARA		=	0xff
+
+	*/
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("odm_RA_ParaAdjust_init \n"));
+
+	pRA_Table->is_ra_dbg_init = TRUE;
+	for (i = 0; i < 3; i++) {
+		pRA_Table->RA_Para_feedback_req = 1;
+		pRA_Table->para_idx	=	ra_para_pool_u8[i];
+		odm_RA_ParaAdjust_Send_H2C(pDM_Odm);
+	}
+
+	if (pDM_Odm->SupportICType == ODM_RTL8192E)
+		pRA_Table->rate_length = ODM_RATEMCS15;
+	else if ((pDM_Odm->SupportICType == ODM_RTL8723B) || (pDM_Odm->SupportICType == ODM_RTL8188E))
+		pRA_Table->rate_length = ODM_RATEMCS7;
+	else if ((pDM_Odm->SupportICType == ODM_RTL8821) || (pDM_Odm->SupportICType == ODM_RTL8881A))
+		pRA_Table->rate_length = ODM_RATEVHTSS1MCS9;
+	else if (pDM_Odm->SupportICType == ODM_RTL8812)
+		pRA_Table->rate_length = ODM_RATEVHTSS2MCS9;
+	else if (pDM_Odm->SupportICType == ODM_RTL8814A)
+		pRA_Table->rate_length = ODM_RATEVHTSS3MCS9;
+	else
+		pRA_Table->rate_length = ODM_RATEVHTSS4MCS9;
+
+}
+
+#else
+
+VOID
+ODM_C2HRaParaReportHandler(
+	IN	PVOID	pDM_VOID,
+	IN pu1Byte   CmdBuf,
+	IN u1Byte   CmdLen
+)
+{
+}
+
+VOID
+odm_RA_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value
+)
+{
+}
+
+VOID
+odm_RA_ParaAdjust_init(
+	IN		PVOID		pDM_VOID
+)
+
+{
+}
+
+#endif //#if (defined(CONFIG_RA_DBG_CMD))
+
+VOID
+phydm_ra_dynamic_retry_count(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		        pRA_Table = &pDM_Odm->DM_RA_Table;
+	PSTA_INFO_T		pEntry;
+	u1Byte	i, retry_offset;
+	u4Byte	ma_rx_tp;
+	/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("pDM_Odm->pre_b_noisy = %d\n", pDM_Odm->pre_b_noisy ));*/
+	if (pDM_Odm->pre_b_noisy != pDM_Odm->NoisyDecision) {
+
+		if (pDM_Odm->NoisyDecision) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("->Noisy Env. RA fallback value\n"));
+			ODM_SetMACReg(pDM_Odm, 0x430, bMaskDWord, 0x0);
+			ODM_SetMACReg(pDM_Odm, 0x434, bMaskDWord, 0x04030201);		
+		} else {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("->Clean Env. RA fallback value\n"));
+			ODM_SetMACReg(pDM_Odm, 0x430, bMaskDWord, 0x02010000);
+			ODM_SetMACReg(pDM_Odm, 0x434, bMaskDWord, 0x06050403);		
+		}
+		pDM_Odm->pre_b_noisy = pDM_Odm->NoisyDecision;
+	}
+}
+
+#if (defined(CONFIG_RA_DYNAMIC_RTY_LIMIT))
+
+VOID
+phydm_retry_limit_table_bound(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	*retry_limit,
+	IN	u1Byte	offset
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		        pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	if (*retry_limit >  offset) {
+		
+		*retry_limit -= offset;
+		
+		if (*retry_limit < pRA_Table->retrylimit_low)
+			*retry_limit = pRA_Table->retrylimit_low;
+		else if (*retry_limit > pRA_Table->retrylimit_high)
+			*retry_limit = pRA_Table->retrylimit_high;
+	} else
+		*retry_limit = pRA_Table->retrylimit_low;
+}
+
+VOID
+phydm_reset_retry_limit_table(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		        pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte			i;
+
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN) /*support all IC platform*/
+
+	#else
+		#if ((RTL8192E_SUPPORT == 1) || (RTL8723B_SUPPORT == 1) || (RTL8188E_SUPPORT == 1)) 
+			u1Byte per_rate_retrylimit_table_20M[ODM_RATEMCS15+1] = {
+				1, 1, 2, 4,					/*CCK*/
+				2, 2, 4, 6, 8, 12, 16, 18,		/*OFDM*/
+				2, 4, 6, 8, 12, 18, 20, 22,		/*20M HT-1SS*/
+				2, 4, 6, 8, 12, 18, 20, 22		/*20M HT-2SS*/
+			};
+			u1Byte per_rate_retrylimit_table_40M[ODM_RATEMCS15+1] = {
+				1, 1, 2, 4,					/*CCK*/
+				2, 2, 4, 6, 8, 12, 16, 18,		/*OFDM*/
+				4, 8, 12, 16, 24, 32, 32, 32,		/*40M HT-1SS*/
+				4, 8, 12, 16, 24, 32, 32, 32		/*40M HT-2SS*/
+			};
+
+		#elif (RTL8821A_SUPPORT == 1) || (RTL8881A_SUPPORT == 1) 
+
+		#elif (RTL8812A_SUPPORT == 1)
+
+		#elif(RTL8814A_SUPPORT == 1)
+
+		#else
+
+		#endif
+	#endif
+
+	memcpy(&(pRA_Table->per_rate_retrylimit_20M[0]), &(per_rate_retrylimit_table_20M[0]), ODM_NUM_RATE_IDX);
+	memcpy(&(pRA_Table->per_rate_retrylimit_40M[0]), &(per_rate_retrylimit_table_40M[0]), ODM_NUM_RATE_IDX);
+
+	for (i = 0; i < ODM_NUM_RATE_IDX; i++) {
+		phydm_retry_limit_table_bound(pDM_Odm, &(pRA_Table->per_rate_retrylimit_20M[i]), 0);
+		phydm_retry_limit_table_bound(pDM_Odm, &(pRA_Table->per_rate_retrylimit_40M[i]), 0);
+	}	
+}
+
+VOID
+phydm_ra_dynamic_retry_limit(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		        pRA_Table = &pDM_Odm->DM_RA_Table;
+	PSTA_INFO_T		pEntry;
+	u1Byte	i, retry_offset;
+	u4Byte	ma_rx_tp;
+
+
+	if (pDM_Odm->pre_number_active_client == pDM_Odm->number_active_client) {
+		
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, (" pre_number_active_client ==  number_active_client\n"));
+		return;
+		
+	} else {
+		if (pDM_Odm->number_active_client == 1) {
+			phydm_reset_retry_limit_table(pDM_Odm);
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("one client only->reset to default value\n"));
+		} else {
+
+			retry_offset = pDM_Odm->number_active_client * pRA_Table->retry_descend_num;
+			
+			for (i = 0; i < ODM_NUM_RATE_IDX; i++) {
+
+				phydm_retry_limit_table_bound(pDM_Odm, &(pRA_Table->per_rate_retrylimit_20M[i]), retry_offset);
+				phydm_retry_limit_table_bound(pDM_Odm, &(pRA_Table->per_rate_retrylimit_40M[i]), retry_offset);	
+			}				
+		}
+	}
+}
+
+VOID
+phydm_ra_dynamic_retry_limit_init(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		        pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	pRA_Table->retry_descend_num = RA_RETRY_DESCEND_NUM;
+	pRA_Table->retrylimit_low = RA_RETRY_LIMIT_LOW;
+	pRA_Table->retrylimit_high = RA_RETRY_LIMIT_HIGH;
+	
+	phydm_reset_retry_limit_table(pDM_Odm);
+	
+}
+#else
+VOID
+phydm_ra_dynamic_retry_limit(
+	IN	PVOID	pDM_VOID
+)
+{
+}
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+VOID
+phydm_ra_dynamic_rate_id_on_assoc(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	wireless_mode,
+	IN	u1Byte	init_rate_id
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("[ON ASSOC] rf_mode = ((0x%x)), wireless_mode = ((0x%x)), init_rate_id = ((0x%x))\n", pDM_Odm->RFType, wireless_mode, init_rate_id));
+	
+	if ((pDM_Odm->RFType == ODM_2T2R) | (pDM_Odm->RFType == ODM_2T2R_GREEN) | (pDM_Odm->RFType == ODM_2T3R) | (pDM_Odm->RFType == ODM_2T4R)) {
+		
+		if ((pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8192E)) &&
+			(wireless_mode & (ODM_WM_N24G | ODM_WM_N5G))
+			){
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("[ON ASSOC] set N-2SS ARFR5 table\n"));
+			ODM_SetMACReg(pDM_Odm, 0x4a4, bMaskDWord, 0xfc1ffff);	/*N-2SS, ARFR5, rate_id = 0xe*/
+			ODM_SetMACReg(pDM_Odm, 0x4a8, bMaskDWord, 0x0);		/*N-2SS, ARFR5, rate_id = 0xe*/
+		} else if ((pDM_Odm->SupportICType & (ODM_RTL8812)) &&
+			(wireless_mode & (ODM_WM_AC_5G | ODM_WM_AC_24G | ODM_WM_AC_ONLY))
+			){
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("[ON ASSOC] set AC-2SS ARFR0 table\n"));
+			ODM_SetMACReg(pDM_Odm, 0x444, bMaskDWord, 0x0fff);	/*AC-2SS, ARFR0, rate_id = 0x9*/
+			ODM_SetMACReg(pDM_Odm, 0x448, bMaskDWord, 0xff01f000);		/*AC-2SS, ARFR0, rate_id = 0x9*/
+		}
+	}
+
+}
+
+VOID
+phydm_ra_dynamic_rate_id_init(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8192E)) {
+		
+		ODM_SetMACReg(pDM_Odm, 0x4a4, bMaskDWord, 0xfc1ffff);	/*N-2SS, ARFR5, rate_id = 0xe*/
+		ODM_SetMACReg(pDM_Odm, 0x4a8, bMaskDWord, 0x0);		/*N-2SS, ARFR5, rate_id = 0xe*/
+		
+		ODM_SetMACReg(pDM_Odm, 0x444, bMaskDWord, 0x0fff);		/*AC-2SS, ARFR0, rate_id = 0x9*/
+		ODM_SetMACReg(pDM_Odm, 0x448, bMaskDWord, 0xff01f000);	/*AC-2SS, ARFR0, rate_id = 0x9*/
+	}
+}
+
+VOID
+phydm_update_rate_id(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	rate,
+	IN	u1Byte	platform_macid
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte		current_tx_ss;
+	u1Byte		rate_idx = rate & 0x7f; /*remove bit7 SGI*/
+	u1Byte		wireless_mode;
+	u1Byte		phydm_macid;
+	PSTA_INFO_T	pEntry;
+	
+	if (rate_idx >= ODM_RATEVHTSS2MCS0) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("Rate[%d]: (( VHT2SS-MCS%d ))\n", platform_macid, (rate_idx-ODM_RATEVHTSS2MCS0)));
+		/*dummy for SD4 check patch*/
+	} else if (rate_idx >= ODM_RATEVHTSS1MCS0) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("Rate[%d]: (( VHT1SS-MCS%d ))\n", platform_macid, (rate_idx-ODM_RATEVHTSS1MCS0)));
+		/*dummy for SD4 check patch*/
+	} else if (rate_idx >= ODM_RATEMCS0) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("Rate[%d]: (( HT-MCS%d ))\n", platform_macid, (rate_idx-ODM_RATEMCS0)));
+		/*dummy for SD4 check patch*/
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("Rate[%d]: (( HT-MCS%d ))\n", platform_macid, rate_idx));
+		/*dummy for SD4 check patch*/
+	}
+		
+	phydm_macid = pDM_Odm->platform2phydm_macid_table[platform_macid];
+	pEntry = pDM_Odm->pODM_StaInfo[phydm_macid];
+	
+	if (IS_STA_VALID(pEntry)) {
+		wireless_mode = pEntry->WirelessMode;
+
+		if ((pDM_Odm->RFType  == ODM_2T2R) | (pDM_Odm->RFType  == ODM_2T2R_GREEN) | (pDM_Odm->RFType  == ODM_2T3R) | (pDM_Odm->RFType  == ODM_2T4R)) {
+			
+			pEntry->ratr_idx = pEntry->ratr_idx_init;
+			if (wireless_mode & (ODM_WM_N24G | ODM_WM_N5G)) { /*N mode*/
+				if (rate_idx >= ODM_RATEMCS8 && rate_idx <= ODM_RATEMCS15) { /*2SS mode*/
+					
+					pEntry->ratr_idx = ARFR_5_RATE_ID;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("ARFR_5\n"));
+				}
+			} else if (wireless_mode & (ODM_WM_AC_5G | ODM_WM_AC_24G | ODM_WM_AC_ONLY)) {/*AC mode*/
+				if (rate_idx >= ODM_RATEVHTSS2MCS0 && rate_idx <= ODM_RATEVHTSS2MCS9) {/*2SS mode*/
+					
+					pEntry->ratr_idx = ARFR_0_RATE_ID;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("ARFR_0\n"));
+				}
+			}
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("UPdate_RateID[%d]: (( 0x%x ))\n", platform_macid, pEntry->ratr_idx));
+		}
+	}
+
+}
+#endif
+
+VOID
+phydm_c2h_ra_report_handler(
+	IN PVOID	pDM_VOID,
+	IN pu1Byte   CmdBuf,
+	IN u1Byte   CmdLen
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		pRA_Table = &pDM_Odm->DM_RA_Table;
+	u1Byte	legacy_table[12] = {1,2,5,11,6,9,12,18,24,36,48,54};
+	u1Byte	macid = CmdBuf[1];
+	
+	u1Byte	rate = CmdBuf[0];
+	u1Byte	rate_idx = rate & 0x7f; /*remove bit7 SGI*/
+	u1Byte	vht_en=(rate_idx >= ODM_RATEVHTSS1MCS0)? 1 :0;	
+	u1Byte	b_sgi = (rate & 0x80)>>7;
+	
+	u1Byte	pre_rate = pRA_Table->link_tx_rate[macid];
+	u1Byte	pre_rate_idx = pre_rate & 0x7f; /*remove bit7 SGI*/
+	u1Byte	pre_vht_en=(pre_rate_idx >= ODM_RATEVHTSS1MCS0)? 1 :0;	
+	u1Byte	pre_b_sgi = (pre_rate & 0x80)>>7;
+	
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	
+	GET_HAL_DATA(Adapter)->CurrentRARate = HwRateToMRate(rate_idx);	
+	#endif
+	#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+	ODM_UpdateInitRate(pDM_Odm, rate_idx);
+	#endif
+
+	/*ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD,("RA: rate_idx=0x%x , sgi = %d\n", rate_idx, b_sgi));*/
+	/*if (pDM_Odm->SupportICType & (ODM_RTL8703B))*/
+	{
+		if (CmdLen >= 4) {
+			if (CmdBuf[3] == 0) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("Init-Rate Update\n"));
+				/**/
+			} else if (CmdBuf[3] == 0xff) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("FW Level: Fix rate\n"));
+				/**/
+			} else if (CmdBuf[3] == 1) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("Try Success\n"));
+				/**/
+			} else if (CmdBuf[3] == 2) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("Try Fail & Try Again\n"));
+				/**/
+			} else if (CmdBuf[3] == 3) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("Rate Back\n"));
+				/**/
+			} else if (CmdBuf[3] == 4) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("start rate by RSSI\n"));
+				/**/
+			} else if (CmdBuf[3] == 5) {
+				ODM_RT_TRACE(pDM_Odm, ODM_FW_DEBUG_TRACE, ODM_DBG_LOUD, ("Try rate\n"));
+				/**/
+			}
+		}
+	}
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("Tx Rate Update, MACID[%d] ( %s%s%s%s%d%s%s ) -> ( %s%s%s%s%d%s%s)\n",
+		macid,
+		((pre_rate_idx >= ODM_RATEVHTSS1MCS0) && (pre_rate_idx <= ODM_RATEVHTSS1MCS9)) ? "VHT 1ss  " : "",
+		((pre_rate_idx >= ODM_RATEVHTSS2MCS0) && (pre_rate_idx <= ODM_RATEVHTSS2MCS9)) ? "VHT 2ss " : "",
+		((pre_rate_idx >= ODM_RATEVHTSS3MCS0) && (pre_rate_idx <= ODM_RATEVHTSS3MCS9)) ? "VHT 3ss " : "",
+		(pre_rate_idx >= ODM_RATEMCS0) ? "MCS " : "",
+		(pre_vht_en) ? ((pre_rate_idx - ODM_RATEVHTSS1MCS0)%10) : ((pre_rate_idx >= ODM_RATEMCS0)? (pre_rate_idx - ODM_RATEMCS0) : ((pre_rate_idx <= ODM_RATE54M)?legacy_table[pre_rate_idx]:0)),
+		(pre_b_sgi) ? "-S" : "  ",
+		(pre_rate_idx >= ODM_RATEMCS0) ? "" : "M",
+		((rate_idx >= ODM_RATEVHTSS1MCS0) && (rate_idx <= ODM_RATEVHTSS1MCS9)) ? "VHT 1ss  " : "",
+		((rate_idx >= ODM_RATEVHTSS2MCS0) && (rate_idx <= ODM_RATEVHTSS2MCS9)) ? "VHT 2ss " : "",
+		((rate_idx >= ODM_RATEVHTSS3MCS0) && (rate_idx <= ODM_RATEVHTSS3MCS9)) ? "VHT 3ss " : "",
+		(rate_idx >= ODM_RATEMCS0) ? "MCS " : "",
+		(vht_en) ? ((rate_idx - ODM_RATEVHTSS1MCS0)%10) : ((rate_idx >= ODM_RATEMCS0)? (rate_idx - ODM_RATEMCS0) : ((rate_idx <= ODM_RATE54M)?legacy_table[rate_idx]:0)),
+		(b_sgi) ? "-S" : "  ",
+		(rate_idx >= ODM_RATEMCS0) ? "" : "M" ));
+
+	pRA_Table->link_tx_rate[macid] = rate;
+
+
+	#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8192E))
+		phydm_update_rate_id(pDM_Odm, rate, macid);
+	#endif
+
+}
+
+VOID
+odm_RSSIMonitorInit(
+	IN		PVOID		pDM_VOID
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		pRA_Table = &pDM_Odm->DM_RA_Table;
+	pRA_Table->firstconnect = FALSE;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+	pRA_Table->PT_collision_pre = TRUE;   //used in ODM_DynamicARFBSelect(WIN only)
+#endif
+#endif
+}
+
+VOID
+ODM_RAPostActionOnAssoc(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	pDM_Odm->H2C_RARpt_connect = 1;
+	odm_RSSIMonitorCheck(pDM_Odm);
+	pDM_Odm->H2C_RARpt_connect = 0;
+}
+
+VOID
+odm_RSSIMonitorCheck(
+	IN		PVOID		pDM_VOID
+)
+{
+	//
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (!(pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR))
+		return;
+
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform) {
+	case	ODM_WIN:
+		odm_RSSIMonitorCheckMP(pDM_Odm);
+		break;
+
+	case	ODM_CE:
+		odm_RSSIMonitorCheckCE(pDM_Odm);
+		break;
+
+	case	ODM_AP:
+		odm_RSSIMonitorCheckAP(pDM_Odm);
+		break;
+
+	case	ODM_ADSL:
+		//odm_DIGAP(pDM_Odm);
+		break;
+	}
+
+}	// odm_RSSIMonitorCheck
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+s4Byte
+phydm_FindMinimumRSSI(
+IN		PDM_ODM_T		pDM_Odm,
+IN		PADAPTER		pAdapter,
+IN OUT	BOOLEAN	*pbLink_temp
+
+	)
+{	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	BOOLEAN			act_as_ap = ACTING_AS_AP(pAdapter);
+
+	/*DbgPrint("bMediaConnect = %d,  ACTING_AS_AP = %d ,  EntryMinUndecoratedSmoothedPWDB = %d\n",
+		pMgntInfo->bMediaConnect,act_as_ap,pHalData->EntryMinUndecoratedSmoothedPWDB);*/
+
+	
+	/* 1.Determine the minimum RSSI */
+	if ((!pMgntInfo->bMediaConnect) ||	
+		(act_as_ap && (pHalData->EntryMinUndecoratedSmoothedPWDB == 0))) {/* We should check AP mode and Entry info.into consideration, revised by Roger, 2013.10.18*/
+	
+		pHalData->MinUndecoratedPWDBForDM = 0;
+		*pbLink_temp = FALSE;
+
+	} else
+		*pbLink_temp = TRUE; 
+	
+
+	if (pMgntInfo->bMediaConnect) {	/* Default port*/
+	
+		if (act_as_ap || pMgntInfo->mIbss) {
+			pHalData->MinUndecoratedPWDBForDM = pHalData->EntryMinUndecoratedSmoothedPWDB;
+			/**/
+		} else {
+			pHalData->MinUndecoratedPWDBForDM = pHalData->UndecoratedSmoothedPWDB;
+			/**/
+		}
+	} else { /* associated entry pwdb*/
+		pHalData->MinUndecoratedPWDBForDM = pHalData->EntryMinUndecoratedSmoothedPWDB;
+		/**/
+	}
+
+	return pHalData->MinUndecoratedPWDBForDM;
+}
+
+#endif
+
+VOID
+odm_RSSIMonitorCheckMP(
+	IN	PVOID	pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			H2C_Parameter[4] = {0};
+	u4Byte			i;
+	BOOLEAN			bExtRAInfo = FALSE;
+	u1Byte			cmdlen = 3;
+	u1Byte			TxBF_EN = 0, stbc_en = 0;
+
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PRT_WLAN_STA	pEntry = NULL;
+	s4Byte			tmpEntryMaxPWDB = 0, tmpEntryMinPWDB = 0xff;
+	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+	PMGNT_INFO		pDefaultMgntInfo = &Adapter->MgntInfo;
+	u8Byte			curTxOkCnt = 0, curRxOkCnt = 0;
+	//BOOLEAN			FirstConnect = 0;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+#if (BEAMFORMING_SUPPORT == 1)
+	BEAMFORMING_CAP Beamform_cap = BEAMFORMING_CAP_NONE;
+#endif
+
+	PADAPTER	pLoopAdapter = GetDefaultAdapter(Adapter);
+
+	if (pDM_Odm->SupportICType & EXT_RA_INFO_SUPPORT_IC) {
+		bExtRAInfo = TRUE;
+		cmdlen = 4;
+	}
+
+	//FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+	//pRA_Table->firstconnect = pHalData->bLinked;
+
+
+	/*
+		if(pDM_Odm->SupportICType == ODM_RTL8188E && (pDefaultMgntInfo->CustomerID==RT_CID_819x_HP))
+		{
+			if(curRxOkCnt >(curTxOkCnt*6))
+				PlatformEFIOWrite4Byte(Adapter, REG_ARFR0, 0x8f015);
+			else
+				PlatformEFIOWrite4Byte(Adapter, REG_ARFR0, 0xff015);
+		}
+
+
+		if(pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821 ||
+		   pDM_Odm->SupportICType == ODM_RTL8814A|| pDM_Odm->SupportICType == ODM_RTL8822B)
+		{
+			if(curRxOkCnt >(curTxOkCnt*6))
+				H2C_Parameter[3]|=RAINFO_BE_RX_STATE;
+		}
+	*/
+
+	while (pLoopAdapter) {
+
+		if (pLoopAdapter != NULL) {
+			pMgntInfo = &pLoopAdapter->MgntInfo;
+			curTxOkCnt = pLoopAdapter->TxStats.NumTxBytesUnicast - pMgntInfo->lastTxOkCnt;
+			curRxOkCnt = pLoopAdapter->RxStats.NumRxBytesUnicast - pMgntInfo->lastRxOkCnt;
+			pMgntInfo->lastTxOkCnt = curTxOkCnt;
+			pMgntInfo->lastRxOkCnt = curRxOkCnt;
+		}
+
+		for (i = 0; i < ASSOCIATE_ENTRY_NUM; i++) {
+
+			if (IsAPModeExist(pLoopAdapter)) {
+				if (GetFirstExtAdapter(pLoopAdapter) != NULL &&
+					GetFirstExtAdapter(pLoopAdapter) == pLoopAdapter)
+					pEntry = AsocEntry_EnumStation(pLoopAdapter, i);
+				else if (GetFirstGOPort(pLoopAdapter) != NULL &&
+						 IsFirstGoAdapter(pLoopAdapter))
+					pEntry = AsocEntry_EnumStation(pLoopAdapter, i);
+			} else {
+				if (GetDefaultAdapter(pLoopAdapter) == pLoopAdapter)
+					pEntry = AsocEntry_EnumStation(pLoopAdapter, i);
+			}
+
+			if (pEntry != NULL) {
+				if (pEntry->bAssociated) {
+
+					RT_DISP_ADDR(FDM, DM_PWDB, ("pEntry->MacAddr ="), pEntry->MacAddr);
+					RT_DISP(FDM, DM_PWDB, ("pEntry->rssi = 0x%x(%d)\n",
+										   pEntry->rssi_stat.UndecoratedSmoothedPWDB, pEntry->rssi_stat.UndecoratedSmoothedPWDB));
+
+					//2 BF_en
+#if (BEAMFORMING_SUPPORT)
+					Beamform_cap = phydm_Beamforming_GetEntryBeamCapByMacId(pDM_Odm, pEntry->AssociatedMacId);
+					if (Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMER_CAP_VHT_SU))
+						TxBF_EN = 1;
+#endif
+					//2 STBC_en
+					if ((IS_WIRELESS_MODE_AC(Adapter) && TEST_FLAG(pEntry->VHTInfo.STBC, STBC_VHT_ENABLE_TX)) ||
+						TEST_FLAG(pEntry->HTInfo.STBC, STBC_HT_ENABLE_TX))
+						stbc_en = 1;
+
+					if (pEntry->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+						tmpEntryMinPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+					if (pEntry->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+						tmpEntryMaxPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if (bExtRAInfo) {
+						if (curRxOkCnt > (curTxOkCnt * 6))
+							H2C_Parameter[3] |= RAINFO_BE_RX_STATE;
+
+						if (TxBF_EN)
+							H2C_Parameter[3] |= RAINFO_BF_STATE;
+						else {
+							if (stbc_en)
+								H2C_Parameter[3] |= RAINFO_STBC_STATE;
+						}
+
+                        if ( pDM_Odm->NoisyDecision )
+                        {
+                            H2C_Parameter[3] |= RAINFO_NOISY_STATE;             // BIT2 
+                        }
+						else
+							H2C_Parameter[3] &= (~RAINFO_NOISY_STATE);
+                        
+						if (pDM_Odm->H2C_RARpt_connect)
+							H2C_Parameter[3] |= RAINFO_INIT_RSSI_RATE_STATE;
+					}
+
+					H2C_Parameter[2] = (u1Byte)(pEntry->rssi_stat.UndecoratedSmoothedPWDB & 0xFF);
+					//H2C_Parameter[1] = 0x20;   // fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+					H2C_Parameter[0] = (pEntry->AssociatedMacId);
+
+					ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, cmdlen, H2C_Parameter);
+				}
+			} else
+				break;
+		}
+
+		pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+	}
+
+	if (tmpEntryMaxPWDB != 0) {	// If associated entry is found
+		pHalData->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
+		RT_DISP(FDM, DM_PWDB, ("EntryMaxPWDB = 0x%x(%d)\n",	tmpEntryMaxPWDB, tmpEntryMaxPWDB));
+	} else
+		pHalData->EntryMaxUndecoratedSmoothedPWDB = 0;
+
+	if (tmpEntryMinPWDB != 0xff) { // If associated entry is found
+		pHalData->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
+		RT_DISP(FDM, DM_PWDB, ("EntryMinPWDB = 0x%x(%d)\n", tmpEntryMinPWDB, tmpEntryMinPWDB));
+
+	} else
+		pHalData->EntryMinUndecoratedSmoothedPWDB = 0;
+
+	// Indicate Rx signal strength to FW.
+	if (pHalData->bUseRAMask) {
+		PRT_HIGH_THROUGHPUT 		pHTInfo = GET_HT_INFO(pDefaultMgntInfo);
+		PRT_VERY_HIGH_THROUGHPUT	pVHTInfo = GET_VHT_INFO(pDefaultMgntInfo);
+
+		//2 BF_en
+#if (BEAMFORMING_SUPPORT == 1)
+		Beamform_cap = phydm_Beamforming_GetEntryBeamCapByMacId(pDM_Odm, pDefaultMgntInfo->mMacId);
+
+		if (Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMER_CAP_VHT_SU))
+			TxBF_EN = 1;
+#endif
+
+		//2 STBC_en
+		if ((IS_WIRELESS_MODE_AC(Adapter) && TEST_FLAG(pVHTInfo->VhtCurStbc, STBC_VHT_ENABLE_TX)) ||
+			TEST_FLAG(pHTInfo->HtCurStbc, STBC_HT_ENABLE_TX))
+			stbc_en = 1;
+
+		if (bExtRAInfo) {
+			if (TxBF_EN)
+				H2C_Parameter[3] |= RAINFO_BF_STATE;
+			else {
+				if (stbc_en)
+					H2C_Parameter[3] |= RAINFO_STBC_STATE;
+			}
+
+			if (pDM_Odm->H2C_RARpt_connect)
+				H2C_Parameter[3] |= RAINFO_INIT_RSSI_RATE_STATE;
+			
+            if ( pDM_Odm->NoisyDecision==1 )
+            {
+                H2C_Parameter[3] |= RAINFO_NOISY_STATE;             // BIT2
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_NOISY_DETECT, ODM_DBG_LOUD, ("[RSSIMonitorCheckMP] Send H2C to FW\n"));
+            }
+			else
+				H2C_Parameter[3] &= (~RAINFO_NOISY_STATE);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_NOISY_DETECT, ODM_DBG_LOUD, ("[RSSIMonitorCheckMP] H2C_Parameter=%x\n", H2C_Parameter[3]));
+		}
+
+		H2C_Parameter[2] = (u1Byte)(pHalData->UndecoratedSmoothedPWDB & 0xFF);
+		//H2C_Parameter[1] = 0x20;	// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+		H2C_Parameter[0] = 0;		// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+
+		ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, cmdlen, H2C_Parameter);
+
+		// BT 3.0 HS mode Rssi
+		if (pDM_Odm->bBtHsOperation) {
+			H2C_Parameter[2] = pDM_Odm->btHsRssi;
+			//H2C_Parameter[1] = 0x0;
+			H2C_Parameter[0] = 2;
+
+			ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, cmdlen, H2C_Parameter);
+		}
+	} else
+		PlatformEFIOWrite1Byte(Adapter, 0x4fe, (u1Byte)pHalData->UndecoratedSmoothedPWDB);
+
+	if ((pDM_Odm->SupportICType == ODM_RTL8812) || (pDM_Odm->SupportICType == ODM_RTL8192E))
+		odm_RSSIDumpToRegister(pDM_Odm);
+
+
+	{
+		PADAPTER pLoopAdapter = GetDefaultAdapter(Adapter);
+		BOOLEAN		default_pointer_value, *pbLink_temp = &default_pointer_value;
+		s4Byte	GlobalRSSI_min = 0xFF, LocalRSSI_Min;
+		BOOLEAN		bLink = FALSE;
+
+		while (pLoopAdapter) {
+			LocalRSSI_Min = phydm_FindMinimumRSSI(pDM_Odm, pLoopAdapter, pbLink_temp);
+			//DbgPrint("pHalData->bLinked=%d, LocalRSSI_Min=%d\n", pHalData->bLinked, LocalRSSI_Min);
+			if ((LocalRSSI_Min < GlobalRSSI_min) && (LocalRSSI_Min != 0))
+				GlobalRSSI_min = LocalRSSI_Min;
+
+			if (*pbLink_temp)
+				bLink = TRUE;
+
+			pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+		}
+
+		pHalData->bLinked = bLink;
+		ODM_CmnInfoUpdate(&pHalData->DM_OutSrc , ODM_CMNINFO_LINK, (u8Byte)bLink);
+
+		if (bLink)
+			ODM_CmnInfoUpdate(&pHalData->DM_OutSrc, ODM_CMNINFO_RSSI_MIN, (u8Byte)GlobalRSSI_min);
+		else
+			ODM_CmnInfoUpdate(&pHalData->DM_OutSrc, ODM_CMNINFO_RSSI_MIN, 0);
+
+	}
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+/*H2C_RSSI_REPORT*/
+s8 phydm_rssi_report(PDM_ODM_T pDM_Odm, u8 mac_id)
+{
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	struct dvobj_priv *pdvobjpriv = adapter_to_dvobj(Adapter);
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	u8 H2C_Parameter[4] = {0};
+	u8 UL_DL_STATE = 0, STBC_TX = 0, TxBF_EN = 0;
+	u8 cmdlen = 4, first_connect = _FALSE;
+	u64	curTxOkCnt = 0, curRxOkCnt = 0;
+	PSTA_INFO_T pEntry = pDM_Odm->pODM_StaInfo[mac_id];
+	
+	if (!IS_STA_VALID(pEntry))
+		return _FAIL;
+
+	if (mac_id != pEntry->mac_id) {
+		DBG_871X("%s mac_id:%u:%u invalid\n", __func__, mac_id, pEntry->mac_id);
+		rtw_warn_on(1);
+		return _FAIL;
+	}	
+	
+	if (IS_MCAST(pEntry->hwaddr))  /*if(psta->mac_id ==1)*/
+		return _FAIL;
+
+	if (pEntry->rssi_stat.UndecoratedSmoothedPWDB == (-1)) {
+		DBG_871X("%s mac_id:%u, mac:"MAC_FMT", rssi == -1\n", __func__, pEntry->mac_id, MAC_ARG(pEntry->hwaddr));
+		return _FAIL;
+	}
+
+	curTxOkCnt = pdvobjpriv->traffic_stat.cur_tx_bytes;
+	curRxOkCnt = pdvobjpriv->traffic_stat.cur_rx_bytes;
+	if (curRxOkCnt > (curTxOkCnt * 6))
+		UL_DL_STATE = 1;
+	else
+		UL_DL_STATE = 0;
+	
+	#ifdef CONFIG_BEAMFORMING
+	{
+		#if (BEAMFORMING_SUPPORT == 1)
+		BEAMFORMING_CAP Beamform_cap = phydm_Beamforming_GetEntryBeamCapByMacId(pDM_Odm, pEntry->mac_id);
+		#else/*for drv beamforming*/
+		BEAMFORMING_CAP Beamform_cap = beamforming_get_entry_beam_cap_by_mac_id(&Adapter->mlmepriv, pEntry->mac_id);
+		#endif
+
+		if (Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMER_CAP_VHT_SU))
+			TxBF_EN = 1;
+		else
+			TxBF_EN = 0;
+	}
+	#endif /*#ifdef CONFIG_BEAMFORMING*/
+		
+	if (TxBF_EN)
+		STBC_TX = 0;
+	else {
+		#ifdef CONFIG_80211AC_VHT
+		if (IsSupportedVHT(pEntry->wireless_mode))
+			STBC_TX = TEST_FLAG(pEntry->vhtpriv.stbc_cap, STBC_VHT_ENABLE_TX);
+		else
+		#endif
+			STBC_TX = TEST_FLAG(pEntry->htpriv.stbc_cap, STBC_HT_ENABLE_TX);
+	}
+		
+	H2C_Parameter[0] = (u8)(pEntry->mac_id & 0xFF);
+	H2C_Parameter[2] = pEntry->rssi_stat.UndecoratedSmoothedPWDB & 0x7F;
+		
+	if (UL_DL_STATE)
+		H2C_Parameter[3] |= RAINFO_BE_RX_STATE;
+		
+	if (TxBF_EN)
+		H2C_Parameter[3] |= RAINFO_BF_STATE;
+	if (STBC_TX)
+		H2C_Parameter[3] |= RAINFO_STBC_STATE;
+	if (pDM_Odm->NoisyDecision)
+		H2C_Parameter[3] |= RAINFO_NOISY_STATE;
+		
+	if (pEntry->ra_rpt_linked == _FALSE) {
+		H2C_Parameter[3] |= RAINFO_INIT_RSSI_RATE_STATE;
+		pEntry->ra_rpt_linked = _TRUE;
+		first_connect = _TRUE;
+	}
+		
+	#if 1
+	if (first_connect) {
+		DBG_871X("%s mac_id:%u, mac:"MAC_FMT", rssi:%d\n", __func__,
+			pEntry->mac_id, MAC_ARG(pEntry->hwaddr), pEntry->rssi_stat.UndecoratedSmoothedPWDB);
+			
+		DBG_871X("%s RAINFO - TP:%s, TxBF:%s, STBC:%s, Noisy:%s, Firstcont:%s\n", __func__,
+			(UL_DL_STATE) ? "DL" : "UL", (TxBF_EN) ? "EN" : "DIS", (STBC_TX) ? "EN" : "DIS",
+			(pDM_Odm->NoisyDecision) ? "True" : "False", (first_connect) ? "True" : "False");
+	}
+	#endif
+		
+	if (pHalData->fw_ractrl == _TRUE) {
+		#if (RTL8188E_SUPPORT == 1)
+		if (pDM_Odm->SupportICType == ODM_RTL8188E)
+			cmdlen = 3;
+		#endif
+		ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, cmdlen, H2C_Parameter);
+	} else {
+		#if ((RTL8188E_SUPPORT == 1) && (RATE_ADAPTIVE_SUPPORT == 1))
+		if (pDM_Odm->SupportICType == ODM_RTL8188E)
+			ODM_RA_SetRSSI_8188E(pDM_Odm, (u8)(pEntry->mac_id & 0xFF), pEntry->rssi_stat.UndecoratedSmoothedPWDB & 0x7F);
+		#endif
+	}
+	return _SUCCESS;
+}
+
+void phydm_ra_rssi_rpt_wk_hdl(PVOID pContext)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pContext;
+	int i;
+	u8 mac_id = 0xFF;
+	PSTA_INFO_T	pEntry = NULL;	
+	
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pEntry = pDM_Odm->pODM_StaInfo[i];
+		if (IS_STA_VALID(pEntry)) {
+			if (IS_MCAST(pEntry->hwaddr))  /*if(psta->mac_id ==1)*/
+				continue;
+			if (pEntry->ra_rpt_linked == _FALSE) {
+				mac_id = i;
+				break;
+			}
+		}
+	}
+	if (mac_id != 0xFF)
+		phydm_rssi_report(pDM_Odm, mac_id);
+}
+void phydm_ra_rssi_rpt_wk(PVOID pContext)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pContext;
+	
+	rtw_run_in_thread_cmd(pDM_Odm->Adapter, phydm_ra_rssi_rpt_wk_hdl, pDM_Odm);
+}
+#endif
+
+VOID
+odm_RSSIMonitorCheckCE(
+	IN		PVOID		pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	PSTA_INFO_T           pEntry;
+	int	i;
+	int	tmpEntryMaxPWDB = 0, tmpEntryMinPWDB = 0xff;
+	u8	sta_cnt = 0;
+	
+	if (pDM_Odm->bLinked != _TRUE)
+		return;	
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pEntry = pDM_Odm->pODM_StaInfo[i];
+		if (IS_STA_VALID(pEntry)) {
+			if (IS_MCAST(pEntry->hwaddr))  /*if(psta->mac_id ==1)*/
+				continue;
+
+			if (pEntry->rssi_stat.UndecoratedSmoothedPWDB == (-1))
+				continue;
+
+			if (pEntry->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+				tmpEntryMinPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+
+			if (pEntry->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+				tmpEntryMaxPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+
+			if (phydm_rssi_report(pDM_Odm, i))
+				sta_cnt++;
+		}
+	}
+	/*DBG_871X("%s==> sta_cnt(%d)\n", __func__, sta_cnt);*/
+
+	if (tmpEntryMaxPWDB != 0)	// If associated entry is found
+		pHalData->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
+	else
+		pHalData->EntryMaxUndecoratedSmoothedPWDB = 0;
+
+	if (tmpEntryMinPWDB != 0xff) // If associated entry is found
+		pHalData->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
+	else
+		pHalData->EntryMinUndecoratedSmoothedPWDB = 0;
+
+	FindMinimumRSSI(Adapter);//get pdmpriv->MinUndecoratedPWDBForDM
+
+	pDM_Odm->RSSI_Min = pHalData->MinUndecoratedPWDBForDM;
+	//ODM_CmnInfoUpdate(&pHalData->odmpriv ,ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM);
+#endif//if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+}
+
+
+VOID
+odm_RSSIMonitorCheckAP(
+	IN		PVOID		pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+#if (RTL8812A_SUPPORT||RTL8881A_SUPPORT||RTL8192E_SUPPORT||RTL8814A_SUPPORT)
+
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte 			H2C_Parameter[4] = {0};
+	u4Byte			 i;
+	BOOLEAN			bExtRAInfo = FALSE;
+	u1Byte			cmdlen = 3 ;
+	u1Byte			TxBF_EN = 0, stbc_en = 0;
+
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+	PSTA_INFO_T 		pstat;
+	BOOLEAN			act_bfer = FALSE;
+
+#ifdef BEAMFORMING_SUPPORT
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
+	pBDC_T	pDM_BdcTable = &pDM_Odm->DM_BdcTable;
+	pDM_BdcTable->num_Txbfee_Client = 0;
+	pDM_BdcTable->num_Txbfer_Client = 0;
+#endif
+#endif
+
+	if (pDM_Odm->H2C_RARpt_connect) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("[RA Init] First Connected\n"));
+		/**/
+	} else if (priv->up_time % 2)
+		return;
+
+	if (pDM_Odm->SupportICType & EXT_RA_INFO_SUPPORT_IC) {
+		bExtRAInfo = TRUE;
+		cmdlen = 4;
+	}
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pstat = pDM_Odm->pODM_StaInfo[i];
+
+		if (IS_STA_VALID(pstat)) {
+			if (pstat->sta_in_firmware != 1)
+				continue;
+
+			//2 BF_en
+#ifdef BEAMFORMING_SUPPORT
+			BEAMFORMING_CAP Beamform_cap = Beamforming_GetEntryBeamCapByMacId(priv, pstat->aid);
+
+			if (Beamform_cap == BEAMFORMER_CAP_HT_EXPLICIT || Beamform_cap == BEAMFORMER_CAP_VHT_SU ||
+				Beamform_cap == (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMEE_CAP_HT_EXPLICIT) ||
+				Beamform_cap == (BEAMFORMER_CAP_VHT_SU | BEAMFORMEE_CAP_VHT_SU)) {
+				TxBF_EN = 1;
+				act_bfer = TRUE;
+			}
+
+#if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY)) /*BDC*/
+
+			if (act_bfer == TRUE) {
+				pDM_BdcTable->w_BFee_Client[i] = 1; //AP act as BFer
+				pDM_BdcTable->num_Txbfee_Client++;
+			} else {
+				pDM_BdcTable->w_BFee_Client[i] = 0; //AP act as BFer
+			}
+
+			if ((Beamform_cap & BEAMFORMEE_CAP_HT_EXPLICIT) || (Beamform_cap & BEAMFORMEE_CAP_VHT_SU)) {
+				pDM_BdcTable->w_BFer_Client[i] = 1; //AP act as BFee
+				pDM_BdcTable->num_Txbfer_Client++;
+			} else {
+				pDM_BdcTable->w_BFer_Client[i] = 0; //AP act as BFer
+			}
+#endif
+#endif
+
+			//2 STBC_en
+			if ((priv->pmib->dot11nConfigEntry.dot11nSTBC) &&
+				((pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_RX_STBC_CAP_))
+#ifdef RTK_AC_SUPPORT
+				 || (pstat->vht_cap_buf.vht_cap_info & cpu_to_le32(_VHTCAP_RX_STBC_CAP_))
+#endif
+				))
+				stbc_en = 1;
+
+			//2 RAINFO
+
+			if (bExtRAInfo) {
+				if ((pstat->rx_avarage)  > ((pstat->tx_avarage) * 6))
+					H2C_Parameter[3] |= RAINFO_BE_RX_STATE;
+
+				if (TxBF_EN)
+					H2C_Parameter[3] |= RAINFO_BF_STATE;
+				else {
+					if (stbc_en)
+						H2C_Parameter[3] |= RAINFO_STBC_STATE;
+				}
+
+                if ( pDM_Odm->NoisyDecision )
+                {
+                    H2C_Parameter[3] |= RAINFO_NOISY_STATE;             // BIT2
+                }
+				else
+					H2C_Parameter[3] &= (~RAINFO_NOISY_STATE);
+				
+				if (pDM_Odm->H2C_RARpt_connect) {
+					H2C_Parameter[3] |= RAINFO_INIT_RSSI_RATE_STATE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_RATE_ADAPTIVE, ODM_DBG_LOUD, ("[RA Init] set Init rate by RSSI\n"));
+				}
+
+				/*ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[RAINFO] H2C_Para[3] = %x\n",H2C_Parameter[3]));*/
+			}
+
+			H2C_Parameter[2] = (u1Byte)(pstat->rssi & 0xFF);
+			H2C_Parameter[0] = REMAP_AID(pstat);
+
+            ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
+            ("H2C_Parameter[3]=%d\n", H2C_Parameter[3]));
+
+			//ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[RSSI] H2C_Para[2] = %x,  \n",H2C_Parameter[2]));
+			//ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("[MACID] H2C_Para[0] = %x,  \n",H2C_Parameter[0]));
+
+			ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, cmdlen, H2C_Parameter);
+
+		}
+	}
+
+#endif
+#endif
+
+}
+
+
+VOID
+odm_RateAdaptiveMaskInit(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_RATE_ADAPTIVE	pOdmRA = &pDM_Odm->RateAdaptive;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PMGNT_INFO		pMgntInfo = &pDM_Odm->Adapter->MgntInfo;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+
+	pMgntInfo->Ratr_State = DM_RATR_STA_INIT;
+
+	if (pMgntInfo->DM_Type == DM_Type_ByDriver)
+		pHalData->bUseRAMask = TRUE;
+	else
+		pHalData->bUseRAMask = FALSE;
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pOdmRA->Type = DM_Type_ByDriver;
+	if (pOdmRA->Type == DM_Type_ByDriver)
+		pDM_Odm->bUseRAMask = _TRUE;
+	else
+		pDM_Odm->bUseRAMask = _FALSE;
+#endif
+
+	pOdmRA->RATRState = DM_RATR_STA_INIT;
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+		pOdmRA->LdpcThres = 50;
+	else
+		pOdmRA->LdpcThres = 35;
+
+	pOdmRA->RtsThres = 35;
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	pOdmRA->LdpcThres = 35;
+	pOdmRA->bUseLdpc = FALSE;
+
+#else
+	pOdmRA->UltraLowRSSIThresh = 9;
+
+#endif
+
+	pOdmRA->HighRSSIThresh = 50;
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP) && \
+	((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+	pOdmRA->LowRSSIThresh = 23;
+#else
+	pOdmRA->LowRSSIThresh = 20;
+#endif
+}
+/*-----------------------------------------------------------------------------
+ * Function:	odm_RefreshRateAdaptiveMask()
+ *
+ * Overview:	Update rate table mask according to rssi
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	05/27/2009	hpfan	Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+VOID
+odm_RefreshRateAdaptiveMask(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("odm_RefreshRateAdaptiveMask()---------->\n"));
+	if (!(pDM_Odm->SupportAbility & ODM_BB_RA_MASK)) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("odm_RefreshRateAdaptiveMask(): Return cos not supported\n"));
+		return;
+	}
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform) {
+	case	ODM_WIN:
+		odm_RefreshRateAdaptiveMaskMP(pDM_Odm);
+		break;
+
+	case	ODM_CE:
+		odm_RefreshRateAdaptiveMaskCE(pDM_Odm);
+		break;
+
+	case	ODM_AP:
+	case	ODM_ADSL:
+		odm_RefreshRateAdaptiveMaskAPADSL(pDM_Odm);
+		break;
+	}
+
+}
+
+VOID
+odm_RefreshRateAdaptiveMaskMP(
+	IN		PVOID		pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				pAdapter	 =  pDM_Odm->Adapter;
+	PADAPTER 				pTargetAdapter = NULL;
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(pAdapter);
+	PMGNT_INFO				pMgntInfo = GetDefaultMgntInfo(pAdapter);
+
+	if (pAdapter->bDriverStopped) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
+		return;
+	}
+
+	if (!pHalData->bUseRAMask) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
+		return;
+	}
+
+	// if default port is connected, update RA table for default port (infrastructure mode only)
+	if (pMgntInfo->mAssoc && (!ACTING_AS_AP(pAdapter))) {
+		odm_RefreshLdpcRtsMP(pAdapter, pDM_Odm, pMgntInfo->mMacId,  pMgntInfo->IOTPeer, pHalData->UndecoratedSmoothedPWDB);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("odm_RefreshRateAdaptiveMask(): Infrasture Mode\n"));
+		if (ODM_RAStateCheck(pDM_Odm, pHalData->UndecoratedSmoothedPWDB, pMgntInfo->bSetTXPowerTrainingByOid, &pMgntInfo->Ratr_State)) {
+			ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pHalData->UndecoratedSmoothedPWDB, pMgntInfo->Ratr_State));
+			pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
+		} else if (pDM_Odm->bChangeState) {
+			ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Change Power Training State, bDisablePowerTraining = %d\n", pDM_Odm->bDisablePowerTraining));
+			pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
+		}
+	}
+
+	//
+	// The following part configure AP/VWifi/IBSS rate adaptive mask.
+	//
+
+	if (pMgntInfo->mIbss) 	// Target: AP/IBSS peer.
+		pTargetAdapter = GetDefaultAdapter(pAdapter);
+	else
+		pTargetAdapter = GetFirstAPAdapter(pAdapter);
+
+	// if extension port (softap) is started, updaet RA table for more than one clients associate
+	if (pTargetAdapter != NULL) {
+		int	i;
+		PRT_WLAN_STA	pEntry;
+
+		for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+			pEntry = AsocEntry_EnumStation(pTargetAdapter, i);
+			if (NULL != pEntry) {
+				if (pEntry->bAssociated) {
+					odm_RefreshLdpcRtsMP(pAdapter, pDM_Odm, pEntry->AssociatedMacId, pEntry->IOTPeer, pEntry->rssi_stat.UndecoratedSmoothedPWDB);
+
+					if (ODM_RAStateCheck(pDM_Odm, pEntry->rssi_stat.UndecoratedSmoothedPWDB, pMgntInfo->bSetTXPowerTrainingByOid, &pEntry->Ratr_State)) {
+						ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target STA addr : "), pEntry->MacAddr);
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pEntry->rssi_stat.UndecoratedSmoothedPWDB, pEntry->Ratr_State));
+						pAdapter->HalFunc.UpdateHalRAMaskHandler(pTargetAdapter, pEntry->AssociatedMacId, pEntry, pEntry->Ratr_State);
+					} else if (pDM_Odm->bChangeState) {
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Change Power Training State, bDisablePowerTraining = %d\n", pDM_Odm->bDisablePowerTraining));
+						pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
+					}
+				}
+			}
+		}
+	}
+
+	if (pMgntInfo->bSetTXPowerTrainingByOid)
+		pMgntInfo->bSetTXPowerTrainingByOid = FALSE;
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+}
+
+
+VOID
+odm_RefreshRateAdaptiveMaskCE(
+	IN	PVOID	pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	PODM_RATE_ADAPTIVE		pRA = &pDM_Odm->RateAdaptive;
+
+	if (RTW_CANNOT_RUN(pAdapter)) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
+		return;
+	}
+
+	if (!pDM_Odm->bUseRAMask) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
+		return;
+	}
+
+	//printk("==> %s \n",__FUNCTION__);
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		PSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];
+		if (IS_STA_VALID(pstat)) {
+			if (IS_MCAST(pstat->hwaddr))  //if(psta->mac_id ==1)
+				continue;
+			if (IS_MCAST(pstat->hwaddr))
+				continue;
+
+#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
+			if ((pDM_Odm->SupportICType == ODM_RTL8812) || (pDM_Odm->SupportICType == ODM_RTL8821)) {
+				if (pstat->rssi_stat.UndecoratedSmoothedPWDB < pRA->LdpcThres) {
+					pRA->bUseLdpc = TRUE;
+					pRA->bLowerRtsRate = TRUE;
+					if ((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
+						Set_RA_LDPC_8812(pstat, TRUE);
+					//DbgPrint("RSSI=%d, bUseLdpc = TRUE\n", pHalData->UndecoratedSmoothedPWDB);
+				} else if (pstat->rssi_stat.UndecoratedSmoothedPWDB > (pRA->LdpcThres - 5)) {
+					pRA->bUseLdpc = FALSE;
+					pRA->bLowerRtsRate = FALSE;
+					if ((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
+						Set_RA_LDPC_8812(pstat, FALSE);
+					//DbgPrint("RSSI=%d, bUseLdpc = FALSE\n", pHalData->UndecoratedSmoothedPWDB);
+				}
+			}
+#endif
+
+			if (TRUE == ODM_RAStateCheck(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, FALSE , &pstat->rssi_level)) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level));
+				//printk("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level);
+				rtw_hal_update_ra_mask(pstat, pstat->rssi_level);
+			} else if (pDM_Odm->bChangeState) {
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Change Power Training State, bDisablePowerTraining = %d\n", pDM_Odm->bDisablePowerTraining));
+				rtw_hal_update_ra_mask(pstat, pstat->rssi_level);
+			}
+
+		}
+	}
+
+#endif
+}
+
+VOID
+odm_RefreshRateAdaptiveMaskAPADSL(
+	IN	PVOID	pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	struct rtl8192cd_priv *priv = pDM_Odm->priv;
+	struct aid_obj *aidarray;
+	u4Byte i;
+	PSTA_INFO_T pstat;
+
+	if (priv->up_time % 2)
+		return;
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pstat = pDM_Odm->pODM_StaInfo[i];
+
+		if (IS_STA_VALID(pstat)) {
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+			aidarray = container_of(pstat, struct aid_obj, station);
+			priv = aidarray->priv;
+#endif
+
+			if (!priv->pmib->dot11StationConfigEntry.autoRate)
+				continue;
+
+			if (ODM_RAStateCheck(pDM_Odm, (s4Byte)pstat->rssi, FALSE, &pstat->rssi_level)) {
+				ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target STA addr : "), pstat->hwaddr);
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi, pstat->rssi_level));
+
+#ifdef CONFIG_WLAN_HAL
+				if (IS_HAL_CHIP(priv)) {
+#ifdef WDS
+//					if(!(pstat->state & WIFI_WDS))//if WDS donot setting
+#endif
+					GET_HAL_INTERFACE(priv)->UpdateHalRAMaskHandler(priv, pstat, pstat->rssi_level);
+				} else
+#endif
+#ifdef CONFIG_RTL_8812_SUPPORT
+					if (GET_CHIP_VER(priv) == VERSION_8812E)
+						UpdateHalRAMask8812(priv, pstat, 3);
+					else
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+						if (GET_CHIP_VER(priv) == VERSION_8188E) {
+#ifdef TXREPORT
+							add_RATid(priv, pstat);
+#endif
+						} else
+#endif
+						{
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_92C_SUPPORT)
+							add_update_RATid(priv, pstat);
+#endif
+						}
+			}
+		}
+	}
+#endif
+}
+
+
+// Return Value: BOOLEAN
+// - TRUE: RATRState is changed.
+BOOLEAN
+ODM_RAStateCheck(
+	IN		PVOID			pDM_VOID,
+	IN		s4Byte			RSSI,
+	IN		BOOLEAN			bForceUpdate,
+	OUT		pu1Byte			pRATRState
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_RATE_ADAPTIVE pRA = &pDM_Odm->RateAdaptive;
+	const u1Byte GoUpGap = 5;
+	u1Byte HighRSSIThreshForRA = pRA->HighRSSIThresh;
+	u1Byte LowRSSIThreshForRA = pRA->LowRSSIThresh;
+	u1Byte RATRState;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI= (( %d )), Current_RSSI_level = (( %d ))\n", RSSI, *pRATRState));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("[Ori RA RSSI Thresh]  High= (( %d )), Low = (( %d ))\n", HighRSSIThreshForRA, LowRSSIThreshForRA));
+	// Threshold Adjustment:
+	// when RSSI state trends to go up one or two levels, make sure RSSI is high enough.
+	// Here GoUpGap is added to solve the boundary's level alternation issue.
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	u1Byte UltraLowRSSIThreshForRA = pRA->UltraLowRSSIThresh;
+	if (pDM_Odm->SupportICType == ODM_RTL8881A)
+		LowRSSIThreshForRA = 30;		// for LDPC / BCC switch
+#endif
+
+	switch (*pRATRState) {
+	case DM_RATR_STA_INIT:
+	case DM_RATR_STA_HIGH:
+		break;
+
+	case DM_RATR_STA_MIDDLE:
+		HighRSSIThreshForRA += GoUpGap;
+		break;
+
+	case DM_RATR_STA_LOW:
+		HighRSSIThreshForRA += GoUpGap;
+		LowRSSIThreshForRA += GoUpGap;
+		break;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	case DM_RATR_STA_ULTRA_LOW:
+		HighRSSIThreshForRA += GoUpGap;
+		LowRSSIThreshForRA += GoUpGap;
+		UltraLowRSSIThreshForRA += GoUpGap;
+		break;
+#endif
+
+	default:
+		ODM_RT_ASSERT(pDM_Odm, FALSE, ("wrong rssi level setting %d !", *pRATRState));
+		break;
+	}
+
+	// Decide RATRState by RSSI.
+	if (RSSI > HighRSSIThreshForRA)
+		RATRState = DM_RATR_STA_HIGH;
+	else if (RSSI > LowRSSIThreshForRA)
+		RATRState = DM_RATR_STA_MIDDLE;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	else if (RSSI > UltraLowRSSIThreshForRA)
+		RATRState = DM_RATR_STA_LOW;
+	else
+		RATRState = DM_RATR_STA_ULTRA_LOW;
+#else
+	else
+		RATRState = DM_RATR_STA_LOW;
+#endif
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("[Mod RA RSSI Thresh]  High= (( %d )), Low = (( %d ))\n", HighRSSIThreshForRA, LowRSSIThreshForRA));
+	/*printk("==>%s,RATRState:0x%02x ,RSSI:%d\n",__FUNCTION__,RATRState,RSSI);*/
+
+	if (*pRATRState != RATRState || bForceUpdate) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("[RSSI Level Update] %d -> %d\n", *pRATRState, RATRState));
+		*pRATRState = RATRState;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+VOID
+odm_RefreshBasicRateMask(
+	IN	PVOID	pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter	 =  pDM_Odm->Adapter;
+	static u1Byte		Stage = 0;
+	u1Byte			CurStage = 0;
+	OCTET_STRING 	osRateSet;
+	PMGNT_INFO		pMgntInfo = GetDefaultMgntInfo(Adapter);
+	u1Byte 			RateSet[5] = {MGN_1M, MGN_2M, MGN_5_5M, MGN_11M, MGN_6M};
+
+	if (pDM_Odm->SupportICType != ODM_RTL8812 && pDM_Odm->SupportICType != ODM_RTL8821)
+		return;
+
+	if (pDM_Odm->bLinked == FALSE)	// unlink Default port information
+		CurStage = 0;
+	else if (pDM_Odm->RSSI_Min < 40)	// link RSSI  < 40%
+		CurStage = 1;
+	else if (pDM_Odm->RSSI_Min > 45)	// link RSSI > 45%
+		CurStage = 3;
+	else
+		CurStage = 2;					// link  25% <= RSSI <= 30%
+
+	if (CurStage != Stage) {
+		if (CurStage == 1) {
+			FillOctetString(osRateSet, RateSet, 5);
+			FilterSupportRate(pMgntInfo->mBrates, &osRateSet, FALSE);
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_BASIC_RATE, (pu1Byte)&osRateSet);
+		} else if (CurStage == 3 && (Stage == 1 || Stage == 2))
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_BASIC_RATE, (pu1Byte)(&pMgntInfo->mBrates));
+	}
+
+	Stage = CurStage;
+#endif
+}
+
+
+VOID
+phydm_ra_info_init(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	#if (defined(CONFIG_RA_DYNAMIC_RTY_LIMIT))
+	phydm_ra_dynamic_retry_limit_init(pDM_Odm);
+	#endif
+	#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	phydm_ra_dynamic_rate_id_init(pDM_Odm);
+	#endif
+
+	/*phydm_fw_trace_en_h2c(pDM_Odm, 1, 0, 0);*/
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+u1Byte
+odm_Find_RTS_Rate(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Tx_Rate,
+	IN		BOOLEAN			bErpProtect
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	RTS_Ini_Rate = ODM_RATE6M;
+	
+	if (bErpProtect) /* use CCK rate as RTS*/
+		RTS_Ini_Rate = ODM_RATE1M;
+	else {
+		switch (Tx_Rate) {
+		case ODM_RATEVHTSS3MCS9:
+		case ODM_RATEVHTSS3MCS8:
+		case ODM_RATEVHTSS3MCS7:
+		case ODM_RATEVHTSS3MCS6:
+		case ODM_RATEVHTSS3MCS5:
+		case ODM_RATEVHTSS3MCS4:
+		case ODM_RATEVHTSS3MCS3:
+		case ODM_RATEVHTSS2MCS9:
+		case ODM_RATEVHTSS2MCS8:
+		case ODM_RATEVHTSS2MCS7:
+		case ODM_RATEVHTSS2MCS6:
+		case ODM_RATEVHTSS2MCS5:
+		case ODM_RATEVHTSS2MCS4:
+		case ODM_RATEVHTSS2MCS3:
+		case ODM_RATEVHTSS1MCS9:
+		case ODM_RATEVHTSS1MCS8:
+		case ODM_RATEVHTSS1MCS7:
+		case ODM_RATEVHTSS1MCS6:
+		case ODM_RATEVHTSS1MCS5:
+		case ODM_RATEVHTSS1MCS4:
+		case ODM_RATEVHTSS1MCS3:
+		case ODM_RATEMCS15:
+		case ODM_RATEMCS14:
+		case ODM_RATEMCS13:
+		case ODM_RATEMCS12:
+		case ODM_RATEMCS11:
+		case ODM_RATEMCS7:
+		case ODM_RATEMCS6:
+		case ODM_RATEMCS5:
+		case ODM_RATEMCS4:
+		case ODM_RATEMCS3:
+		case ODM_RATE54M:
+		case ODM_RATE48M:
+		case ODM_RATE36M:
+		case ODM_RATE24M:		
+			RTS_Ini_Rate = ODM_RATE24M;
+			break;
+		case ODM_RATEVHTSS3MCS2:
+		case ODM_RATEVHTSS3MCS1:
+		case ODM_RATEVHTSS2MCS2:
+		case ODM_RATEVHTSS2MCS1:
+		case ODM_RATEVHTSS1MCS2:
+		case ODM_RATEVHTSS1MCS1:
+		case ODM_RATEMCS10:
+		case ODM_RATEMCS9:
+		case ODM_RATEMCS2:
+		case ODM_RATEMCS1:
+		case ODM_RATE18M:
+		case ODM_RATE12M:
+			RTS_Ini_Rate = ODM_RATE12M;
+			break;
+		case ODM_RATEVHTSS3MCS0:
+		case ODM_RATEVHTSS2MCS0:
+		case ODM_RATEVHTSS1MCS0:
+		case ODM_RATEMCS8:
+		case ODM_RATEMCS0:
+		case ODM_RATE9M:
+		case ODM_RATE6M:
+			RTS_Ini_Rate = ODM_RATE6M;
+			break;
+		case ODM_RATE11M:
+		case ODM_RATE5_5M:
+		case ODM_RATE2M:
+		case ODM_RATE1M:
+			RTS_Ini_Rate = ODM_RATE1M;
+			break;
+		default:
+			RTS_Ini_Rate = ODM_RATE6M;
+			break;
+		}
+	}
+
+	if (*pDM_Odm->pBandType == 1) {
+		if (RTS_Ini_Rate < ODM_RATE6M)
+			RTS_Ini_Rate = ODM_RATE6M;
+	}
+	return RTS_Ini_Rate;
+
+}
+
+VOID
+odm_Set_RA_DM_ARFB_by_Noisy(
+	IN	PDM_ODM_T	pDM_Odm
+)
+{
+	/*DbgPrint("DM_ARFB ====>\n");*/
+	if (pDM_Odm->bNoisyState) {
+		ODM_Write4Byte(pDM_Odm, 0x430, 0x00000000);
+		ODM_Write4Byte(pDM_Odm, 0x434, 0x05040200);
+		/*DbgPrint("DM_ARFB ====> Noisy State\n");*/
+	} else {
+		ODM_Write4Byte(pDM_Odm, 0x430, 0x02010000);
+		ODM_Write4Byte(pDM_Odm, 0x434, 0x07050403);
+		/*DbgPrint("DM_ARFB ====> Clean State\n");*/
+	}
+
+}
+
+VOID
+ODM_UpdateNoisyState(
+	IN	PVOID		pDM_VOID,
+	IN	BOOLEAN		bNoisyStateFromC2H
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	/*DbgPrint("Get C2H Command! NoisyState=0x%x\n ", bNoisyStateFromC2H);*/
+	if (pDM_Odm->SupportICType == ODM_RTL8821  || pDM_Odm->SupportICType == ODM_RTL8812  ||
+		pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188E)
+		pDM_Odm->bNoisyState = bNoisyStateFromC2H;
+	odm_Set_RA_DM_ARFB_by_Noisy(pDM_Odm);
+};
+
+u4Byte
+Set_RA_DM_Ratrbitmap_by_Noisy(
+	IN	PVOID			pDM_VOID,
+	IN	WIRELESS_MODE	WirelessMode,
+	IN	u4Byte			ratr_bitmap,
+	IN	u1Byte			rssi_level
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte ret_bitmap = ratr_bitmap;
+	
+	return ret_bitmap;
+	
+	switch (WirelessMode) {
+	case WIRELESS_MODE_AC_24G:
+	case WIRELESS_MODE_AC_5G:
+	case WIRELESS_MODE_AC_ONLY:
+		if (pDM_Odm->bNoisyState) { /*in Noisy State*/
+			if (rssi_level == 1)
+				ret_bitmap &= 0xfc3e0c08;		// Reserve MCS 5-9
+			else if (rssi_level == 2)
+				ret_bitmap &= 0xfe3f8e08;		// Reserve MCS 3-9
+			else if (rssi_level == 3)
+				ret_bitmap &= 0xffffffff;
+			else
+				ret_bitmap &= 0xffffffff;
+		} else {                                /* in SNR State*/
+			if (rssi_level == 1)
+				ret_bitmap &= 0xfe3f0e08;		// Reserve MCS 4-9
+			else if (rssi_level == 2)
+				ret_bitmap &= 0xff3fcf8c;		// Reserve MCS 2-9
+			else if (rssi_level == 3)
+				ret_bitmap &= 0xffffffff;
+			else
+				ret_bitmap &= 0xffffffff;
+		}
+		break;
+	case WIRELESS_MODE_B:
+	case WIRELESS_MODE_A:
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_N_24G:
+	case WIRELESS_MODE_N_5G:
+		if (pDM_Odm->bNoisyState) {
+			if (rssi_level == 1)
+				ret_bitmap &= 0x0f0e0c08;		// Reserve MCS 4-7; MCS12-15
+			else if (rssi_level == 2)
+				ret_bitmap &= 0x0fcfce0c;		// Reserve MCS 2-7; MCS10-15
+			else if (rssi_level == 3)
+				ret_bitmap &= 0xffffffff;
+			else
+				ret_bitmap &= 0xffffffff;
+		} else {
+			if (rssi_level == 1)
+				ret_bitmap &= 0x0f8f8e08;		// Reserve MCS 3-7; MCS11-15
+			else if (rssi_level == 2)
+				ret_bitmap &= 0x0fefef8c;		// Reserve MCS 1-7; MCS9-15
+			else if (rssi_level == 3)
+				ret_bitmap &= 0xffffffff;
+			else
+				ret_bitmap &= 0xffffffff;
+		}
+		break;
+	default:
+		break;
+	}
+	/*DbgPrint("DM_RAMask ====> rssi_LV = %d, BITMAP = %x\n", rssi_level, ret_bitmap);*/
+	return ret_bitmap;
+
+}
+
+VOID
+ODM_UpdateInitRate(
+	IN	PVOID		pDM_VOID,
+	IN	u1Byte		Rate
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			p = 0;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("Get C2H Command! Rate=0x%x\n", Rate));
+
+	pDM_Odm->TxRate = Rate;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+#if USE_WORKITEM
+		PlatformScheduleWorkItem(&pDM_Odm->RaRptWorkitem);
+#else
+		if (pDM_Odm->SupportICType == ODM_RTL8821) {
+#if (RTL8821A_SUPPORT == 1)
+			ODM_TxPwrTrackSetPwr8821A(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+#endif
+		} else if (pDM_Odm->SupportICType == ODM_RTL8812) {
+			for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8812A; p++) {
+#if (RTL8812A_SUPPORT == 1)
+				ODM_TxPwrTrackSetPwr8812A(pDM_Odm, MIX_MODE, p, 0);
+#endif
+			}
+		} else if (pDM_Odm->SupportICType == ODM_RTL8723B) {
+#if (RTL8723B_SUPPORT == 1)
+			ODM_TxPwrTrackSetPwr_8723B(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+#endif
+		} else if (pDM_Odm->SupportICType == ODM_RTL8192E) {
+			for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8192E; p++) {
+#if (RTL8192E_SUPPORT == 1)
+				ODM_TxPwrTrackSetPwr92E(pDM_Odm, MIX_MODE, p, 0);
+#endif
+			}
+		} else if (pDM_Odm->SupportICType == ODM_RTL8188E) {
+#if (RTL8188E_SUPPORT == 1)
+			ODM_TxPwrTrackSetPwr88E(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+#endif
+		}
+#endif
+#else
+		PlatformScheduleWorkItem(&pDM_Odm->RaRptWorkitem);
+#endif
+#endif
+
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+odm_RSSIDumpToRegister(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+
+	if (pDM_Odm->SupportICType == ODM_RTL8812) {
+		PlatformEFIOWrite1Byte(Adapter, rA_RSSIDump_Jaguar, Adapter->RxStats.RxRSSIPercentage[0]);
+		PlatformEFIOWrite1Byte(Adapter, rB_RSSIDump_Jaguar, Adapter->RxStats.RxRSSIPercentage[1]);
+
+		/* Rx EVM*/
+		PlatformEFIOWrite1Byte(Adapter, rS1_RXevmDump_Jaguar, Adapter->RxStats.RxEVMdbm[0]);
+		PlatformEFIOWrite1Byte(Adapter, rS2_RXevmDump_Jaguar, Adapter->RxStats.RxEVMdbm[1]);
+
+		/* Rx SNR*/
+		PlatformEFIOWrite1Byte(Adapter, rA_RXsnrDump_Jaguar, (u1Byte)(Adapter->RxStats.RxSNRdB[0]));
+		PlatformEFIOWrite1Byte(Adapter, rB_RXsnrDump_Jaguar, (u1Byte)(Adapter->RxStats.RxSNRdB[1]));
+
+		/* Rx Cfo_Short*/
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoShortDump_Jaguar, Adapter->RxStats.RxCfoShort[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoShortDump_Jaguar, Adapter->RxStats.RxCfoShort[1]);
+
+		/* Rx Cfo_Tail*/
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoLongDump_Jaguar, Adapter->RxStats.RxCfoTail[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoLongDump_Jaguar, Adapter->RxStats.RxCfoTail[1]);
+	} else if (pDM_Odm->SupportICType == ODM_RTL8192E) {
+		PlatformEFIOWrite1Byte(Adapter, rA_RSSIDump_92E, Adapter->RxStats.RxRSSIPercentage[0]);
+		PlatformEFIOWrite1Byte(Adapter, rB_RSSIDump_92E, Adapter->RxStats.RxRSSIPercentage[1]);
+		/* Rx EVM*/
+		PlatformEFIOWrite1Byte(Adapter, rS1_RXevmDump_92E, Adapter->RxStats.RxEVMdbm[0]);
+		PlatformEFIOWrite1Byte(Adapter, rS2_RXevmDump_92E, Adapter->RxStats.RxEVMdbm[1]);
+		/* Rx SNR*/
+		PlatformEFIOWrite1Byte(Adapter, rA_RXsnrDump_92E, (u1Byte)(Adapter->RxStats.RxSNRdB[0]));
+		PlatformEFIOWrite1Byte(Adapter, rB_RXsnrDump_92E, (u1Byte)(Adapter->RxStats.RxSNRdB[1]));
+		/* Rx Cfo_Short*/
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoShortDump_92E, Adapter->RxStats.RxCfoShort[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoShortDump_92E, Adapter->RxStats.RxCfoShort[1]);
+		/* Rx Cfo_Tail*/
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoLongDump_92E, Adapter->RxStats.RxCfoTail[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoLongDump_92E, Adapter->RxStats.RxCfoTail[1]);
+	}
+}
+
+VOID
+odm_RefreshLdpcRtsMP(
+	IN	PADAPTER			pAdapter,
+	IN	PDM_ODM_T			pDM_Odm,
+	IN	u1Byte				mMacId,
+	IN	u1Byte				IOTPeer,
+	IN	s4Byte				UndecoratedSmoothedPWDB
+)
+{
+	BOOLEAN					bCtlLdpc = FALSE;
+	PMGNT_INFO				pMgntInfo = GetDefaultMgntInfo(pAdapter);
+	PODM_RATE_ADAPTIVE		pRA = &pDM_Odm->RateAdaptive;
+
+	if (pDM_Odm->SupportICType != ODM_RTL8821 && pDM_Odm->SupportICType != ODM_RTL8812)
+		return;
+
+	if ((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
+		bCtlLdpc = TRUE;
+	else if (pDM_Odm->SupportICType == ODM_RTL8812 &&
+			 IOTPeer == HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP)
+		bCtlLdpc = TRUE;
+
+	if (bCtlLdpc) {
+		if (UndecoratedSmoothedPWDB < (pRA->LdpcThres - 5))
+			MgntSet_TX_LDPC(pAdapter, mMacId, TRUE);
+		else if (UndecoratedSmoothedPWDB > pRA->LdpcThres)
+			MgntSet_TX_LDPC(pAdapter, mMacId, FALSE);
+	}
+
+	if (UndecoratedSmoothedPWDB < (pRA->RtsThres - 5))
+		pRA->bLowerRtsRate = TRUE;
+	else if (UndecoratedSmoothedPWDB > pRA->RtsThres)
+		pRA->bLowerRtsRate = FALSE;
+}
+
+VOID
+ODM_DynamicARFBSelect(
+	IN		PVOID		pDM_VOID,
+	IN 		u1Byte			rate,
+	IN  		BOOLEAN			Collision_State
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	if (pDM_Odm->SupportICType != ODM_RTL8192E)
+		return;
+
+	if (Collision_State == pRA_Table->PT_collision_pre)
+		return;
+
+	if (rate >= DESC_RATEMCS8  && rate <= DESC_RATEMCS12) {
+		if (Collision_State == 1) {
+			if (rate == DESC_RATEMCS12) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060501);
+			} else if (rate == DESC_RATEMCS11) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07070605);
+			} else if (rate == DESC_RATEMCS10) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08080706);
+			} else if (rate == DESC_RATEMCS9) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08080707);
+			} else {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09090808);
+			}
+		} else { /* Collision_State == 0*/
+			if (rate == DESC_RATEMCS12) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x05010000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080706);
+			} else if (rate == DESC_RATEMCS11) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x06050000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080807);
+			} else if (rate == DESC_RATEMCS10) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x07060000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0a090908);
+			} else if (rate == DESC_RATEMCS9) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x07070000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0a090808);
+			} else {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x08080000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0b0a0909);
+			}
+		}
+	} else { /* MCS13~MCS15,  1SS, G-mode*/
+		if (Collision_State == 1) {
+			if (rate == DESC_RATEMCS15) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x05040302);
+			} else if (rate == DESC_RATEMCS14) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x06050302);
+			} else if (rate == DESC_RATEMCS13) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060502);
+			} else {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x06050402);
+			}
+		} else { // Collision_State == 0
+			if (rate == DESC_RATEMCS15) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x03020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060504);
+			} else if (rate == DESC_RATEMCS14) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x03020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08070605);
+			} else if (rate == DESC_RATEMCS13) {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x05020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080706);
+			} else {
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x04020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08070605);
+			}
+
+
+		}
+
+	}
+	pRA_Table->PT_collision_pre = Collision_State;
+}
+
+VOID
+ODM_RateAdaptiveStateApInit(
+	IN	PVOID		PADAPTER_VOID,
+	IN	PRT_WLAN_STA  	pEntry
+)
+{
+	PADAPTER		Adapter = (PADAPTER)PADAPTER_VOID;
+	pEntry->Ratr_State = DM_RATR_STA_INIT;
+}
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE) /*#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)*/
+
+static void
+FindMinimumRSSI(
+	IN	PADAPTER	pAdapter
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
+
+	/*Determine the minimum RSSI*/
+
+	if ((pDM_Odm->bLinked != _TRUE) &&
+		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0)) {
+		pHalData->MinUndecoratedPWDBForDM = 0;
+		/*ODM_RT_TRACE(pDM_Odm,COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any\n"));*/
+	} else
+		pHalData->MinUndecoratedPWDBForDM = pHalData->EntryMinUndecoratedSmoothedPWDB;
+
+	/*DBG_8192C("%s=>MinUndecoratedPWDBForDM(%d)\n",__FUNCTION__,pdmpriv->MinUndecoratedPWDBForDM);*/
+	/*ODM_RT_TRACE(pDM_Odm,COMP_DIG, DBG_LOUD, ("MinUndecoratedPWDBForDM =%d\n",pHalData->MinUndecoratedPWDBForDM));*/
+}
+
+u8Byte
+PhyDM_Get_Rate_Bitmap_Ex(
+	IN	PVOID		pDM_VOID,
+	IN	u4Byte		macid,
+	IN	u8Byte		ra_mask,
+	IN	u1Byte		rssi_level,
+	OUT		u8Byte	*dm_RA_Mask,
+	OUT		u1Byte	*dm_RteID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PSTA_INFO_T	pEntry;
+	u8Byte	rate_bitmap = 0;
+	u1Byte	WirelessMode;
+
+	pEntry = pDM_Odm->pODM_StaInfo[macid];
+	if (!IS_STA_VALID(pEntry))
+		return ra_mask;
+	WirelessMode = pEntry->wireless_mode;
+	switch (WirelessMode) {
+	case ODM_WM_B:
+		if (ra_mask & 0x000000000000000c) /* 11M or 5.5M enable */
+			rate_bitmap = 0x000000000000000d;
+		else
+			rate_bitmap = 0x000000000000000f;
+		break;
+
+	case (ODM_WM_G):
+	case (ODM_WM_A):
+		if (rssi_level == DM_RATR_STA_HIGH)
+			rate_bitmap = 0x0000000000000f00;
+		else
+			rate_bitmap = 0x0000000000000ff0;
+		break;
+
+	case (ODM_WM_B|ODM_WM_G):
+		if (rssi_level == DM_RATR_STA_HIGH)
+			rate_bitmap = 0x0000000000000f00;
+		else if (rssi_level == DM_RATR_STA_MIDDLE)
+			rate_bitmap = 0x0000000000000ff0;
+		else
+			rate_bitmap = 0x0000000000000ff5;
+		break;
+
+	case (ODM_WM_B|ODM_WM_G|ODM_WM_N24G):
+	case (ODM_WM_B|ODM_WM_N24G):
+	case (ODM_WM_G|ODM_WM_N24G):
+	case (ODM_WM_A|ODM_WM_N5G): {
+		if (pDM_Odm->RFType == ODM_1T2R || pDM_Odm->RFType == ODM_1T1R) {
+			if (rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x00000000000f0000;
+			else if (rssi_level == DM_RATR_STA_MIDDLE)
+				rate_bitmap = 0x00000000000ff000;
+			else {
+				if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+					rate_bitmap = 0x00000000000ff015;
+				else
+					rate_bitmap = 0x00000000000ff005;
+			}
+		} else if (pDM_Odm->RFType == ODM_2T2R  || pDM_Odm->RFType == ODM_2T3R  || pDM_Odm->RFType == ODM_2T4R) {
+			if (rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x000000000f8f0000;
+			else if (rssi_level == DM_RATR_STA_MIDDLE)
+				rate_bitmap = 0x000000000f8ff000;
+			else {
+				if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+					rate_bitmap = 0x000000000f8ff015;
+				else
+					rate_bitmap = 0x000000000f8ff005;
+			}
+		} else {
+			if (rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x0000000f0f0f0000;
+			else if (rssi_level == DM_RATR_STA_MIDDLE)
+				rate_bitmap = 0x0000000fcfcfe000;
+			else {
+				if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+					rate_bitmap = 0x0000000ffffff015;
+				else
+					rate_bitmap = 0x0000000ffffff005;
+			}
+		}
+	}
+	break;
+
+	case (ODM_WM_AC|ODM_WM_G):
+		if (rssi_level == 1)
+			rate_bitmap = 0x00000000fc3f0000;
+		else if (rssi_level == 2)
+			rate_bitmap = 0x00000000fffff000;
+		else
+			rate_bitmap = 0x00000000ffffffff;
+		break;
+
+	case (ODM_WM_AC|ODM_WM_A):
+
+		if (pDM_Odm->RFType == ODM_1T2R || pDM_Odm->RFType == ODM_1T1R) {
+			if (rssi_level == 1)				/* add by Gary for ac-series */
+				rate_bitmap = 0x00000000003f8000;
+			else if (rssi_level == 2)
+				rate_bitmap = 0x00000000003fe000;
+			else
+				rate_bitmap = 0x00000000003ff010;
+		} else if (pDM_Odm->RFType == ODM_2T2R  || pDM_Odm->RFType == ODM_2T3R  || pDM_Odm->RFType == ODM_2T4R) {
+			if (rssi_level == 1)				/* add by Gary for ac-series */
+				rate_bitmap = 0x00000000fe3f8000;       /* VHT 2SS MCS3~9 */
+			else if (rssi_level == 2)
+				rate_bitmap = 0x00000000fffff000;       /* VHT 2SS MCS0~9 */
+			else
+				rate_bitmap = 0x00000000fffff010;       /* All */
+		} else {
+			if (rssi_level == 1)				/* add by Gary for ac-series */
+				rate_bitmap = 0x000003f8fe3f8000ULL;       /* VHT 3SS MCS3~9 */
+			else if (rssi_level == 2)
+				rate_bitmap = 0x000003fffffff000ULL;       /* VHT3SS MCS0~9 */
+			else
+				rate_bitmap = 0x000003fffffff010ULL;       /* All */
+		}
+		break;
+
+	default:
+		if (pDM_Odm->RFType == ODM_1T2R || pDM_Odm->RFType == ODM_1T1R)
+			rate_bitmap = 0x00000000000fffff;
+		else if (pDM_Odm->RFType == ODM_2T2R  || pDM_Odm->RFType == ODM_2T3R  || pDM_Odm->RFType == ODM_2T4R)
+			rate_bitmap = 0x000000000fffffff;
+		else
+			rate_bitmap = 0x0000003fffffffffULL;
+		break;
+
+	}
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, (" ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%016llx\n", rssi_level, WirelessMode, rate_bitmap));
+
+	return (ra_mask & rate_bitmap);
+}
+
+
+u4Byte
+ODM_Get_Rate_Bitmap(
+	IN	PVOID		pDM_VOID,
+	IN	u4Byte		macid,
+	IN	u4Byte 		ra_mask,
+	IN	u1Byte 		rssi_level
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PSTA_INFO_T   	pEntry;
+	u4Byte 	rate_bitmap = 0;
+	u1Byte 	WirelessMode;
+	//u1Byte 	WirelessMode =*(pDM_Odm->pWirelessMode);
+
+
+	pEntry = pDM_Odm->pODM_StaInfo[macid];
+	if (!IS_STA_VALID(pEntry))
+		return ra_mask;
+
+	WirelessMode = pEntry->wireless_mode;
+
+	switch (WirelessMode) {
+	case ODM_WM_B:
+		if (ra_mask & 0x0000000c)		//11M or 5.5M enable
+			rate_bitmap = 0x0000000d;
+		else
+			rate_bitmap = 0x0000000f;
+		break;
+
+	case (ODM_WM_G):
+	case (ODM_WM_A):
+		if (rssi_level == DM_RATR_STA_HIGH)
+			rate_bitmap = 0x00000f00;
+		else
+			rate_bitmap = 0x00000ff0;
+		break;
+
+	case (ODM_WM_B|ODM_WM_G):
+		if (rssi_level == DM_RATR_STA_HIGH)
+			rate_bitmap = 0x00000f00;
+		else if (rssi_level == DM_RATR_STA_MIDDLE)
+			rate_bitmap = 0x00000ff0;
+		else
+			rate_bitmap = 0x00000ff5;
+		break;
+
+	case (ODM_WM_B|ODM_WM_G|ODM_WM_N24G)	:
+	case (ODM_WM_B|ODM_WM_N24G)	:
+	case (ODM_WM_G|ODM_WM_N24G)	:
+	case (ODM_WM_A|ODM_WM_N5G)	: {
+		if (pDM_Odm->RFType == ODM_1T2R || pDM_Odm->RFType == ODM_1T1R) {
+			if (rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x000f0000;
+			else if (rssi_level == DM_RATR_STA_MIDDLE)
+				rate_bitmap = 0x000ff000;
+			else {
+				if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+					rate_bitmap = 0x000ff015;
+				else
+					rate_bitmap = 0x000ff005;
+			}
+		} else {
+			if (rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x0f8f0000;
+			else if (rssi_level == DM_RATR_STA_MIDDLE)
+				rate_bitmap = 0x0f8ff000;
+			else {
+				if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+					rate_bitmap = 0x0f8ff015;
+				else
+					rate_bitmap = 0x0f8ff005;
+			}
+		}
+	}
+	break;
+
+	case (ODM_WM_AC|ODM_WM_G):
+		if (rssi_level == 1)
+			rate_bitmap = 0xfc3f0000;
+		else if (rssi_level == 2)
+			rate_bitmap = 0xfffff000;
+		else
+			rate_bitmap = 0xffffffff;
+		break;
+
+	case (ODM_WM_AC|ODM_WM_A):
+
+		if (pDM_Odm->RFType == RF_1T1R) {
+			if (rssi_level == 1)				// add by Gary for ac-series
+				rate_bitmap = 0x003f8000;
+			else if (rssi_level == 2)
+				rate_bitmap = 0x003ff000;
+			else
+				rate_bitmap = 0x003ff010;
+		} else {
+			if (rssi_level == 1)				// add by Gary for ac-series
+				rate_bitmap = 0xfe3f8000;       // VHT 2SS MCS3~9
+			else if (rssi_level == 2)
+				rate_bitmap = 0xfffff000;       // VHT 2SS MCS0~9
+			else
+				rate_bitmap = 0xfffff010;       // All
+		}
+		break;
+
+	default:
+		if (pDM_Odm->RFType == RF_1T2R)
+			rate_bitmap = 0x000fffff;
+		else
+			rate_bitmap = 0x0fffffff;
+		break;
+
+	}
+
+	DBG_871X("%s ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x\n", __func__, rssi_level, WirelessMode, rate_bitmap);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, (" ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x\n", rssi_level, WirelessMode, rate_bitmap));
+
+	return (ra_mask & rate_bitmap);
+
+}
+
+#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+#endif /*#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN| ODM_CE))*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.h
new file mode 100644
index 000000000..da7869526
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rainfo.h
@@ -0,0 +1,445 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__PHYDMRAINFO_H__
+#define    __PHYDMRAINFO_H__
+
+/*#define RAINFO_VERSION	"2.0"  //2014.11.04*/
+/*#define RAINFO_VERSION	"3.0"  //2015.01.13 Dino*/
+/*#define RAINFO_VERSION	"3.1"  //2015.01.14 Dino*/
+#define RAINFO_VERSION	"3.2"  /*2015.01.14 Dino*/
+
+#define HIGH_RSSI_THRESH	50
+#define LOW_RSSI_THRESH	20
+
+#define	ACTIVE_TP_THRESHOLD	150
+#define	RA_RETRY_DESCEND_NUM	2
+#define	RA_RETRY_LIMIT_LOW	4
+#define	RA_RETRY_LIMIT_HIGH	32
+
+#define PHYDM_IC_8051_SERIES		(ODM_RTL8881A|ODM_RTL8812|ODM_RTL8821|ODM_RTL8192S|ODM_RTL8192C|ODM_RTL8192D|ODM_RTL8723A|ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8703B|ODM_RTL8188F)
+#define PHYDM_IC_3081_SERIES		(ODM_RTL8814A|ODM_RTL8821B|ODM_RTL8822B)
+
+#define RAINFO_BE_RX_STATE			BIT0  // 1:RX    //ULDL
+#define RAINFO_STBC_STATE			BIT1
+//#define RAINFO_LDPC_STATE 			BIT2
+#define RAINFO_NOISY_STATE 			BIT2    // set by Noisy_Detection
+#define RAINFO_SHURTCUT_STATE 		BIT3
+#define RAINFO_SHURTCUT_FLAG 		BIT4
+#define RAINFO_INIT_RSSI_RATE_STATE  BIT5
+#define RAINFO_BF_STATE 				BIT6
+#define RAINFO_BE_TX_STATE 			BIT7 // 1:TX
+
+#define	RA_MASK_CCK		0xf
+#define	RA_MASK_OFDM		0xff0
+#define	RA_MASK_HT1SS		0xff000
+#define	RA_MASK_HT2SS		0xff00000
+/*#define	RA_MASK_MCS3SS	*/
+#define	RA_MASK_HT4SS		0xff0
+#define	RA_MASK_VHT1SS	0x3ff000
+#define	RA_MASK_VHT2SS	0xffc00000
+
+#if(DM_ODM_SUPPORT_TYPE == ODM_AP)
+#define	EXT_RA_INFO_SUPPORT_IC (ODM_RTL8881A |ODM_RTL8192E |ODM_RTL8812 |ODM_RTL8814A|ODM_RTL8822B)
+#define		RA_FIRST_MACID 	1
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#define	EXT_RA_INFO_SUPPORT_IC (ODM_RTL8192E | ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8723B | ODM_RTL8814A | ODM_RTL8822B | ODM_RTL8703B)
+#define		RA_FIRST_MACID 	0
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+/*#define	EXT_RA_INFO_SUPPORT_IC (ODM_RTL8192E|ODM_RTL8812|ODM_RTL8821|ODM_RTL8723B|ODM_RTL8814A|ODM_RTL8822B|ODM_RTL8703B) */
+#define		RA_FIRST_MACID 	0
+#endif
+
+
+#define AP_InitRateAdaptiveState	ODM_RateAdaptiveStateApInit
+
+#define		DM_RATR_STA_INIT			0
+#define		DM_RATR_STA_HIGH			1
+#define 		DM_RATR_STA_MIDDLE		2
+#define 		DM_RATR_STA_LOW			3
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)
+#define		DM_RATR_STA_ULTRA_LOW	4
+#endif
+
+#define		DM_RA_RATE_UP				1
+#define		DM_RA_RATE_DOWN			2
+
+typedef enum _phydm_arfr_num {
+	ARFR_0_RATE_ID	=	0x9,
+	ARFR_1_RATE_ID	=	0xa,
+	ARFR_2_RATE_ID	=	0xb,
+	ARFR_3_RATE_ID	=	0xc,
+	ARFR_4_RATE_ID	=	0xd,
+	ARFR_5_RATE_ID	=	0xe
+} PHYDM_RA_ARFR_NUM_E;
+
+typedef enum _Phydm_ra_dbg_para {
+	RADBG_RTY_PENALTY			=	1,  //u8
+	RADBG_N_HIGH 				=	2,
+	RADBG_N_LOW				=	3,
+	RADBG_TRATE_UP_TABLE		=	4,
+	RADBG_TRATE_DOWN_TABLE	=	5,
+	RADBG_TRYING_NECESSARY	=	6,
+	RADBG_TDROPING_NECESSARY =	7,
+	RADBG_RATE_UP_RTY_RATIO	=	8, //u8
+	RADBG_RATE_DOWN_RTY_RATIO =	9, //u8
+
+	RADBG_DEBUG_MONITOR1 = 0xc,
+	RADBG_DEBUG_MONITOR2 = 0xd,
+	RADBG_DEBUG_MONITOR3 = 0xe,
+	RADBG_DEBUG_MONITOR4 = 0xf,
+	NUM_RA_PARA
+} PHYDM_RA_DBG_PARA_E;
+
+
+#if (RATE_ADAPTIVE_SUPPORT == 1)//88E RA
+typedef struct _ODM_RA_Info_ {
+	u1Byte RateID;
+	u4Byte RateMask;
+	u4Byte RAUseRate;
+	u1Byte RateSGI;
+	u1Byte RssiStaRA;
+	u1Byte PreRssiStaRA;
+	u1Byte SGIEnable;
+	u1Byte DecisionRate;
+	u1Byte PreRate;
+	u1Byte HighestRate;
+	u1Byte LowestRate;
+	u4Byte NscUp;
+	u4Byte NscDown;
+	u2Byte RTY[5];
+	u4Byte TOTAL;
+	u2Byte DROP;
+	u1Byte Active;
+	u2Byte RptTime;
+	u1Byte RAWaitingCounter;
+	u1Byte RAPendingCounter;
+#if 1 //POWER_TRAINING_ACTIVE == 1 // For compile  pass only~!
+	u1Byte PTActive;  // on or off
+	u1Byte PTTryState;  // 0 trying state, 1 for decision state
+	u1Byte PTStage;  // 0~6
+	u1Byte PTStopCount; //Stop PT counter
+	u1Byte PTPreRate;  // if rate change do PT
+	u1Byte PTPreRssi; // if RSSI change 5% do PT
+	u1Byte PTModeSS;  // decide whitch rate should do PT
+	u1Byte RAstage;  // StageRA, decide how many times RA will be done between PT
+	u1Byte PTSmoothFactor;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP) && ((DEV_BUS_TYPE == RT_USB_INTERFACE) || (DEV_BUS_TYPE == RT_SDIO_INTERFACE))
+	u1Byte RateDownCounter;
+	u1Byte RateUpCounter;
+	u1Byte RateDirection;
+	u1Byte BoundingType;
+	u1Byte BoundingCounter;
+	u1Byte BoundingLearningTime;
+	u1Byte RateDownStartTime;
+#endif
+} ODM_RA_INFO_T, *PODM_RA_INFO_T;
+#endif
+
+
+typedef struct _Rate_Adaptive_Table_ {
+	u1Byte		firstconnect;
+#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+	BOOLEAN		PT_collision_pre;
+#endif
+
+#if (defined(CONFIG_RA_DBG_CMD))
+	BOOLEAN		is_ra_dbg_init;
+
+	u1Byte	RTY_P[ODM_NUM_RATE_IDX];
+	u1Byte	RTY_P_default[ODM_NUM_RATE_IDX];
+	BOOLEAN	RTY_P_modify_note[ODM_NUM_RATE_IDX];
+
+	u1Byte	RATE_UP_RTY_RATIO[ODM_NUM_RATE_IDX];
+	u1Byte	RATE_UP_RTY_RATIO_default[ODM_NUM_RATE_IDX];
+	BOOLEAN	RATE_UP_RTY_RATIO_modify_note[ODM_NUM_RATE_IDX];
+
+	u1Byte	RATE_DOWN_RTY_RATIO[ODM_NUM_RATE_IDX];
+	u1Byte	RATE_DOWN_RTY_RATIO_default[ODM_NUM_RATE_IDX];
+	BOOLEAN	RATE_DOWN_RTY_RATIO_modify_note[ODM_NUM_RATE_IDX];
+
+	BOOLEAN RA_Para_feedback_req;
+
+	u1Byte   para_idx;
+	u1Byte	rate_idx;
+	u1Byte	value;
+	u2Byte	value_16;
+	u1Byte	rate_length;
+#endif
+	u1Byte	link_tx_rate[ODM_ASSOCIATE_ENTRY_NUM];
+
+	#if (defined(CONFIG_RA_DYNAMIC_RTY_LIMIT))
+	u1Byte per_rate_retrylimit_20M[ODM_NUM_RATE_IDX];
+	u1Byte per_rate_retrylimit_40M[ODM_NUM_RATE_IDX];	
+	u1Byte			retry_descend_num;
+	u1Byte			retrylimit_low;
+	u1Byte			retrylimit_high;
+	#endif
+
+
+} RA_T, *pRA_T;
+
+typedef struct _ODM_RATE_ADAPTIVE {
+	u1Byte				Type;				// DM_Type_ByFW/DM_Type_ByDriver
+	u1Byte				HighRSSIThresh;		// if RSSI > HighRSSIThresh	=> RATRState is DM_RATR_STA_HIGH
+	u1Byte				LowRSSIThresh;		// if RSSI <= LowRSSIThresh	=> RATRState is DM_RATR_STA_LOW
+	u1Byte				RATRState;			// Current RSSI level, DM_RATR_STA_HIGH/DM_RATR_STA_MIDDLE/DM_RATR_STA_LOW
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	u1Byte				LdpcThres;			// if RSSI > LdpcThres => switch from LPDC to BCC
+	BOOLEAN				bLowerRtsRate;
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	u1Byte				RtsThres;
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	BOOLEAN				bUseLdpc;
+#else
+	u1Byte				UltraLowRSSIThresh;
+	u4Byte				LastRATR;			// RATR Register Content
+#endif
+
+} ODM_RATE_ADAPTIVE, *PODM_RATE_ADAPTIVE;
+
+VOID
+ODM_C2HRaParaReportHandler(
+	IN	PVOID	pDM_VOID,
+	IN pu1Byte   CmdBuf,
+	IN u1Byte   CmdLen
+);
+
+VOID
+odm_RA_ParaAdjust_Send_H2C(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+odm_RA_debug(
+	IN		PVOID		pDM_VOID,
+	IN		u4Byte		*const dm_value
+);
+
+VOID
+odm_RA_ParaAdjust_init(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_RA_ParaAdjust(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+phydm_ra_dynamic_retry_count(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+phydm_ra_dynamic_retry_limit(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+phydm_ra_dynamic_rate_id_on_assoc(
+	IN	PVOID	pDM_VOID,
+	IN	u1Byte	wireless_mode,
+	IN	u1Byte	init_rate_id
+);
+
+VOID
+phydm_c2h_ra_report_handler(
+	IN PVOID	pDM_VOID,
+	IN pu1Byte   CmdBuf,
+	IN u1Byte   CmdLen
+);
+
+VOID
+phydm_ra_info_init(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+odm_RSSIMonitorInit(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+odm_RSSIMonitorCheck(
+	IN	PVOID	pDM_VOID
+);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+s4Byte
+phydm_FindMinimumRSSI(
+IN		PDM_ODM_T		pDM_Odm,
+IN		PADAPTER		pAdapter,
+IN OUT	BOOLEAN	*pbLink_temp
+
+	);
+#endif
+
+VOID
+odm_RSSIMonitorCheckMP(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+odm_RSSIMonitorCheckCE(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+odm_RSSIMonitorCheckAP(
+	IN	PVOID	pDM_VOID
+);
+
+
+VOID
+odm_RateAdaptiveMaskInit(
+	IN 	PVOID	pDM_VOID
+);
+
+VOID
+odm_RefreshRateAdaptiveMask(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_RefreshRateAdaptiveMaskMP(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_RefreshRateAdaptiveMaskCE(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+odm_RefreshRateAdaptiveMaskAPADSL(
+	IN		PVOID		pDM_VOID
+);
+
+BOOLEAN
+ODM_RAStateCheck(
+	IN		PVOID		    pDM_VOID,
+	IN		s4Byte			RSSI,
+	IN		BOOLEAN			bForceUpdate,
+	OUT		pu1Byte			pRATRState
+);
+
+VOID
+odm_RefreshBasicRateMask(
+	IN		PVOID		pDM_VOID
+);
+VOID
+ODM_RAPostActionOnAssoc(
+	IN		PVOID	pDM_Odm
+);
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+
+u1Byte
+odm_Find_RTS_Rate(
+	IN	PVOID		pDM_VOID,
+	IN		u1Byte			Tx_Rate,
+	IN		BOOLEAN			bErpProtect
+);
+
+VOID
+ODM_UpdateNoisyState(
+	IN	PVOID		pDM_VOID,
+	IN	BOOLEAN		bNoisyStateFromC2H
+);
+
+u4Byte
+Set_RA_DM_Ratrbitmap_by_Noisy(
+	IN	PVOID			pDM_VOID,
+	IN	WIRELESS_MODE	WirelessMode,
+	IN	u4Byte			ratr_bitmap,
+	IN	u1Byte			rssi_level
+);
+
+VOID
+ODM_UpdateInitRate(
+	IN	PVOID		pDM_VOID,
+	IN	u1Byte		Rate
+);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+odm_RSSIDumpToRegister(
+	IN	PVOID	pDM_VOID
+);
+
+VOID
+odm_RefreshLdpcRtsMP(
+	IN	PADAPTER			pAdapter,
+	IN	PDM_ODM_T			pDM_Odm,
+	IN	u1Byte				mMacId,
+	IN	u1Byte				IOTPeer,
+	IN	s4Byte				UndecoratedSmoothedPWDB
+);
+
+VOID
+ODM_DynamicARFBSelect(
+	IN		PVOID		pDM_VOID,
+	IN 		u1Byte		rate,
+	IN  	BOOLEAN		Collision_State
+);
+
+VOID
+ODM_RateAdaptiveStateApInit(
+	IN	PVOID			PADAPTER_VOID,
+	IN	PRT_WLAN_STA  	pEntry
+);
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+static void
+FindMinimumRSSI(
+	IN	PADAPTER	pAdapter
+);
+
+u8Byte
+PhyDM_Get_Rate_Bitmap_Ex(
+	IN	PVOID		pDM_VOID,
+	IN	u4Byte		macid,
+	IN	u8Byte		ra_mask,
+	IN	u1Byte		rssi_level,
+	OUT		u8Byte	*dm_RA_Mask,
+	OUT		u1Byte	*dm_RteID
+);
+u4Byte
+ODM_Get_Rate_Bitmap(
+	IN	PVOID	    pDM_VOID,
+	IN	u4Byte		macid,
+	IN	u4Byte 		ra_mask,
+	IN	u1Byte 		rssi_level
+);
+void phydm_ra_rssi_rpt_wk(PVOID pContext);
+
+#endif/*#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)*/
+
+#endif/*#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN| ODM_CE))*/
+
+#endif /*#ifndef	__ODMRAINFO_H__*/
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_reg.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_reg.h
new file mode 100644
index 000000000..e8424139b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_reg.h
@@ -0,0 +1,208 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+//============================================================
+// File Name: odm_reg.h
+//
+// Description:
+//
+// This file is for general register definition.
+//
+//
+//============================================================
+#ifndef	__HAL_ODM_REG_H__
+#define __HAL_ODM_REG_H__
+
+//
+// Register Definition
+//
+
+//MAC REG
+#define	ODM_BB_RESET					0x002
+#define	ODM_DUMMY						0x4fe
+#define	RF_T_METER_OLD				0x24
+#define	RF_T_METER_NEW				0x42
+
+#define	ODM_EDCA_VO_PARAM			0x500
+#define	ODM_EDCA_VI_PARAM			0x504
+#define	ODM_EDCA_BE_PARAM			0x508
+#define	ODM_EDCA_BK_PARAM			0x50C
+#define	ODM_TXPAUSE					0x522
+
+//BB REG
+#define	ODM_FPGA_PHY0_PAGE8			0x800
+#define	ODM_PSD_SETTING				0x808
+#define	ODM_AFE_SETTING				0x818
+#define	ODM_TXAGC_B_6_18				0x830
+#define	ODM_TXAGC_B_24_54			0x834
+#define	ODM_TXAGC_B_MCS32_5			0x838
+#define	ODM_TXAGC_B_MCS0_MCS3		0x83c
+#define	ODM_TXAGC_B_MCS4_MCS7		0x848
+#define	ODM_TXAGC_B_MCS8_MCS11		0x84c
+#define	ODM_ANALOG_REGISTER			0x85c
+#define	ODM_RF_INTERFACE_OUTPUT		0x860
+#define	ODM_TXAGC_B_MCS12_MCS15	0x868
+#define	ODM_TXAGC_B_11_A_2_11		0x86c
+#define	ODM_AD_DA_LSB_MASK			0x874
+#define	ODM_ENABLE_3_WIRE			0x88c
+#define	ODM_PSD_REPORT				0x8b4
+#define	ODM_R_ANT_SELECT				0x90c
+#define	ODM_CCK_ANT_SELECT			0xa07
+#define	ODM_CCK_PD_THRESH			0xa0a
+#define	ODM_CCK_RF_REG1				0xa11
+#define	ODM_CCK_MATCH_FILTER			0xa20
+#define	ODM_CCK_RAKE_MAC				0xa2e
+#define	ODM_CCK_CNT_RESET			0xa2d
+#define	ODM_CCK_TX_DIVERSITY			0xa2f
+#define	ODM_CCK_FA_CNT_MSB			0xa5b
+#define	ODM_CCK_FA_CNT_LSB			0xa5c
+#define	ODM_CCK_NEW_FUNCTION		0xa75
+#define	ODM_OFDM_PHY0_PAGE_C		0xc00
+#define	ODM_OFDM_RX_ANT				0xc04
+#define	ODM_R_A_RXIQI					0xc14
+#define	ODM_R_A_AGC_CORE1			0xc50
+#define	ODM_R_A_AGC_CORE2			0xc54
+#define	ODM_R_B_AGC_CORE1			0xc58
+#define	ODM_R_AGC_PAR					0xc70
+#define	ODM_R_HTSTF_AGC_PAR			0xc7c
+#define	ODM_TX_PWR_TRAINING_A		0xc90
+#define	ODM_TX_PWR_TRAINING_B		0xc98
+#define	ODM_OFDM_FA_CNT1				0xcf0
+#define	ODM_OFDM_PHY0_PAGE_D		0xd00
+#define	ODM_OFDM_FA_CNT2				0xda0
+#define	ODM_OFDM_FA_CNT3				0xda4
+#define	ODM_OFDM_FA_CNT4				0xda8
+#define	ODM_TXAGC_A_6_18				0xe00
+#define	ODM_TXAGC_A_24_54			0xe04
+#define	ODM_TXAGC_A_1_MCS32			0xe08
+#define	ODM_TXAGC_A_MCS0_MCS3		0xe10
+#define	ODM_TXAGC_A_MCS4_MCS7		0xe14
+#define	ODM_TXAGC_A_MCS8_MCS11		0xe18
+#define	ODM_TXAGC_A_MCS12_MCS15		0xe1c
+
+//RF REG
+#define	ODM_GAIN_SETTING				0x00
+#define	ODM_CHANNEL					0x18
+#define	ODM_RF_T_METER				0x24
+#define	ODM_RF_T_METER_92D			0x42
+#define	ODM_RF_T_METER_88E			0x42
+#define	ODM_RF_T_METER_92E			0x42
+#define	ODM_RF_T_METER_8812			0x42
+
+//Ant Detect Reg
+#define	ODM_DPDT						0x300
+
+//PSD Init
+#define	ODM_PSDREG					0x808
+
+//92D Path Div
+#define	PATHDIV_REG					0xB30
+#define	PATHDIV_TRI					0xBA0
+
+
+//
+// Bitmap Definition
+//
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP))
+// TX AGC 
+#define		rTxAGC_A_CCK11_CCK1_JAguar	0xc20
+#define		rTxAGC_A_Ofdm18_Ofdm6_JAguar	0xc24
+#define		rTxAGC_A_Ofdm54_Ofdm24_JAguar	0xc28
+#define		rTxAGC_A_MCS3_MCS0_JAguar	0xc2c
+#define		rTxAGC_A_MCS7_MCS4_JAguar	0xc30
+#define		rTxAGC_A_MCS11_MCS8_JAguar	0xc34
+#define		rTxAGC_A_MCS15_MCS12_JAguar	0xc38
+#define		rTxAGC_A_Nss1Index3_Nss1Index0_JAguar	0xc3c
+#define		rTxAGC_A_Nss1Index7_Nss1Index4_JAguar	0xc40
+#define		rTxAGC_A_Nss2Index1_Nss1Index8_JAguar	0xc44
+#define		rTxAGC_A_Nss2Index5_Nss2Index2_JAguar	0xc48
+#define		rTxAGC_A_Nss2Index9_Nss2Index6_JAguar	0xc4c
+#if defined(CONFIG_WLAN_HAL_8814AE)
+#define		rTxAGC_A_MCS19_MCS16_JAguar	0xcd8
+#define		rTxAGC_A_MCS23_MCS20_JAguar	0xcdc
+#define		rTxAGC_A_Nss3Index3_Nss3Index0_JAguar	0xce0
+#define		rTxAGC_A_Nss3Index7_Nss3Index4_JAguar	0xce4
+#define		rTxAGC_A_Nss3Index9_Nss3Index8_JAguar	0xce8
+#endif
+#define		rTxAGC_B_CCK11_CCK1_JAguar	0xe20
+#define		rTxAGC_B_Ofdm18_Ofdm6_JAguar	0xe24
+#define		rTxAGC_B_Ofdm54_Ofdm24_JAguar	0xe28
+#define		rTxAGC_B_MCS3_MCS0_JAguar	0xe2c
+#define		rTxAGC_B_MCS7_MCS4_JAguar	0xe30
+#define		rTxAGC_B_MCS11_MCS8_JAguar	0xe34
+#define		rTxAGC_B_MCS15_MCS12_JAguar	0xe38
+#define		rTxAGC_B_Nss1Index3_Nss1Index0_JAguar	0xe3c
+#define		rTxAGC_B_Nss1Index7_Nss1Index4_JAguar	0xe40
+#define		rTxAGC_B_Nss2Index1_Nss1Index8_JAguar	0xe44
+#define		rTxAGC_B_Nss2Index5_Nss2Index2_JAguar	0xe48
+#define		rTxAGC_B_Nss2Index9_Nss2Index6_JAguar	0xe4c
+#if defined(CONFIG_WLAN_HAL_8814AE)
+#define		rTxAGC_B_MCS19_MCS16_JAguar	0xed8
+#define		rTxAGC_B_MCS23_MCS20_JAguar	0xedc
+#define		rTxAGC_B_Nss3Index3_Nss3Index0_JAguar	0xee0
+#define		rTxAGC_B_Nss3Index7_Nss3Index4_JAguar	0xee4
+#define		rTxAGC_B_Nss3Index9_Nss3Index8_JAguar	0xee8
+#define		rTxAGC_C_CCK11_CCK1_JAguar	0x1820
+#define		rTxAGC_C_Ofdm18_Ofdm6_JAguar	0x1824
+#define		rTxAGC_C_Ofdm54_Ofdm24_JAguar	0x1828
+#define		rTxAGC_C_MCS3_MCS0_JAguar	0x182c
+#define		rTxAGC_C_MCS7_MCS4_JAguar	0x1830
+#define		rTxAGC_C_MCS11_MCS8_JAguar	0x1834
+#define		rTxAGC_C_MCS15_MCS12_JAguar	0x1838
+#define		rTxAGC_C_Nss1Index3_Nss1Index0_JAguar	0x183c
+#define		rTxAGC_C_Nss1Index7_Nss1Index4_JAguar	0x1840
+#define		rTxAGC_C_Nss2Index1_Nss1Index8_JAguar	0x1844
+#define		rTxAGC_C_Nss2Index5_Nss2Index2_JAguar	0x1848
+#define		rTxAGC_C_Nss2Index9_Nss2Index6_JAguar	0x184c
+#define		rTxAGC_C_MCS19_MCS16_JAguar	0x18d8
+#define		rTxAGC_C_MCS23_MCS20_JAguar	0x18dc
+#define		rTxAGC_C_Nss3Index3_Nss3Index0_JAguar	0x18e0
+#define		rTxAGC_C_Nss3Index7_Nss3Index4_JAguar	0x18e4
+#define		rTxAGC_C_Nss3Index9_Nss3Index8_JAguar	0x18e8
+#define		rTxAGC_D_CCK11_CCK1_JAguar	0x1a20
+#define		rTxAGC_D_Ofdm18_Ofdm6_JAguar	0x1a24
+#define		rTxAGC_D_Ofdm54_Ofdm24_JAguar	0x1a28
+#define		rTxAGC_D_MCS3_MCS0_JAguar	0x1a2c
+#define		rTxAGC_D_MCS7_MCS4_JAguar	0x1a30
+#define		rTxAGC_D_MCS11_MCS8_JAguar	0x1a34
+#define		rTxAGC_D_MCS15_MCS12_JAguar	0x1a38
+#define		rTxAGC_D_Nss1Index3_Nss1Index0_JAguar	0x1a3c
+#define		rTxAGC_D_Nss1Index7_Nss1Index4_JAguar	0x1a40
+#define		rTxAGC_D_Nss2Index1_Nss1Index8_JAguar	0x1a44
+#define		rTxAGC_D_Nss2Index5_Nss2Index2_JAguar	0x1a48
+#define		rTxAGC_D_Nss2Index9_Nss2Index6_JAguar	0x1a4c
+#define		rTxAGC_D_MCS19_MCS16_JAguar	0x1ad8
+#define		rTxAGC_D_MCS23_MCS20_JAguar	0x1adc
+#define		rTxAGC_D_Nss3Index3_Nss3Index0_JAguar	0x1ae0
+#define		rTxAGC_D_Nss3Index7_Nss3Index4_JAguar	0x1ae4
+#define		rTxAGC_D_Nss3Index9_Nss3Index8_JAguar	0x1ae8
+#endif
+
+#define		bTxAGC_byte0_Jaguar	0xff
+#define		bTxAGC_byte1_Jaguar	0xff00
+#define		bTxAGC_byte2_Jaguar	0xff0000
+#define		bTxAGC_byte3_Jaguar	0xff000000
+#endif
+
+#define	BIT_FA_RESET					BIT0
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11ac.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11ac.h
new file mode 100644
index 000000000..c8a551d1c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11ac.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__ODM_REGDEFINE11AC_H__
+#define __ODM_REGDEFINE11AC_H__
+
+//2 RF REG LIST
+
+
+
+//2 BB REG LIST
+//PAGE 8
+#define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
+#define	ODM_REG_BB_RX_PATH_11AC			0x808
+#define	ODM_REG_BB_TX_PATH_11AC			0x80c
+#define	ODM_REG_BB_ATC_11AC				0x860
+#define	ODM_REG_EDCCA_POWER_CAL		0x8dc
+#define	ODM_REG_DBG_RPT_11AC			0x8fc
+//PAGE 9
+#define	ODM_REG_EDCCA_DOWN_OPT			0x900
+#define	ODM_REG_ACBB_EDCCA_ENHANCE		0x944
+#define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
+#define	ODM_REG_NHM_TIMER_11AC			0x990
+#define	ODM_REG_CLM_TIME_PERIOD_11AC	0x990
+#define	ODM_REG_NHM_TH9_TH10_11AC		0x994
+#define	ODM_REG_CLM_11AC					0x994
+#define	ODM_REG_NHM_TH3_TO_TH0_11AC	0x998
+#define	ODM_REG_NHM_TH7_TO_TH4_11AC	0x99c
+#define	ODM_REG_NHM_TH8_11AC			0x9a0
+#define	ODM_REG_NHM_9E8_11AC			0x9e8
+#define	ODM_REG_CSI_CONTENT_VALUE		0x9b4
+//PAGE A
+#define	ODM_REG_CCK_CCA_11AC			0xA0A
+#define	ODM_REG_CCK_FA_RST_11AC			0xA2C
+#define	ODM_REG_CCK_FA_11AC				0xA5C
+//PAGE B
+#define	ODM_REG_RST_RPT_11AC				0xB58
+//PAGE C
+#define	ODM_REG_TRMUX_11AC				0xC08
+#define	ODM_REG_IGI_A_11AC				0xC50
+//PAGE E
+#define	ODM_REG_IGI_B_11AC				0xE50
+#define	ODM_REG_TRMUX_11AC_B			0xE08
+//PAGE F
+#define	ODM_REG_CCK_CCA_CNT_11AC		0xF08
+#define	ODM_REG_OFDM_FA_11AC			0xF48
+#define	ODM_REG_RPT_11AC					0xfa0
+#define	ODM_REG_CLM_RESULT_11AC			0xfa4
+#define	ODM_REG_NHM_CNT_11AC			0xfa8
+#define ODM_REG_NHM_DUR_READY_11AC      0xfb4
+
+#define	ODM_REG_NHM_CNT7_TO_CNT4_11AC   0xfac
+#define	ODM_REG_NHM_CNT11_TO_CNT8_11AC  0xfb0
+#define	ODM_REG_OFDM_FA_TYPE2_11AC		0xFD0
+//PAGE 18
+#define	ODM_REG_IGI_C_11AC				0x1850
+//PAGE 1A
+#define	ODM_REG_IGI_D_11AC				0x1A50
+
+//2 MAC REG LIST
+#define	ODM_REG_RESP_TX_11AC				0x6D8
+
+
+
+//DIG Related
+#define	ODM_BIT_IGI_11AC					0xFFFFFFFF
+#define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT16
+#define	ODM_BIT_BB_RX_PATH_11AC			0xF
+#define	ODM_BIT_BB_TX_PATH_11AC			0xF
+#define	ODM_BIT_BB_ATC_11AC				BIT14
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11n.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11n.h
new file mode 100644
index 000000000..8826dfb20
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_regdefine11n.h
@@ -0,0 +1,199 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__ODM_REGDEFINE11N_H__
+#define __ODM_REGDEFINE11N_H__
+
+
+//2 RF REG LIST
+#define	ODM_REG_RF_MODE_11N				0x00
+#define	ODM_REG_RF_0B_11N				0x0B
+#define	ODM_REG_CHNBW_11N				0x18
+#define	ODM_REG_T_METER_11N				0x24
+#define	ODM_REG_RF_25_11N				0x25
+#define	ODM_REG_RF_26_11N				0x26
+#define	ODM_REG_RF_27_11N				0x27
+#define	ODM_REG_RF_2B_11N				0x2B
+#define	ODM_REG_RF_2C_11N				0x2C
+#define	ODM_REG_RXRF_A3_11N				0x3C
+#define	ODM_REG_T_METER_92D_11N			0x42
+#define	ODM_REG_T_METER_88E_11N			0x42
+
+
+
+//2 BB REG LIST
+//PAGE 8
+#define	ODM_REG_BB_CTRL_11N				0x800
+#define	ODM_REG_RF_PIN_11N				0x804
+#define	ODM_REG_PSD_CTRL_11N				0x808
+#define	ODM_REG_TX_ANT_CTRL_11N			0x80C
+#define	ODM_REG_BB_PWR_SAV5_11N			0x818
+#define	ODM_REG_CCK_RPT_FORMAT_11N		0x824
+#define	ODM_REG_CCK_RPT_FORMAT_11N_B	0x82C
+#define	ODM_REG_RX_DEFUALT_A_11N		0x858
+#define	ODM_REG_RX_DEFUALT_B_11N		0x85A
+#define	ODM_REG_BB_PWR_SAV3_11N			0x85C
+#define	ODM_REG_ANTSEL_CTRL_11N			0x860
+#define	ODM_REG_RX_ANT_CTRL_11N			0x864
+#define	ODM_REG_PIN_CTRL_11N				0x870
+#define	ODM_REG_BB_PWR_SAV1_11N			0x874
+#define	ODM_REG_ANTSEL_PATH_11N			0x878
+#define	ODM_REG_BB_3WIRE_11N			0x88C
+#define	ODM_REG_SC_CNT_11N				0x8C4
+#define	ODM_REG_PSD_DATA_11N				0x8B4
+#define	ODM_REG_PSD_DATA_11N				0x8B4
+#define	ODM_REG_NHM_TIMER_11N			0x894
+#define	ODM_REG_CLM_TIME_PERIOD_11N			0x894
+#define	ODM_REG_NHM_TH9_TH10_11N		0x890
+#define	ODM_REG_CLM_11N					0x890
+#define	ODM_REG_NHM_TH3_TO_TH0_11N		0x898
+#define	ODM_REG_NHM_TH7_TO_TH4_11N		0x89c
+#define ODM_REG_NHM_TH8_11N				0xe28
+#define	ODM_REG_CLM_READY_11N			0x8b4
+#define	ODM_REG_CLM_RESULT_11N			0x8d0
+#define	ODM_REG_NHM_CNT_11N				0x8d8
+
+// For ACS, Jeffery, 2014-12-26
+#define	ODM_REG_NHM_CNT7_TO_CNT4_11N    0x8dc
+#define	ODM_REG_NHM_CNT9_TO_CNT8_11N    0x8d0
+#define	ODM_REG_NHM_CNT10_11N           0x8d4
+
+
+
+//PAGE 9
+#define	ODM_REG_DBG_RPT_11N				0x908
+#define	ODM_REG_BB_TX_PATH_11N			0x90c
+#define	ODM_REG_ANT_MAPPING1_11N		0x914
+#define	ODM_REG_ANT_MAPPING2_11N		0x918
+#define	ODM_REG_EDCCA_DOWN_OPT_11N	0x948
+
+//PAGE A
+#define	ODM_REG_CCK_ANTDIV_PARA1_11N	0xA00
+#define	ODM_REG_CCK_CCA_11N				0xA0A
+#define	ODM_REG_CCK_ANTDIV_PARA2_11N	0xA0C
+#define	ODM_REG_CCK_ANTDIV_PARA3_11N	0xA10
+#define	ODM_REG_CCK_ANTDIV_PARA4_11N	0xA14
+#define	ODM_REG_CCK_FILTER_PARA1_11N	0xA22
+#define	ODM_REG_CCK_FILTER_PARA2_11N	0xA23
+#define	ODM_REG_CCK_FILTER_PARA3_11N	0xA24
+#define	ODM_REG_CCK_FILTER_PARA4_11N	0xA25
+#define	ODM_REG_CCK_FILTER_PARA5_11N	0xA26
+#define	ODM_REG_CCK_FILTER_PARA6_11N	0xA27
+#define	ODM_REG_CCK_FILTER_PARA7_11N	0xA28
+#define	ODM_REG_CCK_FILTER_PARA8_11N	0xA29
+#define	ODM_REG_CCK_FA_RST_11N			0xA2C
+#define	ODM_REG_CCK_FA_MSB_11N			0xA58
+#define	ODM_REG_CCK_FA_LSB_11N			0xA5C
+#define	ODM_REG_CCK_CCA_CNT_11N			0xA60
+#define	ODM_REG_BB_PWR_SAV4_11N			0xA74
+//PAGE B
+#define	ODM_REG_LNA_SWITCH_11N			0xB2C
+#define	ODM_REG_PATH_SWITCH_11N			0xB30
+#define	ODM_REG_RSSI_CTRL_11N			0xB38
+#define	ODM_REG_CONFIG_ANTA_11N			0xB68
+#define	ODM_REG_RSSI_BT_11N				0xB9C
+//PAGE C
+#define	ODM_REG_OFDM_FA_HOLDC_11N		0xC00
+#define	ODM_REG_BB_RX_PATH_11N			0xC04
+#define	ODM_REG_TRMUX_11N				0xC08
+#define	ODM_REG_OFDM_FA_RSTC_11N		0xC0C
+#define	ODM_REG_RXIQI_MATRIX_11N		0xC14
+#define	ODM_REG_TXIQK_MATRIX_LSB1_11N	0xC4C
+#define	ODM_REG_IGI_A_11N				0xC50
+#define	ODM_REG_ANTDIV_PARA2_11N		0xC54
+#define	ODM_REG_IGI_B_11N					0xC58
+#define	ODM_REG_ANTDIV_PARA3_11N		0xC5C
+#define   ODM_REG_L1SBD_PD_CH_11N			0XC6C
+#define	ODM_REG_BB_PWR_SAV2_11N		0xC70
+#define	ODM_REG_RX_OFF_11N				0xC7C
+#define	ODM_REG_TXIQK_MATRIXA_11N		0xC80
+#define	ODM_REG_TXIQK_MATRIXB_11N		0xC88
+#define	ODM_REG_TXIQK_MATRIXA_LSB2_11N	0xC94
+#define	ODM_REG_TXIQK_MATRIXB_LSB2_11N	0xC9C
+#define	ODM_REG_RXIQK_MATRIX_LSB_11N	0xCA0
+#define	ODM_REG_ANTDIV_PARA1_11N		0xCA4
+#define	ODM_REG_OFDM_FA_TYPE1_11N		0xCF0
+//PAGE D
+#define	ODM_REG_OFDM_FA_RSTD_11N		0xD00
+#define	ODM_REG_BB_ATC_11N				0xD2C
+#define	ODM_REG_OFDM_FA_TYPE2_11N		0xDA0
+#define	ODM_REG_OFDM_FA_TYPE3_11N		0xDA4
+#define	ODM_REG_OFDM_FA_TYPE4_11N		0xDA8
+#define	ODM_REG_RPT_11N					0xDF4
+//PAGE E
+#define	ODM_REG_TXAGC_A_6_18_11N		0xE00
+#define	ODM_REG_TXAGC_A_24_54_11N		0xE04
+#define	ODM_REG_TXAGC_A_1_MCS32_11N	0xE08
+#define	ODM_REG_TXAGC_A_MCS0_3_11N		0xE10
+#define	ODM_REG_TXAGC_A_MCS4_7_11N		0xE14
+#define	ODM_REG_TXAGC_A_MCS8_11_11N	0xE18
+#define	ODM_REG_TXAGC_A_MCS12_15_11N	0xE1C
+#define	ODM_REG_EDCCA_DCNF_11N			0xE24
+#define	ODM_REG_FPGA0_IQK_11N			0xE28
+#define	ODM_REG_TXIQK_TONE_A_11N		0xE30
+#define	ODM_REG_RXIQK_TONE_A_11N		0xE34
+#define	ODM_REG_TXIQK_PI_A_11N			0xE38
+#define	ODM_REG_RXIQK_PI_A_11N			0xE3C
+#define	ODM_REG_TXIQK_11N				0xE40
+#define	ODM_REG_RXIQK_11N				0xE44
+#define	ODM_REG_IQK_AGC_PTS_11N			0xE48
+#define	ODM_REG_IQK_AGC_RSP_11N			0xE4C
+#define	ODM_REG_BLUETOOTH_11N			0xE6C
+#define	ODM_REG_RX_WAIT_CCA_11N			0xE70
+#define	ODM_REG_TX_CCK_RFON_11N			0xE74
+#define	ODM_REG_TX_CCK_BBON_11N			0xE78
+#define	ODM_REG_OFDM_RFON_11N			0xE7C
+#define	ODM_REG_OFDM_BBON_11N			0xE80
+#define 	ODM_REG_TX2RX_11N				0xE84
+#define	ODM_REG_TX2TX_11N				0xE88
+#define	ODM_REG_RX_CCK_11N				0xE8C
+#define	ODM_REG_RX_OFDM_11N				0xED0
+#define	ODM_REG_RX_WAIT_RIFS_11N		0xED4
+#define	ODM_REG_RX2RX_11N				0xED8
+#define	ODM_REG_STANDBY_11N				0xEDC
+#define	ODM_REG_SLEEP_11N				0xEE0
+#define	ODM_REG_PMPD_ANAEN_11N			0xEEC
+#define	ODM_REG_IGI_C_11N					0xF84
+#define	ODM_REG_IGI_D_11N					0xF88
+
+//2 MAC REG LIST
+#define	ODM_REG_BB_RST_11N				0x02
+#define	ODM_REG_ANTSEL_PIN_11N			0x4C
+#define	ODM_REG_EARLY_MODE_11N			0x4D0
+#define	ODM_REG_RSSI_MONITOR_11N		0x4FE
+#define	ODM_REG_EDCA_VO_11N				0x500
+#define	ODM_REG_EDCA_VI_11N				0x504
+#define	ODM_REG_EDCA_BE_11N				0x508
+#define	ODM_REG_EDCA_BK_11N				0x50C
+#define	ODM_REG_TXPAUSE_11N				0x522
+#define	ODM_REG_RESP_TX_11N				0x6D8
+#define	ODM_REG_ANT_TRAIN_PARA1_11N	0x7b0
+#define	ODM_REG_ANT_TRAIN_PARA2_11N	0x7b4
+
+
+//DIG Related
+#define	ODM_BIT_IGI_11N					0x0000007F
+#define	ODM_BIT_CCK_RPT_FORMAT_11N		BIT9
+#define	ODM_BIT_BB_RX_PATH_11N			0xF
+#define	ODM_BIT_BB_TX_PATH_11N			0xF
+#define	ODM_BIT_BB_ATC_11N				BIT11
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.c
new file mode 100644
index 000000000..9451d5523
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.c
@@ -0,0 +1,1692 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#define	AFH_PSD		1	//0:normal PSD scan, 1: only do 20 pts PSD
+#define	MODE_40M		0	//0:20M, 1:40M
+#define	PSD_TH2		3  
+#define	PSD_CHMIN		20   // Minimum channel number for BT AFH
+#define	SIR_STEP_SIZE	3
+#define   Smooth_Size_1 	5
+#define	Smooth_TH_1	3
+#define   Smooth_Size_2 	10
+#define	Smooth_TH_2	4
+#define   Smooth_Size_3 	20
+#define	Smooth_TH_3	4
+#define   Smooth_Step_Size 5
+#define	Adaptive_SIR	1
+#define	SCAN_INTERVAL	1500 //ms
+#define	SYN_Length		5    // for 92D
+	
+#define	LNA_Low_Gain_1                      0x64
+#define	LNA_Low_Gain_2                      0x5A
+#define	LNA_Low_Gain_3                      0x58
+
+#define	pw_th_10dB					0x0
+#define	pw_th_16dB					0x3
+
+#define	FA_RXHP_TH1                           5000
+#define	FA_RXHP_TH2                           1500
+#define	FA_RXHP_TH3                             800
+#define	FA_RXHP_TH4                             600
+#define	FA_RXHP_TH5                             500
+
+#define	Idle_Mode					0
+#define	High_TP_Mode				1
+#define	Low_TP_Mode				2
+
+
+VOID
+odm_PSDMonitorInit(
+	IN		PVOID			pDM_VOID
+	)
+{
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//PSD Monitor Setting
+	//Which path in ADC/DAC is turnned on for PSD: both I/Q
+	ODM_SetBBReg(pDM_Odm, ODM_PSDREG, BIT10|BIT11, 0x3);
+	//Ageraged number: 8
+	ODM_SetBBReg(pDM_Odm, ODM_PSDREG, BIT12|BIT13, 0x1);
+	pDM_Odm->bPSDinProcess = FALSE;
+	pDM_Odm->bUserAssignLevel = FALSE;
+	pDM_Odm->bPSDactive = FALSE;
+	//pDM_Odm->bDMInitialGainEnable=TRUE;		//change the initialization to DIGinit
+	//Set Debug Port
+	//PHY_SetBBReg(Adapter, 0x908, bMaskDWord, 0x803);
+	//PHY_SetBBReg(Adapter, 0xB34, bMaskByte0, 0x00); // pause PSD
+	//PHY_SetBBReg(Adapter, 0xB38, bMaskByte0, 10); //rescan
+	//PHY_SetBBReg(Adapter, 0xB38, bMaskByte2|bMaskByte3, 100); //interval
+
+	//PlatformSetTimer( Adapter, &pHalData->PSDTriggerTimer, 0); //ms
+#endif
+}
+
+VOID
+PatchDCTone(
+	IN		PVOID			pDM_VOID,
+	pu4Byte		PSD_report,
+	u1Byte 		initial_gain_psd
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//PADAPTER	pAdapter;
+	
+	u4Byte	psd_report;
+
+	//2 Switch to CH11 to patch CH9 and CH13 DC tone
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, 11);
+	
+	if(pDM_Odm->SupportICType== ODM_RTL8192D)
+	{
+		if((*(pDM_Odm->pMacPhyMode) == ODM_SMSP)||(*(pDM_Odm->pMacPhyMode) == ODM_DMSP))
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, 11);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, 0xfffff, 0x643BC);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, 0xfffff, 0x77C1A);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, 0xfffff, 0x41289);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, 0xfffff, 0x01840);
+		}
+		else
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, 0xfffff, 0x643BC);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, 0xfffff, 0x77C1A);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, 0xfffff, 0x41289);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, 0xfffff, 0x01840);
+		}
+	}
+	
+	//Ch9 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 96, initial_gain_psd);
+	PSD_report[50] = psd_report;
+	//Ch13 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 32, initial_gain_psd);
+	PSD_report[70] = psd_report;
+	
+	//2 Switch to CH3 to patch CH1 and CH5 DC tone
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, 3);
+
+	
+	if(pDM_Odm->SupportICType==ODM_RTL8192D)
+	{
+		if((*(pDM_Odm->pMacPhyMode) == ODM_SMSP)||(*(pDM_Odm->pMacPhyMode) == ODM_DMSP))
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, 3);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x25, 0xfffff, 0x643BC);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, 0xfffff, 0x07C1A);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x2B, 0xfffff, 0x61289);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x2C, 0xfffff, 0x01C41);
+		}
+		else
+		{
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x25, 0xfffff, 0x643BC);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, 0xfffff, 0x07C1A);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x2B, 0xfffff, 0x61289);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x2C, 0xfffff, 0x01C41);
+		}
+	}
+	
+	//Ch1 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 96, initial_gain_psd);
+	PSD_report[10] = psd_report;
+	//Ch5 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 32, initial_gain_psd);
+	PSD_report[30] = psd_report;
+
+}
+
+
+VOID
+GoodChannelDecision(
+	IN		PVOID			pDM_VOID,
+	pu4Byte		PSD_report,
+	pu1Byte		PSD_bitmap,
+	u1Byte 		RSSI_BT,
+	pu1Byte		PSD_bitmap_memory)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T			pRX_HP_Table = &pDM_Odm->DM_RXHP_Table;
+	//s4Byte	TH1 =  SSBT-0x15;    // modify TH by Neil Chen
+	s4Byte	TH1= RSSI_BT+0x14;
+	s4Byte	TH2 = RSSI_BT+85;
+	//u2Byte    TH3;
+//	s4Byte	RegB34;
+	u1Byte	bitmap, Smooth_size[3], Smooth_TH[3];
+	//u1Byte	psd_bit;
+	u4Byte	i,n,j, byte_idx, bit_idx, good_cnt, good_cnt_smoothing, Smooth_Interval[3];
+	int 		start_byte_idx,start_bit_idx,cur_byte_idx, cur_bit_idx,NOW_byte_idx ;
+	
+//	RegB34 = PHY_QueryBBReg(Adapter,0xB34, bMaskDWord)&0xFF;
+
+	if((pDM_Odm->SupportICType == ODM_RTL8192C)||(pDM_Odm->SupportICType == ODM_RTL8192D))
+       {
+            TH1 = RSSI_BT + 0x14;  
+	}
+
+	Smooth_size[0]=Smooth_Size_1;
+	Smooth_size[1]=Smooth_Size_2;
+	Smooth_size[2]=Smooth_Size_3;
+	Smooth_TH[0]=Smooth_TH_1;
+	Smooth_TH[1]=Smooth_TH_2;
+	Smooth_TH[2]=Smooth_TH_3;
+	Smooth_Interval[0]=16;
+	Smooth_Interval[1]=15;
+	Smooth_Interval[2]=13;
+	good_cnt = 0;
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+		//2 Threshold  
+
+		if(RSSI_BT >=41)
+			TH1 = 113;	
+		else if(RSSI_BT >=38)   // >= -15dBm
+			TH1 = 105;                              //0x69
+		else if((RSSI_BT >=33)&(RSSI_BT <38))
+			TH1 = 99+(RSSI_BT-33);         //0x63
+		else if((RSSI_BT >=26)&(RSSI_BT<33))
+			TH1 = 99-(33-RSSI_BT)+2;     //0x5e
+	 	else if((RSSI_BT >=24)&(RSSI_BT<26))
+			TH1 = 88-((RSSI_BT-24)*3);   //0x58
+		else if((RSSI_BT >=18)&(RSSI_BT<24))
+			TH1 = 77+((RSSI_BT-18)*2);
+		else if((RSSI_BT >=14)&(RSSI_BT<18))
+			TH1 = 63+((RSSI_BT-14)*2);
+		else if((RSSI_BT >=8)&(RSSI_BT<14))
+			TH1 = 58+((RSSI_BT-8)*2);
+		else if((RSSI_BT >=3)&(RSSI_BT<8))
+			TH1 = 52+(RSSI_BT-3);
+		else
+			TH1 = 51;
+	}
+
+	for (i = 0; i< 10; i++)
+		PSD_bitmap[i] = 0;
+	
+
+	 // Add By Gary
+       for (i=0; i<80; i++)
+	   	pRX_HP_Table->PSD_bitmap_RXHP[i] = 0;
+	// End
+
+
+
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+		TH1 =TH1-SIR_STEP_SIZE;
+	}
+	while (good_cnt < PSD_CHMIN)
+	{
+		good_cnt = 0;
+		if(pDM_Odm->SupportICType==ODM_RTL8723A)
+		{
+		if(TH1 ==TH2)
+			break;
+		if((TH1+SIR_STEP_SIZE) < TH2)
+			TH1 += SIR_STEP_SIZE;
+		else
+			TH1 = TH2;
+		}
+		else
+		{
+			if(TH1==(RSSI_BT+0x1E))
+             		     break;    
+   			if((TH1+2) < (RSSI_BT+0x1E))
+				TH1+=3;
+		     	else
+				TH1 = RSSI_BT+0x1E;	
+             
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: decision threshold is: %d", TH1));
+			 
+		for (i = 0; i< 80; i++)
+		{
+			if((s4Byte)(PSD_report[i]) < TH1)
+			{
+				byte_idx = i / 8;
+				bit_idx = i -8*byte_idx;
+				bitmap = PSD_bitmap[byte_idx];
+				PSD_bitmap[byte_idx] = bitmap | (u1Byte) (1 << bit_idx);
+			}
+		}
+
+#if DBG
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: before smoothing\n"));
+		for(n=0;n<10;n++)
+		{
+			//DbgPrint("PSD_bitmap[%u]=%x\n", n, PSD_bitmap[n]);
+			for (i = 0; i<8; i++)
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD_bitmap[%u] =   %d\n", 2402+n*8+i, (PSD_bitmap[n]&BIT(i))>>i));
+		}
+#endif
+	
+		//1 Start of smoothing function
+
+		for (j=0;j<3;j++)
+		{
+			start_byte_idx=0;
+			start_bit_idx=0;
+			for(n=0; n<Smooth_Interval[j]; n++)
+			{
+				good_cnt_smoothing = 0;
+				cur_bit_idx = start_bit_idx;
+				cur_byte_idx = start_byte_idx;
+				for ( i=0; i < Smooth_size[j]; i++)
+				{
+					NOW_byte_idx = cur_byte_idx + (i+cur_bit_idx)/8;
+					if ( (PSD_bitmap[NOW_byte_idx]& BIT( (cur_bit_idx + i)%8)) != 0)
+						good_cnt_smoothing++;
+
+				}
+
+				if( good_cnt_smoothing < Smooth_TH[j] )
+				{
+					cur_bit_idx = start_bit_idx;
+					cur_byte_idx = start_byte_idx;
+					for ( i=0; i< Smooth_size[j] ; i++)
+					{	
+						NOW_byte_idx = cur_byte_idx + (i+cur_bit_idx)/8;				
+						PSD_bitmap[NOW_byte_idx] = PSD_bitmap[NOW_byte_idx] & (~BIT( (cur_bit_idx + i)%8));
+					}
+				}
+				start_bit_idx =  start_bit_idx + Smooth_Step_Size;
+				while ( (start_bit_idx)  > 7 )
+				{
+					start_byte_idx= start_byte_idx+start_bit_idx/8;
+					start_bit_idx = start_bit_idx%8;
+				}
+			}
+
+			ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: after %u smoothing", j+1));
+			for(n=0;n<10;n++)
+			{
+				for (i = 0; i<8; i++)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD_bitmap[%u] =   %d\n", 2402+n*8+i, (PSD_bitmap[n]&BIT(i))>>i));
+					
+					if ( ((PSD_bitmap[n]&BIT(i))>>i) ==1)  //----- Add By Gary
+					{
+	                                   pRX_HP_Table->PSD_bitmap_RXHP[8*n+i] = 1;
+					}                                                  // ------end by Gary
+				}
+			}
+
+		}
+
+	
+		good_cnt = 0;
+		for ( i = 0; i < 10; i++)
+		{
+			for (n = 0; n < 8; n++)
+				if((PSD_bitmap[i]& BIT(n)) != 0)
+					good_cnt++;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, ODM_COMP_PSD,("PSD: good channel cnt = %u",good_cnt));
+	}
+
+	//RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT=%d, TH2=%d, TH1=%d",SSBT,TH2,TH1));
+	for (i = 0; i <10; i++)
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: PSD_bitmap[%u]=%x",i,PSD_bitmap[i]));
+/*	
+	//Update bitmap memory
+	for(i = 0; i < 80; i++)
+	{
+		byte_idx = i / 8;
+		bit_idx = i -8*byte_idx;
+		psd_bit = (PSD_bitmap[byte_idx] & BIT(bit_idx)) >> bit_idx;
+		bitmap = PSD_bitmap_memory[i]; 
+		PSD_bitmap_memory[i] = (bitmap << 1) |psd_bit;
+	}
+*/
+}
+
+
+
+VOID
+odm_PSD_Monitor(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	//PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	unsigned int 		pts, start_point, stop_point;
+	u1Byte			initial_gain ;
+	static u1Byte		PSD_bitmap_memory[80], init_memory = 0;
+	static u1Byte 		psd_cnt=0;
+	static u4Byte		PSD_report[80], PSD_report_tmp;
+	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	u1Byte 			H2C_PSD_DATA[5]={0,0,0,0,0};
+	static u1Byte		H2C_PSD_DATA_last[5] ={0,0,0,0,0};
+	u1Byte			idx[20]={96,99,102,106,109,112,115,118,122,125,
+					0,3,6,10,13,16,19,22,26,29};
+	u1Byte			n, i, channel, BBReset,tone_idx;
+	u1Byte			PSD_bitmap[10], SSBT=0,initial_gain_psd=0, RSSI_BT=0, initialGainUpper;
+	s4Byte    			PSD_skip_start, PSD_skip_stop;
+	u4Byte			CurrentChannel, RXIQI, RxIdleLowPwr, wlan_channel;
+	u4Byte			ReScan, Interval, Is40MHz;
+	u8Byte			curTxOkCnt, curRxOkCnt;
+	int 				cur_byte_idx, cur_bit_idx;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO      	pMgntInfo = &Adapter->MgntInfo;
+	
+
+	if(*pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep)
+ 	{
+  		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("pbDriverIsGoingToPnpSetPowerSleep!!!!!!!!!!!!!!!\n"));
+  		return;
+ 	}
+
+	
+	if( (*(pDM_Odm->pbScanInProcess)) ||
+		pDM_Odm->bLinkInProcess)
+	{
+		if((pDM_Odm->SupportICType==ODM_RTL8723A)&(pDM_Odm->SupportInterface==ODM_ITRF_PCIE))
+		{
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->PSDTimer, 1500); //ms	
+			//psd_cnt=0;
+		}
+		return;
+	}
+
+	if(pDM_Odm->bBtHsOperation)
+	{
+		ReScan = 1;
+		Interval = SCAN_INTERVAL;
+	}
+	else
+	{
+	ReScan = PSD_RESCAN;
+	Interval = SCAN_INTERVAL;
+	}
+
+	//1 Initialization
+	if(init_memory == 0)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Init memory\n"));
+		for(i = 0; i < 80; i++)
+			PSD_bitmap_memory[i] = 0xFF; // channel is always good
+		init_memory = 1;
+	}
+	if(psd_cnt == 0)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Enter dm_PSD_Monitor\n"));
+		for(i = 0; i < 80; i++)
+			PSD_report[i] = 0;
+	}
+
+	//1 Backup Current Settings
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
+/*
+	if(pDM_Odm->SupportICType==ODM_RTL8192D)
+	{
+		//2 Record Current synthesizer parameters based on current channel
+		if((*pDM_Odm->MacPhyMode92D == SINGLEMAC_SINGLEPHY)||(*pDM_Odm->MacPhyMode92D == DUALMAC_SINGLEPHY))
+		{
+			SYN_RF25 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x2C, bMaskDWord);
+       	}
+		else     // DualMAC_DualPHY 2G
+		{
+			SYN_RF25 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x2C, bMaskDWord);
+		}
+	}
+*/
+	//RXIQI = PHY_QueryBBReg(Adapter, 0xC14, bMaskDWord);
+	RXIQI = ODM_GetBBReg(pDM_Odm, 0xC14, bMaskDWord);
+
+	//RxIdleLowPwr = (PHY_QueryBBReg(Adapter, 0x818, bMaskDWord)&BIT28)>>28;
+	RxIdleLowPwr = (ODM_GetBBReg(pDM_Odm, 0x818, bMaskDWord)&BIT28)>>28;
+
+	//2???
+	if(CHNL_RUN_ABOVE_40MHZ(pMgntInfo))
+		Is40MHz = TRUE;
+	else
+		Is40MHz = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm,	ODM_COMP_PSD, DBG_LOUD,("PSD Scan Start\n"));
+	//1 Turn off CCK
+	//PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT24, 0);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0);
+	//1 Turn off TX
+	//Pause TX Queue
+	//PlatformEFIOWrite1Byte(Adapter, REG_TXPAUSE, 0xFF);
+	ODM_Write1Byte(pDM_Odm,REG_TXPAUSE, 0xFF);
+	
+	//Force RX to stop TX immediately
+	//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
+	//1 Turn off RX
+	//Rx AGC off  RegC70[0]=0, RegC7C[20]=0
+	//PHY_SetBBReg(Adapter, 0xC70, BIT0, 0);
+	//PHY_SetBBReg(Adapter, 0xC7C, BIT20, 0);
+
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 0);
+
+	
+	//Turn off CCA
+	//PHY_SetBBReg(Adapter, 0xC14, bMaskDWord, 0x0);
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0);
+	
+	//BB Reset
+	//BBReset = PlatformEFIORead1Byte(Adapter, 0x02);
+	BBReset = ODM_Read1Byte(pDM_Odm, 0x02);
+	
+	//PlatformEFIOWrite1Byte(Adapter, 0x02, BBReset&(~BIT0));
+	//PlatformEFIOWrite1Byte(Adapter, 0x02, BBReset|BIT0);
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 1); //clock gated to prevent from AGC table mess 
+	ODM_Write1Byte(pDM_Odm,  0x02, BBReset&(~BIT0));
+	ODM_Write1Byte(pDM_Odm,  0x02, BBReset|BIT0);
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 0);
+	
+	//1 Leave RX idle low power
+	//PHY_SetBBReg(Adapter, 0x818, BIT28, 0x0);
+
+	ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);
+	//1 Fix initial gain
+	//if (IS_HARDWARE_TYPE_8723AE(Adapter))
+	//RSSI_BT = pHalData->RSSI_BT;
+       //else if((IS_HARDWARE_TYPE_8192C(Adapter))||(IS_HARDWARE_TYPE_8192D(Adapter)))      // Add by Gary
+       //    RSSI_BT = RSSI_BT_new;
+
+	if((pDM_Odm->SupportICType==ODM_RTL8723A)&(pDM_Odm->SupportInterface==ODM_ITRF_PCIE))
+	RSSI_BT=pDM_Odm->RSSI_BT;		//need to check C2H to pDM_Odm RSSI BT
+
+	if(RSSI_BT>=47)
+		RSSI_BT=47;
+	   
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+	
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+	       //Neil add--2011--10--12
+		//2 Initial Gain index 
+		if(RSSI_BT >=35)   // >= -15dBm
+			initial_gain_psd = RSSI_BT*2;
+		else if((RSSI_BT >=33)&(RSSI_BT<35))
+			initial_gain_psd = RSSI_BT*2+6;
+		else if((RSSI_BT >=24)&(RSSI_BT<33))
+			initial_gain_psd = 70-(33-RSSI_BT);
+	 	else if((RSSI_BT >=19)&(RSSI_BT<24))
+			initial_gain_psd = 64-((24-RSSI_BT)*4);
+		else if((RSSI_BT >=14)&(RSSI_BT<19))
+			initial_gain_psd = 44-((18-RSSI_BT)*2);
+		else if((RSSI_BT >=8)&(RSSI_BT<14))
+			initial_gain_psd = 35-(14-RSSI_BT);
+		else
+			initial_gain_psd = 0x1B;
+	}
+	else
+	{
+	
+		//need to do	
+         	initial_gain_psd = pDM_Odm->RSSI_Min;    // PSD report based on RSSI
+           	//}  	
+	}
+	//if(RSSI_BT<0x17)
+	//	RSSI_BT +=3;
+	//DbgPrint("PSD: RSSI_BT= %d\n", RSSI_BT);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+
+	//initialGainUpper = 0x5E;  //Modify by neil chen
+	
+	if(pDM_Odm->bUserAssignLevel)
+	{
+		pDM_Odm->bUserAssignLevel = FALSE;
+		initialGainUpper = 0x7f;
+	}
+	else
+	{
+		initialGainUpper = 0x5E;
+	}
+	
+	/*
+	if (initial_gain_psd < 0x1a)
+		initial_gain_psd = 0x1a;
+	if (initial_gain_psd > initialGainUpper)
+		initial_gain_psd = initialGainUpper;
+	*/
+
+	//if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	SSBT = RSSI_BT  * 2 +0x3E;
+	
+	
+	//if(IS_HARDWARE_TYPE_8723AE(Adapter))
+	//	SSBT = RSSI_BT  * 2 +0x3E;
+	//else if((IS_HARDWARE_TYPE_8192C(Adapter))||(IS_HARDWARE_TYPE_8192D(Adapter)))   // Add by Gary
+	//{
+	//	RSSI_BT = initial_gain_psd;
+	//	SSBT = RSSI_BT;
+	//}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT= %d\n", SSBT));
+	ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: initial gain= 0x%x\n", initial_gain_psd));
+	//DbgPrint("PSD: SSBT= %d", SSBT);
+	//need to do
+	pDM_Odm->bDMInitialGainEnable = FALSE;
+	initial_gain =(u1Byte) (ODM_GetBBReg(pDM_Odm, 0xc50, bMaskDWord) & 0x7F);
+	
+        // make sure the initial gain is under the correct range.
+	//initial_gain_psd &= 0x7f;
+	ODM_Write_DIG(pDM_Odm, initial_gain_psd);
+	//1 Turn off 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0xF);
+
+	//pts value = 128, 256, 512, 1024
+	pts = 128;
+
+	if(pts == 128)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+		start_point = 64;
+		stop_point = 192;
+	}
+	else if(pts == 256)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x1);
+		start_point = 128;
+		stop_point = 384;
+	}
+	else if(pts == 512)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x2);
+		start_point = 256;
+		stop_point = 768;
+	}
+	else
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x3);
+		start_point = 512;
+		stop_point = 1536;
+	}
+	
+
+//3 Skip WLAN channels if WLAN busy
+
+	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - lastTxOkCnt;
+	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - lastRxOkCnt;
+	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
+	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);	
+
+	PSD_skip_start=80;
+	PSD_skip_stop = 0;
+	wlan_channel = CurrentChannel & 0x0f;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: current channel: %x, BW:%d \n", wlan_channel, Is40MHz));
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+		if(pDM_Odm->bBtHsOperation)
+		{
+			if(pDM_Odm->bLinked)
+			{
+				if(Is40MHz)
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
+				}
+				else
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-10;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+18; 
+				}
+			}
+			else
+			{
+				// mask for 40MHz
+				PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
+				PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
+			}
+			if(PSD_skip_start < 0)
+				PSD_skip_start = 0;
+			if(PSD_skip_stop >80)
+				PSD_skip_stop = 80;
+		}
+		else
+		{
+			if((curRxOkCnt+curTxOkCnt) > 5)
+			{
+				if(Is40MHz)
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
+				}
+				else
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-10;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+18; 
+				}
+				
+				if(PSD_skip_start < 0)
+					PSD_skip_start = 0;
+				if(PSD_skip_stop >80)
+					PSD_skip_stop = 80;
+			}
+		}
+	}
+#if 0	
+	else
+	{
+		if((curRxOkCnt+curTxOkCnt) > 1000)
+		{
+			PSD_skip_start = (wlan_channel-1)*5 -Is40MHz*10;
+			PSD_skip_stop = PSD_skip_start + (1+Is40MHz)*20;
+		}
+	}   
+#endif  //Reove RXHP Issue
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: Skip tone from %d to %d \n", PSD_skip_start, PSD_skip_stop));
+
+ 	for (n=0;n<80;n++)
+ 	{
+ 		if((n%20)==0)
+ 		{
+			channel = (n/20)*4 + 1;
+					
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+				}
+		tone_idx = n%20;
+		if ((n>=PSD_skip_start) && (n<PSD_skip_stop))
+		{	
+			PSD_report[n] = SSBT;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD:Tone %d skipped \n", n));
+		}
+		else
+		{
+			PSD_report_tmp =  GetPSDData(pDM_Odm, idx[tone_idx], initial_gain_psd);
+
+			if ( PSD_report_tmp > PSD_report[n])
+				PSD_report[n] = PSD_report_tmp;
+				
+		}
+	}
+
+	PatchDCTone(pDM_Odm, PSD_report, initial_gain_psd);
+      
+       //----end
+	//1 Turn on RX
+	//Rx AGC on
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 1);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 1);
+	//CCK on
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1);
+	//1 Turn on TX
+	//Resume TX Queue
+	
+	ODM_Write1Byte(pDM_Odm,REG_TXPAUSE, 0x00);
+	//Turn on 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0x0);
+	//1 Restore Current Settings
+	//Resume DIG
+	pDM_Odm->bDMInitialGainEnable = TRUE;
+	
+	ODM_Write_DIG(pDM_Odm, initial_gain);
+
+	// restore originl center frequency
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);
+
+	//Turn on CCA
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, RXIQI);
+	//Restore RX idle low power
+	if(RxIdleLowPwr == TRUE)
+		ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 1);
+	
+	psd_cnt++;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD:psd_cnt = %d \n",psd_cnt));
+	if (psd_cnt < ReScan)
+		ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, Interval);		
+	else
+	{
+		psd_cnt = 0;
+		for(i=0;i<80;i++)
+			//DbgPrint("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]);
+			RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]));
+
+
+		GoodChannelDecision(pDM_Odm, PSD_report, PSD_bitmap,RSSI_BT, PSD_bitmap_memory);
+
+		if(pDM_Odm->SupportICType==ODM_RTL8723A)
+		{
+			cur_byte_idx=0;
+			cur_bit_idx=0;
+
+			//2 Restore H2C PSD Data to Last Data
+		  	H2C_PSD_DATA_last[0] = H2C_PSD_DATA[0];
+			H2C_PSD_DATA_last[1] = H2C_PSD_DATA[1];
+			H2C_PSD_DATA_last[2] = H2C_PSD_DATA[2];
+			H2C_PSD_DATA_last[3] = H2C_PSD_DATA[3];
+			H2C_PSD_DATA_last[4] = H2C_PSD_DATA[4];
+
+	
+			//2 Translate 80bit channel map to 40bit channel	
+			for ( i=0;i<5;i++)
+			{
+				for(n=0;n<8;n++)
+				{
+					cur_byte_idx = i*2 + n/4;
+					cur_bit_idx = (n%4)*2;
+					if ( ((PSD_bitmap[cur_byte_idx]& BIT(cur_bit_idx)) != 0) && ((PSD_bitmap[cur_byte_idx]& BIT(cur_bit_idx+1)) != 0))
+						H2C_PSD_DATA[i] = H2C_PSD_DATA[i] | (u1Byte) (1 << n);
+				}
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("H2C_PSD_DATA[%d]=0x%x\n" ,i, H2C_PSD_DATA[i]));
+			}
+	
+			//3 To Compare the difference
+			for ( i=0;i<5;i++)
+			{
+				if(H2C_PSD_DATA[i] !=H2C_PSD_DATA_last[i])
+				{
+					FillH2CCmd92C(Adapter, H2C_92C_PSD_RESULT, 5, H2C_PSD_DATA);
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_PSD, DBG_LOUD,("Need to Update the AFH Map \n"));
+					break;
+				}
+				else
+				{
+					if(i==5)
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Not need to Update\n"));	
+				}
+			}
+			if(pDM_Odm->bBtHsOperation)
+			{
+				ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, 10000);
+				ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Leave dm_PSD_Monitor\n"));		
+			}
+			else
+			{
+				ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, 1500);
+				ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Leave dm_PSD_Monitor\n"));		
+		}
+	}
+    }
+}
+/*
+//Neil for Get BT RSSI
+// Be Triggered by BT C2H CMD
+VOID
+ODM_PSDGetRSSI(
+	IN	u1Byte	RSSI_BT)
+{
+
+
+}
+
+*/
+
+VOID
+ODM_PSDMonitor(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	//if(IS_HARDWARE_TYPE_8723AE(Adapter))
+	
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)   //may need to add other IC type
+	{
+		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE)
+		{
+			if(!pDM_Odm->bBtEnabled) //need to check upper layer connection
+			{
+				pDM_Odm->bPSDactive=FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, ("odm_PSDMonitor, return for BT is disabled!!!\n"));
+		   		return; 
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, ("odm_PSDMonitor\n"));
+		//{
+			pDM_Odm->bPSDinProcess = TRUE;
+	 		pDM_Odm->bPSDactive=TRUE;
+			odm_PSD_Monitor(pDM_Odm);
+			pDM_Odm->bPSDinProcess = FALSE;
+		}	
+	}	
+
+}
+VOID
+odm_PSDMonitorCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	PlatformScheduleWorkItem(&pHalData->PSDMonitorWorkitem);
+}
+
+VOID
+odm_PSDMonitorWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	ODM_PSDMonitor(pDM_Odm);
+}
+
+
+ //cosa debug tool need to modify
+
+VOID
+ODM_PSDDbgControl(
+	IN	PADAPTER	Adapter,
+	IN	u4Byte		mode,
+	IN	u4Byte		btRssi
+	)
+{
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, (" Monitor mode=%d, btRssi=%d\n", mode, btRssi));
+	if(mode)
+	{
+		pDM_Odm->RSSI_BT = (u1Byte)btRssi;
+		pDM_Odm->bUserAssignLevel = TRUE;
+		ODM_SetTimer( pDM_Odm, &pDM_Odm->PSDTimer, 0); //ms		
+	}
+	else
+	{
+		ODM_CancelTimer(pDM_Odm, &pDM_Odm->PSDTimer);
+	}
+#endif
+}
+
+
+//#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
+
+void	odm_RXHPInit(
+	IN		PVOID			pDM_VOID)
+{
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+   	u1Byte			index;
+
+	pRX_HP_Table->RXHP_enable = TRUE;
+	pRX_HP_Table->RXHP_flag = 0;
+	pRX_HP_Table->PSD_func_trigger = 0;
+	pRX_HP_Table->Pre_IGI = 0x20;
+	pRX_HP_Table->Cur_IGI = 0x20;
+	pRX_HP_Table->Cur_pw_th = pw_th_10dB;
+	pRX_HP_Table->Pre_pw_th = pw_th_10dB;
+	for(index=0; index<80; index++)
+		pRX_HP_Table->PSD_bitmap_RXHP[index] = 1;
+
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)
+	pRX_HP_Table->TP_Mode = Idle_Mode;
+#endif
+#endif
+}
+
+VOID
+odm_PSD_RXHP(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+	PADAPTER		Adapter =  pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	unsigned int 		pts, start_point, stop_point, initial_gain ;
+	static u1Byte		PSD_bitmap_memory[80], init_memory = 0;
+	static u1Byte 		psd_cnt=0;
+	static u4Byte		PSD_report[80], PSD_report_tmp;
+	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	u1Byte			idx[20]={96,99,102,106,109,112,115,118,122,125,
+					0,3,6,10,13,16,19,22,26,29};
+	u1Byte			n, i, channel, BBReset,tone_idx;
+	u1Byte			PSD_bitmap[10]/*, SSBT=0*/,initial_gain_psd=0, RSSI_BT=0, initialGainUpper;
+	s4Byte    			PSD_skip_start, PSD_skip_stop;
+	u4Byte			CurrentChannel, RXIQI, RxIdleLowPwr, wlan_channel;
+	u4Byte			ReScan, Interval, Is40MHz;
+	u8Byte			curTxOkCnt, curRxOkCnt;
+	//--------------2G band synthesizer for 92D switch RF channel using----------------- 
+	u1Byte			group_idx=0;
+	u4Byte			SYN_RF25=0, SYN_RF26=0, SYN_RF27=0, SYN_RF2B=0, SYN_RF2C=0;
+	u4Byte			SYN[5] = {0x25, 0x26, 0x27, 0x2B, 0x2C};    // synthesizer RF register for 2G channel
+	u4Byte			SYN_group[3][5] = {{0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840},     // For CH1,2,4,9,10.11.12   {0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840}
+									    {0x643BC, 0xFC038, 0x07C1A, 0x41289, 0x01840},     // For CH3,13,14
+									    {0x243BC, 0xFC438, 0x07C1A, 0x4128B, 0x0FC41}};   // For Ch5,6,7,8
+       //--------------------- Add by Gary for Debug setting ----------------------
+  	u1Byte                 RSSI_BT_new = (u1Byte) ODM_GetBBReg(pDM_Odm, 0xB9C, 0xFF);
+       u1Byte                 rssi_ctrl = (u1Byte) ODM_GetBBReg(pDM_Odm, 0xB38, 0xFF);
+       //---------------------------------------------------------------------
+	
+	if(pMgntInfo->bScanInProgress)
+	{
+		return;
+	}
+
+	ReScan = PSD_RESCAN;
+	Interval = SCAN_INTERVAL;
+
+
+	//1 Initialization
+	if(init_memory == 0)
+	{
+		RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("Init memory\n"));
+		for(i = 0; i < 80; i++)
+			PSD_bitmap_memory[i] = 0xFF; // channel is always good
+		init_memory = 1;
+	}
+	if(psd_cnt == 0)
+	{
+		RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("Enter dm_PSD_Monitor\n"));
+		for(i = 0; i < 80; i++)
+			PSD_report[i] = 0;
+	}
+
+	//1 Backup Current Settings
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		//2 Record Current synthesizer parameters based on current channel
+		if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))
+		{
+			SYN_RF25 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, bMaskDWord);
+       	}
+		else     // DualMAC_DualPHY 2G
+		{
+			SYN_RF25 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, bMaskDWord);
+		}
+	}
+	RXIQI = ODM_GetBBReg(pDM_Odm, 0xC14, bMaskDWord);
+	RxIdleLowPwr = (ODM_GetBBReg(pDM_Odm, 0x818, bMaskDWord)&BIT28)>>28;
+	Is40MHz = *(pDM_Odm->pBandWidth);
+	ODM_RT_TRACE(pDM_Odm,	ODM_COMP_PSD, DBG_LOUD,("PSD Scan Start\n"));
+	//1 Turn off CCK
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0);
+	//1 Turn off TX
+	//Pause TX Queue
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF);
+	//Force RX to stop TX immediately
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
+	//1 Turn off RX
+	//Rx AGC off  RegC70[0]=0, RegC7C[20]=0
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 0);
+	//Turn off CCA
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0);
+	//BB Reset
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 1); //clock gated to prevent from AGC table mess 
+	BBReset = ODM_Read1Byte(pDM_Odm, 0x02);
+	ODM_Write1Byte(pDM_Odm, 0x02, BBReset&(~BIT0));
+	ODM_Write1Byte(pDM_Odm, 0x02, BBReset|BIT0);
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 0);
+	//1 Leave RX idle low power
+	ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);
+	//1 Fix initial gain
+      	RSSI_BT = RSSI_BT_new;
+	RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+	
+	if(rssi_ctrl == 1)        // just for debug!!
+		initial_gain_psd = RSSI_BT_new; 
+     	else
+		initial_gain_psd = pDM_Odm->RSSI_Min;    // PSD report based on RSSI
+	
+	RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+	
+	initialGainUpper = 0x54;
+	
+	RSSI_BT = initial_gain_psd;
+	//SSBT = RSSI_BT;
+	
+	//RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT= %d\n", SSBT));
+	RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("PSD: initial gain= 0x%x\n", initial_gain_psd));
+	
+	pDM_Odm->bDMInitialGainEnable = FALSE;		
+	initial_gain = ODM_GetBBReg(pDM_Odm, 0xc50, bMaskDWord) & 0x7F;
+	//ODM_SetBBReg(pDM_Odm, 0xc50, 0x7F, initial_gain_psd);	
+	ODM_Write_DIG(pDM_Odm, initial_gain_psd);
+	//1 Turn off 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0xF);
+
+	//pts value = 128, 256, 512, 1024
+	pts = 128;
+
+	if(pts == 128)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+		start_point = 64;
+		stop_point = 192;
+	}
+	else if(pts == 256)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x1);
+		start_point = 128;
+		stop_point = 384;
+	}
+	else if(pts == 512)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x2);
+		start_point = 256;
+		stop_point = 768;
+	}
+	else
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x3);
+		start_point = 512;
+		stop_point = 1536;
+	}
+	
+
+//3 Skip WLAN channels if WLAN busy
+	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - lastTxOkCnt;
+	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - lastRxOkCnt;
+	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
+	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
+	
+	PSD_skip_start=80;
+	PSD_skip_stop = 0;
+	wlan_channel = CurrentChannel & 0x0f;
+
+	RT_TRACE(ODM_COMP_PSD,DBG_LOUD,("PSD: current channel: %x, BW:%d \n", wlan_channel, Is40MHz));
+	
+	if((curRxOkCnt+curTxOkCnt) > 1000)
+	{
+		PSD_skip_start = (wlan_channel-1)*5 -Is40MHz*10;
+		PSD_skip_stop = PSD_skip_start + (1+Is40MHz)*20;
+	}
+
+	RT_TRACE(ODM_COMP_PSD,DBG_LOUD,("PSD: Skip tone from %d to %d \n", PSD_skip_start, PSD_skip_stop));
+
+ 	for (n=0;n<80;n++)
+ 	{
+ 		if((n%20)==0)
+ 		{
+			channel = (n/20)*4 + 1;
+			if(pDM_Odm->SupportICType == ODM_RTL8192D)
+			{
+				switch(channel)
+				{
+					case 1: 
+					case 9:
+						group_idx = 0;
+						break;
+					case 5:
+						group_idx = 2;
+						break;
+					case 13:
+				 		group_idx = 1;
+						break;
+				}
+				if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))   
+		{
+					for(i = 0; i < SYN_Length; i++)
+						ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, SYN[i], bMaskDWord, SYN_group[group_idx][i]);
+
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, channel);
+				}
+				else  // DualMAC_DualPHY 2G
+			{
+					for(i = 0; i < SYN_Length; i++)
+						ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, SYN[i], bMaskDWord, SYN_group[group_idx][i]);   
+					
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+				}
+			}
+			else
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+			}	
+		tone_idx = n%20;
+		if ((n>=PSD_skip_start) && (n<PSD_skip_stop))
+		{	
+			PSD_report[n] = initial_gain_psd;//SSBT;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD:Tone %d skipped \n", n));
+		}
+		else
+		{
+			PSD_report_tmp =  GetPSDData(pDM_Odm, idx[tone_idx], initial_gain_psd);
+
+			if ( PSD_report_tmp > PSD_report[n])
+				PSD_report[n] = PSD_report_tmp;
+				
+		}
+	}
+
+	PatchDCTone(pDM_Odm, PSD_report, initial_gain_psd);
+      
+       //----end
+	//1 Turn on RX
+	//Rx AGC on
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 1);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 1);
+	//CCK on
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1);
+	//1 Turn on TX
+	//Resume TX Queue
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x00);
+	//Turn on 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0x0);
+	//1 Restore Current Settings
+	//Resume DIG
+	pDM_Odm->bDMInitialGainEnable= TRUE;
+	//ODM_SetBBReg(pDM_Odm, 0xc50, 0x7F, initial_gain);
+	ODM_Write_DIG(pDM_Odm,(u1Byte) initial_gain);
+	// restore originl center frequency
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, bMaskDWord, CurrentChannel);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, bMaskDWord, SYN_RF25);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, bMaskDWord, SYN_RF26);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, bMaskDWord, SYN_RF27);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, bMaskDWord, SYN_RF2B);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, bMaskDWord, SYN_RF2C);
+		}
+		else     // DualMAC_DualPHY
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, bMaskDWord, SYN_RF25);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, bMaskDWord, SYN_RF26);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, bMaskDWord, SYN_RF27);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, bMaskDWord, SYN_RF2B);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, bMaskDWord, SYN_RF2C);
+		}
+	}
+	//Turn on CCA
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, RXIQI);
+	//Restore RX idle low power
+	if(RxIdleLowPwr == TRUE)
+		ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 1);
+	
+	psd_cnt++;
+	//gPrint("psd cnt=%d\n", psd_cnt);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD:psd_cnt = %d \n",psd_cnt));
+	if (psd_cnt < ReScan)
+	{
+		ODM_SetTimer(pDM_Odm, &pRX_HP_Table->PSDTimer, Interval);  //ms
+	}
+	else
+	{	
+		psd_cnt = 0;
+		for(i=0;i<80;i++)
+			RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]));
+			//DbgPrint("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]);
+
+		GoodChannelDecision(pDM_Odm, PSD_report, PSD_bitmap,RSSI_BT, PSD_bitmap_memory);
+
+	}
+}
+
+void odm_Write_RXHP(
+	IN		PVOID			pDM_VOID)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T		pRX_HP_Table = &pDM_Odm->DM_RXHP_Table;
+	u4Byte		currentIGI;
+
+	if(pRX_HP_Table->Cur_IGI != pRX_HP_Table->Pre_IGI)
+	{
+		ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);
+	     	ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);	
+	}
+	
+	if(pRX_HP_Table->Cur_pw_th != pRX_HP_Table->Pre_pw_th)
+{
+		ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore2, BIT8|BIT9, pRX_HP_Table->Cur_pw_th);  // RegC54[9:8]=2'b11:  AGC Flow 3
+	}
+
+	if(pRX_HP_Table->RXHP_flag == 0)
+	{
+		pRX_HP_Table->Cur_IGI = 0x20;
+	}
+	else
+	{
+		currentIGI = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
+		if(currentIGI<0x50)
+		{
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);
+	     		ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);	
+		}
+	}
+	pRX_HP_Table->Pre_IGI = pRX_HP_Table->Cur_IGI;
+	pRX_HP_Table->Pre_pw_th = pRX_HP_Table->Cur_pw_th;
+
+}
+
+
+void odm_RXHP(
+	IN		PVOID			pDM_VOID)
+{
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) | (DEV_BUS_TYPE == RT_USB_INTERFACE)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+	PMGNT_INFO	pMgntInfo = &(Adapter->MgntInfo);
+	pDIG_T		pDM_DigTable = &pDM_Odm->DM_DigTable;
+	pRXHP_T		pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+	PFALSE_ALARM_STATISTICS		FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_FALSEALMCNT);
+	
+	u1Byte              	i, j, sum;
+	u1Byte			Is40MHz;
+	s1Byte              	Intf_diff_idx, MIN_Intf_diff_idx = 16;   
+       s4Byte              	cur_channel;    
+       u1Byte              	ch_map_intf_5M[17] = {0};     
+       static u4Byte		FA_TH = 0;	
+	static u1Byte      	psd_intf_flag = 0;
+	static s4Byte      	curRssi = 0;                
+       static s4Byte  		preRssi = 0;                                                                
+	static u1Byte		PSDTriggerCnt = 1;
+	
+	u1Byte			RX_HP_enable = (u1Byte)(ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore2, bMaskDWord)>>31);   // for debug!!
+
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)	
+	static s8Byte  		lastTxOkCnt = 0, lastRxOkCnt = 0;  
+       s8Byte			curTxOkCnt, curRxOkCnt;
+	s8Byte			curTPOkCnt;
+	s8Byte			TP_Acc3, TP_Acc5;
+	static s8Byte		TP_Buff[5] = {0};
+	static u1Byte		pre_state = 0, pre_state_flag = 0;
+	static u1Byte		Intf_HighTP_flag = 0, De_counter = 16; 
+	static u1Byte		TP_Degrade_flag = 0;
+#endif	   
+	static u1Byte		LatchCnt = 0;
+	
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8188E))
+		return;
+	//AGC RX High Power Mode is only applied on 2G band in 92D!!!
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		if(*(pDM_Odm->pBandType) != ODM_BAND_2_4G)
+			return;
+	}
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_RXHP))
+		return;
+
+
+	//RX HP ON/OFF
+	if(RX_HP_enable == 1)
+		pRX_HP_Table->RXHP_enable = FALSE;
+	else
+		pRX_HP_Table->RXHP_enable = TRUE;
+
+	if(pRX_HP_Table->RXHP_enable == FALSE)
+	{
+		if(pRX_HP_Table->RXHP_flag == 1)
+		{
+			pRX_HP_Table->RXHP_flag = 0;
+			psd_intf_flag = 0;
+		}
+		return;
+	}
+
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)	
+	//2 Record current TP for USB interface
+	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast)-lastTxOkCnt;
+	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast)-lastRxOkCnt;
+	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
+	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
+
+	curTPOkCnt = curTxOkCnt+curRxOkCnt;
+	TP_Buff[0] = curTPOkCnt;    // current TP  
+	TP_Acc3 = PlatformDivision64((TP_Buff[1]+TP_Buff[2]+TP_Buff[3]), 3);
+	TP_Acc5 = PlatformDivision64((TP_Buff[0]+TP_Buff[1]+TP_Buff[2]+TP_Buff[3]+TP_Buff[4]), 5);
+	
+	if(TP_Acc5 < 1000)
+		pRX_HP_Table->TP_Mode = Idle_Mode;
+	else if((1000 < TP_Acc5)&&(TP_Acc5 < 3750000))
+		pRX_HP_Table->TP_Mode = Low_TP_Mode;
+	else
+		pRX_HP_Table->TP_Mode = High_TP_Mode;
+
+	ODM_RT_TRACE(pDM_Odm, 	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP TP Mode = %d\n", pRX_HP_Table->TP_Mode));
+	// Since TP result would be sampled every 2 sec, it needs to delay 4sec to wait PSD processing.
+	// When LatchCnt = 0, we would Get PSD result.
+	if(TP_Degrade_flag == 1)
+	{
+		LatchCnt--;
+		if(LatchCnt == 0)
+		{
+			TP_Degrade_flag = 0;
+		}
+	}
+	// When PSD function triggered by TP degrade 20%, and Interference Flag = 1
+	// Set a De_counter to wait IGI = upper bound. If time is UP, the Interference flag will be pull down.
+	if(Intf_HighTP_flag == 1)
+	{
+		De_counter--;
+		if(De_counter == 0)
+		{
+			Intf_HighTP_flag = 0;
+			psd_intf_flag = 0;
+		}
+	}
+#endif
+
+	//2 AGC RX High Power Mode by PSD only applied to STA Mode
+	//3 NOT applied 1. Ad Hoc Mode.
+	//3 NOT applied 2. AP Mode
+	if ((pMgntInfo->mAssoc) && (!pMgntInfo->mIbss) && (!ACTING_AS_AP(Adapter)))
+	{    
+		Is40MHz = *(pDM_Odm->pBandWidth);
+		curRssi = pDM_Odm->RSSI_Min;
+		cur_channel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x0fff) & 0x0f;
+
+		/* check illegal channel and bandwidth */
+		if (Is40MHz && ((cur_channel < 3) || (cur_channel > 12))) {
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("illegal channel setting, 40MHz channel = %d\n", cur_channel));
+			return;
+		}
+		
+		ODM_RT_TRACE(pDM_Odm, 	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP RX HP flag = %d\n", pRX_HP_Table->RXHP_flag));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP FA = %d\n", FalseAlmCnt->Cnt_all));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP cur RSSI = %d, pre RSSI=%d\n", curRssi, preRssi));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP current CH = %d\n", cur_channel));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP Is 40MHz = %d\n", Is40MHz));
+       	//2 PSD function would be triggered 
+       	//3 1. Every 4 sec for PCIE
+       	//3 2. Before TP Mode (Idle TP<4kbps) for USB
+       	//3 3. After TP Mode (High TP) for USB 
+		if((curRssi > 68) && (pRX_HP_Table->RXHP_flag == 0))	// Only RSSI>TH and RX_HP_flag=0 will Do PSD process 
+		{
+#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
+			//2 Before TP Mode ==> PSD would be trigger every 4 sec
+			if(pRX_HP_Table->TP_Mode == Idle_Mode)		//2.1 less wlan traffic <4kbps
+			{
+#endif
+				if(PSDTriggerCnt == 1)       
+				{    	
+					odm_PSD_RXHP(pDM_Odm);
+					pRX_HP_Table->PSD_func_trigger = 1;
+					PSDTriggerCnt = 0;
+				}
+				else
+				{
+             				PSDTriggerCnt++;
+				}
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)
+			}	
+			//2 After TP Mode ==> Check if TP degrade larger than 20% would trigger PSD function
+			if(pRX_HP_Table->TP_Mode == High_TP_Mode)
+			{
+				if((pre_state_flag == 0)&&(LatchCnt == 0)) 
+				{
+					// TP var < 5%
+					if((((curTPOkCnt-TP_Acc3)*20)<(TP_Acc3))&&(((curTPOkCnt-TP_Acc3)*20)>(-TP_Acc3)))
+					{
+						pre_state++;
+						if(pre_state == 3)      // hit pre_state condition => consecutive 3 times
+						{
+							pre_state_flag = 1;
+							pre_state = 0;
+						}
+
+					}
+					else
+					{
+						pre_state = 0;
+					}
+				}
+				//3 If pre_state_flag=1 ==> start to monitor TP degrade 20%
+				if(pre_state_flag == 1)		
+				{
+					if(((TP_Acc3-curTPOkCnt)*5)>(TP_Acc3))      // degrade 20%
+					{
+						odm_PSD_RXHP(pDM_Odm);
+						pRX_HP_Table->PSD_func_trigger = 1;
+						TP_Degrade_flag = 1;
+						LatchCnt = 2;
+						pre_state_flag = 0;
+					}
+					else if(((TP_Buff[2]-curTPOkCnt)*5)>TP_Buff[2])
+					{
+						odm_PSD_RXHP(pDM_Odm);
+						pRX_HP_Table->PSD_func_trigger = 1;
+						TP_Degrade_flag = 1;
+						LatchCnt = 2;
+						pre_state_flag = 0;
+					}
+					else if(((TP_Buff[3]-curTPOkCnt)*5)>TP_Buff[3])
+					{
+						odm_PSD_RXHP(pDM_Odm);
+						pRX_HP_Table->PSD_func_trigger = 1;
+						TP_Degrade_flag = 1;
+						LatchCnt = 2;
+						pre_state_flag = 0;
+					}
+				}
+			}
+#endif
+}
+
+#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
+		for (i=0;i<4;i++)
+		{
+			TP_Buff[4-i] = TP_Buff[3-i];
+		}
+#endif
+		//2 Update PSD bitmap according to PSD report 
+		if((pRX_HP_Table->PSD_func_trigger == 1)&&(LatchCnt == 0))
+    		{	
+           		//2 Separate 80M bandwidth into 16 group with smaller 5M BW.
+			for (i = 0 ; i < 16 ; i++)
+           		{
+				sum = 0;
+				for(j = 0; j < 5 ; j++)
+                			sum += pRX_HP_Table->PSD_bitmap_RXHP[5*i + j];
+            
+                		if(sum < 5)
+                		{
+                			ch_map_intf_5M[i] = 1;  // interference flag
+                		}
+           		}
+			//=============just for debug=========================
+			//for(i=0;i<16;i++)
+				//DbgPrint("RX HP: ch_map_intf_5M[%d] = %d\n", i, ch_map_intf_5M[i]);
+			//===============================================
+			//2 Mask target channel 5M index
+	    		for(i = 0; i < (4+4*Is40MHz) ; i++)
+           		{
+				ch_map_intf_5M[cur_channel - (1+2*Is40MHz) + i] = 0;  
+           		}
+				
+           		psd_intf_flag = 0;
+	    		for(i = 0; i < 16; i++)
+           		{
+         			if(ch_map_intf_5M[i] == 1)
+	              	{
+	              		psd_intf_flag = 1;            // interference is detected!!!	
+	              		break;
+         			}
+	    		}
+				
+#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
+			if(pRX_HP_Table->TP_Mode!=Idle_Mode)
+			{
+				if(psd_intf_flag == 1)     // to avoid psd_intf_flag always 1
+				{
+					Intf_HighTP_flag = 1;
+					De_counter = 32;     // 0x1E -> 0x3E needs 32 times by each IGI step =1
+				}
+			}
+#endif
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP psd_intf_flag = %d\n", psd_intf_flag));
+			//2 Distance between target channel and interference
+           		for(i = 0; i < 16; i++)
+          		{
+				if(ch_map_intf_5M[i] == 1)
+                		{
+					Intf_diff_idx = ((cur_channel+Is40MHz-(i+1))>0) ? (s1Byte)(cur_channel-2*Is40MHz-(i-2)) : (s1Byte)((i+1)-(cur_channel+2*Is40MHz));  
+                      		if(Intf_diff_idx < MIN_Intf_diff_idx)
+						MIN_Intf_diff_idx = Intf_diff_idx;    // the min difference index between interference and target
+		  		}
+	    		}
+	    		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP MIN_Intf_diff_idx = %d\n", MIN_Intf_diff_idx)); 
+			//2 Choose False Alarm Threshold
+			switch (MIN_Intf_diff_idx){
+      				case 0: 
+	   			case 1:
+	        		case 2:
+	        		case 3:	 	 
+                 			FA_TH = FA_RXHP_TH1;  
+                     		break;
+	        		case 4:				// CH5
+	        		case 5:				// CH6
+		   			FA_TH = FA_RXHP_TH2;	
+               			break;
+	        		case 6:				// CH7
+	        		case 7:				// CH8
+		      			FA_TH = FA_RXHP_TH3;
+                    			break; 
+               		case 8:				// CH9
+	        		case 9:				//CH10
+		      			FA_TH = FA_RXHP_TH4;
+                    			break; 	
+	        		case 10:
+	        		case 11:
+	        		case 12:
+	        		case 13:	 
+	        		case 14:
+	      			case 15:	 	
+		      			FA_TH = FA_RXHP_TH5;
+                    			break;  		
+       		}	
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP FA_TH = %d\n", FA_TH));
+			pRX_HP_Table->PSD_func_trigger = 0;
+		}
+		//1 Monitor RSSI variation to choose the suitable IGI or Exit AGC RX High Power Mode
+         	if(pRX_HP_Table->RXHP_flag == 1)
+         	{
+              	if ((curRssi > 80)&&(preRssi < 80))
+              	{ 
+                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_1;
+              	}
+              	else if ((curRssi < 80)&&(preRssi > 80))
+              	{
+                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
+			}
+	       	else if ((curRssi > 72)&&(preRssi < 72))
+	      		{
+                		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
+	       	}
+              	else if ((curRssi < 72)&&( preRssi > 72))
+	     		{
+                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_3;
+	       	}
+	       	else if (curRssi < 68)		 //RSSI is NOT large enough!!==> Exit AGC RX High Power Mode
+	       	{
+                   		pRX_HP_Table->Cur_pw_th = pw_th_10dB;
+				pRX_HP_Table->RXHP_flag = 0;    // Back to Normal DIG Mode		  
+				psd_intf_flag = 0;
+			}
+		}
+		else    // pRX_HP_Table->RXHP_flag == 0
+		{
+			//1 Decide whether to enter AGC RX High Power Mode
+			if ((curRssi > 70) && (psd_intf_flag == 1) && (FalseAlmCnt->Cnt_all > FA_TH) &&  
+				(pDM_DigTable->CurIGValue == pDM_DigTable->rx_gain_range_max))
+			{
+             			if (curRssi > 80)
+             			{
+					pRX_HP_Table->Cur_IGI = LNA_Low_Gain_1;
+				}
+				else if (curRssi > 72) 
+              		{
+               			pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
+				}
+             			else
+            			{
+                   			pRX_HP_Table->Cur_IGI = LNA_Low_Gain_3;
+				}
+           			pRX_HP_Table->Cur_pw_th = pw_th_16dB;		//RegC54[9:8]=2'b11: to enter AGC Flow 3
+				pRX_HP_Table->First_time_enter = TRUE;
+				pRX_HP_Table->RXHP_flag = 1;    //	RXHP_flag=1: AGC RX High Power Mode, RXHP_flag=0: Normal DIG Mode
+			}
+		}
+		preRssi = curRssi; 
+		odm_Write_RXHP(pDM_Odm);	
+	}
+#endif //#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#endif //#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) | (DEV_BUS_TYPE == RT_USB_INTERFACE)
+}
+
+
+VOID
+odm_PSD_RXHPCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+	
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+	#if USE_WORKITEM
+	ODM_ScheduleWorkItem(&pRX_HP_Table->PSDTimeWorkitem);
+	#else
+	odm_PSD_RXHP(pDM_Odm);
+	#endif
+#else
+	ODM_ScheduleWorkItem(&pRX_HP_Table->PSDTimeWorkitem);
+#endif
+	
+	}
+
+VOID
+odm_PSD_RXHPWorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	
+	odm_PSD_RXHP(pDM_Odm);
+}
+
+#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+
+ 
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.h
new file mode 100644
index 000000000..98b3aa6ab
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_rxhp.h
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__PHYDMRXHP_H__
+#define    __PHYDMRXHP_H__
+
+#define RXHP_VERSION	"1.0"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#define	AFH_PSD		1	//0:normal PSD scan, 1: only do 20 pts PSD
+#define	MODE_40M		0	//0:20M, 1:40M
+#define	PSD_TH2		3  
+#define	PSD_CHMIN		20   // Minimum channel number for BT AFH
+#define	SIR_STEP_SIZE	3
+#define   Smooth_Size_1 	5
+#define	Smooth_TH_1	3
+#define   Smooth_Size_2 	10
+#define	Smooth_TH_2	4
+#define   Smooth_Size_3 	20
+#define	Smooth_TH_3	4
+#define   Smooth_Step_Size 5
+#define	Adaptive_SIR	1
+#define	PSD_RESCAN		4
+#define	PSD_SCAN_INTERVAL	700 //ms
+
+typedef struct _RX_High_Power_
+{
+	u1Byte		RXHP_flag;
+	u1Byte		PSD_func_trigger;
+	u1Byte		PSD_bitmap_RXHP[80];
+	u1Byte		Pre_IGI;
+	u1Byte		Cur_IGI;
+	u1Byte		Pre_pw_th;
+	u1Byte		Cur_pw_th;
+	BOOLEAN		First_time_enter;
+	BOOLEAN		RXHP_enable;
+	u1Byte		TP_Mode;
+	RT_TIMER	PSDTimer;
+	#if USE_WORKITEM
+	RT_WORK_ITEM		PSDTimeWorkitem;
+	#endif
+}RXHP_T, *pRXHP_T;
+
+#define	dm_PSDMonitorCallback	odm_PSDMonitorCallback
+VOID	odm_PSDMonitorCallback(PRT_TIMER		pTimer);
+
+VOID
+odm_PSDMonitorInit(
+	IN		PVOID			pDM_VOID
+	);
+
+void	odm_RXHPInit(
+	IN		PVOID			pDM_VOID);
+
+void odm_RXHP(
+	IN		PVOID			pDM_VOID);
+
+VOID
+odm_PSD_RXHPCallback(
+	PRT_TIMER		pTimer
+);
+
+ VOID
+ODM_PSDDbgControl(
+	IN	PADAPTER	Adapter,
+	IN	u4Byte		mode,
+	IN	u4Byte		btRssi
+	);
+
+ VOID
+odm_PSD_RXHPCallback(
+	PRT_TIMER		pTimer
+);
+
+VOID
+odm_PSD_RXHPWorkitemCallback(
+    IN PVOID            pContext
+    );
+
+VOID
+odm_PSDMonitorWorkItemCallback(
+    IN PVOID            pContext
+    );
+
+ #endif
+
+ #endif
+ 
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_types.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_types.h
new file mode 100644
index 000000000..b282ecff2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/phydm_types.h
@@ -0,0 +1,258 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __ODM_TYPES_H__
+#define __ODM_TYPES_H__
+
+
+/*Define Different SW team support*/
+#define	ODM_AP			0x01	/*BIT0*/
+#define	ODM_ADSL		0x02
+#define	ODM_CE			0x04	/*BIT2*/
+#define	ODM_WIN		0x08	/*BIT3*/
+
+/*Deifne HW endian support*/
+#define	ODM_ENDIAN_BIG	0
+#define	ODM_ENDIAN_LITTLE	1
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#define GET_PDM_ODM(__pAdapter)	((PDM_ODM_T)(&((GET_HAL_DATA(__pAdapter))->DM_OutSrc)))
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#define GET_PDM_ODM(__pAdapter)	((PDM_ODM_T)(&((GET_HAL_DATA(__pAdapter))->odmpriv)))
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
+#define 	RT_PCI_INTERFACE				1
+#define 	RT_USB_INTERFACE				2
+#define 	RT_SDIO_INTERFACE				3
+#endif
+
+typedef enum _HAL_STATUS{
+	HAL_STATUS_SUCCESS,
+	HAL_STATUS_FAILURE,
+	/*RT_STATUS_PENDING,
+	RT_STATUS_RESOURCE,
+	RT_STATUS_INVALID_CONTEXT,
+	RT_STATUS_INVALID_PARAMETER,
+	RT_STATUS_NOT_SUPPORT,
+	RT_STATUS_OS_API_FAILED,*/
+}HAL_STATUS,*PHAL_STATUS;
+
+#if( DM_ODM_SUPPORT_TYPE == ODM_AP)
+#define		MP_DRIVER		0
+#endif
+#if(DM_ODM_SUPPORT_TYPE != ODM_WIN)
+
+#define		VISTA_USB_RX_REVISE			0
+
+//
+// Declare for ODM spin lock defintion temporarily fro compile pass.
+//
+typedef enum _RT_SPINLOCK_TYPE{
+	RT_TX_SPINLOCK = 1,
+	RT_RX_SPINLOCK = 2,
+	RT_RM_SPINLOCK = 3,
+	RT_CAM_SPINLOCK = 4,
+	RT_SCAN_SPINLOCK = 5,
+	RT_LOG_SPINLOCK = 7, 
+	RT_BW_SPINLOCK = 8,
+	RT_CHNLOP_SPINLOCK = 9,
+	RT_RF_OPERATE_SPINLOCK = 10,
+	RT_INITIAL_SPINLOCK = 11,
+	RT_RF_STATE_SPINLOCK = 12, // For RF state. Added by Bruce, 2007-10-30.
+#if VISTA_USB_RX_REVISE
+	RT_USBRX_CONTEXT_SPINLOCK = 13,
+	RT_USBRX_POSTPROC_SPINLOCK = 14, // protect data of Adapter->IndicateW/ IndicateR
+#endif
+	//Shall we define Ndis 6.2 SpinLock Here ?
+	RT_PORT_SPINLOCK=16,
+	RT_VNIC_SPINLOCK=17,
+	RT_HVL_SPINLOCK=18,	
+	RT_H2C_SPINLOCK = 20, // For H2C cmd. Added by tynli. 2009.11.09.
+
+	RT_BTData_SPINLOCK=25,
+
+	RT_WAPI_OPTION_SPINLOCK=26,
+	RT_WAPI_RX_SPINLOCK=27,
+
+      // add for 92D CCK control issue  
+	RT_CCK_PAGEA_SPINLOCK = 28,
+	RT_BUFFER_SPINLOCK = 29,
+	RT_CHANNEL_AND_BANDWIDTH_SPINLOCK = 30,
+	RT_GEN_TEMP_BUF_SPINLOCK = 31,
+	RT_AWB_SPINLOCK = 32,
+	RT_FW_PS_SPINLOCK = 33,
+	RT_HW_TIMER_SPIN_LOCK = 34,
+	RT_MPT_WI_SPINLOCK = 35,
+	RT_P2P_SPIN_LOCK = 36,	// Protect P2P context
+	RT_DBG_SPIN_LOCK = 37,
+	RT_IQK_SPINLOCK = 38,
+	RT_PENDED_OID_SPINLOCK = 39,
+	RT_CHNLLIST_SPINLOCK = 40,	
+	RT_INDIC_SPINLOCK = 41,	//protect indication	
+	RT_RFD_SPINLOCK = 42,
+	RT_SYNC_IO_CNT_SPINLOCK = 43,
+	RT_LAST_SPINLOCK,
+}RT_SPINLOCK_TYPE;
+
+#endif
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#define	STA_INFO_T			RT_WLAN_STA
+	#define	PSTA_INFO_T			PRT_WLAN_STA
+	#define	__func__		__FUNCTION__
+	#define	PHYDM_TESTCHIP_SUPPORT	TESTCHIP_SUPPORT
+	#define bMaskH3Bytes			0xffffff00
+	#define SUCCESS	0
+	#define FAIL	(-1)
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+	// To let ADSL/AP project compile ok; it should be removed after all conflict are solved. Added by Annie, 2011-10-07.
+	#define ADSL_AP_BUILD_WORKAROUND
+	#define AP_BUILD_WORKAROUND
+
+	#ifdef AP_BUILD_WORKAROUND
+	#include "../typedef.h"
+	#else
+	typedef void					VOID,*PVOID;
+	typedef unsigned char			BOOLEAN,*PBOOLEAN;
+	typedef unsigned char			u1Byte,*pu1Byte;
+	typedef unsigned short			u2Byte,*pu2Byte;
+	typedef unsigned int			u4Byte,*pu4Byte;
+	typedef unsigned long long		u8Byte,*pu8Byte;
+#if 1
+/* In ARM platform, system would use the type -- "char" as "unsigned char"
+ * And we only use s1Byte/ps1Byte as INT8 now, so changes the type of s1Byte.*/
+    typedef signed char				s1Byte,*ps1Byte;
+#else
+	typedef char					s1Byte,*ps1Byte;
+#endif
+	typedef short					s2Byte,*ps2Byte;
+	typedef long					s4Byte,*ps4Byte;
+	typedef long long				s8Byte,*ps8Byte;
+	#endif
+
+	typedef struct rtl8192cd_priv	*prtl8192cd_priv;
+	typedef struct stat_info		STA_INFO_T,*PSTA_INFO_T;
+	typedef struct timer_list		RT_TIMER, *PRT_TIMER;
+	typedef  void *				RT_TIMER_CALL_BACK;
+
+#ifdef CONFIG_PCI_HCI
+	#define DEV_BUS_TYPE		RT_PCI_INTERFACE
+#endif
+
+	#define _TRUE				1
+	#define _FALSE				0
+
+	#if (defined(TESTCHIP_SUPPORT))
+		#define	PHYDM_TESTCHIP_SUPPORT 1
+	#else
+		#define	PHYDM_TESTCHIP_SUPPORT 0
+	#endif
+	
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#include <drv_types.h>
+#if 0
+	typedef u8					u1Byte, *pu1Byte;
+	typedef u16					u2Byte,*pu2Byte;
+	typedef u32					u4Byte,*pu4Byte;
+	typedef u64					u8Byte,*pu8Byte;
+	typedef s8					s1Byte,*ps1Byte;
+	typedef s16					s2Byte,*ps2Byte;
+	typedef s32					s4Byte,*ps4Byte;
+	typedef s64					s8Byte,*ps8Byte;
+#else
+	#define u1Byte 		u8
+	#define	pu1Byte 	u8*	
+
+	#define u2Byte 		u16
+	#define	pu2Byte 	u16*		
+
+	#define u4Byte 		u32
+	#define	pu4Byte 	u32*	
+
+	#define u8Byte 		u64
+	#define	pu8Byte 	u64*
+
+	#define s1Byte 		s8
+	#define	ps1Byte 	s8*	
+
+	#define s2Byte 		s16
+	#define	ps2Byte 	s16*	
+
+	#define s4Byte 		s32
+	#define	ps4Byte 	s32*	
+
+	#define s8Byte 		s64
+	#define	ps8Byte 	s64*	
+	
+#endif
+	#ifdef CONFIG_USB_HCI
+		#define DEV_BUS_TYPE  	RT_USB_INTERFACE
+	#elif defined(CONFIG_PCI_HCI)
+		#define DEV_BUS_TYPE  	RT_PCI_INTERFACE
+	#elif defined(CONFIG_SDIO_HCI)
+		#define DEV_BUS_TYPE  	RT_SDIO_INTERFACE
+	#elif defined(CONFIG_GSPI_HCI)
+		#define DEV_BUS_TYPE  	RT_SDIO_INTERFACE
+	#endif
+	
+
+	#if defined(CONFIG_LITTLE_ENDIAN)	
+		#define	ODM_ENDIAN_TYPE			ODM_ENDIAN_LITTLE
+	#elif defined (CONFIG_BIG_ENDIAN)
+		#define	ODM_ENDIAN_TYPE			ODM_ENDIAN_BIG
+	#endif
+	
+	typedef struct timer_list		RT_TIMER, *PRT_TIMER;
+	typedef  void *				RT_TIMER_CALL_BACK;
+	#define	STA_INFO_T			struct sta_info
+	#define	PSTA_INFO_T		struct sta_info *
+		
+
+
+	#define TRUE 	_TRUE	
+	#define FALSE	_FALSE
+
+
+	#define SET_TX_DESC_ANTSEL_A_88E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 24, 1, __Value)
+	#define SET_TX_DESC_ANTSEL_B_88E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 25, 1, __Value)
+	#define SET_TX_DESC_ANTSEL_C_88E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+28, 29, 1, __Value)
+
+	//define useless flag to avoid compile warning
+	#define	USE_WORKITEM 0
+	#define	FOR_BRAZIL_PRETEST 0
+	#define	FPGA_TWO_MAC_VERIFICATION	0
+	#define	RTL8881A_SUPPORT	0
+
+	#if (defined(TESTCHIP_SUPPORT))
+		#define	PHYDM_TESTCHIP_SUPPORT 1
+	#else
+		#define	PHYDM_TESTCHIP_SUPPORT 0
+	#endif
+#endif
+
+#define READ_NEXT_PAIR(v1, v2, i) do { if (i+2 >= ArrayLen) break; i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
+#define COND_ELSE  2
+#define COND_ENDIF 3
+
+#endif // __ODM_TYPES_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.c
new file mode 100644
index 000000000..d2a762df5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.c
@@ -0,0 +1,480 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+     
+ History:
+	Data		Who		Remark (Internal History)
+	
+	05/14/2012	MH		Collect RTK inernal infromation and generate channel plan draft.
+	
+******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "mp_precomp.h"
+#include "rtchnlplan.h"
+
+
+
+//
+//	Channel Plan Domain Code
+//
+
+/*
+	Channel Plan Contents					
+	Domain Code		EEPROM	Countries in Specific Domain		
+			2G RD		5G RD		Bit[6:0]	2G	5G	
+	Case	Old Define				00h~1Fh	Old Define	Old Define	
+	1		2G_WORLD	5G_NULL		20h		Worldwird 13	NA	
+	2		2G_ETSI1	5G_NULL		21h		Europe 2G		NA	
+	3		2G_FCC1		5G_NULL		22h		US 2G			NA	
+	4		2G_MKK1		5G_NULL		23h		Japan 2G		NA	
+	5		2G_ETSI2	5G_NULL		24h		France 2G		NA	
+	6		2G_FCC1		5G_FCC1		25h		US 2G			US 5G					Kj{
+	7		2G_WORLD	5G_ETSI1	26h		Worldwird 13	Europe					Kj{
+	8		2G_MKK1		5G_MKK1		27h		Japan 2G		Japan 5G				Kj{
+	9		2G_WORLD	5G_KCC1		28h		Worldwird 13	Korea					Kj{
+	10		2G_WORLD	5G_FCC2		29h		Worldwird 13	US o/w DFS Channels		
+	11		2G_WORLD	5G_FCC3		30h		Worldwird 13	India, Mexico	    	
+	12		2G_WORLD	5G_FCC4		31h		Worldwird 13	Venezuela	        	
+	13		2G_WORLD	5G_FCC5		32h		Worldwird 13	China	            	
+	14		2G_WORLD	5G_FCC6		33h		Worldwird 13	Israel	            	
+	15		2G_FCC1		5G_FCC7		34h		US 2G			US/Canada				Kj{
+	16		2G_WORLD	5G_ETSI2	35h		Worldwird 13	Australia, New Zealand	Kj{
+	17		2G_WORLD	5G_ETSI3	36h		Worldwird 13	Russia	
+	18		2G_MKK1		5G_MKK2		37h		Japan 2G		Japan (W52, W53)	
+	19		2G_MKK1		5G_MKK3		38h		Japan 2G		Japan (W56)	
+	20		2G_FCC1		5G_NCC1		39h		US 2G			Taiwan					Kj{
+						
+	NA		2G_WORLD	5G_FCC1		7F		FCC	FCC DFS Channels	Realtek Define
+						
+						
+						
+						
+						
+	2.4G 	Regulatory 	Domains					
+	Case	2G RD		Regulation	Channels	Frequencyes		Note					Countries in Specific Domain
+	1		2G_WORLD	ETSI		1~13		2412~2472		Passive scan CH 12, 13	Worldwird 13
+	2		2G_ETSI1	ETSI		1~13		2412~2472								Europe
+	3		2G_FCC1		FCC			1~11		2412~2462								US
+	4		2G_MKK1		MKK			1~13, 14	2412~2472, 2484							Japan
+	5		2G_ETSI2	ETSI		10~13		2457~2472								France
+						
+						
+						
+						
+	5G Regulatory Domains					
+	Case	5G RD		Regulation	Channels			Frequencyes					Note											Countries in Specific Domain
+	1		5G_NULL		NA			NA					NA							Do not support 5GHz	
+	2		5G_ETSI1	ETSI		"36~48, 52~64,  	
+									100~140"			"5180~5240, 5260~5230
+														5500~5700"					Band1, Ban2, Band3								Europe
+	3		5G_ETSI2	ETSI		"36~48, 52~64, 
+									100~140, 149~165"	"5180~5240, 5260~5230
+														5500~5700, 5745~5825"		Band1, Ban2, Band3, Band4						Australia, New Zealand
+	4		5G_ETSI3	ETSI		"36~48, 52~64, 
+														100~132, 149~165"	
+														"5180~5240, 5260~5230
+														5500~5660, 5745~5825"		Band1, Ban2, Band3(except CH 136, 140), Band4"	Russia
+	5		5G_FCC1		FCC			"36~48, 52~64, 
+									100~140, 149~165"	
+														"5180~5240, 5260~5230
+														5500~5700, 5745~5825"		Band1(5150~5250MHz), 
+																					Band2(5250~5350MHz),
+																					Band3(5470~5725MHz),
+																					Band4(5725~5850MHz)"							US
+	6		5G_FCC2		FCC			36~48, 149~165		5180~5240, 5745~5825		Band1, Band4	FCC o/w DFS Channels
+	7		5G_FCC3		FCC			"36~48, 52~64, 
+									149~165"			"5180~5240, 5260~5230
+														5745~5825"					Band1, Ban2, Band4								India, Mexico
+	8		5G_FCC4		FCC			"36~48, 52~64, 
+									149~161"			"5180~5240, 5260~5230
+														5745~5805"					Band1, Ban2,
+																					Band4(except CH 165)"							Venezuela
+	9		5G_FCC5		FCC			149~165				5745~5825					Band4											China
+	10		5G_FCC6		FCC			36~48, 52~64		5180~5240, 5260~5230		Band1, Band2									Israel
+	11		5G_FCC7
+			5G_IC1		FCC
+						IC"			"36~48, 52~64, 
+									100~116, 136, 140, 
+									149~165"			"5180~5240, 5260~5230
+														5500~5580, 5680, 5700, 
+														5745~5825"					"Band1, Band2, 
+																					Band3(except 5600~5650MHz),
+																					Band4"											"US
+																																	Canada"
+	12		5G_KCC1		KCC			"36~48, 52~64, 
+									100~124, 149~165"	"5180~5240, 5260~5230
+														5500~5620, 5745~5825"		"Band1, Ban2, 
+																					Band3(5470~5650MHz),
+																					Band4"											Korea
+	13		5G_MKK1		MKK			"36~48, 52~64, 
+									100~140"			"5180~5240, 5260~5230
+														5500~5700"					W52, W53, W56									Japan
+	14		5G_MKK2		MKK			36~48, 52~64		5180~5240, 5260~5230		W52, W53										Japan (W52, W53)
+	15		5G_MKK3		MKK			100~140				5500~5700					W56	Japan (W56)
+	16		5G_NCC1		NCC			"56~64,
+									100~116, 136, 140,
+									149~165"			"5260~5320
+														5500~5580, 5680, 5700, 
+														5745~5825"					"Band2(except CH 52), 
+																					Band3(except 5600~5650MHz),
+																					Band4"											Taiwan
+						
+						
+*/						
+						
+//
+// 2.4G CHannel 
+//						
+/*
+
+	2.4G Band		Regulatory Domains																RTL8192D	
+	Channel Number	Channel Frequency	US		Canada	Europe	Spain	France	Japan	Japan		20M		40M
+					(MHz)				(FCC)	(IC)	(ETSI)							(MPHPT)				
+	1				2412				v		v		v								v			v		
+	2				2417				v		v		v								v			v		
+	3				2422				v		v		v								v			v		v
+	4				2427				v		v		v								v			v		v
+	5				2432				v		v		v								v			v		v
+	6				2437				v		v		v								v			v		v
+	7				2442				v		v		v								v			v		v
+	8				2447				v		v		v								v			v		v
+	9				2452				v		v		v								v			v		v
+	10				2457				v		v		v		v		v				v			v		v
+	11				2462				v		v		v		v		v				v			v		v
+	12				2467								v				v				v			v		v
+	13				2472								v				v				v			v	
+	14				2484														v					v	
+
+
+*/
+
+
+//
+// 5G Operating Channel
+//
+/*
+
+	5G Band		RTL8192D	RTL8195 (Jaguar)				Jaguar 2	Regulatory Domains											
+	Channel Number	Channel Frequency	Global	Global				Global	"US
+(FCC 15.407)"	"Canada
+(FCC, except 5.6~5.65GHz)"	Argentina, Australia, New Zealand, Brazil, S. Africa (FCC/ETSI)	"Europe
+(CE 301 893)"	China	India, Mexico, Singapore	Israel, Turkey	"Japan
+(MIC Item 19-3, 19-3-2)"	Korea	Russia, Ukraine	"Taiwan
+(NCC)"	Venezuela
+		(MHz)	(20MHz)	(20MHz)	(40MHz)	(80MHz)	(160MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)	(20MHz)
+"Band 1
+5.15GHz
+~
+5.25GHz"	36	5180	v	v	v	v		v	Indoor	Indoor	v	Indoor		v	Indoor	Indoor	v	v		v
+	40	5200	v	v				v	Indoor	Indoor	v	Indoor		v	Indoor	Indoor	v	v		v
+	44	5220	v	v	v			v	Indoor	Indoor	v	Indoor		v	Indoor	Indoor	v	v		v
+	48	5240	v	v				v	Indoor	Indoor	v	Indoor		v	Indoor	Indoor	v	v		v
+"Band 2
+5.25GHz
+~
+5.35GHz
+(DFS)"	52	5260	v	v	v	v		v	v	v	v	Indoor		v	Indoor	Indoor	v	v		v
+	56	5280	v	v				v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
+	60	5300	v	v	v			v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
+	64	5320	v	v				v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
+																				
+"Band 3
+5.47GHz
+~
+5.725GHz
+(DFS)"	100	5500	v	v	v	v		v	v	v	v	v				v	v	v	v	
+	104	5520	v	v				v	v	v	v	v				v	v	v	v	
+	108	5540	v	v	v			v	v	v	v	v				v	v	v	v	
+	112	5560	v	v				v	v	v	v	v				v	v	v	v	
+	116	5580	v	v	v	v		v	v	v	v	v				v	v	v	v	
+	120	5600	v	v				v	Indoor		v	Indoor				v	v	v		
+	124	5620	v	v	v			v	Indoor		v	Indoor				v	v	v		
+	128	5640	v	v				v	Indoor		v	Indoor				v		v		
+	132	5660	v	v	v	E		v	Indoor		v	Indoor				v		v		
+	136	5680	v	v				v	v	v	v	v				v			v	
+	140	5700	v	v	E			v	v	v	v	v				v			v	
+	144	5720	E	E				E												
+"Band 4
+5.725GHz
+~
+5.85GHz
+(~5.9GHz)"	149	5745	v	v	v	v		v	v	v	v		v	v			v	v	v	v
+	153	5765	v	v				v	v	v	v		v	v			v	v	v	v
+	157	5785	v	v	v			v	v	v	v		v	v			v	v	v	v
+	161	5805	v	v				v	v	v	v		v	v			v	v	v	v
+	165	5825	v	v	P	P		v	v	v	v		v	v			v	v	v	
+	169	5845	P	P				P												
+	173	5865	P	P	P			P												
+	177	5885	P	P				P												
+Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
+			E: FCC accepted the ask for CH144 from Accord.					PS: 160MHz  80MHz+80MHz{H			Argentina	Belgium (Q)		India	Israel			Russia		
+			P: Customer's requirement from James.								Australia	The Netherlands ()		Mexico	Turkey			Ukraine		
+											New Zealand	UK (^)		Singapore						
+											Brazil	Switzerland (h)								
+
+
+*/
+
+/*---------------------------Define Local Constant---------------------------*/
+
+
+// define Maximum Power v.s each band for each region 
+// ISRAEL
+// Format:
+// RT_CHANNEL_DOMAIN_Region ={{{Chnl_Start, Chnl_end, Pwr_dB_Max}, {Chn2_Start, Chn2_end, Pwr_dB_Max}, {Chn3_Start, Chn3_end, Pwr_dB_Max}, {Chn4_Start, Chn4_end, Pwr_dB_Max}, {Chn5_Start, Chn5_end, Pwr_dB_Max}}, Limit_Num} */
+// RT_CHANNEL_DOMAIN_FCC ={{{01,11,30}, {36,48,17}, {52,64,24}, {100,140,24}, {149,165,30}}, 5} 
+// "NR" is non-release channle.
+// Issue--- Israel--Russia--New Zealand
+// DOMAIN_01= (2G_WORLD, 5G_NULL)
+// DOMAIN_02= (2G_ETSI1, 5G_NULL)
+// DOMAIN_03= (2G_FCC1, 5G_NULL)
+// DOMAIN_04= (2G_MKK1, 5G_NULL)
+// DOMAIN_05= (2G_ETSI2, 5G_NULL)
+// DOMAIN_06= (2G_FCC1, 5G_FCC1)
+// DOMAIN_07= (2G_WORLD, 5G_ETSI1)
+// DOMAIN_08= (2G_MKK1, 5G_MKK1)
+// DOMAIN_09= (2G_WORLD, 5G_KCC1)
+// DOMAIN_10= (2G_WORLD, 5G_FCC2)
+// DOMAIN_11= (2G_WORLD, 5G_FCC3)----india
+// DOMAIN_12= (2G_WORLD, 5G_FCC4)----Venezuela
+// DOMAIN_13= (2G_WORLD, 5G_FCC5)----China
+// DOMAIN_14= (2G_WORLD, 5G_FCC6)----Israel
+// DOMAIN_15= (2G_FCC1, 5G_FCC7)-----Canada
+// DOMAIN_16= (2G_WORLD, 5G_ETSI2)---Australia
+// DOMAIN_17= (2G_WORLD, 5G_ETSI3)---Russia
+// DOMAIN_18= (2G_MKK1, 5G_MKK2)-----Japan
+// DOMAIN_19= (2G_MKK1, 5G_MKK3)-----Japan
+// DOMAIN_20= (2G_FCC1, 5G_NCC1)-----Taiwan
+// DOMAIN_21= (2G_FCC1, 5G_NCC1)-----Taiwan
+
+
+static	RT_CHANNEL_PLAN_MAXPWR	ChnlPlanPwrMax_2G[] = {
+
+	// 2G_WORLD, 
+	{{1, 13, 20}, 1},	
+
+	// 2G_ETSI1
+	{{1, 13, 20}, 1},
+
+	/* RT_CHANNEL_DOMAIN_ETSI */
+	{{{1, 11, 17}, {40, 56, 17}, {60, 128, 17}, {0, 0, 0}, {149, 165, 17}}, 4},
+
+	// RT_CHANNEL_DOMAIN_MKK
+	{{{1, 11, 17}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, 1},
+
+	// Add new channel plan mex power table.
+	// ......
+	};
+
+
+/*
+//===========================================1:(2G_WORLD, 5G_NULL)
+
+RT_CHANNEL_PLAN_MAXPWR	RT_DOMAIN_01 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1} 
+
+//===========================================2:(2G_ETSI1, 5G_NULL)
+
+RT_DOMAIN_02 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1}
+
+//===========================================3:(2G_FCC1, 5G_NULL)
+
+RT_DOMAIN_03 ={{{01,11,30}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1}
+
+//===========================================4:(2G_MKK1, 5G_NULL)
+
+RT_DOMAIN_04 ={{{01,14,23}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1}
+
+//===========================================5:(2G_ETSI2, 5G_NULL)
+
+RT_DOMAIN_05 ={{{10,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1}
+
+//===========================================6:(2G_FCC1, 5G_FCC1)
+
+RT_DOMAIN_06 ={{{01,13,30}, {36,48,17}, {52,64,24}, {100,140,24}, {149,165,30}}, 5}
+
+//===========================================7:(2G_WORLD, 5G_ETSI1)
+
+RT_DOMAIN_07 ={{{01,13,20}, {36,48,23}, {52,64,23}, {100,140,30}, {NR,NR,0}}, 4}
+
+//===========================================8:(2G_MKK1, 5G_MKK1)
+
+RT_DOMAIN_08 ={{{01,14,23}, {36,48,23}, {52,64,23}, {100,140,23}, {NR,NR,0}}, 4}
+
+//===========================================9:(2G_WORLD, 5G_KCC1)
+
+RT_DOMAIN_09 ={{{01,13,20}, {36,48,17}, {52,64,23}, {100,124,23}, {149,165,23}}, 5}
+
+//===========================================10:(2G_WORLD, 5G_FCC2)
+
+RT_DOMAIN_10 ={{{01,13,20}, {36,48,17}, {NR,NR,0}, {NR,NR,0}, {149,165,30}}, 3}
+
+//===========================================11:(2G_WORLD, 5G_FCC3)
+RT_DOMAIN_11 ={{{01,13,20}, {36,48,23}, {52,64,23}, {NR,NR,0}, {149,165,23}}, 4}
+
+//===========================================12:(2G_WORLD, 5G_FCC4)
+RT_DOMAIN_12 ={{{01,13,20}, {36,48,24}, {52,64,24}, {NR,NR,0}, {149,161,27}}, 4}
+
+//===========================================13:(2G_WORLD, 5G_FCC5)
+RT_DOMAIN_13 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {149,165,27}}, 2}
+
+//===========================================14:(2G_WORLD, 5G_FCC6)
+RT_DOMAIN_14 ={{{01,13,20}, {36,48,17}, {52,64,17}, {NR,NR,0}, {NR,NR,0}}, 3}
+
+//===========================================15:(2G_FCC1, 5G_FCC7)
+RT_DOMAIN_15 ={{{01,11,30}, {36,48,23}, {52,64,24}, {100,140,24}, {149,165,30}}, 5}
+
+//===========================================16:(2G_WORLD, 5G_ETSI2)
+RT_DOMAIN_16 ={{{01,13,20}, {36,48,23}, {52,64,23}, {100,140,30}, {149,165,30}}, 5}
+
+//===========================================17:(2G_WORLD, 5G_ETSI3)
+RT_DOMAIN_17 ={{{01,13,20}, {36,48,23}, {52,64,23}, {100,132,30}, {149,165,20}}, 5}
+
+//===========================================18:(2G_MKK1, 5G_MKK2)
+RT_DOMAIN_18 ={{{01,14,23}, {36,48,23}, {52,64,23}, {NR,NR,0}, {NR,NR,0}}, 3}
+
+//===========================================19:(2G_MKK1, 5G_MKK3)
+RT_DOMAIN_19 ={{{01,14,23}, {NR,NR,0}, {NR,NR,0}, {100,140,23}, {NR,NR,0}}, 2}
+
+//===========================================20:(2G_FCC1, 5G_NCC1)
+RT_DOMAIN_20 ={{{01,11,30}, {NR,NR,0}, {56,64,23}, {100,140,24}, {149,165,30}}, 4}
+
+//===========================================21:(2G_FCC1, 5G_NCC2)
+RT_DOMAIN_21 ={{{01,11,30}, {NR,NR,0}, {56,64,23}, {NR,NR,0}, {149,165,30}}, 3}
+
+//===========================================22:(2G_WORLD, 5G_FCC3)
+RT_DOMAIN_22 ={{{01,13,24}, {36,48,20}, {52,64,24}, {NR,NR,0}, {149,165,30}}, 4}
+
+//===========================================23:(2G_WORLD, 5G_ETSI2)
+RT_DOMAIN_23 ={{{01,13,20}, {36,48,23}, {52,64,23}, {100,140,30}, {149,165,30}}, 5}
+
+*/
+
+//
+// Counter & Realtek Channel plan transfer table.
+//
+RT_CHNL_CTRY_TBL	RtCtryChnlTbl[] = 
+{
+
+	{
+		RT_CTRY_AL,							//	"Albania"					
+		"AL",
+		RT_2G_WORLD,
+		RT_5G_WORLD,		
+		RT_CHANNEL_DOMAIN_UNDEFINED			// 2G/5G world.
+	},
+#if 0	
+	{
+		RT_CTRY_BB,							//  "Barbadosh"				
+		"BB",
+		RT_2G_WORLD,
+		RT_5G_NULL,		
+		RT_CHANNEL_DOMAIN_EFUSE_0x20		// 2G world. 5G_NULL
+	},
+	
+	{
+		RT_CTRY_DE,							//  "Germanyw"					
+		"DE",
+		RT_2G_WORLD,
+		RT_5G_ETSI1,		
+		RT_CHANNEL_DOMAIN_EFUSE_0x26
+	},
+	
+	{
+		RT_CTRY_US,							//  "Germanyw"					
+		"US",
+		RT_2G_FCC1,
+		RT_5G_FCC7,		
+		RT_CHANNEL_DOMAIN_EFUSE_0x34
+	},
+
+	{
+		RT_CTRY_JP,							//  "Germanyw"					
+		"JP",
+		RT_2G_MKK1,
+		RT_5G_MKK1,		
+		RT_CHANNEL_DOMAIN_EFUSE_0x34
+	},
+		
+	{
+		RT_CTRY_TW,							//  "Germanyw"					
+		"TW",
+		RT_2G_FCC1,
+		RT_5G_NCC1,		
+		RT_CHANNEL_DOMAIN_EFUSE_0x39
+	},	
+#endif
+
+};	// RtCtryChnlTbl
+
+//
+// Realtek Defined Channel plan.
+//
+#if 0
+
+static	RT_CHANNEL_PLAN_NEW		RtChnlPlan[] =
+{
+	// Channel Plan   0x20.
+	{
+		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.		
+		RT_CHANNEL_DOMAIN_EFUSE_0x20,		// RT_CHANNEL_DOMAIN RT Channel Plan Define 
+		RT_2G_WORLD,						// RT_REGULATION_2G
+		RT_5G_NULL,							// RT_REGULATION_5G
+		RT_WORLD,							// RT_REGULATION_CMN RT Regulatory domain definition.
+		RT_SREQ_NA,							// RT Channel plan special & customerize requirement.
+		
+		CHNL_RT_2G_WORLD,
+		CHNL_RT_2G_WORLD_SCAN_TYPE,
+		&ChnlPlanPwrMax_2G[0],
+
+		CHNL_RT_5G_NULL,
+		CHNL_RT_5G_NULL_SCAN_TYPE,
+
+		
+	},
+	
+	// Channel Plan   0x26.
+	{
+		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.		
+		RT_CHANNEL_DOMAIN_EFUSE_0x26,		// RT_CHANNEL_DOMAIN RT Channel Plan Define 
+		RT_2G_WORLD,						// RT_REGULATION_2G
+		RT_5G_ETSI1,						// RT_REGULATION_5G
+		RT_WORLD,							// RT_REGULATION_CMN RT Regulatory domain definition.
+		RT_SREQ_NA,							// RT Channel plan special & customerize requirement.
+		
+		CHNL_RT_2G_WORLD,					// 2G workd cannel
+		CHNL_RT_2G_WORLD_SCAN_TYPE,
+		&ChnlPlanPwrMax_2G[1],
+		
+		CHNL_RT_5G_ETSI1,
+		CHNL_RT_5G_ETSI1_SCAN_TYPE,
+		
+	}
+	
+	
+};
+#endif
+
+
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.h
new file mode 100644
index 000000000..78a31dcd1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtchnlplan.h
@@ -0,0 +1,699 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__RT_CHANNELPLAN_H__
+#define __RT_CHANNELPLAN_H__
+
+typedef enum _RT_CHANNEL_DOMAIN_NEW
+{
+
+	//===== Add new channel plan above this line ===============//
+
+	// For new architecture we define different 2G/5G CH area for all country.
+	// 2.4 G only
+	RT_CHANNEL_DOMAIN_2G_WORLD_5G_NULL				= 0x20,
+	RT_CHANNEL_DOMAIN_2G_ETSI1_5G_NULL				= 0x21,
+	RT_CHANNEL_DOMAIN_2G_FCC1_5G_NULL				= 0x22,
+	RT_CHANNEL_DOMAIN_2G_MKK1_5G_NULL				= 0x23,
+	RT_CHANNEL_DOMAIN_2G_ETSI2_5G_NULL				= 0x24,
+	// 2.4 G + 5G type 1
+	RT_CHANNEL_DOMAIN_2G_FCC1_5G_FCC1				= 0x25,
+	RT_CHANNEL_DOMAIN_2G_WORLD_5G_ETSI1				= 0x26,
+	//RT_CHANNEL_DOMAIN_2G_WORLD_5G_ETSI1				= 0x27,
+	// .....
+
+	RT_CHANNEL_DOMAIN_MAX_NEW,
+	
+}RT_CHANNEL_DOMAIN_NEW, *PRT_CHANNEL_DOMAIN_NEW;
+
+
+#if 0
+#define DOMAIN_CODE_2G_WORLD \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13}, 13
+#define DOMAIN_CODE_2G_ETSI1 \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13}, 13
+#define DOMAIN_CODE_2G_ETSI2 \
+        {1,2,3,4,5,6,7,8,9,10,11}, 11
+#define DOMAIN_CODE_2G_FCC1 \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13,14}, 14
+#define DOMAIN_CODE_2G_MKK1 \
+        {10,11,12,13}, 4
+
+#define DOMAIN_CODE_5G_ETSI1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140}, 19
+#define DOMAIN_CODE_5G_ETSI2 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}, 24
+#define DOMAIN_CODE_5G_ETSI3 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,149,153,157,161,165}, 22
+#define DOMAIN_CODE_5G_FCC1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}, 24
+#define DOMAIN_CODE_5G_FCC2 \
+        {36,40,44,48,149,153,157,161,165}, 9
+#define DOMAIN_CODE_5G_FCC3 \
+        {36,40,44,48,52,56,60,64,149,153,157,161,165}, 13
+#define DOMAIN_CODE_5G_FCC4 \
+        {36,40,44,48,52,56,60,64,149,153,157,161}, 12
+#define DOMAIN_CODE_5G_FCC5 \
+        {149,153,157,161,165}, 5
+#define DOMAIN_CODE_5G_FCC6 \
+        {36,40,44,48,52,56,60,64}, 8
+#define DOMAIN_CODE_5G_FCC7 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 20
+#define DOMAIN_CODE_5G_IC1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 20
+#define DOMAIN_CODE_5G_KCC1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161,165}, 20
+#define DOMAIN_CODE_5G_MKK1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140}, 19
+#define DOMAIN_CODE_5G_MKK2 \
+        {36,40,44,48,52,56,60,64}, 8
+#define DOMAIN_CODE_5G_MKK3 \
+        {100,104,108,112,116,120,124,128,132,136,140}, 11
+#define DOMAIN_CODE_5G_NCC1 \
+        {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
+#define DOMAIN_CODE_5G_NCC2 \
+        {56,60,64,149,153,157,161,165}, 8  			
+#define UNDEFINED \
+        {0}, 0
+#endif
+
+//
+//
+//
+/*
+
+Countries							"Country Abbreviation"	Domain Code					SKU's	Ch# of 20MHz
+															2G			5G						Ch# of 40MHz
+"Albania"					AL													Local Test	
+									    					        	            	
+"AlgeriaQ"					DZ									CE TCF	    	
+					                    					        	            	
+"Antigua & Barbudawq&F"	AG						2G_WORLD					FCC TCF	
+					                    					        	        		
+"Argentina"					AR						2G_WORLD					Local Test	
+									    					        	        		
+"Armenia"					AM						2G_WORLD					ETSI	
+									    					        	        		
+"Aruba|q"						AW						2G_WORLD					FCC TCF	
+															        	
+"AustraliaDw"						AU						2G_WORLD		5G_ETSI2		
+															        	
+"AustriaaQ"						AT						2G_WORLD		5G_ETSI1	CE	
+					    			    					        	
+"Azerbaijan"				AZ						2G_WORLD					CE TCF	
+					                    					        	
+"Bahamas"						BS						2G_WORLD				
+									    					        	
+"Barbadosh"					BB						2G_WORLD					FCC TCF	
+									    					        	
+"BelgiumQ"						BE						2G_WORLD		5G_ETSI1	CE	
+															        	
+"Bermuda}F"						BM						2G_WORLD					FCC TCF	
+															        	        		
+"Brazil"						BR						2G_WORLD					Local Test	
+									    					        	
+"BulgariaO[Q"					BG						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Canada[j"						CA						2G_FCC1			5G_FCC7		IC / FCC	IC / FCC
+					                    					        	
+"Cayman Islands}sq"			KY						2G_WORLD		5G_ETSI1	CE	
+					                    					        	
+"ChileQ"							CL						2G_WORLD					FCC TCF	
+																    	
+"China"							CN						2G_WORLD		5G_FCC5		H?i2002j353? 	
+					                    					        	
+"Columbia"					CO						2G_WORLD					Voluntary 	
+					    			    					        	
+"Costa RicaF["				CR						2G_WORLD					FCC TCF	
+					    			    					        	
+"Cyprus"					CY						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Czech J"						CZ						2G_WORLD		5G_ETSI1	CE	
+															        	
+"Denmark"						DK						2G_WORLD		5G_ETSI1	CE	
+					                    					        	
+"Dominican Republich[@M"	DO						2G_WORLD					FCC TCF	
+					                    					        	
+"EgyptJ"	EG	2G_WORLD			CE T												CF	    	
+					                    					        	
+"El Salvadorh"				SV						2G_WORLD					Voluntary	
+					        		    					        	
+"EstoniaRF"					EE						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Finland"						FI						2G_WORLD		5G_ETSI1	CE	
+															        	
+"Francek"						FR										5G_E		TSI1	CE	
+															        	
+"Germanyw"						DE						2G_WORLD		5G_ETSI1	CE	
+															        	
+"Greece "						GR						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Guamq"							GU						2G_WORLD				
+									    					        	
+"Guatemalaa"					GT						2G_WORLD				
+									    					        	
+"Haitia"							HT						2G_WORLD					FCC TCF	
+									    					        	
+"Honduras"					HN						2G_WORLD					FCC TCF	
+									    					        	
+"HungaryIQ"						HU						2G_WORLD		5G_ETSI1	CE	
+															        	
+"IcelandBq"						IS						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"IndiaL"							IN						2G_WORLD		5G_FCC3		FCC/CE TCF	
+															        	
+"IrelandR"						IE						2G_WORLD		5G_ETSI1	CE	
+															        	
+"IsraelHC"						IL										5G_F		CC6	CE TCF	
+															        	
+"ItalyqjQ"						IT						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Japan"							JP						2G_MKK1			5G_MKK1		MKK	MKK
+																    	
+"Korea"							KR						2G_WORLD		5G_KCC1		KCC	KCC
+									    					        	
+"Latvia"					LV						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Lithuania{"					LT						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Luxembourgc"					LU						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Malaysia"					MY						2G_WORLD					Local Test	
+									    					        	
+"MaltaL"						MT						2G_WORLD		5G_ETSI1	CE	
+															        	
+"Mexico"						MX						2G_WORLD		5G_FCC3		Local Test	
+															        	
+"Morocco"						MA													CE TCF	
+									    					        	
+"Netherlands"					NL						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"New Zealand"					NZ						2G_WORLD		5G_ETSI2		
+									    					        	
+"Norway"						NO						2G_WORLD		5G_ETSI1	CE	
+															        	
+"Panama "						PA						2G_FCC1						Voluntary	
+									    					        	
+"Philippines"					PH						2G_WORLD					FCC TCF	
+									    					        	
+"Polandi"						PL						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Portugal"					PT						2G_WORLD		5G_ETSI1	CE	
+									    					        	
+"Romania"					RO						2G_WORLD		5G_ETSI1	CE	
+					        		    					        	
+"RussiaX"						RU						2G_WORLD		5G_ETSI3	CE TCF	
+					        		    					        	
+"Saudi ArabiaFaB"			SA						2G_WORLD					CE TCF	
+					        		    					        	
+"Singapores[Y"					SG						2G_WORLD				
+									    					        	
+"SlovakiaJ"					SK						2G_WORLD		5G_ETSI1	CE	
+					    			    					        	
+"Slovenia"				SI						2G_WORLD		5G_ETSI1	CE	
+					    			    					        	
+"South AfricanD"					ZA						2G_WORLD					CE TCF	
+					        		    					        	
+"SpainZ"						ES										5G_ETSI1	CE	
+															        	
+"Sweden"						SE						2G_WORLD		5G_ETSI1	CE	
+					        		    					        	
+"Switzerlandh"					CH						2G_WORLD		5G_ETSI1	CE	
+					        		    					        	
+"TaiwanOW"						TW						2G_FCC1			5G_NCC1	NCC	
+															        	
+"Thailand"						TH						2G_WORLD					FCC/CE TCF	
+															        	
+"Turkeyg"						TR						2G_WORLD				
+															        	
+"UkraineQJ"						UA						2G_WORLD					Local Test	
+					        		    					        	
+"United Kingdom^"				GB						2G_WORLD		5G_ETSI1	CE	ETSI
+					    			    					        	
+"United States"					US						2G_FCC1			5G_FCC7		FCC	FCC
+					    			    					        	
+"Venezuelae"					VE						2G_WORLD		5G_FCC4		FCC TCF	
+					    			    					        	
+"VietnamVn"						VN						2G_WORLD					FCC/CE TCF	
+					
+
+
+*/
+
+// Counter abbervation.
+typedef enum _RT_COUNTRY_DEFINE_NUM
+{
+	RT_CTRY_AL,				//	"Albania"					
+	RT_CTRY_DZ,             //  "AlgeriaQ"					
+	RT_CTRY_AG,             //  "Antigua & Barbudawq&F"	
+	RT_CTRY_AR,             //  "Argentina"					
+	RT_CTRY_AM,             //  "Armenia"					
+	RT_CTRY_AW,             //  "Aruba|q"						
+	RT_CTRY_AU,             //  "AustraliaDw"						
+	RT_CTRY_AT,             //  "AustriaaQ"						
+	RT_CTRY_AZ,             //  "Azerbaijan"				
+	RT_CTRY_BS,             //  "Bahamas"					
+	RT_CTRY_BB,             //  "Barbadosh"				
+	RT_CTRY_BE,             //  "BelgiumQ"					
+	RT_CTRY_BM,             //  "Bermuda}F"					
+	RT_CTRY_BR,             //  "Brazil"						
+	RT_CTRY_BG,             //  "BulgariaO[Q"				
+	RT_CTRY_CA,             //  "Canada[j"					
+	RT_CTRY_KY,             //  "Cayman Islands}sq"			
+	RT_CTRY_CL,             //  "ChileQ"						
+	RT_CTRY_CN,             //  "China"						
+	RT_CTRY_CO,             //  "Columbia"				
+	RT_CTRY_CR,             //  "Costa RicaF["			
+	RT_CTRY_CY,             //  "Cyprus"					
+	RT_CTRY_CZ,             //  "Czech J"						
+	RT_CTRY_DK,             //  "Denmark"					
+	RT_CTRY_DO,             //  "Dominican Republich[@M"	
+	RT_CTRY_CE,             //  "EgyptJ"	EG	2G_WORLD			
+	RT_CTRY_SV,             //  "El Salvadorh"				
+	RT_CTRY_EE,             //  "EstoniaRF"					
+	RT_CTRY_FI,             //  "Finland"						
+	RT_CTRY_FR,             //  "Francek"						
+	RT_CTRY_DE,             //  "Germanyw"					
+	RT_CTRY_GR,             //  "Greece "					
+	RT_CTRY_GU,             //  "Guamq"						
+	RT_CTRY_GT,             //  "Guatemalaa"				
+	RT_CTRY_HT,             //  "Haitia"						
+	RT_CTRY_HN,             //  "Honduras"				
+	RT_CTRY_HU,             //  "HungaryIQ"					
+	RT_CTRY_IS,             //  "IcelandBq"					
+	RT_CTRY_IN,             //  "IndiaL"						
+	RT_CTRY_IE,             //  "IrelandR"					
+	RT_CTRY_IL,             //  "IsraelHC"					
+	RT_CTRY_IT,             //  "ItalyqjQ"					
+	RT_CTRY_JP,             //  "Japan"						
+	RT_CTRY_KR,             //  "Korea"						
+	RT_CTRY_LV,             //  "Latvia"					
+	RT_CTRY_LT,             //  "Lithuania{"				
+	RT_CTRY_LU,             //  "Luxembourgc"				
+	RT_CTRY_MY,             //  "Malaysia"				
+	RT_CTRY_MT,             //  "MaltaL"					
+	RT_CTRY_MX,             //  "Mexico"					
+	RT_CTRY_MA,             //  "Morocco"					
+	RT_CTRY_NL,             //  "Netherlands"				
+	RT_CTRY_NZ,             //  "New Zealand"				
+	RT_CTRY_NO,             //  "Norway"						
+	RT_CTRY_PA,             //  "Panama "					
+	RT_CTRY_PH,             //  "Philippines"				
+	RT_CTRY_PL,             //  "Polandi"						
+	RT_CTRY_PT,             //  "Portugal"					
+	RT_CTRY_RO,             //  "Romania"				
+	RT_CTRY_RU,             //  "RussiaX"					
+	RT_CTRY_SA,             //  "Saudi ArabiaFaB"			
+	RT_CTRY_SG,             //  "Singapores[Y"				
+	RT_CTRY_SK,             //  "SlovakiaJ"				
+	RT_CTRY_SI,             //  "Slovenia"				
+	RT_CTRY_ZA,             //  "South AfricanD"				
+	RT_CTRY_ES,             //  "SpainZ"					
+	RT_CTRY_SE,             //  "Sweden"						
+	RT_CTRY_CH,             //  "Switzerlandh"				
+	RT_CTRY_TW,             //  "TaiwanOW"						
+	RT_CTRY_TH,             //  "Thailand"					
+	RT_CTRY_TR,             //  "Turkeyg"					
+	RT_CTRY_UA,             //  "UkraineQJ"					
+	RT_CTRY_GB,             //  "United Kingdom^"				
+	RT_CTRY_US,             //  "United States"				
+	RT_CTRY_VE,             //  "Venezuelae"				
+	RT_CTRY_VN,             //  "VietnamVn"					
+	RT_CTRY_MAX,            //  
+	
+}RT_COUNTRY_NAME, *PRT_COUNTRY_NAME;
+    
+// Scan type including active and passive scan.
+typedef enum _RT_SCAN_TYPE_NEW
+{
+	SCAN_NULL,
+	SCAN_ACT,
+	SCAN_PAS,
+	SCAN_BOTH,
+}RT_SCAN_TYPE_NEW, *PRT_SCAN_TYPE_NEW;
+    
+
+// Power table sample.
+
+typedef struct _RT_CHNL_PLAN_LIMIT
+{
+	u2Byte	Chnl_Start;
+	u2Byte	Chnl_end;	
+	
+	u2Byte	Freq_Start;
+	u2Byte	Freq_end;	
+}RT_CHNL_PLAN_LIMIT, *PRT_CHNL_PLAN_LIMIT;
+
+    
+//    
+// 2.4G Regulatory Domains
+//
+typedef enum _RT_REGULATION_DOMAIN_2G
+{
+	RT_2G_NULL,   
+	RT_2G_WORLD,
+	RT_2G_ETSI1,
+	RT_2G_FCC1,
+	RT_2G_MKK1,
+	RT_2G_ETSI2	
+	
+}RT_REGULATION_2G, *PRT_REGULATION_2G;
+
+
+//typedef struct _RT_CHANNEL_BEHAVIOR
+//{
+//	u1Byte	Chnl;
+//	RT_SCAN_TYPE_NEW
+//	
+//}RT_CHANNEL_BEHAVIOR, *PRT_CHANNEL_BEHAVIOR;
+
+//typedef struct _RT_CHANNEL_PLAN_TYPE
+//{
+//	RT_CHANNEL_BEHAVIOR		
+//	u1Byte					Chnl_num;
+//}RT_CHNL_PLAN_TYPE, *PRT_CHNL_PLAN_TYPE;
+
+//
+// 2.4G Channel Number
+// Channel definition & number
+//
+#define CHNL_RT_2G_NULL \
+        {0}, 0
+#define CHNL_RT_2G_WORLD \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13}, 13
+#define CHNL_RT_2G_WORLD_TEST \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13}, 13
+
+#define CHNL_RT_2G_EFSI1 \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13}, 13
+#define CHNL_RT_2G_FCC1 \
+        {1,2,3,4,5,6,7,8,9,10,11}, 11
+#define CHNL_RT_2G_MKK1 \
+        {1,2,3,4,5,6,7,8,9,10,11,12,13,14}, 14
+#define CHNL_RT_2G_ETSI2 \
+        {10,11,12,13}, 4
+
+//
+// 2.4G Channel Active or passive scan.
+//
+#define CHNL_RT_2G_NULL_SCAN_TYPE \
+        {SCAN_NULL}
+#define CHNL_RT_2G_WORLD_SCAN_TYPE \
+        {1,1,1,1,1,1,1,1,1,1,1,0,0}
+#define CHNL_RT_2G_EFSI1_SCAN_TYPE \
+        {1,1,1,1,1,1,1,1,1,1,1,1,1}
+#define CHNL_RT_2G_FCC1_SCAN_TYPE \
+        {1,1,1,1,1,1,1,1,1,1,1}
+#define CHNL_RT_2G_MKK1_SCAN_TYPE \
+        {1,1,1,1,1,1,1,1,1,1,1,1,1,1}
+#define CHNL_RT_2G_ETSI2_SCAN_TYPE \
+        {1,1,1,1}
+
+
+//
+// 2.4G Band & Frequency Section
+// Freqency start & end / band number
+//
+#define FREQ_RT_2G_NULL \
+        {0}, 0
+        // Passive scan CH 12, 13
+#define FREQ_RT_2G_WORLD \
+        {2412, 2472}, 1
+#define FREQ_RT_2G_EFSI1 \
+        {2412, 2472}, 1
+#define FREQ_RT_2G_FCC1 \
+        {2412, 2462}, 1
+#define FREQ_RT_2G_MKK1 \
+        {2412, 2484}, 1
+#define FREQ_RT_2G_ETSI2 \
+        {2457, 2472}, 1
+
+
+//    
+// 5G Regulatory Domains
+//
+typedef enum _RT_REGULATION_DOMAIN_5G
+{   
+	RT_5G_NULL,
+	RT_5G_WORLD,
+	RT_5G_ETSI1,
+	RT_5G_ETSI2,
+	RT_5G_ETSI3,
+	RT_5G_FCC1,	
+	RT_5G_FCC2,
+	RT_5G_FCC3,
+	RT_5G_FCC4,
+	RT_5G_FCC5,
+	RT_5G_FCC6,
+	RT_5G_FCC7,
+	RT_5G_IC1,
+	RT_5G_KCC1,
+	RT_5G_MKK1,
+	RT_5G_MKK2,
+	RT_5G_MKK3,
+	RT_5G_NCC1,
+	
+}RT_REGULATION_5G, *PRT_REGULATION_5G;
+
+//
+// 5G Channel Number
+//
+#define CHNL_RT_5G_NULL \
+        {0}, 0
+#define CHNL_RT_5G_WORLD \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140}, 19
+#define CHNL_RT_5G_ETSI1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}, 24
+#define CHNL_RT_5G_ETSI2 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,149,153,157,161,165}, 22
+#define CHNL_RT_5G_ETSI3 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}, 24
+#define CHNL_RT_5G_FCC1 \
+        {36,40,44,48,149,153,157,161,165}, 9
+#define CHNL_RT_5G_FCC2 \
+        {36,40,44,48,52,56,60,64,149,153,157,161,165}, 13
+#define CHNL_RT_5G_FCC3 \
+        {36,40,44,48,52,56,60,64,149,153,157,161}, 12
+#define CHNL_RT_5G_FCC4 \
+        {149,153,157,161,165}, 5
+#define CHNL_RT_5G_FCC5 \
+        {36,40,44,48,52,56,60,64}, 8
+#define CHNL_RT_5G_FCC6 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 20
+#define CHNL_RT_5G_FCC7 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 20
+#define CHNL_RT_5G_IC1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161,165}, 20
+#define CHNL_RT_5G_KCC1 \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140}, 19
+#define CHNL_RT_5G_MKK1 \
+        {36,40,44,48,52,56,60,64}, 8
+#define CHNL_RT_5G_MKK2 \
+        {100,104,108,112,116,120,124,128,132,136,140}, 11
+#define CHNL_RT_5G_MKK3 \
+        {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
+#define CHNL_RT_5G_NCC1 \
+        {56,60,64,149,153,157,161,165}, 8  	
+
+//
+// 5G Channel Active or passive scan.
+//
+#define CHNL_RT_5G_NULL_SCAN_TYPE \
+        {SCAN_NULL}
+#define CHNL_RT_5G_WORLD_SCAN_TYPE \
+        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
+#define CHNL_RT_5G_ETSI1_SCAN_TYPE \
+        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
+#define CHNL_RT_5G_ETSI2_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,149,153,157,161,165}, 22
+#define CHNL_RT_5G_ETSI3_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}, 24
+#define CHNL_RT_5G_FCC1_SCAN_TYPE \
+        {36,40,44,48,149,153,157,161,165}, 9
+#define CHNL_RT_5G_FCC2_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,149,153,157,161,165}, 13
+#define CHNL_RT_5G_FCC3_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,149,153,157,161}, 12
+#define CHNL_RT_5G_FCC4_SCAN_TYPE \
+        {149,153,157,161,165}, 5
+#define CHNL_RT_5G_FCC5_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64}, 8
+#define CHNL_RT_5G_FCC6_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 20
+#define CHNL_RT_5G_FCC7_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 20
+#define CHNL_RT_5G_IC1_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161,165}, 20
+#define CHNL_RT_5G_KCC1_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140}, 19
+#define CHNL_RT_5G_MKK1_SCAN_TYPE \
+        {36,40,44,48,52,56,60,64}, 8
+#define CHNL_RT_5G_MKK2_SCAN_TYPE \
+        {100,104,108,112,116,120,124,128,132,136,140}, 11
+#define CHNL_RT_5G_MKK3_SCAN_TYPE \
+        {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
+#define CHNL_RT_5G_NCC1_SCAN_TYPE \
+        {56,60,64,149,153,157,161,165}, 8  	
+
+//    
+// Global Regulation
+//
+typedef enum _RT_REGULATION_COMMON
+{
+	RT_WORLD,   
+	RT_FCC,   
+	RT_MKK,
+	RT_ETSI,
+	RT_IC,
+	RT_CE,
+	RT_NCC,
+	
+}RT_REGULATION_CMN, *PRT_REGULATION_CMN;
+
+
+
+//    
+// Special requirement for different regulation domain.
+// For internal test or customerize special request.
+//
+typedef enum _RT_CHNLPLAN_SREQ
+{
+	RT_SREQ_NA						= 0x0,
+	RT_SREQ_2G_ADHOC_11N			= 0x00000001,
+	RT_SREQ_2G_ADHOC_11B			= 0x00000002,
+	RT_SREQ_2G_ALL_PASS				= 0x00000004,
+	RT_SREQ_2G_ALL_ACT				= 0x00000008,	
+	RT_SREQ_5G_ADHOC_11N			= 0x00000010,
+	RT_SREQ_5G_ADHOC_11AC			= 0x00000020,
+	RT_SREQ_5G_ALL_PASS				= 0x00000040,
+	RT_SREQ_5G_ALL_ACT				= 0x00000080,
+	RT_SREQ_C1_PLAN					= 0x00000100,	
+	RT_SREQ_C2_PLAN					= 0x00000200,	
+	RT_SREQ_C3_PLAN					= 0x00000400,	
+	RT_SREQ_C4_PLAN					= 0x00000800,	
+	RT_SREQ_NFC_ON					= 0x00001000,	
+	RT_SREQ_MASK					= 0x0000FFFF,   /* Requirements bit mask */
+	
+}RT_CHNLPLAN_SREQ, *PRT_CHNLPLAN_SREQ;
+
+
+//
+// RT_COUNTRY_NAME & RT_REGULATION_2G & RT_REGULATION_5G transfer table
+// 
+//
+typedef struct _RT_CHANNEL_PLAN_COUNTRY_TRANSFER_TABLE
+{   
+	//
+	// Define countery domain and corresponding 
+	//	
+	RT_COUNTRY_NAME		Country_Enum;
+	char				Country_Name[3];
+	
+	//char		Domain_Name[12];
+	RT_REGULATION_2G	Domain_2G;	
+
+	RT_REGULATION_5G	Domain_5G;	
+
+	RT_CHANNEL_DOMAIN	RtChDomain;
+	//u1Byte		Country_Area;
+    
+}RT_CHNL_CTRY_TBL, *PRT_CHNL_CTRY_TBL;
+    
+
+#define		RT_MAX_CHNL_NUM_2G		13
+#define		RT_MAX_CHNL_NUM_5G		44	
+
+// Power table sample.
+
+typedef struct _RT_CHNL_PLAN_PWR_LIMIT
+{
+	u2Byte	Chnl_Start;
+	u2Byte	Chnl_end;
+	u1Byte	dB_Max;
+	u2Byte	mW_Max;
+}RT_CHNL_PWR_LIMIT, *PRT_CHNL_PWR_LIMIT;
+
+
+#define		RT_MAX_BAND_NUM			5
+
+typedef struct _RT_CHANNEL_PLAN_MAXPWR
+{
+//	STRING_T
+	RT_CHNL_PWR_LIMIT	Chnl[RT_MAX_BAND_NUM];
+	u1Byte				Band_Useful_Num;
+
+	
+}RT_CHANNEL_PLAN_MAXPWR, *PRT_CHANNEL_PLAN_MAXPWR;
+
+
+//
+// Power By Rate Table.
+//
+
+
+
+typedef struct _RT_CHANNEL_PLAN_NEW
+{   
+	//
+	// Define countery domain and corresponding 
+	//
+	//char		Country_Name[36];
+	//u1Byte		Country_Enum;
+	
+	//char		Domain_Name[12];
+
+	
+	PRT_CHNL_CTRY_TBL		pCtryTransfer;
+	
+	RT_CHANNEL_DOMAIN		RtChDomain;	
+
+	RT_REGULATION_2G		Domain_2G;
+
+	RT_REGULATION_5G		Domain_5G;	
+
+	RT_REGULATION_CMN		Regulator;
+
+	RT_CHNLPLAN_SREQ		ChnlSreq;
+	
+	//RT_CHNL_PLAN_LIMIT		RtChnl;
+		
+	u1Byte	Chnl2G[MAX_CHANNEL_NUM];				// CHNL_RT_2G_WORLD
+	u1Byte	Len2G;
+	u1Byte	Chnl2GScanTp[MAX_CHANNEL_NUM];			// CHNL_RT_2G_WORLD_SCAN_TYPE
+	//u1Byte	Freq2G[2];								// FREQ_RT_2G_WORLD
+
+	u1Byte	Chnl5G[MAX_CHANNEL_NUM];				
+	u1Byte	Len5G;
+	u1Byte	Chnl5GScanTp[MAX_CHANNEL_NUM];
+	//u1Byte	Freq2G[2];								// FREQ_RT_2G_WORLD
+
+	RT_CHANNEL_PLAN_MAXPWR	ChnlMaxPwr;
+	
+    
+}RT_CHANNEL_PLAN_NEW, *PRT_CHANNEL_PLAN_NEW;
+    
+    
+#endif	// __RT_CHANNELPLAN_H__
+    
+    
+    
+    
+ 
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.c
new file mode 100644
index 000000000..04c6dd041
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.c
@@ -0,0 +1,833 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8703B_SUPPORT == 1)
+static BOOLEAN
+CheckPositive(
+	IN  PDM_ODM_T     pDM_Odm,
+	IN  const u4Byte  Condition1,
+	IN  const u4Byte  Condition2,
+	IN	const u4Byte  Condition3,
+	IN	const u4Byte  Condition4
+)
+{
+	u1Byte    _BoardType = ((pDM_Odm->BoardType & BIT4) >> 4) << 0 | /* _GLNA*/
+				((pDM_Odm->BoardType & BIT3) >> 3) << 1 | /* _GPA*/ 
+				((pDM_Odm->BoardType & BIT7) >> 7) << 2 | /* _ALNA*/
+				((pDM_Odm->BoardType & BIT6) >> 6) << 3 | /* _APA */
+				((pDM_Odm->BoardType & BIT2) >> 2) << 4;  /* _BT*/  
+
+	u4Byte	cond1   = Condition1, cond2 = Condition2, cond3 = Condition3, cond4 = Condition4;
+	u4Byte    driver1 = pDM_Odm->CutVersion       << 24 | 
+				(pDM_Odm->SupportInterface & 0xF0) << 16 | 
+				pDM_Odm->SupportPlatform  << 16 | 
+				pDM_Odm->PackageType      << 12 | 
+				(pDM_Odm->SupportInterface & 0x0F) << 8  |
+				_BoardType;
+
+	u4Byte    driver2 = (pDM_Odm->TypeGLNA & 0xFF) <<  0 |  
+				(pDM_Odm->TypeGPA & 0xFF)  <<  8 | 
+				(pDM_Odm->TypeALNA & 0xFF) << 16 | 
+				(pDM_Odm->TypeAPA & 0xFF)  << 24; 
+
+u4Byte    driver3 = 0;
+
+	u4Byte    driver4 = (pDM_Odm->TypeGLNA & 0xFF00) >>  8 |
+				(pDM_Odm->TypeGPA & 0xFF00) |
+				(pDM_Odm->TypeALNA & 0xFF00) << 8 |
+				(pDM_Odm->TypeAPA & 0xFF00)  << 16;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("===> CheckPositive (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n", cond1, cond2, cond3, cond4));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("===> CheckPositive (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n", driver1, driver2, driver3, driver4));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("	(Platform, Interface) = (0x%X, 0x%X)\n", pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("	(Board, Package) = (0x%X, 0x%X)\n", pDM_Odm->BoardType, pDM_Odm->PackageType));
+
+
+	/*============== Value Defined Check ===============*/
+	/*QFN Type [15:12] and Cut Version [27:24] need to do value check*/
+	
+	if (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return FALSE;
+	if (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return FALSE;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1   &= 0x00FF0FFF; 
+	driver1 &= 0x00FF0FFF; 
+
+	if ((cond1 & driver1) == cond1) {
+		u4Byte bitMask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* BoardType is DONTCARE*/
+			return TRUE;
+
+		if ((cond1 & BIT0) != 0) /*GLNA*/
+			bitMask |= 0x000000FF;
+		if ((cond1 & BIT1) != 0) /*GPA*/
+			bitMask |= 0x0000FF00;
+		if ((cond1 & BIT2) != 0) /*ALNA*/
+			bitMask |= 0x00FF0000;
+		if ((cond1 & BIT3) != 0) /*APA*/
+			bitMask |= 0xFF000000;
+
+		if (((cond2 & bitMask) == (driver2 & bitMask)) && ((cond4 & bitMask) == (driver4 & bitMask)))  /* BoardType of each RF path is matched*/
+			return TRUE;
+		else
+			return FALSE;
+	} else
+		return FALSE;
+}
+static BOOLEAN
+CheckNegative(
+	IN  PDM_ODM_T     pDM_Odm,
+	IN  const u4Byte  Condition1,
+	IN  const u4Byte  Condition2
+)
+{
+	return TRUE;
+}
+
+/******************************************************************************
+*                           AGC_TAB.TXT
+******************************************************************************/
+
+u4Byte Array_MP_8703B_AGC_TAB[] = { 
+		0xC78, 0xFC000101,
+		0xC78, 0xFB010101,
+		0xC78, 0xFA020101,
+		0xC78, 0xF9030101,
+		0xC78, 0xF8040101,
+		0xC78, 0xF7050101,
+		0xC78, 0xF6060101,
+		0xC78, 0xF5070101,
+		0xC78, 0xF4080101,
+		0xC78, 0xF3090101,
+		0xC78, 0xF20A0101,
+		0xC78, 0xF10B0101,
+		0xC78, 0xF00C0101,
+		0xC78, 0xEF0D0101,
+		0xC78, 0xEE0E0101,
+		0xC78, 0xED0F0101,
+		0xC78, 0xEC100101,
+		0xC78, 0xEB110101,
+		0xC78, 0xEA120101,
+		0xC78, 0xE9130101,
+		0xC78, 0xE8140101,
+		0xC78, 0xE7150101,
+		0xC78, 0xE6160101,
+		0xC78, 0xE5170101,
+		0xC78, 0xE4180101,
+		0xC78, 0xE3190101,
+		0xC78, 0x661A0101,
+		0xC78, 0x651B0101,
+		0xC78, 0x641C0101,
+		0xC78, 0x631D0101,
+		0xC78, 0x071E0101,
+		0xC78, 0x061F0101,
+		0xC78, 0x05200101,
+		0xC78, 0x04210101,
+		0xC78, 0x03220101,
+		0xC78, 0xE8230001,
+		0xC78, 0xE7240001,
+		0xC78, 0xE6250001,
+		0xC78, 0xE5260001,
+		0xC78, 0xE4270001,
+		0xC78, 0x89280001,
+		0xC78, 0x88290001,
+		0xC78, 0x872A0001,
+		0xC78, 0x862B0001,
+		0xC78, 0x852C0001,
+		0xC78, 0x482D0001,
+		0xC78, 0x472E0001,
+		0xC78, 0x462F0001,
+		0xC78, 0x45300001,
+		0xC78, 0x44310001,
+		0xC78, 0x07320001,
+		0xC78, 0x06330001,
+		0xC78, 0x05340001,
+		0xC78, 0x04350001,
+		0xC78, 0x03360001,
+		0xC78, 0x02370001,
+		0xC78, 0x01380001,
+		0xC78, 0x00390001,
+		0xC78, 0x003A0001,
+		0xC78, 0x003B0001,
+		0xC78, 0x003C0001,
+		0xC78, 0x003D0001,
+		0xC78, 0x003E0001,
+		0xC78, 0x003F0001,
+		0xC78, 0x7F002001,
+		0xC78, 0x7F012001,
+		0xC78, 0x7F022001,
+		0xC78, 0x7F032001,
+		0xC78, 0x7F042001,
+		0xC78, 0x7F052001,
+		0xC78, 0x7F062001,
+		0xC78, 0x7F072001,
+		0xC78, 0x7F082001,
+		0xC78, 0x7F092001,
+		0xC78, 0x7F0A2001,
+		0xC78, 0x7F0B2001,
+		0xC78, 0x7F0C2001,
+		0xC78, 0x7F0D2001,
+		0xC78, 0x7F0E2001,
+		0xC78, 0x7F0F2001,
+		0xC78, 0x7F102001,
+		0xC78, 0x7F112001,
+		0xC78, 0x7E122001,
+		0xC78, 0x7D132001,
+		0xC78, 0x7C142001,
+		0xC78, 0x7B152001,
+		0xC78, 0x7A162001,
+		0xC78, 0x79172001,
+		0xC78, 0x78182001,
+		0xC78, 0x77192001,
+		0xC78, 0x761A2001,
+		0xC78, 0x751B2001,
+		0xC78, 0x741C2001,
+		0xC78, 0x731D2001,
+		0xC78, 0x721E2001,
+		0xC78, 0x711F2001,
+		0xC78, 0x70202001,
+		0xC78, 0x6F212001,
+		0xC78, 0x6E222001,
+		0xC78, 0x6D232001,
+		0xC78, 0x6C242001,
+		0xC78, 0x6B252001,
+		0xC78, 0x6A262001,
+		0xC78, 0x69272001,
+		0xC78, 0x68282001,
+		0xC78, 0x67292001,
+		0xC78, 0x662A2001,
+		0xC78, 0x652B2001,
+		0xC78, 0x642C2001,
+		0xC78, 0x632D2001,
+		0xC78, 0x622E2001,
+		0xC78, 0x612F2001,
+		0xC78, 0x60302001,
+		0xC78, 0x42312001,
+		0xC78, 0x41322001,
+		0xC78, 0x40332001,
+		0xC78, 0x23342001,
+		0xC78, 0x22352001,
+		0xC78, 0x21362001,
+		0xC78, 0x20372001,
+		0xC78, 0x00382001,
+		0xC78, 0x02392001,
+		0xC78, 0x013A2001,
+		0xC78, 0x003B2001,
+		0xC78, 0x003C2001,
+		0xC78, 0x003D2001,
+		0xC78, 0x003E2001,
+		0xC78, 0x003F2001,
+		0xC78, 0x7F003101,
+		0xC78, 0x7F013101,
+		0xC78, 0x7F023101,
+		0xC78, 0x7F033101,
+		0xC78, 0x7F043101,
+		0xC78, 0x7F053101,
+		0xC78, 0x7F063101,
+		0xC78, 0x7E073101,
+		0xC78, 0x7D083101,
+		0xC78, 0x7C093101,
+		0xC78, 0x7B0A3101,
+		0xC78, 0x7A0B3101,
+		0xC78, 0x790C3101,
+		0xC78, 0x780D3101,
+		0xC78, 0x770E3101,
+		0xC78, 0x760F3101,
+		0xC78, 0x75103101,
+		0xC78, 0x74113101,
+		0xC78, 0x73123101,
+		0xC78, 0x72133101,
+		0xC78, 0x71143101,
+		0xC78, 0x70153101,
+		0xC78, 0x6F163101,
+		0xC78, 0x69173101,
+		0xC78, 0x68183101,
+		0xC78, 0x67193101,
+		0xC78, 0x661A3101,
+		0xC78, 0x651B3101,
+		0xC78, 0x641C3101,
+		0xC78, 0x631D3101,
+		0xC78, 0x621E3101,
+		0xC78, 0x611F3101,
+		0xC78, 0x60203101,
+		0xC78, 0x42213101,
+		0xC78, 0x41223101,
+		0xC78, 0x40233101,
+		0xC78, 0x22243101,
+		0xC78, 0x21253101,
+		0xC78, 0x20263101,
+		0xC78, 0x00273101,
+		0xC78, 0x00283101,
+		0xC78, 0x00293101,
+		0xC78, 0x002A3101,
+		0xC78, 0x002B3101,
+		0xC78, 0x002C3101,
+		0xC78, 0x002D3101,
+		0xC78, 0x002E3101,
+		0xC78, 0x002F3101,
+		0xC78, 0x00303101,
+		0xC78, 0x00313101,
+		0xC78, 0x00323101,
+		0xC78, 0x00333101,
+		0xC78, 0x00343101,
+		0xC78, 0x00353101,
+		0xC78, 0x00363101,
+		0xC78, 0x00373101,
+		0xC78, 0x00383101,
+		0xC78, 0x00393101,
+		0xC78, 0x003A3101,
+		0xC78, 0x003B3101,
+		0xC78, 0x003C3101,
+		0xC78, 0x003D3101,
+		0xC78, 0x003E3101,
+		0xC78, 0x003F3101,
+		0xC78, 0xFA403101,
+		0xC78, 0xF9413101,
+		0xC78, 0xF8423101,
+		0xC78, 0xF7433101,
+		0xC78, 0xF6443101,
+		0xC78, 0xF5453101,
+		0xC78, 0xF4463101,
+		0xC78, 0xF3473101,
+		0xC78, 0xF2483101,
+		0xC78, 0xE1493101,
+		0xC78, 0xE04A3101,
+		0xC78, 0xEF4B3101,
+		0xC78, 0xEE4C3101,
+		0xC78, 0xED4D3101,
+		0xC78, 0xEC4E3101,
+		0xC78, 0xEB4F3101,
+		0xC78, 0xEA503101,
+		0xC78, 0xE9513101,
+		0xC78, 0xE8523101,
+		0xC78, 0xE7533101,
+		0xC78, 0xE6543101,
+		0xC78, 0xE5553101,
+		0xC78, 0xE4563101,
+		0xC78, 0xE3573101,
+		0xC78, 0xE2583101,
+		0xC78, 0xE1593101,
+		0xC78, 0xE05A3101,
+		0xC78, 0xC25B3101,
+		0xC78, 0xC15C3101,
+		0xC78, 0xC05D3101,
+		0xC78, 0x825E3101,
+		0xC78, 0x815F3101,
+		0xC78, 0x80603101,
+		0xC78, 0x80613101,
+		0xC78, 0x80623101,
+		0xC78, 0x80633101,
+		0xC78, 0x80643101,
+		0xC78, 0x80653101,
+		0xC78, 0x80663101,
+		0xC78, 0x80673101,
+		0xC78, 0x80683101,
+		0xC78, 0x80693101,
+		0xC78, 0x806A3101,
+		0xC78, 0x806B3101,
+		0xC78, 0x806C3101,
+		0xC78, 0x806D3101,
+		0xC78, 0x806E3101,
+		0xC78, 0x806F3101,
+		0xC78, 0x80703101,
+		0xC78, 0x80713101,
+		0xC78, 0x80723101,
+		0xC78, 0x80733101,
+		0xC78, 0x80743101,
+		0xC78, 0x80753101,
+		0xC78, 0x80763101,
+		0xC78, 0x80773101,
+		0xC78, 0x80783101,
+		0xC78, 0x80793101,
+		0xC78, 0x807A3101,
+		0xC78, 0x807B3101,
+		0xC78, 0x807C3101,
+		0xC78, 0x807D3101,
+		0xC78, 0x807E3101,
+		0xC78, 0x807F3101,
+		0xC78, 0xFF402001,
+		0xC78, 0xFF412001,
+		0xC78, 0xFF422001,
+		0xC78, 0xFF432001,
+		0xC78, 0xFF442001,
+		0xC78, 0xFF452001,
+		0xC78, 0xFF462001,
+		0xC78, 0xFF472001,
+		0xC78, 0xFF482001,
+		0xC78, 0xFF492001,
+		0xC78, 0xFF4A2001,
+		0xC78, 0xFF4B2001,
+		0xC78, 0xFF4C2001,
+		0xC78, 0xFE4D2001,
+		0xC78, 0xFD4E2001,
+		0xC78, 0xFC4F2001,
+		0xC78, 0xFB502001,
+		0xC78, 0xFA512001,
+		0xC78, 0xF9522001,
+		0xC78, 0xF8532001,
+		0xC78, 0xF7542001,
+		0xC78, 0xF6552001,
+		0xC78, 0xF5562001,
+		0xC78, 0xF4572001,
+		0xC78, 0xF3582001,
+		0xC78, 0xF2592001,
+		0xC78, 0xF15A2001,
+		0xC78, 0xF05B2001,
+		0xC78, 0xEF5C2001,
+		0xC78, 0xEE5D2001,
+		0xC78, 0xED5E2001,
+		0xC78, 0xEC5F2001,
+		0xC78, 0xEB602001,
+		0xC78, 0xEA612001,
+		0xC78, 0xE9622001,
+		0xC78, 0xE8632001,
+		0xC78, 0xE7642001,
+		0xC78, 0xE6652001,
+		0xC78, 0xE5662001,
+		0xC78, 0xE4672001,
+		0xC78, 0xE3682001,
+		0xC78, 0xC5692001,
+		0xC78, 0xC46A2001,
+		0xC78, 0xC36B2001,
+		0xC78, 0xA46C2001,
+		0xC78, 0x846D2001,
+		0xC78, 0x836E2001,
+		0xC78, 0x826F2001,
+		0xC78, 0x81702001,
+		0xC78, 0x80712001,
+		0xC78, 0x80722001,
+		0xC78, 0x80732001,
+		0xC78, 0x80742001,
+		0xC78, 0x80752001,
+		0xC78, 0x80762001,
+		0xC78, 0x80772001,
+		0xC78, 0x80782001,
+		0xC78, 0x80792001,
+		0xC78, 0x807A2001,
+		0xC78, 0x807B2001,
+		0xC78, 0x807C2001,
+		0xC78, 0x807D2001,
+		0xC78, 0x807E2001,
+		0xC78, 0x807F2001,
+		0xC50, 0x69553422,
+		0xC50, 0x69553420,
+
+};
+
+void
+ODM_ReadAndConfig_MP_8703B_AGC_TAB(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+	u4Byte     i         = 0;
+	u1Byte     cCond;
+	BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+	u4Byte     ArrayLen    = sizeof(Array_MP_8703B_AGC_TAB)/sizeof(u4Byte);
+	pu4Byte    Array       = Array_MP_8703B_AGC_TAB;
+	
+	u4Byte	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8703B_AGC_TAB\n"));
+
+	while ((i + 1) < ArrayLen) {
+		v1 = Array[i];
+		v2 = Array[i + 1];
+
+		if (v1 & (BIT31 | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT31) {/* positive condition*/
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if (cCond == COND_ENDIF) {/*end*/
+					bMatched = TRUE;
+					bSkipped = FALSE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ENDIF\n"));
+				} else if (cCond == COND_ELSE) { /*else*/
+					bMatched = bSkipped?FALSE:TRUE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ELSE\n"));
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("IF or ELSE IF\n"));
+				}
+			} else if (v1 & BIT30) { /*negative condition*/
+				if (bSkipped == FALSE) {
+					if (CheckPositive(pDM_Odm, pre_v1, pre_v2, v1, v2)) {
+						bMatched = TRUE;
+						bSkipped = TRUE;
+					} else {
+						bMatched = FALSE;
+						bSkipped = FALSE;
+					}
+				} else
+					bMatched = FALSE;
+			}
+		} else {
+			if (bMatched)
+				odm_ConfigBB_AGC_8703B(pDM_Odm, v1, bMaskDWord, v2);
+		}
+		i = i + 2;
+	}
+}
+
+u4Byte
+ODM_GetVersion_MP_8703B_AGC_TAB(void)
+{
+	   return 17;
+}
+
+/******************************************************************************
+*                           PHY_REG.TXT
+******************************************************************************/
+
+u4Byte Array_MP_8703B_PHY_REG[] = { 
+		0x800, 0x83045700,
+		0x804, 0x00000003,
+		0x808, 0x0000FC00,
+		0x80C, 0x0000000A,
+		0x810, 0x10001331,
+		0x814, 0x020C3D10,
+		0x818, 0x02200385,
+		0x81C, 0x00000000,
+		0x820, 0x01000100,
+		0x824, 0x00390204,
+		0x828, 0x00000000,
+		0x82C, 0x00000000,
+		0x830, 0x00000000,
+		0x834, 0x00000000,
+		0x838, 0x00000000,
+		0x83C, 0x00000000,
+		0x840, 0x00010000,
+		0x844, 0x00000000,
+		0x848, 0x00000000,
+		0x84C, 0x00000000,
+		0x850, 0x00000000,
+		0x854, 0x00000000,
+		0x858, 0x569A11A9,
+		0x85C, 0x01000014,
+		0x860, 0x66F60110,
+		0x864, 0x061F0649,
+		0x868, 0x00000000,
+		0x86C, 0x27272700,
+		0x870, 0x07000760,
+		0x874, 0x25004000,
+		0x878, 0x00000808,
+		0x87C, 0x004F0201,
+		0x880, 0xB0000B1E,
+		0x884, 0x00000001,
+		0x888, 0x00000000,
+		0x88C, 0xCCC000C0,
+		0x890, 0x00000800,
+		0x894, 0xFFFFFFFE,
+		0x898, 0x40302010,
+		0x89C, 0x00706050,
+		0x900, 0x00000000,
+		0x904, 0x00000023,
+		0x908, 0x00000000,
+		0x90C, 0x81121111,
+		0x910, 0x00000002,
+		0x914, 0x00000201,
+		0x948, 0x99000000,
+		0x94C, 0x00000010,
+		0x950, 0x20003800,
+		0x954, 0x4A880000,
+		0x958, 0x4BC5D87A,
+		0x95C, 0x04EB9B79,
+		0xA00, 0x00D047C8,
+		0xA04, 0x80FF800C,
+		0xA08, 0x8C838300,
+		0xA0C, 0x2E7F120F,
+		0xA10, 0x9500BB78,
+		0xA14, 0x1114D028,
+		0xA18, 0x00881117,
+		0xA1C, 0x89140F00,
+		0xA20, 0xD1D80000,
+		0xA24, 0x5A7DA0BD,
+		0xA28, 0x0000223B,
+		0xA2C, 0x00D30000,
+		0xA70, 0x101FBF00,
+		0xA74, 0x00000007,
+		0xA78, 0x00008900,
+		0xA7C, 0x225B0606,
+		0xA80, 0x2180FA74,
+		0xA84, 0x00120000,
+		0xA88, 0x040C0000,
+		0xA8C, 0x12345678,
+		0xA90, 0xABCDEF00,
+		0xA94, 0x001B1B89,
+		0xA98, 0x05100000,
+		0xA9C, 0x3F000000,
+		0xAA0, 0x00000000,
+		0xB2C, 0x00000000,
+		0xC00, 0x48071D40,
+		0xC04, 0x03A05611,
+		0xC08, 0x000000E4,
+		0xC0C, 0x6C6C6C6C,
+		0xC10, 0x18800000,
+		0xC14, 0x40000100,
+		0xC18, 0x08800000,
+		0xC1C, 0x40000100,
+		0xC20, 0x00000000,
+		0xC24, 0x00000000,
+		0xC28, 0x00000000,
+		0xC2C, 0x00000000,
+		0xC30, 0x69E9AC4B,
+		0xC34, 0x31000040,
+		0xC38, 0x21688080,
+		0xC3C, 0x000016CC,
+		0xC40, 0x1F78403F,
+		0xC44, 0x00010036,
+		0xC48, 0xEC020107,
+		0xC4C, 0x007F037F,
+		0xC50, 0x69553420,
+		0xC54, 0x43BC0094,
+		0xC58, 0x00015967,
+		0xC5C, 0x18250492,
+		0xC60, 0x00000000,
+		0xC64, 0x7112848B,
+		0xC68, 0x47C07BFF,
+		0xC6C, 0x00000036,
+		0xC70, 0x2C7F000D,
+		0xC74, 0x020600DB,
+		0xC78, 0x0000001F,
+		0xC7C, 0x00B91612,
+		0xC80, 0x390000E4,
+		0xC84, 0x19F60000,
+		0xC88, 0x40000100,
+		0xC8C, 0x20200000,
+		0xC90, 0x00091521,
+		0xC94, 0x00000000,
+		0xC98, 0x00121820,
+		0xC9C, 0x00007F7F,
+		0xCA0, 0x00000000,
+		0xCA4, 0x000300A0,
+		0xCA8, 0x00000000,
+		0xCAC, 0x00000000,
+		0xCB0, 0x00000000,
+		0xCB4, 0x00000000,
+		0xCB8, 0x00000000,
+		0xCBC, 0x28000000,
+		0xCC0, 0x00000000,
+		0xCC4, 0x00000000,
+		0xCC8, 0x00000000,
+		0xCCC, 0x00000000,
+		0xCD0, 0x00000000,
+		0xCD4, 0x00000000,
+		0xCD8, 0x64B22427,
+		0xCDC, 0x00766932,
+		0xCE0, 0x00222222,
+		0xCE4, 0x10000000,
+		0xCE8, 0x37644302,
+		0xCEC, 0x2F97D40C,
+		0xD00, 0x00030740,
+		0xD04, 0x40020401,
+		0xD08, 0x0000907F,
+		0xD0C, 0x20010201,
+		0xD10, 0xA0633333,
+		0xD14, 0x3333BC53,
+		0xD18, 0x7A8F5B6F,
+		0xD2C, 0xCB979975,
+		0xD30, 0x00000000,
+		0xD34, 0x80608000,
+		0xD38, 0x98000000,
+		0xD3C, 0x40127353,
+		0xD40, 0x00000000,
+		0xD44, 0x00000000,
+		0xD48, 0x00000000,
+		0xD4C, 0x00000000,
+		0xD50, 0x6437140A,
+		0xD54, 0x00000000,
+		0xD58, 0x00000282,
+		0xD5C, 0x30032064,
+		0xD60, 0x4653DE68,
+		0xD64, 0x04518A3C,
+		0xD68, 0x00002101,
+		0xE00, 0x2D2D2D2D,
+		0xE04, 0x2D2D2D2D,
+		0xE08, 0x0390272D,
+		0xE10, 0x2D2D2D2D,
+		0xE14, 0x2D2D2D2D,
+		0xE18, 0x2D2D2D2D,
+		0xE1C, 0x2D2D2D2D,
+		0xE28, 0x00000000,
+		0xE30, 0x1000DC1F,
+		0xE34, 0x10008C1F,
+		0xE38, 0x02140102,
+		0xE3C, 0x681604C2,
+		0xE40, 0x01007C00,
+		0xE44, 0x01004800,
+		0xE48, 0xFB000000,
+		0xE4C, 0x000028D1,
+		0xE50, 0x1000DC1F,
+		0xE54, 0x10008C1F,
+		0xE58, 0x02140102,
+		0xE5C, 0x28160D05,
+		0xE60, 0x00000048,
+		0xE68, 0x001B25A4,
+		0xE6C, 0x01C00014,
+		0xE70, 0x01C00014,
+		0xE74, 0x02000014,
+		0xE78, 0x02000014,
+		0xE7C, 0x02000014,
+		0xE80, 0x02000014,
+		0xE84, 0x01C00014,
+		0xE88, 0x02000014,
+		0xE8C, 0x01C00014,
+		0xED0, 0x01C00014,
+		0xED4, 0x01C00014,
+		0xED8, 0x01C00014,
+		0xEDC, 0x00000014,
+		0xEE0, 0x00000014,
+		0xEE8, 0x21555448,
+		0xEEC, 0x03C00014,
+		0xF14, 0x00000003,
+		0xF4C, 0x00000000,
+		0xF00, 0x00000300,
+
+};
+
+void
+ODM_ReadAndConfig_MP_8703B_PHY_REG(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+	u4Byte     i         = 0;
+	u1Byte     cCond;
+	BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+	u4Byte     ArrayLen    = sizeof(Array_MP_8703B_PHY_REG)/sizeof(u4Byte);
+	pu4Byte    Array       = Array_MP_8703B_PHY_REG;
+	
+	u4Byte	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8703B_PHY_REG\n"));
+
+	while ((i + 1) < ArrayLen) {
+		v1 = Array[i];
+		v2 = Array[i + 1];
+
+		if (v1 & (BIT31 | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT31) {/* positive condition*/
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if (cCond == COND_ENDIF) {/*end*/
+					bMatched = TRUE;
+					bSkipped = FALSE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ENDIF\n"));
+				} else if (cCond == COND_ELSE) { /*else*/
+					bMatched = bSkipped?FALSE:TRUE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ELSE\n"));
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("IF or ELSE IF\n"));
+				}
+			} else if (v1 & BIT30) { /*negative condition*/
+				if (bSkipped == FALSE) {
+					if (CheckPositive(pDM_Odm, pre_v1, pre_v2, v1, v2)) {
+						bMatched = TRUE;
+						bSkipped = TRUE;
+					} else {
+						bMatched = FALSE;
+						bSkipped = FALSE;
+					}
+				} else
+					bMatched = FALSE;
+			}
+		} else {
+			if (bMatched)
+				odm_ConfigBB_PHY_8703B(pDM_Odm, v1, bMaskDWord, v2);
+		}
+		i = i + 2;
+	}
+}
+
+u4Byte
+ODM_GetVersion_MP_8703B_PHY_REG(void)
+{
+	   return 17;
+}
+
+/******************************************************************************
+*                           PHY_REG_PG.TXT
+******************************************************************************/
+
+u4Byte Array_MP_8703B_PHY_REG_PG[] = { 
+	0, 0, 0, 0x00000e08, 0x0000ff00, 0x00003200,
+	0, 0, 0, 0x0000086c, 0xffffff00, 0x32323200,
+	0, 0, 0, 0x00000e00, 0xffffffff, 0x34363636,
+	0, 0, 0, 0x00000e04, 0xffffffff, 0x28303234,
+	0, 0, 0, 0x00000e10, 0xffffffff, 0x30343434,
+	0, 0, 0, 0x00000e14, 0xffffffff, 0x26262830
+};
+
+void
+ODM_ReadAndConfig_MP_8703B_PHY_REG_PG(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+	u4Byte     i         = 0;
+	u4Byte     ArrayLen    = sizeof(Array_MP_8703B_PHY_REG_PG)/sizeof(u4Byte);
+	pu4Byte    Array       = Array_MP_8703B_PHY_REG_PG;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	PlatformZeroMemory(pHalData->BufOfLinesPwrByRate, MAX_LINES_HWCONFIG_TXT*MAX_BYTES_LINE_HWCONFIG_TXT);
+	pHalData->nLinesReadPwrByRate = ArrayLen/6;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8703B_PHY_REG_PG\n"));
+
+	pDM_Odm->PhyRegPgVersion = 1;
+	pDM_Odm->PhyRegPgValueType = PHY_REG_PG_EXACT_VALUE;
+
+	for (i = 0; i < ArrayLen; i += 6) {
+		u4Byte v1 = Array[i];
+		u4Byte v2 = Array[i+1];
+		u4Byte v3 = Array[i+2];
+		u4Byte v4 = Array[i+3];
+		u4Byte v5 = Array[i+4];
+		u4Byte v6 = Array[i+5];
+
+	    odm_ConfigBB_PHY_REG_PG_8703B(pDM_Odm, v1, v2, v3, v4, v5, v6);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	rsprintf((char *)pHalData->BufOfLinesPwrByRate[i/6], 100, "%s, %s, %s, 0x%X, 0x%08X, 0x%08X,",
+		(v1 == 0?"2.4G":"  5G"), (v2 == 0?"A":"B"), (v3 == 0?"1Tx":"2Tx"), v4, v5, v6);
+#endif
+	}
+}
+
+
+
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.h
new file mode 100644
index 000000000..1e616b62d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_bb.h
@@ -0,0 +1,59 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#if (RTL8703B_SUPPORT == 1)
+#ifndef __INC_MP_BB_HW_IMG_8703B_H
+#define __INC_MP_BB_HW_IMG_8703B_H
+
+
+/******************************************************************************
+*                           AGC_TAB.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_AGC_TAB(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_AGC_TAB(void);
+
+/******************************************************************************
+*                           PHY_REG.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_PHY_REG(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_PHY_REG(void);
+
+/******************************************************************************
+*                           PHY_REG_PG.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_PHY_REG_PG(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_PHY_REG_PG(void);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.c
new file mode 100644
index 000000000..54e850a67
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.c
@@ -0,0 +1,3980 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.16*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8703B_SUPPORT == 1)
+#if (defined(CONFIG_AP_WOWLAN) || (DM_ODM_SUPPORT_TYPE & (ODM_AP)))
+
+
+u1Byte Array_MP_8703B_FW_AP[] = {
+0xB2, 0x03, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x26, 0x17, 0x21, 0xF4, 0x49, 0x02, 0x00, 
+0x4F, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x86, 0xAD, 0x02, 0xB8, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xAE, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB8, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB8, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xAC, 0xC7, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB8, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x87, 0xB8, 0x02, 0x88, 0xFC, 0x02, 0x80, 0x86, 0x02, 0x80, 0x89, 0x02, 0x80, 0x8C, 0x02, 
+0xA2, 0x2A, 0x02, 0xAB, 0xC9, 0x02, 0x80, 0x95, 0x02, 0x80, 0x98, 0x02, 0x80, 0x9B, 0x02, 0x80, 
+0x9E, 0x02, 0x80, 0xA1, 0x02, 0x80, 0xA4, 0x02, 0x80, 0xA7, 0x02, 0x80, 0xAA, 0x02, 0x80, 0xAD, 
+0x02, 0x80, 0xB0, 0x02, 0x8C, 0x7C, 0x02, 0x80, 0xB6, 0x02, 0x80, 0xB9, 0x02, 0x80, 0xBC, 0x02, 
+0x80, 0xBF, 0x02, 0x80, 0xC2, 0x02, 0x80, 0xC5, 0x02, 0x80, 0xC8, 0x02, 0x80, 0xCB, 0x02, 0x80, 
+0xCE, 0x02, 0x80, 0xD1, 0x02, 0xC8, 0x25, 0x02, 0x80, 0xD7, 0x02, 0x80, 0xDA, 0x02, 0x80, 0xDD, 
+0x02, 0x80, 0xE0, 0x02, 0x80, 0xE3, 0x02, 0x80, 0xE6, 0x02, 0x80, 0xE9, 0x02, 0x80, 0xEC, 0x00, 
+0x00, 0x00, 0x02, 0x80, 0xF2, 0x00, 0x00, 0x00, 0x02, 0x80, 0xF8, 0x02, 0x80, 0xFB, 0x02, 0x80, 
+0xFE, 0x02, 0x81, 0x01, 0x02, 0x81, 0x04, 0x02, 0x81, 0x07, 0x02, 0x81, 0x0A, 0x02, 0x81, 0x0D, 
+0x02, 0x81, 0x10, 0x02, 0x81, 0x13, 0x02, 0x81, 0x16, 0x02, 0x81, 0x19, 0x02, 0x81, 0x1C, 0x02, 
+0xC8, 0x1F, 0x02, 0x81, 0x22, 0x02, 0x81, 0x25, 0x02, 0x81, 0x28, 0x02, 0x81, 0x2B, 0x02, 0x81, 
+0x2E, 0x02, 0x81, 0x31, 0x02, 0x96, 0x70, 0x02, 0x94, 0x77, 0x02, 0x95, 0x0A, 0x02, 0x91, 0x89, 
+0x02, 0xBF, 0x75, 0x02, 0xA3, 0x88, 0x02, 0xC8, 0x79, 0x02, 0x81, 0x49, 0x02, 0x81, 0x4C, 0x02, 
+0x81, 0x4F, 0x02, 0x81, 0x52, 0x02, 0x81, 0x55, 0x02, 0x81, 0x58, 0x02, 0x81, 0x5B, 0x02, 0x91, 
+0x94, 0x02, 0x81, 0x61, 0x02, 0x81, 0x64, 0x02, 0xC6, 0x93, 0x02, 0x81, 0x6A, 0x02, 0x81, 0x6D, 
+0x02, 0x81, 0x70, 0x02, 0x95, 0x68, 0x02, 0x93, 0x2E, 0x02, 0xBC, 0x29, 0x00, 0x00, 0x00, 0x00, 
+0x15, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 
+0xFF, 0x0F, 0x00, 0x00, 0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 
+0x00, 0x00, 0x00, 0x10, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 
+0x08, 0x03, 0x03, 0x00, 0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 0x02, 0x00, 
+0x04, 0x08, 0x05, 0x03, 0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 0x0A, 0x07, 
+0x04, 0x00, 0x08, 0x0B, 0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 0x08, 0x0B, 
+0x0A, 0x03, 0x02, 0x00, 0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 0x04, 0x00, 
+0x10, 0x24, 0x22, 0x1C, 0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 0x22, 0x14, 
+0x06, 0x00, 0x20, 0x24, 0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 0x20, 0x23, 
+0x21, 0x0C, 0x04, 0x00, 0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 0x04, 0x00, 
+0x20, 0x21, 0x1F, 0x16, 0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 0x2F, 0x18, 
+0x10, 0x00, 0x30, 0x31, 0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 0x30, 0x31, 
+0x28, 0x14, 0x00, 0x00, 0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 0x00, 0x00, 
+0x30, 0x04, 0x04, 0x04, 0x05, 0x08, 0x08, 0x09, 0x09, 0x0C, 0x0E, 0x10, 0x12, 0x06, 0x0B, 0x0D, 
+0x0E, 0x0F, 0x11, 0x12, 0x14, 0x00, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x23, 0x00, 
+0x2D, 0x00, 0x50, 0x00, 0x91, 0x00, 0xC3, 0x01, 0x27, 0x01, 0x31, 0x01, 0x5E, 0x00, 0xC8, 0x00, 
+0xF0, 0x00, 0xDC, 0x01, 0x5E, 0x01, 0x68, 0x01, 0x9A, 0x01, 0xCC, 0x01, 0xEA, 0x02, 0x02, 0x04, 
+0x08, 0x0C, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x14, 0x28, 0x32, 0x50, 0x78, 0xA0, 0xC8, 
+0xE6, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x02, 0x04, 0x06, 
+0x07, 0x07, 0x08, 0x08, 0x08, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
+0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
+0x02, 0x03, 0x03, 0x04, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x03, 0x03, 0x03, 
+0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
+0x02, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x84, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x87, 0xB2, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x87, 0xB2, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x84, 0x4D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x84, 0x4C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x84, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x86, 0xEB, 
+0x02, 0x84, 0xDD, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 
+0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 
+0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 
+0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x87, 0x9B, 0xE4, 0x7E, 
+0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 
+0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 
+0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 
+0xEF, 0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 0xED, 0x39, 0xFD, 0xEC, 0x38, 0xFC, 0x22, 0xEF, 0x5B, 0xFF, 
+0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 
+0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 
+0xE0, 0xFB, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 
+0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 
+0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 
+0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0x41, 0x91, 0x1B, 0x00, 0x44, 
+0x8F, 0xFB, 0x41, 0x4E, 0x59, 0x00, 0x44, 0x8F, 0xF7, 0x61, 0x6E, 0x79, 0x00, 0x41, 0x91, 0x1D, 
+0x00, 0x00, 0xB2, 0x4C, 0xB6, 0x87, 0x9F, 0x04, 0x90, 0x8F, 0xFF, 0xEF, 0xF0, 0x7F, 0x02, 0xD1, 
+0x27, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 0x90, 0x8F, 0xFF, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x89, 0x7E, 
+0xF0, 0x22, 0xE4, 0x90, 0x90, 0xDA, 0xF0, 0x90, 0x90, 0xD8, 0x74, 0x14, 0xF0, 0x90, 0x90, 0xE6, 
+0x74, 0x01, 0xF0, 0xFB, 0xF1, 0xE8, 0x80, 0xD0, 0x7A, 0x90, 0x79, 0xD8, 0x12, 0x5A, 0x18, 0x7F, 
+0x04, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xF5, 0x5D, 0x12, 0x02, 0x06, 0x25, 0x5D, 0x90, 0x89, 0x83, 
+0xF1, 0x5E, 0x25, 0x5D, 0x90, 0x89, 0x84, 0xB1, 0xEA, 0x25, 0x5D, 0x90, 0x89, 0x85, 0x11, 0x37, 
+0x25, 0x5D, 0x90, 0x89, 0x86, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x02, 0x1F, 0x25, 0x5D, 0x90, 0x89, 
+0x87, 0x12, 0xA1, 0xE8, 0x25, 0x5D, 0x90, 0x89, 0x88, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x02, 0x1F, 
+0x25, 0x5D, 0x90, 0x89, 0x89, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x03, 0x02, 0x02, 0x1F, 0x51, 0x36, 
+0x12, 0x02, 0x06, 0xFE, 0x24, 0x33, 0x91, 0x74, 0xE0, 0x54, 0x98, 0x91, 0x70, 0xC0, 0x83, 0xC0, 
+0x82, 0xE0, 0xFF, 0x51, 0x3C, 0x11, 0x38, 0x54, 0x01, 0xFD, 0xEF, 0x4D, 0xD0, 0x82, 0xD0, 0x83, 
+0x91, 0x70, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x3C, 0x11, 0x38, 0x54, 0x02, 0xFD, 0xEF, 
+0x4D, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x70, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x3C, 0x11, 
+0x38, 0x54, 0x04, 0xFD, 0xEF, 0x4D, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x70, 0xC0, 0x83, 0xC0, 0x82, 
+0xE0, 0xFF, 0x51, 0x3C, 0x11, 0x38, 0x54, 0x40, 0xFD, 0xEF, 0x4D, 0xD0, 0x82, 0xD0, 0x83, 0x91, 
+0x70, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x3C, 0x11, 0x38, 0x54, 0x20, 0xFD, 0xEF, 0x4D, 
+0xD0, 0x82, 0xD0, 0x83, 0x11, 0x37, 0x7F, 0x00, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x90, 0x8F, 0xC4, 
+0xEF, 0xF0, 0xEE, 0xC3, 0x94, 0x10, 0x50, 0x0C, 0x51, 0x3C, 0xB1, 0xEB, 0xFF, 0x12, 0xC9, 0xCE, 
+0xEF, 0xF0, 0x80, 0x0C, 0xEE, 0xB4, 0x10, 0x08, 0x51, 0x3C, 0xB1, 0xEB, 0x90, 0x8D, 0x02, 0xF0, 
+0x91, 0x71, 0xE0, 0x30, 0xE5, 0x15, 0x75, 0xF0, 0x12, 0xEE, 0xB1, 0xF6, 0x13, 0x13, 0x54, 0x03, 
+0xFB, 0xAF, 0x06, 0x12, 0xC9, 0xCE, 0xE0, 0xFD, 0x12, 0x6A, 0xFD, 0x22, 0x90, 0x90, 0x02, 0x12, 
+0x87, 0x6C, 0x90, 0x90, 0x01, 0xEF, 0xF0, 0x12, 0x87, 0x75, 0x89, 0x7A, 0x00, 0x89, 0x7F, 0x01, 
+0x89, 0x84, 0x08, 0x89, 0x89, 0x09, 0x89, 0x8E, 0x0A, 0x89, 0x93, 0x12, 0x89, 0x98, 0x13, 0x89, 
+0x9C, 0x14, 0x89, 0xA1, 0x20, 0x89, 0xA6, 0x25, 0x89, 0xAB, 0x26, 0x89, 0xB0, 0x40, 0x89, 0xB4, 
+0x42, 0x89, 0xB8, 0x43, 0x89, 0xBD, 0x44, 0x8A, 0x2F, 0x47, 0x8A, 0x2F, 0x49, 0x89, 0xC2, 0x60, 
+0x89, 0xC6, 0x61, 0x89, 0xCB, 0x62, 0x89, 0xD0, 0x63, 0x89, 0xD5, 0x64, 0x89, 0xDA, 0x65, 0x89, 
+0xDF, 0x66, 0x89, 0xE4, 0x67, 0x89, 0xE9, 0x68, 0x89, 0xEE, 0x69, 0x89, 0xF3, 0x6B, 0x89, 0xF8, 
+0x6C, 0x89, 0xFD, 0x6D, 0x8A, 0x02, 0x6E, 0x8A, 0x07, 0x6F, 0x8A, 0x0C, 0x70, 0x8A, 0x11, 0xC2, 
+0x8A, 0x16, 0xC3, 0x8A, 0x1B, 0xC4, 0x00, 0x00, 0x8A, 0x20, 0x51, 0x30, 0x02, 0x87, 0xF2, 0x51, 
+0x30, 0x02, 0x90, 0xA1, 0x51, 0x30, 0x02, 0x97, 0xF8, 0x51, 0x30, 0x02, 0x9F, 0xFA, 0x51, 0x30, 
+0x02, 0xA0, 0x13, 0x51, 0x30, 0x02, 0xA0, 0x21, 0x51, 0x30, 0xE1, 0x70, 0x51, 0x30, 0x02, 0xA0, 
+0xEB, 0x51, 0x30, 0x02, 0xA0, 0xFA, 0x51, 0x30, 0x02, 0xA7, 0xF3, 0x51, 0x30, 0x02, 0xA8, 0x2D, 
+0x51, 0x30, 0x81, 0x7C, 0x51, 0x30, 0x01, 0x3E, 0x51, 0x30, 0x02, 0x24, 0xE8, 0x51, 0x30, 0x02, 
+0x5F, 0xFA, 0x51, 0x30, 0x80, 0x7C, 0x51, 0x30, 0x02, 0x79, 0x0F, 0x51, 0x30, 0x02, 0x7B, 0xBB, 
+0x51, 0x30, 0x02, 0x7A, 0x6A, 0x51, 0x30, 0x02, 0x60, 0x68, 0x51, 0x30, 0x02, 0x7B, 0x1C, 0x51, 
+0x30, 0x02, 0x72, 0xF1, 0x51, 0x30, 0x02, 0x4E, 0xA5, 0x51, 0x30, 0x02, 0x78, 0xB2, 0x51, 0x30, 
+0x02, 0x43, 0x1E, 0x51, 0x30, 0x02, 0x98, 0xE5, 0x51, 0x30, 0x02, 0x78, 0x32, 0x51, 0x30, 0x02, 
+0x5C, 0xE4, 0x51, 0x30, 0x02, 0x74, 0x98, 0x51, 0x30, 0x02, 0x77, 0x58, 0x51, 0x30, 0x02, 0x62, 
+0x0D, 0x51, 0x30, 0x02, 0xAF, 0xF0, 0x51, 0x30, 0x02, 0xAF, 0xF8, 0x51, 0x30, 0x02, 0xB6, 0x70, 
+0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x90, 0x01, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 
+0x90, 0x90, 0x02, 0x02, 0x87, 0x63, 0x90, 0x90, 0x05, 0x12, 0x87, 0x6C, 0x90, 0x90, 0x05, 0x02, 
+0x87, 0x63, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x51, 0x36, 0x12, 0xA0, 0x09, 0x7B, 0x01, 
+0x7A, 0x8A, 0x79, 0xEA, 0x12, 0x68, 0xAB, 0x51, 0x3C, 0x12, 0x02, 0x06, 0x20, 0xE0, 0x02, 0x61, 
+0xCD, 0x90, 0x05, 0x54, 0xE0, 0x90, 0x8A, 0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 0xFA, 0xF0, 
+0x90, 0x8A, 0xED, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x13, 0xF1, 0x5F, 0x90, 0x8A, 0xEB, 0xF0, 
+0x24, 0x0A, 0x90, 0x8B, 0x1C, 0xB1, 0xEA, 0x90, 0x8A, 0xEC, 0xF0, 0x80, 0x48, 0xF1, 0x5F, 0xFF, 
+0xC3, 0x94, 0x2A, 0x50, 0x14, 0xEF, 0xC3, 0x94, 0x03, 0x50, 0x07, 0x90, 0x8A, 0xEB, 0x74, 0x03, 
+0x80, 0x0C, 0xF1, 0x5F, 0x90, 0x8A, 0xEB, 0x80, 0x05, 0x90, 0x8A, 0xEB, 0x74, 0x2A, 0xF0, 0x24, 
+0x0A, 0x90, 0x8B, 0x1C, 0xF0, 0xB1, 0xEB, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x12, 0xEF, 0xC3, 0x94, 
+0x03, 0x90, 0x8A, 0xEC, 0x50, 0x05, 0x74, 0x03, 0xF0, 0x80, 0x0A, 0xEF, 0xF0, 0x80, 0x06, 0x90, 
+0x8A, 0xEC, 0x74, 0x2A, 0xF0, 0x12, 0x93, 0x1F, 0x30, 0xE0, 0x3D, 0x90, 0x8A, 0xEB, 0xE0, 0x75, 
+0xF0, 0x03, 0x84, 0x90, 0x8A, 0xF3, 0xF0, 0xE0, 0xC3, 0x13, 0xA3, 0xF0, 0x90, 0x8A, 0xEC, 0xE0, 
+0x75, 0xF0, 0x03, 0x84, 0x90, 0x8A, 0xF5, 0xF0, 0x90, 0x8A, 0xEB, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 
+0xF6, 0xF0, 0x90, 0x8A, 0xEC, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 0xF7, 0xF0, 0x90, 0x01, 0x3E, 0x74, 
+0x08, 0xF0, 0xFD, 0x7F, 0x02, 0x12, 0x7B, 0x2A, 0xE4, 0x90, 0x8B, 0x2A, 0xF0, 0x51, 0x3C, 0x11, 
+0x38, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x37, 0x90, 0x8A, 0xEA, 0xE0, 0xC3, 0x13, 0x20, 
+0xE0, 0x06, 0xE0, 0xF1, 0x69, 0x30, 0xE0, 0x28, 0x12, 0x02, 0x06, 0x13, 0x13, 0x13, 0x54, 0x1F, 
+0x30, 0xE0, 0x08, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x08, 0x80, 0x0B, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 
+0x05, 0x75, 0x5D, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x5D, 0x7D, 0x02, 0xAF, 0x5D, 0x12, 0x93, 0x2E, 
+0x90, 0x8A, 0xEA, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x1C, 0x90, 0x8A, 0xEE, 0xE0, 0xC4, 0x13, 
+0x54, 0x07, 0x30, 0xE0, 0x07, 0x7D, 0x04, 0x7F, 0x02, 0x12, 0x53, 0xDB, 0x90, 0x05, 0x00, 0x74, 
+0x1C, 0xF0, 0xA3, 0x74, 0x11, 0xF0, 0x90, 0x05, 0x58, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0xF2, 0xE0, 
+0xB4, 0x01, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x01, 0xF0, 0x80, 0x2B, 0x90, 0x8A, 0xF2, 0xE0, 0xB4, 
+0x04, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x04, 0xF0, 0x80, 0x1C, 0x90, 0x8A, 0xF2, 0xE0, 0xB4, 0x06, 
+0x08, 0x90, 0x8A, 0xFD, 0x74, 0x02, 0xF0, 0x80, 0x0D, 0x90, 0x8A, 0xF2, 0xE0, 0xB4, 0x07, 0x06, 
+0x90, 0x8A, 0xFD, 0x74, 0x05, 0xF0, 0xE4, 0x90, 0x8A, 0xF2, 0xF0, 0x80, 0x61, 0x51, 0x3C, 0x11, 
+0x38, 0x12, 0xA1, 0xEF, 0x30, 0xE0, 0x05, 0x75, 0x5E, 0x02, 0x80, 0x14, 0x12, 0x02, 0x06, 0xFF, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x05, 0x75, 0x5E, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x5E, 
+0x12, 0x78, 0x72, 0x90, 0x8B, 0x51, 0xE0, 0x30, 0xE0, 0x04, 0x7D, 0xAC, 0x80, 0x02, 0x7D, 0x2C, 
+0x7F, 0x40, 0x12, 0x7A, 0xA5, 0x51, 0x3C, 0x11, 0x38, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 
+0x04, 0x7F, 0x03, 0x80, 0x02, 0x7F, 0x01, 0x12, 0x71, 0x29, 0xAD, 0x5E, 0x7F, 0x02, 0x12, 0x93, 
+0x2E, 0x12, 0x91, 0x86, 0x90, 0x05, 0x00, 0x74, 0x1C, 0xF0, 0xA3, 0x74, 0x43, 0xF0, 0x90, 0x8A, 
+0xF0, 0xE0, 0x54, 0xDF, 0xF0, 0xE4, 0x90, 0x8A, 0xFC, 0xF0, 0x90, 0x8A, 0xED, 0xE0, 0xF1, 0x69, 
+0x30, 0xE0, 0x09, 0x90, 0x8B, 0x1D, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x0C, 0x7F, 0x01, 0x12, 0x71, 
+0x63, 0x90, 0x8B, 0x1D, 0xE0, 0x54, 0xFD, 0xF0, 0x7F, 0x03, 0x12, 0x5C, 0x6F, 0x90, 0x8A, 0xEA, 
+0xE0, 0x20, 0xE0, 0x07, 0x90, 0x8A, 0xEE, 0xE0, 0x54, 0xBF, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xF0, 0x74, 0x33, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0x51, 0x36, 0x12, 0x02, 
+0x06, 0x54, 0x7F, 0xFD, 0xF1, 0x5F, 0xFE, 0x54, 0x1F, 0x90, 0x90, 0x09, 0xF1, 0x65, 0x90, 0x90, 
+0x08, 0xB1, 0xEA, 0xFE, 0x54, 0x03, 0xFC, 0xEE, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0x90, 0x90, 0x0B, 
+0xB1, 0xEA, 0xFE, 0x54, 0x40, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x90, 0x90, 0x0A, 0xF1, 0x65, 0xFF, 
+0xB1, 0xEB, 0xFB, 0x54, 0x08, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0x90, 0x0D, 0xF0, 0xFA, 0xEB, 
+0x54, 0x04, 0x13, 0x13, 0x54, 0x3F, 0xA3, 0xF0, 0xEF, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 
+0x80, 0xB1, 0xF1, 0x54, 0x7F, 0x4F, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 
+0x54, 0xC0, 0xB1, 0xF1, 0x54, 0xBF, 0x4F, 0xF0, 0xEA, 0x60, 0x02, 0xA1, 0xE8, 0x90, 0x90, 0x09, 
+0xE0, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 0x12, 0xED, 0x12, 0xBC, 0x05, 0x54, 0xE0, 0x4F, 0xF0, 0xEC, 
+0x54, 0x03, 0xB1, 0xF1, 0x54, 0xFC, 0x4F, 0xF0, 0xEC, 0x54, 0x03, 0x25, 0xE0, 0x25, 0xE0, 0xB1, 
+0xF1, 0x54, 0xF3, 0x4F, 0xF0, 0x90, 0x90, 0x08, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 
+0x75, 0xF0, 0x12, 0xED, 0x12, 0xBC, 0x05, 0x54, 0xDF, 0x4F, 0xF0, 0x90, 0x90, 0x0B, 0xE0, 0x54, 
+0x03, 0xC4, 0x54, 0xF0, 0xB1, 0xF1, 0x54, 0xCF, 0x4F, 0xF0, 0x74, 0x33, 0x2D, 0x91, 0x74, 0xE0, 
+0x54, 0xFB, 0xF0, 0x74, 0x33, 0x2D, 0x91, 0x74, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0x90, 
+0x0E, 0xE0, 0x12, 0xB5, 0x6C, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0x8F, 0xB9, 0xE0, 0x60, 
+0x3A, 0x51, 0x3C, 0xE9, 0x24, 0x03, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x02, 0x06, 0x54, 0x1F, 0x12, 
+0x02, 0x4C, 0x90, 0x90, 0x0C, 0x74, 0x01, 0xF0, 0x90, 0x90, 0x0C, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 
+0x50, 0x19, 0xEF, 0x24, 0x03, 0xFF, 0xE4, 0x33, 0xFE, 0x51, 0x3C, 0x8F, 0x82, 0x8E, 0x83, 0xE4, 
+0x12, 0x02, 0x5E, 0x90, 0x90, 0x0C, 0xE0, 0x04, 0xF0, 0x80, 0xDD, 0x90, 0x8F, 0xB7, 0xE0, 0x54, 
+0x07, 0xFF, 0xBF, 0x05, 0x0A, 0xEC, 0xB4, 0x01, 0x06, 0x90, 0x8F, 0xBC, 0x74, 0x01, 0xF0, 0xE4, 
+0x90, 0x90, 0x0C, 0xF0, 0x90, 0x90, 0x0C, 0xE0, 0xFC, 0x24, 0x03, 0xFF, 0xE4, 0x33, 0xFE, 0x51, 
+0x3C, 0x8F, 0x82, 0x8E, 0x83, 0x12, 0x02, 0x1F, 0xFF, 0xED, 0x12, 0xBE, 0xC8, 0xE5, 0x82, 0x2C, 
+0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x90, 0x0C, 0xE0, 0x04, 0xF0, 0xE0, 
+0xB4, 0x04, 0xD1, 0xAF, 0x05, 0x12, 0x11, 0x87, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x02, 
+0x1F, 0xFF, 0x75, 0xF0, 0x12, 0xED, 0x90, 0x8B, 0x9F, 0x12, 0x04, 0x6E, 0xE0, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0xBE, 0x2E, 0x20, 0xE6, 0x02, 0xE1, 0x25, 0x90, 0x00, 0x8C, 
+0xE0, 0x90, 0x91, 0x09, 0xF0, 0x7F, 0x8D, 0x12, 0x7A, 0xB8, 0x90, 0x91, 0x0A, 0xEF, 0xF0, 0x90, 
+0x00, 0x8E, 0xE0, 0x90, 0x91, 0x0B, 0xF0, 0x90, 0x91, 0x0A, 0xE0, 0x24, 0xFC, 0x60, 0x10, 0x24, 
+0x03, 0x60, 0x02, 0xE1, 0x18, 0x90, 0x91, 0x09, 0xE0, 0xFF, 0x12, 0xBD, 0xDB, 0xE1, 0x18, 0x90, 
+0x91, 0x09, 0xE0, 0x24, 0x43, 0x12, 0xC9, 0xD1, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0xF1, 0x2F, 0x75, 
+0xF0, 0x12, 0xB1, 0xF6, 0x13, 0x13, 0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0xF1, 0x2F, 0x75, 0xF0, 
+0x12, 0xB1, 0xF6, 0xF1, 0x69, 0xFB, 0x0D, 0xE4, 0xFF, 0xF1, 0x2F, 0x75, 0xF0, 0x12, 0xB1, 0xF6, 
+0xC4, 0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0xF1, 0x2F, 0x12, 0xBD, 0xA9, 0xFB, 0xE4, 0xFD, 0x0F, 
+0xF1, 0x2F, 0x75, 0xF0, 0x12, 0x90, 0x8B, 0x9D, 0x12, 0x04, 0x6E, 0xF1, 0x2C, 0x75, 0xF0, 0x12, 
+0x12, 0xBC, 0x05, 0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 0x7F, 0x01, 0xF1, 0x2F, 0x75, 0xF0, 0x12, 
+0x12, 0xBC, 0x05, 0x54, 0x1F, 0xF1, 0x2D, 0x12, 0xBE, 0xC8, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0xF1, 
+0x2F, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x2A, 0x75, 0xF0, 
+0x08, 0xA4, 0x24, 0x02, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x2A, 0x75, 0xF0, 0x08, 0xA4, 0x24, 
+0x03, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x2A, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x04, 0xF5, 0x82, 
+0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0xF1, 0x2F, 0x75, 0xF0, 0x08, 0xA4, 
+0x24, 0x05, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x2A, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x06, 0xF5, 
+0x82, 0xE4, 0x34, 0x82, 0xF1, 0x2A, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x07, 0xF5, 0x82, 0xE4, 0x34, 
+0x82, 0xF5, 0x83, 0xE0, 0xFB, 0x0D, 0xF1, 0x36, 0x12, 0xBE, 0x2E, 0x30, 0xE0, 0x07, 0xE4, 0xFD, 
+0x7F, 0x8D, 0x12, 0x7A, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF5, 0x83, 0xE0, 0xFB, 0x0D, 0xF1, 
+0x36, 0x90, 0x91, 0x09, 0xE0, 0x22, 0xEF, 0x70, 0x04, 0x74, 0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 
+0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 
+0x0C, 0x74, 0xFC, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0xEB, 0xF0, 0x22, 0xF0, 0x90, 
+0x00, 0x01, 0x02, 0x02, 0x1F, 0xF0, 0xEE, 0x54, 0x80, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 
+0x12, 0x02, 0x06, 0xFF, 0x54, 0x80, 0xFE, 0x90, 0x8F, 0xBE, 0xE0, 0x54, 0x7F, 0x4E, 0xFE, 0xF0, 
+0xEF, 0x54, 0x40, 0xFF, 0xEE, 0x54, 0xBF, 0x4F, 0xFF, 0xF0, 0x12, 0x02, 0x06, 0xFE, 0x54, 0x20, 
+0xFD, 0xEF, 0x54, 0xDF, 0x4D, 0xFF, 0x90, 0x8F, 0xBE, 0xF0, 0xEE, 0x54, 0x10, 0xFE, 0xEF, 0x54, 
+0xEF, 0x4E, 0xFF, 0xF0, 0x12, 0x02, 0x06, 0x54, 0x0F, 0xFE, 0xEF, 0x54, 0xF0, 0x4E, 0x90, 0x8F, 
+0xBE, 0xF1, 0x5E, 0xFF, 0x54, 0x7F, 0x90, 0x8F, 0xC0, 0xF0, 0xEF, 0xF1, 0x67, 0xFF, 0x90, 0x8F, 
+0xBF, 0xE0, 0x54, 0xFE, 0xB1, 0xE9, 0x90, 0x8F, 0xC1, 0x11, 0x37, 0x54, 0x01, 0x25, 0xE0, 0xFF, 
+0x90, 0x8F, 0xBF, 0xE0, 0x54, 0xFD, 0x4F, 0xF0, 0x12, 0xAD, 0xF9, 0x20, 0xE0, 0x02, 0x7D, 0x01, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x16, 0xED, 0xF0, 0x90, 0x91, 0x15, 0xEF, 
+0xF0, 0xD3, 0x94, 0x07, 0x50, 0x48, 0x7F, 0x47, 0x12, 0x90, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 
+0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x47, 0x12, 0x7A, 0xA5, 0x7F, 0x46, 0x11, 0x93, 0x80, 0x02, 0xC3, 
+0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x46, 0x12, 0x7A, 0xA5, 0x90, 0x91, 0x16, 0xE0, 0x60, 0x0D, 
+0x7F, 0x45, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0x80, 0x0C, 0x7F, 0x45, 0x11, 
+0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x45, 0x80, 0x4B, 0x90, 0x91, 
+0x15, 0xE0, 0x24, 0xF8, 0xF0, 0x7F, 0x63, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 
+0x5F, 0xFD, 0x7F, 0x63, 0x12, 0x7A, 0xA5, 0x7F, 0x62, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 
+0xFC, 0x4F, 0xFD, 0x7F, 0x62, 0x12, 0x7A, 0xA5, 0x90, 0x91, 0x16, 0xE0, 0x60, 0x0E, 0x11, 0x91, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x61, 0x80, 0x0D, 0x11, 0x91, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x61, 0x12, 0x7A, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x7F, 0x61, 0x12, 0x7A, 0xB8, 0x90, 0x91, 0x15, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 
+0x22, 0x8B, 0x5D, 0x8A, 0x5E, 0x89, 0x5F, 0x90, 0x8F, 0xB3, 0xE0, 0x70, 0x10, 0x12, 0x02, 0x06, 
+0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x06, 0x90, 0x8F, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x8F, 0xB5, 
+0xE0, 0x70, 0x0F, 0x31, 0x7D, 0xC4, 0x54, 0x0F, 0xFF, 0xBF, 0x05, 0x06, 0x90, 0x8F, 0xBA, 0x74, 
+0x01, 0xF0, 0xAB, 0x5D, 0xAA, 0x5E, 0xA9, 0x5F, 0x12, 0x8F, 0x5F, 0xFF, 0xF5, 0x61, 0x12, 0x02, 
+0x06, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x8D, 0xEB, 0xF5, 0x62, 0x80, 0x02, 0x8F, 0x62, 
+0x85, 0x61, 0x60, 0xE5, 0x60, 0xD3, 0x95, 0x62, 0x50, 0x28, 0x31, 0x7D, 0x54, 0x01, 0xFD, 0xAF, 
+0x60, 0x12, 0x6E, 0x43, 0xAF, 0x60, 0x12, 0x77, 0x09, 0xEF, 0xAF, 0x60, 0x70, 0x04, 0x31, 0x40, 
+0x80, 0x02, 0xF1, 0x93, 0x90, 0x8F, 0xBA, 0xE0, 0x60, 0x04, 0xAF, 0x60, 0x31, 0x40, 0x05, 0x60, 
+0x80, 0xD1, 0xE5, 0x61, 0x70, 0x19, 0xFF, 0x12, 0x77, 0x09, 0xEF, 0x70, 0x12, 0xD1, 0x70, 0x12, 
+0x78, 0xD1, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 
+0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x0F, 0xEF, 0xF0, 0xA3, 0xED, 
+0xF0, 0x7D, 0x44, 0x7F, 0x6F, 0x31, 0x89, 0xB1, 0x0A, 0x90, 0x91, 0x10, 0xE0, 0x90, 0x91, 0x0F, 
+0xB4, 0x01, 0x09, 0xE0, 0xF1, 0x6E, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x07, 0xE0, 0xF1, 0x6E, 0xE0, 
+0x54, 0xFB, 0xF0, 0xE4, 0xFD, 0xFF, 0x31, 0x89, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xAB, 0x5D, 0xAA, 
+0x5E, 0xA9, 0x5F, 0x02, 0x02, 0x06, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x8F, 
+0x80, 0xED, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x90, 0xEE, 0xEF, 0xF0, 
+0xA3, 0xED, 0xF0, 0x90, 0x89, 0x80, 0xE0, 0x04, 0xF0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x07, 
+0x90, 0x05, 0x10, 0xE4, 0xF0, 0xA3, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x42, 0x90, 0x05, 0x22, 
+0xE0, 0x90, 0x90, 0xF2, 0xF0, 0x7D, 0x26, 0x7F, 0xFF, 0x31, 0x89, 0xB1, 0x0A, 0xEF, 0x64, 0x01, 
+0x70, 0x17, 0x90, 0x89, 0x85, 0xE0, 0xFF, 0x90, 0x90, 0xEF, 0xE0, 0xFB, 0x90, 0x8E, 0xE9, 0x74, 
+0x0A, 0xF0, 0x7D, 0x01, 0x12, 0x2B, 0x0B, 0x80, 0x07, 0x71, 0x1F, 0x30, 0xE0, 0x04, 0x51, 0x2E, 
+0xF1, 0xDB, 0x90, 0x90, 0xF2, 0xE0, 0xFF, 0x7D, 0x27, 0x31, 0x89, 0x51, 0xFC, 0x80, 0x06, 0x51, 
+0xFC, 0x51, 0x2E, 0xF1, 0xDB, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x10, 0x71, 0x1F, 0x30, 0xE0, 
+0x0B, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x6F, 0xFF, 0x7D, 0x28, 0x31, 0x89, 0x90, 0x04, 0x1F, 0x74, 
+0x20, 0xF0, 0x12, 0xC8, 0x48, 0x74, 0x01, 0xF0, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x89, 
+0x85, 0xE0, 0xFF, 0x90, 0x90, 0xEF, 0xE0, 0xFB, 0x90, 0x91, 0x08, 0x74, 0x0A, 0xF0, 0x7D, 0x01, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x06, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 
+0x91, 0x05, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x7A, 0x7E, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x91, 
+0x05, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x91, 0x06, 0xE0, 0x60, 0x08, 0x71, 0x16, 0xF5, 0x83, 
+0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x54, 0xC0, 0xF0, 0x71, 0x16, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0xF0, 0x90, 0x91, 0x08, 0xE0, 
+0xFF, 0xAE, 0x05, 0x74, 0x18, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x71, 
+0x0D, 0xF5, 0x83, 0xE0, 0x54, 0x01, 0xFF, 0x90, 0x91, 0x07, 0xE0, 0x12, 0xB5, 0x6C, 0x44, 0x02, 
+0x4E, 0xFF, 0xAE, 0x05, 0x71, 0x0D, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x11, 0x2E, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x54, 0xF7, 0xF0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x0F, 0x71, 0x04, 0xF5, 0x83, 
+0xE0, 0x44, 0x80, 0xF0, 0x90, 0x05, 0x12, 0xE4, 0xF0, 0x80, 0x08, 0x71, 0x04, 0xF5, 0x83, 0xE0, 
+0x54, 0x7F, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 0xEE, 0xE0, 
+0xFF, 0x02, 0x59, 0x1B, 0x74, 0x05, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0x22, 0x74, 0x12, 0x2E, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0x22, 0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0x22, 0x90, 
+0x8A, 0xEE, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xED, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x8A, 0xED, 
+0x71, 0x22, 0x30, 0xE0, 0x02, 0x81, 0x4E, 0x90, 0x8B, 0x2D, 0xE0, 0x70, 0x69, 0x90, 0x8F, 0xED, 
+0xE0, 0x64, 0x02, 0x60, 0x2E, 0x90, 0x8F, 0xEE, 0xE0, 0x70, 0x28, 0x91, 0x53, 0x90, 0x8F, 0xED, 
+0xE0, 0x90, 0x8F, 0xEF, 0xB4, 0x01, 0x05, 0x12, 0x04, 0xB2, 0x80, 0x0C, 0x12, 0x04, 0xB2, 0xEF, 
+0x44, 0x80, 0xFF, 0xEE, 0x44, 0x02, 0xFE, 0xEC, 0x91, 0x61, 0x91, 0x67, 0x7F, 0x48, 0x7E, 0x09, 
+0x12, 0x6F, 0xFE, 0x90, 0x8F, 0xEE, 0xE0, 0xFF, 0x64, 0x02, 0x70, 0x02, 0x81, 0x4E, 0xEF, 0x70, 
+0x02, 0x81, 0x4E, 0x91, 0x53, 0x90, 0x8B, 0x2C, 0xE0, 0x90, 0x8F, 0xEF, 0x60, 0x09, 0x12, 0x04, 
+0xB2, 0xEF, 0x44, 0x80, 0xFF, 0x80, 0x07, 0x12, 0x04, 0xB2, 0xEE, 0x44, 0x02, 0xFE, 0x91, 0x60, 
+0x91, 0x67, 0x7F, 0x48, 0x81, 0x49, 0x90, 0x8F, 0xED, 0xE0, 0x64, 0x02, 0x60, 0x2B, 0xD1, 0x43, 
+0x54, 0xFC, 0xFF, 0x91, 0x60, 0x90, 0x8F, 0xED, 0xE0, 0x90, 0x8F, 0xEF, 0xB4, 0x01, 0x08, 0x12, 
+0x04, 0xB2, 0xEF, 0x44, 0x01, 0x80, 0x06, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x02, 0xFF, 0x91, 0x60, 
+0x91, 0x67, 0x7F, 0x2C, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0x90, 0x8F, 0xEE, 0xE0, 0x64, 0x02, 0x60, 
+0x5D, 0x7F, 0x30, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xE4, 0xFF, 0x91, 0x60, 0x90, 0x8F, 0xEE, 0xE0, 
+0x70, 0x0C, 0xA3, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x77, 0xFF, 0x91, 0x60, 0x80, 0x37, 0x90, 0x8F, 
+0xEF, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x66, 0xFF, 0x91, 0x60, 0xD1, 0x43, 0x54, 0xFC, 0xF1, 0x3F, 
+0x90, 0x8B, 0x2C, 0xE0, 0x90, 0x8F, 0xF3, 0x60, 0x08, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x02, 0x80, 
+0x06, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x01, 0xF1, 0x3F, 0x90, 0x8F, 0xF3, 0x91, 0x6A, 0x7F, 0x2C, 
+0x7E, 0x09, 0x12, 0x6F, 0xFE, 0x91, 0x67, 0x7F, 0x30, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x7F, 0x48, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xE4, 0xFF, 0xEE, 0x54, 0xF0, 0xFE, 
+0xEC, 0x90, 0x8F, 0xEF, 0x02, 0x04, 0x31, 0x90, 0x8F, 0xEF, 0x12, 0x04, 0xB2, 0x90, 0x8E, 0xEE, 
+0x02, 0x04, 0x31, 0x7F, 0xFF, 0x31, 0x89, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xB8, 
+0x90, 0x90, 0xFB, 0x12, 0x04, 0x31, 0x90, 0x90, 0xFB, 0x91, 0x6A, 0x7F, 0x30, 0x7E, 0x08, 0x12, 
+0x6F, 0xFE, 0xB1, 0x0A, 0xD1, 0x69, 0xD1, 0x53, 0xD1, 0x53, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 
+0x7A, 0xA5, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 0x90, 0x01, 
+0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF1, 0xAD, 0x30, 0xE0, 0x05, 
+0x7F, 0x01, 0x12, 0x71, 0x29, 0xF1, 0x9E, 0x13, 0x30, 0xE0, 0x32, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 
+0x08, 0x90, 0x90, 0xF9, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x90, 0xF9, 0xF0, 0xEF, 0xC4, 
+0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0x90, 0xFA, 0xF0, 0x80, 0x06, 0x90, 0x90, 0xFA, 
+0x74, 0x02, 0xF0, 0x90, 0x90, 0xF9, 0x71, 0x29, 0x7F, 0x01, 0x12, 0x71, 0x29, 0x90, 0x8A, 0xE7, 
+0xE0, 0x60, 0x02, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x91, 0x11, 0xF0, 0xA3, 
+0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 
+0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0x71, 0x1F, 0x30, 0xE0, 0x15, 0xD3, 0x90, 0x91, 0x12, 0xE0, 
+0x94, 0x03, 0x90, 0x91, 0x11, 0xE0, 0x94, 0x00, 0x40, 0x02, 0x80, 0x13, 0x7F, 0x01, 0x80, 0x1B, 
+0xD3, 0x90, 0x91, 0x12, 0xE0, 0x94, 0xE8, 0x90, 0x91, 0x11, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 
+0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x7B, 0x8D, 
+0x90, 0x91, 0x11, 0x12, 0xAA, 0xFE, 0x80, 0xA9, 0x90, 0x90, 0xE8, 0xEF, 0xF0, 0x90, 0x8B, 0x2D, 
+0xE0, 0x70, 0x51, 0x7F, 0x48, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xEE, 0x54, 0x0F, 0xFE, 0xE4, 0xFD, 
+0xFC, 0x90, 0x90, 0xE9, 0x12, 0x04, 0x31, 0xE4, 0x7F, 0x80, 0xD1, 0x35, 0x70, 0x05, 0x90, 0x8B, 
+0x0B, 0x80, 0x1B, 0xE4, 0xFF, 0xFE, 0xD1, 0x37, 0x70, 0x0A, 0x90, 0x8B, 0x0B, 0x04, 0xF0, 0xE4, 
+0xA3, 0xF0, 0x80, 0x4C, 0xE4, 0xFF, 0xD1, 0x35, 0x70, 0x09, 0x90, 0x8B, 0x0B, 0x04, 0xF0, 0xA3, 
+0xF0, 0x80, 0x3D, 0xE4, 0x7F, 0x80, 0xFE, 0xD1, 0x37, 0x70, 0x35, 0x90, 0x8B, 0x0B, 0xF0, 0xA3, 
+0x04, 0xF0, 0x80, 0x2C, 0xD1, 0x43, 0x54, 0x02, 0xF1, 0xC5, 0x60, 0x08, 0x90, 0x8B, 0x0B, 0x74, 
+0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x8B, 0x0B, 0xF0, 0x7F, 0x30, 0xD1, 0x45, 0x54, 0x01, 0xF1, 
+0xC5, 0x60, 0x07, 0xE4, 0x90, 0x8B, 0x0C, 0xF0, 0x80, 0x06, 0x90, 0x8B, 0x0C, 0x74, 0x01, 0xF0, 
+0x90, 0x8B, 0x05, 0xE0, 0x44, 0x01, 0xF0, 0x7D, 0x11, 0x91, 0x73, 0x90, 0x07, 0x78, 0xE0, 0x90, 
+0x8B, 0x0A, 0xF0, 0x90, 0x8B, 0x2C, 0xE0, 0xFF, 0xE4, 0xFD, 0x71, 0x2E, 0x90, 0x90, 0xE8, 0xE0, 
+0xFD, 0x70, 0x02, 0x80, 0x1C, 0xED, 0xB4, 0x01, 0x06, 0xD1, 0x4C, 0x44, 0x20, 0xF0, 0x22, 0x90, 
+0x90, 0xE8, 0xE0, 0xFD, 0xB4, 0x02, 0x06, 0xD1, 0x4C, 0x44, 0x60, 0xF0, 0x22, 0xED, 0xB4, 0x03, 
+0x03, 0xD1, 0x4C, 0xF0, 0x22, 0x7E, 0x02, 0xFD, 0xFC, 0x90, 0x90, 0xE9, 0x12, 0x87, 0x57, 0xC3, 
+0x02, 0x03, 0xDA, 0x7F, 0x2C, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xEF, 0x22, 0x90, 0x8B, 0x05, 0xE0, 
+0x54, 0x1F, 0x22, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x7F, 0x02, 0x12, 0x7A, 0xB8, 
+0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x7F, 0x02, 0x12, 0x7A, 0xB8, 0xEF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xB8, 0x90, 0x90, 0xF5, 0x12, 0x04, 0x31, 0x90, 
+0x90, 0xF5, 0x91, 0x6A, 0x7F, 0x30, 0x7E, 0x08, 0x12, 0x6F, 0xFE, 0x90, 0x01, 0x01, 0xE0, 0x44, 
+0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 
+0xB4, 0x74, 0x86, 0xF1, 0xAD, 0x30, 0xE0, 0x05, 0x7F, 0x03, 0x12, 0x71, 0x29, 0x90, 0x8B, 0x05, 
+0xE0, 0x20, 0xE0, 0x31, 0xF1, 0x9E, 0x13, 0x30, 0xE0, 0x2B, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x07, 
+0xE4, 0x90, 0x90, 0xF3, 0xF0, 0x80, 0x06, 0x90, 0x90, 0xF3, 0x74, 0x01, 0xF0, 0xEF, 0xC4, 0x13, 
+0x54, 0x07, 0x90, 0x90, 0xF4, 0x30, 0xE0, 0x05, 0x74, 0x01, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 
+0x90, 0x90, 0xF3, 0x71, 0x29, 0xD1, 0x69, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8F, 0xA8, 0xE0, 0x30, 0xE0, 0x43, 0x13, 0x13, 0x54, 0x3F, 0x20, 
+0xE0, 0x0F, 0x12, 0xAA, 0x71, 0xF1, 0x84, 0xE4, 0xF1, 0x47, 0x30, 0xE0, 0x02, 0xF1, 0x97, 0xE1, 
+0xA5, 0x90, 0x8F, 0xA8, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x22, 0xE4, 0x90, 0x8E, 0xF6, 
+0xF0, 0x90, 0x8F, 0xAB, 0xF1, 0x84, 0x90, 0x8F, 0xA8, 0xE0, 0x54, 0xFB, 0xF0, 0xE0, 0xC3, 0x13, 
+0x30, 0xE0, 0x07, 0x7D, 0x04, 0x7F, 0x01, 0x02, 0x53, 0xDB, 0x7D, 0x31, 0x91, 0x73, 0x22, 0xFF, 
+0xEC, 0x90, 0x8F, 0xF3, 0x02, 0x04, 0x31, 0xFD, 0xFF, 0x31, 0x89, 0xD1, 0x70, 0x90, 0x8F, 0xA8, 
+0xE0, 0xC3, 0x13, 0x22, 0x90, 0x8F, 0xA8, 0xE0, 0x30, 0xE0, 0x0E, 0x90, 0x01, 0x57, 0xE4, 0xF0, 
+0xF1, 0x47, 0x30, 0xE0, 0x02, 0xF1, 0x97, 0xF1, 0xA5, 0x22, 0xE0, 0xFD, 0xE5, 0x7E, 0xC4, 0x54, 
+0xF0, 0x24, 0x05, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0xF0, 0xE4, 0x90, 0x8E, 0xF6, 
+0xF0, 0x90, 0x8A, 0xE1, 0xE0, 0x90, 0x8E, 0xF7, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 
+0x02, 0x5E, 0xAD, 0xE4, 0xFD, 0x21, 0x42, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x53, 0xDB, 0x90, 0x8A, 
+0xE8, 0xE0, 0xFF, 0xC3, 0x22, 0x90, 0x8F, 0xA8, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xF0, 0x90, 0x8A, 
+0xE8, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x7F, 0x30, 0x7E, 0x08, 0x12, 0x6F, 0xC1, 0xED, 
+0x44, 0x80, 0xFD, 0xEC, 0x22, 0xFF, 0xE4, 0xFE, 0xFD, 0xFC, 0x90, 0x90, 0xE9, 0x12, 0x04, 0x31, 
+0x90, 0x90, 0xE9, 0x12, 0x04, 0xB2, 0xEC, 0x4D, 0x4E, 0x4F, 0x22, 0x90, 0x90, 0xF0, 0xEE, 0xF0, 
+0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x90, 0xEE, 0xE0, 0xFF, 0x12, 0x56, 0x8E, 0x90, 0x90, 0xF0, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x02, 0x4F, 0xDA, 0x12, 0xA8, 0xFC, 0x30, 0xE0, 0x13, 0x11, 0xA4, 
+0x90, 0x89, 0x82, 0xE0, 0x64, 0x01, 0x70, 0x27, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0x80, 
+0x1E, 0x90, 0x8F, 0xA4, 0xE0, 0x60, 0x16, 0x7D, 0x10, 0xE4, 0xFF, 0x12, 0x7A, 0xEE, 0x90, 0x01, 
+0x3C, 0xE0, 0x30, 0xE4, 0x03, 0x74, 0x10, 0xF0, 0x90, 0x01, 0x63, 0xE4, 0xF0, 0xF1, 0xD7, 0x12, 
+0x8A, 0x3C, 0x12, 0x8F, 0x5F, 0x90, 0x8F, 0x83, 0x12, 0x8D, 0xEA, 0x90, 0x8F, 0x84, 0xF0, 0x90, 
+0x8F, 0x83, 0xE0, 0x54, 0x01, 0x90, 0x8F, 0x90, 0xF0, 0x90, 0x8F, 0x83, 0xE0, 0x54, 0x02, 0x90, 
+0x8F, 0x91, 0xF0, 0x90, 0x8F, 0x83, 0xE0, 0x54, 0x04, 0x90, 0x8F, 0x92, 0xF0, 0x90, 0x8F, 0x83, 
+0xE0, 0x54, 0x08, 0x90, 0x8F, 0x93, 0xF0, 0x90, 0x8F, 0x83, 0xE0, 0x54, 0x10, 0x90, 0x8F, 0x94, 
+0xF0, 0x90, 0x8F, 0x84, 0xE0, 0x54, 0x01, 0x90, 0x8F, 0x95, 0xF0, 0x90, 0x8F, 0x84, 0xE0, 0x54, 
+0x02, 0x90, 0x8F, 0x96, 0xF0, 0x90, 0x8F, 0x84, 0xE0, 0x54, 0x04, 0x90, 0x8F, 0x97, 0xF0, 0x90, 
+0x8F, 0x84, 0xE0, 0x54, 0x08, 0x90, 0x8F, 0x98, 0xF0, 0x90, 0x8F, 0x84, 0xE0, 0x54, 0x10, 0x90, 
+0x8F, 0x99, 0xF0, 0x22, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xF1, 0x8E, 0x90, 0x8A, 
+0x74, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x8F, 0x82, 0xE0, 
+0x44, 0x01, 0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0x12, 0x7B, 0x97, 0x90, 0x05, 0x52, 0xE0, 0x54, 0x07, 
+0x04, 0x90, 0x8F, 0x8D, 0x11, 0xDE, 0x90, 0x04, 0x22, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xF0, 0xE4, 
+0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x12, 0x8A, 0x36, 0x12, 0xA0, 0x09, 0x7B, 0x01, 0x7A, 0x8B, 0x79, 
+0x3D, 0x12, 0x68, 0xAB, 0x90, 0x8B, 0x3F, 0x31, 0x59, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 
+0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x8B, 0x49, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x40, 0x31, 
+0x59, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x8B, 0x4B, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x41, 0x31, 0x59, 0x90, 0x8B, 0x4D, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x8B, 0x3D, 0xE0, 0x30, 0xE0, 0x13, 0x90, 0x8B, 0x44, 0x74, 0x01, 0xF0, 0xA3, 0xF0, 
+0xA3, 0x11, 0xDE, 0x90, 0x07, 0x83, 0xE0, 0x44, 0x20, 0xF0, 0x22, 0xE4, 0x90, 0x8B, 0x44, 0x31, 
+0x75, 0x90, 0x07, 0x83, 0xE0, 0x54, 0xDF, 0xF0, 0x22, 0xE0, 0xFF, 0x7E, 0x00, 0x7C, 0x01, 0x7D, 
+0x40, 0x02, 0x02, 0x80, 0x90, 0x8F, 0xC5, 0xE0, 0xFF, 0x90, 0x90, 0x51, 0xE4, 0xF0, 0xA3, 0xEF, 
+0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 
+0x8F, 0x9F, 0xE0, 0x90, 0x90, 0xA2, 0xF0, 0x90, 0x8F, 0xA0, 0xE0, 0x90, 0x90, 0xA3, 0xF0, 0x90, 
+0x8F, 0xA1, 0xE0, 0x90, 0x90, 0xA4, 0xF0, 0x90, 0x8F, 0xA2, 0xE0, 0x90, 0x90, 0xA5, 0xF0, 0x90, 
+0x8F, 0xA3, 0xE0, 0x90, 0x90, 0xA6, 0xF0, 0x90, 0x8F, 0x90, 0xE0, 0x90, 0x90, 0xA7, 0xF0, 0x90, 
+0x8F, 0x91, 0xE0, 0x90, 0x90, 0xA8, 0xF0, 0x90, 0x8F, 0x92, 0xE0, 0x90, 0x90, 0xA9, 0xF0, 0x90, 
+0x8F, 0x93, 0xE0, 0x90, 0x90, 0xAA, 0xF0, 0x90, 0x8F, 0x94, 0xE0, 0x90, 0x90, 0xAB, 0xF0, 0x90, 
+0x8F, 0x95, 0xE0, 0x90, 0x90, 0xAC, 0xF0, 0x90, 0x8F, 0x96, 0xE0, 0x90, 0x90, 0xAD, 0xF0, 0x90, 
+0x8F, 0x97, 0xE0, 0x90, 0x90, 0xAE, 0xF0, 0x90, 0x8F, 0x98, 0xE0, 0x90, 0x90, 0xAF, 0xF0, 0x90, 
+0x8F, 0x99, 0xE0, 0x90, 0x90, 0xB0, 0xF0, 0xF1, 0x7C, 0x31, 0x75, 0x90, 0x90, 0x4A, 0xF0, 0xD1, 
+0x58, 0x50, 0x04, 0xD1, 0x72, 0x80, 0xF8, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xF1, 
+0x8E, 0x90, 0x90, 0x3F, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0x90, 0x90, 0x4A, 0xF0, 0xD1, 0x58, 0x50, 
+0x4A, 0xD1, 0x94, 0x90, 0x90, 0x4A, 0xE0, 0xFE, 0x24, 0xB1, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xD1, 
+0xC1, 0xE0, 0x24, 0x4D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 0x4C, 0x2E, 
+0xF5, 0x82, 0xE4, 0x34, 0x90, 0xD1, 0xC1, 0xE0, 0x24, 0x4E, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 
+0x01, 0xEE, 0xF1, 0xB3, 0x12, 0x87, 0x6C, 0xD1, 0xC5, 0xE0, 0x24, 0x38, 0xF9, 0xE4, 0x34, 0xFC, 
+0xFA, 0xEE, 0xF1, 0xA5, 0x12, 0x87, 0x6C, 0xD1, 0x7F, 0x80, 0xB2, 0x90, 0x02, 0x87, 0xE0, 0x70, 
+0x02, 0xC1, 0x57, 0x90, 0x8F, 0x82, 0xE0, 0x20, 0xE0, 0x02, 0xC1, 0x57, 0xE4, 0x90, 0x90, 0xBB, 
+0x31, 0x75, 0x90, 0x90, 0x3F, 0xE0, 0xFF, 0xA3, 0xE0, 0xA3, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0x90, 0x41, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0x90, 0xFD, 0x11, 0xF0, 0x74, 0x01, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0xF5, 0x83, 0xE0, 0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x54, 0x3F, 0x90, 0x90, 0x43, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 
+0x33, 0x33, 0x33, 0x54, 0xF8, 0x90, 0x90, 0x46, 0xF0, 0xFC, 0x74, 0x07, 0x2D, 0xF5, 0x82, 0xE4, 
+0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0x90, 0x90, 0x48, 0xF0, 0xEC, 0x24, 0x18, 0x90, 0x90, 
+0x45, 0xF0, 0xFD, 0x90, 0x90, 0x41, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x52, 0xBD, 0xEF, 0x54, 
+0xFC, 0x90, 0x90, 0x47, 0xF0, 0x90, 0x90, 0x46, 0xE0, 0x24, 0x18, 0xFF, 0xE4, 0x33, 0x90, 0x90, 
+0x43, 0x8F, 0xF0, 0x12, 0x02, 0xE7, 0x90, 0x90, 0x43, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0xC8, 
+0x57, 0x90, 0x90, 0x3F, 0xEE, 0x8F, 0xF0, 0x12, 0x02, 0xE7, 0x90, 0x8A, 0x74, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x90, 0x90, 0x3F, 0x12, 0xC6, 0x06, 0x40, 0x1B, 0x90, 0x8A, 0x75, 0xE0, 0x24, 0x01, 
+0xFF, 0x90, 0x8A, 0x74, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0xED, 0x9F, 0xFF, 0xEC, 0x9E, 0x90, 0x90, 
+0x3F, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x90, 0x47, 0xE0, 0x24, 0xC0, 0x60, 0x02, 0xA1, 0x5A, 0xD1, 
+0x65, 0x24, 0x18, 0xFD, 0x12, 0x52, 0xBD, 0xEF, 0x60, 0x02, 0xA1, 0x4E, 0xD1, 0x65, 0x24, 0x19, 
+0xFD, 0x12, 0x52, 0xBD, 0x90, 0x90, 0x60, 0xEF, 0xF0, 0xE4, 0x90, 0x90, 0x49, 0xF0, 0x90, 0x90, 
+0x60, 0xE0, 0xFF, 0xD1, 0xA3, 0x9F, 0x50, 0x1A, 0xD1, 0x65, 0x24, 0x1A, 0xFC, 0xED, 0x2C, 0xFD, 
+0x12, 0x52, 0xBD, 0x90, 0x90, 0x49, 0xE0, 0x24, 0x61, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xD1, 0xAA, 
+0x80, 0xDC, 0x90, 0x90, 0x60, 0xE0, 0x70, 0x02, 0x81, 0x72, 0xE4, 0x90, 0x90, 0x4A, 0xF0, 0xD1, 
+0x58, 0x40, 0x02, 0x81, 0x5A, 0xD1, 0x94, 0x90, 0x90, 0x4A, 0xE0, 0xFF, 0x24, 0x4C, 0xF5, 0x82, 
+0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFE, 0x90, 0x90, 0x60, 0xE0, 0xFD, 0xEE, 0x6D, 0x70, 0x20, 
+0xEF, 0xF1, 0xB3, 0x12, 0x87, 0x63, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xD1, 0xB5, 0x90, 0x90, 
+0xC6, 0xED, 0xF0, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0xD1, 0xD0, 0xEF, 0x60, 0x02, 0x80, 0x4D, 
+0x90, 0x90, 0x60, 0xE0, 0x64, 0x03, 0x70, 0x54, 0xD1, 0xB5, 0x90, 0x90, 0xC6, 0x74, 0x03, 0xF0, 
+0x7A, 0x8F, 0x79, 0xFB, 0xD1, 0xD0, 0xEF, 0x70, 0x11, 0xD1, 0xB5, 0x90, 0x90, 0xC6, 0x74, 0x03, 
+0xF0, 0x7A, 0x8F, 0x79, 0xF7, 0xD1, 0xD0, 0xEF, 0x60, 0x2A, 0x90, 0x90, 0x4A, 0xE0, 0xFF, 0x24, 
+0xAC, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x60, 0x02, 0x80, 0x0B, 0x90, 0x90, 0x4A, 
+0xE0, 0xFF, 0x24, 0xA7, 0xF1, 0x85, 0x60, 0x05, 0x74, 0xBB, 0x2F, 0x80, 0x15, 0xD1, 0x86, 0x74, 
+0x01, 0xF0, 0x80, 0x12, 0x90, 0x90, 0x4A, 0xE0, 0x24, 0xBB, 0x80, 0x06, 0x90, 0x90, 0x4A, 0xE0, 
+0x24, 0xBB, 0xD1, 0x8C, 0xE4, 0xF0, 0xD1, 0x7F, 0x61, 0xAF, 0x90, 0x90, 0xBB, 0xE0, 0x70, 0x4F, 
+0xA3, 0xE0, 0x70, 0x4B, 0xA3, 0xE0, 0x70, 0x47, 0xA3, 0xE0, 0x70, 0x43, 0xA3, 0xE0, 0x70, 0x3F, 
+0xA1, 0x4E, 0xE4, 0x90, 0x90, 0x4A, 0xF0, 0xD1, 0x58, 0x50, 0x1C, 0x74, 0xA7, 0x2E, 0xF1, 0x85, 
+0x60, 0x09, 0x74, 0xBB, 0x2E, 0xD1, 0x8C, 0xE4, 0xF0, 0x80, 0x08, 0x74, 0xBB, 0x2E, 0xD1, 0x8C, 
+0x74, 0x01, 0xF0, 0xD1, 0x7F, 0x80, 0xE0, 0x90, 0x90, 0xBB, 0xE0, 0x70, 0x12, 0xA3, 0xE0, 0x70, 
+0x0E, 0xA3, 0xE0, 0x70, 0x0A, 0xA3, 0xE0, 0x70, 0x06, 0xA3, 0xE0, 0x70, 0x02, 0xA1, 0x4E, 0xE4, 
+0x90, 0x90, 0x4A, 0xF0, 0xD1, 0x58, 0x40, 0x02, 0xA1, 0x4E, 0xD1, 0x94, 0xD1, 0x86, 0xE0, 0x70, 
+0x02, 0xA1, 0x4A, 0x90, 0x8F, 0xA8, 0xE0, 0x30, 0xE0, 0x07, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 
+0x79, 0xE4, 0xFF, 0xFE, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x10, 0xD3, 0xEF, 0x94, 0xE8, 0xEE, 0x94, 
+0x03, 0x50, 0x07, 0x0F, 0xBF, 0x00, 0x01, 0x0E, 0x80, 0xEA, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x5A, 
+0x90, 0x90, 0x4A, 0xE0, 0x24, 0xA2, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 
+0x91, 0x08, 0x74, 0x06, 0xF0, 0x7B, 0x08, 0x7D, 0x01, 0x12, 0x92, 0x40, 0x90, 0x90, 0x43, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0x90, 0x90, 0x49, 0xF0, 0xD1, 0xA3, 0x94, 0x06, 0x50, 0x21, 0xD1, 
+0x65, 0x24, 0x0A, 0xFC, 0xED, 0x2C, 0xFD, 0x12, 0x52, 0xBD, 0x90, 0x90, 0x43, 0xA3, 0xE0, 0xFE, 
+0x90, 0x90, 0x49, 0xE0, 0x2E, 0x24, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xD1, 0xAA, 0x80, 0xD9, 
+0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x90, 0x06, 0x35, 0xF0, 0xD1, 0x7F, 0x81, 0xB4, 0xF1, 0x73, 
+0xF1, 0x97, 0x90, 0x06, 0x36, 0x74, 0xDD, 0xF0, 0x41, 0x6B, 0x90, 0x90, 0x48, 0xE0, 0x60, 0x02, 
+0xC1, 0x51, 0xD1, 0x65, 0x24, 0x16, 0xFD, 0x12, 0x52, 0xBD, 0x90, 0x06, 0x34, 0xEF, 0xF0, 0xD1, 
+0x65, 0x24, 0x17, 0xFD, 0x12, 0x52, 0xBD, 0x90, 0x06, 0x37, 0xEF, 0xF0, 0xE4, 0x90, 0x90, 0x4A, 
+0xF0, 0xD1, 0x58, 0x50, 0x41, 0xD1, 0x94, 0xE4, 0x90, 0x90, 0x49, 0xF0, 0xD1, 0xA3, 0x94, 0x06, 
+0x50, 0x30, 0xD1, 0x65, 0x24, 0x04, 0x2D, 0xFD, 0x12, 0x52, 0xBD, 0x90, 0x90, 0x4A, 0xE0, 0xFE, 
+0xF1, 0xA5, 0x12, 0x87, 0x63, 0x90, 0x90, 0x49, 0xE0, 0xF5, 0x82, 0xD1, 0xFE, 0x6F, 0x60, 0x0E, 
+0x74, 0xB6, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE4, 0xF0, 0x80, 0x04, 0xD1, 0xAE, 
+0x80, 0xCA, 0xD1, 0x7F, 0x80, 0xBB, 0x90, 0x90, 0xB6, 0xE0, 0x64, 0x01, 0x60, 0x17, 0xA3, 0xE0, 
+0x64, 0x01, 0x60, 0x11, 0xA3, 0xE0, 0x64, 0x01, 0x60, 0x0B, 0xA3, 0xE0, 0x64, 0x01, 0x60, 0x05, 
+0xA3, 0xE0, 0xB4, 0x01, 0x06, 0x90, 0x90, 0x4B, 0x74, 0x01, 0xF0, 0x90, 0x90, 0x4B, 0xE0, 0x64, 
+0x01, 0x70, 0x4E, 0xF1, 0xD7, 0xF1, 0xF1, 0x12, 0xAD, 0x71, 0x90, 0x8F, 0xA4, 0xE0, 0x70, 0x02, 
+0x41, 0x6B, 0x90, 0x01, 0x3C, 0xE0, 0x30, 0xE4, 0x03, 0x74, 0x10, 0xF0, 0x7D, 0x10, 0xE4, 0xFF, 
+0x12, 0x7B, 0x2A, 0x90, 0x8F, 0xA5, 0xE0, 0x60, 0x08, 0xF5, 0x35, 0xE4, 0xF5, 0x36, 0xFB, 0x80, 
+0x15, 0x90, 0x8F, 0xA6, 0xE0, 0x60, 0x08, 0xFB, 0xE4, 0xF5, 0x35, 0xF5, 0x36, 0x80, 0x07, 0x75, 
+0x35, 0x20, 0xE4, 0xF5, 0x36, 0xFB, 0x7D, 0x01, 0x7F, 0x60, 0x7E, 0x01, 0x12, 0x76, 0x0E, 0x41, 
+0x6B, 0xF1, 0x7C, 0x31, 0x75, 0x90, 0x90, 0x4A, 0xF0, 0xD1, 0x58, 0x50, 0x04, 0xD1, 0x72, 0x80, 
+0xF8, 0xF1, 0x73, 0xF1, 0x97, 0x41, 0x6B, 0x22, 0x90, 0x8F, 0x8D, 0xE0, 0xFF, 0x90, 0x90, 0x4A, 
+0xE0, 0xFE, 0xC3, 0x9F, 0x22, 0x90, 0x90, 0x41, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x90, 0x45, 
+0xE0, 0x22, 0x74, 0xB6, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x74, 0x01, 0xF0, 0x90, 
+0x90, 0x4A, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x90, 0x4A, 0xE0, 0x24, 0xBB, 0xF5, 0x82, 0xE4, 0x34, 
+0x90, 0xF5, 0x83, 0x22, 0x74, 0xA2, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFF, 
+0x02, 0x7A, 0x7E, 0x90, 0x90, 0x49, 0xE0, 0xFD, 0xC3, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x90, 
+0x49, 0xE0, 0x04, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x61, 0x90, 0x90, 0xC3, 0x02, 0x87, 
+0x6C, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0xB1, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 
+0x90, 0x90, 0xC0, 0x12, 0x87, 0x6C, 0xE4, 0xFF, 0x90, 0x90, 0xC6, 0xE0, 0xFE, 0xEF, 0xC3, 0x9E, 
+0x50, 0x14, 0x90, 0x90, 0xC3, 0xD1, 0xF9, 0xFE, 0x90, 0x90, 0xC0, 0xD1, 0xF9, 0x6E, 0x60, 0x03, 
+0x7F, 0x00, 0x22, 0x0F, 0x80, 0xE2, 0x7F, 0x01, 0x22, 0x12, 0x87, 0x63, 0x8F, 0x82, 0x75, 0x83, 
+0x00, 0x02, 0x02, 0x1F, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x86, 0x4E, 0x90, 0x90, 0x3E, 
+0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 
+0xAF, 0xEF, 0x30, 0xE0, 0x0F, 0x90, 0x89, 0x7E, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 0x12, 0x37, 
+0x43, 0x12, 0xBF, 0xA8, 0xF1, 0x69, 0x30, 0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0x5D, 0x58, 0xF1, 
+0x69, 0x30, 0xE2, 0x06, 0x54, 0xFB, 0xF0, 0x12, 0x61, 0xA6, 0xF1, 0x69, 0x30, 0xE5, 0x0B, 0x54, 
+0xDF, 0xF0, 0x12, 0xAB, 0x05, 0xBF, 0x01, 0x02, 0x31, 0x7F, 0xF1, 0x69, 0x30, 0xE6, 0x06, 0x54, 
+0xBF, 0xF0, 0x12, 0x6D, 0xBF, 0xD2, 0xAF, 0x80, 0xAB, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x89, 0x7E, 
+0xE0, 0xFF, 0x22, 0x90, 0x90, 0x3F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE4, 0x90, 0x90, 0x4B, 
+0xF0, 0x90, 0x90, 0xB6, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x22, 0xE0, 0x7C, 
+0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x22, 0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 
+0xE0, 0x44, 0x01, 0xF0, 0x22, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0x93, 0xF5, 0x82, 0xE4, 0x34, 0x90, 
+0xF5, 0x83, 0x22, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 
+0x22, 0x90, 0x8F, 0x82, 0xE0, 0x54, 0xFE, 0x11, 0xDE, 0x90, 0x8F, 0x89, 0x31, 0x77, 0x90, 0x8F, 
+0xA4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xC2, 0xAF, 0x90, 0x8F, 0x82, 0xE0, 0x54, 0xFE, 0xF0, 
+0x7D, 0x08, 0xE4, 0xFF, 0x12, 0x7B, 0x53, 0xE4, 0x90, 0x8F, 0x8E, 0xF0, 0xA3, 0xF0, 0xD2, 0xAF, 
+0x22, 0x90, 0x01, 0xC7, 0x74, 0x66, 0xF0, 0xE4, 0xFF, 0x22, 0x12, 0x8A, 0x36, 0x12, 0xA0, 0x09, 
+0x7B, 0x01, 0x7A, 0x8F, 0x79, 0x9A, 0x02, 0x68, 0xAB, 0x8B, 0x1B, 0x8A, 0x1C, 0x89, 0x1D, 0x75, 
+0x1E, 0x05, 0x22, 0x12, 0x8A, 0x36, 0x11, 0x09, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0x9F, 0x02, 0x68, 
+0xAB, 0x12, 0x02, 0x06, 0xFF, 0x90, 0x8F, 0xA7, 0xF0, 0xBF, 0x01, 0x07, 0x11, 0x34, 0xE4, 0x90, 
+0x8F, 0xA7, 0xF0, 0x22, 0x11, 0xE4, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x06, 
+0x90, 0x90, 0x05, 0xE0, 0xA3, 0xF0, 0x11, 0xE4, 0x7F, 0xF6, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 
+0x01, 0x08, 0x90, 0x90, 0x05, 0xE0, 0x90, 0x90, 0x07, 0xF0, 0x11, 0xE4, 0x7F, 0xF4, 0x7E, 0x01, 
+0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0x05, 0xE0, 0x90, 0x90, 0x08, 0xF0, 0x11, 0xE4, 
+0x7F, 0xF3, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0x05, 0xE0, 0x90, 0x90, 
+0x09, 0xF0, 0x11, 0xE4, 0x7F, 0xF2, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 
+0x05, 0xE0, 0x90, 0x90, 0x0A, 0xF0, 0x90, 0x90, 0x06, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 
+0xFB, 0xA3, 0xE0, 0x90, 0x90, 0x0E, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 0x90, 0x90, 0x0F, 0xF0, 0x90, 
+0x90, 0x10, 0x74, 0x12, 0xF0, 0x90, 0x90, 0x1E, 0x74, 0x05, 0xF0, 0x90, 0x90, 0x12, 0xEF, 0xF0, 
+0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x90, 0x0E, 0xE0, 0x90, 0x90, 0x15, 0xF0, 0x90, 0x90, 
+0x0F, 0xE0, 0x90, 0x90, 0x16, 0xF0, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x10, 0x12, 0x5A, 0x18, 0x7F, 
+0x04, 0x02, 0x87, 0xB8, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x05, 0x22, 0x12, 0x02, 0x06, 0x54, 0x01, 
+0xFF, 0x90, 0x8F, 0xC3, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x8A, 0x36, 0x12, 0x02, 0x06, 
+0xFF, 0x54, 0x7F, 0x90, 0x8A, 0x83, 0xF0, 0xEF, 0x12, 0x8F, 0x69, 0xA3, 0x12, 0x8F, 0x5E, 0xFD, 
+0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFF, 0x90, 0x8A, 0x81, 0xE0, 0x54, 0xF0, 0x4F, 0x12, 0x88, 0x37, 
+0xFC, 0x54, 0x01, 0x25, 0xE0, 0xFF, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 0xFD, 0x4F, 0xF0, 0xEC, 0x54, 
+0x04, 0xC3, 0x13, 0xFF, 0x90, 0x8A, 0x80, 0xE0, 0x54, 0xFD, 0x4F, 0xF0, 0xED, 0x54, 0x0F, 0xC4, 
+0x54, 0xF0, 0xFF, 0xA3, 0xE0, 0x54, 0x0F, 0x12, 0x8D, 0xE9, 0x90, 0x8A, 0x82, 0xF0, 0x90, 0x00, 
+0x04, 0x12, 0x02, 0x1F, 0xFD, 0x7F, 0x02, 0x12, 0x53, 0xDB, 0x12, 0x8A, 0x3C, 0x31, 0xE9, 0xFF, 
+0x54, 0x01, 0xFE, 0x90, 0x8A, 0xE8, 0x12, 0xC9, 0xD9, 0x31, 0xE7, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 
+0x54, 0xFB, 0x4D, 0xFF, 0x90, 0x8A, 0xE8, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x31, 
+0xE6, 0xFE, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x8A, 0xE8, 0xF0, 0xEE, 0x54, 
+0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x31, 0xE6, 0x54, 0x40, 0xFE, 0xEF, 0x54, 0xBF, 0x4E, 0x90, 0x8A, 
+0xE8, 0xF0, 0xE0, 0x31, 0xEF, 0x20, 0xE0, 0x29, 0xEF, 0xC3, 0x13, 0x20, 0xE0, 0x0B, 0x75, 0x5E, 
+0x01, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x0B, 0x80, 0x0E, 0xE4, 0xF5, 0x5E, 0x90, 0x8B, 0x2C, 0xE0, 
+0x60, 0x05, 0xE4, 0xF5, 0x5D, 0x80, 0x03, 0x75, 0x5D, 0x01, 0xAD, 0x5E, 0xAF, 0x5D, 0x12, 0x93, 
+0x2E, 0x12, 0x8A, 0x3C, 0x12, 0x6C, 0xAD, 0xF1, 0x6D, 0xF0, 0x90, 0x8A, 0x83, 0xF1, 0x84, 0x91, 
+0xD2, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x4E, 0xFF, 0xF0, 0x90, 0x00, 0x05, 0x02, 0x02, 0x1F, 0xFF, 
+0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0x31, 0xEF, 0x30, 0xE0, 0x2A, 0xEF, 
+0x54, 0xBF, 0xF1, 0xE1, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFE, 
+0xF1, 0x6C, 0x74, 0x04, 0xF0, 0x90, 0x8A, 0xF0, 0xE0, 0xFF, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x80, 0x03, 0xB1, 0x63, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x91, 0x1C, 0xED, 0xF0, 0x90, 0x8A, 0x7E, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x30, 0xE0, 0x02, 0x61, 0x83, 0xEE, 0x12, 0x8F, 0x69, 0x30, 0xE0, 0x02, 0x61, 0x83, 0x90, 0x8A, 
+0x86, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x61, 0x83, 0xEF, 0x70, 0x02, 0x41, 0xF0, 0x24, 0xFE, 0x70, 
+0x02, 0x61, 0x2D, 0x24, 0xFE, 0x60, 0x4D, 0x24, 0xFC, 0x70, 0x02, 0x61, 0x6C, 0x24, 0xFC, 0x60, 
+0x02, 0x61, 0x7D, 0xEE, 0xB4, 0x0E, 0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x05, 
+0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 
+0x8A, 0x86, 0xE0, 0xB4, 0x04, 0x0F, 0x90, 0x91, 0x1C, 0xE0, 0xFF, 0x60, 0x05, 0x12, 0x6C, 0x1E, 
+0x80, 0x03, 0x12, 0x78, 0xD1, 0x90, 0x8A, 0x86, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x61, 0x7D, 0x12, 
+0x7A, 0x3E, 0x61, 0x7D, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 
+0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 
+0x71, 0x88, 0xBF, 0x01, 0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0x64, 0x0C, 0x60, 0x02, 
+0x61, 0x7D, 0x71, 0x88, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x61, 0x7D, 0x12, 0x6D, 0x38, 0x61, 0x7D, 
+0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 0x71, 0x88, 0xBF, 0x01, 0x03, 0x12, 0x74, 0x33, 0x90, 
+0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x08, 
+0x71, 0x88, 0xBF, 0x01, 0x03, 0x12, 0x6D, 0x38, 0x90, 0x8A, 0x86, 0xE0, 0x64, 0x04, 0x70, 0x5D, 
+0x12, 0xC8, 0x79, 0xEF, 0x64, 0x01, 0x70, 0x55, 0x12, 0x77, 0x7E, 0x80, 0x50, 0x90, 0x8A, 0x86, 
+0xE0, 0xB4, 0x0E, 0x08, 0x71, 0x88, 0xBF, 0x01, 0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 
+0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x08, 0x71, 0x88, 0xBF, 
+0x01, 0x03, 0x12, 0x6D, 0x38, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 
+0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x04, 0x16, 0x12, 0x79, 0x64, 0x80, 0x11, 0x90, 0x8A, 0x86, 0xE0, 
+0xB4, 0x0C, 0x0A, 0x91, 0xDA, 0x54, 0x3F, 0x30, 0xE0, 0x03, 0x12, 0x79, 0xE1, 0x90, 0x8A, 0x86, 
+0xF1, 0x84, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x10, 0x90, 0x8A, 0xF0, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x12, 0x75, 0x0E, 0x10, 0x80, 0x45, 0x12, 0x79, 0x80, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x75, 0x0E, 
+0x01, 0x80, 0x38, 0x90, 0x8A, 0x7E, 0x12, 0x97, 0xB1, 0x30, 0xE0, 0x05, 0x75, 0x0E, 0x02, 0x80, 
+0x2A, 0x90, 0x8A, 0x85, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 0x75, 0x0E, 0x08, 0x80, 0x1C, 0x90, 
+0x8F, 0xA8, 0xE0, 0x30, 0xE0, 0x0C, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x05, 0x75, 0x0E, 0x11, 
+0x80, 0x09, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x80, 0x0E, 0x90, 0x01, 0xB9, 0x74, 0x02, 
+0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x0E, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8A, 
+0xEA, 0xE0, 0x20, 0xE0, 0x2A, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x01, 0x70, 0x22, 0x12, 0x70, 0x76, 
+0x91, 0xD3, 0x60, 0x0F, 0xE4, 0xFD, 0x7F, 0x0C, 0x51, 0x2A, 0xE4, 0xFD, 0xFF, 0x12, 0x91, 0x89, 
+0x02, 0x69, 0xD6, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x06, 0x7D, 0x01, 0x7F, 0x04, 0x51, 0x2A, 0x22, 
+0xE4, 0xF5, 0x7B, 0x90, 0x8A, 0x83, 0xE0, 0x70, 0x02, 0x81, 0xC0, 0xD1, 0xE4, 0x60, 0x02, 0x81, 
+0xC0, 0xF1, 0xB9, 0x90, 0x8A, 0x81, 0xE0, 0xC4, 0x54, 0x0F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 
+0x04, 0x70, 0x1E, 0x90, 0x8A, 0x8A, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x8A, 0x8C, 
+0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x8A, 0x89, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x7B, 
+0x01, 0xE5, 0x7B, 0x60, 0x4B, 0x90, 0x8A, 0x86, 0xE0, 0x20, 0xE2, 0x06, 0x7D, 0x01, 0x7F, 0x04, 
+0x51, 0x2A, 0x90, 0x8A, 0x87, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x8A, 0x8C, 0xE0, 0x60, 0x04, 0x64, 
+0x01, 0x70, 0x0D, 0x91, 0xC8, 0x91, 0xC1, 0x12, 0x97, 0x85, 0x90, 0x8A, 0x8C, 0xE0, 0x80, 0x17, 
+0x91, 0xC8, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0x91, 0xC1, 0x12, 0x97, 0x85, 0x90, 0x8A, 0x8C, 
+0xE0, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0x91, 0xC1, 0x90, 0x8A, 0x9C, 0xF0, 0x12, 0x70, 0x76, 
+0x22, 0xFF, 0x90, 0x8A, 0x8B, 0xE0, 0x2F, 0x22, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x8A, 0x8C, 
+0xE0, 0x22, 0xF0, 0x90, 0x8A, 0x81, 0xE0, 0x54, 0x0F, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 0xFF, 0x13, 
+0x13, 0x22, 0x91, 0xDA, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x10, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x30, 0xE0, 0x07, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x7B, 0x53, 0x90, 0x8A, 0x7E, 0xE0, 0xFF, 0x13, 
+0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xEF, 0xF1, 0x77, 0x70, 0x57, 0x80, 0x53, 0x90, 0x8A, 0x8C, 
+0xE0, 0x04, 0xF0, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x8A, 0xE0, 0xE0, 0xFF, 0x90, 
+0x8A, 0x8C, 0xE0, 0xD3, 0x9F, 0x40, 0x39, 0xD1, 0xE4, 0x70, 0x37, 0x91, 0xD3, 0x70, 0x0B, 0x12, 
+0x68, 0x5F, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x12, 0x68, 0x5F, 0x90, 0x8A, 0x8D, 
+0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x0E, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0xFB, 0xF0, 
+0xE4, 0x90, 0x8A, 0x8D, 0xF0, 0x80, 0x03, 0x12, 0x78, 0x92, 0xE4, 0x90, 0x8A, 0x8C, 0xF0, 0x22, 
+0xB1, 0x63, 0x22, 0x90, 0x8A, 0x85, 0xE0, 0xFF, 0x7D, 0x01, 0x41, 0x2A, 0x90, 0x06, 0xA9, 0xE0, 
+0xF5, 0x7B, 0x54, 0xC0, 0x70, 0x08, 0xD1, 0xDD, 0xF0, 0x54, 0xFD, 0xF0, 0x80, 0xE5, 0xE5, 0x7B, 
+0x30, 0xE6, 0x1E, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x01, 0x70, 0x19, 0x90, 0x8A, 0x87, 0xE0, 0x44, 
+0x01, 0x91, 0xD2, 0x64, 0x02, 0x60, 0x05, 0x12, 0x72, 0xB9, 0x80, 0x08, 0x12, 0x78, 0x92, 0x80, 
+0x03, 0xD1, 0xDD, 0xF0, 0xE5, 0x7B, 0x90, 0x8A, 0x87, 0x30, 0xE7, 0x0E, 0xE0, 0x44, 0x02, 0x12, 
+0x97, 0x7B, 0x90, 0x8A, 0x7E, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 
+0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 
+0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x90, 0xC7, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xD1, 0xE4, 0x60, 0x02, 
+0xC1, 0xDC, 0x90, 0x8A, 0x83, 0xE0, 0x70, 0x02, 0xC1, 0xDC, 0x90, 0x05, 0x63, 0xE0, 0x90, 0x8A, 
+0xD2, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0x90, 0x8A, 0xD3, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0x90, 0x8A, 
+0xD4, 0xF0, 0x90, 0x05, 0x60, 0xE0, 0x90, 0x8A, 0xD5, 0xF0, 0xF1, 0x61, 0xF0, 0x90, 0x8A, 0x87, 
+0xE0, 0x54, 0xEC, 0xF0, 0xD1, 0xF6, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x02, 0xB1, 0x6C, 0xD1, 0xF6, 
+0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x8A, 0x8A, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 
+0x90, 0x8A, 0x89, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x8A, 0x89, 0xE0, 0xFE, 0xFF, 0x80, 
+0x00, 0x90, 0x8A, 0x8A, 0xEF, 0xF0, 0x12, 0x33, 0x5F, 0xE4, 0x90, 0x8A, 0x8C, 0xF0, 0x12, 0xC7, 
+0x52, 0x91, 0xDA, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x7C, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 
+0xE0, 0x35, 0x90, 0x8A, 0x89, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x69, 0x90, 0x8A, 0x7F, 0xE0, 
+0x44, 0x40, 0xF0, 0x90, 0x8A, 0x89, 0xE0, 0x90, 0x05, 0x73, 0xD1, 0xED, 0x7F, 0x03, 0x12, 0x7B, 
+0x2A, 0x7D, 0x01, 0x7F, 0x02, 0x12, 0x7B, 0x53, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x7B, 0x53, 0x90, 
+0x8A, 0x8A, 0xE0, 0x14, 0xF0, 0x80, 0x3E, 0x90, 0x8A, 0x81, 0xE0, 0xC4, 0x54, 0x0F, 0x64, 0x01, 
+0x70, 0x33, 0x90, 0x8A, 0x89, 0xE0, 0xFF, 0xA3, 0xE0, 0xFE, 0x6F, 0x60, 0x28, 0x90, 0x05, 0x73, 
+0xE0, 0xFF, 0xEE, 0x6F, 0x60, 0x1F, 0x91, 0xDA, 0x54, 0x3F, 0x30, 0xE0, 0x18, 0xEF, 0x54, 0xBF, 
+0xD1, 0xED, 0x7F, 0x03, 0x12, 0x7A, 0xEE, 0x7D, 0x01, 0x7F, 0x02, 0x12, 0x7B, 0x97, 0x7D, 0x02, 
+0x7F, 0x02, 0x12, 0x7B, 0x97, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0x8A, 0x87, 
+0xE0, 0x54, 0xFE, 0x22, 0xE4, 0xFF, 0x12, 0x77, 0x09, 0xEF, 0x64, 0x01, 0x22, 0xF0, 0x90, 0x01, 
+0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x22, 0x90, 0x8A, 0x81, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0xD1, 
+0xE4, 0x70, 0x13, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0D, 0xF1, 0x61, 0xF0, 0x90, 0x8A, 0x7E, 0xE0, 
+0xF1, 0x77, 0x70, 0x02, 0xB1, 0x63, 0x22, 0xE4, 0x90, 0x90, 0xD8, 0xF0, 0x90, 0x8A, 0x83, 0xE0, 
+0x60, 0x3E, 0xD1, 0xE4, 0x70, 0x3A, 0x90, 0x8A, 0x89, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0xF1, 0xB9, 
+0x90, 0x90, 0xD8, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x8A, 0x8A, 0xF0, 0x04, 0x60, 0x22, 0x90, 0x8A, 
+0x86, 0xE0, 0x20, 0xE2, 0x06, 0x7D, 0x01, 0x7F, 0x04, 0x51, 0x2A, 0x90, 0x8A, 0x87, 0xE0, 0x44, 
+0x10, 0xF0, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x8A, 0x8B, 0x12, 0x97, 0x84, 0x12, 0x70, 0x76, 
+0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0xF0, 0x90, 0x01, 0xB9, 
+0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x22, 0x54, 0xFB, 0xF0, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xFD, 
+0xF0, 0x54, 0x07, 0x22, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x8A, 0x85, 0xE0, 0x90, 0x01, 0xBB, 
+0x22, 0xD1, 0xE4, 0x70, 0x0B, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x05, 0xF1, 0x61, 0x12, 0x97, 0x7B, 
+0x22, 0xE4, 0xFF, 0x12, 0x77, 0x09, 0xBF, 0x01, 0x0F, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x09, 0xD1, 
+0xDD, 0xF0, 0x54, 0x07, 0x70, 0x02, 0xB1, 0x63, 0x22, 0x90, 0x05, 0x63, 0xE0, 0x90, 0x8A, 0xD6, 
+0xF0, 0x90, 0x05, 0x62, 0xE0, 0x90, 0x8A, 0xD7, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0x90, 0x8A, 0xD8, 
+0xF0, 0x90, 0x05, 0x60, 0xE0, 0x90, 0x8A, 0xD9, 0xF0, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x80, 0xF0, 
+0x22, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8A, 0x7F, 0x22, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x02, 
+0x71, 0xFE, 0x22, 0x12, 0x02, 0x06, 0x90, 0x8A, 0xE9, 0xF0, 0x60, 0x30, 0xA3, 0xE0, 0x20, 0xE0, 
+0x2B, 0xE4, 0xFD, 0x7F, 0x04, 0x12, 0xA2, 0x2A, 0x12, 0x97, 0x9E, 0x13, 0x30, 0xE0, 0x1D, 0xEF, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0x20, 0xE0, 0x14, 0x90, 0x8A, 0xE8, 0xE0, 0x13, 0x13, 0x54, 0x3F, 
+0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 0x7F, 0x09, 0x12, 0x71, 0x29, 0x22, 0x11, 0xFC, 0xFF, 
+0x54, 0x01, 0xFE, 0x90, 0x8F, 0xA8, 0x12, 0xC9, 0xD9, 0xFF, 0xF0, 0x12, 0x02, 0x06, 0xFE, 0x54, 
+0x04, 0x25, 0xE0, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0xFF, 0x90, 0x8F, 0xA8, 0xF0, 0xEE, 0x54, 0x08, 
+0x25, 0xE0, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0xF0, 0x90, 0x05, 0x52, 0xE0, 0x54, 0x07, 0xFF, 0x90, 
+0x90, 0x05, 0x60, 0x16, 0x12, 0x87, 0x63, 0x12, 0x8F, 0x5F, 0xFD, 0x90, 0x05, 0x56, 0xE0, 0xC3, 
+0x9D, 0x90, 0x8F, 0xAA, 0xF0, 0xA3, 0xED, 0xF0, 0x80, 0x26, 0x12, 0x87, 0x63, 0x12, 0x8F, 0x5F, 
+0xFB, 0xFF, 0x90, 0x05, 0x54, 0xE0, 0xC3, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 0xFE, 0x7C, 0x00, 0x7D, 
+0x05, 0x12, 0x02, 0x92, 0x90, 0x8F, 0xAA, 0xEF, 0xF0, 0xEB, 0x75, 0xF0, 0x05, 0x84, 0xA3, 0xF0, 
+0x12, 0x8A, 0x3C, 0x12, 0x02, 0x06, 0x20, 0xE0, 0x0D, 0x12, 0x96, 0x70, 0x12, 0x91, 0x86, 0x90, 
+0x01, 0x57, 0xE4, 0xF0, 0x80, 0x06, 0x12, 0x97, 0x97, 0x12, 0x97, 0xA5, 0x31, 0x05, 0x20, 0xE0, 
+0x04, 0xEF, 0x54, 0xDF, 0xF0, 0x12, 0x97, 0x4D, 0x30, 0xE0, 0x19, 0x90, 0x8A, 0x83, 0x74, 0x01, 
+0xF0, 0xE4, 0x90, 0x8A, 0x85, 0xF0, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x05, 0x58, 
+0x74, 0x05, 0xF0, 0x22, 0xE4, 0x90, 0x8A, 0x83, 0xF0, 0x90, 0x8A, 0x85, 0x74, 0x0C, 0xF0, 0x90, 
+0x8A, 0x7E, 0xE0, 0x54, 0xFE, 0xF0, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x90, 0x05, 0x12, 
+0x87, 0x6C, 0x02, 0x02, 0x06, 0x90, 0x8F, 0xA8, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x90, 0x8F, 
+0xA8, 0xE0, 0x30, 0xE0, 0x08, 0x51, 0x71, 0x12, 0x97, 0x84, 0x12, 0x97, 0xA5, 0x90, 0x89, 0x82, 
+0xE0, 0xB4, 0x01, 0x10, 0x31, 0x05, 0x20, 0xE0, 0x0B, 0xEF, 0xC4, 0x13, 0x54, 0x07, 0x20, 0xE0, 
+0x03, 0x12, 0xC9, 0x92, 0x22, 0x90, 0x8B, 0x05, 0xE0, 0x30, 0xE0, 0x05, 0x12, 0x6C, 0xF3, 0x80, 
+0x03, 0x12, 0x64, 0x62, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x04, 0xA3, 0xE0, 0x04, 0xF0, 0x90, 
+0x8B, 0x34, 0xE0, 0x64, 0x08, 0x70, 0x20, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x14, 0x12, 0xB7, 
+0x7E, 0xE4, 0xFD, 0x12, 0x6F, 0x45, 0x90, 0x8B, 0x33, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xA3, 0xF0, 
+0x80, 0x05, 0xE4, 0x90, 0x8B, 0x34, 0xF0, 0x12, 0x93, 0x1F, 0x30, 0xE0, 0x13, 0x90, 0x8B, 0x35, 
+0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x14, 0x09, 0x90, 0x04, 0x9C, 0xE4, 0xF0, 0x90, 0x8B, 0x35, 0xF0, 
+0x90, 0x8A, 0x83, 0xE0, 0x70, 0x02, 0x41, 0x43, 0x90, 0x8A, 0x9A, 0xE0, 0x04, 0xF0, 0x90, 0x05, 
+0x61, 0x51, 0x63, 0x78, 0x08, 0x12, 0x03, 0xFE, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 
+0x90, 0x05, 0x60, 0x51, 0x63, 0x12, 0x87, 0x4A, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0x05, 0x62, 0x51, 0x63, 0x78, 0x10, 0x12, 0x03, 0xFE, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
+0xD0, 0x00, 0x12, 0x87, 0x4A, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0x51, 0x63, 
+0x78, 0x18, 0x12, 0x03, 0xFE, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x87, 0x4A, 
+0x90, 0x8A, 0xCE, 0x12, 0x04, 0x31, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x30, 
+0xE0, 0x0C, 0x51, 0x7A, 0x12, 0x40, 0x55, 0x90, 0x8A, 0x80, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x8A, 
+0x7F, 0x12, 0x97, 0xB1, 0x30, 0xE0, 0x15, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x0E, 0x7D, 0x02, 
+0x7F, 0x02, 0x12, 0x7B, 0x53, 0x7D, 0x01, 0x7F, 0x02, 0x12, 0x7B, 0x53, 0x90, 0x91, 0x19, 0xE0, 
+0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 
+0x44, 0x01, 0xF0, 0x51, 0x6A, 0xFF, 0xBF, 0x03, 0x14, 0x90, 0x8F, 0xB0, 0xE0, 0xB4, 0x01, 0x0D, 
+0x90, 0x01, 0xB8, 0xE0, 0x04, 0xF0, 0x90, 0x05, 0x21, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x01, 0x71, 
+0xC9, 0x21, 0x0E, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0x90, 0x01, 0x02, 0xE0, 0x54, 0x03, 
+0x22, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x8F, 0xAA, 0x22, 0x90, 0x8A, 0x95, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xFD, 0x90, 0x8A, 0x9C, 0xE0, 0xFB, 0x22, 0x51, 0xBA, 0x90, 0x90, 0xD8, 0xEF, 0xF0, 0x30, 
+0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xDB, 0x90, 0x90, 0xD8, 
+0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 
+0x01, 0x2F, 0x74, 0x80, 0xF0, 0x51, 0x7A, 0x02, 0x40, 0x55, 0xE4, 0x90, 0x90, 0xDA, 0xF0, 0xA3, 
+0xF0, 0x7F, 0x83, 0x12, 0x7A, 0xB8, 0x90, 0x90, 0xD9, 0xEF, 0xF0, 0x7F, 0x83, 0x12, 0x7A, 0xB8, 
+0xAE, 0x07, 0x90, 0x90, 0xD9, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x90, 0xDB, 0xE0, 
+0x94, 0x64, 0x90, 0x90, 0xDA, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 
+0xF0, 0x90, 0x90, 0xD9, 0xE0, 0xFF, 0x22, 0x90, 0x90, 0xDA, 0x51, 0xFE, 0x80, 0xC3, 0xE4, 0x75, 
+0xF0, 0x01, 0x02, 0x02, 0xE7, 0xE4, 0x90, 0x91, 0x17, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x86, 0xE0, 
+0x20, 0xE1, 0x22, 0xC3, 0x90, 0x91, 0x18, 0xE0, 0x94, 0xD0, 0x90, 0x91, 0x17, 0xE0, 0x94, 0x07, 
+0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x91, 0x17, 0x51, 
+0xFE, 0x91, 0x46, 0x80, 0xD7, 0x7F, 0x01, 0x22, 0x90, 0x8F, 0x8D, 0xE0, 0xFD, 0x7C, 0x00, 0xA3, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x02, 0x92, 0xED, 0x4C, 0x70, 0x05, 0x90, 0x8F, 0x9A, 0x80, 
+0x2A, 0xED, 0x64, 0x01, 0x4C, 0x70, 0x05, 0x90, 0x8F, 0x9B, 0x80, 0x1F, 0xED, 0x64, 0x02, 0x4C, 
+0x70, 0x05, 0x90, 0x8F, 0x9C, 0x80, 0x14, 0xED, 0x64, 0x03, 0x4C, 0x70, 0x05, 0x90, 0x8F, 0x9D, 
+0x80, 0x09, 0xED, 0x64, 0x04, 0x4C, 0x70, 0x0C, 0x90, 0x8F, 0x9E, 0xE0, 0xFF, 0xF1, 0xDB, 0x90, 
+0x8F, 0x8E, 0x51, 0xFE, 0x22, 0x12, 0xA4, 0x30, 0xE4, 0xFF, 0x71, 0x9B, 0x90, 0x8F, 0x82, 0xE0, 
+0x30, 0xE0, 0x02, 0x71, 0x38, 0x12, 0x7A, 0x10, 0x02, 0x97, 0x54, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x8A, 0x80, 0xE0, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x18, 0x90, 0x90, 0xD8, 0x74, 
+0x1E, 0xF0, 0x90, 0x90, 0xE6, 0x74, 0x01, 0xF0, 0x90, 0x90, 0xDA, 0xEF, 0xF0, 0x7B, 0x01, 0x12, 
+0x87, 0xE8, 0x71, 0xC9, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8F, 0x0D, 0x7F, 0x02, 0x12, 0x86, 0x27, 
+0x90, 0x89, 0x7E, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0xE4, 0x90, 0x90, 0x1F, 0xF0, 0xA3, 0xF0, 0x91, 
+0x2D, 0xEF, 0x64, 0x01, 0x60, 0x40, 0xC3, 0x90, 0x90, 0x20, 0xE0, 0x94, 0x88, 0x90, 0x90, 0x1F, 
+0xE0, 0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 
+0xFD, 0xF0, 0x80, 0x22, 0x90, 0x90, 0x1F, 0x51, 0xFE, 0x7F, 0x14, 0x7E, 0x00, 0x12, 0x7B, 0x8D, 
+0xD3, 0x90, 0x90, 0x20, 0xE0, 0x94, 0x32, 0x90, 0x90, 0x1F, 0xE0, 0x94, 0x00, 0x40, 0xC0, 0x90, 
+0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB9, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x90, 0x01, 0x9A, 
+0xE0, 0x54, 0xC0, 0x44, 0x0B, 0x91, 0x45, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xC0, 0x7F, 0x00, 0xB4, 
+0x40, 0x02, 0x7F, 0x01, 0x22, 0xF0, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 0x90, 0xC7, 
+0xEF, 0xF0, 0x90, 0x04, 0x7E, 0xE0, 0xFF, 0xA3, 0xE0, 0x90, 0x90, 0xD7, 0xF0, 0xE0, 0xFE, 0x6F, 
+0x60, 0x64, 0x90, 0x90, 0xC8, 0x74, 0x03, 0xF0, 0x90, 0x90, 0xD6, 0x74, 0x08, 0xF0, 0xEE, 0x04, 
+0x54, 0x0F, 0xFF, 0xE4, 0xFE, 0xEF, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 
+0x80, 0xF5, 0x83, 0xE5, 0x82, 0x2E, 0xF1, 0xD2, 0xFD, 0x74, 0xCA, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 
+0x90, 0xF5, 0x83, 0xED, 0xF0, 0x0E, 0xEE, 0xB4, 0x08, 0xDB, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xC8, 
+0x12, 0x5A, 0x18, 0x90, 0x90, 0xD7, 0xE0, 0x04, 0x54, 0x0F, 0xFF, 0xF0, 0xBF, 0x0F, 0x02, 0xE4, 
+0xF0, 0x90, 0x90, 0xD7, 0xE0, 0x90, 0x04, 0x7F, 0xF0, 0x90, 0x90, 0xC7, 0xE0, 0x7F, 0x04, 0x70, 
+0x02, 0x61, 0xC9, 0x12, 0x87, 0xB8, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 
+0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xC7, 0xF0, 0x74, 0xAC, 0xA3, 0xF0, 0x12, 0x74, 
+0xF9, 0xE5, 0x55, 0x30, 0xE1, 0x03, 0x12, 0xB9, 0x29, 0xE5, 0x55, 0x30, 0xE2, 0x02, 0xB1, 0xB6, 
+0xE5, 0x55, 0x30, 0xE4, 0x02, 0xB1, 0x6B, 0xE5, 0x56, 0x30, 0xE0, 0x02, 0x51, 0x88, 0xE5, 0x57, 
+0x30, 0xE2, 0x0A, 0x12, 0xB9, 0x35, 0x90, 0x07, 0x8F, 0xE0, 0x44, 0x10, 0xF0, 0xE5, 0x58, 0x30, 
+0xE1, 0x04, 0x7F, 0x04, 0x71, 0xC9, 0xE5, 0x58, 0x30, 0xE4, 0x02, 0xB1, 0xA5, 0xE5, 0x58, 0x30, 
+0xE5, 0x03, 0x12, 0xA1, 0xF6, 0xE5, 0x58, 0x30, 0xE6, 0x03, 0x12, 0xB9, 0x8B, 0xE5, 0x58, 0x30, 
+0xE7, 0x03, 0x12, 0xB9, 0x71, 0x74, 0xC7, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xAC, 0xA3, 0xF0, 
+0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
+0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x12, 0x3D, 0x30, 0x12, 0x9F, 
+0xF1, 0x90, 0x91, 0x1A, 0xEF, 0xF0, 0x90, 0x89, 0x82, 0xE0, 0xB4, 0x02, 0x12, 0x90, 0x91, 0x1A, 
+0xE0, 0xFF, 0x64, 0x01, 0x60, 0x1E, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x80, 0x13, 0x90, 
+0x01, 0x00, 0x74, 0xFF, 0xF1, 0xCA, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x91, 0x1A, 
+0xE0, 0xFF, 0xD1, 0x0A, 0x22, 0x12, 0xA7, 0x17, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x7B, 0x97, 0x7F, 
+0x01, 0x71, 0x9B, 0x02, 0x7A, 0x10, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x16, 0x90, 0x06, 0x92, 0xE0, 
+0x30, 0xE1, 0x05, 0x12, 0x69, 0xD6, 0x80, 0x0A, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 0xF7, 0xF0, 0x12, 
+0xA5, 0x63, 0x90, 0x8F, 0xBE, 0xE0, 0xFF, 0x12, 0x8F, 0x69, 0x30, 0xE0, 0x1B, 0xEF, 0xC4, 0x54, 
+0x0F, 0x30, 0xE0, 0x03, 0x12, 0x87, 0xD2, 0x90, 0x8F, 0xBF, 0xE0, 0x30, 0xE0, 0x0A, 0xB1, 0xF9, 
+0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x8F, 0xE0, 0x22, 0x90, 0x8F, 0xBE, 0xE0, 0xFE, 0x54, 0x0F, 
+0xFF, 0xEE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x7D, 0x00, 0x22, 0xAD, 0x07, 0x90, 0x8F, 0xC0, 0xE0, 
+0x75, 0xF0, 0x20, 0xA4, 0xFF, 0x90, 0x90, 0xFF, 0xF1, 0xE9, 0x90, 0x8F, 0xC1, 0xE0, 0x75, 0xF0, 
+0x08, 0xA4, 0xAE, 0xF0, 0x90, 0x91, 0x01, 0xF0, 0xEE, 0xA3, 0xF0, 0x90, 0x90, 0xFF, 0xE0, 0xFE, 
+0xA3, 0xE0, 0x90, 0x91, 0x03, 0xF0, 0xEE, 0xA3, 0xF0, 0xED, 0x64, 0x01, 0x60, 0x73, 0x90, 0x8F, 
+0xBE, 0xE0, 0xFE, 0x12, 0x8F, 0x69, 0x30, 0xE0, 0x68, 0xEE, 0xB1, 0xFE, 0x20, 0xE0, 0x02, 0x7D, 
+0x01, 0x12, 0x8F, 0xE0, 0x90, 0x8F, 0xBE, 0xE0, 0xFE, 0x54, 0x0F, 0xFF, 0xEE, 0xC4, 0x13, 0x13, 
+0x54, 0x01, 0xFD, 0x12, 0x8F, 0xE0, 0x90, 0x8F, 0xBE, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x29, 0xA3, 0xE0, 0x30, 0xE0, 0x0F, 0x90, 0x91, 0x04, 0xE0, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x91, 
+0x03, 0xD1, 0xB2, 0x80, 0x15, 0x90, 0x90, 0xFF, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x7B, 0x8D, 
+0xB1, 0xF9, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x8F, 0xE0, 0x90, 0x8F, 0xBE, 0xE0, 0xC4, 0x54, 
+0x0F, 0x30, 0xE0, 0x0D, 0x90, 0x91, 0x02, 0xE0, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x91, 0x01, 0xD1, 
+0xB2, 0x22, 0xE0, 0x90, 0x8E, 0xF7, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x02, 0x5E, 
+0xAD, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0xC1, 0xF0, 0x74, 0xAE, 0xA3, 0xF0, 0x12, 0x70, 0xEE, 0xE5, 0x4B, 0x30, 0xE1, 0x02, 
+0xF1, 0x88, 0xE5, 0x4B, 0x30, 0xE3, 0x02, 0xF1, 0x93, 0xE5, 0x4B, 0x30, 0xE4, 0x02, 0xF1, 0x8C, 
+0xE5, 0x4B, 0x30, 0xE5, 0x03, 0x12, 0xC7, 0x5C, 0xE5, 0x4D, 0x30, 0xE0, 0x02, 0x71, 0x85, 0xE5, 
+0x4D, 0x30, 0xE1, 0x02, 0x31, 0x35, 0xE5, 0x4D, 0x30, 0xE2, 0x03, 0x12, 0xB8, 0xFB, 0xE5, 0x4D, 
+0x30, 0xE3, 0x03, 0x12, 0xA7, 0x91, 0xE5, 0x4D, 0x30, 0xE4, 0x03, 0x12, 0xA6, 0xFF, 0xE5, 0x4D, 
+0x30, 0xE5, 0x03, 0x12, 0xB9, 0x0D, 0xE5, 0x4D, 0x30, 0xE6, 0x03, 0x12, 0xA7, 0xA1, 0xE5, 0x4D, 
+0x30, 0xE7, 0x02, 0xF1, 0xAD, 0xE5, 0x4E, 0x30, 0xE0, 0x02, 0xF1, 0x9F, 0xE5, 0x4E, 0x30, 0xE1, 
+0x03, 0x12, 0xA7, 0xEA, 0xE5, 0x4E, 0x30, 0xE4, 0x02, 0xF1, 0xC5, 0xE5, 0x4E, 0x30, 0xE5, 0x02, 
+0xF1, 0xC2, 0x74, 0xC1, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xAE, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 
+0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 
+0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xFF, 0x81, 0x4D, 0x12, 0x3A, 0xE3, 0x7F, 
+0x02, 0x61, 0xC9, 0x90, 0x8F, 0x82, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x20, 0x71, 0xC9, 0x22, 0x51, 
+0x6A, 0xFF, 0xBF, 0x03, 0x07, 0x90, 0x05, 0x21, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0xE4, 0xF5, 0x7B, 
+0xF5, 0x7C, 0xF5, 0x7D, 0x51, 0x6A, 0xFF, 0xBF, 0x03, 0x07, 0x90, 0x05, 0x21, 0xE0, 0x54, 0x7F, 
+0xF0, 0x22, 0x02, 0x5F, 0x1C, 0xE4, 0xFF, 0x02, 0x37, 0x43, 0xF0, 0x7F, 0x64, 0x7E, 0x00, 0x02, 
+0x7B, 0x8D, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0x04, 0x24, 0xEF, 0xF0, 
+0x90, 0x04, 0x57, 0xF0, 0x22, 0xFF, 0x90, 0x90, 0x51, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 
+0x12, 0x02, 0x06, 0x90, 0x8F, 0xB0, 0xF0, 0x22, 0x12, 0x02, 0x06, 0xFF, 0x90, 0x8F, 0xB1, 0xF0, 
+0xBF, 0x01, 0x09, 0x7F, 0x01, 0x11, 0x0D, 0xE4, 0x90, 0x8F, 0xB1, 0xF0, 0x22, 0x90, 0x90, 0x1F, 
+0xEF, 0xF0, 0x31, 0xA7, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 
+0x2F, 0xE0, 0x90, 0x90, 0x31, 0xF0, 0x31, 0xA7, 0x7F, 0xF5, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 
+0x01, 0x08, 0x90, 0x90, 0x2F, 0xE0, 0x90, 0x90, 0x32, 0xF0, 0x31, 0xA7, 0x7F, 0xF6, 0x7E, 0x00, 
+0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0x2F, 0xE0, 0x90, 0x90, 0x33, 0xF0, 0x31, 0xA7, 
+0x7F, 0xF7, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0x2F, 0xE0, 0x90, 0x90, 
+0x34, 0xF0, 0x31, 0xA7, 0x7F, 0xF8, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 
+0x2F, 0xE0, 0x90, 0x90, 0x35, 0xF0, 0x31, 0xA7, 0x7F, 0xF9, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 
+0x01, 0x08, 0x90, 0x90, 0x2F, 0xE0, 0x90, 0x90, 0x36, 0xF0, 0x31, 0xA7, 0x31, 0xAE, 0x70, 0x52, 
+0x90, 0x90, 0x2F, 0xE0, 0x90, 0x90, 0x37, 0xF0, 0x54, 0x07, 0x60, 0x08, 0x90, 0x90, 0x2F, 0xE0, 
+0x54, 0xE0, 0x70, 0x3E, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x30, 0x7F, 0xFA, 0x31, 0xB0, 0x70, 0x32, 
+0x90, 0x90, 0x2F, 0xE0, 0xFC, 0x54, 0x07, 0x70, 0x12, 0x90, 0x90, 0x37, 0xE0, 0xFE, 0x90, 0x90, 
+0x30, 0xE0, 0x54, 0x07, 0xFD, 0xEE, 0x4D, 0x90, 0x90, 0x37, 0xF0, 0xEC, 0x54, 0xE0, 0x70, 0x12, 
+0x90, 0x90, 0x37, 0xE0, 0xFF, 0x90, 0x90, 0x30, 0xE0, 0x54, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x90, 
+0x37, 0xF0, 0x31, 0xA7, 0x7F, 0xFD, 0x31, 0xB0, 0x70, 0x47, 0x90, 0x90, 0x2F, 0xE0, 0xFE, 0x54, 
+0xCC, 0x90, 0x90, 0x38, 0xF0, 0xEE, 0x54, 0x0C, 0xFF, 0x60, 0x08, 0x90, 0x90, 0x2F, 0xE0, 0x54, 
+0xC0, 0x70, 0x2E, 0xEF, 0x70, 0x12, 0x90, 0x90, 0x38, 0xE0, 0xFF, 0x90, 0x90, 0x2F, 0xE0, 0x54, 
+0x03, 0xB1, 0x6C, 0x4E, 0x90, 0x90, 0x38, 0xF0, 0x90, 0x90, 0x2F, 0xE0, 0xFF, 0x54, 0xC0, 0x70, 
+0x10, 0x90, 0x90, 0x38, 0xE0, 0xFE, 0xEF, 0x54, 0x30, 0x25, 0xE0, 0x25, 0xE0, 0xFF, 0xEE, 0x4F, 
+0xF0, 0x90, 0x90, 0x20, 0x74, 0x19, 0xF0, 0x90, 0x90, 0x2E, 0x74, 0x08, 0xF0, 0x90, 0x90, 0x31, 
+0xE0, 0x90, 0x90, 0x22, 0xF0, 0x90, 0x90, 0x32, 0xE0, 0x90, 0x90, 0x23, 0xF0, 0x90, 0x90, 0x33, 
+0xE0, 0x90, 0x90, 0x24, 0xF0, 0x90, 0x90, 0x34, 0xE0, 0x90, 0x90, 0x25, 0xF0, 0x90, 0x90, 0x35, 
+0xE0, 0x90, 0x90, 0x26, 0xF0, 0x90, 0x90, 0x36, 0xE0, 0x90, 0x90, 0x27, 0xF0, 0x90, 0x90, 0x37, 
+0xE0, 0x90, 0x90, 0x28, 0xF0, 0x90, 0x90, 0x38, 0xE0, 0x90, 0x90, 0x29, 0xF0, 0x90, 0x90, 0x1F, 
+0xE0, 0xB4, 0x01, 0x0E, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x20, 0x12, 0x5A, 0x18, 0x7F, 0x04, 0x02, 
+0x87, 0xB8, 0x75, 0x1B, 0x01, 0x75, 0x1C, 0x90, 0x75, 0x1D, 0x20, 0x75, 0x1E, 0x0A, 0x7B, 0x01, 
+0x7A, 0x01, 0x79, 0xA0, 0x02, 0x68, 0xAB, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x2F, 0x22, 0x7F, 0xFB, 
+0x7E, 0x00, 0x12, 0x62, 0xDB, 0xEF, 0x64, 0x01, 0x22, 0x7E, 0x00, 0x7F, 0x0B, 0x7D, 0x00, 0x7B, 
+0x01, 0x7A, 0x8F, 0x79, 0xB3, 0x12, 0x04, 0x7A, 0x51, 0x45, 0x7F, 0xF9, 0x7E, 0x00, 0x12, 0x62, 
+0xDB, 0xBF, 0x01, 0x1C, 0x90, 0x90, 0x1F, 0xE0, 0xFE, 0x54, 0x01, 0x90, 0x8F, 0xB3, 0xF0, 0xEE, 
+0x54, 0x04, 0x90, 0x8F, 0xB5, 0xF0, 0x90, 0x90, 0x1F, 0xE0, 0x54, 0x08, 0x90, 0x8F, 0xB4, 0xF0, 
+0x51, 0x45, 0x31, 0xAE, 0x70, 0x34, 0x90, 0x90, 0x1F, 0xE0, 0x54, 0x07, 0x70, 0x14, 0x7B, 0x01, 
+0x7A, 0x90, 0x79, 0x20, 0x7F, 0xFA, 0xFE, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x0F, 0x90, 0x90, 0x20, 
+0x80, 0x03, 0x90, 0x90, 0x1F, 0xE0, 0x54, 0x07, 0x90, 0x8F, 0xB7, 0xF0, 0x90, 0x90, 0x1F, 0xE0, 
+0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x90, 0x8F, 0xB6, 0xF0, 0x51, 0x45, 0x7F, 0xFD, 0x7E, 0x00, 
+0x12, 0x62, 0xDB, 0xBF, 0x01, 0x0E, 0x90, 0x90, 0x1F, 0xE0, 0x54, 0x0C, 0x13, 0x13, 0x54, 0x3F, 
+0x90, 0x8F, 0xB8, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x1F, 0x22, 0x90, 0x00, 0x80, 0xE0, 
+0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x7A, 0xA5, 0xB1, 0x65, 0xB1, 0x89, 0x12, 0x7A, 0xCB, 0xB1, 
+0xCB, 0xB1, 0x7D, 0x7F, 0x01, 0x12, 0x85, 0x15, 0x90, 0x8F, 0xAF, 0x74, 0x02, 0xF0, 0xFF, 0x12, 
+0x85, 0x15, 0x90, 0x8F, 0xAF, 0xE0, 0x04, 0xF0, 0x71, 0xB2, 0x51, 0xE7, 0x90, 0x01, 0xCC, 0x74, 
+0x0F, 0xF0, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x7A, 0xA5, 0x75, 0x20, 
+0xFF, 0x12, 0x7B, 0xC2, 0xE4, 0xFF, 0x11, 0x0D, 0x12, 0xAB, 0xD8, 0x90, 0x00, 0x81, 0xE0, 0x44, 
+0x04, 0xFD, 0x7F, 0x81, 0x12, 0x7A, 0xA5, 0xB1, 0x73, 0x31, 0xB9, 0x90, 0x01, 0x94, 0xE0, 0x54, 
+0xFD, 0xF0, 0x90, 0x01, 0x98, 0xE4, 0xF0, 0xA3, 0x74, 0x40, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0xA3, 
+0x74, 0x80, 0x12, 0xAF, 0xCA, 0x90, 0x01, 0x98, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0x88, 0xF0, 0xA3, 
+0xE4, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x90, 0x00, 0xAA, 0xE0, 0x44, 0x02, 0xF0, 0xA3, 0xE0, 0x44, 
+0x80, 0xF0, 0xE4, 0xFF, 0x02, 0x85, 0x9E, 0xB1, 0x5F, 0x12, 0x7B, 0x0E, 0x12, 0x3C, 0x0A, 0x91, 
+0x16, 0x91, 0x97, 0x71, 0x04, 0x12, 0x9F, 0xC1, 0x12, 0x47, 0xFC, 0xB1, 0xAE, 0x90, 0x8F, 0xB0, 
+0x74, 0x01, 0xF0, 0x22, 0x90, 0x8F, 0xA8, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x54, 0xFB, 
+0xF0, 0x44, 0x10, 0xF0, 0x90, 0x89, 0x82, 0xE0, 0xFF, 0x64, 0x02, 0x70, 0x2D, 0x90, 0xFD, 0x80, 
+0xE0, 0x7E, 0x00, 0x30, 0xE0, 0x02, 0x7E, 0x01, 0x90, 0x8F, 0xAE, 0x71, 0xAB, 0x7E, 0x00, 0x30, 
+0xE1, 0x02, 0x7E, 0x01, 0x90, 0x8F, 0xAC, 0x71, 0xAB, 0x7E, 0x00, 0x30, 0xE2, 0x02, 0x7E, 0x01, 
+0x90, 0x8F, 0xAD, 0x71, 0xAB, 0x90, 0x02, 0xFB, 0xF0, 0x22, 0xEF, 0x64, 0x01, 0x70, 0x21, 0x71, 
+0xA4, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 0x8F, 0xAE, 0xEF, 0xF0, 0x71, 0xA4, 0x30, 0xE1, 0x02, 
+0x7F, 0x01, 0x90, 0x8F, 0xAC, 0xEF, 0xF0, 0x71, 0xA4, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x80, 0x27, 
+0x90, 0x89, 0x82, 0xE0, 0x64, 0x03, 0x70, 0x24, 0x71, 0x9D, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 
+0x8F, 0xAE, 0xEF, 0xF0, 0x71, 0x9D, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x90, 0x8F, 0xAC, 0xEF, 0xF0, 
+0x71, 0x9D, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x90, 0x8F, 0xAD, 0xEF, 0xF0, 0x22, 0x90, 0xFD, 0x78, 
+0xE0, 0x7F, 0x00, 0x22, 0x90, 0xFD, 0x70, 0xE0, 0x7F, 0x00, 0x22, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 
+0xE0, 0x22, 0x12, 0x7A, 0x92, 0x90, 0x89, 0x82, 0xEF, 0xF0, 0x71, 0xE6, 0x90, 0x01, 0x64, 0x74, 
+0x01, 0xF0, 0x90, 0x04, 0x23, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x00, 0x17, 0xE0, 0x54, 0xFC, 0x44, 
+0x04, 0xFD, 0x7F, 0x17, 0x12, 0x7A, 0xA5, 0x90, 0x00, 0x38, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x38, 
+0x12, 0x7A, 0xA5, 0x02, 0x67, 0x21, 0x12, 0x75, 0x87, 0x12, 0x75, 0x29, 0xB1, 0xE9, 0xD1, 0x0E, 
+0xE4, 0xF5, 0x3F, 0xF5, 0x40, 0xF5, 0x41, 0x75, 0x42, 0x80, 0xAD, 0x3F, 0x7F, 0x50, 0x12, 0x7A, 
+0xA5, 0xAD, 0x40, 0x7F, 0x51, 0x12, 0x7A, 0xA5, 0xAD, 0x41, 0x7F, 0x52, 0x12, 0x7A, 0xA5, 0xAD, 
+0x42, 0x7F, 0x53, 0x02, 0x7A, 0xA5, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x90, 0x8B, 0x7B, 0x12, 
+0x87, 0x6C, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0x80, 0x90, 0x8B, 0x7E, 0x12, 0x87, 0x6C, 0x7A, 0x81, 
+0x79, 0xBF, 0x90, 0x8B, 0x81, 0x12, 0x87, 0x6C, 0x7A, 0x82, 0x79, 0x61, 0x90, 0x8B, 0x87, 0x12, 
+0x87, 0x6C, 0x7A, 0x82, 0x79, 0x75, 0x90, 0x8B, 0x8A, 0x12, 0x87, 0x6C, 0x7A, 0x82, 0x79, 0x9D, 
+0x90, 0x8B, 0x8D, 0x12, 0x87, 0x6C, 0x7A, 0x82, 0x79, 0xB1, 0x90, 0x8B, 0x93, 0x12, 0x87, 0x6C, 
+0x7A, 0x82, 0x79, 0xD9, 0x90, 0x8B, 0x96, 0x12, 0x87, 0x6C, 0x7A, 0x83, 0x79, 0x01, 0x90, 0x8B, 
+0x99, 0x12, 0x87, 0x6C, 0xE4, 0x90, 0x8F, 0xC5, 0xF0, 0x90, 0x90, 0x1F, 0xF0, 0x90, 0x90, 0x1F, 
+0xE0, 0xFF, 0xC3, 0x94, 0x05, 0x50, 0x0F, 0x74, 0xD6, 0x2F, 0xD1, 0x68, 0xE4, 0xF0, 0x90, 0x90, 
+0x1F, 0xE0, 0x04, 0xF0, 0x80, 0xE7, 0x22, 0x7E, 0x00, 0x7F, 0x62, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 
+0x8A, 0x79, 0x7E, 0x12, 0x04, 0x7A, 0x90, 0x8A, 0x82, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0x89, 0x14, 
+0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0x90, 0x8A, 0x8F, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xB1, 
+0x4F, 0xB1, 0x96, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xDB, 0x7D, 0x0C, 0x7F, 0x02, 0x12, 0x53, 0xDB, 
+0x12, 0x97, 0x97, 0x90, 0x89, 0x82, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0x8A, 0x8E, 0x74, 0xDD, 
+0xF0, 0x80, 0x0F, 0xEF, 0x90, 0x8A, 0x8E, 0xB4, 0x03, 0x05, 0x74, 0xD4, 0xF0, 0x80, 0x03, 0x74, 
+0x40, 0xF0, 0x7F, 0x79, 0x12, 0x7A, 0xB8, 0xEF, 0x54, 0x03, 0xFF, 0xBF, 0x02, 0x0F, 0x7F, 0x28, 
+0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE2, 0x06, 0x90, 0x8A, 0xA0, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0xE0, 
+0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 
+0x07, 0xB1, 0x4F, 0x7F, 0x01, 0x12, 0x6F, 0x83, 0x7E, 0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 
+0x7A, 0x8A, 0x79, 0xE7, 0x12, 0x04, 0x7A, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 
+0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x8A, 0xE9, 0xF0, 0x22, 0xF0, 
+0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x04, 0x90, 0x8A, 0x9B, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0x22, 0xE4, 
+0xFD, 0xFF, 0x02, 0x6E, 0x43, 0x90, 0x89, 0x64, 0x74, 0x80, 0xF0, 0x22, 0x25, 0xE0, 0x25, 0xE0, 
+0xFE, 0xEF, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x04, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0xE4, 0x90, 0x89, 
+0x7E, 0x12, 0x99, 0x77, 0x90, 0x8F, 0x80, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 
+0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x8A, 0xDA, 0x74, 0x04, 0xF0, 0x14, 0xF0, 0xA3, 0xF0, 
+0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0x64, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x8F, 
+0xBE, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xF0, 0xF0, 0xE4, 0x90, 
+0x8F, 0xC0, 0xF0, 0x90, 0x8F, 0xBE, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 
+0x04, 0xF0, 0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0x12, 0xAC, 0x45, 0x90, 0x01, 0x99, 0xE0, 0x44, 
+0xC0, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x80, 0xF0, 0x22, 0x75, 0x47, 0x12, 0xE4, 0xF5, 0x48, 0x75, 
+0x49, 0x87, 0x75, 0x4A, 0x33, 0x90, 0x01, 0x30, 0xE5, 0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0xA3, 
+0xE5, 0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0x90, 0x01, 0x20, 0xE5, 0x4F, 0xF0, 0x22, 0x75, 0x51, 
+0x06, 0x43, 0x51, 0x10, 0x75, 0x52, 0x01, 0x75, 0x53, 0x03, 0x75, 0x54, 0x62, 0x43, 0x54, 0x80, 
+0x43, 0x53, 0x04, 0x90, 0x01, 0x38, 0xE5, 0x51, 0xF0, 0xA3, 0xE5, 0x52, 0xF0, 0xA3, 0xE5, 0x53, 
+0xF0, 0xA3, 0xE5, 0x54, 0xF0, 0x22, 0xF0, 0x90, 0x90, 0x3F, 0x12, 0x87, 0x63, 0x90, 0x00, 0x06, 
+0x12, 0x03, 0x3E, 0xFF, 0xAE, 0xF0, 0x90, 0x00, 0x08, 0x12, 0x03, 0x3E, 0x2F, 0xFF, 0xE5, 0xF0, 
+0x3E, 0xFE, 0x90, 0x00, 0x04, 0x12, 0x03, 0x3E, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 0x90, 0x90, 0x55, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0xD6, 0x25, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0x22, 
+0x12, 0x02, 0x06, 0x90, 0x8F, 0xA4, 0x12, 0x8F, 0x5E, 0x90, 0x8F, 0xA5, 0x12, 0x8D, 0xEA, 0x90, 
+0x8F, 0xA6, 0xF0, 0x22, 0x02, 0x8D, 0xFE, 0xE4, 0x90, 0x90, 0x39, 0xF0, 0x90, 0x90, 0x39, 0xE0, 
+0x64, 0x01, 0xF0, 0x24, 0x87, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xB6, 0xA3, 0xF0, 0x12, 0x7B, 0x6C, 
+0xBF, 0x01, 0x03, 0x12, 0x58, 0x9B, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0F, 0x90, 0x8A, 0x86, 0xE0, 
+0xFF, 0x90, 0x8A, 0x85, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0xA5, 0x63, 0xC2, 0xAF, 0xF1, 0xEA, 0xBF, 
+0x01, 0x02, 0xD1, 0xD0, 0xD2, 0xAF, 0x12, 0xB9, 0xDE, 0xD1, 0x84, 0x12, 0x84, 0x4D, 0x80, 0xBC, 
+0x90, 0x8A, 0x7E, 0xE0, 0x30, 0xE0, 0x02, 0xD1, 0xDA, 0x22, 0x90, 0x8A, 0x86, 0xE0, 0xFF, 0x60, 
+0x03, 0xB4, 0x08, 0x0E, 0x12, 0xC9, 0x3A, 0xBF, 0x01, 0x08, 0xD1, 0xF3, 0x90, 0x01, 0xE5, 0xE0, 
+0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0x27, 0xF1, 0x03, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x12, 0xC8, 0x00, 0x7F, 0x08, 0x12, 0x7A, 0xB8, 0xEF, 0x54, 0xEF, 0xFD, 0x7F, 
+0x08, 0x12, 0x7A, 0xA5, 0xE4, 0xFF, 0xF1, 0x96, 0xF1, 0x7E, 0xE4, 0xFD, 0x12, 0x6F, 0x45, 0x90, 
+0x8A, 0x7F, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x10, 0xF0, 0xF1, 0x7E, 
+0x7D, 0x01, 0x12, 0x6F, 0x45, 0x90, 0x8A, 0x8E, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x7A, 0xA5, 0x90, 
+0x8A, 0x84, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 
+0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x7F, 0x08, 0x12, 0x7A, 0xB8, 0xEF, 0x44, 0x10, 0xFD, 
+0x7F, 0x08, 0x12, 0x7A, 0xA5, 0x7F, 0x01, 0xF1, 0x96, 0x7F, 0x90, 0x12, 0x7A, 0xB8, 0xEF, 0x44, 
+0x01, 0xFD, 0x7F, 0x90, 0x12, 0x7A, 0xA5, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 0x8A, 
+0xED, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x01, 0xFF, 0x90, 0x8B, 0x2D, 0xE0, 0xFB, 0x90, 0x8B, 0x2C, 
+0xE0, 0x90, 0x84, 0xDC, 0xF0, 0x22, 0x90, 0x91, 0x0C, 0xEF, 0x12, 0x98, 0xDE, 0x90, 0x01, 0x09, 
+0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0x91, 0x0C, 0xE0, 0x6F, 0x60, 0x3A, 0xC3, 
+0x90, 0x91, 0x0E, 0xE0, 0x94, 0x88, 0x90, 0x91, 0x0D, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 
+0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x91, 0x0D, 0x12, 0xAA, 0xFE, 0x7F, 0x14, 0x7E, 0x00, 
+0x12, 0x7B, 0x8D, 0xD3, 0x90, 0x91, 0x0E, 0xE0, 0x94, 0x32, 0x90, 0x91, 0x0D, 0xE0, 0x94, 0x00, 
+0x40, 0xBB, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB4, 0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 
+0xEA, 0xF0, 0x74, 0xB7, 0xA3, 0xF0, 0x90, 0x8F, 0xAF, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x18, 
+0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x0B, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 
+0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xDE, 0x74, 0xEA, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
+0xB7, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 
+0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x27, 0xF0, 0x74, 0xB8, 0xA3, 0xF0, 0x12, 0x6B, 
+0x8E, 0x74, 0x27, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xB8, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 
+0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 
+0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 
+0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x77, 0xF0, 0x74, 0xB8, 0xA3, 0xF0, 0x12, 0x0F, 
+0x2F, 0x53, 0x91, 0xBF, 0x74, 0x77, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xB8, 0xA3, 0xF0, 0xD0, 
+0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 
+0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xC0, 0xE0, 0xC0, 0x83, 0xC0, 0x82, 
+0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x05, 0xC0, 0x07, 0x7D, 0xCA, 0x90, 0x01, 0xC4, 0xED, 0xF0, 
+0x74, 0xB8, 0xFF, 0xA3, 0xF0, 0xED, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0xA3, 0xEF, 0xF0, 0xD0, 0x07, 
+0xD0, 0x05, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0x32, 0x90, 0x8A, 0x86, 0xE0, 0x64, 
+0x02, 0x60, 0x09, 0x12, 0xA5, 0xBF, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0xE4, 0xFF, 0x12, 
+0x77, 0x09, 0xBF, 0x01, 0x13, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0D, 0x12, 0xA4, 0xD3, 0x64, 0x02, 
+0x60, 0x03, 0x02, 0x72, 0xB9, 0x12, 0x78, 0x92, 0x22, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x03, 0x12, 
+0xA4, 0xE2, 0x02, 0x96, 0xF4, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8B, 0x3D, 0xE0, 
+0x30, 0xE0, 0x29, 0x90, 0x8B, 0x44, 0xE0, 0xB4, 0x01, 0x15, 0xA3, 0xE0, 0xB4, 0x01, 0x1D, 0x74, 
+0x02, 0xF0, 0x90, 0x8B, 0x4B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x72, 0x10, 0x80, 0x0D, 0x90, 
+0x8B, 0x44, 0xE0, 0xB4, 0x02, 0x06, 0x74, 0x03, 0xF0, 0x12, 0x53, 0x4D, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x8B, 0x05, 0xE0, 0x30, 0xE0, 0x05, 0x12, 0x78, 0x11, 0x80, 0x03, 0x12, 0x69, 0x8C, 
+0x90, 0x8B, 0x3D, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x53, 0x4D, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0xFF, 
+0x12, 0x8F, 0x69, 0x30, 0xE0, 0x20, 0xEF, 0x54, 0x7F, 0x12, 0xA7, 0xE1, 0x30, 0xE1, 0x06, 0xE0, 
+0x44, 0x02, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFD, 0x12, 0xA7, 0x6C, 0x04, 0xF0, 0x90, 0x8A, 0x83, 
+0xE0, 0x60, 0x03, 0x12, 0xA5, 0x63, 0x12, 0x93, 0x1F, 0x30, 0xE0, 0x21, 0x90, 0x8A, 0xF1, 0xE0, 
+0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x17, 0xEF, 0x54, 0xFD, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8A, 
+0xF1, 0x30, 0xE1, 0x05, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xB9, 0xE0, 0x60, 0x25, 0x7F, 0x54, 0x7E, 0x09, 0x12, 
+0x6F, 0xC1, 0x51, 0x36, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0xFE, 0xFF, 0xEE, 0x44, 0x03, 0xFE, 0xED, 
+0x44, 0x04, 0xFD, 0xEC, 0x51, 0x36, 0x12, 0x94, 0x6A, 0x7F, 0x54, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 
+0x90, 0x8F, 0xB4, 0xE0, 0x70, 0x04, 0x90, 0x07, 0xCC, 0xF0, 0x90, 0x8F, 0xBC, 0xE0, 0x70, 0x0A, 
+0x90, 0x8F, 0xB9, 0xE0, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0x07, 0x90, 0x00, 0x1F, 0xE0, 0x54, 0xF0, 
+0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 0x3A, 0x12, 0x04, 0x31, 0x90, 0x90, 0x3A, 0x22, 
+0x7A, 0x00, 0x7D, 0x03, 0x7F, 0x01, 0x90, 0x01, 0xC6, 0xE0, 0xFE, 0x64, 0x80, 0x70, 0x60, 0x90, 
+0x90, 0x5B, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xEB, 0xA3, 0xF0, 0xEA, 0xA3, 0xF0, 0x90, 0x90, 0x51, 
+0xE0, 0xFC, 0xA3, 0xE0, 0x90, 0x90, 0x5F, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x90, 0x53, 0xE0, 0xFC, 
+0xA3, 0xE0, 0x90, 0x90, 0x61, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x90, 0x55, 0xE0, 0xFC, 0xA3, 0xE0, 
+0x90, 0x90, 0x63, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x90, 0x57, 0xE0, 0xFC, 0xA3, 0xE0, 0x90, 0x90, 
+0x65, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x90, 0x59, 0x74, 0xFE, 0xF0, 0x90, 0x90, 0x67, 0x74, 0x0C, 
+0xF0, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x59, 0x12, 0x5A, 0x18, 0x7F, 0x04, 0x12, 0x87, 0xB8, 0x22, 
+0x8F, 0x72, 0x8D, 0x73, 0xEF, 0x91, 0x1C, 0xE0, 0xF5, 0x74, 0x54, 0x7F, 0xF5, 0x75, 0xE5, 0x74, 
+0x54, 0x80, 0xF5, 0x77, 0x75, 0xF0, 0x12, 0xEF, 0xB1, 0xAC, 0xF5, 0x79, 0x75, 0xF0, 0x12, 0xEF, 
+0x12, 0x8D, 0xF6, 0xC4, 0x54, 0x03, 0xF5, 0x7A, 0x71, 0xF4, 0x74, 0xFF, 0xF0, 0xB1, 0xB4, 0xE5, 
+0x74, 0x45, 0x77, 0xFF, 0x91, 0xB0, 0xEF, 0xF0, 0xE5, 0x72, 0x12, 0x97, 0x6E, 0xE0, 0x54, 0x03, 
+0xF5, 0x78, 0x74, 0xB3, 0x25, 0x72, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0xE5, 0x78, 0xF0, 
+0xE5, 0x75, 0x65, 0x79, 0x70, 0x47, 0x91, 0x00, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x0C, 0xE5, 
+0x77, 0x70, 0x08, 0xE5, 0x75, 0x44, 0x80, 0xF5, 0x74, 0x61, 0xB4, 0xB1, 0xB4, 0xE5, 0x72, 0x25, 
+0xE0, 0x24, 0xE2, 0xF5, 0x82, 0xE4, 0x34, 0x8C, 0xF5, 0x83, 0xE0, 0xFF, 0xA3, 0xE0, 0x90, 0x90, 
+0x53, 0xCF, 0x71, 0xE9, 0xE5, 0x72, 0xF0, 0xE4, 0x90, 0x90, 0x55, 0x12, 0x99, 0x77, 0x7B, 0x01, 
+0xFA, 0x7D, 0x02, 0x7F, 0x04, 0x51, 0x46, 0x7D, 0x07, 0xAF, 0x72, 0xC1, 0xF5, 0xE5, 0x75, 0xC3, 
+0x95, 0x79, 0x50, 0x59, 0xAB, 0x72, 0xAD, 0x79, 0xAF, 0x75, 0x12, 0x72, 0x81, 0x8F, 0x76, 0x85, 
+0x76, 0x74, 0x91, 0x00, 0xC4, 0x13, 0x54, 0x01, 0xFF, 0x90, 0x90, 0x55, 0x71, 0xE8, 0xE5, 0x76, 
+0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0xE5, 0x75, 0xF0, 0xE5, 0x77, 0x12, 0x8F, 0x69, 0xD1, 0xBE, 0xE4, 
+0xFB, 0xFA, 0x7D, 0x05, 0x7F, 0x04, 0x51, 0x46, 0xE5, 0x75, 0xC3, 0x94, 0x0C, 0x40, 0x25, 0x91, 
+0x00, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x1C, 0xE5, 0x73, 0x60, 0x18, 0xE5, 0x77, 0x70, 0x14, 
+0xE5, 0x75, 0x44, 0x80, 0xF5, 0x74, 0x71, 0xF4, 0xE5, 0x76, 0xF0, 0x80, 0x07, 0x91, 0xB0, 0xE5, 
+0x79, 0xF0, 0xF5, 0x74, 0x71, 0xED, 0xE5, 0x74, 0xF0, 0x71, 0xF4, 0xE0, 0xFF, 0xD1, 0xA6, 0xEF, 
+0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0xE5, 0x78, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0xE5, 0x73, 0xF0, 0x7B, 
+0x01, 0x7A, 0x00, 0x7D, 0x05, 0x7F, 0x04, 0x51, 0x46, 0x90, 0x8E, 0xA6, 0xE5, 0x78, 0xF0, 0xAB, 
+0x73, 0xAD, 0x74, 0xAF, 0x72, 0x02, 0x23, 0x3F, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x90, 0x51, 
+0xE4, 0xF0, 0xA3, 0x22, 0x74, 0xC6, 0x25, 0x72, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0x22, 
+0x75, 0xF0, 0x12, 0xE5, 0x72, 0x90, 0x8B, 0x9E, 0x12, 0x04, 0x6E, 0xE0, 0x22, 0x74, 0x23, 0x25, 
+0x7E, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0xE4, 0xF0, 0xE5, 0x7E, 0xC4, 0x54, 0xF0, 0x24, 
+0x00, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0x8D, 0x7E, 0xEF, 0x30, 0xE6, 0x1B, 0x91, 
+0x1A, 0x12, 0x97, 0x6A, 0xE0, 0x54, 0x03, 0x90, 0x8E, 0xA6, 0xF0, 0xE4, 0xFB, 0xAF, 0x7E, 0x12, 
+0x23, 0x3F, 0x91, 0x0D, 0x91, 0x9C, 0x74, 0x01, 0x80, 0x49, 0x91, 0xA3, 0x04, 0xF0, 0x91, 0xA3, 
+0x64, 0x02, 0x70, 0x1E, 0x74, 0xC6, 0x25, 0x7E, 0x71, 0xF8, 0xE0, 0xFD, 0xF4, 0x60, 0x02, 0x80, 
+0x04, 0x91, 0x1A, 0xE0, 0xFD, 0x12, 0x97, 0x6C, 0xB1, 0x9B, 0x91, 0x1A, 0x91, 0x9C, 0x74, 0x02, 
+0x80, 0x21, 0x91, 0xA3, 0xD3, 0x94, 0x03, 0x40, 0x0D, 0xAF, 0x7E, 0x12, 0x6C, 0x66, 0x91, 0x0D, 
+0x91, 0x9C, 0x74, 0x03, 0x80, 0x0D, 0x91, 0x1A, 0x12, 0x97, 0x6A, 0xB1, 0x9B, 0x91, 0x1A, 0x91, 
+0x9C, 0x74, 0x02, 0xF0, 0xAB, 0x7E, 0xE4, 0xFD, 0xFF, 0x02, 0x4E, 0x09, 0xE0, 0x90, 0x84, 0x47, 
+0xF0, 0xA3, 0x22, 0x74, 0x23, 0x25, 0x7E, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0xE0, 0x22, 
+0x74, 0x33, 0x25, 0x72, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0x22, 0xAC, 0x05, 0x90, 0x90, 
+0x4B, 0xEF, 0xF0, 0xFD, 0xE0, 0xFF, 0x91, 0x1C, 0xE0, 0xF5, 0x72, 0x54, 0x7F, 0xF5, 0x74, 0x75, 
+0xF0, 0x12, 0xEF, 0x90, 0x8B, 0x9D, 0x12, 0x04, 0x6E, 0xE0, 0xF9, 0x90, 0x90, 0x4B, 0xE0, 0xB1, 
+0xA9, 0xFE, 0xEF, 0x12, 0x97, 0x6E, 0xE0, 0x54, 0x03, 0xF5, 0x73, 0xE5, 0x74, 0x90, 0x82, 0x9D, 
+0x93, 0xFB, 0xED, 0x25, 0xE0, 0x24, 0xE2, 0xF5, 0x82, 0xE4, 0x34, 0x8C, 0xF5, 0x83, 0xE4, 0xF0, 
+0xA3, 0xEB, 0xF0, 0x12, 0x8D, 0xF2, 0xC4, 0x54, 0x03, 0x90, 0x90, 0x4C, 0xF0, 0x74, 0x33, 0x2D, 
+0x91, 0xB4, 0xE5, 0x74, 0xF0, 0x74, 0xB3, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0xE5, 
+0x73, 0xF0, 0xE5, 0x74, 0xD3, 0x9E, 0x40, 0x06, 0x8E, 0x74, 0xAF, 0x06, 0x8F, 0x72, 0x8C, 0x75, 
+0xE4, 0xFF, 0xEF, 0xC3, 0x95, 0x75, 0x50, 0x2F, 0xE5, 0x72, 0x30, 0xE7, 0x09, 0x85, 0x74, 0x72, 
+0x1C, 0xEC, 0x70, 0x20, 0x80, 0x21, 0xE5, 0x74, 0xD3, 0x99, 0x40, 0x14, 0xAD, 0x01, 0x90, 0x90, 
+0x4B, 0xE0, 0xFB, 0x90, 0x90, 0x50, 0xEC, 0xF0, 0xAF, 0x74, 0xD1, 0x35, 0x8F, 0x72, 0x80, 0x07, 
+0x89, 0x72, 0x80, 0x03, 0x0F, 0x80, 0xCB, 0x90, 0x90, 0x4B, 0xE0, 0xFF, 0x71, 0xED, 0xEF, 0xF0, 
+0xA3, 0xE4, 0xF0, 0xA3, 0xE5, 0x72, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0xE5, 0x73, 0x12, 0x98, 0xDE, 
+0x7B, 0x01, 0xFA, 0x7D, 0x05, 0x7F, 0x08, 0x51, 0x46, 0x90, 0x90, 0x4B, 0xE0, 0xFF, 0x90, 0x8E, 
+0xA6, 0xE5, 0x73, 0xF0, 0xE4, 0xFB, 0xAD, 0x72, 0x02, 0x23, 0x3F, 0xE0, 0x54, 0x03, 0x90, 0x8E, 
+0xA6, 0xF0, 0x7B, 0x01, 0xAF, 0x7E, 0x02, 0x23, 0x3F, 0x75, 0xF0, 0x12, 0x90, 0x8B, 0x9C, 0x12, 
+0x04, 0x6E, 0xE0, 0x22, 0xE5, 0x75, 0x25, 0xE0, 0x24, 0x75, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 
+0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0xE5, 0x72, 0x25, 0xE0, 0x24, 0xE2, 0xF5, 0x82, 
+0xE4, 0x34, 0x8C, 0xF5, 0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x91, 0x13, 0xEF, 0xF0, 0xD1, 0x2E, 0x30, 0xE6, 0x3D, 0x7F, 0x8D, 0x12, 0x7A, 
+0xB8, 0xEF, 0x64, 0x01, 0x70, 0x33, 0x90, 0x91, 0x14, 0xF0, 0x90, 0x91, 0x14, 0xE0, 0xFD, 0x90, 
+0x91, 0x13, 0xE0, 0x91, 0x1C, 0xE5, 0x82, 0x2D, 0x12, 0xAF, 0xD2, 0xFB, 0xE4, 0xFF, 0x12, 0x8F, 
+0x36, 0x90, 0x91, 0x14, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x10, 0x40, 0xDD, 0xD1, 0x2E, 0x30, 
+0xE0, 0x07, 0xE4, 0xFD, 0x7F, 0x8D, 0x12, 0x7A, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x8F, 
+0x12, 0x7A, 0xB8, 0xEF, 0x22, 0xE4, 0xF5, 0x77, 0xEF, 0x14, 0xF5, 0x76, 0xED, 0xFF, 0xE5, 0x76, 
+0xF5, 0x82, 0x33, 0x95, 0xE0, 0xF5, 0x83, 0xC3, 0xE5, 0x82, 0x9F, 0x74, 0x80, 0xF8, 0x65, 0x83, 
+0x98, 0x40, 0x50, 0xE5, 0x76, 0x78, 0x03, 0xA2, 0xE7, 0x13, 0xD8, 0xFB, 0xFF, 0x33, 0x95, 0xE0, 
+0xFE, 0xEB, 0xD1, 0xC8, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE5, 0x83, 0x3E, 0xF5, 0x83, 0xE0, 0xF5, 
+0x82, 0x75, 0x83, 0x00, 0xE5, 0x76, 0xD1, 0xEA, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
+0xF9, 0xFF, 0xEE, 0x55, 0x83, 0xFE, 0xEF, 0x55, 0x82, 0x4E, 0x60, 0x13, 0x85, 0x76, 0x78, 0x05, 
+0x77, 0x90, 0x90, 0x50, 0xE0, 0x65, 0x77, 0x60, 0x0A, 0xE5, 0x78, 0xD3, 0x9D, 0x40, 0x04, 0x15, 
+0x76, 0x80, 0x99, 0xAF, 0x78, 0x22, 0x90, 0x90, 0x53, 0xE4, 0xF0, 0xA3, 0x22, 0x7A, 0x00, 0x7D, 
+0x01, 0x7F, 0x01, 0x41, 0x46, 0x7A, 0x00, 0xE4, 0xFD, 0x7F, 0x01, 0x41, 0x46, 0xE0, 0xFF, 0x90, 
+0x90, 0x57, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 
+0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x24, 0xDC, 0xF5, 0x82, 0xE4, 
+0x34, 0x8C, 0xF5, 0x83, 0xE0, 0xFD, 0x7C, 0x00, 0xE5, 0x64, 0x54, 0x07, 0xFF, 0x74, 0x01, 0x7E, 
+0x00, 0xA8, 0x07, 0x08, 0x22, 0xED, 0x30, 0xE0, 0x26, 0x75, 0xF0, 0x12, 0xEF, 0x90, 0x8B, 0xA4, 
+0xF1, 0x46, 0xEF, 0x90, 0x8B, 0xA6, 0xF1, 0x46, 0xEF, 0x90, 0x8B, 0xA8, 0xF1, 0x46, 0xEF, 0x90, 
+0x8B, 0xAA, 0xF1, 0x46, 0xEF, 0x90, 0x8B, 0xAC, 0x12, 0x04, 0x6E, 0xE4, 0xF0, 0xA3, 0xF0, 0xED, 
+0x30, 0xE1, 0x0A, 0x75, 0xF0, 0x12, 0xEF, 0xF1, 0x6F, 0xE4, 0xF0, 0xA3, 0xF0, 0xED, 0x30, 0xE2, 
+0x08, 0x75, 0xF0, 0x12, 0xEF, 0xF1, 0x64, 0xE4, 0xF0, 0xF1, 0x51, 0xE0, 0x54, 0xBF, 0x44, 0x80, 
+0xFE, 0xF1, 0x51, 0xEE, 0xF0, 0x22, 0x12, 0x04, 0x6E, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x12, 
+0x22, 0xEF, 0xC4, 0x54, 0xF0, 0x24, 0x03, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0x75, 
+0xF0, 0x12, 0xE5, 0x64, 0x90, 0x8B, 0xA2, 0x02, 0x04, 0x6E, 0x75, 0xF0, 0x12, 0xE5, 0x64, 0x90, 
+0x8B, 0xA0, 0x02, 0x04, 0x6E, 0xEF, 0x64, 0x13, 0x60, 0x04, 0xEF, 0xB4, 0x0B, 0x05, 0x90, 0x8B, 
+0x30, 0x80, 0x1F, 0xEF, 0x64, 0x12, 0x60, 0x04, 0xEF, 0xB4, 0x0A, 0x05, 0x90, 0x8B, 0x31, 0x80, 
+0x11, 0xEF, 0x64, 0x11, 0x60, 0x04, 0xEF, 0xB4, 0x09, 0x05, 0x90, 0x8B, 0x32, 0x80, 0x03, 0x90, 
+0x8B, 0x2F, 0xE0, 0xF5, 0x7F, 0xAF, 0x7F, 0x22, 0x90, 0x04, 0x85, 0xE0, 0xF5, 0x6D, 0x90, 0x8F, 
+0xC5, 0xE0, 0x04, 0xF0, 0xE4, 0xF5, 0x64, 0x90, 0x8A, 0x78, 0xE0, 0xFF, 0xE5, 0x64, 0xC3, 0x9F, 
+0x40, 0x03, 0x02, 0xC5, 0xE2, 0xE5, 0x64, 0x91, 0x1C, 0xE0, 0xF5, 0x6F, 0x12, 0xC9, 0xE8, 0xF5, 
+0x83, 0xE0, 0x65, 0x6F, 0x60, 0x18, 0x90, 0x84, 0x47, 0xE5, 0x6F, 0xF0, 0xE4, 0xA3, 0xF0, 0xAB, 
+0x64, 0xFD, 0xFF, 0x12, 0x4E, 0x09, 0x12, 0xC9, 0xE8, 0xF5, 0x83, 0xE5, 0x6F, 0xF0, 0x90, 0x04, 
+0xA0, 0xE0, 0x64, 0x01, 0x70, 0x50, 0xA3, 0xE0, 0x65, 0x64, 0x70, 0x4A, 0xA3, 0xE0, 0xF5, 0x65, 
+0xA3, 0xE0, 0x90, 0x90, 0x4A, 0xF0, 0xE5, 0x64, 0x12, 0xBC, 0x1C, 0xE0, 0x65, 0x65, 0x70, 0x02, 
+0xA1, 0xDD, 0xE5, 0x64, 0x12, 0xBC, 0x1C, 0xE5, 0x65, 0xF0, 0xE5, 0x64, 0x12, 0x97, 0x6E, 0xE0, 
+0x54, 0xFC, 0xFF, 0x90, 0x90, 0x4A, 0xE0, 0x54, 0x03, 0x4F, 0xFF, 0xE5, 0x64, 0x12, 0x97, 0x6E, 
+0xEF, 0xF0, 0x90, 0x84, 0x47, 0xE5, 0x65, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0xAB, 0x64, 0xE4, 0xFD, 
+0xFF, 0x12, 0x4E, 0x09, 0xA1, 0xDD, 0xAF, 0x64, 0x12, 0x77, 0x09, 0x75, 0xF0, 0x12, 0xE5, 0x64, 
+0x12, 0x8D, 0xF6, 0x12, 0x8F, 0x69, 0xFD, 0xD1, 0x4F, 0xED, 0xF0, 0x90, 0x90, 0x53, 0x12, 0xBB, 
+0xE8, 0xE5, 0x64, 0xF0, 0x12, 0xBE, 0xD6, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 
+0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0xFF, 0x90, 0x90, 0x57, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7B, 
+0x02, 0x12, 0xBE, 0xB5, 0x12, 0xBF, 0x6A, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0xBF, 0x5F, 0xE0, 
+0xFD, 0xE5, 0x64, 0xC4, 0x54, 0xF0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 
+0x54, 0x80, 0xFB, 0xD1, 0x4F, 0xEB, 0xF0, 0x12, 0xBE, 0xA6, 0xED, 0xF0, 0x90, 0x90, 0x51, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8F, 0xC4, 0x12, 0xBE, 0xBD, 0x7B, 0x03, 0x12, 0xBE, 0xB5, 0xAF, 
+0x64, 0x12, 0x77, 0x09, 0xEF, 0x70, 0x02, 0xA1, 0xDD, 0x75, 0xF0, 0x12, 0xE5, 0x64, 0x12, 0x8D, 
+0xF6, 0x12, 0x8F, 0x69, 0x30, 0xE0, 0x02, 0xA1, 0xDD, 0xE5, 0x64, 0x12, 0xBE, 0xD6, 0x80, 0x05, 
+0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x60, 0x02, 
+0xA1, 0xDD, 0x12, 0xBF, 0x6A, 0xE0, 0xFE, 0xA3, 0xE0, 0x4E, 0x70, 0x08, 0x12, 0xBF, 0x5F, 0xE0, 
+0x70, 0x02, 0xA1, 0xDD, 0xE5, 0x64, 0x75, 0xF0, 0x12, 0xA4, 0x24, 0xA4, 0xF9, 0x74, 0x8B, 0x35, 
+0xF0, 0xFA, 0x7B, 0x01, 0x90, 0x90, 0x3F, 0x12, 0x87, 0x6C, 0xD1, 0x43, 0xFF, 0x12, 0x03, 0x13, 
+0x2F, 0xFF, 0xB1, 0xF0, 0x2F, 0xFF, 0xD1, 0x3D, 0x2F, 0xFF, 0xD1, 0x16, 0x2F, 0xF5, 0x6E, 0x12, 
+0xBF, 0x6A, 0xE0, 0xF5, 0x6A, 0xA3, 0xE0, 0xF5, 0x6B, 0x12, 0xBF, 0x5F, 0xE0, 0xFF, 0x90, 0x90, 
+0x42, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0xE5, 0x64, 0x12, 0xBC, 0x1C, 0xE0, 0xF5, 0x65, 0x54, 0x80, 
+0xF5, 0x67, 0xE5, 0x65, 0x54, 0x7F, 0xF5, 0x66, 0x90, 0x8F, 0xC4, 0xE0, 0x60, 0x11, 0x75, 0x70, 
+0x0A, 0xB1, 0xF6, 0xE4, 0x93, 0xC3, 0x13, 0x74, 0x01, 0x93, 0x13, 0xF5, 0x71, 0x80, 0x11, 0x7B, 
+0xFF, 0x7A, 0x82, 0x79, 0xB1, 0x90, 0x8B, 0x93, 0x12, 0x87, 0x6C, 0xE4, 0xF5, 0x70, 0xF5, 0x71, 
+0xD1, 0x49, 0x12, 0x03, 0x13, 0x12, 0xAF, 0xE5, 0xD1, 0x43, 0xFF, 0x90, 0x90, 0x53, 0x12, 0xAF, 
+0xE9, 0xB1, 0xF0, 0xFF, 0x90, 0x90, 0x55, 0x12, 0xAF, 0xE9, 0xD1, 0x3D, 0xFF, 0x90, 0x90, 0x57, 
+0x12, 0xAF, 0xE9, 0x7B, 0x01, 0x12, 0xBE, 0xAD, 0xD1, 0x10, 0x12, 0xAF, 0xE5, 0x90, 0x90, 0x42, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xD1, 0x75, 0xA3, 0xE5, 0x6A, 0xF0, 0xA3, 0xE5, 0x6B, 0xF0, 0xA3, 0xE4, 
+0xF0, 0xA3, 0xE5, 0x65, 0xF0, 0x7B, 0x02, 0x12, 0xBE, 0xAD, 0x74, 0xE3, 0x25, 0x64, 0xF5, 0x82, 
+0xE4, 0x34, 0x8D, 0xF5, 0x83, 0xE0, 0xC3, 0x94, 0x05, 0x40, 0x02, 0x81, 0x4A, 0x75, 0xF0, 0x12, 
+0xE5, 0x64, 0x12, 0xBD, 0xAC, 0xFF, 0xE5, 0x66, 0xD3, 0x9F, 0x40, 0x08, 0x8F, 0x66, 0xE5, 0x66, 
+0x45, 0x67, 0xF5, 0x65, 0xE5, 0x66, 0x90, 0x82, 0x61, 0x93, 0xF5, 0x6C, 0xFD, 0xAF, 0x66, 0x12, 
+0x64, 0x02, 0x8F, 0x6C, 0xE5, 0x67, 0x60, 0x04, 0x05, 0x6C, 0x05, 0x6C, 0x90, 0x04, 0x8C, 0xE0, 
+0x64, 0x01, 0x70, 0x28, 0xE5, 0x66, 0xC3, 0x94, 0x0C, 0x40, 0x21, 0x74, 0x84, 0x25, 0x66, 0xF5, 
+0x82, 0xE4, 0x34, 0x04, 0xF5, 0x83, 0xE0, 0xFF, 0x54, 0x7F, 0xFE, 0xEF, 0x30, 0xE7, 0x06, 0xE5, 
+0x6C, 0x2E, 0xFF, 0x80, 0x05, 0xC3, 0xE5, 0x6C, 0x9E, 0xFF, 0x8F, 0x6C, 0xE5, 0x6C, 0xD3, 0x94, 
+0x1A, 0xAF, 0x6C, 0x40, 0x02, 0x7F, 0x1A, 0x8F, 0x6C, 0x12, 0x99, 0x69, 0x7B, 0x03, 0xFA, 0x12, 
+0xBE, 0xAF, 0xE5, 0x65, 0x90, 0x82, 0xD9, 0x93, 0xFF, 0xD3, 0x90, 0x90, 0x43, 0xE0, 0x9F, 0x90, 
+0x90, 0x42, 0xE0, 0x94, 0x00, 0x40, 0x02, 0x80, 0x6E, 0xC3, 0xE5, 0x6B, 0x94, 0x0A, 0xE5, 0x6A, 
+0x94, 0x00, 0x40, 0x02, 0x61, 0x5A, 0x12, 0xB6, 0x64, 0xE0, 0xC3, 0x94, 0x01, 0x40, 0x06, 0x12, 
+0xB6, 0x64, 0xE0, 0x14, 0xF0, 0xD1, 0x10, 0xFF, 0x90, 0x90, 0x43, 0xE0, 0x2F, 0xFF, 0x90, 0x90, 
+0x42, 0xE0, 0xD1, 0x1C, 0xB1, 0xEF, 0x2F, 0xFD, 0xEE, 0x35, 0xF0, 0xFC, 0xE5, 0x6A, 0xC3, 0x13, 
+0xFE, 0xE5, 0x6B, 0x13, 0xFF, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x34, 0xE5, 0x64, 0x94, 0x05, 
+0x50, 0x06, 0x12, 0xB6, 0x64, 0x74, 0x03, 0xF0, 0x90, 0x90, 0x51, 0xE5, 0x6A, 0xF0, 0xA3, 0xE5, 
+0x6B, 0xF0, 0xE5, 0x6A, 0xC3, 0x13, 0xA3, 0xF0, 0xE5, 0x6B, 0x13, 0xA3, 0x12, 0xB6, 0x36, 0x12, 
+0xBE, 0xBD, 0x7B, 0x01, 0x12, 0xBA, 0x40, 0x7D, 0x01, 0xAF, 0x64, 0x12, 0xBC, 0xBC, 0x81, 0x4A, 
+0xD1, 0x49, 0x12, 0x03, 0x13, 0x65, 0x6E, 0x70, 0x02, 0xE5, 0xF0, 0x70, 0x5B, 0x90, 0x90, 0x51, 
+0xF0, 0xA3, 0xE5, 0x6E, 0xF0, 0xC3, 0x13, 0xFF, 0xA3, 0xE4, 0xF0, 0xA3, 0xEF, 0x12, 0xB6, 0x36, 
+0x12, 0xBE, 0xBD, 0x7B, 0x02, 0x12, 0xBA, 0x40, 0xE5, 0x64, 0xC3, 0x94, 0x05, 0x50, 0x10, 0x12, 
+0xB6, 0x64, 0xE0, 0xD3, 0x94, 0x00, 0x40, 0x07, 0x12, 0x99, 0x64, 0x7B, 0x03, 0x80, 0x0C, 0xE5, 
+0x6E, 0xC3, 0x94, 0x03, 0x50, 0x12, 0x12, 0x99, 0x64, 0x7B, 0x04, 0xFA, 0x12, 0xBA, 0x42, 0x7D, 
+0x06, 0xAF, 0x64, 0x12, 0xBE, 0xF5, 0xA1, 0xDD, 0xE4, 0xFD, 0xAF, 0x64, 0x12, 0xBA, 0xB0, 0x7D, 
+0x07, 0xAF, 0x64, 0x12, 0xBE, 0xF5, 0x81, 0x4A, 0x12, 0x99, 0x64, 0x7B, 0x08, 0xFA, 0x12, 0xBA, 
+0x42, 0x7D, 0x01, 0xAF, 0x64, 0x12, 0x63, 0xA2, 0x81, 0x4A, 0x12, 0xB6, 0x64, 0xE4, 0xF0, 0x90, 
+0x84, 0x61, 0x74, 0x02, 0xF0, 0xAB, 0x6C, 0xAD, 0x64, 0xAF, 0x6B, 0xAE, 0x6A, 0x12, 0x42, 0x43, 
+0x8E, 0x68, 0x8F, 0x69, 0xB1, 0xF6, 0xC3, 0x74, 0x01, 0x93, 0x95, 0x71, 0xFF, 0xE4, 0x93, 0x94, 
+0x00, 0xFE, 0xD3, 0xE5, 0x69, 0x9F, 0xE5, 0x68, 0x9E, 0x40, 0x34, 0xB1, 0xE3, 0xE4, 0xF0, 0x7D, 
+0x01, 0xAF, 0x64, 0x12, 0xBA, 0xB0, 0xB1, 0xF6, 0xC3, 0x74, 0x01, 0x93, 0x95, 0x71, 0xFE, 0xE4, 
+0x93, 0x94, 0x00, 0x90, 0x90, 0x53, 0xF0, 0xA3, 0xCE, 0xF0, 0x90, 0x90, 0x51, 0xE5, 0x68, 0xF0, 
+0xA3, 0xE5, 0x69, 0xF0, 0xE4, 0x90, 0x90, 0x55, 0x12, 0x99, 0x77, 0x7B, 0x01, 0x80, 0x24, 0xD1, 
+0x35, 0xC3, 0xE5, 0x69, 0x9F, 0xE5, 0x68, 0x94, 0x00, 0x50, 0x22, 0xB1, 0xE3, 0xE4, 0xF0, 0x7D, 
+0x01, 0xAF, 0x64, 0x12, 0xBC, 0xBC, 0xD1, 0x2B, 0x12, 0xBE, 0xA6, 0xEF, 0xF0, 0xE4, 0x12, 0x99, 
+0x76, 0x7B, 0x02, 0xFA, 0x7D, 0x05, 0x7F, 0x01, 0x12, 0xBA, 0x46, 0x80, 0x5D, 0x7D, 0x07, 0xAF, 
+0x64, 0x12, 0xBE, 0xF5, 0xB1, 0xF6, 0xE4, 0x93, 0xFF, 0x74, 0x01, 0x93, 0xD1, 0x75, 0xD1, 0x2B, 
+0xD1, 0x4F, 0xEF, 0xF0, 0xB1, 0xE3, 0x12, 0xBE, 0xBD, 0x7B, 0x03, 0x7A, 0x00, 0x7D, 0x05, 0x7F, 
+0x01, 0x12, 0xBA, 0x46, 0xB1, 0xE3, 0xE0, 0x04, 0xF0, 0xE5, 0x66, 0x90, 0x82, 0xED, 0x93, 0x25, 
+0x70, 0xFF, 0xE4, 0x33, 0xFE, 0xB1, 0xE3, 0xE0, 0xC3, 0x9F, 0xEE, 0xD1, 0x8C, 0x40, 0x1B, 0xB1, 
+0xE3, 0xE4, 0xD1, 0x34, 0xB1, 0xF6, 0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 0x93, 0x34, 0x00, 0xC3, 
+0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x64, 0x12, 0xBD, 0xCA, 0x75, 0xF0, 0x12, 0xE5, 0x64, 0x90, 
+0x8B, 0xA3, 0x12, 0x04, 0x6E, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xA1, 0xC0, 0xD1, 0x49, 0xD1, 0x43, 
+0xFF, 0xAE, 0xF0, 0x12, 0x03, 0x13, 0x2F, 0xFF, 0xE5, 0xF0, 0x3E, 0xB1, 0xEF, 0x2F, 0xFF, 0xEE, 
+0xD1, 0x1C, 0xFE, 0x90, 0x00, 0x08, 0xD1, 0x22, 0x90, 0x90, 0x44, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 
+0x03, 0x13, 0xFF, 0xC3, 0x90, 0x90, 0x45, 0xE0, 0x9F, 0xFE, 0x90, 0x90, 0x44, 0xE0, 0x95, 0xF0, 
+0x90, 0x90, 0x46, 0xF0, 0xA3, 0xCE, 0xF0, 0xD1, 0x3D, 0xFD, 0xAC, 0xF0, 0x25, 0xE0, 0xFF, 0xEC, 
+0x33, 0xFE, 0xEF, 0x2D, 0xFD, 0xEE, 0x3C, 0xFC, 0xB1, 0xF0, 0x25, 0xE0, 0xFF, 0xE5, 0xF0, 0x33, 
+0xFE, 0x90, 0x00, 0x02, 0xD1, 0x22, 0xCF, 0x2D, 0xFD, 0xEF, 0x3C, 0xFC, 0xD1, 0x10, 0xAE, 0xF0, 
+0x78, 0x02, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x2D, 0xFF, 0xEC, 0x3E, 0x90, 0x90, 0x48, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x90, 0x42, 0xD1, 0x62, 0x24, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 
+0xD1, 0x04, 0x50, 0x07, 0x90, 0x90, 0x42, 0xD1, 0x56, 0x80, 0x04, 0x7E, 0xFF, 0x7F, 0xFF, 0xE5, 
+0x64, 0x25, 0xE0, 0x24, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0x12, 0xBD, 0xD3, 0x90, 0x90, 0x44, 
+0xD1, 0x62, 0x24, 0x93, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xD1, 0x04, 0x50, 0x07, 0x90, 0x90, 0x44, 
+0xD1, 0x56, 0x80, 0x04, 0x7E, 0xFF, 0x7F, 0xFF, 0xE5, 0x64, 0x25, 0xE0, 0x24, 0x93, 0xF5, 0x82, 
+0xE4, 0x34, 0x8D, 0x12, 0xBD, 0xD3, 0x90, 0x90, 0x48, 0xD1, 0x62, 0x24, 0xC3, 0xF5, 0x82, 0xE4, 
+0x34, 0x8D, 0xD1, 0x04, 0x50, 0x07, 0x90, 0x90, 0x48, 0xD1, 0x56, 0x80, 0x04, 0x7E, 0xFF, 0x7F, 
+0xFF, 0xE5, 0x64, 0x25, 0xE0, 0x24, 0xC3, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0x12, 0xBD, 0xD3, 0xC3, 
+0x74, 0xFF, 0x95, 0x6B, 0xFF, 0x74, 0xFF, 0x95, 0x6A, 0xFE, 0xD1, 0x7E, 0x34, 0x8D, 0xD1, 0x04, 
+0x50, 0x0A, 0xE5, 0x6B, 0x2D, 0xFF, 0xE5, 0x6A, 0x3C, 0xFE, 0x80, 0x04, 0x7E, 0xFF, 0x7F, 0xFF, 
+0xD1, 0x7E, 0x34, 0x8D, 0x12, 0xBD, 0xD3, 0x90, 0x90, 0x46, 0xE0, 0xFE, 0xA3, 0xE0, 0xFB, 0xC3, 
+0x74, 0xFF, 0x9B, 0xFF, 0x74, 0xFF, 0x9E, 0xFE, 0x74, 0xFF, 0x94, 0x00, 0xFD, 0x74, 0xFF, 0x94, 
+0x00, 0xFC, 0x90, 0x8C, 0xDE, 0x12, 0x87, 0x57, 0xD3, 0x12, 0x03, 0xDA, 0x50, 0x16, 0x90, 0x90, 
+0x46, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0x90, 0x8C, 0xDE, 0x12, 0x87, 0x57, 0x12, 
+0x87, 0x30, 0x80, 0x06, 0x74, 0xFF, 0xFF, 0xFE, 0xFD, 0xFC, 0x90, 0x8C, 0xDE, 0x12, 0x04, 0x31, 
+0xE4, 0xF5, 0x6E, 0xFD, 0xAF, 0x64, 0x12, 0x63, 0xA2, 0xE4, 0x90, 0x90, 0x51, 0xF0, 0x12, 0x99, 
+0x72, 0xA3, 0xF0, 0x7B, 0x01, 0xFA, 0x7D, 0xFF, 0x7F, 0x01, 0x12, 0xBA, 0x46, 0x05, 0x64, 0x02, 
+0xBF, 0xB7, 0x22, 0x74, 0x13, 0x25, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0xFE, 
+0x90, 0x00, 0x04, 0x02, 0x03, 0x3E, 0xE5, 0x66, 0x25, 0xE0, 0x24, 0x75, 0xF5, 0x82, 0xE4, 0x34, 
+0x82, 0xF5, 0x83, 0x22, 0xF5, 0x83, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xD3, 0x9F, 0xEC, 0x9E, 0x22, 
+0x90, 0x90, 0x3F, 0x12, 0x87, 0x63, 0x90, 0x00, 0x08, 0x02, 0x03, 0x3E, 0x35, 0xF0, 0xFE, 0x90, 
+0x00, 0x06, 0x12, 0x03, 0x3E, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 0x22, 0x90, 0x90, 0x51, 0xE5, 0x68, 
+0xF0, 0xA3, 0xE5, 0x69, 0xF0, 0xE5, 0x66, 0x90, 0x82, 0x9D, 0x93, 0xFF, 0x22, 0x90, 0x00, 0x06, 
+0x02, 0x03, 0x3E, 0x90, 0x00, 0x02, 0x02, 0x03, 0x3E, 0x90, 0x90, 0x3F, 0x02, 0x87, 0x63, 0x90, 
+0x90, 0x55, 0xE4, 0xF0, 0xA3, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xED, 0x2F, 0xFF, 0xEC, 0x3E, 
+0xFE, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 0x74, 0xFF, 0x9F, 0xFF, 0x74, 0xFF, 0x9E, 0xFE, 
+0xE5, 0x64, 0x25, 0xE0, 0x22, 0x90, 0x90, 0x53, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xE5, 0x64, 
+0x25, 0xE0, 0x24, 0xF3, 0xF5, 0x82, 0xE4, 0x22, 0xE0, 0xD3, 0x9D, 0xEC, 0x64, 0x80, 0xF8, 0x74, 
+0x80, 0x98, 0x22, 0xAC, 0x07, 0x90, 0x8A, 0x7F, 0xE0, 0x12, 0x8F, 0x69, 0x30, 0xE0, 0x02, 0xE1, 
+0x4A, 0x90, 0x8A, 0x7E, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x04, 0x90, 0x8A, 
+0x98, 0xF0, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x03, 0x90, 0x8A, 0x97, 0xF0, 0x80, 0x0D, 0x90, 0x8A, 
+0x98, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0x97, 0x14, 0xF0, 0x0B, 0x0B, 0x90, 0x8A, 0x97, 0xE0, 0xFA, 
+0x90, 0x8A, 0x96, 0xE0, 0xD3, 0x9A, 0x50, 0x0D, 0x90, 0x8A, 0x8B, 0xEB, 0xF0, 0x90, 0x8A, 0x98, 
+0xE0, 0xC3, 0x9D, 0x80, 0x11, 0xC3, 0xED, 0x9A, 0x2B, 0x90, 0x8A, 0x8B, 0xF0, 0x90, 0x8A, 0x97, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x2C, 0x90, 0x8A, 0x9B, 0xF0, 0x90, 0x8A, 0x98, 0xE0, 0xFF, 
+0x24, 0x0A, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x8A, 0x9B, 0xD1, 0x88, 0x40, 0x04, 0xEF, 0x24, 0x0A, 
+0xF0, 0x90, 0x8A, 0x9B, 0xE0, 0xFF, 0x24, 0x23, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x8A, 0x8B, 0xD1, 
+0x88, 0x40, 0x04, 0xEF, 0x24, 0x23, 0xF0, 0x90, 0x8A, 0x9B, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x8A, 
+0x8F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xE0, 0x6F, 0x70, 0x01, 0xE4, 0x60, 0x02, 
+0xF1, 0x52, 0x90, 0x8A, 0x80, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x8A, 0x80, 0xE0, 0x44, 0x01, 
+0xF0, 0x22, 0x90, 0x8A, 0x8F, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 0x01, 0xCF, 0xE0, 
+0x90, 0x90, 0xC7, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 
+0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 
+0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x75, 0x87, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 
+0x7F, 0x03, 0x12, 0x7A, 0xA5, 0x80, 0xFE, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x8F, 0xDB, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x6F, 0xC1, 0x90, 0x8F, 0xE5, 0x12, 0x04, 0x31, 
+0x90, 0x8F, 0xDD, 0x12, 0x04, 0xB2, 0x12, 0x03, 0xCD, 0x90, 0x8F, 0xE5, 0x12, 0x87, 0x57, 0x12, 
+0x87, 0x3D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x8F, 0xDD, 0x12, 0x04, 0xB2, 
+0x90, 0x8F, 0xE1, 0x12, 0x87, 0x57, 0x12, 0x87, 0x3D, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 
+0x00, 0x12, 0x87, 0x4A, 0x90, 0x8F, 0xE9, 0x12, 0x04, 0x31, 0x90, 0x8F, 0xE9, 0x12, 0x94, 0x6A, 
+0x90, 0x8F, 0xDB, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x6F, 0xFE, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x01, 0xC4, 0x74, 0x00, 0xF0, 0x74, 0xC8, 0xA3, 0xF0, 0x7F, 0x90, 0x12, 0x7A, 0xB8, 0xEF, 
+0x20, 0xE0, 0xF7, 0x74, 0x00, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xC8, 0xA3, 0xF0, 0x22, 0x90, 
+0x90, 0xE7, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x11, 0x48, 0xE0, 0x90, 
+0x90, 0xED, 0xF0, 0xED, 0x90, 0x00, 0x73, 0x70, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 
+0x54, 0xFB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x89, 0x7C, 0xA3, 0xE0, 0x24, 0x7F, 0xF5, 
+0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0x7D, 0x07, 0xEF, 0x5D, 0xC3, 0x60, 0x0A, 0x11, 0x6C, 
+0x24, 0x08, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x03, 0x11, 0x6C, 0xFF, 0x22, 0x74, 0xFF, 0x9D, 0xFD, 
+0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x1E, 0x90, 0x8A, 0xFC, 0xE0, 0x60, 0x05, 0x75, 0x0F, 0x40, 
+0x21, 0x27, 0x90, 0x8A, 0x85, 0xE0, 0xD3, 0x94, 0x00, 0x40, 0x02, 0x80, 0x2D, 0x90, 0x8A, 0xE9, 
+0xE0, 0x60, 0x7B, 0x80, 0x55, 0x12, 0x79, 0x80, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x75, 0x0F, 0x01, 
+0x80, 0x75, 0x90, 0x8A, 0x87, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x05, 0x75, 0x0F, 0x02, 0x80, 0x67, 
+0x90, 0x8A, 0x85, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x05, 0x75, 0x0F, 0x04, 0x80, 0x58, 0xEF, 
+0x30, 0xE2, 0x05, 0x75, 0x0F, 0x08, 0x80, 0x4F, 0x90, 0x8A, 0x87, 0xE0, 0x30, 0xE4, 0x05, 0x75, 
+0x0F, 0x10, 0x80, 0x43, 0x90, 0x8A, 0x7F, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x05, 0x75, 
+0x0F, 0x20, 0x80, 0x33, 0x90, 0x8A, 0xE9, 0xE0, 0x60, 0x05, 0x75, 0x0F, 0x80, 0x80, 0x28, 0x90, 
+0x06, 0x62, 0xE0, 0x30, 0xE1, 0x05, 0x75, 0x0F, 0x11, 0x80, 0x1C, 0x90, 0x06, 0x62, 0xE0, 0x30, 
+0xE0, 0x0C, 0xE0, 0x54, 0xFC, 0xFF, 0xBF, 0x80, 0x05, 0x75, 0x0F, 0x12, 0x80, 0x09, 0x90, 0x01, 
+0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x80, 0x0E, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x90, 0x01, 0xB8, 
+0xE5, 0x0F, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x02, 0x87, 0xE0, 0x60, 0x02, 
+0x80, 0x08, 0x90, 0x01, 0x00, 0xE0, 0x64, 0x3F, 0x60, 0x05, 0x75, 0x63, 0x01, 0x80, 0x34, 0x90, 
+0x02, 0x96, 0xE0, 0x60, 0x05, 0x75, 0x63, 0x10, 0x80, 0x29, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 
+0x02, 0x80, 0x07, 0x90, 0x02, 0x86, 0xE0, 0x30, 0xE3, 0x05, 0x75, 0x63, 0x04, 0x80, 0x14, 0x90, 
+0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x05, 0x75, 0x63, 0x20, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 
+0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x63, 0xF0, 0x7F, 
+0x00, 0x22, 0x90, 0x8F, 0xA8, 0xE0, 0x30, 0xE0, 0x34, 0xC4, 0x13, 0x54, 0x07, 0x20, 0xE0, 0x2D, 
+0x90, 0x91, 0x1D, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0xC8, 0x40, 0x21, 0x90, 0x8F, 0xA8, 0xE0, 
+0x44, 0x20, 0xF0, 0xE4, 0x90, 0x91, 0x1D, 0xF0, 0x90, 0x8F, 0xA8, 0xE0, 0x13, 0x30, 0xE0, 0x0D, 
+0x90, 0x8A, 0x7E, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x8A, 0x8E, 0x74, 0xD0, 0xF0, 0x22, 0x74, 0x43, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 
+0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0x22, 0x74, 0x23, 0x25, 0x64, 0xF5, 0x82, 0xE4, 0x34, 
+0x8D, 0x22, 0x12, 0xB0, 
+};
+u4Byte ArrayLength_MP_8703B_FW_AP = 18964;
+
+
+void
+ODM_ReadFirmware_MP_8703B_FW_AP(
+	IN   PDM_ODM_T    pDM_Odm,
+	OUT  u1Byte       *pFirmware,
+	OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8703B_FW_AP;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8703B_FW_AP, ArrayLength_MP_8703B_FW_AP);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8703B_FW_AP;
+}
+
+
+#endif /* #if (defined(CONFIG_AP_WOWLAN)||(DM_ODM_SUPPORT_TYPE & (ODM_AP)) */
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN)) || (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+
+
+u1Byte Array_MP_8703B_FW_NIC[] = {
+0xB2, 0x03, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x26, 0x17, 0x21, 0xB0, 0x51, 0x02, 0x00, 
+0x4F, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x86, 0xAD, 0x02, 0xC5, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB5, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xC6, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xC5, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xBC, 0x4E, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xC5, 0xD1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x87, 0x9E, 0x02, 0x88, 0xEE, 0x02, 0x80, 0x86, 0x02, 0x80, 0x89, 0x02, 0xA1, 0xB4, 0x02, 
+0xAA, 0x73, 0x02, 0xB6, 0xED, 0x02, 0x80, 0x95, 0x02, 0x80, 0x98, 0x02, 0x80, 0x9B, 0x02, 0x80, 
+0x9E, 0x02, 0x80, 0xA1, 0x02, 0x80, 0xA4, 0x02, 0x80, 0xA7, 0x02, 0x80, 0xAA, 0x02, 0x80, 0xAD, 
+0x02, 0x80, 0xB0, 0x02, 0x8C, 0x55, 0x02, 0x80, 0xB6, 0x02, 0x80, 0xB9, 0x02, 0x80, 0xBC, 0x02, 
+0x80, 0xBF, 0x02, 0x80, 0xC2, 0x02, 0x80, 0xC5, 0x02, 0x80, 0xC8, 0x02, 0x80, 0xCB, 0x02, 0x80, 
+0xCE, 0x02, 0x80, 0xD1, 0x02, 0xCC, 0x8B, 0x02, 0x80, 0xD7, 0x02, 0x80, 0xDA, 0x02, 0x80, 0xDD, 
+0x02, 0x80, 0xE0, 0x02, 0x80, 0xE3, 0x02, 0x80, 0xE6, 0x02, 0x80, 0xE9, 0x02, 0x80, 0xEC, 0x00, 
+0x00, 0x00, 0x02, 0x80, 0xF2, 0x00, 0x00, 0x00, 0x02, 0x80, 0xF8, 0x02, 0x80, 0xFB, 0x02, 0x80, 
+0xFE, 0x02, 0x81, 0x01, 0x02, 0x81, 0x04, 0x02, 0x81, 0x07, 0x02, 0x81, 0x0A, 0x02, 0x81, 0x0D, 
+0x02, 0x81, 0x10, 0x02, 0x81, 0x13, 0x02, 0x81, 0x16, 0x02, 0x81, 0x19, 0x02, 0x81, 0x1C, 0x02, 
+0xCB, 0x7E, 0x02, 0x81, 0x22, 0x02, 0x81, 0x25, 0x02, 0x81, 0x28, 0x02, 0x81, 0x2B, 0x02, 0x81, 
+0x2E, 0x02, 0x81, 0x31, 0x02, 0xB8, 0x26, 0x02, 0xA5, 0x92, 0x02, 0xA4, 0x03, 0x02, 0x96, 0xA5, 
+0x02, 0xC9, 0x6D, 0x02, 0xAB, 0xD7, 0x02, 0xCE, 0x86, 0x02, 0x81, 0x49, 0x02, 0x81, 0x4C, 0x02, 
+0x81, 0x4F, 0x02, 0x81, 0x52, 0x02, 0x81, 0x55, 0x02, 0x81, 0x58, 0x02, 0x81, 0x5B, 0x02, 0xA6, 
+0x2F, 0x02, 0x81, 0x61, 0x02, 0x81, 0x64, 0x02, 0xCF, 0x43, 0x02, 0x81, 0x6A, 0x02, 0x81, 0x6D, 
+0x02, 0x81, 0x70, 0x02, 0xCB, 0x84, 0x02, 0xA4, 0x70, 0x02, 0x98, 0x3E, 0x00, 0x00, 0x00, 0x00, 
+0x15, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 
+0xFF, 0x0F, 0x00, 0x00, 0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 
+0x00, 0x00, 0x00, 0x10, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 
+0x08, 0x03, 0x03, 0x00, 0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 0x02, 0x00, 
+0x04, 0x08, 0x05, 0x03, 0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 0x0A, 0x07, 
+0x04, 0x00, 0x08, 0x0B, 0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 0x08, 0x0B, 
+0x0A, 0x03, 0x02, 0x00, 0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 0x04, 0x00, 
+0x10, 0x24, 0x22, 0x1C, 0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 0x22, 0x14, 
+0x06, 0x00, 0x20, 0x24, 0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 0x20, 0x23, 
+0x21, 0x0C, 0x04, 0x00, 0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 0x04, 0x00, 
+0x20, 0x21, 0x1F, 0x16, 0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 0x2F, 0x18, 
+0x10, 0x00, 0x30, 0x31, 0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 0x30, 0x31, 
+0x28, 0x14, 0x00, 0x00, 0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 0x00, 0x00, 
+0x30, 0x04, 0x04, 0x04, 0x05, 0x08, 0x08, 0x09, 0x09, 0x0C, 0x0E, 0x10, 0x12, 0x06, 0x0B, 0x0D, 
+0x0E, 0x0F, 0x11, 0x12, 0x14, 0x00, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x23, 0x00, 
+0x2D, 0x00, 0x50, 0x00, 0x91, 0x00, 0xC3, 0x01, 0x27, 0x01, 0x31, 0x01, 0x5E, 0x00, 0xC8, 0x00, 
+0xF0, 0x00, 0xDC, 0x01, 0x5E, 0x01, 0x68, 0x01, 0x9A, 0x01, 0xCC, 0x01, 0xEA, 0x02, 0x02, 0x04, 
+0x08, 0x0C, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x14, 0x28, 0x32, 0x50, 0x78, 0xA0, 0xC8, 
+0xE6, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x02, 0x04, 0x06, 
+0x07, 0x07, 0x08, 0x08, 0x08, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
+0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
+0x02, 0x03, 0x03, 0x04, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x03, 0x03, 0x03, 
+0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
+0x02, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x84, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x87, 0x8E, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x87, 0x8E, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x84, 0x4D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x84, 0x4C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x84, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x86, 0xEB, 
+0x02, 0x84, 0xDD, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 
+0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 
+0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 
+0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x87, 0x94, 0xE4, 0x7E, 
+0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 
+0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 
+0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 
+0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 
+0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 
+0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 
+0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 
+0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 
+0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xBE, 0xF1, 
+0xC4, 0x75, 0xC5, 0x21, 0x41, 0x91, 0x55, 0x00, 0x00, 0x12, 0x5A, 0x18, 0x7F, 0x04, 0x90, 0x8F, 
+0xFF, 0xEF, 0xF0, 0x7F, 0x02, 0xD1, 0x27, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 0x90, 0x8F, 0xFF, 0xE0, 
+0xFE, 0xEF, 0x4E, 0x90, 0x89, 0x7E, 0xF0, 0x22, 0x90, 0x90, 0xD0, 0x74, 0x12, 0xF0, 0x90, 0x90, 
+0xDE, 0x74, 0x05, 0xF0, 0x90, 0x90, 0xD2, 0xF1, 0xE6, 0x90, 0x90, 0xCE, 0xE0, 0x90, 0x90, 0xD5, 
+0xF0, 0x90, 0x90, 0xCF, 0xE0, 0x90, 0x90, 0xD6, 0xF0, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xD0, 0x12, 
+0x5A, 0x18, 0x7F, 0x04, 0x80, 0xB8, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x22, 0x90, 
+0x02, 0x09, 0xE0, 0xF5, 0x5D, 0x12, 0x02, 0x06, 0x25, 0x5D, 0x90, 0x89, 0x83, 0xF0, 0xF1, 0x91, 
+0x25, 0x5D, 0x90, 0x89, 0x84, 0xB1, 0xBF, 0x25, 0x5D, 0x90, 0x89, 0x85, 0x11, 0x2B, 0x25, 0x5D, 
+0x90, 0x89, 0x86, 0xF1, 0xD1, 0x25, 0x5D, 0x90, 0x89, 0x87, 0xF1, 0xE2, 0x25, 0x5D, 0x90, 0x89, 
+0x88, 0x12, 0xA9, 0x90, 0x25, 0x5D, 0x90, 0x89, 0x89, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x03, 0x02, 
+0x02, 0x1F, 0x51, 0x21, 0x12, 0x02, 0x06, 0xFE, 0x24, 0x33, 0x91, 0x4D, 0xE0, 0x54, 0x98, 0x91, 
+0x49, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x27, 0x11, 0x2C, 0x54, 0x01, 0xFD, 0xEF, 0x4D, 
+0xD0, 0x82, 0xD0, 0x83, 0x91, 0x49, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x27, 0x11, 0x2C, 
+0x54, 0x02, 0xFD, 0xEF, 0x4D, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x49, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 
+0xFF, 0x51, 0x27, 0x11, 0x2C, 0x54, 0x04, 0xFD, 0xEF, 0x4D, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x49, 
+0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x27, 0x11, 0x2C, 0x54, 0x40, 0xFD, 0xEF, 0x4D, 0xD0, 
+0x82, 0xD0, 0x83, 0x91, 0x49, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x51, 0x27, 0x11, 0x2C, 0x54, 
+0x20, 0xFD, 0xEF, 0x4D, 0xD0, 0x82, 0xD0, 0x83, 0x11, 0x2B, 0x7F, 0x00, 0x30, 0xE2, 0x02, 0x7F, 
+0x01, 0x90, 0x8F, 0x80, 0xEF, 0xF0, 0xEE, 0xC3, 0x94, 0x10, 0x50, 0x0B, 0x51, 0x27, 0xB1, 0xC0, 
+0xFF, 0xF1, 0xC6, 0xEF, 0xF0, 0x80, 0x0C, 0xEE, 0xB4, 0x10, 0x08, 0x51, 0x27, 0xB1, 0xC0, 0x90, 
+0x8D, 0x02, 0xF0, 0x91, 0x4A, 0xE0, 0x30, 0xE5, 0x14, 0x75, 0xF0, 0x12, 0xEE, 0xB1, 0xCB, 0x13, 
+0x13, 0x54, 0x03, 0xFB, 0xAF, 0x06, 0xF1, 0xC6, 0xE0, 0xFD, 0x12, 0x6A, 0xFD, 0x22, 0x90, 0x90, 
+0xC2, 0x12, 0x87, 0x5F, 0x90, 0x90, 0xC1, 0xEF, 0xF0, 0x12, 0x87, 0x68, 0x89, 0x6C, 0x00, 0x89, 
+0x71, 0x01, 0x89, 0x75, 0x10, 0x89, 0x7A, 0x11, 0x89, 0x7F, 0x12, 0x89, 0x84, 0x14, 0x8A, 0x1A, 
+0x15, 0x89, 0x89, 0x16, 0x89, 0x8D, 0x18, 0x89, 0x92, 0x19, 0x89, 0x97, 0x1C, 0x89, 0x9B, 0x20, 
+0x89, 0xA0, 0x24, 0x89, 0xA5, 0x25, 0x89, 0xAA, 0x27, 0x89, 0xAF, 0x40, 0x89, 0xB3, 0x42, 0x8A, 
+0x1A, 0x47, 0x8A, 0x1A, 0x49, 0x89, 0xB7, 0x60, 0x89, 0xBB, 0x61, 0x89, 0xC0, 0x62, 0x89, 0xC5, 
+0x63, 0x89, 0xCA, 0x64, 0x89, 0xCF, 0x65, 0x89, 0xD4, 0x66, 0x89, 0xD9, 0x67, 0x89, 0xDE, 0x68, 
+0x89, 0xE3, 0x69, 0x89, 0xE8, 0x6B, 0x89, 0xED, 0x6C, 0x89, 0xF2, 0x6D, 0x89, 0xF7, 0x6E, 0x89, 
+0xFC, 0x6F, 0x8A, 0x01, 0x70, 0x8A, 0x06, 0xC3, 0x00, 0x00, 0x8A, 0x0B, 0x51, 0x1B, 0x02, 0x87, 
+0xEF, 0x51, 0x1B, 0xE1, 0xF9, 0x51, 0x1B, 0x02, 0x9F, 0xFE, 0x51, 0x1B, 0x02, 0x90, 0x9C, 0x51, 
+0x1B, 0x02, 0xB0, 0x35, 0x51, 0x1B, 0x02, 0xB0, 0xCD, 0x51, 0x1B, 0xE1, 0xA4, 0x51, 0x1B, 0x02, 
+0xA8, 0x01, 0x51, 0x1B, 0x02, 0xAF, 0xF7, 0x51, 0x1B, 0xE1, 0x3A, 0x51, 0x1B, 0x02, 0xB0, 0xDC, 
+0x51, 0x1B, 0x02, 0xAC, 0x39, 0x51, 0x1B, 0x02, 0xB7, 0xEA, 0x51, 0x1B, 0x02, 0xBF, 0xE6, 0x51, 
+0x1B, 0x81, 0x55, 0x51, 0x1B, 0x01, 0x32, 0x51, 0x1B, 0x80, 0x72, 0x51, 0x1B, 0x02, 0x79, 0x0F, 
+0x51, 0x1B, 0x02, 0x7B, 0xBB, 0x51, 0x1B, 0x02, 0x7A, 0x6A, 0x51, 0x1B, 0x02, 0x60, 0x68, 0x51, 
+0x1B, 0x02, 0x7B, 0x1C, 0x51, 0x1B, 0x02, 0x72, 0xF1, 0x51, 0x1B, 0x02, 0x4E, 0xA5, 0x51, 0x1B, 
+0x02, 0x78, 0xB2, 0x51, 0x1B, 0x02, 0x43, 0x1E, 0x51, 0x1B, 0x02, 0xBE, 0x52, 0x51, 0x1B, 0x02, 
+0x78, 0x32, 0x51, 0x1B, 0x02, 0x5C, 0xE4, 0x51, 0x1B, 0x02, 0x74, 0x98, 0x51, 0x1B, 0x02, 0x77, 
+0x58, 0x51, 0x1B, 0x02, 0x62, 0x0D, 0x51, 0x1B, 0x02, 0xC0, 0x26, 0x90, 0x01, 0xC0, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0x90, 0xC1, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0x90, 0xC2, 0x02, 0x87, 
+0x56, 0x90, 0x90, 0xC5, 0x12, 0x87, 0x5F, 0x90, 0x90, 0xC5, 0x02, 0x87, 0x56, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x51, 0x21, 0x12, 0xBF, 0xCE, 0x7A, 0x8A, 0x79, 0xEA, 0x12, 0x68, 0xAB, 
+0x51, 0x27, 0x12, 0x02, 0x06, 0x20, 0xE0, 0x02, 0x61, 0xAE, 0x90, 0x05, 0x54, 0xE0, 0x90, 0x8A, 
+0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 0xFA, 0xF0, 0x90, 0x8A, 0xED, 0xE0, 0xC4, 0x54, 0x0F, 
+0x30, 0xE0, 0x13, 0xF1, 0x91, 0x90, 0x8A, 0xEB, 0xF0, 0x24, 0x0A, 0x90, 0x8B, 0x1C, 0xB1, 0xBF, 
+0x90, 0x8A, 0xEC, 0xF0, 0x80, 0x48, 0xF1, 0x91, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x14, 0xEF, 0xC3, 
+0x94, 0x03, 0x50, 0x07, 0x90, 0x8A, 0xEB, 0x74, 0x03, 0x80, 0x0C, 0xF1, 0x91, 0x90, 0x8A, 0xEB, 
+0x80, 0x05, 0x90, 0x8A, 0xEB, 0x74, 0x2A, 0xF0, 0x24, 0x0A, 0x90, 0x8B, 0x1C, 0xF0, 0xB1, 0xC0, 
+0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x12, 0xEF, 0xC3, 0x94, 0x03, 0x90, 0x8A, 0xEC, 0x50, 0x05, 0x74, 
+0x03, 0xF0, 0x80, 0x0A, 0xEF, 0xF0, 0x80, 0x06, 0x90, 0x8A, 0xEC, 0x74, 0x2A, 0xF0, 0x12, 0xA4, 
+0x61, 0x30, 0xE0, 0x3D, 0x90, 0x8A, 0xEB, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0x8A, 0xF3, 0xF0, 
+0xE0, 0xC3, 0x13, 0xA3, 0xF0, 0x90, 0x8A, 0xEC, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0x8A, 0xF5, 
+0xF0, 0x90, 0x8A, 0xEB, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 0xF6, 0xF0, 0x90, 0x8A, 0xEC, 0xE0, 0xC3, 
+0x13, 0x90, 0x8A, 0xF7, 0xF0, 0x90, 0x01, 0x3E, 0x74, 0x08, 0xF0, 0xFD, 0x7F, 0x02, 0x12, 0x7B, 
+0x2A, 0xE4, 0x90, 0x8B, 0x2A, 0xF0, 0x51, 0x27, 0x11, 0x2C, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 
+0xE0, 0x37, 0x90, 0x8A, 0xEA, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x06, 0xE0, 0xF1, 0x33, 0x30, 0xE0, 
+0x28, 0x12, 0x02, 0x06, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 0x8B, 0x2C, 0xE0, 
+0x60, 0x08, 0x80, 0x0B, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x05, 0x75, 0x5D, 0x01, 0x80, 0x03, 0xE4, 
+0xF5, 0x5D, 0x7D, 0x02, 0xAF, 0x5D, 0x12, 0xA4, 0x70, 0x90, 0x8A, 0xEA, 0xE0, 0xC4, 0x54, 0x0F, 
+0x30, 0xE0, 0x17, 0x90, 0x8A, 0xEE, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 0x7D, 0x04, 
+0x7F, 0x02, 0x12, 0x53, 0xDB, 0xF1, 0xD8, 0x74, 0x11, 0xF0, 0x12, 0xCE, 0x55, 0x90, 0x8A, 0xF2, 
+0xE0, 0xB4, 0x01, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x01, 0xF0, 0x80, 0x2B, 0x90, 0x8A, 0xF2, 0xE0, 
+0xB4, 0x04, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x04, 0xF0, 0x80, 0x1C, 0x90, 0x8A, 0xF2, 0xE0, 0xB4, 
+0x06, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x02, 0xF0, 0x80, 0x0D, 0x90, 0x8A, 0xF2, 0xE0, 0xB4, 0x07, 
+0x06, 0x90, 0x8A, 0xFD, 0x74, 0x05, 0xF0, 0xE4, 0x90, 0x8A, 0xF2, 0xF0, 0x80, 0x59, 0x51, 0x27, 
+0x11, 0x2C, 0x12, 0xAE, 0xC2, 0x30, 0xE0, 0x05, 0x75, 0x5E, 0x02, 0x80, 0x11, 0x12, 0x02, 0x06, 
+0x12, 0xAE, 0xDD, 0x30, 0xE0, 0x05, 0x75, 0x5E, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x5E, 0x12, 0x78, 
+0x72, 0x90, 0x8B, 0x51, 0xE0, 0x30, 0xE0, 0x04, 0x7D, 0xAC, 0x80, 0x02, 0x7D, 0x2C, 0x7F, 0x40, 
+0x12, 0x7A, 0xA5, 0x51, 0x27, 0x11, 0x2C, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x04, 0x7F, 
+0x03, 0x80, 0x02, 0x7F, 0x01, 0x12, 0x71, 0x29, 0xAD, 0x5E, 0x7F, 0x02, 0x12, 0xA4, 0x70, 0x12, 
+0x96, 0xA2, 0xF1, 0xD8, 0x74, 0x43, 0xF0, 0x90, 0x8A, 0xF0, 0xE0, 0x54, 0xDF, 0xF0, 0xE4, 0x90, 
+0x8A, 0xFC, 0xF0, 0x90, 0x8A, 0xED, 0xE0, 0xF1, 0x33, 0x30, 0xE0, 0x09, 0x90, 0x8B, 0x1D, 0xE0, 
+0x44, 0x02, 0xF0, 0x80, 0x0C, 0x7F, 0x01, 0x12, 0x71, 0x63, 0x90, 0x8B, 0x1D, 0xE0, 0x54, 0xFD, 
+0xF0, 0x7F, 0x03, 0x12, 0x5C, 0x6F, 0x90, 0x8A, 0xEA, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x8A, 0xEE, 
+0xE0, 0x54, 0xBF, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x74, 0x33, 0x2E, 0xF5, 0x82, 0xE4, 
+0x34, 0x8D, 0xF5, 0x83, 0x22, 0x51, 0x21, 0x12, 0x02, 0x06, 0x54, 0x7F, 0xFD, 0xF1, 0x91, 0xFE, 
+0x54, 0x1F, 0x90, 0x90, 0xC9, 0xF0, 0xEE, 0xF1, 0x31, 0x90, 0x90, 0xC8, 0xB1, 0xBF, 0xFE, 0x54, 
+0x03, 0xFC, 0xEE, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0x90, 0x90, 0xCB, 0xB1, 0xBF, 0xFE, 0x54, 0x40, 
+0xC4, 0x13, 0x13, 0x54, 0x03, 0x90, 0x90, 0xCA, 0xF0, 0xEE, 0xF1, 0x31, 0xFF, 0xB1, 0xC0, 0xFB, 
+0x54, 0x08, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0x90, 0xCD, 0xF0, 0xFA, 0xEB, 0x54, 0x04, 0x13, 
+0x13, 0x54, 0x3F, 0xA3, 0xF0, 0xEF, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xB1, 0xC6, 
+0x54, 0x7F, 0x4F, 0xF0, 0x90, 0x90, 0xCA, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x54, 0xC0, 0xB1, 
+0xC6, 0x54, 0xBF, 0x4F, 0xF0, 0xEA, 0x60, 0x02, 0xA1, 0xBD, 0x90, 0x90, 0xC9, 0xE0, 0x54, 0x1F, 
+0xFF, 0x75, 0xF0, 0x12, 0xED, 0xF1, 0x9C, 0x54, 0xE0, 0x4F, 0xF0, 0xEC, 0x54, 0x03, 0xB1, 0xC6, 
+0x54, 0xFC, 0x4F, 0xF0, 0xEC, 0x54, 0x03, 0x25, 0xE0, 0x25, 0xE0, 0xB1, 0xC6, 0x54, 0xF3, 0x4F, 
+0xF0, 0x90, 0x90, 0xC8, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x12, 0xED, 
+0xF1, 0x9C, 0x54, 0xDF, 0x4F, 0xF0, 0x90, 0x90, 0xCB, 0xE0, 0x54, 0x03, 0xC4, 0x54, 0xF0, 0xB1, 
+0xC6, 0x54, 0xCF, 0x4F, 0xF0, 0x74, 0x33, 0x2D, 0x91, 0x4D, 0xE0, 0x54, 0xFB, 0xF0, 0x74, 0x33, 
+0x2D, 0x91, 0x4D, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0x90, 0xCE, 0x12, 0xC2, 0x77, 0x4E, 
+0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0x90, 0xBB, 0xE0, 0x60, 0x3A, 0x51, 0x27, 0xE9, 0x24, 0x03, 
+0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x02, 0x06, 0x54, 0x1F, 0x12, 0x02, 0x4C, 0x90, 0x90, 0xCC, 0x74, 
+0x01, 0xF0, 0x90, 0x90, 0xCC, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x19, 0xEF, 0x24, 0x03, 0xFF, 
+0xE4, 0x33, 0xFE, 0x51, 0x27, 0x8F, 0x82, 0x8E, 0x83, 0xE4, 0x12, 0x02, 0x5E, 0x90, 0x90, 0xCC, 
+0xE0, 0x04, 0xF0, 0x80, 0xDD, 0x90, 0x90, 0xB9, 0xE0, 0x54, 0x07, 0xFF, 0xBF, 0x05, 0x0A, 0xEC, 
+0xB4, 0x01, 0x06, 0x90, 0x90, 0xBE, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x90, 0xCC, 0xF0, 0x90, 0x90, 
+0xCC, 0xE0, 0xFC, 0x24, 0x03, 0xFF, 0xE4, 0x33, 0xFE, 0x51, 0x27, 0x8F, 0x82, 0x8E, 0x83, 0x12, 
+0x02, 0x1F, 0xFF, 0xED, 0xF1, 0xE9, 0xE5, 0x82, 0x2C, 0x12, 0xC9, 0xFE, 0xEF, 0xF0, 0x90, 0x90, 
+0xCC, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x04, 0xD6, 0xAF, 0x05, 0x12, 0x11, 0x87, 0x22, 0x4F, 0xF0, 
+0x90, 0x00, 0x02, 0x02, 0x02, 0x1F, 0xFF, 0x75, 0xF0, 0x12, 0xED, 0x90, 0x8B, 0x9F, 0x12, 0x04, 
+0x6E, 0xE0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7F, 0x8F, 0x12, 0x7A, 0xB8, 0xEF, 
+0x20, 0xE6, 0x02, 0xC1, 0xF8, 0x90, 0x00, 0x8C, 0xE0, 0x90, 0x8F, 0xF4, 0xF0, 0x7F, 0x8D, 0x12, 
+0x7A, 0xB8, 0x90, 0x8F, 0xF5, 0xEF, 0xF0, 0x90, 0x00, 0x8E, 0xE0, 0x90, 0x8F, 0xF6, 0xF0, 0x90, 
+0x8F, 0xF5, 0xE0, 0x24, 0xFC, 0x60, 0x10, 0x24, 0x03, 0x60, 0x02, 0xC1, 0xEC, 0x90, 0x8F, 0xF4, 
+0xE0, 0xFF, 0x12, 0xC9, 0xA0, 0xC1, 0xEC, 0x90, 0x8F, 0xF4, 0xE0, 0x24, 0x43, 0xF1, 0xC9, 0xE0, 
+0xFB, 0xE4, 0xFD, 0xFF, 0xF1, 0x2A, 0x75, 0xF0, 0x12, 0xB1, 0xCB, 0x13, 0x13, 0x54, 0x03, 0xFB, 
+0x0D, 0xE4, 0xFF, 0xF1, 0x2A, 0x75, 0xF0, 0x12, 0xB1, 0xCB, 0xF1, 0x33, 0xFB, 0x0D, 0xE4, 0xFF, 
+0xF1, 0x2A, 0x75, 0xF0, 0x12, 0xB1, 0xCB, 0xC4, 0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0xF1, 0x2A, 
+0x12, 0x9F, 0xF3, 0xFB, 0xE4, 0xFD, 0x0F, 0xF1, 0x2A, 0x75, 0xF0, 0x12, 0x90, 0x8B, 0x9D, 0x12, 
+0x04, 0x6E, 0xF1, 0x27, 0x75, 0xF0, 0x12, 0xF1, 0x9C, 0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 0x7F, 
+0x01, 0xF1, 0x2A, 0x75, 0xF0, 0x12, 0xF1, 0x9C, 0x54, 0x1F, 0xF1, 0x28, 0xF1, 0xE9, 0xE0, 0xFB, 
+0xE4, 0xFD, 0x0F, 0xF1, 0x2A, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x82, 
+0xF1, 0x25, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x02, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x25, 0x75, 
+0xF0, 0x08, 0xA4, 0x24, 0x03, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x25, 0x75, 0xF0, 0x08, 0xA4, 
+0x24, 0x04, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0xF1, 0x2A, 
+0x75, 0xF0, 0x08, 0xA4, 0x24, 0x05, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x25, 0x75, 0xF0, 0x08, 
+0xA4, 0x24, 0x06, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF1, 0x25, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x07, 
+0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFB, 0x0D, 0xD1, 0xFD, 0x7F, 0x8F, 0x12, 0x7A, 
+0xB8, 0xEF, 0x30, 0xE0, 0x03, 0x12, 0xC9, 0xF7, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x70, 0x04, 
+0x74, 0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 
+0x74, 0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 0x0C, 0x74, 0xFC, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x02, 
+0xF5, 0x83, 0xEB, 0xF0, 0x22, 0xF5, 0x83, 0xE0, 0xFB, 0x0D, 0xD1, 0xFD, 0x90, 0x8F, 0xF4, 0xE0, 
+0x22, 0x54, 0x80, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0x90, 0xC5, 0x12, 0x87, 0x5F, 
+0x12, 0x02, 0x06, 0xFF, 0xF1, 0x91, 0xFE, 0x54, 0x03, 0xFD, 0xEE, 0x13, 0x13, 0x54, 0x07, 0xFB, 
+0xC0, 0x03, 0x51, 0x27, 0xB1, 0xC0, 0x54, 0x0F, 0x90, 0x8F, 0xF3, 0xF0, 0xD0, 0x03, 0x12, 0xA1, 
+0xB4, 0x51, 0x27, 0xF1, 0x91, 0x12, 0x93, 0x24, 0x90, 0x90, 0xC8, 0x74, 0x10, 0xF0, 0x90, 0x90, 
+0xD6, 0x74, 0x07, 0xF0, 0x51, 0x27, 0x12, 0x02, 0x06, 0x90, 0x90, 0xCA, 0xF0, 0x7B, 0x01, 0x7A, 
+0x90, 0x79, 0xC8, 0x12, 0x5A, 0x18, 0x7F, 0x04, 0x02, 0x87, 0x9E, 0xAB, 0x5D, 0xAA, 0x5E, 0xA9, 
+0x5F, 0x90, 0x00, 0x01, 0x02, 0x02, 0x1F, 0x75, 0xF0, 0x12, 0xE5, 0x73, 0x90, 0x8B, 0x9E, 0x12, 
+0x04, 0x6E, 0xE0, 0x22, 0x12, 0xB0, 0x2C, 0x90, 0x90, 0x3C, 0xF0, 0xF1, 0x91, 0x90, 0x90, 0x3D, 
+0xB1, 0xBF, 0x90, 0x90, 0x4F, 0x11, 0x2B, 0x90, 0x90, 0x50, 0xF1, 0xD1, 0x90, 0x90, 0x62, 0xF1, 
+0xE2, 0x90, 0x90, 0x63, 0xF0, 0x22, 0x74, 0x43, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 
+0x22, 0xF0, 0x90, 0x00, 0x04, 0x02, 0x02, 0x1F, 0x90, 0x05, 0x00, 0x74, 0x1C, 0xF0, 0xA3, 0x22, 
+0x4E, 0xFF, 0xF0, 0x90, 0x00, 0x05, 0x02, 0x02, 0x1F, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 
+0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0xA1, 0xD3, 0x8B, 0x5D, 0x8A, 0x5E, 0x89, 0x5F, 0x90, 
+0x90, 0xB5, 0xE0, 0x70, 0x10, 0x12, 0x02, 0x06, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x06, 0x90, 
+0x90, 0xBB, 0x74, 0x01, 0xF0, 0x90, 0x90, 0xB7, 0xE0, 0x70, 0x0F, 0x11, 0x95, 0x12, 0xAA, 0x00, 
+0xFF, 0xBF, 0x05, 0x06, 0x90, 0x90, 0xBC, 0x74, 0x01, 0xF0, 0x12, 0x8F, 0x8B, 0xFF, 0xF5, 0x61, 
+0x12, 0x02, 0x06, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x8D, 0xC0, 0xF5, 0x62, 0x80, 0x02, 
+0x8F, 0x62, 0x85, 0x61, 0x60, 0xE5, 0x60, 0xD3, 0x95, 0x62, 0x50, 0x2C, 0x11, 0x95, 0x12, 0x02, 
+0x06, 0x54, 0x01, 0xFD, 0xAF, 0x60, 0x12, 0x6E, 0x43, 0xAF, 0x60, 0x12, 0x77, 0x09, 0xEF, 0xAF, 
+0x60, 0x70, 0x04, 0xF1, 0xF5, 0x80, 0x03, 0x12, 0xC3, 0x81, 0x90, 0x90, 0xBC, 0xE0, 0x60, 0x04, 
+0xAF, 0x60, 0xF1, 0xF5, 0x05, 0x60, 0x80, 0xCD, 0xE5, 0x61, 0x70, 0x16, 0xFF, 0x12, 0x77, 0x09, 
+0xEF, 0x70, 0x0F, 0x12, 0xB8, 0x26, 0x12, 0x78, 0xD1, 0x12, 0xBE, 0xD7, 0x54, 0xBF, 0xF0, 0x54, 
+0x7F, 0xF0, 0x22, 0x31, 0x5E, 0xAB, 0x5D, 0xAA, 0x5E, 0xA9, 0x5F, 0x22, 0x12, 0xB0, 0x2C, 0xC4, 
+0x54, 0x0F, 0xFF, 0xBF, 0x0F, 0x17, 0x90, 0x90, 0x09, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 0xB7, 0xDC, 
+0x11, 0x95, 0x12, 0x02, 0x06, 0x54, 0x0F, 0xFF, 0x51, 0x41, 0x02, 0xCA, 0x06, 0x12, 0x8F, 0x8B, 
+0x12, 0xD1, 0xA5, 0x12, 0xD0, 0x69, 0xEF, 0x12, 0x8D, 0xBF, 0x54, 0x03, 0xFF, 0xED, 0x51, 0x32, 
+0x54, 0xFC, 0x12, 0x8D, 0xBE, 0x54, 0x1C, 0xFF, 0xEE, 0x54, 0x0F, 0xFE, 0x51, 0x32, 0x54, 0xE3, 
+0x12, 0x8D, 0xBE, 0x54, 0xE0, 0xFF, 0xEE, 0x51, 0x32, 0x54, 0x1F, 0x4F, 0x12, 0x8F, 0xD1, 0x12, 
+0xD1, 0x6F, 0xE4, 0xFB, 0x11, 0x93, 0x12, 0x8F, 0xE3, 0x12, 0xD1, 0x6F, 0x7B, 0x01, 0x11, 0x93, 
+0x12, 0x88, 0x2C, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x12, 0xD1, 0xA5, 0xFD, 0x75, 0xF0, 0x0E, 0xA4, 
+0x24, 0x16, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xEF, 0x12, 0x88, 0x2B, 0xC4, 0x13, 0x54, 
+0x07, 0xFF, 0xED, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x17, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 
+0xEF, 0xF0, 0xEE, 0xC4, 0x54, 0x0F, 0xFF, 0x14, 0x6D, 0x70, 0x22, 0x90, 0x90, 0x0B, 0xEF, 0x12, 
+0xA9, 0x90, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x90, 0x90, 0x0A, 0xE0, 0x54, 0x0F, 0x4F, 0xF0, 
+0x54, 0xF1, 0xF0, 0x90, 0x90, 0x09, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0xD1, 0x9E, 0x22, 0x8F, 0x60, 
+0x8D, 0x61, 0xAE, 0x03, 0x74, 0x1F, 0xC3, 0x95, 0x60, 0x40, 0x0A, 0x51, 0x28, 0xE4, 0xFD, 0x51, 
+0x20, 0x24, 0xD4, 0x80, 0x31, 0x74, 0x3F, 0xC3, 0x95, 0x60, 0x40, 0x0A, 0x51, 0x28, 0x7D, 0x20, 
+0x51, 0x1E, 0x24, 0x88, 0x80, 0x20, 0x74, 0x5F, 0xC3, 0x95, 0x60, 0x40, 0x0A, 0x51, 0x28, 0x7D, 
+0x40, 0x51, 0x1E, 0x24, 0xD0, 0x80, 0x0F, 0x74, 0x7F, 0xC3, 0x95, 0x60, 0x40, 0x1E, 0x51, 0x28, 
+0x7D, 0x60, 0x51, 0x1E, 0x24, 0x84, 0xFD, 0xE4, 0x34, 0x04, 0xFC, 0xE5, 0x61, 0x12, 0xD0, 0x78, 
+0x75, 0xF0, 0x03, 0xEE, 0x12, 0x04, 0x6E, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x22, 0xC3, 0xEF, 0x9D, 
+0xF5, 0x62, 0xC3, 0x94, 0x08, 0x50, 0x19, 0xE4, 0xF5, 0x63, 0x12, 0xD0, 0x5A, 0xC0, 0x83, 0xC0, 
+0x82, 0x90, 0x90, 0xC9, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x71, 0x10, 0xE5, 0x62, 0xF0, 0x80, 0x3B, 
+0xE5, 0x62, 0xC3, 0x94, 0x10, 0x50, 0x09, 0x75, 0x63, 0x01, 0xE5, 0x62, 0x24, 0xF8, 0x80, 0x17, 
+0xE5, 0x62, 0xC3, 0x94, 0x18, 0x50, 0x09, 0x75, 0x63, 0x02, 0xE5, 0x62, 0x24, 0xF0, 0x80, 0x07, 
+0x75, 0x63, 0x03, 0xE5, 0x62, 0x24, 0xE8, 0xFF, 0x12, 0xD0, 0x5A, 0xC0, 0x83, 0xC0, 0x82, 0x90, 
+0x90, 0xC9, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x71, 0x10, 0xEF, 0xF0, 0xAF, 0x63, 0x22, 0xAF, 0x60, 
+0x31, 0xBD, 0x90, 0x90, 0xC5, 0xEF, 0xF0, 0x22, 0x90, 0x90, 0xC9, 0xEE, 0xF0, 0xAB, 0x61, 0x22, 
+0xE5, 0x60, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x0E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 
+0x22, 0x8F, 0x60, 0x12, 0xA3, 0xFC, 0xE5, 0x60, 0x12, 0xD0, 0x6A, 0xE0, 0xFC, 0x51, 0x30, 0x12, 
+0xA1, 0x9C, 0x51, 0x30, 0x71, 0x24, 0xE5, 0x60, 0x12, 0xA3, 0xEA, 0xF1, 0xF0, 0xF1, 0xEB, 0xAD, 
+0x60, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xE8, 0xEF, 0xF0, 0xA3, 
+0xED, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x8F, 0xEA, 0xE0, 0xFF, 0xC3, 0x94, 0x03, 0x40, 0x02, 0x61, 
+0x0B, 0x90, 0x8F, 0xE9, 0xE0, 0xFE, 0x12, 0xD0, 0x78, 0x75, 0xF0, 0x03, 0xEF, 0x12, 0x04, 0x6E, 
+0x12, 0xD1, 0x42, 0xE0, 0x90, 0x8F, 0xEB, 0xF0, 0x90, 0x8F, 0xE8, 0xE0, 0xFC, 0xB4, 0x02, 0x23, 
+0x90, 0x8F, 0xEB, 0xE0, 0xFD, 0xEE, 0x12, 0xD0, 0x5B, 0xC0, 0x83, 0xC0, 0x82, 0x90, 0x8F, 0xEA, 
+0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x71, 0x10, 0x12, 0xD1, 0x77, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0x4D, 0x80, 0x23, 0xEC, 0xB4, 0x01, 0x23, 0x12, 0xD1, 0x26, 0x12, 0xD0, 0x5B, 0xC0, 0x83, 0xC0, 
+0x82, 0x90, 0x8F, 0xEA, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x71, 0x10, 0x12, 0xD1, 0x77, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x8F, 0xEB, 0xF0, 0x12, 0xD1, 0x26, 0x12, 0xD0, 0x78, 
+0xC0, 0x83, 0xC0, 0x82, 0x90, 0x8F, 0xEA, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x71, 0x10, 0x12, 0xD1, 
+0x42, 0xEF, 0xF0, 0x90, 0x8F, 0xEA, 0xE0, 0x04, 0xF0, 0x41, 0x75, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x75, 0xF0, 0x03, 0x02, 0x04, 0x6E, 0x75, 0xF0, 0x13, 0xA4, 0x24, 0x38, 0xF5, 0x82, 0xE4, 0x34, 
+0x90, 0xF5, 0x83, 0xE0, 0xFE, 0x54, 0x03, 0xFF, 0xEE, 0x13, 0x13, 0x54, 0x07, 0xFD, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x52, 0xED, 0xF0, 0xE4, 0xA3, 0xF0, 0xEF, 0x14, 0x60, 
+0x02, 0x81, 0x13, 0x90, 0x06, 0x03, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x91, 0x52, 0xE0, 0xFB, 0xC4, 
+0x33, 0x54, 0xE0, 0xFE, 0x90, 0x04, 0x42, 0xE0, 0x54, 0x9F, 0x4E, 0xFE, 0xF0, 0xE4, 0xFD, 0x12, 
+0xCB, 0x37, 0x90, 0x91, 0x53, 0xEF, 0xF0, 0x90, 0x04, 0x83, 0xF0, 0x90, 0x8F, 0xAC, 0x12, 0x04, 
+0x3D, 0x00, 0x00, 0x00, 0x01, 0x90, 0x8F, 0xB0, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x01, 0x91, 
+0xE2, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x01, 0x90, 0x8F, 0xB0, 0x12, 0x04, 0x3D, 0x00, 0x00, 
+0x00, 0x01, 0x7F, 0x00, 0x7E, 0x09, 0x91, 0xE6, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x10, 0x12, 
+0xA2, 0xBB, 0xEF, 0x54, 0x03, 0xFF, 0xE4, 0x78, 0x01, 0x12, 0x03, 0xEB, 0x78, 0x04, 0x12, 0xD0, 
+0x9F, 0x7F, 0x00, 0x7E, 0x0A, 0x91, 0xE6, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x0C, 0x00, 0x12, 0xA2, 
+0xBB, 0xEF, 0x54, 0x03, 0xFF, 0xE4, 0x78, 0x0A, 0x12, 0xD0, 0x9F, 0x7F, 0x00, 0x7E, 0x0D, 0x91, 
+0xE6, 0x12, 0x04, 0x3D, 0x0C, 0x00, 0x00, 0x00, 0x90, 0x91, 0x53, 0x12, 0xA2, 0xBE, 0xEF, 0x54, 
+0x03, 0xFF, 0xE4, 0x78, 0x1A, 0x12, 0xD0, 0x9F, 0x7F, 0x18, 0x91, 0xE4, 0x12, 0x04, 0x3D, 0x00, 
+0x00, 0x0C, 0x00, 0x90, 0x8F, 0xB0, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x12, 0xD1, 0x11, 
+0x12, 0x04, 0x3D, 0x00, 0x00, 0x0C, 0x00, 0x90, 0x8F, 0x9E, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x04, 
+0x00, 0x80, 0x59, 0x90, 0x06, 0x03, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x8F, 0xAC, 0x12, 0x04, 0x3D, 
+0x00, 0x00, 0x00, 0x01, 0x90, 0x8F, 0xB0, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x91, 0xE2, 
+0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x01, 0x90, 0x8F, 0xB0, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 
+0x00, 0x7F, 0x00, 0x7E, 0x09, 0x91, 0xE6, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x0C, 0x00, 0x90, 0x8F, 
+0xB0, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x0C, 0x00, 0x12, 0xD1, 0x11, 0x12, 0x04, 0x3D, 0x00, 0x00, 
+0x0C, 0x00, 0x90, 0x8F, 0x9E, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x0C, 0x00, 0x7D, 0x18, 0x7C, 0x00, 
+0xE4, 0xFF, 0x12, 0xA2, 0x2C, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x8F, 0xAA, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x6F, 0xC1, 0x90, 0x8F, 0xB4, 0x12, 
+0x04, 0x31, 0x90, 0x8F, 0xAC, 0x12, 0x04, 0xB2, 0x12, 0x03, 0xCD, 0x90, 0x8F, 0xB4, 0x12, 0x87, 
+0x4A, 0x12, 0x87, 0x30, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x8F, 0xAC, 0x12, 
+0x04, 0xB2, 0x90, 0x8F, 0xB0, 0x12, 0x87, 0x4A, 0x12, 0x87, 0x30, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 
+0x01, 0xD0, 0x00, 0x12, 0x87, 0x3D, 0x90, 0x8F, 0xB8, 0x12, 0x04, 0x31, 0x90, 0x8F, 0xB8, 0x12, 
+0xA5, 0x89, 0x90, 0x8F, 0xAA, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x6F, 0xFE, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x7F, 0x00, 0x7E, 0x08, 0x91, 0x7A, 0x90, 0x8F, 0xAC, 0x22, 0x12, 0xD0, 0x39, 0xB5, 
+0x07, 0x04, 0xEE, 0x54, 0xF1, 0xF0, 0x12, 0xB2, 0x91, 0xE4, 0x90, 0x90, 0x0C, 0xF0, 0x12, 0xA4, 
+0x03, 0x12, 0xD0, 0x50, 0x12, 0xD0, 0x69, 0xE0, 0xFA, 0xED, 0x51, 0x32, 0xFC, 0x54, 0x03, 0xFD, 
+0xEC, 0x13, 0x13, 0x54, 0x07, 0xFB, 0xEE, 0xC4, 0x54, 0x0F, 0x90, 0x8F, 0xF3, 0xF0, 0xAF, 0x02, 
+0x12, 0xA1, 0xB4, 0xB1, 0x4D, 0x51, 0x32, 0x71, 0x24, 0xB1, 0x4D, 0xFF, 0x75, 0xF0, 0x0E, 0xA4, 
+0x24, 0x18, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0x12, 0xA3, 0xE9, 0xF1, 
+0xF0, 0xE4, 0xFD, 0xFF, 0xB1, 0x4B, 0xFD, 0x7F, 0x01, 0x41, 0x63, 0xD1, 0xA5, 0x90, 0x90, 0x0A, 
+0xE0, 0xC3, 0x13, 0x54, 0x07, 0x22, 0xE4, 0x90, 0x91, 0x36, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 0x20, 
+0xE0, 0x02, 0xC1, 0xA1, 0x90, 0x90, 0x0C, 0xE0, 0xB4, 0x14, 0x0C, 0x7F, 0x01, 0x12, 0xA0, 0x48, 
+0xEF, 0x60, 0x02, 0xC1, 0xA1, 0xC1, 0x9C, 0xB1, 0x4D, 0x12, 0xA7, 0xF2, 0x54, 0x07, 0x90, 0x91, 
+0x34, 0xF0, 0x60, 0x07, 0xE0, 0x64, 0x02, 0x60, 0x02, 0xC1, 0x63, 0x90, 0x90, 0x0C, 0xE0, 0x70, 
+0x35, 0x12, 0xA2, 0xB2, 0x30, 0xE0, 0x02, 0xC1, 0x52, 0x12, 0xD1, 0x66, 0x7D, 0x4E, 0x7F, 0x6F, 
+0xB1, 0x4B, 0x12, 0xA0, 0x3C, 0x12, 0xA3, 0xF5, 0x7B, 0x04, 0x7D, 0x01, 0xF1, 0x4A, 0xBF, 0x01, 
+0x0D, 0xD1, 0xB7, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x90, 0x0C, 0x74, 0x01, 0xF0, 0x22, 0x12, 0xD0, 
+0xEE, 0xFF, 0x7D, 0x4F, 0x80, 0x7C, 0x90, 0x90, 0x0C, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xC1, 0x52, 
+0xD1, 0xB7, 0xE0, 0xFF, 0x30, 0xE0, 0x08, 0x90, 0x91, 0x36, 0x74, 0x01, 0xF0, 0x80, 0x15, 0xEF, 
+0xC3, 0x13, 0x20, 0xE0, 0x0F, 0x90, 0x91, 0x36, 0x74, 0x01, 0xF0, 0x12, 0xD1, 0x66, 0x7D, 0x50, 
+0x7F, 0x6F, 0xD1, 0xA5, 0x90, 0x91, 0x36, 0xE0, 0x60, 0x58, 0x90, 0x90, 0xB2, 0xE0, 0x64, 0x06, 
+0x60, 0x42, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x01, 0x40, 0x08, 0x90, 0x91, 0x37, 0x74, 0x04, 
+0xF0, 0x80, 0x05, 0xE4, 0x90, 0x91, 0x37, 0xF0, 0xB1, 0x4D, 0x12, 0xA0, 0x3C, 0x12, 0xA3, 0xF5, 
+0x90, 0x91, 0x37, 0xE0, 0xFB, 0x7D, 0x01, 0xF1, 0x4A, 0xBF, 0x01, 0x10, 0x12, 0xBB, 0x5D, 0x74, 
+0x03, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x02, 0x5E, 0xAD, 0x12, 0xD0, 0xEE, 0xFF, 
+0x7D, 0x51, 0x80, 0x61, 0xE4, 0x90, 0x90, 0xB2, 0xF0, 0x12, 0xBB, 0xAF, 0xD1, 0xB7, 0xE0, 0x54, 
+0xFB, 0xF0, 0x90, 0x90, 0x0C, 0xE0, 0x64, 0x05, 0x70, 0x47, 0xFF, 0x12, 0xA0, 0x48, 0xEF, 0x70, 
+0x40, 0x80, 0x39, 0x90, 0x91, 0x34, 0xE0, 0x64, 0x03, 0x70, 0x36, 0x90, 0x90, 0x0C, 0xE0, 0x64, 
+0x05, 0x70, 0x2E, 0x12, 0xA2, 0xB2, 0x20, 0xE0, 0x13, 0xB1, 0x4D, 0x04, 0xFF, 0xA3, 0xE0, 0xB5, 
+0x07, 0x02, 0xE4, 0xFF, 0xEF, 0x12, 0xBB, 0x4C, 0xEF, 0x12, 0xB2, 0xC0, 0xB1, 0x4D, 0xFD, 0x7F, 
+0x02, 0x12, 0xCA, 0x15, 0xE4, 0xFF, 0x12, 0xA0, 0x48, 0xEF, 0x70, 0x05, 0x7F, 0x06, 0x12, 0xA9, 
+0x97, 0x22, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x90, 0x01, 0xED, 0xF0, 0x22, 
+0xE4, 0x75, 0xF0, 0x01, 0x12, 0x02, 0xE7, 0x90, 0x90, 0x0A, 0xE0, 0xC3, 0x13, 0x54, 0x07, 0x75, 
+0xF0, 0x13, 0xA4, 0x24, 0x3E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0xE4, 0x90, 0x91, 
+0x33, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 0xFF, 0x30, 0xE0, 0x6B, 0x12, 0xA2, 0xB2, 0x20, 0xE0, 0x65, 
+0xEF, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xD1, 0xBF, 0xE0, 0xFE, 0x30, 0xE0, 0x58, 0xEF, 0xD1, 0xBF, 
+0xEE, 0x54, 0xFE, 0xF0, 0xEF, 0xD1, 0xBF, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x0F, 0x90, 
+0x90, 0x76, 0xD1, 0xB0, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x91, 0x33, 0x74, 0x01, 0xF0, 0x90, 0x04, 
+0xE0, 0xE0, 0x30, 0xE1, 0x25, 0x12, 0xBB, 0xAF, 0xD1, 0xB7, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0x90, 
+0x90, 0xB2, 0xF0, 0xB1, 0x4D, 0xFD, 0x7F, 0x02, 0x12, 0xCA, 0x15, 0x90, 0x91, 0x33, 0xE0, 0x60, 
+0x14, 0xE4, 0x90, 0x90, 0x74, 0xF0, 0xA3, 0xF0, 0xA1, 0x56, 0x90, 0x90, 0x74, 0xD1, 0xB0, 0xE0, 
+0x54, 0xFD, 0xF0, 0xF1, 0xEB, 0x22, 0xE4, 0xFB, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x8F, 0xD5, 0xEE, 0xF0, 0xA3, 0x12, 0x87, 0xE6, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x26, 
+0x90, 0x05, 0x22, 0xE0, 0x90, 0x8F, 0xDB, 0xF0, 0x7D, 0x14, 0x12, 0xA3, 0xFE, 0xEF, 0x64, 0x01, 
+0x70, 0x05, 0x12, 0xC3, 0x4C, 0x80, 0x04, 0x7F, 0x00, 0x80, 0x16, 0x90, 0x8F, 0xDB, 0xE0, 0xFF, 
+0x7D, 0x15, 0xD1, 0xA5, 0x80, 0x03, 0x12, 0xC3, 0x4C, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x7F, 
+0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 0x09, 0xE0, 0x30, 0xE0, 0x4D, 0x90, 0x90, 0x0C, 
+0xE0, 0x70, 0x24, 0x7D, 0x16, 0x12, 0xCA, 0x97, 0xB1, 0x4D, 0x12, 0xA3, 0xEA, 0xF1, 0x46, 0xB1, 
+0x4D, 0x12, 0xBB, 0xDE, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0xBB, 0x5D, 0x74, 0x03, 0x12, 0xB2, 0xC0, 
+0x90, 0x90, 0x0C, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x90, 0x0C, 0xE0, 0x64, 0x01, 0x70, 0x19, 0xB1, 
+0x4D, 0x12, 0xBB, 0xDD, 0xE0, 0x30, 0xE0, 0x10, 0x12, 0xA3, 0xE9, 0xF1, 0x46, 0x12, 0xBB, 0x5D, 
+0x74, 0x03, 0x12, 0xBE, 0xDF, 0x02, 0x5E, 0xAD, 0x91, 0xEC, 0x22, 0xE4, 0xFD, 0xFF, 0xC1, 0xA5, 
+0xE4, 0xFB, 0xFD, 0xE1, 0x4A, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 
+0xFD, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x7D, 0x44, 0x12, 0xCA, 0x97, 0x90, 0x8F, 0xFE, 0xE0, 0x90, 
+0x8F, 0xFD, 0xB4, 0x01, 0x09, 0xE0, 0x11, 0x31, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x07, 0xE0, 0x11, 
+0x31, 0xE0, 0x54, 0xFB, 0xF0, 0x12, 0x96, 0xA2, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0xFD, 0xE5, 
+0x7E, 0xC4, 0x54, 0xF0, 0x24, 0x05, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0x8D, 0x7E, 
+0xEF, 0x30, 0xE6, 0x1E, 0x11, 0xC6, 0x11, 0x2D, 0xE0, 0x54, 0x03, 0x90, 0x8E, 0xA6, 0xF0, 0xE4, 
+0xFB, 0xAF, 0x7E, 0x12, 0x23, 0x3F, 0x11, 0xB9, 0xE0, 0x90, 0x84, 0x47, 0xF0, 0xA3, 0x74, 0x01, 
+0x80, 0x4E, 0x12, 0xD0, 0x86, 0x04, 0xF0, 0x12, 0xD0, 0x86, 0x64, 0x02, 0x70, 0x1D, 0x74, 0x82, 
+0x25, 0x7E, 0xF1, 0xA4, 0xE0, 0xFD, 0xF4, 0x60, 0x02, 0x80, 0x04, 0x11, 0xC6, 0xE0, 0xFD, 0x11, 
+0x2F, 0x12, 0xD0, 0xB8, 0x11, 0xC6, 0x12, 0xD1, 0x54, 0x80, 0x25, 0x12, 0xD0, 0x86, 0xD3, 0x94, 
+0x03, 0x40, 0x11, 0xAF, 0x7E, 0x12, 0x6C, 0x66, 0x11, 0xB9, 0xE0, 0x90, 0x84, 0x47, 0xF0, 0xA3, 
+0x74, 0x03, 0x80, 0x0C, 0x11, 0xC6, 0x11, 0x2D, 0x12, 0xD0, 0xB8, 0x11, 0xC6, 0x12, 0xD1, 0x54, 
+0xF0, 0xAB, 0x7E, 0xE4, 0xFD, 0xFF, 0x02, 0x4E, 0x09, 0x74, 0x23, 0x25, 0x7E, 0xF5, 0x82, 0xE4, 
+0x34, 0x8E, 0xF5, 0x83, 0xE4, 0xF0, 0xE5, 0x7E, 0xC4, 0x54, 0xF0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 
+0x34, 0x81, 0xF5, 0x83, 0x22, 0x90, 0x04, 0x85, 0xE0, 0xF5, 0x6E, 0x90, 0x8F, 0x81, 0xE0, 0x04, 
+0xF0, 0xE4, 0xF5, 0x65, 0x90, 0x8A, 0x78, 0xE0, 0xFF, 0xE5, 0x65, 0xC3, 0x9F, 0x40, 0x02, 0xA1, 
+0x5D, 0xE5, 0x65, 0x11, 0xC8, 0xE0, 0xF5, 0x70, 0x12, 0xD0, 0xFA, 0xE0, 0x65, 0x70, 0x60, 0x16, 
+0x90, 0x84, 0x47, 0xE5, 0x70, 0xF0, 0xE4, 0xA3, 0xF0, 0xAB, 0x65, 0xFD, 0xFF, 0x12, 0x4E, 0x09, 
+0x12, 0xD0, 0xFA, 0xE5, 0x70, 0xF0, 0x90, 0x04, 0xA0, 0xE0, 0x64, 0x01, 0x70, 0x4C, 0xA3, 0xE0, 
+0x65, 0x65, 0x70, 0x46, 0xA3, 0xE0, 0xF5, 0x66, 0xA3, 0xE0, 0x90, 0x91, 0x04, 0xF0, 0xE5, 0x65, 
+0x11, 0xC8, 0xE0, 0x65, 0x66, 0x70, 0x02, 0xA1, 0x59, 0xE5, 0x65, 0x11, 0xC8, 0xE5, 0x66, 0xF0, 
+0xE5, 0x65, 0x11, 0x31, 0xE0, 0x54, 0xFC, 0xFF, 0x90, 0x91, 0x04, 0xE0, 0x54, 0x03, 0x4F, 0xFF, 
+0xE5, 0x65, 0x11, 0x31, 0xEF, 0xF0, 0x90, 0x84, 0x47, 0xE5, 0x66, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 
+0xAB, 0x65, 0xE4, 0xFD, 0xFF, 0x12, 0x4E, 0x09, 0xA1, 0x59, 0xAF, 0x65, 0x12, 0x77, 0x09, 0x75, 
+0xF0, 0x12, 0xE5, 0x65, 0x12, 0x8D, 0xCB, 0x12, 0x8F, 0x33, 0xFD, 0xF1, 0xE6, 0xED, 0xF0, 0x90, 
+0x91, 0x0D, 0xE4, 0xF1, 0x95, 0xE5, 0x65, 0xF0, 0x12, 0xC8, 0x5C, 0x80, 0x05, 0xC3, 0x33, 0xCE, 
+0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0xFF, 0x90, 0x91, 0x11, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x7B, 0x02, 0x12, 0xD1, 0x39, 0x12, 0xC7, 0x3D, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x12, 0xC7, 0x32, 0xE0, 0xFD, 0xE5, 0x65, 0xC4, 0x54, 0xF0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 
+0x81, 0xF5, 0x83, 0xE0, 0x54, 0x80, 0xFB, 0xF1, 0xE6, 0xEB, 0xF0, 0xF1, 0xDF, 0xED, 0xF0, 0x90, 
+0x91, 0x0B, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8F, 0x80, 0xF1, 0x82, 0x7B, 0x03, 0x12, 0xD1, 
+0x39, 0xAF, 0x65, 0x12, 0x77, 0x09, 0xEF, 0x70, 0x02, 0xA1, 0x59, 0x75, 0xF0, 0x12, 0xE5, 0x65, 
+0x12, 0x8D, 0xCB, 0x12, 0x8F, 0x33, 0x30, 0xE0, 0x02, 0xA1, 0x59, 0xE5, 0x65, 0x12, 0xC8, 0x5C, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 
+0x60, 0x02, 0xA1, 0x59, 0x12, 0xC7, 0x3D, 0xE0, 0xFE, 0xA3, 0xE0, 0x4E, 0x70, 0x08, 0x12, 0xC7, 
+0x32, 0xE0, 0x70, 0x02, 0xA1, 0x59, 0xE5, 0x65, 0x75, 0xF0, 0x12, 0xA4, 0x24, 0xA4, 0xF9, 0x74, 
+0x8B, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x90, 0x90, 0xFF, 0x12, 0x87, 0x5F, 0x12, 0xD1, 0x8F, 0x12, 
+0x03, 0x13, 0x2F, 0xFF, 0xF1, 0xD3, 0x2F, 0xFF, 0xF1, 0xD9, 0x2F, 0xFF, 0x12, 0xD0, 0x99, 0x2F, 
+0xF5, 0x6F, 0x12, 0xC7, 0x3D, 0xE0, 0xF5, 0x6B, 0xA3, 0xE0, 0xF5, 0x6C, 0x12, 0xC7, 0x32, 0xE0, 
+0xFF, 0x90, 0x91, 0x02, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0xE5, 0x65, 0x11, 0xC8, 0xE0, 0xF5, 0x66, 
+0x54, 0x80, 0xF5, 0x68, 0xE5, 0x66, 0x54, 0x7F, 0xF5, 0x67, 0x90, 0x8F, 0x80, 0xE0, 0x60, 0x11, 
+0x75, 0x71, 0x0A, 0xB1, 0x9A, 0xE4, 0x93, 0xC3, 0x13, 0x74, 0x01, 0x93, 0x13, 0xF5, 0x72, 0x80, 
+0x0A, 0x7B, 0xFF, 0x12, 0xC7, 0xC6, 0xE4, 0xF5, 0x71, 0xF5, 0x72, 0x12, 0xD1, 0x30, 0xB1, 0x83, 
+0x12, 0xD1, 0x8F, 0x90, 0x91, 0x0D, 0xB1, 0x87, 0xF1, 0xD3, 0xFF, 0x90, 0x91, 0x0F, 0xB1, 0x87, 
+0xF1, 0xD9, 0xFF, 0x90, 0x91, 0x11, 0xB1, 0x87, 0x7B, 0x01, 0xF1, 0x8D, 0x12, 0xD0, 0x93, 0xB1, 
+0x83, 0x90, 0x91, 0x02, 0xE0, 0xFF, 0xA3, 0xE0, 0x12, 0xD1, 0x4B, 0xA3, 0x12, 0xD1, 0x87, 0xA3, 
+0xE4, 0xF0, 0xA3, 0xE5, 0x66, 0xF0, 0x7B, 0x02, 0xF1, 0x8D, 0x74, 0xE3, 0x25, 0x65, 0xF5, 0x82, 
+0xE4, 0x34, 0x8D, 0xF5, 0x83, 0xE0, 0xC3, 0x94, 0x05, 0x40, 0x02, 0xA1, 0x3E, 0x75, 0xF0, 0x12, 
+0xE5, 0x65, 0xF1, 0xF6, 0xFF, 0xE5, 0x67, 0xD3, 0x9F, 0x40, 0x08, 0x8F, 0x67, 0xE5, 0x67, 0x45, 
+0x68, 0xF5, 0x66, 0xE5, 0x67, 0x90, 0x82, 0x61, 0x93, 0xF5, 0x6D, 0xFD, 0xAF, 0x67, 0x12, 0x64, 
+0x02, 0x8F, 0x6D, 0xE5, 0x68, 0x60, 0x04, 0x05, 0x6D, 0x05, 0x6D, 0x90, 0x04, 0x8C, 0xE0, 0x64, 
+0x01, 0x70, 0x28, 0xE5, 0x67, 0xC3, 0x94, 0x0C, 0x40, 0x21, 0x74, 0x84, 0x25, 0x67, 0xF5, 0x82, 
+0xE4, 0x34, 0x04, 0xF5, 0x83, 0xE0, 0xFF, 0x54, 0x7F, 0xFE, 0xEF, 0x30, 0xE7, 0x06, 0xE5, 0x6D, 
+0x2E, 0xFF, 0x80, 0x05, 0xC3, 0xE5, 0x6D, 0x9E, 0xFF, 0x8F, 0x6D, 0xE5, 0x6D, 0xD3, 0x94, 0x1A, 
+0xAF, 0x6D, 0x40, 0x02, 0x7F, 0x1A, 0x8F, 0x6D, 0xB1, 0x63, 0x7B, 0x03, 0xFA, 0xF1, 0x8F, 0xE5, 
+0x66, 0x90, 0x82, 0xD9, 0x93, 0xFF, 0xD3, 0x90, 0x91, 0x03, 0xE0, 0x9F, 0x90, 0x91, 0x02, 0xE0, 
+0x94, 0x00, 0x40, 0x02, 0x80, 0x72, 0xC3, 0xE5, 0x6C, 0x94, 0x0A, 0xE5, 0x6B, 0x94, 0x00, 0x40, 
+0x02, 0x81, 0x57, 0xB1, 0x79, 0xF5, 0x83, 0xE0, 0xC3, 0x94, 0x01, 0x40, 0x07, 0xB1, 0x79, 0xF5, 
+0x83, 0xE0, 0x14, 0xF0, 0x12, 0xD0, 0x93, 0xFF, 0x90, 0x91, 0x03, 0xE0, 0x2F, 0xFF, 0x90, 0x91, 
+0x02, 0xE0, 0x35, 0xF0, 0xFE, 0xF1, 0xD9, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 0xFE, 0xF1, 0xD3, 0x2F, 
+0xFD, 0xEE, 0x35, 0xF0, 0xFC, 0xE5, 0x6B, 0xC3, 0x13, 0xFE, 0xE5, 0x6C, 0x13, 0xFF, 0xD3, 0xED, 
+0x9F, 0xEC, 0x9E, 0x40, 0x28, 0xE5, 0x65, 0x94, 0x05, 0x50, 0x07, 0xB1, 0x79, 0xF5, 0x83, 0x74, 
+0x03, 0xF0, 0x90, 0x91, 0x0B, 0x12, 0xD1, 0x87, 0xE5, 0x6B, 0xC3, 0x13, 0xA3, 0xF0, 0xE5, 0x6C, 
+0x13, 0xA3, 0xF1, 0x49, 0x7B, 0x01, 0xD1, 0xDE, 0x12, 0xC8, 0x7B, 0xA1, 0x3E, 0x12, 0xD1, 0x30, 
+0x65, 0x6F, 0x70, 0x02, 0xE5, 0xF0, 0x70, 0x4F, 0x90, 0x91, 0x0B, 0xF0, 0xA3, 0xE5, 0x6F, 0xF0, 
+0xC3, 0x13, 0xFF, 0xA3, 0xE4, 0xF0, 0xA3, 0xEF, 0xF1, 0x49, 0x7B, 0x02, 0xD1, 0xDE, 0xE5, 0x65, 
+0xC3, 0x94, 0x05, 0x50, 0x10, 0xB1, 0x79, 0xF5, 0x83, 0xE0, 0xD3, 0x94, 0x00, 0x40, 0x06, 0xB1, 
+0x5E, 0x7B, 0x03, 0x80, 0x0B, 0xE5, 0x6F, 0xC3, 0x94, 0x03, 0x50, 0x10, 0xB1, 0x5E, 0x7B, 0x04, 
+0xFA, 0xD1, 0xE0, 0x7D, 0x06, 0xAF, 0x65, 0x12, 0xC6, 0xCB, 0xA1, 0x59, 0xE4, 0xFD, 0xAF, 0x65, 
+0xB1, 0xA8, 0x12, 0xC6, 0xC7, 0xA1, 0x3E, 0xB1, 0x5E, 0x7B, 0x08, 0xFA, 0xD1, 0xE0, 0x7D, 0x01, 
+0xAF, 0x65, 0x12, 0x63, 0xA2, 0xA1, 0x3E, 0xB1, 0x79, 0xF5, 0x83, 0xE4, 0xF0, 0x90, 0x84, 0x61, 
+0x74, 0x02, 0xF0, 0xAB, 0x6D, 0xAD, 0x65, 0xAF, 0x6C, 0xAE, 0x6B, 0x12, 0x42, 0x43, 0x8E, 0x69, 
+0x8F, 0x6A, 0xB1, 0x9A, 0xC3, 0x74, 0x01, 0x93, 0x95, 0x72, 0xFF, 0xE4, 0x93, 0x94, 0x00, 0xFE, 
+0xD3, 0xE5, 0x6A, 0x9F, 0xE5, 0x69, 0x9E, 0x40, 0x32, 0xB1, 0x8E, 0xE4, 0xF0, 0x7D, 0x01, 0xAF, 
+0x65, 0xB1, 0xA8, 0xB1, 0x9A, 0xC3, 0x74, 0x01, 0x93, 0x95, 0x72, 0xFE, 0xE4, 0x93, 0x94, 0x00, 
+0x90, 0x91, 0x0D, 0xF0, 0xA3, 0xCE, 0xF0, 0x90, 0x91, 0x0B, 0xE5, 0x69, 0xF0, 0xA3, 0xE5, 0x6A, 
+0xF0, 0xE4, 0x90, 0x91, 0x0F, 0xB1, 0x71, 0x7B, 0x01, 0x80, 0x1E, 0xF1, 0xB6, 0xC3, 0xE5, 0x6A, 
+0x9F, 0xE5, 0x69, 0x94, 0x00, 0x50, 0x17, 0xB1, 0x8E, 0xE4, 0xF0, 0x12, 0xC8, 0x7B, 0xF1, 0xAC, 
+0xF1, 0xDF, 0xEF, 0xF0, 0xE4, 0xB1, 0x70, 0x7B, 0x02, 0xFA, 0xF1, 0xED, 0x80, 0x60, 0x12, 0xC6, 
+0xC7, 0xB1, 0x9A, 0xE4, 0x93, 0xFF, 0x74, 0x01, 0x93, 0x12, 0xD1, 0x4B, 0xF1, 0xAC, 0xF1, 0xE6, 
+0xEF, 0xF0, 0x74, 0x13, 0x25, 0x65, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF1, 0x80, 0x7B, 0x03, 0x7A, 
+0x00, 0xF1, 0xED, 0xB1, 0x8E, 0xE0, 0x04, 0xF0, 0xE5, 0x67, 0x90, 0x82, 0xED, 0x93, 0x25, 0x71, 
+0xFF, 0xE4, 0x33, 0xFE, 0xB1, 0x8E, 0xE0, 0xC3, 0x9F, 0xEE, 0x12, 0xD0, 0xD9, 0x40, 0x1F, 0xB1, 
+0x8E, 0xE4, 0xF1, 0xB5, 0xB1, 0x9A, 0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 0x93, 0x34, 0x00, 0xC3, 
+0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x65, 0xF1, 0xC7, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xF5, 
+0x6F, 0xFD, 0xAF, 0x65, 0x12, 0x63, 0xA2, 0xE4, 0x90, 0x91, 0x0B, 0xF0, 0xB1, 0x6C, 0xA3, 0xF0, 
+0x7B, 0x01, 0xFA, 0x7D, 0xFF, 0x7F, 0x01, 0xD1, 0xE4, 0x05, 0x65, 0x01, 0xE4, 0x22, 0x90, 0x8F, 
+0x81, 0xE0, 0xFF, 0x90, 0x91, 0x0B, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 
+0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x74, 0x92, 0x25, 0x65, 0xF5, 0x82, 0xE4, 
+0x34, 0x8F, 0x22, 0xFF, 0x90, 0x91, 0x0B, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x74, 0x13, 
+0x25, 0x65, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0xE5, 0x67, 0x25, 0xE0, 0x24, 0x75, 
+0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0x8F, 0x73, 0x8D, 0x74, 0xEF, 0x11, 0xC8, 0xE0, 
+0xF5, 0x75, 0x54, 0x7F, 0xF5, 0x76, 0xE5, 0x75, 0x54, 0x80, 0xF5, 0x78, 0x75, 0xF0, 0x12, 0xEF, 
+0xF1, 0xF6, 0xF5, 0x7A, 0x75, 0xF0, 0x12, 0xEF, 0x12, 0x8D, 0xCB, 0xC4, 0x54, 0x03, 0xF5, 0x7B, 
+0xF1, 0xA0, 0x74, 0xFF, 0xF0, 0xE5, 0x76, 0xB1, 0x9C, 0xF1, 0xBE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0xE5, 0x75, 0x45, 0x78, 0xFF, 0x12, 0xC9, 0x51, 0xEF, 0xF0, 0xE5, 0x73, 0x11, 0x31, 0xE0, 0x54, 
+0x03, 0xF5, 0x79, 0x74, 0xB3, 0x25, 0x73, 0x12, 0xC9, 0x65, 0xE5, 0x79, 0xF0, 0xE5, 0x76, 0x65, 
+0x7A, 0x70, 0x46, 0x12, 0x8F, 0x97, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x0C, 0xE5, 0x78, 0x70, 
+0x08, 0xE5, 0x76, 0x44, 0x80, 0xF5, 0x75, 0xC1, 0xB1, 0xE5, 0x76, 0xB1, 0x9C, 0xF1, 0xBE, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0xF1, 0xC5, 0xE0, 0xFF, 0xA3, 0xE0, 0x90, 0x91, 0x0D, 0xCF, 0xF1, 0x95, 
+0xE5, 0x73, 0xF0, 0xE4, 0x90, 0x91, 0x0F, 0xB1, 0x71, 0x7B, 0x01, 0xFA, 0x7D, 0x02, 0x7F, 0x04, 
+0xD1, 0xE4, 0x7D, 0x07, 0xAF, 0x73, 0x02, 0xC6, 0xCB, 0xE5, 0x76, 0xC3, 0x95, 0x7A, 0x50, 0x59, 
+0xAB, 0x73, 0xAD, 0x7A, 0xAF, 0x76, 0x12, 0x72, 0x81, 0x8F, 0x77, 0x85, 0x77, 0x75, 0x12, 0x8F, 
+0x97, 0xC4, 0x13, 0x54, 0x01, 0xFF, 0x90, 0x91, 0x0F, 0xE4, 0xF1, 0x95, 0xE5, 0x77, 0xF0, 0xA3, 
+0xE4, 0xF0, 0xA3, 0xE5, 0x76, 0xF0, 0xE5, 0x78, 0x12, 0x8F, 0x33, 0xF1, 0x83, 0xE4, 0xFB, 0xFA, 
+0x12, 0xD1, 0x97, 0xE5, 0x76, 0xC3, 0x94, 0x0C, 0x40, 0x27, 0x12, 0x8F, 0x97, 0xC4, 0x13, 0x54, 
+0x07, 0x30, 0xE0, 0x1D, 0xE5, 0x74, 0x60, 0x19, 0xE5, 0x78, 0x70, 0x15, 0xE5, 0x76, 0x44, 0x80, 
+0xF5, 0x75, 0xF1, 0xA0, 0xE5, 0x77, 0xF0, 0x80, 0x08, 0x12, 0xC9, 0x51, 0xE5, 0x7A, 0xF0, 0xF5, 
+0x75, 0xF1, 0x99, 0xE5, 0x75, 0xF0, 0xF1, 0xA0, 0xE0, 0xFF, 0xF1, 0xDF, 0xEF, 0xF0, 0xA3, 0xE4, 
+0xF0, 0xA3, 0xE5, 0x79, 0x12, 0xC9, 0x5D, 0xF0, 0x7B, 0x01, 0x7A, 0x00, 0x12, 0xD1, 0x97, 0x90, 
+0x8E, 0xA6, 0xE5, 0x79, 0xF0, 0xAB, 0x74, 0xAD, 0x75, 0xAF, 0x73, 0x02, 0x23, 0x3F, 0x7A, 0x00, 
+0x7D, 0x03, 0x7F, 0x01, 0x90, 0x01, 0xC6, 0xE0, 0xFE, 0x64, 0x80, 0x70, 0x5B, 0x90, 0x91, 0x15, 
+0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xEB, 0xA3, 0xF0, 0xEA, 0xA3, 0xF0, 0x90, 0x91, 0x0B, 0xE0, 0xFC, 
+0xA3, 0xE0, 0x90, 0x91, 0x19, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x91, 0x0D, 0xE0, 0xFC, 0xA3, 0xE0, 
+0x90, 0x91, 0x1B, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x91, 0x0F, 0xE0, 0xFC, 0xA3, 0xE0, 0x90, 0x91, 
+0x1D, 0xF0, 0xEC, 0xA3, 0xF0, 0x90, 0x91, 0x11, 0xE0, 0xFC, 0xA3, 0xE0, 0x90, 0x91, 0x1F, 0xF0, 
+0xEC, 0xA3, 0xF0, 0x90, 0x91, 0x13, 0x74, 0xFE, 0xF0, 0x90, 0x91, 0x21, 0x74, 0x0C, 0xF0, 0x7B, 
+0x01, 0x7A, 0x91, 0x79, 0x13, 0x12, 0x87, 0x99, 0x22, 0xF0, 0x90, 0x90, 0xFF, 0x12, 0x87, 0x56, 
+0x90, 0x00, 0x06, 0x12, 0x03, 0x3E, 0xFF, 0xAE, 0xF0, 0x90, 0x00, 0x08, 0x12, 0x03, 0x3E, 0x2F, 
+0xFF, 0xE5, 0xF0, 0x3E, 0xFE, 0x90, 0x00, 0x04, 0x12, 0x03, 0x3E, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 
+0x90, 0x91, 0x0F, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x92, 0x25, 0x65, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 
+0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x91, 0x11, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x7A, 0x00, 0x7D, 
+0x01, 0x7F, 0x01, 0xC1, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x91, 0x0B, 0xE4, 0xF0, 0xA3, 0x22, 
+0x74, 0x82, 0x25, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0x22, 0x90, 0x91, 0x0B, 0xE5, 
+0x69, 0xF0, 0xA3, 0xE5, 0x6A, 0xF0, 0xE5, 0x67, 0x90, 0x82, 0x9D, 0x93, 0xFF, 0x22, 0xE4, 0x93, 
+0xFE, 0x74, 0x01, 0x93, 0xFF, 0xE5, 0x73, 0x25, 0xE0, 0x24, 0xE2, 0xF5, 0x82, 0xE4, 0x34, 0x8C, 
+0xF5, 0x83, 0x22, 0x90, 0x00, 0x04, 0x02, 0x03, 0x3E, 0x90, 0x00, 0x06, 0x02, 0x03, 0x3E, 0x90, 
+0x91, 0x0D, 0xE4, 0xF0, 0xA3, 0x22, 0x90, 0x91, 0x0F, 0xE4, 0xF0, 0xA3, 0x22, 0x7D, 0x05, 0x7F, 
+0x01, 0xC1, 0xE4, 0x75, 0xF0, 0x12, 0x90, 0x8B, 0x9C, 0x12, 0x04, 0x6E, 0xE0, 0x22, 0x90, 0x90, 
+0xC5, 0x12, 0x87, 0x5F, 0x90, 0x04, 0x24, 0xE0, 0xF5, 0x5D, 0xE4, 0xFF, 0x12, 0x8A, 0x27, 0x11, 
+0x30, 0xEF, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x19, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xEE, 
+0xF0, 0x11, 0x30, 0xEF, 0x11, 0x3C, 0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x03, 0xDD, 0x22, 
+0x8F, 0x82, 0x75, 0x83, 0x00, 0x12, 0x02, 0x1F, 0x25, 0x5D, 0xFE, 0x22, 0x75, 0xF0, 0x13, 0xA4, 
+0x24, 0x40, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0x22, 0x90, 0x91, 0x38, 0xEF, 0xF0, 0x91, 0x03, 0xEF, 
+0x70, 0x02, 0xFF, 0x22, 0x12, 0x95, 0x4D, 0x90, 0x90, 0x70, 0xF0, 0x12, 0xD0, 0x39, 0xB5, 0x07, 
+0x04, 0xEE, 0x54, 0xF1, 0xF0, 0x12, 0x95, 0x4D, 0xF5, 0x7D, 0x90, 0x91, 0x38, 0xE0, 0x90, 0x90, 
+0x0C, 0x70, 0x03, 0xF0, 0x80, 0x03, 0x74, 0x14, 0xF0, 0xE5, 0x7D, 0x12, 0xD0, 0xC6, 0x30, 0xE0, 
+0x26, 0x31, 0x21, 0xE0, 0x24, 0x79, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFF, 0x31, 
+0x2D, 0xEF, 0x31, 0x20, 0xE0, 0x04, 0x31, 0x20, 0xE0, 0xFF, 0x90, 0x90, 0x78, 0xE0, 0xFE, 0xEF, 
+0xB5, 0x06, 0x04, 0x31, 0x21, 0xE4, 0xF0, 0x31, 0x2D, 0xE0, 0xFC, 0x90, 0x90, 0x70, 0xE0, 0x31, 
+0x2F, 0xE0, 0x6C, 0x60, 0x09, 0xE5, 0x7D, 0x31, 0x8E, 0xE5, 0x7D, 0x12, 0x93, 0x16, 0xE5, 0x7D, 
+0x75, 0xF0, 0x13, 0xA4, 0x24, 0x3F, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 
+0x90, 0x91, 0x38, 0xE0, 0x70, 0x1E, 0x51, 0xB2, 0x20, 0xE0, 0x19, 0xE5, 0x7D, 0xF1, 0xF2, 0x54, 
+0x07, 0xFF, 0x60, 0x03, 0xBF, 0x02, 0x0D, 0xE5, 0x7D, 0x11, 0x3C, 0x71, 0xF5, 0x7B, 0x04, 0xE4, 
+0xFD, 0x12, 0x97, 0x4A, 0xAD, 0x7D, 0x7F, 0x01, 0x12, 0xCA, 0x15, 0x90, 0x90, 0x72, 0xE0, 0xC3, 
+0x13, 0x54, 0x03, 0xFF, 0xBF, 0x02, 0x05, 0xE4, 0xFF, 0x12, 0xA9, 0x97, 0x90, 0x01, 0xA5, 0xE0, 
+0xB4, 0xFF, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0xA5, 0xE0, 0x04, 0xF0, 0x7F, 0x01, 0x22, 
+0xF0, 0x74, 0x9C, 0x25, 0x7D, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0xE5, 0x7D, 0x75, 
+0xF0, 0x13, 0xA4, 0x24, 0x37, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0x8F, 0x61, 0x90, 
+0x05, 0x22, 0xE0, 0x90, 0x90, 0xCD, 0xF0, 0x71, 0xFC, 0xEF, 0x64, 0x01, 0x70, 0x33, 0xE5, 0x61, 
+0x31, 0x2F, 0xE0, 0xFC, 0xE5, 0x61, 0x31, 0x8E, 0xE5, 0x61, 0x12, 0x93, 0x16, 0x51, 0xB2, 0x20, 
+0xE0, 0x15, 0xE5, 0x61, 0xF1, 0xF2, 0x54, 0x07, 0xFF, 0x60, 0x03, 0xBF, 0x02, 0x09, 0xE5, 0x61, 
+0x11, 0x3C, 0x71, 0xF5, 0x12, 0x97, 0xF0, 0xAD, 0x61, 0x7F, 0x01, 0x12, 0xCA, 0x15, 0x7F, 0x01, 
+0x22, 0x90, 0x90, 0xCD, 0xE0, 0xFF, 0x7D, 0x49, 0x12, 0x96, 0xA5, 0x7F, 0x00, 0x22, 0x75, 0xF0, 
+0x13, 0xA4, 0x24, 0x38, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFE, 0x54, 0x03, 0xFD, 
+0xEE, 0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0x90, 0x0A, 0xE0, 0xFE, 0xC4, 0x54, 0x0F, 0x90, 0x8F, 
+0xF3, 0xF0, 0xAF, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xF0, 0xEF, 0xF0, 
+0xED, 0x64, 0x01, 0x70, 0x2E, 0xEB, 0xB4, 0x01, 0x07, 0xE0, 0x24, 0x02, 0xF5, 0x0E, 0x80, 0x08, 
+0x90, 0x8F, 0xF0, 0xE0, 0x24, 0xFE, 0xF5, 0x0E, 0x90, 0x8F, 0x9A, 0x12, 0x04, 0x3D, 0x00, 0x00, 
+0x00, 0xFF, 0xAF, 0x0E, 0x51, 0x1D, 0x51, 0xAA, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0xFF, 0xAF, 
+0x0E, 0x80, 0x1F, 0x90, 0x8F, 0x9A, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0xFF, 0x90, 0x8F, 0xF0, 
+0x51, 0xBE, 0x51, 0x21, 0x51, 0xAA, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0xFF, 0x90, 0x8F, 0xF0, 
+0xE0, 0xFF, 0x51, 0x1D, 0x7F, 0x01, 0x51, 0x2C, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFC, 0xFD, 
+0xFE, 0x90, 0x8F, 0x9E, 0x12, 0x04, 0x31, 0x7D, 0x18, 0x7C, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0x98, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x8F, 0x97, 0xEF, 0xF0, 
+0xA3, 0xA3, 0xE0, 0xFD, 0x12, 0x7A, 0xFF, 0x90, 0x8F, 0xA2, 0x12, 0x04, 0x31, 0x90, 0x8F, 0x9A, 
+0x12, 0x04, 0xB2, 0x12, 0x03, 0xCD, 0x90, 0x8F, 0xA2, 0x12, 0x87, 0x4A, 0x12, 0x87, 0x30, 0xC0, 
+0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x8F, 0x9A, 0x12, 0x04, 0xB2, 0x90, 0x8F, 0x9E, 
+0x12, 0x87, 0x4A, 0x12, 0x87, 0x30, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x87, 
+0x3D, 0x90, 0x8F, 0xA6, 0x12, 0x04, 0x31, 0x90, 0x8F, 0x98, 0xA3, 0xE0, 0xFD, 0xC0, 0x05, 0x90, 
+0x8F, 0xA6, 0x12, 0x04, 0xB2, 0x90, 0x87, 0x05, 0x12, 0x04, 0x31, 0x90, 0x8F, 0x97, 0xE0, 0xFF, 
+0xD0, 0x05, 0x12, 0x77, 0xEE, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFF, 0x51, 0x2C, 0x90, 0x8F, 
+0x9A, 0x22, 0x90, 0x90, 0x72, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x22, 0x90, 0x91, 0x52, 0xE0, 0xFF, 
+0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0x90, 0x8B, 0x05, 0xE0, 0x30, 0xE0, 0x05, 0x12, 0x6C, 0xF3, 0x80, 
+0x03, 0x12, 0x64, 0x62, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x04, 0xA3, 0xE0, 0x04, 0xF0, 0x90, 
+0x8B, 0x34, 0xE0, 0x64, 0x08, 0x70, 0x20, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x14, 0x12, 0xB9, 
+0xED, 0xE4, 0xFD, 0x12, 0x6F, 0x45, 0x90, 0x8B, 0x33, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xA3, 0xF0, 
+0x80, 0x05, 0xE4, 0x90, 0x8B, 0x34, 0xF0, 0x91, 0x61, 0x30, 0xE0, 0x13, 0x90, 0x8B, 0x35, 0xE0, 
+0x04, 0xF0, 0xE0, 0xB4, 0x14, 0x09, 0x90, 0x04, 0x9C, 0xE4, 0xF0, 0x90, 0x8B, 0x35, 0xF0, 0x90, 
+0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x8A, 0x7B, 0x74, 0x01, 0xF0, 0x90, 0x8A, 0x83, 0xE0, 
+0x70, 0x02, 0x61, 0xD3, 0x90, 0x8A, 0x9A, 0xE0, 0x04, 0xF0, 0x90, 0x05, 0x61, 0x51, 0xBE, 0x78, 
+0x08, 0x12, 0x03, 0xFE, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x05, 0x60, 0x51, 
+0xBE, 0x12, 0x87, 0x3D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x05, 0x62, 0x51, 
+0xBE, 0x78, 0x10, 0x12, 0x03, 0xFE, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x87, 
+0x3D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0x51, 0xBE, 0x78, 0x18, 0x12, 0x03, 
+0xFE, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x87, 0x3D, 0x90, 0x8A, 0xCE, 0x12, 
+0x04, 0x31, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x30, 0xE0, 0x09, 0x12, 0xD0, 
+0xE0, 0x12, 0x40, 0x55, 0x12, 0xCF, 0xFF, 0x90, 0x8A, 0x7F, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 
+0x30, 0xE0, 0x09, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x02, 0xF1, 0x88, 0x90, 0x91, 0x54, 0xE0, 
+0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 
+0x44, 0x01, 0xF0, 0x7F, 0x01, 0x12, 0xB6, 0xED, 0x90, 0x90, 0x04, 0xE0, 0x30, 0xE0, 0x09, 0x90, 
+0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x02, 0xF1, 0x88, 0x22, 0xEF, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x19, 
+0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFF, 0x7E, 0x00, 0x22, 0x7D, 0x17, 0x7F, 0xFF, 
+0x12, 0x96, 0xA5, 0xE4, 0x90, 0x91, 0x4E, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 
+0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0x91, 
+0x61, 0x30, 0xE0, 0x15, 0xD3, 0x90, 0x91, 0x4F, 0xE0, 0x94, 0x03, 0x90, 0x91, 0x4E, 0xE0, 0x94, 
+0x00, 0x40, 0x02, 0x80, 0x13, 0x7F, 0x01, 0x80, 0x1B, 0xD3, 0x90, 0x91, 0x4F, 0xE0, 0x94, 0xE8, 
+0x90, 0x91, 0x4E, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 
+0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x7B, 0x8D, 0x90, 0x91, 0x4E, 0x12, 0xBA, 0x60, 0x80, 
+0xA9, 0x90, 0x8A, 0xEE, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xCB, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 
+0x8A, 0xED, 0x91, 0x64, 0x30, 0xE0, 0x02, 0xA1, 0x79, 0x90, 0x8B, 0x2D, 0xE0, 0x70, 0x5E, 0x90, 
+0x8F, 0xCB, 0xE0, 0x64, 0x02, 0x60, 0x26, 0x90, 0x8F, 0xCC, 0xE0, 0x70, 0x20, 0xF1, 0x45, 0xB1, 
+0x7F, 0xF1, 0x2A, 0xB4, 0x01, 0x05, 0x12, 0x04, 0xB2, 0x80, 0x07, 0xF1, 0x32, 0xEE, 0x44, 0x02, 
+0xFE, 0xEC, 0xB1, 0x80, 0xB1, 0x86, 0x7F, 0x48, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0x90, 0x8F, 0xCC, 
+0xE0, 0xFF, 0x64, 0x02, 0x70, 0x02, 0xA1, 0x79, 0xEF, 0x70, 0x02, 0xA1, 0x79, 0xF1, 0x45, 0xB1, 
+0x7F, 0x90, 0x8B, 0x2C, 0xE0, 0x90, 0x8F, 0xCD, 0x60, 0x04, 0xF1, 0x32, 0x80, 0x07, 0x12, 0x04, 
+0xB2, 0xEE, 0x44, 0x02, 0xFE, 0xB1, 0x7F, 0xB1, 0x86, 0x7F, 0x48, 0xA1, 0x74, 0x90, 0x8F, 0xCB, 
+0xE0, 0x64, 0x02, 0x60, 0x25, 0xF1, 0x13, 0xEF, 0x54, 0xFC, 0xB1, 0x7E, 0xF1, 0x2A, 0xB4, 0x01, 
+0x08, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x01, 0x80, 0x06, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x02, 0xB1, 
+0x7E, 0xB1, 0x86, 0x7F, 0x2C, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0x90, 0x8F, 0xCC, 0xE0, 0x64, 0x02, 
+0x60, 0x57, 0x12, 0xCC, 0x84, 0xE4, 0xB1, 0x7E, 0x90, 0x8F, 0xCC, 0xE0, 0x70, 0x0B, 0xA3, 0x12, 
+0x04, 0xB2, 0xEF, 0x44, 0x77, 0xB1, 0x7E, 0x80, 0x37, 0x90, 0x8F, 0xCD, 0x12, 0x04, 0xB2, 0xEF, 
+0x44, 0x66, 0xB1, 0x7E, 0xF1, 0x13, 0xEF, 0x54, 0xFC, 0xF1, 0x22, 0x90, 0x8B, 0x2C, 0xE0, 0x90, 
+0x8F, 0xD1, 0x60, 0x08, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x02, 0x80, 0x06, 0x12, 0x04, 0xB2, 0xEF, 
+0x44, 0x01, 0xF1, 0x22, 0x90, 0x8F, 0xD1, 0xB1, 0x89, 0x7F, 0x2C, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 
+0xB1, 0x86, 0x7F, 0x30, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xFF, 0xEC, 
+0x90, 0x8F, 0xCD, 0x02, 0x04, 0x31, 0x90, 0x8F, 0xCD, 0x12, 0x04, 0xB2, 0x90, 0x8E, 0xEE, 0x02, 
+0x04, 0x31, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0xBF, 0xDA, 0xEC, 0x90, 0x8F, 0xE4, 
+0x12, 0x04, 0x31, 0x90, 0x8F, 0xE4, 0xB1, 0x89, 0x7F, 0x30, 0x7E, 0x08, 0x12, 0x6F, 0xFE, 0x91, 
+0x03, 0x7F, 0x02, 0x12, 0x7A, 0xB8, 0xF1, 0x53, 0xF1, 0x53, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 
+0x12, 0x7A, 0xA5, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 0x90, 
+0x01, 0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0x12, 0xB8, 0xB7, 0x13, 
+0x54, 0x1F, 0x30, 0xE0, 0x05, 0x7F, 0x01, 0x12, 0x71, 0x29, 0x12, 0xB8, 0x1E, 0x30, 0xE0, 0x32, 
+0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x08, 0x90, 0x8F, 0xE2, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 
+0x8F, 0xE2, 0xF0, 0xEF, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0x8F, 0xE3, 0xF0, 
+0x80, 0x06, 0x90, 0x8F, 0xE3, 0x74, 0x02, 0xF0, 0x90, 0x8F, 0xE2, 0x91, 0x6B, 0x7F, 0x01, 0x12, 
+0x71, 0x29, 0x90, 0x8A, 0xE7, 0xE0, 0x60, 0x02, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x49, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x89, 
+0x80, 0xE0, 0x04, 0xF0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x07, 0x90, 0x05, 0x10, 0xE4, 0xF0, 
+0xA3, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x55, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x91, 0x4D, 0xF0, 
+0x7D, 0x26, 0x71, 0xFE, 0xEF, 0x64, 0x01, 0x70, 0x23, 0x90, 0x89, 0x85, 0xE0, 0xFF, 0x90, 0x91, 
+0x4A, 0xE0, 0xFB, 0x90, 0x8E, 0xE9, 0x74, 0x0A, 0xF0, 0x7D, 0x01, 0x12, 0x2B, 0x0B, 0xD1, 0xFC, 
+0x20, 0xE0, 0x1C, 0x90, 0x90, 0x09, 0xE0, 0x20, 0xE0, 0x15, 0x80, 0x11, 0x91, 0x61, 0x30, 0xE0, 
+0x0E, 0xD1, 0xE7, 0x20, 0xE0, 0x09, 0x90, 0x90, 0x09, 0xE0, 0x20, 0xE0, 0x02, 0xF1, 0x3A, 0x90, 
+0x91, 0x4D, 0xE0, 0xFF, 0x7D, 0x27, 0x12, 0x96, 0xA5, 0xF1, 0x1A, 0x80, 0x10, 0xF1, 0x1A, 0xD1, 
+0xE7, 0x20, 0xE0, 0x09, 0x90, 0x90, 0x09, 0xE0, 0x20, 0xE0, 0x02, 0xF1, 0x3A, 0x90, 0x8A, 0xEA, 
+0xE0, 0x30, 0xE0, 0x11, 0x91, 0x61, 0x30, 0xE0, 0x0C, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x6F, 0xFF, 
+0x7D, 0x28, 0x12, 0x96, 0xA5, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x12, 0xCC, 0xAE, 0x74, 0x01, 
+0xF0, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x89, 0x85, 0xE0, 0xFF, 0x90, 0x91, 0x4A, 0xE0, 
+0xFB, 0x90, 0x8F, 0xEF, 0x74, 0x0A, 0xF0, 0x7D, 0x01, 0x12, 0xC2, 0x7F, 0x90, 0x91, 0x4B, 0xEE, 
+0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x91, 0x49, 0xE0, 0xFF, 0x12, 0x56, 0x8E, 0x90, 0x90, 
+0x0A, 0xE0, 0x22, 0x7F, 0x2C, 0x7E, 0x09, 0x02, 0x6F, 0xC1, 0x90, 0x91, 0x49, 0xE0, 0xFF, 0x02, 
+0x59, 0x1B, 0xFF, 0xEC, 0x90, 0x8F, 0xD1, 0x02, 0x04, 0x31, 0x90, 0x8F, 0xCB, 0xE0, 0x90, 0x8F, 
+0xCD, 0x22, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x80, 0xFF, 0x22, 0x90, 0x91, 0x4B, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x02, 0x4F, 0xDA, 0x7F, 0x48, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xE4, 0xFF, 0xEE, 0x54, 
+0xF0, 0xFE, 0x22, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x7F, 0x02, 0x12, 0x7A, 
+0xB8, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x7F, 0x02, 0x02, 0x7A, 0xB8, 0x7D, 
+0x20, 0x7F, 0xFF, 0x12, 0x96, 0xA5, 0xB1, 0x92, 0x90, 0x8A, 0x7C, 0x74, 0x02, 0xF0, 0x22, 0x80, 
+0xF5, 0x12, 0xB8, 0xD1, 0x7D, 0x23, 0x80, 0xE9, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x7B, 0x53, 0x7D, 
+0x01, 0x7F, 0x02, 0x02, 0x7B, 0x53, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x64, 0x01, 
+0x70, 0x1A, 0xF1, 0xE5, 0x60, 0x0A, 0xF1, 0xDE, 0x12, 0x7B, 0x2A, 0x12, 0xD1, 0x5D, 0x80, 0x07, 
+0xF1, 0xDE, 0x12, 0x7A, 0xEE, 0xF1, 0x88, 0x12, 0x79, 0xE1, 0x80, 0x19, 0xF1, 0xE5, 0x60, 0x07, 
+0xF1, 0xDE, 0x12, 0x7B, 0x2A, 0x80, 0x05, 0xF1, 0xDE, 0x12, 0x7A, 0xEE, 0x12, 0xB5, 0x86, 0x12, 
+0xB7, 0xE3, 0x12, 0x7A, 0x3E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 
+0xF0, 0xFD, 0x7F, 0x03, 0x22, 0x90, 0x90, 0x06, 0xE0, 0x90, 0x01, 0x3F, 0x22, 0x12, 0xAF, 0xF0, 
+0xE1, 0x6F, 0x75, 0xF0, 0x13, 0xA4, 0x24, 0x3A, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 
+0x22, 0x12, 0xB0, 0x2C, 0xFF, 0x54, 0x0F, 0xF5, 0x60, 0xEF, 0xC4, 0x54, 0x0F, 0x64, 0x0F, 0x70, 
+0x4C, 0x90, 0x01, 0xA4, 0x04, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 0x54, 0xFE, 0xFF, 0xF0, 0xE5, 0x60, 
+0x54, 0x07, 0x25, 0xE0, 0xFE, 0xEF, 0x54, 0xF1, 0x4E, 0x51, 0x0E, 0x60, 0x03, 0xBF, 0x01, 0x0F, 
+0x90, 0x05, 0x27, 0xE0, 0x54, 0xED, 0xF0, 0x90, 0x01, 0xA4, 0x74, 0x02, 0xF0, 0x80, 0x03, 0x12, 
+0xB7, 0xDC, 0xAF, 0x60, 0x12, 0xA1, 0x3D, 0xBF, 0x01, 0x08, 0xE4, 0xFD, 0xFF, 0x12, 0xCA, 0x15, 
+0x80, 0x00, 0x7F, 0x02, 0x31, 0x97, 0x90, 0x01, 0xA4, 0x74, 0x04, 0xF0, 0x22, 0xE5, 0x60, 0x75, 
+0xF0, 0x13, 0xA4, 0x24, 0x37, 0xF9, 0x74, 0x90, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xC0, 0x02, 0xC0, 
+0x01, 0xE5, 0x5F, 0x24, 0x01, 0xF9, 0xE4, 0x35, 0x5E, 0x85, 0x5D, 0x1B, 0xF5, 0x1C, 0x89, 0x1D, 
+0x75, 0x1E, 0x04, 0xD0, 0x01, 0xD0, 0x02, 0x12, 0x68, 0xAB, 0x12, 0x90, 0x95, 0x31, 0x91, 0x12, 
+0x8F, 0x31, 0xFF, 0xE5, 0x60, 0x12, 0xD0, 0xC6, 0x54, 0xFE, 0x4F, 0xF0, 0xE5, 0x60, 0x12, 0xA7, 
+0xF2, 0x54, 0xF7, 0xF0, 0x51, 0x00, 0x14, 0x65, 0x60, 0x60, 0x02, 0x21, 0x8F, 0x90, 0x8A, 0x83, 
+0xE0, 0x70, 0x07, 0x90, 0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x05, 0x21, 0x97, 0x90, 0x01, 
+0xA4, 0xE4, 0xF0, 0xA3, 0xF0, 0x12, 0x90, 0x95, 0x51, 0x00, 0x90, 0x90, 0x0B, 0x31, 0x90, 0xFF, 
+0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFE, 0x90, 0x90, 0x0A, 0xE0, 0x54, 0x0F, 0x4E, 0xF0, 0xEF, 0x54, 
+0x10, 0x25, 0xE0, 0xFF, 0x90, 0x90, 0x72, 0xE0, 0x54, 0xDF, 0x4F, 0xFF, 0x31, 0x90, 0x54, 0x60, 
+0xC4, 0x54, 0x0F, 0xFE, 0xEF, 0x54, 0xF9, 0x4E, 0x90, 0x90, 0x72, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 
+0x54, 0xF1, 0xF0, 0x12, 0xCE, 0x55, 0x90, 0x90, 0xA8, 0xE0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x44, 
+0x40, 0xF0, 0x51, 0x07, 0x30, 0xE0, 0x06, 0xEF, 0x54, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x90, 0x0A, 
+0xE0, 0x44, 0x01, 0x51, 0x0E, 0x60, 0x05, 0xEF, 0x64, 0x01, 0x70, 0x19, 0x90, 0x90, 0xA9, 0x51, 
+0x07, 0x30, 0xE0, 0x08, 0xEF, 0x54, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x29, 0x90, 0x05, 0x27, 0xE0, 
+0x44, 0x12, 0xF0, 0x80, 0x20, 0x12, 0xD1, 0x9E, 0xE4, 0xFF, 0xEF, 0xFD, 0xC3, 0x74, 0x87, 0x51, 
+0x19, 0x74, 0x03, 0x51, 0x29, 0xEF, 0xFD, 0xC3, 0x74, 0x8B, 0x51, 0x19, 0x74, 0x07, 0x51, 0x29, 
+0x0F, 0xEF, 0xB4, 0x04, 0xE5, 0x7F, 0x03, 0x31, 0x97, 0x90, 0x90, 0x39, 0xE0, 0x90, 0x90, 0xA7, 
+0xB4, 0x64, 0x05, 0x74, 0xC8, 0xF0, 0x80, 0x03, 0x74, 0x64, 0xF0, 0x90, 0x90, 0x9F, 0x12, 0x04, 
+0x3D, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90, 0xA3, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x22, 
+0xF0, 0x90, 0x00, 0x06, 0x02, 0x02, 0x1F, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xA9, 0x07, 
+0x90, 0x05, 0x63, 0xE0, 0xFE, 0x90, 0x05, 0x62, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 
+0xAD, 0x07, 0xFC, 0x90, 0x05, 0x61, 0xE0, 0xFE, 0x90, 0x05, 0x60, 0xE0, 0x7A, 0x00, 0x24, 0x00, 
+0xFF, 0xEA, 0x3E, 0xFE, 0x90, 0x8F, 0xBC, 0x74, 0x17, 0xF0, 0x90, 0x8F, 0xCA, 0x74, 0x06, 0xF0, 
+0x90, 0x8F, 0xBE, 0xE9, 0xF0, 0x12, 0x95, 0x4D, 0x12, 0xA1, 0x2F, 0xE0, 0x90, 0x8F, 0xBF, 0xF0, 
+0xAB, 0x07, 0xA3, 0xEB, 0xF0, 0xEE, 0xA3, 0xF0, 0xAF, 0x05, 0xA3, 0xEF, 0xF0, 0xAE, 0x04, 0xEE, 
+0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0xBC, 0x12, 0x87, 0x99, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x12, 0x02, 0x06, 0xC4, 0x54, 0x0F, 0x22, 0xE0, 0xFF, 0xC4, 0x13, 0x54, 0x07, 0x22, 0xF0, 0x90, 
+0x90, 0x3A, 0xE0, 0x54, 0x07, 0xFF, 0x64, 0x03, 0x22, 0x9D, 0xFD, 0x74, 0x05, 0x94, 0x00, 0x8D, 
+0x82, 0xF5, 0x83, 0xE0, 0xFE, 0xEF, 0xFD, 0xC3, 0x22, 0x9D, 0xFD, 0xE4, 0x94, 0x00, 0xFC, 0x74, 
+0xC5, 0x2D, 0xF5, 0x82, 0x74, 0x90, 0x3C, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x8A, 0x7E, 0xD1, 
+0xC1, 0x30, 0xE0, 0x2A, 0xEF, 0x54, 0xBF, 0x12, 0xBF, 0x97, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 
+0xF0, 0x80, 0x0A, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 0xBF, 0xB8, 0x74, 0x04, 0xF0, 0x90, 0x8A, 0xF0, 
+0x51, 0x07, 0x30, 0xE0, 0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x80, 0x08, 0x12, 0xB4, 0x7C, 0x22, 0x7D, 
+0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x57, 0xED, 0xF0, 0x90, 
+0x8A, 0x7E, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x61, 0xD2, 0xEE, 0x12, 
+0x8F, 0x33, 0x30, 0xE0, 0x02, 0x61, 0xD2, 0x90, 0x8A, 0x86, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x61, 
+0xD2, 0xEF, 0x70, 0x02, 0x61, 0x39, 0x24, 0xFE, 0x70, 0x02, 0x61, 0x76, 0x24, 0xFE, 0x60, 0x4D, 
+0x24, 0xFC, 0x70, 0x02, 0x61, 0xB5, 0x24, 0xFC, 0x60, 0x02, 0x61, 0xC8, 0xEE, 0xB4, 0x0E, 0x03, 
+0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 
+0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x04, 0x0F, 0x90, 
+0x91, 0x57, 0xE0, 0xFF, 0x60, 0x05, 0x12, 0x6C, 0x1E, 0x80, 0x03, 0x12, 0x78, 0xD1, 0x90, 0x8A, 
+0x86, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x61, 0xC8, 0x12, 0x7A, 0x3E, 0x61, 0xC8, 0x90, 0x8A, 0x86, 
+0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 
+0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 0x71, 0xD7, 0xBF, 0x01, 0x03, 0x12, 0x74, 
+0x33, 0x90, 0x8A, 0x86, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x61, 0xC8, 0x71, 0xD7, 0xEF, 0x64, 0x01, 
+0x60, 0x02, 0x61, 0xC8, 0x12, 0x6D, 0x38, 0x61, 0xC8, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 
+0x71, 0xD7, 0xBF, 0x01, 0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 
+0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x08, 0x71, 0xD7, 0xBF, 0x01, 0x03, 0x12, 0x6D, 
+0x38, 0x90, 0x8A, 0x86, 0xE0, 0x64, 0x04, 0x70, 0x5F, 0x12, 0xCE, 0x86, 0xEF, 0x64, 0x01, 0x70, 
+0x57, 0x12, 0x77, 0x7E, 0x80, 0x52, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 0x71, 0xD7, 0xBF, 
+0x01, 0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 
+0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x08, 0x71, 0xD7, 0xBF, 0x01, 0x03, 0x12, 0x6D, 0x38, 0x90, 0x8A, 
+0x86, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x04, 0x18, 
+0x12, 0x79, 0x64, 0x80, 0x13, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x0C, 0x90, 0x8A, 0x7F, 0x12, 
+0xB4, 0xD9, 0x30, 0xE0, 0x03, 0x12, 0x79, 0xE1, 0x90, 0x8A, 0x86, 0x12, 0xD1, 0x1C, 0x90, 0x01, 
+0xBB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 
+0xEA, 0xE0, 0x30, 0xE0, 0x10, 0x90, 0x8A, 0xF0, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x12, 
+0x75, 0x0F, 0x10, 0x80, 0x31, 0x12, 0x79, 0x80, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x75, 0x0F, 0x01, 
+0x80, 0x24, 0x90, 0x8A, 0x7E, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x05, 0x75, 0x0F, 
+0x02, 0x80, 0x13, 0x90, 0x8A, 0x85, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 0x75, 0x0F, 0x08, 0x80, 
+0x05, 0x12, 0xBE, 0xCF, 0x80, 0x0E, 0x90, 0x01, 0xB9, 0x74, 0x02, 0xF0, 0x90, 0x01, 0xB8, 0xE5, 
+0x0F, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x8B, 0x5D, 0x8A, 0x5E, 0x89, 0x5F, 0x90, 0x05, 0x27, 0xE0, 0xF5, 0x60, 0x8B, 0x1B, 0x8A, 0x1C, 
+0x89, 0x1D, 0x75, 0x1E, 0x01, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0x79, 0x12, 0x68, 0xAB, 0x12, 0x90, 
+0x95, 0x12, 0x02, 0x06, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x81, 0xF3, 0x90, 0x8A, 0x79, 0xE0, 
+0x30, 0xE0, 0x6F, 0xD1, 0xC9, 0x75, 0x60, 0x21, 0xD1, 0xD0, 0x30, 0xE0, 0x05, 0x12, 0xD0, 0xA8, 
+0x80, 0x0D, 0xE4, 0x90, 0x8A, 0x7A, 0xF0, 0xA3, 0xF0, 0x7D, 0x40, 0xFF, 0x12, 0x7B, 0x53, 0x90, 
+0x8A, 0x79, 0xD1, 0xDC, 0x30, 0xE0, 0x03, 0x43, 0x60, 0x12, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 
+0x03, 0x43, 0x60, 0x14, 0x90, 0x8A, 0x79, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x03, 0x43, 
+0x60, 0x80, 0x90, 0x8A, 0x79, 0x12, 0xA4, 0x64, 0x20, 0xE0, 0x03, 0x43, 0x60, 0x40, 0xB1, 0x9C, 
+0x90, 0x8A, 0x7C, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0xB1, 0xA3, 0xD1, 0xBE, 0x30, 0xE0, 0x04, 0x7F, 
+0x04, 0x80, 0x0B, 0xD1, 0xE4, 0xEF, 0x60, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0xB1, 0xA3, 
+0xA1, 0x64, 0xB1, 0x99, 0x90, 0x8A, 0x7C, 0xE0, 0x64, 0x04, 0x60, 0x02, 0xA1, 0x94, 0xFF, 0xB1, 
+0xA3, 0xA1, 0x94, 0x90, 0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x72, 0xD1, 0xC9, 0x43, 0x60, 0x31, 0xD1, 
+0xD0, 0x30, 0xE0, 0x05, 0x12, 0xD0, 0xA8, 0x80, 0x07, 0x7D, 0x40, 0xE4, 0xFF, 0x12, 0x7B, 0x53, 
+0x90, 0x8A, 0x79, 0xD1, 0xDC, 0x30, 0xE0, 0x03, 0x43, 0x60, 0x02, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 
+0xE0, 0x03, 0x43, 0x60, 0x04, 0xB1, 0x9C, 0xD1, 0xBE, 0x30, 0xE0, 0x0E, 0x90, 0x8A, 0x7D, 0xE0, 
+0x64, 0x02, 0x60, 0x30, 0xE4, 0xFD, 0x7F, 0x02, 0x80, 0x1E, 0x12, 0xB8, 0xD1, 0x90, 0x8A, 0x7D, 
+0xE0, 0xB4, 0x02, 0x18, 0x12, 0x7A, 0x27, 0xD1, 0xE4, 0xBF, 0x01, 0x09, 0x90, 0x8A, 0x85, 0xE0, 
+0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 0x51, 0x73, 0x80, 0x08, 0x90, 0x8A, 0x86, 0xE0, 
+0x90, 0x8A, 0x7D, 0xF0, 0x90, 0x05, 0x40, 0x74, 0x22, 0xF0, 0x80, 0x28, 0xB1, 0x99, 0x90, 0x8A, 
+0x7D, 0xE0, 0xB4, 0x02, 0x06, 0x7D, 0x01, 0x7F, 0x04, 0x80, 0x0B, 0x90, 0x8A, 0x7D, 0xE0, 0xB4, 
+0x08, 0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x51, 0x73, 0x12, 0xCD, 0x4A, 0x90, 0x8A, 0x85, 0x12, 0xB4, 
+0x8B, 0x12, 0xCC, 0xC3, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0x60, 0x01, 0x90, 0x05, 0x27, 0xE5, 
+0x60, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 0x7C, 0xE0, 0x90, 0x91, 
+0x56, 0xF0, 0x6F, 0x70, 0x02, 0xC1, 0xB9, 0xEF, 0x14, 0x60, 0x46, 0x14, 0x60, 0x73, 0x14, 0x70, 
+0x02, 0xC1, 0x60, 0x14, 0x70, 0x02, 0xC1, 0x8F, 0x24, 0x04, 0x60, 0x02, 0xC1, 0xB9, 0x90, 0x91, 
+0x56, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xCC, 0xEF, 0xC1, 0xB9, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x02, 
+0x05, 0x12, 0xCC, 0xF3, 0xC1, 0xB9, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x03, 0x05, 0x12, 0xCC, 0xF7, 
+0xC1, 0xB9, 0x90, 0x91, 0x56, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xC1, 0xB9, 0x12, 0xCC, 0xE2, 0xC1, 
+0xB9, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xCD, 0x05, 0xC1, 0xB9, 0x90, 0x91, 0x56, 
+0xE0, 0xB4, 0x02, 0x05, 0x12, 0xCD, 0x12, 0xC1, 0xB9, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x03, 0x05, 
+0x12, 0xCC, 0xFB, 0xC1, 0xB9, 0x90, 0x91, 0x56, 0xE0, 0x60, 0x02, 0xC1, 0xB9, 0xF1, 0xF0, 0xC1, 
+0xB9, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xA7, 0x81, 0x80, 0x7C, 0x90, 0x91, 0x56, 
+0xE0, 0xB4, 0x01, 0x05, 0x12, 0xA7, 0x6F, 0x80, 0x70, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x03, 0x05, 
+0x12, 0xA7, 0x7F, 0x80, 0x64, 0x90, 0x91, 0x56, 0xE0, 0x70, 0x5E, 0x12, 0xA7, 0xED, 0x80, 0x59, 
+0x90, 0x91, 0x56, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xB8, 0xBF, 0x80, 0x4D, 0x90, 0x91, 0x56, 0xE0, 
+0xB4, 0x01, 0x05, 0x12, 0xBF, 0xAA, 0x80, 0x41, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x02, 0x05, 0x12, 
+0xB8, 0xAE, 0x80, 0x35, 0x90, 0x91, 0x56, 0xE0, 0x70, 0x2F, 0x12, 0xBF, 0xB3, 0x80, 0x2A, 0x90, 
+0x91, 0x56, 0xE0, 0xB4, 0x03, 0x04, 0xF1, 0xE8, 0x80, 0x1F, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x01, 
+0x04, 0xF1, 0xD3, 0x80, 0x14, 0x90, 0x91, 0x56, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0xB8, 0xCA, 0x80, 
+0x08, 0x90, 0x91, 0x56, 0xE0, 0x70, 0x02, 0xF1, 0xEC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8A, 
+0x79, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x7D, 0x03, 0x7F, 0x02, 0x02, 0x7B, 0x2A, 
+0x90, 0x8A, 0x79, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 0xFF, 0x13, 0x13, 
+0x13, 0x54, 0x1F, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 
+0xE4, 0xF5, 0x7C, 0x90, 0x8A, 0x83, 0xE0, 0x70, 0x02, 0xE1, 0x94, 0x12, 0xB4, 0x18, 0x60, 0x02, 
+0xE1, 0x94, 0x12, 0xD0, 0x11, 0x12, 0xB3, 0xE5, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 
+0x1E, 0x90, 0x8A, 0x8A, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x8A, 0x8C, 0xE0, 0x60, 
+0x0E, 0xEF, 0x70, 0x08, 0x90, 0x8A, 0x89, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x7C, 0x01, 0x90, 
+0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x11, 0x90, 0x8A, 0x7D, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 0xF5, 0x7C, 
+0xD1, 0xE4, 0xEF, 0x70, 0x02, 0xF5, 0x7C, 0xE5, 0x7C, 0x60, 0x49, 0x90, 0x8A, 0x86, 0xE0, 0x20, 
+0xE2, 0x02, 0x51, 0x6F, 0x12, 0xD1, 0x7F, 0x90, 0x8A, 0x8C, 0xE0, 0x60, 0x04, 0x64, 0x01, 0x70, 
+0x17, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x8A, 0x8C, 0xE0, 0xF1, 0x95, 0x90, 0x8E, 0xF7, 0x12, 
+0xB2, 0xC0, 0x90, 0x8A, 0x8C, 0xE0, 0x80, 0x13, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x12, 0xD1, 0x06, 
+0xF1, 0x95, 0x90, 0x8E, 0xF7, 0x12, 0xB2, 0xC0, 0x12, 0xD1, 0x06, 0xF1, 0x95, 0x90, 0x8A, 0x9C, 
+0xF0, 0x12, 0x70, 0x76, 0x22, 0xFF, 0x90, 0x8A, 0x8B, 0xE0, 0x2F, 0x22, 0xD1, 0xBE, 0x30, 0xE0, 
+0x0E, 0x90, 0x8A, 0x7D, 0xE0, 0x64, 0x02, 0x60, 0x06, 0x7D, 0x01, 0x7F, 0x02, 0x51, 0x73, 0x90, 
+0x8A, 0x7D, 0xE0, 0x64, 0x02, 0x60, 0x02, 0xF1, 0xBA, 0x22, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x02, 
+0x60, 0x10, 0x12, 0xB1, 0xD3, 0x60, 0x0B, 0x12, 0x79, 0x80, 0xEF, 0x70, 0x05, 0xFD, 0x7F, 0x0C, 
+0x51, 0x73, 0x22, 0x7D, 0x1F, 0x7F, 0x6F, 0x12, 0x96, 0xA5, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 
+0xF0, 0x90, 0x8A, 0x7C, 0x74, 0x04, 0xF0, 0x22, 0x7D, 0x25, 0x80, 0xE9, 0xF1, 0xF0, 0x80, 0xE3, 
+0x90, 0x8A, 0x7C, 0x74, 0x01, 0xF0, 0x22, 0x12, 0xB0, 0x2C, 0xFF, 0x54, 0x01, 0xC4, 0x33, 0x54, 
+0xE0, 0xFE, 0x90, 0x90, 0xA9, 0xE0, 0x54, 0xDF, 0x4E, 0xF0, 0xEF, 0x54, 0xFE, 0xC3, 0x13, 0xFF, 
+0x90, 0x90, 0xA8, 0xE0, 0x54, 0x80, 0x4F, 0xF0, 0x12, 0x8F, 0x91, 0x90, 0x90, 0xAA, 0x12, 0x8D, 
+0xBF, 0x90, 0x90, 0xAB, 0x12, 0x88, 0x2B, 0x90, 0x90, 0xAC, 0xF0, 0x22, 0x8B, 0x5D, 0x8A, 0x5E, 
+0x89, 0x5F, 0x02, 0x02, 0x06, 0x12, 0x02, 0x06, 0xFF, 0x90, 0x90, 0x03, 0xF0, 0xBF, 0x01, 0x07, 
+0x11, 0x48, 0xE4, 0x90, 0x90, 0x03, 0xF0, 0x22, 0x11, 0xC6, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x62, 
+0xDB, 0xBF, 0x01, 0x06, 0x90, 0x90, 0xC5, 0xE0, 0xA3, 0xF0, 0x11, 0xC6, 0x7F, 0xF6, 0x7E, 0x01, 
+0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xC5, 0xE0, 0x90, 0x90, 0xC7, 0xF0, 0x11, 0xC6, 
+0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xC5, 0xE0, 0x90, 0x90, 
+0xC8, 0xF0, 0x11, 0xC6, 0x7F, 0xF3, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 
+0xC5, 0xE0, 0x90, 0x90, 0xC9, 0xF0, 0x11, 0xC6, 0x7F, 0xF2, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 
+0x01, 0x08, 0x90, 0x90, 0xC5, 0xE0, 0x90, 0x90, 0xCA, 0xF0, 0x90, 0x90, 0xC6, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0x90, 0xCE, 0xF0, 0x90, 0x90, 0xCA, 0xE0, 0x90, 
+0x90, 0xCF, 0xF0, 0x02, 0x87, 0xB8, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xC5, 0x22, 0x12, 0x02, 0x06, 
+0x54, 0x01, 0xFF, 0x90, 0x90, 0xC0, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x8A, 0x21, 0x12, 
+0x02, 0x06, 0xFF, 0x54, 0x7F, 0x90, 0x8A, 0x83, 0xF0, 0xEF, 0x12, 0x8F, 0x33, 0xA3, 0xF0, 0x12, 
+0x8F, 0x91, 0xFD, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFF, 0x90, 0x8A, 0x81, 0xE0, 0x54, 0xF0, 0x4F, 
+0x12, 0x88, 0x2B, 0xFC, 0x54, 0x01, 0x25, 0xE0, 0xFF, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 0xFD, 0x4F, 
+0xF0, 0xEC, 0x54, 0x04, 0xC3, 0x13, 0xFF, 0x90, 0x8A, 0x80, 0xE0, 0x54, 0xFD, 0x4F, 0xF0, 0xED, 
+0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0xA3, 0xE0, 0x54, 0x0F, 0x12, 0x8D, 0xBE, 0x90, 0x8A, 0x82, 
+0x12, 0x8F, 0xD1, 0xFD, 0x7F, 0x02, 0x12, 0x53, 0xDB, 0x12, 0x8A, 0x27, 0x12, 0x8F, 0xE3, 0xFF, 
+0x54, 0x01, 0xFE, 0x90, 0x8A, 0xE8, 0x12, 0xC0, 0x17, 0x12, 0x8F, 0xE1, 0xFE, 0x54, 0x04, 0xFD, 
+0xEF, 0x54, 0xFB, 0x31, 0xC4, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x12, 0x8F, 0xE0, 0xFE, 0x54, 
+0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x31, 0xC4, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x12, 0x8F, 0xE0, 
+0x54, 0x40, 0xFE, 0xEF, 0x54, 0xBF, 0x4E, 0x90, 0x8A, 0xE8, 0xF0, 0x12, 0xAE, 0xC1, 0x20, 0xE0, 
+0x29, 0xEF, 0xC3, 0x13, 0x20, 0xE0, 0x0B, 0x75, 0x5E, 0x01, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x0B, 
+0x80, 0x0E, 0xE4, 0xF5, 0x5E, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x05, 0xE4, 0xF5, 0x5D, 0x80, 0x03, 
+0x75, 0x5D, 0x01, 0xAD, 0x5E, 0xAF, 0x5D, 0x12, 0xA4, 0x70, 0x12, 0x8A, 0x27, 0x12, 0x6C, 0xAD, 
+0x12, 0xBF, 0xB8, 0xF0, 0x90, 0x8A, 0x83, 0x12, 0xD1, 0x1C, 0x90, 0x01, 0xBB, 0x31, 0xD2, 0x90, 
+0x01, 0xBE, 0xF0, 0x22, 0x4D, 0xFF, 0x90, 0x8A, 0xE8, 0xF0, 0xEE, 0x22, 0x90, 0x8A, 0x87, 0xE0, 
+0x44, 0x01, 0xF0, 0x90, 0x8A, 0x81, 0xE0, 0x54, 0x0F, 0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x91, 
+0x24, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 0x04, 0x51, 0x46, 0x80, 0x56, 0xED, 0x30, 0xE6, 0x3F, 
+0x90, 0x8A, 0x83, 0xE0, 0x64, 0x02, 0x70, 0x27, 0x90, 0x8A, 0x7E, 0xE0, 0xFF, 0xC3, 0x13, 0x20, 
+0xE0, 0x09, 0x90, 0x8A, 0x87, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x1A, 0x31, 0xD3, 0x64, 0x01, 0x70, 
+0x20, 0x90, 0x8A, 0x87, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x01, 0x12, 0x5B, 0x82, 0x80, 0x12, 0x31, 
+0xCC, 0x64, 0x02, 0x60, 0x05, 0x12, 0x72, 0xB9, 0x80, 0x07, 0x12, 0x78, 0x92, 0x80, 0x02, 0x51, 
+0x46, 0x90, 0x91, 0x24, 0xE0, 0x90, 0x8A, 0x87, 0x30, 0xE7, 0x06, 0x71, 0xF6, 0x51, 0xC0, 0x61, 
+0xEE, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x06, 
+0xA9, 0xE0, 0xF5, 0x7C, 0x54, 0xC0, 0x70, 0x07, 0x51, 0x46, 0x54, 0xFD, 0xF0, 0x81, 0x7C, 0xE5, 
+0x7C, 0x30, 0xE6, 0x18, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x01, 0x70, 0x12, 0x31, 0xCC, 0x64, 0x02, 
+0x60, 0x05, 0x12, 0x72, 0xB9, 0x80, 0x07, 0x12, 0x78, 0x92, 0x80, 0x02, 0x51, 0x46, 0xE5, 0x7C, 
+0x90, 0x8A, 0x87, 0x30, 0xE7, 0x06, 0x71, 0xF6, 0x51, 0xC0, 0x61, 0xEE, 0xE0, 0x54, 0xFD, 0xF0, 
+0x22, 0x90, 0x90, 0x0A, 0xE0, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x17, 
+0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xFE, 0xEF, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x16, 
+0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x90, 0x8E, 0xF7, 0xF0, 0x90, 0x8E, 0xF6, 0xEE, 
+0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x02, 0x5E, 0xAD, 0x90, 0x05, 0x62, 0xE0, 0xFE, 
+0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 
+0x90, 0x91, 0x22, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x91, 0x18, 0x60, 0x02, 0x61, 0xC9, 0x90, 0x8A, 
+0x83, 0xE0, 0x70, 0x02, 0x61, 0xC9, 0x90, 0x05, 0x63, 0xE0, 0x90, 0x8A, 0xD2, 0xF0, 0x90, 0x05, 
+0x62, 0xE0, 0x90, 0x8A, 0xD3, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0x90, 0x8A, 0xD4, 0xF0, 0x90, 0x05, 
+0x60, 0xE0, 0x90, 0x8A, 0xD5, 0xF0, 0x91, 0xAC, 0xF0, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xEC, 0xF0, 
+0x71, 0xE5, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x0D, 0x90, 0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x04, 0x31, 
+0xDA, 0x80, 0x02, 0x51, 0x4E, 0x71, 0xE5, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 
+0x8A, 0x8A, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0x8A, 0x89, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 
+0x90, 0x8A, 0x89, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x8A, 0x8A, 0xEF, 0xF0, 0x12, 0x33, 0x5F, 
+0xE4, 0x90, 0x8A, 0x8C, 0xF0, 0x12, 0xD0, 0x07, 0x12, 0xAE, 0xD9, 0x30, 0xE0, 0x59, 0xEF, 0xC4, 
+0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x21, 0x71, 0xDD, 0x6F, 0x70, 0x4B, 0x90, 0x8A, 0x7F, 0xE0, 
+0x44, 0x40, 0xF0, 0xB1, 0x55, 0x12, 0xA7, 0xDA, 0x12, 0x7B, 0x2A, 0x12, 0xA7, 0x8F, 0xB1, 0x4E, 
+0x90, 0x8A, 0x8A, 0xE0, 0x14, 0xF0, 0x80, 0x2F, 0x90, 0x8A, 0x81, 0xE0, 0xC4, 0x54, 0x0F, 0x64, 
+0x01, 0x70, 0x24, 0x71, 0xDD, 0xFE, 0x6F, 0x60, 0x1E, 0x90, 0x05, 0x73, 0xE0, 0xFF, 0xEE, 0x6F, 
+0x60, 0x15, 0x90, 0x8A, 0x7F, 0x91, 0xD9, 0x30, 0xE0, 0x0D, 0xEF, 0x54, 0xBF, 0x12, 0xA7, 0xDA, 
+0x12, 0x7A, 0xEE, 0xF1, 0xE3, 0xB1, 0x86, 0x71, 0xD5, 0x90, 0x8A, 0x79, 0xE0, 0xC3, 0x13, 0x20, 
+0xE0, 0x02, 0x71, 0xD5, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0x8A, 0x89, 
+0xE0, 0xFF, 0xA3, 0xE0, 0x22, 0x90, 0x8A, 0x81, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x90, 0x8A, 
+0x7E, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 
+0x8A, 0xE1, 0xE0, 0x90, 0x8E, 0xF7, 0x22, 0x91, 0x18, 0x70, 0x0C, 0x90, 0x8A, 0x83, 0xE0, 0x60, 
+0x06, 0x91, 0xAC, 0x71, 0xF9, 0x51, 0xC0, 0x22, 0xE4, 0xFF, 0x12, 0x77, 0x09, 0xEF, 0x64, 0x01, 
+0x22, 0x12, 0xAE, 0xD9, 0x30, 0xE0, 0x0B, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 
+0xB1, 0x4E, 0x91, 0xD6, 0x30, 0xE0, 0x08, 0x91, 0xE0, 0x54, 0x07, 0x70, 0x36, 0x80, 0x32, 0xD1, 
+0xFC, 0x40, 0x2E, 0x91, 0x18, 0x70, 0x2C, 0x31, 0xD3, 0x70, 0x05, 0x12, 0x68, 0x5F, 0x80, 0x24, 
+0x12, 0x68, 0x5F, 0x90, 0x8A, 0x8D, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x09, 0x91, 
+0x74, 0xE4, 0x90, 0x8A, 0x8D, 0xF0, 0x80, 0x03, 0x12, 0x78, 0x92, 0xE4, 0x90, 0x8A, 0x8C, 0xF0, 
+0x22, 0x91, 0x7C, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x8A, 0x79, 0xE0, 
+0x90, 0x8A, 0x85, 0x30, 0xE0, 0x05, 0xE0, 0xFF, 0x02, 0xCD, 0x2C, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 
+0xAA, 0x73, 0x91, 0x18, 0x70, 0x15, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0F, 0x91, 0xAC, 0xF0, 0x90, 
+0x8A, 0x7E, 0xE0, 0x91, 0xE1, 0x54, 0x07, 0x70, 0x02, 0x91, 0x7C, 0x22, 0x90, 0x01, 0x57, 0xE4, 
+0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0x90, 0x01, 0x57, 0xE0, 0x60, 0x18, 0x91, 0xAF, 0xF0, 
+0x91, 0xD6, 0x30, 0xE0, 0x02, 0x80, 0x19, 0xD1, 0xFC, 0x40, 0x0A, 0xE4, 0xFF, 0x12, 0x77, 0x09, 
+0xBF, 0x01, 0x02, 0x91, 0x74, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 
+0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0xE4, 0x90, 0x91, 0x33, 
+0xF0, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x56, 0x91, 0x18, 0x70, 0x52, 0xB1, 0x55, 0xF0, 0x12, 0xD0, 
+0x11, 0x90, 0x91, 0x33, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x8A, 0x8A, 0xF0, 0x90, 0x8A, 0x79, 0xE0, 
+0x30, 0xE0, 0x16, 0x90, 0x8A, 0x7D, 0xE0, 0xB4, 0x02, 0x05, 0xE4, 0x90, 0x91, 0x33, 0xF0, 0x12, 
+0xAE, 0xE4, 0xEF, 0x70, 0x04, 0x90, 0x91, 0x33, 0xF0, 0x90, 0x91, 0x33, 0xE0, 0x60, 0x1E, 0x90, 
+0x8A, 0x86, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0xAA, 0x6F, 0x12, 0xD1, 0x7F, 0xE4, 0x90, 0x8E, 0xF6, 
+0xF0, 0x90, 0x8A, 0x8B, 0xE0, 0x90, 0x8E, 0xF7, 0x51, 0xC0, 0x12, 0x70, 0x76, 0x22, 0x7D, 0x02, 
+0x7F, 0x02, 0x02, 0x7B, 0x53, 0x90, 0x8A, 0x89, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x91, 0xEC, 0xB1, 
+0x86, 0x7F, 0x01, 0xF1, 0x73, 0x12, 0x7A, 0x10, 0x90, 0x90, 0x04, 0xE0, 0x30, 0xE0, 0x16, 0x12, 
+0xD1, 0x5D, 0x90, 0x90, 0x07, 0xE0, 0x60, 0x05, 0x14, 0xF0, 0x02, 0x79, 0xE1, 0x12, 0xC0, 0x0D, 
+0xE4, 0xFF, 0x12, 0xA7, 0x96, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x02, 0x7B, 0x97, 0x90, 0x90, 0x09, 
+0xE0, 0x30, 0xE0, 0x09, 0xF1, 0xDC, 0xE4, 0x90, 0x90, 0x0C, 0xF0, 0x51, 0x91, 0x22, 0xE4, 0xFF, 
+0x12, 0x77, 0x09, 0xBF, 0x01, 0x0E, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x08, 0x51, 0x46, 0x54, 0x07, 
+0x70, 0x02, 0x91, 0x7C, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 
+0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
+0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xB5, 0xF0, 0x74, 0xB5, 0xA3, 0xF0, 0x12, 0x70, 0xEE, 0xE5, 
+0x4B, 0x30, 0xE1, 0x02, 0xD1, 0x6A, 0xE5, 0x4B, 0x30, 0xE4, 0x02, 0xD1, 0xE8, 0xE5, 0x4B, 0x30, 
+0xE5, 0x03, 0x12, 0xCA, 0xCF, 0xE5, 0x4B, 0x30, 0xE6, 0x03, 0x12, 0xC6, 0x55, 0xE5, 0x4D, 0x30, 
+0xE0, 0x02, 0xF1, 0x51, 0xE5, 0x4D, 0x30, 0xE1, 0x03, 0x12, 0xA2, 0xC5, 0xE5, 0x4D, 0x30, 0xE2, 
+0x02, 0xF1, 0xA7, 0xE5, 0x4D, 0x30, 0xE3, 0x02, 0x91, 0x07, 0xE5, 0x4D, 0x30, 0xE4, 0x02, 0x91, 
+0x92, 0xE5, 0x4D, 0x30, 0xE5, 0x02, 0xF1, 0x15, 0xE5, 0x4D, 0x30, 0xE6, 0x02, 0xB1, 0x9E, 0xE5, 
+0x4E, 0x30, 0xE1, 0x02, 0xF1, 0x30, 0xE5, 0x4E, 0x30, 0xE4, 0x02, 0xF1, 0xD7, 0xE5, 0x4E, 0x30, 
+0xE5, 0x02, 0xF1, 0xD2, 0x74, 0xB5, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xB5, 0xA3, 0xF0, 0xD0, 
+0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 
+0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xFF, 0x90, 0x91, 0x22, 0xEF, 
+0xF0, 0x90, 0x04, 0x7E, 0xE0, 0xFF, 0xA3, 0xE0, 0x90, 0x91, 0x32, 0xF0, 0xE0, 0xFE, 0x6F, 0x60, 
+0x66, 0x90, 0x91, 0x23, 0x74, 0x03, 0xF0, 0x90, 0x91, 0x31, 0x74, 0x08, 0xF0, 0xEE, 0x04, 0x54, 
+0x0F, 0xFF, 0xE4, 0xFE, 0xEF, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x80, 
+0xF5, 0x83, 0xE5, 0x82, 0x2E, 0x12, 0xC9, 0xFE, 0xE0, 0xFD, 0x74, 0x25, 0x2E, 0xF5, 0x82, 0xE4, 
+0x34, 0x91, 0xF5, 0x83, 0xED, 0xF0, 0x0E, 0xEE, 0xB4, 0x08, 0xD9, 0x7B, 0x01, 0x7A, 0x91, 0x79, 
+0x23, 0x12, 0x5A, 0x18, 0x90, 0x91, 0x32, 0xE0, 0x04, 0x54, 0x0F, 0xFF, 0xF0, 0xBF, 0x0F, 0x02, 
+0xE4, 0xF0, 0x90, 0x91, 0x32, 0xE0, 0x90, 0x04, 0x7F, 0xF0, 0x90, 0x91, 0x22, 0xE0, 0x7F, 0x04, 
+0x70, 0x02, 0x80, 0x09, 0x12, 0x87, 0x9E, 0x22, 0x12, 0x3A, 0xE3, 0x7F, 0x02, 0x8F, 0x0D, 0x7F, 
+0x02, 0x12, 0x86, 0x27, 0x90, 0x89, 0x7E, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0x90, 0x8A, 0x8C, 0xE0, 
+0x04, 0xF0, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x8A, 0xE0, 0xE0, 0xFF, 0x90, 0x8A, 
+0x8C, 0xE0, 0xD3, 0x9F, 0x22, 0xE4, 0xFF, 0x12, 0x77, 0x09, 0xBF, 0x01, 0x12, 0x90, 0x8A, 0x83, 
+0xE0, 0x60, 0x0C, 0x31, 0xD3, 0x64, 0x02, 0x60, 0x03, 0x02, 0x72, 0xB9, 0x12, 0x78, 0x92, 0x22, 
+0x90, 0x8A, 0x83, 0xE0, 0x70, 0x07, 0x90, 0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x13, 0x90, 0x8A, 0x79, 
+0xE0, 0x30, 0xE0, 0x09, 0x12, 0xAE, 0xE4, 0xBF, 0x01, 0x06, 0x02, 0xAF, 0xBA, 0x12, 0xCD, 0x53, 
+0x22, 0x90, 0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x11, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0x8A, 0x79, 0xE0, 
+0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x12, 0xBE, 0x30, 0x12, 0xAE, 0xF0, 0xE4, 0xFF, 0xF1, 0x73, 
+0x02, 0x7A, 0x10, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 0x80, 0xE0, 0xFE, 0xC3, 
+0x13, 0x30, 0xE0, 0x1E, 0x90, 0x91, 0x33, 0x74, 0x1E, 0xF0, 0x90, 0x91, 0x41, 0x74, 0x01, 0xF0, 
+0x90, 0x91, 0x35, 0xEF, 0xF0, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x33, 0x12, 0x5A, 0x18, 0x7F, 0x04, 
+0xD1, 0xED, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8A, 0x79, 0xE0, 0xFF, 0x30, 0xE0, 0x08, 0x90, 
+0x8A, 0x7D, 0xE0, 0x64, 0x02, 0x60, 0x1A, 0x90, 0x8A, 0x83, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 
+0x0A, 0x90, 0x8A, 0x86, 0xE0, 0x64, 0x02, 0x60, 0x08, 0x51, 0xCB, 0x90, 0x01, 0xE6, 0xE0, 0x04, 
+0xF0, 0x22, 0x02, 0x5F, 0x1C, 0xA1, 0x8D, 0xE4, 0xFF, 0x02, 0x37, 0x43, 0x7D, 0x20, 0xE4, 0xFF, 
+0x02, 0x7A, 0xEE, 0x7D, 0x01, 0x7F, 0x02, 0x02, 0x7B, 0x97, 0x12, 0x02, 0x06, 0x90, 0x8A, 0xE9, 
+0xF0, 0x60, 0x2A, 0xA3, 0xE0, 0x20, 0xE0, 0x25, 0xE4, 0xFD, 0x7F, 0x04, 0x12, 0xAA, 0x73, 0x11, 
+0x1E, 0x30, 0xE0, 0x19, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x20, 0xE0, 0x10, 0x11, 0xB8, 0x54, 
+0x3F, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 0x7F, 0x09, 0x12, 0x71, 0x29, 0x22, 0x90, 0x8A, 
+0xE8, 0xE0, 0xFF, 0xC3, 0x13, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xDA, 0xEC, 
+0x90, 0x8F, 0xDE, 0x12, 0x04, 0x31, 0x90, 0x8F, 0xDE, 0x12, 0xA5, 0x89, 0x7F, 0x30, 0x7E, 0x08, 
+0x12, 0x6F, 0xFE, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 
+0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0x11, 0xB7, 0x13, 0x54, 0x1F, 
+0x30, 0xE0, 0x05, 0x7F, 0x03, 0x12, 0x71, 0x29, 0x90, 0x8B, 0x05, 0xE0, 0x20, 0xE0, 0x31, 0x11, 
+0x1E, 0x30, 0xE0, 0x2C, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x07, 0xE4, 0x90, 0x8F, 0xDC, 0xF0, 0x80, 
+0x06, 0x90, 0x8F, 0xDC, 0x74, 0x01, 0xF0, 0xEF, 0xC4, 0x13, 0x54, 0x07, 0x90, 0x8F, 0xDD, 0x30, 
+0xE0, 0x05, 0x74, 0x01, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 0x90, 0x8F, 0xDC, 0x12, 0xA4, 0x6B, 
+0x7F, 0x02, 0x11, 0xD9, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x11, 0x26, 
+0x90, 0x8A, 0x7C, 0x74, 0x03, 0xF0, 0x22, 0xF0, 0x90, 0x8A, 0xE8, 0xE0, 0x13, 0x13, 0x22, 0x7D, 
+0x22, 0x7F, 0xFF, 0x12, 0x96, 0xA5, 0x11, 0xD1, 0x80, 0xE6, 0x11, 0x26, 0x7D, 0x24, 0x02, 0xAF, 
+0xD5, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x12, 0x7A, 0xB8, 0xEF, 0x44, 0x01, 0xFD, 
+0x22, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x10, 0xF0, 0x31, 0xED, 0x7D, 0x01, 0x12, 0x6F, 0x45, 0x90, 
+0x8A, 0x8E, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x7A, 0xA5, 0x90, 0x8A, 0x84, 0xE0, 0x60, 0x12, 0x90, 
+0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 
+0xF0, 0x7F, 0x08, 0x12, 0x7A, 0xB8, 0xEF, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 0x7A, 0xA5, 0x7F, 
+0x01, 0x31, 0xA0, 0x7F, 0x90, 0x11, 0xD9, 0x7F, 0x90, 0x12, 0x7A, 0xA5, 0x7F, 0x14, 0x7E, 0x00, 
+0x02, 0x7B, 0x8D, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x11, 0xE1, 0x31, 0x7C, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x8A, 0x86, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0D, 0x51, 0x05, 0xBF, 
+0x01, 0x08, 0x31, 0x33, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0x30, 
+0xE0, 0x19, 0x90, 0x8A, 0x79, 0xE0, 0xFF, 0x30, 0xE0, 0x0F, 0xC3, 0x13, 0x30, 0xE0, 0x08, 0x12, 
+0xCD, 0x1F, 0xBF, 0x01, 0x06, 0x80, 0x02, 0x80, 0x00, 0x31, 0x43, 0x22, 0x12, 0xCB, 0x5F, 0x7F, 
+0x08, 0x12, 0x7A, 0xB8, 0xEF, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 0x7A, 0xA5, 0xE4, 0xFF, 0x31, 
+0xA0, 0x31, 0xED, 0xE4, 0xFD, 0x12, 0x6F, 0x45, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 
+0x90, 0x8F, 0xFA, 0xEF, 0xD1, 0x4B, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 
+0x01, 0x90, 0x8F, 0xFA, 0xE0, 0x6F, 0x60, 0x34, 0xC3, 0x90, 0x8F, 0xFC, 0xE0, 0x94, 0x88, 0x90, 
+0x8F, 0xFB, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 
+0x8F, 0xFB, 0x51, 0x60, 0x51, 0xB7, 0xD3, 0x90, 0x8F, 0xFC, 0xE0, 0x94, 0x32, 0x90, 0x8F, 0xFB, 
+0xE0, 0x94, 0x00, 0x40, 0xC1, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xBA, 0x22, 0x90, 0x8A, 0xED, 
+0xE0, 0xC4, 0x13, 0x13, 0x54, 0x01, 0xFF, 0x90, 0x8B, 0x2D, 0xE0, 0xFB, 0x90, 0x8B, 0x2C, 0xE0, 
+0x90, 0x84, 0xDC, 0xF0, 0x22, 0x90, 0x90, 0x04, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x35, 0x90, 0x02, 
+0x87, 0xE0, 0x60, 0x02, 0x80, 0x08, 0x90, 0x01, 0x00, 0xE0, 0x64, 0x3F, 0x60, 0x05, 0x75, 0x64, 
+0x01, 0x80, 0x2E, 0x90, 0x02, 0x96, 0xE0, 0x60, 0x05, 0x75, 0x64, 0x10, 0x80, 0x23, 0x90, 0x02, 
+0x86, 0xE0, 0x20, 0xE1, 0x02, 0x80, 0x07, 0x90, 0x02, 0x86, 0xE0, 0x30, 0xE3, 0x05, 0x75, 0x64, 
+0x04, 0x80, 0x0E, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x05, 0x75, 0x64, 0x20, 0x80, 0x02, 0xC1, 
+0xCF, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x64, 0xF0, 0x7F, 0x00, 0x22, 
+0xE4, 0x75, 0xF0, 0x01, 0x02, 0x02, 0xE7, 0xE4, 0x90, 0x90, 0xDF, 0xF0, 0xA3, 0xF0, 0x51, 0xBE, 
+0xEF, 0x64, 0x01, 0x60, 0x3B, 0xC3, 0x90, 0x90, 0xE0, 0xE0, 0x94, 0x88, 0x90, 0x90, 0xDF, 0xE0, 
+0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 
+0xF0, 0x80, 0x1D, 0x90, 0x90, 0xDF, 0x51, 0x60, 0x51, 0xB7, 0xD3, 0x90, 0x90, 0xE0, 0xE0, 0x94, 
+0x32, 0x90, 0x90, 0xDF, 0xE0, 0x94, 0x00, 0x40, 0xC5, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xBE, 
+0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 0x01, 
+0x9A, 0xE0, 0x54, 0xC0, 0x44, 0x0B, 0xF0, 0x7F, 0x0A, 0xD1, 0xE8, 0xE0, 0x54, 0xC0, 0x7F, 0x00, 
+0xB4, 0x40, 0x02, 0x7F, 0x01, 0x22, 0x90, 0x90, 0xA9, 0x12, 0xA4, 0x64, 0x30, 0xE0, 0x6C, 0x90, 
+0x90, 0x0A, 0xE0, 0x30, 0xE0, 0x65, 0x90, 0x90, 0xAD, 0x51, 0x60, 0x90, 0x90, 0xA9, 0xE0, 0x54, 
+0xBF, 0xF0, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 0x90, 0x4C, 0xE0, 0x24, 0xFB, 0x90, 0x8E, 0xF7, 
+0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x60, 0x7E, 0x01, 0x12, 0x5E, 0xAD, 0x12, 0x95, 0x4D, 0x12, 0xA7, 
+0xF2, 0x54, 0x07, 0x90, 0x91, 0x33, 0xF0, 0x90, 0x90, 0x72, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x30, 
+0xE0, 0x17, 0xEF, 0x54, 0xEF, 0xF0, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x20, 0xE0, 0x1D, 0x12, 0x95, 
+0x4D, 0x71, 0x4C, 0xEF, 0xD1, 0xDF, 0x02, 0x5E, 0xAD, 0x90, 0x91, 0x33, 0xE0, 0xFF, 0x64, 0x03, 
+0x60, 0x04, 0xEF, 0xB4, 0x01, 0x05, 0x71, 0xAF, 0x12, 0x95, 0x56, 0x22, 0x75, 0xF0, 0x13, 0xA4, 
+0x24, 0x39, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x24, 0xFC, 0xFF, 0xE4, 0x90, 0x8E, 
+0xF6, 0xF0, 0xA3, 0x22, 0x90, 0x8A, 0x79, 0xE0, 0xFF, 0x30, 0xE0, 0x41, 0x90, 0x8A, 0x7D, 0xE0, 
+0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x8A, 0x7C, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 
+0x7D, 0x01, 0xED, 0x4E, 0x70, 0x27, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x04, 0xD1, 0x30, 0x80, 0x1D, 
+0x12, 0xB4, 0xB7, 0x90, 0x8A, 0x7D, 0xE0, 0xB4, 0x0C, 0x06, 0xE4, 0xFD, 0x7F, 0x08, 0x80, 0x0A, 
+0x90, 0x8A, 0x7D, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0xAA, 0x73, 0x41, 0xD6, 0x90, 
+0x90, 0x0C, 0x74, 0x05, 0xF0, 0x22, 0x90, 0x90, 0x09, 0xE0, 0x30, 0xE0, 0x1F, 0xA3, 0xE0, 0xC3, 
+0x13, 0x54, 0x07, 0x71, 0xDD, 0xE0, 0xFE, 0x30, 0xE0, 0x12, 0xEF, 0x71, 0xDE, 0xEE, 0x54, 0xFE, 
+0xF0, 0x71, 0xAF, 0x12, 0x95, 0x4D, 0xFD, 0x7F, 0x02, 0x12, 0x92, 0x63, 0x22, 0xFF, 0x75, 0xF0, 
+0x0E, 0xA4, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 
+0xFF, 0x12, 0x8F, 0x33, 0x30, 0xE0, 0x1F, 0xEF, 0x54, 0x7F, 0xF1, 0x97, 0x30, 0xE1, 0x06, 0xE0, 
+0x44, 0x02, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFD, 0xF0, 0xF1, 0xB8, 0x04, 0xF0, 0x90, 0x8A, 0x83, 
+0xE0, 0x60, 0x03, 0x12, 0xB4, 0x7C, 0x90, 0x8A, 0xEE, 0x12, 0xAE, 0xC1, 0x30, 0xE0, 0x22, 0x90, 
+0x8A, 0xF1, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x18, 0xEF, 0x54, 0xFD, 0xF0, 0x90, 0x04, 0xE0, 
+0xE0, 0x90, 0x8A, 0xF1, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFB, 
+0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x30, 0xE1, 0x05, 0x71, 0xB6, 0x12, 0x96, 0xCD, 0x22, 0xC0, 0xE0, 
+0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 
+0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x4E, 
+0xF0, 0x74, 0xBC, 0xA3, 0xF0, 0x12, 0x74, 0xF9, 0xE5, 0x55, 0x30, 0xE1, 0x03, 0x12, 0xC6, 0x62, 
+0xE5, 0x55, 0x30, 0xE2, 0x02, 0xB1, 0x12, 0xE5, 0x55, 0x30, 0xE4, 0x03, 0x12, 0xCB, 0x0B, 0xE5, 
+0x55, 0x30, 0xE5, 0x03, 0x12, 0xB7, 0xD5, 0xE5, 0x56, 0x30, 0xE0, 0x02, 0xB1, 0x34, 0xE5, 0x57, 
+0x30, 0xE1, 0x02, 0x71, 0x64, 0xE5, 0x57, 0x30, 0xE0, 0x02, 0xB1, 0xAB, 0xE5, 0x57, 0x30, 0xE3, 
+0x03, 0x12, 0xCB, 0x1D, 0xE5, 0x57, 0x30, 0xE2, 0x0A, 0x12, 0xC6, 0x71, 0x90, 0x07, 0x8F, 0xE0, 
+0x44, 0x10, 0xF0, 0xE5, 0x58, 0x30, 0xE1, 0x05, 0x7F, 0x04, 0x12, 0xB6, 0xED, 0xE5, 0x58, 0x30, 
+0xE4, 0x03, 0x12, 0xB5, 0x5D, 0xE5, 0x58, 0x30, 0xE5, 0x03, 0x12, 0xAA, 0x3C, 0xE5, 0x58, 0x30, 
+0xE6, 0x02, 0x71, 0xEC, 0xE5, 0x58, 0x30, 0xE7, 0x03, 0x12, 0xC6, 0xAD, 0x74, 0x4E, 0x04, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0xBC, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 
+0xE0, 0x32, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x11, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x05, 0x12, 
+0x69, 0xD6, 0x80, 0x05, 0xD1, 0xD7, 0x12, 0xB4, 0x7C, 0x90, 0x90, 0x0C, 0xE0, 0xB4, 0x01, 0x03, 
+0x12, 0x95, 0x56, 0x22, 0xB1, 0x67, 0x90, 0x91, 0x33, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 
+0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xDB, 0x90, 0x91, 0x33, 0xE0, 0x30, 0xE6, 0x11, 
+0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 
+0xF0, 0x12, 0xD0, 0xE0, 0x02, 0x40, 0x55, 0xE4, 0x90, 0x91, 0x35, 0xF0, 0xA3, 0xF0, 0x7F, 0x83, 
+0x12, 0x7A, 0xB8, 0x90, 0x91, 0x34, 0xEF, 0xF0, 0x7F, 0x83, 0x12, 0x7A, 0xB8, 0xAE, 0x07, 0x90, 
+0x91, 0x34, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x91, 0x36, 0xE0, 0x94, 0x64, 0x90, 
+0x91, 0x35, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x91, 
+0x34, 0xE0, 0xFF, 0x22, 0x90, 0x91, 0x35, 0x51, 0x60, 0x80, 0xC3, 0x90, 0x8A, 0x79, 0xE0, 0xFF, 
+0x30, 0xE0, 0x40, 0x90, 0x8A, 0x7D, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x8A, 
+0x7C, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x26, 0xEF, 0xC3, 0x13, 
+0x30, 0xE0, 0x04, 0xD1, 0x30, 0x80, 0x1C, 0x12, 0xAF, 0x9C, 0x90, 0x8A, 0x7D, 0xE0, 0xB4, 0x08, 
+0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 0x90, 0x8A, 0x7D, 0xE0, 0x70, 0x06, 0xFD, 0x7F, 0x04, 
+0x12, 0xAA, 0x73, 0x90, 0x90, 0xA9, 0x12, 0xA4, 0x64, 0x30, 0xE0, 0x1D, 0x90, 0x90, 0x0A, 0xE0, 
+0xFF, 0x30, 0xE0, 0x15, 0xC3, 0x13, 0x54, 0x07, 0x12, 0xA7, 0xF2, 0x54, 0x07, 0xFE, 0xD1, 0x1A, 
+0xEE, 0x60, 0x03, 0xB4, 0x02, 0x03, 0x12, 0x95, 0x56, 0x22, 0x12, 0x96, 0xB7, 0xE0, 0x20, 0xE0, 
+0x07, 0xC3, 0x13, 0x30, 0xE0, 0x09, 0x61, 0xAF, 0x12, 0x96, 0xB7, 0xE0, 0x44, 0x04, 0xF0, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0xAE, 0xE4, 0xBF, 0x01, 0x04, 0x7F, 0x01, 0x80, 
+0x02, 0x7F, 0x02, 0x12, 0xAD, 0xA3, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 
+0xF0, 0x22, 0x12, 0x8A, 0x21, 0xF1, 0xCE, 0x7A, 0x8B, 0x79, 0x3D, 0x12, 0x68, 0xAB, 0x90, 0x8B, 
+0x3F, 0xD1, 0xC4, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x8B, 
+0x49, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x40, 0xD1, 0xC4, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 
+0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x8B, 0x4B, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 
+0x41, 0xD1, 0xC4, 0x90, 0x8B, 0x4D, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x3D, 0xE0, 0x30, 
+0xE0, 0x13, 0x90, 0x8B, 0x44, 0x74, 0x01, 0xF0, 0xA3, 0xF0, 0xA3, 0xD1, 0x4B, 0x90, 0x07, 0x83, 
+0xE0, 0x44, 0x20, 0xF0, 0x22, 0xE4, 0x90, 0x8B, 0x44, 0x12, 0x9D, 0x6F, 0x90, 0x07, 0x83, 0xE0, 
+0x54, 0xDF, 0xF0, 0x22, 0xE0, 0xFF, 0x7E, 0x00, 0x7C, 0x01, 0x7D, 0x40, 0x02, 0x02, 0x80, 0x90, 
+0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 0xF7, 0xF0, 0x22, 0xF0, 
+0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x22, 0x7E, 0x00, 0x12, 0x7B, 0x8D, 0x90, 0x01, 0x98, 
+0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x7A, 0xA5, 0xF1, 0x90, 0x12, 
+0xCA, 0x9F, 0x12, 0x7A, 0xCB, 0x12, 0xCA, 0xAC, 0xF1, 0xC2, 0x7F, 0x01, 0x12, 0x85, 0x15, 0x90, 
+0x90, 0x08, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x85, 0x15, 0x90, 0x90, 0x08, 0xE0, 0x04, 0xF0, 0x12, 
+0xC4, 0x05, 0x12, 0xC7, 0xD0, 0x90, 0x01, 0xCC, 0x74, 0x0F, 0xF0, 0x90, 0x00, 0x80, 0xE0, 0x44, 
+0x40, 0xFD, 0x7F, 0x80, 0x12, 0x7A, 0xA5, 0x75, 0x20, 0xFF, 0x12, 0x7B, 0xC2, 0xE4, 0xFF, 0x12, 
+0xC0, 0x3B, 0x51, 0x67, 0x90, 0x00, 0x81, 0xE0, 0x44, 0x04, 0xFD, 0x7F, 0x81, 0x12, 0x7A, 0xA5, 
+0xF1, 0xA0, 0x12, 0xC1, 0xE2, 0x90, 0x01, 0x94, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x01, 0x98, 0xE4, 
+0xF0, 0xA3, 0x74, 0x40, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x64, 0xD1, 
+0xE8, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0x88, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x90, 
+0x00, 0xAA, 0xE0, 0x44, 0x02, 0xF0, 0xA3, 0xE0, 0x44, 0x80, 0xF0, 0xE4, 0xFF, 0x02, 0x85, 0x9E, 
+0x90, 0x89, 0x64, 0x74, 0x80, 0xF0, 0x22, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8A, 0x7F, 0x22, 
+0x90, 0x01, 0xE4, 0x74, 0x04, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x7D, 0x21, 0x7F, 0xFF, 0x12, 0x96, 
+0xA5, 0x01, 0xB0, 0x12, 0xAF, 0xF0, 0x80, 0xF2, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 
+0xB8, 0x22, 0xE4, 0x90, 0x89, 0x7E, 0x12, 0x9D, 0x71, 0x90, 0x90, 0x01, 0xF0, 0x22, 0x8B, 0x1B, 
+0x8A, 0x1C, 0x89, 0x1D, 0x75, 0x1E, 0x05, 0x7B, 0x01, 0x22, 0x7F, 0x30, 0x7E, 0x08, 0x12, 0x6F, 
+0xC1, 0xED, 0x44, 0x80, 0xFD, 0x22, 0x12, 0x02, 0x06, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x90, 0x04, 
+0x12, 0xC0, 0x17, 0xF0, 0x12, 0x8F, 0x91, 0x90, 0x90, 0x05, 0x12, 0x8D, 0xBF, 0x90, 0x90, 0x06, 
+0xF0, 0x11, 0x0D, 0x90, 0x90, 0x04, 0xE0, 0x54, 0x01, 0xFF, 0x02, 0xA7, 0x96, 0x90, 0x90, 0x05, 
+0xE0, 0x14, 0x90, 0x90, 0x07, 0xF0, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 
+0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0x22, 0x12, 0x02, 0x06, 0xFF, 0x90, 0x90, 0xB3, 0xF0, 0xBF, 0x01, 
+0x09, 0x7F, 0x01, 0x11, 0x3B, 0xE4, 0x90, 0x90, 0xB3, 0xF0, 0x22, 0x90, 0x90, 0xDF, 0xEF, 0xF0, 
+0x31, 0xD0, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xEF, 0xE0, 
+0x90, 0x90, 0xF1, 0xF0, 0x31, 0xD0, 0x7F, 0xF5, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 
+0x90, 0x90, 0xEF, 0xE0, 0x90, 0x90, 0xF2, 0xF0, 0x31, 0xD0, 0x7F, 0xF6, 0x7E, 0x00, 0x12, 0x62, 
+0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xEF, 0xE0, 0x90, 0x90, 0xF3, 0xF0, 0x31, 0xD0, 0x7F, 0xF7, 
+0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xEF, 0xE0, 0x90, 0x90, 0xF4, 0xF0, 
+0x31, 0xD0, 0x7F, 0xF8, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xEF, 0xE0, 
+0x90, 0x90, 0xF5, 0xF0, 0x31, 0xD0, 0x51, 0x70, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xEF, 0xE0, 0x90, 
+0x90, 0xF6, 0xF0, 0x31, 0xD0, 0x31, 0xD7, 0x70, 0x52, 0x90, 0x90, 0xEF, 0xE0, 0x90, 0x90, 0xF7, 
+0xF0, 0x54, 0x07, 0x60, 0x08, 0x90, 0x90, 0xEF, 0xE0, 0x54, 0xE0, 0x70, 0x3E, 0x7B, 0x01, 0x7A, 
+0x90, 0x79, 0xF0, 0x7F, 0xFA, 0x31, 0xD9, 0x70, 0x32, 0x90, 0x90, 0xEF, 0xE0, 0xFC, 0x54, 0x07, 
+0x70, 0x12, 0x90, 0x90, 0xF7, 0xE0, 0xFE, 0x90, 0x90, 0xF0, 0xE0, 0x54, 0x07, 0xFD, 0xEE, 0x4D, 
+0x90, 0x90, 0xF7, 0xF0, 0xEC, 0x54, 0xE0, 0x70, 0x12, 0x90, 0x90, 0xF7, 0xE0, 0xFF, 0x90, 0x90, 
+0xF0, 0xE0, 0x54, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x90, 0xF7, 0xF0, 0x31, 0xD0, 0x7F, 0xFD, 0x31, 
+0xD9, 0x70, 0x47, 0x90, 0x90, 0xEF, 0xE0, 0xFE, 0x54, 0xCC, 0x90, 0x90, 0xF8, 0xF0, 0xEE, 0x54, 
+0x0C, 0xFF, 0x60, 0x08, 0x90, 0x90, 0xEF, 0xE0, 0x54, 0xC0, 0x70, 0x2E, 0xEF, 0x70, 0x12, 0x90, 
+0x90, 0xF8, 0xE0, 0xFF, 0x90, 0x90, 0xEF, 0xE0, 0x54, 0x03, 0x51, 0x78, 0x4E, 0x90, 0x90, 0xF8, 
+0xF0, 0x90, 0x90, 0xEF, 0xE0, 0xFF, 0x54, 0xC0, 0x70, 0x10, 0x90, 0x90, 0xF8, 0xE0, 0xFE, 0xEF, 
+0x54, 0x30, 0x25, 0xE0, 0x25, 0xE0, 0xFF, 0xEE, 0x4F, 0xF0, 0x90, 0x90, 0xE0, 0x74, 0x19, 0xF0, 
+0x90, 0x90, 0xEE, 0x74, 0x08, 0xF0, 0x90, 0x90, 0xF1, 0xE0, 0x90, 0x90, 0xE2, 0xF0, 0x90, 0x90, 
+0xF2, 0xE0, 0x90, 0x90, 0xE3, 0xF0, 0x90, 0x90, 0xF3, 0xE0, 0x90, 0x90, 0xE4, 0xF0, 0x90, 0x90, 
+0xF4, 0xE0, 0x90, 0x90, 0xE5, 0xF0, 0x90, 0x90, 0xF5, 0xE0, 0x90, 0x90, 0xE6, 0xF0, 0x90, 0x90, 
+0xF6, 0xE0, 0x90, 0x90, 0xE7, 0xF0, 0x90, 0x90, 0xF7, 0xE0, 0x90, 0x90, 0xE8, 0xF0, 0x90, 0x90, 
+0xF8, 0xE0, 0x90, 0x90, 0xE9, 0xF0, 0x90, 0x90, 0xDF, 0xE0, 0xB4, 0x01, 0x0E, 0x7B, 0x01, 0x7A, 
+0x90, 0x79, 0xE0, 0x12, 0x5A, 0x18, 0x7F, 0x04, 0x02, 0x87, 0x9E, 0x75, 0x1B, 0x01, 0x75, 0x1C, 
+0x90, 0x75, 0x1D, 0xE0, 0x75, 0x1E, 0x0A, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x02, 0x68, 0xAB, 
+0x7B, 0x01, 0x7A, 0x90, 0x79, 0xEF, 0x22, 0x7F, 0xFB, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xEF, 0x64, 
+0x01, 0x22, 0x7E, 0x00, 0x7F, 0x0B, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xB5, 0x12, 0x04, 
+0x7A, 0x51, 0x69, 0x51, 0x70, 0xBF, 0x01, 0x1C, 0x90, 0x90, 0xDF, 0xE0, 0xFE, 0x54, 0x01, 0x90, 
+0x90, 0xB5, 0xF0, 0xEE, 0x54, 0x04, 0x90, 0x90, 0xB7, 0xF0, 0x90, 0x90, 0xDF, 0xE0, 0x54, 0x08, 
+0x90, 0x90, 0xB6, 0xF0, 0x51, 0x69, 0x31, 0xD7, 0x70, 0x34, 0x90, 0x90, 0xDF, 0xE0, 0x54, 0x07, 
+0x70, 0x14, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xE0, 0x7F, 0xFA, 0xFE, 0x12, 0x62, 0xDB, 0xBF, 0x01, 
+0x0F, 0x90, 0x90, 0xE0, 0x80, 0x03, 0x90, 0x90, 0xDF, 0xE0, 0x54, 0x07, 0x90, 0x90, 0xB9, 0xF0, 
+0x90, 0x90, 0xDF, 0xE0, 0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x90, 0x90, 0xB8, 0xF0, 0x51, 0x69, 
+0x7F, 0xFD, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x0E, 0x90, 0x90, 0xDF, 0xE0, 0x54, 0x0C, 
+0x13, 0x13, 0x54, 0x3F, 0x90, 0x90, 0xBA, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xDF, 0x22, 
+0x7F, 0xF9, 0x7E, 0x00, 0x02, 0x62, 0xDB, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFE, 0xEF, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xED, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x8F, 
+0xEC, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x7A, 0x7E, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x8F, 0xEC, 
+0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x8F, 0xED, 0xE0, 0x60, 0x05, 0x71, 0x40, 0x44, 0x80, 0xF0, 
+0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0xF0, 
+0x71, 0x40, 0x54, 0xC0, 0xF0, 0x90, 0x8F, 0xEF, 0xE0, 0xFF, 0xAE, 0x05, 0x74, 0x18, 0x2E, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x71, 0x29, 0xE0, 0x54, 0x01, 0xFF, 0x90, 0x8F, 
+0xEE, 0x51, 0x77, 0x44, 0x02, 0x4E, 0xFF, 0xAE, 0x05, 0x71, 0x29, 0xEF, 0xF0, 0x74, 0x11, 0x2E, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2E, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF7, 0xF0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x0C, 0x71, 
+0x34, 0x44, 0x80, 0xF0, 0x90, 0x05, 0x12, 0xE4, 0xF0, 0x80, 0x05, 0x71, 0x34, 0x54, 0x7F, 0xF0, 
+0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x74, 0x12, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0x22, 0x74, 0x05, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 
+0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0x8F, 0xD5, 0xA3, 
+0xE0, 0xFF, 0x90, 0x8F, 0xEF, 0x74, 0x03, 0xF0, 0x7B, 0x06, 0x7D, 0x01, 0x51, 0x7F, 0x90, 0x8F, 
+0xD9, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x8F, 0xD8, 0xE0, 0xFF, 0x74, 0x10, 0x2D, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x8F, 0xD7, 0xE0, 0xFF, 0x02, 0x56, 
+0x8E, 0xE4, 0xFD, 0x02, 0x97, 0xF7, 0xE4, 0xF5, 0x3F, 0xF5, 0x40, 0xF5, 0x41, 0x75, 0x42, 0x80, 
+0xAD, 0x3F, 0x7F, 0x50, 0x12, 0x7A, 0xA5, 0xAD, 0x40, 0x7F, 0x51, 0x12, 0x7A, 0xA5, 0xAD, 0x41, 
+0x7F, 0x52, 0x12, 0x7A, 0xA5, 0xAD, 0x42, 0x7F, 0x53, 0x02, 0x7A, 0xA5, 0x12, 0x75, 0x87, 0x12, 
+0x75, 0x29, 0x71, 0xB8, 0x71, 0xDD, 0x80, 0xCE, 0x75, 0x47, 0x12, 0xE4, 0xF5, 0x48, 0x75, 0x49, 
+0x07, 0x75, 0x4A, 0x32, 0x90, 0x01, 0x30, 0xE5, 0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0xA3, 0xE5, 
+0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0x90, 0x01, 0x20, 0xE5, 0x4F, 0xF0, 0x22, 0x75, 0x51, 0x06, 
+0x43, 0x51, 0x10, 0x75, 0x52, 0x01, 0x75, 0x53, 0x03, 0x75, 0x54, 0x62, 0x43, 0x54, 0x80, 0x43, 
+0x53, 0x04, 0x90, 0x01, 0x38, 0xE5, 0x51, 0xF0, 0xA3, 0xE5, 0x52, 0xF0, 0xA3, 0xE5, 0x53, 0xF0, 
+0xA3, 0xE5, 0x54, 0xF0, 0x22, 0x12, 0x7A, 0x92, 0x90, 0x89, 0x82, 0xEF, 0xF0, 0x71, 0xAC, 0x90, 
+0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x04, 0x23, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x00, 0x17, 0xE0, 
+0x54, 0xFC, 0x44, 0x04, 0xFD, 0x7F, 0x17, 0x12, 0x7A, 0xA5, 0x90, 0x00, 0x38, 0xE0, 0x44, 0x40, 
+0xFD, 0x7F, 0x38, 0x12, 0x7A, 0xA5, 0x02, 0x67, 0x21, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0x39, 
+0xF0, 0x74, 0xC4, 0xA3, 0xF0, 0x90, 0x90, 0x08, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x18, 0xED, 
+0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x0B, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0xA3, 
+0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xDE, 0x74, 0x39, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xC4, 
+0xA3, 0xF0, 0x7F, 0x01, 0x22, 0xE4, 0x90, 0x90, 0xF9, 0xF0, 0x90, 0x90, 0xF9, 0xE0, 0x64, 0x01, 
+0xF0, 0x24, 0x75, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xC4, 0xA3, 0xF0, 0x12, 0x7B, 0x6C, 0xBF, 0x01, 
+0x03, 0x12, 0x58, 0x9B, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0F, 0x90, 0x8A, 0x86, 0xE0, 0xFF, 0x90, 
+0x8A, 0x85, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0xB4, 0x7C, 0xC2, 0xAF, 0x91, 0x39, 0xBF, 0x01, 0x03, 
+0x12, 0xB9, 0x5B, 0xD2, 0xAF, 0x91, 0xBF, 0x12, 0x8F, 0xF7, 0x12, 0x84, 0x4D, 0x80, 0xBB, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x90, 0xBB, 0xE0, 0x60, 0x25, 0x7F, 0x54, 0x7E, 0x09, 
+0x12, 0x6F, 0xC1, 0xB1, 0x17, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0xFE, 0xFF, 0xEE, 0x44, 0x03, 0xFE, 
+0xED, 0x44, 0x04, 0xFD, 0xEC, 0xB1, 0x17, 0x12, 0xA5, 0x89, 0x7F, 0x54, 0x7E, 0x09, 0x12, 0x6F, 
+0xFE, 0x90, 0x90, 0xB6, 0xE0, 0x70, 0x04, 0x90, 0x07, 0xCC, 0xF0, 0x90, 0x90, 0xBE, 0xE0, 0x70, 
+0x0A, 0x90, 0x90, 0xBB, 0xE0, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0x07, 0x90, 0x00, 0x1F, 0xE0, 0x54, 
+0xF0, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 0xFA, 0x12, 0x04, 0x31, 0x90, 0x90, 0xFA, 
+0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x86, 0x4E, 0x90, 0x90, 0xFE, 0xEF, 0xF0, 0x60, 
+0xF0, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 
+0xE0, 0x0F, 0x90, 0x89, 0x7E, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 0x12, 0x37, 0x43, 0x12, 0x98, 
+0xD5, 0xB1, 0x76, 0x30, 0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0x5D, 0x58, 0xB1, 0x76, 0x30, 0xE2, 
+0x06, 0x54, 0xFB, 0xF0, 0x12, 0x61, 0xA6, 0xB1, 0x76, 0x30, 0xE6, 0x06, 0x54, 0xBF, 0xF0, 0x12, 
+0x6D, 0xBF, 0xD2, 0xAF, 0x80, 0xBB, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 0x22, 
+0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0x81, 0xF0, 0x74, 0xC5, 0xA3, 0xF0, 0x12, 0x6B, 0x8E, 0x74, 0x81, 0x04, 0x90, 0x01, 
+0xC4, 0xF0, 0x74, 0xC5, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 
+0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 
+0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0xD1, 0xF0, 0x74, 0xC5, 0xA3, 0xF0, 0x12, 0x0F, 0x2F, 0x53, 0x91, 0xBF, 0x74, 0xD1, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xC5, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0xC0, 0xE0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 
+0x05, 0xC0, 0x07, 0x7D, 0x24, 0x90, 0x01, 0xC4, 0xED, 0xF0, 0x74, 0xC6, 0xFF, 0xA3, 0xF0, 0xED, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0xA3, 0xEF, 0xF0, 0xD0, 0x07, 0xD0, 0x05, 0xD0, 0xD0, 0xD0, 0x82, 
+0xD0, 0x83, 0xD0, 0xE0, 0x32, 0x90, 0x8A, 0x79, 0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 
+0xF0, 0x22, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x03, 0x12, 0xB4, 0x21, 0x12, 0x97, 0x96, 0x02, 0x95, 
+0x56, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8B, 0x3D, 0xE0, 0x30, 0xE0, 0x29, 0x90, 
+0x8B, 0x44, 0xE0, 0xB4, 0x01, 0x15, 0xA3, 0xE0, 0xB4, 0x01, 0x1D, 0x74, 0x02, 0xF0, 0x90, 0x8B, 
+0x4B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x72, 0x10, 0x80, 0x0D, 0x90, 0x8B, 0x44, 0xE0, 0xB4, 
+0x02, 0x06, 0x74, 0x03, 0xF0, 0x12, 0x53, 0x4D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8B, 0x05, 
+0xE0, 0x30, 0xE0, 0x05, 0x12, 0x78, 0x11, 0x80, 0x03, 0x12, 0x69, 0x8C, 0x90, 0x8B, 0x3D, 0xE0, 
+0x30, 0xE0, 0x03, 0x12, 0x53, 0x4D, 0x22, 0x7D, 0x07, 0xAF, 0x65, 0xED, 0x30, 0xE0, 0x22, 0x75, 
+0xF0, 0x12, 0xEF, 0x90, 0x8B, 0xA4, 0xF1, 0x18, 0x90, 0x8B, 0xA6, 0xF1, 0x18, 0x90, 0x8B, 0xA8, 
+0xF1, 0x18, 0x90, 0x8B, 0xAA, 0xF1, 0x18, 0x90, 0x8B, 0xAC, 0x12, 0x04, 0x6E, 0xE4, 0xF0, 0xA3, 
+0xF0, 0xED, 0x30, 0xE1, 0x0A, 0x75, 0xF0, 0x12, 0xEF, 0xF1, 0x42, 0xE4, 0xF0, 0xA3, 0xF0, 0xED, 
+0x30, 0xE2, 0x08, 0x75, 0xF0, 0x12, 0xEF, 0xF1, 0x37, 0xE4, 0xF0, 0xF1, 0x24, 0xE0, 0x54, 0xBF, 
+0x44, 0x80, 0xFE, 0xF1, 0x24, 0xEE, 0xF0, 0x22, 0x12, 0x04, 0x6E, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 
+0xF0, 0x12, 0xEF, 0x22, 0xEF, 0xC4, 0x54, 0xF0, 0x24, 0x03, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 
+0x83, 0x22, 0x75, 0xF0, 0x12, 0xE5, 0x65, 0x90, 0x8B, 0xA2, 0x02, 0x04, 0x6E, 0x75, 0xF0, 0x12, 
+0xE5, 0x65, 0x90, 0x8B, 0xA0, 0x02, 0x04, 0x6E, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x90, 0x8B, 
+0x7B, 0x12, 0x87, 0x5F, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0x80, 0x90, 0x8B, 0x7E, 0x12, 0x87, 0x5F, 
+0x7A, 0x81, 0x79, 0xBF, 0x90, 0x8B, 0x81, 0x12, 0x87, 0x5F, 0x7A, 0x82, 0x79, 0x61, 0x90, 0x8B, 
+0x87, 0x12, 0x87, 0x5F, 0x7A, 0x82, 0x79, 0x75, 0x90, 0x8B, 0x8A, 0x12, 0x87, 0x5F, 0x7A, 0x82, 
+0x79, 0x9D, 0x90, 0x8B, 0x8D, 0x12, 0x87, 0x5F, 0xF1, 0xC6, 0x7A, 0x82, 0x79, 0xD9, 0x90, 0x8B, 
+0x96, 0x12, 0x87, 0x5F, 0x7A, 0x83, 0x79, 0x01, 0x90, 0x8B, 0x99, 0x12, 0x87, 0x5F, 0xE4, 0x90, 
+0x8F, 0x81, 0xF0, 0x90, 0x90, 0xDF, 0xF0, 0x90, 0x90, 0xDF, 0xE0, 0xFF, 0xC3, 0x94, 0x05, 0x50, 
+0x14, 0x74, 0x92, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0xE4, 0xF0, 0x90, 0x90, 0xDF, 
+0xE0, 0x04, 0xF0, 0x80, 0xE2, 0x22, 0x7A, 0x82, 0x79, 0xB1, 0x90, 0x8B, 0x93, 0x02, 0x87, 0x5F, 
+0x12, 0xCC, 0xBD, 0x12, 0x7B, 0x0E, 0x12, 0x3C, 0x0A, 0xF1, 0x48, 0x12, 0xCC, 0xC3, 0x12, 0xCD, 
+0x81, 0x12, 0xCE, 0x67, 0x12, 0xCA, 0x06, 0x02, 0x47, 0xFC, 0xE4, 0xF5, 0x78, 0xEF, 0x14, 0xF5, 
+0x77, 0xED, 0xFF, 0xE5, 0x77, 0xF5, 0x82, 0x33, 0x95, 0xE0, 0xF5, 0x83, 0xC3, 0xE5, 0x82, 0x9F, 
+0x74, 0x80, 0xF8, 0x65, 0x83, 0x98, 0x40, 0x51, 0xE5, 0x77, 0x78, 0x03, 0xA2, 0xE7, 0x13, 0xD8, 
+0xFB, 0xFF, 0x33, 0x95, 0xE0, 0xFE, 0xEB, 0x12, 0x8F, 0xE9, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE5, 
+0x83, 0x3E, 0xF5, 0x83, 0xE0, 0xF5, 0x82, 0x75, 0x83, 0x00, 0xE5, 0x77, 0x11, 0x70, 0x80, 0x05, 
+0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x55, 0x83, 0xFE, 0xEF, 0x55, 0x82, 0x4E, 
+0x60, 0x13, 0x85, 0x77, 0x79, 0x05, 0x78, 0x90, 0x91, 0x0A, 0xE0, 0x65, 0x78, 0x60, 0x0A, 0xE5, 
+0x79, 0xD3, 0x9D, 0x40, 0x04, 0x15, 0x77, 0x80, 0x98, 0xAF, 0x79, 0x22, 0x13, 0x13, 0x13, 0x54, 
+0x1F, 0x24, 0xDC, 0xF5, 0x82, 0xE4, 0x34, 0x8C, 0xF5, 0x83, 0xE0, 0xFD, 0x7C, 0x00, 0xE5, 0x65, 
+0x54, 0x07, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x7D, 0x01, 0xAF, 0x65, 0xAC, 
+0x05, 0x90, 0x91, 0x05, 0xEF, 0xF0, 0xFD, 0xE0, 0xFF, 0x12, 0x98, 0xC8, 0xE0, 0xF5, 0x73, 0x54, 
+0x7F, 0xF5, 0x75, 0x75, 0xF0, 0x12, 0xEF, 0x90, 0x8B, 0x9D, 0x12, 0x04, 0x6E, 0xE0, 0xF9, 0x90, 
+0x91, 0x05, 0xE0, 0x12, 0x9F, 0xF3, 0xFE, 0xEF, 0x12, 0x98, 0x31, 0xE0, 0x54, 0x03, 0xF5, 0x74, 
+0xE5, 0x75, 0x90, 0x82, 0x9D, 0x93, 0xFB, 0xED, 0x12, 0x9F, 0xC7, 0xE4, 0xF0, 0xA3, 0xEB, 0xF0, 
+0x12, 0x8D, 0xC7, 0xC4, 0x54, 0x03, 0x90, 0x91, 0x06, 0xF0, 0x74, 0x33, 0x2D, 0x31, 0x55, 0xE5, 
+0x75, 0xF0, 0x74, 0xB3, 0x2D, 0x31, 0x65, 0xE5, 0x74, 0xF0, 0xE5, 0x75, 0xD3, 0x9E, 0x40, 0x06, 
+0x8E, 0x75, 0xAF, 0x06, 0x8F, 0x73, 0x8C, 0x76, 0xE4, 0xFF, 0xEF, 0xC3, 0x95, 0x76, 0x50, 0x30, 
+0xE5, 0x73, 0x30, 0xE7, 0x09, 0x85, 0x75, 0x73, 0x1C, 0xEC, 0x70, 0x21, 0x80, 0x22, 0xE5, 0x75, 
+0xD3, 0x99, 0x40, 0x15, 0xAD, 0x01, 0x90, 0x91, 0x05, 0xE0, 0xFB, 0x90, 0x91, 0x0A, 0xEC, 0xF0, 
+0xAF, 0x75, 0x12, 0xC7, 0xEA, 0x8F, 0x73, 0x80, 0x07, 0x89, 0x73, 0x80, 0x03, 0x0F, 0x80, 0xCA, 
+0x90, 0x91, 0x05, 0xE0, 0xFF, 0x12, 0x9F, 0x99, 0xEF, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0xE5, 0x73, 
+0x31, 0x5D, 0x12, 0xBE, 0x4B, 0x7B, 0x01, 0xFA, 0x7D, 0x05, 0x7F, 0x08, 0x12, 0x9E, 0xE4, 0x90, 
+0x91, 0x05, 0xE0, 0xFF, 0x90, 0x8E, 0xA6, 0xE5, 0x74, 0xF0, 0xE4, 0xFB, 0xAD, 0x73, 0x02, 0x23, 
+0x3F, 0x74, 0x33, 0x25, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0x22, 0xF0, 0xA3, 0xE4, 
+0xF0, 0xA3, 0xE5, 0x74, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0xEF, 0x64, 0x13, 
+0x60, 0x04, 0xEF, 0xB4, 0x0B, 0x05, 0x90, 0x8B, 0x30, 0x80, 0x1F, 0xEF, 0x64, 0x12, 0x60, 0x04, 
+0xEF, 0xB4, 0x0A, 0x05, 0x90, 0x8B, 0x31, 0x80, 0x11, 0xEF, 0x64, 0x11, 0x60, 0x04, 0xEF, 0xB4, 
+0x09, 0x05, 0x90, 0x8B, 0x32, 0x80, 0x03, 0x90, 0x8B, 0x2F, 0xE0, 0xF5, 0x7F, 0xAF, 0x7F, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x50, 0xEF, 0xF0, 0x7F, 0x8F, 0x12, 0x7A, 
+0xB8, 0xEF, 0x30, 0xE6, 0x3D, 0x7F, 0x8D, 0x12, 0x7A, 0xB8, 0xEF, 0x64, 0x01, 0x70, 0x33, 0x90, 
+0x91, 0x51, 0xF0, 0x90, 0x91, 0x51, 0xE0, 0xFD, 0x90, 0x91, 0x50, 0xE0, 0x12, 0x98, 0xC8, 0xE5, 
+0x82, 0x2D, 0x31, 0xFE, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x8E, 0xFD, 0x90, 0x91, 0x51, 0xE0, 0x04, 
+0xF0, 0xE0, 0xC3, 0x94, 0x10, 0x40, 0xDC, 0x7F, 0x8F, 0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE0, 0x02, 
+0x31, 0xF7, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFD, 0x7F, 0x8D, 0x02, 0x7A, 0xA5, 0xF5, 0x82, 
+0xE4, 0x35, 0x83, 0xF5, 0x83, 0x22, 0x7E, 0x00, 0x7F, 0xAA, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x90, 
+0x79, 0x09, 0x02, 0x04, 0x7A, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xF8, 0xED, 
+0xF0, 0x90, 0x8F, 0xF7, 0xEF, 0xF0, 0x64, 0x02, 0x70, 0x24, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x8F, 
+0xF9, 0xF0, 0x7D, 0x4A, 0x51, 0x97, 0xBF, 0x01, 0x07, 0x90, 0x04, 0xD4, 0x74, 0xFF, 0x80, 0x4D, 
+0x90, 0x8F, 0xF9, 0xE0, 0xFF, 0x7D, 0x46, 0x12, 0x96, 0xA5, 0x7F, 0x00, 0x80, 0x44, 0x90, 0x8F, 
+0xF7, 0xE0, 0x64, 0x01, 0x70, 0x33, 0xFD, 0xFF, 0x12, 0x96, 0xA5, 0x90, 0x8F, 0xF8, 0xE0, 0xFF, 
+0x75, 0xF0, 0x13, 0xA4, 0x24, 0x3C, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xF4, 0x90, 
+0x04, 0xD4, 0xF0, 0xEF, 0x75, 0xF0, 0x13, 0xA4, 0x24, 0x3D, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 
+0x83, 0xE0, 0xF4, 0x90, 0x04, 0xD5, 0xF0, 0x80, 0x07, 0x90, 0x04, 0xD4, 0xE4, 0xF0, 0xA3, 0xF0, 
+0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x6F, 0x12, 0x96, 0xA5, 0x02, 0xA4, 0x03, 0x90, 
+0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 
+0x44, 0x04, 0xF0, 0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0xF0, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x7B, 
+0x8D, 0x90, 0x01, 0x99, 0xE0, 0x44, 0xC0, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x80, 0xF0, 0x22, 0x90, 
+0x01, 0xCF, 0xE0, 0x90, 0x91, 0x22, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 
+0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 
+0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x75, 0x87, 0x90, 0x00, 0x03, 0xE0, 
+0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x7A, 0xA5, 0x80, 0xFE, 0x22, 0x12, 0x3D, 0x30, 0x90, 0x90, 
+0x0A, 0xE0, 0x30, 0xE0, 0x07, 0x90, 0x90, 0xA9, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x90, 0x90, 0x0A, 
+0xE0, 0x30, 0xE0, 0x12, 0x90, 0x90, 0xA8, 0xE0, 0x12, 0x8F, 0x33, 0x30, 0xE0, 0x08, 0xA3, 0xE0, 
+0x44, 0x20, 0xF0, 0x44, 0x40, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFE, 
+0xFD, 0xEF, 0xB4, 0x01, 0x0D, 0xEB, 0xB4, 0x02, 0x03, 0x0D, 0x80, 0x06, 0xEB, 0xB4, 0x01, 0x02, 
+0x7D, 0x02, 0xAF, 0x06, 0xEF, 0xC4, 0x54, 0xF0, 0x4D, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
+0x01, 0xC4, 0x74, 0x5F, 0xF0, 0x74, 0xCB, 0xA3, 0xF0, 0x7F, 0x90, 0x12, 0x7A, 0xB8, 0xEF, 0x20, 
+0xE0, 0xF7, 0x74, 0x5F, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xCB, 0xA3, 0xF0, 0x22, 0x90, 0x91, 
+0x42, 0xEF, 0xF0, 0x22, 0x90, 0x91, 0x43, 0xEF, 0xF0, 0x90, 0x8B, 0x2D, 0xE0, 0x70, 0x51, 0x7F, 
+0x48, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xEE, 0x54, 0x0F, 0xFE, 0xE4, 0xFD, 0xFC, 0x90, 0x91, 0x44, 
+0x12, 0x04, 0x31, 0xE4, 0x7F, 0x80, 0x91, 0x59, 0x70, 0x05, 0x90, 0x8B, 0x0B, 0x80, 0x1B, 0xE4, 
+0xFF, 0xFE, 0x91, 0x5B, 0x70, 0x0A, 0x90, 0x8B, 0x0B, 0x04, 0xF0, 0xE4, 0xA3, 0xF0, 0x80, 0x4D, 
+0xE4, 0xFF, 0x91, 0x59, 0x70, 0x09, 0x90, 0x8B, 0x0B, 0x04, 0xF0, 0xA3, 0xF0, 0x80, 0x3E, 0xE4, 
+0x7F, 0x80, 0xFE, 0x91, 0x5B, 0x70, 0x36, 0x90, 0x8B, 0x0B, 0xF0, 0xA3, 0x04, 0xF0, 0x80, 0x2D, 
+0x12, 0xA7, 0x13, 0xEF, 0x54, 0x02, 0x91, 0x6E, 0x60, 0x08, 0x90, 0x8B, 0x0B, 0x74, 0x01, 0xF0, 
+0x80, 0x05, 0xE4, 0x90, 0x8B, 0x0B, 0xF0, 0x91, 0x84, 0xEF, 0x54, 0x01, 0x91, 0x6E, 0x60, 0x07, 
+0xE4, 0x90, 0x8B, 0x0C, 0xF0, 0x80, 0x06, 0x90, 0x8B, 0x0C, 0x74, 0x01, 0xF0, 0x90, 0x8B, 0x05, 
+0xE0, 0x44, 0x01, 0xF0, 0x7D, 0x11, 0x7F, 0xFF, 0x12, 0x96, 0xA5, 0x12, 0xA5, 0x92, 0x90, 0x07, 
+0x78, 0xE0, 0x90, 0x8B, 0x0A, 0xF0, 0x90, 0x8B, 0x2C, 0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0xA4, 0x70, 
+0x90, 0x91, 0x43, 0xE0, 0xFD, 0x70, 0x02, 0x80, 0x1C, 0xED, 0xB4, 0x01, 0x06, 0x91, 0x67, 0x44, 
+0x20, 0xF0, 0x22, 0x90, 0x91, 0x43, 0xE0, 0xFD, 0xB4, 0x02, 0x06, 0x91, 0x67, 0x44, 0x60, 0xF0, 
+0x22, 0xED, 0xB4, 0x03, 0x03, 0x91, 0x67, 0xF0, 0x22, 0x7E, 0x02, 0xFD, 0xFC, 0x90, 0x91, 0x44, 
+0x12, 0x87, 0x4A, 0xC3, 0x02, 0x03, 0xDA, 0x90, 0x8B, 0x05, 0xE0, 0x54, 0x1F, 0x22, 0xFF, 0xE4, 
+0xFE, 0xFD, 0xFC, 0x90, 0x91, 0x44, 0x12, 0x04, 0x31, 0x90, 0x91, 0x44, 0x12, 0x04, 0xB2, 0xEC, 
+0x4D, 0x4E, 0x4F, 0x22, 0x7F, 0x30, 0x7E, 0x09, 0x02, 0x6F, 0xC1, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x91, 0xAE, 0xE0, 0x90, 0x91, 0x48, 0xF0, 0xED, 0x90, 0x00, 0x73, 0x70, 0x06, 0xE0, 
+0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x89, 
+0x7C, 0xA3, 0xE0, 0x24, 0x7F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0xE4, 0xFD, 0xFF, 
+0x02, 0x6E, 0x43, 0x7E, 0x00, 0x7F, 0x01, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0x79, 0x12, 
+0x04, 0x7A, 0x90, 0x8A, 0x79, 0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0x12, 0x9D, 0x72, 0xA3, 0x74, 0x0C, 
+0xF0, 0x22, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0xE4, 0x90, 0x8A, 0x7C, 0xF0, 0x22, 0xB1, 
+0x05, 0x80, 0xEF, 0xB1, 0x12, 0x80, 0xEB, 0x91, 0xFB, 0x80, 0xE7, 0x12, 0x97, 0xEB, 0x90, 0x8A, 
+0x7C, 0x74, 0x01, 0xF0, 0x22, 0x12, 0x97, 0xEB, 0x12, 0xB8, 0xD1, 0x90, 0x8A, 0x7C, 0x74, 0x01, 
+0xF0, 0x22, 0x12, 0xB8, 0x26, 0x12, 0x97, 0xEB, 0x90, 0x8A, 0x7C, 0x74, 0x01, 0xF0, 0x22, 0x90, 
+0x8A, 0x7C, 0xE0, 0x64, 0x02, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xAE, 0x07, 0x12, 0xAE, 
+0xE4, 0xBF, 0x01, 0x13, 0x90, 0x8A, 0x79, 0x12, 0xA4, 0x64, 0x20, 0xE0, 0x0A, 0xAF, 0x06, 0x7D, 
+0x01, 0x12, 0xAA, 0x73, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x12, 0x79, 0x80, 0xEF, 0x70, 0x02, 
+0xB1, 0x53, 0x22, 0x90, 0x8A, 0xEA, 0xE0, 0x20, 0xE0, 0x26, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x01, 
+0x70, 0x1E, 0x12, 0x70, 0x76, 0x12, 0xB1, 0xD3, 0x60, 0x0D, 0xE4, 0xFD, 0x7F, 0x0C, 0x12, 0xAA, 
+0x73, 0x12, 0x97, 0xEB, 0x02, 0x69, 0xD6, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x03, 0x12, 0xAA, 0x6F, 
+0x22, 0x7E, 0x00, 0x7F, 0x62, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0x7E, 0x12, 0x04, 0x7A, 
+0xD1, 0x5C, 0x79, 0x04, 0x12, 0x04, 0x7A, 0x90, 0x8A, 0x82, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0x89, 
+0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0x90, 0x8A, 0x8F, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 
+0xD1, 0x45, 0xD1, 0x6E, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xDB, 0x7D, 0x0C, 0x7F, 0x02, 0x12, 0x53, 
+0xDB, 0x7D, 0x0C, 0x7F, 0x01, 0x12, 0x53, 0xDB, 0x90, 0x89, 0x82, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 
+0x90, 0x8A, 0x8E, 0x74, 0xDD, 0xF0, 0x80, 0x0F, 0xEF, 0x90, 0x8A, 0x8E, 0xB4, 0x03, 0x05, 0x74, 
+0xD4, 0xF0, 0x80, 0x03, 0x74, 0x40, 0xF0, 0x7F, 0x79, 0x12, 0x7A, 0xB8, 0xEF, 0x54, 0x03, 0xFF, 
+0xBF, 0x02, 0x0F, 0x7F, 0x28, 0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE2, 0x06, 0x90, 0x8A, 0xA0, 0x74, 
+0x02, 0xF0, 0x90, 0x8A, 0xE0, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 
+0x44, 0x28, 0xF0, 0xA3, 0x74, 0x07, 0xD1, 0x45, 0x7F, 0x01, 0x12, 0x6F, 0x83, 0xD1, 0x55, 0x7E, 
+0x00, 0xFF, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0xE7, 0x12, 0x04, 0x7A, 0x90, 0x06, 0x04, 
+0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x90, 0x05, 0x22, 0xE4, 0xF0, 
+0x90, 0x8A, 0xE9, 0xF0, 0x22, 0xF0, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x04, 0x90, 0x8A, 0x9B, 0xF0, 
+0xA3, 0x74, 0x0A, 0xF0, 0x22, 0x90, 0x05, 0x58, 0x74, 0x02, 0xF0, 0x22, 0x7E, 0x00, 0x7F, 0x04, 
+0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x90, 0x22, 0xD1, 0x5C, 0x79, 0x04, 0x02, 0x04, 0x7A, 0x90, 0x8A, 
+0xDA, 0x74, 0x04, 0xF0, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0x64, 0xF0, 0xA3, 
+0x74, 0x05, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 0xEA, 
+0xE0, 0x30, 0xE0, 0x1E, 0x90, 0x8A, 0xFC, 0xE0, 0x60, 0x05, 0x75, 0x10, 0x40, 0xE1, 0x30, 0x90, 
+0x8A, 0x85, 0xE0, 0xD3, 0x94, 0x00, 0x40, 0x02, 0x80, 0x2D, 0x90, 0x8A, 0xE9, 0xE0, 0x60, 0x7B, 
+0x80, 0x55, 0x12, 0x79, 0x80, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x75, 0x10, 0x01, 0x80, 0x71, 0x90, 
+0x8A, 0x87, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x05, 0x75, 0x10, 0x02, 0x80, 0x63, 0x90, 0x8A, 0x85, 
+0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x05, 0x75, 0x10, 0x04, 0x80, 0x54, 0xEF, 0x30, 0xE2, 0x05, 
+0x75, 0x10, 0x08, 0x80, 0x4B, 0x90, 0x8A, 0x87, 0xE0, 0x30, 0xE4, 0x05, 0x75, 0x10, 0x10, 0x80, 
+0x3F, 0x90, 0x8A, 0x7F, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x05, 0x75, 0x10, 0x20, 0x80, 
+0x2F, 0x90, 0x8A, 0xE9, 0xE0, 0x60, 0x05, 0x75, 0x10, 0x80, 0x80, 0x24, 0x90, 0x06, 0x62, 0xE0, 
+0x30, 0xE1, 0x05, 0x75, 0x10, 0x11, 0x80, 0x18, 0x90, 0x06, 0x62, 0xE0, 0x30, 0xE0, 0x0C, 0xE0, 
+0x54, 0xFC, 0xFF, 0xBF, 0x80, 0x05, 0x75, 0x10, 0x12, 0x80, 0x05, 0x12, 0xBE, 0xCF, 0x80, 0x0E, 
+0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x10, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xAC, 0x07, 0x90, 0x8A, 0x7F, 0xE0, 0x12, 0x8F, 0x33, 0x30, 0xE0, 0x02, 0xE1, 
+0xF7, 0x90, 0x8A, 0x7E, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x04, 0x90, 0x8A, 
+0x98, 0xF0, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x03, 0x90, 0x8A, 0x97, 0xF0, 0x80, 0x0D, 0x90, 0x8A, 
+0x98, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0x97, 0x14, 0xF0, 0x0B, 0x0B, 0x90, 0x8A, 0x97, 0xE0, 0xFA, 
+0x90, 0x8A, 0x96, 0xE0, 0xD3, 0x9A, 0x50, 0x0D, 0x90, 0x8A, 0x8B, 0xEB, 0xF0, 0x90, 0x8A, 0x98, 
+0xE0, 0xC3, 0x9D, 0x80, 0x11, 0xC3, 0xED, 0x9A, 0x2B, 0x90, 0x8A, 0x8B, 0xF0, 0x90, 0x8A, 0x97, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x2C, 0x90, 0x8A, 0x9B, 0xF0, 0x90, 0x8A, 0x98, 0xE0, 0xFF, 
+0x24, 0x0A, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x8A, 0x9B, 0x12, 0xD0, 0xD5, 0x40, 0x04, 0xEF, 0x24, 
+0x0A, 0xF0, 0x90, 0x8A, 0x9B, 0xE0, 0xFF, 0x24, 0x23, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x8A, 0x8B, 
+0x12, 0xD0, 0xD5, 0x40, 0x04, 0xEF, 0x24, 0x23, 0xF0, 0x90, 0x8A, 0x9B, 0xE0, 0xFF, 0x7E, 0x00, 
+0x90, 0x8A, 0x8F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xE0, 0x6F, 0x70, 0x01, 0xE4, 
+0x60, 0x03, 0x12, 0xD0, 0x07, 0x80, 0x08, 0x90, 0x8A, 0x80, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 
+0x8A, 0x80, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x8A, 0x8F, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 
+0x22, 0x90, 0x05, 0x63, 0xE0, 0x90, 0x8A, 0xD6, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0x90, 0x8A, 0xD7, 
+0xF0, 0x90, 0x05, 0x61, 0xE0, 0x90, 0x8A, 0xD8, 0xF0, 0x90, 0x05, 0x60, 0xE0, 0x90, 0x8A, 0xD9, 
+0xF0, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x80, 0xF0, 0x22, 0x90, 0x90, 0x0A, 0xE0, 0xFF, 0xC3, 0x13, 
+0xFE, 0xEF, 0x54, 0xF1, 0xFF, 0xEE, 0x04, 0x54, 0x07, 0x25, 0xE0, 0x4F, 0xF0, 0xA3, 0xE0, 0xFF, 
+0x90, 0x90, 0x0A, 0xE0, 0xFE, 0xC3, 0x13, 0x54, 0x07, 0x22, 0xEB, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 
+0x11, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0xFD, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x0D, 
+0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x0F, 0xF5, 0x82, 
+0xE4, 0x34, 0x90, 0xF5, 0x83, 0x22, 0x74, 0x23, 0x25, 0x7E, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 
+0x83, 0xE0, 0x22, 0x90, 0x90, 0xFF, 0x12, 0x87, 0x56, 0x90, 0x00, 0x08, 0x02, 0x03, 0x3E, 0x12, 
+0x03, 0xFE, 0x90, 0x8F, 0xB0, 0x02, 0x04, 0x31, 0x90, 0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 
+0xFF, 0x12, 0x7B, 0x97, 0x43, 0x60, 0x08, 0x22, 0xE0, 0x54, 0x03, 0x90, 0x8E, 0xA6, 0xF0, 0x7B, 
+0x01, 0xAF, 0x7E, 0x02, 0x23, 0x3F, 0x75, 0xF0, 0x13, 0xA4, 0x24, 0x3B, 0xF5, 0x82, 0xE4, 0x34, 
+0x90, 0xF5, 0x83, 0xE0, 0x22, 0xE0, 0xD3, 0x9D, 0xEC, 0x64, 0x80, 0xF8, 0x74, 0x80, 0x98, 0x22, 
+0x90, 0x8A, 0x95, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x90, 0x8A, 0x9C, 0xE0, 0xFB, 0x22, 0x90, 0x90, 
+0x72, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x91, 0x35, 0xE0, 0x22, 0x74, 0x23, 0x25, 0x65, 0xF5, 0x82, 
+0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0x90, 0x8A, 0x8C, 0xE0, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 
+0x22, 0x7F, 0x84, 0x7E, 0x08, 0x12, 0x94, 0x7A, 0x90, 0x8F, 0x9A, 0x22, 0xE0, 0x90, 0x01, 0xBA, 
+0xF0, 0x90, 0x8A, 0x85, 0xE0, 0x22, 0x90, 0x8F, 0xEB, 0xE0, 0xFF, 0x90, 0x8F, 0xE9, 0xE0, 0x22, 
+0x90, 0x90, 0xFF, 0x12, 0x87, 0x56, 0x02, 0x03, 0x13, 0x7A, 0x00, 0xE4, 0xFD, 0x7F, 0x01, 0x02, 
+0x9E, 0xE4, 0xE0, 0xFC, 0xA3, 0xE0, 0xF5, 0x82, 0x8C, 0x83, 0x22, 0x90, 0x91, 0x0D, 0xCF, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x22, 0xE0, 0x90, 0x84, 0x47, 0xF0, 0xA3, 0x74, 0x02, 0x22, 0x90, 0x90, 0x06, 
+0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x91, 0x35, 0xF0, 0x22, 0xFF, 
+0x12, 0x02, 0x06, 0x54, 0x0F, 0xFD, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x22, 0x90, 
+0x8A, 0x87, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xE5, 0x6B, 0xF0, 0xA3, 0xE5, 0x6C, 0xF0, 0x22, 0x90, 
+0x00, 0x02, 0x12, 0x03, 0x3E, 0xFF, 0x22, 0x7D, 0x05, 0x7F, 0x04, 0x02, 0x9E, 0xE4, 0x7D, 0x20, 
+0xE4, 0xFF, 0x02, 0x7B, 0x2A, 0xFF, 0x12, 0x02, 0x06, 0xFE, 0x54, 0x0F, 0x22, 0x00, 0x87, 0x16, 
+
+};
+u4Byte ArrayLength_MP_8703B_FW_NIC = 20944;
+
+
+void
+ODM_ReadFirmware_MP_8703B_FW_NIC(
+	IN   PDM_ODM_T    pDM_Odm,
+	OUT  u1Byte       *pFirmware,
+	OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8703B_FW_NIC;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8703B_FW_NIC, ArrayLength_MP_8703B_FW_NIC);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8703B_FW_NIC;
+}
+
+
+u1Byte Array_MP_8703B_FW_WoWLAN[] = {
+0xB2, 0x03, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x26, 0x17, 0x21, 0x24, 0x56, 0x02, 0x00, 
+0x4F, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x88, 0xC2, 0x02, 0xB3, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xA6, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB3, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB4, 0x0C, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xB7, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x89, 0x54, 0x02, 0x91, 0x1D, 0x02, 0x80, 0x86, 0x02, 0x80, 0x89, 0x02, 0x80, 0x8C, 0x02, 
+0xA0, 0x62, 0x02, 0xA7, 0x35, 0x02, 0x80, 0x95, 0x02, 0x80, 0x98, 0x02, 0x80, 0x9B, 0x02, 0x80, 
+0x9E, 0x02, 0x80, 0xA1, 0x02, 0x80, 0xA4, 0x02, 0x80, 0xA7, 0x02, 0x80, 0xAA, 0x02, 0x80, 0xAD, 
+0x02, 0x80, 0xB0, 0x02, 0x80, 0xB3, 0x02, 0x80, 0xB6, 0x02, 0x80, 0xB9, 0x02, 0x80, 0xBC, 0x02, 
+0x80, 0xBF, 0x02, 0x80, 0xC2, 0x02, 0x80, 0xC5, 0x02, 0x80, 0xC8, 0x02, 0x80, 0xCB, 0x02, 0x80, 
+0xCE, 0x02, 0x80, 0xD1, 0x02, 0xC9, 0xC4, 0x02, 0x80, 0xD7, 0x02, 0x80, 0xDA, 0x02, 0x80, 0xDD, 
+0x02, 0x80, 0xE0, 0x02, 0x80, 0xE3, 0x02, 0x80, 0xE6, 0x02, 0x80, 0xE9, 0x02, 0x80, 0xEC, 0x00, 
+0x00, 0x00, 0x02, 0x80, 0xF2, 0x00, 0x00, 0x00, 0x02, 0x80, 0xF8, 0x02, 0x80, 0xFB, 0x02, 0x80, 
+0xFE, 0x02, 0x81, 0x01, 0x02, 0x81, 0x04, 0x02, 0x81, 0x07, 0x02, 0x81, 0x0A, 0x02, 0x81, 0x0D, 
+0x02, 0x81, 0x10, 0x02, 0x81, 0x13, 0x02, 0x81, 0x16, 0x02, 0x81, 0x19, 0x02, 0x81, 0x1C, 0x02, 
+0xC9, 0xBE, 0x02, 0x81, 0x22, 0x02, 0x81, 0x25, 0x02, 0x81, 0x28, 0x02, 0x81, 0x2B, 0x02, 0x81, 
+0x2E, 0x02, 0x81, 0x31, 0x02, 0xC0, 0x57, 0x02, 0xC1, 0x07, 0x02, 0xB6, 0xA3, 0x02, 0x8F, 0xCF, 
+0x02, 0x81, 0x40, 0x02, 0xA1, 0xC0, 0x02, 0xD2, 0x27, 0x02, 0x81, 0x49, 0x02, 0x81, 0x4C, 0x02, 
+0x81, 0x4F, 0x02, 0x81, 0x52, 0x02, 0x81, 0x55, 0x02, 0x81, 0x58, 0x02, 0x81, 0x5B, 0x02, 0xB5, 
+0xE4, 0x02, 0x81, 0x61, 0x02, 0x81, 0x64, 0x02, 0xD3, 0x5E, 0x02, 0x81, 0x6A, 0x02, 0x81, 0x6D, 
+0x02, 0x81, 0x70, 0x02, 0xC2, 0xB3, 0x02, 0x92, 0x45, 0x02, 0x81, 0x79, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x84, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x89, 0x4E, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x89, 0x4E, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x84, 0x4D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x84, 0x4C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x84, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xEF, 0x2B, 0xFF, 
+0xEE, 0x3A, 0xFE, 0xED, 0x39, 0xFD, 0xEC, 0x38, 0xFC, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 
+0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 
+0xEC, 0x48, 0xFC, 0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0x22, 
+0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 
+0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 
+0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 
+0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xE3, 0xF5, 0xF0, 0x09, 0xE2, 0x08, 0xB5, 0xF0, 
+0x6B, 0xDF, 0xF5, 0x80, 0x67, 0xE3, 0xF5, 0xF0, 0x09, 0xE6, 0x08, 0xB5, 0xF0, 0x5E, 0xDF, 0xF5, 
+0x80, 0x5A, 0x87, 0xF0, 0x09, 0xE6, 0x08, 0xB5, 0xF0, 0x52, 0xDF, 0xF6, 0x80, 0x4E, 0x87, 0xF0, 
+0x09, 0xE2, 0x08, 0xB5, 0xF0, 0x46, 0xDF, 0xF6, 0x80, 0x42, 0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 
+0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x36, 0xDF, 0xF6, 0x80, 0x32, 0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 
+0x09, 0xE4, 0x93, 0xA3, 0xB5, 0xF0, 0x25, 0xDF, 0xF5, 0x80, 0x21, 0x88, 0x82, 0x8C, 0x83, 0xE3, 
+0xF5, 0xF0, 0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x14, 0xDF, 0xF5, 0x80, 0x10, 0x88, 0x82, 0x8C, 0x83, 
+0xE3, 0xF5, 0xF0, 0x09, 0xE4, 0x93, 0xA3, 0xB5, 0xF0, 0x02, 0xDF, 0xF4, 0x02, 0x88, 0x47, 0x80, 
+0x87, 0x80, 0xE9, 0x80, 0x90, 0x80, 0xD4, 0x80, 0x3E, 0x80, 0x15, 0x80, 0x6E, 0x80, 0x7E, 0x80, 
+0x9D, 0x80, 0xB7, 0x80, 0x8D, 0x80, 0xA3, 0x80, 0x51, 0x80, 0x74, 0x80, 0x3C, 0x02, 0x88, 0x53, 
+0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 
+0xC5, 0x83, 0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 
+0x76, 0xDF, 0xE3, 0xDE, 0xE1, 0x80, 0x70, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 
+0xE2, 0x08, 0xB5, 0xF0, 0x62, 0xDF, 0xF4, 0x80, 0x5E, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 
+0xA3, 0xE6, 0x08, 0xB5, 0xF0, 0x51, 0xDF, 0xF5, 0x80, 0x4D, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 
+0xF0, 0xA3, 0xE2, 0x08, 0xB5, 0xF0, 0x40, 0xDF, 0xF5, 0x80, 0x3C, 0x89, 0x82, 0x8A, 0x83, 0xE4, 
+0x93, 0xF5, 0xF0, 0xA3, 0xE6, 0x08, 0xB5, 0xF0, 0x2E, 0xDF, 0xF4, 0x80, 0x2A, 0x80, 0x02, 0x80, 
+0x57, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
+0xCC, 0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 
+0x06, 0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0x00, 0x7F, 0xFF, 0xB5, 0xF0, 0x02, 0x0F, 0x22, 0x40, 0x02, 
+0x7F, 0x01, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 
+0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 
+0xF0, 0xD5, 0xDF, 0xE5, 0xDE, 0xE3, 0x80, 0xCF, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xF5, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 
+0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xAF, 0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0xA9, 0x88, 0xF0, 
+0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xAB, 0xED, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x98, 0xF5, 
+0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x8E, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x87, 
+0x8F, 0x73, 0x02, 0x89, 0x00, 0x02, 0x84, 0xDD, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 
+0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 
+0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 
+0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 
+0x90, 0x89, 0x45, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 
+0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 
+0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 
+0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 
+0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x41, 0x93, 0xA3, 0x00, 0x41, 0x93, 0xA4, 0x00, 0x00, 0x8C, 0x64, 
+0xB0, 0x51, 0xB2, 0x92, 0x90, 0x93, 0xA0, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x86, 0x27, 0x90, 0x89, 
+0x7E, 0xE0, 0xFF, 0x90, 0x93, 0xA0, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x89, 0x7E, 0xF0, 0x22, 0x90, 
+0x92, 0x93, 0xEF, 0xF0, 0x71, 0x09, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 
+0x90, 0x92, 0xA3, 0xE0, 0x90, 0x92, 0xA5, 0xF0, 0x71, 0x09, 0x7F, 0xF5, 0x7E, 0x00, 0x12, 0x62, 
+0xDB, 0xBF, 0x01, 0x08, 0x90, 0x92, 0xA3, 0xE0, 0x90, 0x92, 0xA6, 0xF0, 0x71, 0x09, 0x7F, 0xF6, 
+0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x92, 0xA3, 0xE0, 0x90, 0x92, 0xA7, 0xF0, 
+0x71, 0x09, 0x7F, 0xF7, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x92, 0xA3, 0xE0, 
+0x90, 0x92, 0xA8, 0xF0, 0x71, 0x09, 0x7F, 0xF8, 0x7E, 0x00, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 
+0x90, 0x92, 0xA3, 0xE0, 0x90, 0x92, 0xA9, 0xF0, 0x71, 0x09, 0x71, 0xA9, 0xBF, 0x01, 0x08, 0x90, 
+0x92, 0xA3, 0xE0, 0x90, 0x92, 0xAA, 0xF0, 0x71, 0x09, 0x7F, 0xFB, 0x71, 0x10, 0x70, 0x52, 0x90, 
+0x92, 0xA3, 0xE0, 0x90, 0x92, 0xAB, 0xF0, 0x54, 0x07, 0x60, 0x08, 0x90, 0x92, 0xA3, 0xE0, 0x54, 
+0xE0, 0x70, 0x3E, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xA4, 0x7F, 0xFA, 0x71, 0x10, 0x70, 0x32, 0x90, 
+0x92, 0xA3, 0xE0, 0xFC, 0x54, 0x07, 0x70, 0x12, 0x90, 0x92, 0xAB, 0xE0, 0xFE, 0x90, 0x92, 0xA4, 
+0xE0, 0x54, 0x07, 0xFD, 0xEE, 0x4D, 0x90, 0x92, 0xAB, 0xF0, 0xEC, 0x54, 0xE0, 0x70, 0x12, 0x90, 
+0x92, 0xAB, 0xE0, 0xFF, 0x90, 0x92, 0xA4, 0xE0, 0x54, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x92, 0xAB, 
+0xF0, 0x71, 0x09, 0x7F, 0xFD, 0x71, 0x10, 0x70, 0x4B, 0x90, 0x92, 0xA3, 0xE0, 0xFE, 0x54, 0xCC, 
+0x90, 0x92, 0xAC, 0xF0, 0xEE, 0x54, 0x0C, 0xFF, 0x60, 0x08, 0x90, 0x92, 0xA3, 0xE0, 0x54, 0xC0, 
+0x70, 0x32, 0xEF, 0x70, 0x16, 0x90, 0x92, 0xAC, 0xE0, 0xFF, 0x90, 0x92, 0xA3, 0xE0, 0x54, 0x03, 
+0x25, 0xE0, 0x25, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x92, 0xAC, 0xF0, 0x90, 0x92, 0xA3, 0xE0, 0xFF, 
+0x54, 0xC0, 0x70, 0x10, 0x90, 0x92, 0xAC, 0xE0, 0xFE, 0xEF, 0x54, 0x30, 0x25, 0xE0, 0x25, 0xE0, 
+0xFF, 0xEE, 0x4F, 0xF0, 0x90, 0x92, 0x94, 0x74, 0x19, 0xF0, 0x90, 0x92, 0xA2, 0x74, 0x08, 0xF0, 
+0x90, 0x92, 0xA5, 0xE0, 0x90, 0x92, 0x96, 0xF0, 0x90, 0x92, 0xA6, 0xE0, 0x90, 0x92, 0x97, 0xF0, 
+0x90, 0x92, 0xA7, 0xE0, 0x90, 0x92, 0x98, 0xF0, 0x90, 0x92, 0xA8, 0xE0, 0x90, 0x92, 0x99, 0xF0, 
+0x90, 0x92, 0xA9, 0xE0, 0x90, 0x92, 0x9A, 0xF0, 0x90, 0x92, 0xAA, 0xE0, 0x90, 0x92, 0x9B, 0xF0, 
+0x90, 0x92, 0xAB, 0xE0, 0x90, 0x92, 0x9C, 0xF0, 0x90, 0x92, 0xAC, 0xE0, 0x90, 0x92, 0x9D, 0xF0, 
+0x90, 0x92, 0x93, 0xE0, 0xB4, 0x01, 0x0D, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0x94, 0x12, 0x5A, 0x18, 
+0x7F, 0x04, 0x21, 0x54, 0x75, 0x1B, 0x01, 0x75, 0x1C, 0x92, 0x75, 0x1D, 0x94, 0x75, 0x1E, 0x0A, 
+0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x02, 0x68, 0xAB, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xA3, 0x22, 
+0x7E, 0x00, 0x12, 0x62, 0xDB, 0xEF, 0x64, 0x01, 0x22, 0x7E, 0x00, 0x7F, 0x0B, 0x7D, 0x00, 0x7B, 
+0x01, 0x7A, 0x92, 0x79, 0x5C, 0x12, 0x04, 0x7A, 0x71, 0xA2, 0x71, 0xA9, 0xBF, 0x01, 0x1C, 0x90, 
+0x92, 0x93, 0xE0, 0xFE, 0x54, 0x01, 0x90, 0x92, 0x5C, 0xF0, 0xEE, 0x54, 0x04, 0x90, 0x92, 0x5E, 
+0xF0, 0x90, 0x92, 0x93, 0xE0, 0x54, 0x08, 0x90, 0x92, 0x5D, 0xF0, 0x71, 0xA2, 0x7F, 0xFB, 0x71, 
+0x10, 0x70, 0x34, 0x90, 0x92, 0x93, 0xE0, 0x54, 0x07, 0x70, 0x14, 0x7B, 0x01, 0x7A, 0x92, 0x79, 
+0x94, 0x7F, 0xFA, 0xFE, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x0F, 0x90, 0x92, 0x94, 0x80, 0x03, 0x90, 
+0x92, 0x93, 0xE0, 0x54, 0x07, 0x90, 0x92, 0x60, 0xF0, 0x90, 0x92, 0x93, 0xE0, 0x54, 0xE0, 0xC4, 
+0x13, 0x54, 0x07, 0x90, 0x92, 0x5F, 0xF0, 0x71, 0xA2, 0x7F, 0xFD, 0x7E, 0x00, 0x12, 0x62, 0xDB, 
+0xBF, 0x01, 0x0E, 0x90, 0x92, 0x93, 0xE0, 0x54, 0x0C, 0x13, 0x13, 0x54, 0x3F, 0x90, 0x92, 0x61, 
+0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0x93, 0x22, 0x7F, 0xF9, 0x7E, 0x00, 0x02, 0x62, 0xDB, 
+0x90, 0x92, 0x84, 0x74, 0x12, 0xF0, 0x90, 0x92, 0x92, 0x74, 0x05, 0xF0, 0x90, 0x92, 0x86, 0xEF, 
+0x12, 0xD5, 0xFA, 0x90, 0x92, 0x82, 0xE0, 0x90, 0x92, 0x89, 0xF0, 0x90, 0x92, 0x83, 0xE0, 0x90, 
+0x92, 0x8A, 0xF0, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0x84, 0x12, 0x5A, 0x18, 0x7F, 0x04, 0x21, 0x54, 
+0x91, 0x5D, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x06, 0x90, 0x92, 0x79, 0xE0, 
+0xA3, 0xF0, 0x91, 0x5D, 0x7F, 0xF6, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x92, 
+0x79, 0xE0, 0x90, 0x92, 0x7B, 0xF0, 0x91, 0x5D, 0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 
+0x01, 0x08, 0x90, 0x92, 0x79, 0xE0, 0x90, 0x92, 0x7C, 0xF0, 0x91, 0x5D, 0x7F, 0xF3, 0x7E, 0x01, 
+0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x92, 0x79, 0xE0, 0x90, 0x92, 0x7D, 0xF0, 0x91, 0x5D, 
+0x7F, 0xF2, 0x7E, 0x01, 0x12, 0x62, 0xDB, 0xBF, 0x01, 0x08, 0x90, 0x92, 0x79, 0xE0, 0x90, 0x92, 
+0x7E, 0xF0, 0x90, 0x92, 0x7A, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 
+0x92, 0x82, 0xF0, 0x90, 0x92, 0x7E, 0xE0, 0x90, 0x92, 0x83, 0xF0, 0x61, 0xB0, 0x7B, 0x01, 0x7A, 
+0x92, 0x79, 0x79, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x7A, 0xA5, 
+0x12, 0xB2, 0x8B, 0x12, 0xC8, 0xA9, 0x12, 0x7A, 0xCB, 0x12, 0xB3, 0x9D, 0xB1, 0x06, 0x7F, 0x01, 
+0x12, 0x85, 0x15, 0x90, 0x92, 0x4D, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x85, 0x15, 0x90, 0x92, 0x4D, 
+0xE0, 0x04, 0xF0, 0x12, 0xB2, 0x4D, 0x12, 0xC3, 0xE5, 0x90, 0x01, 0xCC, 0x74, 0x0F, 0xF0, 0x90, 
+0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x7A, 0xA5, 0x75, 0x20, 0xFF, 0x12, 0x7B, 
+0xC2, 0xE4, 0xFF, 0x31, 0x6F, 0x12, 0xB3, 0x45, 0x90, 0x00, 0x81, 0xE0, 0x44, 0x04, 0xFD, 0x7F, 
+0x81, 0x12, 0x7A, 0xA5, 0x12, 0xB2, 0x81, 0x71, 0x19, 0x90, 0x01, 0x94, 0xE0, 0x54, 0xFD, 0xF0, 
+0x90, 0x01, 0x98, 0xE4, 0xF0, 0xA3, 0x74, 0x40, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0xA3, 0x74, 0x80, 
+0xF0, 0x12, 0xD5, 0x12, 0x90, 0x01, 0x98, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0x88, 0xF0, 0xA3, 0xE4, 
+0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x90, 0x00, 0xAA, 0xE0, 0x44, 0x02, 0xF0, 0xA3, 0xE0, 0x44, 0x80, 
+0xF0, 0xE4, 0xFF, 0x02, 0x85, 0x9E, 0xE4, 0x90, 0x89, 0x7E, 0xB1, 0x11, 0x90, 0x90, 0x01, 0xF0, 
+0x22, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x12, 0x9A, 0x20, 0xE4, 0x90, 0x92, 0x47, 
+0xB1, 0x11, 0x90, 0x91, 0xE5, 0xB1, 0x11, 0xA3, 0xB1, 0x11, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x91, 
+0xF7, 0xF0, 0xA3, 0xF0, 0x90, 0x92, 0x39, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x93, 0x16, 0xEF, 0xF0, 
+0xA3, 0x12, 0x86, 0xE9, 0x90, 0x93, 0x17, 0xD1, 0x01, 0xB1, 0xDB, 0x24, 0x02, 0xB1, 0x9B, 0xB1, 
+0xF0, 0x24, 0x04, 0xB1, 0xD2, 0x24, 0x03, 0xB1, 0x9B, 0xB1, 0xF0, 0x24, 0x08, 0xB1, 0xD2, 0x24, 
+0x04, 0xB1, 0x9B, 0xB1, 0xF0, 0x24, 0x0C, 0xB1, 0xD2, 0x24, 0x05, 0xB1, 0x9B, 0x90, 0x93, 0x16, 
+0xE0, 0xFE, 0x44, 0x50, 0x90, 0x93, 0x1A, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 
+0xA3, 0xF0, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0xB1, 0x9B, 0x90, 0x93, 0x1A, 0x74, 0xFF, 0xB1, 0x11, 
+0xB1, 0xE7, 0x04, 0xB1, 0x9B, 0x90, 0x06, 0x72, 0xE4, 0xF0, 0x22, 0xFF, 0x7B, 0x01, 0x7A, 0x93, 
+0x79, 0x1A, 0x12, 0x02, 0x06, 0x90, 0x06, 0x74, 0x12, 0x95, 0x9C, 0x90, 0x06, 0x75, 0x12, 0x96, 
+0x85, 0x90, 0x06, 0x76, 0xF0, 0x12, 0x95, 0xA9, 0x90, 0x06, 0x77, 0xF0, 0x90, 0x06, 0x70, 0xEF, 
+0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x02, 
+0x7B, 0x8D, 0xF9, 0xE4, 0x3A, 0x8B, 0x1B, 0xF5, 0x1C, 0x89, 0x1D, 0x75, 0x1E, 0x04, 0x7B, 0x01, 
+0x7A, 0x93, 0x79, 0x1A, 0x12, 0x68, 0xAB, 0x90, 0x93, 0x16, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x22, 
+0x90, 0x93, 0x17, 0x12, 0x86, 0xE0, 0xE9, 0x22, 0x90, 0x92, 0x79, 0x12, 0x86, 0xE9, 0x90, 0x92, 
+0x79, 0x12, 0x86, 0xE0, 0x8B, 0x1B, 0x8A, 0x1C, 0x89, 0x1D, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x8F, 0xA7, 0x12, 0x86, 0xE9, 0x78, 0xB3, 0x7C, 0x8F, 0x7D, 0x01, 0x7B, 0xFF, 
+0x7A, 0x81, 0x79, 0x8E, 0x12, 0x9F, 0xF1, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x8F, 0xB2, 0xF0, 0x90, 
+0x04, 0x1D, 0xE0, 0x60, 0x0C, 0x7D, 0x33, 0x12, 0xB6, 0x9E, 0xEF, 0x64, 0x01, 0x70, 0x17, 0x80, 
+0x00, 0x90, 0x92, 0x3E, 0xE0, 0xFF, 0x90, 0x93, 0x92, 0x74, 0x10, 0x12, 0xD5, 0x84, 0x90, 0x8F, 
+0xAF, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8F, 0xAF, 0x12, 0xBA, 0xF8, 0x90, 0x8F, 0xB1, 0xEF, 
+0xF0, 0x90, 0x8F, 0xAF, 0x12, 0xD4, 0x98, 0x90, 0x8F, 0xAD, 0xE0, 0xFD, 0x12, 0x97, 0x5E, 0x90, 
+0x8F, 0xAE, 0xE0, 0x70, 0x55, 0xF1, 0xEF, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x8F, 0xAA, 
+0xD1, 0x01, 0x75, 0x1E, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x68, 0xAB, 0x90, 0x8F, 
+0xAF, 0xF1, 0x36, 0xF1, 0xBE, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x8F, 
+0xAA, 0xD1, 0x01, 0x75, 0x1E, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x68, 0xAB, 0x90, 
+0x8F, 0xAF, 0xF1, 0x36, 0xF1, 0xC5, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x8F, 0xA7, 0xD1, 
+0x01, 0x75, 0x1E, 0x04, 0xD0, 0x01, 0xD0, 0x02, 0x80, 0x4C, 0x90, 0x8F, 0xAE, 0xE0, 0x64, 0x01, 
+0x70, 0x49, 0xF1, 0xEF, 0xC0, 0x03, 0x8B, 0x1B, 0x75, 0x1C, 0x90, 0x75, 0x1D, 0x2D, 0x75, 0x1E, 
+0x06, 0xD0, 0x03, 0x12, 0x68, 0xAB, 0x90, 0x8F, 0xAF, 0xF1, 0x36, 0xF1, 0xBE, 0xFA, 0x7B, 0x01, 
+0xC0, 0x03, 0x8B, 0x1B, 0x75, 0x1C, 0x90, 0x75, 0x1D, 0x37, 0x75, 0x1E, 0x06, 0xD0, 0x03, 0x12, 
+0x68, 0xAB, 0x90, 0x8F, 0xAF, 0xF1, 0x36, 0xF1, 0xC5, 0xC0, 0x03, 0x8B, 0x1B, 0x75, 0x1C, 0x90, 
+0x75, 0x1D, 0x3D, 0x75, 0x1E, 0x04, 0xD0, 0x03, 0x12, 0x68, 0xAB, 0x90, 0x06, 0x30, 0xE0, 0x44, 
+0x10, 0xF0, 0x90, 0x8F, 0xB2, 0xE0, 0xFF, 0x7D, 0x34, 0xF1, 0xDA, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x12, 0x68, 0xAB, 0x90, 0x92, 0xEE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x22, 0x12, 0x7A, 0x7E, 
+0x90, 0x92, 0x79, 0xE4, 0x12, 0xC6, 0xEA, 0x12, 0xBA, 0xF8, 0x90, 0x92, 0x7B, 0xEF, 0xF0, 0x90, 
+0x92, 0x79, 0xA3, 0xE0, 0x24, 0x38, 0xF9, 0xE4, 0x34, 0xFC, 0xF1, 0xAF, 0x75, 0x1E, 0x06, 0x7B, 
+0x01, 0x7A, 0x90, 0x79, 0x2D, 0xF1, 0xB7, 0xF1, 0x36, 0x24, 0x3E, 0xF9, 0xE4, 0x34, 0xFC, 0xF1, 
+0xAF, 0x75, 0x1E, 0x04, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x33, 0xF1, 0xB7, 0xF1, 0x36, 0xF1, 0xBE, 
+0xF1, 0xAF, 0x75, 0x1E, 0x06, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x37, 0xF1, 0xB7, 0xF1, 0x36, 0x24, 
+0x48, 0xF9, 0xE4, 0x34, 0xFC, 0xF1, 0xAF, 0x75, 0x1E, 0x04, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x3D, 
+0x02, 0x68, 0xAB, 0x12, 0x7A, 0x7E, 0x7E, 0x00, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 0x75, 
+0x1B, 0x01, 0xF5, 0x1C, 0x89, 0x1D, 0x22, 0x12, 0x68, 0xAB, 0x90, 0x92, 0x79, 0x22, 0x24, 0x42, 
+0xF9, 0xE4, 0x34, 0xFC, 0x22, 0x24, 0x48, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x90, 
+0x05, 0x22, 0xEF, 0xF0, 0x90, 0x90, 0x01, 0xED, 0xF0, 0x22, 0xF1, 0xCF, 0x90, 0x04, 0x1F, 0x74, 
+0x20, 0xF0, 0x22, 0x90, 0x90, 0x08, 0x12, 0x97, 0xFC, 0x30, 0xE0, 0x02, 0xB1, 0x19, 0x22, 0xA3, 
+0xA3, 0xE0, 0x24, 0x38, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x80, 0xE5, 0x90, 0x02, 
+0x09, 0xE0, 0xF5, 0x0D, 0x12, 0x02, 0x06, 0x25, 0x0D, 0x90, 0x89, 0x83, 0xB1, 0x9C, 0x25, 0x0D, 
+0x90, 0x89, 0x84, 0xD1, 0x85, 0x25, 0x0D, 0x90, 0x89, 0x85, 0xF0, 0xB1, 0xA9, 0x25, 0x0D, 0x90, 
+0x89, 0x86, 0xF1, 0x02, 0x25, 0x0D, 0x90, 0x89, 0x87, 0x11, 0x3B, 0x25, 0x0D, 0x90, 0x89, 0x88, 
+0xF1, 0x4C, 0x25, 0x0D, 0x90, 0x89, 0x89, 0xF0, 0x22, 0x4E, 0xFF, 0xF0, 0x90, 0x00, 0x05, 0x02, 
+0x02, 0x1F, 0xF1, 0xF6, 0xF1, 0xED, 0xFF, 0x54, 0x7F, 0x90, 0x8A, 0x83, 0xF0, 0xEF, 0x12, 0x9F, 
+0x8D, 0xA3, 0xB1, 0x9C, 0xFD, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFF, 0x90, 0x8A, 0x81, 0xE0, 0x54, 
+0xF0, 0x4F, 0xF0, 0xB1, 0xA9, 0xFC, 0x54, 0x01, 0x25, 0xE0, 0xFF, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 
+0xFD, 0x4F, 0xF0, 0xEC, 0x54, 0x04, 0xC3, 0x13, 0xFF, 0x90, 0x8A, 0x80, 0xE0, 0x54, 0xFD, 0x4F, 
+0xF0, 0xED, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0xA3, 0xE0, 0x54, 0x0F, 0xD1, 0x84, 0x90, 0x8A, 
+0x82, 0xF1, 0x02, 0xFD, 0x7F, 0x02, 0x12, 0x53, 0xDB, 0x90, 0x92, 0x79, 0x12, 0x86, 0xE0, 0x11, 
+0x3C, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x8A, 0xE8, 0x12, 0xD4, 0x45, 0x11, 0x3A, 0xFE, 0x12, 0xBF, 
+0xEE, 0x90, 0x8A, 0xE8, 0x12, 0xD4, 0xF3, 0x11, 0x39, 0xFE, 0x12, 0xD4, 0xDC, 0x90, 0x8A, 0xE8, 
+0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x11, 0x39, 0x54, 0x40, 0xFE, 0xEF, 0x54, 0xBF, 
+0x4E, 0x90, 0x8A, 0xE8, 0xF0, 0xF1, 0xFC, 0x20, 0xE0, 0x28, 0xEF, 0xC3, 0x13, 0x20, 0xE0, 0x0B, 
+0x75, 0x0E, 0x01, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x0B, 0x80, 0x0E, 0xE4, 0xF5, 0x0E, 0x90, 0x8B, 
+0x2C, 0xE0, 0x60, 0x05, 0xE4, 0xF5, 0x0D, 0x80, 0x03, 0x75, 0x0D, 0x01, 0xAD, 0x0E, 0xAF, 0x0D, 
+0x51, 0x45, 0x90, 0x92, 0x79, 0x12, 0x86, 0xE0, 0x12, 0x6C, 0xAD, 0x12, 0xD4, 0xC7, 0xF0, 0x90, 
+0x8A, 0x83, 0x12, 0xD4, 0xE5, 0x12, 0xA5, 0x66, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x92, 0x76, 
+0x12, 0x86, 0xE9, 0x90, 0x92, 0x75, 0xEF, 0xF0, 0x12, 0x86, 0xF2, 0x91, 0x8F, 0x00, 0x91, 0x94, 
+0x01, 0x91, 0x99, 0x03, 0x91, 0x9E, 0x04, 0x91, 0xA2, 0x12, 0x91, 0xA7, 0x14, 0x91, 0xAC, 0x20, 
+0x91, 0xB0, 0x25, 0x91, 0xB5, 0x27, 0x91, 0xBA, 0x60, 0x91, 0xBE, 0x61, 0x91, 0xC3, 0x62, 0x91, 
+0xC8, 0x63, 0x91, 0xCD, 0x64, 0x91, 0xD2, 0x65, 0x91, 0xD7, 0x66, 0x91, 0xDC, 0x67, 0x91, 0xE1, 
+0x68, 0x91, 0xE6, 0x69, 0x91, 0xEB, 0x6B, 0x91, 0xF0, 0x6C, 0x91, 0xF5, 0x6D, 0x91, 0xFA, 0x6E, 
+0x91, 0xFF, 0x6F, 0x92, 0x04, 0x70, 0x92, 0x0E, 0x80, 0x92, 0x09, 0x81, 0x92, 0x13, 0x82, 0x92, 
+0x18, 0x83, 0x92, 0x1C, 0x84, 0x92, 0x20, 0x88, 0x92, 0x25, 0xC3, 0x00, 0x00, 0x92, 0x2A, 0x51, 
+0x3A, 0x02, 0x8F, 0xFE, 0x51, 0x3A, 0x02, 0x98, 0x04, 0x51, 0x3A, 0x02, 0xC9, 0xF6, 0x51, 0x3A, 
+0xE1, 0x09, 0x51, 0x3A, 0x02, 0xA0, 0x03, 0x51, 0x3A, 0x02, 0xA0, 0x17, 0x51, 0x3A, 0x01, 0x42, 
+0x51, 0x3A, 0x02, 0xA0, 0x26, 0x51, 0x3A, 0x02, 0xA7, 0xF1, 0x51, 0x3A, 0x61, 0x7D, 0x51, 0x3A, 
+0x02, 0x79, 0x0F, 0x51, 0x3A, 0x02, 0x7B, 0xBB, 0x51, 0x3A, 0x02, 0x7A, 0x6A, 0x51, 0x3A, 0x02, 
+0x60, 0x68, 0x51, 0x3A, 0x02, 0x7B, 0x1C, 0x51, 0x3A, 0x02, 0x72, 0xF1, 0x51, 0x3A, 0x02, 0x4E, 
+0xA5, 0x51, 0x3A, 0x02, 0x78, 0xB2, 0x51, 0x3A, 0x02, 0x43, 0x1E, 0x51, 0x3A, 0x02, 0xA8, 0x1D, 
+0x51, 0x3A, 0x02, 0x78, 0x32, 0x51, 0x3A, 0x02, 0x5C, 0xE4, 0x51, 0x3A, 0x02, 0x74, 0x98, 0x51, 
+0x3A, 0x02, 0x77, 0x58, 0x51, 0x3A, 0x02, 0x62, 0x0D, 0x51, 0x3A, 0x02, 0xBC, 0xC4, 0x51, 0x3A, 
+0x02, 0xBD, 0x84, 0x51, 0x3A, 0x02, 0xD1, 0x3D, 0x51, 0x3A, 0xC1, 0x8C, 0x51, 0x3A, 0xC1, 0xC7, 
+0x51, 0x3A, 0x02, 0xD1, 0x53, 0x51, 0x3A, 0x02, 0xAF, 0xF6, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 
+0xF0, 0x90, 0x92, 0x75, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0x92, 0x76, 0x02, 0x86, 0xE0, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xD4, 0xEF, 
+0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x8A, 0xED, 0x12, 0xB5, 0x41, 0x30, 0xE0, 0x02, 0x61, 0x58, 0x90, 
+0x8B, 0x2D, 0xE0, 0x70, 0x5D, 0x90, 0x8F, 0xD4, 0xE0, 0x64, 0x02, 0x60, 0x26, 0x90, 0x8F, 0xD5, 
+0xE0, 0x70, 0x20, 0x71, 0x5D, 0x12, 0xD5, 0xCA, 0xB4, 0x01, 0x05, 0x12, 0x04, 0xB2, 0x80, 0x08, 
+0x12, 0xD6, 0x0A, 0xEE, 0x44, 0x02, 0xFE, 0xEC, 0x71, 0x6B, 0x71, 0x71, 0x7F, 0x48, 0x7E, 0x09, 
+0x12, 0x6F, 0xFE, 0x90, 0x8F, 0xD5, 0xE0, 0xFF, 0x64, 0x02, 0x70, 0x02, 0x61, 0x58, 0xEF, 0x70, 
+0x02, 0x61, 0x58, 0x71, 0x5D, 0x90, 0x8B, 0x2C, 0xE0, 0x90, 0x8F, 0xD6, 0x60, 0x05, 0x12, 0xD6, 
+0x0A, 0x80, 0x07, 0x12, 0x04, 0xB2, 0xEE, 0x44, 0x02, 0xFE, 0x71, 0x6A, 0x71, 0x71, 0x7F, 0x48, 
+0x61, 0x53, 0x90, 0x8F, 0xD4, 0xE0, 0x64, 0x02, 0x60, 0x29, 0x12, 0xC3, 0xAD, 0xEF, 0x54, 0xFC, 
+0xFF, 0x71, 0x6A, 0x12, 0xD5, 0xCA, 0xB4, 0x01, 0x08, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x01, 0x80, 
+0x06, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x02, 0xFF, 0x71, 0x6A, 0x71, 0x71, 0x7F, 0x2C, 0x7E, 0x09, 
+0x12, 0x6F, 0xFE, 0x90, 0x8F, 0xD5, 0xE0, 0x64, 0x02, 0x60, 0x5D, 0x12, 0xC6, 0xDB, 0xE4, 0xFF, 
+0x71, 0x6A, 0x90, 0x8F, 0xD5, 0xE0, 0x70, 0x0C, 0xA3, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x77, 0xFF, 
+0x71, 0x6A, 0x80, 0x3B, 0x90, 0x8F, 0xD6, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x66, 0xFF, 0x71, 0x6A, 
+0x12, 0xC3, 0xAD, 0xEF, 0x54, 0xFC, 0x12, 0xD5, 0xB9, 0x90, 0x8B, 0x2C, 0xE0, 0x90, 0x8F, 0xDA, 
+0x60, 0x08, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x02, 0x80, 0x06, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x01, 
+0x12, 0xD5, 0xB9, 0x90, 0x8F, 0xDA, 0x71, 0x74, 0x7F, 0x2C, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0x71, 
+0x71, 0x7F, 0x30, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x48, 0x7E, 
+0x09, 0x12, 0x6F, 0xC1, 0xE4, 0xFF, 0xEE, 0x54, 0xF0, 0xFE, 0xEC, 0x90, 0x8F, 0xD6, 0x02, 0x04, 
+0x31, 0x90, 0x8F, 0xD6, 0x12, 0x04, 0xB2, 0x90, 0x8E, 0xEE, 0x02, 0x04, 0x31, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x8D, 0xF8, 0x75, 0x1E, 0x05, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0xEA, 
+0x12, 0x68, 0xAB, 0xF1, 0xED, 0x20, 0xE0, 0x02, 0x81, 0xFF, 0x90, 0x05, 0x54, 0xE0, 0x90, 0x8A, 
+0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 0xFA, 0xF0, 0x90, 0x8A, 0xED, 0xE0, 0xC4, 0x54, 0x0F, 
+0x30, 0xE0, 0x13, 0xB1, 0x9D, 0x90, 0x8A, 0xEB, 0xF0, 0x24, 0x0A, 0x90, 0x8B, 0x1C, 0xD1, 0x85, 
+0x90, 0x8A, 0xEC, 0xF0, 0x80, 0x48, 0xB1, 0x9D, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x14, 0xEF, 0xC3, 
+0x94, 0x03, 0x50, 0x07, 0x90, 0x8A, 0xEB, 0x74, 0x03, 0x80, 0x0C, 0xB1, 0x9D, 0x90, 0x8A, 0xEB, 
+0x80, 0x05, 0x90, 0x8A, 0xEB, 0x74, 0x2A, 0xF0, 0x24, 0x0A, 0x90, 0x8B, 0x1C, 0xF0, 0xD1, 0x86, 
+0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x12, 0xEF, 0xC3, 0x94, 0x03, 0x90, 0x8A, 0xEC, 0x50, 0x05, 0x74, 
+0x03, 0xF0, 0x80, 0x0A, 0xEF, 0xF0, 0x80, 0x06, 0x90, 0x8A, 0xEC, 0x74, 0x2A, 0xF0, 0x12, 0xB5, 
+0x3E, 0x30, 0xE0, 0x3D, 0x90, 0x8A, 0xEB, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0x8A, 0xF3, 0xF0, 
+0xE0, 0xC3, 0x13, 0xA3, 0xF0, 0x90, 0x8A, 0xEC, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0x8A, 0xF5, 
+0xF0, 0x90, 0x8A, 0xEB, 0xE0, 0xC3, 0x13, 0x90, 0x8A, 0xF6, 0xF0, 0x90, 0x8A, 0xEC, 0xE0, 0xC3, 
+0x13, 0x90, 0x8A, 0xF7, 0xF0, 0x90, 0x01, 0x3E, 0x74, 0x08, 0xF0, 0xFD, 0x7F, 0x02, 0x12, 0x7B, 
+0x2A, 0xE4, 0x90, 0x8B, 0x2A, 0xF0, 0xB1, 0xA3, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x36, 
+0x90, 0x8A, 0xEA, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x06, 0x12, 0x9F, 0x8C, 0x30, 0xE0, 0x27, 0x12, 
+0x02, 0x06, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x08, 
+0x80, 0x0B, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x05, 0x75, 0x0D, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x0D, 
+0x7D, 0x02, 0xAF, 0x0D, 0x51, 0x45, 0x90, 0x8A, 0xEA, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x18, 
+0x90, 0x8A, 0xEE, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 0x7D, 0x04, 0x7F, 0x02, 0x12, 
+0x53, 0xDB, 0x12, 0xD6, 0x1A, 0x74, 0x11, 0xF0, 0x90, 0x05, 0x58, 0x74, 0x02, 0xF0, 0x90, 0x8A, 
+0xF2, 0xE0, 0xB4, 0x01, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x01, 0xF0, 0x80, 0x2B, 0x90, 0x8A, 0xF2, 
+0xE0, 0xB4, 0x04, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x04, 0xF0, 0x80, 0x1C, 0x90, 0x8A, 0xF2, 0xE0, 
+0xB4, 0x06, 0x08, 0x90, 0x8A, 0xFD, 0x74, 0x02, 0xF0, 0x80, 0x0D, 0x90, 0x8A, 0xF2, 0xE0, 0xB4, 
+0x07, 0x06, 0x90, 0x8A, 0xFD, 0x74, 0x05, 0xF0, 0xE4, 0x90, 0x8A, 0xF2, 0xF0, 0x80, 0x5A, 0xB1, 
+0xA3, 0xF1, 0xFD, 0x30, 0xE0, 0x05, 0x75, 0x0E, 0x02, 0x80, 0x14, 0x12, 0x02, 0x06, 0xFF, 0x13, 
+0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x05, 0x75, 0x0E, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x0E, 0x12, 
+0x78, 0x72, 0x90, 0x8B, 0x51, 0xE0, 0x30, 0xE0, 0x04, 0x7D, 0xAC, 0x80, 0x02, 0x7D, 0x2C, 0x7F, 
+0x40, 0x12, 0x7A, 0xA5, 0xB1, 0xA3, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x04, 0x7F, 0x03, 
+0x80, 0x02, 0x7F, 0x01, 0x12, 0x71, 0x29, 0xAD, 0x0E, 0x7F, 0x02, 0x51, 0x45, 0xE4, 0xFD, 0xFF, 
+0x12, 0x8F, 0xCF, 0x12, 0xD6, 0x1A, 0x74, 0x43, 0xF0, 0x90, 0x8A, 0xF0, 0xE0, 0x54, 0xDF, 0xF0, 
+0xE4, 0x90, 0x8A, 0xFC, 0xF0, 0x90, 0x8A, 0xED, 0x12, 0x9F, 0x8C, 0x30, 0xE0, 0x09, 0x90, 0x8B, 
+0x1D, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x0C, 0x7F, 0x01, 0x12, 0x71, 0x63, 0x90, 0x8B, 0x1D, 0xE0, 
+0x54, 0xFD, 0xF0, 0x7F, 0x03, 0x12, 0x5C, 0x6F, 0x90, 0x8A, 0xEA, 0xE0, 0x20, 0xE0, 0x07, 0x90, 
+0x8A, 0xEE, 0xE0, 0x54, 0xBF, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x4E, 0xF0, 0x90, 0x00, 0x01, 
+0x02, 0x02, 0x1F, 0x90, 0x92, 0x79, 0x12, 0x86, 0xE0, 0x90, 0x00, 0x03, 0x02, 0x02, 0x1F, 0x90, 
+0x8F, 0xB9, 0x12, 0x86, 0xE9, 0x12, 0x02, 0x06, 0x90, 0x8F, 0xBE, 0xB1, 0x9C, 0x90, 0x8F, 0xBF, 
+0xF1, 0x02, 0x90, 0x8F, 0xC0, 0x11, 0x3B, 0x90, 0x8F, 0xC1, 0xF1, 0x4C, 0x90, 0x8F, 0xC2, 0xF0, 
+0x90, 0x00, 0x07, 0x12, 0x02, 0x1F, 0x90, 0x8F, 0xC3, 0xF0, 0xB1, 0xA9, 0x90, 0x8F, 0xC6, 0xF0, 
+0xED, 0x70, 0x19, 0xFF, 0xF1, 0x53, 0xE0, 0xB4, 0xFF, 0x06, 0xF1, 0x53, 0xE4, 0xF0, 0x80, 0x07, 
+0xF1, 0x53, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 0xB4, 0x06, 0xE8, 0x90, 0x8F, 0xBD, 0xE0, 
+0xFF, 0xB4, 0x04, 0x19, 0xA3, 0xE0, 0xFE, 0xD1, 0x7E, 0xEE, 0x12, 0xD5, 0xD2, 0xFE, 0xD1, 0x7E, 
+0x90, 0x00, 0x01, 0xEE, 0x12, 0x02, 0x5E, 0x90, 0x00, 0x02, 0xE4, 0x80, 0x21, 0xEF, 0xB4, 0x02, 
+0x20, 0x90, 0x8F, 0xBF, 0xD1, 0x7C, 0xEF, 0x12, 0xD5, 0xD2, 0x44, 0x20, 0x54, 0x7F, 0xD1, 0x7D, 
+0x90, 0x00, 0x01, 0xEF, 0x12, 0x02, 0x5E, 0x90, 0x8F, 0xBE, 0xE0, 0x90, 0x00, 0x02, 0x12, 0x02, 
+0x5E, 0xD1, 0x7E, 0xE9, 0x24, 0x03, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x02, 0x06, 0x44, 0x20, 0x12, 
+0x02, 0x4C, 0x90, 0x8F, 0xC0, 0xD1, 0x7C, 0x90, 0x00, 0x04, 0xEF, 0x12, 0x02, 0x5E, 0x90, 0x8F, 
+0xC1, 0xE0, 0x90, 0x00, 0x05, 0x12, 0x02, 0x5E, 0x90, 0x8F, 0xC2, 0xE0, 0x90, 0x00, 0x06, 0x12, 
+0x02, 0x5E, 0x90, 0x8F, 0xC3, 0xE0, 0x90, 0x00, 0x07, 0x02, 0x02, 0x5E, 0xE0, 0xFF, 0x90, 0x8F, 
+0xB9, 0x02, 0x86, 0xE0, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x02, 0x1F, 0x12, 0xD1, 0x65, 0x90, 
+0x92, 0x3D, 0xB1, 0x9C, 0xFF, 0xED, 0x2F, 0x90, 0x92, 0x3E, 0xD1, 0x85, 0xFF, 0xED, 0x2F, 0x90, 
+0x92, 0x3F, 0xF0, 0xB1, 0xA9, 0xFF, 0xED, 0x2F, 0x90, 0x92, 0x40, 0xF1, 0x02, 0xFF, 0xED, 0x2F, 
+0x90, 0x92, 0x41, 0x11, 0x3B, 0xFF, 0xED, 0x2F, 0x90, 0x92, 0x42, 0xF1, 0x4C, 0xFF, 0xAE, 0x05, 
+0xED, 0x2F, 0x90, 0x92, 0x43, 0xF0, 0x22, 0x12, 0xD1, 0x65, 0x90, 0x92, 0x44, 0xB1, 0x9C, 0xFF, 
+0xED, 0x2F, 0x90, 0x92, 0x45, 0xD1, 0x85, 0xFF, 0xED, 0x2F, 0x90, 0x92, 0x46, 0xF0, 0xB1, 0xA9, 
+0xFF, 0xED, 0x2F, 0x90, 0x92, 0x47, 0xF1, 0x02, 0xFF, 0xED, 0x2F, 0x90, 0x92, 0x48, 0x11, 0x3B, 
+0xFF, 0xED, 0x2F, 0x90, 0x92, 0x49, 0xF1, 0x4C, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x92, 0x4A, 
+0xF0, 0x22, 0xF0, 0x90, 0x00, 0x04, 0x02, 0x02, 0x1F, 0xF1, 0xF6, 0x12, 0xC4, 0x1B, 0xF1, 0xED, 
+0xFF, 0x54, 0x01, 0xFE, 0x12, 0x99, 0x51, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x2C, 0xB1, 
+0x9D, 0x90, 0x92, 0x53, 0xD1, 0x85, 0x90, 0x92, 0x54, 0xF0, 0x12, 0x02, 0x06, 0xFF, 0x54, 0x04, 
+0xFE, 0x90, 0x92, 0x52, 0xE0, 0x54, 0xFB, 0x4E, 0xF0, 0xB1, 0xA9, 0x90, 0x92, 0x55, 0xF0, 0xEF, 
+0x54, 0x08, 0xFF, 0x90, 0x92, 0x52, 0xE0, 0x54, 0xF7, 0x4F, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x06, 
+0x02, 0x02, 0x1F, 0x74, 0xBE, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0x22, 0x90, 0x8F, 
+0xF5, 0xED, 0xF0, 0x90, 0x8F, 0xF2, 0x12, 0x86, 0xE9, 0xE4, 0x90, 0x8F, 0xF6, 0xF0, 0xA3, 0xF0, 
+0x12, 0x02, 0x06, 0xFF, 0xB1, 0x9D, 0xFD, 0xF1, 0x03, 0xFB, 0x12, 0xBB, 0x1E, 0x90, 0x8F, 0xF6, 
+0xEF, 0xF0, 0x90, 0x8F, 0xF2, 0x12, 0x86, 0xE0, 0xF1, 0x03, 0xFF, 0x12, 0xCE, 0xBD, 0x90, 0x8F, 
+0xF7, 0xEF, 0xF0, 0x90, 0x91, 0xE4, 0xE0, 0x24, 0xFE, 0x60, 0x16, 0x24, 0xFE, 0x60, 0x12, 0x14, 
+0x60, 0x07, 0x14, 0x60, 0x04, 0x24, 0x05, 0x70, 0x43, 0x12, 0xD5, 0x2D, 0x12, 0xD1, 0x7F, 0x80, 
+0x0D, 0x12, 0xD5, 0x2D, 0x90, 0x91, 0xE4, 0xE0, 0x90, 0x8F, 0xBD, 0xF0, 0xB1, 0xAF, 0x90, 0x8F, 
+0xF7, 0xE0, 0xFF, 0x90, 0x8F, 0xF2, 0x12, 0x86, 0xE0, 0x90, 0x8F, 0xF6, 0xE0, 0x7C, 0x00, 0x29, 
+0xF9, 0xEC, 0x3A, 0xFA, 0xC3, 0xE9, 0x9F, 0xF9, 0xEA, 0x94, 0x00, 0xFA, 0x75, 0x1B, 0x01, 0x75, 
+0x1C, 0x91, 0x75, 0x1D, 0xB3, 0xA3, 0xE0, 0xF5, 0x1E, 0x12, 0x68, 0xAB, 0x22, 0x90, 0x92, 0x79, 
+0x12, 0x86, 0xE0, 0x02, 0x02, 0x06, 0x90, 0x92, 0x79, 0x02, 0x86, 0xE9, 0xE0, 0xFF, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x22, 0x8B, 0x0D, 0x8A, 0x0E, 0x89, 0x0F, 0x90, 0x92, 0x5C, 0xE0, 0x70, 0x0C, 
+0x12, 0xD6, 0x02, 0x30, 0xE0, 0x06, 0x90, 0x92, 0x62, 0x74, 0x01, 0xF0, 0x90, 0x92, 0x5E, 0xE0, 
+0x70, 0x0F, 0x11, 0x9C, 0xC4, 0x54, 0x0F, 0xFF, 0xBF, 0x05, 0x06, 0x90, 0x92, 0x63, 0x74, 0x01, 
+0xF0, 0xAB, 0x0D, 0xAA, 0x0E, 0xA9, 0x0F, 0x12, 0x95, 0x9D, 0xFF, 0xF5, 0x11, 0x12, 0x02, 0x06, 
+0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x96, 0x86, 0xF5, 0x12, 0x80, 0x02, 0x8F, 0x12, 0x85, 
+0x11, 0x10, 0xE5, 0x10, 0xD3, 0x95, 0x12, 0x50, 0x28, 0x11, 0x9C, 0x54, 0x01, 0xFD, 0xAF, 0x10, 
+0x12, 0x6E, 0x43, 0xAF, 0x10, 0x12, 0x77, 0x09, 0xEF, 0xAF, 0x10, 0x70, 0x04, 0x11, 0xAD, 0x80, 
+0x02, 0x11, 0xF8, 0x90, 0x92, 0x63, 0xE0, 0x60, 0x04, 0xAF, 0x10, 0x11, 0xAD, 0x05, 0x10, 0x80, 
+0xD1, 0xE5, 0x11, 0x70, 0x16, 0xFF, 0x12, 0x77, 0x09, 0xEF, 0x70, 0x0F, 0x12, 0xC0, 0x57, 0x12, 
+0x78, 0xD1, 0x12, 0xD6, 0x12, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 0xAB, 0x0D, 0xAA, 0x0E, 
+0xA9, 0x0F, 0x02, 0x02, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x6E, 0x43, 0xE4, 0xFF, 0x7D, 0x01, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x96, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x7D, 0x44, 
+0x7F, 0x6F, 0x12, 0x8F, 0xCF, 0x12, 0xB6, 0xA3, 0x90, 0x93, 0x97, 0xE0, 0x90, 0x93, 0x96, 0xB4, 
+0x01, 0x07, 0x11, 0xE9, 0x44, 0x04, 0xF0, 0x80, 0x05, 0x11, 0xE9, 0x54, 0xFB, 0xF0, 0xE4, 0xFD, 
+0xFF, 0x12, 0x8F, 0xCF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0xC4, 0x54, 0xF0, 0x24, 0x05, 0xF5, 
+0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0x22, 0xE4, 0xFD, 0x80, 0xB3, 0x90, 0x92, 0x52, 0xE0, 
+0xFD, 0x30, 0xE0, 0x4C, 0x90, 0x92, 0x57, 0xE0, 0xFC, 0x60, 0x45, 0x74, 0x01, 0x7E, 0x00, 0xA8, 
+0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 0xE0, 0xE0, 
+0xFB, 0xEF, 0x5B, 0x60, 0x0B, 0xE4, 0x90, 0x92, 0x57, 0xF0, 0x90, 0x92, 0x59, 0x04, 0xF0, 0x22, 
+0x90, 0x92, 0x54, 0xE0, 0xD3, 0x9C, 0x50, 0x13, 0xED, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 
+0x04, 0x11, 0xA5, 0x80, 0x02, 0x31, 0xD3, 0x31, 0x51, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xF1, 0xF8, 
+0x22, 0x90, 0x92, 0x52, 0xE0, 0x54, 0xFE, 0x22, 0x90, 0x92, 0x52, 0xE0, 0x30, 0xE0, 0x73, 0x90, 
+0x92, 0x56, 0xE0, 0x04, 0xF0, 0x90, 0x92, 0x59, 0xE0, 0x64, 0x01, 0x70, 0x30, 0x90, 0x92, 0x52, 
+0x12, 0xA7, 0xE2, 0x30, 0xE0, 0x27, 0x90, 0x92, 0x58, 0xE0, 0x70, 0x21, 0x90, 0x92, 0x55, 0xE0, 
+0xFE, 0xA3, 0xE0, 0xC3, 0x9E, 0x40, 0x16, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x07, 
+0x11, 0xA5, 0x31, 0x51, 0xF0, 0x80, 0x06, 0x31, 0xD3, 0x31, 0x51, 0xF0, 0x22, 0x90, 0x92, 0x56, 
+0xE0, 0xFF, 0x90, 0x92, 0x53, 0xE0, 0xD3, 0x9F, 0x50, 0x28, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 
+0x12, 0x90, 0x92, 0x58, 0xE0, 0x70, 0x0C, 0x7D, 0x08, 0xF1, 0xF8, 0x90, 0x92, 0x51, 0xE0, 0x04, 
+0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0x92, 0x56, 0xF0, 0x90, 0x92, 
+0x58, 0xF0, 0x22, 0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0x7F, 0x01, 0x90, 0x93, 0xA2, 0xEF, 0xF0, 
+0x90, 0x89, 0x82, 0xE0, 0x64, 0x02, 0x70, 0x1D, 0x90, 0x93, 0xA2, 0xE0, 0xFD, 0x64, 0x01, 0x70, 
+0x2C, 0xF1, 0x81, 0xF1, 0x89, 0x30, 0xE0, 0x09, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x80, 
+0x1C, 0xAF, 0x05, 0x80, 0x15, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x12, 0xD5, 0x12, 0x90, 0x06, 
+0x90, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x93, 0xA2, 0xE0, 0xFF, 0x12, 0xBF, 0x0F, 0x31, 0x51, 0xF0, 
+0x90, 0x90, 0x08, 0xE0, 0x54, 0xBF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 
+0x90, 0x8F, 0x8A, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0x12, 0xA8, 0x9D, 0x90, 0x8F, 0x92, 0xF0, 
+0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0xC4, 0x74, 0x28, 0xF0, 0x74, 0x9A, 0xA3, 0xF0, 0x12, 0xC7, 
+0x04, 0x12, 0xBC, 0x14, 0x90, 0x8F, 0x80, 0x12, 0xC6, 0xFB, 0x90, 0x8F, 0x89, 0xF0, 0x90, 0x90, 
+0x08, 0xE0, 0x20, 0xE0, 0x02, 0x81, 0xB2, 0xE4, 0x90, 0x8F, 0x88, 0xF0, 0x90, 0x8F, 0x89, 0xE0, 
+0xFF, 0x90, 0x8F, 0x88, 0xE0, 0xC3, 0x9F, 0x40, 0x02, 0x81, 0xB2, 0xF1, 0xD6, 0xEC, 0xFF, 0x90, 
+0xFD, 0x11, 0xF0, 0x90, 0x8F, 0x92, 0xEF, 0xF0, 0x12, 0xD4, 0x79, 0x54, 0x3F, 0xFE, 0x90, 0x8F, 
+0x82, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8F, 0x8E, 0xEE, 0x12, 0xD4, 0x54, 0xFE, 0xEF, 0x24, 0x18, 
+0x2E, 0xFF, 0x90, 0x8F, 0x93, 0xF0, 0x90, 0x8F, 0x81, 0xE0, 0x2F, 0xFF, 0x90, 0x8F, 0x80, 0xE0, 
+0x34, 0x00, 0xFE, 0x90, 0x8F, 0x84, 0xF1, 0xCD, 0xC0, 0x07, 0x91, 0xC3, 0x7D, 0x01, 0x12, 0x52, 
+0xBD, 0xC0, 0x07, 0x91, 0xC3, 0x7D, 0x04, 0x12, 0x52, 0xBD, 0xAB, 0x07, 0xD0, 0x05, 0xD0, 0x07, 
+0x12, 0xBB, 0x1E, 0x90, 0x8F, 0x8A, 0xEF, 0x91, 0xC2, 0xE4, 0xFD, 0x12, 0x52, 0xBD, 0xEF, 0x54, 
+0xFC, 0x90, 0x8F, 0x86, 0xF0, 0x90, 0x8F, 0x93, 0xE0, 0xFF, 0x90, 0x8F, 0x82, 0xE4, 0x8F, 0xF0, 
+0x12, 0x02, 0xE7, 0xF1, 0xDF, 0x12, 0xC5, 0xCD, 0x90, 0x8F, 0x82, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x8F, 0x80, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x0F, 0x12, 0x52, 0xBD, 0x90, 0x8F, 0x87, 
+0xEF, 0xF0, 0x7D, 0x01, 0x12, 0xD1, 0x2E, 0xF1, 0xDF, 0x90, 0x8F, 0x80, 0x12, 0xC7, 0x76, 0xF1, 
+0xD6, 0xD3, 0x9F, 0xEC, 0x9E, 0x40, 0x0F, 0x12, 0xC7, 0x85, 0xED, 0x9F, 0xFF, 0xEC, 0x9E, 0x90, 
+0x8F, 0x80, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8F, 0x86, 0xE0, 0x24, 0xF8, 0x60, 0x37, 0x24, 0x80, 
+0x60, 0x33, 0x24, 0xC8, 0x60, 0x06, 0x24, 0x20, 0x60, 0x02, 0x81, 0x47, 0x90, 0x90, 0x0B, 0xF1, 
+0x8C, 0x20, 0xE0, 0x02, 0x81, 0x47, 0x90, 0x90, 0x1E, 0xE0, 0x04, 0x91, 0xC2, 0x12, 0xCA, 0x4E, 
+0xEF, 0x70, 0x02, 0x81, 0x47, 0x90, 0x8F, 0x86, 0xE0, 0xFF, 0x12, 0xCA, 0x3C, 0x90, 0x90, 0x1F, 
+0xE0, 0x04, 0xF0, 0x81, 0x47, 0x90, 0x90, 0x08, 0x12, 0xB5, 0x41, 0x30, 0xE0, 0x59, 0x90, 0x8F, 
+0x8A, 0xE0, 0xFF, 0x90, 0x8F, 0x85, 0xE0, 0x2F, 0xFF, 0x90, 0x8F, 0x84, 0xE0, 0x34, 0x00, 0xCF, 
+0x24, 0x08, 0xCF, 0x34, 0x00, 0xFE, 0x90, 0x8F, 0x90, 0xF1, 0xCD, 0xEF, 0x64, 0x45, 0x70, 0x37, 
+0x91, 0xCD, 0x12, 0xD1, 0xE3, 0xEF, 0x64, 0x01, 0x70, 0x2D, 0x91, 0xCD, 0xF1, 0x94, 0xEF, 0x64, 
+0x01, 0x70, 0x24, 0x90, 0x8F, 0x94, 0x04, 0x91, 0xCC, 0xA3, 0xE0, 0xFD, 0x12, 0xCE, 0x2F, 0xEF, 
+0x70, 0x0D, 0x90, 0x8F, 0x92, 0xE0, 0xFD, 0x90, 0xFD, 0x11, 0x91, 0xCC, 0x12, 0xCD, 0xF4, 0x90, 
+0x8F, 0x92, 0xE0, 0x90, 0xFD, 0x11, 0xF0, 0x91, 0xC3, 0x12, 0xCA, 0x4E, 0xEF, 0x60, 0x20, 0x91, 
+0xC3, 0x90, 0x8F, 0x8A, 0xE0, 0xFD, 0x90, 0x8F, 0x8D, 0xE0, 0xFB, 0x90, 0x8F, 0x92, 0xE0, 0x90, 
+0x92, 0xB7, 0xF0, 0x12, 0xB5, 0x48, 0xEF, 0x60, 0x06, 0x90, 0x8F, 0x94, 0x74, 0x01, 0xF0, 0x90, 
+0x90, 0x08, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x12, 0x91, 0xC3, 0x90, 0x8F, 0x8A, 0xE0, 0xFD, 0xD1, 
+0x3F, 0xEF, 0x60, 0x06, 0x90, 0x8F, 0x94, 0x74, 0x01, 0xF0, 0x90, 0x90, 0x08, 0xE0, 0x13, 0x13, 
+0x54, 0x3F, 0x30, 0xE0, 0x0A, 0x91, 0xC3, 0x90, 0x8F, 0x8A, 0xE0, 0xFD, 0x12, 0xCB, 0xD6, 0x90, 
+0x90, 0x08, 0xF1, 0x8C, 0x30, 0xE0, 0x10, 0x90, 0x8F, 0x94, 0xE0, 0x70, 0x0A, 0x91, 0xC3, 0x90, 
+0x8F, 0x8A, 0xE0, 0xFD, 0x12, 0xCA, 0x96, 0x90, 0x8F, 0x87, 0xE0, 0xFF, 0x7D, 0x02, 0x12, 0xD1, 
+0x2E, 0x30, 0xE0, 0x04, 0x7F, 0x01, 0x31, 0xDB, 0x12, 0xCA, 0x25, 0xEF, 0x64, 0x01, 0x70, 0x36, 
+0x90, 0x90, 0x20, 0xE0, 0x04, 0xF0, 0x12, 0xC7, 0xBB, 0xAD, 0x07, 0xEF, 0x64, 0x01, 0x60, 0x1E, 
+0xF1, 0x81, 0xED, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x42, 0xF0, 0x80, 0x0A, 0xED, 0xB4, 
+0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x43, 0xF0, 0x7F, 0x01, 0x31, 0xDB, 0x80, 0x24, 0x90, 0x8F, 
+0x80, 0x12, 0xC7, 0xA8, 0x80, 0x14, 0x90, 0x90, 0x0A, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x20, 0xE0, 
+0x11, 0x90, 0x90, 0x08, 0xE0, 0x54, 0xFE, 0xF0, 0x80, 0x08, 0x90, 0x8F, 0x88, 0xE0, 0x04, 0xF0, 
+0x41, 0x6C, 0x74, 0x28, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x9A, 0xA3, 0xF0, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xF0, 0x90, 0x8F, 0x84, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xF0, 0x90, 0x8F, 0x90, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x06, 0x31, 
+0xE0, 0x54, 0xEF, 0x44, 0x08, 0xF0, 0xED, 0x2F, 0xFF, 0xE4, 0x3E, 0xFE, 0x7C, 0x00, 0xEF, 0x24, 
+0x08, 0xFF, 0xEC, 0x3E, 0x90, 0x92, 0xBC, 0xF0, 0xA3, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x83, 0x7D, 
+0x00, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x19, 0x12, 0x04, 0x7A, 0x90, 0x92, 0xBD, 0xE0, 0x24, 0x01, 
+0xD1, 0x30, 0xD1, 0x2A, 0x90, 0x91, 0x1A, 0xD1, 0x38, 0x24, 0x04, 0xD1, 0x30, 0xD1, 0x2A, 0x90, 
+0x91, 0x1D, 0xD1, 0x38, 0x24, 0x05, 0xD1, 0x30, 0xD1, 0x2A, 0x90, 0x91, 0x1E, 0xD1, 0x38, 0x24, 
+0x06, 0xD1, 0x30, 0xD1, 0x2A, 0x90, 0x91, 0x1F, 0xD1, 0x38, 0x24, 0x07, 0xD1, 0x30, 0xD1, 0x2A, 
+0x90, 0x91, 0x20, 0xD1, 0x38, 0x24, 0x08, 0xD1, 0x30, 0xD1, 0x2A, 0x90, 0x91, 0x21, 0xEF, 0xF0, 
+0xE4, 0x90, 0x92, 0xBB, 0xF0, 0x90, 0x92, 0xBB, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 0x1D, 0x90, 
+0x92, 0xBD, 0xE0, 0x24, 0x09, 0xFD, 0x90, 0x92, 0xBC, 0xE0, 0xD1, 0x20, 0x90, 0x92, 0xBB, 0xE0, 
+0x24, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0x12, 0xD5, 0x4F, 0x80, 0xD9, 0xE4, 0x90, 0x92, 0xBB, 
+0xF0, 0x90, 0x92, 0xBB, 0xE0, 0xFF, 0xC3, 0x94, 0x20, 0x50, 0x1D, 0x90, 0x92, 0xBD, 0xE0, 0x24, 
+0x63, 0xFD, 0x90, 0x92, 0xBC, 0xE0, 0xD1, 0x20, 0x90, 0x92, 0xBB, 0xE0, 0x24, 0x7C, 0xF5, 0x82, 
+0xE4, 0x34, 0x91, 0x12, 0xD5, 0x4F, 0x80, 0xD9, 0x90, 0x91, 0x1E, 0x12, 0xD5, 0xEA, 0x90, 0x92, 
+0xB9, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x30, 0xE3, 0x0C, 0x7F, 0x01, 0x31, 0xDB, 0x90, 0x01, 0xC7, 
+0x74, 0x03, 0xF0, 0x80, 0x3F, 0x90, 0x92, 0xB9, 0xA3, 0xE0, 0xFF, 0x7C, 0x00, 0x54, 0x07, 0xFD, 
+0x64, 0x01, 0x60, 0x05, 0xED, 0x64, 0x02, 0x70, 0x2B, 0xED, 0x64, 0x02, 0x4C, 0x70, 0x25, 0xEF, 
+0x54, 0x30, 0xFF, 0xE4, 0xC4, 0xF8, 0x54, 0xF0, 0xC8, 0xEF, 0xC4, 0x54, 0x0F, 0x48, 0x90, 0x91, 
+0xB2, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xE4, 0xFD, 0x12, 0xAA, 0xC0, 0x90, 0x06, 0x31, 0xE0, 0x54, 
+0xF7, 0x44, 0x10, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x92, 0xB5, 0xE0, 0xFD, 
+0x90, 0x92, 0xB4, 0xE0, 0x2D, 0xFD, 0x90, 0x92, 0xB3, 0xE0, 0x34, 0x00, 0xCD, 0x24, 0x10, 0xCD, 
+0x34, 0x00, 0xFC, 0x7E, 0x00, 0xED, 0x2F, 0xFF, 0xEE, 0x3C, 0xFE, 0xE4, 0xFD, 0x02, 0x52, 0xBD, 
+0xFF, 0x90, 0x92, 0xBC, 0xE0, 0x34, 0x00, 0x22, 0xEF, 0xF0, 0x90, 0x92, 0xBD, 0xE0, 0x22, 0x12, 
+0xCD, 0xB0, 0x12, 0xCE, 0x9C, 0x7A, 0x81, 0x79, 0x80, 0xF1, 0xF1, 0x78, 0xC2, 0x7C, 0x92, 0x7D, 
+0x01, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0x86, 0xF1, 0xC6, 0x78, 0xC6, 0x7C, 0x92, 0x7D, 0x01, 0x7B, 
+0xFF, 0x7A, 0x81, 0x79, 0x8A, 0xF1, 0xC6, 0xE4, 0x90, 0x92, 0xCB, 0xF0, 0xF1, 0x6E, 0xCF, 0x24, 
+0x06, 0xCF, 0x34, 0x00, 0xD1, 0x2A, 0xEF, 0x64, 0x08, 0x60, 0x02, 0xE1, 0x5D, 0xF1, 0x6E, 0xCF, 
+0x24, 0x07, 0xCF, 0x34, 0x00, 0xD1, 0x2A, 0xEF, 0x64, 0x06, 0x60, 0x02, 0xE1, 0x5D, 0x90, 0x92, 
+0xCB, 0x04, 0xF0, 0xE4, 0x90, 0x92, 0xCA, 0xF0, 0x12, 0xD5, 0xB0, 0x50, 0x17, 0x90, 0x92, 0xB4, 
+0xE0, 0x24, 0x0A, 0xFD, 0x90, 0x92, 0xB3, 0xE0, 0xD1, 0x20, 0x90, 0x92, 0xCA, 0x12, 0xCE, 0x93, 
+0xF1, 0x63, 0x80, 0xE4, 0x12, 0xCB, 0xCF, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x18, 0x12, 0xCE, 0xA5, 
+0x60, 0x02, 0xE1, 0x5D, 0x90, 0x92, 0xCA, 0xF0, 0xF1, 0xE8, 0x50, 0x19, 0x12, 0xCD, 0xA4, 0xF1, 
+0x79, 0xCD, 0x24, 0x20, 0xD1, 0x1F, 0x90, 0x92, 0xCA, 0xE0, 0x24, 0xC6, 0xF5, 0x82, 0xE4, 0x34, 
+0x92, 0xF1, 0x63, 0x80, 0xE3, 0x78, 0xC6, 0x7C, 0x92, 0x12, 0xCE, 0xAE, 0xEF, 0x70, 0x65, 0x90, 
+0x06, 0x30, 0xE0, 0x44, 0x01, 0x54, 0xDF, 0xF0, 0x90, 0x90, 0x0A, 0xE0, 0x30, 0xE0, 0x09, 0x90, 
+0x01, 0xC7, 0x74, 0x09, 0xF1, 0x80, 0x80, 0x55, 0xE4, 0x90, 0x92, 0xCA, 0xF0, 0x12, 0xD5, 0xB0, 
+0x50, 0x0C, 0xD1, 0x0B, 0x90, 0x92, 0xCA, 0x12, 0xCE, 0x8A, 0xF1, 0x63, 0x80, 0xEF, 0xE4, 0x90, 
+0x92, 0xCA, 0xF0, 0xF1, 0xE8, 0x50, 0x19, 0x12, 0xCD, 0xA4, 0xF1, 0x79, 0xCD, 0x24, 0x16, 0xD1, 
+0x1F, 0x90, 0x92, 0xCA, 0xE0, 0x24, 0xC2, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF1, 0x63, 0x80, 0xE3, 
+0x7B, 0x01, 0x7A, 0x92, 0x79, 0xBC, 0x12, 0xD5, 0x21, 0xA3, 0xF0, 0x7A, 0x92, 0x79, 0xC2, 0x12, 
+0x8E, 0x0B, 0x80, 0x09, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x21, 0x54, 0xEF, 0xF0, 0x90, 0x92, 0xCB, 
+0xE0, 0xFF, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x92, 0xCA, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x92, 
+0xB5, 0xE0, 0xFF, 0x90, 0x92, 0xB4, 0xE0, 0x2F, 0xFF, 0x90, 0x92, 0xB3, 0xE0, 0x34, 0x00, 0x22, 
+0xF0, 0x90, 0x90, 0x11, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x90, 0x0C, 0xE0, 0xC4, 0x13, 0x13, 
+0x13, 0x54, 0x01, 0x22, 0x12, 0xD2, 0x1E, 0x24, 0x16, 0xFF, 0xE4, 0x3E, 0xD1, 0x2A, 0x90, 0x91, 
+0xF5, 0xA3, 0xE0, 0xB5, 0x07, 0x1A, 0x90, 0x92, 0xB4, 0xE0, 0x24, 0x16, 0xF1, 0x78, 0xFE, 0x7D, 
+0x01, 0x12, 0x52, 0xBD, 0xEF, 0xFD, 0x90, 0x91, 0xF5, 0xE0, 0x6D, 0x70, 0x01, 0xE4, 0x60, 0x03, 
+0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0x7E, 0x00, 0x7F, 0x04, 0x02, 0x01, 0xE0, 0xF0, 0xA3, 0xEF, 
+0xF0, 0xE4, 0xFD, 0x02, 0x52, 0xBD, 0x90, 0x8F, 0x80, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x22, 0x90, 
+0x8F, 0x82, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x90, 0x92, 0xCA, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 
+0x22, 0x7E, 0x00, 0x7F, 0x06, 0x02, 0x01, 0xE0, 0xFF, 0x12, 0x6F, 0x06, 0x90, 0x92, 0x57, 0xE0, 
+0x04, 0xF0, 0x22, 0x12, 0x02, 0x06, 0xFF, 0x90, 0x90, 0x03, 0xF0, 0xBF, 0x01, 0x08, 0x12, 0x8B, 
+0xE0, 0xE4, 0x90, 0x90, 0x03, 0xF0, 0x22, 0x12, 0x02, 0x06, 0x54, 0x01, 0xFF, 0x90, 0x92, 0x74, 
+0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x02, 0x06, 0x90, 0x8A, 0xE9, 0xF0, 0x60, 0x2E, 0xA3, 
+0xE0, 0x20, 0xE0, 0x29, 0xE4, 0xFD, 0x7F, 0x04, 0x11, 0x62, 0x12, 0xC3, 0xB4, 0x30, 0xE0, 0x1D, 
+0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x20, 0xE0, 0x14, 0x90, 0x8A, 0xE8, 0xE0, 0x13, 0x13, 0x54, 
+0x3F, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 0x7F, 0x09, 0x12, 0x71, 0x29, 0x22, 0x7D, 0x01, 
+0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0xA5, 0xED, 0xF0, 0x90, 0x8A, 
+0x7E, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x21, 0xBB, 0xEE, 0x12, 0x9F, 
+0x8D, 0x30, 0xE0, 0x02, 0x21, 0xBB, 0x90, 0x8A, 0x86, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x21, 0xBB, 
+0xEF, 0x70, 0x02, 0x21, 0x28, 0x24, 0xFE, 0x70, 0x02, 0x21, 0x65, 0x24, 0xFE, 0x60, 0x4D, 0x24, 
+0xFC, 0x70, 0x02, 0x21, 0xA4, 0x24, 0xFC, 0x60, 0x02, 0x21, 0xB5, 0xEE, 0xB4, 0x0E, 0x03, 0x12, 
+0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 0x86, 
+0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x04, 0x0F, 0x90, 0x93, 
+0xA5, 0xE0, 0xFF, 0x60, 0x05, 0x12, 0x6C, 0x1E, 0x80, 0x03, 0x12, 0x78, 0xD1, 0x90, 0x8A, 0x86, 
+0xE0, 0x64, 0x08, 0x60, 0x02, 0x21, 0xB5, 0x12, 0x7A, 0x3E, 0x21, 0xB5, 0x90, 0x8A, 0x86, 0xE0, 
+0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 
+0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 0x31, 0xC0, 0xBF, 0x01, 0x03, 0x12, 0x74, 0x33, 
+0x90, 0x8A, 0x86, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x21, 0xB5, 0x31, 0xC0, 0xEF, 0x64, 0x01, 0x60, 
+0x02, 0x21, 0xB5, 0x12, 0x6D, 0x38, 0x21, 0xB5, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 0x31, 
+0xC0, 0xBF, 0x01, 0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 
+0xCB, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x08, 0x31, 0xC0, 0xBF, 0x01, 0x03, 0x12, 0x6D, 0x38, 
+0x90, 0x8A, 0x86, 0xE0, 0x64, 0x04, 0x70, 0x5D, 0x12, 0xD2, 0x27, 0xEF, 0x64, 0x01, 0x70, 0x55, 
+0x12, 0x77, 0x7E, 0x80, 0x50, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0E, 0x08, 0x31, 0xC0, 0xBF, 0x01, 
+0x03, 0x12, 0x74, 0x33, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x06, 0x03, 0x12, 0x73, 0xCB, 0x90, 0x8A, 
+0x86, 0xE0, 0xB4, 0x0C, 0x08, 0x31, 0xC0, 0xBF, 0x01, 0x03, 0x12, 0x6D, 0x38, 0x90, 0x8A, 0x86, 
+0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x04, 0x16, 0x12, 
+0x79, 0x64, 0x80, 0x11, 0x90, 0x8A, 0x86, 0xE0, 0xB4, 0x0C, 0x0A, 0x71, 0x2C, 0x54, 0x3F, 0x30, 
+0xE0, 0x03, 0x12, 0x79, 0xE1, 0x90, 0x8A, 0x86, 0x12, 0xD4, 0xE5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x10, 0x90, 0x8A, 
+0xF0, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x12, 0x75, 0x5D, 0x10, 0x80, 0x2D, 0x12, 0x79, 
+0x80, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x75, 0x5D, 0x01, 0x80, 0x20, 0x90, 0x8A, 0x7E, 0x12, 0xC3, 
+0xBF, 0x30, 0xE0, 0x05, 0x75, 0x5D, 0x02, 0x80, 0x12, 0x90, 0x8A, 0x85, 0xE0, 0xD3, 0x94, 0x04, 
+0x40, 0x05, 0x75, 0x5D, 0x08, 0x80, 0x04, 0xF1, 0xE9, 0x80, 0x0E, 0x90, 0x01, 0xB9, 0x74, 0x02, 
+0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x5D, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8A, 
+0xEA, 0xE0, 0x20, 0xE0, 0x26, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x01, 0x70, 0x1E, 0x12, 0x70, 0x76, 
+0xB1, 0x66, 0x60, 0x0F, 0xE4, 0xFD, 0x7F, 0x0C, 0x11, 0x62, 0xE4, 0xFD, 0xFF, 0x12, 0x8F, 0xCF, 
+0x02, 0x69, 0xD6, 0x90, 0x8A, 0x86, 0xE0, 0x70, 0x02, 0x11, 0x5E, 0x22, 0xE4, 0xF5, 0x14, 0x90, 
+0x8A, 0x83, 0xE0, 0x60, 0x71, 0x91, 0x7D, 0x70, 0x6D, 0xF1, 0xBA, 0xD1, 0x1C, 0x60, 0x22, 0x24, 
+0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0x8A, 0x8A, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 
+0x90, 0x8A, 0x8C, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x8A, 0x89, 0xE0, 0xA3, 0xF0, 0x80, 
+0x00, 0x75, 0x14, 0x01, 0xE5, 0x14, 0x60, 0x3E, 0x90, 0x8A, 0x86, 0xE0, 0x20, 0xE2, 0x02, 0x11, 
+0x5E, 0xD1, 0x2C, 0x90, 0x8A, 0x8C, 0xE0, 0x60, 0x04, 0x64, 0x01, 0x70, 0x13, 0xE4, 0x90, 0x8E, 
+0xF6, 0xF0, 0x90, 0x8A, 0x8C, 0xE0, 0x51, 0xC7, 0x51, 0xE3, 0x90, 0x8A, 0x8C, 0xE0, 0x80, 0x0D, 
+0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x51, 0xCE, 0x51, 0xC7, 0x51, 0xE3, 0x51, 0xCE, 0x51, 0xC7, 0x90, 
+0x8A, 0x9C, 0xF0, 0x12, 0x70, 0x76, 0x22, 0xFF, 0x90, 0x8A, 0x8B, 0xE0, 0x2F, 0x22, 0x90, 0x8A, 
+0x8C, 0xE0, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0x22, 0xF0, 0xE4, 0x90, 0x8E, 0xF6, 0xF0, 0x90, 
+0x8A, 0xE1, 0xE0, 0x90, 0x8E, 0xF7, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x02, 0x5E, 
+0xAD, 0xE4, 0x90, 0x93, 0x74, 0xF0, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x2F, 0x91, 0x7D, 0x70, 0x2B, 
+0xD1, 0x24, 0xF0, 0xF1, 0xBA, 0x90, 0x93, 0x74, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x8A, 0x8A, 0xF0, 
+0x04, 0x60, 0x18, 0x90, 0x8A, 0x86, 0xE0, 0x20, 0xE2, 0x02, 0x11, 0x5E, 0xD1, 0x2C, 0xE4, 0x90, 
+0x8E, 0xF6, 0xF0, 0x90, 0x8A, 0x8B, 0x51, 0xE2, 0x12, 0x70, 0x76, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 
+0xFF, 0x13, 0x13, 0x22, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 
+0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 0xD5, 0x95, 0x91, 0x7D, 0x60, 0x02, 
+0x81, 0x20, 0x90, 0x8A, 0x83, 0xE0, 0x70, 0x02, 0x81, 0x20, 0x90, 0x05, 0x63, 0xE0, 0x90, 0x8A, 
+0xD2, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0x90, 0x8A, 0xD3, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0x90, 0x8A, 
+0xD4, 0xF0, 0x90, 0x05, 0x60, 0xE0, 0x90, 0x8A, 0xD5, 0xF0, 0xB1, 0x98, 0xF0, 0x90, 0x8A, 0x87, 
+0xE0, 0x54, 0xEC, 0xF0, 0x91, 0x86, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x02, 0x91, 0x9E, 0x91, 0x86, 
+0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x8A, 0x8A, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 
+0x90, 0x8A, 0x89, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x8A, 0x89, 0xE0, 0xFE, 0xFF, 0x80, 
+0x00, 0x90, 0x8A, 0x8A, 0xEF, 0xF0, 0x12, 0x33, 0x5F, 0xE4, 0x90, 0x8A, 0x8C, 0xF0, 0x12, 0xD4, 
+0x29, 0x71, 0x2C, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x50, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 
+0xE0, 0x1F, 0x91, 0x75, 0x6F, 0x70, 0x42, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x40, 0xF0, 0xD1, 0x24, 
+0x91, 0x21, 0x12, 0x7B, 0x2A, 0xF1, 0x6B, 0xD1, 0x0E, 0x90, 0x8A, 0x8A, 0xE0, 0x14, 0xF0, 0x80, 
+0x28, 0xD1, 0x1C, 0x64, 0x01, 0x70, 0x22, 0x91, 0x75, 0xFE, 0x6F, 0x60, 0x1C, 0x90, 0x05, 0x73, 
+0xE0, 0xFF, 0xEE, 0x6F, 0x60, 0x13, 0x71, 0x2C, 0x54, 0x3F, 0x30, 0xE0, 0x0C, 0xEF, 0x54, 0xBF, 
+0x91, 0x21, 0x12, 0x7A, 0xEE, 0xD1, 0x15, 0xB1, 0xE0, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x04, 0xF0, 
+0x22, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xEF, 0x64, 0x01, 0x70, 0x19, 0x91, 0x6D, 0x60, 0x09, 0x91, 0x25, 0x12, 0x7B, 
+0x2A, 0xD1, 0x34, 0x80, 0x07, 0x91, 0x25, 0x12, 0x7A, 0xEE, 0xF1, 0x64, 0x12, 0x79, 0xE1, 0x80, 
+0x17, 0x91, 0x6D, 0x60, 0x07, 0x91, 0x25, 0x12, 0x7B, 0x2A, 0x80, 0x05, 0x91, 0x25, 0x12, 0x7A, 
+0xEE, 0xB1, 0xE0, 0xD1, 0x15, 0x12, 0x7A, 0x3E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 0x06, 
+0xE0, 0x90, 0x01, 0x3F, 0x22, 0x90, 0x8A, 0x89, 0xE0, 0xFF, 0xA3, 0xE0, 0x22, 0xE4, 0xFF, 0x12, 
+0x77, 0x09, 0xEF, 0x64, 0x01, 0x22, 0x90, 0x8A, 0x81, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x91, 
+0x7D, 0x70, 0x0A, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x04, 0xB1, 0x98, 0x51, 0xD9, 0x22, 0x90, 0x06, 
+0xA9, 0xE0, 0xF5, 0x14, 0x54, 0xC0, 0x70, 0x07, 0x91, 0xEF, 0x54, 0xFD, 0xF0, 0xA1, 0x75, 0xE5, 
+0x14, 0x30, 0xE6, 0x1F, 0x90, 0x8A, 0x83, 0xE0, 0x64, 0x01, 0x70, 0x19, 0x90, 0x8A, 0x87, 0xE0, 
+0x44, 0x01, 0xF0, 0xB1, 0x66, 0x64, 0x02, 0x60, 0x05, 0x12, 0x72, 0xB9, 0x80, 0x07, 0x12, 0x78, 
+0x92, 0x80, 0x02, 0x91, 0xEF, 0xE5, 0x14, 0x90, 0x8A, 0x87, 0x30, 0xE7, 0x0D, 0xE0, 0x44, 0x02, 
+0x51, 0xD9, 0x90, 0x8A, 0x7E, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 
+0x8A, 0x87, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x71, 0x2C, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x0B, 0xEF, 
+0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0xD1, 0x0E, 0x90, 0x8A, 0x7E, 0xF1, 0xE2, 0x30, 
+0xE0, 0x09, 0xEF, 0xF1, 0x4D, 0x54, 0x07, 0x70, 0x4C, 0x80, 0x48, 0x90, 0x8A, 0x8C, 0xE0, 0x04, 
+0xF0, 0x90, 0x8A, 0x87, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x8A, 0xE0, 0xE0, 0xFF, 0x90, 0x8A, 0x8C, 
+0xE0, 0xD3, 0x9F, 0x40, 0x2E, 0x91, 0x7D, 0x70, 0x2C, 0xB1, 0x66, 0x70, 0x05, 0x12, 0x68, 0x5F, 
+0x80, 0x2B, 0x12, 0x68, 0x5F, 0x90, 0x8A, 0x8D, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 
+0x09, 0xB1, 0x6D, 0xE4, 0x90, 0x8A, 0x8D, 0xF0, 0x80, 0x03, 0x12, 0x78, 0x92, 0xE4, 0x90, 0x8A, 
+0x8C, 0xF0, 0x22, 0xB1, 0x75, 0x22, 0x90, 0x8A, 0x81, 0xE0, 0x54, 0x0F, 0x22, 0x90, 0x8A, 0x7F, 
+0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x8A, 0x85, 0xE0, 0xFF, 0x7D, 0x01, 0x01, 0x62, 0x91, 0x7D, 
+0x70, 0x15, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0F, 0xB1, 0x98, 0xF0, 0x90, 0x8A, 0x7E, 0xE0, 0xF1, 
+0x4D, 0x54, 0x07, 0x70, 0x02, 0xB1, 0x75, 0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 
+0x74, 0x02, 0x22, 0x90, 0x8A, 0x7E, 0x12, 0x97, 0xFC, 0x30, 0xE0, 0x2F, 0xEF, 0x54, 0xBF, 0x12, 
+0xD5, 0xC1, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x0A, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 
+0xD4, 0xC7, 0x74, 0x04, 0xF0, 0x90, 0x8A, 0xF0, 0xE0, 0xFF, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x08, 0x7D, 0x01, 0x7F, 0x0C, 0x11, 0x62, 0x80, 0x02, 0xB1, 0x75, 0xE4, 0xFF, 0x02, 0x98, 0xFC, 
+0x7D, 0x02, 0x7F, 0x02, 0x02, 0x7B, 0x97, 0x51, 0xF1, 0xB1, 0xE0, 0x7F, 0x01, 0xD1, 0x46, 0x12, 
+0x7A, 0x10, 0x90, 0x90, 0x04, 0xE0, 0x30, 0xE0, 0x14, 0xD1, 0x34, 0x90, 0x90, 0x07, 0xE0, 0x60, 
+0x05, 0x14, 0xF0, 0x02, 0x79, 0xE1, 0x12, 0xA8, 0x13, 0xE4, 0xFF, 0x91, 0x2C, 0x22, 0x7D, 0x02, 
+0x7F, 0x02, 0x02, 0x7B, 0x53, 0x7D, 0x01, 0x7F, 0x02, 0x02, 0x7B, 0x97, 0x90, 0x8A, 0x81, 0xE0, 
+0xC4, 0x54, 0x0F, 0x22, 0x90, 0x8A, 0x89, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x90, 0x8A, 0x87, 0xE0, 
+0x44, 0x10, 0xF0, 0x22, 0x90, 0x90, 0x06, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x51, 0x4C, 0xE4, 
+0xFF, 0xD1, 0x46, 0x02, 0x7A, 0x10, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 0x80, 
+0xE0, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x1E, 0x90, 0x93, 0x74, 0x74, 0x1E, 0xF0, 0x90, 0x93, 0x82, 
+0x74, 0x01, 0xF0, 0x90, 0x93, 0x76, 0xEF, 0xF0, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x74, 0x12, 0x5A, 
+0x18, 0x7F, 0x04, 0xF1, 0x35, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 
+0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 
+0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x7A, 0xF0, 0x74, 0xA6, 0xA3, 
+0xF0, 0x12, 0x70, 0xEE, 0xE5, 0x4B, 0x30, 0xE3, 0x02, 0xF1, 0x58, 0xE5, 0x4B, 0x30, 0xE4, 0x02, 
+0xF1, 0x30, 0xE5, 0x4B, 0x30, 0xE5, 0x03, 0x12, 0xC8, 0xB6, 0xE5, 0x4D, 0x30, 0xE0, 0x02, 0xD1, 
+0x3D, 0xE5, 0x4D, 0x30, 0xE1, 0x03, 0x12, 0xB8, 0x71, 0xE5, 0x4D, 0x30, 0xE2, 0x02, 0xF1, 0x88, 
+0xE5, 0x4D, 0x30, 0xE3, 0x02, 0x91, 0x8F, 0xE5, 0x4D, 0x30, 0xE4, 0x02, 0xB1, 0x7E, 0xE5, 0x4D, 
+0x30, 0xE5, 0x02, 0xF1, 0x9F, 0xE5, 0x4D, 0x30, 0xE6, 0x02, 0xF1, 0x19, 0xE5, 0x4E, 0x30, 0xE1, 
+0x02, 0xF1, 0x44, 0x74, 0x7A, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xA6, 0xA3, 0xF0, 0xD0, 0x07, 
+0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 
+0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xFF, 0x12, 0x77, 0x09, 0xBF, 0x01, 
+0x0E, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x08, 0x91, 0xEF, 0x54, 0x07, 0x70, 0x02, 0xB1, 0x75, 0x22, 
+0x12, 0x3A, 0xE3, 0x7F, 0x02, 0x8F, 0x17, 0x7F, 0x02, 0x12, 0x86, 0x27, 0x90, 0x89, 0x7E, 0xE0, 
+0x45, 0x17, 0xF0, 0x22, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x02, 0x51, 0x1E, 0x22, 0x54, 0xFB, 0xF0, 
+0x90, 0x8A, 0x87, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x90, 0x08, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 
+0x10, 0xF1, 0x35, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x7B, 0x53, 0x7D, 0x01, 0x7F, 0x02, 0x02, 
+0x7B, 0x53, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0F, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 
+0x69, 0xD6, 0x12, 0xD6, 0x12, 0xB1, 0x75, 0x22, 0x90, 0x92, 0x58, 0xE0, 0x04, 0xF0, 0x90, 0x8A, 
+0x86, 0xE0, 0x64, 0x02, 0x60, 0x08, 0x71, 0x34, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0xE4, 
+0xFF, 0x12, 0x77, 0x09, 0xBF, 0x01, 0x12, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0C, 0xB1, 0x66, 0x64, 
+0x02, 0x60, 0x03, 0x02, 0x72, 0xB9, 0x12, 0x78, 0x92, 0x22, 0x90, 0x05, 0x63, 0xE0, 0x90, 0x8A, 
+0xD6, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0x90, 0x8A, 0xD7, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0x90, 0x8A, 
+0xD8, 0xF0, 0x90, 0x05, 0x60, 0xE0, 0x90, 0x8A, 0xD9, 0xF0, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x80, 
+0xF0, 0x22, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 
+0x22, 0x12, 0xCA, 0x15, 0x90, 0x90, 0x04, 0x12, 0xD4, 0x45, 0x12, 0x95, 0x9C, 0x90, 0x90, 0x05, 
+0x12, 0x96, 0x85, 0x90, 0x90, 0x06, 0xF0, 0x11, 0x13, 0x90, 0x90, 0x04, 0xE0, 0x54, 0x01, 0xFF, 
+0x02, 0xA4, 0x2C, 0x90, 0x90, 0x05, 0xE0, 0x14, 0x90, 0x90, 0x07, 0xF0, 0x22, 0x12, 0x8D, 0xF8, 
+0x75, 0x1E, 0x05, 0x7B, 0x01, 0x7A, 0x8B, 0x79, 0x3D, 0x12, 0x68, 0xAB, 0x90, 0x8B, 0x3F, 0x11, 
+0x92, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x8B, 0x49, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x40, 0x11, 0x92, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 
+0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x8B, 0x4B, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x41, 0x11, 
+0x92, 0x90, 0x8B, 0x4D, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8B, 0x3D, 0xE0, 0x30, 0xE0, 0x11, 
+0x90, 0x8B, 0x44, 0x74, 0x01, 0xF0, 0xA3, 0x11, 0x9D, 0x90, 0x07, 0x83, 0xE0, 0x44, 0x20, 0xF0, 
+0x22, 0xE4, 0x90, 0x8B, 0x44, 0x12, 0x8D, 0x11, 0xA3, 0xF0, 0x90, 0x07, 0x83, 0xE0, 0x54, 0xDF, 
+0xF0, 0x22, 0xE0, 0xFF, 0x7E, 0x00, 0x7C, 0x01, 0x7D, 0x40, 0x02, 0x02, 0x80, 0xF0, 0xA3, 0xF0, 
+0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x93, 0x93, 0xEF, 0x11, 0x9F, 0x90, 0x01, 0x09, 0xE0, 
+0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0x93, 0x93, 0xE0, 0x6F, 0x60, 0x35, 0xC3, 0x90, 
+0x93, 0x95, 0xE0, 0x94, 0x88, 0x90, 0x93, 0x94, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 
+0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x93, 0x94, 0xF1, 0xEF, 0x12, 0xB3, 0x96, 0xD3, 0x90, 0x93, 
+0x95, 0xE0, 0x94, 0x32, 0x90, 0x93, 0x94, 0xE0, 0x94, 0x00, 0x40, 0xC0, 0x90, 0x01, 0xC6, 0xE0, 
+0x30, 0xE0, 0xB9, 0x22, 0x12, 0xC9, 0x9F, 0x7F, 0x08, 0x12, 0x7A, 0xB8, 0xEF, 0x54, 0xEF, 0xFD, 
+0x7F, 0x08, 0x12, 0x7A, 0xA5, 0xE4, 0xFF, 0x11, 0xA6, 0x31, 0x7F, 0xE4, 0xFD, 0x12, 0x6F, 0x45, 
+0x90, 0x8A, 0x7F, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x31, 
+0x28, 0x11, 0xF4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8A, 0x7F, 0xE0, 0x44, 0x10, 0xF0, 0x31, 
+0x7F, 0x7D, 0x01, 0x12, 0x6F, 0x45, 0x90, 0x8A, 0x8E, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x7A, 0xA5, 
+0x90, 0x8A, 0x84, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 
+0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x7F, 0x08, 0x12, 0x7A, 0xB8, 0xEF, 0x44, 0x10, 
+0xFD, 0x7F, 0x08, 0x12, 0x7A, 0xA5, 0x7F, 0x01, 0x11, 0xA6, 0x7F, 0x90, 0x12, 0x7A, 0xB8, 0xEF, 
+0x44, 0x01, 0xFD, 0x7F, 0x90, 0x12, 0x7A, 0xA5, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 
+0x8A, 0xED, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x01, 0xFF, 0x90, 0x8B, 0x2D, 0xE0, 0xFB, 0x90, 0x8B, 
+0x2C, 0xE0, 0x90, 0x84, 0xDC, 0xF0, 0x22, 0x90, 0x8A, 0x86, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 
+0x0E, 0x12, 0xD2, 0xE4, 0xBF, 0x01, 0x08, 0x31, 0x18, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x3C, 0xE0, 0xFD, 0xB4, 0x02, 0x07, 0x51, 
+0xAF, 0x74, 0x08, 0xF0, 0x80, 0x09, 0xED, 0xB4, 0x04, 0x05, 0x51, 0xAF, 0x74, 0x10, 0xF0, 0xEF, 
+0x64, 0x02, 0x4E, 0x60, 0x02, 0x41, 0xAA, 0x90, 0x91, 0x1A, 0xE0, 0xFF, 0x64, 0xFE, 0x70, 0x02, 
+0x41, 0xAA, 0xEF, 0x64, 0x02, 0x60, 0x07, 0xEF, 0x64, 0x03, 0x60, 0x02, 0x41, 0xAA, 0x90, 0x91, 
+0x7A, 0x12, 0xD5, 0xEA, 0x90, 0x93, 0x14, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x51, 0xB7, 0x7A, 0x92, 
+0x79, 0xD2, 0x12, 0x04, 0x7A, 0x51, 0xB7, 0x7A, 0x92, 0x79, 0xF2, 0x12, 0x04, 0x7A, 0x90, 0x85, 
+0x03, 0x74, 0x10, 0x11, 0x9F, 0x7B, 0x20, 0xFD, 0xFC, 0xFF, 0xFE, 0x12, 0x71, 0x9D, 0x7B, 0x01, 
+0x7A, 0x91, 0x79, 0x7C, 0x90, 0x85, 0x12, 0x12, 0x86, 0xE9, 0x7A, 0x92, 0x79, 0xF2, 0x90, 0x85, 
+0x15, 0x12, 0x86, 0xE9, 0x90, 0x85, 0x18, 0x74, 0x20, 0xF0, 0x7A, 0x90, 0x79, 0xE9, 0x12, 0x63, 
+0x40, 0x75, 0x1B, 0x01, 0x75, 0x1C, 0x92, 0x75, 0x1D, 0xFA, 0x75, 0x1E, 0x18, 0x7B, 0x01, 0x7A, 
+0x92, 0x79, 0xD2, 0x12, 0x68, 0xAB, 0x75, 0x1B, 0x01, 0x75, 0x1C, 0x92, 0x75, 0x1D, 0xDA, 0x75, 
+0x1E, 0x10, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xC1, 0x12, 0x68, 0xAB, 0x90, 0x92, 0xD8, 0xE0, 0x54, 
+0x03, 0x90, 0x92, 0xD1, 0xF0, 0xC3, 0x94, 0x04, 0x50, 0x1C, 0xE0, 0x90, 0x91, 0xE3, 0xF0, 0x75, 
+0x1B, 0x01, 0x75, 0x1C, 0x92, 0x75, 0x1D, 0xC1, 0x75, 0x1E, 0x10, 0x7B, 0x01, 0x7A, 0x91, 0x79, 
+0xC3, 0x12, 0x68, 0xAB, 0x80, 0x06, 0x90, 0x91, 0xE3, 0x74, 0x05, 0xF0, 0x90, 0x92, 0xD1, 0xE0, 
+0xFF, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xC1, 0x12, 0x8D, 0x3B, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
+0x93, 0x12, 0x74, 0x80, 0xF0, 0xA3, 0x22, 0x7E, 0x00, 0x7F, 0x20, 0x7D, 0x00, 0x7B, 0x01, 0x22, 
+0x90, 0x92, 0xC0, 0xED, 0xF0, 0x90, 0x92, 0xBE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x31, 0xB0, 0x90, 
+0x92, 0xBE, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x92, 0xC1, 0x12, 0xCD, 0xB3, 0x90, 0x92, 0xD9, 0x74, 0x18, 0xF0, 0x7E, 0x00, 0x7F, 
+0x80, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xE1, 0x12, 0x04, 0x7A, 0x90, 0x01, 0xC4, 0x74, 
+0xDA, 0xF0, 0x74, 0xAA, 0xA3, 0xF0, 0x90, 0x92, 0x40, 0xE0, 0xFF, 0x12, 0x7A, 0x7E, 0x90, 0x92, 
+0xD8, 0xEF, 0xF0, 0xF9, 0xE0, 0xFE, 0x24, 0x29, 0x12, 0xD5, 0x0A, 0x74, 0x41, 0xF0, 0xEE, 0x24, 
+0x28, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x92, 0xD9, 0xE0, 0x7A, 0x00, 0x2D, 0xFE, 0xEA, 0x3C, 0x90, 
+0x92, 0xDD, 0xF0, 0xA3, 0xCE, 0xF0, 0x74, 0x28, 0x29, 0x12, 0xD4, 0x9C, 0x90, 0x92, 0xC3, 0xE0, 
+0xFD, 0x12, 0x97, 0x5E, 0xB1, 0xFF, 0x90, 0x92, 0xDD, 0xE0, 0xFF, 0xA3, 0xE0, 0x90, 0x92, 0xDB, 
+0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 0xE1, 0x74, 0x01, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xE4, 
+0xA3, 0xF0, 0xA3, 0x74, 0x5F, 0xF0, 0x90, 0x92, 0xDD, 0xE4, 0x75, 0xF0, 0x04, 0x12, 0x02, 0xE7, 
+0x90, 0x91, 0x1D, 0xE0, 0xFF, 0x7E, 0x02, 0xB4, 0xFE, 0x02, 0x7E, 0xFE, 0x90, 0x92, 0xDD, 0xA3, 
+0xE0, 0xFD, 0xB1, 0xD1, 0xEE, 0xF0, 0x74, 0x00, 0x2D, 0xB1, 0xD3, 0xE0, 0x90, 0x92, 0xE5, 0xF0, 
+0x90, 0x92, 0xDD, 0xF1, 0xEF, 0x90, 0x91, 0xB2, 0xE0, 0x90, 0x92, 0xC1, 0xB4, 0x01, 0x0B, 0xE0, 
+0x44, 0x03, 0xFC, 0xA3, 0xE0, 0x44, 0x10, 0xFD, 0x80, 0x09, 0xE0, 0x44, 0x03, 0xFC, 0xA3, 0xE0, 
+0x44, 0x20, 0xFD, 0x90, 0x92, 0xDF, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x92, 0xE6, 0x74, 0x03, 
+0xF0, 0xA3, 0x74, 0x12, 0xF0, 0x12, 0xD5, 0x45, 0xEF, 0x64, 0xFE, 0x70, 0x27, 0x90, 0x92, 0xDD, 
+0xA3, 0xE0, 0x24, 0x00, 0x12, 0xC7, 0x10, 0xC0, 0x03, 0x8B, 0x1B, 0x12, 0xD5, 0x7A, 0xD0, 0x03, 
+0x12, 0x68, 0xAB, 0x75, 0x1B, 0x01, 0x12, 0xD5, 0x7A, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xE8, 0x12, 
+0x68, 0xAB, 0x80, 0x58, 0x90, 0x92, 0x3B, 0xE0, 0xFF, 0xB4, 0x02, 0x27, 0x90, 0x92, 0xDD, 0xE0, 
+0xFC, 0xA3, 0xE0, 0xFD, 0x24, 0x00, 0xF5, 0x82, 0x74, 0xFC, 0x3C, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 
+0x01, 0x2D, 0xF5, 0x82, 0x74, 0xFC, 0x3C, 0xF5, 0x83, 0x74, 0x20, 0x12, 0xD5, 0xE2, 0x74, 0x20, 
+0xF0, 0x80, 0x29, 0xEF, 0xB4, 0x04, 0x25, 0x90, 0x92, 0xDD, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x24, 
+0x00, 0xF5, 0x82, 0x74, 0xFC, 0x3E, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2F, 0xF5, 0x82, 0x74, 
+0xFC, 0x3E, 0xF5, 0x83, 0x74, 0x10, 0x12, 0xD5, 0xE2, 0x74, 0x10, 0xF0, 0x12, 0xD5, 0x45, 0xE4, 
+0x90, 0x92, 0xDA, 0xF0, 0x12, 0xD4, 0xB7, 0xFE, 0x90, 0x92, 0xDD, 0xA3, 0xE0, 0xFD, 0xEF, 0x2D, 
+0xB1, 0xD1, 0xEE, 0xF0, 0x12, 0xD4, 0xB7, 0xFE, 0x74, 0xEA, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x92, 
+0xF5, 0x83, 0xEE, 0xB1, 0xF7, 0xE0, 0xB4, 0x08, 0xDB, 0xD1, 0x09, 0x90, 0x92, 0xDD, 0xE4, 0x75, 
+0xF0, 0x20, 0x12, 0x02, 0xE7, 0x90, 0x92, 0xDD, 0xE4, 0x75, 0xF0, 0x10, 0x12, 0x02, 0xE7, 0xB1, 
+0xFF, 0xE4, 0x90, 0x93, 0x64, 0xF0, 0xE4, 0x90, 0x92, 0xDA, 0xF0, 0x12, 0xD5, 0x9E, 0x50, 0x10, 
+0x12, 0xD4, 0xA4, 0xB1, 0xF0, 0x12, 0xD5, 0x70, 0xE0, 0xB1, 0xD1, 0xE4, 0xB1, 0xF7, 0x80, 0xEB, 
+0x12, 0xD5, 0x12, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x92, 0x41, 0xE0, 0xFD, 0x12, 
+0xC7, 0x54, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x85, 0x04, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0xED, 0xFF, 0x90, 0x92, 0x40, 0xE0, 0xC3, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 0xFE, 0xEF, 
+0x78, 0x07, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x92, 0xD9, 0xE0, 0x7C, 0x00, 
+0x2F, 0xFF, 0xEC, 0x3E, 0xCF, 0x24, 0x38, 0xCF, 0x34, 0x00, 0xFE, 0x90, 0x85, 0x03, 0x74, 0x10, 
+0xF0, 0x7B, 0x63, 0xE4, 0xFD, 0x12, 0x71, 0x9D, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xE1, 0x90, 0x85, 
+0x29, 0x12, 0x86, 0xE9, 0x7A, 0x92, 0x79, 0xC4, 0x90, 0x85, 0x2C, 0x12, 0x86, 0xE9, 0x90, 0x85, 
+0x2F, 0x74, 0x10, 0xF0, 0x7A, 0x90, 0x79, 0xD9, 0x12, 0x6E, 0x84, 0x90, 0x93, 0x64, 0xE0, 0x04, 
+0xF0, 0x90, 0x06, 0x31, 0xE0, 0x30, 0xE2, 0x07, 0x12, 0xD5, 0xDA, 0x50, 0x02, 0x81, 0x96, 0x12, 
+0xD5, 0xDA, 0x40, 0x0A, 0x90, 0x06, 0x35, 0xE0, 0x44, 0x20, 0x90, 0x06, 0x34, 0xF0, 0xE4, 0x90, 
+0x92, 0xDA, 0xF0, 0x12, 0xD5, 0x9E, 0x50, 0x22, 0x12, 0xD4, 0xA4, 0xB1, 0xF0, 0x12, 0xD5, 0x70, 
+0x90, 0x92, 0xDA, 0xE0, 0x24, 0xC4, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 
+0x92, 0xD8, 0xE0, 0xB1, 0xD1, 0xEF, 0xB1, 0xF7, 0x80, 0xD9, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x22, 
+0x90, 0x05, 0x22, 0xE0, 0x90, 0x93, 0x63, 0xF0, 0x7D, 0x1D, 0x12, 0xB6, 0x9E, 0xBF, 0x01, 0x06, 
+0xB1, 0xDB, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x93, 0x63, 0xE0, 0xFF, 0x7D, 0x1E, 0x12, 0x8F, 0xCF, 
+0x80, 0x06, 0xB1, 0xDB, 0x90, 0x04, 0x25, 0xF0, 0x12, 0x8F, 0xDC, 0x90, 0x8A, 0x86, 0xE0, 0x70, 
+0x05, 0x7F, 0x01, 0x12, 0x78, 0xF0, 0x74, 0xDA, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xAA, 0xA3, 
+0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xFD, 0xE4, 0x33, 0x90, 0x8F, 0xD2, 0xF0, 0xA3, 0xED, 0xF0, 
+0xFE, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 0x92, 0x40, 0xE0, 0xFF, 
+0x90, 0x93, 0x92, 0x74, 0x08, 0xF0, 0x7B, 0x18, 0x7D, 0x01, 0x12, 0xB7, 0x13, 0x90, 0x92, 0xD8, 
+0xEF, 0xF0, 0x90, 0x92, 0x40, 0xE0, 0x22, 0xF0, 0x90, 0x92, 0xDA, 0xE0, 0x04, 0xF0, 0x22, 0x90, 
+0x92, 0xDD, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x02, 0xE7, 0x90, 0x92, 0xDD, 0xE4, 0x75, 0xF0, 0x08, 
+0x02, 0x02, 0xE7, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0xC7, 0xEC, 0x12, 0xD5, 
+0xFA, 0xAA, 0x07, 0x90, 0x8F, 0xCE, 0x12, 0x04, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x12, 0xD5, 0x5A, 
+0xEA, 0x24, 0xEF, 0x60, 0x38, 0x24, 0xD7, 0x70, 0x02, 0xE1, 0x7F, 0x24, 0x3A, 0x60, 0x02, 0xE1, 
+0xB5, 0xF1, 0xE8, 0x24, 0x0A, 0xB1, 0xC6, 0x12, 0xBB, 0xFE, 0xE4, 0xF0, 0xFE, 0x74, 0x00, 0x2F, 
+0x12, 0xD5, 0xF2, 0x7D, 0x14, 0xF1, 0xD1, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0xF1, 0xDC, 0x90, 
+0x84, 0xF3, 0x12, 0x04, 0x31, 0x7D, 0x14, 0x7C, 0x00, 0xE4, 0xFF, 0xE1, 0x7A, 0x90, 0x8F, 0xC7, 
+0xE4, 0x75, 0xF0, 0x14, 0x12, 0x02, 0xE7, 0x90, 0x8F, 0xC7, 0xA3, 0xE0, 0xFB, 0xFF, 0x24, 0x06, 
+0xFC, 0xE4, 0x33, 0x90, 0x8F, 0xD2, 0xF0, 0xA3, 0xCC, 0xF0, 0x90, 0x8F, 0xD2, 0xA3, 0xE0, 0xB1, 
+0xD0, 0x12, 0xBB, 0xFE, 0xE4, 0xF0, 0x74, 0x04, 0x2F, 0x12, 0xBC, 0xBC, 0xE0, 0xFE, 0xA9, 0x03, 
+0x74, 0x05, 0x29, 0x12, 0xB7, 0xE2, 0x12, 0xBC, 0x14, 0xFE, 0x90, 0x8F, 0xCC, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x8F, 0xC7, 0xE0, 0xFC, 0xA3, 0xE0, 0x2F, 0xFF, 0xEC, 0x3E, 0xFE, 0xD3, 0xEF, 0x94, 
+0x00, 0xEE, 0x94, 0x01, 0x90, 0x8F, 0xC7, 0x40, 0x6C, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xE9, 0x7C, 
+0x00, 0x24, 0x00, 0xF9, 0xEC, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC3, 0xE4, 0x9F, 0xFD, 0x74, 0x01, 
+0x9E, 0xFC, 0xF1, 0xD3, 0x90, 0x8F, 0xC9, 0xE0, 0x24, 0x01, 0xFF, 0xE4, 0x33, 0xA2, 0xE7, 0x13, 
+0xEF, 0x13, 0x90, 0xFD, 0x10, 0xF0, 0x12, 0xD4, 0xD6, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0x7B, 0x01, 0x7A, 0xFC, 0x79, 0x00, 0x90, 0x8F, 0xC7, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 
+0xE4, 0x9F, 0xFF, 0x74, 0x01, 0x9E, 0xFE, 0x12, 0xD5, 0x19, 0xC3, 0x9F, 0xFD, 0xEC, 0x9E, 0xFC, 
+0x12, 0x45, 0x99, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x86, 0xAD, 0xF1, 0xD6, 
+0x12, 0xD5, 0x5A, 0x80, 0x0F, 0xA3, 0xE0, 0x7E, 0x00, 0x24, 0x00, 0x12, 0xD5, 0xF2, 0x12, 0xD5, 
+0x19, 0xFD, 0xF1, 0xD3, 0x90, 0x8F, 0xC7, 0x74, 0xFF, 0x75, 0xF0, 0xEC, 0x12, 0x02, 0xE7, 0xF1, 
+0xE8, 0x7E, 0x00, 0x24, 0x0C, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x02, 0xC0, 0x01, 
+0x74, 0x10, 0x2F, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0xF1, 0xDC, 0x90, 0x84, 0xF3, 0x12, 0x04, 0x31, 
+0x12, 0xD5, 0x19, 0xFD, 0xD0, 0x01, 0xD0, 0x02, 0x7F, 0x11, 0x12, 0x3E, 0x54, 0x80, 0x2E, 0xF1, 
+0xE8, 0x24, 0x2A, 0xB1, 0xC6, 0x12, 0xBB, 0xFE, 0xE4, 0xF0, 0x12, 0xC7, 0x0D, 0x7D, 0x48, 0xF1, 
+0xD1, 0xF1, 0xE2, 0x12, 0xD4, 0xD1, 0x12, 0x86, 0xAD, 0xE4, 0xFD, 0xFC, 0xF1, 0xD6, 0xF1, 0xE2, 
+0x12, 0xD4, 0xD1, 0x12, 0x86, 0xAD, 0xF1, 0xD6, 0xF1, 0xE2, 0x12, 0x03, 0xCD, 0x90, 0x8F, 0xCA, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x8F, 0xCA, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0xFF, 0x90, 
+0x8F, 0xD2, 0xA3, 0xE0, 0xB1, 0xD0, 0xEF, 0x12, 0xBB, 0xFF, 0xED, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x7C, 0x00, 0x12, 0x45, 0x99, 0x90, 0x8F, 0xCE, 0x02, 0x04, 0x31, 0x90, 0x84, 0xF0, 0x12, 
+0x86, 0xE9, 0x90, 0x8F, 0xCE, 0x02, 0x04, 0xB2, 0x90, 0x8F, 0xC7, 0xA3, 0xE0, 0xFF, 0x22, 0xE4, 
+0x75, 0xF0, 0x01, 0x02, 0x02, 0xE7, 0x12, 0x02, 0x06, 0xFF, 0x90, 0x92, 0x5A, 0xF0, 0xBF, 0x01, 
+0x0A, 0x7F, 0x01, 0x12, 0x89, 0x6F, 0xE4, 0x90, 0x92, 0x5A, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x7F, 0x8F, 0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE6, 0x29, 0x90, 0x00, 0x8C, 0xE0, 
+0x90, 0x8F, 0xFD, 0xF0, 0x7F, 0x8D, 0x12, 0x7A, 0xB8, 0x90, 0x8F, 0xFE, 0xEF, 0xF0, 0x90, 0x00, 
+0x8E, 0xE0, 0x90, 0x8F, 0xFF, 0xF0, 0x90, 0x8F, 0xFE, 0xE0, 0x7F, 0x8F, 0x12, 0x7A, 0xB8, 0xEF, 
+0x30, 0xE0, 0x02, 0x11, 0x4A, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFD, 0x7F, 0x8D, 0x02, 0x7A, 
+0xA5, 0xE4, 0x90, 0x92, 0xAD, 0xF0, 0x90, 0x92, 0xAD, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0x51, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0xB0, 0xA3, 0xF0, 0x12, 0x7B, 0x6C, 0xBF, 0x01, 0x03, 0x12, 0x58, 0x9B, 
+0x90, 0x8A, 0x83, 0xE0, 0x60, 0x0F, 0x90, 0x8A, 0x86, 0xE0, 0xFF, 0x90, 0x8A, 0x85, 0xE0, 0x6F, 
+0x60, 0x03, 0x12, 0xA5, 0x75, 0xC2, 0xAF, 0x31, 0x06, 0xBF, 0x01, 0x02, 0x11, 0xFB, 0xD2, 0xAF, 
+0x11, 0x99, 0x11, 0x0C, 0x12, 0x84, 0x4D, 0x80, 0xBD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x92, 0x62, 0xE0, 0x60, 0x25, 0x7F, 0x54, 0x7E, 0x09, 0x12, 0x6F, 0xC1, 0x11, 0xF1, 0x12, 
+0x04, 0xB2, 0xEF, 0x44, 0xFE, 0xFF, 0xEE, 0x44, 0x03, 0xFE, 0xED, 0x44, 0x04, 0xFD, 0xEC, 0x11, 
+0xF1, 0x12, 0x93, 0x74, 0x7F, 0x54, 0x7E, 0x09, 0x12, 0x6F, 0xFE, 0x90, 0x92, 0x5D, 0xE0, 0x70, 
+0x04, 0x90, 0x07, 0xCC, 0xF0, 0x90, 0x92, 0x65, 0xE0, 0x70, 0x0A, 0x90, 0x92, 0x62, 0xE0, 0x70, 
+0x04, 0xA3, 0xE0, 0x60, 0x07, 0x90, 0x00, 0x1F, 0xE0, 0x54, 0xF0, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x92, 0xAE, 0x12, 0x04, 0x31, 0x90, 0x92, 0xAE, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0x30, 
+0xE0, 0x03, 0x12, 0xA9, 0x97, 0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0x06, 0xF0, 0x74, 0xB1, 
+0xA3, 0xF0, 0x90, 0x92, 0x4D, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x18, 0xED, 0x25, 0xE0, 0x24, 
+0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x0B, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0xA3, 0xF0, 0x7F, 0x00, 
+0x22, 0x0D, 0x80, 0xDE, 0x74, 0x06, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xB1, 0xA3, 0xF0, 0x7F, 
+0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x9A, 0xEF, 0xF0, 0x7F, 0x8F, 
+0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE6, 0x4A, 0x7F, 0x8D, 0x12, 0x7A, 0xB8, 0xEF, 0x64, 0x01, 0x70, 
+0x40, 0x90, 0x93, 0x9B, 0xF0, 0x90, 0x93, 0x9B, 0xE0, 0xFD, 0x90, 0x93, 0x9A, 0xE0, 0xC4, 0x54, 
+0xF0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE5, 0x82, 0x2D, 0xF5, 0x82, 0xE4, 
+0x35, 0x83, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFF, 0x31, 0xA6, 0x90, 0x93, 0x9B, 0xE0, 0x04, 0xF0, 
+0xE0, 0xC3, 0x94, 0x10, 0x40, 0xCF, 0x7F, 0x8F, 0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE0, 0x02, 0x11, 
+0x4A, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x70, 0x04, 0x74, 0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 
+0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 
+0x0C, 0x74, 0xFC, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0xEB, 0xF0, 0x22, 0xE4, 0xF5, 
+0x3F, 0xF5, 0x40, 0xF5, 0x41, 0x75, 0x42, 0x80, 0xAD, 0x3F, 0x7F, 0x50, 0x12, 0x7A, 0xA5, 0xAD, 
+0x40, 0x7F, 0x51, 0x12, 0x7A, 0xA5, 0xAD, 0x41, 0x7F, 0x52, 0x12, 0x7A, 0xA5, 0xAD, 0x42, 0x7F, 
+0x53, 0x02, 0x7A, 0xA5, 0x12, 0x75, 0x87, 0x12, 0x75, 0x29, 0x51, 0x00, 0x51, 0x25, 0x80, 0xCE, 
+0x75, 0x47, 0x10, 0xE4, 0xF5, 0x48, 0x75, 0x49, 0x07, 0x75, 0x4A, 0x02, 0x90, 0x01, 0x30, 0xE5, 
+0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0xA3, 0xE5, 0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0x90, 0x01, 
+0x20, 0xE5, 0x4F, 0xF0, 0x22, 0x75, 0x51, 0x06, 0x43, 0x51, 0x10, 0x75, 0x52, 0x01, 0x75, 0x53, 
+0x03, 0x75, 0x54, 0x62, 0x43, 0x54, 0x80, 0x43, 0x53, 0x04, 0x90, 0x01, 0x38, 0xE5, 0x51, 0xF0, 
+0xA3, 0xE5, 0x52, 0xF0, 0xA3, 0xE5, 0x53, 0xF0, 0xA3, 0xE5, 0x54, 0xF0, 0x22, 0x12, 0x7A, 0x92, 
+0x90, 0x89, 0x82, 0xEF, 0xF0, 0x31, 0xF4, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x04, 0x23, 
+0xE0, 0x44, 0x80, 0xF0, 0x90, 0x00, 0x17, 0xE0, 0x54, 0xFC, 0x44, 0x04, 0xFD, 0x7F, 0x17, 0x12, 
+0x7A, 0xA5, 0x90, 0x00, 0x38, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x38, 0x12, 0x7A, 0xA5, 0x02, 0x67, 
+0x21, 0x90, 0x01, 0xE4, 0x74, 0x04, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x89, 0x64, 0x74, 0x80, 
+0xF0, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x86, 0x4E, 0x90, 0x92, 0xB2, 0xEF, 0xF0, 
+0x60, 0xF0, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 
+0x30, 0xE1, 0x0A, 0x90, 0x89, 0x7E, 0xE0, 0x54, 0xFD, 0xF0, 0x12, 0x5D, 0x58, 0x51, 0xE7, 0x30, 
+0xE2, 0x06, 0x54, 0xFB, 0xF0, 0x12, 0x61, 0xA6, 0x51, 0xE7, 0x30, 0xE4, 0x0B, 0x54, 0xEF, 0xF0, 
+0x51, 0xF1, 0xBF, 0x01, 0x03, 0x12, 0x9A, 0x28, 0x51, 0xE7, 0x30, 0xE6, 0x06, 0x54, 0xBF, 0xF0, 
+0x12, 0x6D, 0xBF, 0xD2, 0xAF, 0x80, 0xBB, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x89, 0x7E, 0xE0, 0xFF, 
+0x22, 0xE4, 0x90, 0x93, 0x9E, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x23, 0xC3, 
+0x90, 0x93, 0x9F, 0xE0, 0x94, 0xD0, 0x90, 0x93, 0x9E, 0xE0, 0x94, 0x07, 0x40, 0x0A, 0x90, 0x01, 
+0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x93, 0x9E, 0x12, 0xAF, 0xEF, 0x71, 0x25, 
+0x80, 0xD6, 0x7F, 0x01, 0x22, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 0x01, 0x9A, 0xE0, 
+0x54, 0xC0, 0x44, 0x0B, 0xF0, 0x71, 0x25, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xC0, 0x7F, 0x00, 0xB4, 
+0x40, 0x02, 0x7F, 0x01, 0x22, 0xE4, 0x90, 0x92, 0x93, 0xF0, 0xA3, 0xF0, 0x71, 0x2C, 0xEF, 0x64, 
+0x01, 0x60, 0x3C, 0xC3, 0x90, 0x92, 0x94, 0xE0, 0x94, 0x88, 0x90, 0x92, 0x93, 0xE0, 0x94, 0x13, 
+0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 
+0x1E, 0x90, 0x92, 0x93, 0x12, 0xAF, 0xEF, 0x71, 0x96, 0xD3, 0x90, 0x92, 0x94, 0xE0, 0x94, 0x32, 
+0x90, 0x92, 0x93, 0xE0, 0x94, 0x00, 0x40, 0xC4, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xBD, 0x90, 
+0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 0x01, 0x01, 
+0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0xF0, 0x71, 0x25, 0x90, 0x01, 0x99, 
+0xE0, 0x44, 0xC0, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x80, 0xF0, 0x22, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xBC, 0xF0, 0x74, 
+0xB3, 0xA3, 0xF0, 0x12, 0x6B, 0x8E, 0x74, 0xBC, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xB3, 0xA3, 
+0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 
+0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x0C, 0xF0, 0x74, 
+0xB4, 0xA3, 0xF0, 0x12, 0x74, 0xF9, 0xE5, 0x55, 0x30, 0xE1, 0x03, 0x12, 0xBF, 0xF7, 0xE5, 0x55, 
+0x30, 0xE2, 0x03, 0x12, 0xA7, 0x72, 0xE5, 0x55, 0x30, 0xE4, 0x02, 0xF1, 0xEA, 0xE5, 0x56, 0x30, 
+0xE0, 0x02, 0x91, 0xB2, 0xE5, 0x57, 0x30, 0xE2, 0x0A, 0x12, 0xC0, 0x01, 0x90, 0x07, 0x8F, 0xE0, 
+0x44, 0x10, 0xF0, 0xE5, 0x58, 0x30, 0xE1, 0x05, 0x7F, 0x04, 0x12, 0xA7, 0x35, 0xE5, 0x58, 0x30, 
+0xE4, 0x03, 0x12, 0xA5, 0xE7, 0xE5, 0x58, 0x30, 0xE5, 0x03, 0x12, 0xA5, 0xA3, 0xE5, 0x58, 0x30, 
+0xE6, 0x02, 0x91, 0xE6, 0xE5, 0x58, 0x30, 0xE7, 0x03, 0x12, 0xC0, 0x3D, 0x74, 0x0C, 0x04, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0xB4, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 
+0xE0, 0x32, 0x12, 0xC9, 0x5A, 0x90, 0x93, 0x74, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 
+0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xDB, 0x90, 0x93, 0x74, 0xE0, 0x30, 0xE6, 0x11, 0x90, 
+0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 
+0x12, 0xD4, 0xFC, 0x02, 0x40, 0x55, 0x90, 0x8A, 0x7E, 0xE0, 0xFF, 0x12, 0x9F, 0x8D, 0x30, 0xE0, 
+0x21, 0xEF, 0x54, 0x7F, 0x12, 0xD5, 0xC1, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x09, 
+0xE0, 0x54, 0xFD, 0xF0, 0x12, 0xD4, 0xC7, 0x04, 0xF0, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x03, 0x12, 
+0xA5, 0x75, 0xB1, 0x3E, 0x30, 0xE0, 0x22, 0x90, 0x8A, 0xF1, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 
+0x18, 0xEF, 0x54, 0xFD, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8A, 0xF1, 0x30, 0xE1, 0x06, 0xE0, 
+0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFB, 0xF0, 0x7F, 0x01, 0x02, 0x98, 0xFC, 0x90, 0x8A, 
+0xEE, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x92, 0xB5, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 
+0x12, 0xD2, 0x1E, 0xE4, 0x90, 0x92, 0xB8, 0xF0, 0xFD, 0x12, 0x52, 0xBD, 0xEF, 0x54, 0x0C, 0x64, 
+0x08, 0x70, 0x5E, 0xB1, 0xC8, 0xA3, 0xE0, 0xB1, 0xD1, 0x64, 0x88, 0x70, 0x54, 0xB1, 0xC8, 0xA3, 
+0xE0, 0x24, 0x07, 0xFD, 0x12, 0x52, 0xBD, 0xEF, 0x64, 0x8E, 0x70, 0x45, 0x90, 0x92, 0xB8, 0x04, 
+0xB1, 0xC7, 0xB1, 0xD9, 0x04, 0xFD, 0x12, 0x52, 0xBD, 0xEF, 0x64, 0x03, 0x70, 0x33, 0xB1, 0xC8, 
+0xB1, 0xD9, 0xB1, 0xD1, 0x30, 0xE3, 0x07, 0x90, 0x01, 0xC7, 0x74, 0x01, 0x80, 0x20, 0x90, 0x90, 
+0x08, 0x12, 0xC3, 0xBF, 0x30, 0xE0, 0x0A, 0xB1, 0xC8, 0xA3, 0xE0, 0xFD, 0x12, 0x9C, 0xD6, 0x80, 
+0x10, 0x90, 0x90, 0x0B, 0xB1, 0x41, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x02, 0x12, 0x9F, 
+0x80, 0x90, 0x92, 0xB8, 0xE0, 0xFF, 0x22, 0xF0, 0x90, 0x92, 0xB3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x22, 0x24, 0x06, 0xFD, 0x12, 0x52, 0xBD, 0xEF, 0x22, 0x90, 0x92, 0xB6, 0xE0, 0xFD, 0x90, 0x92, 
+0xB5, 0xE0, 0x2D, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x8A, 0xEF, 0xF0, 
+0xA3, 0xED, 0xF0, 0x90, 0x89, 0x80, 0xE0, 0x04, 0xF0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x07, 
+0x90, 0x05, 0x10, 0xE4, 0xF0, 0xA3, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x3F, 0x90, 0x05, 0x22, 
+0xE0, 0x90, 0x93, 0x8E, 0xF0, 0x7D, 0x26, 0xD1, 0x9E, 0xEF, 0x64, 0x01, 0x70, 0x17, 0x90, 0x89, 
+0x85, 0xE0, 0xFF, 0x90, 0x93, 0x8B, 0xE0, 0xFB, 0x90, 0x8E, 0xE9, 0x74, 0x0A, 0xF0, 0x7D, 0x01, 
+0x12, 0x2B, 0x0B, 0x80, 0x07, 0xB1, 0x3E, 0x30, 0xE0, 0x04, 0xF1, 0x01, 0xD1, 0x81, 0x90, 0x93, 
+0x8E, 0xE0, 0xFF, 0x7D, 0x27, 0x12, 0x8F, 0xCF, 0xD1, 0x79, 0x80, 0x06, 0xD1, 0x79, 0xF1, 0x01, 
+0xD1, 0x81, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x11, 0xB1, 0x3E, 0x30, 0xE0, 0x0C, 0x90, 0x05, 
+0x22, 0xE0, 0x54, 0x6F, 0xFF, 0x7D, 0x28, 0x12, 0x8F, 0xCF, 0x12, 0x8F, 0xDC, 0x12, 0xC9, 0xE7, 
+0x74, 0x01, 0xF0, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x93, 0x8A, 0xE0, 0xFF, 0x02, 0x59, 
+0x1B, 0x90, 0x93, 0x8C, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x93, 0x8A, 0xE0, 0xFF, 
+0x12, 0x56, 0x8E, 0x90, 0x93, 0x8C, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x02, 0x4F, 0xDA, 0x7F, 0xFF, 
+0x12, 0x8F, 0xCF, 0xE4, 0x90, 0x93, 0x98, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 
+0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xB1, 
+0x3E, 0x30, 0xE0, 0x15, 0xD3, 0x90, 0x93, 0x99, 0xE0, 0x94, 0x03, 0x90, 0x93, 0x98, 0xE0, 0x94, 
+0x00, 0x40, 0x02, 0x80, 0x13, 0x7F, 0x01, 0x80, 0x1B, 0xD3, 0x90, 0x93, 0x99, 0xE0, 0x94, 0xE8, 
+0x90, 0x93, 0x98, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 
+0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x7B, 0x8D, 0x90, 0x93, 0x98, 0x12, 0xAF, 0xEF, 0x80, 
+0xA9, 0x90, 0x89, 0x85, 0xE0, 0xFF, 0x90, 0x93, 0x8B, 0xE0, 0xFB, 0x90, 0x93, 0x92, 0x74, 0x0A, 
+0xF0, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x90, 0xED, 0xF0, 0xA3, 
+0xEB, 0xF0, 0x90, 0x93, 0x8F, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0xC7, 0x5F, 0x90, 0x93, 0x8F, 
+0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x93, 0x90, 0xE0, 0x60, 0x06, 0x12, 0xD5, 0x39, 0x44, 0x80, 
+0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 
+0xF0, 0x12, 0xD5, 0x39, 0x54, 0xC0, 0xF0, 0x90, 0x93, 0x92, 0xE0, 0xFF, 0xAE, 0x05, 0x74, 0x18, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x00, 0x8B, 0xE0, 0xD3, 0x94, 
+0x03, 0x74, 0x10, 0x40, 0x07, 0xF1, 0xD6, 0x74, 0x04, 0xF0, 0x80, 0x04, 0xF1, 0xD6, 0xE4, 0xF0, 
+0xAF, 0x05, 0x12, 0xD5, 0x65, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0x93, 0x91, 0xE0, 0x25, 0xE0, 0x25, 
+0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x12, 0xD5, 0x65, 0xEE, 0xF0, 0x74, 0x11, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2F, 0x12, 0xD5, 0x0A, 0xE0, 
+0x54, 0xF7, 0xF0, 0x90, 0x8A, 0xEA, 0xE0, 0x30, 0xE0, 0x0D, 0xF1, 0xDF, 0xE0, 0x44, 0x80, 0xF0, 
+0x90, 0x05, 0x12, 0xE4, 0xF0, 0x80, 0x06, 0xF1, 0xDF, 0xE0, 0x54, 0x7F, 0xF0, 0xAE, 0x04, 0xAF, 
+0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 
+0x05, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x02, 0x3D, 0x30, 0xC0, 0xE0, 0xC0, 
+0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
+0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xED, 0xF0, 
+0x74, 0xB7, 0xA3, 0xF0, 0x12, 0x0F, 0x2F, 0x53, 0x91, 0xBF, 0x74, 0xED, 0x04, 0x90, 0x01, 0xC4, 
+0xF0, 0x74, 0xB7, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 
+0xC0, 0xE0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x05, 0xC0, 0x07, 0x7D, 
+0x40, 0x90, 0x01, 0xC4, 0xED, 0xF0, 0x74, 0xB8, 0xFF, 0xA3, 0xF0, 0xED, 0x04, 0x90, 0x01, 0xC4, 
+0xF0, 0xA3, 0xEF, 0xF0, 0xD0, 0x07, 0xD0, 0x05, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 
+0x32, 0x90, 0x8B, 0x05, 0xE0, 0x30, 0xE0, 0x05, 0x12, 0x6C, 0xF3, 0x80, 0x03, 0x12, 0x64, 0x62, 
+0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x04, 0xA3, 0xE0, 0x04, 0xF0, 0x90, 0x8B, 0x34, 0xE0, 0x64, 
+0x08, 0x70, 0x20, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x14, 0x12, 0xA9, 0x7F, 0xE4, 0xFD, 0x12, 
+0x6F, 0x45, 0x90, 0x8B, 0x33, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xA3, 0xF0, 0x80, 0x05, 0xE4, 0x90, 
+0x8B, 0x34, 0xF0, 0x90, 0x8A, 0xEE, 0x12, 0x97, 0xFC, 0x30, 0xE0, 0x13, 0x90, 0x8B, 0x35, 0xE0, 
+0x04, 0xF0, 0xE0, 0xB4, 0x14, 0x09, 0x90, 0x04, 0x9C, 0xE4, 0xF0, 0x90, 0x8B, 0x35, 0xF0, 0x90, 
+0x8A, 0x83, 0xE0, 0x70, 0x02, 0x21, 0x84, 0x90, 0x8A, 0x9A, 0xE0, 0x04, 0xF0, 0x90, 0x05, 0x61, 
+0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x03, 0xFE, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 
+0x06, 0xAB, 0x07, 0x90, 0x05, 0x60, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x86, 0xC7, 0xC0, 
+0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x05, 0x62, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 
+0x78, 0x10, 0x12, 0x03, 0xFE, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x86, 0xC7, 
+0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 
+0x18, 0x12, 0x03, 0xFE, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x86, 0xC7, 0x90, 
+0x8A, 0xCE, 0x12, 0x04, 0x31, 0x90, 0x8A, 0x7F, 0xE0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x30, 0xE0, 
+0x09, 0x12, 0xD4, 0xFC, 0x12, 0x40, 0x55, 0x12, 0xD4, 0x21, 0x12, 0xA3, 0x2C, 0x13, 0x54, 0x1F, 
+0x30, 0xE0, 0x0A, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x03, 0x12, 0xA7, 0x64, 0x90, 0x93, 0xA1, 
+0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 
+0xE0, 0x44, 0x01, 0xF0, 0x12, 0x99, 0x58, 0x31, 0xEC, 0xE4, 0x90, 0x92, 0x51, 0xF0, 0x12, 0xD4, 
+0x33, 0x90, 0x90, 0x08, 0x12, 0xB5, 0x41, 0x30, 0xE0, 0x51, 0x90, 0x91, 0xE5, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x7C, 0x00, 0x7D, 0x64, 0x12, 0x02, 0x92, 0x90, 0x92, 0x39, 0xE0, 0x6E, 0x70, 0x03, 
+0xA3, 0xE0, 0x6F, 0x60, 0x0A, 0x90, 0x92, 0x39, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x02, 0xE7, 0x90, 
+0x91, 0xE9, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x91, 0xF7, 0xE0, 0xB5, 0x06, 0x14, 0xA3, 0xE0, 
+0xB5, 0x07, 0x0F, 0xEF, 0x4E, 0x60, 0x0B, 0x90, 0x01, 0xC7, 0x74, 0x31, 0xF0, 0x7F, 0x01, 0x02, 
+0x99, 0xDB, 0x51, 0x47, 0xE4, 0x90, 0x92, 0x39, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x92, 0x4E, 0xE0, 
+0x30, 0xE0, 0x34, 0x12, 0xA4, 0x7D, 0x70, 0x2F, 0x90, 0x93, 0xA3, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 
+0x0A, 0x0B, 0x90, 0x92, 0x50, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x93, 0xA3, 0xF0, 0x90, 0x92, 0x50, 
+0xE0, 0xFF, 0x90, 0x92, 0x4F, 0xE0, 0xD3, 0x9F, 0x50, 0x0D, 0x90, 0x92, 0x51, 0xE0, 0x70, 0x07, 
+0xE4, 0x90, 0x92, 0x50, 0xF0, 0x51, 0x28, 0x22, 0x90, 0x92, 0x4E, 0x12, 0xA7, 0xE2, 0x30, 0xE0, 
+0x0F, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x12, 0xD5, 0x21, 0xA3, 0x04, 0xF0, 0x02, 0x8E, 0x0B, 
+0x7D, 0x08, 0xE4, 0xFF, 0x02, 0x6F, 0x06, 0xE4, 0x90, 0x93, 0x68, 0xF0, 0xA3, 0xF0, 0x90, 0x06, 
+0x32, 0xE0, 0x44, 0x20, 0xF0, 0x12, 0x75, 0xB5, 0xEF, 0x64, 0x01, 0x70, 0x6C, 0x90, 0x92, 0x48, 
+0xE0, 0xFF, 0x90, 0x93, 0x92, 0x74, 0x0D, 0xF0, 0x7B, 0x08, 0x7D, 0x01, 0x12, 0xB7, 0x13, 0x12, 
+0xD5, 0x95, 0x90, 0x93, 0x65, 0x51, 0xF8, 0x90, 0x93, 0x67, 0xEF, 0xF0, 0x90, 0x93, 0x65, 0x12, 
+0xD4, 0x98, 0xE4, 0xFD, 0x12, 0x97, 0x5E, 0x90, 0x93, 0x67, 0xE0, 0xFF, 0x90, 0x93, 0x66, 0xE0, 
+0x2F, 0xFF, 0x90, 0x93, 0x65, 0xE0, 0x34, 0x00, 0xCF, 0x24, 0x30, 0xCF, 0x34, 0x00, 0xFE, 0x90, 
+0x93, 0x68, 0xF0, 0xA3, 0xEF, 0xF0, 0x51, 0xD3, 0x51, 0xCA, 0x90, 0x92, 0x48, 0xE0, 0xFB, 0xE4, 
+0xFF, 0x12, 0xAE, 0x13, 0x51, 0xCA, 0x90, 0x92, 0x44, 0xE0, 0xFB, 0x7F, 0x11, 0x12, 0xAE, 0x13, 
+0x12, 0x8F, 0xDC, 0x90, 0x91, 0xF7, 0x12, 0xAF, 0xEF, 0x22, 0x90, 0x93, 0x68, 0xE0, 0xFC, 0xA3, 
+0xE0, 0xFD, 0x22, 0xAD, 0x07, 0x90, 0x91, 0xEF, 0x12, 0xAF, 0xEF, 0x90, 0x91, 0xEF, 0xE0, 0xFF, 
+0xAE, 0x05, 0x74, 0x04, 0x2E, 0x91, 0xBC, 0xEF, 0xF0, 0x90, 0x91, 0xEF, 0xA3, 0xE0, 0xFF, 0x74, 
+0x05, 0x2E, 0x12, 0xB7, 0xE2, 0xEF, 0xF0, 0x22, 0xA3, 0xE0, 0xFE, 0x24, 0x28, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 0x29, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0xFD, 0x74, 0x2C, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFE, 
+0xEF, 0x30, 0xE7, 0x04, 0x7C, 0x02, 0x80, 0x02, 0xE4, 0xFC, 0xED, 0x30, 0xE6, 0x09, 0xAF, 0x03, 
+0x12, 0xCE, 0xBD, 0xAE, 0x07, 0x80, 0x02, 0xE4, 0xFE, 0xEC, 0x24, 0x18, 0x2E, 0xFF, 0x22, 0x90, 
+0x92, 0x48, 0x71, 0xF3, 0xE0, 0xFE, 0x24, 0x28, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0xFF, 0x74, 0x29, 0x2E, 0x12, 0xD5, 0x0A, 0xE0, 0xFD, 0x90, 0x92, 0x79, 0xE0, 0x24, 0x2C, 0x71, 
+0x15, 0x90, 0x92, 0x79, 0xE0, 0x2F, 0x24, 0x30, 0xA3, 0xF0, 0xE0, 0xFD, 0x24, 0x04, 0x91, 0xBC, 
+0xE0, 0xFE, 0x12, 0xB7, 0xDF, 0x91, 0x14, 0x90, 0x91, 0xEF, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 
+0x7A, 0xE0, 0x24, 0x0C, 0xF9, 0xE4, 0x34, 0xFC, 0x12, 0x8F, 0xAF, 0x75, 0x1E, 0x04, 0x7B, 0x01, 
+0x7A, 0x91, 0x79, 0xF1, 0x12, 0x68, 0xAB, 0x90, 0x92, 0x7A, 0xE0, 0x24, 0x14, 0xF0, 0xE0, 0xFD, 
+0x24, 0x01, 0x91, 0x03, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0x12, 0xAD, 0xD3, 0x91, 0x14, 0x90, 0x91, 
+0xF5, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 0x49, 0x71, 0xF3, 0x90, 0x91, 0xEB, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x4E, 0x60, 0x14, 0x90, 0x92, 0x79, 0xE0, 0x24, 0x00, 0x12, 0x8F, 0xAB, 0x8F, 0x1E, 
+0x7B, 0x01, 0x7A, 0x91, 0x79, 0xF9, 0x12, 0x68, 0xAB, 0x90, 0x92, 0x4A, 0x71, 0xF3, 0x24, 0x00, 
+0x12, 0x8F, 0xAB, 0x90, 0x91, 0xED, 0xA3, 0xE0, 0xF5, 0x1E, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0x19, 
+0x02, 0x68, 0xAB, 0xE0, 0xFF, 0x12, 0x7A, 0x7E, 0x90, 0x92, 0x79, 0xEF, 0xF0, 0x22, 0xE4, 0xF0, 
+0x74, 0x01, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF0, 0x90, 0x01, 0x17, 0xE0, 
+0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x22, 0xE4, 0xFD, 0xFC, 
+0x90, 0x92, 0x47, 0x12, 0xC7, 0x5D, 0xAB, 0x05, 0x74, 0x01, 0x2B, 0x91, 0x03, 0xE0, 0xFE, 0x74, 
+0x00, 0x2B, 0x12, 0xAD, 0xD3, 0x12, 0xD4, 0x8F, 0x90, 0x91, 0xE5, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 
+0x03, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x02, 0x2B, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0x91, 0xB3, 0x90, 0x91, 0xE7, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x05, 0x2B, 0x12, 
+0xB7, 0xE2, 0xE0, 0xFE, 0x74, 0x04, 0x2B, 0x91, 0xBC, 0x91, 0xB5, 0x90, 0x91, 0xE9, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x74, 0x07, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x06, 
+0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0x91, 0xB3, 0x90, 0x91, 0xEB, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 
+0x09, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x08, 0x2B, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x90, 0x91, 0xED, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x22, 0xF5, 0x83, 0xE0, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x22, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0xCA, 0x15, 0x90, 0x90, 
+0x08, 0x12, 0xD4, 0x45, 0xB1, 0x7D, 0xF1, 0xEE, 0x90, 0x90, 0x08, 0x12, 0xD4, 0xF3, 0xB1, 0x7C, 
+0x12, 0xD4, 0xDC, 0x90, 0x90, 0x08, 0xB1, 0x74, 0x12, 0xD5, 0x8C, 0x90, 0x90, 0x08, 0x12, 0xD5, 
+0xA7, 0x4E, 0x12, 0x96, 0x85, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x90, 0x0A, 0xE0, 0x54, 0xFE, 0x12, 
+0x95, 0x9B, 0xFE, 0x54, 0x01, 0xFD, 0x90, 0x90, 0x09, 0xE0, 0x54, 0xFE, 0x4D, 0xFD, 0xF0, 0xEE, 
+0x54, 0x04, 0xFE, 0xED, 0x54, 0xFB, 0x4E, 0xF0, 0xEF, 0x54, 0x10, 0xFF, 0xA3, 0xE0, 0x54, 0xEF, 
+0x4F, 0xFF, 0x12, 0x96, 0x85, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0x90, 0x90, 0x0A, 0x91, 
+0x0B, 0x12, 0xC6, 0xE2, 0x90, 0x90, 0x08, 0xE0, 0xC3, 0x13, 0x54, 0x01, 0xFF, 0x12, 0xD1, 0x73, 
+0x90, 0x90, 0x08, 0xE0, 0x13, 0x13, 0x54, 0x01, 0xFF, 0x12, 0xCF, 0x0B, 0x90, 0x90, 0x08, 0xE0, 
+0x13, 0x13, 0x13, 0x54, 0x01, 0xFF, 0x12, 0xC7, 0x18, 0x90, 0x90, 0x08, 0xE0, 0xC4, 0x13, 0x13, 
+0x54, 0x01, 0xFF, 0xF1, 0xE6, 0x90, 0x90, 0x08, 0xE0, 0x54, 0x01, 0xFF, 0x12, 0xC1, 0xA5, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0xFF, 0xF0, 0x12, 
+0x02, 0x06, 0xFE, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x97, 0xF6, 0x12, 0x02, 
+0x06, 0x20, 0xE0, 0x47, 0x90, 0x90, 0x0C, 0xE0, 0xFF, 0x12, 0x9F, 0x8D, 0x20, 0xE0, 0x37, 0xEF, 
+0xF1, 0x04, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0xC7, 0xE9, 0x90, 0x92, 
+0x67, 0xE0, 0x90, 0x00, 0x4A, 0xF0, 0x90, 0x92, 0x68, 0xE0, 0x90, 0x00, 0x4E, 0xF0, 0x90, 0x92, 
+0x69, 0xE0, 0x90, 0x00, 0x72, 0xF0, 0x90, 0x92, 0x6A, 0xE0, 0x90, 0x00, 0x40, 0xF0, 0x90, 0x92, 
+0x6B, 0xE0, 0x90, 0x00, 0x67, 0xF0, 0x12, 0xC4, 0x62, 0xC1, 0xEC, 0x12, 0x97, 0xED, 0xFF, 0x54, 
+0x01, 0xFE, 0x90, 0x90, 0x0B, 0x12, 0xD4, 0x45, 0xB1, 0x7D, 0xF1, 0xEE, 0x90, 0x90, 0x0B, 0x12, 
+0xD4, 0xF3, 0xB1, 0x7C, 0x12, 0xD4, 0xDC, 0x90, 0x90, 0x0B, 0xB1, 0x74, 0x12, 0xD5, 0x8C, 0x90, 
+0x90, 0x0B, 0x12, 0xD5, 0xA7, 0x12, 0x95, 0x9B, 0x54, 0x80, 0xFF, 0x90, 0x90, 0x0C, 0xE0, 0x54, 
+0x7F, 0x4F, 0xF0, 0x12, 0xD6, 0x02, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x04, 0xF0, 
+0x12, 0x97, 0xED, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 
+0x08, 0xF0, 0x90, 0x89, 0x82, 0xE0, 0xB4, 0x02, 0x08, 0x12, 0x9F, 0x89, 0x30, 0xE0, 0x02, 0xC1, 
+0xCE, 0x90, 0x00, 0x4A, 0xE0, 0x90, 0x92, 0x67, 0xF0, 0xE0, 0x54, 0xFE, 0x90, 0x00, 0x4A, 0xF0, 
+0x90, 0x00, 0x4E, 0xE0, 0x90, 0x92, 0x68, 0xF0, 0xE0, 0x54, 0xDF, 0x90, 0x00, 0x4E, 0xF0, 0x90, 
+0x00, 0x72, 0xE0, 0x90, 0x92, 0x69, 0xF0, 0xE0, 0x54, 0xFB, 0x90, 0x00, 0x72, 0xF0, 0x90, 0x00, 
+0x40, 0xE0, 0x90, 0x92, 0x6A, 0xF0, 0xE0, 0x54, 0xFC, 0x90, 0x00, 0x40, 0xF0, 0x90, 0x00, 0x67, 
+0xE0, 0x90, 0x92, 0x6B, 0xF0, 0xE0, 0x54, 0xFB, 0x90, 0x00, 0x67, 0x12, 0x95, 0x9C, 0x54, 0x7F, 
+0xFF, 0x90, 0x90, 0x0C, 0xE0, 0x54, 0x80, 0x12, 0x96, 0x84, 0x90, 0x90, 0x0D, 0xF0, 0x12, 0x95, 
+0xA9, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x90, 0x0E, 0x12, 0xCA, 0x1D, 0x54, 0xFE, 0xFF, 0xEE, 0x54, 
+0x01, 0x4F, 0x12, 0x97, 0x02, 0x54, 0x04, 0xFF, 0x90, 0x90, 0x0F, 0xE0, 0x54, 0xFB, 0x4F, 0xF0, 
+0xF1, 0x00, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0xC7, 0xE9, 0x90, 0x89, 
+0x82, 0xE0, 0xB4, 0x01, 0x17, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x91, 0xE3, 0x74, 
+0x05, 0xF0, 0x12, 0xC6, 0xF2, 0x7A, 0x91, 0x79, 0x22, 0x12, 0x04, 0x7A, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x8F, 0xF8, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x8F, 0xFC, 0xE0, 0xFD, 0xF1, 0xB7, 
+0x90, 0x90, 0x0C, 0xE0, 0x54, 0x7F, 0xFF, 0x90, 0x90, 0x0B, 0xE0, 0xFE, 0xC4, 0x13, 0x22, 0xAD, 
+0x07, 0x90, 0x90, 0x0D, 0xE0, 0x75, 0xF0, 0x40, 0xA4, 0xFF, 0x90, 0x8F, 0xF8, 0xE5, 0xF0, 0xF0, 
+0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x90, 0x0E, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0x8F, 
+0xFB, 0xF0, 0x90, 0x90, 0x0F, 0xE0, 0x13, 0x13, 0x54, 0x01, 0x90, 0x8F, 0xFC, 0xF0, 0xED, 0x64, 
+0x01, 0x70, 0x73, 0xE0, 0x70, 0x15, 0x90, 0x8F, 0xF8, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 0x0B, 
+0x90, 0x8F, 0xF8, 0x74, 0xFF, 0x75, 0xF0, 0xD0, 0x12, 0x02, 0xE7, 0xF1, 0x00, 0x54, 0x07, 0x7D, 
+0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0xC7, 0xE9, 0xF1, 0x00, 0x54, 0x01, 0xFD, 0x12, 0xC7, 
+0xE9, 0x90, 0x90, 0x0E, 0xE0, 0x30, 0xE0, 0x3E, 0xD1, 0xF1, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 
+0x02, 0x7D, 0x01, 0x12, 0xC7, 0xE9, 0xE4, 0x90, 0x8F, 0xFA, 0xF0, 0x90, 0x8F, 0xFB, 0xE0, 0xFF, 
+0x90, 0x8F, 0xFA, 0xE0, 0xC3, 0x9F, 0x50, 0x1E, 0xD1, 0xF1, 0x54, 0x01, 0xFD, 0x12, 0xC7, 0xE9, 
+0xD1, 0xF1, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0xC7, 0xE9, 0x90, 0x8F, 
+0xFA, 0xE0, 0x04, 0xF0, 0x80, 0xD5, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x15, 
+0x8F, 0x16, 0xBD, 0x01, 0x15, 0xE5, 0x16, 0x78, 0x03, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 
+0xFF, 0xEE, 0x54, 0x1F, 0xFE, 0x12, 0x79, 0xC9, 0x80, 0x07, 0xAF, 0x16, 0xAE, 0x15, 0x12, 0x7B, 
+0x8D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x60, 0x04, 0x91, 0x1D, 0x71, 0x3F, 0x22, 0x54, 0x04, 
+0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x22, 0x90, 0x8A, 0x83, 0xE0, 0x60, 0x03, 0x12, 0xA4, 0xF7, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8B, 0x3D, 0xE0, 0x30, 0xE0, 0x29, 0x90, 
+0x8B, 0x44, 0xE0, 0xB4, 0x01, 0x15, 0xA3, 0xE0, 0xB4, 0x01, 0x1D, 0x74, 0x02, 0xF0, 0x90, 0x8B, 
+0x4B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x72, 0x10, 0x80, 0x0D, 0x90, 0x8B, 0x44, 0xE0, 0xB4, 
+0x02, 0x06, 0x74, 0x03, 0xF0, 0x12, 0x53, 0x4D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8B, 0x05, 
+0xE0, 0x30, 0xE0, 0x05, 0x12, 0x78, 0x11, 0x80, 0x03, 0x12, 0x69, 0x8C, 0x90, 0x8B, 0x3D, 0xE0, 
+0x30, 0xE0, 0x03, 0x12, 0x53, 0x4D, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x71, 0xC6, 
+0xEC, 0x90, 0x8F, 0xE8, 0x12, 0x04, 0x31, 0x90, 0x8F, 0xE8, 0x12, 0x93, 0x74, 0x7F, 0x30, 0x7E, 
+0x08, 0x12, 0x6F, 0xFE, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 
+0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x71, 0xD2, 0xE4, 
+0xFD, 0x12, 0x6F, 0x45, 0x71, 0xBC, 0x30, 0xE0, 0x05, 0x7F, 0x03, 0x12, 0x71, 0x29, 0x90, 0x8B, 
+0x05, 0xE0, 0x20, 0xE0, 0x31, 0x71, 0xB4, 0x30, 0xE0, 0x2C, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x07, 
+0xE4, 0x90, 0x8F, 0xE6, 0xF0, 0x80, 0x06, 0x90, 0x8F, 0xE6, 0x74, 0x01, 0xF0, 0xEF, 0xC4, 0x13, 
+0x54, 0x07, 0x90, 0x8F, 0xE7, 0x30, 0xE0, 0x05, 0x74, 0x01, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 
+0x90, 0x8F, 0xE6, 0x12, 0x92, 0x40, 0x11, 0xFB, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x7F, 0x02, 0x12, 
+0x7A, 0xB8, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x7F, 0x02, 0x12, 0x7A, 0xB8, 
+0xEF, 0x22, 0x7F, 0xFF, 0x12, 0x8F, 0xCF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x71, 0xC6, 
+0xEC, 0x90, 0x8F, 0xEE, 0x12, 0x04, 0x31, 0x90, 0x8F, 0xEE, 0x12, 0x93, 0x74, 0x7F, 0x30, 0x7E, 
+0x08, 0x12, 0x6F, 0xFE, 0x71, 0xD2, 0x7D, 0x01, 0x12, 0x6F, 0x45, 0x12, 0xB6, 0xA3, 0x11, 0xFB, 
+0x11, 0xE5, 0x11, 0xE5, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x7A, 0xA5, 0x90, 0x01, 0x00, 0x74, 
+0x3F, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 0x90, 0x01, 0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 
+0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0x71, 0xBC, 0x30, 0xE0, 0x05, 0x7F, 0x01, 0x12, 0x71, 0x29, 
+0x71, 0xB4, 0x30, 0xE0, 0x33, 0x90, 0x8B, 0x2C, 0xE0, 0x60, 0x08, 0x90, 0x8F, 0xEC, 0x74, 0x01, 
+0xF0, 0x80, 0x05, 0xE4, 0x90, 0x8F, 0xEC, 0xF0, 0xEF, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 
+0xE4, 0x90, 0x8F, 0xED, 0xF0, 0x80, 0x06, 0x90, 0x8F, 0xED, 0x74, 0x02, 0xF0, 0x90, 0x8F, 0xEC, 
+0x12, 0x92, 0x40, 0x7F, 0x01, 0x12, 0x71, 0x29, 0x90, 0x8A, 0xE7, 0xE0, 0x60, 0x02, 0xE4, 0xF0, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x60, 0x3E, 0x90, 0x92, 0x3D, 0xE0, 0xFF, 0x60, 0x02, 0xF1, 
+0x67, 0x90, 0x01, 0xC7, 0xE4, 0x12, 0xBC, 0x0B, 0xD1, 0xE2, 0x90, 0x06, 0x09, 0xE0, 0x54, 0xFE, 
+0xF0, 0x7D, 0x35, 0x31, 0x02, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xF0, 0x91, 0x9F, 0x71, 0xAC, 
+0x11, 0x57, 0xE4, 0xFD, 0xFF, 0x12, 0x8F, 0xCF, 0x91, 0x2F, 0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 
+0xFD, 0xE4, 0xFF, 0x02, 0x7B, 0x97, 0x7D, 0x08, 0xE4, 0xFF, 0x12, 0x7B, 0x53, 0x90, 0x06, 0x90, 
+0xE0, 0x54, 0xF0, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x54, 0xFB, 0xF0, 0x91, 0x62, 0x12, 0x8F, 0xFC, 
+0x7E, 0x00, 0x7F, 0x25, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x08, 0x12, 0x04, 0x7A, 0x90, 
+0x06, 0x90, 0xE0, 0x44, 0x20, 0xF0, 0x91, 0x8C, 0x12, 0x8D, 0x19, 0x90, 0x89, 0x82, 0xE0, 0xFF, 
+0x64, 0x02, 0x70, 0x29, 0x51, 0xAC, 0x30, 0xE0, 0x02, 0x7E, 0x01, 0x90, 0x90, 0x27, 0x51, 0xAA, 
+0x30, 0xE1, 0x02, 0x7E, 0x01, 0x90, 0x90, 0x25, 0x51, 0xAA, 0x30, 0xE2, 0x02, 0x7E, 0x01, 0x90, 
+0x90, 0x26, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 0xE0, 0x90, 0x02, 0xFB, 0xF0, 0x22, 0xEF, 0x64, 0x01, 
+0x70, 0x1D, 0x51, 0xA3, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 0x90, 0x27, 0x51, 0xA1, 0x30, 0xE1, 
+0x02, 0x7F, 0x01, 0x90, 0x90, 0x25, 0x51, 0xA1, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x80, 0x23, 0x90, 
+0x89, 0x82, 0xE0, 0x64, 0x03, 0x70, 0x20, 0x51, 0x9A, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 0x90, 
+0x27, 0x51, 0x98, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x90, 0x90, 0x25, 0x51, 0x98, 0x30, 0xE2, 0x02, 
+0x7F, 0x01, 0x90, 0x90, 0x26, 0xEF, 0xF0, 0x22, 0xEF, 0xF0, 0x90, 0xFD, 0x78, 0xE0, 0x7F, 0x00, 
+0x22, 0xEF, 0xF0, 0x90, 0xFD, 0x70, 0xE0, 0x7F, 0x00, 0x22, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 0xE0, 
+0x7E, 0x00, 0x22, 0x90, 0x93, 0x84, 0xEF, 0xF0, 0x90, 0x8B, 0x2D, 0xE0, 0x70, 0x51, 0x7F, 0x48, 
+0x7E, 0x09, 0x12, 0x6F, 0xC1, 0xEE, 0x54, 0x0F, 0xFE, 0xE4, 0xFD, 0xFC, 0x90, 0x93, 0x85, 0x12, 
+0x04, 0x31, 0xE4, 0x7F, 0x80, 0x71, 0x81, 0x70, 0x05, 0x90, 0x8B, 0x0B, 0x80, 0x1B, 0xE4, 0xFF, 
+0xFE, 0x71, 0x83, 0x70, 0x0A, 0x90, 0x8B, 0x0B, 0x04, 0xF0, 0xE4, 0xA3, 0xF0, 0x80, 0x4C, 0xE4, 
+0xFF, 0x71, 0x81, 0x70, 0x09, 0x90, 0x8B, 0x0B, 0x04, 0xF0, 0xA3, 0xF0, 0x80, 0x3D, 0xE4, 0x7F, 
+0x80, 0xFE, 0x71, 0x83, 0x70, 0x35, 0x90, 0x8B, 0x0B, 0xF0, 0xA3, 0x04, 0xF0, 0x80, 0x2C, 0x71, 
+0xAD, 0xEF, 0x54, 0x02, 0x71, 0x96, 0x60, 0x08, 0x90, 0x8B, 0x0B, 0x74, 0x01, 0xF0, 0x80, 0x05, 
+0xE4, 0x90, 0x8B, 0x0B, 0xF0, 0xD1, 0xDB, 0xEF, 0x54, 0x01, 0x71, 0x96, 0x60, 0x07, 0xE4, 0x90, 
+0x8B, 0x0C, 0xF0, 0x80, 0x06, 0x90, 0x8B, 0x0C, 0x74, 0x01, 0xF0, 0x90, 0x8B, 0x05, 0xE0, 0x44, 
+0x01, 0xF0, 0x7D, 0x11, 0x31, 0x02, 0x90, 0x07, 0x78, 0xE0, 0x90, 0x8B, 0x0A, 0xF0, 0x90, 0x8B, 
+0x2C, 0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0x92, 0x45, 0x90, 0x93, 0x84, 0xE0, 0xFD, 0x70, 0x02, 0x80, 
+0x1C, 0xED, 0xB4, 0x01, 0x06, 0x71, 0x8F, 0x44, 0x20, 0xF0, 0x22, 0x90, 0x93, 0x84, 0xE0, 0xFD, 
+0xB4, 0x02, 0x06, 0x71, 0x8F, 0x44, 0x60, 0xF0, 0x22, 0xED, 0xB4, 0x03, 0x03, 0x71, 0x8F, 0xF0, 
+0x22, 0x7E, 0x02, 0xFD, 0xFC, 0x90, 0x93, 0x85, 0x12, 0x86, 0xD4, 0xC3, 0x02, 0x03, 0xDA, 0x90, 
+0x8B, 0x05, 0xE0, 0x54, 0x1F, 0x22, 0xFF, 0xE4, 0xFE, 0xFD, 0xFC, 0x90, 0x93, 0x85, 0x12, 0x04, 
+0x31, 0x90, 0x93, 0x85, 0x12, 0x04, 0xB2, 0xEC, 0x4D, 0x4E, 0x4F, 0x22, 0x22, 0x7F, 0x2C, 0x7E, 
+0x09, 0x02, 0x6F, 0xC1, 0x90, 0x8A, 0xE8, 0xE0, 0xFF, 0xC3, 0x13, 0x22, 0x90, 0x8A, 0xE8, 0xE0, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x7F, 0x30, 0x7E, 0x08, 0x12, 0x6F, 0xC1, 0xED, 0x44, 0x80, 
+0xFD, 0x22, 0x90, 0x90, 0x26, 0xE0, 0xFF, 0x90, 0x90, 0x25, 0xE0, 0xFB, 0x90, 0x90, 0x27, 0xE0, 
+0x90, 0x84, 0xDC, 0xF0, 0x22, 0xD1, 0xD5, 0x12, 0x7B, 0x0E, 0xB1, 0xF0, 0x91, 0x14, 0x51, 0x00, 
+0xF1, 0x95, 0x91, 0x1B, 0x12, 0x47, 0xFC, 0x90, 0x92, 0x6F, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 
+0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xF0, 0xF0, 0xE4, 0x90, 0x92, 0x71, 0xF0, 0x90, 0x92, 0x6F, 0xE0, 
+0x54, 0xEF, 0xF0, 0x22, 0xD1, 0xCA, 0x79, 0x04, 0x02, 0x04, 0x7A, 0xD1, 0xF2, 0x7A, 0x92, 0x79, 
+0x52, 0x12, 0x04, 0x7A, 0x90, 0x92, 0x53, 0x74, 0x08, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0x22, 0xE4, 
+0xFF, 0x74, 0x18, 0x91, 0x57, 0x74, 0x18, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xEE, 
+0xF0, 0x74, 0x10, 0x91, 0x57, 0x74, 0x12, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xEE, 
+0xF0, 0x0F, 0xEF, 0xB4, 0x06, 0xDB, 0x22, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x06, 0xF5, 0x83, 0xE0, 
+0xFE, 0x22, 0x91, 0x8C, 0x90, 0x92, 0x4C, 0xE0, 0xFF, 0x91, 0xEB, 0x90, 0x01, 0x3F, 0x74, 0x04, 
+0xF0, 0x90, 0x89, 0x82, 0xE0, 0xFF, 0xB4, 0x01, 0x07, 0x90, 0xFD, 0x00, 0xE0, 0x54, 0xEF, 0xF0, 
+0xEF, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xE4, 0xFD, 0x7F, 0x8F, 0x12, 0x7A, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 
+0xBB, 0xAD, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x9F, 0xF0, 0x74, 0xC4, 0xA3, 0xF0, 0xED, 0x64, 0x01, 
+0x60, 0x1E, 0x12, 0x9F, 0x81, 0xED, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x40, 0xF0, 0x80, 
+0x0A, 0xED, 0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x41, 0xF0, 0x7F, 0x01, 0x02, 0x99, 0xDB, 
+0xB1, 0x51, 0x90, 0x02, 0x87, 0xE0, 0x70, 0xF8, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x02, 0xF0, 0x74, 
+0x9F, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xC4, 0xA3, 0xF0, 0x22, 0x90, 0x92, 0x7C, 0xEF, 0xF0, 
+0xE4, 0xFF, 0x74, 0xB3, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x84, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x04, 0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x08, 0xE3, 0x90, 
+0x91, 0xE3, 0xE0, 0x90, 0x04, 0x8C, 0xF0, 0x75, 0x1B, 0x01, 0x75, 0x1C, 0x91, 0x75, 0x1D, 0x22, 
+0x75, 0x1E, 0x08, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0xBB, 0x12, 0x68, 0xAB, 0x90, 0x92, 0x4C, 0xE0, 
+0x60, 0x1E, 0x90, 0x92, 0x7C, 0xE0, 0xFF, 0x12, 0x7A, 0x7E, 0x7E, 0x00, 0xF1, 0x0D, 0xC0, 0x03, 
+0x8B, 0x1B, 0x75, 0x1C, 0x91, 0x75, 0x1D, 0xB3, 0x75, 0x1E, 0x32, 0xD0, 0x03, 0x12, 0x68, 0xAB, 
+0x22, 0xF1, 0x04, 0x12, 0xBC, 0x14, 0x90, 0x92, 0x79, 0xD1, 0xFB, 0xF9, 0x90, 0x90, 0x08, 0xE0, 
+0x30, 0xE0, 0x69, 0xEC, 0xC3, 0x99, 0x50, 0x64, 0x90, 0x92, 0x79, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 
+0xEA, 0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0xAD, 0x07, 0x12, 0xD4, 0x79, 0x54, 0x3F, 0x90, 0x92, 
+0x7B, 0x12, 0xD4, 0x54, 0xFB, 0xEF, 0x24, 0x18, 0xFF, 0xE4, 0x33, 0xCF, 0x2B, 0xCF, 0x3A, 0x90, 
+0x92, 0x7B, 0x8F, 0xF0, 0x12, 0x02, 0xE7, 0x90, 0x92, 0x7B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xB1, 
+0xCD, 0x90, 0x92, 0x7B, 0xEE, 0xD1, 0xEA, 0xF1, 0x76, 0xD3, 0x90, 0x92, 0x7A, 0xE0, 0x9F, 0x90, 
+0x92, 0x79, 0xE0, 0x9E, 0x40, 0x0E, 0xF1, 0x85, 0x90, 0x92, 0x7A, 0xE0, 0x9F, 0xF0, 0x90, 0x92, 
+0x79, 0xE0, 0x9E, 0xF0, 0x90, 0x92, 0x79, 0xF1, 0xA8, 0x0C, 0x80, 0x97, 0x22, 0x7D, 0x07, 0xEF, 
+0x5D, 0xC3, 0x60, 0x0B, 0xB1, 0xE4, 0x5F, 0x24, 0x08, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x04, 0xB1, 
+0xE4, 0x5F, 0xFF, 0x22, 0x74, 0xFF, 0x9D, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x22, 
+0x7E, 0x00, 0x7F, 0x62, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0x7E, 0x12, 0x04, 0x7A, 0xD1, 
+0xCA, 0x79, 0x04, 0x12, 0x04, 0x7A, 0x90, 0x8A, 0x82, 0x74, 0x02, 0xF0, 0x90, 0x8A, 0x89, 0x14, 
+0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0x90, 0x8A, 0x8F, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xD1, 
+0xBA, 0xF1, 0xD1, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xDB, 0x7D, 0x0C, 0x7F, 0x02, 0x12, 0x53, 0xDB, 
+0x7D, 0x0C, 0x7F, 0x01, 0x12, 0x53, 0xDB, 0x90, 0x89, 0x82, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 
+0x8A, 0x8E, 0x74, 0xDD, 0xF0, 0x80, 0x11, 0xEF, 0xB4, 0x03, 0x08, 0x90, 0x8A, 0x8E, 0x74, 0xD4, 
+0xF0, 0x80, 0x05, 0xE4, 0x90, 0x8A, 0x8E, 0xF0, 0x7F, 0x79, 0x12, 0x7A, 0xB8, 0xEF, 0x54, 0x03, 
+0xFF, 0xBF, 0x02, 0x0F, 0x7F, 0x28, 0x12, 0x7A, 0xB8, 0xEF, 0x30, 0xE2, 0x06, 0x90, 0x8A, 0xA0, 
+0x74, 0x02, 0xF0, 0x90, 0x8A, 0xE0, 0x74, 0x03, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xA3, 0xE0, 0x54, 
+0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x07, 0xD1, 0xBA, 0x7F, 0x01, 0x12, 0x6F, 0x83, 0x90, 0x05, 
+0x58, 0x74, 0x02, 0xF0, 0x7E, 0x00, 0xFF, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8A, 0x79, 0xE7, 0x12, 
+0x04, 0x7A, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 
+0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x8A, 0xE9, 0xF0, 0x22, 0xF0, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 
+0x04, 0x90, 0x8A, 0x9B, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0x22, 0x7E, 0x00, 0x7F, 0x04, 0x7D, 0x00, 
+0x7B, 0x01, 0x7A, 0x90, 0x22, 0xE4, 0xFD, 0xFF, 0x02, 0x6E, 0x43, 0x7F, 0x30, 0x7E, 0x09, 0x02, 
+0x6F, 0xC1, 0x90, 0x8A, 0x74, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 
+0x79, 0x22, 0x7E, 0x00, 0x7F, 0x08, 0x7D, 0x00, 0x7B, 0x01, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0x02, 0x87, 0xE0, 0x22, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0x22, 0x74, 0x00, 0x2F, 
+0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0xE4, 0xFD, 0xFC, 0xEF, 0x60, 0x35, 0x90, 0x92, 
+0x41, 0xF1, 0x5D, 0xF1, 0x0D, 0x12, 0x8D, 0xF8, 0x75, 0x1E, 0x40, 0x7B, 0x01, 0x7A, 0x90, 0x79, 
+0xD9, 0x12, 0x68, 0xAB, 0xE4, 0xFD, 0x7F, 0x03, 0x12, 0x58, 0x1A, 0x90, 0x92, 0x42, 0xE0, 0xF1, 
+0x54, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 0x76, 0x63, 0x7D, 0x01, 0x7F, 0x03, 
+0x12, 0x58, 0x1A, 0x22, 0x75, 0xF0, 0x80, 0xA4, 0xAE, 0xF0, 0x78, 0x03, 0x22, 0xE0, 0xFF, 0x12, 
+0x7A, 0x7E, 0x7C, 0x00, 0xAD, 0x07, 0x22, 0x12, 0x8F, 0xA3, 0x75, 0x1E, 0x08, 0x7B, 0x01, 0x7A, 
+0x91, 0x79, 0xB3, 0x02, 0x68, 0xAB, 0xEE, 0x8F, 0xF0, 0x12, 0x02, 0xE7, 0x90, 0x8A, 0x74, 0xE0, 
+0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x90, 0x8A, 0x75, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x8A, 0x74, 0xE0, 
+0x34, 0x00, 0xFE, 0xC3, 0x22, 0x90, 0x92, 0x4E, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 0xF0, 0x54, 
+0xFB, 0xF0, 0xA3, 0x74, 0x0A, 0x02, 0xA8, 0x9F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x02, 0x84, 
+0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x20, 
+0xE2, 0x03, 0x7F, 0x04, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x7F, 0x01, 0x20, 0xE1, 0x02, 0x7F, 0x02, 
+0x22, 0x90, 0x8A, 0xDA, 0x74, 0x04, 0xF0, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 
+0x64, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x93, 0x9D, 0xED, 0xF0, 0x90, 0x93, 0x9C, 0xEF, 0xF0, 0xD3, 0x94, 0x07, 0x50, 0x42, 0x7F, 
+0x47, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x47, 0x12, 0x7A, 
+0xA5, 0x7F, 0x46, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x46, 0x11, 
+0xA1, 0x60, 0x0D, 0x7F, 0x45, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0x80, 0x0C, 
+0x7F, 0x45, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x45, 0x80, 
+0x4A, 0x90, 0x93, 0x9C, 0xE0, 0x24, 0xF8, 0xF0, 0x7F, 0x63, 0x11, 0x93, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x63, 0x12, 0x7A, 0xA5, 0x7F, 0x62, 0x11, 0x93, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x62, 0x11, 0xA1, 0x60, 0x10, 0x7F, 0x61, 0x11, 0x93, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x61, 0x80, 0x0F, 0x7F, 0x61, 0x11, 0x93, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x61, 0x12, 0x7A, 0xA5, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x12, 0x7A, 0xB8, 0x90, 0x93, 0x9C, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 
+0x22, 0x12, 0x7A, 0xA5, 0x90, 0x93, 0x9D, 0xE0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 
+0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0x93, 0x65, 0xF0, 0xE0, 0xFF, 
+0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 
+0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 
+0x12, 0x75, 0x87, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x7A, 0xA5, 0x80, 
+0xFE, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8F, 0x95, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x12, 0x6F, 0xC1, 0x90, 0x8F, 0x9F, 0x12, 0x04, 0x31, 0x90, 0x8F, 0x97, 0x12, 0x04, 0xB2, 
+0x12, 0x03, 0xCD, 0x90, 0x8F, 0x9F, 0x12, 0x86, 0xD4, 0x12, 0x86, 0xBA, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0x8F, 0x97, 0x12, 0x04, 0xB2, 0x90, 0x8F, 0x9B, 0x12, 0x86, 0xD4, 
+0x12, 0x86, 0xBA, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x86, 0xC7, 0x90, 0x8F, 
+0xA3, 0x12, 0x04, 0x31, 0x90, 0x8F, 0xA3, 0x12, 0x93, 0x74, 0x90, 0x8F, 0x95, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x12, 0x6F, 0xFE, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x93, 0x76, 0xF0, 0xA3, 
+0xF0, 0x7F, 0x83, 0x12, 0x7A, 0xB8, 0x90, 0x93, 0x75, 0xEF, 0xF0, 0x7F, 0x83, 0x12, 0x7A, 0xB8, 
+0xAE, 0x07, 0x90, 0x93, 0x75, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x93, 0x77, 0xE0, 
+0x94, 0x64, 0x90, 0x93, 0x76, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 
+0xF0, 0x90, 0x93, 0x75, 0xE0, 0xFF, 0x22, 0x90, 0x93, 0x76, 0x12, 0xAF, 0xEF, 0x80, 0xC2, 0x90, 
+0x01, 0xC4, 0x74, 0x9F, 0xF0, 0x74, 0xC9, 0xA3, 0xF0, 0x7F, 0x90, 0x12, 0x7A, 0xB8, 0xEF, 0x20, 
+0xE0, 0xF7, 0x74, 0x9F, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xC9, 0xA3, 0xF0, 0x22, 0x90, 0x93, 
+0x83, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x31, 0xE7, 0xE0, 0x90, 0x93, 
+0x89, 0xF0, 0xED, 0x90, 0x00, 0x73, 0x70, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 
+0xFB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x89, 0x7C, 0xA3, 0xE0, 0x24, 0x7F, 0xF5, 0x82, 
+0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0x51, 0x15, 0x90, 0x92, 0x4E, 0x51, 0x1D, 0x54, 0x04, 0xFF, 
+0xEE, 0x54, 0xFB, 0x4F, 0xF0, 0x12, 0x02, 0x06, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x95, 0x9D, 
+0x90, 0x92, 0x4F, 0xF0, 0x22, 0x12, 0x02, 0x06, 0xFF, 0x54, 0x01, 0xFE, 0x22, 0xE0, 0x54, 0xFE, 
+0x4E, 0xFE, 0xF0, 0xEF, 0x22, 0x90, 0x90, 0x11, 0xE0, 0x30, 0xE0, 0x0D, 0x90, 0x90, 0x0B, 0xE0, 
+0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0xEF, 0x90, 0x01, 0xC7, 
+0xB4, 0xA0, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x02, 0x9F, 0x81, 0x71, 0xC6, 
+0xE4, 0x90, 0x92, 0xCB, 0xF0, 0x90, 0x92, 0xCB, 0xE0, 0xFD, 0xC3, 0x94, 0x06, 0x50, 0x22, 0x90, 
+0x92, 0xC4, 0xE0, 0x24, 0x04, 0x71, 0xBD, 0x12, 0x52, 0xBD, 0x90, 0x92, 0xCB, 0xE0, 0x24, 0xC5, 
+0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x92, 0xCB, 0xE0, 0x04, 0xF0, 0x80, 
+0xD4, 0x78, 0x12, 0x7C, 0x90, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xC5, 0xD1, 0xA5, 0x7F, 
+0x00, 0x70, 0x02, 0x7F, 0x01, 0x22, 0xB1, 0xB0, 0x71, 0xCF, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0xBA, 
+0x12, 0x9F, 0xF1, 0x78, 0xBD, 0x7C, 0x92, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0xC0, 0x12, 
+0x9F, 0xC6, 0x12, 0xB5, 0xC8, 0x51, 0x4E, 0xEF, 0x60, 0x7A, 0x12, 0x9F, 0x6E, 0xFE, 0x90, 0x92, 
+0xC1, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x06, 0xFF, 0xE4, 0x3E, 0x12, 0x9E, 0x2A, 0xEF, 0x64, 0x08, 
+0x70, 0x62, 0x90, 0x92, 0xC2, 0xE0, 0x24, 0x07, 0x71, 0x35, 0x12, 0x9E, 0x2A, 0xEF, 0x70, 0x54, 
+0x90, 0x92, 0xBC, 0xF0, 0x90, 0x92, 0xBC, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x25, 0x90, 0x92, 
+0xC2, 0xE0, 0x24, 0x18, 0xFD, 0x90, 0x92, 0xC1, 0xE0, 0x12, 0x9E, 0x20, 0x90, 0x92, 0xBC, 0xE0, 
+0x24, 0xBD, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x92, 0xBC, 0xE0, 0x04, 
+0xF0, 0x80, 0xD1, 0x78, 0xBD, 0x7C, 0x92, 0xD1, 0xAE, 0xEF, 0x70, 0x18, 0x90, 0x92, 0xC2, 0xE0, 
+0x24, 0x08, 0x71, 0x35, 0xFE, 0x71, 0x3D, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xC7, 0x74, 
+0x22, 0x12, 0x9F, 0x80, 0x22, 0xFF, 0x90, 0x92, 0xC1, 0xE0, 0x34, 0x00, 0x22, 0x71, 0xC6, 0x7D, 
+0x09, 0x12, 0x52, 0xBD, 0xEF, 0x64, 0x06, 0x70, 0x27, 0x71, 0xB4, 0x7D, 0x14, 0x12, 0x52, 0xBD, 
+0xEF, 0x70, 0x1D, 0x71, 0xB4, 0x7D, 0x15, 0x12, 0x52, 0xBD, 0xEF, 0x64, 0x50, 0x70, 0x11, 0x71, 
+0xB4, 0x7D, 0x21, 0x12, 0x52, 0xBD, 0xEF, 0x20, 0xE0, 0x03, 0x30, 0xE2, 0x03, 0x7F, 0x01, 0x22, 
+0x90, 0x90, 0x09, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x36, 0x71, 0xB4, 0x7D, 0x09, 0x12, 
+0x52, 0xBD, 0xEF, 0x64, 0x11, 0x70, 0x2A, 0x90, 0x92, 0xC4, 0xE0, 0x24, 0x14, 0x71, 0xBD, 0x90, 
+0x92, 0xC5, 0xF0, 0xA3, 0xEF, 0xF0, 0x7D, 0x02, 0x12, 0x52, 0xBD, 0xEF, 0x70, 0x13, 0x90, 0x92, 
+0xC5, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x03, 0x12, 0x52, 0xBD, 0xBF, 0x89, 0x03, 0x7F, 0x01, 
+0x22, 0x7F, 0x00, 0x22, 0x90, 0x92, 0xC3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xFF, 0x90, 0x92, 
+0xC3, 0xE0, 0x34, 0x00, 0xFE, 0x22, 0x90, 0x92, 0xC3, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x78, 
+0xB6, 0x7C, 0x92, 0x7D, 0x01, 0x22, 0xB1, 0xB0, 0x71, 0xCF, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0x94, 
+0x12, 0x9F, 0xF1, 0xD1, 0x9C, 0x7A, 0x81, 0x79, 0x9A, 0xB1, 0x81, 0x78, 0xCC, 0x7C, 0x92, 0x7D, 
+0x01, 0x7B, 0xFF, 0x7A, 0x81, 0x79, 0xAA, 0xB1, 0x81, 0xE4, 0x90, 0x92, 0xDF, 0x12, 0xB5, 0xC7, 
+0xA3, 0xE0, 0xFD, 0xB1, 0xBC, 0xEF, 0x64, 0x01, 0x60, 0x02, 0xA1, 0x69, 0x12, 0x9F, 0x6E, 0xCF, 
+0x24, 0x0E, 0xCF, 0x34, 0x00, 0x12, 0x9E, 0x2A, 0xEF, 0x64, 0x3A, 0x60, 0x02, 0xA1, 0x69, 0x12, 
+0x9F, 0x6E, 0xCF, 0x24, 0x30, 0xCF, 0x34, 0x00, 0x12, 0x9E, 0x2A, 0xEF, 0x64, 0x87, 0x60, 0x02, 
+0xA1, 0x69, 0x90, 0x92, 0xDF, 0x04, 0xF0, 0xE4, 0x90, 0x92, 0xDC, 0xF0, 0xB1, 0x6F, 0x94, 0x10, 
+0x50, 0x1A, 0xB1, 0xA4, 0x12, 0x9F, 0x79, 0xCD, 0x24, 0x38, 0x12, 0x9E, 0x1F, 0x90, 0x92, 0xDC, 
+0xE0, 0x24, 0xCC, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xB1, 0x76, 0x80, 0xE0, 0xE4, 0x90, 0x92, 0xDD, 
+0xF0, 0x90, 0x92, 0xDD, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x40, 0x02, 0xA1, 0x69, 0x75, 0xF0, 0x38, 
+0xEF, 0xB1, 0x88, 0x20, 0xE0, 0x02, 0xA1, 0x69, 0xE4, 0x90, 0x92, 0xDE, 0xF0, 0xB1, 0x90, 0x90, 
+0x90, 0x42, 0x12, 0x04, 0x6E, 0xE0, 0xFE, 0x90, 0x92, 0xDE, 0xE0, 0xC3, 0x9E, 0x40, 0x02, 0xA1, 
+0x61, 0xEF, 0x75, 0xF0, 0x38, 0xA4, 0x24, 0x59, 0xF9, 0x74, 0x90, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 
+0xE0, 0x75, 0xF0, 0x10, 0xA4, 0x29, 0xF9, 0xEA, 0x35, 0xF0, 0xFA, 0x78, 0xCC, 0x7C, 0x92, 0xB1, 
+0x99, 0x60, 0x02, 0xA1, 0x52, 0x90, 0x06, 0x33, 0xE0, 0x44, 0x01, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 
+0x92, 0xDC, 0xF0, 0xB1, 0x6F, 0x94, 0x06, 0x50, 0x14, 0xB1, 0xA4, 0x12, 0x9F, 0x79, 0xCD, 0x24, 
+0x4A, 0x12, 0x9E, 0x1F, 0x90, 0x92, 0xDC, 0xD1, 0x93, 0xB1, 0x76, 0x80, 0xE6, 0xE4, 0x90, 0x92, 
+0xDC, 0xF0, 0xB1, 0x6F, 0x94, 0x10, 0x50, 0x0C, 0x12, 0x9E, 0x0B, 0x90, 0x92, 0xDC, 0xD1, 0x8A, 
+0xB1, 0x76, 0x80, 0xEE, 0xB1, 0x90, 0xB1, 0x88, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x19, 0xEF, 0x75, 
+0xF0, 0x38, 0xA4, 0x24, 0x49, 0xF9, 0x74, 0x90, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x78, 0xBC, 0x7C, 
+0x92, 0xB1, 0x99, 0x70, 0x44, 0x80, 0x00, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xB6, 0x90, 0x92, 0xE3, 
+0x12, 0x86, 0xE9, 0x7A, 0x92, 0x79, 0xCC, 0x90, 0x92, 0xE6, 0x12, 0x86, 0xE9, 0x90, 0x92, 0xDD, 
+0xE0, 0x75, 0xF0, 0x38, 0xA4, 0x24, 0x43, 0xF9, 0x74, 0x90, 0x35, 0xF0, 0xFA, 0x90, 0x92, 0xE9, 
+0x12, 0x86, 0xE9, 0xE4, 0x90, 0x92, 0xEC, 0xF0, 0xA3, 0xF0, 0x7A, 0x92, 0x79, 0xBC, 0xF1, 0x55, 
+0x80, 0x07, 0x90, 0x06, 0x33, 0xE0, 0x44, 0x05, 0xF0, 0x90, 0x92, 0xDE, 0xE0, 0x04, 0xF0, 0x81, 
+0x7D, 0x90, 0x92, 0xDD, 0xE0, 0x04, 0xF0, 0x81, 0x61, 0x90, 0x92, 0xDF, 0xE0, 0xFF, 0x22, 0x90, 
+0x92, 0xDC, 0xE0, 0xFF, 0xC3, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x92, 0xDC, 0xE0, 0x04, 0xF0, 
+0x22, 0x7E, 0x00, 0x7F, 0x10, 0x02, 0x01, 0xE0, 0x90, 0x90, 0x41, 0x12, 0x04, 0x6E, 0xE0, 0x22, 
+0x90, 0x92, 0xDD, 0xE0, 0xFF, 0x75, 0xF0, 0x38, 0x22, 0x7D, 0x01, 0x7E, 0x00, 0x7F, 0x10, 0x12, 
+0x88, 0x9E, 0xEF, 0x22, 0x90, 0x92, 0xB5, 0xE0, 0xFD, 0x90, 0x92, 0xB4, 0xE0, 0x2D, 0xFD, 0x22, 
+0x90, 0x92, 0xB3, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x22, 0x90, 0x92, 0xE0, 0xB1, 
+0xB3, 0x2F, 0xFF, 0xE4, 0x3E, 0xCF, 0x24, 0x06, 0xCF, 0x34, 0x00, 0x12, 0x9E, 0x2A, 0xBF, 0x86, 
+0x20, 0x90, 0x92, 0xE2, 0xE0, 0xFF, 0x90, 0x92, 0xE1, 0xE0, 0x2F, 0xFF, 0x90, 0x92, 0xE0, 0xE0, 
+0x34, 0x00, 0xCF, 0x24, 0x07, 0xCF, 0x34, 0x00, 0x12, 0x9E, 0x2A, 0xBF, 0xDD, 0x03, 0x7F, 0x01, 
+0x22, 0x7F, 0x00, 0x22, 0xB1, 0xB0, 0xE4, 0xA3, 0xF0, 0xD1, 0x75, 0x50, 0x1A, 0x12, 0xB5, 0xC8, 
+0xD1, 0x7E, 0x24, 0x19, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE0, 0xB5, 0x07, 0x1D, 0x90, 
+0x92, 0xB6, 0xE0, 0x04, 0xF0, 0x80, 0xE2, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x01, 
+0xC7, 0x74, 0x30, 0xF0, 0x7F, 0x01, 0x12, 0x99, 0xDB, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xB1, 
+0xB0, 0x90, 0x91, 0xEB, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 0x26, 0xE4, 0x90, 0x92, 0xB6, 0xF0, 
+0xD1, 0x75, 0x50, 0x20, 0x12, 0xB5, 0xC8, 0xD1, 0x7E, 0x24, 0xF9, 0xF5, 0x82, 0xE4, 0x34, 0x91, 
+0xF5, 0x83, 0xE0, 0x6F, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x92, 0xB6, 0xE0, 0x04, 0xF0, 0x80, 
+0xDF, 0x7F, 0x00, 0x22, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x40, 0xF0, 0xE4, 0x90, 0x91, 0xF7, 0xF0, 
+0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x92, 0xB6, 0xE0, 0xFD, 0xC3, 0x94, 0x02, 0x22, 0xED, 0x24, 
+0x1C, 0xFD, 0x12, 0x52, 0xBD, 0x90, 0x92, 0xB6, 0xE0, 0x22, 0xE0, 0x24, 0xBC, 0xF5, 0x82, 0xE4, 
+0x34, 0x92, 0x22, 0xE0, 0x24, 0xB6, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0x22, 0x78, 0xBC, 0x7C, 0x92, 
+0x7D, 0x01, 0x7B, 0xFF, 0x22, 0x7E, 0x00, 0x7F, 0x06, 0x12, 0x88, 0x9E, 0xEF, 0x22, 0x7D, 0x01, 
+0x7B, 0x01, 0x7A, 0x90, 0x79, 0x33, 0x7E, 0x00, 0x7F, 0x04, 0x02, 0x88, 0x9E, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x20, 0xE0, 0x05, 0x90, 0x92, 0x3B, 0x80, 0x03, 0x90, 0x92, 0x3C, 
+0xE0, 0x90, 0x91, 0xE4, 0xF0, 0x90, 0x91, 0xE4, 0xE0, 0x14, 0x60, 0x13, 0x14, 0x60, 0x14, 0x24, 
+0xFE, 0x60, 0x10, 0x14, 0x60, 0x09, 0x14, 0x60, 0x06, 0x24, 0x06, 0xE4, 0xFE, 0x80, 0x06, 0x7E, 
+0x04, 0x80, 0x02, 0x7E, 0x08, 0xAF, 0x06, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x8F, 0xA3, 0x75, 
+0x1E, 0x70, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x41, 0x02, 0x68, 0xAB, 0xEF, 0x60, 0x07, 0x90, 0x92, 
+0x43, 0xE0, 0xFF, 0xD1, 0xFC, 0x22, 0x90, 0x93, 0x1A, 0x12, 0x86, 0xE9, 0x90, 0x93, 0x1D, 0x12, 
+0x8E, 0x01, 0x75, 0x1E, 0x10, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xB1, 0x12, 0x68, 0xAB, 0x90, 0x93, 
+0x1A, 0x12, 0x8E, 0x01, 0x75, 0x1E, 0x10, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xC1, 0x12, 0x68, 0xAB, 
+0x90, 0x93, 0x20, 0x12, 0x04, 0xB2, 0x90, 0x90, 0xD1, 0x12, 0x04, 0x31, 0x90, 0x93, 0x24, 0xE0, 
+0x90, 0x90, 0xD8, 0xF0, 0x22, 0x90, 0x92, 0xE0, 0x12, 0x86, 0xE9, 0x90, 0x05, 0x22, 0xE0, 0x90, 
+0x92, 0xF1, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x0C, 0x7D, 0x39, 0x12, 0xB6, 0x9E, 0xEF, 0x64, 
+0x01, 0x70, 0x17, 0x80, 0x00, 0x90, 0x92, 0x3F, 0xE0, 0xFF, 0x90, 0x93, 0x92, 0x74, 0x11, 0x12, 
+0xD5, 0x84, 0x90, 0x92, 0xEE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 0xEE, 0x12, 0xBA, 0xF8, 
+0x90, 0x92, 0xF0, 0xEF, 0xF0, 0x90, 0x92, 0xEE, 0x12, 0xD4, 0x98, 0x90, 0x92, 0xEC, 0xE0, 0xFD, 
+0x12, 0x97, 0x5E, 0x90, 0x92, 0xED, 0xE0, 0x60, 0x03, 0x02, 0xD0, 0x3F, 0x12, 0x8F, 0xEF, 0xC0, 
+0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x92, 0xE3, 0x12, 0x8E, 0x01, 0x75, 0x1E, 0x06, 0xD0, 0x01, 
+0xD0, 0x02, 0xD0, 0x03, 0x12, 0x8F, 0x30, 0x12, 0x8F, 0xC5, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 
+0x90, 0x92, 0xE0, 0x12, 0x8E, 0x01, 0x75, 0x1E, 0x10, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 
+0x8F, 0x30, 0x12, 0x8F, 0xF2, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x92, 0xE6, 0x12, 0x8E, 
+0x01, 0x75, 0x1E, 0x10, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x8F, 0x30, 0x24, 0x60, 0xF9, 
+0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x92, 0xE6, 0x12, 
+0x8E, 0x01, 0x75, 0x1E, 0x10, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x8F, 0x30, 0x24, 0x72, 
+0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x92, 0xE9, 
+0x12, 0x8E, 0x01, 0x75, 0x1E, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x68, 0xAB, 0x90, 
+0x92, 0xE6, 0x12, 0x86, 0xE0, 0x90, 0x93, 0x1D, 0x12, 0x86, 0xE9, 0x90, 0x93, 0x20, 0x12, 0x04, 
+0x3D, 0x00, 0x00, 0x00, 0x20, 0x90, 0x93, 0x24, 0x74, 0x3A, 0xF0, 0x90, 0x92, 0xE0, 0x12, 0x86, 
+0xE0, 0x12, 0xCF, 0x16, 0x12, 0x8F, 0x33, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 0x12, 0x8F, 0xAF, 
+0x75, 0x1E, 0x28, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0xF2, 0x12, 0x8F, 0x30, 0x11, 0xDA, 0xC0, 0x03, 
+0x8B, 0x1B, 0x75, 0x1C, 0x90, 0x75, 0x1D, 0xB1, 0x75, 0x1E, 0x28, 0xD0, 0x03, 0x12, 0x68, 0xAB, 
+0x90, 0x92, 0xF0, 0xE0, 0xFF, 0x90, 0x92, 0xEF, 0xE0, 0x2F, 0xFF, 0x90, 0x92, 0xEE, 0xE0, 0x34, 
+0x00, 0xCF, 0x24, 0x30, 0xFD, 0xE4, 0x3F, 0xFC, 0x90, 0x92, 0x3F, 0xE0, 0xFB, 0x7F, 0x3A, 0x12, 
+0xAE, 0x13, 0x12, 0x8F, 0x33, 0x11, 0xDA, 0xC0, 0x03, 0x8B, 0x1B, 0x75, 0x1C, 0x92, 0x75, 0x1D, 
+0xF2, 0x75, 0x1E, 0x28, 0xD0, 0x03, 0x12, 0x68, 0xAB, 0x90, 0x06, 0x33, 0xE0, 0x44, 0x02, 0xF0, 
+0x90, 0x92, 0xF1, 0xE0, 0xFF, 0x7D, 0x3A, 0x02, 0x8F, 0xDA, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 
+0xFA, 0x7B, 0x01, 0x22, 0xE4, 0xFE, 0x90, 0x90, 0x11, 0xE0, 0x30, 0xE0, 0x03, 0x7F, 0x01, 0x22, 
+0xED, 0x30, 0xE1, 0x0C, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x05, 0x74, 0x04, 0xF0, 0x31, 0x25, 
+0xED, 0x30, 0xE0, 0x1E, 0xEF, 0x30, 0xE6, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x22, 0xF0, 0x7E, 0x01, 
+0xEF, 0x30, 0xE7, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x21, 0xF0, 0x7E, 0x01, 0xEF, 0x30, 0xE5, 0x02, 
+0x31, 0x25, 0xAF, 0x06, 0x22, 0x90, 0x01, 0xC7, 0x74, 0x23, 0xF0, 0x7E, 0x01, 0x22, 0x11, 0xE4, 
+0xEF, 0x54, 0x01, 0xFF, 0x90, 0x90, 0x11, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x90, 0x02, 0x09, 
+0xE0, 0x90, 0x92, 0x79, 0xF0, 0x12, 0x02, 0x06, 0x90, 0x92, 0x3B, 0x12, 0x95, 0x9C, 0x90, 0x92, 
+0x3C, 0xF0, 0x22, 0x31, 0x65, 0x90, 0x92, 0x4B, 0x12, 0x95, 0x9C, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 
+0x90, 0x92, 0x4C, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 0x02, 0x06, 0xFE, 0xAF, 0x05, 
+0xED, 0x2E, 0x22, 0xEF, 0x60, 0x08, 0x90, 0x92, 0x3E, 0xE0, 0xFF, 0x12, 0x8F, 0x3D, 0x22, 0x90, 
+0x8F, 0xE1, 0xED, 0xF0, 0x90, 0x8F, 0xDE, 0x12, 0x86, 0xE9, 0x12, 0x95, 0xA9, 0x90, 0x8F, 0xE5, 
+0xF0, 0x90, 0x8F, 0xDE, 0x12, 0x8E, 0x01, 0x75, 0x1E, 0x03, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0xE2, 
+0x12, 0x68, 0xAB, 0x90, 0x8F, 0xE1, 0xE0, 0x70, 0x2E, 0xFF, 0x31, 0xD8, 0xE0, 0xB4, 0xFF, 0x06, 
+0x31, 0xD8, 0xE4, 0xF0, 0x80, 0x07, 0x31, 0xD8, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 0xB4, 
+0x03, 0xE8, 0x75, 0x1B, 0x01, 0x75, 0x1C, 0x8F, 0x75, 0x1D, 0xE2, 0x75, 0x1E, 0x03, 0x90, 0x8F, 
+0xDE, 0x12, 0x86, 0xE0, 0x12, 0x68, 0xAB, 0x22, 0x74, 0xE2, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 
+0xF5, 0x83, 0x22, 0x51, 0x1E, 0xE4, 0xA3, 0xF0, 0x90, 0x92, 0xB5, 0xE0, 0xFD, 0xC3, 0x94, 0x04, 
+0x50, 0x29, 0x90, 0x92, 0xB4, 0xE0, 0x24, 0x10, 0x12, 0x9F, 0x78, 0xFE, 0x12, 0x52, 0xBD, 0x90, 
+0x92, 0xB5, 0xE0, 0x24, 0xF1, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 0xE0, 0x6F, 0x60, 0x03, 
+0x7F, 0x00, 0x22, 0x90, 0x92, 0xB5, 0xE0, 0x04, 0xF0, 0x80, 0xCD, 0x7F, 0x01, 0x22, 0x90, 0x92, 
+0xB3, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8A, 
+0xEA, 0xE0, 0x30, 0xE0, 0x1E, 0x90, 0x8A, 0xFC, 0xE0, 0x60, 0x05, 0x75, 0x5E, 0x40, 0x41, 0xD1, 
+0x90, 0x8A, 0x85, 0xE0, 0xD3, 0x94, 0x00, 0x40, 0x02, 0x80, 0x2D, 0x90, 0x8A, 0xE9, 0xE0, 0x60, 
+0x7B, 0x80, 0x55, 0x12, 0x79, 0x80, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x75, 0x5E, 0x01, 0x80, 0x71, 
+0x90, 0x8A, 0x87, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x05, 0x75, 0x5E, 0x02, 0x80, 0x63, 0x90, 0x8A, 
+0x85, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x05, 0x75, 0x5E, 0x04, 0x80, 0x54, 0xEF, 0x30, 0xE2, 
+0x05, 0x75, 0x5E, 0x08, 0x80, 0x4B, 0x90, 0x8A, 0x87, 0xE0, 0x30, 0xE4, 0x05, 0x75, 0x5E, 0x10, 
+0x80, 0x3F, 0x90, 0x8A, 0x7F, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x05, 0x75, 0x5E, 0x20, 
+0x80, 0x2F, 0x90, 0x8A, 0xE9, 0xE0, 0x60, 0x05, 0x75, 0x5E, 0x80, 0x80, 0x24, 0x90, 0x06, 0x62, 
+0xE0, 0x30, 0xE1, 0x05, 0x75, 0x5E, 0x11, 0x80, 0x18, 0x90, 0x06, 0x62, 0xE0, 0x30, 0xE0, 0x0C, 
+0xE0, 0x54, 0xFC, 0xFF, 0xBF, 0x80, 0x05, 0x75, 0x5E, 0x12, 0x80, 0x05, 0x12, 0xA7, 0xE9, 0x80, 
+0x0E, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x5E, 0xF0, 0x7F, 0x00, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 0x04, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x48, 0x90, 0x02, 0x87, 
+0xE0, 0x60, 0x02, 0x80, 0x08, 0x90, 0x01, 0x00, 0xE0, 0x64, 0x3F, 0x60, 0x05, 0x75, 0x13, 0x01, 
+0x80, 0x4D, 0x90, 0x90, 0x08, 0xE0, 0x30, 0xE0, 0x0B, 0x90, 0x02, 0x82, 0xE0, 0x60, 0x05, 0x75, 
+0x13, 0x02, 0x80, 0x3B, 0x90, 0x90, 0x11, 0xE0, 0x30, 0xE0, 0x05, 0x75, 0x13, 0x08, 0x80, 0x2F, 
+0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x02, 0x80, 0x07, 0x90, 0x02, 0x86, 0xE0, 0x30, 0xE3, 0x05, 
+0x75, 0x13, 0x04, 0x80, 0x1A, 0x90, 0x8B, 0x33, 0xE0, 0x30, 0xE0, 0x05, 0x75, 0x13, 0x20, 0x80, 
+0x0E, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x05, 0x75, 0x13, 0x40, 0x80, 0x03, 0x02, 0xA7, 0xE9, 0x90, 
+0x01, 0xB9, 0x74, 0x08, 0xF0, 0x90, 0x01, 0xB8, 0xE5, 0x13, 0xF0, 0x7F, 0x00, 0x22, 0xAC, 0x07, 
+0x90, 0x8A, 0x7F, 0x12, 0x9F, 0x8C, 0x30, 0xE0, 0x02, 0x81, 0x0E, 0x90, 0x8A, 0x7E, 0xE0, 0x30, 
+0xE0, 0x16, 0x90, 0x8A, 0xA0, 0xE0, 0x24, 0x04, 0x90, 0x8A, 0x98, 0xF0, 0x90, 0x8A, 0xA0, 0xE0, 
+0x24, 0x03, 0x90, 0x8A, 0x97, 0xF0, 0x80, 0x0D, 0x90, 0x8A, 0x98, 0x74, 0x02, 0xF0, 0x90, 0x8A, 
+0x97, 0x14, 0xF0, 0x0B, 0x0B, 0x90, 0x8A, 0x97, 0xE0, 0xFA, 0x90, 0x8A, 0x96, 0xE0, 0xD3, 0x9A, 
+0x50, 0x0D, 0x90, 0x8A, 0x8B, 0xEB, 0xF0, 0x90, 0x8A, 0x98, 0xE0, 0xC3, 0x9D, 0x80, 0x11, 0xC3, 
+0xED, 0x9A, 0x2B, 0x90, 0x8A, 0x8B, 0xF0, 0x90, 0x8A, 0x97, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 
+0x2C, 0x90, 0x8A, 0x9B, 0xF0, 0x90, 0x8A, 0x98, 0xE0, 0xFF, 0x24, 0x0A, 0xFD, 0xE4, 0x33, 0xFC, 
+0x90, 0x8A, 0x9B, 0x91, 0x16, 0x40, 0x04, 0xEF, 0x24, 0x0A, 0xF0, 0x90, 0x8A, 0x9B, 0xE0, 0xFF, 
+0x24, 0x23, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x8A, 0x8B, 0x91, 0x16, 0x40, 0x04, 0xEF, 0x24, 0x23, 
+0xF0, 0x90, 0x8A, 0x9B, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x8A, 0x8F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x05, 0x58, 0xE0, 0x6F, 0x70, 0x01, 0xE4, 0x60, 0x02, 0x91, 0x29, 0x80, 0x13, 0x90, 0x8A, 
+0x80, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0xE0, 0xD3, 0x9D, 0xEC, 0x64, 0x80, 0xF8, 0x74, 0x80, 0x98, 
+0x22, 0x90, 0x8A, 0x80, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x8A, 0x8F, 0xA3, 0xE0, 0x90, 0x05, 
+0x58, 0xF0, 0x22, 0x90, 0x90, 0x04, 0xE0, 0x30, 0xE0, 0x0A, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 
+0x03, 0x12, 0xA7, 0x64, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 
+0x54, 0xFD, 0x4F, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xFF, 0x74, 0x03, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x03, 0x22, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 
+0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x22, 0xA3, 0xE0, 0x24, 0x28, 0xF9, 0xE4, 0x34, 0xFC, 
+0xFA, 0x7B, 0x01, 0x22, 0x90, 0x92, 0xDE, 0xE0, 0x2F, 0xFF, 0x90, 0x92, 0xDD, 0xE0, 0x34, 0x00, 
+0xFE, 0x90, 0x93, 0x61, 0xF0, 0xA3, 0x22, 0x90, 0x92, 0xDA, 0xE0, 0xFF, 0x24, 0x22, 0xF5, 0x82, 
+0xE4, 0x34, 0x91, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 
+0x22, 0x78, 0x10, 0x12, 0x03, 0xEB, 0x90, 0x8F, 0xCE, 0x02, 0x86, 0xD4, 0x54, 0x10, 0xFD, 0xEF, 
+0x54, 0xEF, 0x4D, 0xFF, 0x22, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x8A, 0x85, 0xE0, 0x90, 0x01, 
+0xBB, 0xF0, 0x22, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x22, 0x90, 0x8A, 0x95, 0xE0, 
+0xFF, 0xA3, 0xE0, 0xFD, 0x90, 0x8A, 0x9C, 0xE0, 0xFB, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0x22, 0x7F, 0x64, 0x7E, 0x00, 0x02, 0x7B, 0x8D, 0x90, 0x8F, 0xCC, 0xE0, 0xFC, 0xA3, 0xE0, 
+0x22, 0x90, 0x8F, 0xAA, 0x12, 0x86, 0xE9, 0xE4, 0x90, 0x8F, 0xAD, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 
+0x91, 0x79, 0xB3, 0x90, 0x8F, 0xF5, 0xE0, 0xFD, 0x22, 0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0x92, 0xDD, 0xE4, 0x75, 0xF0, 0x02, 0x02, 0x02, 0xE7, 0xF5, 
+0x83, 0xEF, 0xF0, 0x90, 0x92, 0xBB, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x8F, 0xC9, 0xE0, 0xC3, 0x13, 
+0x90, 0xFD, 0x10, 0xF0, 0x22, 0x74, 0x12, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 
+0xFD, 0x12, 0x7A, 0xDD, 0x90, 0x92, 0xD8, 0xEF, 0xF0, 0x22, 0x75, 0x1C, 0x91, 0x75, 0x1D, 0x20, 
+0x75, 0x1E, 0x02, 0x22, 0xF0, 0x7B, 0x18, 0x7D, 0x01, 0x02, 0xB7, 0x13, 0x54, 0x40, 0xFD, 0xEF, 
+0x54, 0xBF, 0x4D, 0xFF, 0x22, 0x90, 0x93, 0x65, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x90, 0x92, 
+0xDA, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x22, 0xF0, 0xEE, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x22, 
+0x90, 0x92, 0xCA, 0xE0, 0xFF, 0xC3, 0x94, 0x06, 0x22, 0xFF, 0xEC, 0x90, 0x8F, 0xDA, 0x02, 0x04, 
+0x31, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8A, 0x7F, 0x22, 0x90, 0x8F, 0xD4, 0xE0, 0x90, 0x8F, 
+0xD6, 0x22, 0x12, 0x02, 0x4C, 0x90, 0x8F, 0xBF, 0xE0, 0x22, 0x90, 0x93, 0x64, 0xE0, 0xC3, 0x94, 
+0x0A, 0x22, 0xF0, 0xE4, 0x90, 0x92, 0xE8, 0xF0, 0xA3, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFD, 0xED, 
+0xFF, 0x22, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 
+0xF0, 0x22, 0x12, 0x02, 0x06, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x12, 0x04, 0xB2, 0xEF, 0x44, 0x80, 
+0xFF, 0x22, 0x90, 0x8A, 0x7E, 0xE0, 0x54, 0xF7, 0xF0, 0x22, 0x90, 0x05, 0x00, 0x74, 0x1C, 0xF0, 
+0xA3, 0x22, 0xCF, 0x41, 
+};
+u4Byte ArrayLength_MP_8703B_FW_WoWLAN = 22084;
+
+
+void
+ODM_ReadFirmware_MP_8703B_FW_WoWLAN(
+	IN   PDM_ODM_T    pDM_Odm,
+	OUT  u1Byte       *pFirmware,
+	OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8703B_FW_WoWLAN;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8703B_FW_WoWLAN, ArrayLength_MP_8703B_FW_WoWLAN);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8703B_FW_WoWLAN;
+}
+
+
+
+#endif /* end of (defined(CONFIG_AP_WOWLAN) || (DM_ODM_SUPPORT_TYPE & (ODM_AP)))*/
+
+
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.h
new file mode 100644
index 000000000..8c666884e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_fw.h
@@ -0,0 +1,62 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.16*/
+#if (RTL8703B_SUPPORT == 1)
+#ifndef __INC_MP_FW_HW_IMG_8703B_H
+#define __INC_MP_FW_HW_IMG_8703B_H
+
+
+/******************************************************************************
+*                           FW_AP.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8703B_FW_AP(
+	IN   PDM_ODM_T    pDM_Odm,
+	OUT  u1Byte       *pFirmware,
+	OUT  u4Byte       *pFirmwareSize
+);
+
+/******************************************************************************
+*                           FW_NIC.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8703B_FW_NIC(
+	IN   PDM_ODM_T    pDM_Odm,
+	OUT  u1Byte       *pFirmware,
+	OUT  u4Byte       *pFirmwareSize
+);
+
+/******************************************************************************
+*                           FW_WoWLAN.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8703B_FW_WoWLAN(
+	IN   PDM_ODM_T    pDM_Odm,
+	OUT  u1Byte       *pFirmware,
+	OUT  u4Byte       *pFirmwareSize
+);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.c
new file mode 100644
index 000000000..27b867971
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.c
@@ -0,0 +1,290 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8703B_SUPPORT == 1)
+static BOOLEAN
+CheckPositive(
+	IN  PDM_ODM_T     pDM_Odm,
+	IN  const u4Byte  Condition1,
+	IN  const u4Byte  Condition2,
+	IN	const u4Byte  Condition3,
+	IN	const u4Byte  Condition4
+)
+{
+	u1Byte    _BoardType = ((pDM_Odm->BoardType & BIT4) >> 4) << 0 | /* _GLNA*/
+				((pDM_Odm->BoardType & BIT3) >> 3) << 1 | /* _GPA*/ 
+				((pDM_Odm->BoardType & BIT7) >> 7) << 2 | /* _ALNA*/
+				((pDM_Odm->BoardType & BIT6) >> 6) << 3 | /* _APA */
+				((pDM_Odm->BoardType & BIT2) >> 2) << 4;  /* _BT*/  
+
+	u4Byte	cond1   = Condition1, cond2 = Condition2, cond3 = Condition3, cond4 = Condition4;
+	u4Byte    driver1 = pDM_Odm->CutVersion       << 24 | 
+				(pDM_Odm->SupportInterface & 0xF0) << 16 | 
+				pDM_Odm->SupportPlatform  << 16 | 
+				pDM_Odm->PackageType      << 12 | 
+				(pDM_Odm->SupportInterface & 0x0F) << 8  |
+				_BoardType;
+
+	u4Byte    driver2 = (pDM_Odm->TypeGLNA & 0xFF) <<  0 |  
+				(pDM_Odm->TypeGPA & 0xFF)  <<  8 | 
+				(pDM_Odm->TypeALNA & 0xFF) << 16 | 
+				(pDM_Odm->TypeAPA & 0xFF)  << 24; 
+
+u4Byte    driver3 = 0;
+
+	u4Byte    driver4 = (pDM_Odm->TypeGLNA & 0xFF00) >>  8 |
+				(pDM_Odm->TypeGPA & 0xFF00) |
+				(pDM_Odm->TypeALNA & 0xFF00) << 8 |
+				(pDM_Odm->TypeAPA & 0xFF00)  << 16;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("===> CheckPositive (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n", cond1, cond2, cond3, cond4));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("===> CheckPositive (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n", driver1, driver2, driver3, driver4));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("	(Platform, Interface) = (0x%X, 0x%X)\n", pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("	(Board, Package) = (0x%X, 0x%X)\n", pDM_Odm->BoardType, pDM_Odm->PackageType));
+
+
+	/*============== Value Defined Check ===============*/
+	/*QFN Type [15:12] and Cut Version [27:24] need to do value check*/
+	
+	if (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return FALSE;
+	if (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return FALSE;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1   &= 0x00FF0FFF; 
+	driver1 &= 0x00FF0FFF; 
+
+	if ((cond1 & driver1) == cond1) {
+		u4Byte bitMask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* BoardType is DONTCARE*/
+			return TRUE;
+
+		if ((cond1 & BIT0) != 0) /*GLNA*/
+			bitMask |= 0x000000FF;
+		if ((cond1 & BIT1) != 0) /*GPA*/
+			bitMask |= 0x0000FF00;
+		if ((cond1 & BIT2) != 0) /*ALNA*/
+			bitMask |= 0x00FF0000;
+		if ((cond1 & BIT3) != 0) /*APA*/
+			bitMask |= 0xFF000000;
+
+		if (((cond2 & bitMask) == (driver2 & bitMask)) && ((cond4 & bitMask) == (driver4 & bitMask)))  /* BoardType of each RF path is matched*/
+			return TRUE;
+		else
+			return FALSE;
+	} else
+		return FALSE;
+}
+static BOOLEAN
+CheckNegative(
+	IN  PDM_ODM_T     pDM_Odm,
+	IN  const u4Byte  Condition1,
+	IN  const u4Byte  Condition2
+)
+{
+	return TRUE;
+}
+
+/******************************************************************************
+*                           MAC_REG.TXT
+******************************************************************************/
+
+u4Byte Array_MP_8703B_MAC_REG[] = { 
+		0x02F, 0x00000030,
+		0x035, 0x00000000,
+		0x067, 0x00000002,
+		0x092, 0x00000080,
+		0x421, 0x0000000F,
+		0x428, 0x0000000A,
+		0x429, 0x00000010,
+		0x430, 0x00000000,
+		0x431, 0x00000000,
+		0x432, 0x00000000,
+		0x433, 0x00000001,
+		0x434, 0x00000004,
+		0x435, 0x00000005,
+		0x436, 0x00000007,
+		0x437, 0x00000008,
+		0x43C, 0x00000004,
+		0x43D, 0x00000005,
+		0x43E, 0x00000007,
+		0x43F, 0x00000008,
+		0x440, 0x0000005D,
+		0x441, 0x00000001,
+		0x442, 0x00000000,
+		0x444, 0x00000010,
+		0x445, 0x00000000,
+		0x446, 0x00000000,
+		0x447, 0x00000000,
+		0x448, 0x00000000,
+		0x449, 0x000000F0,
+		0x44A, 0x0000000F,
+		0x44B, 0x0000003E,
+		0x44C, 0x00000010,
+		0x44D, 0x00000000,
+		0x44E, 0x00000000,
+		0x44F, 0x00000000,
+		0x450, 0x00000000,
+		0x451, 0x000000F0,
+		0x452, 0x0000000F,
+		0x453, 0x00000000,
+		0x456, 0x0000005E,
+		0x460, 0x00000066,
+		0x461, 0x00000066,
+		0x4C8, 0x000000FF,
+		0x4C9, 0x00000008,
+		0x4CC, 0x000000FF,
+		0x4CD, 0x000000FF,
+		0x4CE, 0x00000001,
+		0x500, 0x00000026,
+		0x501, 0x000000A2,
+		0x502, 0x0000002F,
+		0x503, 0x00000000,
+		0x504, 0x00000028,
+		0x505, 0x000000A3,
+		0x506, 0x0000005E,
+		0x507, 0x00000000,
+		0x508, 0x0000002B,
+		0x509, 0x000000A4,
+		0x50A, 0x0000005E,
+		0x50B, 0x00000000,
+		0x50C, 0x0000004F,
+		0x50D, 0x000000A4,
+		0x50E, 0x00000000,
+		0x50F, 0x00000000,
+		0x512, 0x0000001C,
+		0x514, 0x0000000A,
+		0x516, 0x0000000A,
+		0x525, 0x0000004F,
+		0x550, 0x00000010,
+		0x551, 0x00000010,
+		0x559, 0x00000002,
+		0x55C, 0x00000028,
+		0x55D, 0x000000FF,
+		0x605, 0x00000030,
+		0x608, 0x0000000E,
+		0x609, 0x0000002A,
+		0x620, 0x000000FF,
+		0x621, 0x000000FF,
+		0x622, 0x000000FF,
+		0x623, 0x000000FF,
+		0x624, 0x000000FF,
+		0x625, 0x000000FF,
+		0x626, 0x000000FF,
+		0x627, 0x000000FF,
+		0x638, 0x00000028,
+		0x63C, 0x0000000A,
+		0x63D, 0x0000000A,
+		0x63E, 0x0000000C,
+		0x63F, 0x0000000C,
+		0x640, 0x00000040,
+		0x642, 0x00000040,
+		0x643, 0x00000000,
+		0x652, 0x000000C8,
+		0x66A, 0x000000B0,
+		0x66E, 0x00000005,
+		0x700, 0x00000021,
+		0x701, 0x00000043,
+		0x702, 0x00000065,
+		0x703, 0x00000087,
+		0x708, 0x00000021,
+		0x709, 0x00000043,
+		0x70A, 0x00000065,
+		0x70B, 0x00000087,
+		0x765, 0x00000018,
+		0x76E, 0x00000004,
+
+};
+
+void
+ODM_ReadAndConfig_MP_8703B_MAC_REG(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+	u4Byte     i         = 0;
+	u1Byte     cCond;
+	BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+	u4Byte     ArrayLen    = sizeof(Array_MP_8703B_MAC_REG)/sizeof(u4Byte);
+	pu4Byte    Array       = Array_MP_8703B_MAC_REG;
+	
+	u4Byte	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8703B_MAC_REG\n"));
+
+	while ((i + 1) < ArrayLen) {
+		v1 = Array[i];
+		v2 = Array[i + 1];
+
+		if (v1 & (BIT31 | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT31) {/* positive condition*/
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if (cCond == COND_ENDIF) {/*end*/
+					bMatched = TRUE;
+					bSkipped = FALSE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ENDIF\n"));
+				} else if (cCond == COND_ELSE) { /*else*/
+					bMatched = bSkipped?FALSE:TRUE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ELSE\n"));
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("IF or ELSE IF\n"));
+				}
+			} else if (v1 & BIT30) { /*negative condition*/
+				if (bSkipped == FALSE) {
+					if (CheckPositive(pDM_Odm, pre_v1, pre_v2, v1, v2)) {
+						bMatched = TRUE;
+						bSkipped = TRUE;
+					} else {
+						bMatched = FALSE;
+						bSkipped = FALSE;
+					}
+				} else
+					bMatched = FALSE;
+			}
+		} else {
+			if (bMatched)
+				odm_ConfigMAC_8703B(pDM_Odm, v1, (u1Byte)v2);
+		}
+		i = i + 2;
+	}
+}
+
+u4Byte
+ODM_GetVersion_MP_8703B_MAC_REG(void)
+{
+	   return 17;
+}
+
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.h
new file mode 100644
index 000000000..c8d14ce76
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_mac.h
@@ -0,0 +1,39 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#if (RTL8703B_SUPPORT == 1)
+#ifndef __INC_MP_MAC_HW_IMG_8703B_H
+#define __INC_MP_MAC_HW_IMG_8703B_H
+
+
+/******************************************************************************
+*                           MAC_REG.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_MAC_REG(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_MAC_REG(void);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.c
new file mode 100644
index 000000000..c85c78e67
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.c
@@ -0,0 +1,976 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8703B_SUPPORT == 1)
+static BOOLEAN
+CheckPositive(
+	IN  PDM_ODM_T     pDM_Odm,
+	IN  const u4Byte  Condition1,
+	IN  const u4Byte  Condition2,
+	IN	const u4Byte  Condition3,
+	IN	const u4Byte  Condition4
+)
+{
+	u1Byte    _BoardType = ((pDM_Odm->BoardType & BIT4) >> 4) << 0 | /* _GLNA*/
+				((pDM_Odm->BoardType & BIT3) >> 3) << 1 | /* _GPA*/ 
+				((pDM_Odm->BoardType & BIT7) >> 7) << 2 | /* _ALNA*/
+				((pDM_Odm->BoardType & BIT6) >> 6) << 3 | /* _APA */
+				((pDM_Odm->BoardType & BIT2) >> 2) << 4;  /* _BT*/  
+
+	u4Byte	cond1   = Condition1, cond2 = Condition2, cond3 = Condition3, cond4 = Condition4;
+	u4Byte    driver1 = pDM_Odm->CutVersion       << 24 | 
+				(pDM_Odm->SupportInterface & 0xF0) << 16 | 
+				pDM_Odm->SupportPlatform  << 16 | 
+				pDM_Odm->PackageType      << 12 | 
+				(pDM_Odm->SupportInterface & 0x0F) << 8  |
+				_BoardType;
+
+	u4Byte    driver2 = (pDM_Odm->TypeGLNA & 0xFF) <<  0 |  
+				(pDM_Odm->TypeGPA & 0xFF)  <<  8 | 
+				(pDM_Odm->TypeALNA & 0xFF) << 16 | 
+				(pDM_Odm->TypeAPA & 0xFF)  << 24; 
+
+u4Byte    driver3 = 0;
+
+	u4Byte    driver4 = (pDM_Odm->TypeGLNA & 0xFF00) >>  8 |
+				(pDM_Odm->TypeGPA & 0xFF00) |
+				(pDM_Odm->TypeALNA & 0xFF00) << 8 |
+				(pDM_Odm->TypeAPA & 0xFF00)  << 16;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("===> CheckPositive (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n", cond1, cond2, cond3, cond4));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("===> CheckPositive (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n", driver1, driver2, driver3, driver4));
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("	(Platform, Interface) = (0x%X, 0x%X)\n", pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+	("	(Board, Package) = (0x%X, 0x%X)\n", pDM_Odm->BoardType, pDM_Odm->PackageType));
+
+
+	/*============== Value Defined Check ===============*/
+	/*QFN Type [15:12] and Cut Version [27:24] need to do value check*/
+	
+	if (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return FALSE;
+	if (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return FALSE;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1   &= 0x00FF0FFF; 
+	driver1 &= 0x00FF0FFF; 
+
+	if ((cond1 & driver1) == cond1) {
+		u4Byte bitMask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* BoardType is DONTCARE*/
+			return TRUE;
+
+		if ((cond1 & BIT0) != 0) /*GLNA*/
+			bitMask |= 0x000000FF;
+		if ((cond1 & BIT1) != 0) /*GPA*/
+			bitMask |= 0x0000FF00;
+		if ((cond1 & BIT2) != 0) /*ALNA*/
+			bitMask |= 0x00FF0000;
+		if ((cond1 & BIT3) != 0) /*APA*/
+			bitMask |= 0xFF000000;
+
+		if (((cond2 & bitMask) == (driver2 & bitMask)) && ((cond4 & bitMask) == (driver4 & bitMask)))  /* BoardType of each RF path is matched*/
+			return TRUE;
+		else
+			return FALSE;
+	} else
+		return FALSE;
+}
+static BOOLEAN
+CheckNegative(
+	IN  PDM_ODM_T     pDM_Odm,
+	IN  const u4Byte  Condition1,
+	IN  const u4Byte  Condition2
+)
+{
+	return TRUE;
+}
+
+/******************************************************************************
+*                           RadioA.TXT
+******************************************************************************/
+
+u4Byte Array_MP_8703B_RadioA[] = { 
+		0x018, 0x00008C01,
+		0x0B5, 0x0008C050,
+		0x0B1, 0x00054258,
+		0x0B2, 0x00054C00,
+		0x030, 0x00018000,
+		0x031, 0x00000027,
+		0x032, 0x000A7F07,
+		0x030, 0x00020000,
+		0x031, 0x00000027,
+		0x032, 0x000E7D87,
+		0x01C, 0x000F8635,
+		0x0EF, 0x00080000,
+		0x030, 0x00008000,
+		0x031, 0x00000004,
+		0x032, 0x00006105,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00000400,
+		0x041, 0x0000BD54,
+		0x041, 0x00003DD4,
+		0x041, 0x0000FDD4,
+		0x0EF, 0x00000000,
+		0x0DF, 0x00000600,
+		0x050, 0x0000C6DB,
+		0x051, 0x00004505,
+		0x052, 0x0000E31D,
+		0x053, 0x00040579,
+		0x054, 0x00000000,
+		0x055, 0x0008206E,
+		0x056, 0x00040000,
+		0x0EF, 0x00000100,
+		0x034, 0x0000ADD7,
+		0x034, 0x00009DD4,
+		0x034, 0x00008DD1,
+		0x034, 0x00007DCE,
+		0x034, 0x00006DCB,
+		0x034, 0x00005CCE,
+		0x034, 0x000048CD,
+		0x034, 0x000034CC,
+		0x034, 0x0000244F,
+		0x034, 0x0000144C,
+		0x034, 0x0000004E,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00002000,
+		0x03B, 0x0003801F,
+		0x03B, 0x00030002,
+		0x03B, 0x00028001,
+		0x03B, 0x00020000,
+		0x03B, 0x00018003,
+		0x03B, 0x00010002,
+		0x03B, 0x00008001,
+		0x03B, 0x00000000,
+		0x0EF, 0x00000000,
+		0x082, 0x000C0000,
+		0x083, 0x000AF025,
+		0x01E, 0x00000C08,
+
+};
+
+void
+ODM_ReadAndConfig_MP_8703B_RadioA(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+	u4Byte     i         = 0;
+	u1Byte     cCond;
+	BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+	u4Byte     ArrayLen    = sizeof(Array_MP_8703B_RadioA)/sizeof(u4Byte);
+	pu4Byte    Array       = Array_MP_8703B_RadioA;
+	
+	u4Byte	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8703B_RadioA\n"));
+
+	while ((i + 1) < ArrayLen) {
+		v1 = Array[i];
+		v2 = Array[i + 1];
+
+		if (v1 & (BIT31 | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT31) {/* positive condition*/
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if (cCond == COND_ENDIF) {/*end*/
+					bMatched = TRUE;
+					bSkipped = FALSE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ENDIF\n"));
+				} else if (cCond == COND_ELSE) { /*else*/
+					bMatched = bSkipped?FALSE:TRUE;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ELSE\n"));
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("IF or ELSE IF\n"));
+				}
+			} else if (v1 & BIT30) { /*negative condition*/
+				if (bSkipped == FALSE) {
+					if (CheckPositive(pDM_Odm, pre_v1, pre_v2, v1, v2)) {
+						bMatched = TRUE;
+						bSkipped = TRUE;
+					} else {
+						bMatched = FALSE;
+						bSkipped = FALSE;
+					}
+				} else
+					bMatched = FALSE;
+			}
+		} else {
+			if (bMatched)
+				odm_ConfigRF_RadioA_8703B(pDM_Odm, v1, v2);
+		}
+		i = i + 2;
+	}
+}
+
+u4Byte
+ODM_GetVersion_MP_8703B_RadioA(void)
+{
+	   return 17;
+}
+
+/******************************************************************************
+*                           TxPowerTrack_SDIO.TXT
+******************************************************************************/
+
+#if DEV_BUS_TYPE == RT_SDIO_INTERFACE
+u1Byte gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_SDIO_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+};
+u1Byte gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_SDIO_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+};
+u1Byte gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_SDIO_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+};
+u1Byte gDeltaSwingTableIdx_MP_5GA_P_TxPowerTrack_SDIO_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+};
+u1Byte gDeltaSwingTableIdx_MP_2GB_N_TxPowerTrack_SDIO_8703B[]    = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_SDIO_8703B[]    = {0, 1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15};
+u1Byte gDeltaSwingTableIdx_MP_2GA_N_TxPowerTrack_SDIO_8703B[]    = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_SDIO_8703B[]    = {0, 1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_SDIO_8703B[] = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_SDIO_8703B[] = {0, 0, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_SDIO_8703B[] = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_SDIO_8703B[] = {0, 0, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13};
+#endif
+
+void
+ODM_ReadAndConfig_MP_8703B_TxPowerTrack_SDIO(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+#if DEV_BUS_TYPE == RT_SDIO_INTERFACE
+	PODM_RF_CAL_T  pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_MP_8703B\n"));
+
+
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_P, gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_N, gDeltaSwingTableIdx_MP_2GA_N_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GB_P, gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GB_N, gDeltaSwingTableIdx_MP_2GB_N_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKA_P, gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKA_N, gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKB_P, gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKB_N, gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE);
+
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_P, gDeltaSwingTableIdx_MP_5GA_P_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE*3);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_N, gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE*3);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_P, gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE*3);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_N, gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_SDIO_8703B, DELTA_SWINGIDX_SIZE*3);
+#endif
+}
+
+/******************************************************************************
+*                           TxPowerTrack_USB.TXT
+******************************************************************************/
+
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+u1Byte gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_USB_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+};
+u1Byte gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_USB_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+};
+u1Byte gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_USB_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
+};
+u1Byte gDeltaSwingTableIdx_MP_5GA_P_TxPowerTrack_USB_8703B[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
+};
+u1Byte gDeltaSwingTableIdx_MP_2GB_N_TxPowerTrack_USB_8703B[]    = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_USB_8703B[]    = {0, 1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15};
+u1Byte gDeltaSwingTableIdx_MP_2GA_N_TxPowerTrack_USB_8703B[]    = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_USB_8703B[]    = {0, 1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_USB_8703B[] = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_USB_8703B[] = {0, 0, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_USB_8703B[] = {0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11};
+u1Byte gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_USB_8703B[] = {0, 0, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13};
+#endif
+
+void
+ODM_ReadAndConfig_MP_8703B_TxPowerTrack_USB(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+	PODM_RF_CAL_T  pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_MP_8703B\n"));
+
+
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_P, gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_N, gDeltaSwingTableIdx_MP_2GA_N_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GB_P, gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GB_N, gDeltaSwingTableIdx_MP_2GB_N_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKA_P, gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKA_N, gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKB_P, gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKB_N, gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE);
+
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_P, gDeltaSwingTableIdx_MP_5GA_P_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE*3);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_N, gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE*3);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_P, gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE*3);
+	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_N, gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_USB_8703B, DELTA_SWINGIDX_SIZE*3);
+#endif
+}
+
+/******************************************************************************
+*                           TXPWR_LMT.TXT
+******************************************************************************/
+
+const char *Array_MP_8703B_TXPWR_LMT[] = { 
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "30", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "63", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "63", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "26", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63", 
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63", 
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "28", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "28", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "28", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "32", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "28", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "28", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "63", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "63", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "28", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63", 
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63", 
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "26", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "26", 
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "28",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "26", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "32", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "26", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "26", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "63", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32", 
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "63", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "26", 
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "28",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63", 
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63", 
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "28", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "28", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "30", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "30", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "30", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "30", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "30", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "30", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "28", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "28", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "28", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "30", 
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "30",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63", 
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63", 
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63", 
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63", 
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "26", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "26", 
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "26", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "28", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "28", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "28", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "26", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "26", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "26", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "28", 
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "26", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "26", 
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "26", 
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "26", 
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "26",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63", 
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63", 
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63", 
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63", 
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "26", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "26", 
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "26",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63", 
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63", 
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "32", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "28", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "114", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "114", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "114", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "32", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "32", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "30", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "28", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "34", 
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "32", 
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "36", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "36", "32",
+	"FCC", "5G", "20M", "HT", "1T", "40", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "40", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "40", "32",
+	"FCC", "5G", "20M", "HT", "1T", "44", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "44", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "44", "32",
+	"FCC", "5G", "20M", "HT", "1T", "48", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "48", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "48", "32",
+	"FCC", "5G", "20M", "HT", "1T", "52", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "52", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "52", "32",
+	"FCC", "5G", "20M", "HT", "1T", "56", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "56", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "56", "32",
+	"FCC", "5G", "20M", "HT", "1T", "60", "32", 
+	"ETSI", "5G", "20M", "HT", "1T", "60", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "60", "32",
+	"FCC", "5G", "20M", "HT", "1T", "64", "28", 
+	"ETSI", "5G", "20M", "HT", "1T", "64", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "64", "32",
+	"FCC", "5G", "20M", "HT", "1T", "100", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "100", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "100", "32",
+	"FCC", "5G", "20M", "HT", "1T", "114", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "114", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "114", "32",
+	"FCC", "5G", "20M", "HT", "1T", "108", "32", 
+	"ETSI", "5G", "20M", "HT", "1T", "108", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "108", "32",
+	"FCC", "5G", "20M", "HT", "1T", "112", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "112", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "112", "32",
+	"FCC", "5G", "20M", "HT", "1T", "116", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "116", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "116", "32",
+	"FCC", "5G", "20M", "HT", "1T", "120", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "120", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "120", "32",
+	"FCC", "5G", "20M", "HT", "1T", "124", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "124", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "124", "32",
+	"FCC", "5G", "20M", "HT", "1T", "128", "32", 
+	"ETSI", "5G", "20M", "HT", "1T", "128", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "128", "32",
+	"FCC", "5G", "20M", "HT", "1T", "132", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "132", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "132", "32",
+	"FCC", "5G", "20M", "HT", "1T", "136", "30", 
+	"ETSI", "5G", "20M", "HT", "1T", "136", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "136", "32",
+	"FCC", "5G", "20M", "HT", "1T", "140", "28", 
+	"ETSI", "5G", "20M", "HT", "1T", "140", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "140", "32",
+	"FCC", "5G", "20M", "HT", "1T", "149", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "149", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "153", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "157", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "161", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "34", 
+	"ETSI", "5G", "20M", "HT", "1T", "165", "32", 
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32", 
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30", 
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26", 
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "114", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "114", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "114", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30", 
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32", 
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32", 
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32", 
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30", 
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28", 
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26", 
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34", 
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30", 
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "30", 
+	"ETSI", "5G", "40M", "HT", "1T", "38", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "38", "32",
+	"FCC", "5G", "40M", "HT", "1T", "46", "30", 
+	"ETSI", "5G", "40M", "HT", "1T", "46", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "46", "32",
+	"FCC", "5G", "40M", "HT", "1T", "54", "32", 
+	"ETSI", "5G", "40M", "HT", "1T", "54", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "54", "32",
+	"FCC", "5G", "40M", "HT", "1T", "62", "32", 
+	"ETSI", "5G", "40M", "HT", "1T", "62", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "62", "32",
+	"FCC", "5G", "40M", "HT", "1T", "102", "28", 
+	"ETSI", "5G", "40M", "HT", "1T", "102", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "102", "32",
+	"FCC", "5G", "40M", "HT", "1T", "110", "32", 
+	"ETSI", "5G", "40M", "HT", "1T", "110", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "110", "32",
+	"FCC", "5G", "40M", "HT", "1T", "118", "34", 
+	"ETSI", "5G", "40M", "HT", "1T", "118", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "118", "32",
+	"FCC", "5G", "40M", "HT", "1T", "126", "34", 
+	"ETSI", "5G", "40M", "HT", "1T", "126", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "126", "32",
+	"FCC", "5G", "40M", "HT", "1T", "134", "32", 
+	"ETSI", "5G", "40M", "HT", "1T", "134", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "134", "32",
+	"FCC", "5G", "40M", "HT", "1T", "151", "34", 
+	"ETSI", "5G", "40M", "HT", "1T", "151", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "34", 
+	"ETSI", "5G", "40M", "HT", "1T", "159", "32", 
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28", 
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28", 
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30", 
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30", 
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26", 
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30", 
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34", 
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32", 
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30", 
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34", 
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34", 
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30", 
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "30", 
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "32", 
+	"MKK", "5G", "80M", "VHT", "1T", "42", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "28", 
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "32", 
+	"MKK", "5G", "80M", "VHT", "1T", "58", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "30", 
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "32", 
+	"MKK", "5G", "80M", "VHT", "1T", "106", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "34", 
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "32", 
+	"MKK", "5G", "80M", "VHT", "1T", "122", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "34", 
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "32", 
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28", 
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30", 
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26", 
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30", 
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28", 
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30", 
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32", 
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30", 
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34", 
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30", 
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+ODM_ReadAndConfig_MP_8703B_TXPWR_LMT(
+	IN   PDM_ODM_T  pDM_Odm
+)
+{
+	u4Byte     i           = 0;
+	u4Byte     ArrayLen    = sizeof(Array_MP_8703B_TXPWR_LMT)/sizeof(pu1Byte);
+	pu1Byte    *Array      = (pu1Byte *)Array_MP_8703B_TXPWR_LMT;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	PlatformZeroMemory(pHalData->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT*MAX_BYTES_LINE_HWCONFIG_TXT);
+	pHalData->nLinesReadPwrLmt = ArrayLen/7;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8703B_TXPWR_LMT\n"));
+
+	for (i = 0; i < ArrayLen; i += 7) {
+		pu1Byte regulation = Array[i];
+		pu1Byte band = Array[i+1];
+		pu1Byte bandwidth = Array[i+2];
+		pu1Byte rate = Array[i+3];
+		pu1Byte rfPath = Array[i+4];
+		pu1Byte chnl = Array[i+5];
+		pu1Byte val = Array[i+6];
+	
+		odm_ConfigBB_TXPWR_LMT_8703B(pDM_Odm, regulation, band, bandwidth, rate, rfPath, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)pHalData->BufOfLinesPwrLmt[i/7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			regulation, band, bandwidth, rate, rfPath, chnl, val);
+#endif
+	}
+
+}
+
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.h
new file mode 100644
index 000000000..b679e1541
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halhwimg8703b_rf.h
@@ -0,0 +1,69 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#if (RTL8703B_SUPPORT == 1)
+#ifndef __INC_MP_RF_HW_IMG_8703B_H
+#define __INC_MP_RF_HW_IMG_8703B_H
+
+
+/******************************************************************************
+*                           RadioA.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_RadioA(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_RadioA(void);
+
+/******************************************************************************
+*                           TxPowerTrack_SDIO.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_TxPowerTrack_SDIO(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_TxPowerTrack_SDIO(void);
+
+/******************************************************************************
+*                           TxPowerTrack_USB.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_TxPowerTrack_USB(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_TxPowerTrack_USB(void);
+
+/******************************************************************************
+*                           TXPWR_LMT.TXT
+******************************************************************************/
+
+void
+ODM_ReadAndConfig_MP_8703B_TXPWR_LMT(/* TC: Test Chip, MP: MP Chip*/
+	IN   PDM_ODM_T  pDM_Odm
+);
+u4Byte ODM_GetVersion_MP_8703B_TXPWR_LMT(void);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.c
new file mode 100644
index 000000000..5a2065bfd
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.c
@@ -0,0 +1,2228 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+
+
+/*---------------------------Define Local Constant---------------------------*/
+//IQK
+#define IQK_DELAY_TIME_8703B	10
+#define LCK_DELAY_TIME_8703B	100
+
+/* LTE_COEX */
+#define REG_LTECOEX_CTRL 0x07C0
+#define REG_LTECOEX_WRITE_DATA 0x07C4
+#define REG_LTECOEX_READ_DATA 0x07C8
+#define REG_LTECOEX_PATH_CONTROL 0x70
+
+
+
+// 2010/04/25 MH Define the max tx power tracking tx agc power.
+#define		ODM_TXPWRTRACK_MAX_IDX8703B		6
+
+#define     IDX_0xC94                       0
+#define     IDX_0xC80                       1
+#define     IDX_0xC4C                       2
+
+#define     IDX_0xC14                       0
+#define     IDX_0xCA0                       1
+
+#define     KEY                             0
+#define     VAL                             1
+
+/*---------------------------Define Local Constant---------------------------*/
+
+
+//3============================================================
+//3 Tx Power Tracking
+//3============================================================
+
+
+void setIqkMatrix_8703B(
+	PDM_ODM_T	pDM_Odm,
+	u1Byte		OFDM_index,
+	u1Byte		RFPath,
+	s4Byte		IqkResult_X,
+	s4Byte		IqkResult_Y
+)
+{
+	s4Byte			ele_A = 0, ele_D = 0, ele_C = 0, value32, tmp;
+	s4Byte			ele_A_ext = 0, ele_C_ext = 0, ele_D_ext = 0;
+
+	RFPath = ODM_RF_PATH_A;
+
+
+	if (OFDM_index >= OFDM_TABLE_SIZE)
+		OFDM_index = OFDM_TABLE_SIZE-1;
+	else if (OFDM_index < 0)
+		OFDM_index = 0;
+
+	if ((IqkResult_X != 0) && (*(pDM_Odm->pBandType) == ODM_BAND_2_4G)) {
+
+		/* new element D */
+		ele_D = (OFDMSwingTable_New[OFDM_index] & 0xFFC00000)>>22;
+		ele_D_ext = (((IqkResult_X * ele_D)>>7)&0x01);
+
+		/* new element A */
+		if ((IqkResult_X & 0x00000200) != 0)		/* consider minus */
+			IqkResult_X = IqkResult_X | 0xFFFFFC00;
+		ele_A = ((IqkResult_X * ele_D)>>8)&0x000003FF;
+		ele_A_ext = ((IqkResult_X * ele_D)>>7) & 0x1;
+		/* new element C */
+		if ((IqkResult_Y & 0x00000200) != 0)
+			IqkResult_Y = IqkResult_Y | 0xFFFFFC00;
+		ele_C = ((IqkResult_Y * ele_D)>>8)&0x000003FF;
+		ele_C_ext = ((IqkResult_Y * ele_D)>>7) & 0x1;
+
+		switch (RFPath) {
+		case ODM_RF_PATH_A:
+			/* write new elements A, C, D to regC80, regC94, reg0xc4c, and element B is always 0 */
+			/* write 0xc80 */
+			value32 = (ele_D << 22) | ((ele_C & 0x3F) << 16) | ele_A;
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
+			/* write 0xc94 */
+			value32 = (ele_C & 0x000003C0) >> 6;
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
+			/* write 0xc4c */
+			value32 = (ele_D_ext << 28) | (ele_A_ext << 31) | (ele_C_ext << 29);
+			value32 = (ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord)&(~(BIT31|BIT29|BIT28))) | value32;
+			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord, value32);
+			break;
+		case ODM_RF_PATH_B:
+			/* write new elements A, C, D to regC88, regC9C, regC4C, and element B is always 0 */
+			/* write 0xc88 */
+			value32 = (ele_D << 22) | ((ele_C & 0x3F) << 16) | ele_A;
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
+			/* write 0xc9c */
+			value32 = (ele_C & 0x000003C0) >> 6;
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
+			/* write 0xc4c */
+			value32 = (ele_D_ext << 24) | (ele_A_ext << 27) | (ele_C_ext << 25);
+			value32 = (ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord)&(~(BIT24|BIT27|BIT25))) | value32;
+			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord, value32);
+			break;
+		default:
+			break;
+		}
+	} else {
+		switch (RFPath) {
+		case ODM_RF_PATH_A:
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable_New[OFDM_index]);
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
+			value32 = ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord)&(~(BIT31|BIT29|BIT28));
+			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord, value32);
+			break;
+
+		case ODM_RF_PATH_B:
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable_New[OFDM_index]);
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
+			value32 = ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord)&(~(BIT24|BIT27|BIT25));
+			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord, value32);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("TxPwrTracking path %c: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x ele_A_ext = 0x%x ele_C_ext = 0x%x ele_D_ext = 0x%x\n",
+				 (RFPath == ODM_RF_PATH_A ? 'A' : 'B'), (u4Byte)IqkResult_X, (u4Byte)IqkResult_Y, (u4Byte)ele_A, (u4Byte)ele_C, (u4Byte)ele_D, (u4Byte)ele_A_ext, (u4Byte)ele_C_ext, (u4Byte)ele_D_ext));
+}
+
+VOID
+setCCKFilterCoefficient_8703B(
+	PDM_ODM_T	pDM_Odm,
+	u1Byte 		CCKSwingIndex
+)
+{
+	ODM_Write1Byte(pDM_Odm, 0xa22, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][0]);
+	ODM_Write1Byte(pDM_Odm, 0xa23, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][1]);
+	ODM_Write1Byte(pDM_Odm, 0xa24, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][2]);
+	ODM_Write1Byte(pDM_Odm, 0xa25, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][3]);
+	ODM_Write1Byte(pDM_Odm, 0xa26, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][4]);
+	ODM_Write1Byte(pDM_Odm, 0xa27, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][5]);
+	ODM_Write1Byte(pDM_Odm, 0xa28, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][6]);
+	ODM_Write1Byte(pDM_Odm, 0xa29, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][7]);
+	ODM_Write1Byte(pDM_Odm, 0xa9a, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][8]);
+	ODM_Write1Byte(pDM_Odm, 0xa9b, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][9]);
+	ODM_Write1Byte(pDM_Odm, 0xa9c, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][10]);
+	ODM_Write1Byte(pDM_Odm, 0xa9d, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][11]);
+	ODM_Write1Byte(pDM_Odm, 0xaa0, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][12]);
+	ODM_Write1Byte(pDM_Odm, 0xaa1, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][13]);
+	ODM_Write1Byte(pDM_Odm, 0xaa2, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][14]);
+	ODM_Write1Byte(pDM_Odm, 0xaa3, CCKSwingTable_Ch1_Ch14_88F[CCKSwingIndex][15]);
+}
+
+void DoIQK_8703B(
+	PVOID		pDM_VOID,
+	u1Byte		DeltaThermalIndex,
+	u1Byte		ThermalValue,
+	u1Byte		Threshold
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	PADAPTER 		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+#endif
+
+	ODM_ResetIQKResult(pDM_Odm);
+
+
+	pDM_Odm->RFCalibrateInfo.ThermalValue_IQK= ThermalValue;
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	PHY_IQCalibrate_8703B(pDM_Odm, FALSE);
+#else
+	PHY_IQCalibrate_8703B(Adapter, FALSE);
+#endif
+
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	odm_TxPwrTrackSetPwr88E()
+ *
+ * Overview:	88E change all channel tx power accordign to flag.
+ *				OFDM & CCK are all different.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	04/23/2012	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+VOID
+ODM_TxPwrTrackSetPwr_8703B(
+	IN	PVOID		pDM_VOID,
+	PWRTRACK_METHOD 	Method,
+	u1Byte 				RFPath,
+	u1Byte 				ChannelMappedIndex
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	u1Byte		PwrTrackingLimit_OFDM = 34; /* +0dB */
+	u1Byte		PwrTrackingLimit_CCK = CCK_TABLE_SIZE_88F - 1;   /* -2dB */
+	u1Byte		TxRate = 0xFF;
+	u1Byte		Final_OFDM_Swing_Index = 0;
+	u1Byte		Final_CCK_Swing_Index = 0;
+	u1Byte		i = 0;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#if (MP_DRIVER == 1)	/*win MP */
+	PMPT_CONTEXT			pMptCtx = &(Adapter->MptCtx);
+	TxRate = MptToMgntRate(pMptCtx->MptRateIndex);
+#else	/*win normal*/
+	PMGNT_INFO      		pMgntInfo = &(Adapter->MgntInfo);
+	if (!pMgntInfo->ForcedDataRate) {	/*auto rate*/
+		if (pDM_Odm->TxRate != 0xFF)
+			TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate);
+	} else {
+		TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
+	}
+#endif
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	if (pDM_Odm->mp_mode == TRUE) {	/*CE MP*/
+		PMPT_CONTEXT		pMptCtx = &(Adapter->mppriv.MptCtx);
+
+		TxRate = MptToMgntRate(pMptCtx->MptRateIndex);
+	} else {	/*CE normal*/
+		u2Byte	rate	 = *(pDM_Odm->pForcedDataRate);
+
+		if (!rate) {	/*auto rate*/
+			if (pDM_Odm->TxRate != 0xFF)
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+				TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate);
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+				TxRate = HwRateToMRate(pDM_Odm->TxRate);
+#endif
+		} else {	/*force rate*/
+			TxRate = (u1Byte)rate;
+		}
+	}
+#endif
+
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("===>ODM_TxPwrTrackSetPwr8703B\n"));
+
+	if (TxRate != 0xFF) {
+		/*2 CCK*/
+		if ((TxRate >= MGN_1M) && (TxRate <= MGN_11M))
+			PwrTrackingLimit_CCK = CCK_TABLE_SIZE_88F - 1;
+		/*2 OFDM*/
+		else if ((TxRate >= MGN_6M) && (TxRate <= MGN_48M))
+			PwrTrackingLimit_OFDM = 36;	/*+3dB*/
+		else if (TxRate == MGN_54M)
+			PwrTrackingLimit_OFDM = 34;	/*+2dB*/
+		/*2 HT*/
+		else if ((TxRate >= MGN_MCS0) && (TxRate <= MGN_MCS2))	/*QPSK/BPSK*/
+			PwrTrackingLimit_OFDM = 38;	/*+4dB*/
+		else if ((TxRate >= MGN_MCS3) && (TxRate <= MGN_MCS4))	/*16QAM*/
+			PwrTrackingLimit_OFDM = 36;	/*+3dB*/
+		else if ((TxRate >= MGN_MCS5) && (TxRate <= MGN_MCS7))	/*64QAM*/
+			PwrTrackingLimit_OFDM = 34;	/*+2dB*/
+		else
+			PwrTrackingLimit_OFDM =  pRFCalibrateInfo->DefaultOfdmIndex;   /*Default OFDM index = 30*/
+	}
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("TxRate=0x%x, PwrTrackingLimit=%d\n", TxRate, PwrTrackingLimit_OFDM));
+
+	if (Method == TXAGC) {
+		u1Byte	rf = 0;
+		u4Byte	pwr = 0, TxAGC = 0;
+		PADAPTER Adapter = pDM_Odm->Adapter;
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("odm_TxPwrTrackSetPwr8703B CH=%d\n", *(pDM_Odm->pChannel)));
+
+		pRFCalibrateInfo->Remnant_OFDMSwingIdx[RFPath] = pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath];
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE ))
+#if (MP_DRIVER != 1)
+		pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = TRUE;
+		pRFCalibrateInfo->Modify_TxAGC_Flag_PathA_CCK = TRUE;
+
+		PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, CCK);
+		PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, OFDM);
+		PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, HT_MCS0_MCS7);
+#else
+		pwr = PHY_QueryBBReg(Adapter, rTxAGC_A_Rate18_06, 0xFF);
+		pwr += pRFCalibrateInfo->PowerIndexOffset[RFPath];
+		PHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, pwr);
+		TxAGC = (pwr<<16)|(pwr<<8)|(pwr);
+		PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, TxAGC);
+		RT_DISP(FPHY, PHY_TXPWR, ("ODM_TxPwrTrackSetPwr8703B: CCK Tx-rf(A) Power = 0x%x\n", TxAGC));
+
+		pwr = PHY_QueryBBReg(Adapter, rTxAGC_A_Rate18_06, 0xFF);
+		pwr += (pRFCalibrateInfo->BbSwingIdxOfdm[RFPath] - pRFCalibrateInfo->BbSwingIdxOfdmBase[RFPath]);
+		TxAGC |= ((pwr<<24)|(pwr<<16)|(pwr<<8)|pwr);
+		PHY_SetBBReg(Adapter, rTxAGC_A_Rate18_06, bMaskDWord, TxAGC);
+		PHY_SetBBReg(Adapter, rTxAGC_A_Rate54_24, bMaskDWord, TxAGC);
+		PHY_SetBBReg(Adapter, rTxAGC_A_Mcs03_Mcs00, bMaskDWord, TxAGC);
+		PHY_SetBBReg(Adapter, rTxAGC_A_Mcs07_Mcs04, bMaskDWord, TxAGC);
+		PHY_SetBBReg(Adapter, rTxAGC_A_Mcs11_Mcs08, bMaskDWord, TxAGC);
+		PHY_SetBBReg(Adapter, rTxAGC_A_Mcs15_Mcs12, bMaskDWord, TxAGC);
+		RT_DISP(FPHY, PHY_TXPWR, ("ODM_TxPwrTrackSetPwr8703B: OFDM Tx-rf(A) Power = 0x%x\n", TxAGC));
+#endif
+#endif
+	} else if (Method == BBSWING) {
+		Final_OFDM_Swing_Index = pRFCalibrateInfo->DefaultOfdmIndex + pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath];
+		Final_CCK_Swing_Index = pRFCalibrateInfo->DefaultCckIndex + pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath];
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					 (" pRFCalibrateInfo->DefaultOfdmIndex=%d,  pRFCalibrateInfo->DefaultCCKIndex=%d, pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath]=%d, pRFCalibrateInfo->Remnant_CCKSwingIdx=%d   RF_Path = %d\n",
+					  pRFCalibrateInfo->DefaultOfdmIndex, pRFCalibrateInfo->DefaultCckIndex, pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath], pRFCalibrateInfo->Remnant_CCKSwingIdx, RFPath));
+
+		/* Adjust BB swing by OFDM IQ matrix */
+		if (Final_OFDM_Swing_Index >= PwrTrackingLimit_OFDM)
+			Final_OFDM_Swing_Index = PwrTrackingLimit_OFDM;
+		else if (Final_OFDM_Swing_Index < 0)
+			Final_OFDM_Swing_Index = 0;
+
+		if (Final_CCK_Swing_Index >= CCK_TABLE_SIZE)
+			Final_CCK_Swing_Index = CCK_TABLE_SIZE-1;
+		else if (pRFCalibrateInfo->BbSwingIdxCck < 0)
+			Final_CCK_Swing_Index = 0;
+
+		setIqkMatrix_8703B(pDM_Odm, Final_OFDM_Swing_Index, ODM_RF_PATH_A,
+						   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][0],
+						   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][1]);
+
+		setCCKFilterCoefficient_8703B(pDM_Odm, Final_CCK_Swing_Index);
+
+	} else if (Method == MIX_MODE) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					 (" pDM_Odm->DefaultOfdmIndex=%d,  pDM_Odm->DefaultCCKIndex=%d, pDM_Odm->Absolute_OFDMSwingIdx[RFPath]=%d, pDM_Odm->Remnant_CCKSwingIdx=%d   RF_Path = %d\n",
+					  pRFCalibrateInfo->DefaultOfdmIndex, pRFCalibrateInfo->DefaultCckIndex, pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath], pRFCalibrateInfo->Remnant_CCKSwingIdx, RFPath));
+
+		Final_OFDM_Swing_Index = pRFCalibrateInfo->DefaultOfdmIndex + pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath];
+		Final_CCK_Swing_Index  = pRFCalibrateInfo->DefaultCckIndex + pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath];
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					 (" pDM_Odm->DefaultOfdmIndex=%d,  pDM_Odm->DefaultCCKIndex=%d, pDM_Odm->Absolute_OFDMSwingIdx[RFPath]=%d   RF_Path = %d\n",
+					  pRFCalibrateInfo->DefaultOfdmIndex, pRFCalibrateInfo->DefaultCckIndex, pRFCalibrateInfo->Absolute_OFDMSwingIdx[RFPath], RFPath));
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+					 (" Final_OFDM_Swing_Index=%d,  Final_CCK_Swing_Index=%d RFPath=%d\n",
+					  Final_OFDM_Swing_Index, Final_CCK_Swing_Index, RFPath));
+
+
+		if (Final_OFDM_Swing_Index > PwrTrackingLimit_OFDM) {   /*BBSwing higher then Limit*/
+			pRFCalibrateInfo->Remnant_OFDMSwingIdx[RFPath] = Final_OFDM_Swing_Index - PwrTrackingLimit_OFDM;
+
+			setIqkMatrix_8703B(pDM_Odm, PwrTrackingLimit_OFDM, ODM_RF_PATH_A,
+							   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][0],
+							   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][1]);
+
+			pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = TRUE;
+			PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, OFDM);
+			PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, HT_MCS0_MCS7);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						 (" ******Path_A Over BBSwing Limit , PwrTrackingLimit = %d , Remnant TxAGC Value = %d\n",
+						  PwrTrackingLimit_OFDM, pRFCalibrateInfo->Remnant_OFDMSwingIdx[RFPath]));
+		} else if (Final_OFDM_Swing_Index < 0) {
+			pRFCalibrateInfo->Remnant_OFDMSwingIdx[RFPath] = Final_OFDM_Swing_Index;
+
+			setIqkMatrix_8703B(pDM_Odm, 0, ODM_RF_PATH_A,
+							   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][0],
+							   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][1]);
+
+			pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = TRUE;
+			PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, OFDM);
+			PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, HT_MCS0_MCS7);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						 (" ******Path_A Lower then BBSwing lower bound  0 , Remnant TxAGC Value = %d\n",
+						  pRFCalibrateInfo->Remnant_OFDMSwingIdx[RFPath]));
+		} else {
+			setIqkMatrix_8703B(pDM_Odm, Final_OFDM_Swing_Index, ODM_RF_PATH_A,
+							   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][0],
+							   pRFCalibrateInfo->IQKMatrixRegSetting[ChannelMappedIndex].Value[0][1]);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						 (" ******Path_A Compensate with BBSwing , Final_OFDM_Swing_Index = %d\n", Final_OFDM_Swing_Index));
+
+			if (pRFCalibrateInfo->Modify_TxAGC_Flag_PathA) {		/*If TxAGC has changed, reset TxAGC again*/
+				pRFCalibrateInfo->Remnant_OFDMSwingIdx[RFPath] = 0;
+				PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, OFDM);
+				PHY_SetTxPowerIndexByRateSection(Adapter, RFPath, pHalData->CurrentChannel, HT_MCS0_MCS7);
+				pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = FALSE;
+
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+							 (" ******Path_A pDM_Odm->Modify_TxAGC_Flag = FALSE\n"));
+			}
+		}
+		if (Final_CCK_Swing_Index > PwrTrackingLimit_CCK) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						 (" Final_CCK_Swing_Index(%d) > PwrTrackingLimit_CCK(%d)\n", Final_CCK_Swing_Index, PwrTrackingLimit_CCK));
+
+			pRFCalibrateInfo->Remnant_CCKSwingIdx = Final_CCK_Swing_Index - PwrTrackingLimit_CCK;
+
+			setCCKFilterCoefficient_8703B(pDM_Odm, PwrTrackingLimit_CCK);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("******Path_A CCK Over Limit , PwrTrackingLimit_CCK = %d , pDM_Odm->Remnant_CCKSwingIdx  = %d\n", PwrTrackingLimit_CCK, pRFCalibrateInfo->Remnant_CCKSwingIdx));
+
+			pRFCalibrateInfo->Modify_TxAGC_Flag_PathA_CCK = TRUE;
+
+			PHY_SetTxPowerIndexByRateSection(Adapter, ODM_RF_PATH_A, pHalData->CurrentChannel, CCK);
+
+		} else if (Final_CCK_Swing_Index < 0) {		/* Lowest CCK Index = 0 */
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						 (" Final_CCK_Swing_Index(%d) < 0      PwrTrackingLimit_CCK(%d)\n", Final_CCK_Swing_Index, PwrTrackingLimit_CCK));
+
+			pRFCalibrateInfo->Remnant_CCKSwingIdx = Final_CCK_Swing_Index;
+
+			setCCKFilterCoefficient_8703B(pDM_Odm, 0);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("******Path_A CCK Under Limit , PwrTrackingLimit_CCK = %d , pDM_Odm->Remnant_CCKSwingIdx  = %d\n", 0, pRFCalibrateInfo->Remnant_CCKSwingIdx));
+
+			pRFCalibrateInfo->Modify_TxAGC_Flag_PathA_CCK = TRUE;
+
+			PHY_SetTxPowerIndexByRateSection(Adapter, ODM_RF_PATH_A, pHalData->CurrentChannel, CCK);
+
+		} else {
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
+						 (" else Final_CCK_Swing_Index=%d      PwrTrackingLimit_CCK(%d)\n", Final_CCK_Swing_Index, PwrTrackingLimit_CCK));
+
+			setCCKFilterCoefficient_8703B(pDM_Odm, Final_CCK_Swing_Index);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("******Path_A CCK Compensate with BBSwing , Final_CCK_Swing_Index = %d\n", Final_CCK_Swing_Index));
+
+			pRFCalibrateInfo->Modify_TxAGC_Flag_PathA_CCK = FALSE;
+
+			pRFCalibrateInfo->Remnant_CCKSwingIdx = 0;
+
+			if (pRFCalibrateInfo->Modify_TxAGC_Flag_PathA_CCK) {		/*If TxAGC has changed, reset TxAGC again*/
+				pRFCalibrateInfo->Remnant_CCKSwingIdx = 0;
+				PHY_SetTxPowerIndexByRateSection(Adapter, ODM_RF_PATH_A, pHalData->CurrentChannel, CCK);
+				pRFCalibrateInfo->Modify_TxAGC_Flag_PathA_CCK = FALSE;
+			}
+
+
+
+		}
+
+	} else {
+		return; // This method is not supported.
+	}
+}
+
+VOID
+GetDeltaSwingTable_8703B(
+	IN	PVOID		pDM_VOID,
+	OUT pu1Byte		*TemperatureUP_A,
+	OUT pu1Byte		*TemperatureDOWN_A,
+	OUT pu1Byte		*TemperatureUP_B,
+	OUT pu1Byte		*TemperatureDOWN_B
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter 		 = pDM_Odm->Adapter;
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+	HAL_DATA_TYPE	*pHalData		 = GET_HAL_DATA(Adapter);
+	u1Byte			TxRate			= 0xFF;
+	u1Byte			channel 		 = pHalData->CurrentChannel;
+
+	
+	if (pDM_Odm->mp_mode == TRUE) {
+	#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+		#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+			#if (MP_DRIVER == 1)
+					PMPT_CONTEXT pMptCtx = &(Adapter->MptCtx);
+					
+					TxRate = MptToMgntRate(pMptCtx->MptRateIndex);
+			#endif
+		#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+				PMPT_CONTEXT pMptCtx = &(Adapter->mppriv.MptCtx);
+				
+				TxRate = MptToMgntRate(pMptCtx->MptRateIndex);
+		#endif	
+	#endif
+	} else {
+		u2Byte	rate	 = *(pDM_Odm->pForcedDataRate);
+		
+		if (!rate) { /*auto rate*/
+			if (rate != 0xFF) {
+			#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+						TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate);
+			#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+						TxRate = HwRateToMRate(pDM_Odm->TxRate);
+			#endif
+			}
+		} else { /*force rate*/
+			TxRate = (u1Byte)rate;
+		}
+	}
+		
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("Power Tracking TxRate=0x%X\n", TxRate));
+
+	if ( 1 <= channel && channel <= 14) {
+		if (IS_CCK_RATE(TxRate)) {
+			*TemperatureUP_A   = pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKA_P;
+			*TemperatureDOWN_A = pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKA_N;
+			*TemperatureUP_B   = pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKB_P;
+			*TemperatureDOWN_B = pRFCalibrateInfo->DeltaSwingTableIdx_2GCCKB_N;
+		} else {
+			*TemperatureUP_A   = pRFCalibrateInfo->DeltaSwingTableIdx_2GA_P;
+			*TemperatureDOWN_A = pRFCalibrateInfo->DeltaSwingTableIdx_2GA_N;
+			*TemperatureUP_B   = pRFCalibrateInfo->DeltaSwingTableIdx_2GB_P;
+			*TemperatureDOWN_B = pRFCalibrateInfo->DeltaSwingTableIdx_2GB_N;
+		}
+	} else {
+		*TemperatureUP_A   = (pu1Byte)DeltaSwingTableIdx_2GA_P_8188E;
+		*TemperatureDOWN_A = (pu1Byte)DeltaSwingTableIdx_2GA_N_8188E;
+		*TemperatureUP_B   = (pu1Byte)DeltaSwingTableIdx_2GA_P_8188E;
+		*TemperatureDOWN_B = (pu1Byte)DeltaSwingTableIdx_2GA_N_8188E;
+	}
+
+	return;
+}
+
+
+void ConfigureTxpowerTrack_8703B(
+	PTXPWRTRACK_CFG	pConfig
+)
+{
+	pConfig->SwingTableSize_CCK = CCK_TABLE_SIZE;
+	pConfig->SwingTableSize_OFDM = OFDM_TABLE_SIZE;
+	pConfig->Threshold_IQK = IQK_THRESHOLD;
+	pConfig->AverageThermalNum = AVG_THERMAL_NUM_8703B;
+	pConfig->RfPathCount = MAX_PATH_NUM_8703B;
+	pConfig->ThermalRegAddr = RF_T_METER_8703B;
+
+	pConfig->ODM_TxPwrTrackSetPwr = ODM_TxPwrTrackSetPwr_8703B;
+	pConfig->DoIQK = DoIQK_8703B;
+	pConfig->PHY_LCCalibrate = PHY_LCCalibrate_8703B;
+	pConfig->GetDeltaSwingTable = GetDeltaSwingTable_8703B;
+}
+
+//1 7.	IQK
+#define MAX_TOLERANCE		5
+#define IQK_DELAY_TIME		1		//ms
+
+u1Byte			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+phy_PathA_IQK_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm
+#else
+	IN	PADAPTER	pAdapter
+#endif
+)
+{
+	u4Byte regEAC, regE94, regE9C, tmp/*, regEA4*/;
+	u1Byte result = 0x00, Ktime;
+	u4Byte originalPath, originalGNT;
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]TX IQK!\n"));
+
+	/*8703b IQK v2.0 20150713*/
+	/*1 Tx IQK*/
+	/*IQK setting*/
+	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	/*path-A IQK setting*/
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+/*	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x8214010a);*/
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x8214030f);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+
+	/*LO calibration setting*/
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+
+	/*leave IQK mode*/
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+
+	/*PA, PAD setting*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, 0x800, 0x1);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x55, 0x0007f, 0x7);	
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x7f, bRFRegOffsetMask, 0x0d400);
+
+	/*enter IQK mode*/
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x808000);
+
+#if 1
+	/*path setting*/
+	/*Save Original Path Owner, Original GNT*/
+	originalPath = ODM_GetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, bMaskDWord);  /*save 0x70*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0x800f0038);
+	ODM_delay_ms(1);
+	originalGNT = ODM_GetBBReg(pDM_Odm, REG_LTECOEX_READ_DATA, bMaskDWord);  /*save 0x38*/
+
+	/*set GNT_WL=1/GNT_BT=0  and Path owner to WiFi for pause BT traffic*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_WRITE_DATA, bMaskDWord, 0x00007700);
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0xc0020038);	/*0x38[15:8] = 0x77*/
+	ODM_SetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, BIT26, 0x1);  /*0x70[26] =1 --> Path Owner to WiFi*/
+#endif
+
+	/*One shot, path A LOK & IQK*/
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+	/* delay x ms */
+	ODM_delay_ms(IQK_DELAY_TIME_8703B);
+	Ktime = 0;
+	while ((ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord) == 0) && Ktime < 10) {
+		ODM_delay_ms(5);
+		Ktime++;
+	}
+
+#if 1
+	/*path setting*/
+	/*Restore GNT_WL/GNT_BT  and Path owner*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_WRITE_DATA, bMaskDWord, originalGNT);
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0xc00f0038);
+	ODM_SetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, 0xffffffff, originalPath);
+
+	originalPath = ODM_GetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, bMaskDWord);  /*save 0x70*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0x800f0038);
+	ODM_delay_ms(1);
+	originalGNT = ODM_GetBBReg(pDM_Odm, REG_LTECOEX_READ_DATA, bMaskDWord);  /*save 0x38*/
+
+/*	DBG_871X("[COEXDBG] REG 0x38 = 0x%08X, 0x70=0x%08x After Tx IQK !!!!!!!!!!\n", originalGNT, originalPath);*/
+#endif
+
+	/*leave IQK mode*/
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+	/*	PA/PAD controlled by 0x0*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, 0x800, 0x0);
+
+	/* Check failed*/
+	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xeac = 0x%x\n", regEAC));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xe94 = 0x%x, 0xe9c = 0x%x\n", regE94, regE9C));
+	/*monitor image power before & after IQK*/
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xe90(before IQK)= 0x%x, 0xe98(afer IQK) = 0x%x\n",
+				 ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xe98, bMaskDWord)));
+
+	if (!(regEAC & BIT28) &&
+	   (((regE94 & 0x03FF0000)>>16) != 0x142) &&
+	   (((regE9C & 0x03FF0000)>>16) != 0x42))
+
+		result |= 0x01;
+
+	return result;
+
+}
+
+u1Byte			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+phy_PathA_RxIQK8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm
+#else
+	IN	PADAPTER	pAdapter
+#endif
+)
+{
+	u4Byte regEAC, regE94, regE9C, regEA4, u4tmp,tmp;
+	u1Byte result = 0x00, Ktime;
+	u4Byte originalPath, originalGNT;
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]RX IQK:Get TXIMR setting\n"));
+	//1 Get TX_XY
+
+	//IQK setting
+	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+
+	//path-A IQK setting
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+
+//	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x8216000f);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+
+	//LO calibration setting
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+
+	//leave IQK mode
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+
+	//modify RXIQK mode table
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x30000);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x00007);
+	/*IQK PA off*/
+//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0x57db7);
+
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x808000);
+
+#if 1
+	/*path setting*/
+	/*Save Original Path Owner, Original GNT*/
+	originalPath = ODM_GetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, bMaskDWord);  /*save 0x70*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0x800f0038);
+	ODM_delay_ms(1);
+	originalGNT = ODM_GetBBReg(pDM_Odm, REG_LTECOEX_READ_DATA, bMaskDWord);  /*save 0x38*/
+
+	/*set GNT_WL=1/GNT_BT=0  and Path owner to WiFi for pause BT traffic*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_WRITE_DATA, bMaskDWord, 0x00007700);
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0xc0020038);	/*0x38[15:8] = 0x77*/
+	ODM_SetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, BIT26, 0x1);  /*0x70[26] =1 --> Path Owner to WiFi*/
+#endif
+
+	//One shot, path A LOK & IQK
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+	// delay x ms
+	ODM_delay_ms(IQK_DELAY_TIME_8703B);
+	Ktime = 0;
+	while ((ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord) == 0) && Ktime < 10) {
+		ODM_delay_ms(5);
+		Ktime++;
+	}
+
+#if 1
+	/*path setting*/
+	/*Restore GNT_WL/GNT_BT  and Path owner*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_WRITE_DATA, bMaskDWord, originalGNT);
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0xc00f0038);
+	ODM_SetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, 0xffffffff, originalPath);
+
+	originalPath = ODM_GetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, bMaskDWord);  /*save 0x70*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0x800f0038);
+	ODM_delay_ms(1);
+	originalGNT = ODM_GetBBReg(pDM_Odm, REG_LTECOEX_READ_DATA, bMaskDWord);  /*save 0x38*/
+
+/*	DBG_871X("[COEXDBG] REG 0x38 = 0x%08X, 0x70=0x%08x After Get TXIMR !!!!!!!!!!\n", originalGNT, originalPath);*/
+
+#endif
+
+	//leave IQK mode
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+
+	// Check failed
+	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xeac = 0x%x\n", regEAC));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xe94 = 0x%x, 0xe9c = 0x%x\n", regE94, regE9C));
+	/*monitor image power before & after IQK*/
+	ODM_RT_TRACE(pDM_Odm , ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xe90(before IQK)= 0x%x, 0xe98(afer IQK) = 0x%x\n",
+				 ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xe98, bMaskDWord)));
+
+	//Allen 20131125
+	tmp = (regE9C & 0x03FF0000)>>16;
+	if ((tmp & 0x200) > 0)
+		tmp = 0x400 - tmp;
+
+	if (!(regEAC & BIT28) &&
+	   (((regE94 & 0x03FF0000)>>16) != 0x142) &&
+	   (((regE9C & 0x03FF0000)>>16) != 0x42))
+
+		result |= 0x01;
+	else							//if Tx not OK, ignore Rx
+		return result;
+
+
+
+	u4tmp = 0x80007C00 | (regE94&0x3FF0000)  | ((regE9C&0x3FF0000) >> 16);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, u4tmp);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xe40 = 0x%x u4tmp = 0x%x\n", ODM_GetBBReg(pDM_Odm, rTx_IQK, bMaskDWord), u4tmp));
+
+	//1 RX IQK
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]RX IQK\n"));
+
+	//IQK setting
+	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+
+	//path-A IQK setting
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28160c1f);
+/*	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x2816001f);*/
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+
+	//LO calibration setting
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x0046a8d1);
+
+
+	//modify RXIQK mode table
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x30000);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x00007);
+	/*PA off*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7d77);
+
+	/*PA, PAD setting*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, 0x800, 0x1);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x55, 0x0007f, 0x5);	
+
+	/*enter IQK mode*/
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x808000);
+
+#if 1
+	/*path setting*/
+	/*Save Original Path Owner, Original GNT*/
+	originalPath = ODM_GetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, bMaskDWord);  /*save 0x70*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0x800f0038);
+	ODM_delay_ms(1);
+	originalGNT = ODM_GetBBReg(pDM_Odm, REG_LTECOEX_READ_DATA, bMaskDWord);  /*save 0x38*/
+
+	/*set GNT_WL=1/GNT_BT=0  and Path owner to WiFi for pause BT traffic*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_WRITE_DATA, bMaskDWord, 0x00007700);
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0xc0020038);	/*0x38[15:8] = 0x77*/
+	ODM_SetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, BIT26, 0x1);  /*0x70[26] =1 --> Path Owner to WiFi*/
+#endif
+
+	//One shot, path A LOK & IQK
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+	// delay x ms
+	ODM_delay_ms(IQK_DELAY_TIME_8703B);
+	Ktime = 0;
+	while ((ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord) == 0) && Ktime < 10) {
+		ODM_delay_ms(5);
+		Ktime++;
+	}
+
+#if 1
+	/*path setting*/
+	/*Restore GNT_WL/GNT_BT  and Path owner*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_WRITE_DATA, bMaskDWord, originalGNT);
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0xc00f0038);
+	ODM_SetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, 0xffffffff, originalPath);
+
+	originalPath = ODM_GetMACReg(pDM_Odm, REG_LTECOEX_PATH_CONTROL, bMaskDWord);  /*save 0x70*/
+	ODM_SetBBReg(pDM_Odm, REG_LTECOEX_CTRL, bMaskDWord, 0x800f0038);
+	ODM_delay_ms(1);
+	originalGNT = ODM_GetBBReg(pDM_Odm, REG_LTECOEX_READ_DATA, bMaskDWord);  /*save 0x38*/
+
+/*	DBG_871X("[COEXDBG] REG 0x38 = 0x%08X, 0x70=0x%08x After Rx IQK !!!!!!!!!!\n", originalGNT, originalPath);*/
+
+#endif
+
+	/*leave IQK mode*/
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+	//	PA/PAD controlled by 0x0
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, 0x800, 0x0);
+
+	// Check failed
+	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regEA4= ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]0xeac = 0x%x\n", regEAC));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xea4 = 0x%x, 0xeac = 0x%x\n", regEA4, regEAC));
+	//monitor image power before & after IQK
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]0xea0(before IQK)= 0x%x, 0xea8(afer IQK) = 0x%x\n",
+				 ODM_GetBBReg(pDM_Odm, 0xea0, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xea8, bMaskDWord)));
+
+	//Allen 20131125
+	tmp = (regEAC & 0x03FF0000)>>16;
+	if ((tmp & 0x200) > 0)
+		tmp = 0x400 - tmp;
+
+	if (!(regEAC & BIT27) &&		/*if Tx is OK, check whether Rx is OK*/
+	   (((regEA4 & 0x03FF0000)>>16) != 0x132) &&
+	   (((regEAC & 0x03FF0000)>>16) != 0x36) &&
+	   (((regEA4 & 0x03FF0000)>>16) < 0x11a) &&
+	   (((regEA4 & 0x03FF0000)>>16) > 0xe6) &&
+	   (tmp < 0x1a))
+		result |= 0x02;
+	else							//if Tx not OK, ignore Rx
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Path A Rx IQK fail!!\n"));
+
+	return result;
+}
+
+
+VOID
+_PHY_PathAFillIQKMatrix8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN  BOOLEAN    	bIQKOK,
+	IN	s4Byte		result[][8],
+	IN	u1Byte		final_candidate,
+	IN  BOOLEAN		bTxOnly
+)
+{
+	u4Byte	Oldval_0, X, TX0_A, reg, tmp0xc80, tmp0xc94, tmp0xc4c, tmp0xc14, tmp0xca0;
+	s4Byte	Y, TX0_C;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed"));
+
+	if(final_candidate == 0xFF)
+		return;
+
+	else if (bIQKOK) {
+
+		Oldval_0 = (ODM_GetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+		X = result[final_candidate][0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX0_A = (X * Oldval_0) >> 8;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]X = 0x%x, TX0_A = 0x%x, Oldval_0 0x%x\n", X, TX0_A, Oldval_0));
+		tmp0xc80 = (ODM_GetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord) & 0xfffffc00) | (TX0_A & 0x3ff);
+		tmp0xc4c = (((X* Oldval_0>>7) & 0x1) << 31 ) | (ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord) & 0x7fffffff);
+
+		Y = result[final_candidate][1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+
+		//2 Tx IQC
+		TX0_C = (Y * Oldval_0) >> 8;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]Y = 0x%x, TX = 0x%x\n", Y, TX0_C));
+
+		tmp0xc94 = (((TX0_C&0x3C0)>>6) << 28) | (ODM_GetBBReg(pDM_Odm, rOFDM0_XCTxAFE, bMaskDWord) & 0x0fffffff);
+
+		pRFCalibrateInfo->TxIQC_8703B[IDX_0xC94][KEY] = rOFDM0_XCTxAFE;
+		pRFCalibrateInfo->TxIQC_8703B[IDX_0xC94][VAL] = tmp0xc94;
+
+		tmp0xc80 = (tmp0xc80 & 0xffc0ffff) | (TX0_C & 0x3F)<<16;
+
+		pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][KEY] = rOFDM0_XATxIQImbalance;
+		pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][VAL] = tmp0xc80;
+
+		tmp0xc4c = (tmp0xc4c & 0xdfffffff) | (((Y* Oldval_0>>7) & 0x1)<<29);
+
+		pRFCalibrateInfo->TxIQC_8703B[IDX_0xC4C][KEY] = rOFDM0_ECCAThreshold;
+		pRFCalibrateInfo->TxIQC_8703B[IDX_0xC4C][VAL] = tmp0xc4c;
+
+		if (bTxOnly) {
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]_PHY_PathAFillIQKMatrix8703B only Tx OK\n"));
+
+			// <20130226, Kordan> Saving RxIQC, otherwise not initialized.
+			pRFCalibrateInfo->RxIQC_8703B[IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
+			pRFCalibrateInfo->RxIQC_8703B[IDX_0xCA0][VAL] = 0xfffffff & ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, bMaskDWord);
+			pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
+			pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][VAL] = 0x40000100;
+			return;
+		}
+
+		reg = result[final_candidate][2];
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+		if (RTL_ABS(reg , 0x100) >= 16)
+			reg = 0x100;
+#endif
+
+		//2 Rx IQC
+		tmp0xc14 = (0x40000100 & 0xfffffc00) | reg;
+
+		reg = result[final_candidate][3] & 0x3F;
+		tmp0xc14 = (tmp0xc14 & 0xffff03ff) | (reg << 10);
+
+		pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
+		pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][VAL] = tmp0xc14;
+
+		reg = (result[final_candidate][3] >> 6) & 0xF;
+		tmp0xca0 = ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, 0x0fffffff) | (reg << 28);
+
+		pRFCalibrateInfo->RxIQC_8703B[IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
+		pRFCalibrateInfo->RxIQC_8703B[IDX_0xCA0][VAL] = tmp0xca0;
+	}
+}
+
+#if 0
+VOID
+_PHY_PathBFillIQKMatrix8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN  BOOLEAN   	bIQKOK,
+	IN	s4Byte		result[][8],
+	IN	u1Byte		final_candidate,
+	IN	BOOLEAN		bTxOnly			//do Tx only
+	)
+{
+	u4Byte	Oldval_1, X, TX1_A, reg, tmp0xc80, tmp0xc94, tmp0xc4c, tmp0xc14, tmp0xca0;
+	s4Byte	Y, TX1_C;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+	#endif
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	#endif
+#endif
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed"));
+
+	if(final_candidate == 0xFF)
+		return;
+
+	else if(bIQKOK)
+	{
+		Oldval_1 = (ODM_GetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+
+		X = result[final_candidate][4];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX1_A = (X * Oldval_1) >> 8;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]X = 0x%x, TX1_A = 0x%x\n", X, TX1_A));
+
+		tmp0xc80 = (ODM_GetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord) & 0xfffffc00) | (TX1_A & 0x3ff);
+		tmp0xc4c = (((X* Oldval_1>>7) & 0x1) << 31 ) | (ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord) & 0x7fffffff);
+
+		Y = result[final_candidate][5];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+
+		TX1_C = (Y * Oldval_1) >> 8;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]Y = 0x%x, TX1_C = 0x%x\n", Y, TX1_C));
+
+		/*2 Tx IQC*/
+
+		tmp0xc94 = (((TX1_C&0x3C0)>>6) << 28) | (ODM_GetBBReg(pDM_Odm,rOFDM0_XCTxAFE, bMaskDWord) & 0x0fffffff);
+
+		pRFCalibrateInfo->TxIQC_8703B[PATH_S0][IDX_0xC94][KEY] = rOFDM0_XCTxAFE;
+		pRFCalibrateInfo->TxIQC_8703B[PATH_S0][IDX_0xC94][VAL] = tmp0xc94;
+
+        tmp0xc80 = (tmp0xc80 & 0xffc0ffff) | (TX1_C&0x3F)<<16;
+		pRFCalibrateInfo->TxIQC_8703B[PATH_S0][IDX_0xC80][KEY] = rOFDM0_XATxIQImbalance;
+		pRFCalibrateInfo->TxIQC_8703B[PATH_S0][IDX_0xC80][VAL] = tmp0xc80;
+
+		tmp0xc4c = (tmp0xc4c & 0xdfffffff) | (((Y* Oldval_1>>7) & 0x1)<<29);
+		pRFCalibrateInfo->TxIQC_8703B[PATH_S0][IDX_0xC4C][KEY] = rOFDM0_ECCAThreshold;
+		pRFCalibrateInfo->TxIQC_8703B[PATH_S0][IDX_0xC4C][VAL] = tmp0xc4c;
+
+		if(bTxOnly) {
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]_PHY_PathBFillIQKMatrix8703B only Tx OK\n"));
+
+			pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
+			pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xC14][VAL] = 0x40000100;
+			pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
+			pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xCA0][VAL] = 0x0fffffff & ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, bMaskDWord);
+			return;
+		}
+
+		//2 Rx IQC
+		reg = result[final_candidate][6];
+		tmp0xc14 = (0x40000100 & 0xfffffc00) | reg;
+
+		reg = result[final_candidate][7] & 0x3F;
+		tmp0xc14 = (tmp0xc14 & 0xffff03ff) | (reg << 10);
+
+		pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
+		pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xC14][VAL] = tmp0xc14;
+
+		reg = (result[final_candidate][7] >> 6) & 0xF;
+		tmp0xca0 = ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, 0x0fffffff) | (reg << 28);
+
+		pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
+		pRFCalibrateInfo->RxIQC_8703B[PATH_S0][IDX_0xCA0][VAL] = tmp0xca0;
+	}
+}
+#endif
+
+BOOLEAN
+ODM_SetIQCbyRFpath_8703B(
+	IN PDM_ODM_T		pDM_Odm
+)
+{
+
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+
+	if ((pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][VAL] != 0x0) && (pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][VAL] != 0x0)) {
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]reload RF IQC!!!\n"));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]0xc80 = 0x%x!!!\n", pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][VAL]));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]0xc14 = 0x%x!!!\n", pRFCalibrateInfo->TxIQC_8703B[IDX_0xC14][VAL]));
+
+		/* TX IQC */
+		ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8703B[IDX_0xC94][KEY], bMaskH4Bits, (pRFCalibrateInfo->TxIQC_8703B[IDX_0xC94][VAL]>>28));
+		ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][VAL]);
+		ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8703B[IDX_0xC4C][KEY], BIT31, (pRFCalibrateInfo->TxIQC_8703B[IDX_0xC4C][VAL]>>31));
+		ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8703B[IDX_0xC4C][KEY], BIT29, ((pRFCalibrateInfo->TxIQC_8703B[IDX_0xC4C][VAL] & BIT29)>>29));
+
+		/* RX IQC */
+		ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8703B[IDX_0xC14][VAL]);
+		ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->RxIQC_8703B[IDX_0xCA0][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8703B[IDX_0xCA0][VAL]);
+		return TRUE;
+		
+	} else {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQC value invalid!!!\n"));
+		return FALSE;
+	}
+}
+
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+BOOLEAN
+ODM_CheckPowerStatus(
+	IN	PADAPTER		Adapter)
+{
+#if 0
+		HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+		PDM_ODM_T				pDM_Odm = &pHalData->DM_OutSrc;
+		RT_RF_POWER_STATE	rtState;
+		PMGNT_INFO				pMgntInfo	= &(Adapter->MgntInfo);
+
+		/* 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.*/
+		if (pMgntInfo->init_adpt_in_progress == TRUE) {
+			ODM_RT_TRACE(pDM_Odm, COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter"));
+			return	TRUE;
+		}
+
+
+		/*	2011/07/19 MH We can not execute tx power tracking/ LLC calibrate or IQK.*/
+
+		Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));
+		if (Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff) {
+			ODM_RT_TRACE(pDM_Odm, COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n",
+			Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
+			return	FALSE;
+		}
+#endif
+	return	TRUE;
+}
+#endif
+
+VOID
+_PHY_SaveADDARegisters8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		ADDAReg,
+	IN	pu4Byte		ADDABackup,
+	IN	u4Byte		RegisterNum
+)
+{
+	u4Byte	i;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+
+	if (ODM_CheckPowerStatus(pAdapter) == FALSE)
+		return;
+#endif
+
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Save ADDA parameters.\n"));
+	for (i = 0; i < RegisterNum; i++)
+		ADDABackup[i] = ODM_GetBBReg(pDM_Odm, ADDAReg[i], bMaskDWord);
+}
+
+
+VOID
+_PHY_SaveMACRegisters8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		MACReg,
+	IN	pu4Byte		MACBackup
+)
+{
+	u4Byte	i;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Save MAC parameters.\n"));
+	for (i = 0; i < (IQK_MAC_REG_NUM - 1); i++) 
+		MACBackup[i] = ODM_Read1Byte(pDM_Odm, MACReg[i]);
+	
+	MACBackup[i] = ODM_Read4Byte(pDM_Odm, MACReg[i]);
+
+}
+
+
+VOID
+_PHY_ReloadADDARegisters8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		ADDAReg,
+	IN	pu4Byte		ADDABackup,
+	IN	u4Byte		RegiesterNum
+)
+{
+	u4Byte	i;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Reload ADDA power saving parameters !\n"));
+	for (i = 0 ; i < RegiesterNum; i++) 
+		ODM_SetBBReg(pDM_Odm, ADDAReg[i], bMaskDWord, ADDABackup[i]);
+	
+}
+
+VOID
+_PHY_ReloadMACRegisters8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		MACReg,
+	IN	pu4Byte		MACBackup
+)
+{
+	u4Byte	i;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Reload MAC parameters !\n"));
+	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++)
+		ODM_Write1Byte(pDM_Odm, MACReg[i], (u1Byte)MACBackup[i]);
+
+	ODM_Write4Byte(pDM_Odm, MACReg[i], MACBackup[i]);
+}
+
+
+VOID
+_PHY_PathADDAOn8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		ADDAReg,
+	IN	BOOLEAN		isPathAOn
+)
+{
+	u4Byte	pathOn;
+	u4Byte	i;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("ADDA ON.\n"));
+
+	pathOn = 0x03c00014;
+
+
+	for (i = 0; i < IQK_ADDA_REG_NUM; i++)
+		ODM_SetBBReg(pDM_Odm,ADDAReg[i], bMaskDWord, pathOn);
+
+}
+
+VOID
+_PHY_MACSettingCalibration8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		MACReg,
+	IN	pu4Byte		MACBackup
+)
+{
+	u4Byte	i = 0;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("MAC settings for Calibration.\n"));
+
+	ODM_Write1Byte(pDM_Odm, MACReg[i], 0x3F);
+
+	for (i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++) 
+		ODM_Write1Byte(pDM_Odm, MACReg[i], (u1Byte)(MACBackup[i]&(~BIT3)));
+
+	ODM_Write1Byte(pDM_Odm, MACReg[i], (u1Byte)(MACBackup[i]&(~BIT5)));
+
+}
+
+BOOLEAN
+phy_SimularityCompare_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	s4Byte 		result[][8],
+	IN	u1Byte		 c1,
+	IN	u1Byte		 c2
+)
+{
+	u4Byte		i, j, diff, SimularityBitMap, bound = 0;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+	u1Byte		final_candidate[2] = {0xFF, 0xFF};	//for path A and path B
+	BOOLEAN		bResult = TRUE;
+//#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+//	BOOLEAN		is2T = IS_92C_SERIAL( pHalData->VersionID);
+//#else
+	BOOLEAN		is2T = TRUE;
+//#endif
+
+	s4Byte tmp1 = 0,tmp2 = 0;
+
+	if(is2T)
+		bound = 8;
+	else
+		bound = 4;
+
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("===> IQK:phy_SimularityCompare_8192E c1 %d c2 %d!!!\n", c1, c2));
+
+
+	SimularityBitMap = 0;
+
+	for (i = 0; i < bound; i++) {
+
+		if ((i == 1) || (i == 3) || (i == 5) || (i == 7)) {
+			if((result[c1][i]& 0x00000200) != 0)
+				tmp1 = result[c1][i] | 0xFFFFFC00;
+			else
+				tmp1 = result[c1][i];
+
+			if((result[c2][i]& 0x00000200) != 0)
+				tmp2 = result[c2][i] | 0xFFFFFC00;
+			else
+				tmp2 = result[c2][i];
+		} else {
+			tmp1 = result[c1][i];
+			tmp2 = result[c2][i];
+		}
+
+		diff = (tmp1 > tmp2) ? (tmp1 - tmp2) : (tmp2 - tmp1);
+
+		if (diff > MAX_TOLERANCE) {
+//			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("IQK:differnece overflow %d index %d compare1 0x%x compare2 0x%x!!!\n",  diff, i, result[c1][i], result[c2][i]));
+
+			if ((i == 2 || i == 6) && !SimularityBitMap) {
+				if(result[c1][i]+result[c1][i+1] == 0)
+					final_candidate[(i/4)] = c2;
+				else if (result[c2][i]+result[c2][i+1] == 0)
+					final_candidate[(i/4)] = c1;
+				else
+					SimularityBitMap = SimularityBitMap|(1<<i);
+			} else
+				SimularityBitMap = SimularityBitMap|(1<<i);
+		}
+	}
+
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("IQK:phy_SimularityCompare_8192E SimularityBitMap   %x !!!\n", SimularityBitMap));
+
+	if (SimularityBitMap == 0) {
+		for (i = 0; i < (bound/4); i++) {
+			if (final_candidate[i] != 0xFF) {
+				for (j = i*4; j < (i+1)*4-2; j++)
+					result[3][j] = result[final_candidate[i]][j];
+				bResult = FALSE;
+			}
+		}
+		return bResult;
+	} else {
+
+		if (!(SimularityBitMap & 0x03)) {		/*path A TX OK*/
+			for (i = 0; i < 2; i++)
+				result[3][i] = result[c1][i];
+		}
+
+		if (!(SimularityBitMap & 0x0c)) {		/*path A RX OK*/
+			for (i = 2; i < 4; i++)
+				result[3][i] = result[c1][i];
+		}
+
+		if (!(SimularityBitMap & 0x30)) {	/*path B TX OK*/
+			for (i = 4; i < 6; i++)
+				result[3][i] = result[c1][i];
+
+		}
+
+		if (!(SimularityBitMap & 0xc0)) {	/*path B RX OK*/
+			for (i = 6; i < 8; i++)
+				result[3][i] = result[c1][i];
+		}
+		return FALSE;
+	}
+}
+
+
+
+VOID
+phy_IQCalibrate_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	s4Byte 		result[][8],
+	IN	u1Byte		t
+)
+{
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#endif
+#endif
+	u4Byte			i;
+	u1Byte			PathAOK, PathBOK;
+	u1Byte 			tmp0xc50 = (u1Byte)ODM_GetBBReg(pDM_Odm, 0xC50, bMaskByte0);
+	u1Byte			tmp0xc58 = (u1Byte)ODM_GetBBReg(pDM_Odm, 0xC58, bMaskByte0);
+	u4Byte			ADDA_REG[IQK_ADDA_REG_NUM] = {
+		rFPGA0_XCD_SwitchControl,		rBlue_Tooth,
+		rRx_Wait_CCA,		rTx_CCK_RFON,
+		rTx_CCK_BBON,		rTx_OFDM_RFON,
+		rTx_OFDM_BBON,		rTx_To_Rx,
+		rTx_To_Tx,		rRx_CCK,
+		rRx_OFDM,		rRx_Wait_RIFS,
+		rRx_TO_Rx,		rStandby,
+		rSleep,		rPMPD_ANAEN
+	};
+	u4Byte			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
+		REG_TXPAUSE,		REG_BCN_CTRL,
+		REG_BCN_CTRL_1,	REG_GPIO_MUXCFG
+	};
+
+	/*since 92C & 92D have the different define in IQK_BB_REG*/
+	u4Byte	IQK_BB_REG_92C[IQK_BB_REG_NUM] = {
+		rOFDM0_TRxPathEnable,		rOFDM0_TRMuxPar,
+		rFPGA0_XCD_RFInterfaceSW,	rConfig_AntA,	rConfig_AntB,
+		rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
+		rFPGA0_XB_RFInterfaceOE,		rCCK0_AFESetting
+	};
+
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	u4Byte	retryCount = 2;
+#else
+#if MP_DRIVER
+	const u4Byte	retryCount = 1;
+#else
+	const u4Byte	retryCount = 2;
+#endif
+#endif
+
+	/* Note: IQ calibration must be performed after loading*/
+	/*PHY_REG.txt , and radio_a, radio_b.txt*/
+
+	//u4Byte bbvalue;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+#ifdef MP_TEST
+	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific)
+		retryCount = 9;
+#endif
+#endif
+
+
+	if (t == 0) {
+//	 	 bbvalue = ODM_GetBBReg(pDM_Odm, rFPGA0_RFMOD, bMaskDWord);
+//			RT_DISP(FINIT, INIT_IQK, ("phy_IQCalibrate_8188E()==>0x%08x\n",bbvalue));
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQ Calibration for %d times\n", t));
+
+		/* Save ADDA parameters, turn Path A ADDA on*/
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		_PHY_SaveADDARegisters8703B(pAdapter, ADDA_REG, pDM_Odm->RFCalibrateInfo.ADDA_backup, IQK_ADDA_REG_NUM);
+		_PHY_SaveMACRegisters8703B(pAdapter, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
+		_PHY_SaveADDARegisters8703B(pAdapter, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup, IQK_BB_REG_NUM);
+#else
+		_PHY_SaveADDARegisters8703B(pDM_Odm, ADDA_REG, pDM_Odm->RFCalibrateInfo.ADDA_backup, IQK_ADDA_REG_NUM);
+		_PHY_SaveMACRegisters8703B(pDM_Odm, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
+		_PHY_SaveADDARegisters8703B(pDM_Odm, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup, IQK_BB_REG_NUM);
+#endif
+	}
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQ Calibration for %d times\n", t));
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+
+	_PHY_PathADDAOn8703B(pAdapter, ADDA_REG, TRUE);
+#else
+	_PHY_PathADDAOn8703B(pDM_Odm, ADDA_REG, TRUE);
+#endif
+
+
+	//MAC settings
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	_PHY_MACSettingCalibration8703B(pAdapter, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
+#else
+	_PHY_MACSettingCalibration8703B(pDM_Odm, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
+#endif
+
+	//BB setting
+	/*ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0x00);*/
+	ODM_SetBBReg(pDM_Odm, rCCK0_AFESetting, 0x0f000000, 0xf);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x25204000);
+
+//path A TX IQK
+#if 1
+
+	for (i = 0 ; i < retryCount ; i++) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		PathAOK = phy_PathA_IQK_8703B(pAdapter);
+#else
+		PathAOK = phy_PathA_IQK_8703B(pDM_Odm);
+#endif
+
+		if (PathAOK == 0x01) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]Tx IQK Success!!\n"));
+			result[t][0] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			break;
+		}
+
+	}
+#endif
+
+//path A RXIQK
+#if 1
+
+	for (i = 0 ; i < retryCount ; i++) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		PathAOK = phy_PathA_RxIQK8703B(pAdapter);
+#else
+		PathAOK = phy_PathA_RxIQK8703B(pDM_Odm);
+#endif
+		if (PathAOK == 0x03) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]Rx IQK Success!!\n"));
+//			result[t][0] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+//			result[t][1] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][2] = (ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][3] = (ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			break;
+		} else {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]Rx IQK Fail!!\n"));
+		}
+	}
+
+	if (0x00 == PathAOK)
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQK failed!!\n"));
+
+#endif
+
+
+//path B TX IQK
+#if 0
+
+#if MP_DRIVER != 1
+	if ((*pDM_Odm->pIs1Antenna == FALSE) || ((*pDM_Odm->pIs1Antenna == TRUE) && (*pDM_Odm->pRFDefaultPath == 1))
+	   || (pDM_Odm->SupportInterface == ODM_ITRF_USB))
+#endif
+	{
+
+		for (i = 0 ; i < retryCount ; i++) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+			PathBOK = phy_PathB_IQK_8703B(pAdapter);
+#else
+			PathBOK = phy_PathB_IQK_8703B(pDM_Odm);
+#endif
+//		if(PathBOK == 0x03){
+			if (PathBOK == 0x01) {
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]S0 Tx IQK Success!!\n"));
+				result[t][4] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				break;
+			}
+
+		}
+#endif
+
+//path B RX IQK
+#if 0
+
+		for (i = 0 ; i < retryCount ; i++) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+			PathBOK = phy_PathB_RxIQK8703B(pAdapter);
+#else
+			PathBOK = phy_PathB_RxIQK8703B(pDM_Odm);
+#endif
+			if (PathBOK == 0x03) {
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]S0 Rx IQK Success!!\n"));
+//				result[t][0] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+//				result[t][1] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				break;
+				
+			} else
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]S0 Rx IQK Fail!!\n"));
+
+		}
+
+
+
+		if (0x00 == PathBOK)
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]S0 IQK failed!!\n"));
+
+	}
+#endif
+
+	//Back to BB mode, load original value
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQK:Back to BB mode, load original value!\n"));
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+
+	if (t != 0) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+
+		/* Reload ADDA power saving parameters*/
+		_PHY_ReloadADDARegisters8703B(pAdapter, ADDA_REG, pDM_Odm->RFCalibrateInfo.ADDA_backup, IQK_ADDA_REG_NUM);
+
+		/* Reload MAC parameters*/
+		_PHY_ReloadMACRegisters8703B(pAdapter, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
+
+		_PHY_ReloadADDARegisters8703B(pAdapter, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup, IQK_BB_REG_NUM);
+#else
+		/* Reload ADDA power saving parameters*/
+		_PHY_ReloadADDARegisters8703B(pDM_Odm, ADDA_REG, pDM_Odm->RFCalibrateInfo.ADDA_backup, IQK_ADDA_REG_NUM);
+
+		/* Reload MAC parameters*/
+		_PHY_ReloadMACRegisters8703B(pDM_Odm, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
+
+		_PHY_ReloadADDARegisters8703B(pDM_Odm, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup, IQK_BB_REG_NUM);
+#endif
+
+		//Allen initial gain 0xc50
+		// Restore RX initial gain
+		ODM_SetBBReg(pDM_Odm, 0xc50, bMaskByte0, 0x50);
+		ODM_SetBBReg(pDM_Odm, 0xc50, bMaskByte0, tmp0xc50);
+
+		//load 0xe30 IQC default value
+		ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+		ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]phy_IQCalibrate_8703B() <==\n"));
+
+}
+
+
+VOID
+phy_LCCalibrate_8703B(
+	IN PDM_ODM_T		pDM_Odm,
+	IN	BOOLEAN		is2T
+)
+{
+	u1Byte	tmpReg;
+	u4Byte	RF_Amode=0, RF_Bmode=0, LC_Cal;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	PADAPTER pAdapter = pDM_Odm->Adapter;
+#endif
+
+	//Check continuous TX and Packet TX
+	tmpReg = ODM_Read1Byte(pDM_Odm, 0xd03);
+
+	if ((tmpReg&0x70) != 0)			/*Deal with contisuous TX case*/
+		ODM_Write1Byte(pDM_Odm, 0xd03, tmpReg&0x8F);	//disable all continuous TX
+	else							// Deal with Packet TX case
+		ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF);			// block all queues
+
+	if ((tmpReg&0x70) != 0) {
+		//1. Read original RF mode
+		//Path-A
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		RF_Amode = PHY_QueryRFReg(pAdapter, ODM_RF_PATH_A, RF_AC, bMask12Bits);
+
+		//Path-B
+		if(is2T)
+			RF_Bmode = PHY_QueryRFReg(pAdapter, ODM_RF_PATH_B, RF_AC, bMask12Bits);
+#else
+		RF_Amode = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bMask12Bits);
+
+		//Path-B
+		if(is2T)
+			RF_Bmode = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_AC, bMask12Bits);
+#endif
+
+		//2. Set RF mode = standby mode
+		//Path-A
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bMask12Bits, (RF_Amode&0x8FFFF)|0x10000);
+
+		//Path-B
+		if(is2T)
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_AC, bMask12Bits, (RF_Bmode&0x8FFFF)|0x10000);
+	}
+
+	//3. Read RF reg18
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	LC_Cal = PHY_QueryRFReg(pAdapter, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits);
+#else
+	LC_Cal = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits);
+#endif
+
+	//4. Set LC calibration begin	bit15
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xB0, bRFRegOffsetMask, 0xDFBE0); // LDO ON
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal|0x08000);
+
+	ODM_delay_ms(LCK_DELAY_TIME_8703B);
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xB0, bRFRegOffsetMask, 0xDFFE0); // LDO OFF
+
+    /*disable below for 8703B by jerrychou 20150720
+	// Channel 10 LC calibration issue for 8703Bs with 26M xtal
+	if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO && pDM_Odm->PackageType >= 0x2)
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal);
+       */
+
+	//Restore original situation
+	if ((tmpReg&0x70) != 0) {	/*Deal with contisuous TX case*/
+		//Path-A
+		ODM_Write1Byte(pDM_Odm, 0xd03, tmpReg);
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bMask12Bits, RF_Amode);
+
+		//Path-B
+		if(is2T)
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_AC, bMask12Bits, RF_Bmode);
+	} else { /* Deal with Packet TX case*/
+		ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x00);
+	}
+}
+
+/* IQK version:V0.4*/
+/* 1. add coex. related setting*/
+
+VOID
+PHY_IQCalibrate_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	BOOLEAN 	bReCovery
+)
+{
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else  /* (DM_ODM_SUPPORT_TYPE == ODM_CE)*/
+	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
+#endif
+
+#if (MP_DRIVER == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);
+#else/* (DM_ODM_SUPPORT_TYPE == ODM_CE)*/
+	PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);
+#endif
+#endif/*(MP_DRIVER == 1)*/
+
+	u1Byte			u1bTmp;
+	u2Byte			count=0;
+#endif
+
+	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
+
+	s4Byte			result[4][8];	//last is final result
+	u1Byte			i, final_candidate, Indexforchannel;
+	BOOLEAN			bPathAOK, bPathBOK;
+	s4Byte			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
+	BOOLEAN			is12simular, is13simular, is23simular;
+	BOOLEAN 		bStartContTx = FALSE, bSingleTone = FALSE, bCarrierSuppression = FALSE;
+	u4Byte			IQK_BB_REG_92C[IQK_BB_REG_NUM] = {
+		rOFDM0_XARxIQImbalance,		rOFDM0_XBRxIQImbalance,
+		rOFDM0_ECCAThreshold,		rOFDM0_AGCRSSITable,
+		rOFDM0_XATxIQImbalance,		rOFDM0_XBTxIQImbalance,
+		rOFDM0_XCTxAFE,			rOFDM0_XDTxAFE,
+		rOFDM0_RxIQExtAnta
+	};
+	BOOLEAN			bReloadIQK = FALSE;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE) )
+	if (ODM_CheckPowerStatus(pAdapter) == FALSE)
+		return;
+#else
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+
+#ifdef MP_TEST
+	if (priv->pshare->rf_ft_var.mp_specific) {
+		if((OPMODE & WIFI_MP_CTX_PACKET) || (OPMODE & WIFI_MP_CTX_ST))
+			return;
+	}
+#endif
+
+	if(priv->pshare->IQK_88E_done)
+		bReCovery= 1;
+	priv->pshare->IQK_88E_done = 1;
+#endif
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if (!(pDM_Odm->SupportAbility & ODM_RF_CALIBRATION)) 
+		return;
+
+#endif
+
+
+	if (pDM_Odm->mp_mode == TRUE) {
+#if MP_DRIVER == 1
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		/* <VincentL, 131231> Add to determine IQK ON/OFF in certain case, Suggested by Cheng.*/
+		if (!pHalData->IQK_MP_Switch)
+			return;
+#endif
+
+		bStartContTx = pMptCtx->bStartContTx;
+		bSingleTone = pMptCtx->bSingleTone;
+		bCarrierSuppression = pMptCtx->bCarrierSuppression;
+
+		/* 20120213<Kordan> Turn on when continuous Tx to pass lab testing. (required by Edlu)*/
+		if (bSingleTone || bCarrierSuppression)
+			return;
+#endif
+	}
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+
+	if (pDM_Odm->RFCalibrateInfo.bIQKInProgress)
+		return;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_AP))
+	if(bReCovery)
+#else//for ODM_WIN
+	if(bReCovery && (!pAdapter->bInHctTest))  //YJ,add for PowerTest,120405
+#endif
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("[IQK]PHY_IQCalibrate_8703B: Return due to bReCovery!\n"));
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		_PHY_ReloadADDARegisters8703B(pAdapter, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup_recover, 9);
+#else
+		_PHY_ReloadADDARegisters8703B(pDM_Odm, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup_recover, 9);
+#endif
+		return;
+	}
+
+
+	if (pDM_Odm->mp_mode == FALSE) {
+#if MP_DRIVER != 1
+//check if IQK had been done before!!
+
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK] 0xc80 = 0x%x\n", pRFCalibrateInfo->TxIQC_8703B[IDX_0xC80][VAL]));
+		if (ODM_SetIQCbyRFpath_8703B(pDM_Odm)) {
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQK value is reloaded!!!\n"));
+			bReloadIQK = TRUE;
+		}
+
+		if(bReloadIQK)
+			return;
+#endif
+	}
+	/*Check & wait if BT is doing IQK*/
+
+	if (pDM_Odm->mp_mode == FALSE) {
+#if MP_DRIVER != 1
+		// Set H2C cmd to inform FW (enable).
+		SetFwWiFiCalibrationCmd(pAdapter, 1);
+		// Check 0x1e6
+		count=0;
+		u1bTmp = PlatformEFIORead1Byte(pAdapter, 0x1e6);
+		while (u1bTmp != 0x1 && count < 1000) {
+			PlatformStallExecution(10);
+			u1bTmp = PlatformEFIORead1Byte(pAdapter, 0x1e6);
+			count++;
+		}
+
+		if (count >= 1000) 
+			RT_TRACE(COMP_INIT, DBG_LOUD, ("[IQK]Polling 0x1e6 to 1 for WiFi calibration H2C cmd FAIL! count(%d)", count));
+
+
+		// Wait BT IQK finished.
+		// polling 0x1e7[0]=1 or 300ms timeout
+		u1bTmp = PlatformEFIORead1Byte(pAdapter, 0x1e7);
+		while ((!(u1bTmp&BIT0)) && count < 6000) {
+			PlatformStallExecution(50);
+			u1bTmp = PlatformEFIORead1Byte(pAdapter, 0x1e7);
+			count++;
+		}
+#endif
+	}
+
+	//IQK start!!!!!!!!!!
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQK:Start!!!\n"));
+	ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
+	pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
+	ODM_ReleaseSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
+
+
+	for (i = 0; i < 8; i++) {
+		result[0][i] = 0;
+		result[1][i] = 0;
+		result[2][i] = 0;
+		result[3][i] = 0;
+	}
+	final_candidate = 0xff;
+	bPathAOK = FALSE;
+	bPathBOK = FALSE;
+	is12simular = FALSE;
+	is23simular = FALSE;
+	is13simular = FALSE;
+
+
+	for (i = 0; i < 3; i++) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+		phy_IQCalibrate_8703B(pAdapter, result, i);
+#else
+		phy_IQCalibrate_8703B(pDM_Odm, result, i);
+#endif
+
+
+		if (i == 1) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+			is12simular = phy_SimularityCompare_8703B(pAdapter, result, 0, 1);
+#else
+			is12simular = phy_SimularityCompare_8703B(pDM_Odm, result, 0, 1);
+#endif
+			if (is12simular) {
+				final_candidate = 0;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQK: is12simular final_candidate is %x\n", final_candidate));
+				break;
+			}
+		}
+
+		if (i == 2) {
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+			is13simular = phy_SimularityCompare_8703B(pAdapter, result, 0, 2);
+#else
+			is13simular = phy_SimularityCompare_8703B(pDM_Odm, result, 0, 2);
+#endif
+			if (is13simular) {
+				final_candidate = 0;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQK: is13simular final_candidate is %x\n",final_candidate));
+
+				break;
+			}
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+			is23simular = phy_SimularityCompare_8703B(pAdapter, result, 1, 2);
+#else
+			is23simular = phy_SimularityCompare_8703B(pDM_Odm, result, 1, 2);
+#endif
+			if (is23simular) {
+				final_candidate = 1;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQK: is23simular final_candidate is %x\n", final_candidate));
+			} else {
+				for(i = 0; i < 8; i++)
+					RegTmp += result[3][i];
+
+				if(RegTmp != 0)
+					final_candidate = 3;
+				else
+					final_candidate = 0xFF;
+			}
+		}
+	}
+/*	RT_TRACE(COMP_INIT,DBG_LOUD,("Release Mutex in IQCalibrate\n"));*/
+
+	for (i = 0; i < 4; i++) {
+		RegE94 = result[i][0];
+		RegE9C = result[i][1];
+		RegEA4 = result[i][2];
+		RegEAC = result[i][3];
+		RegEB4 = result[i][4];
+		RegEBC = result[i][5];
+		RegEC4 = result[i][6];
+		RegECC = result[i][7];
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("[IQK]IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
+	}
+
+	if (final_candidate != 0xff) {
+		pDM_Odm->RFCalibrateInfo.RegE94 = RegE94 = result[final_candidate][0];
+		pDM_Odm->RFCalibrateInfo.RegE9C = RegE9C = result[final_candidate][1];
+		RegEA4 = result[final_candidate][2];
+		RegEAC = result[final_candidate][3];
+		pDM_Odm->RFCalibrateInfo.RegEB4 = RegEB4 = result[final_candidate][4];
+		pDM_Odm->RFCalibrateInfo.RegEBC = RegEBC = result[final_candidate][5];
+		RegEC4 = result[final_candidate][6];
+		RegECC = result[final_candidate][7];
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQK: final_candidate is %x\n",final_candidate));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
+		bPathAOK = bPathBOK = TRUE;
+	} else {
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQK: FAIL use default value\n"));
+		pDM_Odm->RFCalibrateInfo.RegE94 = pDM_Odm->RFCalibrateInfo.RegEB4 = 0x100;	//X default value
+		pDM_Odm->RFCalibrateInfo.RegE9C = pDM_Odm->RFCalibrateInfo.RegEBC = 0x0;		//Y default value
+	}
+
+	// fill IQK matrix
+	if (RegE94 != 0)
+		_PHY_PathAFillIQKMatrix8703B(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+//	if (RegEB4 != 0)
+//		_PHY_PathBFillIQKMatrix8703B(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	Indexforchannel = ODM_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
+#else
+	Indexforchannel = 0;
+#endif
+
+//To Fix BSOD when final_candidate is 0xff
+//by sherry 20120321
+	if (final_candidate < 4) {
+		for(i = 0; i < IQK_Matrix_REG_NUM; i++)
+			pDM_Odm->RFCalibrateInfo.IQKMatrixRegSetting[Indexforchannel].Value[0][i] = result[final_candidate][i];
+		pDM_Odm->RFCalibrateInfo.IQKMatrixRegSetting[Indexforchannel].bIQKDone = TRUE;
+	}
+	//RT_DISP(FINIT, INIT_IQK, ("\nIQK OK Indexforchannel %d.\n", Indexforchannel));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]\nIQK OK Indexforchannel %d.\n", Indexforchannel));
+
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	_PHY_SaveADDARegisters8703B(pAdapter, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup_recover, 9);
+#else
+	_PHY_SaveADDARegisters8703B(pDM_Odm, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup_recover, IQK_BB_REG_NUM);
+#endif
+
+//fill IQK register
+	ODM_SetIQCbyRFpath_8703B(pDM_Odm);
+
+	if (pDM_Odm->mp_mode == FALSE) {
+#if MP_DRIVER != 1
+		// Set H2C cmd to inform FW (disable).
+		SetFwWiFiCalibrationCmd(pAdapter, 0);
+
+		// Check 0x1e6
+		count = 0;
+		u1bTmp = PlatformEFIORead1Byte(pAdapter, 0x1e6);
+		while (u1bTmp != 0 && count < 1000) {
+			PlatformStallExecution(10);
+			u1bTmp = PlatformEFIORead1Byte(pAdapter, 0x1e6);
+			count++;
+		}
+
+		if (count >= 1000) 
+			RT_TRACE(COMP_INIT, DBG_LOUD, ("[IQK]Polling 0x1e6 to 0 for WiFi calibration H2C cmd FAIL! count(%d)", count));
+
+#endif
+	}
+
+	ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
+	pDM_Odm->RFCalibrateInfo.bIQKInProgress = FALSE;
+	ODM_ReleaseSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("[IQK]IQK finished\n"));
+}
+
+
+VOID
+PHY_LCCalibrate_8703B(
+	PVOID		pDM_VOID
+)
+{
+	BOOLEAN 		bStartContTx = FALSE, bSingleTone = FALSE, bCarrierSuppression = FALSE;
+	u4Byte			timeout = 2000, timecount = 0;
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+	PADAPTER	pAdapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+#if (MP_DRIVER == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);
+#else/* (DM_ODM_SUPPORT_TYPE == ODM_CE)*/
+	PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);
+#endif
+#endif/*(MP_DRIVER == 1)*/
+#endif
+
+
+
+
+#if MP_DRIVER == 1
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	// <VincentL, 140319> Add to Disable Default LCK when Cont Tx, For Lab Test Usage.
+	if (!pHalData->IQK_MP_Switch)
+		return;
+#endif
+
+	bStartContTx = pMptCtx->bStartContTx;
+	bSingleTone = pMptCtx->bSingleTone;
+	bCarrierSuppression = pMptCtx->bCarrierSuppression;
+#endif
+
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if (!(pDM_Odm->SupportAbility & ODM_RF_CALIBRATION)) 
+		return;
+
+#endif
+	// 20120213<Kordan> Turn on when continuous Tx to pass lab testing. (required by Edlu)
+	if(bSingleTone || bCarrierSuppression)
+		return;
+
+	while (*(pDM_Odm->pbScanInProcess) && timecount < timeout) {
+		ODM_delay_ms(50);
+		timecount += 50;
+	}
+
+	pDM_Odm->RFCalibrateInfo.bLCKInProgress = TRUE;
+
+
+	phy_LCCalibrate_8703B(pDM_Odm, FALSE);
+
+
+	pDM_Odm->RFCalibrateInfo.bLCKInProgress = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LCK:Finish!!!interface %d\n", pDM_Odm->InterfaceIndex));
+
+}
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.h
new file mode 100644
index 000000000..402a307de
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/halphyrf_8703b.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL_PHY_RF_8703B_H__
+#define __HAL_PHY_RF_8703B_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define	index_mapping_NUM_8703B		15
+#define AVG_THERMAL_NUM_8703B		4
+#define RF_T_METER_8703B		0x42
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#include "../halphyrf_win.h"
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+#include "../halphyrf_ce.h"
+#endif
+
+void ConfigureTxpowerTrack_8703B(
+	PTXPWRTRACK_CFG	pConfig
+	);
+
+void DoIQK_8703B(
+	PVOID		pDM_VOID,
+	u1Byte 		DeltaThermalIndex,
+	u1Byte		ThermalValue,	
+	u1Byte 		Threshold
+	);
+
+VOID
+ODM_TxPwrTrackSetPwr_8703B(
+	IN	PVOID		pDM_VOID,
+	PWRTRACK_METHOD 	Method,
+	u1Byte 				RFPath,
+	u1Byte 				ChannelMappedIndex
+	);
+
+//1 7.	IQK
+
+void	
+PHY_IQCalibrate_8703B(	
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN PADAPTER	Adapter,
+#endif
+	IN	BOOLEAN 	bReCovery);
+
+BOOLEAN
+ODM_SetIQCbyRFpath_8703B(
+	IN PDM_ODM_T		pDM_Odm
+	);
+
+//
+// LC calibrate
+//
+void	
+PHY_LCCalibrate_8703B(
+	PVOID		pDM_VOID
+);
+
+//
+// AP calibrate
+//
+void	
+PHY_APCalibrate_8703B(		
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+							IN 	s1Byte		delta);
+void	
+PHY_DigitalPredistortion_8703B(		IN	PADAPTER	pAdapter);
+
+
+VOID
+_PHY_SaveADDARegisters_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		ADDAReg,
+	IN	pu4Byte		ADDABackup,
+	IN	u4Byte		RegisterNum
+	);
+
+VOID
+_PHY_PathADDAOn_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		ADDAReg,
+	IN	BOOLEAN		isPathAOn,
+	IN	BOOLEAN		is2T
+	);
+
+VOID
+_PHY_MACSettingCalibration_8703B(
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	IN PDM_ODM_T		pDM_Odm,
+#else
+	IN	PADAPTER	pAdapter,
+#endif
+	IN	pu4Byte		MACReg,
+	IN	pu4Byte		MACBackup	
+	);
+							
+#endif	// #ifndef __HAL_PHY_RF_8188E_H__								
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.c
new file mode 100644
index 000000000..c13bd5abf
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.c
@@ -0,0 +1,219 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8703B_SUPPORT == 1)  
+
+void
+odm_ConfigRFReg_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data,
+	IN  ODM_RF_RADIO_PATH_E     RF_PATH,
+	IN	u4Byte				    RegAddr
+	)
+{
+    if(Addr == 0xfe || Addr == 0xffe)
+	{ 					  
+		#ifdef CONFIG_LONG_DELAY_ISSUE
+		ODM_sleep_ms(50);
+		#else		
+		ODM_delay_ms(50);
+		#endif
+	}
+	else
+	{
+		ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
+		// Add 1us delay between BB/RF register setting.
+		ODM_delay_us(1);
+	}	
+}
+
+
+void 
+odm_ConfigRF_RadioA_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	)
+{
+	u4Byte  content = 0x1000; // RF_Content: radioa_txt
+	u4Byte	maskforPhySet= (u4Byte)(content&0xE000);
+
+    odm_ConfigRFReg_8703B(pDM_Odm, Addr, Data, ODM_RF_PATH_A, Addr|maskforPhySet);
+
+    ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [RadioA] %08X %08X\n", Addr, Data));
+}
+
+void 
+odm_ConfigRF_RadioB_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	)
+{
+	u4Byte  content = 0x1001; // RF_Content: radiob_txt
+	u4Byte	maskforPhySet= (u4Byte)(content&0xE000);
+
+    odm_ConfigRFReg_8703B(pDM_Odm, Addr, Data, ODM_RF_PATH_B, Addr|maskforPhySet);
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [RadioB] %08X %08X\n", Addr, Data));
+    
+}
+
+void 
+odm_ConfigRF_RadioC_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	)
+{
+	u4Byte  content = 0x1001; // RF_Content: radiob_txt
+	u4Byte	maskforPhySet= (u4Byte)(content&0xE000);
+
+    odm_ConfigRFReg_8703B(pDM_Odm, Addr, Data, ODM_RF_PATH_C, Addr|maskforPhySet);
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [RadioC] %08X %08X\n", Addr, Data));
+    
+}
+
+void 
+odm_ConfigRF_RadioD_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	)
+{
+	u4Byte  content = 0x1001; // RF_Content: radiob_txt
+	u4Byte	maskforPhySet= (u4Byte)(content&0xE000);
+
+    odm_ConfigRFReg_8703B(pDM_Odm, Addr, Data, ODM_RF_PATH_D, Addr|maskforPhySet);
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [RadioD] %08X %08X\n", Addr, Data));
+    
+}
+
+void 
+odm_ConfigMAC_8703B(
+ 	IN 	PDM_ODM_T 	pDM_Odm,
+ 	IN 	u4Byte 		Addr,
+ 	IN 	u1Byte 		Data
+ 	)
+{
+	ODM_Write1Byte(pDM_Odm, Addr, Data);
+    ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigMACWithHeaderFile: [MAC_REG] %08X %08X\n", Addr, Data));
+}
+
+void 
+odm_ConfigBB_AGC_8703B(
+    IN 	PDM_ODM_T 	pDM_Odm,
+    IN 	u4Byte 		Addr,
+    IN 	u4Byte 		Bitmask,
+    IN 	u4Byte 		Data
+    )
+{
+	ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);		
+	// Add 1us delay between BB/RF register setting.
+	ODM_delay_us(1);
+
+    ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigBBWithHeaderFile: [AGC_TAB] %08X %08X\n", Addr, Data));
+}
+
+void
+odm_ConfigBB_PHY_REG_PG_8703B(
+	IN 	PDM_ODM_T 	pDM_Odm,
+	IN	u4Byte		Band,
+	IN	u4Byte		RfPath,
+	IN	u4Byte		TxNum,
+    IN 	u4Byte 		Addr,
+    IN 	u4Byte 		Bitmask,
+    IN 	u4Byte 		Data
+    )
+{    
+	if (Addr == 0xfe || Addr == 0xffe)
+		#ifdef CONFIG_LONG_DELAY_ISSUE
+		ODM_sleep_ms(50);
+		#else		
+		ODM_delay_ms(50);
+		#endif
+    else 
+    {
+#if	!(DM_ODM_SUPPORT_TYPE&ODM_AP)
+	    PHY_StoreTxPowerByRate(pDM_Odm->Adapter, Band, RfPath, TxNum, Addr, Bitmask, Data);
+#endif
+    }
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ConfigBBWithHeaderFile: [PHY_REG] %08X %08X %08X\n", Addr, Bitmask, Data));
+}
+
+void 
+odm_ConfigBB_PHY_8703B(
+	IN 	PDM_ODM_T 	pDM_Odm,
+    IN 	u4Byte 		Addr,
+    IN 	u4Byte 		Bitmask,
+    IN 	u4Byte 		Data
+    )
+{    
+	if (Addr == 0xfe)
+		#ifdef CONFIG_LONG_DELAY_ISSUE
+		ODM_sleep_ms(50);
+		#else		
+		ODM_delay_ms(50);
+		#endif
+	else if (Addr == 0xfd)
+		ODM_delay_ms(5);
+	else if (Addr == 0xfc)
+		ODM_delay_ms(1);
+	else if (Addr == 0xfb)
+		ODM_delay_us(50);
+	else if (Addr == 0xfa)
+		ODM_delay_us(5);
+	else if (Addr == 0xf9)
+		ODM_delay_us(1);
+	else 
+	{
+		ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);		
+	}
+	
+	// Add 1us delay between BB/RF register setting.
+	ODM_delay_us(1);
+    ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigBBWithHeaderFile: [PHY_REG] %08X %08X\n", Addr, Data));
+}
+
+void
+odm_ConfigBB_TXPWR_LMT_8703B(
+	IN 	PDM_ODM_T 	pDM_Odm,
+	IN	pu1Byte		Regulation,
+	IN	pu1Byte		Band,
+	IN	pu1Byte		Bandwidth,
+	IN	pu1Byte		RateSection,
+	IN	pu1Byte		RfPath,
+	IN	pu1Byte 	Channel,
+	IN	pu1Byte		PowerLimit
+    )
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PHY_SetTxPowerLimit(pDM_Odm, Regulation, Band,
+		Bandwidth, RateSection, RfPath, Channel, PowerLimit);
+#endif
+}
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.h
new file mode 100644
index 000000000..7fde2e779
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/phydm_regconfig8703b.h
@@ -0,0 +1,109 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_ODM_REGCONFIG_H_8703B
+#define __INC_ODM_REGCONFIG_H_8703B
+ 
+#if (RTL8703B_SUPPORT == 1)
+
+void
+odm_ConfigRFReg_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data,
+	IN  ODM_RF_RADIO_PATH_E     RF_PATH,
+	IN	u4Byte				    RegAddr
+	);
+
+void 
+odm_ConfigRF_RadioA_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	);
+
+void 
+odm_ConfigRF_RadioB_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	);
+
+void 
+odm_ConfigRF_RadioC_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	);
+
+void 
+odm_ConfigRF_RadioD_8703B(
+	IN 	PDM_ODM_T 				pDM_Odm,
+	IN 	u4Byte 					Addr,
+	IN 	u4Byte 					Data
+	);
+
+void 
+odm_ConfigMAC_8703B(
+ 	IN 	PDM_ODM_T 	pDM_Odm,
+ 	IN 	u4Byte 		Addr,
+ 	IN 	u1Byte 		Data
+ 	);
+
+void 
+odm_ConfigBB_AGC_8703B(
+    IN 	PDM_ODM_T 	pDM_Odm,
+    IN 	u4Byte 		Addr,
+    IN 	u4Byte 		Bitmask,
+    IN 	u4Byte 		Data
+    );
+
+void
+odm_ConfigBB_PHY_REG_PG_8703B(
+	IN 	PDM_ODM_T 	pDM_Odm,
+	IN	u4Byte		Band,
+	IN	u4Byte		RfPath,
+	IN	u4Byte		TxNum,
+    IN 	u4Byte 		Addr,
+    IN 	u4Byte 		Bitmask,
+    IN 	u4Byte 		Data
+    );
+
+void 
+odm_ConfigBB_PHY_8703B(
+	IN 	PDM_ODM_T 	pDM_Odm,
+    IN 	u4Byte 		Addr,
+    IN 	u4Byte 		Bitmask,
+    IN 	u4Byte 		Data
+    );
+
+void
+odm_ConfigBB_TXPWR_LMT_8703B(
+	IN 	PDM_ODM_T 	pDM_Odm,
+	IN	pu1Byte		Regulation,
+	IN	pu1Byte		Band,
+	IN	pu1Byte		Bandwidth,
+	IN	pu1Byte		RateSection,
+	IN	pu1Byte		RfPath,
+	IN	pu1Byte 	Channel,
+	IN	pu1Byte		PowerLimit
+    );
+#endif
+#endif // end of SUPPORT
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/version_rtl8703b.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/version_rtl8703b.h
new file mode 100644
index 000000000..6331b5527
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/rtl8703b/version_rtl8703b.h
@@ -0,0 +1,10 @@
+/*RTL8703B PHY Parameters*/
+/* 
+[Caution] 
+  Since 01/Aug/2015, the commit rules will be simplified. 
+  You do not need to fill up the version.h anymore, 
+  only the maintenance supervisor fills it before formal release.
+*/
+#define	RELEASE_DATE_8703B		20150915
+#define	COMMIT_BY_8703B			"BB_Luke"
+#define	RELEASE_VERSION_8703B	17
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.c
new file mode 100644
index 000000000..146b6e018
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.c
@@ -0,0 +1,547 @@
+//============================================================
+// Description:
+//
+// This file is for TXBF mechanism
+//
+//============================================================
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+/*Beamforming halcomtxbf API create by YuChen 2015/05*/
+
+VOID
+halComTxbf_beamformInit(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		HalTxbf8822B_Init(pDM_Odm);
+}
+
+/*Only used for MU BFer Entry when get GID management frame (self is as MU STA)*/
+VOID
+halComTxbf_ConfigGtab(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		HalTxbf8822B_ConfigGtab(pDM_Odm);
+}
+
+VOID
+phydm_beamformSetSoundingEnter(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_EnterWorkItem)) == FALSE)
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_EnterWorkItem));
+#else
+	halComTxbf_EnterWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetSoundingLeave(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_LeaveWorkItem)) == FALSE)
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_LeaveWorkItem));
+#else
+	halComTxbf_LeaveWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetSoundingRate(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_RateWorkItem)) == FALSE)
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_RateWorkItem));
+#else
+	halComTxbf_RateWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetSoundingStatus(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_StatusWorkItem)) == FALSE)
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_StatusWorkItem));
+#else
+	halComTxbf_StatusWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetSoundingFwNdpa(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (*pDM_Odm->pbFwDwRsvdPageInProgress)
+		ODM_SetTimer(pDM_Odm, &(pTxbfInfo->Txbf_FwNdpaTimer), 5);
+	else
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_FwNdpaWorkItem));
+#else
+	halComTxbf_FwNdpaWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetSoundingClk(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_ClkWorkItem)) == FALSE)
+			PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_ClkWorkItem));
+#else
+	halComTxbf_ClkWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetResetTxPath(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_ResetTxPathWorkItem)) == FALSE)
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_ResetTxPathWorkItem));
+#else
+	halComTxbf_ResetTxPathWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID
+phydm_beamformSetGetTxRate(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	if (PlatformIsWorkItemScheduled(&(pTxbfInfo->Txbf_GetTxRateWorkItem)) == FALSE)
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_GetTxRateWorkItem));
+#else
+	halComTxbf_GetTxRateWorkItemCallback(pDM_Odm);
+#endif
+}
+
+VOID 
+halComTxbf_EnterWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+	u1Byte			Idx = pTxbfInfo->TXBFIdx;
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+	
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+		HalTxbfJaguar_Enter(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+		HalTxbf8192E_Enter(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_Enter(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8821B)
+		HalTxbf8821B_Enter(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		HalTxbf8822B_Enter(pDM_Odm, Idx);
+}
+
+VOID 
+halComTxbf_LeaveWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	u1Byte			Idx = pTxbfInfo->TXBFIdx;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+		HalTxbfJaguar_Leave(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+		HalTxbf8192E_Leave(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_Leave(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8821B)
+		HalTxbf8821B_Leave(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		HalTxbf8822B_Leave(pDM_Odm, Idx);
+}
+
+
+VOID 
+halComTxbf_FwNdpaWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+	u1Byte	Idx = pTxbfInfo->NdpaIdx;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+		HalTxbfJaguar_FwTxBF(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+		HalTxbf8192E_FwTxBF(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_FwTxBF(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8821B)
+		HalTxbf8821B_FwTxBF(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		HalTxbf8822B_FwTxBF(pDM_Odm, Idx);
+}
+
+VOID
+halComTxbf_ClkWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pDM_Odm->SupportICType & ODM_RTL8812)
+		HalTxbfJaguar_Clk_8812A(pDM_Odm);
+}
+
+
+
+VOID
+halComTxbf_RateWorkItemCallback(	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+	u1Byte			BW = pTxbfInfo->BW;
+	u1Byte			Rate = pTxbfInfo->Rate;	
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pDM_Odm->SupportICType & ODM_RTL8812)
+		HalTxbf8812A_setNDPArate(pDM_Odm, BW, Rate);
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+		HalTxbf8192E_setNDPArate(pDM_Odm, BW, Rate);
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_setNDPArate(pDM_Odm, BW, Rate);
+	
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID 
+halComTxbf_FwNdpaTimerCallback(
+	IN	PRT_TIMER		pTimer
+	)
+{
+
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (*pDM_Odm->pbFwDwRsvdPageInProgress)
+		ODM_SetTimer(pDM_Odm, &(pTxbfInfo->Txbf_FwNdpaTimer), 5);
+	else
+		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_FwNdpaWorkItem));
+}
+#endif
+
+
+VOID
+halComTxbf_StatusWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	u1Byte			Idx = pTxbfInfo->TXBFIdx;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+		HalTxbfJaguar_Status(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+		HalTxbf8192E_Status(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_Status(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8821B)
+		HalTxbf8821B_Status(pDM_Odm, Idx);
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+		HalTxbf8822B_Status(pDM_Odm, Idx);
+}
+
+VOID
+halComTxbf_ResetTxPathWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	u1Byte			Idx = pTxbfInfo->TXBFIdx;
+
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_ResetTxPath(pDM_Odm, Idx);
+	
+}
+
+VOID
+halComTxbf_GetTxRateWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#endif
+	
+	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+		HalTxbf8814A_GetTxRate(pDM_Odm);
+}
+
+
+BOOLEAN
+HalComTxbf_Set(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte			setType,
+	IN	PVOID			pInBuf
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PBOOLEAN		pBoolean=(PBOOLEAN)pInBuf;
+	pu1Byte			pU1Tmp=(pu1Byte)pInBuf;
+	pu4Byte			pU4Tmp=(pu4Byte)pInBuf;
+	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] setType = 0x%X\n", __func__, setType));
+	
+	switch(setType){
+	case TXBF_SET_SOUNDING_ENTER:
+	pTxbfInfo->TXBFIdx = *pU1Tmp;
+	phydm_beamformSetSoundingEnter(pDM_Odm);
+	break;
+
+	case TXBF_SET_SOUNDING_LEAVE:
+	pTxbfInfo->TXBFIdx = *pU1Tmp;
+	phydm_beamformSetSoundingLeave(pDM_Odm);
+	break;
+
+	case TXBF_SET_SOUNDING_RATE:
+	pTxbfInfo->BW = pU1Tmp[0];
+	pTxbfInfo->Rate = pU1Tmp[1];
+	phydm_beamformSetSoundingRate(pDM_Odm);
+	break;
+
+	case TXBF_SET_SOUNDING_STATUS:
+	pTxbfInfo->TXBFIdx = *pU1Tmp;
+	phydm_beamformSetSoundingStatus(pDM_Odm);
+	break;
+
+	case TXBF_SET_SOUNDING_FW_NDPA:
+	pTxbfInfo->NdpaIdx = *pU1Tmp;
+	phydm_beamformSetSoundingFwNdpa(pDM_Odm);
+	break;
+
+	case TXBF_SET_SOUNDING_CLK:
+	phydm_beamformSetSoundingClk(pDM_Odm);
+	break;
+		
+	case TXBF_SET_TX_PATH_RESET:
+	pTxbfInfo->TXBFIdx = *pU1Tmp;
+	phydm_beamformSetResetTxPath(pDM_Odm);
+	break;
+
+	case TXBF_SET_GET_TX_RATE:
+	phydm_beamformSetGetTxRate(pDM_Odm);
+	break;
+	
+	}
+
+	return TRUE;
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+BOOLEAN
+HalComTxbf_Get(
+	IN 	PADAPTER		Adapter,
+	IN	u1Byte			getType,
+	OUT	PVOID			pOutBuf
+	)
+{
+	PHAL_DATA_TYPE		pHalData=GET_HAL_DATA(Adapter);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	PBOOLEAN			pBoolean=(PBOOLEAN)pOutBuf;
+	ps4Byte				pS4Tmp=(ps4Byte)pOutBuf;
+	pu4Byte				pU4Tmp=(pu4Byte)pOutBuf;
+	pu1Byte				pU1Tmp=(pu1Byte)pOutBuf;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (getType == TXBF_GET_EXPLICIT_BEAMFORMEE) {
+		if (IS_HARDWARE_TYPE_OLDER_THAN_8812A(Adapter))
+			*pBoolean = FALSE;
+		else if (/*IS_HARDWARE_TYPE_8822B(Adapter)	||*/
+				IS_HARDWARE_TYPE_8821B(Adapter) 	||
+				IS_HARDWARE_TYPE_8192E(Adapter) 	||
+				IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_JAGUAR_AND_JAGUAR2(Adapter))
+			*pBoolean = TRUE;
+		else
+			*pBoolean = FALSE;
+	} else if (getType == TXBF_GET_EXPLICIT_BEAMFORMER) {
+		if (IS_HARDWARE_TYPE_OLDER_THAN_8812A(Adapter))
+			*pBoolean = FALSE;		
+		else	if (/*IS_HARDWARE_TYPE_8822B(Adapter)	||*/
+				IS_HARDWARE_TYPE_8821B(Adapter) 	||
+				IS_HARDWARE_TYPE_8192E(Adapter) 	||
+				IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_JAGUAR_AND_JAGUAR2(Adapter)) {
+			if(pHalData->RF_Type == RF_2T2R || pHalData->RF_Type == RF_3T3R)
+				*pBoolean = TRUE;
+			else
+				*pBoolean = FALSE;
+		} else
+			*pBoolean = FALSE;
+	} else if (getType == TXBF_GET_MU_MIMO_STA) {
+#if (RTL8822B_SUPPORT == 1)
+		if (/*pDM_Odm->SupportICType & (ODM_RTL8822B)*/
+			IS_HARDWARE_TYPE_8822B(Adapter))
+			*pBoolean = TRUE;
+		else
+#endif
+			*pBoolean = FALSE;
+
+
+	} else if (getType == TXBF_GET_MU_MIMO_AP) {
+#if (RTL8822B_SUPPORT == 1)	
+		if (/*pDM_Odm->SupportICType & (ODM_RTL8822B)*/
+			IS_HARDWARE_TYPE_8822B(Adapter))
+			*pBoolean = TRUE;
+		else
+#endif
+			*pBoolean = FALSE;
+	}
+	
+	return TRUE;
+}	
+#endif
+
+
+#endif 
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.h
new file mode 100644
index 000000000..7be4efd17
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/halcomtxbf.h
@@ -0,0 +1,181 @@
+#ifndef __HAL_COM_TXBF_H__
+#define __HAL_COM_TXBF_H__
+
+/*
+typedef	BOOLEAN
+(*TXBF_GET)(
+	IN	PVOID			pAdapter,
+	IN	u1Byte			getType,
+	OUT	PVOID			pOutBuf
+	);
+
+typedef	BOOLEAN
+(*TXBF_SET)(
+	IN	PVOID			pAdapter,
+	IN	u1Byte			setType,
+	OUT	PVOID			pInBuf
+	);
+*/
+#define TxBF_Nr(a, b) ((a > b) ? (b) : (a))
+
+typedef enum _TXBF_SET_TYPE{
+	TXBF_SET_SOUNDING_ENTER,
+	TXBF_SET_SOUNDING_LEAVE,
+	TXBF_SET_SOUNDING_RATE,
+	TXBF_SET_SOUNDING_STATUS,
+	TXBF_SET_SOUNDING_FW_NDPA,
+	TXBF_SET_SOUNDING_CLK,
+	TXBF_SET_TX_PATH_RESET,
+	TXBF_SET_GET_TX_RATE
+}TXBF_SET_TYPE,*PTXBF_SET_TYPE;
+
+
+typedef enum _TXBF_GET_TYPE{
+	TXBF_GET_EXPLICIT_BEAMFORMEE,
+	TXBF_GET_EXPLICIT_BEAMFORMER,
+	TXBF_GET_MU_MIMO_STA,
+	TXBF_GET_MU_MIMO_AP
+}TXBF_GET_TYPE,*PTXBF_GET_TYPE;
+
+
+
+//2 HAL TXBF related
+typedef struct _HAL_TXBF_INFO {
+	u1Byte				TXBFIdx;
+	u1Byte				NdpaIdx;
+	u1Byte				BW;
+	u1Byte				Rate;
+
+	RT_TIMER			Txbf_FwNdpaTimer;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	RT_WORK_ITEM		Txbf_EnterWorkItem;  
+	RT_WORK_ITEM		Txbf_LeaveWorkItem;
+	RT_WORK_ITEM		Txbf_FwNdpaWorkItem;
+	RT_WORK_ITEM		Txbf_ClkWorkItem;
+	RT_WORK_ITEM		Txbf_StatusWorkItem;
+	RT_WORK_ITEM		Txbf_RateWorkItem;
+	RT_WORK_ITEM		Txbf_ResetTxPathWorkItem;
+	RT_WORK_ITEM		Txbf_GetTxRateWorkItem;
+#endif
+
+} HAL_TXBF_INFO, *PHAL_TXBF_INFO;
+
+#if (BEAMFORMING_SUPPORT == 1)
+
+VOID
+halComTxbf_beamformInit(
+	IN PVOID			pDM_VOID
+	);
+
+VOID
+halComTxbf_ConfigGtab(
+	IN PVOID			pDM_VOID
+	);
+
+VOID 
+halComTxbf_EnterWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID 
+halComTxbf_LeaveWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID 
+halComTxbf_FwNdpaWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID
+halComTxbf_ClkWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID
+halComTxbf_ResetTxPathWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID
+halComTxbf_GetTxRateWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID
+halComTxbf_RateWorkItemCallback(	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+VOID 
+halComTxbf_FwNdpaTimerCallback(
+	IN	PRT_TIMER		pTimer
+	);
+
+VOID
+halComTxbf_StatusWorkItemCallback(
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	PADAPTER		Adapter
+#else
+	IN PVOID			pDM_VOID
+#endif
+	);
+
+BOOLEAN
+HalComTxbf_Set(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte			setType,
+	IN	PVOID			pInBuf
+	);
+
+BOOLEAN
+HalComTxbf_Get(
+	IN	PADAPTER		Adapter,
+	IN	u1Byte			getType,
+	OUT	PVOID			pOutBuf
+	);
+
+#else
+#define halComTxbf_beamformInit(pDM_VOID)					NULL
+#define halComTxbf_ConfigGtab(pDM_VOID)				NULL
+#define halComTxbf_EnterWorkItemCallback(_Adapter)		NULL
+#define halComTxbf_LeaveWorkItemCallback(_Adapter)		NULL
+#define halComTxbf_FwNdpaWorkItemCallback(_Adapter)		NULL
+#define halComTxbf_ClkWorkItemCallback(_Adapter)			NULL
+#define halComTxbf_RateWorkItemCallback(_Adapter)		NULL
+#define halComTxbf_FwNdpaTimerCallback(_Adapter)		NULL
+#define halComTxbf_StatusWorkItemCallback(_Adapter)		NULL
+#define HalComTxbf_Get(_Adapter, _getType, _pOutBuf)
+
+#endif
+							
+#endif	// #ifndef __HAL_COM_TXBF_H__								
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.c
new file mode 100644
index 000000000..41a8bacf0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.c
@@ -0,0 +1,392 @@
+//============================================================
+// Description:
+//
+// This file is for 8192E TXBF mechanism
+//
+//============================================================
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8192E_SUPPORT == 1)
+
+VOID
+HalTxbf8192E_setNDPArate(
+	IN PVOID			pDM_VOID,
+	IN u1Byte	BW,
+	IN u1Byte	Rate
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8192E,  (Rate << 2 | BW));	
+
+}
+
+VOID
+halTxbf8192E_RfMode(
+	IN PVOID			pDM_VOID,
+	IN PRT_BEAMFORMING_INFO	pBeamInfo
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	BOOLEAN				bSelfBeamformer = FALSE;
+	BOOLEAN				bSelfBeamformee = FALSE;
+	BEAMFORMING_CAP	BeamformCap = BEAMFORMING_CAP_NONE;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pDM_Odm->RFType == ODM_1T1R)
+		return;
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1); /*RF Mode table write enable*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_WE_LUT, 0x80000, 0x1); /*RF Mode table write enable*/
+	
+	if (pBeamInfo->beamformee_su_cnt > 0) {
+		/*Path_A*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableAddr, 0xfffff, 0x18000);	/*Select RX mode  0x30=0x18000*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData0, 0xfffff, 0x0000f);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0x77fc2);	/*Enable TXIQGEN in RX mode*/
+		/*Path_B*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableAddr, 0xfffff, 0x18000);	/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData0, 0xfffff, 0x0000f);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData1, 0xfffff, 0x77fc2);	/*Enable TXIQGEN in RX mode*/
+	} else {
+		/*Path_A*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableAddr, 0xfffff, 0x18000);	/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData0, 0xfffff, 0x0000f);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0x77f82);	/*Disable TXIQGEN in RX mode*/
+		/*Path_B*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableAddr, 0xfffff, 0x18000);	/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData0, 0xfffff, 0x0000f);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData1, 0xfffff, 0x77f82);	/*Disable TXIQGEN in RX mode*/
+	}
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);	/*RF Mode table write disable*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_WE_LUT, 0x80000, 0x0);	/*RF Mode table write disable*/
+
+	if (pBeamInfo->beamformee_su_cnt > 0) {
+		ODM_SetBBReg(pDM_Odm, rFPGA1_TxInfo, bMaskDWord, 0x83321333);
+		ODM_SetBBReg(pDM_Odm, rCCK0_AFESetting, bMaskByte3, 0xc1);
+	} else
+		ODM_SetBBReg(pDM_Odm, rFPGA1_TxInfo, bMaskDWord, 0x81121313);
+}
+
+
+
+VOID
+halTxbf8192E_FwTxBFCmd(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	Idx, Period0 = 0, Period1 = 0;
+	u1Byte	PageNum0 = 0xFF, PageNum1 = 0xFF;
+	u1Byte	u1TxBFParm[3] = {0};
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		if (pBeamInfo->BeamformeeEntry[Idx].BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			if (Idx == 0) {
+				if (pBeamInfo->BeamformeeEntry[Idx].bSound)
+					PageNum0 = 0xFE;
+				else
+					PageNum0 = 0xFF; //stop sounding
+				Period0 = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			} else if (Idx == 1) {
+				if (pBeamInfo->BeamformeeEntry[Idx].bSound)
+					PageNum1 = 0xFE;
+				else
+					PageNum1 = 0xFF; //stop sounding
+				Period1 = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			}
+		}
+	}
+
+	u1TxBFParm[0] = PageNum0;
+	u1TxBFParm[1] = PageNum1;
+	u1TxBFParm[2] = (Period1 << 4) | Period0;
+	ODM_FillH2CCmd(pDM_Odm, PHYDM_H2C_TXBF, 3, u1TxBFParm);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, 
+		("[%s] PageNum0 = %d Period0 = %d, PageNum1 = %d Period1 %d\n", __func__, PageNum0, Period0, PageNum1, Period1));
+}
+
+
+VOID
+halTxbf8192E_DownloadNDPA(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			u1bTmp = 0, tmpReg422 = 0, Head_Page;
+	u1Byte			BcnValidReg = 0, count = 0, DLBcnCount = 0;
+	BOOLEAN			bSendBeacon = FALSE;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	u1Byte			TxPageBndy = LAST_ENTRY_OF_TX_PKT_BUFFER_8812;	
+	/*default reseved 1 page for the IC type which is undefined.*/
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	*pDM_Odm->pbFwDwRsvdPageInProgress = TRUE;
+#endif
+	if (Idx == 0)
+		Head_Page = 0xFE;
+	else
+		Head_Page = 0xFE;
+
+	Adapter->HalFunc.GetHalDefVarHandler(Adapter, HAL_DEF_TX_PAGE_BOUNDARY, (pu1Byte)&TxPageBndy);
+
+	/*Set REG_CR bit 8. DMA beacon by SW.*/
+	u1bTmp = ODM_Read1Byte(pDM_Odm, REG_CR_8192E+1);
+	ODM_Write1Byte(pDM_Odm,  REG_CR_8192E+1, (u1bTmp | BIT0));
+
+	/*Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.*/
+	tmpReg422 = ODM_Read1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8192E+2);
+	ODM_Write1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8192E+2,  tmpReg422 & (~BIT6));
+
+	if (tmpReg422 & BIT6) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_WARNING, ("%s There is an Adapter is sending beacon.\n", __func__));
+		bSendBeacon = TRUE;
+	}
+
+	/*TDECTRL[15:8] 0x209[7:0] = 0xFE/0xFD	NDPA Head for TXDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_DWBCN0_CTRL_8192E+1, Head_Page);
+
+	do {
+		/*Clear beacon valid check bit.*/
+		BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_DWBCN0_CTRL_8192E+2);
+		ODM_Write1Byte(pDM_Odm, REG_DWBCN0_CTRL_8192E+2, (BcnValidReg | BIT0));
+
+		// download NDPA rsvd page.
+		Beamforming_SendHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->SoundBW, BEACON_QUEUE);
+
+#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)
+		u1bTmp = ODM_Read1Byte(pDM_Odm, REG_MGQ_TXBD_NUM_8192E+3);
+		count = 0;
+		while ((count < 20) && (u1bTmp & BIT4)) {
+			count++;
+			ODM_delay_us(10);
+			u1bTmp = ODM_Read1Byte(pDM_Odm, REG_MGQ_TXBD_NUM_8192E+3);
+		}
+		ODM_Write1Byte(pDM_Odm, REG_MGQ_TXBD_NUM_8192E+3, u1bTmp | BIT4);
+#endif
+
+		/*check rsvd page download OK.*/
+		BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_DWBCN0_CTRL_8192E+2);
+		count = 0;
+		while (!(BcnValidReg & BIT0) && count < 20) {
+			count++;
+			ODM_delay_us(10);
+			BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_DWBCN0_CTRL_8192E+2);
+		}
+		DLBcnCount++;
+	} while (!(BcnValidReg & BIT0) && DLBcnCount < 5);
+
+	if (!(BcnValidReg & BIT0))
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_WARNING, ("%s Download RSVD page failed!\n", __func__));
+
+	/*TDECTRL[15:8] 0x209[7:0] = 0xF9	Beacon Head for TXDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_DWBCN0_CTRL_8192E+1, TxPageBndy);
+
+	/*To make sure that if there exists an adapter which would like to send beacon.*/
+	/*If exists, the origianl value of 0x422[6] will be 1, we should check this to*/
+	/*prevent from setting 0x422[6] to 0 after download reserved page, or it will cause*/
+	/*the beacon cannot be sent by HW.*/
+	/*2010.06.23. Added by tynli.*/
+	if (bSendBeacon)
+		ODM_Write1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8192E+2, tmpReg422);
+
+	/*Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli.*/
+	/*Clear CR[8] or beacon packet will not be send to TxBuf anymore.*/
+	u1bTmp = ODM_Read1Byte(pDM_Odm, REG_CR_8192E+1);
+	ODM_Write1Byte(pDM_Odm, REG_CR_8192E+1, (u1bTmp & (~BIT0)));
+
+	pBeamEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSED;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	*pDM_Odm->pbFwDwRsvdPageInProgress = FALSE;
+#endif
+}
+
+
+VOID
+HalTxbf8192E_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				BFerBFeeIdx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					i = 0;
+	u1Byte					BFerIdx = (BFerBFeeIdx & 0xF0) >> 4;
+	u1Byte					BFeeIdx = (BFerBFeeIdx & 0xF);
+	u4Byte					CSI_Param;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	u2Byte					STAid = 0;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	halTxbf8192E_RfMode(pDM_Odm, pBeamformingInfo);
+
+	if (pDM_Odm->RFType == ODM_2T2R)
+		ODM_Write4Byte(pDM_Odm, 0xd80, 0x00000000);		/*Nc =2*/
+
+	if ((pBeamformingInfo->beamformer_su_cnt > 0) && (BFerIdx < BEAMFORMER_ENTRY_NUM)) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[BFerIdx];
+
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8192E, 0xCB);
+
+		/*MAC address/Partial AID of Beamformer*/
+		if (BFerIdx == 0) {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER0_INFO_8192E+i), BeamformerEntry.MacAddr[i]);
+		} else {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER1_INFO_8192E+i), BeamformerEntry.MacAddr[i]);
+		}
+
+		/*CSI report parameters of Beamformer Default use Nc = 2*/
+		CSI_Param = 0x03090309;
+
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8192E, CSI_Param);
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8192E, CSI_Param);
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8192E, CSI_Param);
+
+		/*Timeout value for MAC to leave NDP_RX_standby_state (60 us, Test chip) (80 us,  MP chip)*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8192E+3, 0x50);
+
+	}
+
+	if ((pBeamformingInfo->beamformee_su_cnt > 0) && (BFeeIdx < BEAMFORMEE_ENTRY_NUM)) {
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[BFeeIdx];
+
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+			STAid = BeamformeeEntry.MacId;
+		else
+			STAid = BeamformeeEntry.P_AID;
+
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s], STAid=0x%X\n", __func__, STAid));
+
+		/*P_AID of Beamformee & enable NDPA transmission & enable NDPA interrupt*/
+		if (BFeeIdx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8192E, STAid);
+			ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8192E+3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8192E+3) | BIT4 | BIT6 | BIT7);
+		} else
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8192E+2, STAid | BIT12 | BIT14 | BIT15);
+
+		/*CSI report parameters of Beamformee*/
+		if (BFeeIdx == 0) {
+			/*Get BIT24 & BIT25*/
+			u1Byte tmp = ODM_Read1Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E+3) & 0x3;
+			
+			ODM_Write1Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E+3, tmp | 0x60);
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E, STAid | BIT9);
+		} else {
+			/*Set BIT25*/
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E+2, STAid | 0xE200);
+		}
+			phydm_Beamforming_Notify(pDM_Odm);
+
+	}
+}
+
+
+VOID
+HalTxbf8192E_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	halTxbf8192E_RfMode(pDM_Odm, pBeamInfo);
+
+	/*	Clear P_AID of Beamformee
+	* 	Clear MAC addresss of Beamformer
+	*	Clear Associated Bfmee Sel
+	*/
+	if (pBeamInfo->BeamformCap == BEAMFORMING_CAP_NONE)
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8192E, 0xC8);
+
+	if (Idx == 0) {
+		ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8192E, 0);
+		ODM_Write4Byte(pDM_Odm, REG_ASSOCIATED_BFMER0_INFO_8192E, 0);
+		ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMER0_INFO_8192E+4, 0);
+		ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E, 0);
+	} else {
+		ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8192E+2, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8192E+2) & 0xF000);
+		ODM_Write4Byte(pDM_Odm, REG_ASSOCIATED_BFMER1_INFO_8192E, 0);
+		ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMER1_INFO_8192E+4, 0);
+		ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E+2, ODM_Read2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8192E+2) & 0x60);
+	}
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Idx %d\n", __func__, Idx));
+}
+
+
+VOID
+HalTxbf8192E_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte					BeamCtrlVal;
+	u4Byte					BeamCtrlReg;
+	PRT_BEAMFORMING_INFO	pBeamInfo =  &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformEntry = pBeamInfo->BeamformeeEntry[Idx];
+
+	if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+		BeamCtrlVal = BeamformEntry.MacId;
+	else
+		BeamCtrlVal = BeamformEntry.P_AID;
+
+	if (Idx == 0)
+		BeamCtrlReg = REG_TXBF_CTRL_8192E;
+	else {
+		BeamCtrlReg = REG_TXBF_CTRL_8192E+2;
+		BeamCtrlVal |= BIT12 | BIT14 | BIT15;
+	}
+
+	if (BeamformEntry.BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+		if (BeamformEntry.SoundBW == CHANNEL_WIDTH_20)
+			BeamCtrlVal |= BIT9;
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_40)
+			BeamCtrlVal |= BIT10;
+	} else
+		BeamCtrlVal &= ~(BIT9 | BIT10 | BIT11);
+
+	ODM_Write2Byte(pDM_Odm, BeamCtrlReg, BeamCtrlVal);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Idx %d BeamCtrlReg %x BeamCtrlVal %x\n", __func__, Idx, BeamCtrlReg, BeamCtrlVal));
+}
+
+
+VOID
+HalTxbf8192E_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pBeamEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING)
+		halTxbf8192E_DownloadNDPA(pDM_Odm, Idx);
+
+	halTxbf8192E_FwTxBFCmd(pDM_Odm);
+}
+
+#endif	/* #if (RTL8192E_SUPPORT == 1)*/
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.h
new file mode 100644
index 000000000..be70cc656
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8192e.h
@@ -0,0 +1,52 @@
+#ifndef __HAL_TXBF_8192E_H__
+#define __HAL_TXBF_8192E_H__
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8192E_SUPPORT == 1)
+VOID
+HalTxbf8192E_setNDPArate(
+	IN PVOID			pDM_VOID,
+	IN u1Byte	BW,
+	IN u1Byte	Rate
+);
+
+VOID
+HalTxbf8192E_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8192E_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8192E_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8192E_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+	);
+#else
+
+#define HalTxbf8192E_setNDPArate(pDM_VOID, BW, Rate)
+#define HalTxbf8192E_Enter(pDM_VOID, Idx)
+#define HalTxbf8192E_Leave(pDM_VOID, Idx)
+#define HalTxbf8192E_Status(pDM_VOID, Idx)
+#define HalTxbf8192E_FwTxBF(pDM_VOID, Idx)
+
+#endif
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.c
new file mode 100644
index 000000000..c9c2f25aa
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.c
@@ -0,0 +1,653 @@
+//============================================================
+// Description:
+//
+// This file is for 8814A TXBF mechanism
+//
+//============================================================
+
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8814A_SUPPORT == 1)
+
+VOID
+HalTxbf8814A_setNDPArate(
+	IN PVOID			pDM_VOID,
+	IN u1Byte	BW,
+	IN u1Byte	Rate
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8814A, BW);
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_RATE_8814A, (u1Byte) Rate);
+
+}
+
+#define PHYDM_MEMORY_MAP_BUF_READ	0x8000
+#define PHYDM_CTRL_INFO_PAGE			0x660
+
+VOID
+phydm_DataRate_8814A(
+	IN	PDM_ODM_T			pDM_Odm,
+	IN	u1Byte				macId,	
+	OUT	pu4Byte				data,
+	IN	u1Byte				dataLen
+	)
+{
+	u1Byte	i = 0;
+	u2Byte	XReadDataAddr = 0;
+
+	ODM_Write2Byte(pDM_Odm, REG_PKTBUF_DBG_CTRL_8814A, PHYDM_CTRL_INFO_PAGE);
+	XReadDataAddr = PHYDM_MEMORY_MAP_BUF_READ + macId*32; /*Ctrl Info: 32Bytes for each macid(n)*/
+	
+	if ((XReadDataAddr < PHYDM_MEMORY_MAP_BUF_READ) || (XReadDataAddr > 0x8FFF)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("XReadDataAddr(0x%x) is not correct!\n", XReadDataAddr));
+		return;	
+	}
+	
+	/* Read data */
+	for (i = 0; i < dataLen; i++)
+		*(data+i) = ODM_Read2Byte(pDM_Odm, XReadDataAddr+i);	
+	
+}
+
+VOID
+HalTxbf8814A_GetTxRate(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pEntry;
+	u4Byte	TxRptData = 0;
+	u1Byte	DataRate = 0xFF;
+
+	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
+	
+	phydm_DataRate_8814A(pDM_Odm, (u1Byte)pEntry->MacId, &TxRptData, 1);
+	DataRate = (u1Byte)TxRptData;
+	DataRate &= bMask7bits;   /*Bit7 indicates SGI*/
+
+	pDM_Odm->TxBfDataRate = DataRate;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] pDM_Odm->TxBfDataRate = 0x%x\n", __func__, pDM_Odm->TxBfDataRate));
+}
+
+VOID
+HalTxbf8814A_ResetTxPath(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	u1Byte	Nr_index = 0;
+
+	if (idx < BEAMFORMEE_ENTRY_NUM)
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[idx];
+	else
+		return;
+
+	if ((pDM_Odm->LastUSBHub) != (*pDM_Odm->HubUsbMode)) {
+		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), BeamformeeEntry.CompSteeringNumofBFer);
+
+		if (idx == 0) {
+			switch (Nr_index) {
+			case 0:
+			break;
+
+			case 1:			/*Nsts = 2	BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, bMaskByte3LowNibble | bMaskL3Bytes, 0x9366);		/*tx2path, BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskL3Bytes, 0x936);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x9360);
+			break;
+
+			case 2:			/*Nsts = 3	BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, bMaskByte3LowNibble | bMaskL3Bytes, 0x93e93ee);	/*tx3path, BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93e);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93e93e0);
+			break;
+
+			default:			/*Nr>3, same as Case 3*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, bMaskByte3LowNibble | bMaskL3Bytes, 0x93f93ff);	/*tx4path, ABCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93f);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskDWord, 0x93f93f0);
+			break;
+			}
+		} else	{
+			switch (Nr_index) {
+			case 0:
+				break;
+
+			case 1:			/*Nsts = 2	BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, bMaskByte3LowNibble | bMaskL3Bytes, 0x9366);		/*tx2path, BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x936);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x9360);
+			break;
+
+			case 2:			/*Nsts = 3	BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, bMaskByte3LowNibble | bMaskL3Bytes, 0x93e93ee);	/*tx3path, BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93e);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93e93e0);
+			break;
+
+			default:			/*Nr>3, same as Case 3*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, bMaskByte3LowNibble | bMaskL3Bytes, 0x93f93ff);	/*tx4path, ABCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93f);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93f93f0);
+			break;
+			}
+		}
+
+		pDM_Odm->LastUSBHub = *pDM_Odm->HubUsbMode;
+	} else
+		return;
+#endif
+}
+
+
+u1Byte
+halTxbf8814A_GetNtx(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			Ntx = 0;
+
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+	if (pDM_Odm->SupportInterface == ODM_ITRF_USB) {
+		if (*pDM_Odm->HubUsbMode == 2) {/*USB3.0*/
+			if (pDM_Odm->RFType == ODM_4T4R)
+				Ntx = 3;
+			else if (pDM_Odm->RFType == ODM_3T3R)
+				Ntx = 2;
+			else
+				Ntx = 1;
+		} else if (*pDM_Odm->HubUsbMode == 1)	/*USB 2.0 always 2Tx*/
+			Ntx = 1;
+		else
+			Ntx = 1;
+	} else
+#endif
+	{
+		if (pDM_Odm->RFType == ODM_4T4R)
+			Ntx = 3;
+		else if (pDM_Odm->RFType == ODM_3T3R)
+			Ntx = 2;
+		else
+			Ntx = 1;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Ntx = %d\n", __func__, Ntx));
+	return Ntx;
+}
+
+u1Byte
+halTxbf8814A_GetNrx(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			Nrx = 0;
+
+	if (pDM_Odm->RFType == ODM_4T4R)
+		Nrx = 3;
+	else if (pDM_Odm->RFType == ODM_3T3R)
+		Nrx = 2;
+	else if (pDM_Odm->RFType == ODM_2T2R)
+		Nrx = 1;
+	else if (pDM_Odm->RFType == ODM_2T3R)
+		Nrx = 2;
+	else if (pDM_Odm->RFType == ODM_2T4R)
+		Nrx = 3;
+	else if (pDM_Odm->RFType == ODM_1T1R)
+		Nrx = 0;
+	else if (pDM_Odm->RFType == ODM_1T2R)
+		Nrx = 1;
+	else
+		Nrx = 0;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Nrx = %d\n", __func__, Nrx));
+	return Nrx;
+}
+
+VOID
+halTxbf8814A_RfMode(
+	IN PVOID			pDM_VOID,
+	IN	PRT_BEAMFORMING_INFO	pBeamformingInfo,
+	IN	u1Byte					idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte				i, Nr_index = 0;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+
+	if (idx < BEAMFORMEE_ENTRY_NUM)
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[idx];
+	else
+		return;
+
+	Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), BeamformeeEntry.CompSteeringNumofBFer);
+
+	if (pDM_Odm->RFType == ODM_1T1R)
+		return;
+
+	for (i = ODM_RF_PATH_A; i < MAX_RF_PATH; i++) {
+		ODM_SetRFReg(pDM_Odm, i, RF_WeLut_Jaguar, 0x80000, 0x1);
+		/*RF Mode table write enable*/
+	}
+
+	if (pBeamformingInfo->beamformee_su_cnt > 0) {
+		for (i = ODM_RF_PATH_A; i < MAX_RF_PATH; i++) {
+			ODM_SetRFReg(pDM_Odm, i, RF_ModeTableAddr, 0xfffff, 0x18000);
+			/*Select RX mode*/
+			ODM_SetRFReg(pDM_Odm, i, RF_ModeTableData0, 0xfffff, 0xBE77F);
+			/*Set Table data*/
+			ODM_SetRFReg(pDM_Odm, i, RF_ModeTableData1, 0xfffff, 0x226BF);
+			/*Enable TXIQGEN in RX mode*/
+		}
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0xE26BF);
+		/*Enable TXIQGEN in RX mode*/
+	}
+
+	for (i = ODM_RF_PATH_A; i < MAX_RF_PATH; i++) {
+		ODM_SetRFReg(pDM_Odm, i, RF_WeLut_Jaguar, 0x80000, 0x0);
+		/*RF Mode table write disable*/
+	}
+
+	if (pBeamformingInfo->beamformee_su_cnt > 0) {
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+		pDM_Odm->LastUSBHub = *pDM_Odm->HubUsbMode;
+#endif
+
+		/*for 8814 19ac(idx 1), 19b4(idx 0), different Tx ant setting*/
+		ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, BIT28 | BIT29, 0x2);			/*enable BB TxBF ant mapping register*/
+
+		if (idx == 0) {
+			switch (Nr_index) {
+			case 0:
+				break;
+
+			case 1:			/*Nsts = 2	BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, bMaskByte3LowNibble | bMaskL3Bytes, 0x9366);		/*tx2path, BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskL3Bytes, 0x936);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x9360);
+			break;
+
+			case 2:			/*Nsts = 3	BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, bMaskByte3LowNibble | bMaskL3Bytes, 0x93e93ee);	/*tx3path, BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93e);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93e93e0);
+			break;
+
+			default:			/*Nr>3, same as Case 3*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, bMaskByte3LowNibble | bMaskL3Bytes, 0x93f93ff);	/*tx4path, ABCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93f);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskDWord, 0x93f93f0);
+			break;
+			}
+		} else {
+			switch (Nr_index) {
+			case 0:
+			break;
+
+			case 1:			/*Nsts = 2	BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, bMaskByte3LowNibble | bMaskL3Bytes, 0x9366);		/*tx2path, BC*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x936);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x9360);
+			break;
+
+			case 2:			/*Nsts = 3	BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, bMaskByte3LowNibble | bMaskL3Bytes, 0x93e93ee);	/*tx3path, BCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93e);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93e93e0);
+			break;
+
+			default:			/*Nr>3, same as Case 3*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, bMaskByte3LowNibble | bMaskL3Bytes, 0x93f93ff);	/*tx4path, ABCD*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x93f);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93f93f0);
+			break;
+			}
+		}
+	}
+
+	if ((pBeamformingInfo->beamformee_su_cnt == 0) && (pBeamformingInfo->beamformer_su_cnt == 0)) {
+		ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, bMaskByte3 | bMaskByte2HighNibble, 0x932);	/*set TxPath selection for 8814a BFer bug refine*/
+		ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93e9360);
+	}
+}
+#if 0
+VOID
+halTxbf8814A_DownloadNDPA(
+	IN	PADAPTER			Adapter,
+	IN	u1Byte				Idx
+)
+{
+	u1Byte			u1bTmp = 0, tmpReg422 = 0;
+	u1Byte			BcnValidReg = 0, count = 0, DLBcnCount = 0;
+	u2Byte			Head_Page = 0x7FE;
+	BOOLEAN			bSendBeacon = FALSE;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u2Byte			TxPageBndy = LAST_ENTRY_OF_TX_PKT_BUFFER_8814A; /*default reseved 1 page for the IC type which is undefined.*/
+	PRT_BEAMFORMING_INFO	pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+
+	pHalData->bFwDwRsvdPageInProgress = TRUE;
+	Adapter->HalFunc.GetHalDefVarHandler(Adapter, HAL_DEF_TX_PAGE_BOUNDARY, (pu2Byte)&TxPageBndy);
+
+	/*Set REG_CR bit 8. DMA beacon by SW.*/
+	u1bTmp = PlatformEFIORead1Byte(Adapter, REG_CR_8814A + 1);
+	PlatformEFIOWrite1Byte(Adapter,  REG_CR_8814A + 1, (u1bTmp | BIT0));
+
+
+	/*Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.*/
+	tmpReg422 = PlatformEFIORead1Byte(Adapter, REG_FWHW_TXQ_CTRL_8814A + 2);
+	PlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL_8814A + 2,  tmpReg422 & (~BIT6));
+
+	if (tmpReg422 & BIT6) {
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("SetBeamformDownloadNDPA_8814A(): There is an Adapter is sending beacon.\n"));
+		bSendBeacon = TRUE;
+	}
+
+	/*0x204[11:0]	Beacon Head for TXDMA*/
+	PlatformEFIOWrite2Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A, Head_Page);
+
+	do {
+		/*Clear beacon valid check bit.*/
+		BcnValidReg = PlatformEFIORead1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A + 1);
+		PlatformEFIOWrite1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A + 1, (BcnValidReg | BIT7));
+
+		/*download NDPA rsvd page.*/
+		if (pBeamEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
+			Beamforming_SendVHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->AID, pBeamEntry->SoundBW, BEACON_QUEUE);
+		else
+			Beamforming_SendHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->SoundBW, BEACON_QUEUE);
+
+		/*check rsvd page download OK.*/
+		BcnValidReg = PlatformEFIORead1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A + 1);
+		count = 0;
+		while (!(BcnValidReg & BIT7) && count < 20) {
+			count++;
+			delay_us(10);
+			BcnValidReg = PlatformEFIORead1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A + 2);
+		}
+		DLBcnCount++;
+	} while (!(BcnValidReg & BIT7) && DLBcnCount < 5);
+
+	if (!(BcnValidReg & BIT0))
+		RT_DISP(FBEAM, FBEAM_ERROR, ("%s Download RSVD page failed!\n", __func__));
+
+	/*0x204[11:0]	Beacon Head for TXDMA*/
+	PlatformEFIOWrite2Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A, TxPageBndy);
+
+	/*To make sure that if there exists an adapter which would like to send beacon.*/
+	/*If exists, the origianl value of 0x422[6] will be 1, we should check this to*/
+	/*prevent from setting 0x422[6] to 0 after download reserved page, or it will cause */
+	/*the beacon cannot be sent by HW.*/
+	/*2010.06.23. Added by tynli.*/
+	if (bSendBeacon)
+		PlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL_8814A + 2, tmpReg422);
+
+	/*Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli.*/
+	/*Clear CR[8] or beacon packet will not be send to TxBuf anymore.*/
+	u1bTmp = PlatformEFIORead1Byte(Adapter, REG_CR_8814A + 1);
+	PlatformEFIOWrite1Byte(Adapter, REG_CR_8814A + 1, (u1bTmp & (~BIT0)));
+
+	pBeamEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSED;
+
+	pHalData->bFwDwRsvdPageInProgress = FALSE;
+}
+
+VOID
+halTxbf8814A_FwTxBFCmd(
+	IN	PADAPTER	Adapter
+)
+{
+	u1Byte	Idx, Period = 0;
+	u1Byte	PageNum0 = 0xFF, PageNum1 = 0xFF;
+	u1Byte	u1TxBFParm[3] = {0};
+
+	PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
+	PRT_BEAMFORMING_INFO	pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		if (pBeamInfo->BeamformeeEntry[Idx].bUsed && pBeamInfo->BeamformeeEntry[Idx].BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			if (pBeamInfo->BeamformeeEntry[Idx].bSound) {
+				PageNum0 = 0xFE;
+				PageNum1 = 0x07;
+				Period = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			} else if (PageNum0 == 0xFF) {
+				PageNum0 = 0xFF; /*stop sounding*/
+				PageNum1 = 0x0F;
+			}
+		}
+	}
+
+	u1TxBFParm[0] = PageNum0;
+	u1TxBFParm[1] = PageNum1;
+	u1TxBFParm[2] = Period;
+	FillH2CCmd(Adapter, PHYDM_H2C_TXBF, 3, u1TxBFParm);
+
+	RT_DISP(FBEAM, FBEAM_FUN, ("@%s End, PageNum0 = 0x%x, PageNum1 = 0x%x Period = %d", __func__, PageNum0, PageNum1, Period));
+}
+#endif
+VOID
+HalTxbf8814A_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				BFerBFeeIdx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					i = 0;
+	u1Byte					BFerIdx = (BFerBFeeIdx & 0xF0) >> 4;
+	u1Byte					BFeeIdx = (BFerBFeeIdx & 0xF);
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	u2Byte					STAid = 0, CSI_Param = 0;
+	u1Byte					Nc_index = 0, Nr_index = 0, grouping = 0, codebookinfo = 0, coefficientsize = 0;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] BFerIdx=%d, BFeeIdx=%d\n", __func__, BFerIdx, BFeeIdx));
+	ODM_SetMACReg(pDM_Odm, REG_SND_PTCL_CTRL_8814A, bMaskByte1 | bMaskByte2, 0x0202);
+
+	if ((pBeamformingInfo->beamformer_su_cnt > 0) && (BFerIdx < BEAMFORMER_ENTRY_NUM)) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[BFerIdx];
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8814A, 0xDB);
+
+		/*MAC address/Partial AID of Beamformer*/
+		if (BFerIdx == 0) {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER0_INFO_8814A + i), BeamformerEntry.MacAddr[i]);
+		} else {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER1_INFO_8814A + i), BeamformerEntry.MacAddr[i]);
+		}
+
+		/*CSI report parameters of Beamformer*/
+		Nc_index = halTxbf8814A_GetNrx(pDM_Odm);	/*for 8814A Nrx = 3(4 Ant), min=0(1 Ant)*/
+		Nr_index = BeamformerEntry.NumofSoundingDim;	/*0x718[7] = 1 use Nsts, 0x718[7] = 0 use reg setting. as Bfee, we use Nsts, so Nr_index don't care*/
+
+		grouping = 0;
+
+		/*for ac = 1, for n = 3*/
+		if (BeamformerEntry.BeamformEntryCap & BEAMFORMEE_CAP_VHT_SU)
+			codebookinfo = 1;
+		else if (BeamformerEntry.BeamformEntryCap & BEAMFORMEE_CAP_HT_EXPLICIT)
+			codebookinfo = 3;
+
+		coefficientsize = 3;
+
+		CSI_Param = (u2Byte)((coefficientsize << 10) | (codebookinfo << 8) | (grouping << 6) | (Nr_index << 3) | (Nc_index));
+
+		if (BFerIdx == 0)
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8814A, CSI_Param);
+		else
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8814A + 2, CSI_Param);
+		/*ndp_rx_standby_timer, 8814 need > 0x56, suggest from Dvaid*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8814A + 3, 0x40);
+
+	}
+
+	if ((pBeamformingInfo->beamformee_su_cnt > 0) && (BFeeIdx < BEAMFORMEE_ENTRY_NUM)) {
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[BFeeIdx];
+
+		halTxbf8814A_RfMode(pDM_Odm, pBeamformingInfo, BFeeIdx);
+
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+			STAid = BeamformeeEntry.MacId;
+		else
+			STAid = BeamformeeEntry.P_AID;
+
+		/*P_AID of Beamformee & enable NDPA transmission & enable NDPA interrupt*/
+		if (BFeeIdx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8814A, STAid);
+			ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8814A + 3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8814A + 3) | BIT4 | BIT6 | BIT7);
+		} else
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8814A + 2, STAid | BIT14 | BIT15 | BIT12);
+
+		/*CSI report parameters of Beamformee*/
+		if (BFeeIdx == 0) {
+			/*Get BIT24 & BIT25*/
+			u1Byte	tmp = ODM_Read1Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A + 3) & 0x3;
+
+			ODM_Write1Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A + 3, tmp | 0x60);
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A, STAid | BIT9);
+		} else
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A + 2, STAid | 0xE200);	/*Set BIT25*/
+
+		phydm_Beamforming_Notify(pDM_Odm);
+	}
+
+}
+
+
+VOID
+HalTxbf8814A_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+
+	if (Idx < BEAMFORMER_ENTRY_NUM) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[Idx];
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[Idx];
+	} else
+		return;
+
+	/*Clear P_AID of Beamformee*/
+	/*Clear MAC address of Beamformer*/
+	/*Clear Associated Bfmee Sel*/
+
+	if (BeamformerEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8814A, 0xD8);
+		if (Idx == 0) {
+			ODM_Write4Byte(pDM_Odm, REG_ASSOCIATED_BFMER0_INFO_8814A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMER0_INFO_8814A + 4, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8814A, 0);
+		} else {
+			ODM_Write4Byte(pDM_Odm, REG_ASSOCIATED_BFMER1_INFO_8814A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMER1_INFO_8814A + 4, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8814A + 2, 0);
+		}
+	}
+
+	if (BeamformeeEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		halTxbf8814A_RfMode(pDM_Odm, pBeamformingInfo, Idx);
+		if (Idx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8814A, 0x0);
+			ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8814A + 3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8814A + 3) | BIT4 | BIT6 | BIT7);
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A, 0);
+		} else {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8814A + 2, 0x0 | BIT14 | BIT15 | BIT12);
+
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A + 2, ODM_Read2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8814A + 2) & 0x60);
+		}
+	}
+}
+
+VOID
+HalTxbf8814A_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte					BeamCtrlVal, tmpVal;
+	u4Byte					BeamCtrlReg;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformEntry;
+
+	if (Idx < BEAMFORMEE_ENTRY_NUM)
+		BeamformEntry = pBeamformingInfo->BeamformeeEntry[Idx];
+	else
+		return;
+
+	if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+		BeamCtrlVal = BeamformEntry.MacId;
+	else
+		BeamCtrlVal = BeamformEntry.P_AID;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("@%s, BeamformEntry.BeamformEntryState = %d", __func__, BeamformEntry.BeamformEntryState));
+
+	if (Idx == 0)
+		BeamCtrlReg = REG_TXBF_CTRL_8814A;
+	else {
+		BeamCtrlReg = REG_TXBF_CTRL_8814A + 2;
+		BeamCtrlVal |= BIT12 | BIT14 | BIT15;
+	}
+
+	if (BeamformEntry.BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+		if (BeamformEntry.SoundBW == CHANNEL_WIDTH_20)
+			BeamCtrlVal |= BIT9;
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_40)
+			BeamCtrlVal |= (BIT9 | BIT10);
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_80)
+			BeamCtrlVal |= (BIT9 | BIT10 | BIT11);
+	} else {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("@%s, Don't apply Vmatrix",  __func__));
+		BeamCtrlVal &= ~(BIT9 | BIT10 | BIT11);
+	}
+
+	ODM_Write2Byte(pDM_Odm, BeamCtrlReg, BeamCtrlVal);
+	/*disable NDP packet use beamforming */
+	tmpVal = ODM_Read2Byte(pDM_Odm, REG_TXBF_CTRL_8814A);
+	ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8814A, tmpVal | BIT15);
+
+}
+
+
+
+
+
+VOID
+HalTxbf8814A_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+)
+{
+#if 0
+	PRT_BEAMFORMING_INFO 	pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+
+	if (pBeamEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING)
+		halTxbf8814A_DownloadNDPA(Adapter, Idx);
+
+	halTxbf8814A_FwTxBFCmd(Adapter);
+#endif
+}
+
+#endif	/* (RTL8814A_SUPPORT == 1)*/
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.h
new file mode 100644
index 000000000..aac2b9308
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8814a.h
@@ -0,0 +1,70 @@
+#ifndef __HAL_TXBF_8814A_H__
+#define __HAL_TXBF_8814A_H__
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8814A_SUPPORT == 1)
+VOID
+HalTxbf8814A_setNDPArate(
+	IN PVOID			pDM_VOID,
+	IN u1Byte	BW,
+	IN u1Byte	Rate
+);
+
+u1Byte
+halTxbf8814A_GetNtx(
+	IN PVOID			pDM_VOID
+	);
+
+VOID
+HalTxbf8814A_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8814A_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8814A_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+VOID
+HalTxbf8814A_ResetTxPath(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8814A_GetTxRate(
+	IN PVOID			pDM_VOID
+	);
+
+VOID
+HalTxbf8814A_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+	);
+#else
+
+#define HalTxbf8814A_setNDPArate(pDM_VOID,	BW,	Rate)
+#define halTxbf8814A_GetNtx(pDM_VOID) 0
+#define HalTxbf8814A_Enter(pDM_VOID, Idx)
+#define HalTxbf8814A_Leave(pDM_VOID, Idx)
+#define HalTxbf8814A_Status(pDM_VOID, Idx)
+#define HalTxbf8814A_ResetTxPath(pDM_VOID,	Idx)
+#define HalTxbf8814A_GetTxRate(pDM_VOID)
+#define HalTxbf8814A_FwTxBF(pDM_VOID,	Idx)
+#endif
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.c
new file mode 100644
index 000000000..36ea38a16
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.c
@@ -0,0 +1,400 @@
+/*============================================================*/
+/*Description:*/
+/*This file is for 8812/8821/8811 TXBF mechanism*/
+/*============================================================*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8821B_SUPPORT == 1)
+
+VOID
+halTxbf8821B_RfMode(
+	IN PVOID			pDM_VOID,
+	IN PRT_BEAMFORMING_INFO	pBeamInfo
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (pDM_Odm->RFType == ODM_1T1R)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] set TxIQGen\n", __func__));
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WeLut_Jaguar, 0x80000, 0x1);	/*RF Mode table write enable*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_WeLut_Jaguar, 0x80000, 0x1);	/*RF Mode table write enable*/
+
+	if (pBeamInfo->beamformee_su_cnt > 0) {
+		/*Path_A*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0xE26BF);	/*Enable TXIQGEN in RX mode*/
+		/*Path_B*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData1, 0xfffff, 0xE26BF);	/*Enable TXIQGEN in RX mode*/
+	} else {
+		/*Path_A*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0xC26BF);	/*Disable TXIQGEN in RX mode*/
+		/*Path_B*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData1, 0xfffff, 0xC26BF);	/*Disable TXIQGEN in RX mode*/
+	}
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WeLut_Jaguar, 0x80000, 0x0);	/*RF Mode table write disable*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_WeLut_Jaguar, 0x80000, 0x0);	/*RF Mode table write disable*/
+
+	if (pBeamInfo->beamformee_su_cnt > 0)
+		ODM_SetBBReg(pDM_Odm, rTxPath_Jaguar, bMaskByte1, 0x33);
+	else
+		ODM_SetBBReg(pDM_Odm, rTxPath_Jaguar, bMaskByte1, 0x11);
+}
+
+#if 0
+VOID
+halTxbf8821B_DownloadNDPA(
+	IN PDM_ODM_T			pDM_Odm,
+	IN	u1Byte				Idx
+)
+{
+	u1Byte			u1bTmp = 0, tmpReg422 = 0, Head_Page;
+	u1Byte			BcnValidReg = 0, count = 0, DLBcnCount = 0;
+	BOOLEAN			bSendBeacon = FALSE;
+	u1Byte			TxPageBndy = LAST_ENTRY_OF_TX_PKT_BUFFER_8812;	/*default reseved 1 page for the IC type which is undefined.*/
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+
+	pHalData->bFwDwRsvdPageInProgress = TRUE;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (Idx == 0)
+		Head_Page = 0xFE;
+	else
+		Head_Page = 0xFE;
+
+	Adapter->HalFunc.GetHalDefVarHandler(Adapter, HAL_DEF_TX_PAGE_BOUNDARY, (pu1Byte)&TxPageBndy);
+
+	/*Set REG_CR bit 8. DMA beacon by SW.*/
+	u1bTmp = ODM_Read1Byte(pDM_Odm, REG_CR_8821B + 1);
+	ODM_Write1Byte(pDM_Odm,  REG_CR_8821B + 1, (u1bTmp | BIT0));
+
+
+	/*Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.*/
+	tmpReg422 = ODM_Read1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8821B + 2);
+	ODM_Write1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8821B + 2,  tmpReg422 & (~BIT6));
+
+	if (tmpReg422 & BIT6) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("SetBeamformDownloadNDPA_8812(): There is an Adapter is sending beacon.\n"));
+		bSendBeacon = TRUE;
+	}
+
+	/*TDECTRL[15:8] 0x209[7:0] = 0xF6	Beacon Head for TXDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 1, Head_Page);
+
+	do {
+		/*Clear beacon valid check bit.*/
+		BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_TDECTRL_8812A + 2);
+		ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 2, (BcnValidReg | BIT0));
+
+		/*download NDPA rsvd page.*/
+		if (pBeamEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
+			Beamforming_SendVHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->AID, pBeamEntry->SoundBW, BEACON_QUEUE);
+		else
+			Beamforming_SendHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->SoundBW, BEACON_QUEUE);
+
+		/*check rsvd page download OK.*/
+		BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_TDECTRL_8812A + 2);
+		count = 0;
+		while (!(BcnValidReg & BIT0) && count < 20) {
+			count++;
+			ODM_delay_ms(10);
+			BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_TDECTRL_8812A + 2);
+		}
+		DLBcnCount++;
+	} while (!(BcnValidReg & BIT0) && DLBcnCount < 5);
+
+	if (!(BcnValidReg & BIT0))
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Download RSVD page failed!\n", __func__));
+
+	/*TDECTRL[15:8] 0x209[7:0] = 0xF6	Beacon Head for TXDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 1, TxPageBndy);
+
+	/*To make sure that if there exists an adapter which would like to send beacon.*/
+	/*If exists, the origianl value of 0x422[6] will be 1, we should check this to*/
+	/*prevent from setting 0x422[6] to 0 after download reserved page, or it will cause*/
+	/*the beacon cannot be sent by HW.*/
+	/*2010.06.23. Added by tynli.*/
+	if (bSendBeacon)
+		ODM_Write1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8821B + 2, tmpReg422);
+
+	/*Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli.*/
+	/*Clear CR[8] or beacon packet will not be send to TxBuf anymore.*/
+	u1bTmp = ODM_Read1Byte(pDM_Odm, REG_CR_8821B + 1);
+	ODM_Write1Byte(pDM_Odm, REG_CR_8821B + 1, (u1bTmp & (~BIT0)));
+
+	pBeamEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSED;
+
+	pHalData->bFwDwRsvdPageInProgress = FALSE;
+}
+
+
+VOID
+halTxbf8821B_FwTxBFCmd(
+	IN PDM_ODM_T			pDM_Odm
+)
+{
+	u1Byte	Idx, Period0 = 0, Period1 = 0;
+	u1Byte	PageNum0 = 0xFF, PageNum1 = 0xFF;
+	u1Byte	u1TxBFParm[3] = {0};
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		/*Modified by David*/
+		if (pBeamInfo->BeamformeeEntry[Idx].bUsed && pBeamInfo->BeamformeeEntry[Idx].BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			if (Idx == 0) {
+				if (pBeamInfo->BeamformeeEntry[Idx].bSound)
+					PageNum0 = 0xFE;
+				else
+					PageNum0 = 0xFF; /*stop sounding*/
+				Period0 = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			} else if (Idx == 1) {
+				if (pBeamInfo->BeamformeeEntry[Idx].bSound)
+					PageNum1 = 0xFE;
+				else
+					PageNum1 = 0xFF; /*stop sounding*/
+				Period1 = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			}
+		}
+	}
+
+	u1TxBFParm[0] = PageNum0;
+	u1TxBFParm[1] = PageNum1;
+	u1TxBFParm[2] = (Period1 << 4) | Period0;
+	FillH2CCmd(Adapter, PHYDM_H2C_TXBF, 3, u1TxBFParm);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, 
+		("[%s] PageNum0 = %d Period0 = %d, PageNum1 = %d Period1 %d\n", __func__, PageNum0, Period0, PageNum1, Period1));
+}
+
+#endif
+VOID
+HalTxbf8821B_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				BFerBFeeIdx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					i = 0;
+	u1Byte					BFerIdx = (BFerBFeeIdx & 0xF0) >> 4;
+	u1Byte					BFeeIdx = (BFerBFeeIdx & 0xF);
+	u4Byte					CSI_Param;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	u2Byte					STAid = 0;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Start!\n", __func__));
+
+	halTxbf8821B_RfMode(pDM_Odm, pBeamformingInfo);
+
+	if (pDM_Odm->RFType == ODM_2T2R)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CSI_CONTENT_VALUE, bMaskDWord, 0x00000000);	/*Nc =2*/
+	else
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CSI_CONTENT_VALUE, bMaskDWord, 0x01081008);	/*Nc =1*/
+
+	if ((pBeamformingInfo->beamformer_su_cnt > 0) && (BFerIdx < BEAMFORMER_ENTRY_NUM)) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[BFerIdx];
+
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8821B, 0xCB);
+
+		/*MAC address/Partial AID of Beamformer*/
+		if (BFerIdx == 0) {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_BFMER0_INFO_8812A + i), BeamformerEntry.MacAddr[i]);
+			/*CSI report use legacy ofdm so don't need to fill P_AID. */
+			/*PlatformEFIOWrite2Byte(Adapter, REG_BFMER0_INFO_8821B+6, BeamformEntry.P_AID); */
+		} else {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_BFMER1_INFO_8812A + i), BeamformerEntry.MacAddr[i]);
+			/*CSI report use legacy ofdm so don't need to fill P_AID.*/
+			/*PlatformEFIOWrite2Byte(Adapter, REG_BFMER1_INFO_8821B+6, BeamformEntry.P_AID);*/
+		}
+
+		/*CSI report parameters of Beamformee*/
+		if (BeamformerEntry.BeamformEntryCap & BEAMFORMEE_CAP_VHT_SU) {
+			if (pDM_Odm->RFType == ODM_2T2R)
+				CSI_Param = 0x01090109;
+			else
+				CSI_Param = 0x01080108;
+		} else {
+			if (pDM_Odm->RFType == ODM_2T2R)
+				CSI_Param = 0x03090309;
+			else
+				CSI_Param = 0x03080308;
+		}
+
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8821B, CSI_Param);
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8821B, CSI_Param);
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8821B, CSI_Param);
+
+		/*Timeout value for MAC to leave NDP_RX_standby_state (60 us, Test chip) (80 us,  MP chip)*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8821B + 3, 0x50);
+	}
+
+
+	if ((pBeamformingInfo->beamformee_su_cnt > 0) && (BFeeIdx < BEAMFORMEE_ENTRY_NUM)) {
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[BFeeIdx];
+
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+			STAid = BeamformeeEntry.MacId;
+		else
+			STAid = BeamformeeEntry.P_AID;
+
+		/*P_AID of Beamformee & enable NDPA transmission & enable NDPA interrupt*/
+		if (BFeeIdx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8821B, STAid);
+			ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8821B + 3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8821B + 3) | BIT4 | BIT6 | BIT7);
+		} else
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8821B + 2, STAid | BIT12 | BIT14 | BIT15);
+
+		/*CSI report parameters of Beamformee*/
+		if (BFeeIdx == 0) {
+			/*Get BIT24 & BIT25*/
+			u1Byte	tmp = ODM_Read1Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 3) & 0x3;
+
+			ODM_Write1Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 3, tmp | 0x60);
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A, STAid | BIT9);
+		} else {
+			/*Set BIT25*/
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2, STAid | 0xE200);
+		}
+			phydm_Beamforming_Notify(pDM_Odm);
+	}
+}
+
+
+VOID
+HalTxbf8821B_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	
+	if (Idx < BEAMFORMER_ENTRY_NUM) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[Idx];
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[Idx];
+	} else
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Start!, IDx = %d\n", __func__, Idx));
+
+	/*Clear P_AID of Beamformee*/
+	/*Clear MAC address of Beamformer*/
+	/*Clear Associated Bfmee Sel*/
+	
+	if (BeamformerEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8821B, 0xC8);
+		if (Idx == 0) {
+			ODM_Write4Byte(pDM_Odm, REG_BFMER0_INFO_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_BFMER0_INFO_8812A + 4, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8821B, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8821B, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8821B, 0);
+		} else {
+			ODM_Write4Byte(pDM_Odm, REG_BFMER1_INFO_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_BFMER1_INFO_8812A + 4, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8821B, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8821B, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8821B, 0);
+		}
+	}
+
+	if (BeamformeeEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		halTxbf8821B_RfMode(pDM_Odm, pBeamformingInfo);
+		if (Idx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8821B, 0x0);
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A, 0);
+		} else {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8821B + 2, ODM_Read2Byte(pDM_Odm, REG_TXBF_CTRL_8821B + 2) & 0xF000);
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2, ODM_Read2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2) & 0x60);
+		}
+	}
+	
+}
+
+
+VOID
+HalTxbf8821B_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte					BeamCtrlVal;
+	u4Byte					BeamCtrlReg;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformEntry = pBeamInfo->BeamformeeEntry[Idx];
+
+	if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+		BeamCtrlVal = BeamformEntry.MacId;
+	else
+		BeamCtrlVal = BeamformEntry.P_AID;
+
+	if (Idx == 0)
+		BeamCtrlReg = REG_TXBF_CTRL_8821B;
+	else {
+		BeamCtrlReg = REG_TXBF_CTRL_8821B + 2;
+		BeamCtrlVal |= BIT12 | BIT14 | BIT15;
+	}
+
+	if (BeamformEntry.BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+		if (BeamformEntry.SoundBW == CHANNEL_WIDTH_20)
+			BeamCtrlVal |= BIT9;
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_40)
+			BeamCtrlVal |= BIT10;
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_80)
+			BeamCtrlVal |= BIT11;
+	} else
+		BeamCtrlVal &= ~(BIT9 | BIT10 | BIT11);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] BeamCtrlVal = 0x%x!\n", __func__, BeamCtrlVal));
+
+	ODM_Write2Byte(pDM_Odm, BeamCtrlReg, BeamCtrlVal);
+}
+
+
+
+VOID
+HalTxbf8821B_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+#if 0
+	if (pBeamEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING)
+		halTxbf8821B_DownloadNDPA(pDM_Odm, Idx);
+
+	halTxbf8821B_FwTxBFCmd(pDM_Odm);
+#endif
+}
+
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.h
new file mode 100644
index 000000000..3045cafe4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8821b.h
@@ -0,0 +1,43 @@
+#ifndef __HAL_TXBF_8821B_H__
+#define __HAL_TXBF_8821B_H__
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8821B_SUPPORT == 1)
+VOID
+HalTxbf8821B_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8821B_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8821B_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8821B_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+	);
+
+#else
+#define HalTxbf8821B_Enter(pDM_VOID, Idx)
+#define HalTxbf8821B_Leave(pDM_VOID, Idx)
+#define HalTxbf8821B_Status(pDM_VOID, Idx)
+#define HalTxbf8821B_FwTxBF(pDM_VOID, Idx)
+#endif
+
+
+#endif
+
+#endif	// #ifndef __HAL_TXBF_8821B_H__								
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.c
new file mode 100644
index 000000000..291e2f932
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.c
@@ -0,0 +1,1099 @@
+/*============================================================*/
+/* Description:                                               */
+/*                                                            */
+/* This file is for 8814A TXBF mechanism                      */
+/*                                                            */
+/*============================================================*/
+
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8822B_SUPPORT == 1)
+
+#if 0
+VOID
+HalTxbf8814A_GetBeamformcap(
+	IN PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = GET_BEAMFORM_INFO(Adapter);
+	BEAMFORMING_CAP	BeamformCap = BEAMFORMING_CAP_NONE;
+
+	BeamformCap = phydm_Beamforming_GetBeamCap(pDM_Odm, pBeamformingInfo);
+
+	if (BeamformCap == pBeamformingInfo->BeamformCap)
+		return;
+	else 
+		pBeamformingInfo->BeamformCap = BeamformCap;
+
+}
+
+VOID
+HalTxbf8814A_GetTxRate(
+	IN	PADAPTER			Adapter
+)
+{
+
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T					pDM_Odm = &pHalData->DM_OutSrc;
+	PRT_BEAMFORMING_INFO			pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pEntry;
+	u4Byte		TxRptData = 0;
+	u1Byte		DataRate = 0xFF;
+
+	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
+
+	ReadSdramData_8814A(Adapter, (u1Byte)pEntry->MacId, LOC_8814A_CTRL_INFO, &TxRptData, 1);
+	DataRate = (u1Byte)TxRptData;
+	DataRate &= bMask7bits;   /*Bit7 indicates SGI*/
+	
+	pDM_Odm->TxBfDataRate = DataRate;
+
+}
+
+VOID
+HalTxbf8814A_ResetTxPath(
+	IN	PADAPTER			Adapter,
+	IN	u1Byte				idx
+)
+{
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter); 
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc; 
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = GET_BEAMFORM_INFO(Adapter);
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	u1Byte	Nr_index = 0;
+	
+	if (idx < BEAMFORMEE_ENTRY_NUM)
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[idx];
+	else
+		return;
+	
+	if ((pDM_Odm->LastUSBHub) != (RT_GetHubUSBMode(Adapter))) {	
+		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(Adapter), BeamformeeEntry.CompSteeringNumofBFer);
+
+		if (idx == 0) {
+			switch (Nr_index) {			
+			case 0:	
+			break;
+
+			case 1:			/*Nsts = 2	BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT3|BIT2|BIT1|BIT0, 0x6);		/*1ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT7|BIT6|BIT5|BIT4, 0x6);		/*2ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, 0x0000ff00, 0x10);				/*BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, BIT23|BIT22|BIT21|BIT20, 0x6);	/*set TxPath selection for 8814a BFer bug refine*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, bMaskByte3, 0x10);				/*if Bfer enable, always use 3Tx for all Spatial stream*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x1060);
+			break;
+
+			case 2:			/*Nsts = 3	BCD*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT3|BIT2|BIT1|BIT0, 0xe);		/*1ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT7|BIT6|BIT5|BIT4, 0xe);		/*2ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, 0x0000ff00, 0x90);				/*BCD*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT19|BIT18|BIT17|BIT16, 0xe);	/*3ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, 0xff00000, 0x90);					/*bcd*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, BIT23|BIT22|BIT21|BIT20, 0xe);	/*set TxPath selection for 8814a BFer bug refine*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, bMaskByte3, 0x90);				/*if Bfer enable, always use 3Tx for all Spatial stream*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x90e90e0);
+			break;
+			
+			default:			/*Nr>3, same as Case 3*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT3|BIT2|BIT1|BIT0, 0xf);		/*1ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT7|BIT6|BIT5|BIT4, 0xf);		/*2ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, 0x0000ff00, 0x93);				/*BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, BIT19|BIT18|BIT17|BIT16, 0xf);	/*3ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF0, 0xff00000, 0x93);					/*bcd*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, BIT23|BIT22|BIT21|BIT20, 0xf);	/*set TxPath selection for 8814a BFer bug refine*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, bMaskByte3, 0x93);				/*if Bfer enable, always use 3Tx for all Spatial stream*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93f93f0);
+			break;
+			}
+		} else	{
+			switch (Nr_index) {
+			case 0:	
+			break;
+
+			case 1:			/*Nsts = 2	BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT3|BIT2|BIT1|BIT0, 0x6);		/*1ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT7|BIT6|BIT5|BIT4, 0x6);		/*2ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, 0x0000ff00, 0x10);				/*BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, BIT23|BIT22|BIT21|BIT20, 0x6);	/*set TxPath selection for 8814a BFer bug refine*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, bMaskByte3, 0x10);				/*if Bfer enable, always use 3Tx for all Spatial stream*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x1060);
+			break;
+
+			case 2:			/*Nsts = 3	BCD*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT3|BIT2|BIT1|BIT0, 0xe);		/*1ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT7|BIT6|BIT5|BIT4, 0xe);		/*2ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, 0x0000ff00, 0x90);				/*BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT19|BIT18|BIT17|BIT16, 0xe);	/*3ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, 0xff00000, 0x90);					/*bcd*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, BIT23|BIT22|BIT21|BIT20, 0xe);	/*set TxPath selection for 8814a BFer bug refine*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, bMaskByte3, 0x90);				/*if Bfer enable, always use 3Tx for all Spatial stream*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x90e90e0);
+			break;
+			
+			default:			/*Nr>3, same as Case 3*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT3|BIT2|BIT1|BIT0, 0xf);		/*1ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT7|BIT6|BIT5|BIT4, 0xf);		/*2ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, 0x0000ff00, 0x93);				/*BC*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, BIT19|BIT18|BIT17|BIT16, 0xf);	/*3ss*/
+			PHY_SetBBReg(Adapter, REG_BB_TXBF_ANT_SET_BF1, 0xff00000, 0x93);					/*bcd*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, BIT23|BIT22|BIT21|BIT20, 0xf);	/*set TxPath selection for 8814a BFer bug refine*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_1, bMaskByte3, 0x93);				/*if Bfer enable, always use 3Tx for all Spatial stream*/
+			PHY_SetBBReg(Adapter, REG_BB_TX_PATH_SEL_2, bMaskDWord, 0x93f93f0);
+			break;
+		
+			}
+		}
+
+			pDM_Odm->LastUSBHub = RT_GetHubUSBMode(Adapter);
+	}
+	else
+		return;
+#endif
+}
+#endif
+
+u1Byte
+halTxbf8822B_GetNtx(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			Ntx = 0;
+
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+	if (pDM_Odm->SupportInterface == ODM_ITRF_USB) {
+		if (*pDM_Odm->HubUsbMode == 2) {/*USB3.0*/
+			if (pDM_Odm->RFType == ODM_4T4R)
+				Ntx = 3;
+			else if (pDM_Odm->RFType == ODM_3T3R)
+				Ntx = 2;
+			else
+				Ntx = 1;
+		} else if (*pDM_Odm->HubUsbMode == 1)	/*USB 2.0 always 2Tx*/
+			Ntx = 1;
+		else
+			Ntx = 1;
+	} else
+#endif
+	{
+		if (pDM_Odm->RFType == ODM_4T4R)
+			Ntx = 3;
+		else if (pDM_Odm->RFType == ODM_3T3R)
+			Ntx = 2;
+		else
+			Ntx = 1;
+	}
+
+	return Ntx;
+
+}
+
+u1Byte
+halTxbf8822B_GetNrx(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			Nrx = 0;
+
+	if (pDM_Odm->RFType == ODM_4T4R)
+		Nrx = 3;
+	else if (pDM_Odm->RFType == ODM_3T3R)
+		Nrx = 2;
+	else if (pDM_Odm->RFType == ODM_2T2R)
+		Nrx = 1;
+	else if (pDM_Odm->RFType == ODM_2T3R)
+		Nrx = 2;
+	else if (pDM_Odm->RFType == ODM_2T4R)
+		Nrx = 3;
+	else if (pDM_Odm->RFType == ODM_1T1R)
+		Nrx = 0;
+	else if (pDM_Odm->RFType == ODM_1T2R)
+		Nrx = 1;
+	else
+		Nrx = 0;
+
+	return Nrx;
+	
+}
+
+/***************SU & MU BFee Entry********************/
+VOID
+halTxbf8822B_RfMode(
+	IN PVOID			pDM_VOID,
+	IN	PRT_BEAMFORMING_INFO	pBeamformingInfo,
+	IN	u1Byte					idx
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte				i, Nr_index = 0;
+	BOOLEAN				bSelfBeamformer = FALSE;
+	BOOLEAN				bSelfBeamformee = FALSE;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+
+	if (idx < BEAMFORMEE_ENTRY_NUM)
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[idx];
+	else
+		return;
+
+	if (pDM_Odm->RFType == ODM_1T1R)
+		return;
+
+	for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_B; i++) {
+		ODM_SetRFReg(pDM_Odm, i, RF_WeLut_Jaguar, 0x80000, 0x1);
+		/*RF Mode table write enable*/
+	}
+
+	if ((pBeamformingInfo->beamformee_su_cnt > 0) || (pBeamformingInfo->beamformee_mu_cnt > 0)) {
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_B; i++) {
+			ODM_SetRFReg(pDM_Odm, i, RF_ModeTableAddr, 0xfffff, 0x18000);
+			/*Select RX mode*/
+			ODM_SetRFReg(pDM_Odm, i, RF_ModeTableData0, 0xfffff, 0xBE77F);
+			/*Set Table data*/
+			ODM_SetRFReg(pDM_Odm, i, RF_ModeTableData1, 0xfffff, 0x226BF);
+			/*Enable TXIQGEN in RX mode*/
+		}
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0xE26BF);
+		/*Enable TXIQGEN in RX mode*/
+	}
+
+	for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_B; i++) {
+		ODM_SetRFReg(pDM_Odm, i, RF_WeLut_Jaguar, 0x80000, 0x0);
+		/*RF Mode table write disable*/
+	}
+
+	if (pBeamformingInfo->beamformee_su_cnt > 0) {
+
+		/*for 8814 19ac(idx 1), 19b4(idx 0), different Tx ant setting*/
+		ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, BIT28|BIT29, 0x2);			/*enable BB TxBF ant mapping register*/
+		
+		if (idx == 0) {
+			/*Nsts = 2	AB*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF0, 0xffff, 0x0433);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, 0xfff00000, 0x043);
+			/*ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x430);*/
+
+		} else {/*IDX =1*/
+			ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, 0xffff, 0x0433);
+			ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, 0xfff00000, 0x043);
+			/*ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x430;*/
+		}
+	} else {
+		ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, 0xfff00000, 0x1); /*1SS by path-A*/
+		ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_2, bMaskLWord, 0x430); /*2SS by path-A,B*/
+	}
+	
+	if (pBeamformingInfo->beamformee_mu_cnt > 0) {
+		/*MU STAs share the common setting*/
+		ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, BIT31, 1);
+		ODM_SetBBReg(pDM_Odm, REG_BB_TXBF_ANT_SET_BF1, 0xffff, 0x0433);
+		ODM_SetBBReg(pDM_Odm, REG_BB_TX_PATH_SEL_1, 0xfff00000, 0x043);
+	}
+
+}
+#if 0
+VOID
+halTxbf8822B_DownloadNDPA(
+	IN	PADAPTER			Adapter,
+	IN	u1Byte				Idx
+	)
+{
+	u1Byte			u1bTmp = 0, tmpReg422 = 0;
+	u1Byte			BcnValidReg = 0, count = 0, DLBcnCount = 0;
+	u2Byte			Head_Page = 0x7FE;
+	BOOLEAN			bSendBeacon = FALSE;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u2Byte			TxPageBndy = LAST_ENTRY_OF_TX_PKT_BUFFER_8814A; /*default reseved 1 page for the IC type which is undefined.*/
+	PRT_BEAMFORMING_INFO	pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry+Idx;
+
+	pHalData->bFwDwRsvdPageInProgress = TRUE;
+	Adapter->HalFunc.GetHalDefVarHandler(Adapter, HAL_DEF_TX_PAGE_BOUNDARY, (pu2Byte)&TxPageBndy);
+	
+	/*Set REG_CR bit 8. DMA beacon by SW.*/
+	u1bTmp = PlatformEFIORead1Byte(Adapter, REG_CR_8814A+1);
+	PlatformEFIOWrite1Byte(Adapter,  REG_CR_8814A+1, (u1bTmp|BIT0));
+
+
+	/*Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.*/
+	tmpReg422 = PlatformEFIORead1Byte(Adapter, REG_FWHW_TXQ_CTRL_8814A+2);
+	PlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL_8814A+2,  tmpReg422&(~BIT6));
+
+	if (tmpReg422 & BIT6) {
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("SetBeamformDownloadNDPA_8814A(): There is an Adapter is sending beacon.\n"));
+		bSendBeacon = TRUE;
+	}
+
+	/*0x204[11:0]	Beacon Head for TXDMA*/
+	PlatformEFIOWrite2Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A, Head_Page);
+	
+	do {		
+		/*Clear beacon valid check bit.*/
+		BcnValidReg = PlatformEFIORead1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A+1);
+		PlatformEFIOWrite1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A+1, (BcnValidReg|BIT7));
+		
+		/*download NDPA rsvd page.*/
+		if (pBeamEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
+			Beamforming_SendVHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->AID, pBeamEntry->SoundBW, BEACON_QUEUE);
+		else 
+			Beamforming_SendHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->SoundBW, BEACON_QUEUE);
+	
+		/*check rsvd page download OK.*/
+		BcnValidReg = PlatformEFIORead1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A + 1);
+		count = 0;
+		while (!(BcnValidReg & BIT7) && count < 20) {
+			count++;
+			delay_us(10);
+			BcnValidReg = PlatformEFIORead1Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A+2);
+		}
+		DLBcnCount++;
+	} while (!(BcnValidReg & BIT7) && DLBcnCount < 5);
+	
+	if (!(BcnValidReg & BIT0))
+		RT_DISP(FBEAM, FBEAM_ERROR, ("%s Download RSVD page failed!\n", __func__));
+
+	/*0x204[11:0]	Beacon Head for TXDMA*/
+	PlatformEFIOWrite2Byte(Adapter, REG_FIFOPAGE_CTRL_2_8814A, TxPageBndy);
+
+	/*To make sure that if there exists an adapter which would like to send beacon.*/
+	/*If exists, the origianl value of 0x422[6] will be 1, we should check this to*/
+	/*prevent from setting 0x422[6] to 0 after download reserved page, or it will cause */
+	/*the beacon cannot be sent by HW.*/
+	/*2010.06.23. Added by tynli.*/
+	if (bSendBeacon)
+		PlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL_8814A+2, tmpReg422);
+
+	/*Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli.*/
+	/*Clear CR[8] or beacon packet will not be send to TxBuf anymore.*/
+	u1bTmp = PlatformEFIORead1Byte(Adapter, REG_CR_8814A+1);
+	PlatformEFIOWrite1Byte(Adapter, REG_CR_8814A+1, (u1bTmp&(~BIT0)));
+
+	pBeamEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSED;
+
+	pHalData->bFwDwRsvdPageInProgress = FALSE;
+}
+
+VOID
+halTxbf8822B_FwTxBFCmd(
+	IN	PADAPTER	Adapter
+	)
+{
+	u1Byte	Idx, Period = 0;
+	u1Byte	PageNum0 = 0xFF, PageNum1 = 0xFF;
+	u1Byte	u1TxBFParm[3] = {0};
+
+	PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
+	PRT_BEAMFORMING_INFO	pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		if (pBeamInfo->BeamformeeEntry[Idx].bUsed && pBeamInfo->BeamformeeEntry[Idx].BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			if (pBeamInfo->BeamformeeEntry[Idx].bSound) {
+				PageNum0 = 0xFE;
+				PageNum1 = 0x07;
+				Period = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			} else if (PageNum0 == 0xFF) {
+				PageNum0 = 0xFF; /*stop sounding*/
+				PageNum1 = 0x0F;
+			}
+		}
+	}
+
+	u1TxBFParm[0] = PageNum0;
+	u1TxBFParm[1] = PageNum1;
+	u1TxBFParm[2] = Period;
+	FillH2CCmd(Adapter, PHYDM_H2C_TXBF, 3, u1TxBFParm);
+	
+	RT_DISP(FBEAM, FBEAM_FUN, ("@%s End, PageNum0 = 0x%x, PageNum1 = 0x%x Period = %d", __func__, PageNum0, PageNum1, Period));
+}
+#endif
+
+VOID
+HalTxbf8822B_Init(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte		u1bTmp;
+	PRT_BEAMFORMING_INFO		pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+
+	ODM_SetBBReg(pDM_Odm, 0x14c0 , BIT16, 1); /*Enable P1 aggr new packet according to P0 transfer time*/
+	ODM_SetBBReg(pDM_Odm, 0x14c0 , BIT15|BIT14|BIT13|BIT12, 1); /*MU Retry Limit*/
+	ODM_SetBBReg(pDM_Odm, 0x14c0 , BIT7, 0); /*Disable Tx MU-MIMO until sounding done*/	
+	ODM_SetBBReg(pDM_Odm, 0x14c0 , 0x3F, 0); /* Clear validity of MU STAs */
+	ODM_Write1Byte(pDM_Odm, 0x167c , 0x70); /*MU-MIMO Option as default value*/
+	ODM_Write2Byte(pDM_Odm, 0x1680 , 0); /*MU-MIMO Control as default value*/
+
+	/* Set MU NDPA rate & BW source */
+	/* 0x42C[30] = 1 (0: from Tx desc, 1: from 0x45F) */
+	u1bTmp = ODM_Read1Byte(pDM_Odm, 0x42C);
+	ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8822B, (u1bTmp|BIT6));
+	/* 0x45F[7:0] = 0x10 (Rate=OFDM_6M, BW20) */
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8822B, 0x10);
+
+	/* Init HW variable */
+	pBeamformingInfo->RegMUTxCtrl = ODM_Read4Byte(pDM_Odm, 0x14c0);
+}
+
+VOID
+HalTxbf8822B_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				BFerBFeeIdx
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					i = 0;
+	u1Byte					BFerIdx = (BFerBFeeIdx & 0xF0)>>4;
+	u1Byte					BFeeIdx = (BFerBFeeIdx & 0xF);
+	u2Byte					CSI_Param = 0;
+	PRT_BEAMFORMING_INFO		pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamformeeEntry;
+	PRT_BEAMFORMER_ENTRY	pBeamformerEntry;
+	u2Byte					value16, STAid = 0;
+	u1Byte					Nc_index = 0, Nr_index = 0, grouping = 0, codebookinfo = 0, coefficientsize = 0;
+	u4Byte					gid_valid, user_position_l, user_position_h;
+	u4Byte					mu_reg[6] = {0x1684, 0x1686, 0x1688, 0x168a, 0x168c, 0x168e};
+	u1Byte					u1bTmp;
+	u4Byte					u4bTmp;
+	
+	RT_DISP(FBEAM, FBEAM_FUN, ("%s: BFerBFeeIdx=%d, BFerIdx=%d, BFeeIdx=%d\n", __func__, BFerBFeeIdx, BFerIdx, BFeeIdx));
+
+	/*************SU BFer Entry Init*************/
+	if ((pBeamformingInfo->beamformer_su_cnt > 0) && (BFerIdx < BEAMFORMER_ENTRY_NUM)) {
+		pBeamformerEntry = &pBeamformingInfo->BeamformerEntry[BFerIdx];
+		pBeamformerEntry->is_mu_ap = FALSE;
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8822B, 0xDB);	
+	
+		
+		for (i = 0; i < MAX_BEAMFORMER_SU; i++) {
+			if ((pBeamformingInfo->beamformer_su_reg_maping & BIT(i)) == 0) {
+				pBeamformingInfo->beamformer_su_reg_maping |= BIT(i);
+				pBeamformerEntry->su_reg_index = i;
+				break;
+			}
+		}
+		
+		/*MAC address/Partial AID of Beamformer*/
+		if (pBeamformerEntry->su_reg_index == 0) {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER0_INFO_8822B+i), pBeamformerEntry->MacAddr[i]);
+		} else {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER1_INFO_8822B+i), pBeamformerEntry->MacAddr[i]);
+		}
+
+		/*CSI report parameters of Beamformer*/
+		Nc_index = halTxbf8822B_GetNrx(pDM_Odm);	/*for 8814A Nrx = 3(4 Ant), min=0(1 Ant)*/
+		Nr_index = pBeamformerEntry->NumofSoundingDim;	/*0x718[7] = 1 use Nsts, 0x718[7] = 0 use reg setting. as Bfee, we use Nsts, so Nr_index don't care*/
+		
+		grouping = 0;
+
+		/*for ac = 1, for n = 3*/
+		if (pBeamformerEntry->BeamformEntryCap & BEAMFORMEE_CAP_VHT_SU)
+			codebookinfo = 1;	
+		else if (pBeamformerEntry->BeamformEntryCap & BEAMFORMEE_CAP_HT_EXPLICIT)
+			codebookinfo = 3;	
+
+		coefficientsize = 3;
+
+		CSI_Param = (u2Byte)((coefficientsize<<10)|(codebookinfo<<8)|(grouping<<6)|(Nr_index<<3)|(Nc_index));
+
+		if (BFerIdx == 0)
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8822B, CSI_Param);
+		else
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8822B+2, CSI_Param);
+		/*ndp_rx_standby_timer, 8814 need > 0x56, suggest from Dvaid*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8814A+3, 0x70);
+	
+	}
+
+	/*************SU BFee Entry Init*************/
+	if ((pBeamformingInfo->beamformee_su_cnt > 0) && (BFeeIdx < BEAMFORMEE_ENTRY_NUM)) {
+		pBeamformeeEntry = &pBeamformingInfo->BeamformeeEntry[BFeeIdx];
+		pBeamformeeEntry->is_mu_sta = FALSE;
+		halTxbf8822B_RfMode(pDM_Odm, pBeamformingInfo, BFeeIdx);
+		
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+			STAid = pBeamformeeEntry->MacId;
+		else 
+			STAid = pBeamformeeEntry->P_AID;
+
+		for (i = 0; i < MAX_BEAMFORMEE_SU; i++) {
+			if ((pBeamformingInfo->beamformee_su_reg_maping & BIT(i)) == 0) {
+				pBeamformingInfo->beamformee_su_reg_maping |= BIT(i);
+				pBeamformeeEntry->su_reg_index = i;
+				break;
+			}
+		}
+		
+		/*P_AID of Beamformee & enable NDPA transmission & enable NDPA interrupt*/
+		if (pBeamformeeEntry->su_reg_index == 0) {	
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8822B, STAid);	
+			ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8822B+3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8822B+3)|BIT4|BIT6|BIT7);
+		} else {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8822B+2, STAid | BIT14 | BIT15 | BIT12);
+		}	
+
+		/*CSI report parameters of Beamformee*/
+		if (pBeamformeeEntry->su_reg_index == 0) {
+			/*Get BIT24 & BIT25*/
+			u1Byte	tmp = ODM_Read1Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B+3) & 0x3;
+			
+			ODM_Write1Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B + 3, tmp | 0x60);
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B, STAid | BIT9);
+		} else		
+			ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B+2, STAid | 0xE200);	/*Set BIT25*/
+			
+			phydm_Beamforming_Notify(pDM_Odm);
+	}
+
+	/*************MU BFer Entry Init*************/
+	if ((pBeamformingInfo->beamformer_mu_cnt > 0) && (BFerIdx < BEAMFORMER_ENTRY_NUM)) {
+		pBeamformerEntry = &pBeamformingInfo->BeamformerEntry[BFerIdx];
+		pBeamformingInfo->mu_ap_index = BFerIdx;
+		pBeamformerEntry->is_mu_ap = TRUE;
+		for (i = 0; i < 8; i++)
+			pBeamformerEntry->gid_valid[i] = 0;
+		for (i = 0; i < 16; i++)
+			pBeamformerEntry->user_position[i] = 0;
+		
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8822B, 0xDB);	
+		
+		/* MAC address */
+		for (i = 0; i < 6 ; i++)
+			ODM_Write1Byte(pDM_Odm, (REG_ASSOCIATED_BFMER0_INFO_8822B+i), pBeamformerEntry->MacAddr[i]);
+
+		/* Set partial AID */
+		ODM_Write2Byte(pDM_Odm, (REG_ASSOCIATED_BFMER0_INFO_8822B+6), pBeamformerEntry->P_AID);
+
+		/* Fill our AID to 0x1680[11:0] and [13:12] = 2b'00, BF report segment select to 3895 bytes*/
+		u1bTmp = ODM_Read1Byte(pDM_Odm, 0x1680);
+		u1bTmp = (pBeamformerEntry->AID)&0xFFF;
+		ODM_Write1Byte(pDM_Odm, 0x1680, u1bTmp);
+
+		/* Set 80us for leaving ndp_rx_standby_state */
+		ODM_Write1Byte(pDM_Odm, 0x71B, 0x50);
+		
+		/* Set 0x6A0[14] = 1 to accept action_no_ack */
+		u1bTmp = ODM_Read1Byte(pDM_Odm, REG_RXFLTMAP0_8822B+1);
+		u1bTmp |= 0x40;
+		ODM_Write1Byte(pDM_Odm, REG_RXFLTMAP0_8822B+1, u1bTmp);
+		/* Set 0x6A2[5:4] = 1 to NDPA and BF report poll */
+		u1bTmp = ODM_Read1Byte(pDM_Odm, REG_RXFLTMAP1_8822B);
+		u1bTmp |= 0x30;
+		ODM_Write1Byte(pDM_Odm, REG_RXFLTMAP1_8822B, u1bTmp);
+		
+		/*CSI report parameters of Beamformer*/
+		Nc_index = halTxbf8822B_GetNrx(pDM_Odm);	/* Depend on RF type */
+		Nr_index = 1;	/*0x718[7] = 1 use Nsts, 0x718[7] = 0 use reg setting. as Bfee, we use Nsts, so Nr_index don't care*/
+		grouping = 0; /*no grouping*/
+		codebookinfo = 1; /*7 bit for psi, 9 bit for phi*/
+		coefficientsize = 0; /*This is nothing really matter*/ 
+		CSI_Param = (u2Byte)((coefficientsize<<10)|(codebookinfo<<8)|(grouping<<6)|(Nr_index<<3)|(Nc_index));
+		ODM_Write2Byte(pDM_Odm, 0x6F4, CSI_Param);
+
+	}
+	
+	/*************MU BFee Entry Init*************/
+	if ((pBeamformingInfo->beamformee_mu_cnt > 0) && (BFeeIdx < BEAMFORMEE_ENTRY_NUM)) {
+		pBeamformeeEntry = &pBeamformingInfo->BeamformeeEntry[BFeeIdx];
+		pBeamformeeEntry->is_mu_sta = TRUE;
+		for (i = 0; i < MAX_BEAMFORMEE_MU; i++) {
+			if ((pBeamformingInfo->beamformee_mu_reg_maping & BIT(i)) == 0) {
+				pBeamformingInfo->beamformee_mu_reg_maping |= BIT(i);
+				pBeamformeeEntry->mu_reg_index = i;
+				break;
+			}
+		}
+
+		if (pBeamformeeEntry->mu_reg_index == 0xFF) {
+			/* There is no valid bit in beamformee_mu_reg_maping */
+			RT_DISP(FBEAM, FBEAM_FUN, ("%s: ERROR! There is no valid bit in beamformee_mu_reg_maping!\n", __func__));
+			return;
+		}
+		
+		/*User position table*/
+		switch (pBeamformeeEntry->mu_reg_index) {
+		case 0:
+			gid_valid = 0x7fe;
+			user_position_l = 0x111110;
+			user_position_h = 0x0;
+			break;
+		case 1:
+			gid_valid = 0x7f806;
+			user_position_l = 0x11000004;
+			user_position_h = 0x11;
+			break;
+		case 2:
+			gid_valid = 0x1f81818;
+			user_position_l = 0x400040;
+			user_position_h = 0x11100;
+			break;
+		case 3:
+			gid_valid = 0x1e186060;
+			user_position_l = 0x4000400;
+			user_position_h = 0x1100040;
+			break;
+		case 4:
+			gid_valid = 0x66618180;
+			user_position_l = 0x40004000;
+			user_position_h = 0x10040400;
+			break;
+		case 5:
+			gid_valid = 0x79860600;
+			user_position_l = 0x40000;
+			user_position_h = 0x4404004;
+			break;
+		}
+
+		for (i = 0; i < 8; i++) {
+			if (i < 4) {
+				pBeamformeeEntry->gid_valid[i] = (u1Byte)(gid_valid & 0xFF);
+				gid_valid = (gid_valid >> 8);
+			} else
+				pBeamformeeEntry->gid_valid[i] = 0;
+		}
+		for (i = 0; i < 16; i++) {
+			if (i < 4) {
+				pBeamformeeEntry->user_position[i] = (u1Byte)(user_position_l & 0xFF);
+				user_position_l = user_position_l >> 8;
+			} else if (i < 8) {
+				pBeamformeeEntry->user_position[i] = (u1Byte)(user_position_h & 0xFF);
+				user_position_h = user_position_h >> 8;
+			} else
+				pBeamformeeEntry->user_position[i] = 0;
+		}
+
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8822B, 0xDB);	
+
+		/*select MU STA table*/
+		pBeamformingInfo->RegMUTxCtrl &= ~(BIT8|BIT9|BIT10);
+		pBeamformingInfo->RegMUTxCtrl |= (pBeamformeeEntry->mu_reg_index << 8)&(BIT8|BIT9|BIT10);
+		ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);	
+		
+		ODM_SetBBReg(pDM_Odm, 0x14c4 , bMaskDWord, 0); /*Reset gid_valid table*/
+		ODM_SetBBReg(pDM_Odm, 0x14c8 , bMaskDWord, user_position_l);
+		ODM_SetBBReg(pDM_Odm, 0x14cc , bMaskDWord, user_position_h);
+
+		/*set validity of MU STAs*/		
+		pBeamformingInfo->RegMUTxCtrl &= 0xFFFFFFC0;
+		pBeamformingInfo->RegMUTxCtrl |= pBeamformingInfo->beamformee_mu_reg_maping&0x3F;
+		ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);	
+
+		value16 = ODM_Read2Byte(pDM_Odm, mu_reg[pBeamformeeEntry->mu_reg_index]);
+		value16 &= 0xFE00; /*Clear PAID*/
+		value16 |= BIT9; /*Enable MU BFee*/
+		value16 |= pBeamformeeEntry->P_AID;
+		ODM_Write2Byte(pDM_Odm, mu_reg[pBeamformeeEntry->mu_reg_index] , value16);
+		
+		/* 0x42C[30] = 1 (0: from Tx desc, 1: from 0x45F) */
+		u1bTmp = ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8822B+3);
+		u1bTmp |= 0xD0; /* Set bit 28, 30, 31 to 3b'111*/
+		ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8822B+3, u1bTmp);
+		/* Set NDPA to 6M*/
+		ODM_Write1Byte(pDM_Odm, REG_NDPA_RATE_8822B, 0x4); /* 6M */
+
+		u1bTmp = ODM_Read1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8822B);
+		u1bTmp &= 0xFC; /* Clear bit 0, 1*/
+		ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8822B, u1bTmp);
+
+		u4bTmp = ODM_Read4Byte(pDM_Odm, REG_SND_PTCL_CTRL_8822B);
+		u4bTmp = ((u4bTmp & 0xFF0000FF) | 0x020200); /* Set [23:8] to 0x0202 */
+		ODM_Write4Byte(pDM_Odm, REG_SND_PTCL_CTRL_8822B, u4bTmp);	
+
+		/* Set 0x6A0[14] = 1 to accept action_no_ack */
+		u1bTmp = ODM_Read1Byte(pDM_Odm, REG_RXFLTMAP0_8822B+1);
+		u1bTmp |= 0x40;
+		ODM_Write1Byte(pDM_Odm, REG_RXFLTMAP0_8822B+1, u1bTmp);
+		/* End of MAC registers setting */
+		
+		halTxbf8822B_RfMode(pDM_Odm, pBeamformingInfo, BFeeIdx);
+#if (SUPPORT_MU_BF == 1)
+		/*Special for plugfest*/
+		delay_ms(50); /* wait for 4-way handshake ending*/
+		SendSWVHTGIDMgntFrame(pDM_Odm, pBeamformeeEntry->MacAddr, BFeeIdx);
+#endif		
+
+		phydm_Beamforming_Notify(pDM_Odm);
+
+	}
+
+}
+
+
+VOID
+HalTxbf8822B_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMER_ENTRY	pBeamformerEntry; 
+	PRT_BEAMFORMEE_ENTRY	pBeamformeeEntry;
+	u4Byte					mu_reg[6] = {0x1684, 0x1686, 0x1688, 0x168a, 0x168c, 0x168e};
+
+	if (Idx < BEAMFORMER_ENTRY_NUM) {
+		pBeamformerEntry = &pBeamformingInfo->BeamformerEntry[Idx];
+		pBeamformeeEntry = &pBeamformingInfo->BeamformeeEntry[Idx];
+	} else
+		return;
+
+	/*Clear P_AID of Beamformee*/
+	/*Clear MAC address of Beamformer*/
+	/*Clear Associated Bfmee Sel*/
+
+	if (pBeamformerEntry->BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8822B, 0xD8);	
+		if (pBeamformerEntry->is_mu_ap == 0) { /*SU BFer */
+			if (pBeamformerEntry->su_reg_index == 0) {	
+				ODM_Write4Byte(pDM_Odm, REG_ASSOCIATED_BFMER0_INFO_8822B, 0);
+				ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMER0_INFO_8822B+4, 0);
+				ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8822B, 0);
+			} else {
+				ODM_Write4Byte(pDM_Odm, REG_ASSOCIATED_BFMER1_INFO_8822B, 0);
+				ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMER1_INFO_8822B+4, 0);
+				ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8822B+2, 0);
+			}
+			pBeamformingInfo->beamformer_su_reg_maping &= ~(BIT(pBeamformerEntry->su_reg_index));
+			pBeamformerEntry->su_reg_index = 0xFF;
+		} else { /*MU BFer */
+			/*set validity of MU STA0 and MU STA1*/
+			pBeamformingInfo->RegMUTxCtrl &= 0xFFFFFFC0;
+			ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+			
+			ODM_Memory_Set(pDM_Odm, pBeamformerEntry->gid_valid, 0, 8);
+			ODM_Memory_Set(pDM_Odm, pBeamformerEntry->user_position, 0, 16);
+			pBeamformerEntry->is_mu_ap = FALSE;
+		}
+	}
+
+	if (pBeamformeeEntry->BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		halTxbf8822B_RfMode(pDM_Odm, pBeamformingInfo, Idx);
+		if (pBeamformeeEntry->is_mu_sta == 0) { /*SU BFee*/
+			if (pBeamformeeEntry->su_reg_index == 0) {	
+				ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8822B, 0x0);	
+				ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8822B+3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8822B+3)|BIT4|BIT6|BIT7);
+				ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B, 0);
+			} else {
+				ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8822B+2, 0x0 | BIT14 | BIT15 | BIT12);
+
+				ODM_Write2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B+2, 
+				ODM_Read2Byte(pDM_Odm, REG_ASSOCIATED_BFMEE_SEL_8822B+2) & 0x60);
+			}
+			pBeamformingInfo->beamformee_su_reg_maping &= ~(BIT(pBeamformeeEntry->su_reg_index));
+			pBeamformeeEntry->su_reg_index = 0xFF;
+		} else { /*MU BFee */
+			/*Disable sending NDPA & BF-rpt-poll to this BFee*/
+			ODM_Write2Byte(pDM_Odm, mu_reg[pBeamformeeEntry->mu_reg_index] , 0);
+			/*set validity of MU STA*/
+			pBeamformingInfo->RegMUTxCtrl &= ~(BIT(pBeamformeeEntry->mu_reg_index));
+			ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+			
+			
+			pBeamformeeEntry->is_mu_sta = FALSE;
+			pBeamformingInfo->beamformee_mu_reg_maping &= ~(BIT(pBeamformeeEntry->mu_reg_index));
+			pBeamformeeEntry->mu_reg_index = 0xFF;
+		}
+	}
+}
+
+
+/***********SU & MU BFee Entry Only when souding done****************/
+VOID
+HalTxbf8822B_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte					BeamCtrlVal, tmpVal;
+	u4Byte					BeamCtrlReg;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry;
+	BOOLEAN	is_mu_sounding = pBeamformingInfo->is_mu_sounding, is_bitmap_ready = FALSE;
+	u16 bitmap;
+	u8 idx, gid, i;
+	u8 id1, id0;
+	u32 gid_valid[6] = {0};
+	u32 user_position_lsb[6] = {0};
+	u32 user_position_msb[6] = {0};
+	u32 value32;
+
+	if (Idx < BEAMFORMEE_ENTRY_NUM)
+		pBeamformEntry = &pBeamformingInfo->BeamformeeEntry[Idx];
+	else
+		return;
+	
+	/*SU sounding done */
+	if (is_mu_sounding == FALSE) {
+
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+			BeamCtrlVal = pBeamformEntry->MacId;
+		else 
+			BeamCtrlVal = pBeamformEntry->P_AID;
+
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("@%s, BeamformEntry.BeamformEntryState = %d", __func__, pBeamformEntry->BeamformEntryState));
+
+		if (pBeamformEntry->su_reg_index == 0) {
+			BeamCtrlReg = REG_TXBF_CTRL_8822B;
+		} else {
+			BeamCtrlReg = REG_TXBF_CTRL_8822B+2;
+			BeamCtrlVal |= BIT12|BIT14|BIT15;
+		}
+
+		if (pBeamformEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			if (pBeamformEntry->SoundBW == CHANNEL_WIDTH_20)
+				BeamCtrlVal |= BIT9;
+			else if (pBeamformEntry->SoundBW == CHANNEL_WIDTH_40)
+				BeamCtrlVal |= (BIT9|BIT10);
+			else if (pBeamformEntry->SoundBW == CHANNEL_WIDTH_80)
+				BeamCtrlVal |= (BIT9|BIT10|BIT11);		
+		} else {
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("@%s, Don't apply Vmatrix",  __func__));
+			BeamCtrlVal &= ~(BIT9|BIT10|BIT11);
+		}
+
+		ODM_Write2Byte(pDM_Odm, BeamCtrlReg, BeamCtrlVal);
+		/*disable NDP packet use beamforming */
+		tmpVal = ODM_Read2Byte(pDM_Odm, REG_TXBF_CTRL_8822B);
+		ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8822B, tmpVal|BIT15);
+	} else {
+		/*MU sounding done */
+		if (pBeamformEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			/*value32 = ODM_GetBBReg(pDM_Odm, 0xF4C, 0xFFFF0000);*/
+			value32 = 1;
+			
+			is_bitmap_ready = (BOOLEAN)((value32 & BIT15) >> 15);
+			bitmap = (u16)(value32 & 0x3FFF);
+		
+			for (idx = 0; idx < 15; idx++) {
+				if (idx < 5) {/*bit0~4*/
+					id0 = 0;
+					id1 = (u8)(idx + 1);
+				} else if (idx < 9) { /*bit5~8*/
+					id0 = 1;
+					id1 = (u8)(idx - 3);
+				} else if (idx < 12) { /*bit9~11*/
+					id0 = 2;
+					id1 = (u8)(idx - 6);
+				} else if (idx < 14) { /*bit12~13*/	
+					id0 = 3;
+					id1 = (u8)(idx - 8);
+				} else { /*bit14*/
+					id0 = 4;
+					id1 = (u8)(idx - 9);
+				}
+				if (bitmap & BIT(idx)) {
+					/*Pair 1*/
+					gid = (idx << 1) + 1;
+					gid_valid[id0] |= (BIT(gid));
+					gid_valid[id1] |= (BIT(gid));
+					/*Pair 2*/
+					gid += 1;
+					gid_valid[id0] |= (BIT(gid));
+					gid_valid[id1] |= (BIT(gid));
+				} else {
+					/*Pair 1*/
+					gid = (idx << 1) + 1;
+					gid_valid[id0] &= ~(BIT(gid));
+					gid_valid[id1] &= ~(BIT(gid));
+					/*Pair 2*/
+					gid += 1;
+					gid_valid[id0] &= ~(BIT(gid));
+					gid_valid[id1] &= ~(BIT(gid));
+				}
+			}
+
+			for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
+				pBeamformEntry = &pBeamformingInfo->BeamformeeEntry[i];
+				if ((pBeamformEntry->is_mu_sta) && (pBeamformEntry->mu_reg_index < 6)) {
+					value32 = gid_valid[pBeamformEntry->mu_reg_index];
+					for (idx = 0; idx < 4; idx++) {
+						pBeamformEntry->gid_valid[idx] = (u8)(value32 & 0xFF);
+						value32 = (value32 >> 8);
+					}
+				}
+			}
+
+			for (idx = 0; idx < 6; idx++) {
+				pBeamformingInfo->RegMUTxCtrl |= ~(BIT8|BIT9|BIT10);
+				pBeamformingInfo->RegMUTxCtrl |= ((idx<<8)&(BIT8|BIT9|BIT10));
+				ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+				ODM_SetMACReg(pDM_Odm, 0x14C4, bMaskDWord, gid_valid[idx]); /*set MU STA gid valid table*/
+			}
+
+			/*Enable TxMU PPDU*/
+			pBeamformingInfo->RegMUTxCtrl |= BIT7;
+			ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+		}
+	}
+}
+
+/*Only used for MU BFer Entry when get GID management frame (self is as MU STA)*/
+VOID
+HalTxbf8822B_ConfigGtab(
+	IN PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMER_ENTRY	pBeamformerEntry = NULL;
+	u4Byte		gid_valid = 0, user_position_l = 0, user_position_h = 0, i;
+
+	if (pBeamformingInfo->mu_ap_index < BEAMFORMER_ENTRY_NUM)
+		pBeamformerEntry = &pBeamformingInfo->BeamformerEntry[pBeamformingInfo->mu_ap_index];
+	else
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s==>\n", __func__));
+
+	/*For GID 0~31*/
+	for (i = 0; i < 4; i++)
+		gid_valid |= (pBeamformerEntry->gid_valid[i] << (i<<3));
+	for (i = 0; i < 8; i++) {
+		if (i < 4)
+			user_position_l |= (pBeamformerEntry->user_position[i] << (i << 3));
+		else
+			user_position_h |= (pBeamformerEntry->user_position[i] << ((i - 4)<<3));
+	}
+	/*select MU STA0 table*/
+	pBeamformingInfo->RegMUTxCtrl &= ~(BIT8|BIT9|BIT10);
+	ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+	ODM_SetBBReg(pDM_Odm, 0x14c4, bMaskDWord, gid_valid); 
+	ODM_SetBBReg(pDM_Odm, 0x14c8, bMaskDWord, user_position_l);
+	ODM_SetBBReg(pDM_Odm, 0x14cc, bMaskDWord, user_position_h);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: STA0: gid_valid = 0x%x, user_position_l = 0x%x, user_position_h = 0x%x\n",
+		__func__, gid_valid, user_position_l, user_position_h));
+
+	gid_valid = 0;
+	user_position_l = 0;
+	user_position_h = 0;
+
+	/*For GID 32~64*/
+	for (i = 4; i < 8; i++)
+		gid_valid |= (pBeamformerEntry->gid_valid[i] << ((i - 4)<<3));
+	for (i = 8; i < 16; i++) {
+		if (i < 4)
+			user_position_l |= (pBeamformerEntry->user_position[i] << ((i - 8) << 3));
+		else
+			user_position_h |= (pBeamformerEntry->user_position[i] << ((i - 12) << 3));
+	}
+	/*select MU STA1 table*/
+	pBeamformingInfo->RegMUTxCtrl &= ~(BIT8|BIT9|BIT10);
+	pBeamformingInfo->RegMUTxCtrl |= BIT8;
+	ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+	ODM_SetBBReg(pDM_Odm, 0x14c4, bMaskDWord, gid_valid); 
+	ODM_SetBBReg(pDM_Odm, 0x14c8, bMaskDWord, user_position_l);
+	ODM_SetBBReg(pDM_Odm, 0x14cc, bMaskDWord, user_position_h);
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: STA1: gid_valid = 0x%x, user_position_l = 0x%x, user_position_h = 0x%x\n",
+		__func__, gid_valid, user_position_l, user_position_h));
+
+	/* Set validity of MU STA0 and MU STA1*/
+	pBeamformingInfo->RegMUTxCtrl &= 0xFFFFFFC0;
+	pBeamformingInfo->RegMUTxCtrl |= 0x3; /* STA0, STA1*/
+	ODM_Write4Byte(pDM_Odm, 0x14c0, pBeamformingInfo->RegMUTxCtrl);
+	
+}
+
+
+
+#if 0
+/*This function translate the bitmap to GTAB*/
+VOID
+haltxbf8822b_gtab_translation(
+	IN PDM_ODM_T			pDM_Odm
+) 
+{
+	u8 idx, gid;
+	u8 id1, id0;
+	u32 gid_valid[6] = {0};
+	u32 user_position_lsb[6] = {0};
+	u32 user_position_msb[6] = {0};
+	
+	for (idx = 0; idx < 15; idx++) {
+		if (idx < 5) {/*bit0~4*/
+			id0 = 0;
+			id1 = (u8)(idx + 1);
+		} else if (idx < 9) { /*bit5~8*/
+			id0 = 1;
+			id1 = (u8)(idx - 3);
+		} else if (idx < 12) { /*bit9~11*/
+			id0 = 2;
+			id1 = (u8)(idx - 6);
+		} else if (idx < 14) { /*bit12~13*/	
+			id0 = 3;
+			id1 = (u8)(idx - 8);
+		} else { /*bit14*/
+			id0 = 4;
+			id1 = (u8)(idx - 9);
+		}
+
+		/*Pair 1*/
+		gid = (idx << 1) + 1;
+		gid_valid[id0] |= (1 << gid);
+		gid_valid[id1] |= (1 << gid);
+		if (gid < 16) {
+			/*user_position_lsb[id0] |= (0 << (gid << 1));*/
+			user_position_lsb[id1] |= (1 << (gid << 1));
+		} else {
+			/*user_position_msb[id0] |= (0 << ((gid - 16) << 1));*/
+			user_position_msb[id1] |= (1 << ((gid - 16) << 1));
+		}
+		
+		/*Pair 2*/
+		gid += 1;
+		gid_valid[id0] |= (1 << gid);
+		gid_valid[id1] |= (1 << gid);
+		if (gid < 16) {
+			user_position_lsb[id0] |= (1 << (gid << 1));
+			/*user_position_lsb[id1] |= (0 << (gid << 1));*/
+		} else {
+			user_position_msb[id0] |= (1 << ((gid - 16) << 1));
+			/*user_position_msb[id1] |= (0 << ((gid - 16) << 1));*/
+		}
+
+	}
+
+
+	for (idx = 0; idx < 6; idx++) {
+		/*DbgPrint("gid_valid[%d] = 0x%x\n", idx, gid_valid[idx]);
+		DbgPrint("user_position[%d] = 0x%x   %x\n", idx, user_position_msb[idx], user_position_lsb[idx]);*/
+	}
+}
+#endif
+
+VOID
+HalTxbf8822B_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+	)
+{
+#if 0
+	PRT_BEAMFORMING_INFO	pBeamInfo = GET_BEAMFORM_INFO(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry+Idx;
+
+	if (pBeamEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING)
+		halTxbf8822B_DownloadNDPA(Adapter, Idx);
+
+	halTxbf8822B_FwTxBFCmd(Adapter);
+#endif
+}
+
+#else	/* (RTL8822B_SUPPORT == 1)*/
+
+#endif	/* (RTL8822B_SUPPORT == 1)*/
+
+#endif /*(BEAMFORMING_SUPPORT == 1)*/
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.h
new file mode 100644
index 000000000..d9bc960d5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbf8822b.h
@@ -0,0 +1,53 @@
+#ifndef __HAL_TXBF_8822B_H__
+#define __HAL_TXBF_8822B_H__
+#if (BEAMFORMING_SUPPORT == 1)
+#if (RTL8822B_SUPPORT == 1)
+
+VOID
+HalTxbf8822B_Init(
+	IN PVOID			pDM_VOID
+	);
+
+VOID
+HalTxbf8822B_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8822B_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbf8822B_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+VOID
+HalTxbf8822B_ConfigGtab(
+	IN PVOID			pDM_VOID
+	);
+
+VOID
+HalTxbf8822B_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+	);
+#else
+#define HalTxbf8822B_Init(pDM_VOID)		
+#define HalTxbf8822B_Enter(pDM_VOID, Idx)
+#define HalTxbf8822B_Leave(pDM_VOID, Idx)
+#define HalTxbf8822B_Status(pDM_VOID, Idx)
+#define HalTxbf8822B_FwTxBF(pDM_VOID, Idx)
+#define HalTxbf8822B_ConfigGtab(pDM_VOID)
+#endif
+
+
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.c
new file mode 100644
index 000000000..e7d79f02b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.c
@@ -0,0 +1,1384 @@
+//============================================================
+// Description:
+//
+// This file is for TXBF interface mechanism
+//
+//============================================================
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+Beamforming_GidPAid(
+	PADAPTER	Adapter,
+	PRT_TCB		pTcb
+)
+{
+	u1Byte		Idx = 0;
+	u1Byte		RA[6] ={0};
+	pu1Byte		pHeader = GET_FRAME_OF_FIRST_FRAG(Adapter, pTcb);
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T				pDM_Odm = &pHalData->DM_OutSrc;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+
+	if (Adapter->HardwareType < HARDWARE_TYPE_RTL8192EE)
+		return;
+	else if (IS_WIRELESS_MODE_N(Adapter) == FALSE)
+		return;
+
+#if (SUPPORT_MU_BF == 1)
+	if (pTcb->TxBFPktType == RT_BF_PKT_TYPE_BROADCAST_NDPA) { /* MU NDPA */
+#else
+	if (0) {
+#endif
+		/* Fill G_ID and P_AID */
+		pTcb->G_ID = 63;
+		if (pBeamInfo->FirstMUBFeeIndex < BEAMFORMEE_ENTRY_NUM) {
+			pTcb->P_AID = pBeamInfo->BeamformeeEntry[pBeamInfo->FirstMUBFeeIndex].P_AID;			
+			RT_DISP(FBEAM, FBEAM_FUN, ("[David]@%s End, G_ID=0x%X, P_AID=0x%X\n", __func__, pTcb->G_ID, pTcb->P_AID));
+		}
+	} else {
+		GET_80211_HDR_ADDRESS1(pHeader, &RA);
+
+		// VHT SU PPDU carrying one or more group addressed MPDUs or
+		// Transmitting a VHT NDP intended for multiple recipients
+		if (MacAddr_isBcst(RA) || MacAddr_isMulticast(RA)	|| pTcb->macId == MAC_ID_STATIC_FOR_BROADCAST_MULTICAST) {
+			pTcb->G_ID = 63;
+			pTcb->P_AID = 0;
+		} else if (ACTING_AS_AP(Adapter)) {
+			u2Byte	AID = (u2Byte) (MacIdGetOwnerAssociatedClientAID(Adapter, pTcb->macId) & 0x1ff);		/*AID[0:8]*/
+	
+			/*RT_DISP(FBEAM, FBEAM_FUN, ("@%s  pTcb->macId=0x%X, AID=0x%X\n", __func__, pTcb->macId, AID));*/
+			pTcb->G_ID = 63;
+
+			if (AID == 0)		/*A PPDU sent by an AP to a non associated STA*/
+				pTcb->P_AID = 0;
+			else {				/*Sent by an AP and addressed to a STA associated with that AP*/
+				u2Byte	BSSID = 0;
+				GET_80211_HDR_ADDRESS2(pHeader, &RA);
+				BSSID = ((RA[5] & 0xf0) >> 4) ^ (RA[5] & 0xf);	/*BSSID[44:47] xor BSSID[40:43]*/
+				pTcb->P_AID = (AID + BSSID *32) & 0x1ff;		/*(dec(A) + dec(B)*32) mod 512*/
+			}
+		} else if (ACTING_AS_IBSS(Adapter)) {
+			pTcb->G_ID = 63;
+			/*P_AID for infrasturcture mode; MACID for ad-hoc mode. */
+			pTcb->P_AID = pTcb->macId;
+		} else if (MgntLinkStatusQuery(Adapter)) {				/*Addressed to AP*/
+			pTcb->G_ID = 0;
+			GET_80211_HDR_ADDRESS1(pHeader, &RA);
+			pTcb->P_AID =  RA[5];							/*RA[39:47]*/
+			pTcb->P_AID = (pTcb->P_AID << 1) | (RA[4] >> 7 );
+		} else {
+			pTcb->G_ID = 63;
+			pTcb->P_AID = 0;
+		}
+		/*RT_DISP(FBEAM, FBEAM_FUN, ("[David]@%s End, G_ID=0x%X, P_AID=0x%X\n", __func__, pTcb->G_ID, pTcb->P_AID));*/
+	}
+}
+
+
+RT_STATUS
+Beamforming_GetReportFrame(
+	IN	PADAPTER		Adapter,
+	IN	PRT_RFD			pRfd,
+	IN	POCTET_STRING	pPduOS
+	)
+{
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T					pDM_Odm = &pHalData->DM_OutSrc;
+	PRT_BEAMFORMEE_ENTRY		pBeamformEntry = NULL;
+	pu1Byte						pMIMOCtrlField, pCSIReport, pCSIMatrix;
+	u1Byte						Idx, Nc, Nr, CH_W;
+	u2Byte						CSIMatrixLen = 0;
+
+	ACT_PKT_TYPE				pktType = ACT_PKT_TYPE_UNKNOWN;
+
+	//Memory comparison to see if CSI report is the same with previous one
+	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, Frame_Addr2(*pPduOS), &Idx);
+
+	if (pBeamformEntry == NULL) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Beamforming_GetReportFrame: Cannot find entry by addr\n"));
+		return RT_STATUS_FAILURE;
+	}
+
+	pktType = PacketGetActionFrameType(pPduOS);
+	
+	//-@ Modified by David
+	if (pktType == ACT_PKT_VHT_COMPRESSED_BEAMFORMING) {
+		pMIMOCtrlField = pPduOS->Octet + 26; 
+		Nc = ((*pMIMOCtrlField) & 0x7) + 1;
+		Nr = (((*pMIMOCtrlField) & 0x38) >> 3) + 1;
+		CH_W =  (((*pMIMOCtrlField) & 0xC0) >> 6);
+		pCSIMatrix = pMIMOCtrlField + 3 + Nc; //24+(1+1+3)+2  MAC header+(Category+ActionCode+MIMOControlField) +SNR(Nc=2)
+		CSIMatrixLen = pPduOS->Length  - 26 -3 -Nc;
+	} else if (pktType == ACT_PKT_HT_COMPRESSED_BEAMFORMING) {
+		pMIMOCtrlField = pPduOS->Octet + 26; 
+		Nc = ((*pMIMOCtrlField) & 0x3) + 1;
+		Nr =  (((*pMIMOCtrlField) & 0xC) >> 2) + 1;
+		CH_W =  (((*pMIMOCtrlField) & 0x10) >> 4);
+		pCSIMatrix = pMIMOCtrlField + 6 + Nr;	//24+(1+1+6)+2  MAC header+(Category+ActionCode+MIMOControlField) +SNR(Nc=2)
+		CSIMatrixLen = pPduOS->Length  - 26 -6 -Nr;
+	} else
+		return RT_STATUS_SUCCESS;	
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] idx=%d, pkt type=%d, Nc=%d, Nr=%d, CH_W=%d\n", __func__, Idx, pktType, Nc, Nr, CH_W));		
+
+	return RT_STATUS_SUCCESS;
+}
+
+
+VOID
+ConstructHTNDPAPacket(
+	PADAPTER		Adapter,
+	pu1Byte			RA,
+	pu1Byte			Buffer,
+	pu4Byte			pLength,
+	CHANNEL_WIDTH	BW
+	)
+{
+	u2Byte					Duration= 0;
+	PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
+	OCTET_STRING			pNDPAFrame,ActionContent;
+	u1Byte					ActionHdr[4] = {ACT_CAT_VENDOR, 0x00, 0xe0, 0x4c};
+
+	PlatformZeroMemory(Buffer, 32);
+
+	SET_80211_HDR_FRAME_CONTROL(Buffer,0);
+
+	SET_80211_HDR_ORDER(Buffer, 1);
+	SET_80211_HDR_TYPE_AND_SUBTYPE(Buffer,Type_Action_No_Ack);
+
+	SET_80211_HDR_ADDRESS1(Buffer, RA);
+	SET_80211_HDR_ADDRESS2(Buffer, Adapter->CurrentAddress);
+	SET_80211_HDR_ADDRESS3(Buffer, pMgntInfo->Bssid);
+
+	Duration = 2*aSifsTime + 40;
+	
+	if (BW == CHANNEL_WIDTH_40)
+		Duration+= 87;
+	else	
+		Duration+= 180;
+
+	SET_80211_HDR_DURATION(Buffer, Duration);
+
+	//HT control field
+	SET_HT_CTRL_CSI_STEERING(Buffer+sMacHdrLng, 3);
+	SET_HT_CTRL_NDP_ANNOUNCEMENT(Buffer+sMacHdrLng, 1);
+	
+	FillOctetString(pNDPAFrame, Buffer, sMacHdrLng+sHTCLng);
+
+	FillOctetString(ActionContent, ActionHdr, 4);
+	PacketAppendData(&pNDPAFrame, ActionContent);	
+
+	*pLength = 32;
+}
+
+
+
+
+BOOLEAN
+SendFWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	PRT_TCB 				pTcb;
+	PRT_TX_LOCAL_BUFFER 	pBuf;
+	BOOLEAN 				ret = TRUE;
+	u4Byte					BufLen;
+	pu1Byte					BufAddr;
+	u1Byte					DescLen = 0, Idx = 0, NDPTxRate;
+	PADAPTER				pDefAdapter = GetDefaultAdapter(Adapter);
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pBeamformEntry == NULL)
+		return FALSE;
+
+	NDPTxRate = Beamforming_GetHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetFWBuffer(pDefAdapter, &pTcb, &pBuf)) {
+#if(DEV_BUS_TYPE != RT_PCI_INTERFACE)
+		DescLen = Adapter->HWDescHeadLength - pHalData->USBALLDummyLength;
+#endif
+		BufAddr = pBuf->Buffer.VirtualAddress + DescLen;
+
+		ConstructHTNDPAPacket(
+				Adapter, 
+				RA,
+				BufAddr, 
+				&BufLen,
+				BW
+				);
+
+		pTcb->PacketLength = BufLen + DescLen;
+
+		pTcb->bTxEnableSwCalcDur = TRUE;
+		
+		pTcb->BWOfPacket = BW;
+
+		if(ACTING_AS_IBSS(Adapter) || ACTING_AS_AP(Adapter))
+			pTcb->G_ID = 63;
+
+		pTcb->P_AID = pBeamformEntry->P_AID;
+		pTcb->DataRate = NDPTxRate;	/*rate of NDP decide by Nr*/
+
+		Adapter->HalFunc.CmdSendPacketHandler(Adapter, pTcb, pBuf, pTcb->PacketLength, DESC_PACKET_TYPE_NORMAL, FALSE);
+	} else
+		ret = FALSE;
+
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
+	
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+}
+
+
+BOOLEAN
+SendSWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	PRT_TCB					pTcb;
+	PRT_TX_LOCAL_BUFFER		pBuf;
+	BOOLEAN					ret = TRUE;
+	u1Byte					Idx = 0, NDPTxRate = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	NDPTxRate = Beamforming_GetHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+	
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetBuffer(Adapter, &pTcb, &pBuf)) {
+		ConstructHTNDPAPacket(
+				Adapter, 
+				RA,
+				pBuf->Buffer.VirtualAddress, 
+				&pTcb->PacketLength,
+				BW
+				);
+
+		pTcb->bTxEnableSwCalcDur = TRUE;
+
+		pTcb->BWOfPacket = BW;
+
+		MgntSendPacket(Adapter, pTcb, pBuf, pTcb->PacketLength, NORMAL_QUEUE, NDPTxRate);
+	} else
+		ret = FALSE;
+	
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+}
+
+
+
+VOID
+ConstructVHTNDPAPacket(
+	IN PDM_ODM_T	pDM_Odm,
+	pu1Byte			RA,
+	u2Byte			AID,
+	pu1Byte			Buffer,
+	pu4Byte			pLength,
+	CHANNEL_WIDTH	BW
+	)
+{
+	u2Byte					Duration= 0;
+	u1Byte					Sequence = 0;
+	pu1Byte					pNDPAFrame = Buffer;
+	RT_NDPA_STA_INFO		STAInfo;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	u1Byte	Idx = 0;
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+	// Frame control.
+	SET_80211_HDR_FRAME_CONTROL(pNDPAFrame, 0);
+	SET_80211_HDR_TYPE_AND_SUBTYPE(pNDPAFrame, Type_NDPA);
+
+	SET_80211_HDR_ADDRESS1(pNDPAFrame, RA);
+	SET_80211_HDR_ADDRESS2(pNDPAFrame, pBeamformEntry->MyMacAddr);
+
+	Duration = 2*aSifsTime + 44;
+	
+	if (BW == CHANNEL_WIDTH_80)
+		Duration += 40;
+	else if(BW == CHANNEL_WIDTH_40)
+		Duration+= 87;
+	else	
+		Duration+= 180;
+
+	SET_80211_HDR_DURATION(pNDPAFrame, Duration);
+
+	Sequence = *(pDM_Odm->pSoundingSeq) << 2;
+	ODM_MoveMemory(pDM_Odm, pNDPAFrame+16, &Sequence, 1);
+
+	if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS) || phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP) == FALSE)
+		AID = 0;
+
+	STAInfo.AID = AID;
+	STAInfo.FeedbackType = 0;
+	STAInfo.NcIndex = 0;
+	
+	ODM_MoveMemory(pDM_Odm, pNDPAFrame+17, (pu1Byte)&STAInfo, 2);
+
+	*pLength = 19;
+}
+
+
+BOOLEAN
+SendFWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	PRT_TCB					pTcb;
+	PRT_TX_LOCAL_BUFFER		pBuf;
+	BOOLEAN					ret = TRUE;
+	u4Byte					BufLen;
+	pu1Byte					BufAddr;
+	u1Byte					DescLen = 0, Idx = 0, NDPTxRate = 0;
+	PADAPTER				pDefAdapter = GetDefaultAdapter(Adapter);
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry =phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pBeamformEntry == NULL)
+		return FALSE;
+
+	NDPTxRate = Beamforming_GetVHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+	
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetFWBuffer(pDefAdapter, &pTcb, &pBuf)) {
+#if(DEV_BUS_TYPE != RT_PCI_INTERFACE)
+		DescLen = Adapter->HWDescHeadLength - pHalData->USBALLDummyLength;
+#endif
+		BufAddr = pBuf->Buffer.VirtualAddress + DescLen;
+
+		ConstructVHTNDPAPacket(
+				pDM_Odm, 
+				RA,
+				AID,
+				BufAddr, 
+				&BufLen,
+				BW
+				);
+		
+		pTcb->PacketLength = BufLen + DescLen;
+
+		pTcb->bTxEnableSwCalcDur = TRUE;
+		
+		pTcb->BWOfPacket = BW;
+
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS) || phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP))
+			pTcb->G_ID = 63;
+
+		pTcb->P_AID = pBeamformEntry->P_AID;
+		pTcb->DataRate = NDPTxRate;	/*decide by Nr*/
+
+		Adapter->HalFunc.CmdSendPacketHandler(Adapter, pTcb, pBuf, pTcb->PacketLength, DESC_PACKET_TYPE_NORMAL, FALSE);
+	} else
+		ret = FALSE;
+	
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);	
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End, ret=%d\n", __func__, ret));
+
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+}
+
+
+
+BOOLEAN
+SendSWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	PRT_TCB					pTcb;
+	PRT_TX_LOCAL_BUFFER		pBuf;
+	BOOLEAN					ret = TRUE;
+	u1Byte					Idx = 0, NDPTxRate = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	NDPTxRate = Beamforming_GetVHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetBuffer(Adapter, &pTcb, &pBuf)) {
+		ConstructVHTNDPAPacket(
+				pDM_Odm, 
+				RA,
+				AID,
+				pBuf->Buffer.VirtualAddress, 
+				&pTcb->PacketLength,
+				BW
+				);
+
+		pTcb->bTxEnableSwCalcDur = TRUE;
+		pTcb->BWOfPacket = BW;
+
+		/*rate of NDP decide by Nr*/
+		MgntSendPacket(Adapter, pTcb, pBuf, pTcb->PacketLength, NORMAL_QUEUE, NDPTxRate);
+	} else
+		ret = FALSE;
+	
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);	
+
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+}
+
+#ifdef SUPPORT_MU_BF
+#if (SUPPORT_MU_BF == 1)
+/*
+// Description: On VHT GID management frame by an MU beamformee.
+//
+// 2015.05.20. Created by tynli.
+*/
+RT_STATUS
+Beamforming_GetVHTGIDMgntFrame(
+	IN	PADAPTER		Adapter,
+	IN	PRT_RFD			pRfd,
+	IN	POCTET_STRING	pPduOS
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	RT_STATUS		rtStatus = RT_STATUS_SUCCESS;
+	pu1Byte			pBuffer = NULL;
+	pu1Byte			pRaddr = NULL;
+	u1Byte			MemStatus[8] = {0}, UserPos[16] = {0};
+	u1Byte			idx;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMER_ENTRY	pBeamformEntry = &pBeamInfo->BeamformerEntry[pBeamInfo->mu_ap_index];
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] On VHT GID mgnt frame!\n", __func__));		
+
+	/* Check length*/
+	if (pPduOS->Length < (FRAME_OFFSET_VHT_GID_MGNT_USER_POSITION_ARRAY+16)) {	
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Beamforming_GetVHTGIDMgntFrame(): Invalid length (%d)\n", pPduOS->Length));
+		return RT_STATUS_INVALID_LENGTH;
+	}
+
+	/* Check RA*/
+	pRaddr = (pu1Byte)(pPduOS->Octet)+4;
+	if (!eqMacAddr(pRaddr, Adapter->CurrentAddress)) {		
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Beamforming_GetVHTGIDMgntFrame(): Drop because of RA error.\n"));
+		return RT_STATUS_PKT_DROP;
+	}
+
+	RT_DISP_DATA(FBEAM, FBEAM_DATA, "On VHT GID Mgnt Frame ==>:\n", pPduOS->Octet, pPduOS->Length);
+
+	/*Parsing Membership Status Array*/
+	pBuffer = pPduOS->Octet + FRAME_OFFSET_VHT_GID_MGNT_MEMBERSHIP_STATUS_ARRAY;
+	for (idx = 0; idx < 8; idx++) {
+		MemStatus[idx] = GET_VHT_GID_MGNT_INFO_MEMBERSHIP_STATUS(pBuffer+idx);
+		pBeamformEntry->gid_valid[idx] = GET_VHT_GID_MGNT_INFO_MEMBERSHIP_STATUS(pBuffer+idx);
+	}
+
+	RT_DISP_DATA(FBEAM, FBEAM_DATA, "MemStatus: ", MemStatus, 8);
+
+	/* Parsing User Position Array*/
+	pBuffer = pPduOS->Octet + FRAME_OFFSET_VHT_GID_MGNT_USER_POSITION_ARRAY;
+	for (idx = 0; idx < 16; idx++) {
+		UserPos[idx] = GET_VHT_GID_MGNT_INFO_USER_POSITION(pBuffer+idx);
+		pBeamformEntry->user_position[idx] = GET_VHT_GID_MGNT_INFO_USER_POSITION(pBuffer+idx);
+	}
+
+	RT_DISP_DATA(FBEAM, FBEAM_DATA, "UserPos: ", UserPos, 16);
+
+	/* Group ID detail printed*/
+	{
+		u1Byte	i, j;
+		u1Byte	tmpVal;
+		u2Byte	tmpVal2;
+
+		for (i = 0; i < 8; i++) {
+			tmpVal = MemStatus[i];
+			tmpVal2 = ((UserPos[i*2 + 1] << 8) & 0xFF00) + (UserPos[i * 2] & 0xFF);
+			for (j = 0; j < 8; j++) {
+				if ((tmpVal >> j) & BIT0) {
+					ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("Use Group ID (%d), User Position (%d)\n",
+						(i*8+j), (tmpVal2 >> 2 * j)&0x3));
+				}
+			}
+		}
+	}
+
+	/* Indicate GID frame to IHV service. */
+	{
+		u1Byte	Indibuffer[24] = {0};
+		u1Byte	Indioffset = 0;
+			
+		PlatformMoveMemory(Indibuffer + Indioffset, pBeamformEntry->gid_valid, 8);
+		Indioffset += 8;
+		PlatformMoveMemory(Indibuffer + Indioffset, pBeamformEntry->user_position, 16);
+		Indioffset += 16;
+
+		PlatformIndicateCustomStatus(
+			Adapter,
+			RT_CUSTOM_EVENT_VHT_RECV_GID_MGNT_FRAME,
+			RT_CUSTOM_INDI_TARGET_IHV,
+			Indibuffer,
+			Indioffset);
+	}
+
+	/* Config HW GID table */
+	halComTxbf_ConfigGtab(pDM_Odm);
+
+	return rtStatus;
+}
+
+/*
+// Description: Construct VHT Group ID (GID) management frame.
+//
+// 2015.05.20. Created by tynli.
+*/
+VOID
+ConstructVHTGIDMgntFrame(
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	pu1Byte			RA,
+	IN	PRT_BEAMFORMEE_ENTRY	pBeamformEntry,
+	OUT	pu1Byte			Buffer,
+	OUT	pu4Byte			pLength
+	
+)
+{
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PADAPTER				Adapter = pBeamInfo->SourceAdapter;
+	OCTET_STRING		osFTMFrame, tmp;
+
+	FillOctetString(osFTMFrame, Buffer, 0);
+	*pLength = 0;
+
+	ConstructMaFrameHdr(
+					Adapter, 
+					RA, 
+					ACT_CAT_VHT, 
+					ACT_VHT_GROUPID_MANAGEMENT, 
+					&osFTMFrame);
+
+	/* Membership Status Array*/
+	FillOctetString(tmp, pBeamformEntry->gid_valid, 8);
+	PacketAppendData(&osFTMFrame, tmp);
+
+	/* User Position Array*/
+	FillOctetString(tmp, pBeamformEntry->user_position, 16);
+	PacketAppendData(&osFTMFrame, tmp);
+
+	*pLength = osFTMFrame.Length;
+
+	RT_DISP_DATA(FBEAM, FBEAM_DATA, "ConstructVHTGIDMgntFrame():\n", Buffer, *pLength);
+}
+
+BOOLEAN
+SendSWVHTGIDMgntFrame(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u1Byte			Idx
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_TCB					pTcb;
+	PRT_TX_LOCAL_BUFFER		pBuf;
+	BOOLEAN					ret = TRUE;
+	u1Byte					DataRate = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = &pBeamInfo->BeamformeeEntry[Idx];
+	PADAPTER				Adapter = pBeamInfo->SourceAdapter;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+	
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetBuffer(Adapter, &pTcb, &pBuf)) {
+		ConstructVHTGIDMgntFrame(
+				pDM_Odm, 
+				RA,
+				pBeamformEntry,
+				pBuf->Buffer.VirtualAddress, 
+				&pTcb->PacketLength
+				);
+
+		pTcb->BWOfPacket = CHANNEL_WIDTH_20;
+		DataRate = MGN_6M;
+		MgntSendPacket(Adapter, pTcb, pBuf, pTcb->PacketLength, NORMAL_QUEUE, DataRate);
+	} else
+		ret = FALSE;
+	
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+}
+
+
+/*
+// Description: Construct VHT beamforming report poll.
+//
+// 2015.05.20. Created by tynli.
+*/
+VOID
+ConstructVHTBFReportPoll(
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	pu1Byte			RA,
+	OUT	pu1Byte			Buffer,
+	OUT	pu4Byte			pLength
+)
+{
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PADAPTER				Adapter = pBeamInfo->SourceAdapter;
+	pu1Byte			pBFRptPoll = Buffer;
+	
+	/* Frame control*/
+	SET_80211_HDR_FRAME_CONTROL(pBFRptPoll, 0);
+	SET_80211_HDR_TYPE_AND_SUBTYPE(pBFRptPoll, Type_Beamforming_Report_Poll);
+
+	/* Duration*/	
+	SET_80211_HDR_DURATION(pBFRptPoll, 100);
+
+	/* RA*/
+	SET_VHT_BF_REPORT_POLL_RA(pBFRptPoll, RA);
+
+	/* TA*/
+	SET_VHT_BF_REPORT_POLL_TA(pBFRptPoll, Adapter->CurrentAddress);
+
+	/* Feedback Segment Retransmission Bitmap*/
+	SET_VHT_BF_REPORT_POLL_FEEDBACK_SEG_RETRAN_BITMAP(pBFRptPoll, 0xFF);
+
+	*pLength = 17;
+
+	RT_DISP_DATA(FBEAM, FBEAM_DATA, "ConstructVHTBFReportPoll():\n", Buffer, *pLength);
+
+}
+
+BOOLEAN
+SendSWVHTBFReportPoll(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	BOOLEAN			bFinalPoll
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_TCB					pTcb;
+	PRT_TX_LOCAL_BUFFER		pBuf;
+	BOOLEAN					ret = TRUE;
+	u1Byte					Idx = 0, DataRate = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+	PADAPTER				Adapter = pBeamInfo->SourceAdapter;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetBuffer(Adapter, &pTcb, &pBuf)) {
+		ConstructVHTBFReportPoll(
+				pDM_Odm, 
+				RA,
+				pBuf->Buffer.VirtualAddress, 
+				&pTcb->PacketLength
+				);
+
+		pTcb->bTxEnableSwCalcDur = TRUE; /* <tynli_note> need?*/
+		pTcb->BWOfPacket = CHANNEL_WIDTH_20;
+
+		if (bFinalPoll)
+			pTcb->TxBFPktType = RT_BF_PKT_TYPE_FINAL_BF_REPORT_POLL;
+		else
+			pTcb->TxBFPktType = RT_BF_PKT_TYPE_BF_REPORT_POLL;
+		
+		DataRate = MGN_6M;	/* Legacy OFDM rate*/
+		MgntSendPacket(Adapter, pTcb, pBuf, pTcb->PacketLength, NORMAL_QUEUE, DataRate);
+	} else
+		ret = FALSE;
+	
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "SendSWVHTBFReportPoll():\n", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+
+}
+
+
+/*
+// Description: Construct VHT MU NDPA packet.
+//	<Note> We should combine this function with ConstructVHTNDPAPacket() in the future.
+//
+// 2015.05.21. Created by tynli.
+*/
+VOID
+ConstructVHTMUNDPAPacket(
+	IN PDM_ODM_T		pDM_Odm,
+	IN CHANNEL_WIDTH	BW,
+	OUT pu1Byte			Buffer,
+	OUT pu4Byte			pLength
+	)
+{	
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PADAPTER				Adapter = pBeamInfo->SourceAdapter;
+	u2Byte					Duration = 0;
+	u1Byte					Sequence = 0;
+	pu1Byte					pNDPAFrame = Buffer;
+	RT_NDPA_STA_INFO		STAInfo;
+	u1Byte					idx;
+	u1Byte					DestAddr[6] = {0};
+	PRT_BEAMFORMEE_ENTRY	pEntry = NULL;
+
+	/* Fill the first MU BFee entry (STA1) MAC addr to destination address then
+	     HW will change A1 to broadcast addr. 2015.05.28. Suggested by SD1 Chunchu. */
+	for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {		
+		pEntry = &(pBeamInfo->BeamformeeEntry[idx]);
+		if (pEntry->is_mu_sta) {
+			cpMacAddr(DestAddr, pEntry->MacAddr);
+			break;
+		}
+	}
+	if (pEntry == NULL)
+		return;
+
+	/* Frame control.*/
+	SET_80211_HDR_FRAME_CONTROL(pNDPAFrame, 0);
+	SET_80211_HDR_TYPE_AND_SUBTYPE(pNDPAFrame, Type_NDPA);
+
+	SET_80211_HDR_ADDRESS1(pNDPAFrame, DestAddr);
+	SET_80211_HDR_ADDRESS2(pNDPAFrame, pEntry->MyMacAddr);
+
+	/*--------------------------------------------*/
+	/* <Note> Need to modify "Duration" to MU consideration. */
+	Duration = 2*aSifsTime + 44;
+	
+	if (BW == CHANNEL_WIDTH_80)
+		Duration += 40;
+	else if(BW == CHANNEL_WIDTH_40)
+		Duration+= 87;
+	else	
+		Duration+= 180;
+	/*--------------------------------------------*/
+
+	SET_80211_HDR_DURATION(pNDPAFrame, Duration);
+
+	Sequence = *(pDM_Odm->pSoundingSeq) << 2;
+	ODM_MoveMemory(pDM_Odm, pNDPAFrame + 16, &Sequence, 1);
+
+	*pLength = 17;
+
+	/* Construct STA info. for multiple STAs*/
+	for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {		
+		pEntry = &(pBeamInfo->BeamformeeEntry[idx]);
+		if (pEntry->is_mu_sta) {
+			STAInfo.AID = pEntry->AID;
+			STAInfo.FeedbackType = 1; /* 1'b1: MU*/
+			STAInfo.NcIndex = 0;
+
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Get BeamformeeEntry idx(%d), AID =%d\n", __func__, idx, pEntry->AID));
+			
+			ODM_MoveMemory(pDM_Odm, pNDPAFrame+(*pLength), (pu1Byte)&STAInfo, 2);
+			*pLength += 2;
+		}
+	}
+
+}
+
+BOOLEAN
+SendSWVHTMUNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_TCB					pTcb;
+	PRT_TX_LOCAL_BUFFER		pBuf;
+	BOOLEAN					ret = TRUE;
+	u1Byte					NDPTxRate = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PADAPTER				Adapter = pBeamInfo->SourceAdapter;
+
+	NDPTxRate = MGN_VHT2SS_MCS0;
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+
+	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
+
+	if (MgntGetBuffer(Adapter, &pTcb, &pBuf)) {
+		ConstructVHTMUNDPAPacket(
+				pDM_Odm,
+				BW,
+				pBuf->Buffer.VirtualAddress, 
+				&pTcb->PacketLength
+				);
+
+		pTcb->bTxEnableSwCalcDur = TRUE;
+		pTcb->BWOfPacket = BW;
+		pTcb->TxBFPktType = RT_BF_PKT_TYPE_BROADCAST_NDPA;
+
+		/*rate of NDP decide by Nr*/
+		MgntSendPacket(Adapter, pTcb, pBuf, pTcb->PacketLength, NORMAL_QUEUE, NDPTxRate);
+	} else
+		ret = FALSE;
+	
+	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);	
+
+	if (ret)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "", pBuf->Buffer.VirtualAddress, pTcb->PacketLength);
+
+	return ret;
+}
+
+#endif	/*#if (SUPPORT_MU_BF == 1)*/
+#endif	/*#ifdef SUPPORT_MU_BF*/
+
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+u4Byte
+Beamforming_GetReportFrame(
+	IN	PVOID			pDM_VOID,
+	union recv_frame *precv_frame
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte					ret = _SUCCESS;
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = NULL;
+	pu1Byte					pframe = precv_frame->u.hdr.rx_data;
+	u4Byte					frame_len = precv_frame->u.hdr.len;
+	pu1Byte					TA;
+	u1Byte					Idx, offset;
+	
+	/*DBG_871X("beamforming_get_report_frame\n");*/
+
+	/*Memory comparison to see if CSI report is the same with previous one*/
+	TA = GetAddr2Ptr(pframe);
+	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, TA, &Idx);
+	if(pBeamformEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
+		offset = 31;		/*24+(1+1+3)+2  MAC header+(Category+ActionCode+MIMOControlField)+SNR(Nc=2)*/
+	else if(pBeamformEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)
+		offset = 34;		/*24+(1+1+6)+2  MAC header+(Category+ActionCode+MIMOControlField)+SNR(Nc=2)*/
+	else
+		return ret;
+
+	/*DBG_871X("%s MacId %d offset=%d\n", __FUNCTION__, pBeamformEntry->mac_id, offset);*/
+	
+	return ret;
+}
+
+
+BOOLEAN
+SendFWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	struct xmit_frame		*pmgntframe;
+	struct pkt_attrib		*pattrib;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u1Byte	ActionHdr[4] = {ACT_CAT_VENDOR, 0x00, 0xe0, 0x4c};
+	u1Byte	*pframe;
+	u2Byte	*fctrl;
+	u2Byte	duration = 0;
+	u1Byte	aSifsTime = 0, NDPTxRate = 0, Idx = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	
+	if (pmgntframe == NULL) {
+		DBG_871X("%s, alloc mgnt frame fail\n", __func__);
+		return _FALSE;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(Adapter, pattrib);
+
+	pattrib->qsel = QSLT_BEACON;
+	NDPTxRate = Beamforming_GetHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+	pattrib->rate = NDPTxRate;
+	pattrib->bwmode = BW;
+	pattrib->order = 1;
+	pattrib->subtype = WIFI_ACTION_NOACK;
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	pwlanhdr = (struct rtw_ieee80211_hdr*)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+
+	SetOrderBit(pframe);
+	SetFrameSubType(pframe, WIFI_ACTION_NOACK);
+
+	_rtw_memcpy(pwlanhdr->addr1, RA, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, pBeamformEntry->MyMacAddr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	if( pmlmeext->cur_wireless_mode == WIRELESS_11B)
+		aSifsTime = 10;
+	else
+		aSifsTime = 16;
+
+	duration = 2*aSifsTime + 40;
+	
+	if(BW == CHANNEL_WIDTH_40)
+		duration+= 87;
+	else	
+		duration+= 180;
+
+	SetDuration(pframe, duration);
+
+	//HT control field
+	SET_HT_CTRL_CSI_STEERING(pframe+24, 3);
+	SET_HT_CTRL_NDP_ANNOUNCEMENT(pframe+24, 1);
+
+	_rtw_memcpy(pframe+28, ActionHdr, 4);
+
+	pattrib->pktlen = 32;
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(Adapter, pmgntframe);
+
+	return _TRUE;
+}
+
+
+BOOLEAN
+SendSWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	struct xmit_frame		*pmgntframe;
+	struct pkt_attrib		*pattrib;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u1Byte	ActionHdr[4] = {ACT_CAT_VENDOR, 0x00, 0xe0, 0x4c};
+	pu1Byte	pframe;
+	pu2Byte	fctrl;
+	u2Byte	duration = 0;
+	u1Byte	aSifsTime = 0, NDPTxRate = 0, Idx = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	NDPTxRate = Beamforming_GetHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	
+	if (pmgntframe == NULL) {
+		DBG_871X("%s, alloc mgnt frame fail\n", __func__);
+		return _FALSE;
+	}
+
+	/*update attribute*/
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(Adapter, pattrib);
+	pattrib->qsel = QSLT_MGNT;
+	pattrib->rate = NDPTxRate;
+	pattrib->bwmode = BW;
+	pattrib->order = 1;
+	pattrib->subtype = WIFI_ACTION_NOACK;
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+
+	SetOrderBit(pframe);
+	SetFrameSubType(pframe, WIFI_ACTION_NOACK);
+
+	_rtw_memcpy(pwlanhdr->addr1, RA, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, pBeamformEntry->MyMacAddr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	if (pmlmeext->cur_wireless_mode == WIRELESS_11B)
+		aSifsTime = 10;
+	else
+		aSifsTime = 16;
+
+	duration = 2*aSifsTime + 40;
+	
+	if (BW == CHANNEL_WIDTH_40)
+		duration += 87;
+	else	
+		duration += 180;
+
+	SetDuration(pframe, duration);
+
+	/*HT control field*/
+	SET_HT_CTRL_CSI_STEERING(pframe+24, 3);
+	SET_HT_CTRL_NDP_ANNOUNCEMENT(pframe+24, 1);
+
+	_rtw_memcpy(pframe+28, ActionHdr, 4);
+
+	pattrib->pktlen = 32;
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(Adapter, pmgntframe);
+
+	return _TRUE;
+}
+
+
+BOOLEAN
+SendFWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	struct xmit_frame		*pmgntframe;
+	struct pkt_attrib		*pattrib;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv		*pmlmepriv = &(Adapter->mlmepriv);
+	pu1Byte	pframe;
+	pu2Byte	fctrl;
+	u2Byte	duration = 0;
+	u1Byte	sequence = 0, aSifsTime = 0, NDPTxRate= 0, Idx = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+	RT_NDPA_STA_INFO	sta_info;
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	
+	if (pmgntframe == NULL) {
+		DBG_871X("%s, alloc mgnt frame fail\n", __func__);
+		return _FALSE;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	_rtw_memcpy(pattrib->ra, RA, ETH_ALEN);
+	update_mgntframe_attrib(Adapter, pattrib);
+
+	pattrib->qsel = QSLT_BEACON;
+	NDPTxRate = Beamforming_GetVHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+	pattrib->rate = NDPTxRate;
+	pattrib->bwmode = BW;
+	pattrib->subtype = WIFI_NDPA;
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	pwlanhdr = (struct rtw_ieee80211_hdr*)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+
+	SetFrameSubType(pframe, WIFI_NDPA);
+
+	_rtw_memcpy(pwlanhdr->addr1, RA, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, pBeamformEntry->MyMacAddr, ETH_ALEN);
+
+	if (IsSupported5G(pmlmeext->cur_wireless_mode) || IsSupportedHT(pmlmeext->cur_wireless_mode))
+		aSifsTime = 16;
+	else
+		aSifsTime = 10;
+
+	duration = 2*aSifsTime + 44;
+	
+	if(BW == CHANNEL_WIDTH_80)
+		duration += 40;
+	else if(BW == CHANNEL_WIDTH_40)
+		duration+= 87;
+	else	
+		duration+= 180;
+
+	SetDuration(pframe, duration);
+
+	sequence = pBeamInfo->SoundingSequence<< 2;
+	if (pBeamInfo->SoundingSequence >= 0x3f)
+		pBeamInfo->SoundingSequence = 0;
+	else
+		pBeamInfo->SoundingSequence++;
+
+	_rtw_memcpy(pframe+16, &sequence,1);
+
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+		AID = 0;		
+
+	sta_info.AID = AID;
+	sta_info.FeedbackType = 0;
+	sta_info.NcIndex= 0;
+	
+	_rtw_memcpy(pframe+17, (u8 *)&sta_info, 2);
+
+	pattrib->pktlen = 19;
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(Adapter, pmgntframe);
+
+	return _TRUE;
+}
+
+
+
+BOOLEAN
+SendSWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				Adapter = pDM_Odm->Adapter;
+	struct xmit_frame		*pmgntframe;
+	struct pkt_attrib		*pattrib;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv		*pmlmepriv = &(Adapter->mlmepriv);
+	RT_NDPA_STA_INFO	ndpa_sta_info;
+	u1Byte	NDPTxRate = 0, sequence = 0, aSifsTime = 0, Idx = 0;
+	pu1Byte	pframe;
+	pu2Byte	fctrl;
+	u2Byte	duration = 0;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
+	PRT_BEAMFORMEE_ENTRY	pBeamformEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
+
+	NDPTxRate = Beamforming_GetVHTNDPTxRate(pDM_Odm, pBeamformEntry->CompSteeringNumofBFer);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] NDPTxRate =%d\n", __func__, NDPTxRate));
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	
+	if (pmgntframe == NULL) {
+		DBG_871X("%s, alloc mgnt frame fail\n", __func__);
+		return _FALSE;
+	}
+	
+	/*update attribute*/
+	pattrib = &pmgntframe->attrib;
+	_rtw_memcpy(pattrib->ra, RA, ETH_ALEN);
+	update_mgntframe_attrib(Adapter, pattrib);
+	pattrib->qsel = QSLT_MGNT;
+	pattrib->rate = NDPTxRate;
+	pattrib->bwmode = BW;
+	pattrib->subtype = WIFI_NDPA;
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+
+	SetFrameSubType(pframe, WIFI_NDPA);
+
+	_rtw_memcpy(pwlanhdr->addr1, RA, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, pBeamformEntry->MyMacAddr, ETH_ALEN);
+
+	if (IsSupported5G(pmlmeext->cur_wireless_mode) || IsSupportedHT(pmlmeext->cur_wireless_mode))
+		aSifsTime = 16;
+	else
+		aSifsTime = 10;
+
+	duration = 2*aSifsTime + 44;
+	
+	if (BW == CHANNEL_WIDTH_80)
+		duration += 40;
+	else if (BW == CHANNEL_WIDTH_40)
+		duration += 87;
+	else	
+		duration += 180;
+
+	SetDuration(pframe, duration);
+	
+	sequence = pBeamInfo->SoundingSequence << 2;
+	if (pBeamInfo->SoundingSequence >= 0x3f)
+		pBeamInfo->SoundingSequence = 0;
+	else
+		pBeamInfo->SoundingSequence++;
+
+	_rtw_memcpy(pframe+16, &sequence, 1);
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+		AID = 0;		
+
+	ndpa_sta_info.AID = AID;
+	ndpa_sta_info.FeedbackType = 0;
+	ndpa_sta_info.NcIndex = 0;
+	
+	_rtw_memcpy(pframe+17, (u8 *)&ndpa_sta_info, 2);
+
+	pattrib->pktlen = 19;
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(Adapter, pmgntframe);
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] [%d]\n", __func__, __LINE__));
+	
+	return _TRUE;
+}
+
+
+#endif
+
+
+VOID
+Beamforming_GetNDPAFrame(
+	IN	PVOID			pDM_VOID,
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	OCTET_STRING	pduOS
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	union recv_frame *precv_frame
+#endif
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	pu1Byte						TA ;
+	u1Byte						Idx, Sequence;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	pu1Byte						pNDPAFrame = pduOS.Octet;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pu1Byte						pNDPAFrame = precv_frame->u.hdr.rx_data;
+#endif
+	PRT_BEAMFORMER_ENTRY		pBeamformerEntry = NULL;		/*Modified By Jeffery @2014-10-29*/
+	
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		RT_DISP_DATA(FBEAM, FBEAM_DATA, "Beamforming_GetNDPAFrame\n", pduOS.Octet, pduOS.Length);
+	if (IsCtrlNDPA(pNDPAFrame) == FALSE)
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if (GetFrameSubType(pNDPAFrame) != WIFI_NDPA)
+#endif
+		return;
+	else if (!(pDM_Odm->SupportICType & (ODM_RTL8812 | ODM_RTL8821))) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] not 8812 or 8821A, return\n", __func__));
+		return;
+	}
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	TA = Frame_Addr2(pduOS);
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	TA = GetAddr2Ptr(pNDPAFrame);
+#endif
+	/*Remove signaling TA. */
+	TA[0] = TA[0] & 0xFE;
+    
+	pBeamformerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, TA, &Idx);		// Modified By Jeffery @2014-10-29
+
+	/*Break options for Clock Reset*/    
+	if (pBeamformerEntry == NULL)
+		return;
+	else if (!(pBeamformerEntry->BeamformEntryCap & BEAMFORMEE_CAP_VHT_SU))
+		return;
+	/*LogSuccess: As long as 8812A receive NDPA and feedback CSI succeed once, clock reset is NO LONGER needed !2015-04-10, Jeffery*/
+	/*ClockResetTimes: While BFer entry always doesn't receive our CSI, clock will reset again and again.So ClockResetTimes is limited to 5 times.2015-04-13, Jeffery*/
+	else if ((pBeamformerEntry->LogSuccess == 1) || (pBeamformerEntry->ClockResetTimes == 5)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] LogSeq=%d, PreLogSeq=%d, LogRetryCnt=%d, LogSuccess=%d, ClockResetTimes=%d, clock reset is no longer needed.\n", 
+			__func__, pBeamformerEntry->LogSeq, pBeamformerEntry->PreLogSeq, pBeamformerEntry->LogRetryCnt, pBeamformerEntry->LogSuccess, pBeamformerEntry->ClockResetTimes));
+
+        return;
+	}
+
+	Sequence = (pNDPAFrame[16]) >> 2;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start, Sequence=%d, LogSeq=%d, PreLogSeq=%d, LogRetryCnt=%d, ClockResetTimes=%d, LogSuccess=%d\n", 
+		__func__, Sequence, pBeamformerEntry->LogSeq, pBeamformerEntry->PreLogSeq, pBeamformerEntry->LogRetryCnt, pBeamformerEntry->ClockResetTimes, pBeamformerEntry->LogSuccess));
+
+	if ((pBeamformerEntry->LogSeq != 0) && (pBeamformerEntry->PreLogSeq != 0)) {
+		/*Success condition*/
+		if ((pBeamformerEntry->LogSeq != Sequence) && (pBeamformerEntry->PreLogSeq != pBeamformerEntry->LogSeq)) {
+			/* break option for clcok reset, 2015-03-30, Jeffery */
+			pBeamformerEntry->LogRetryCnt = 0;
+			/*As long as 8812A receive NDPA and feedback CSI succeed once, clock reset is no longer needed.*/
+			/*That is, LogSuccess is NOT needed to be reset to zero, 2015-04-13, Jeffery*/
+			pBeamformerEntry->LogSuccess = 1;
+
+		} else {/*Fail condition*/
+
+			if (pBeamformerEntry->LogRetryCnt == 5) {
+				pBeamformerEntry->ClockResetTimes++;
+				pBeamformerEntry->LogRetryCnt = 0;
+
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Clock Reset!!! ClockResetTimes=%d\n", 
+				__func__, pBeamformerEntry->ClockResetTimes));
+			HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_CLK, NULL);
+
+			} else
+				pBeamformerEntry->LogRetryCnt++;
+		}
+	}
+
+	/*Update LogSeq & PreLogSeq*/
+	pBeamformerEntry->PreLogSeq = pBeamformerEntry->LogSeq;
+	pBeamformerEntry->LogSeq = Sequence;
+	
+}
+
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.h
new file mode 100644
index 000000000..18c8edb96
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfinterface.h
@@ -0,0 +1,158 @@
+#ifndef __HAL_TXBF_INTERFACE_H__
+#define __HAL_TXBF_INTERFACE_H__
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+Beamforming_GidPAid(
+	PADAPTER	Adapter,
+	PRT_TCB		pTcb
+	);
+
+RT_STATUS
+Beamforming_GetReportFrame(
+	IN	PADAPTER		Adapter,
+	IN	PRT_RFD			pRfd,
+	IN	POCTET_STRING	pPduOS
+	);
+
+VOID
+Beamforming_GetNDPAFrame(
+	IN	PVOID			pDM_VOID,
+	IN	OCTET_STRING	pduOS
+	);
+
+BOOLEAN
+SendFWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+BOOLEAN
+SendFWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+BOOLEAN
+SendSWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+BOOLEAN
+SendSWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+#ifdef SUPPORT_MU_BF
+#if (SUPPORT_MU_BF == 1)
+RT_STATUS
+Beamforming_GetVHTGIDMgntFrame(
+	IN	PADAPTER		Adapter,
+	IN	PRT_RFD			pRfd,
+	IN	POCTET_STRING	pPduOS
+	);
+
+BOOLEAN
+SendSWVHTGIDMgntFrame(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u1Byte			Idx
+	);
+
+BOOLEAN
+SendSWVHTBFReportPoll(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	BOOLEAN			bFinalPoll
+	);
+
+BOOLEAN
+SendSWVHTMUNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	CHANNEL_WIDTH	BW
+	);
+#else
+#define Beamforming_GetVHTGIDMgntFrame(Adapter, pRfd, pPduOS) RT_STATUS_FAILURE
+#define SendSWVHTGIDMgntFrame(pDM_VOID, RA)
+#define SendSWVHTBFReportPoll(pDM_VOID, RA, bFinalPoll)
+#define SendSWVHTMUNDPAPacket(pDM_VOID, BW)
+#endif
+#endif
+
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+u4Byte
+Beamforming_GetReportFrame(
+	IN	PVOID			pDM_VOID,
+	union recv_frame *precv_frame
+	);
+
+BOOLEAN
+SendFWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+BOOLEAN
+SendSWHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+BOOLEAN
+SendFWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	);
+
+BOOLEAN
+SendSWVHTNDPAPacket(
+	IN	PVOID			pDM_VOID,
+	IN	pu1Byte			RA,
+	IN	u2Byte			AID,
+	IN	CHANNEL_WIDTH	BW
+	);
+#endif
+
+VOID
+Beamforming_GetNDPAFrame(
+	IN	PVOID			pDM_VOID,
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	IN	OCTET_STRING	pduOS
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	union recv_frame *precv_frame
+#endif
+);
+
+#else
+#define Beamforming_GetNDPAFrame(pDM_Odm, _PduOS)
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#define Beamforming_GetReportFrame(Adapter, precv_frame)		RT_STATUS_FAILURE
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#define Beamforming_GetReportFrame(Adapter, pRfd, pPduOS)		RT_STATUS_FAILURE
+#define Beamforming_GetVHTGIDMgntFrame(Adapter, pRfd, pPduOS) RT_STATUS_FAILURE
+#endif
+#define SendFWHTNDPAPacket(pDM_VOID, RA, BW)
+#define SendSWHTNDPAPacket(pDM_VOID, RA, BW)
+#define SendFWVHTNDPAPacket(pDM_VOID, RA, AID, BW)
+#define SendSWVHTNDPAPacket(pDM_VOID, RA,	AID, BW)
+#define SendSWVHTGIDMgntFrame(pDM_VOID, RA, idx)
+#define SendSWVHTBFReportPoll(pDM_VOID, RA, bFinalPoll)
+#define SendSWVHTMUNDPAPacket(pDM_VOID, BW)
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.c b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.c
new file mode 100644
index 000000000..b34e851cd
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.c
@@ -0,0 +1,527 @@
+//============================================================
+// Description:
+//
+// This file is for 8812/8821/8811 TXBF mechanism
+//
+//============================================================
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if ((RTL8812A_SUPPORT == 1) || (RTL8821A_SUPPORT == 1))
+VOID
+HalTxbf8812A_setNDPArate(
+	IN PVOID			pDM_VOID,
+	IN u1Byte	BW,
+	IN u1Byte	Rate
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8812A,  (Rate << 2 | BW));	
+
+}
+
+VOID
+halTxbfJaguar_RfMode(
+	IN PVOID			pDM_VOID,
+	IN PRT_BEAMFORMING_INFO	pBeamInfo
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (pDM_Odm->RFType == ODM_1T1R)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] set TxIQGen\n", __func__));
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WeLut_Jaguar, 0x80000, 0x1);	/*RF Mode table write enable*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_WeLut_Jaguar, 0x80000, 0x1);	/*RF Mode table write enable*/
+
+	if (pBeamInfo->beamformee_su_cnt > 0) {
+		// Paath_A
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0xE26BF);	/*Enable TXIQGEN in RX mode*/
+		// Path_B
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData1, 0xfffff, 0xE26BF);	/*Enable TXIQGEN in RX mode*/
+	} else {
+		// Paath_A
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_ModeTableData1, 0xfffff, 0xC26BF);	/*Disable TXIQGEN in RX mode*/
+		// Path_B
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableAddr, 0x78000, 0x3);		/*Select RX mode*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData0, 0xfffff, 0x3F7FF);	/*Set Table data*/
+		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_ModeTableData1, 0xfffff, 0xC26BF);	/*Disable TXIQGEN in RX mode*/
+	}
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WeLut_Jaguar, 0x80000, 0x0);	/*RF Mode table write disable*/
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_WeLut_Jaguar, 0x80000, 0x0);	/*RF Mode table write disable*/
+
+	if (pBeamInfo->beamformee_su_cnt > 0)
+		ODM_SetBBReg(pDM_Odm, rTxPath_Jaguar, bMaskByte1, 0x33);
+	else
+		ODM_SetBBReg(pDM_Odm, rTxPath_Jaguar, bMaskByte1, 0x11);
+}
+
+
+VOID
+halTxbfJaguar_DownloadNDPA(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			u1bTmp = 0, tmpReg422 = 0, Head_Page;
+	u1Byte			BcnValidReg = 0, count = 0, DLBcnCount = 0;
+	BOOLEAN			bSendBeacon = FALSE;
+	u1Byte			TxPageBndy = LAST_ENTRY_OF_TX_PKT_BUFFER_8812;	/*default reseved 1 page for the IC type which is undefined.*/
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	*pDM_Odm->pbFwDwRsvdPageInProgress = TRUE;
+#endif
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (Idx == 0)
+		Head_Page = 0xFE;
+	else
+		Head_Page = 0xFE;
+
+	Adapter->HalFunc.GetHalDefVarHandler(Adapter, HAL_DEF_TX_PAGE_BOUNDARY, (pu1Byte)&TxPageBndy);
+
+	/*Set REG_CR bit 8. DMA beacon by SW.*/
+	u1bTmp = ODM_Read1Byte(pDM_Odm, REG_CR_8812A + 1);
+	ODM_Write1Byte(pDM_Odm,  REG_CR_8812A + 1, (u1bTmp | BIT0));
+
+
+	/*Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.*/
+	tmpReg422 = ODM_Read1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8812A + 2);
+	ODM_Write1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8812A + 2,  tmpReg422 & (~BIT6));
+
+	if (tmpReg422 & BIT6) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("SetBeamformDownloadNDPA_8812(): There is an Adapter is sending beacon.\n"));
+		bSendBeacon = TRUE;
+	}
+
+	/*TDECTRL[15:8] 0x209[7:0] = 0xF6	Beacon Head for TXDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 1, Head_Page);
+
+	do {
+		/*Clear beacon valid check bit.*/
+		BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_TDECTRL_8812A + 2);
+		ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 2, (BcnValidReg | BIT0));
+
+		/*download NDPA rsvd page.*/
+		if (pBeamEntry->BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
+			Beamforming_SendVHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->AID, pBeamEntry->SoundBW, BEACON_QUEUE);
+		else
+			Beamforming_SendHTNDPAPacket(pDM_Odm, pBeamEntry->MacAddr, pBeamEntry->SoundBW, BEACON_QUEUE);
+
+		/*check rsvd page download OK.*/
+		BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_TDECTRL_8812A + 2);
+		count = 0;
+		while (!(BcnValidReg & BIT0) && count < 20) {
+			count++;
+			ODM_delay_ms(10);
+			BcnValidReg = ODM_Read1Byte(pDM_Odm, REG_TDECTRL_8812A + 2);
+		}
+		DLBcnCount++;
+	} while (!(BcnValidReg & BIT0) && DLBcnCount < 5);
+
+	if (!(BcnValidReg & BIT0))
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Download RSVD page failed!\n", __func__));
+
+	/*TDECTRL[15:8] 0x209[7:0] = 0xF6	Beacon Head for TXDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 1, TxPageBndy);
+
+	/*To make sure that if there exists an adapter which would like to send beacon.*/
+	/*If exists, the origianl value of 0x422[6] will be 1, we should check this to*/
+	/*prevent from setting 0x422[6] to 0 after download reserved page, or it will cause*/
+	/*the beacon cannot be sent by HW.*/
+	/*2010.06.23. Added by tynli.*/
+	if (bSendBeacon)
+		ODM_Write1Byte(pDM_Odm, REG_FWHW_TXQ_CTRL_8812A + 2, tmpReg422);
+
+	/*Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli.*/
+	/*Clear CR[8] or beacon packet will not be send to TxBuf anymore.*/
+	u1bTmp = ODM_Read1Byte(pDM_Odm, REG_CR_8812A + 1);
+	ODM_Write1Byte(pDM_Odm, REG_CR_8812A + 1, (u1bTmp & (~BIT0)));
+
+	pBeamEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSED;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	*pDM_Odm->pbFwDwRsvdPageInProgress = FALSE;
+#endif
+}
+
+
+VOID
+halTxbfJaguar_FwTxBFCmd(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	Idx, Period0 = 0, Period1 = 0;
+	u1Byte	PageNum0 = 0xFF, PageNum1 = 0xFF;
+	u1Byte	u1TxBFParm[3] = {0};
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
+		/*Modified by David*/
+		if (pBeamInfo->BeamformeeEntry[Idx].bUsed && pBeamInfo->BeamformeeEntry[Idx].BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+			if (Idx == 0) {
+				if (pBeamInfo->BeamformeeEntry[Idx].bSound)
+					PageNum0 = 0xFE;
+				else
+					PageNum0 = 0xFF; /*stop sounding*/
+				Period0 = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			} else if (Idx == 1) {
+				if (pBeamInfo->BeamformeeEntry[Idx].bSound)
+					PageNum1 = 0xFE;
+				else
+					PageNum1 = 0xFF; /*stop sounding*/
+				Period1 = (u1Byte)(pBeamInfo->BeamformeeEntry[Idx].SoundPeriod);
+			}
+		}
+	}
+
+	u1TxBFParm[0] = PageNum0;
+	u1TxBFParm[1] = PageNum1;
+	u1TxBFParm[2] = (Period1 << 4) | Period0;
+	ODM_FillH2CCmd(pDM_Odm, PHYDM_H2C_TXBF, 3, u1TxBFParm);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, 
+		("[%s] PageNum0 = %d Period0 = %d, PageNum1 = %d Period1 %d\n", __func__, PageNum0, Period0, PageNum1, Period1));
+}
+
+
+VOID
+HalTxbfJaguar_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				BFerBFeeIdx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte					i = 0;
+	u1Byte					BFerIdx = (BFerBFeeIdx & 0xF0) >> 4;
+	u1Byte					BFeeIdx = (BFerBFeeIdx & 0xF);
+	u4Byte					CSI_Param;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	u2Byte					STAid = 0;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Start!\n", __func__));
+
+	halTxbfJaguar_RfMode(pDM_Odm, pBeamformingInfo);
+
+	if (pDM_Odm->RFType == ODM_2T2R)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CSI_CONTENT_VALUE, bMaskDWord, 0x00000000);	/*Nc =2*/
+	else
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CSI_CONTENT_VALUE, bMaskDWord, 0x01081008);	/*Nc =1*/
+
+	if ((pBeamformingInfo->beamformer_su_cnt > 0) && (BFerIdx < BEAMFORMER_ENTRY_NUM)) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[BFerIdx];
+
+		/*Sounding protocol control*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A, 0xCB);
+
+		/*MAC address/Partial AID of Beamformer*/
+		if (BFerIdx == 0) {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_BFMER0_INFO_8812A + i), BeamformerEntry.MacAddr[i]);
+			/*CSI report use legacy ofdm so don't need to fill P_AID. */
+			/*PlatformEFIOWrite2Byte(Adapter, REG_BFMER0_INFO_8812A+6, BeamformEntry.P_AID); */
+		} else {
+			for (i = 0; i < 6 ; i++)
+				ODM_Write1Byte(pDM_Odm, (REG_BFMER1_INFO_8812A + i), BeamformerEntry.MacAddr[i]);
+			/*CSI report use legacy ofdm so don't need to fill P_AID.*/
+			/*PlatformEFIOWrite2Byte(Adapter, REG_BFMER1_INFO_8812A+6, BeamformEntry.P_AID);*/
+		}
+
+		/*CSI report parameters of Beamformee*/
+		if (BeamformerEntry.BeamformEntryCap & BEAMFORMEE_CAP_VHT_SU) {
+			if (pDM_Odm->RFType == ODM_2T2R)
+				CSI_Param = 0x01090109;
+			else
+				CSI_Param = 0x01080108;
+		} else {
+			if (pDM_Odm->RFType == ODM_2T2R)
+				CSI_Param = 0x03090309;
+			else
+				CSI_Param = 0x03080308;
+		}
+
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8812A, CSI_Param);
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8812A, CSI_Param);
+		ODM_Write4Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8812A, CSI_Param);
+
+		/*Timeout value for MAC to leave NDP_RX_standby_state (60 us, Test chip) (80 us,  MP chip)*/
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A + 3, 0x50);
+	}
+
+
+	if ((pBeamformingInfo->beamformee_su_cnt > 0) && (BFeeIdx < BEAMFORMEE_ENTRY_NUM)) {
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[BFeeIdx];
+
+		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+			STAid = BeamformeeEntry.MacId;
+		else
+			STAid = BeamformeeEntry.P_AID;
+
+		/*P_AID of Beamformee & enable NDPA transmission & enable NDPA interrupt*/
+		if (BFeeIdx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8812A, STAid);
+			ODM_Write1Byte(pDM_Odm, REG_TXBF_CTRL_8812A + 3, ODM_Read1Byte(pDM_Odm, REG_TXBF_CTRL_8812A + 3) | BIT4 | BIT6 | BIT7);
+		} else
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8812A + 2, STAid | BIT12 | BIT14 | BIT15);
+
+		/*CSI report parameters of Beamformee*/
+		if (BFeeIdx == 0) {
+			/*Get BIT24 & BIT25*/
+			u1Byte	tmp = ODM_Read1Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 3) & 0x3;
+
+			ODM_Write1Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 3, tmp | 0x60);
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A, STAid | BIT9);
+		} else {
+			/*Set BIT25*/
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2, STAid | 0xE200);
+		}
+			phydm_Beamforming_Notify(pDM_Odm);
+	}
+}
+
+
+VOID
+HalTxbfJaguar_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMER_ENTRY	BeamformerEntry;
+	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
+	
+	if (Idx < BEAMFORMER_ENTRY_NUM) {
+		BeamformerEntry = pBeamformingInfo->BeamformerEntry[Idx];
+		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[Idx];
+	} else
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Start!, IDx = %d\n", __func__, Idx));
+
+	/*Clear P_AID of Beamformee*/
+	/*Clear MAC address of Beamformer*/
+	/*Clear Associated Bfmee Sel*/
+	
+	if (BeamformerEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A, 0xC8);
+		if (Idx == 0) {
+			ODM_Write4Byte(pDM_Odm, REG_BFMER0_INFO_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_BFMER0_INFO_8812A + 4, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8812A, 0);
+		} else {
+			ODM_Write4Byte(pDM_Odm, REG_BFMER1_INFO_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_BFMER1_INFO_8812A + 4, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW20_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW40_8812A, 0);
+			ODM_Write2Byte(pDM_Odm, REG_CSI_RPT_PARAM_BW80_8812A, 0);
+		}
+	}
+
+	if (BeamformeeEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
+		halTxbfJaguar_RfMode(pDM_Odm, pBeamformingInfo);
+		if (Idx == 0) {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8812A, 0x0);
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A, 0);
+		} else {
+			ODM_Write2Byte(pDM_Odm, REG_TXBF_CTRL_8812A + 2, ODM_Read2Byte(pDM_Odm, REG_TXBF_CTRL_8812A + 2) & 0xF000);
+			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2, ODM_Read2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2) & 0x60);
+		}
+	}
+	
+}
+
+
+VOID
+HalTxbfJaguar_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte					BeamCtrlVal;
+	u4Byte					BeamCtrlReg;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	RT_BEAMFORMEE_ENTRY	BeamformEntry = pBeamInfo->BeamformeeEntry[Idx];
+
+	if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_IBSS))
+		BeamCtrlVal = BeamformEntry.MacId;
+	else
+		BeamCtrlVal = BeamformEntry.P_AID;
+
+	if (Idx == 0)
+		BeamCtrlReg = REG_TXBF_CTRL_8812A;
+	else {
+		BeamCtrlReg = REG_TXBF_CTRL_8812A + 2;
+		BeamCtrlVal |= BIT12 | BIT14 | BIT15;
+	}
+
+	if (BeamformEntry.BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSED) {
+		if (BeamformEntry.SoundBW == CHANNEL_WIDTH_20)
+			BeamCtrlVal |= BIT9;
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_40)
+			BeamCtrlVal |= (BIT9 | BIT10);
+		else if (BeamformEntry.SoundBW == CHANNEL_WIDTH_80)
+			BeamCtrlVal |= (BIT9 | BIT10 | BIT11);
+	} else
+		BeamCtrlVal &= ~(BIT9 | BIT10 | BIT11);
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] BeamCtrlVal = 0x%x!\n", __func__, BeamCtrlVal));
+
+	ODM_Write2Byte(pDM_Odm, BeamCtrlReg, BeamCtrlVal);
+}
+
+
+
+VOID
+HalTxbfJaguar_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+	PRT_BEAMFORMEE_ENTRY	pBeamEntry = pBeamInfo->BeamformeeEntry + Idx;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pBeamEntry->BeamformEntryState == BEAMFORMING_ENTRY_STATE_PROGRESSING)
+		halTxbfJaguar_DownloadNDPA(pDM_Odm, Idx);
+
+	halTxbfJaguar_FwTxBFCmd(pDM_Odm);
+}
+
+
+VOID
+HalTxbfJaguar_Patch(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Operation
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (pBeamInfo->BeamformCap == BEAMFORMING_CAP_NONE)
+		return;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if (Operation == SCAN_OPT_BACKUP_BAND0)
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A, 0xC8);
+	else if (Operation == SCAN_OPT_RESTORE)
+		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A, 0xCB);
+#endif
+}
+
+VOID
+HalTxbfJaguar_Clk_8812A(
+	IN PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte	u2btmp;
+	u1Byte	Count = 0, u1btmp;
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
+
+	if (*(pDM_Odm->pbScanInProcess)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] return by Scan\n", __func__));
+		return;
+	}
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE	
+	/*Stop PCIe TxDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_PCIE_CTRL_REG_8812A + 1, 0xFE);
+#endif
+
+	/*Stop Usb TxDMA*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	RT_DISABLE_FUNC(Adapter, DF_TX_BIT);
+	PlatformReturnAllPendingTxPackets(Adapter);
+#else
+	rtw_write_port_cancel(Adapter);
+#endif
+
+	/*Wait TXFF empty*/
+	for (Count = 0; Count < 100; Count++) {
+		u2btmp = ODM_Read2Byte(pDM_Odm, REG_TXPKT_EMPTY_8812A);
+		u2btmp = u2btmp & 0xfff;
+		if (u2btmp != 0xfff) {
+			ODM_delay_ms(10);
+			continue;
+		} else
+			break;
+	}
+
+	/*TX pause*/
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE_8812A, 0xFF);
+
+	/*Wait TX State Machine OK*/
+	for (Count = 0; Count < 100; Count++) {
+		if (ODM_Read4Byte(pDM_Odm, REG_SCH_TXCMD_8812A) != 0)
+			continue;
+		else
+			break;
+	}
+
+
+	/*Stop RX DMA path*/
+	u1btmp = ODM_Read1Byte(pDM_Odm, REG_RXDMA_CONTROL_8812A);
+	ODM_Write1Byte(pDM_Odm, REG_RXDMA_CONTROL_8812A, u1btmp | BIT2);
+
+	for (Count = 0; Count < 100; Count++) {
+		u1btmp = ODM_Read1Byte(pDM_Odm, REG_RXDMA_CONTROL_8812A);
+		if (u1btmp & BIT1)
+			break;
+		else
+			ODM_delay_ms(10);
+	}
+
+	/*Disable clock*/
+	ODM_Write1Byte(pDM_Odm, REG_SYS_CLKR_8812A + 1, 0xf0);
+	/*Disable 320M*/
+	ODM_Write1Byte(pDM_Odm, REG_AFE_PLL_CTRL_8812A + 3, 0x8);
+	/*Enable 320M*/
+	ODM_Write1Byte(pDM_Odm, REG_AFE_PLL_CTRL_8812A + 3, 0xa);
+	/*Enable clock*/
+	ODM_Write1Byte(pDM_Odm, REG_SYS_CLKR_8812A + 1, 0xfc);
+
+
+	/*Release Tx pause*/
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE_8812A, 0);
+
+	/*Enable RX DMA path*/
+	u1btmp = ODM_Read1Byte(pDM_Odm, REG_RXDMA_CONTROL_8812A);
+	ODM_Write1Byte(pDM_Odm, REG_RXDMA_CONTROL_8812A, u1btmp & (~BIT2));
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+	/*Enable PCIe TxDMA*/
+	ODM_Write1Byte(pDM_Odm, REG_PCIE_CTRL_REG_8812A + 1, 0);
+#endif
+	/*Start Usb TxDMA*/
+	RT_ENABLE_FUNC(Adapter, DF_TX_BIT);
+}
+
+#endif
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.h b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.h
new file mode 100644
index 000000000..ba16b7f04
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/phydm/txbf/haltxbfjaguar.h
@@ -0,0 +1,67 @@
+#ifndef __HAL_TXBF_JAGUAR_H__
+#define __HAL_TXBF_JAGUAR_H__
+
+#if (BEAMFORMING_SUPPORT == 1)
+#if ((RTL8812A_SUPPORT == 1) || (RTL8821A_SUPPORT == 1))
+VOID
+HalTxbf8812A_setNDPArate(
+	IN PVOID			pDM_VOID,
+	IN u1Byte	BW,
+	IN u1Byte	Rate
+);
+
+
+VOID
+HalTxbfJaguar_Enter(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbfJaguar_Leave(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbfJaguar_Status(
+	IN PVOID			pDM_VOID,
+	IN u1Byte				Idx
+	);
+
+
+VOID
+HalTxbfJaguar_FwTxBF(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Idx
+	);
+
+
+VOID
+HalTxbfJaguar_Patch(
+	IN PVOID			pDM_VOID,
+	IN	u1Byte				Operation
+	);
+
+
+VOID
+HalTxbfJaguar_Clk_8812A(
+	IN PVOID			pDM_VOID
+	);
+
+#else
+
+#define HalTxbf8812A_setNDPArate(pDM_VOID,	BW,	Rate)
+#define HalTxbfJaguar_Enter(pDM_VOID, Idx)
+#define HalTxbfJaguar_Leave(pDM_VOID, Idx)
+#define HalTxbfJaguar_Status(pDM_VOID, Idx)
+#define HalTxbfJaguar_FwTxBF(pDM_VOID,	Idx)
+#define HalTxbfJaguar_Patch(pDM_VOID, Operation)
+#define HalTxbfJaguar_Clk_8812A(pDM_VOID)
+#endif
+
+#endif				
+#endif	// #ifndef __HAL_TXBF_JAGUAR_H__								
+
-- 
2.34.1

