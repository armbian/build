From 6db06399424f7eaf9e455dccaf6bcde31ca21f4f Mon Sep 17 00:00:00 2001
From: Sven-Ola Tuecke <sven-ola@gmx.de>
Date: Tue, 13 Jan 2026 16:39:38 +0100
Subject: [PATCH] Spacemit HW crypto: avoid unnecessary fallback to SW crypto

Signed-off-by: Sven-Ola Tuecke <sven-ola@gmx.de>
---
 drivers/crypto/spacemit/spacemit_ce_engine.c | 21 ++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/drivers/crypto/spacemit/spacemit_ce_engine.c b/drivers/crypto/spacemit/spacemit_ce_engine.c
index 033ce6531b..d1170b47c4 100644
--- a/drivers/crypto/spacemit/spacemit_ce_engine.c
+++ b/drivers/crypto/spacemit/spacemit_ce_engine.c
@@ -1153,14 +1153,15 @@ static int ce_aes_process_nblocks_noalign(int index, const unsigned char *buf_in
 				  unsigned long blocks, symmetric_key * skey1, symmetric_key * skey2,
 				  AES_MODE_T mode, uint8_t *inv, AES_OP_MODE_T op) {
 	int ret;
-	int len_bytes = 0;
-	int step_bytes = 0;
-	unsigned char *in_cpy = NULL, *out_cpy = NULL;
-	unsigned char *in_work = NULL, *out_work = NULL;
-	unsigned char *aligned_buf_1 = &engine[index].internal_working_buffer[0];
-	unsigned char *aligned_buf_2 = &engine[index].internal_working_buffer[WORK_BUF_SIZE];
 
 	if ((unsigned long) buf_in & 0x3 || (unsigned long) buf_out & 0x3) {
+		int len_bytes = 0;
+		int step_bytes = 0;
+		unsigned char *in_cpy = NULL, *out_cpy = NULL;
+		unsigned char *in_work = NULL, *out_work = NULL;
+		unsigned char *aligned_buf_1 = &engine[index].internal_working_buffer[0];
+		unsigned char *aligned_buf_2 = &engine[index].internal_working_buffer[WORK_BUF_SIZE];
+
 		len_bytes = blocks << 4;
 		in_cpy = (unsigned char *) buf_in;
 		out_cpy = (unsigned char *) buf_out;
@@ -1199,9 +1200,12 @@ static int ce_aes_process_nblocks_noalign(int index, const unsigned char *buf_in
 				sw_aes_ce_decrypt(inv, inv, key_local, key_len);
 			}
 		}
+exit:
+		memset(aligned_buf_1, 0x0, WORK_BUF_SIZE);
+		memset(aligned_buf_2, 0x0, WORK_BUF_SIZE);
 	} else {
 		ret = ce_aes_process_nblocks(index, buf_in, buf_out, blocks, skey1, skey2, mode, inv, op);
-		if (!ret && (mode == E_AES_XTS)) {
+		if ((ret != 0) && (mode == E_AES_XTS)) {
 			unsigned char key_local[32];
 			unsigned int key_len = (skey2->rijndael.Nr < 32) ? skey2->rijndael.Nr : 32;
 
@@ -1213,9 +1217,6 @@ static int ce_aes_process_nblocks_noalign(int index, const unsigned char *buf_in
 		}
 	}
 
-exit:
-	memset(aligned_buf_1, 0x0, WORK_BUF_SIZE);
-	memset(aligned_buf_2, 0x0, WORK_BUF_SIZE);
 	return ret;
 }
 
-- 
2.34.1

