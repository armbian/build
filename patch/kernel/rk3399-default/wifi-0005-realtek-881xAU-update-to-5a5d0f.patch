diff --git a/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c b/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c
index cc65410..050bfa3 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c
@@ -1420,10 +1420,11 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 #ifdef CONFIG_AP_MODE
 	switch (GetFrameSubType(pframe)) {
 	case WIFI_AUTH:
-		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) {
 			ptable->func = &OnAuth;
-		else
+		} else
 			ptable->func = &OnAuthClient;
+	/* Intentional fallthrough */
 	/* pass through */
 	case WIFI_ASSOCREQ:
 	case WIFI_REASSOCREQ:
@@ -2201,14 +2202,15 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 			if (rtw_is_list_empty(&pstat->asoc_list) == _FALSE) {
 				rtw_list_delete(&pstat->asoc_list);
 				pstapriv->asoc_list_cnt--;
-				if (pstat->expire_to > 0)
+				if (pstat->expire_to > 0) {
 					;/* TODO: STA re_auth within expire_to */
+				}
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
-			if (seq == 1)
+			if (seq == 1) {
 				; /* TODO: STA re_auth and auth timeout */
-
+			}
 		}
 	}
 
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c b/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c
index d8b45f4..0a596db 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c
@@ -219,6 +219,7 @@ bool rtw_pwr_unassociated_idle(_adapter *adapter)
 			    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 			    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 			    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+			    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 			    || pcfg80211_wdinfo->is_ro_ch
 #elif defined(CONFIG_P2P)
@@ -618,6 +619,7 @@ u8 PS_RDY_CHECK(_adapter *padapter)
 	    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 	    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 	    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+	    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 	    || pcfg80211_wdinfo->is_ro_ch
 #endif
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_recv.c b/drivers/net/wireless/rtl8812au/core/rtw_recv.c
index 83ed24e..8bb59ee 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_recv.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_recv.c
@@ -2125,7 +2125,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 			if ((bDumpRxPkt == 4) && (eth_type == 0x888e))
 				dump_rx_packet(ptr);
 #endif
-		} else
+		} else {
 			DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_handled);
 		break;
 	default:
@@ -2136,6 +2136,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 		retval = _FAIL;
 		break;
 	}
+}
 
 exit:
 
@@ -3607,8 +3608,15 @@ static sint fill_radiotap_hdr(_adapter *padapter, union recv_frame *precvframe)
 	if (pattrib->mfrag)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FRAG;
 
-	/* always append FCS */
-	/* hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS; */
+#ifdef CONFIG_RX_PACKET_APPEND_FCS
+        // Start by always indicating FCS is there:
+        hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS;
+
+        // Next, test for prior conditions that will remove FCS, and update flag accordingly:
+        if(check_fwstate(&padapter->mlmepriv,WIFI_MONITOR_STATE) == _FALSE)
+                if((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                        hdr_buf[rt_len] &= ~IEEE80211_RADIOTAP_F_FCS;
+#endif
 
 	if (0)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_DATAPAD;
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c b/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c
index 54c9a35..6de4e2e 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c
@@ -2353,8 +2353,7 @@ int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
 
 		_rtw_memcpy(recv_beacon->ssid, elems.ssid, elems.ssid_len);
 		recv_beacon->ssid_len = elems.ssid_len;
-	} else
-		; /* means hidden ssid */
+	} else { ; } /* means hidden ssid */
 
 	/* checking RSN first */
 	if (elems.rsn_ie && elems.rsn_ie_len) {
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_xmit.c b/drivers/net/wireless/rtl8812au/core/rtw_xmit.c
index 1620473..c1019bb 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_xmit.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_xmit.c
@@ -1254,10 +1254,11 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		_rtw_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_ap);
-	} else
+	} else {
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_unknown);
 
 	bmcast = IS_MCAST(pattrib->ra);
+	}
 	if (bmcast) {
 		psta = rtw_get_bcmc_stainfo(padapter);
 		if (psta == NULL) { /* if we cannot get psta => drop the pkt */
@@ -3874,7 +3875,7 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	u32 len = skb->len;
 	u8 category, action;
 	int type = -1;
-	
+
 	//RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if (skb)
@@ -3922,17 +3923,17 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 					fixed_rate = 0;
 				fixed_rate += MGN_MCS0;
 			}
-			if ((mcs_have & 4) && 
+			if ((mcs_have & 4) &&
 			    (iterator.this_arg[1] & 4))
 				sgi = 1;
-			if ((mcs_have & 1) && 
+			if ((mcs_have & 1) &&
 			    (iterator.this_arg[1] & 1))
 				bwidth = 1;
-			if ((mcs_have & 0x10) && 
+			if ((mcs_have & 0x10) &&
 			    (iterator.this_arg[1] & 0x10))
 				ldpc = 1;
 			if ((mcs_have & 0x20))
-				stbc = (iterator.this_arg[1] >> 5) & 3;	
+				stbc = (iterator.this_arg[1] >> 5) & 3;
 		}
 		break;
 
@@ -3994,9 +3995,9 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	pattrib->ldpc = ldpc;
 	pattrib->stbc = stbc;
 	pattrib->retry_ctrl = (txflags & 0x08)?_FALSE:_TRUE;
-	pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;
+	// pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;  // Adds support for pre-configured SeqNum via RadioTap
+
 
-	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
index 22f793c..b7ff6f6 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MPCIE.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MPCIE[] = { 
+u1Byte Array_MP_8814A_MPCIE[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
index 8b51c1b..9b4d7c5 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
index cd80e92..d882d92 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MUSB.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MUSB[] = { 
+u1Byte Array_MP_8814A_MUSB[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
index 4262400..be33e37 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c b/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c
index 68ee167..bc5f941 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c
@@ -112,7 +112,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz , u8 ba
 
 	/* offset 12 */
 
-	if (!pattrib->qos_en && pattrib->sw_seq == _FALSE) {
+	if (!pattrib->qos_en) {
 		SET_TX_DESC_HWSEQ_EN_8812(ptxdesc, 1); /* Hw set sequence number */
 	} else
 		SET_TX_DESC_SEQ_8812(ptxdesc, pattrib->seqnum);
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
index 423ba9f..f0a247a 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
@@ -554,7 +554,6 @@ PHY_ConfigBB_8814A(
 }
 
 
-
 //2 3.3 RF Config
 
 s32
@@ -1157,7 +1156,7 @@ PHY_GetTxPowerIndex_8814A(
 	tpt_offset = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);
 
 	powerDiffByRate = powerDiffByRate > limit ? limit : powerDiffByRate;
-	/*RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);*/
+	RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);
 
 	txPower += powerDiffByRate;
 
@@ -1184,8 +1183,8 @@ PHY_GetTxPowerIndex_8814A(
 		//(pHalData->bautoload_fail_flag || pHalData->EfuseMap[EFUSE_INIT_MAP][EEPROM_TX_PWR_INX_JAGUAR] == 0xFF))
 		//txPower = 0x12;
 
-	/*RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
-		txPower, txPower);*/
+	RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
+		txPower, txPower);
 
 	return (u8) txPower;
 }
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c
index 4a7947e..b9e83fd 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c
@@ -93,7 +93,7 @@ void rtl8814_sreset_linked_status_check(_adapter *padapter)
 	regc58 = rtw_read32(padapter,0xc58);
 	reg824 = rtw_read32(padapter,0x824);
 	reg800 = rtw_read32(padapter,0x800);
-	if(	((regc50&0xFFFFFF00)!= 0x69543400)||
+	if (	((regc50&0xFFFFFF00)!= 0x69543400)||
 		((regc58&0xFFFFFF00)!= 0x69543400)||
 		(((reg824&0xFFFFFF00)!= 0x00390000)&&(((reg824&0xFFFFFF00)!= 0x80390000)))||
 		( ((reg800&0xFFFFFF00)!= 0x03040000)&&((reg800&0xFFFFFF00)!= 0x83040000)))
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c
index 43b8268..bb6cdd8 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c
@@ -172,7 +172,6 @@ InsertEMContent_8814(
 }
 
 
-
 void UpdateEarlyModeInfo8814(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf )
 {
 	//_adapter *padapter, struct xmit_frame *pxmitframe,struct tx_servq	*ptxservq
@@ -254,7 +253,6 @@ void rtl8814a_cal_txdesc_chksum(u8 *ptxdesc)
 	u32 index;
 	u16 checksum = 0;
 
-
 	usPtr = (u16*)ptxdesc;
 	// checksume is always calculated by first 32 bytes,
 	// and it doesn't depend on TX DESC length.
@@ -439,7 +437,7 @@ BWMapping_8814(
 		else
 			BWSettingOfDesc = 0;
 	}
-	else if(pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
+	else if (pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
 		if ((pattrib->bwmode == CHANNEL_WIDTH_40) || (pattrib->bwmode == CHANNEL_WIDTH_80))
 			BWSettingOfDesc = 1;
 		else
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c
index 8200263..0f4d3e1 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c
@@ -61,7 +61,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	if (padapter->registrypriv.mp_mode == 0) {
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
 			ptxdesc = (pmem+PACKET_OFFSET_SZ);
 			//RTW_INFO("==> non-agg-pkt,shift pointer...\n");
 			pull = 1;
@@ -94,10 +94,9 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	}
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
-	if (padapter->registrypriv.mp_mode == 0)
-	{
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)){
-			if((pull) && (pxmitframe->pkt_offset>0)) {
+	if (padapter->registrypriv.mp_mode == 0) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)) {
+			if ((pull) && (pxmitframe->pkt_offset>0)) {
 				pxmitframe->pkt_offset = pxmitframe->pkt_offset -1;
 			}
 		}
@@ -119,10 +118,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 	if (!pattrib->qos_en) {
 		/* HW sequence, to fix to use 0 queue. todo: 4AC packets to use auto queue select */
-		if (pattrib->sw_seq == _FALSE)
-			SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
-		else
-			SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
+		SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
 		SET_TX_DESC_EN_HWEXSEQ_8814A(ptxdesc, 0);
 		SET_TX_DESC_DISQSELSEQ_8814A(ptxdesc, 1);
 		SET_TX_DESC_HW_SSN_SEL_8814A(ptxdesc, 0);
@@ -130,8 +126,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 		SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
 	}
 
-	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-	{
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
 		//RTW_INFO("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
 		rtl8814a_fill_txdesc_sectype(pattrib, ptxdesc);
@@ -189,7 +184,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (padapter->fix_rate != 0xFF) { // modify data rate by iwpriv
 				SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 				DriverFixedRate = 0x01;
-				if(padapter->fix_rate & BIT(7))
+				if (padapter->fix_rate & BIT(7))
 					SET_TX_DESC_DATA_SHORT_8814A(ptxdesc, 	1);
 
 				SET_TX_DESC_TX_RATE_8814A(ptxdesc, (padapter->fix_rate & 0x7F));
@@ -202,7 +197,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (pattrib->stbc)
 				SET_TX_DESC_DATA_STBC_8814A(ptxdesc, 1);
 
-			//work arond before fixing RA
+			//work around before fixing RA
 			//SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 			//SET_TX_DESC_TX_RATE_8814A(ptxdesc, 0x10);
 		} else {
@@ -253,7 +248,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			SET_TX_DESC_DATA_RETRY_LIMIT_8814A(ptxdesc, 5);
 			SET_TX_DESC_DISABLE_FB_8814A(ptxdesc, 1);
 
-			//if(pattrib->rts_cca)
+			//if (pattrib->rts_cca)
 			//{
 			//	SET_TX_DESC_NDPA_8812(ptxdesc, 2);
 			//}
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
index b134d5a..e9a5c68 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,8 +33,7 @@ static void _dbg_dump_macreg(_adapter *padapter)
 	u32 offset = 0;
 	u32 val32 = 0;
 	u32 index =0 ;
-	for(index=0;index<64;index++)
-	{
+	for (index=0;index<64;index++) {
 		offset = index*4;
 		val32 = rtw_read32(padapter,offset);
 		RTW_INFO("offset : 0x%02x ,val:0x%08x\n",offset,val32);
@@ -52,11 +51,11 @@ _ConfigChipOutEP_8814(
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber = 0;
 
-	switch(NumOutPipe){
+	switch (NumOutPipe) {
 		case 	4:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=4;
-				break;		
+				break;
 		case 	3:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=3;
@@ -69,9 +68,9 @@ _ConfigChipOutEP_8814(
 				pHalData->OutEpQueueSel=TX_SELE_HQ;
 				pHalData->OutEpNumber=1;
 				break;
-		default:				
+		default:
 				break;
-			
+
 	}
 	RTW_INFO("%s OutEpQueueSel(0x%02x), OutEpNumber(%d) \n",__FUNCTION__,pHalData->OutEpQueueSel,pHalData->OutEpNumber );
 
@@ -87,10 +86,10 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	BOOLEAN			result		= _FALSE;
 
 	_ConfigChipOutEP_8814(pAdapter, NumOutPipe);
-	
+
 	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
-	if(1 == pHalData->OutEpNumber){
-		if(1 != NumInPipe){
+	if (1 == pHalData->OutEpNumber) {
+		if (1 != NumInPipe) {
 			return result;
 		}
 	}
@@ -101,7 +100,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	//}
 
 	result = Hal_MappingOutPipe(pAdapter, NumOutPipe);
-	
+
 	return result;
 
 }
@@ -173,55 +172,45 @@ _InitBurstPktLen(IN PADAPTER Adapter)
 {
 	u8 			u1bTmp;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
- 
+
 	//yx_qi 131128 move to 0x1448, 144c
 	rtw_write32(Adapter, REG_FAST_EDCA_VOVI_SETTING_8814A, 0x08070807); //yx_qi 131128
 	rtw_write32(Adapter, REG_FAST_EDCA_BEBK_SETTING_8814A, 0x08070807); //yx_qi 131128
-	
+
 	u1bTmp = rtw_read8(Adapter, 0xff); //check device operation speed: SS 0xff bit7
-	
-	if(u1bTmp & BIT7)   //USB2/1.1 Mode
-	{
+
+	if (u1bTmp & BIT7) { //USB2/1.1 Mode
  		pHalData->bSupportUSB3 = FALSE;
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		pHalData->bSupportUSB3 = TRUE;
 	}
-	
-	if(pHalData->bSupportUSB3 == _FALSE)   //USB2/1.1 Mode
-	{
-		if(pHalData->UsbBulkOutSize == 512)
-		{
+
+	if (pHalData->bSupportUSB3 == _FALSE) { //USB2/1.1 Mode
+		if (pHalData->UsbBulkOutSize == 512) {
 			//set burst pkt len=512B
 			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x1e);
-		}
-		else
-		{
+		} else {
 			//set burst pkt len=64B
-			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);		
+			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);
 		}
 
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x2005); //dmc agg th 20K
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		//set burst pkt len=1k
-		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);				
+		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x0a05); //dmc agg th 20K
-		
+
 		// set Reg 0xf008[3:4] to 2'00 to disable U1/U2 Mode to avoid 2.5G spur in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)&0xE7);
 		//to avoid usb 3.0 H2C fail
 		rtw_write16(Adapter, 0xf002, 0);
-		
+
 		rtw_write8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A, rtw_read8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A) & ~BIT(6));
 		RTW_INFO("turn off the LDPC pre-TX\n");
-		
-	} 
 
-	if(pHalData->AMPDUBurstMode)
-	{
+	}
+
+	if (pHalData->AMPDUBurstMode) {
 		rtw_write8(Adapter,REG_SW_AMPDU_BURST_MODE_CTRL_8814A,  0x5F);
 	}
 }
@@ -232,7 +221,7 @@ _InitQueueReservedPage_8814AUsb(
 	)
 {
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
-	u16		txpktbuf_bndy; 
+	u16		txpktbuf_bndy;
 
 	RTW_INFO("===>_InitQueueReservedPage_8814AUsb()\n");
 
@@ -246,7 +235,7 @@ _InitQueueReservedPage_8814AUsb(
 
 	rtw_write32(Adapter, REG_RQPN_CTRL_2_8814A, 0x80000000);
 
-	if(!pregistrypriv->wifi_spec)
+	if (!pregistrypriv->wifi_spec)
 		txpktbuf_bndy = TX_PAGE_BOUNDARY_8814A;
 	else		// for WMM
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_8814A;
@@ -260,7 +249,7 @@ _InitQueueReservedPage_8814AUsb(
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A, txpktbuf_bndy);
 	//The head page of packet of Bcnq1
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A+2,txpktbuf_bndy);
-	
+
 	RTW_INFO("<===_InitQueueReservedPage_8814AUsb()\n");
 }
 
@@ -273,7 +262,7 @@ static u32 _InitPowerOn_8814AU(_adapter *padapter)
 	u8	u1btmp = rtw_read8(padapter, 0x10C2);
 	rtw_write8(padapter, 0x10C2, (u1btmp | BIT1));
 
-	if(!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
+	if (!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
 		return _FAIL;
 
 	// Enable MAC DMA/WMAC/SCHEDULE/SEC block
@@ -320,9 +309,9 @@ _InitPageBoundary_8814AUsb(
 {
 	//20130416 KaiYuan modified for 8814
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
-	
+
 	rtw_write16(Adapter, REG_RXFF_PTR_8814A, RX_DMA_BOUNDARY_8814A); //yx_qi 20140331
-	
+
 }
 
 static VOID
@@ -353,11 +342,11 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
-	
+
 	u16	valueHi = 0;
 	u16	valueLow = 0;
-	
-	switch(pHalData->OutEpQueueSel)
+
+	switch (pHalData->OutEpQueueSel)
 	{
 		case (TX_SELE_HQ | TX_SELE_LQ):
 			valueHi = QUEUE_HIGH;
@@ -373,27 +362,27 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 			break;
 		default:
 			valueHi = QUEUE_HIGH;
-			valueLow = QUEUE_NORMAL;			
+			valueLow = QUEUE_NORMAL;
 			break;
 	}
 
-	if(!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		beQ 		= valueLow;
 		bkQ 		= valueLow;
 		viQ		= valueHi;
 		voQ 		= valueHi;
-		mgtQ 	= valueHi; 
-		hiQ 		= valueHi;								
+		mgtQ 	= valueHi;
+		hiQ 		= valueHi;
 	}
-	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+	else { //for WMM ,CONFIG_OUT_EP_WIFI_MODE
 		beQ		= valueLow;
 		bkQ 		= valueHi;
 		viQ 		= valueHi;
 		voQ 		= valueLow;
 		mgtQ 	= valueHi;
-		hiQ 		= valueHi;							
+		hiQ 		= valueHi;
 	}
-	
+
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
 
@@ -405,21 +394,20 @@ _InitNormalChipThreeOutEpPriority_8814AUsb(
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if(!pregistrypriv->wifi_spec){// typical setting
+	if (!pregistrypriv->wifi_spec) { // typical setting
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_LOW;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
-	}
-	else{// for WMM
+		hiQ 		= QUEUE_HIGH;
+	} else { // for WMM
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_NORMAL;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
+		hiQ 		= QUEUE_HIGH;
 	}
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
@@ -431,7 +419,7 @@ _InitQueuePriority_8814AUsb(
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	switch(pHalData->OutEpNumber)
+	switch (pHalData->OutEpNumber)
 	{
 		case 2:
 			_InitNormalChipTwoOutEpPriority_8814AUsb(Adapter);
@@ -499,8 +487,8 @@ _InitWMACSetting_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	//pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
-	pHalData->ReceiveConfig = 
-	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;	  
+	pHalData->ReceiveConfig =
+	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
 	pHalData->ReceiveConfig |= ACRC32;
@@ -539,7 +527,7 @@ _InitWMACSetting_8814A(
 	//rtw_write16(Adapter, REG_RXFLTMAP0, value16);
 
 	//enable RX_SHIFT bits
-	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));	
+	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));
 
 }
 */
@@ -553,21 +541,21 @@ _InitMacConfigure_8814A(
 	u16			value16;
 	u32			regRRSR;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	
+
 	switch (Adapter->registrypriv.wireless_mode)
 	{
 		case WIRELESS_11B:
 			regRRSR = RATE_ALL_CCK;
 			break;
-		
+
 		case WIRELESS_11G:
 		case WIRELESS_11A:
 		case WIRELESS_11_5N:
-		case WIRELESS_11A_5N://Todo: no basic rate for ofdm ?
+		case WIRELESS_11A_5N: //Todo: no basic rate for ofdm ?
 		case WIRELESS_11_5AC:
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-		
+
 		case WIRELESS_11BG:
 		case WIRELESS_11G_24N:
 		case WIRELESS_11_24N:
@@ -575,7 +563,7 @@ _InitMacConfigure_8814A(
 		default:
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
-	
+
 	}
 
 	// Init value for RRSR.
@@ -584,7 +572,7 @@ _InitMacConfigure_8814A(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RETRY_LIMIT_8814A, value16);
-	
+
 	pHalData->ReceiveConfig = RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 	pHalData->ReceiveConfig |= FORCEACK;
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
@@ -608,8 +596,8 @@ _InitMacConfigure_8814A(
 
 	// 201409/25 MH When RA is enabled, we need to reduce the value.
 	rtw_write8(Adapter, REG_MAX_AGGR_NUM_8814A, 0x36);
-	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36); 
-	
+	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36);
+
 }
 
 /*
@@ -643,7 +631,7 @@ _InitAdaptiveCtrl_8812AUsb(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
-	
+
 }*/
 
 static VOID
@@ -656,7 +644,7 @@ _InitEDCA_8814AUsb(
 	rtw_write16(Adapter,REG_MAC_SPEC_SIFS, 0x100a);
 
 	// Set SIFS for CCK
-	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);	
+	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);
 
 	// Set SIFS for OFDM
 	rtw_write16(Adapter,REG_SIFS_TRX, 0x100a);
@@ -679,9 +667,9 @@ _InitBeaconMaxError_8814A(
 	)
 {
 #ifdef CONFIG_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);	
+	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
 #else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));	
+	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
 #endif
 }
 
@@ -689,12 +677,12 @@ _InitBeaconMaxError_8814A(
 static void _InitHWLed(PADAPTER Adapter)
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
-	
-	if( pledpriv->LedStrategy != HW_LED)
+
+	if ( pledpriv->LedStrategy != HW_LED)
 		return;
-	
+
 // HW led control
-// to do .... 
+// to do ....
 //must consider cases of antenna diversity/ commbo card/solo card/mini card
 
 }
@@ -717,7 +705,7 @@ _InitRetryFunction_8814A(
 	)
 {
 	u8	value8;
-	
+
 	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
 	value8 |= EN_AMPDU_RTY_NEW;
 	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
@@ -730,7 +718,7 @@ _InitRetryFunction_8814A(
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingTxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -751,25 +739,25 @@ usb_AggSettingTxUpdate_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32			value32;
 
-	if(Adapter->registrypriv.wifi_spec)
+	if (Adapter->registrypriv.wifi_spec)
 		pHalData->UsbTxAggDescNum = 1;
 
-	if(pHalData->UsbTxAggMode){
+	if (pHalData->UsbTxAggMode){
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
-		
+
 		rtw_write32(Adapter, REG_TDECTRL, value32);
 		rtw_write8(Adapter, REG_TDECTRL+3, pHalData->UsbTxAggDescNum<<1);
 	}
-	
+
 #endif //CONFIG_USB_TX_AGGREGATION
 }	// usb_AggSettingTxUpdate
 
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingRxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -793,7 +781,7 @@ usb_AggSettingRxUpdate_8814A(
 
 	valueDMA = rtw_read8(Adapter, REG_TRXDMA_CTRL_8814A);
 	valueUSB = rtw_read8(Adapter, REG_RXDMA_AGG_PG_TH_8814A+3);
-	switch(pHalData->rxagg_mode)
+	switch (pHalData->rxagg_mode)
 	{
 		case RX_AGG_DMA:
 			valueDMA |= RXDMA_AGG_EN;
@@ -853,7 +841,7 @@ init_UsbAggregationSetting_8814A(
  *
  * Revised History:
  *	When		Who		Remark
- *	12/10/2010	MHC		Create Version 0.  
+ *	12/10/2010	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
 VOID
@@ -866,37 +854,33 @@ USB_AggModeSwitch(
 	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
 
 	//pHalData->UsbRxHighSpeedMode = _FALSE;
-	// How to measure the RX speed? We assume that when traffic is more than 
+	// How to measure the RX speed? We assume that when traffic is more than
 	if (pMgntInfo->bRegAggDMEnable == _FALSE)
 	{
 		return;	// Inf not support.
 	}
-		
-	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE && 
+
+	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE &&
 		pHalData->UsbRxHighSpeedMode == _FALSE)
 	{
 		pHalData->UsbRxHighSpeedMode = _TRUE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to HIGH\n"));
 	}
-	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE && 
+	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE &&
 		pHalData->UsbRxHighSpeedMode == _TRUE)
 	{
 		pHalData->UsbRxHighSpeedMode = _FALSE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to LOW\n"));
+	} else {
+		return;
 	}
-	else
-	{
-		return; 
-	}
-	
+
 #if USB_RX_AGGREGATION_92C
-	if (pHalData->UsbRxHighSpeedMode == _TRUE)	
-	{
+	if (pHalData->UsbRxHighSpeedMode == _TRUE) {
 		// 2010/12/10 MH The parameter is tested by SD1 engineer and SD3 channel emulator.
 		// USB mode
 #if (RT_PLATFORM == PLATFORM_LINUX)
-		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic)
-		{
+		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic) {
 			pHalData->RxAggBlockCount	= 16;
 			pHalData->RxAggBlockTimeout	= 7;
 		}
@@ -908,23 +892,20 @@ USB_AggModeSwitch(
 		}
 		// Mix mode
 		pHalData->RxAggPageCount	= 72;
-		pHalData->RxAggPageTimeout	= 6;		
-	}
-	else
-	{
+		pHalData->RxAggPageTimeout	= 6;
+	} else {
 		// USB mode
 		pHalData->RxAggBlockCount	= pMgntInfo->RegRxAggBlockCount;
-		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;	
+		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;
 		// Mix mode
 		pHalData->RxAggPageCount		= pMgntInfo->RegRxAggPageCount;
-		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;	
+		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;
 	}
 
 	if (pHalData->RxAggBlockCount > MAX_RX_AGG_BLKCNT)
 		pHalData->RxAggBlockCount = MAX_RX_AGG_BLKCNT;
 #if (OS_WIN_FROM_VISTA(OS_VERSION)) || (RT_PLATFORM == PLATFORM_LINUX)	// do not support WINXP to prevent usbehci.sys BSOD
-	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter))
-	{
+	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter)) {
 		//
 		// 2010/12/24 MH According to V1012 QC IOT test, XP BSOD happen when running chariot test
 		// with the aggregation dynamic change!! We need to disable the function to prevent it is broken
@@ -933,12 +914,12 @@ USB_AggModeSwitch(
 		usb_AggSettingRxUpdate_8188E(Adapter);
 
 		// 2010/12/27 MH According to designer's suggstion, we can only modify Timeout value. Otheriwse
-		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the 
+		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the
 		// issue. Base on the newest test, we can not enable block cnt > 30, otherwise XP usbehci.sys may
 		// BSOD.
 	}
 #endif
-	
+
 #endif
 #endif
 }	// USB_AggModeSwitch
@@ -957,7 +938,7 @@ _InitOperationMode_8814A(
 	//
 	// Set RRSR, RATR, and REG_BWOPMODE registers
 	//
-	switch(Adapter->RegWirelessMode)
+	switch (Adapter->RegWirelessMode)
 	{
 		case WIRELESS_MODE_B:
 			regBwOpMode = BW_OPMODE_20MHZ;
@@ -975,14 +956,11 @@ _InitOperationMode_8814A(
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
 		case WIRELESS_MODE_AUTO:
-			if (Adapter->bInHctTest)
-			{
+			if (Adapter->bInHctTest) {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
-			}
-			else
-			{
+			} else {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
@@ -1000,7 +978,7 @@ _InitOperationMode_8814A(
 			regRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-			
+
 		default: //for MacOSX compiler warning.
 			break;
 	}
@@ -1039,20 +1017,19 @@ static VOID _RfPowerSave(
 	return;
 #endif
 
-	if(pMgntInfo->RegRfOff == _TRUE){ // User disable RF via registry.
+	if (pMgntInfo->RegRfOff == _TRUE) { // User disable RF via registry.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
 		MgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 		for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if(pMgntInfo->RfOffReason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+	else if (pMgntInfo->RfOffReason > RF_CHANGE_BY_PS) { // H/W or S/W RF OFF before sleep.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
 		MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
-	}
-	else{
+	} else {
 		pHalData->eRFPowerState = eRfOn;
-		pMgntInfo->RfOffReason = 0; 
+		pMgntInfo->RfOffReason = 0;
 		if(Adapter->bInSetPower || Adapter->bResetInProgress)
 			PlatformUsbEnableInPipes(Adapter);
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
@@ -1062,7 +1039,7 @@ static VOID _RfPowerSave(
 */
 enum {
 	Antenna_Lfet = 1,
-	Antenna_Right = 2,	
+	Antenna_Right = 2,
 };
 
 static VOID
@@ -1071,21 +1048,21 @@ _InitAntenna_Selection_8814A(IN	PADAPTER Adapter)
 
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	if(pHalData->AntDivCfg==0)
+	if (pHalData->AntDivCfg==0)
 		return;
-/*		
-	RTW_INFO("==>  %s ....\n",__FUNCTION__);		
+/*
+	RTW_INFO("==>  %s ....\n",__FUNCTION__);
 
 	rtw_write8(Adapter, REG_LEDCFG2, 0x82);
 
 	PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
-		
+
 	if(PHY_QueryBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == MAIN_ANT)
 		pHalData->CurAntenna = MAIN_ANT;
 	else
 		pHalData->CurAntenna = AUX_ANT;
 	RTW_INFO("%s,Cur_ant:(%x)%s\n",__FUNCTION__,pHalData->CurAntenna,(pHalData->CurAntenna == MAIN_ANT)?"MAIN_ANT":"AUX_ANT");
-			
+
 */
 }
 
@@ -1104,28 +1081,24 @@ HalDetectSelectiveSuspendMode(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
 
-	// If support HW radio detect, we need to enable WOL ability, otherwise, we 
+	// If support HW radio detect, we need to enable WOL ability, otherwise, we
 	// can not use FW to notify host the power state switch.
-	
+
 	EFUSE_ShadowRead(Adapter, 1, EEPROM_USB_OPTIONAL1, (u32 *)&tmpvalue);
 
 	DBG_8192C("HalDetectSelectiveSuspendMode(): SS ");
-	if(tmpvalue & BIT1)
-	{
+	if (tmpvalue & BIT1) {
 		DBG_8192C("Enable\n");
-	}
-	else
-	{
+	} else {
 		DBG_8192C("Disable\n");
 		pdvobjpriv->RegUsbSS = _FALSE;
 	}
 
 	// 2010/09/01 MH According to Dongle Selective Suspend INF. We can switch SS mode.
-	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData))
-	{
+	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData)) {
 		//PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
 
-		//if (!pMgntInfo->bRegDongleSS)	
+		//if (!pMgntInfo->bRegDongleSS)
 		//{
 		//	RT_TRACE(COMP_INIT, DBG_LOUD, ("Dongle disable SS\n"));
 			pdvobjpriv->RegUsbSS = _FALSE;
@@ -1156,12 +1129,11 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 {
 #if 0
                 u8 reg_val=0;
-	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7)
-	{		
-		_8051Reset8812(Adapter);  
+	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) {
+		_8051Reset8812(Adapter);
 		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
 		//before BB reset should do clock gated
-		rtw_write32(Adapter, rFPGA0_XCD_RFPara, 
+		rtw_write32(Adapter, rFPGA0_XCD_RFPara,
 			rtw_read32(Adapter, rFPGA0_XCD_RFPara)|(BIT6));
 		//reset BB
 		reg_val = rtw_read8(Adapter, REG_SYS_FUNC_EN);
@@ -1172,16 +1144,16 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 		//reset TRX path
 		rtw_write16(Adapter, REG_CR, 0);
 		//reset MAC
-		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		reg_val |= BIT(1);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);       //reg0x5[1] ,auto FSM off
 
 		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
- 
+
 		//check if   reg0x5[1] auto cleared
-		while(reg_val & BIT(1)){
+		while (reg_val & BIT(1)) {
 			rtw_udelay_os(1);
-			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		}
 		reg_val |= BIT(0);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);     //reg0x5[0] ,auto FSM on
@@ -1272,7 +1244,7 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 	int hal_init_profiling_i;
 	u32 hal_init_stages_timestamp[HAL_INIT_STAGES_NUM]; //used to record the time of each stage's starting point
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
 		hal_init_stages_timestamp[hal_init_profiling_i]=0;
 
 	#define HAL_INIT_PROFILE_TAG(stage) hal_init_stages_timestamp[(stage)]=rtw_get_current_time();
@@ -1281,15 +1253,12 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 #endif //DBG_HAL_INIT_PROFILING
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
-	if(pwrctrlpriv->bkeepfwalive)
-	{
+	if (pwrctrlpriv->bkeepfwalive) {
 		_ps_open_RF(Adapter);
 
-		if(pHalData->bIQKInitialized){
+		if (pHalData->bIQKInitialized) {
 			//PHY_IQCalibrate_8812A(Adapter,_TRUE);
-		}
-		else
-		{
+		} else {
 			//PHY_IQCalibrate_8812A(Adapter,_FALSE);
 			//pHalData->bIQKInitialized = _TRUE;
 		}
@@ -1301,16 +1270,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}
 
 	// Check if MAC has already power on. by tynli. 2011.05.27.
-	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);	
+	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);
 	u1bRegCR = rtw_read8(Adapter, REG_CR);
 	RTW_INFO(" power-on :REG_SYS_CLKR 0x09=0x%02x. REG_CR 0x100=0x%02x.\n", value8, u1bRegCR);
-	if((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA))
-	{
+	if ((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA)) {
 		//pHalData->bMACFuncEnable = _TRUE;
 		RTW_INFO(" MAC has already power on.\n");
-	}
-	else
-	{
+	} else {
 		//pHalData->bMACFuncEnable = _FALSE;
 		// Set FwPSState to ALL_ON mode to prevent from the I/O be return because of 32k
 		// state which is set before sleep under wowlan mode. 2012.01.04. by tynli.
@@ -1332,7 +1298,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}*/
 
 /*
-	If HW didn't go through a complete de-initial procedure,  
+	If HW didn't go through a complete de-initial procedure,
 	it probably occurs some problem for double initial procedure.
 	Like "CONFIG_DEINIT_BEFORE_INIT" in 92du chip
 */
@@ -1340,15 +1306,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 	status = _InitPowerOn_8814AU(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init power on!\n");
 		goto exit;
 	}
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
-	
+
 	status =  InitLLTTable8814A(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init LLT table\n");
 		goto exit;
 	}
@@ -1375,8 +1341,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 	}
 
 	InitializeFirmwareVars8814(Adapter);
-	
-	if(pwrctrlpriv->reg_rfoff == _TRUE){
+
+	if (pwrctrlpriv->reg_rfoff == _TRUE) {
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -1393,16 +1359,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC);
 #if (HAL_MAC_ENABLE == 1)
 	status = PHY_MACConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_MAC_ENABLE
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
-	
+
 	_InitQueuePriority_8814AUsb(Adapter);
-	_InitPageBoundary_8814AUsb(Adapter);	
+	_InitPageBoundary_8814AUsb(Adapter);
 
 	_InitTransferPageSize_8814AUsb(Adapter);
 
@@ -1411,8 +1376,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	_InitDriverInfoSize_8814A(Adapter, DRVINFO_SZ);
 
 	_InitInterrupt_8814AU(Adapter);
-	_InitID_8814A(Adapter);//set mac_address
-	_InitNetworkType_8814A(Adapter);//set msr	
+	_InitID_8814A(Adapter); //set mac_address
+	_InitNetworkType_8814A(Adapter); //set msr
 	_InitMacConfigure_8814A(Adapter);
 	//_InitWMACSetting_8814A(Adapter);
 	//_InitAdaptiveCtrl_8814AUsb(Adapter);
@@ -1428,7 +1393,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 
 	//
 	// Init CR MACTXEN, MACRXEN after setting RxFF boundary REG_TRXFF_BNDY to patch
-	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E. 
+	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E.
 	// 2011.08.05. by tynli.
 	//
 	value8 = rtw_read8(Adapter, REG_CR);
@@ -1449,7 +1414,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	rtw_write16(Adapter, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	// unit: 256us. 3s
 #endif	// CONFIG_TX_MCAST2UNI
 #endif	// CONFIG_CONCURRENT_MODE || CONFIG_TX_MCAST2UNI
-	
+
 #ifdef CONFIG_LED
 	_InitHWLed(Adapter);
 #endif //CONFIG_LED
@@ -1461,8 +1426,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 #if (HAL_BB_ENABLE == 1)
 	status = PHY_BBConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_BB_ENABLE
@@ -1472,9 +1436,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 #if (HAL_RF_ENABLE == 1)
-	status = PHY_RFConfig8814A(Adapter);	
-	if(status == _FAIL)
-	{
+	status = PHY_RFConfig8814A(Adapter);
+	if (status == _FAIL) {
 		goto exit;
 	}
 
@@ -1485,12 +1448,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 
 	PHY_ConfigBB_8814A(Adapter);
 
-	if(Adapter->registrypriv.channel <= 14)
+	if (Adapter->registrypriv.channel <= 14)
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_2_4G);
 	else
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_5G);
 
-	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel, 
+	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel,
 		CHANNEL_WIDTH_20, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TURN_ON_BLOCK);
@@ -1503,9 +1466,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	// HW SEQ CTRL
 	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
-	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF); 
-	
-	// 
+	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF);
+
+	//
 	// Disable BAR, suggested by Scott
 	// 2010.04.09 add by hpfan
 	//
@@ -1513,7 +1476,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	rtw_write8(Adapter,REG_SECONDARY_CCA_CTRL_8814A,0x03);
 
-	if(pregistrypriv->wifi_spec)
+	if (pregistrypriv->wifi_spec)
 		rtw_write16(Adapter,REG_FAST_EDCA_CTRL ,0);
 	//adjust EDCCA to avoid collision
 	/*if(pregistrypriv->wifi_spec)
@@ -1525,21 +1488,21 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	rtl8814_InitHalDm(Adapter);
-	
+
 	//
 	// 2010/08/11 MH Merge from 8192SE for Minicard init. We need to confirm current radio status
-	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not 
+	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not
 	// call init_adapter. May cause some problem??
 	//
-	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed 
-	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState 
+	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed
+	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState
 	// is the same as eRfOff, we should change it to eRfOn after we config RF parameters.
 	// Added by tynli. 2010.03.30.
 	pwrctrlpriv->rf_pwrstate = rf_on;
 
 	PHY_IQCalibrate_8814A_Init(&pHalData->odmpriv);
 
-#if (HAL_BB_ENABLE == 1)	
+#if (HAL_BB_ENABLE == 1)
 	PHY_SetRFEReg8814A(Adapter, _TRUE, pHalData->CurrentBandType);
 #endif //HAL_BB_ENABLE
 
@@ -1561,13 +1524,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	// Reset USB mode switch setting
 	rtw_write8(Adapter, REG_SDIO_CTRL_8814A, 0x0);
 	rtw_write8(Adapter, REG_ACLK_MON, 0x0);
-	
+
 	//RT_TRACE(COMP_INIT, DBG_TRACE, ("InitializeAdapter8188EUsb() <====\n"));
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	// 2010/08/26 MH Merge from 8192CE.
-	if(pwrctrlpriv->rf_pwrstate == rf_on)
-	{
+	if (pwrctrlpriv->rf_pwrstate == rf_on) {
 /*		if(IS_HARDWARE_TYPE_8812AU(Adapter))
 		{
 #if (RTL8812A_SUPPORT == 1)
@@ -1584,9 +1546,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	//this should be done by rf team using phydm code
 	//PHY_IQCalibrate_8814A(&pHalData->odmpriv, _FALSE);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
-		
+
 		//ODM_TXPowerTrackingCheck(&pHalData->odmpriv );
-		
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);
 		//PHY_LCCalibrate_8812A(Adapter);
 	}
@@ -1596,8 +1558,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC21);
 //HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PABIAS);
 //	_InitPABias(Adapter);
 #if (MP_DRIVER == 1)
-	if (Adapter->registrypriv.mp_mode == 1)
-	{
+	if (Adapter->registrypriv.mp_mode == 1) {
 		Adapter->mppriv.channel = pHalData->CurrentChannel;
 		MPT_InitializeAdapter(Adapter, Adapter->mppriv.channel);
 	}
@@ -1610,13 +1571,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BT_COEXIST);
 	// suspend mode automatically.
 	//HwSuspendModeEnable92Cu(Adapter, _FALSE);
 
-	if ( _TRUE == pHalData->EEPROMBluetoothCoexist)
-        {
-               // Init BT hw config.
-                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);      
-        }
-        else
-        {
+	if ( _TRUE == pHalData->EEPROMBluetoothCoexist) {
+		// Init BT hw config.
+                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);
+        } else {
                 // In combo card run wifi only , must setting some hardware reg.
                 rtl8812a_combo_card_WifiOnlyHwInit(Adapter);
         }
@@ -1633,18 +1591,18 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 
 	//misc
 	{
-		int i;		
+		int i;
 		u8 mac_addr[6];
-		for(i=0; i<6; i++)
-		{			
+		for (i=0; i<6; i++)
+		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if(Adapter->iface_type == IFACE_PORT1)
+			if (Adapter->iface_type == IFACE_PORT1)
 				mac_addr[i] = rtw_read8(Adapter, REG_MACID1+i);
 			else
 #endif
-			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);		
+			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);
 		}
-		
+
 		RTW_INFO("MAC Address from REG_MACID = "MAC_FMT"\n", MAC_ARG(mac_addr));
 	}
 
@@ -1656,14 +1614,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 	#ifdef DBG_HAL_INIT_PROFILING
 	hal_init_stages_timestamp[HAL_INIT_STAGES_END]=rtw_get_current_time();
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
 		RTW_INFO("DBG_HAL_INIT_PROFILING: %35s, %u, %5u, %5u\n"
 			, hal_init_stages_str[hal_init_profiling_i]
 			, hal_init_stages_timestamp[hal_init_profiling_i]
 			, (hal_init_stages_timestamp[hal_init_profiling_i+1]-hal_init_stages_timestamp[hal_init_profiling_i])
 			, rtw_get_time_interval_ms(hal_init_stages_timestamp[hal_init_profiling_i], hal_init_stages_timestamp[hal_init_profiling_i+1])
 		);
-	}	
+	}
 	#endif
 
 	return status;
@@ -1671,30 +1629,30 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 
 VOID
 hal_carddisable_8814(
-	IN	PADAPTER			Adapter 
+	IN	PADAPTER			Adapter
 )
 {
 	u8	u1bTmp;
 
 	RTW_INFO("CardDisableRTL8814AU\n");
 
-	// stop rx 
+	// stop rx
 	rtw_write8(Adapter, REG_CR_8814A, 0x0);
 
 	// Card disable power action flow
 	HalPwrSeqCmdParsing(Adapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_DISABLE_FLOW);
 
 	Adapter->bFWReady = _FALSE;
-	
+
 }
 
 static void rtl8814au_hw_power_down(_adapter *padapter)
 {
 	// 2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
 	// Then enable power down control bit of register 0x04 BIT4 and BIT15 as 1.
-		
+
 	// Enable register area 0x0-0xc.
-	rtw_write8(padapter,REG_RSV_CTRL, 0x0);			
+	rtw_write8(padapter,REG_RSV_CTRL, 0x0);
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
@@ -1705,8 +1663,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
    	RTW_INFO("==> %s \n",__FUNCTION__);
 
 #ifdef CONFIG_BT_COEXIST
-	if (hal_btcoex_IsBtExist(Adapter))
-	{
+	if (hal_btcoex_IsBtExist(Adapter)) {
 		RTW_INFO("BT module enable SIC\n");
 		// Only under WIN7 we can support selective suspend and enter D3 state when system call halt adapter.
 
@@ -1720,8 +1677,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 		rtw_write16(Adapter, REG_GPIO_MUXCFG, rtw_read16(Adapter, REG_GPIO_MUXCFG)&(~BIT12));
 	}
 
-	if(pHalData->bSupportUSB3 == _TRUE)
-	{
+	if (pHalData->bSupportUSB3 == _TRUE) {
 		// set Reg 0xf008[3:4] to 2'11 to eable U1/U2 Mode in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)|0x18);
 	}
@@ -1733,33 +1689,32 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 
  #ifdef SUPPORT_HW_RFOFF_DETECTED
  	RTW_INFO("bkeepfwalive(%x)\n", pwrctl->bkeepfwalive);
- 	if(pwrctl->bkeepfwalive)
- 	{
-		_ps_close_RF(Adapter);		
-		if((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
+ 	if (pwrctl->bkeepfwalive) {
+		_ps_close_RF(Adapter);
+		if ((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
 			rtl8814au_hw_power_down(Adapter);
  	}
 	else
 #endif
-	{	
+	{
 		if (rtw_is_hw_init_completed(Adapter)) {
 			hal_carddisable_8814(Adapter);
 
-			if((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
+			if ((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
 				rtl8814au_hw_power_down(Adapter);
 		}
-	}		
+	}
 	return _SUCCESS;
  }
 
 unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
-{	
-	u8 i;	
+{
+	u8 i;
 	struct recv_buf *precvbuf;
 	uint	status;
 	struct dvobj_priv *pdev= adapter_to_dvobj(Adapter);
 	struct intf_hdl * pintfhdl=&Adapter->iopriv.intf;
-	struct recv_priv *precvpriv = &(Adapter->recvpriv);	
+	struct recv_priv *precvpriv = &(Adapter->recvpriv);
 	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
@@ -1770,22 +1725,20 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 
 	status = _SUCCESS;
 
-	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
-		
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));
+
 	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
 
-	//issue Rx irp to receive data	
-	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
-	for(i=0; i<NR_RECVBUFF; i++)
-	{
-		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
-		{
+	//issue Rx irp to receive data
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i=0; i<NR_RECVBUFF; i++) {
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE ) {
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
 			status = _FAIL;
 			goto exit;
 		}
-		
-		precvbuf++;		
+
+		precvbuf++;
 		precvpriv->free_recv_buf_queue_cnt--;
 	}
 
@@ -1794,17 +1747,16 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 		status = _FAIL;
 		RTW_INFO("%s =>Warning !! Have not USB Int-IN pipe, RtIntInPipe(%d)!!!\n", __func__, pdev->RtInPipe[REALTEK_USB_IN_INT_EP_IDX]);
 		goto exit;
-	}	
+	}
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE )
-	{
+	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE ) {
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error \n"));
 		status = _FAIL;
 	}
 #endif
 
 exit:
-	
+
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
 
 	return status;
@@ -1812,9 +1764,9 @@ exit:
 }
 
 unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
-{	
+{
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
-	
+
 	rtw_read_port_cancel(Adapter);
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
@@ -1836,25 +1788,22 @@ hal_ReadIDs_8814AU(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	if( !AutoloadFail )
-	{
+	if ( !AutoloadFail ) {
 		pHalData->EEPROMVID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_VID_8814AU] );
-		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );		
-		
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );
+
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID = *(pu1Byte)&PROMContent[EEPROM_CustomID_8814];
 		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
-	}
-	else
-	{
+	} else {
 		pHalData->EEPROMVID 			= EEPROM_Default_VID;
 		pHalData->EEPROMPID 			= EEPROM_Default_PID;
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID		= EEPROM_Default_CustomerID;
 		pHalData->EEPROMSubCustomerID	= EEPROM_Default_SubCustomerID;
 	}
-	
+
 	RTW_INFO("VID = 0x%04X, PID = 0x%04X\n", pHalData->EEPROMVID, pHalData->EEPROMPID);
 	RTW_INFO("Customer ID: 0x%02X, SubCustomer ID: 0x%02X\n", pHalData->EEPROMCustomerID, pHalData->EEPROMSubCustomerID);
 }
@@ -1869,18 +1818,15 @@ hal_InitPGData_8814A(
 	u32			i;
 	u16			value16;
 
-	if(_FALSE == pHalData->bautoload_fail_flag)
-	{ // autoload OK.
+	if (_FALSE == pHalData->bautoload_fail_flag) { // autoload OK.
 		// hal_ReadeFuse_8814A is FW offload read efuse, todo
 	//#if ((DEV_BUS_TYPE==RT_USB_INTERFACE || DEV_BUS_TYPE==RT_SDIO_INTERFACE))  && (MP_DRIVER != 1)
 		//if(hal_ReadeFuse_8814A(pAdapter) == _FAIL)
 	//#endif
-		
+
 		// Read EFUSE real map to shadow.
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
-	}
-	else
-	{//autoload fail
+	} else { //autoload fail
 		RTW_INFO("AutoLoad Fail reported from CR9346!!\n");
 		//update to default value 0xFF
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
@@ -1899,11 +1845,11 @@ hal_CustomizedBehavior_8814AU(
 	IN	PADAPTER	Adapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct led_priv	*pledpriv = &(Adapter->ledpriv);
-	
+
 	// Led mode
-	switch(pHalData->CustomerID)
+	switch (pHalData->CustomerID)
 	{
 		case RT_CID_DEFAULT:
 			pledpriv->LedStrategy = SW_LED_MODE9;
@@ -1922,48 +1868,48 @@ hal_CustomizeByCustomerID_8814AU(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	
+
 	RTW_INFO("PID= 0x%x, VID=  %x\n",pHalData->EEPROMPID,pHalData->EEPROMVID);
-	
+
 	//	Decide CustomerID according to VID/DID or EEPROM
-	switch(pHalData->EEPROMCustomerID)
+	switch (pHalData->EEPROMCustomerID)
 	{
 		case EEPROM_CID_DEFAULT:
-			if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
+			if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
+			else if ((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
 			{
 				pHalData->CustomerID = RT_CID_CHINA_MOBILE;
-			}	
-			else if((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
+			}
+			else if ((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
 				pHalData->CustomerID = RT_CID_CC_C;
-			
+
 			break;
 		case EEPROM_CID_WHQL:
 			//padapter->bInHctTest = _TRUE;
-	
+
 			//pMgntInfo->bSupportTurboMode = _FALSE;
 			//pMgntInfo->bAutoTurboBy8186 = _FALSE;
-	
+
 			//pMgntInfo->PowerSaveControl.bInactivePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bIPSModeBackup = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePsModeBackup = _FALSE;
 			//pMgntInfo->keepAliveLevel = 0;
-	
+
 			//padapter->bUnloadDriverwhenS3S4 = _FALSE;
-			break;			
+			break;
 		default:
 			pHalData->CustomerID = RT_CID_DEFAULT;
 			break;
-			
+
 	}
 	RTW_INFO("Customer ID: 0x%2x\n", pHalData->CustomerID);
-	
+
 	hal_CustomizedBehavior_8814AU(pAdapter);
 }
 
@@ -1975,7 +1921,7 @@ hal_ReadUsbModeSwitch_8814AU(
 	)
 {
   	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-	
+
 	if (AutoloadFail)
 		pHalData->EEPROMUsbSwitch = _FALSE;
 	else
@@ -1985,7 +1931,7 @@ hal_ReadUsbModeSwitch_8814AU(
 
 static VOID
 ReadLEDSetting_8814AU(
-	IN	PADAPTER	Adapter,	
+	IN	PADAPTER	Adapter,
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -2015,19 +1961,19 @@ InitAdapterVariablesByPROM_8814AU(
 	hal_ReadTxPowerInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadBoardType8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_Read_TRX_antenna_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	//
 	// Read Bluetooth co-exist and initialize
 	//
 	hal_EfuseParseBTCoexistInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	hal_ReadChannelPlan8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_EfuseParseXtal_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);	
 	hal_ReadThermalMeter_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRemoteWakeup_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadAntennaDiversity8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRFEType_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	ReadLEDSetting_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 
 	hal_ReadUsbModeSwitch_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
@@ -2041,7 +1987,7 @@ InitAdapterVariablesByPROM_8814AU(
 static void hal_ReadPROMContent_8814A(
 	IN PADAPTER 		Adapter
 	)
-{	
+{
 	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(Adapter);
 	u8			eeValue;
 
@@ -2064,7 +2010,7 @@ ReadAdapterInfo8814AU(
 	)
 {
 	Hal_InitEfuseVars_8814A(Adapter);
-	
+
 	// Read all content in Efuse/EEPROM.
 	hal_ReadPROMContent_8814A(Adapter);
 
@@ -2079,21 +2025,21 @@ void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 Remo
 	u32 *himr;
 	pHalData = GET_HAL_DATA(padapter);
 
-	if(bHIMR0)
+	if (bHIMR0)
 		himr = &(pHalData->IntrMask[0]);
 	else
 		himr = &(pHalData->IntrMask[1]);
-	
+
 	if (AddMSR)
 		*himr |= AddMSR;
 
 	if (RemoveMSR)
 		*himr &= (~RemoveMSR);
 
-	if(bHIMR0)	
+	if (bHIMR0)
 		rtw_write32(padapter, REG_HIMR0_8814A, *himr);
 	else
-		rtw_write32(padapter, REG_HIMR1_8814A, *himr);	
+		rtw_write32(padapter, REG_HIMR1_8814A, *himr);
 
 }
 
@@ -2103,7 +2049,7 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
 	struct registry_priv *registry_par = &Adapter->registrypriv;
 
-	switch(variable)
+	switch (variable)
 	{
 		case HW_VAR_RXDMA_AGG_PG_TH:
 #ifdef CONFIG_USB_RX_AGGREGATION
@@ -2185,9 +2131,9 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 
 void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	switch(variable)
+	switch (variable)
 	{
 		default:
 			GetHwReg8814A(Adapter,variable,val);
@@ -2210,7 +2156,7 @@ SetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			SetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2221,7 +2167,7 @@ SetHalDefVar8814AUsb(
 }
 
 //
-//	Description: 
+//	Description:
 //		Query setting of specified variable.
 //
 u8
@@ -2234,7 +2180,7 @@ GetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			GetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2302,9 +2248,9 @@ static void rtl8814au_init_default_value(_adapter * padapter)
 }
 
 static u8 rtl8814au_ps_func(PADAPTER Adapter,HAL_INTF_PS_FUNC efunc_id, u8 *val)
-{	
+{
 	u8 bResult = _TRUE;
-	switch(efunc_id){
+	switch (efunc_id) {
 
 		#if defined(CONFIG_AUTOSUSPEND) && defined(SUPPORT_HW_RFOFF_DETECTED)
 		case HAL_USB_SELECT_SUSPEND:
@@ -2327,7 +2273,7 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 
 	pHalFunc->hal_power_on = _InitPowerOn_8814AU;
 	pHalFunc->hal_power_off = hal_carddisable_8814;
-	
+
 	pHalFunc->hal_init = &rtl8814au_hal_init;
 	pHalFunc->hal_deinit = &rtl8814au_hal_deinit;
 
@@ -2345,12 +2291,12 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 #else //case of hw led or no led
 	pHalFunc->InitSwLeds = NULL;
 	pHalFunc->DeInitSwLeds = NULL;
-#endif//CONFIG_SW_LED
-	
+#endif //CONFIG_SW_LED
+
 	pHalFunc->init_default_value = &rtl8814au_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8814au_interface_configure;
 	pHalFunc->read_adapter_info = &ReadAdapterInfo8814AU;
- 
+
 	pHalFunc->SetHwRegHandler = &SetHwReg8814AU;
 	pHalFunc->GetHwRegHandler = &GetHwReg8814AU;
   	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8814AUsb;
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
index 59281f9..d2fea87 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,17 +24,16 @@
 
 #ifdef CONFIG_SUPPORT_USB_INT
 void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
-{	
+{
 	HAL_DATA_TYPE	*pHalData=GET_HAL_DATA(padapter);
 	struct reportpwrstate_parm pwr_rpt;
-	
-	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN )
-	{
+
+	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN ) {
 		RTW_INFO("%s Invalid interrupt content length (%d)!\n", __FUNCTION__, pkt_len);
 		return ;
 	}
 
-	// HISR 
+	// HISR
 	_rtw_memcpy(&(pHalData->IntArray[0]), &(pbuf[USB_INTR_CONTENT_HISR_OFFSET]), 4);
 	_rtw_memcpy(&(pHalData->IntArray[1]), &(pbuf[USB_INTR_CONTENT_HISRE_OFFSET]), 4);
 
@@ -42,25 +41,24 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	{
 		u32 hisr=0 ,hisr_ex=0;
 		_rtw_memcpy(&hisr,&(pHalData->IntArray[0]),4);
-		hisr = le32_to_cpu(hisr);	
-		
+		hisr = le32_to_cpu(hisr);
+
 		_rtw_memcpy(&hisr_ex,&(pHalData->IntArray[1]),4);
 		hisr_ex = le32_to_cpu(hisr_ex);
-		
-		if((hisr != 0) || (hisr_ex!=0))
+
+		if ((hisr != 0) || (hisr_ex!=0))
 			RTW_INFO("===> %s hisr:0x%08x ,hisr_ex:0x%08x \n",__FUNCTION__,hisr,hisr_ex);
 	}
 	#endif
 
 
 #ifdef CONFIG_LPS_LCLK
-	if(  pHalData->IntArray[0]  & IMR_CPWM_88E )
-	{
+	if (  pHalData->IntArray[0]  & IMR_CPWM_88E ) {
 		_rtw_memcpy(&pwr_rpt.state, &(pbuf[USB_INTR_CONTENT_CPWM1_OFFSET]), 1);
 		//_rtw_memcpy(&pwr_rpt.state2, &(pbuf[USB_INTR_CONTENT_CPWM2_OFFSET]), 1);
 
-		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.		
-		pwr_rpt.state |= PS_STATE_S2;		
+		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.
+		pwr_rpt.state |= PS_STATE_S2;
 		_set_workitem(&(adapter_to_pwrctl(padapter)->cpwm_event));
 	}
 #endif//CONFIG_LPS_LCLK
@@ -72,40 +70,38 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	#endif
 	#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
 	if (pHalData->IntArray[0] & (IMR_TBDER_88E|IMR_TBDOK_88E))
-	#endif	
-	{		
+	#endif
+	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 		#if 0
-		if(pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
+		if (pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
 			RTW_INFO("%s: HISR_BCNERLY_INT\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDOK_88E)
+		if (pHalData->IntArray[0] & IMR_TBDOK_88E)
 			RTW_INFO("%s: HISR_TXBCNOK\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDER_88E)
+		if (pHalData->IntArray[0] & IMR_TBDER_88E)
 			RTW_INFO("%s: HISR_TXBCNERR\n", __func__);
 		#endif
-		
 
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
-		{
+
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(pmlmepriv->update_bcn == _TRUE)
+			if (pmlmepriv->update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter);
 			}
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_fwstate(padapter, WIFI_AP_STATE))
-		{
+		if (check_buddy_fwstate(padapter, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
+			if (padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter->pbuddy_adapter);
 			}
 		}
 #endif
-		
+
 	}
 #endif //CONFIG_INTERRUPT_BASED_TXBCN
 
@@ -361,8 +357,9 @@ int recvbuf2recvframe(PADAPTER padapter, void *ptr)
 		}
 
 #ifdef CONFIG_RX_PACKET_APPEND_FCS
-		if(pattrib->pkt_rpt_type == NORMAL_RX)
-			pattrib->pkt_len -= IEEE80211_FCS_LEN;
+                if (check_fwstate(&padapter->mlmepriv, WIFI_MONITOR_STATE) == _FALSE)
+                        if ((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                                pattrib->pkt_len -= IEEE80211_FCS_LEN;
 #endif
 		if(rtw_os_alloc_recvframe(padapter, precvframe, 
 			(pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), pskb) == _FAIL)
diff --git a/drivers/net/wireless/rtl8812au/include/autoconf.h b/drivers/net/wireless/rtl8812au/include/autoconf.h
index 2e1c614..3c1713f 100644
--- a/drivers/net/wireless/rtl8812au/include/autoconf.h
+++ b/drivers/net/wireless/rtl8812au/include/autoconf.h
@@ -309,7 +309,6 @@
 #endif /* !CONFIG_BT_COEXIST */
 
 
-
 #ifdef CONFIG_USB_TX_AGGREGATION
 /* #define	CONFIG_TX_EARLY_MODE */
 #endif
@@ -347,12 +346,11 @@
 /* #define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap" */
 
 
-
 /* #define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE */
 /* #define DBG_ROAMING_TEST */
 
 /* #define DBG_HAL_INIT_PROFILING */
 
-/*#define DBG_MEMORY_LEAK*/
+/* #define DBG_MEMORY_LEAK*/
 #define	DBG_RX_DFRAME_RAW_DATA
-/*#define CONFIG_USE_EXTERNAL_POWER  */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate*/
+/* #define CONFIG_USE_EXTERNAL_POWER */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate */
diff --git a/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h b/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h
index 69bd71d..7acbb95 100644
--- a/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 #ifndef __RTW_WIFI_REGD_H__
-#define __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__ 
 
 int rtw_regd_init(_adapter *padapter);
 void rtw_reg_notify_by_driver(_adapter *adapter);
diff --git a/drivers/net/wireless/rtl8812au/include/rtw_xmit.h b/drivers/net/wireless/rtl8812au/include/rtw_xmit.h
index d372338..6b5ea43 100644
--- a/drivers/net/wireless/rtl8812au/include/rtw_xmit.h
+++ b/drivers/net/wireless/rtl8812au/include/rtw_xmit.h
@@ -421,7 +421,7 @@ struct pkt_attrib {
 	u8	rate;
 	u8	intel_proxim;
 	u8	retry_ctrl;
-	u8	sw_seq;
+	//u8	sw_seq; // Add support for pre-configured SeqNum via RadioTap
 	u8   mbssid;
 	u8	ldpc;
 	u8	stbc;
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c
index 8a7e088..17937e7 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c
@@ -1750,6 +1750,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 
 		sinfo->filled |= STATION_INFO_BSS_PARAM;
 
+#if defined (LINUX_VERSION_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 20, 0))
 		if (!psta->no_short_preamble_set)
 		  sinfo->bss_param.flags |= STATION_INFO_BSS_PARAM_SHORT_PREAMBLE;
 
@@ -1765,6 +1766,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 		sinfo->bss_param.dtim_period = pwrctl->dtim;
 		
 		sinfo->bss_param.beacon_interval = get_beacon_interval(&cur_network->network);
+#endif
 
 	}
 
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c b/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c
index 52fbba5..a802a9d 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c
@@ -445,10 +445,11 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 #endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
 
 		ret = rtw_netif_rx(padapter->pnetdev, pkt);
-		if (ret == NET_RX_SUCCESS)
+		if (ret == NET_RX_SUCCESS) {
 			DBG_COUNTER(padapter->rx_logs.os_netif_ok);
-		else
+		} else {
 			DBG_COUNTER(padapter->rx_logs.os_netif_err);
+		}
 	}
 }
 
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c b/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c
index 6ed4e72..47b3435 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c
@@ -222,6 +222,7 @@ static struct usb_device_id rtw_usb_id_tbl[] = {
 	{USB_DEVICE(0x2001, 0x331A), .driver_info = RTL8814A}, /* D-Link - D-Link */
 	{USB_DEVICE(0x0B05, 0x1817), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x0B05, 0x1852), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
+	{USB_DEVICE(0x0B05, 0x1853), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x056E, 0x400B), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x056E, 0x400D), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x7392, 0xA834), .driver_info = RTL8814A}, /* Edimax - Edimax */
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c
index fa8ba7b..b0a4abd 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c
@@ -15,8 +15,8 @@ void rtw_reg_notify_by_driver(_adapter *adapter)
 	return;
 }
 
-int rtw_regd_init(_adapter *padapter)
+int rtw_regd_init(_adapter * padapter)
 {
 	return 0;
 }
-#endif /* CONFIG_IOCTL_CFG80211 */
+#endif //CONFIG_IOCTL_CFG80211
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c b/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
index cc65410..050bfa3 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
@@ -1420,10 +1420,11 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 #ifdef CONFIG_AP_MODE
 	switch (GetFrameSubType(pframe)) {
 	case WIFI_AUTH:
-		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) {
 			ptable->func = &OnAuth;
-		else
+		} else
 			ptable->func = &OnAuthClient;
+	/* Intentional fallthrough */
 	/* pass through */
 	case WIFI_ASSOCREQ:
 	case WIFI_REASSOCREQ:
@@ -2201,14 +2202,15 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 			if (rtw_is_list_empty(&pstat->asoc_list) == _FALSE) {
 				rtw_list_delete(&pstat->asoc_list);
 				pstapriv->asoc_list_cnt--;
-				if (pstat->expire_to > 0)
+				if (pstat->expire_to > 0) {
 					;/* TODO: STA re_auth within expire_to */
+				}
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
-			if (seq == 1)
+			if (seq == 1) {
 				; /* TODO: STA re_auth and auth timeout */
-
+			}
 		}
 	}
 
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c b/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
index d8b45f4..0a596db 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
@@ -219,6 +219,7 @@ bool rtw_pwr_unassociated_idle(_adapter *adapter)
 			    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 			    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 			    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+			    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 			    || pcfg80211_wdinfo->is_ro_ch
 #elif defined(CONFIG_P2P)
@@ -618,6 +619,7 @@ u8 PS_RDY_CHECK(_adapter *padapter)
 	    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 	    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 	    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+	    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 	    || pcfg80211_wdinfo->is_ro_ch
 #endif
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_recv.c b/drivers/net/wireless/rtl8814au/core/rtw_recv.c
index 83ed24e..8bb59ee 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_recv.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_recv.c
@@ -2125,7 +2125,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 			if ((bDumpRxPkt == 4) && (eth_type == 0x888e))
 				dump_rx_packet(ptr);
 #endif
-		} else
+		} else {
 			DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_handled);
 		break;
 	default:
@@ -2136,6 +2136,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 		retval = _FAIL;
 		break;
 	}
+}
 
 exit:
 
@@ -3607,8 +3608,15 @@ static sint fill_radiotap_hdr(_adapter *padapter, union recv_frame *precvframe)
 	if (pattrib->mfrag)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FRAG;
 
-	/* always append FCS */
-	/* hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS; */
+#ifdef CONFIG_RX_PACKET_APPEND_FCS
+        // Start by always indicating FCS is there:
+        hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS;
+
+        // Next, test for prior conditions that will remove FCS, and update flag accordingly:
+        if(check_fwstate(&padapter->mlmepriv,WIFI_MONITOR_STATE) == _FALSE)
+                if((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                        hdr_buf[rt_len] &= ~IEEE80211_RADIOTAP_F_FCS;
+#endif
 
 	if (0)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_DATAPAD;
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c b/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
index 54c9a35..6de4e2e 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
@@ -2353,8 +2353,7 @@ int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
 
 		_rtw_memcpy(recv_beacon->ssid, elems.ssid, elems.ssid_len);
 		recv_beacon->ssid_len = elems.ssid_len;
-	} else
-		; /* means hidden ssid */
+	} else { ; } /* means hidden ssid */
 
 	/* checking RSN first */
 	if (elems.rsn_ie && elems.rsn_ie_len) {
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_xmit.c b/drivers/net/wireless/rtl8814au/core/rtw_xmit.c
index 1620473..c1019bb 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_xmit.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_xmit.c
@@ -1254,10 +1254,11 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		_rtw_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_ap);
-	} else
+	} else {
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_unknown);
 
 	bmcast = IS_MCAST(pattrib->ra);
+	}
 	if (bmcast) {
 		psta = rtw_get_bcmc_stainfo(padapter);
 		if (psta == NULL) { /* if we cannot get psta => drop the pkt */
@@ -3874,7 +3875,7 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	u32 len = skb->len;
 	u8 category, action;
 	int type = -1;
-	
+
 	//RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if (skb)
@@ -3922,17 +3923,17 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 					fixed_rate = 0;
 				fixed_rate += MGN_MCS0;
 			}
-			if ((mcs_have & 4) && 
+			if ((mcs_have & 4) &&
 			    (iterator.this_arg[1] & 4))
 				sgi = 1;
-			if ((mcs_have & 1) && 
+			if ((mcs_have & 1) &&
 			    (iterator.this_arg[1] & 1))
 				bwidth = 1;
-			if ((mcs_have & 0x10) && 
+			if ((mcs_have & 0x10) &&
 			    (iterator.this_arg[1] & 0x10))
 				ldpc = 1;
 			if ((mcs_have & 0x20))
-				stbc = (iterator.this_arg[1] >> 5) & 3;	
+				stbc = (iterator.this_arg[1] >> 5) & 3;
 		}
 		break;
 
@@ -3994,9 +3995,9 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	pattrib->ldpc = ldpc;
 	pattrib->stbc = stbc;
 	pattrib->retry_ctrl = (txflags & 0x08)?_FALSE:_TRUE;
-	pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;
+	// pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;  // Adds support for pre-configured SeqNum via RadioTap
+
 
-	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
index 22f793c..b7ff6f6 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MPCIE.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MPCIE[] = { 
+u1Byte Array_MP_8814A_MPCIE[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
index 8b51c1b..9b4d7c5 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
index cd80e92..d882d92 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MUSB.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MUSB[] = { 
+u1Byte Array_MP_8814A_MUSB[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
index 4262400..be33e37 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c
index 68ee167..bc5f941 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c
@@ -112,7 +112,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz , u8 ba
 
 	/* offset 12 */
 
-	if (!pattrib->qos_en && pattrib->sw_seq == _FALSE) {
+	if (!pattrib->qos_en) {
 		SET_TX_DESC_HWSEQ_EN_8812(ptxdesc, 1); /* Hw set sequence number */
 	} else
 		SET_TX_DESC_SEQ_8812(ptxdesc, pattrib->seqnum);
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c
index 423ba9f..f0a247a 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c
@@ -554,7 +554,6 @@ PHY_ConfigBB_8814A(
 }
 
 
-
 //2 3.3 RF Config
 
 s32
@@ -1157,7 +1156,7 @@ PHY_GetTxPowerIndex_8814A(
 	tpt_offset = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);
 
 	powerDiffByRate = powerDiffByRate > limit ? limit : powerDiffByRate;
-	/*RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);*/
+	RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);
 
 	txPower += powerDiffByRate;
 
@@ -1184,8 +1183,8 @@ PHY_GetTxPowerIndex_8814A(
 		//(pHalData->bautoload_fail_flag || pHalData->EfuseMap[EFUSE_INIT_MAP][EEPROM_TX_PWR_INX_JAGUAR] == 0xFF))
 		//txPower = 0x12;
 
-	/*RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
-		txPower, txPower);*/
+	RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
+		txPower, txPower);
 
 	return (u8) txPower;
 }
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c
index 4a7947e..b9e83fd 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c
@@ -93,7 +93,7 @@ void rtl8814_sreset_linked_status_check(_adapter *padapter)
 	regc58 = rtw_read32(padapter,0xc58);
 	reg824 = rtw_read32(padapter,0x824);
 	reg800 = rtw_read32(padapter,0x800);
-	if(	((regc50&0xFFFFFF00)!= 0x69543400)||
+	if (	((regc50&0xFFFFFF00)!= 0x69543400)||
 		((regc58&0xFFFFFF00)!= 0x69543400)||
 		(((reg824&0xFFFFFF00)!= 0x00390000)&&(((reg824&0xFFFFFF00)!= 0x80390000)))||
 		( ((reg800&0xFFFFFF00)!= 0x03040000)&&((reg800&0xFFFFFF00)!= 0x83040000)))
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c
index 43b8268..bb6cdd8 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c
@@ -172,7 +172,6 @@ InsertEMContent_8814(
 }
 
 
-
 void UpdateEarlyModeInfo8814(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf )
 {
 	//_adapter *padapter, struct xmit_frame *pxmitframe,struct tx_servq	*ptxservq
@@ -254,7 +253,6 @@ void rtl8814a_cal_txdesc_chksum(u8 *ptxdesc)
 	u32 index;
 	u16 checksum = 0;
 
-
 	usPtr = (u16*)ptxdesc;
 	// checksume is always calculated by first 32 bytes,
 	// and it doesn't depend on TX DESC length.
@@ -439,7 +437,7 @@ BWMapping_8814(
 		else
 			BWSettingOfDesc = 0;
 	}
-	else if(pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
+	else if (pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
 		if ((pattrib->bwmode == CHANNEL_WIDTH_40) || (pattrib->bwmode == CHANNEL_WIDTH_80))
 			BWSettingOfDesc = 1;
 		else
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
index 8200263..0f4d3e1 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
@@ -61,7 +61,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	if (padapter->registrypriv.mp_mode == 0) {
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
 			ptxdesc = (pmem+PACKET_OFFSET_SZ);
 			//RTW_INFO("==> non-agg-pkt,shift pointer...\n");
 			pull = 1;
@@ -94,10 +94,9 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	}
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
-	if (padapter->registrypriv.mp_mode == 0)
-	{
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)){
-			if((pull) && (pxmitframe->pkt_offset>0)) {
+	if (padapter->registrypriv.mp_mode == 0) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)) {
+			if ((pull) && (pxmitframe->pkt_offset>0)) {
 				pxmitframe->pkt_offset = pxmitframe->pkt_offset -1;
 			}
 		}
@@ -119,10 +118,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 	if (!pattrib->qos_en) {
 		/* HW sequence, to fix to use 0 queue. todo: 4AC packets to use auto queue select */
-		if (pattrib->sw_seq == _FALSE)
-			SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
-		else
-			SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
+		SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
 		SET_TX_DESC_EN_HWEXSEQ_8814A(ptxdesc, 0);
 		SET_TX_DESC_DISQSELSEQ_8814A(ptxdesc, 1);
 		SET_TX_DESC_HW_SSN_SEL_8814A(ptxdesc, 0);
@@ -130,8 +126,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 		SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
 	}
 
-	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-	{
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
 		//RTW_INFO("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
 		rtl8814a_fill_txdesc_sectype(pattrib, ptxdesc);
@@ -189,7 +184,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (padapter->fix_rate != 0xFF) { // modify data rate by iwpriv
 				SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 				DriverFixedRate = 0x01;
-				if(padapter->fix_rate & BIT(7))
+				if (padapter->fix_rate & BIT(7))
 					SET_TX_DESC_DATA_SHORT_8814A(ptxdesc, 	1);
 
 				SET_TX_DESC_TX_RATE_8814A(ptxdesc, (padapter->fix_rate & 0x7F));
@@ -202,7 +197,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (pattrib->stbc)
 				SET_TX_DESC_DATA_STBC_8814A(ptxdesc, 1);
 
-			//work arond before fixing RA
+			//work around before fixing RA
 			//SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 			//SET_TX_DESC_TX_RATE_8814A(ptxdesc, 0x10);
 		} else {
@@ -253,7 +248,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			SET_TX_DESC_DATA_RETRY_LIMIT_8814A(ptxdesc, 5);
 			SET_TX_DESC_DISABLE_FB_8814A(ptxdesc, 1);
 
-			//if(pattrib->rts_cca)
+			//if (pattrib->rts_cca)
 			//{
 			//	SET_TX_DESC_NDPA_8812(ptxdesc, 2);
 			//}
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c
index b134d5a..e9a5c68 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,8 +33,7 @@ static void _dbg_dump_macreg(_adapter *padapter)
 	u32 offset = 0;
 	u32 val32 = 0;
 	u32 index =0 ;
-	for(index=0;index<64;index++)
-	{
+	for (index=0;index<64;index++) {
 		offset = index*4;
 		val32 = rtw_read32(padapter,offset);
 		RTW_INFO("offset : 0x%02x ,val:0x%08x\n",offset,val32);
@@ -52,11 +51,11 @@ _ConfigChipOutEP_8814(
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber = 0;
 
-	switch(NumOutPipe){
+	switch (NumOutPipe) {
 		case 	4:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=4;
-				break;		
+				break;
 		case 	3:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=3;
@@ -69,9 +68,9 @@ _ConfigChipOutEP_8814(
 				pHalData->OutEpQueueSel=TX_SELE_HQ;
 				pHalData->OutEpNumber=1;
 				break;
-		default:				
+		default:
 				break;
-			
+
 	}
 	RTW_INFO("%s OutEpQueueSel(0x%02x), OutEpNumber(%d) \n",__FUNCTION__,pHalData->OutEpQueueSel,pHalData->OutEpNumber );
 
@@ -87,10 +86,10 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	BOOLEAN			result		= _FALSE;
 
 	_ConfigChipOutEP_8814(pAdapter, NumOutPipe);
-	
+
 	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
-	if(1 == pHalData->OutEpNumber){
-		if(1 != NumInPipe){
+	if (1 == pHalData->OutEpNumber) {
+		if (1 != NumInPipe) {
 			return result;
 		}
 	}
@@ -101,7 +100,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	//}
 
 	result = Hal_MappingOutPipe(pAdapter, NumOutPipe);
-	
+
 	return result;
 
 }
@@ -173,55 +172,45 @@ _InitBurstPktLen(IN PADAPTER Adapter)
 {
 	u8 			u1bTmp;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
- 
+
 	//yx_qi 131128 move to 0x1448, 144c
 	rtw_write32(Adapter, REG_FAST_EDCA_VOVI_SETTING_8814A, 0x08070807); //yx_qi 131128
 	rtw_write32(Adapter, REG_FAST_EDCA_BEBK_SETTING_8814A, 0x08070807); //yx_qi 131128
-	
+
 	u1bTmp = rtw_read8(Adapter, 0xff); //check device operation speed: SS 0xff bit7
-	
-	if(u1bTmp & BIT7)   //USB2/1.1 Mode
-	{
+
+	if (u1bTmp & BIT7) { //USB2/1.1 Mode
  		pHalData->bSupportUSB3 = FALSE;
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		pHalData->bSupportUSB3 = TRUE;
 	}
-	
-	if(pHalData->bSupportUSB3 == _FALSE)   //USB2/1.1 Mode
-	{
-		if(pHalData->UsbBulkOutSize == 512)
-		{
+
+	if (pHalData->bSupportUSB3 == _FALSE) { //USB2/1.1 Mode
+		if (pHalData->UsbBulkOutSize == 512) {
 			//set burst pkt len=512B
 			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x1e);
-		}
-		else
-		{
+		} else {
 			//set burst pkt len=64B
-			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);		
+			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);
 		}
 
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x2005); //dmc agg th 20K
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		//set burst pkt len=1k
-		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);				
+		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x0a05); //dmc agg th 20K
-		
+
 		// set Reg 0xf008[3:4] to 2'00 to disable U1/U2 Mode to avoid 2.5G spur in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)&0xE7);
 		//to avoid usb 3.0 H2C fail
 		rtw_write16(Adapter, 0xf002, 0);
-		
+
 		rtw_write8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A, rtw_read8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A) & ~BIT(6));
 		RTW_INFO("turn off the LDPC pre-TX\n");
-		
-	} 
 
-	if(pHalData->AMPDUBurstMode)
-	{
+	}
+
+	if (pHalData->AMPDUBurstMode) {
 		rtw_write8(Adapter,REG_SW_AMPDU_BURST_MODE_CTRL_8814A,  0x5F);
 	}
 }
@@ -232,7 +221,7 @@ _InitQueueReservedPage_8814AUsb(
 	)
 {
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
-	u16		txpktbuf_bndy; 
+	u16		txpktbuf_bndy;
 
 	RTW_INFO("===>_InitQueueReservedPage_8814AUsb()\n");
 
@@ -246,7 +235,7 @@ _InitQueueReservedPage_8814AUsb(
 
 	rtw_write32(Adapter, REG_RQPN_CTRL_2_8814A, 0x80000000);
 
-	if(!pregistrypriv->wifi_spec)
+	if (!pregistrypriv->wifi_spec)
 		txpktbuf_bndy = TX_PAGE_BOUNDARY_8814A;
 	else		// for WMM
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_8814A;
@@ -260,7 +249,7 @@ _InitQueueReservedPage_8814AUsb(
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A, txpktbuf_bndy);
 	//The head page of packet of Bcnq1
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A+2,txpktbuf_bndy);
-	
+
 	RTW_INFO("<===_InitQueueReservedPage_8814AUsb()\n");
 }
 
@@ -273,7 +262,7 @@ static u32 _InitPowerOn_8814AU(_adapter *padapter)
 	u8	u1btmp = rtw_read8(padapter, 0x10C2);
 	rtw_write8(padapter, 0x10C2, (u1btmp | BIT1));
 
-	if(!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
+	if (!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
 		return _FAIL;
 
 	// Enable MAC DMA/WMAC/SCHEDULE/SEC block
@@ -320,9 +309,9 @@ _InitPageBoundary_8814AUsb(
 {
 	//20130416 KaiYuan modified for 8814
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
-	
+
 	rtw_write16(Adapter, REG_RXFF_PTR_8814A, RX_DMA_BOUNDARY_8814A); //yx_qi 20140331
-	
+
 }
 
 static VOID
@@ -353,11 +342,11 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
-	
+
 	u16	valueHi = 0;
 	u16	valueLow = 0;
-	
-	switch(pHalData->OutEpQueueSel)
+
+	switch (pHalData->OutEpQueueSel)
 	{
 		case (TX_SELE_HQ | TX_SELE_LQ):
 			valueHi = QUEUE_HIGH;
@@ -373,27 +362,27 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 			break;
 		default:
 			valueHi = QUEUE_HIGH;
-			valueLow = QUEUE_NORMAL;			
+			valueLow = QUEUE_NORMAL;
 			break;
 	}
 
-	if(!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		beQ 		= valueLow;
 		bkQ 		= valueLow;
 		viQ		= valueHi;
 		voQ 		= valueHi;
-		mgtQ 	= valueHi; 
-		hiQ 		= valueHi;								
+		mgtQ 	= valueHi;
+		hiQ 		= valueHi;
 	}
-	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+	else { //for WMM ,CONFIG_OUT_EP_WIFI_MODE
 		beQ		= valueLow;
 		bkQ 		= valueHi;
 		viQ 		= valueHi;
 		voQ 		= valueLow;
 		mgtQ 	= valueHi;
-		hiQ 		= valueHi;							
+		hiQ 		= valueHi;
 	}
-	
+
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
 
@@ -405,21 +394,20 @@ _InitNormalChipThreeOutEpPriority_8814AUsb(
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if(!pregistrypriv->wifi_spec){// typical setting
+	if (!pregistrypriv->wifi_spec) { // typical setting
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_LOW;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
-	}
-	else{// for WMM
+		hiQ 		= QUEUE_HIGH;
+	} else { // for WMM
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_NORMAL;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
+		hiQ 		= QUEUE_HIGH;
 	}
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
@@ -431,7 +419,7 @@ _InitQueuePriority_8814AUsb(
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	switch(pHalData->OutEpNumber)
+	switch (pHalData->OutEpNumber)
 	{
 		case 2:
 			_InitNormalChipTwoOutEpPriority_8814AUsb(Adapter);
@@ -499,8 +487,8 @@ _InitWMACSetting_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	//pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
-	pHalData->ReceiveConfig = 
-	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;	  
+	pHalData->ReceiveConfig =
+	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
 	pHalData->ReceiveConfig |= ACRC32;
@@ -539,7 +527,7 @@ _InitWMACSetting_8814A(
 	//rtw_write16(Adapter, REG_RXFLTMAP0, value16);
 
 	//enable RX_SHIFT bits
-	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));	
+	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));
 
 }
 */
@@ -553,21 +541,21 @@ _InitMacConfigure_8814A(
 	u16			value16;
 	u32			regRRSR;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	
+
 	switch (Adapter->registrypriv.wireless_mode)
 	{
 		case WIRELESS_11B:
 			regRRSR = RATE_ALL_CCK;
 			break;
-		
+
 		case WIRELESS_11G:
 		case WIRELESS_11A:
 		case WIRELESS_11_5N:
-		case WIRELESS_11A_5N://Todo: no basic rate for ofdm ?
+		case WIRELESS_11A_5N: //Todo: no basic rate for ofdm ?
 		case WIRELESS_11_5AC:
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-		
+
 		case WIRELESS_11BG:
 		case WIRELESS_11G_24N:
 		case WIRELESS_11_24N:
@@ -575,7 +563,7 @@ _InitMacConfigure_8814A(
 		default:
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
-	
+
 	}
 
 	// Init value for RRSR.
@@ -584,7 +572,7 @@ _InitMacConfigure_8814A(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RETRY_LIMIT_8814A, value16);
-	
+
 	pHalData->ReceiveConfig = RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 	pHalData->ReceiveConfig |= FORCEACK;
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
@@ -608,8 +596,8 @@ _InitMacConfigure_8814A(
 
 	// 201409/25 MH When RA is enabled, we need to reduce the value.
 	rtw_write8(Adapter, REG_MAX_AGGR_NUM_8814A, 0x36);
-	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36); 
-	
+	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36);
+
 }
 
 /*
@@ -643,7 +631,7 @@ _InitAdaptiveCtrl_8812AUsb(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
-	
+
 }*/
 
 static VOID
@@ -656,7 +644,7 @@ _InitEDCA_8814AUsb(
 	rtw_write16(Adapter,REG_MAC_SPEC_SIFS, 0x100a);
 
 	// Set SIFS for CCK
-	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);	
+	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);
 
 	// Set SIFS for OFDM
 	rtw_write16(Adapter,REG_SIFS_TRX, 0x100a);
@@ -679,9 +667,9 @@ _InitBeaconMaxError_8814A(
 	)
 {
 #ifdef CONFIG_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);	
+	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
 #else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));	
+	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
 #endif
 }
 
@@ -689,12 +677,12 @@ _InitBeaconMaxError_8814A(
 static void _InitHWLed(PADAPTER Adapter)
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
-	
-	if( pledpriv->LedStrategy != HW_LED)
+
+	if ( pledpriv->LedStrategy != HW_LED)
 		return;
-	
+
 // HW led control
-// to do .... 
+// to do ....
 //must consider cases of antenna diversity/ commbo card/solo card/mini card
 
 }
@@ -717,7 +705,7 @@ _InitRetryFunction_8814A(
 	)
 {
 	u8	value8;
-	
+
 	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
 	value8 |= EN_AMPDU_RTY_NEW;
 	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
@@ -730,7 +718,7 @@ _InitRetryFunction_8814A(
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingTxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -751,25 +739,25 @@ usb_AggSettingTxUpdate_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32			value32;
 
-	if(Adapter->registrypriv.wifi_spec)
+	if (Adapter->registrypriv.wifi_spec)
 		pHalData->UsbTxAggDescNum = 1;
 
-	if(pHalData->UsbTxAggMode){
+	if (pHalData->UsbTxAggMode){
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
-		
+
 		rtw_write32(Adapter, REG_TDECTRL, value32);
 		rtw_write8(Adapter, REG_TDECTRL+3, pHalData->UsbTxAggDescNum<<1);
 	}
-	
+
 #endif //CONFIG_USB_TX_AGGREGATION
 }	// usb_AggSettingTxUpdate
 
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingRxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -793,7 +781,7 @@ usb_AggSettingRxUpdate_8814A(
 
 	valueDMA = rtw_read8(Adapter, REG_TRXDMA_CTRL_8814A);
 	valueUSB = rtw_read8(Adapter, REG_RXDMA_AGG_PG_TH_8814A+3);
-	switch(pHalData->rxagg_mode)
+	switch (pHalData->rxagg_mode)
 	{
 		case RX_AGG_DMA:
 			valueDMA |= RXDMA_AGG_EN;
@@ -853,7 +841,7 @@ init_UsbAggregationSetting_8814A(
  *
  * Revised History:
  *	When		Who		Remark
- *	12/10/2010	MHC		Create Version 0.  
+ *	12/10/2010	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
 VOID
@@ -866,37 +854,33 @@ USB_AggModeSwitch(
 	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
 
 	//pHalData->UsbRxHighSpeedMode = _FALSE;
-	// How to measure the RX speed? We assume that when traffic is more than 
+	// How to measure the RX speed? We assume that when traffic is more than
 	if (pMgntInfo->bRegAggDMEnable == _FALSE)
 	{
 		return;	// Inf not support.
 	}
-		
-	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE && 
+
+	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE &&
 		pHalData->UsbRxHighSpeedMode == _FALSE)
 	{
 		pHalData->UsbRxHighSpeedMode = _TRUE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to HIGH\n"));
 	}
-	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE && 
+	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE &&
 		pHalData->UsbRxHighSpeedMode == _TRUE)
 	{
 		pHalData->UsbRxHighSpeedMode = _FALSE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to LOW\n"));
+	} else {
+		return;
 	}
-	else
-	{
-		return; 
-	}
-	
+
 #if USB_RX_AGGREGATION_92C
-	if (pHalData->UsbRxHighSpeedMode == _TRUE)	
-	{
+	if (pHalData->UsbRxHighSpeedMode == _TRUE) {
 		// 2010/12/10 MH The parameter is tested by SD1 engineer and SD3 channel emulator.
 		// USB mode
 #if (RT_PLATFORM == PLATFORM_LINUX)
-		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic)
-		{
+		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic) {
 			pHalData->RxAggBlockCount	= 16;
 			pHalData->RxAggBlockTimeout	= 7;
 		}
@@ -908,23 +892,20 @@ USB_AggModeSwitch(
 		}
 		// Mix mode
 		pHalData->RxAggPageCount	= 72;
-		pHalData->RxAggPageTimeout	= 6;		
-	}
-	else
-	{
+		pHalData->RxAggPageTimeout	= 6;
+	} else {
 		// USB mode
 		pHalData->RxAggBlockCount	= pMgntInfo->RegRxAggBlockCount;
-		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;	
+		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;
 		// Mix mode
 		pHalData->RxAggPageCount		= pMgntInfo->RegRxAggPageCount;
-		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;	
+		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;
 	}
 
 	if (pHalData->RxAggBlockCount > MAX_RX_AGG_BLKCNT)
 		pHalData->RxAggBlockCount = MAX_RX_AGG_BLKCNT;
 #if (OS_WIN_FROM_VISTA(OS_VERSION)) || (RT_PLATFORM == PLATFORM_LINUX)	// do not support WINXP to prevent usbehci.sys BSOD
-	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter))
-	{
+	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter)) {
 		//
 		// 2010/12/24 MH According to V1012 QC IOT test, XP BSOD happen when running chariot test
 		// with the aggregation dynamic change!! We need to disable the function to prevent it is broken
@@ -933,12 +914,12 @@ USB_AggModeSwitch(
 		usb_AggSettingRxUpdate_8188E(Adapter);
 
 		// 2010/12/27 MH According to designer's suggstion, we can only modify Timeout value. Otheriwse
-		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the 
+		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the
 		// issue. Base on the newest test, we can not enable block cnt > 30, otherwise XP usbehci.sys may
 		// BSOD.
 	}
 #endif
-	
+
 #endif
 #endif
 }	// USB_AggModeSwitch
@@ -957,7 +938,7 @@ _InitOperationMode_8814A(
 	//
 	// Set RRSR, RATR, and REG_BWOPMODE registers
 	//
-	switch(Adapter->RegWirelessMode)
+	switch (Adapter->RegWirelessMode)
 	{
 		case WIRELESS_MODE_B:
 			regBwOpMode = BW_OPMODE_20MHZ;
@@ -975,14 +956,11 @@ _InitOperationMode_8814A(
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
 		case WIRELESS_MODE_AUTO:
-			if (Adapter->bInHctTest)
-			{
+			if (Adapter->bInHctTest) {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
-			}
-			else
-			{
+			} else {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
@@ -1000,7 +978,7 @@ _InitOperationMode_8814A(
 			regRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-			
+
 		default: //for MacOSX compiler warning.
 			break;
 	}
@@ -1039,20 +1017,19 @@ static VOID _RfPowerSave(
 	return;
 #endif
 
-	if(pMgntInfo->RegRfOff == _TRUE){ // User disable RF via registry.
+	if (pMgntInfo->RegRfOff == _TRUE) { // User disable RF via registry.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
 		MgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 		for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if(pMgntInfo->RfOffReason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+	else if (pMgntInfo->RfOffReason > RF_CHANGE_BY_PS) { // H/W or S/W RF OFF before sleep.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
 		MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
-	}
-	else{
+	} else {
 		pHalData->eRFPowerState = eRfOn;
-		pMgntInfo->RfOffReason = 0; 
+		pMgntInfo->RfOffReason = 0;
 		if(Adapter->bInSetPower || Adapter->bResetInProgress)
 			PlatformUsbEnableInPipes(Adapter);
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
@@ -1062,7 +1039,7 @@ static VOID _RfPowerSave(
 */
 enum {
 	Antenna_Lfet = 1,
-	Antenna_Right = 2,	
+	Antenna_Right = 2,
 };
 
 static VOID
@@ -1071,21 +1048,21 @@ _InitAntenna_Selection_8814A(IN	PADAPTER Adapter)
 
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	if(pHalData->AntDivCfg==0)
+	if (pHalData->AntDivCfg==0)
 		return;
-/*		
-	RTW_INFO("==>  %s ....\n",__FUNCTION__);		
+/*
+	RTW_INFO("==>  %s ....\n",__FUNCTION__);
 
 	rtw_write8(Adapter, REG_LEDCFG2, 0x82);
 
 	PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
-		
+
 	if(PHY_QueryBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == MAIN_ANT)
 		pHalData->CurAntenna = MAIN_ANT;
 	else
 		pHalData->CurAntenna = AUX_ANT;
 	RTW_INFO("%s,Cur_ant:(%x)%s\n",__FUNCTION__,pHalData->CurAntenna,(pHalData->CurAntenna == MAIN_ANT)?"MAIN_ANT":"AUX_ANT");
-			
+
 */
 }
 
@@ -1104,28 +1081,24 @@ HalDetectSelectiveSuspendMode(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
 
-	// If support HW radio detect, we need to enable WOL ability, otherwise, we 
+	// If support HW radio detect, we need to enable WOL ability, otherwise, we
 	// can not use FW to notify host the power state switch.
-	
+
 	EFUSE_ShadowRead(Adapter, 1, EEPROM_USB_OPTIONAL1, (u32 *)&tmpvalue);
 
 	DBG_8192C("HalDetectSelectiveSuspendMode(): SS ");
-	if(tmpvalue & BIT1)
-	{
+	if (tmpvalue & BIT1) {
 		DBG_8192C("Enable\n");
-	}
-	else
-	{
+	} else {
 		DBG_8192C("Disable\n");
 		pdvobjpriv->RegUsbSS = _FALSE;
 	}
 
 	// 2010/09/01 MH According to Dongle Selective Suspend INF. We can switch SS mode.
-	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData))
-	{
+	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData)) {
 		//PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
 
-		//if (!pMgntInfo->bRegDongleSS)	
+		//if (!pMgntInfo->bRegDongleSS)
 		//{
 		//	RT_TRACE(COMP_INIT, DBG_LOUD, ("Dongle disable SS\n"));
 			pdvobjpriv->RegUsbSS = _FALSE;
@@ -1156,12 +1129,11 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 {
 #if 0
                 u8 reg_val=0;
-	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7)
-	{		
-		_8051Reset8812(Adapter);  
+	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) {
+		_8051Reset8812(Adapter);
 		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
 		//before BB reset should do clock gated
-		rtw_write32(Adapter, rFPGA0_XCD_RFPara, 
+		rtw_write32(Adapter, rFPGA0_XCD_RFPara,
 			rtw_read32(Adapter, rFPGA0_XCD_RFPara)|(BIT6));
 		//reset BB
 		reg_val = rtw_read8(Adapter, REG_SYS_FUNC_EN);
@@ -1172,16 +1144,16 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 		//reset TRX path
 		rtw_write16(Adapter, REG_CR, 0);
 		//reset MAC
-		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		reg_val |= BIT(1);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);       //reg0x5[1] ,auto FSM off
 
 		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
- 
+
 		//check if   reg0x5[1] auto cleared
-		while(reg_val & BIT(1)){
+		while (reg_val & BIT(1)) {
 			rtw_udelay_os(1);
-			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		}
 		reg_val |= BIT(0);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);     //reg0x5[0] ,auto FSM on
@@ -1272,7 +1244,7 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 	int hal_init_profiling_i;
 	u32 hal_init_stages_timestamp[HAL_INIT_STAGES_NUM]; //used to record the time of each stage's starting point
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
 		hal_init_stages_timestamp[hal_init_profiling_i]=0;
 
 	#define HAL_INIT_PROFILE_TAG(stage) hal_init_stages_timestamp[(stage)]=rtw_get_current_time();
@@ -1281,15 +1253,12 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 #endif //DBG_HAL_INIT_PROFILING
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
-	if(pwrctrlpriv->bkeepfwalive)
-	{
+	if (pwrctrlpriv->bkeepfwalive) {
 		_ps_open_RF(Adapter);
 
-		if(pHalData->bIQKInitialized){
+		if (pHalData->bIQKInitialized) {
 			//PHY_IQCalibrate_8812A(Adapter,_TRUE);
-		}
-		else
-		{
+		} else {
 			//PHY_IQCalibrate_8812A(Adapter,_FALSE);
 			//pHalData->bIQKInitialized = _TRUE;
 		}
@@ -1301,16 +1270,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}
 
 	// Check if MAC has already power on. by tynli. 2011.05.27.
-	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);	
+	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);
 	u1bRegCR = rtw_read8(Adapter, REG_CR);
 	RTW_INFO(" power-on :REG_SYS_CLKR 0x09=0x%02x. REG_CR 0x100=0x%02x.\n", value8, u1bRegCR);
-	if((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA))
-	{
+	if ((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA)) {
 		//pHalData->bMACFuncEnable = _TRUE;
 		RTW_INFO(" MAC has already power on.\n");
-	}
-	else
-	{
+	} else {
 		//pHalData->bMACFuncEnable = _FALSE;
 		// Set FwPSState to ALL_ON mode to prevent from the I/O be return because of 32k
 		// state which is set before sleep under wowlan mode. 2012.01.04. by tynli.
@@ -1332,7 +1298,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}*/
 
 /*
-	If HW didn't go through a complete de-initial procedure,  
+	If HW didn't go through a complete de-initial procedure,
 	it probably occurs some problem for double initial procedure.
 	Like "CONFIG_DEINIT_BEFORE_INIT" in 92du chip
 */
@@ -1340,15 +1306,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 	status = _InitPowerOn_8814AU(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init power on!\n");
 		goto exit;
 	}
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
-	
+
 	status =  InitLLTTable8814A(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init LLT table\n");
 		goto exit;
 	}
@@ -1375,8 +1341,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 	}
 
 	InitializeFirmwareVars8814(Adapter);
-	
-	if(pwrctrlpriv->reg_rfoff == _TRUE){
+
+	if (pwrctrlpriv->reg_rfoff == _TRUE) {
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -1393,16 +1359,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC);
 #if (HAL_MAC_ENABLE == 1)
 	status = PHY_MACConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_MAC_ENABLE
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
-	
+
 	_InitQueuePriority_8814AUsb(Adapter);
-	_InitPageBoundary_8814AUsb(Adapter);	
+	_InitPageBoundary_8814AUsb(Adapter);
 
 	_InitTransferPageSize_8814AUsb(Adapter);
 
@@ -1411,8 +1376,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	_InitDriverInfoSize_8814A(Adapter, DRVINFO_SZ);
 
 	_InitInterrupt_8814AU(Adapter);
-	_InitID_8814A(Adapter);//set mac_address
-	_InitNetworkType_8814A(Adapter);//set msr	
+	_InitID_8814A(Adapter); //set mac_address
+	_InitNetworkType_8814A(Adapter); //set msr
 	_InitMacConfigure_8814A(Adapter);
 	//_InitWMACSetting_8814A(Adapter);
 	//_InitAdaptiveCtrl_8814AUsb(Adapter);
@@ -1428,7 +1393,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 
 	//
 	// Init CR MACTXEN, MACRXEN after setting RxFF boundary REG_TRXFF_BNDY to patch
-	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E. 
+	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E.
 	// 2011.08.05. by tynli.
 	//
 	value8 = rtw_read8(Adapter, REG_CR);
@@ -1449,7 +1414,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	rtw_write16(Adapter, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	// unit: 256us. 3s
 #endif	// CONFIG_TX_MCAST2UNI
 #endif	// CONFIG_CONCURRENT_MODE || CONFIG_TX_MCAST2UNI
-	
+
 #ifdef CONFIG_LED
 	_InitHWLed(Adapter);
 #endif //CONFIG_LED
@@ -1461,8 +1426,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 #if (HAL_BB_ENABLE == 1)
 	status = PHY_BBConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_BB_ENABLE
@@ -1472,9 +1436,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 #if (HAL_RF_ENABLE == 1)
-	status = PHY_RFConfig8814A(Adapter);	
-	if(status == _FAIL)
-	{
+	status = PHY_RFConfig8814A(Adapter);
+	if (status == _FAIL) {
 		goto exit;
 	}
 
@@ -1485,12 +1448,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 
 	PHY_ConfigBB_8814A(Adapter);
 
-	if(Adapter->registrypriv.channel <= 14)
+	if (Adapter->registrypriv.channel <= 14)
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_2_4G);
 	else
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_5G);
 
-	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel, 
+	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel,
 		CHANNEL_WIDTH_20, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TURN_ON_BLOCK);
@@ -1503,9 +1466,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	// HW SEQ CTRL
 	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
-	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF); 
-	
-	// 
+	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF);
+
+	//
 	// Disable BAR, suggested by Scott
 	// 2010.04.09 add by hpfan
 	//
@@ -1513,7 +1476,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	rtw_write8(Adapter,REG_SECONDARY_CCA_CTRL_8814A,0x03);
 
-	if(pregistrypriv->wifi_spec)
+	if (pregistrypriv->wifi_spec)
 		rtw_write16(Adapter,REG_FAST_EDCA_CTRL ,0);
 	//adjust EDCCA to avoid collision
 	/*if(pregistrypriv->wifi_spec)
@@ -1525,21 +1488,21 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	rtl8814_InitHalDm(Adapter);
-	
+
 	//
 	// 2010/08/11 MH Merge from 8192SE for Minicard init. We need to confirm current radio status
-	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not 
+	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not
 	// call init_adapter. May cause some problem??
 	//
-	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed 
-	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState 
+	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed
+	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState
 	// is the same as eRfOff, we should change it to eRfOn after we config RF parameters.
 	// Added by tynli. 2010.03.30.
 	pwrctrlpriv->rf_pwrstate = rf_on;
 
 	PHY_IQCalibrate_8814A_Init(&pHalData->odmpriv);
 
-#if (HAL_BB_ENABLE == 1)	
+#if (HAL_BB_ENABLE == 1)
 	PHY_SetRFEReg8814A(Adapter, _TRUE, pHalData->CurrentBandType);
 #endif //HAL_BB_ENABLE
 
@@ -1561,13 +1524,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	// Reset USB mode switch setting
 	rtw_write8(Adapter, REG_SDIO_CTRL_8814A, 0x0);
 	rtw_write8(Adapter, REG_ACLK_MON, 0x0);
-	
+
 	//RT_TRACE(COMP_INIT, DBG_TRACE, ("InitializeAdapter8188EUsb() <====\n"));
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	// 2010/08/26 MH Merge from 8192CE.
-	if(pwrctrlpriv->rf_pwrstate == rf_on)
-	{
+	if (pwrctrlpriv->rf_pwrstate == rf_on) {
 /*		if(IS_HARDWARE_TYPE_8812AU(Adapter))
 		{
 #if (RTL8812A_SUPPORT == 1)
@@ -1584,9 +1546,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	//this should be done by rf team using phydm code
 	//PHY_IQCalibrate_8814A(&pHalData->odmpriv, _FALSE);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
-		
+
 		//ODM_TXPowerTrackingCheck(&pHalData->odmpriv );
-		
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);
 		//PHY_LCCalibrate_8812A(Adapter);
 	}
@@ -1596,8 +1558,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC21);
 //HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PABIAS);
 //	_InitPABias(Adapter);
 #if (MP_DRIVER == 1)
-	if (Adapter->registrypriv.mp_mode == 1)
-	{
+	if (Adapter->registrypriv.mp_mode == 1) {
 		Adapter->mppriv.channel = pHalData->CurrentChannel;
 		MPT_InitializeAdapter(Adapter, Adapter->mppriv.channel);
 	}
@@ -1610,13 +1571,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BT_COEXIST);
 	// suspend mode automatically.
 	//HwSuspendModeEnable92Cu(Adapter, _FALSE);
 
-	if ( _TRUE == pHalData->EEPROMBluetoothCoexist)
-        {
-               // Init BT hw config.
-                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);      
-        }
-        else
-        {
+	if ( _TRUE == pHalData->EEPROMBluetoothCoexist) {
+		// Init BT hw config.
+                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);
+        } else {
                 // In combo card run wifi only , must setting some hardware reg.
                 rtl8812a_combo_card_WifiOnlyHwInit(Adapter);
         }
@@ -1633,18 +1591,18 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 
 	//misc
 	{
-		int i;		
+		int i;
 		u8 mac_addr[6];
-		for(i=0; i<6; i++)
-		{			
+		for (i=0; i<6; i++)
+		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if(Adapter->iface_type == IFACE_PORT1)
+			if (Adapter->iface_type == IFACE_PORT1)
 				mac_addr[i] = rtw_read8(Adapter, REG_MACID1+i);
 			else
 #endif
-			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);		
+			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);
 		}
-		
+
 		RTW_INFO("MAC Address from REG_MACID = "MAC_FMT"\n", MAC_ARG(mac_addr));
 	}
 
@@ -1656,14 +1614,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 	#ifdef DBG_HAL_INIT_PROFILING
 	hal_init_stages_timestamp[HAL_INIT_STAGES_END]=rtw_get_current_time();
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
 		RTW_INFO("DBG_HAL_INIT_PROFILING: %35s, %u, %5u, %5u\n"
 			, hal_init_stages_str[hal_init_profiling_i]
 			, hal_init_stages_timestamp[hal_init_profiling_i]
 			, (hal_init_stages_timestamp[hal_init_profiling_i+1]-hal_init_stages_timestamp[hal_init_profiling_i])
 			, rtw_get_time_interval_ms(hal_init_stages_timestamp[hal_init_profiling_i], hal_init_stages_timestamp[hal_init_profiling_i+1])
 		);
-	}	
+	}
 	#endif
 
 	return status;
@@ -1671,30 +1629,30 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 
 VOID
 hal_carddisable_8814(
-	IN	PADAPTER			Adapter 
+	IN	PADAPTER			Adapter
 )
 {
 	u8	u1bTmp;
 
 	RTW_INFO("CardDisableRTL8814AU\n");
 
-	// stop rx 
+	// stop rx
 	rtw_write8(Adapter, REG_CR_8814A, 0x0);
 
 	// Card disable power action flow
 	HalPwrSeqCmdParsing(Adapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_DISABLE_FLOW);
 
 	Adapter->bFWReady = _FALSE;
-	
+
 }
 
 static void rtl8814au_hw_power_down(_adapter *padapter)
 {
 	// 2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
 	// Then enable power down control bit of register 0x04 BIT4 and BIT15 as 1.
-		
+
 	// Enable register area 0x0-0xc.
-	rtw_write8(padapter,REG_RSV_CTRL, 0x0);			
+	rtw_write8(padapter,REG_RSV_CTRL, 0x0);
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
@@ -1705,8 +1663,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
    	RTW_INFO("==> %s \n",__FUNCTION__);
 
 #ifdef CONFIG_BT_COEXIST
-	if (hal_btcoex_IsBtExist(Adapter))
-	{
+	if (hal_btcoex_IsBtExist(Adapter)) {
 		RTW_INFO("BT module enable SIC\n");
 		// Only under WIN7 we can support selective suspend and enter D3 state when system call halt adapter.
 
@@ -1720,8 +1677,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 		rtw_write16(Adapter, REG_GPIO_MUXCFG, rtw_read16(Adapter, REG_GPIO_MUXCFG)&(~BIT12));
 	}
 
-	if(pHalData->bSupportUSB3 == _TRUE)
-	{
+	if (pHalData->bSupportUSB3 == _TRUE) {
 		// set Reg 0xf008[3:4] to 2'11 to eable U1/U2 Mode in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)|0x18);
 	}
@@ -1733,33 +1689,32 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 
  #ifdef SUPPORT_HW_RFOFF_DETECTED
  	RTW_INFO("bkeepfwalive(%x)\n", pwrctl->bkeepfwalive);
- 	if(pwrctl->bkeepfwalive)
- 	{
-		_ps_close_RF(Adapter);		
-		if((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
+ 	if (pwrctl->bkeepfwalive) {
+		_ps_close_RF(Adapter);
+		if ((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
 			rtl8814au_hw_power_down(Adapter);
  	}
 	else
 #endif
-	{	
+	{
 		if (rtw_is_hw_init_completed(Adapter)) {
 			hal_carddisable_8814(Adapter);
 
-			if((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
+			if ((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
 				rtl8814au_hw_power_down(Adapter);
 		}
-	}		
+	}
 	return _SUCCESS;
  }
 
 unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
-{	
-	u8 i;	
+{
+	u8 i;
 	struct recv_buf *precvbuf;
 	uint	status;
 	struct dvobj_priv *pdev= adapter_to_dvobj(Adapter);
 	struct intf_hdl * pintfhdl=&Adapter->iopriv.intf;
-	struct recv_priv *precvpriv = &(Adapter->recvpriv);	
+	struct recv_priv *precvpriv = &(Adapter->recvpriv);
 	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
@@ -1770,22 +1725,20 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 
 	status = _SUCCESS;
 
-	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
-		
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));
+
 	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
 
-	//issue Rx irp to receive data	
-	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
-	for(i=0; i<NR_RECVBUFF; i++)
-	{
-		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
-		{
+	//issue Rx irp to receive data
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i=0; i<NR_RECVBUFF; i++) {
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE ) {
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
 			status = _FAIL;
 			goto exit;
 		}
-		
-		precvbuf++;		
+
+		precvbuf++;
 		precvpriv->free_recv_buf_queue_cnt--;
 	}
 
@@ -1794,17 +1747,16 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 		status = _FAIL;
 		RTW_INFO("%s =>Warning !! Have not USB Int-IN pipe, RtIntInPipe(%d)!!!\n", __func__, pdev->RtInPipe[REALTEK_USB_IN_INT_EP_IDX]);
 		goto exit;
-	}	
+	}
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE )
-	{
+	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE ) {
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error \n"));
 		status = _FAIL;
 	}
 #endif
 
 exit:
-	
+
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
 
 	return status;
@@ -1812,9 +1764,9 @@ exit:
 }
 
 unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
-{	
+{
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
-	
+
 	rtw_read_port_cancel(Adapter);
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
@@ -1836,25 +1788,22 @@ hal_ReadIDs_8814AU(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	if( !AutoloadFail )
-	{
+	if ( !AutoloadFail ) {
 		pHalData->EEPROMVID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_VID_8814AU] );
-		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );		
-		
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );
+
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID = *(pu1Byte)&PROMContent[EEPROM_CustomID_8814];
 		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
-	}
-	else
-	{
+	} else {
 		pHalData->EEPROMVID 			= EEPROM_Default_VID;
 		pHalData->EEPROMPID 			= EEPROM_Default_PID;
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID		= EEPROM_Default_CustomerID;
 		pHalData->EEPROMSubCustomerID	= EEPROM_Default_SubCustomerID;
 	}
-	
+
 	RTW_INFO("VID = 0x%04X, PID = 0x%04X\n", pHalData->EEPROMVID, pHalData->EEPROMPID);
 	RTW_INFO("Customer ID: 0x%02X, SubCustomer ID: 0x%02X\n", pHalData->EEPROMCustomerID, pHalData->EEPROMSubCustomerID);
 }
@@ -1869,18 +1818,15 @@ hal_InitPGData_8814A(
 	u32			i;
 	u16			value16;
 
-	if(_FALSE == pHalData->bautoload_fail_flag)
-	{ // autoload OK.
+	if (_FALSE == pHalData->bautoload_fail_flag) { // autoload OK.
 		// hal_ReadeFuse_8814A is FW offload read efuse, todo
 	//#if ((DEV_BUS_TYPE==RT_USB_INTERFACE || DEV_BUS_TYPE==RT_SDIO_INTERFACE))  && (MP_DRIVER != 1)
 		//if(hal_ReadeFuse_8814A(pAdapter) == _FAIL)
 	//#endif
-		
+
 		// Read EFUSE real map to shadow.
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
-	}
-	else
-	{//autoload fail
+	} else { //autoload fail
 		RTW_INFO("AutoLoad Fail reported from CR9346!!\n");
 		//update to default value 0xFF
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
@@ -1899,11 +1845,11 @@ hal_CustomizedBehavior_8814AU(
 	IN	PADAPTER	Adapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct led_priv	*pledpriv = &(Adapter->ledpriv);
-	
+
 	// Led mode
-	switch(pHalData->CustomerID)
+	switch (pHalData->CustomerID)
 	{
 		case RT_CID_DEFAULT:
 			pledpriv->LedStrategy = SW_LED_MODE9;
@@ -1922,48 +1868,48 @@ hal_CustomizeByCustomerID_8814AU(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	
+
 	RTW_INFO("PID= 0x%x, VID=  %x\n",pHalData->EEPROMPID,pHalData->EEPROMVID);
-	
+
 	//	Decide CustomerID according to VID/DID or EEPROM
-	switch(pHalData->EEPROMCustomerID)
+	switch (pHalData->EEPROMCustomerID)
 	{
 		case EEPROM_CID_DEFAULT:
-			if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
+			if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
+			else if ((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
 			{
 				pHalData->CustomerID = RT_CID_CHINA_MOBILE;
-			}	
-			else if((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
+			}
+			else if ((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
 				pHalData->CustomerID = RT_CID_CC_C;
-			
+
 			break;
 		case EEPROM_CID_WHQL:
 			//padapter->bInHctTest = _TRUE;
-	
+
 			//pMgntInfo->bSupportTurboMode = _FALSE;
 			//pMgntInfo->bAutoTurboBy8186 = _FALSE;
-	
+
 			//pMgntInfo->PowerSaveControl.bInactivePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bIPSModeBackup = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePsModeBackup = _FALSE;
 			//pMgntInfo->keepAliveLevel = 0;
-	
+
 			//padapter->bUnloadDriverwhenS3S4 = _FALSE;
-			break;			
+			break;
 		default:
 			pHalData->CustomerID = RT_CID_DEFAULT;
 			break;
-			
+
 	}
 	RTW_INFO("Customer ID: 0x%2x\n", pHalData->CustomerID);
-	
+
 	hal_CustomizedBehavior_8814AU(pAdapter);
 }
 
@@ -1975,7 +1921,7 @@ hal_ReadUsbModeSwitch_8814AU(
 	)
 {
   	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-	
+
 	if (AutoloadFail)
 		pHalData->EEPROMUsbSwitch = _FALSE;
 	else
@@ -1985,7 +1931,7 @@ hal_ReadUsbModeSwitch_8814AU(
 
 static VOID
 ReadLEDSetting_8814AU(
-	IN	PADAPTER	Adapter,	
+	IN	PADAPTER	Adapter,
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -2015,19 +1961,19 @@ InitAdapterVariablesByPROM_8814AU(
 	hal_ReadTxPowerInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadBoardType8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_Read_TRX_antenna_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	//
 	// Read Bluetooth co-exist and initialize
 	//
 	hal_EfuseParseBTCoexistInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	hal_ReadChannelPlan8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_EfuseParseXtal_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);	
 	hal_ReadThermalMeter_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRemoteWakeup_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadAntennaDiversity8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRFEType_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	ReadLEDSetting_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 
 	hal_ReadUsbModeSwitch_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
@@ -2041,7 +1987,7 @@ InitAdapterVariablesByPROM_8814AU(
 static void hal_ReadPROMContent_8814A(
 	IN PADAPTER 		Adapter
 	)
-{	
+{
 	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(Adapter);
 	u8			eeValue;
 
@@ -2064,7 +2010,7 @@ ReadAdapterInfo8814AU(
 	)
 {
 	Hal_InitEfuseVars_8814A(Adapter);
-	
+
 	// Read all content in Efuse/EEPROM.
 	hal_ReadPROMContent_8814A(Adapter);
 
@@ -2079,21 +2025,21 @@ void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 Remo
 	u32 *himr;
 	pHalData = GET_HAL_DATA(padapter);
 
-	if(bHIMR0)
+	if (bHIMR0)
 		himr = &(pHalData->IntrMask[0]);
 	else
 		himr = &(pHalData->IntrMask[1]);
-	
+
 	if (AddMSR)
 		*himr |= AddMSR;
 
 	if (RemoveMSR)
 		*himr &= (~RemoveMSR);
 
-	if(bHIMR0)	
+	if (bHIMR0)
 		rtw_write32(padapter, REG_HIMR0_8814A, *himr);
 	else
-		rtw_write32(padapter, REG_HIMR1_8814A, *himr);	
+		rtw_write32(padapter, REG_HIMR1_8814A, *himr);
 
 }
 
@@ -2103,7 +2049,7 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
 	struct registry_priv *registry_par = &Adapter->registrypriv;
 
-	switch(variable)
+	switch (variable)
 	{
 		case HW_VAR_RXDMA_AGG_PG_TH:
 #ifdef CONFIG_USB_RX_AGGREGATION
@@ -2185,9 +2131,9 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 
 void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	switch(variable)
+	switch (variable)
 	{
 		default:
 			GetHwReg8814A(Adapter,variable,val);
@@ -2210,7 +2156,7 @@ SetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			SetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2221,7 +2167,7 @@ SetHalDefVar8814AUsb(
 }
 
 //
-//	Description: 
+//	Description:
 //		Query setting of specified variable.
 //
 u8
@@ -2234,7 +2180,7 @@ GetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			GetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2302,9 +2248,9 @@ static void rtl8814au_init_default_value(_adapter * padapter)
 }
 
 static u8 rtl8814au_ps_func(PADAPTER Adapter,HAL_INTF_PS_FUNC efunc_id, u8 *val)
-{	
+{
 	u8 bResult = _TRUE;
-	switch(efunc_id){
+	switch (efunc_id) {
 
 		#if defined(CONFIG_AUTOSUSPEND) && defined(SUPPORT_HW_RFOFF_DETECTED)
 		case HAL_USB_SELECT_SUSPEND:
@@ -2327,7 +2273,7 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 
 	pHalFunc->hal_power_on = _InitPowerOn_8814AU;
 	pHalFunc->hal_power_off = hal_carddisable_8814;
-	
+
 	pHalFunc->hal_init = &rtl8814au_hal_init;
 	pHalFunc->hal_deinit = &rtl8814au_hal_deinit;
 
@@ -2345,12 +2291,12 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 #else //case of hw led or no led
 	pHalFunc->InitSwLeds = NULL;
 	pHalFunc->DeInitSwLeds = NULL;
-#endif//CONFIG_SW_LED
-	
+#endif //CONFIG_SW_LED
+
 	pHalFunc->init_default_value = &rtl8814au_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8814au_interface_configure;
 	pHalFunc->read_adapter_info = &ReadAdapterInfo8814AU;
- 
+
 	pHalFunc->SetHwRegHandler = &SetHwReg8814AU;
 	pHalFunc->GetHwRegHandler = &GetHwReg8814AU;
   	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8814AUsb;
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c
index 59281f9..d2fea87 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,17 +24,16 @@
 
 #ifdef CONFIG_SUPPORT_USB_INT
 void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
-{	
+{
 	HAL_DATA_TYPE	*pHalData=GET_HAL_DATA(padapter);
 	struct reportpwrstate_parm pwr_rpt;
-	
-	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN )
-	{
+
+	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN ) {
 		RTW_INFO("%s Invalid interrupt content length (%d)!\n", __FUNCTION__, pkt_len);
 		return ;
 	}
 
-	// HISR 
+	// HISR
 	_rtw_memcpy(&(pHalData->IntArray[0]), &(pbuf[USB_INTR_CONTENT_HISR_OFFSET]), 4);
 	_rtw_memcpy(&(pHalData->IntArray[1]), &(pbuf[USB_INTR_CONTENT_HISRE_OFFSET]), 4);
 
@@ -42,25 +41,24 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	{
 		u32 hisr=0 ,hisr_ex=0;
 		_rtw_memcpy(&hisr,&(pHalData->IntArray[0]),4);
-		hisr = le32_to_cpu(hisr);	
-		
+		hisr = le32_to_cpu(hisr);
+
 		_rtw_memcpy(&hisr_ex,&(pHalData->IntArray[1]),4);
 		hisr_ex = le32_to_cpu(hisr_ex);
-		
-		if((hisr != 0) || (hisr_ex!=0))
+
+		if ((hisr != 0) || (hisr_ex!=0))
 			RTW_INFO("===> %s hisr:0x%08x ,hisr_ex:0x%08x \n",__FUNCTION__,hisr,hisr_ex);
 	}
 	#endif
 
 
 #ifdef CONFIG_LPS_LCLK
-	if(  pHalData->IntArray[0]  & IMR_CPWM_88E )
-	{
+	if (  pHalData->IntArray[0]  & IMR_CPWM_88E ) {
 		_rtw_memcpy(&pwr_rpt.state, &(pbuf[USB_INTR_CONTENT_CPWM1_OFFSET]), 1);
 		//_rtw_memcpy(&pwr_rpt.state2, &(pbuf[USB_INTR_CONTENT_CPWM2_OFFSET]), 1);
 
-		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.		
-		pwr_rpt.state |= PS_STATE_S2;		
+		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.
+		pwr_rpt.state |= PS_STATE_S2;
 		_set_workitem(&(adapter_to_pwrctl(padapter)->cpwm_event));
 	}
 #endif//CONFIG_LPS_LCLK
@@ -72,40 +70,38 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	#endif
 	#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
 	if (pHalData->IntArray[0] & (IMR_TBDER_88E|IMR_TBDOK_88E))
-	#endif	
-	{		
+	#endif
+	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 		#if 0
-		if(pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
+		if (pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
 			RTW_INFO("%s: HISR_BCNERLY_INT\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDOK_88E)
+		if (pHalData->IntArray[0] & IMR_TBDOK_88E)
 			RTW_INFO("%s: HISR_TXBCNOK\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDER_88E)
+		if (pHalData->IntArray[0] & IMR_TBDER_88E)
 			RTW_INFO("%s: HISR_TXBCNERR\n", __func__);
 		#endif
-		
 
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
-		{
+
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(pmlmepriv->update_bcn == _TRUE)
+			if (pmlmepriv->update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter);
 			}
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_fwstate(padapter, WIFI_AP_STATE))
-		{
+		if (check_buddy_fwstate(padapter, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
+			if (padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter->pbuddy_adapter);
 			}
 		}
 #endif
-		
+
 	}
 #endif //CONFIG_INTERRUPT_BASED_TXBCN
 
@@ -361,8 +357,9 @@ int recvbuf2recvframe(PADAPTER padapter, void *ptr)
 		}
 
 #ifdef CONFIG_RX_PACKET_APPEND_FCS
-		if(pattrib->pkt_rpt_type == NORMAL_RX)
-			pattrib->pkt_len -= IEEE80211_FCS_LEN;
+                if (check_fwstate(&padapter->mlmepriv, WIFI_MONITOR_STATE) == _FALSE)
+                        if ((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                                pattrib->pkt_len -= IEEE80211_FCS_LEN;
 #endif
 		if(rtw_os_alloc_recvframe(padapter, precvframe, 
 			(pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), pskb) == _FAIL)
diff --git a/drivers/net/wireless/rtl8814au/include/autoconf.h b/drivers/net/wireless/rtl8814au/include/autoconf.h
index 2e1c614..3c1713f 100644
--- a/drivers/net/wireless/rtl8814au/include/autoconf.h
+++ b/drivers/net/wireless/rtl8814au/include/autoconf.h
@@ -309,7 +309,6 @@
 #endif /* !CONFIG_BT_COEXIST */
 
 
-
 #ifdef CONFIG_USB_TX_AGGREGATION
 /* #define	CONFIG_TX_EARLY_MODE */
 #endif
@@ -347,12 +346,11 @@
 /* #define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap" */
 
 
-
 /* #define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE */
 /* #define DBG_ROAMING_TEST */
 
 /* #define DBG_HAL_INIT_PROFILING */
 
-/*#define DBG_MEMORY_LEAK*/
+/* #define DBG_MEMORY_LEAK*/
 #define	DBG_RX_DFRAME_RAW_DATA
-/*#define CONFIG_USE_EXTERNAL_POWER  */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate*/
+/* #define CONFIG_USE_EXTERNAL_POWER */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate */
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h b/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
index 69bd71d..7acbb95 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 #ifndef __RTW_WIFI_REGD_H__
-#define __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__ 
 
 int rtw_regd_init(_adapter *padapter);
 void rtw_reg_notify_by_driver(_adapter *adapter);
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_xmit.h b/drivers/net/wireless/rtl8814au/include/rtw_xmit.h
index d372338..6b5ea43 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_xmit.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_xmit.h
@@ -421,7 +421,7 @@ struct pkt_attrib {
 	u8	rate;
 	u8	intel_proxim;
 	u8	retry_ctrl;
-	u8	sw_seq;
+	//u8	sw_seq; // Add support for pre-configured SeqNum via RadioTap
 	u8   mbssid;
 	u8	ldpc;
 	u8	stbc;
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
index 8a7e088..17937e7 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
@@ -1750,6 +1750,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 
 		sinfo->filled |= STATION_INFO_BSS_PARAM;
 
+#if defined (LINUX_VERSION_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 20, 0))
 		if (!psta->no_short_preamble_set)
 		  sinfo->bss_param.flags |= STATION_INFO_BSS_PARAM_SHORT_PREAMBLE;
 
@@ -1765,6 +1766,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 		sinfo->bss_param.dtim_period = pwrctl->dtim;
 		
 		sinfo->bss_param.beacon_interval = get_beacon_interval(&cur_network->network);
+#endif
 
 	}
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c b/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
index 52fbba5..a802a9d 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
@@ -445,10 +445,11 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 #endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
 
 		ret = rtw_netif_rx(padapter->pnetdev, pkt);
-		if (ret == NET_RX_SUCCESS)
+		if (ret == NET_RX_SUCCESS) {
 			DBG_COUNTER(padapter->rx_logs.os_netif_ok);
-		else
+		} else {
 			DBG_COUNTER(padapter->rx_logs.os_netif_err);
+		}
 	}
 }
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c b/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
index 6ed4e72..47b3435 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
@@ -222,6 +222,7 @@ static struct usb_device_id rtw_usb_id_tbl[] = {
 	{USB_DEVICE(0x2001, 0x331A), .driver_info = RTL8814A}, /* D-Link - D-Link */
 	{USB_DEVICE(0x0B05, 0x1817), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x0B05, 0x1852), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
+	{USB_DEVICE(0x0B05, 0x1853), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x056E, 0x400B), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x056E, 0x400D), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x7392, 0xA834), .driver_info = RTL8814A}, /* Edimax - Edimax */
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
index fa8ba7b..b0a4abd 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
@@ -15,8 +15,8 @@ void rtw_reg_notify_by_driver(_adapter *adapter)
 	return;
 }
 
-int rtw_regd_init(_adapter *padapter)
+int rtw_regd_init(_adapter * padapter)
 {
 	return 0;
 }
-#endif /* CONFIG_IOCTL_CFG80211 */
+#endif //CONFIG_IOCTL_CFG80211
