From 90dc2bf4b9243830a9d2951518e95116dd3fbb43 Mon Sep 17 00:00:00 2001
From: Paolo Sabatino <paolo.sabatino@gmail.com>
Date: Sun, 7 May 2023 15:07:06 +0200
Subject: [PATCH 2/2] apply bugfixes for uwe5622 driver

---
 drivers/net/wireless/uwe5622/tty-sdio/tty.c   |  72 +--
 drivers/net/wireless/uwe5622/tty-sdio/woble.c |   9 +-
 .../net/wireless/uwe5622/unisocwcn/Makefile   |  97 ++--
 .../unisocwcn/boot/wcn_integrate_boot.c       |   1 -
 .../unisocwcn/include/marlin_platform.h       |   3 +-
 .../uwe5622/unisocwcn/include/uwe562x_glb.h   |  11 +-
 .../uwe5622/unisocwcn/platform/bufring.c      |   1 -
 .../unisocwcn/platform/gnss/gnss_common.h     |  82 ++-
 .../unisocwcn/platform/gnss/gnss_common_ctl.c |  76 ++-
 .../unisocwcn/platform/gnss/gnss_dbg.c        |  23 +-
 .../unisocwcn/platform/gnss/gnss_dump.c       |  28 +-
 .../platform/gnss/gnss_pmnotify_ctl.c         |   9 +-
 .../uwe5622/unisocwcn/platform/rdc_debug.c    |   8 +-
 .../uwe5622/unisocwcn/platform/wcn_boot.c     | 206 +++----
 .../uwe5622/unisocwcn/platform/wcn_op.h       |   6 -
 .../unisocwcn/platform/wcn_parn_parser.c      |   3 -
 .../uwe5622/unisocwcn/platform/wcn_procfs.c   |  58 +-
 .../uwe5622/unisocwcn/platform/wcn_txrx.c     |  26 +-
 .../uwe5622/unisocwcn/platform/wcn_txrx.h     |   6 +-
 .../wireless/uwe5622/unisocwcn/sdio/sdiohal.h |  10 +-
 .../uwe5622/unisocwcn/sdio/sdiohal_common.c   | 201 ++++---
 .../uwe5622/unisocwcn/sdio/sdiohal_ctl.c      |   9 +-
 .../uwe5622/unisocwcn/sdio/sdiohal_main.c     |   1 -
 .../uwe5622/unisocwcn/sdio/sdiohal_rx.c       |  52 +-
 .../uwe5622/unisocwcn/sdio/sdiohal_tx.c       |   8 +-
 .../uwe5622/unisocwcn/sleep/sdio_int.c        |  11 +-
 .../uwe5622/unisocwcn/sleep/sdio_int.h        |   4 +-
 .../uwe5622/unisocwcn/sleep/slp_mgr.c         |  10 +-
 .../net/wireless/uwe5622/unisocwcn/wcn_bus.c  |  12 +-
 .../net/wireless/uwe5622/unisocwifi/Kconfig   |   7 +-
 .../net/wireless/uwe5622/unisocwifi/Makefile  |  50 +-
 .../wireless/uwe5622/unisocwifi/api_version.c |  14 +-
 .../wireless/uwe5622/unisocwifi/cfg80211.c    | 522 ++++++++++--------
 .../wireless/uwe5622/unisocwifi/cfg80211.h    |   9 -
 .../net/wireless/uwe5622/unisocwifi/cmdevt.c  | 428 +++++++++-----
 .../net/wireless/uwe5622/unisocwifi/cmdevt.h  |   1 +
 .../uwe5622/unisocwifi/dbg_ini_util.c         |   6 +-
 .../net/wireless/uwe5622/unisocwifi/debug.c   |   6 +-
 .../net/wireless/uwe5622/unisocwifi/defrag.c  |  32 +-
 .../wireless/uwe5622/unisocwifi/edma_test.c   |  18 +-
 .../net/wireless/uwe5622/unisocwifi/ibss.c    |  14 +-
 .../net/wireless/uwe5622/unisocwifi/intf.h    |  20 +-
 .../wireless/uwe5622/unisocwifi/intf_ops.h    |  22 +
 .../net/wireless/uwe5622/unisocwifi/main.c    | 136 +++--
 drivers/net/wireless/uwe5622/unisocwifi/mm.c  |  66 +--
 drivers/net/wireless/uwe5622/unisocwifi/msg.c |   6 +-
 drivers/net/wireless/uwe5622/unisocwifi/msg.h |   2 +
 drivers/net/wireless/uwe5622/unisocwifi/nan.c |   2 +-
 drivers/net/wireless/uwe5622/unisocwifi/npi.c |  20 +-
 drivers/net/wireless/uwe5622/unisocwifi/qos.c |  63 ++-
 drivers/net/wireless/uwe5622/unisocwifi/qos.h |   5 +-
 .../wireless/uwe5622/unisocwifi/reg_domain.c  |   8 +-
 .../net/wireless/uwe5622/unisocwifi/reorder.c | 100 ++--
 .../wireless/uwe5622/unisocwifi/rf_marlin3.c  |   4 +-
 drivers/net/wireless/uwe5622/unisocwifi/rtt.c | 130 ++---
 .../net/wireless/uwe5622/unisocwifi/rx_msg.c  |  40 +-
 .../wireless/uwe5622/unisocwifi/softap_hook.c |  12 +-
 .../net/wireless/uwe5622/unisocwifi/sprdwl.h  |   3 +
 .../net/wireless/uwe5622/unisocwifi/tcp_ack.c |  38 +-
 .../net/wireless/uwe5622/unisocwifi/tx_msg.c  | 102 ++--
 .../net/wireless/uwe5622/unisocwifi/txrx.c    |  39 +-
 .../net/wireless/uwe5622/unisocwifi/vendor.c  | 329 ++++++-----
 .../wireless/uwe5622/unisocwifi/wcn_wrapper.h |  20 +
 .../net/wireless/uwe5622/unisocwifi/wl_core.c | 157 ++++--
 .../net/wireless/uwe5622/unisocwifi/wl_core.h |   2 +-
 .../net/wireless/uwe5622/unisocwifi/wl_intf.c | 234 ++++----
 .../net/wireless/uwe5622/unisocwifi/wl_intf.h |   1 +
 .../net/wireless/uwe5622/unisocwifi/work.c    |  28 +-
 68 files changed, 2155 insertions(+), 1584 deletions(-)
 create mode 100755 drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h

diff --git a/drivers/net/wireless/uwe5622/tty-sdio/tty.c b/drivers/net/wireless/uwe5622/tty-sdio/tty.c
index 0f90a758b7bc..6498272fc192 100644
--- a/drivers/net/wireless/uwe5622/tty-sdio/tty.c
+++ b/drivers/net/wireless/uwe5622/tty-sdio/tty.c
@@ -113,17 +113,6 @@ static ssize_t dumpmem_store(struct device *dev,
 
 static DEVICE_ATTR_WO(dumpmem);
 
-static struct attribute *bluetooth_attrs[] = {
-	&dev_attr_dumpmem.attr,
-	NULL,
-};
-
-static struct attribute_group bluetooth_group = {
-	.name = NULL,
-	.attrs = bluetooth_attrs,
-};
-
-#ifdef KERNEL_VERSION_414
 static ssize_t chipid_show(struct device *dev,
 	   struct device_attribute *attr, char *buf)
 {
@@ -144,8 +133,22 @@ static ssize_t chipid_show(struct device *dev,
 
 static DEVICE_ATTR_RO(chipid);
 
+static ssize_t ant_num_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int num = 2;
+
+	num = marlin_get_ant_num();
+	pr_err("%s: %d", __func__, num);
+
+	return sprintf(buf, "%d", num);
+}
+
+static DEVICE_ATTR_RO(ant_num);
+
 static struct attribute *bluetooth_attrs[] = {
+	&dev_attr_dumpmem.attr,
 	&dev_attr_chipid.attr,
+	&dev_attr_ant_num.attr,
 	NULL,
 };
 
@@ -153,7 +156,6 @@ static struct attribute_group bluetooth_group = {
 	.name = NULL,
 	.attrs = bluetooth_attrs,
 };
-#endif
 
 static void hex_dump(unsigned char *bin, size_t binsz)
 {
@@ -629,47 +631,13 @@ struct mchn_ops_t bt_tx_ops = {
 #endif
 };
 
-static int bluetooth_reset(struct notifier_block *this, unsigned long ev, void *ptr)
-{
-#define RESET_BUFSIZE 5
-	int ret = 0;
-	int block_size = RESET_BUFSIZE;
-	unsigned char reset_buf[RESET_BUFSIZE] = {0x04, 0xff, 0x02, 0x57, 0xa5};
-
-	if (!ev) {
-		pr_info("%s:reset callback coming\n", __func__);
-		if (mtty_dev != NULL) {
-			if (!work_pending(&mtty_dev->bt_rx_work)) {
-				pr_info("%s tty_insert_flip_string", __func__);
-				while (ret < block_size) {
-					pr_info("%s before tty_insert_flip_string ret: %d, len: %d\n",
-							__func__, ret, RESET_BUFSIZE);
-					ret = tty_insert_flip_string(mtty_dev->port,
-							(unsigned char *)reset_buf,
-							RESET_BUFSIZE);   // -BT_SDIO_HEAD_LEN
-					pr_info("%s ret: %d, len: %d\n", __func__, ret, RESET_BUFSIZE);
-					if (ret)
-						tty_flip_buffer_push(mtty_dev->port);
-					block_size = block_size - ret;
-					ret = 0;
-				}
-			}
-		}
-		ret = NOTIFY_DONE;
-	}
-	return ret;
-}
-
-static struct notifier_block bluetooth_reset_block = {
-    .notifier_call = bluetooth_reset,
-};
-
 static int  mtty_probe(struct platform_device *pdev)
 {
 	struct mtty_init_data *pdata = (struct mtty_init_data *)
-					pdev->dev.platform_data;
+								pdev->dev.platform_data;
 	struct mtty_device *mtty;
 	int rval = 0;
+
 #ifdef OTT_UWE
 	static struct mtty_init_data mtty_driver_data = {
 		.name = "ttyBT",
@@ -714,7 +682,7 @@ static int  mtty_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&mtty->rx_head);
 	/*tasklet_init(&mtty->rx_task, mtty_rx_task, (unsigned long)mtty);*/
 	mtty->bt_rx_workqueue =
-	create_singlethread_workqueue("SPRDBT_RX_QUEUE");
+		create_singlethread_workqueue("SPRDBT_RX_QUEUE");
 	if (!mtty->bt_rx_workqueue) {
 		pr_err("%s SPRDBT_RX_QUEUE create failed", __func__);
 		return -ENOMEM;
@@ -724,7 +692,8 @@ static int  mtty_probe(struct platform_device *pdev)
 	mtty_dev = mtty;
 
 //#ifdef KERNEL_VERSION_414
-	if (sysfs_create_group(&pdev->dev.kobj, &bluetooth_group)) {
+	if (sysfs_create_group(&pdev->dev.kobj,
+			&bluetooth_group)) {
 		pr_err("%s failed to create bluetooth tty attributes.\n", __func__);
 	}
 //#endif
@@ -732,9 +701,6 @@ static int  mtty_probe(struct platform_device *pdev)
 	rfkill_bluetooth_init(pdev);
 	bluesleep_init();
 	woble_init();
-
-	marlin_reset_callback_register(MARLIN_BLUETOOTH, &bluetooth_reset_block);
-
 	sprdwcn_bus_chn_init(&bt_rx_ops);
 	sprdwcn_bus_chn_init(&bt_tx_ops);
 	sema_init(&sem_id, BT_TX_POOL_SIZE - 1);
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/woble.c b/drivers/net/wireless/uwe5622/tty-sdio/woble.c
index 1df3f37fd6be..578108e7a78a 100644
--- a/drivers/net/wireless/uwe5622/tty-sdio/woble.c
+++ b/drivers/net/wireless/uwe5622/tty-sdio/woble.c
@@ -22,13 +22,13 @@
 #include <linux/string.h>
 #include "woble.h"
 #include "tty.h"
+#include "alignment/sitm.h"
+#include <marlin_platform.h>
 
 #define CMD_TIMEOUT 5000
 #define MAX_WAKE_DEVICE_MAX_NUM 36
 #define CONFIG_FILE_PATH "/data/misc/bluedroid/bt_config.conf"
 
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-
 static struct hci_cmd_t hci_cmd;
 uint8_t device_count_db;
 const woble_config_t s_woble_config_cust = {WOBLE_MOD_ENABLE, WOBLE_SLEEP_MOD_COULD_NOT_KNOW, 0, WOBLE_SLEEP_MOD_NOT_NEED_NOTITY};
@@ -224,7 +224,7 @@ int woble_data_recv(const unsigned char *buf, int count)
 int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py,
 		struct HC_BT_HDR *rsp)
 {
-	unsigned char msg_req[HCI_CMD_MAX_LEN], *p;
+	unsigned char msg_req[HCI_CMD_MAX_LEN + BYTE_ALIGNMENT] = {0}, *p;
 	int ret = 0;
 
 	p = msg_req;
@@ -239,7 +239,7 @@ int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py,
 	}
 
 	hci_cmd.opcode = opcode;
-	ret = marlin_sdio_write(msg_req, p - msg_req);
+	ret = marlin_sdio_write(msg_req, (p - msg_req) + (BYTE_ALIGNMENT - ((p - msg_req) % BYTE_ALIGNMENT)));
 	if (!ret) {
 		hci_cmd.opcode = 0;
 		pr_err("%s marlin_sdio_write fail", __func__);
@@ -248,6 +248,7 @@ int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py,
 
 	if (down_timeout(&hci_cmd.wait, msecs_to_jiffies(CMD_TIMEOUT))) {
 		pr_err("%s CMD_TIMEOUT for CMD: 0x%04X", __func__, opcode);
+		mdbg_assert_interface("hci cmd timeout");
 	}
 	hci_cmd.opcode = 0;
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/Makefile b/drivers/net/wireless/uwe5622/unisocwcn/Makefile
index b62652f63acb..f9c595747547 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/Makefile
+++ b/drivers/net/wireless/uwe5622/unisocwcn/Makefile
@@ -50,6 +50,7 @@ endif
 ifeq ($(CFG_AML_WIFI_DEVICE_UWE5622),y)
 export CONFIG_WCN_SDIO = y
 #export CONFIG_WCN_USB = y
+# export CONFIG_WCN_GNSS = y
 ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
 #ccflags-y += -DCONFIG_UWE5622
 BSP_CHIP_ID := uwe5621
@@ -68,6 +69,7 @@ endif
 ifeq ($(CONFIG_RK_WIFI_DEVICE_UWE5622),y)
 export CONFIG_WCN_SDIO = y
 #export CONFIG_WCN_USB = y
+# export CONFIG_WCN_GNSS = y
 #ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
 ccflags-y += -DCONFIG_UWE5622
 BSP_CHIP_ID := uwe5622
@@ -77,8 +79,9 @@ endif
 ifeq ($(CONFIG_AW_WIFI_DEVICE_UWE5622),y)
 export CONFIG_WCN_SDIO = y
 #export CONFIG_WCN_USB = y
-#ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
-ccflags-y += -DCONFIG_UWE5622
+# export CONFIG_WCN_GNSS = y
+ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+# ccflags-y += -DCONFIG_UWE5622
 BSP_CHIP_ID := uwe5622
 WCN_HW_TYPE := sdio
 endif
@@ -97,6 +100,9 @@ endif
 ifneq ($(UNISOC_DBG_PATH_CONFIG),)
 ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_PATH=\"$(UNISOC_DBG_PATH_CONFIG)\"
 endif
+ifneq ($(UNISOC_SDIO_IRQ_TYPE_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_SDIO_IRQ_TYPE=$(UNISOC_SDIO_IRQ_TYPE_CONFIG)
+endif
 
 #### add cflag ######
 ifeq ($(CONFIG_WCN_SDIO),y)
@@ -114,11 +120,15 @@ endif
 ifeq ($(CONFIG_WCN_USB),y)
 ccflags-y += -DCONFIG_WCN_USB
 endif
+
+ifeq ($(CONFIG_WCN_GNSS),y)
+ccflags-y += -DCONFIG_WCN_GNSS
+endif
+
 ccflags-y += -DCONFIG_WCN_BOOT
 ccflags-y += -DCONFIG_WCN_UTILS
 
 #### include path ######
-ccflags-y += -I$(src)/../tty-sdio
 ccflags-y += -I$(src)/include/
 ccflags-y += -I$(src)/platform/
 ccflags-y += -I$(src)/platform/rf/
@@ -148,7 +158,7 @@ ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
 ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
 ccflags-y += -DCONFIG_SDIO_INBAND_INT
 #ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
-#ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
 #ccflags-y += -DCONFIG_SDIO_PWRSEQ
 endif
 
@@ -177,7 +187,7 @@ ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
 ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
 ccflags-y += -DCONFIG_SDIO_INBAND_INT
 #ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
-#ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
 #ccflags-y += -DCONFIG_SDIO_PWRSEQ
 
 all_dependencies += install
@@ -197,6 +207,7 @@ ccflags-y += -DCONFIG_HISI_BOARD
 #ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
 #ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
 #ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+ccflags-y += -DCONFIG_SYS_REBOOT_NOT_REPOWER_USBCHIP
 ifneq ($(TARGET_BUILD_VARIANT),user)
 ccflags-y += -DCONFIG_WCN_LOOPCHECK
 ccflags-y += -DCONFIG_CPLOG_DEBUG
@@ -227,7 +238,8 @@ ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
 #ccflags-y += -DCONFIG_MEM_PD
 #ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
 #ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
-ccflags-y += -DCONFIG_SDIO_INBAND_INT
+# ccflags-y += -DCONFIG_SDIO_INBAND_INT
+ccflags-y += -DCONFIG_CUSTOMIZE_SDIO_IRQ_TYPE=2
 #ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
 ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
 #ccflags-y += -DCONFIG_SDIO_PWRSEQ
@@ -250,14 +262,15 @@ ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
 #ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
 #ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
 #ccflags-y += -DCONFIG_WCN_LOOPCHECK
-ifneq ($(TARGET_BUILD_VARIANT),user)
-ccflags-y += -DCONFIG_CPLOG_DEBUG
-endif
+#ifneq ($(TARGET_BUILD_VARIANT),user)
+#ccflags-y += -DCONFIG_CPLOG_DEBUG
+#endif
 #ccflags-y += -DCONFIG_MEM_PD
 #ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
 #ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
 #ccflags-y += -DCONFIG_SDIO_INBAND_INT
 #ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+ccflags-y += -DCONFIG_CUSTOMIZE_SDIO_IRQ_TYPE=3
 ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
 #ccflags-y += -DCONFIG_SDIO_PWRSEQ
 
@@ -293,7 +306,7 @@ ccflags-y += -DCONFIG_WCN_PARSE_DTS
 #ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
 ifneq ($(TARGET_BUILD_VARIANT),user)
 ccflags-y += -DCONFIG_WCN_LOOPCHECK
-ccflags-y += -DCONFIG_CPLOG_DEBUG
+#ccflags-y += -DCONFIG_CPLOG_DEBUG
 endif
 #ccflags-y += -DCONFIG_MEM_PD
 
@@ -346,41 +359,47 @@ obj-m := $(MODULE_NAME).o
 endif
 
 $(MODULE_NAME)-y += wcn_bus.o \
-		    platform/wcn_boot.o \
-		    platform/wcn_dump.o \
-		    platform/bufring.o \
-		    platform/wcn_txrx.o \
-		    platform/wcn_op.o \
-		    platform/wcn_parn_parser.o \
-		    platform/rdc_debug.o \
-		    platform/wcn_log.o \
-		    platform/wcn_misc.o \
-		    platform/wcn_procfs.o \
-		    platform/loopcheck.o
+			platform/wcn_boot.o \
+			platform/wcn_dump.o \
+			platform/bufring.o \
+			platform/wcn_txrx.o \
+			platform/wcn_op.o \
+			platform/wcn_parn_parser.o \
+			platform/rdc_debug.o \
+			platform/wcn_log.o \
+			platform/wcn_misc.o \
+			platform/wcn_procfs.o \
+			platform/loopcheck.o
 
 $(MODULE_NAME)-$(CONFIG_WCN_SWD) += platform/wcn_swd_dp.o
 
 $(MODULE_NAME)-$(CONFIG_WCN_USB) += \
-		    usb/wcn_usb.o \
-		    usb/wcn_usb_rx_tx.o \
-		    usb/wcn_usb_store.o \
-		    usb/wcn_usb_io.o \
-		    usb/wcn_usb_test.o \
-		    usb/wcn_usb_download.o \
-		    platform/usb_boot.o
+			usb/wcn_usb.o \
+			usb/wcn_usb_rx_tx.o \
+			usb/wcn_usb_store.o \
+			usb/wcn_usb_io.o \
+			usb/wcn_usb_test.o \
+			usb/wcn_usb_download.o \
+			platform/usb_boot.o
 
 $(MODULE_NAME)-$(CONFIG_WCN_SDIO) += \
-		    sdio/sdiohal_main.o \
-		    sdio/sdiohal_common.o \
-		    sdio/sdiohal_tx.o \
-		    sdio/sdiohal_rx.o \
-		    sdio/sdio_v3.o \
-		    sdio/sdiohal_ctl.o \
-		    sleep/sdio_int.o \
-		    sleep/slp_mgr.o \
-		    sleep/slp_sdio.o \
-		    sleep/slp_test.o \
-		    platform/mem_pd_mgr.o
+			sdio/sdiohal_main.o \
+			sdio/sdiohal_common.o \
+			sdio/sdiohal_tx.o \
+			sdio/sdiohal_rx.o \
+			sdio/sdio_v3.o \
+			sdio/sdiohal_ctl.o \
+			sleep/sdio_int.o \
+			sleep/slp_mgr.o \
+			sleep/slp_sdio.o \
+			sleep/slp_test.o \
+			platform/mem_pd_mgr.o
+
+$(MODULE_NAME)-$(CONFIG_WCN_GNSS) += \
+			platform/gnss/gnss_common_ctl.o \
+			platform/gnss/gnss_pmnotify_ctl.o \
+			platform/gnss/gnss_dbg.o \
+			platform/gnss/gnss_dump.o \
 
 KDIR ?= $(ANDROID_PRODUCT_OUT)/obj/KERNEL_OBJ
 ARCH ?= arm
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c b/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c
index c544d63cfa7d..9f713386ca60 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c
@@ -19,7 +19,6 @@
 #include "wcn_gnss.h"
 #include "wcn_procfs.h"
 
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
 
 static struct mutex marlin_lock;
 static struct wifi_calibration wifi_data;
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h b/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
index ae8daac46644..7a78181a4586 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
@@ -83,7 +83,8 @@ enum marlin_wake_host_en {
 };
 
 enum marlin_cp2_status {
-	MARLIN_CP2_STS_ASSERTED = 0,
+	MARLIN_CP2_STS_READY = 0,
+	MARLIN_CP2_STS_ASSERTED = 1,
 };
 
 enum wcn_hw_type wcn_get_hw_if_type(void);
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
index ca7feadb5460..275a464eb05d 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
@@ -245,16 +245,15 @@ static inline unsigned int reg_value(unsigned int marlin3reg,
 #define GNSS_CP_START_ADDR_M3L 0x40A50000
 #define GNSS_CP_START_ADDR_M3_M3E	0x40A20000
 #define GNSS_CP_START_ADDR \
-	SET_REG_VALUE(GNSS_CP_START_ADDR_M3_M3E, GNSS_CP_START_ADDR_M3L,\
-	GNSS_CP_START_ADDR_M3_M3E)\
+	SET_REG_VALUE(GNSS_CP_START_ADDR_M3_M3E, GNSS_CP_START_ADDR_M3L,	\
+	GNSS_CP_START_ADDR_M3_M3E)
 
 #define GNSS_CP_RESET_REG	0x40BC8280
-//#define GNSS_FIRMWARE_MAX_SIZE 0x58000
 #define GNSS_FIRMWARE_MAX_SIZE_M3L 0x2B000
 #define GNSS_FIRMWARE_MAX_SIZE_M3_M3E 0x58000
-#define	GNSS_FIRMWARE_MAX_SIZE \
-	SET_REG_VALUE(GNSS_FIRMWARE_MAX_SIZE_M3_M3E,\
-	GNSS_FIRMWARE_MAX_SIZE_M3L, GNSS_FIRMWARE_MAX_SIZE_M3_M3E)\
+#define	GNSS_FIRMWARE_MAX_SIZE	\
+	SET_REG_VALUE(GNSS_FIRMWARE_MAX_SIZE_M3_M3E,	\
+	GNSS_FIRMWARE_MAX_SIZE_M3L, GNSS_FIRMWARE_MAX_SIZE_M3_M3E)
 
 #define GNSS_CHIPID_REG 0x603003fc
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c
index b8459b914cb1..7cb79f2f2d0c 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c
@@ -117,7 +117,6 @@ void mdbg_ring_destroy(struct mdbg_ring_t *ring)
 		}
 		MDBG_LOG("to free ring.");
 		kfree(ring);
-		ring = NULL;
 	}
 }
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h
index 5999726f543c..34de085bb05c 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h
@@ -20,44 +20,76 @@
 #ifndef __GNSS_COMMON_H__
 #define __GNSS_COMMON_H__
 
-#ifndef CONFIG_SC2342_INTEG
 /* begin: address map on gnss side, operate by SDIO BUS */
 /* set(s)/clear(c) */
 #define GNSS_SET_OFFSET                 0x1000
 #define GNSS_CLEAR_OFFSET               0x2000
 
-#define GNSS_APB_BASE              0x40bc8000
-#define REG_GNSS_APB_MCU_AP_RST        (GNSS_APB_BASE + 0x0280) /* s/c */
-#define BIT_GNSS_APB_MCU_AP_RST_SOFT    (1<<0)    /* bit0 */
+#define GNSS_APB_BASE                   0x40bc8000
+#define REG_GNSS_APB_MCU_AP_RST         (GNSS_APB_BASE + 0x0280) /* s/c */
+#define BIT_GNSS_APB_MCU_AP_RST_SOFT    (1<<0)                   /* bit0 */
 
-#define GNSS_INDIRECT_OP_REG		0x40b20000
+#define GNSS_INDIRECT_OP_REG            0x40b20000
 
-#define GNSS_AHB_BASE			   0x40b18000
-#define GNSS_ARCH_EB_REG		   (GNSS_AHB_BASE + 0x084)
-#define GNSS_ARCH_EB_REG_BYPASS    (1<<1)
+#define GNSS_AHB_BASE                   0x40b18000
+#define GNSS_ARCH_EB_REG                (GNSS_AHB_BASE + 0x084)
+#define GNSS_ARCH_EB_REG_BYPASS         (1<<1)
+#define GNSS_BOOTSTATUS_SIZE            0x4
+#define GNSS_BOOTSTATUS_MAGIC           0x12345678
+#define GNSS_EFUSE_DATA_SIZE            0xc
+#define GNSS_CALI_DONE_FLAG             0x1314520
 
-#define GNSS_CALI_ADDRESS 0x40aaff4c
-#define GNSS_CALI_DONE_FLAG 0x1314520
-#define GNSS_CALI_DATA_SIZE 0x14
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+#undef CONFIG_CHECK_DRIVER_BY_CHIPID
+#define CONFIG_UWE5622
+#endif
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+#define GNSS_CALI_ADDRESS               0x40aabf4c
+#define GNSS_CALI_DATA_SIZE             0x1c
+#else
+#define GNSS_CALI_ADDRESS               0x40aaff4c
+#define GNSS_CALI_DATA_SIZE             0x14
+#endif
 
-#define GNSS_EFUSE_ADDRESS 0x40aaff40
-#define GNSS_EFUSE_DATA_SIZE 0xc
+#ifdef CONFIG_UWE5622
+#define GNSS_EFUSE_ADDRESS              0x40aabf40
+#else
+#define GNSS_EFUSE_ADDRESS              0x40aaff40
+#endif
 
 /*  GNSS assert workaround */
-#define GNSS_BOOTSTATUS_ADDRESS  0x40aaff6C
-#define GNSS_BOOTSTATUS_SIZE     0x4
-#define GNSS_BOOTSTATUS_MAGIC    0x12345678
-
-/* end: address map on gnss side */
+#ifdef CONFIG_UWE5622
+#define GNSS_BOOTSTATUS_ADDRESS         0x40aabf6c
+#else
+#define GNSS_BOOTSTATUS_ADDRESS         0x40aaff6c
+#endif
 
-int gnss_write_data(void);
-int gnss_backup_data(void);
-void gnss_file_path_set(char *buf);
 #else
-#define GNSS_FLAG_ADDRESS_INFILE    0xFFFFC
-#define GNSS_FLAG_GLO               0x4E4C4700
-#define GNSS_FLAG_BD                0x44420000
+#include "uwe562x_glb.h"
+
+#define GNSS_CALI_ADDRESS_M3               0x40aaff4c
+#define GNSS_CALI_ADDRESS_M3L              0x40aabf4c
+#define GNSS_CALI_ADDRESS  SET_REG_VALUE(GNSS_CALI_ADDRESS_M3, \
+									GNSS_CALI_ADDRESS_M3L, 0)
+
+#define GNSS_CALI_DATA_SIZE_M3              0x14
+#define GNSS_CALI_DATA_SIZE_M3L             0x1c
+#define GNSS_CALI_DATA_SIZE SET_REG_VALUE(GNSS_CALI_DATA_SIZE_M3, \
+									GNSS_CALI_DATA_SIZE_M3L, 0)
+
+#define GNSS_EFUSE_ADDRESS_M3              0x40aaff40
+#define GNSS_EFUSE_ADDRESS_M3L             0x40aabf40
+#define GNSS_EFUSE_ADDRESS SET_REG_VALUE(GNSS_EFUSE_ADDRESS_M3, \
+									GNSS_EFUSE_ADDRESS_M3L, 0)
+
+#define GNSS_BOOTSTATUS_ADDRESS_M3         0x40aaff6c
+#define GNSS_BOOTSTATUS_ADDRESS_M3L        0x40aabf6c
+#define GNSS_BOOTSTATUS_ADDRESS SET_REG_VALUE(GNSS_BOOTSTATUS_ADDRESS_M3, \
+									GNSS_BOOTSTATUS_ADDRESS_M3L, 0)
+
 #endif
-bool gnss_delay_ctl(void);
+
+/* end: address map on gnss side */
 
 #endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c
index c9831c1d38cc..0fe9e1aded81 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c
@@ -76,18 +76,21 @@ enum gnss_cp_status_subtype {
 };
 static struct completion gnss_dump_complete;
 #endif
+
+static const int gnss_version = 0x22;
+#ifdef CONFIG_WCN_PARSE_DTS
 static const struct of_device_id gnss_common_ctl_of_match[] = {
-	{.compatible = "sprd,gnss_common_ctl", .data = (void *)0x22},
+	{.compatible = "sprd,gnss_common_ctl", .data = (void *)&gnss_version},
 	{},
 };
-
+#endif
 #ifndef CONFIG_SC2342_INTEG
 struct gnss_cali {
 	bool cali_done;
 	u32 *cali_data;
 };
 static struct gnss_cali gnss_cali_data;
-static u32 gnss_efuse_data[3];
+static u32 *gnss_efuse_data;
 
 
 #ifdef GNSSDEBUG
@@ -107,14 +110,28 @@ static int gnss_cali_init(void)
 		return -ENOMEM;
 	}
 
-	#ifdef GNSSDEBUG
+#ifdef GNSSDEBUG
 	init_completion(&marlin_dev.gnss_cali_done);
 	sdio_pub_int_RegCb(GNSS_CALI_DONE, (PUB_INT_ISR)gnss_cali_done_isr);
-	#endif
+#endif
+	gnss_efuse_data = kzalloc(GNSS_EFUSE_DATA_SIZE, GFP_KERNEL);
+	if (gnss_efuse_data == NULL) {
+		GNSSCOMM_ERR("%s malloc efuse data fail.\n", __func__);
+		return -ENOMEM;
+	}
 
 	return 0;
 }
 
+static void gnss_cali_deinit(void)
+{
+	gnss_cali_data.cali_done = false;
+	if (gnss_cali_data.cali_data)
+		kfree(gnss_cali_data.cali_data);
+	if (gnss_efuse_data)
+		kfree(gnss_efuse_data);
+}
+
 int gnss_write_cali_data(void)
 {
 	GNSSCOMM_INFO("gnss write calidata, flag %d\n",
@@ -157,16 +174,14 @@ int gnss_backup_cali(void)
 		if (gnss_cali_data.cali_data != NULL) {
 			while (i--) {
 				sprdwcn_bus_direct_read(GNSS_CALI_ADDRESS,
-					gnss_cali_data.cali_data,
-					GNSS_CALI_DATA_SIZE);
+					gnss_cali_data.cali_data, GNSS_CALI_DATA_SIZE);
 				tempvalue = *(gnss_cali_data.cali_data);
-				GNSSCOMM_ERR(" cali %d time, value is 0x%x\n",
-							i, tempvalue);
+				GNSSCOMM_INFO(" cali %d time, value is 0x%x\n", i, tempvalue);
 				if (tempvalue != GNSS_CALI_DONE_FLAG) {
 					msleep(100);
 					continue;
 				}
-				GNSSCOMM_INFO(" cali success\n");
+				GNSSCOMM_INFO("-------------->cali success\n");
 				gnss_cali_data.cali_done = true;
 				break;
 			}
@@ -206,15 +221,20 @@ int gnss_backup_data(void)
 int gnss_boot_wait(void)
 {
 	int ret = -1;
-	u32 magic_value;
+	u32 *magic_value;
 	int i = 125;
 
+	magic_value = kzalloc(GNSS_BOOTSTATUS_SIZE, GFP_KERNEL);
+	if (magic_value == NULL) {
+		GNSSCOMM_ERR("%s, malloc fail\n", __func__);
+		return -1;
+	}
 	while (i--) {
-		sprdwcn_bus_direct_read(GNSS_BOOTSTATUS_ADDRESS, &magic_value,
+		sprdwcn_bus_direct_read(GNSS_BOOTSTATUS_ADDRESS, magic_value,
 					GNSS_BOOTSTATUS_SIZE);
 		GNSSCOMM_ERR("boot read %d time, value is 0x%x\n",
-					i, magic_value);
-		if (magic_value != GNSS_BOOTSTATUS_MAGIC) {
+					i, *magic_value);
+		if (*magic_value != GNSS_BOOTSTATUS_MAGIC) {
 			msleep(20);
 			continue;
 		}
@@ -222,7 +242,7 @@ int gnss_boot_wait(void)
 		GNSSCOMM_INFO("boot read success\n");
 		break;
 	}
-
+	kfree(magic_value);
 	return ret;
 }
 #else
@@ -441,7 +461,7 @@ static ssize_t gnss_dump_store(struct device *dev,
 		temp = wait_for_completion_timeout(&gnss_dump_complete,
 						   msecs_to_jiffies(6000));
 		GNSSCOMM_INFO("%s exit %d\n", __func__,
-			      jiffies_to_msecs(temp));
+				  jiffies_to_msecs(temp));
 		if (temp > 0)
 			ret = GNSS_DUMP_DATA_SUCCESS;
 		else
@@ -600,18 +620,18 @@ static struct sprdwcn_gnss_ops gnss_common_ctl_ops = {
 static int gnss_common_ctl_probe(struct platform_device *pdev)
 {
 	int ret;
+#ifdef CONFIG_WCN_PARSE_DTS
 	const struct of_device_id *of_id;
+#endif
 
-	GNSSCOMM_INFO("%s enter", __func__);
+	GNSSCOMM_ERR("%s enter", __func__);
 	gnss_common_ctl_dev.dev = &pdev->dev;
 
 	gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWEROFF;
-#ifndef CONFIG_SC2342_INTEG
 	gnss_common_ctl_dev.gnss_subsys = MARLIN_GNSS;
 	gnss_cali_init();
-#else
-	gnss_common_ctl_dev.gnss_subsys = WCN_GNSS;
-#endif
+
+#ifdef CONFIG_WCN_PARSE_DTS
 	/* considering backward compatibility, it's not use now  start */
 	of_id = of_match_node(gnss_common_ctl_of_match,
 		pdev->dev.of_node);
@@ -620,7 +640,12 @@ static int gnss_common_ctl_probe(struct platform_device *pdev)
 			"get gnss_common_ctl of device id failed!\n");
 		return -ENODEV;
 	}
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
 	gnss_common_ctl_dev.chip_ver = (unsigned long)(of_id->data);
+#else
+	gnss_common_ctl_dev.chip_ver = gnss_version;
+#endif
 	/* considering backward compatibility, it's not use now  end */
 
 	platform_set_drvdata(pdev, &gnss_common_ctl_dev);
@@ -655,6 +680,7 @@ static int gnss_common_ctl_probe(struct platform_device *pdev)
 
 static int gnss_common_ctl_remove(struct platform_device *pdev)
 {
+	gnss_cali_deinit();
 	wcn_gnss_ops_unregister();
 	sysfs_remove_group(&gnss_common_ctl_miscdev.this_device->kobj,
 				&gnss_common_ctl_group);
@@ -666,24 +692,28 @@ static struct platform_driver gnss_common_ctl_drv = {
 	.driver = {
 		   .name = "gnss_common_ctl",
 		   .owner = THIS_MODULE,
+#ifdef CONFIG_WCN_PARSE_DTS
 		   .of_match_table = of_match_ptr(gnss_common_ctl_of_match),
+#endif
 		   },
 	.probe = gnss_common_ctl_probe,
 	.remove = gnss_common_ctl_remove
 };
 
-static int __init gnss_common_ctl_init(void)
+int __init gnss_common_ctl_init(void)
 {
 	return platform_driver_register(&gnss_common_ctl_drv);
 }
 
-static void __exit gnss_common_ctl_exit(void)
+void __exit gnss_common_ctl_exit(void)
 {
 	platform_driver_unregister(&gnss_common_ctl_drv);
 }
 
+#if (0)
 module_init(gnss_common_ctl_init);
 module_exit(gnss_common_ctl_exit);
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Spreadtrum Gnss Driver");
 MODULE_AUTHOR("Jun.an<jun.an@spreadtrum.com>");
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c
index 5d21799337fd..b1c2b9408cd4 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c
@@ -109,7 +109,6 @@ static void gnss_ring_destroy(struct gnss_ring_t *pring)
 		}
 		GNSS_DEBUG("to free pring.");
 		kfree(pring);
-		pring = NULL;
 	}
 }
 
@@ -165,8 +164,8 @@ static int gnss_ring_read(struct gnss_ring_t *pring, char *buf, int len)
 
 	if (!buf || !pring || !len) {
 		GNSS_ERR
-		    ("Ring Read Failed, Param Error!,buf=%p,pring=%p,len=%d",
-		     buf, pring, len);
+			("Ring Read Failed, Param Error!,buf=%p,pring=%p,len=%d",
+			 buf, pring, len);
 		return -GNSS_ERR_BAD_PARAM;
 	}
 	mutex_lock(pring->plock);
@@ -209,8 +208,8 @@ static int gnss_ring_write(struct gnss_ring_t *pring, char *buf, int len)
 
 	if (!pring || !buf || !len) {
 		GNSS_ERR
-		    ("Ring Write Failed, Param Error!,buf=%p,pring=%p,len=%d",
-		     buf, pring, len);
+			("Ring Write Failed, Param Error!,buf=%p,pring=%p,len=%d",
+			 buf, pring, len);
 		return -GNSS_ERR_BAD_PARAM;
 	}
 	pstart = gnss_ring_start(pring);
@@ -292,7 +291,7 @@ static ssize_t gnss_dbg_read(struct file *filp,
 }
 
 static ssize_t gnss_dbg_write(struct file *filp, const char __user *buf,
-			      size_t count, loff_t *pos)
+				  size_t count, loff_t *pos)
 {
 	ssize_t len = 0;
 
@@ -318,7 +317,7 @@ static struct miscdevice gnss_dbg_device = {
 };
 
 static ssize_t gnss_slog_read(struct file *filp, char __user *buf,
-			      size_t count, loff_t *pos)
+				  size_t count, loff_t *pos)
 {
 	ssize_t len = 0;
 
@@ -328,7 +327,7 @@ static ssize_t gnss_slog_read(struct file *filp, char __user *buf,
 }
 
 static ssize_t gnss_slog_write(struct file *filp, const char __user *buf,
-			       size_t count, loff_t *pos)
+				   size_t count, loff_t *pos)
 {
 	return 0;
 }
@@ -373,12 +372,12 @@ static struct miscdevice gnss_slog_device = {
 	.fops = &gnss_slog_fops,
 };
 
-static int __init gnss_module_init(void)
+int __init gnss_module_init(void)
 {
 	int ret;
 
 	gnss_rx_ring = gnss_ring_init(GNSS_RX_RING_SIZE,
-				      gnss_memcpy_rd, gnss_memcpy_wr);
+					  gnss_memcpy_rd, gnss_memcpy_wr);
 	if (!gnss_rx_ring) {
 		GNSS_ERR("Ring malloc error.");
 		return -GNSS_ERR_MALLOC_FAIL;
@@ -406,7 +405,7 @@ static int __init gnss_module_init(void)
 	return ret;
 }
 
-static void __exit gnss_module_exit(void)
+void __exit gnss_module_exit(void)
 {
 	gnss_ring_destroy(gnss_rx_ring);
 	gnss_device_destroy();
@@ -414,6 +413,8 @@ static void __exit gnss_module_exit(void)
 	misc_deregister(&gnss_slog_device);
 }
 
+#if (0)
 module_init(gnss_module_init);
 module_exit(gnss_module_exit);
 MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c
index 44afbf6ec70f..48da71449d89 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c
@@ -18,7 +18,9 @@
 #endif
 #include <linux/kthread.h>
 #include <linux/printk.h>
+#ifdef CONFIG_WCN_SIPC
 #include <linux/sipc.h>
+#endif
 #include <linux/slab.h>
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
@@ -47,7 +49,11 @@ struct gnss_mem_dump {
 
 /* dump cp firmware firstly, wait for next adding */
 static struct gnss_mem_dump gnss_marlin3_dump[] = {
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
 	{GNSS_CP_START_ADDR, GNSS_FIRMWARE_MAX_SIZE}, /* gnss firmware code */
+#else
+	{0, 0},
+#endif
 	{GNSS_DRAM_ADDR, GNSS_DRAM_SIZE}, /* gnss dram */
 	{GNSS_TE_MEM, GNSS_TE_MEM_SIZE}, /* gnss te mem */
 	{GNSS_BASE_AON_APB, GNSS_BASE_AON_APB_SIZE}, /* aon apb */
@@ -99,6 +105,20 @@ static char gnss_dump_level; /* 0: default, all, 1: only data, pmu, aon */
 
 #endif
 
+
+static int wcn_chmod(char *path, char *mode)
+{
+	int result = 0;
+	char cmd_path[] = "/usr/bin/chmod";
+	char *cmd_argv[] = {cmd_path, mode, path, NULL};
+	char *cmd_envp[] = {"HOME=/", "PATH=/sbin:/bin:/usr/bin", NULL};
+
+	result = call_usermodehelper(cmd_path, cmd_argv, cmd_envp,
+		UMH_WAIT_PROC);
+
+	return result;
+}
+
 static int gnss_creat_gnss_dump_file(void)
 {
 	gnss_dump_file = filp_open(GNSS_MEMDUMP_PATH,
@@ -109,7 +129,7 @@ static int gnss_creat_gnss_dump_file(void)
 			__func__, gnss_dump_file);
 		return -1;
 	}
-	if (sys_chmod(GNSS_MEMDUMP_PATH, 0666) != 0)
+	if (wcn_chmod(GNSS_MEMDUMP_PATH, "0666") != 0)
 		GNSSDUMP_ERR("%s chmod	error\n", __func__);
 
 	return 0;
@@ -441,7 +461,7 @@ static int gnss_ext_hold_cpu(void)
 	}
 	temp = GNSS_ARCH_EB_REG_BYPASS;
 	ret = sprdwcn_bus_reg_write(GNSS_ARCH_EB_REG + GNSS_SET_OFFSET,
-				    &temp, 4);
+					&temp, 4);
 	if (ret < 0)
 		GNSSDUMP_ERR("%s write bypass reg error:%d\n", __func__, ret);
 
@@ -501,11 +521,11 @@ static int gnss_ext_dump_mem(void)
 	int i = 0;
 
 	GNSSDUMP_INFO("%s entry\n", __func__);
-#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+// #ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
 	/*update the two address after get chip type*/
 	gnss_marlin3_dump[0].address = GNSS_CP_START_ADDR;
 	gnss_marlin3_dump[0].length = GNSS_FIRMWARE_MAX_SIZE;
-#endif
+// #endif
 	gnss_ext_hold_cpu();
 	ret = gnss_creat_gnss_dump_file();
 	if (ret == -1) {
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c
index 84412f9160dd..6bf78a2bd9c1 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c
@@ -32,6 +32,7 @@
 #include <linux/timer.h>
 #include <linux/types.h>
 #include <linux/uaccess.h>
+// #include <linux/wakelock.h>
 #include <linux/wait.h>
 #include <marlin_platform.h>
 
@@ -50,6 +51,8 @@ struct sprd_gnss {
 static struct sprd_gnss gnss_dev;
 static int gnss_delay_cancel;
 
+extern bool gnss_delay_ctl(void);
+
 static int gnss_pmnotify_ctl_open(struct inode *inode, struct file *filp)
 {
 	return 0;
@@ -117,7 +120,7 @@ static struct miscdevice gnss_pmnotify_ctl_device = {
 	.fops = &gnss_pmnotify_ctl_fops,
 };
 
-static int __init gnss_pmnotify_ctl_init(void)
+int __init gnss_pmnotify_ctl_init(void)
 {
 	int err = 0;
 
@@ -132,12 +135,14 @@ static int __init gnss_pmnotify_ctl_init(void)
 	return err;
 }
 
-static void __exit gnss_pmnotify_ctl_cleanup(void)
+void __exit gnss_pmnotify_ctl_cleanup(void)
 {
 	misc_deregister(&gnss_pmnotify_ctl_device);
 }
 
+#if (0)
 module_init(gnss_pmnotify_ctl_init);
 module_exit(gnss_pmnotify_ctl_cleanup);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("sprd gnss pmnotify ctl driver");
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c
index 015c9020e913..86fa3b103ad3 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c
@@ -31,8 +31,6 @@
 #define UNISOC_DBG_PATH_DEFAULT "/data/unisoc_dbg"
 #endif
 
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-
 /* size of cp2 log files, default is 20M. */
 static unsigned int wcn_cp2_log_limit_size =
 	UNISOC_DBG_FILESIZE_DEFAULT * 1024 * 1024;
@@ -43,16 +41,14 @@ static unsigned int wcn_cp2_file_max_num = UNISOC_DBG_FILENUM_DEFAULT;
  */
 static unsigned int wcn_cp2_log_cover_old = 1;
 /* path of config file unisoc_cp2log_config.txt */
-#define WCN_DEBUG_CFG_MAX_PATH_NUM	3
+#define WCN_DEBUG_CFG_MAX_PATH_NUM	0
 static char *wcn_cp2_config_path[WCN_DEBUG_CFG_MAX_PATH_NUM] = {
-	"/etc/unisoc_cp2log_config.txt",
 	"/data/unisoc_cp2log_config.txt",
 	"/vendor/etc/wifi/unisoc_cp2log_config.txt"
 };
 /* path of cp2 log and mem files. */
-#define WCN_UNISOC_DBG_MAX_PATH_NUM	4
+#define WCN_UNISOC_DBG_MAX_PATH_NUM	0
 static char *wcn_unisoc_dbg_path[WCN_UNISOC_DBG_MAX_PATH_NUM] = {
-	"/etc",
 	UNISOC_DBG_PATH_DEFAULT,/* most of projects */
 	"/data",		/* amlogic s905w... */
 	"/mnt/UDISK"		/* allwinner r328... */
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
index 57cf1a898fb9..fca777c80200 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
@@ -10,7 +10,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
+#include <linux/syscalls.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
@@ -325,6 +325,8 @@ static struct regmap *reg_map;
 #define AFC_CALI_READ_FINISH 0x12121212
 #define WCN_AFC_CALI_PATH "/productinfo/wcn/tsx_bt_data.txt"
 
+#define BIT(nr) (1UL << (nr))
+
 #ifdef CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
 #define POWER_WQ_DELAYED_MS 0
 #else
@@ -1255,8 +1257,6 @@ static void marlin_release_firmware(struct marlin_firmware *mfirmware)
 	if (mfirmware) {
 		if (mfirmware->is_from_fs)
 			release_firmware(mfirmware->priv);
-		else
-			vfree(mfirmware->data);
 		kfree(mfirmware);
 	}
 }
@@ -1277,75 +1277,35 @@ void wcn_gnss_ops_unregister(void)
 {
 	gnss_ops = NULL;
 }
-
-static char *gnss_load_firmware_data(unsigned long int imag_size)
+static int gnss_download_firmware(void)
 {
 	char *buf;
+	int err;
+	unsigned int load_fw_cnt = 0;
 
-	MDBG_LOG("%s entry\n", __func__);
+	buf = marlin_dev->write_buffer;
+reload:
+	WCN_DEBUG("%s %d.load from %s\n", __func__, load_fw_cnt + 1, GNSS_FIRMWARE_PATH);
 	if (gnss_ops && (gnss_ops->set_file_path))
 		gnss_ops->set_file_path(&GNSS_FIRMWARE_PATH[0]);
 	else
 		WCN_ERR("%s gnss_ops set_file_path error\n", __func__);
-	buf = load_firmware_data_path(GNSS_FIRMWARE_PATH, 0, imag_size);
-
-	return buf;
-}
-
-static int gnss_download_from_partition(void)
-{
-	int err;
-	unsigned long int imgpack_size, img_size;
-	char *buffer = NULL;
-	char *temp = NULL;
-
-	img_size = imgpack_size =  GNSS_FIRMWARE_MAX_SIZE;
-	WCN_INFO("GNSS %s entry\n", __func__);
-	temp = buffer = gnss_load_firmware_data(imgpack_size);
-	if (!buffer) {
-		WCN_INFO("%s gnss buff is NULL\n", __func__);
-		return -1;
-	}
-
-	err = sprdwcn_bus_direct_write_dispack(GNSS_CP_START_ADDR, buffer,
-			img_size, PACKET_SIZE);
-	vfree(temp);
-	if (!err)
-		WCN_INFO("%s gnss download firmware finish\n", __func__);
 
-	return err;
-}
-
-static int gnss_download_firmware(void)
-{
-	const struct firmware *firmware;
-	char *buf;
-	int err;
-
-	if (marlin_dev->is_gnss_in_sysfs == 1) {
-		err = gnss_download_from_partition();
-		return err;
-	}
+	buf = load_firmware_data_path(GNSS_FIRMWARE_PATH, 0, GNSS_FIRMWARE_MAX_SIZE);
 
-	WCN_INFO("%s start from /system/etc/firmware/\n", __func__);
-	buf = marlin_dev->write_buffer;
-	err = request_firmware(&firmware, GNSS_FW_NAME, NULL);
-	if (err < 0) {
-		WCN_ERR("%s no find %s err:%d(ignore)\n",
-			__func__, GNSS_FW_NAME, err);
-		marlin_dev->is_gnss_in_sysfs = 1;
-		err = gnss_download_from_partition();
-
-		return err;
+	if (!buf) {
+		++load_fw_cnt;
+		if (load_fw_cnt < WCN_FW_MAX_PATH_NUM) {
+			sprintf(GNSS_FIRMWARE_PATH, "%s%s", \
+					wcn_fw_path[load_fw_cnt], GNSS_FW_NAME);
+			goto reload;
+		}
 	}
 
-	err = sprdwcn_bus_direct_write_dispack(GNSS_CP_START_ADDR,
-			firmware->data, firmware->size, PACKET_SIZE);
-	if (!err)
-		WCN_INFO("%s successfully through request_firmware!\n",
-				__func__);
-	release_firmware(firmware);
-	WCN_INFO("%s successfully through request_firmware!\n", __func__);
+	err = sprdwcn_bus_direct_write_dispack(GNSS_CP_START_ADDR, \
+			buf, GNSS_FIRMWARE_MAX_SIZE, PACKET_SIZE);
+	if (err)
+		WCN_INFO("%s download error\n", __func__);
 
 	return err;
 }
@@ -1413,14 +1373,15 @@ static int marlin_registsr_bt_wake(struct device *dev)
 {
 	struct device_node *np;
 	int bt_wake_host_gpio, ret = 0;
-	enum of_gpio_flags config;
+	struct gpio_config config;
 
 	np = of_find_compatible_node(NULL, NULL, "allwinner,sunxi-btlpm");
 	if (!np) {
 		WCN_ERR("dts node for bt_wake not found");
 		return -EINVAL;
 	}
-	bt_wake_host_gpio = of_get_named_gpio_flags(np, "bt_hostwake", 0, &config);
+	bt_wake_host_gpio = of_get_named_gpio_flags(np, "bt_hostwake", 0,
+		(enum of_gpio_flags *)&config);
 	if (!gpio_is_valid(bt_wake_host_gpio)) {
 		WCN_ERR("bt_hostwake irq is invalid: %d\n",
 			bt_wake_host_gpio);
@@ -1444,8 +1405,10 @@ static int marlin_registsr_bt_wake(struct device *dev)
 
 	marlin_dev->bt_wake_host_int_num = gpio_to_irq(bt_wake_host_gpio);
 
-	WCN_INFO("%s bt_hostwake gpio=%d intnum=%d\n",
-		 __func__, bt_wake_host_gpio,
+	WCN_INFO("%s bt_hostwake gpio=%d mul-sel=%d pull=%d "
+		 "drv_level=%d data=%d intnum=%d\n",
+		 __func__, config.gpio, config.mul_sel, config.pull,
+		 config.drv_level, config.data,
 		 marlin_dev->bt_wake_host_int_num);
 
 	ret = device_init_wakeup(dev, true);
@@ -1489,6 +1452,8 @@ static int marlin_parse_dt(struct platform_device *pdev)
 {
 #ifdef CONFIG_WCN_PARSE_DTS
 	struct device_node *np = pdev->dev.of_node;
+#elif defined CONFIG_AW_BOARD
+	struct device_node *np = NULL;
 #endif
 #ifdef CONFIG_WCN_PMIC
 	struct regmap *pmu_apb_gpr;
@@ -1507,7 +1472,7 @@ static int marlin_parse_dt(struct platform_device *pdev)
 
 	/* xtal-26m-clk-type has priority over than xtal-26m-clk-type-gpio */
 	ret = of_property_read_string(np, "xtal-26m-clk-type",
-				      (const char **)&buf);
+					  (const char **)&buf);
 	if (!ret) {
 		WCN_INFO("force config xtal 26m clk %s\n", buf);
 		if (!strncmp(buf, "TCXO", 4))
@@ -1655,7 +1620,7 @@ static int marlin_parse_dt(struct platform_device *pdev)
 #endif
 
 	ret = of_property_read_string(np, "unisoc,btwf-file-name",
-				      (const char **)&marlin_dev->btwf_path);
+					  (const char **)&marlin_dev->btwf_path);
 	if (!ret)
 		strcpy(BTWF_FIRMWARE_PATH, marlin_dev->btwf_path);
 	else
@@ -1664,7 +1629,7 @@ static int marlin_parse_dt(struct platform_device *pdev)
 	WCN_DEBUG("btwf firmware path is %s\n", BTWF_FIRMWARE_PATH);
 
 	ret = of_property_read_string(np, "unisoc,gnss-file-name",
-				      (const char **)&marlin_dev->gnss_path);
+					  (const char **)&marlin_dev->gnss_path);
 	if (!ret) {
 		WCN_INFO("gnss firmware name:%s\n", marlin_dev->gnss_path);
 		strcpy(GNSS_FIRMWARE_PATH, marlin_dev->gnss_path);
@@ -1672,6 +1637,8 @@ static int marlin_parse_dt(struct platform_device *pdev)
 #else
 	sprintf(BTWF_FIRMWARE_PATH, "%s%s", wcn_fw_path[0], WCN_FW_NAME);
 	WCN_DEBUG("btwf firmware path is %s\n", BTWF_FIRMWARE_PATH);
+	sprintf(GNSS_FIRMWARE_PATH, "%s%s", wcn_fw_path[0], GNSS_FW_NAME);
+	WCN_DEBUG("gnss firmware path is %s\n", GNSS_FIRMWARE_PATH);
 #endif /* end of CONFIG_WCN_PARSE_DTS */
 
 #ifdef CONFIG_WCN_PARSE_DTS
@@ -1823,7 +1790,7 @@ static int marlin_avdd18_dcxo_enable(bool enable)
 		if (regulator_is_enabled(marlin_dev->dcxo18))
 			return 0;
 		regulator_set_voltage(marlin_dev->dcxo18,
-					      1800000, 1800000);
+						  1800000, 1800000);
 		ret = regulator_enable(marlin_dev->dcxo18);
 		if (ret)
 			WCN_ERR("fail to enable avdd18_dcxo\n");
@@ -1852,7 +1819,7 @@ static int marlin_digital_power_enable(bool enable)
 		/* gpio_direction_output(marlin_dev->reset, 0); */
 
 		regulator_set_voltage(marlin_dev->dvdd12,
-					      1200000, 1200000);
+						  1200000, 1200000);
 		ret = regulator_enable(marlin_dev->dvdd12);
 	} else {
 		if (regulator_is_enabled(marlin_dev->dvdd12))
@@ -1949,7 +1916,7 @@ void marlin_read_cali_data(void)
 		WCN_INFO("marlin2 cp_clk_wait_val is modifyed 0x%x\n",
 					cp_clk_wait_val);
 		err = sprdwcn_bus_reg_write(marlin2_clk_wait_reg,
-					       &cp_clk_wait_val, 4);
+						   &cp_clk_wait_val, 4);
 		if (err < 0)
 			WCN_ERR("marlin2 write 26M error:%d\n", err);
 	}
@@ -2059,10 +2026,18 @@ static void marlin_send_sdio_config_to_cp_vendor(void)
 		sdio_cfg.cfg.sdio_irq_type = 1;
 		WCN_INFO("sdio_config irq:[inband]\n");
 	} else {
-#if defined(CONFIG_AML_BOARD)
-		sdio_cfg.cfg.sdio_irq_type = 3;
-		WCN_INFO("sdio_config sdio_irq:[gpio13]\n");
+#ifdef CONFIG_CUSTOMIZE_SDIO_IRQ_TYPE
+		sdio_cfg.cfg.sdio_irq_type = CONFIG_CUSTOMIZE_SDIO_IRQ_TYPE;
+		if (sdio_cfg.cfg.sdio_irq_type == 0)
+			WCN_INFO("sdio_config sdio_irq:[gpio1]\n");
+		else if (sdio_cfg.cfg.sdio_irq_type == 2)
+			WCN_INFO("sdio_config sdio_irq:[pubint]\n");
+		else if (sdio_cfg.cfg.sdio_irq_type == 3)
+			WCN_INFO("sdio_config sdio_irq:[esmd3]\n");
+		else
+			WCN_INFO("sdio_config sdio_irq:[error]\n");
 #else
+		sdio_cfg.cfg.sdio_irq_type = 0;
 		WCN_INFO("sdio_config sdio_irq:[gpio1]\n");
 #endif
 	}
@@ -2458,6 +2433,10 @@ static int check_cp_ready(void)
 	int ret = 0;
 	int i = 0;
 
+#ifdef CONFIG_WCN_USB
+	return sprdwcn_check_cp_ready(SYNC_ADDR, 3000);
+#endif
+
 	do {
 		i++;
 		ret = sprdwcn_bus_direct_read(SYNC_ADDR,
@@ -2709,17 +2688,6 @@ void marlin_chip_en(bool enable, bool reset)
 }
 EXPORT_SYMBOL_GPL(marlin_chip_en);
 
-static int marlin_set_power(int subsys, int val);
-
-void marlin_cp2_reset(void)
-{
-	WCN_INFO("[%s], DO BSP RESET\n", __func__);
-	marlin_dev->first_power_on_flag = 0;
-	marlin_set_power(MARLIN_WIFI, false);
-	marlin_set_power(MARLIN_BLUETOOTH, false);
-}
-EXPORT_SYMBOL_GPL(marlin_cp2_reset);
-
 int set_cp_mem_status(int subsys, int val)
 {
 	int ret;
@@ -2848,19 +2816,21 @@ static void power_state_notify_or_not(int subsys, int poweron)
 	}
 }
 
-static int marlin_scan_finish(void)
+static void marlin_scan_finish(void)
 {
 	WCN_INFO("marlin_scan_finish!\n");
 	complete(&marlin_dev->carddetect_done);
-	return 0;
 }
 
 int find_firmware_path(void)
 {
 	int ret;
 	int pre_len;
-
+#ifdef CONFIG_WCN_GNSS
+	if ((strlen(BTWF_FIRMWARE_PATH) != 0) || (strlen(GNSS_FIRMWARE_PATH) != 0))
+#else
 	if (strlen(BTWF_FIRMWARE_PATH) != 0)
+#endif
 		return 0;
 
 	ret = parse_firmware_path(BTWF_FIRMWARE_PATH);
@@ -2870,11 +2840,8 @@ int find_firmware_path(void)
 	}
 	WCN_INFO("BTWF path is %s\n", BTWF_FIRMWARE_PATH);
 	pre_len = strlen(BTWF_FIRMWARE_PATH) - strlen("wcnmodem");
-	memcpy(GNSS_FIRMWARE_PATH,
-		BTWF_FIRMWARE_PATH,
-		strlen(BTWF_FIRMWARE_PATH));
-	memcpy(&GNSS_FIRMWARE_PATH[pre_len], "gnssmodem",
-		strlen("gnssmodem"));
+	memcpy(GNSS_FIRMWARE_PATH, BTWF_FIRMWARE_PATH, strlen(BTWF_FIRMWARE_PATH));
+	memcpy(&GNSS_FIRMWARE_PATH[pre_len], "gnssmodem", strlen("gnssmodem"));
 	GNSS_FIRMWARE_PATH[pre_len + strlen("gnssmodem")] = '\0';
 	WCN_INFO("GNSS path is %s\n", GNSS_FIRMWARE_PATH);
 
@@ -2925,7 +2892,7 @@ static void pre_gnss_download_firmware(struct work_struct *work)
 
 }
 
-#ifdef CONFIG_WCN_USB
+#if defined CONFIG_WCN_USB && defined CONFIG_SYS_REBOOT_NOT_REPOWER_USBCHIP
 static unsigned char fdl_hex_buf[] = {
 #include "../fw/usb_fdl.bin.hex"
 };
@@ -2993,6 +2960,7 @@ static void btwifi_download_fdl_firmware(void)
 static void pre_btwifi_download_sdio(struct work_struct *work)
 {
 #ifdef CONFIG_WCN_USB
+#ifdef CONFIG_SYS_REBOOT_NOT_REPOWER_USBCHIP
 	/*
 	 * Fix Bug 1349945.
 	 * Because the usb vbus can't be controlled on some platforms,
@@ -3006,7 +2974,7 @@ static void pre_btwifi_download_sdio(struct work_struct *work)
 	 * again and normal boot system.
 	 */
 	btwifi_download_fdl_firmware();
-
+#endif
 	marlin_firmware_download_start_usb();
 #endif
 	wcn_get_chip_name();
@@ -3071,7 +3039,7 @@ void wifipa_enable(int enable)
 			if (regulator_is_enabled(marlin_dev->avdd33))
 				return;
 			regulator_set_voltage(marlin_dev->avdd33,
-					      3300000, 3300000);
+						  3300000, 3300000);
 			ret = regulator_enable(marlin_dev->avdd33);
 			if (ret)
 				WCN_ERR("fail to enable wifipa\n");
@@ -3624,10 +3592,10 @@ int marlin_get_module_status(void)
 		test_bit(MARLIN_FM, &marlin_dev->power_state) ||
 		test_bit(MARLIN_WIFI, &marlin_dev->power_state) ||
 		test_bit(MARLIN_MDBG, &marlin_dev->power_state) ||
+		test_bit(MARLIN_GNSS, &marlin_dev->power_state) ||
 		test_bit(WCN_AUTO, &marlin_dev->power_state))
 		return 1;
-	else
-		return 0;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(marlin_get_module_status);
 
@@ -3643,11 +3611,9 @@ EXPORT_SYMBOL_GPL(is_first_power_on);
 int cali_ini_need_download(enum marlin_sub_sys subsys)
 {
 	unsigned int pd_wifi_st = 0;
+
 #ifdef CONFIG_AW_BOARD
-/*
- * Fix SPCSS00757820, wifi&bt on/off frequently & fast,
- * need download ini but don't download
- */
+	/*FIX SPCSS00757820, wifi-bt on/off frequently & quickly, ini need download but not*/
 	return 1;
 #endif
 
@@ -3873,7 +3839,7 @@ static int marlin_probe(struct platform_device *pdev)
 	INIT_DELAYED_WORK(&marlin_dev->power_wq, marlin_power_wq);
 #if 0
 	schedule_delayed_work(&marlin_dev->power_wq,
-			      msecs_to_jiffies(POWER_WQ_DELAYED_MS));
+				  msecs_to_jiffies(POWER_WQ_DELAYED_MS));
 #endif
 
 #ifdef CONFIG_WCN_PMIC
@@ -4014,6 +3980,7 @@ static void marlin_reset_notify_init(void)
 */
 int marlin_reset_notify_call(enum marlin_cp2_status sts)
 {
+
 	int i = 0;
 	for (i = 0; i < MARLIN_ALL; i++) {
 		if (NULL != marlin_reset_notifiers[i].head)
@@ -4085,14 +4052,41 @@ static struct platform_device uwe_device = {
 		.release = uwe_release,
 	}
 };
+
+#ifdef CONFIG_WCN_GNSS
+static void gnss_common_ctl_release(struct device *dev)
+{
+	WCN_INFO("[%s]enter\n", __func__);
+}
+static struct platform_device gnss_common_ctl_device = {
+	.name = "gnss_common_ctl",
+	.dev = {
+		.release = gnss_common_ctl_release,
+	}
+};
+#endif
 #endif
 
+#ifdef CONFIG_WCN_GNSS
+extern int __init gnss_common_ctl_init(void);
+extern void __exit gnss_common_ctl_exit(void);
+extern int __init gnss_pmnotify_ctl_init(void);
+extern void __exit gnss_pmnotify_ctl_cleanup(void);
+extern int __init gnss_module_init(void);
+extern void __exit gnss_module_exit(void);
+#endif
 static int __init marlin_init(void)
 {
 	WCN_INFO("marlin_init entry!\n");
 
 #ifndef CONFIG_WCN_PARSE_DTS
 	platform_device_register(&uwe_device);
+#endif
+#ifdef CONFIG_WCN_GNSS
+	platform_device_register(&gnss_common_ctl_device);
+	gnss_common_ctl_init();
+	gnss_pmnotify_ctl_init();
+	gnss_module_init();
 #endif
 	return platform_driver_register(&marlin_driver);
 }
@@ -4108,6 +4102,12 @@ static void __exit marlin_exit(void)
 
 #ifndef CONFIG_WCN_PARSE_DTS
 	platform_device_unregister(&uwe_device);
+#endif
+#ifdef CONFIG_WCN_GNSS
+	gnss_common_ctl_exit();
+	gnss_pmnotify_ctl_cleanup();
+	gnss_module_exit();
+	platform_device_register(&gnss_common_ctl_device);
 #endif
 	platform_driver_unregister(&marlin_driver);
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h
index 391280910f84..7121823e7af8 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h
@@ -1,12 +1,6 @@
 #ifndef __WCN_OP_H__
 #define __WCN_OP_H__
 
-#if defined(CONFIG_STACKPROTECTOR) && defined(CONFIG_STACKPROTECTOR_PER_TASK)
-#include <linux/stackprotector.h>
-unsigned long __stack_chk_guard __read_mostly;
-EXPORT_SYMBOL(__stack_chk_guard);
-#endif
-
 int wcn_op_init(void);
 void wcn_op_exit(void);
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c
index fe6cd44fb178..0a61282f4cb1 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c
@@ -48,9 +48,6 @@
 #define CONF_DELIMITERS " =\n\r\t"
 #define CONF_VALUES_DELIMITERS "=\n\r\t"
 #define CONF_MAX_LINE_LEN 255
-
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-
 static const char *prefix = "fstab.s";
 static char fstab_name[128];
 static char fstab_dir[FSTAB_PATH_NUM][32] = {
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
index b179f2398b1f..77b4ec259e3d 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
@@ -23,7 +23,7 @@
 #include <linux/seq_file.h>
 #include <linux/version.h>
 #include <linux/wait.h>
-#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
 #include <linux/sched/clock.h>
 #endif
 #include <wcn_bus.h>
@@ -38,7 +38,7 @@
 #include "marlin_platform.h"
 
 
-#define CONFIG_CP2_ASSERT       (0)
+#define CONFIG_CP2_ASSERT       (1)
 
 u32 wcn_print_level = WCN_DEBUG_OFF;
 
@@ -94,12 +94,12 @@ void mdbg_assert_interface(char *str)
 	stop_loopcheck();
 #endif
 
+#if (CONFIG_CP2_ASSERT)
 	memset(mdbg_proc->assert.buf, 0, MDBG_ASSERT_SIZE);
 	strncpy(mdbg_proc->assert.buf, str, len);
 	WCN_INFO("mdbg_assert_interface:%s\n",
 		(char *)(mdbg_proc->assert.buf));
 
-#if (CONFIG_CP2_ASSERT)
 	sprdwcn_bus_set_carddump_status(true);
 #ifndef CONFIG_WCND
 	/* wcn_hold_cpu(); */
@@ -113,9 +113,8 @@ void mdbg_assert_interface(char *str)
 #else
 	WCN_ERR("%s,%s reset & notify...\n", __func__, str);
 	marlin_reset_notify_call(MARLIN_CP2_STS_ASSERTED);
-	marlin_cp2_reset();
 	msleep(1000);
-	// marlin_reset_notify_call(MARLIN_CP2_STS_READY);
+	marlin_reset_notify_call(MARLIN_CP2_STS_READY);
 #endif
 
 }
@@ -142,6 +141,7 @@ int mdbg_assert_read(int channel, struct mbuf_t *head,
 		     struct mbuf_t *tail, int num)
 {
 	unsigned int data_length;
+#if (CONFIG_CP2_ASSERT)
 	data_length = mdbg_mbuf_get_datalength(head);
 	if (data_length > MDBG_ASSERT_SIZE) {
 		WCN_ERR("assert data len:%d,beyond max read:%d",
@@ -154,7 +154,6 @@ int mdbg_assert_read(int channel, struct mbuf_t *head,
 	mdbg_proc->assert.rcv_len = data_length;
 	WCN_INFO("mdbg_assert_read:%s,data length %d\n",
 		(char *)(mdbg_proc->assert.buf), data_length);
-#if (CONFIG_CP2_ASSERT)
 #ifndef CONFIG_WCND
 	sprdwcn_bus_set_carddump_status(true);
 	/* wcn_hold_cpu(); */
@@ -173,9 +172,8 @@ int mdbg_assert_read(int channel, struct mbuf_t *head,
 #endif
 		WCN_ERR("chip reset & notify every subsystem...\n");
 		marlin_reset_notify_call(MARLIN_CP2_STS_ASSERTED);
-		marlin_cp2_reset();
 		msleep(1000);
-		// marlin_reset_notify_call(MARLIN_CP2_STS_READY);
+		marlin_reset_notify_call(MARLIN_CP2_STS_READY);
 #endif
 	return 0;
 }
@@ -239,7 +237,7 @@ int mdbg_at_cmd_read(int channel, struct mbuf_t *head,
 	default:
 		memset(mdbg_proc->at_cmd.buf, 0, MDBG_AT_CMD_SIZE);
 		memcpy(mdbg_proc->at_cmd.buf, head->buf + PUB_HEAD_RSV,
-		       data_length);
+			   data_length);
 		mdbg_proc->at_cmd.rcv_len = data_length;
 		WCN_INFO("WCND at cmd read:%s\n",
 			(char *)(mdbg_proc->at_cmd.buf));
@@ -315,7 +313,7 @@ static int loopcheck_prepare_buf(int chn, struct mbuf_t **head,
 }
 
 static int at_cmd_prepare_buf(int chn, struct mbuf_t **head,
-			      struct mbuf_t **tail, int *num)
+				  struct mbuf_t **tail, int *num)
 {
 	int ret;
 
@@ -326,7 +324,7 @@ static int at_cmd_prepare_buf(int chn, struct mbuf_t **head,
 }
 
 static int assert_prepare_buf(int chn, struct mbuf_t **head,
-			      struct mbuf_t **tail, int *num)
+				  struct mbuf_t **tail, int *num)
 {
 	int ret;
 
@@ -420,13 +418,23 @@ static int mdbg_snap_shoot_seq_open(struct inode *inode, struct file *file)
 	return seq_open(file, &mdbg_snap_shoot_seq_ops);
 }
 
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
 static const struct proc_ops mdbg_snap_shoot_seq_fops = {
 	.proc_open = mdbg_snap_shoot_seq_open,
 	.proc_read = seq_read,
 	.proc_write = mdbg_snap_shoot_seq_write,
 	.proc_lseek = seq_lseek,
-	.proc_release = seq_release
+	.proc_release = seq_release,
 };
+#else
+static const struct file_operations mdbg_snap_shoot_seq_fops = {
+	.open = mdbg_snap_shoot_seq_open,
+	.read = seq_read,
+	.write = mdbg_snap_shoot_seq_write,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+#endif
 
 static int mdbg_proc_open(struct inode *inode, struct file *filp)
 {
@@ -756,6 +764,12 @@ static ssize_t mdbg_proc_write(struct file *filp,
 		return count;
 	}
 
+	if (strncmp(mdbg_proc->write_buf, "startgps", 7) == 0) {
+		start_marlin(MARLIN_GNSS);
+		return count;
+	}
+
+
 
 	/* unit of loglimitsize is MByte. */
 	if (strncmp(mdbg_proc->write_buf, "loglimitsize=",
@@ -1011,13 +1025,23 @@ static unsigned int mdbg_proc_poll(struct file *filp, poll_table *wait)
 	return mask;
 }
 
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
 static const struct proc_ops mdbg_proc_fops = {
-	.proc_open		= mdbg_proc_open,
-	.proc_release	= mdbg_proc_release,
-	.proc_read		= mdbg_proc_read,
-	.proc_write		= mdbg_proc_write,
-	.proc_poll		= mdbg_proc_poll,
+	.proc_open = mdbg_proc_open,
+	.proc_release = mdbg_proc_release,
+	.proc_read = mdbg_proc_read,
+	.proc_write = mdbg_proc_write,
+	.proc_poll = mdbg_proc_poll,
 };
+#else
+static const struct file_operations mdbg_proc_fops = {
+	.open		= mdbg_proc_open,
+	.release	= mdbg_proc_release,
+	.read		= mdbg_proc_read,
+	.write		= mdbg_proc_write,
+	.poll		= mdbg_proc_poll,
+};
+#endif
 
 int mdbg_memory_alloc(void)
 {
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
index 8b19305ca192..2fd7f39888a4 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
@@ -114,7 +114,7 @@ static long int mdbg_comm_write(char *buf,
 	str = strstr(send_buf + PUB_HEAD_RSV, SMP_HEAD_STR);
 	if (!str)
 		str = strstr(send_buf + PUB_HEAD_RSV + ARMLOG_HEAD,
-			     SMP_HEAD_STR);
+				 SMP_HEAD_STR);
 
 	if (str) {
 		int ret;
@@ -160,7 +160,7 @@ static void mdbg_ring_rx_task(struct work_struct *work)
 
 	spin_lock_bh(&ring_dev->rw_lock);
 	rx = list_first_entry_or_null(&ring_dev->rx_head,
-				      struct ring_rx_data, entry);
+					  struct ring_rx_data, entry);
 	if (rx) {
 		list_del(&rx->entry);
 	} else {
@@ -188,7 +188,7 @@ static void mdbg_ring_rx_task(struct work_struct *work)
 #endif
 	}
 	sprdwcn_bus_push_list(mdbg_ringc_ops.channel,
-			      rx->head, rx->tail, rx->num);
+				  rx->head, rx->tail, rx->num);
 	wake_up_log_wait();
 	kfree(rx);
 }
@@ -226,9 +226,10 @@ long int mdbg_send(char *buf, long int len, unsigned int subtype)
 	long int sent_size = 0;
 
 	WCN_DEBUG("BYTE MODE");
-	__pm_stay_awake(ring_dev->rw_ws);
+
+	__pm_stay_awake(ring_dev->rw_wake_lock);
 	sent_size = mdbg_comm_write(buf, len, subtype);
-	__pm_relax(ring_dev->rw_ws);
+	__pm_relax(ring_dev->rw_wake_lock);
 
 	return sent_size;
 }
@@ -240,7 +241,7 @@ long int mdbg_receive(void *buf, long int len)
 }
 
 int mdbg_tx_cb(int channel, struct mbuf_t *head,
-	       struct mbuf_t *tail, int num)
+		   struct mbuf_t *tail, int num)
 {
 #ifndef CONFIG_WCN_PCIE
 	struct mbuf_t *mbuf_node;
@@ -301,8 +302,10 @@ int mdbg_ring_init(void)
 		return -MDBG_ERR_MALLOC_FAIL;
 	}
 
-	ring_dev->rw_ws = wakeup_source_create("mdbg_wake_lock");
-	wakeup_source_add(ring_dev->rw_ws);
+	/*wakeup_source pointer*/
+	ring_dev->rw_wake_lock = wakeup_source_create("mdbg_wake_lock");
+	wakeup_source_add(ring_dev->rw_wake_lock);
+
 	spin_lock_init(&ring_dev->rw_lock);
 	mutex_init(&ring_dev->mdbg_read_mutex);
 	INIT_LIST_HEAD(&ring_dev->rx_head);
@@ -328,8 +331,11 @@ void mdbg_ring_remove(void)
 		kfree(pos);
 	}
 	mutex_destroy(&ring_dev->mdbg_read_mutex);
-	wakeup_source_remove(ring_dev->rw_ws);
-	wakeup_source_destroy(ring_dev->rw_ws);
+
+	/*wakeup_source pointer*/
+	wakeup_source_remove(ring_dev->rw_wake_lock);
+	wakeup_source_destroy(ring_dev->rw_wake_lock);
+
 	mdbg_ring_destroy(ring_dev->ring);
 	mdbg_dev->ring_dev = NULL;
 	kfree(ring_dev);
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
index 9e74b7176ae0..3e1dc9f42258 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
@@ -18,8 +18,6 @@
 #include <linux/types.h>
 #include <linux/version.h>
 #include <linux/wait.h>
-#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
-#endif
 
 #include "mdbg_type.h"
 #include <wcn_bus.h>
@@ -49,7 +47,9 @@ struct ring_rx_data {
 
 struct ring_device {
 	struct mdbg_ring_t	*ring;
-	struct wakeup_source	*rw_ws;
+	/*wakeup_source pointer*/
+	struct wakeup_source	*rw_wake_lock;
+
 	spinlock_t		rw_lock;
 	struct mutex mdbg_read_mutex;
 	struct list_head	rx_head;
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
index 55eda732610b..c26bfb3251b4 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
@@ -15,7 +15,7 @@
 #endif
 
 #include <linux/version.h>
-#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
 #include <uapi/linux/sched/types.h>
 #else
 #include <linux/sched.h>
@@ -62,7 +62,7 @@ extern long int sdiohal_log_level;
 	} while (0)
 #define sdiohal_pr_perf(fmt, args...) \
 	do { if (sdiohal_log_level & SDIOHAL_PERF_LEVEL) \
-		pr_info(fmt, ## args); \
+		trace_printk(fmt, ## args); \
 	} while (0)
 #else
 #define sdiohal_normal(fmt, args...)
@@ -301,8 +301,10 @@ struct sdiohal_data_t {
 	struct task_struct *rx_thread;
 	struct completion tx_completed;
 	struct completion rx_completed;
+	/*wakeup_source pointer*/
 	struct wakeup_source *tx_ws;
 	struct wakeup_source *rx_ws;
+
 	atomic_t tx_wake_flag;
 	atomic_t rx_wake_flag;
 #ifdef CONFIG_WCN_SLP
@@ -369,7 +371,9 @@ struct sdiohal_data_t {
 	struct timespec tm_begin_irq;
 	struct timespec tm_end_irq;
 
+	/*wakeup_source pointer*/
 	struct wakeup_source *scan_ws;
+
 	struct completion scan_done;
 	struct completion remove_done;
 	unsigned int sdio_int_reg;
@@ -456,7 +460,7 @@ struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num);
 struct sdiohal_list_t *sdiohal_get_rx_mbuf_node(int num);
 int sdiohal_rx_list_dispatch(void);
 struct sdiohal_list_t *sdiohal_get_rx_channel_list(int channel);
-void *sdiohal_get_rx_free_buf(unsigned int *alloc_size);
+void *sdiohal_get_rx_free_buf(unsigned int *alloc_size, unsigned int read_len);
 void sdiohal_tx_init_retrybuf(void);
 int sdiohal_misc_init(void);
 void sdiohal_misc_deinit(void);
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
index 8896272a950f..8dbf21437b57 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
@@ -3,7 +3,7 @@
 #include "sdiohal.h"
 
 void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
-			     const char *func, int loglevel)
+				 const char *func, int loglevel)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 	struct mbuf_t *node;
@@ -13,7 +13,7 @@ void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
 
 	if (!data_list || !data_list->mbuf_head) {
 		sdiohal_err("%s, data_list:%p,data_list->mbuf_head:%p",
-			    __func__, data_list, data_list->mbuf_head);
+				__func__, data_list, data_list->mbuf_head);
 		WARN_ON(1);
 		return;
 	}
@@ -25,11 +25,11 @@ void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
 			break;
 		print_len = node->len + SDIO_PUB_HEADER_SIZE;
 		if ((channel == p_data->printlog_txchn) ||
-		    (channel == p_data->printlog_rxchn)) {
+			(channel == p_data->printlog_rxchn)) {
 			print_hex_dump(KERN_WARNING, print_str,
-				       DUMP_PREFIX_NONE, 16, 1, node->buf,
-				       (print_len < SDIOHAL_PRINTF_LEN ?
-				       print_len : SDIOHAL_PRINTF_LEN), true);
+					   DUMP_PREFIX_NONE, 16, 1, node->buf,
+					   (print_len < SDIOHAL_PRINTF_LEN ?
+					   print_len : SDIOHAL_PRINTF_LEN), true);
 		} else {
 			sdiohal_pr_data(KERN_WARNING, print_str,
 					DUMP_PREFIX_NONE, 16, 1, node->buf,
@@ -41,8 +41,8 @@ void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
 }
 
 void sdiohal_print_mbuf_data(int channel, struct mbuf_t *head,
-			     struct mbuf_t *tail, int num, const char *func,
-			     int loglevel)
+				 struct mbuf_t *tail, int num, const char *func,
+				 int loglevel)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 	struct mbuf_t *node;
@@ -63,11 +63,11 @@ void sdiohal_print_mbuf_data(int channel, struct mbuf_t *head,
 			break;
 		print_len = node->len + SDIO_PUB_HEADER_SIZE;
 		if ((channel == p_data->printlog_txchn) ||
-		    (channel == p_data->printlog_rxchn)) {
+			(channel == p_data->printlog_rxchn)) {
 			print_hex_dump(KERN_WARNING, print_str,
-				       DUMP_PREFIX_NONE, 16, 1, node->buf,
-				       (print_len < SDIOHAL_PRINTF_LEN ?
-				       print_len : SDIOHAL_PRINTF_LEN), true);
+					   DUMP_PREFIX_NONE, 16, 1, node->buf,
+					   (print_len < SDIOHAL_PRINTF_LEN ?
+					   print_len : SDIOHAL_PRINTF_LEN), true);
 		} else {
 			sdiohal_pr_data(KERN_WARNING, print_str,
 					DUMP_PREFIX_NONE, 16, 1, node->buf,
@@ -107,8 +107,8 @@ void sdiohal_list_check(struct sdiohal_list_t *data_list,
 }
 
 void sdiohal_mbuf_list_check(int channel, struct mbuf_t *head,
-			     struct mbuf_t *tail, int num,
-			     const char *func, bool dir, int loglevel)
+				 struct mbuf_t *tail, int num,
+				 const char *func, bool dir, int loglevel)
 {
 	struct mbuf_t *node;
 	int i;
@@ -242,38 +242,36 @@ void sdiohal_unlock_rx_ws(void)
 void sdiohal_lock_scan_ws(void)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
-
 	__pm_stay_awake(p_data->scan_ws);
 }
 
 void sdiohal_unlock_scan_ws(void)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
-
 	__pm_relax(p_data->scan_ws);
 }
 
 void sdiohal_wakelock_init(void)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
-
+	/*wakeup_source pointer*/
 	p_data->tx_ws = wakeup_source_create("sdiohal_tx_wakelock");
-	p_data->rx_ws = wakeup_source_create("sdiohal_rx_wakelock");
-	p_data->scan_ws = wakeup_source_create("sdiohal_scan_wakelock");
 	wakeup_source_add(p_data->tx_ws);
+	p_data->rx_ws = wakeup_source_create("sdiohal_rx_wakelock");
 	wakeup_source_add(p_data->rx_ws);
+	p_data->scan_ws = wakeup_source_create("sdiohal_scan_wakelock");
 	wakeup_source_add(p_data->scan_ws);
 }
 
 void sdiohal_wakelock_deinit(void)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
-
+	/*wakeup_source pointer*/
 	wakeup_source_remove(p_data->tx_ws);
-	wakeup_source_remove(p_data->rx_ws);
-	wakeup_source_remove(p_data->scan_ws);
 	wakeup_source_destroy(p_data->tx_ws);
+	wakeup_source_remove(p_data->rx_ws);
 	wakeup_source_destroy(p_data->rx_ws);
+	wakeup_source_remove(p_data->scan_ws);
 	wakeup_source_destroy(p_data->scan_ws);
 }
 
@@ -323,8 +321,8 @@ void sdiohal_cp_tx_sleep(enum slp_subsys subsys)
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 
 	sdiohal_debug("%s subsys:%d count:%d\n",
-		      __func__, subsys,
-		      atomic_read(&p_data->tx_wake_cp_count[subsys]));
+			  __func__, subsys,
+			  atomic_read(&p_data->tx_wake_cp_count[subsys]));
 
 	sdiohal_atomic_sub(1, &p_data->tx_wake_cp_count[subsys]);
 	if (atomic_read(&p_data->tx_wake_cp_count[subsys]))
@@ -338,8 +336,8 @@ void sdiohal_cp_tx_wakeup(enum slp_subsys subsys)
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 
 	sdiohal_debug("%s subsys:%d count:%d\n",
-		      __func__, subsys,
-		      atomic_read(&p_data->tx_wake_cp_count[subsys]));
+			  __func__, subsys,
+			  atomic_read(&p_data->tx_wake_cp_count[subsys]));
 
 	sdiohal_atomic_add(1, &p_data->tx_wake_cp_count[subsys]);
 	slp_mgr_drv_sleep(subsys, false);
@@ -351,8 +349,8 @@ void sdiohal_cp_rx_sleep(enum slp_subsys subsys)
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 
 	sdiohal_debug("%s subsys:%d count:%d\n",
-		      __func__, subsys,
-		      atomic_read(&p_data->rx_wake_cp_count[subsys]));
+			  __func__, subsys,
+			  atomic_read(&p_data->rx_wake_cp_count[subsys]));
 
 	sdiohal_atomic_sub(1, &p_data->rx_wake_cp_count[subsys]);
 	if (atomic_read(&p_data->rx_wake_cp_count[subsys]))
@@ -366,8 +364,8 @@ void sdiohal_cp_rx_wakeup(enum slp_subsys subsys)
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 
 	sdiohal_debug("%s subsys:%d count:%d\n",
-		      __func__, subsys,
-		      atomic_read(&p_data->rx_wake_cp_count[subsys]));
+			  __func__, subsys,
+			  atomic_read(&p_data->rx_wake_cp_count[subsys]));
 
 	sdiohal_atomic_add(1, &p_data->rx_wake_cp_count[subsys]);
 	slp_mgr_drv_sleep(subsys, false);
@@ -488,14 +486,14 @@ bool sdiohal_is_tx_list_empty(void)
 }
 
 int sdiohal_tx_packer(struct sdiohal_sendbuf_t *send_buf,
-		      struct sdiohal_list_t *data_list,
-		      struct mbuf_t *mbuf_node)
+			  struct sdiohal_list_t *data_list,
+			  struct mbuf_t *mbuf_node)
 {
 	if ((!send_buf) || (!data_list) || (!mbuf_node))
 		return -EINVAL;
 
 	memcpy(send_buf->buf + send_buf->used_len,
-	       mbuf_node->buf, mbuf_node->len + sizeof(struct sdio_puh_t));
+		   mbuf_node->buf, mbuf_node->len + sizeof(struct sdio_puh_t));
 
 	send_buf->used_len += sizeof(struct sdio_puh_t) +
 		SDIOHAL_ALIGN_4BYTE(mbuf_node->len);
@@ -510,14 +508,14 @@ int sdiohal_tx_set_eof(struct sdiohal_sendbuf_t *send_buf,
 		return -EINVAL;
 
 	memcpy((void *)(send_buf->buf + send_buf->used_len),
-	       (void *)eof_buf, sizeof(struct sdio_puh_t));
+		   (void *)eof_buf, sizeof(struct sdio_puh_t));
 	send_buf->used_len += sizeof(struct sdio_puh_t);
 
 	return 0;
 }
 
 static int sdiohal_tx_fill_puh(int channel, struct mbuf_t *head,
-			       struct mbuf_t *tail, int num)
+				   struct mbuf_t *tail, int num)
 {
 	struct sdio_puh_t *puh = NULL;
 	struct mbuf_t *mbuf_node;
@@ -531,7 +529,7 @@ static int sdiohal_tx_fill_puh(int channel, struct mbuf_t *head,
 	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
 		if (!mbuf_node) {
 			sdiohal_err("%s tx fill puh, mbuf ptr error:%p\n",
-				    __func__, mbuf_node);
+					__func__, mbuf_node);
 
 			return -EFAULT;
 		}
@@ -612,7 +610,7 @@ static int sdiohal_tx_pop_assignment(struct sdiohal_list_t *data_list)
 		mbuf_node = mbuf_next;
 		if (!mbuf_node) {
 			sdiohal_err("%s tx pop mbuf ptr error:%p\n",
-				    __func__, mbuf_node);
+					__func__, mbuf_node);
 
 			return -EFAULT;
 		}
@@ -622,7 +620,7 @@ static int sdiohal_tx_pop_assignment(struct sdiohal_list_t *data_list)
 			puh->type, puh->subtype);
 		if (channel >= SDIO_CHN_TX_NUM) {
 			sdiohal_err("%s tx pop channel error:%d\n",
-				    __func__, channel);
+					__func__, channel);
 			continue;
 		}
 
@@ -666,12 +664,12 @@ int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list)
 
 		sdiohal_list_check(tx_list, __func__, SDIOHAL_WRITE);
 		channel = sdiohal_hwtype_to_channel(inout, tx_list->type,
-						    tx_list->subtype);
+							tx_list->subtype);
 		sdiohal_print_list_data(channel, tx_list, __func__,
 					SDIOHAL_NORMAL_LEVEL);
 		if (channel >= SDIO_CHN_TX_NUM) {
 			sdiohal_err("%s tx pop channel error:%d\n",
-				    __func__, channel);
+					__func__, channel);
 			continue;
 		}
 
@@ -690,11 +688,11 @@ int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list)
 			p_data->chntx_denq_old.time =
 				p_data->chntx_denq_new.time;
 			memcpy(p_data->chntx_denq_old.data_bk,
-			       p_data->chntx_denq_new.data_bk,
-			       SDIOHAL_PRINTF_LEN);
+				   p_data->chntx_denq_new.data_bk,
+				   SDIOHAL_PRINTF_LEN);
 			memcpy(p_data->chntx_denq_new.data_bk,
-			       tx_list->mbuf_tail->buf,
-			       SDIOHAL_PRINTF_LEN);
+				   tx_list->mbuf_tail->buf,
+				   SDIOHAL_PRINTF_LEN);
 			p_data->chntx_denq_new.time =
 				(unsigned int)ktime_to_ms(ktime_get());
 		}
@@ -702,11 +700,11 @@ int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list)
 
 		if (sdiohal_ops && sdiohal_ops->pop_link) {
 			sdiohal_ops->pop_link(channel, tx_list->mbuf_head,
-					      tx_list->mbuf_tail,
-					      tx_list->node_num);
+						  tx_list->mbuf_tail,
+						  tx_list->node_num);
 		} else
 			sdiohal_err("%s no tx ops channel:%d\n",
-				    __func__, channel);
+					__func__, channel);
 
 		tx_list->node_num = 0;
 		sdiohal_callback_unlock(&chn_callback[channel]);
@@ -751,12 +749,12 @@ int sdiohal_rx_list_dispatch(void)
 
 		sdiohal_list_check(rx_list, __func__, SDIOHAL_READ);
 		channel = sdiohal_hwtype_to_channel(inout, rx_list->type,
-						    rx_list->subtype);
+							rx_list->subtype);
 		sdiohal_print_list_data(channel, rx_list, __func__,
 					SDIOHAL_NORMAL_LEVEL);
 		if (channel >= SDIO_CHANNEL_NUM) {
 			sdiohal_err("%s rx pop channel error:%d\n",
-				    __func__, channel);
+					__func__, channel);
 			continue;
 		}
 
@@ -772,16 +770,16 @@ int sdiohal_rx_list_dispatch(void)
 
 #if SDIO_DUMP_CHANNEL_DATA
 		if ((channel == SDIO_DUMP_RX_CHANNEL_NUM) &&
-		    (rx_list->mbuf_tail->buf[SDIO_PUB_HEADER_SIZE + 1] <
-		     SDIO_DUMP_RX_WIFI_EVENT_MIN)) {
+			(rx_list->mbuf_tail->buf[SDIO_PUB_HEADER_SIZE + 1] <
+			 SDIO_DUMP_RX_WIFI_EVENT_MIN)) {
 			p_data->chnrx_dispatch_old.time =
 				p_data->chnrx_dispatch_new.time;
 			memcpy(p_data->chnrx_dispatch_old.data_bk,
-			       p_data->chnrx_dispatch_new.data_bk,
-			       SDIOHAL_PRINTF_LEN);
+				   p_data->chnrx_dispatch_new.data_bk,
+				   SDIOHAL_PRINTF_LEN);
 			memcpy(p_data->chnrx_dispatch_new.data_bk,
-			       rx_list->mbuf_tail->buf,
-			       SDIOHAL_PRINTF_LEN);
+				   rx_list->mbuf_tail->buf,
+				   SDIOHAL_PRINTF_LEN);
 			p_data->chnrx_dispatch_new.time =
 				(unsigned int)ktime_to_ms(ktime_get());
 		}
@@ -789,14 +787,14 @@ int sdiohal_rx_list_dispatch(void)
 
 		if (sdiohal_ops && sdiohal_ops->pop_link) {
 			sdiohal_ops->pop_link(channel, rx_list->mbuf_head,
-					      rx_list->mbuf_tail,
-					      rx_list->node_num);
+						  rx_list->mbuf_tail,
+						  rx_list->node_num);
 		} else {
 			sdiohal_err("%s no rx ops channel:%d\n",
-				    __func__, channel);
+					__func__, channel);
 			sdiohal_rx_list_free(rx_list->mbuf_head,
-					     rx_list->mbuf_tail,
-					     rx_list->node_num);
+						 rx_list->mbuf_tail,
+						 rx_list->node_num);
 		}
 		rx_list->node_num = 0;
 		sdiohal_callback_unlock(&chn_callback[channel]);
@@ -914,24 +912,33 @@ static void *sdiohal_alloc_frag(unsigned int fragsz, gfp_t gfp_mask,
 #else
 		order = SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT;
 #endif
+		/*GFP_KERNEL allow sleep, so not in interrupt; sdma changed,adma not*/
+		if (gfp_mask & GFP_KERNEL)
+			local_irq_restore(flags);
 		for (; ;) {
 			gfp_t gfp = gfp_mask;
 
 			if (order)
-				gfp |= __GFP_COMP | __GFP_NOWARN;
+				gfp |= __GFP_COMP;
 			/* alloc_pages will initialize count to 1. */
 			frag_ctl->frag.page = alloc_pages(gfp, order);
 			if (likely(frag_ctl->frag.page))
 				break;
-			if (--order < 0)
-				goto fail;
+			if (--order < 0) {
+				if (gfp_mask & GFP_KERNEL)
+					goto fail1;
+				else
+					goto fail;
+			}
 		}
+		if (gfp_mask & GFP_KERNEL)
+			local_irq_save(flags);
 		frag_ctl->frag.size = PAGE_SIZE << order;
 		if (frag_ctl->frag.size < fragsz) {
 			sdiohal_info("BITS_PER_LONG=%d,PAGE_SIZE=%ld,order=%d\n",
-				     BITS_PER_LONG, PAGE_SIZE, order);
+					 BITS_PER_LONG, PAGE_SIZE, order);
 			sdiohal_info("alloc 0x%x mem, need:0x%x\n",
-				     frag_ctl->frag.size, fragsz);
+					 frag_ctl->frag.size, fragsz);
 			if (ignore_alloc_fail) {
 				/* alloc fail, not put_page, fill frag size. */
 				*alloc_size = frag_ctl->frag.size;
@@ -1001,6 +1008,7 @@ static void *sdiohal_alloc_frag(unsigned int fragsz, gfp_t gfp_mask,
 	return data;
 fail:
 	local_irq_restore(flags);
+fail1:
 	sdiohal_err("alloc mem fail\n");
 	return NULL;
 }
@@ -1020,7 +1028,7 @@ struct sdiohal_list_t *sdiohal_get_rx_mbuf_node(int num)
 
 	if (num > p_data->list_rx_buf.node_num) {
 		sdiohal_err("no rx mbuf node, need num:%d, list node num:%d\n",
-			    num, p_data->list_rx_buf.node_num);
+				num, p_data->list_rx_buf.node_num);
 		goto err;
 	}
 
@@ -1074,7 +1082,7 @@ struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num)
 			0, NULL);
 		if (!mbuf_temp->buf) {
 			sdiohal_rx_list_free(idle_list->mbuf_head,
-					     idle_list->mbuf_tail, num);
+						 idle_list->mbuf_tail, num);
 			kfree(idle_list);
 			goto err;
 		}
@@ -1090,24 +1098,26 @@ struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num)
 }
 
 /* for normal dma idle buf */
-void *sdiohal_get_rx_free_buf(unsigned int *alloc_size)
+void *sdiohal_get_rx_free_buf(unsigned int *alloc_size, unsigned int read_len)
 {
 	void *p;
 	unsigned int fragsz;
 
-#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
-	fragsz = SDIOHAL_RX_RECVBUF_LEN;
+	/* fragsz need to be 1024 aligned */
+	fragsz = roundup(read_len, 1024);
 
-#else
-	fragsz = SDIOHAL_32_BIT_RX_RECVBUF_LEN;
-#endif
+/*
+ * GFP_ATOMIC is not sleep forever, requirement is high;
+ * GFP_KERNEL is nornal way, allow sleep;
+ *__GFP_COLD
+ */
 	p = sdiohal_alloc_frag(fragsz,
 #if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
-			       GFP_ATOMIC,
+				   GFP_KERNEL,
 #else
-			       GFP_ATOMIC | __GFP_COLD,
+				   GFP_KERNEL,
 #endif
-			       1, alloc_size);
+				   1, alloc_size);
 
 	WARN_ON(((unsigned long int)p) % 64);
 
@@ -1170,7 +1180,7 @@ static void sdiohal_rx_buf_deinit(void)
 }
 
 int sdiohal_list_push(int channel, struct mbuf_t *head,
-		      struct mbuf_t *tail, int num)
+			  struct mbuf_t *tail, int num)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 	struct timespec tm_begin, tm_end;
@@ -1212,7 +1222,7 @@ int sdiohal_list_push(int channel, struct mbuf_t *head,
 	if (channel < SDIO_CHN_TX_NUM) {
 		if (!atomic_read(&p_data->flag_resume)) {
 			sdiohal_err("%s chn=%d, in suspend, can't send data\n",
-				    __func__, channel);
+					__func__, channel);
 			return -EFAULT;
 		}
 		sdiohal_print_mbuf_data(channel, head, tail, num,
@@ -1223,11 +1233,11 @@ int sdiohal_list_push(int channel, struct mbuf_t *head,
 			p_data->chntx_push_old.time =
 				p_data->chntx_push_new.time;
 			memcpy(p_data->chntx_push_old.data_bk,
-			       p_data->chntx_push_new.data_bk,
-			       SDIOHAL_PRINTF_LEN);
+				   p_data->chntx_push_new.data_bk,
+				   SDIOHAL_PRINTF_LEN);
 			memcpy(p_data->chntx_push_new.data_bk,
-			       tail->buf,
-			       SDIOHAL_PRINTF_LEN);
+				   tail->buf,
+				   SDIOHAL_PRINTF_LEN);
 			p_data->chntx_push_new.time =
 				(unsigned int)ktime_to_ms(ktime_get());
 		}
@@ -1258,7 +1268,7 @@ int sdiohal_list_push(int channel, struct mbuf_t *head,
  * not calling tx_pop callback when working in sdma mode.
  */
 int sdiohal_list_direct_write(int channel, struct mbuf_t *head,
-			      struct mbuf_t *tail, int num)
+				  struct mbuf_t *tail, int num)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 	struct sdiohal_list_t data_list;
@@ -1403,17 +1413,11 @@ static int sdiohal_dtbs_buf_init(void)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 
-	p_data->dtbs_buf = sdiohal_alloc_frag(MAX_MBUF_SIZE,
-#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
-					      GFP_ATOMIC,
-#else
-					      GFP_ATOMIC | __GFP_COLD,
-#endif
-					      0, NULL);
-	if (!p_data->dtbs_buf)
+	p_data->dtbs_buf = kzalloc(MAX_MBUF_SIZE, GFP_KERNEL);
+	if (!p_data->dtbs_buf) {
+		sdiohal_err("dtbs buf alloc fail\n");
 		return -ENOMEM;
-
-	WARN_ON(((unsigned long int)p_data->dtbs_buf) % 64);
+	}
 
 	return 0;
 }
@@ -1421,17 +1425,8 @@ static int sdiohal_dtbs_buf_init(void)
 static int sdiohal_dtbs_buf_deinit(void)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
-	int order;
-
-	if (!p_data->dtbs_buf)
-		return -ENOMEM;
 
-#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
-	order = SDIOHAL_FRAG_PAGE_MAX_ORDER;
-#else
-	order = SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT;
-#endif
-	free_pages((unsigned long)p_data->dtbs_buf, order);
+	kfree(p_data->dtbs_buf);
 	p_data->dtbs_buf = NULL;
 
 	return 0;
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
index ceb34a487e69..b426bf89cd9a 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
@@ -55,9 +55,6 @@
 #define GNSS_DUMP_WIFI_RAM_ADDR	0x40580000
 #define GNSS_DUMP_DATA_SIZE	0x38000
 
-#include <linux/module.h>
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-
 enum {
 	/* SDIO TX */
 	CHANNEL_TX_BASE = 0,
@@ -225,7 +222,7 @@ static int sdiohal_throughput_tx(void)
 static void sdiohal_throughput_tx_compute_time(void)
 {
 	static signed long long times_count;
-	struct timespec now;
+	struct timespec64 now;
 
 	if (tp_tx_flag != 1)
 		return;
@@ -554,7 +551,7 @@ int at_list_rx_pop(int channel, struct mbuf_t *head,
 		   struct mbuf_t *tail, int num)
 {
 	static signed long long times_count;
-	struct timespec now;
+	struct timespec64 now;
 
 	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
 		     __func__, channel, head, tail, num);
@@ -837,7 +834,7 @@ static ssize_t at_cmd_write(struct file *filp,
 	long int long_data;
 	int ret;
 	unsigned char *send_buf = NULL;
-	struct timespec now;
+	struct timespec64 now;
 
 	if (count > SDIOHAL_WRITE_SIZE) {
 		sdiohal_err("%s write size > %d\n",
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
index 42fb0a2b38a8..0f67a7f35c30 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
@@ -1971,7 +1971,6 @@ static int sdiohal_probe(struct sdio_func *func,
 	if (scan_card_notify != NULL)
 		scan_card_notify();
 
-	device_disable_async_suspend(&func->dev);
 	sdiohal_debug("rescan callback:%p\n", scan_card_notify);
 	sdiohal_info("probe ok\n");
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
index 287d17c959db..2a64dac7af55 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
@@ -99,8 +99,8 @@ static int sdiohal_rx_list_parser(struct sdiohal_list_t *data_list,
 				(puh->len == 0)) {
 				sdiohal_rx_list_free(mbuf_node, mbuf_node, 1);
 				sdiohal_err("%s skip type[%d]sub[%d]len[%d]\n",
-					    __func__, puh->type, puh->subtype,
-					    puh->len);
+						__func__, puh->type, puh->subtype,
+						puh->len);
 				continue;
 			}
 			p_data->rx_packer_cnt++;
@@ -108,11 +108,11 @@ static int sdiohal_rx_list_parser(struct sdiohal_list_t *data_list,
 			sdiohal_data_list_assignment(mbuf_node, puh, channel);
 		} else {
 			sdiohal_debug("%s eof pac:%d,parse[%d]%s valid[%d]\n",
-				      __func__, puh->eof, parse_len,
-				      (parse_len < valid_len ? "<":">="),
-				      valid_len);
+					  __func__, puh->eof, parse_len,
+					  (parse_len < valid_len ? "<":">="),
+					  valid_len);
 			sdiohal_debug("%s type[%d]sub[%d]len[%d]\n", __func__,
-				      puh->type, puh->subtype, puh->len);
+					  puh->type, puh->subtype, puh->len);
 
 			sdiohal_rx_list_free(mbuf_node, mbuf_node, 1);
 		}
@@ -147,8 +147,8 @@ static int sdiohal_rx_buf_parser(char *data_buf, int valid_len)
 				(MAX_PAC_SIZE - SDIO_PUB_HEADER_SIZE)) ||
 				(puh->len == 0)) {
 				sdiohal_err("%s skip type[%d]sub[%d]len[%d]\n",
-					    __func__, puh->type, puh->subtype,
-					    puh->len);
+						__func__, puh->type, puh->subtype,
+						puh->len);
 				continue;
 			}
 			p_data->rx_packer_cnt++;
@@ -167,7 +167,7 @@ static int sdiohal_rx_buf_parser(char *data_buf, int valid_len)
 						SDIOHAL_DATA_LEVEL);
 
 			sdiohal_data_list_assignment(data_list->mbuf_head,
-						     puh, channel);
+							 puh, channel);
 			kfree(data_list);
 		}
 		/* pointer to next packet */
@@ -219,7 +219,7 @@ int sdiohal_rx_thread(void *data)
 			break;
 		if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
 			sdiohal_err("%s line %d not have card\n",
-				    __func__, __LINE__);
+					__func__, __LINE__);
 			continue;
 		}
 
@@ -238,8 +238,8 @@ int sdiohal_rx_thread(void *data)
 			/* read len is packet num */
 			mbuf_num = sdiohal_rx_adapt_get_pac_num();
 			sdiohal_debug("%s mbuf_num:%d adma_rx_enable:%d\n",
-				      __func__, mbuf_num,
-				      p_data->adma_rx_enable);
+					  __func__, mbuf_num,
+					  p_data->adma_rx_enable);
 
 			data_list = sdiohal_get_rx_mbuf_list(mbuf_num);
 			if (!data_list) {
@@ -249,20 +249,27 @@ int sdiohal_rx_thread(void *data)
 			}
 			if (p_data->irq_type == SDIOHAL_RX_POLLING)
 				memset(p_data->dtbs_buf, 0x0,
-				       SDIOHAL_DTBS_BUF_SIZE);
+					   SDIOHAL_DTBS_BUF_SIZE);
 			ret = sdiohal_adma_pt_read(data_list);
 			if (ret != 0) {
 				sdiohal_err("adma read fail ret:%d\n", ret);
 				rx_dtbs = 0;
-				if (p_data->irq_type != SDIOHAL_RX_POLLING)
+				if (p_data->irq_type != SDIOHAL_RX_POLLING) {
+					sdiohal_rx_list_free(
+							data_list->mbuf_head,
+							data_list->mbuf_tail,
+							data_list->node_num);
+					kfree(data_list);
+					data_list = NULL;
 					goto submit_list;
+				}
 			}
 			rx_dtbs =  *((unsigned int *)(p_data->dtbs_buf
 				   + (SDIOHAL_DTBS_BUF_SIZE - 4)));
 			valid_len = *((unsigned int *)(p_data->dtbs_buf
-				    + (SDIOHAL_DTBS_BUF_SIZE - 8)));
+					+ (SDIOHAL_DTBS_BUF_SIZE - 8)));
 			sdiohal_debug("%s rx_pac_num:%d, valid len:%d\n",
-				      __func__, rx_dtbs, valid_len);
+					  __func__, rx_dtbs, valid_len);
 			sdiohal_rx_list_parser(data_list, valid_len);
 			kfree(data_list);
 			data_list = NULL;
@@ -272,20 +279,21 @@ int sdiohal_rx_thread(void *data)
 			/* read len is packet data len */
 			read_len = sdiohal_rx_adapt_get();
 			sdiohal_debug("%s read_len:%d adma_rx_enable:%d\n",
-				      __func__, read_len,
-				      p_data->adma_rx_enable);
+					  __func__, read_len,
+					  p_data->adma_rx_enable);
 
-			rx_buf = sdiohal_get_rx_free_buf(&alloc_size);
+			/*get buf by readlen 1024 aligned */
+			rx_buf = sdiohal_get_rx_free_buf(&alloc_size, read_len);
 			if (!rx_buf) {
 				sdiohal_err("get_rx_free_buf fail, rlen=%d\n",
-					    read_len);
+						read_len);
 				msleep(100);
 				goto submit_list;
 			}
 			if (alloc_size < read_len) {
 				read_len = alloc_size;
 				sdiohal_debug("alloc_size=%d < read_len=%d\n",
-					      alloc_size, read_len);
+						  alloc_size, read_len);
 			}
 
 			ret = sdiohal_sdio_pt_read(rx_buf, read_len);
@@ -299,7 +307,7 @@ int sdiohal_rx_thread(void *data)
 			valid_len =
 				*((unsigned int *)(rx_buf + (read_len - 8)));
 			sdiohal_debug("%s rx_dtbs:%d,valid len:%d\n",
-				      __func__, rx_dtbs, valid_len);
+					  __func__, rx_dtbs, valid_len);
 			sdiohal_rx_buf_parser(rx_buf, valid_len);
 		}
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
index 540a589770b4..c0790f6cdd13 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
@@ -33,8 +33,8 @@ static void sdiohal_tx_retrybuf_left(unsigned int suc_pac_cnt)
 	}
 
 	sdiohal_debug("sdiohal_tx_retrybuf_left [%p] retry_len[%d]\n",
-		      p_data->send_buf.retry_buf,
-		      p_data->send_buf.retry_len);
+			  p_data->send_buf.retry_buf,
+			  p_data->send_buf.retry_len);
 }
 
 static int sdiohal_send_try(struct sdiohal_sendbuf_t *send_buf)
@@ -87,7 +87,7 @@ static int sdiohal_send(struct sdiohal_sendbuf_t *send_buf,
 }
 
 int sdiohal_tx_data_list_send(struct sdiohal_list_t *data_list,
-			      bool pop_flag)
+				  bool pop_flag)
 {
 	struct sdiohal_data_t *p_data = sdiohal_get_data();
 	struct mbuf_t *mbuf_node;
@@ -150,7 +150,7 @@ int sdiohal_tx_thread(void *data)
 			break;
 		if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
 			sdiohal_err("%s line %d not have card\n",
-				    __func__, __LINE__);
+					__func__, __LINE__);
 			continue;
 		}
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
index 6a14855a91e7..f3dec551e97e 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
@@ -58,7 +58,7 @@ void sdio_wait_pub_int_done(void)
 
 		/* wait pub_int handle finish*/
 		while ((atomic_read(&flag_pub_int_done) == 0) &&
-		       (wait_cnt < 10)) {
+			   (wait_cnt < 10)) {
 			wait_cnt++;
 			SLP_MGR_INFO("wait pub_int_done:%d", wait_cnt);
 			usleep_range(1500, 3000);
@@ -104,7 +104,7 @@ int pub_int_handle_thread(void *data)
 		if (sdio_power_notify)
 			atomic_set(&flag_pub_int_done, 1);
 		else {
-			__pm_relax(sdio_int.pub_int_ws);
+			__pm_relax((sdio_int.pub_int_ws));
 		}
 
 		/* enable interrupt, balance with disable in pub_int_isr */
@@ -127,7 +127,7 @@ static irqreturn_t pub_int_isr(int irq, void *para)
 	if (sdio_power_notify)
 		atomic_set(&flag_pub_int_done, 0);
 	else {
-		__pm_stay_awake(sdio_int.pub_int_ws);
+		__pm_stay_awake((sdio_int.pub_int_ws));
 	}
 
 	irq_cnt++;
@@ -314,8 +314,11 @@ int sdio_pub_int_init(int irq)
 	sdio_int.pub_int_sts0 = REG_PUB_INT_STS0;
 
 	atomic_set(&flag_pub_int_done, 1);
+
+	/*wakeup_source pointer*/
 	sdio_int.pub_int_ws = wakeup_source_create("pub_int_ws");
 	wakeup_source_add(sdio_int.pub_int_ws);
+
 	init_completion(&(sdio_int.pub_int_completion));
 
 	sdio_pub_int_register(irq);
@@ -344,6 +347,8 @@ int sdio_pub_int_deinit(void)
 	sdio_power_notify = FALSE;
 	disable_irq(sdio_int.pub_int_num);
 	free_irq(sdio_int.pub_int_num, NULL);
+
+	/*wakeup_source pointer*/
 	wakeup_source_remove(sdio_int.pub_int_ws);
 	wakeup_source_destroy(sdio_int.pub_int_ws);
 
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
index b4ed05fd5efa..2a1bbf24864f 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
@@ -2,8 +2,6 @@
 #define __SDIO_INT_H__
 #include <linux/device.h>
 #include <linux/version.h>
-#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
-#endif
 
 #define SLP_MGR_HEADER "[slp_mgr]"
 
@@ -104,7 +102,9 @@ struct sdio_int_t {
 	unsigned int pub_int_clr0;
 	unsigned int pub_int_sts0;
 	PUB_INT_ISR pub_int_cb[PUB_INT_MAX];
+	/*wakeup_source pointer*/
 	struct wakeup_source *pub_int_ws;
+
 	struct completion pub_int_completion;
 	unsigned int pub_int_num;
 	/* 1: power on, 0: power off */
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
index 3c173c260444..65f37abc4399 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
@@ -29,6 +29,7 @@
 #include <linux/platform_device.h>
 #include <linux/spinlock.h>
 #include <linux/version.h>
+//#include <linux/wakelock.h>
 #include <wcn_bus.h>
 #include "../sdio/sdiohal.h"
 #include "slp_mgr.h"
@@ -73,11 +74,10 @@ int slp_mgr_wakeup(enum slp_subsys subsys)
 #if KERNEL_VERSION(3, 16, 75) > LINUX_VERSION_CODE
 	ktime_t time_cmp;
 #endif
-
 	mutex_lock(&(slp_mgr.wakeup_lock));
 	if (STAY_SLPING == (atomic_read(&(slp_mgr.cp2_state)))) {
 		ap_wakeup_cp();
-		time_end = ktime_add_ms(ktime_get(), 10);
+		time_end = ktime_add_ms(ktime_get(), 30);
 #ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
 #ifdef CONFIG_UWE5623
 		/*select btwf_slp_status*/
@@ -111,7 +111,7 @@ int slp_mgr_wakeup(enum slp_subsys subsys)
 				unsigned int reg_val = 0;
 
 				sprdwcn_bus_reg_read(CP_WAKE_STATUS,
-						     &reg_val, 4);
+							 &reg_val, 4);
 				if ((reg_val & BIT(31)) == 0)
 #endif
 					break;
@@ -130,7 +130,7 @@ int slp_mgr_wakeup(enum slp_subsys subsys)
 					unsigned int reg_val = 0;
 
 					sprdwcn_bus_reg_read(CP_WAKE_STATUS,
-							     &reg_val, 4);
+								 &reg_val, 4);
 					if ((reg_val & BIT(31)) == 0)
 						break;
 				} else
@@ -142,7 +142,7 @@ int slp_mgr_wakeup(enum slp_subsys subsys)
 			if (do_dump) {
 				atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
 				SLP_MGR_INFO("wakeup fail, slp_sts-0x%x",
-					     slp_sts);
+						 slp_sts);
 				sdiohal_dump_aon_reg();
 				mutex_unlock(&(slp_mgr.wakeup_lock));
 				return -1;
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c b/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
index 0277de66659e..231718d77364 100644
--- a/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
+++ b/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
@@ -17,8 +17,6 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
-#include <linux/io.h>
-
 #include <wcn_bus.h>
 
 struct buffer_pool_t {
@@ -82,7 +80,7 @@ static int buf_pool_check(struct buffer_pool_t *pool)
 	struct mbuf_t *mbuf;
 
 	for (i = 0, mbuf = pool->head;
-	     i < pool->free; i++, mbuf = mbuf->next) {
+		 i < pool->free; i++, mbuf = mbuf->next) {
 		WARN_ON(!mbuf);
 		WARN_ON((char *)mbuf < pool->mem ||
 			(char *)mbuf > pool->mem + ((sizeof(struct mbuf_t)
@@ -106,13 +104,13 @@ static int buf_pool_init(struct buffer_pool_t *pool, int size, int payload)
 	pool->payload = payload;
 	spin_lock_init(&(pool->lock));
 	pool->mem = kzalloc((sizeof(struct mbuf_t) + payload) * size,
-			    GFP_KERNEL);
+				GFP_KERNEL);
 	if (!pool->mem)
 		return -ENOMEM;
 
 	pool->head = (struct mbuf_t *) (pool->mem);
 	for (i = 0, mbuf = (struct mbuf_t *)(pool->head);
-	     i < (size - 1); i++) {
+		 i < (size - 1); i++) {
 		mbuf->seq = i;
 		next = (struct mbuf_t *)((char *)mbuf +
 			sizeof(struct mbuf_t) + payload);
@@ -133,7 +131,7 @@ static int buf_pool_init(struct buffer_pool_t *pool, int size, int payload)
 static int buf_pool_deinit(struct buffer_pool_t *pool)
 {
 	memset(pool->mem, 0x00,
-	       (sizeof(struct mbuf_t) + pool->payload) * pool->size);
+		   (sizeof(struct mbuf_t) + pool->payload) * pool->size);
 	kfree(pool->mem);
 	pool->mem = NULL;
 
@@ -244,7 +242,7 @@ int bus_chn_init(struct mchn_ops_t *ops, int hif_type)
 	chn_inf->ops[ops->channel] = ops;
 	if (ops->pool_size > 0)
 		ret = buf_pool_init(&(chn_inf->pool[ops->channel]),
-				    ops->pool_size, 0);
+					ops->pool_size, 0);
 	mutex_unlock(&chn_inf->callback_lock[ops->channel]);
 
 	/* pr_info("[-]%s(%d)\n", __func__, ops->channel); */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/Kconfig b/drivers/net/wireless/uwe5622/unisocwifi/Kconfig
index 060c584f5da3..fce21d35d06c 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/Kconfig
+++ b/drivers/net/wireless/uwe5622/unisocwifi/Kconfig
@@ -1,3 +1,8 @@
+config WLAN_UWE5621
+	tristate "UWE5621 Wi-Fi Driver"
+	help
+	  Sprd UWE5621 Wi-Fi Driver.
+
 config WLAN_UWE5622
 	tristate "UWE5622 Wi-Fi Driver"
 	help
@@ -15,5 +20,5 @@ config UNISOC_WIFI_PS
 	bool "Unisoc Wi-Fi Power Save Support"
 	depends on WLAN_UWE5622
         help
-          Spard UWE5622 Wi-Fi Driver Power Save.
+          Sprd UWE5622 Wi-Fi Driver Power Save.
 
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/Makefile b/drivers/net/wireless/uwe5622/unisocwifi/Makefile
index 966e74eeeb2c..f9047ecd5a37 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/Makefile
+++ b/drivers/net/wireless/uwe5622/unisocwifi/Makefile
@@ -1,8 +1,6 @@
 PWD := $(shell pwd)
 all_dependencies := driver
 
-ccflags-y += -I$(src)/../unisocwcn/include
-ccflags-$(ORIGIN_BSP) += -I$(srctree)/../hardware/wifi/unisoc/drivers/unisocwcn/include
 
 ifneq ($(UNISOC_BSP_INCLUDE),)
 ccflags-y += -I$(UNISOC_BSP_INCLUDE)
@@ -16,7 +14,14 @@ ifneq ($(UNISOC_WIFI_MAC_FILE),)
 ccflags-y += -DCUSTOMIZE_WIFI_MAC_FILE=\"$(UNISOC_WIFI_MAC_FILE)\"
 endif
 
+ifneq ($(UNISOC_MODULE_NAME),)
+MODULE_NAME := $(UNISOC_MODULE_NAME)
+else
+MODULE_NAME := sprdwl_ng
+endif
+
 ####add cflag######
+ccflags-y += -DUWE5621_FTR
 ccflags-y += -DIBSS_SUPPORT -DIBSS_RSN_SUPPORT
 ccflags-y += -DNAN_SUPPORT
 ccflags-y += -DRTT_SUPPORT
@@ -24,34 +29,45 @@ ccflags-y += -DACS_SUPPORT -DRX_HW_CSUM
 ccflags-y += -DWMMAC_WFA_CERTIFICATION
 ccflags-y += -DCOMPAT_SAMPILE_CODE
 ccflags-y += -DRND_MAC_SUPPORT
+#ccflags-y += -DSOFTAP_HOOK
 ccflags-y += -DATCMD_ASSERT
 ccflags-y += -DTCPACK_DELAY_SUPPORT
-ccflags-$(DEBUGMODE) += -DWL_CONFIG_DEBUG
+#ccflags-y += -DDFS_MASTER
+#ccflags-y += -DRX_NAPI
+ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DWL_CONFIG_DEBUG
+endif
 ccflags-y += -DSPLIT_STACK
 ccflags-y += -DOTT_UWE
-ccflags-y += -DCP2_RESET_SUPPORT
+#ccflags-y += -DCP2_RESET_SUPPORT
 ifeq ($(UNISOC_STA_SOFTAP_SCC_MODE),y)
 ccflags-y += -DSTA_SOFTAP_SCC_MODE
 endif
 
 ccflags-$(CONFIG_UNISOC_WIFI_PS) += -DUNISOC_WIFI_PS
+ccflags-y += -DPPPOE_LLC_SUPPORT
+ccflags-y += -DSYNC_DISCONNECT
+#ccflags-y += -DSPRDWL_TX_SELF
+#ccflags-y += -DTCP_ACK_DROP_SUPPORT
+#ccflags-y += -DWOW_SUPPORT -DCONFIG_PM
+
+#####module name ###
+obj-m += $(MODULE_NAME).o
 
 #######add .o file#####
-sprdwl_ng-objs += main.o cfg80211.o txrx.o cmdevt.o npi.o msg.o work.o vendor.o \
+$(MODULE_NAME)-objs += main.o cfg80211.o txrx.o cmdevt.o npi.o msg.o work.o vendor.o \
 				  tcp_ack.o mm.o reorder.o wl_core.o tx_msg.o rx_msg.o \
 				  wl_intf.o qos.o dbg_ini_util.o reg_domain.o
-sprdwl_ng-objs += defrag.o
-sprdwl_ng-objs += ibss.o
-sprdwl_ng-objs += nan.o
-sprdwl_ng-objs += tracer.o
-sprdwl_ng-objs += rf_marlin3.o
-sprdwl_ng-objs += rtt.o
-sprdwl_ng-objs += api_version.o
-sprdwl_ng-objs += rnd_mac_addr.o
-sprdwl_ng-objs += debug.o
-#sprdwl_ng-objs += 11h.o
-
-obj-$(CONFIG_WLAN_UWE5622) += sprdwl_ng.o
+$(MODULE_NAME)-objs += defrag.o
+$(MODULE_NAME)-objs += ibss.o
+$(MODULE_NAME)-objs += nan.o
+$(MODULE_NAME)-objs += tracer.o
+$(MODULE_NAME)-objs += rf_marlin3.o
+$(MODULE_NAME)-objs += rtt.o
+$(MODULE_NAME)-objs += api_version.o
+$(MODULE_NAME)-objs += rnd_mac_addr.o
+$(MODULE_NAME)-objs += debug.o
+#$(MODULE_NAME)-objs += 11h.o
 
 all: $(all_dependencies)
 driver: $(driver_dependencies)
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/api_version.c b/drivers/net/wireless/uwe5622/unisocwifi/api_version.c
index 79f0b5706d13..91bcfee46fb8 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/api_version.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/api_version.c
@@ -407,7 +407,7 @@ void sprdwl_fill_drv_api_version(struct sprdwl_priv *priv,
 	/*fill CMD struct drv_api*/
 	drv_api->main_ver = priv->sync_api.main_drv;
 	for (count = 0; count < MAX_API &&
-	     count < sizeof(g_api_array) / sizeof(g_api_array[0]); count++) {
+		 count < sizeof(g_api_array) / sizeof(g_api_array[0]); count++) {
 		p = &g_api_array[count];
 		if (p->drv_version)
 			drv_api->api_map[count] =
@@ -439,7 +439,7 @@ void sprdwl_fill_fw_api_version(struct sprdwl_priv *priv,
 }
 
 int sprdwl_api_available_check(struct sprdwl_priv *priv,
-			       struct sprdwl_msg_buf *msg)
+				   struct sprdwl_msg_buf *msg)
 {
 	/*define tmp struct *p */
 	struct api_version_t *p = NULL;
@@ -449,7 +449,11 @@ int sprdwl_api_available_check(struct sprdwl_priv *priv,
 	u8 drv_ver = 0, fw_ver = 0;
 	u32 min_ver = 255;
 
+#if defined(UWE5621_FTR)
 	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
 	cmd_id = hdr->cmd_id;
 	if (cmd_id == WIFI_CMD_SYNC_VERSION)
 		return 0;
@@ -460,17 +464,17 @@ int sprdwl_api_available_check(struct sprdwl_priv *priv,
 	min_ver = min(drv_ver, fw_ver);
 	if (min_ver) {
 		if ((min_ver == drv_ver) ||
-		    min_ver == priv->sync_api.compat) {
+			min_ver == priv->sync_api.compat) {
 			priv->sync_api.compat = DEFAULT_COMPAT;
 			return 0;
 		} else {
 			wl_err("CMD ID:%d,drv ver:%d, fw ver:%d,compat:%d\n",
-			       cmd_id, drv_ver, fw_ver, priv->sync_api.compat);
+				   cmd_id, drv_ver, fw_ver, priv->sync_api.compat);
 			return -1;
 		}
 	} else {
 		wl_err("CMD ID:%d,drv ver:%d, fw ver:%d drop it!!\n",
-		       cmd_id, drv_ver, fw_ver);
+			   cmd_id, drv_ver, fw_ver);
 		return -1;
 	}
 }
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
index 47d60f30c2e6..490797f8fc42 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
@@ -238,38 +238,38 @@ sprdwl_mgmt_stypes[NUM_NL80211_IFTYPES] = {
 	[NL80211_IFTYPE_STATION] = {
 		.tx = 0xffff,
 		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
 	},
 	[NL80211_IFTYPE_AP] = {
 		.tx = 0xffff,
 		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
-		      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
-		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
-		      BIT(IEEE80211_STYPE_DISASSOC >> 4) |
-		      BIT(IEEE80211_STYPE_AUTH >> 4) |
-		      BIT(IEEE80211_STYPE_DEAUTH >> 4) |
-		      BIT(IEEE80211_STYPE_ACTION >> 4)
+			  BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			  BIT(IEEE80211_STYPE_AUTH >> 4) |
+			  BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			  BIT(IEEE80211_STYPE_ACTION >> 4)
 	},
 	[NL80211_IFTYPE_P2P_CLIENT] = {
 		.tx = 0xffff,
 		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
 	},
 	[NL80211_IFTYPE_P2P_GO] = {
 		.tx = 0xffff,
 		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
-		      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
-		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
-		      BIT(IEEE80211_STYPE_DISASSOC >> 4) |
-		      BIT(IEEE80211_STYPE_AUTH >> 4) |
-		      BIT(IEEE80211_STYPE_DEAUTH >> 4) |
-		      BIT(IEEE80211_STYPE_ACTION >> 4)
+			  BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			  BIT(IEEE80211_STYPE_AUTH >> 4) |
+			  BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			  BIT(IEEE80211_STYPE_ACTION >> 4)
 	},
 #ifndef CONFIG_P2P_INTF
 	[NL80211_IFTYPE_P2P_DEVICE] = {
 		.tx = 0xffff,
 		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
 	}
 #endif
 };
@@ -398,7 +398,7 @@ int sprdwl_init_fw(struct sprdwl_vif *vif)
 	u8 vif_ctx_id = 0;
 
 	wl_ndev_log(L_DBG, vif->ndev, "%s type %d, mode %d\n", __func__, type,
-		    vif->mode);
+			vif->mode);
 
 	if (vif->mode != SPRDWL_MODE_NONE) {
 		wl_ndev_log(L_ERR, vif->ndev, "%s already in use: mode %d\n",
@@ -438,8 +438,8 @@ int sprdwl_init_fw(struct sprdwl_vif *vif)
 	}
 	vif->ctx_id  = vif_ctx_id;
 	wl_ndev_log(L_DBG, vif->ndev, "%s,open success type %d, mode:%d, ctx_id:%d\n",
-		    __func__, type,
-		    vif->mode, vif->ctx_id);
+			__func__, type,
+			vif->mode, vif->ctx_id);
 	priv->fw_stat[vif->mode] = SPRDWL_INTF_OPEN;
 
 	return 0;
@@ -491,7 +491,7 @@ int sprdwl_uninit_fw(struct sprdwl_vif *vif)
 	handle_tx_status_after_close(vif);
 
 	wl_ndev_log(L_DBG, vif->ndev, "%s type %d, mode %d\n", __func__,
-		    vif->wdev.iftype, vif->mode);
+			vif->wdev.iftype, vif->mode);
 	vif->mode = SPRDWL_MODE_NONE;
 
 	return 0;
@@ -514,15 +514,15 @@ int sprdwl_check_p2p_coex(struct sprdwl_priv *priv)
 
 #ifndef CONFIG_P2P_INTF
 static struct wireless_dev *sprdwl_cfg80211_add_iface(struct wiphy *wiphy,
-						      const char *name,
+							  const char *name,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
 							  unsigned char name_assign_type,
 #endif
-						      enum nl80211_iftype type,
+							  enum nl80211_iftype type,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-						      u32 *flags,
+							  u32 *flags,
 #endif
-						      struct vif_params *params)
+							  struct vif_params *params)
 {
 	enum sprdwl_mode mode;
 	enum nl80211_iftype iftype = type;
@@ -535,7 +535,7 @@ static struct wireless_dev *sprdwl_cfg80211_add_iface(struct wiphy *wiphy,
 
 	if (sprdwl_check_p2p_coex(priv)) {
 		wl_err("%s P2P mode already exist type: %u not allowed\n",
-		       __func__, type);
+			   __func__, type);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -552,7 +552,7 @@ static struct wireless_dev *sprdwl_cfg80211_add_iface(struct wiphy *wiphy,
 #endif
 
 static int sprdwl_cfg80211_del_iface(struct wiphy *wiphy,
-				     struct wireless_dev *wdev)
+					 struct wireless_dev *wdev)
 {
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
 	struct sprdwl_vif *vif = NULL, *tmp_vif = NULL;
@@ -686,17 +686,17 @@ static int sprdwl_add_cipher_key(struct sprdwl_vif *vif, bool pairwise,
 	int ret = 0;
 
 	wl_ndev_log(L_DBG, vif->ndev, "%s %s key_index %d\n", __func__,
-		    pairwise ? "pairwise" : "group", key_index);
+			pairwise ? "pairwise" : "group", key_index);
 
 	if (vif->key_len[pairwise][0] || vif->key_len[pairwise][1] ||
-	    vif->key_len[pairwise][2] || vif->key_len[pairwise][3]) {
+		vif->key_len[pairwise][2] || vif->key_len[pairwise][3]) {
 		*cipher_ptr = vif->prwise_crypto = sprdwl_parse_cipher(cipher);
 
 		ret = sprdwl_add_key(vif->priv, vif->ctx_id,
-				     vif->key[pairwise][key_index],
-				     vif->key_len[pairwise][key_index],
-				     pairwise, key_index, key_seq,
-				     *cipher_ptr, mac_addr);
+					 vif->key[pairwise][key_index],
+					 vif->key_len[pairwise][key_index],
+					 pairwise, key_index, key_seq,
+					 *cipher_ptr, mac_addr);
 	}
 
 	return ret;
@@ -716,12 +716,12 @@ static int sprdwl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
 	/* PMK is for Roaming offload */
 	if (params->cipher == WLAN_CIPHER_SUITE_PMK)
 		return sprdwl_set_roam_offload(vif->priv, vif->ctx_id,
-					       SPRDWL_ROAM_OFFLOAD_SET_PMK,
-					       params->key, params->key_len);
+						   SPRDWL_ROAM_OFFLOAD_SET_PMK,
+						   params->key, params->key_len);
 	else
 		return sprdwl_add_cipher_key(vif, pairwise, key_index,
-					     params->cipher, params->seq,
-					     mac_addr);
+						 params->cipher, params->seq,
+						 mac_addr);
 }
 
 static int sprdwl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
@@ -730,18 +730,18 @@ static int sprdwl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
-	wl_ndev_log(L_DBG, ndev, "%s key_index=%d, pairwise=%d\n",
-		    __func__, key_index, pairwise);
+	//wl_ndev_log(L_DBG, ndev, "%s key_index=%d, pairwise=%d\n",
+	//		__func__, key_index, pairwise);
 
 	if (key_index > SPRDWL_MAX_KEY_INDEX) {
-		wl_ndev_log(L_ERR, ndev, "%s key index %d out of bounds!\n", __func__,
-			   key_index);
+		//wl_ndev_log(L_ERR, ndev, "%s key index %d out of bounds!\n", __func__,
+		//	   key_index);
 		return -ENOENT;
 	}
 
 	if (!vif->key_len[pairwise][key_index]) {
-		wl_ndev_log(L_ERR, ndev, "%s key index %d is empty!\n", __func__,
-			   key_index);
+		//wl_ndev_log(L_ERR, ndev, "%s key index %d is empty!\n", __func__,
+		//	   key_index);
 		return 0;
 	}
 
@@ -750,7 +750,7 @@ static int sprdwl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
 	vif->grp_crypto = SPRDWL_CIPHER_NONE;
 
 	return sprdwl_del_key(vif->priv, vif->ctx_id, key_index,
-			      pairwise, mac_addr);
+				  pairwise, mac_addr);
 }
 
 static int sprdwl_cfg80211_set_default_key(struct wiphy *wiphy,
@@ -792,23 +792,23 @@ int sprdwl_change_beacon(struct sprdwl_vif *vif,
 	if (beacon->beacon_ies_len) {
 		wl_ndev_log(L_DBG, vif->ndev, "set beacon extra IE\n");
 		ret = sprdwl_set_ie(vif->priv, vif->ctx_id, SPRDWL_IE_BEACON,
-				    beacon->beacon_ies, beacon->beacon_ies_len);
+					beacon->beacon_ies, beacon->beacon_ies_len);
 	}
 
 	if (beacon->proberesp_ies_len) {
 		wl_ndev_log(L_DBG, vif->ndev, "set probe response extra IE\n");
 		ret = sprdwl_set_ie(vif->priv, vif->ctx_id,
-				    SPRDWL_IE_PROBE_RESP,
-				    beacon->proberesp_ies,
-				    beacon->proberesp_ies_len);
+					SPRDWL_IE_PROBE_RESP,
+					beacon->proberesp_ies,
+					beacon->proberesp_ies_len);
 	}
 
 	if (beacon->assocresp_ies_len) {
 		wl_ndev_log(L_DBG, vif->ndev, "set associate response extra IE\n");
 		ret = sprdwl_set_ie(vif->priv, vif->ctx_id,
-				    SPRDWL_IE_ASSOC_RESP,
-				    beacon->assocresp_ies,
-				    beacon->assocresp_ies_len);
+					SPRDWL_IE_ASSOC_RESP,
+					beacon->assocresp_ies,
+					beacon->assocresp_ies_len);
 	}
 
 	if (ret)
@@ -818,8 +818,8 @@ int sprdwl_change_beacon(struct sprdwl_vif *vif,
 }
 
 static int sprdwl_cfg80211_start_ap(struct wiphy *wiphy,
-				    struct net_device *ndev,
-				    struct cfg80211_ap_settings *settings)
+					struct net_device *ndev,
+					struct cfg80211_ap_settings *settings)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
@@ -836,7 +836,7 @@ static int sprdwl_cfg80211_start_ap(struct wiphy *wiphy,
 
 #ifdef ACS_SUPPORT
 	if ((vif->mode == SPRDWL_MODE_AP) &&
-	    !list_empty(&vif->survey_info_list)) {
+		!list_empty(&vif->survey_info_list)) {
 		clean_survey_info_list(vif);
 	}
 #endif
@@ -933,15 +933,15 @@ static int sprdwl_cfg80211_start_ap(struct wiphy *wiphy,
 		hidden_index = index;
 
 	memcpy(data + index, head + hidden_index - 1,
-	       head_len + 1 - hidden_index);
+		   head_len + 1 - hidden_index);
 
 	if (beacon->tail)
 		memcpy(data + head_len + 1 +
 			(settings->hidden_ssid != 0 ? settings->ssid_len : 0),
-		       tail, tail_len);
+			   tail, tail_len);
 
 	ret = sprdwl_start_ap(vif->priv, vif->ctx_id, (unsigned char *)mgmt,
-			      mgmt_len);
+				  mgmt_len);
 	kfree(mgmt);
 
 #ifdef DFS_MASTER
@@ -1003,14 +1003,14 @@ static int sprdwl_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
 }
 
 static int sprdwl_cfg80211_add_station(struct wiphy *wiphy,
-				       struct net_device *ndev, const u8 *mac,
-				       struct station_parameters *params)
+					   struct net_device *ndev, const u8 *mac,
+					   struct station_parameters *params)
 {
 	return 0;
 }
 
 static int sprdwl_cfg80211_del_station(struct wiphy *wiphy,
-				       struct net_device *ndev,
+					   struct net_device *ndev,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
 					   struct station_del_parameters *params
 #else
@@ -1046,16 +1046,16 @@ static int sprdwl_cfg80211_del_station(struct wiphy *wiphy,
 
 static int
 sprdwl_cfg80211_change_station(struct wiphy *wiphy,
-			       struct net_device *ndev, const u8 *mac,
-			       struct station_parameters *params)
+				   struct net_device *ndev, const u8 *mac,
+				   struct station_parameters *params)
 {
 	return 0;
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
 static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
-				       struct net_device *ndev, const u8 *mac,
-				       struct station_info *sinfo)
+					   struct net_device *ndev, const u8 *mac,
+					   struct station_info *sinfo)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	struct sprdwl_cmd_get_station sta;
@@ -1126,8 +1126,8 @@ static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
 
 #else
 static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
-				       struct net_device *ndev, const u8 *mac,
-				       struct station_info *sinfo)
+					   struct net_device *ndev, const u8 *mac,
+					   struct station_info *sinfo)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	struct sprdwl_cmd_get_station sta;
@@ -1180,8 +1180,8 @@ static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
 #endif
 
 static int sprdwl_cfg80211_set_channel(struct wiphy *wiphy,
-				       struct net_device *ndev,
-				       struct ieee80211_channel *chan)
+					   struct net_device *ndev,
+					   struct ieee80211_channel *chan)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
@@ -1221,7 +1221,7 @@ void sprdwl_report_softap(struct sprdwl_vif *vif, u8 is_connect, u8 *addr,
 	} else {
 		cfg80211_del_sta(vif->ndev, addr, GFP_KERNEL);
 		wl_ndev_log(L_DBG, vif->ndev, "The station (%pM) disconnected\n",
-			    addr);
+				addr);
 		trace_deauth_reason(vif->mode, 0, REMOTE_EVENT);
 	}
 }
@@ -1263,7 +1263,7 @@ void sprdwl_cancel_scan(struct sprdwl_vif *vif)
 #endif
 			else
 				wl_err("%s, %d, error, scan_request freed",
-				       __func__, __LINE__);
+					   __func__, __LINE__);
 			priv->scan_request = NULL;
 			priv->scan_vif = NULL;
 		}
@@ -1323,7 +1323,7 @@ void sprdwl_scan_done(struct sprdwl_vif *vif, bool abort)
 #endif
 			} else {
 				wl_err("%s, %d, error, scan_request freed",
-				       __func__, __LINE__);
+					   __func__, __LINE__);
 			}
 			priv->scan_request = NULL;
 			priv->scan_vif = NULL;
@@ -1348,7 +1348,7 @@ void sprdwl_sched_scan_done(struct sprdwl_vif *vif, bool abort)
 			cfg80211_sched_scan_results(vif->wdev.wiphy);
 #endif
 			wl_ndev_log(L_DBG, priv->sched_scan_vif->ndev,
-				    "%s report result\n", __func__);
+					"%s report result\n", __func__);
 			priv->sched_scan_request = NULL;
 			priv->sched_scan_vif = NULL;
 		}
@@ -1393,7 +1393,7 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 {
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
 	struct sprdwl_vif *vif =
-	    container_of(request->wdev, struct sprdwl_vif, wdev);
+		container_of(request->wdev, struct sprdwl_vif, wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
 	struct sprdwl_scan_ssid *scan_ssids;
 	u8 *ssids_ptr = NULL;
@@ -1421,11 +1421,11 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 #endif
 
 	wl_ndev_log(L_DBG, vif->ndev, "%s n_channels %u\n", __func__,
-		    request->n_channels);
+			request->n_channels);
 
 	if (!sprdwl_is_valid_iftype(wiphy, request->wdev->iftype)) {
 		wl_err("%s unsupported interface type: %u\n",
-		       __func__, request->wdev->iftype);
+			   __func__, request->wdev->iftype);
 		ret = -EOPNOTSUPP;
 		goto err;
 	}
@@ -1443,7 +1443,7 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 		if (flags & (1<<3)) {
 			random_mac_flag = 1;
 			wl_info("Random MAC support==set value:%d\n",
-			       random_mac_set);
+				   random_mac_set);
 			wl_info("random mac addr: %pM\n", rand_addr);
 		} else {
 			wl_info("random mac feature disabled\n");
@@ -1452,7 +1452,7 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 		if (random_mac_flag != old_mac_flag) {
 			old_mac_flag = random_mac_flag;
 			wlan_cmd_set_rand_mac(vif->priv, vif->ctx_id,
-					      old_mac_flag, rand_addr);
+						  old_mac_flag, rand_addr);
 		}
 	}
 #endif
@@ -1467,7 +1467,7 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 		}
 
 		ret = sprdwl_set_ie(priv, vif->ctx_id, SPRDWL_IE_PROBE_REQ,
-				    request->ie, request->ie_len);
+					request->ie, request->ie_len);
 		if (ret)
 			goto err;
 	}
@@ -1510,7 +1510,7 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 			info->beacon_num = 0;
 			info->channel = NULL;
 			list_add_tail(&info->survey_list,
-				      &vif->survey_info_list);
+					  &vif->survey_info_list);
 		}
 #endif /* ACS_SUPPORT */
 	}
@@ -1536,7 +1536,7 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 			scan_ssids_len += (ssids[i].ssid_len
 					   + sizeof(scan_ssids->len));
 			scan_ssids = (struct sprdwl_scan_ssid *)
-			    (ssids_ptr + scan_ssids_len);
+				(ssids_ptr + scan_ssids_len);
 		}
 	} else {
 #ifndef ACS_SUPPORT
@@ -1572,9 +1572,9 @@ static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
 }
 
 static int sprdwl_cfg80211_sched_scan_start(struct wiphy *wiphy,
-					    struct net_device *ndev,
-					    struct cfg80211_sched_scan_request
-					    *request)
+						struct net_device *ndev,
+						struct cfg80211_sched_scan_request
+						*request)
 {
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
@@ -1596,7 +1596,7 @@ static int sprdwl_cfg80211_sched_scan_start(struct wiphy *wiphy,
 	/*scan not allowed if closed*/
 	if (vif->priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
 		wl_err("%s, %d, error!mode%d scan after closed not allowed\n",
-		       __func__, __LINE__, vif->mode);
+			   __func__, __LINE__, vif->mode);
 		return -ENOMEM;
 	}
 
@@ -1607,23 +1607,23 @@ static int sprdwl_cfg80211_sched_scan_start(struct wiphy *wiphy,
 	/*to protect the size of struct sprdwl_sched_scan_buf*/
 	if (request->n_channels > TOTAL_2G_5G_CHANNEL_NUM) {
 		wl_err("%s, %d, error! request->n_channels=%d\n",
-		       __func__, __LINE__, request->n_channels);
+			   __func__, __LINE__, request->n_channels);
 		request->n_channels = TOTAL_2G_5G_CHANNEL_NUM;
 	}
 	if (request->n_ssids > TOTAL_2G_5G_SSID_NUM) {
 		wl_err("%s, %d, error! request->n_ssids=%d\n",
-		       __func__, __LINE__, request->n_ssids);
+			   __func__, __LINE__, request->n_ssids);
 		request->n_ssids = TOTAL_2G_5G_SSID_NUM;
 	}
 	if (request->n_match_sets > TOTAL_2G_5G_SSID_NUM) {
 		wl_err("%s, %d, error! request->n_match_sets=%d\n",
-		       __func__, __LINE__, request->n_match_sets);
+			   __func__, __LINE__, request->n_match_sets);
 		request->n_match_sets = TOTAL_2G_5G_SSID_NUM;
 	}
 	sscan_buf = kzalloc(sizeof(*sscan_buf), GFP_KERNEL);
 	if (!sscan_buf)
 		return -ENOMEM;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 	scan_plans = request->scan_plans;
 	sscan_buf->interval = scan_plans->interval;
 #else
@@ -1648,8 +1648,8 @@ static int sprdwl_cfg80211_sched_scan_start(struct wiphy *wiphy,
 
 		if (ch == 0) {
 			wl_ndev_log(L_DBG, ndev, "%s  unknown frequency %dMhz\n",
-				    __func__,
-				    request->channels[i]->center_freq);
+					__func__,
+					request->channels[i]->center_freq);
 			continue;
 		}
 
@@ -1725,6 +1725,20 @@ static int sprdwl_cfg80211_sched_scan_stop(struct wiphy *wiphy,
 #ifdef SYNC_DISCONNECT
 void sprdwl_disconnect_handle(struct sprdwl_vif *vif)
 {
+	u16 reason_code = 0;
+	if ((vif->sm_state == SPRDWL_CONNECTED) ||
+			(vif->sm_state == SPRDWL_DISCONNECTING)) {
+		cfg80211_disconnected(vif->ndev, reason_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+			NULL, 0, true, GFP_KERNEL);
+#else
+			NULL, 0, GFP_KERNEL);
+#endif
+		wl_ndev_log(L_DBG, vif->ndev,
+			"%s %s, reason_code %d\n", __func__,
+			vif->ssid, reason_code);
+	}
+
 	vif->sm_state = SPRDWL_DISCONNECTED;
 
 	/* Clear bssid & ssid */
@@ -1746,24 +1760,22 @@ void sprdwl_disconnect_handle(struct sprdwl_vif *vif)
 }
 #endif
 static int sprdwl_cfg80211_disconnect(struct wiphy *wiphy,
-				      struct net_device *ndev, u16 reason_code)
+					  struct net_device *ndev, u16 reason_code)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	enum sm_state old_state = vif->sm_state;
 	int ret;
 #ifdef SYNC_DISCONNECT
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 60)
 	u32 msec;
 	ktime_t kt;
 #endif
-#endif
 #ifdef STA_SOFTAP_SCC_MODE
 	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
 	intf->sta_home_channel = 0;
 #endif
 
 	wl_ndev_log(L_DBG, ndev, "%s %s reason: %d\n", __func__, vif->ssid,
-		    reason_code);
+			reason_code);
 
 	vif->sm_state = SPRDWL_DISCONNECTING;
 
@@ -1776,17 +1788,19 @@ static int sprdwl_cfg80211_disconnect(struct wiphy *wiphy,
 		goto out;
 	}
 #ifdef SYNC_DISCONNECT
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 60)
 	if (!sprdwl_sync_disconnect_event(vif, msecs_to_jiffies(1000))) {
 		kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
 		msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
 		wl_err("Wait disconnect event timeout. [mstime = %d]\n",
-		       cpu_to_le32(msec));
+			   cpu_to_le32(msec));
 	} else {
 		sprdwl_disconnect_handle(vif);
 	}
 	atomic_set(&vif->sync_disconnect_event, 0);
-#endif
 #endif
 	trace_deauth_reason(vif->mode, reason_code, LOCAL_EVENT);
 out:
@@ -1803,14 +1817,14 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 	struct sprdwl_cmd_connect con;
 	enum sm_state old_state = vif->sm_state;
 	int is_wep = (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||
-	    (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104);
+		(sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104);
 	int random_mac_flag;
 	int ret = -EPERM;
 
 	/*workround for bug 795430*/
 	if (vif->priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
 		wl_err("%s, %d, error!mode%d connect after closed not allowed",
-		       __func__, __LINE__, vif->mode);
+			   __func__, __LINE__, vif->mode);
 		goto err;
 	}
 
@@ -1818,7 +1832,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 		if (vif->has_rand_mac) {
 			 random_mac_flag = SPRDWL_CONNECT_RANDOM_ADDR;
 			 ret = wlan_cmd_set_rand_mac(vif->priv, vif->ctx_id,
-					       random_mac_flag, vif->random_mac);
+						   random_mac_flag, vif->random_mac);
 			 if (ret)
 				 netdev_info(ndev, "Set random mac failed!\n");
 		}
@@ -1836,7 +1850,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 	if (sme->ie_len > 0) {
 		wl_ndev_log(L_DBG, ndev, "set assoc req ie, len %zx\n", sme->ie_len);
 		ret = sprdwl_set_ie(vif->priv, vif->ctx_id, SPRDWL_IE_ASSOC_REQ,
-				    sme->ie, sme->ie_len);
+					sme->ie, sme->ie_len);
 		if (ret)
 			goto err;
 	}
@@ -1848,7 +1862,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 
 	wl_ndev_log(L_DBG, ndev, "auth type %#x\n", sme->auth_type);
 	if ((sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) ||
-	    ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && !is_wep))
+		((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && !is_wep))
 		con.auth_type = SPRDWL_AUTH_OPEN;
 	else if ((sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) ||
 		 ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && is_wep))
@@ -1857,11 +1871,11 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 	/* Set pairewise cipher */
 	if (sme->crypto.n_ciphers_pairwise) {
 		vif->prwise_crypto =
-		    sprdwl_parse_cipher(sme->crypto.ciphers_pairwise[0]);
+			sprdwl_parse_cipher(sme->crypto.ciphers_pairwise[0]);
 
 		if (vif->prwise_crypto != SPRDWL_CIPHER_NONE) {
 			wl_ndev_log(L_DBG, ndev, "pairwise cipher %#x\n",
-				    sme->crypto.ciphers_pairwise[0]);
+					sme->crypto.ciphers_pairwise[0]);
 			con.pairwise_cipher = vif->prwise_crypto;
 			con.pairwise_cipher |= SPRDWL_VALID_CONFIG;
 		}
@@ -1874,7 +1888,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 	vif->grp_crypto = sprdwl_parse_cipher(sme->crypto.cipher_group);
 	if (vif->grp_crypto != SPRDWL_CIPHER_NONE) {
 		wl_ndev_log(L_DBG, ndev, "group cipher %#x\n",
-			    sme->crypto.cipher_group);
+				sme->crypto.cipher_group);
 		con.group_cipher = vif->grp_crypto;
 		con.group_cipher |= SPRDWL_VALID_CONFIG;
 	}
@@ -1882,7 +1896,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 	/* Set auth key management (akm) */
 	if (sme->crypto.n_akm_suites) {
 		wl_ndev_log(L_DBG, ndev, "akm suites %#x\n",
-			    sme->crypto.akm_suites[0]);
+				sme->crypto.akm_suites[0]);
 		con.key_mgmt = sprdwl_parse_akm(sme->crypto.akm_suites[0]);
 		con.key_mgmt |= SPRDWL_VALID_CONFIG;
 	} else {
@@ -1892,17 +1906,17 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 	/* Set PSK */
 	if (sme->key_len) {
 		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40 ||
-		    sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104 ||
-		    sme->crypto.ciphers_pairwise[0] ==
-		    WLAN_CIPHER_SUITE_WEP40 ||
-		    sme->crypto.ciphers_pairwise[0] ==
-		    WLAN_CIPHER_SUITE_WEP104) {
+			sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104 ||
+			sme->crypto.ciphers_pairwise[0] ==
+			WLAN_CIPHER_SUITE_WEP40 ||
+			sme->crypto.ciphers_pairwise[0] ==
+			WLAN_CIPHER_SUITE_WEP104) {
 			vif->key_index[SPRDWL_GROUP] = sme->key_idx;
 			vif->key_len[SPRDWL_GROUP][sme->key_idx] = sme->key_len;
 			memcpy(vif->key[SPRDWL_GROUP][sme->key_idx], sme->key,
-			       sme->key_len);
+				   sme->key_len);
 			ret =
-			    sprdwl_add_cipher_key(vif, 0, sme->key_idx,
+				sprdwl_add_cipher_key(vif, 0, sme->key_idx,
 						  sme->crypto.
 						  ciphers_pairwise[0],
 						  NULL, NULL);
@@ -1931,7 +1945,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 			u16 center_freq = sme->channel_hint->center_freq;
 
 			con.channel =
-			    ieee80211_frequency_to_channel(center_freq);
+				ieee80211_frequency_to_channel(center_freq);
 			wl_ndev_log(L_DBG, ndev, "channel_hint %d\n", con.channel);
 #ifdef STA_SOFTAP_SCC_MODE
 			if (sme->channel_hint->flags != IEEE80211_CHAN_RADAR)
@@ -1944,7 +1958,7 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 		}
 	} else {
 		con.channel =
-		    ieee80211_frequency_to_channel(sme->channel->center_freq);
+			ieee80211_frequency_to_channel(sme->channel->center_freq);
 		wl_ndev_log(L_DBG, ndev, "channel %d\n", con.channel);
 #ifdef STA_SOFTAP_SCC_MODE
 		if (sme->channel->flags != IEEE80211_CHAN_RADAR)
@@ -1967,14 +1981,14 @@ static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 
 	/* Special process for WEP(WEP key must be set before essid) */
 	if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40 ||
-	    sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104) {
+		sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104) {
 		wl_ndev_log(L_DBG, ndev, "%s WEP cipher_group\n", __func__);
 
 		if (sme->key_len <= 0) {
 			wl_ndev_log(L_DBG, ndev, "No key specified!\n");
 		} else {
 			if (sme->key_len != WLAN_KEY_LEN_WEP104 &&
-			    sme->key_len != WLAN_KEY_LEN_WEP40) {
+				sme->key_len != WLAN_KEY_LEN_WEP40) {
 				wl_ndev_log(L_ERR, ndev, "%s invalid WEP key length!\n",
 					   __func__);
 				ret = -EINVAL;
@@ -2037,38 +2051,38 @@ static int sprdwl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 }
 
 static int sprdwl_cfg80211_set_pmksa(struct wiphy *wiphy,
-				     struct net_device *ndev,
-				     struct cfg80211_pmksa *pmksa)
+					 struct net_device *ndev,
+					 struct cfg80211_pmksa *pmksa)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
 	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
 
 	return sprdwl_pmksa(vif->priv, vif->ctx_id, pmksa->bssid,
-			    pmksa->pmkid, SPRDWL_SUBCMD_SET);
+				pmksa->pmkid, SPRDWL_SUBCMD_SET);
 }
 
 static int sprdwl_cfg80211_del_pmksa(struct wiphy *wiphy,
-				     struct net_device *ndev,
-				     struct cfg80211_pmksa *pmksa)
+					 struct net_device *ndev,
+					 struct cfg80211_pmksa *pmksa)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
 	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
 
 	return sprdwl_pmksa(vif->priv, vif->ctx_id, pmksa->bssid,
-			    pmksa->pmkid, SPRDWL_SUBCMD_DEL);
+				pmksa->pmkid, SPRDWL_SUBCMD_DEL);
 }
 
 static int sprdwl_cfg80211_flush_pmksa(struct wiphy *wiphy,
-				       struct net_device *ndev)
+					   struct net_device *ndev)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
 	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
 
 	return sprdwl_pmksa(vif->priv, vif->ctx_id, vif->bssid, NULL,
-			    SPRDWL_SUBCMD_FLUSH);
+				SPRDWL_SUBCMD_FLUSH);
 }
 
 void sprdwl_report_fake_probe(struct wiphy *wiphy, u8 *ie, size_t ielen)
@@ -2159,14 +2173,18 @@ void signal_level_enhance(struct sprdwl_vif *vif,
 }
 
 void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
-			       u8 *frame, u16 len)
+				   u8 *frame, u16 len)
 {
 	struct sprdwl_priv *priv = vif->priv;
 	struct wiphy *wiphy = priv->wiphy;
 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame;
 	struct ieee80211_channel *channel;
 	struct cfg80211_bss *bss;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
 	struct timespec ts;
+#else
+	struct timespec64 ts;
+#endif
 	u16 capability, beacon_interval;
 	u32 freq;
 	s32 signal;
@@ -2204,7 +2222,7 @@ void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
 
 	if ((rssi * 100) != signal)
 		wl_debug("old signal level:%d,new signal level:%d\n",
-		       (rssi*100), signal);
+			   (rssi*100), signal);
 
 #ifdef ACS_SUPPORT
 	if (vif->mode == SPRDWL_MODE_AP)
@@ -2214,13 +2232,18 @@ void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
 	ie = mgmt->u.probe_resp.variable;
 	ielen = len - offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
 	/* framework use system bootup time */
-	tsf = (u64)ktime_to_us(ktime_get_boottime());
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+	get_monotonic_boottime(&ts);
+#else
+	ktime_get_boottime_ts64(&ts);
+#endif
+	tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
 	beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
 	capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
 
 	wl_ndev_log(L_DBG, vif->ndev, "   %s, %pM, channel %2u, signal %d\n",
-		    ieee80211_is_probe_resp(mgmt->frame_control)
-		    ? "proberesp" : "beacon   ", mgmt->bssid, chan, signal);
+			ieee80211_is_probe_resp(mgmt->frame_control)
+			? "proberesp" : "beacon   ", mgmt->bssid, chan, signal);
 
 	bss = cfg80211_inform_bss(wiphy, channel,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
@@ -2230,8 +2253,9 @@ void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
 				  ie, ielen, signal, GFP_KERNEL);
 
 	if (unlikely(!bss))
-		wl_ndev_log(L_ERR, vif->ndev,
-			   "%s failed to inform bss frame!\n", __func__);
+		;
+		//wl_ndev_log(L_ERR, vif->ndev,
+		//	   "%s failed to inform bss frame!\n", __func__);
 	cfg80211_put_bss(wiphy, bss);
 
 	/*check log mac flag and call report fake probe*/
@@ -2240,14 +2264,14 @@ void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
 
 	if (vif->beacon_loss) {
 		bss = cfg80211_get_bss(wiphy, NULL, vif->bssid,
-				       vif->ssid, vif->ssid_len,
-				       WLAN_CAPABILITY_ESS,
-				       WLAN_CAPABILITY_ESS);
+					   vif->ssid, vif->ssid_len,
+					   WLAN_CAPABILITY_ESS,
+					   WLAN_CAPABILITY_ESS);
 		if (bss) {
 			cfg80211_unlink_bss(wiphy, bss);
 			wl_ndev_log(L_DBG, vif->ndev,
-				    "unlink %pM due to beacon loss\n",
-				    bss->bssid);
+					"unlink %pM due to beacon loss\n",
+					bss->bssid);
 			vif->beacon_loss = 0;
 		}
 	}
@@ -2262,7 +2286,11 @@ void sprdwl_report_connection(struct sprdwl_vif *vif,
 	struct ieee80211_channel *channel;
 	struct ieee80211_mgmt *mgmt;
 	struct cfg80211_bss *bss = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
 	struct timespec ts;
+#else
+	struct timespec64 ts;
+#endif
 #ifdef WMMAC_WFA_CERTIFICATION
 	struct wmm_params_element *wmm_params;
 	int i;
@@ -2277,19 +2305,19 @@ void sprdwl_report_connection(struct sprdwl_vif *vif,
 #endif
 
 	if (vif->sm_state != SPRDWL_CONNECTING &&
-	    vif->sm_state != SPRDWL_CONNECTED) {
+		vif->sm_state != SPRDWL_CONNECTED) {
 		wl_ndev_log(L_ERR, vif->ndev, "%s Unexpected event!\n", __func__);
 		return;
 	}
 #ifndef IBSS_SUPPORT
 	if (conn_info->status != SPRDWL_CONNECT_SUCCESS &&
-	    conn_info->status != SPRDWL_ROAM_SUCCESS)
+		conn_info->status != SPRDWL_ROAM_SUCCESS)
 		goto err;
 #else
 	if (conn_info->status != SPRDWL_CONNECT_SUCCESS &&
-	    conn_info->status != SPRDWL_ROAM_SUCCESS &&
-	    conn_info->status != SPRDWL_IBSS_JOIN &&
-	    conn_info->status != SPRDWL_IBSS_START)
+		conn_info->status != SPRDWL_ROAM_SUCCESS &&
+		conn_info->status != SPRDWL_IBSS_JOIN &&
+		conn_info->status != SPRDWL_IBSS_START)
 		goto err;
 #endif /* IBSS_SUPPORT */
 	if (!conn_info->bssid) {
@@ -2325,20 +2353,25 @@ void sprdwl_report_connection(struct sprdwl_vif *vif,
 
 		mgmt = (struct ieee80211_mgmt *)conn_info->bea_ie;
 		wl_ndev_log(L_DBG, vif->ndev, "%s update BSS %s\n", __func__,
-			    vif->ssid);
+				vif->ssid);
 		if (!mgmt) {
 			wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
 			goto err;
 		}
-		if (!ether_addr_equal(conn_info->bssid, mgmt->bssid))
-			wl_ndev_log(L_ERR, vif->ndev,
-				    "%s Invalid Beacon!,vif->bssid = %pM, con->bssid = %pM, mgmt->bssid = %pM\n",
-				    __func__, vif->bssid, conn_info->bssid, mgmt->bssid);
+		//if (!ether_addr_equal(conn_info->bssid, mgmt->bssid))
+		//	wl_ndev_log(L_ERR, vif->ndev,
+		//			"%s Invalid Beacon!,vif->bssid = %pM, con->bssid = %pM, mgmt->bssid = %pM\n",
+		//			__func__, vif->bssid, conn_info->bssid, mgmt->bssid);
 		ie = mgmt->u.probe_resp.variable;
 		ielen = conn_info->bea_ie_len - offsetof(struct ieee80211_mgmt,
 						 u.probe_resp.variable);
 		/* framework use system bootup time */
-		tsf = (u64)ktime_to_us(ktime_get_boottime());
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		get_monotonic_boottime(&ts);
+#else
+		ktime_get_boottime_ts64(&ts);
+#endif
+		tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
 		beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
 		capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
 		wl_ndev_log(L_DBG, vif->ndev, "%s, %pM, signal: %d\n",
@@ -2354,15 +2387,16 @@ void sprdwl_report_connection(struct sprdwl_vif *vif,
 					  capability, beacon_interval,
 					  ie, ielen, conn_info->signal, GFP_KERNEL);
 		if (unlikely(!bss))
-			wl_ndev_log(L_ERR, vif->ndev,
-				   "%s failed to inform bss frame!\n",
-				   __func__);
+			;
+			//wl_ndev_log(L_ERR, vif->ndev,
+			//	   "%s failed to inform bss frame!\n",
+			//	   __func__);
 	} else {
 		wl_ndev_log(L_ERR, vif->ndev, "%s No Beason IE!\n", __func__);
 	}
 
 	if (vif->sm_state == SPRDWL_CONNECTING &&
-	    conn_info->status == SPRDWL_CONNECT_SUCCESS)
+		conn_info->status == SPRDWL_CONNECT_SUCCESS)
 		cfg80211_connect_result(vif->ndev,
 					conn_info->bssid, conn_info->req_ie, conn_info->req_ie_len,
 					conn_info->resp_ie, conn_info->resp_ie_len,
@@ -2380,7 +2414,7 @@ void sprdwl_report_connection(struct sprdwl_vif *vif,
 		cfg80211_roamed(vif->ndev, &roam_info, GFP_KERNEL);
 #else
 		cfg80211_roamed_bss(vif->ndev, bss, conn_info->req_ie, conn_info->req_ie_len,
-				    conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+					conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
 #endif
 	}
 #ifdef IBSS_SUPPORT
@@ -2437,7 +2471,7 @@ void sprdwl_report_connection(struct sprdwl_vif *vif,
 	vif->sm_state = SPRDWL_CONNECTED;
 	memcpy(vif->bssid, conn_info->bssid, sizeof(vif->bssid));
 	wl_ndev_log(L_DBG, vif->ndev, "%s %s to %s (%pM)\n", __func__,
-		    conn_info->status == SPRDWL_CONNECT_SUCCESS ?
+			conn_info->status == SPRDWL_CONNECT_SUCCESS ?
 			"connect" : "roam", vif->ssid, vif->bssid);
 	return;
 err:
@@ -2468,11 +2502,11 @@ void sprdwl_report_disconnection(struct sprdwl_vif *vif, u16 reason_code)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
 				NULL, 0, false, GFP_KERNEL);
 #else
-				      NULL, 0, GFP_KERNEL);
+					  NULL, 0, GFP_KERNEL);
 #endif
 		wl_ndev_log(L_DBG, vif->ndev,
-			    "%s %s, reason_code %d\n", __func__,
-			    vif->ssid, reason_code);
+				"%s %s, reason_code %d\n", __func__,
+				vif->ssid, reason_code);
 	} else {
 		wl_ndev_log(L_ERR, vif->ndev, "%s Unexpected event!\n", __func__);
 		return;
@@ -2504,13 +2538,13 @@ void sprdwl_report_disconnection(struct sprdwl_vif *vif, u16 reason_code)
 void sprdwl_report_mic_failure(struct sprdwl_vif *vif, u8 is_mcast, u8 key_id)
 {
 	wl_ndev_log(L_DBG, vif->ndev,
-		    "%s is_mcast:0x%x key_id: 0x%x bssid: %pM\n",
-		    __func__, is_mcast, key_id, vif->bssid);
+			"%s is_mcast:0x%x key_id: 0x%x bssid: %pM\n",
+			__func__, is_mcast, key_id, vif->bssid);
 
 	cfg80211_michael_mic_failure(vif->ndev, vif->bssid,
-				     (is_mcast ? NL80211_KEYTYPE_GROUP :
-				      NL80211_KEYTYPE_PAIRWISE),
-				     key_id, NULL, GFP_KERNEL);
+					 (is_mcast ? NL80211_KEYTYPE_GROUP :
+					  NL80211_KEYTYPE_PAIRWISE),
+					 key_id, NULL, GFP_KERNEL);
 }
 
 static char type_name[16][32] = {
@@ -2581,10 +2615,10 @@ void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
 
 	if (type == IEEE80211_FTYPE_MGMT) {
 		idx += sprintf(p + idx, "%dMHz, %s, ",
-			       freq, type_name[subtype]);
+				   freq, type_name[subtype]);
 	} else {
 		idx += sprintf(p + idx,
-			       "%dMHz, not mgmt frame, type=%d, ", freq, type);
+				   "%dMHz, not mgmt frame, type=%d, ", freq, type);
 	}
 
 	if (subtype == ACTION_TYPE) {
@@ -2592,10 +2626,10 @@ void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
 		action_subtype = *(buf + ACTION_SUBTYPE_OFFSET);
 		if (action == PUB_ACTION)
 			idx += sprintf(p + idx, "PUB:%s ",
-				       pub_action_name[action_subtype]);
+					   pub_action_name[action_subtype]);
 		else if (action == P2P_ACTION)
 			idx += sprintf(p + idx, "P2P:%s ",
-				       p2p_action_name[action_subtype]);
+					   p2p_action_name[action_subtype]);
 		else
 			idx += sprintf(p + idx, "Unknown ACTION(0x%x)", action);
 	}
@@ -2606,9 +2640,9 @@ void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
 
 /* P2P related stuff */
 static int sprdwl_cfg80211_remain_on_channel(struct wiphy *wiphy,
-					     struct wireless_dev *wdev,
-					     struct ieee80211_channel *chan,
-					     unsigned int duration, u64 *cookie)
+						 struct wireless_dev *wdev,
+						 struct ieee80211_channel *chan,
+						 unsigned int duration, u64 *cookie)
 {
 	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
 	enum nl80211_channel_type channel_type = 0;
@@ -2617,7 +2651,7 @@ static int sprdwl_cfg80211_remain_on_channel(struct wiphy *wiphy,
 
 	*cookie = vif->listen_cookie = ++remain_index;
 	wl_ndev_log(L_DBG, wdev->netdev, "%s %d for %dms, cookie %lld\n",
-		    __func__, chan->center_freq, duration, *cookie);
+			__func__, chan->center_freq, duration, *cookie);
 	memcpy(&vif->listen_channel, chan, sizeof(struct ieee80211_channel));
 
 	ret = sprdwl_remain_chan(vif->priv, vif->ctx_id, chan,
@@ -2631,8 +2665,8 @@ static int sprdwl_cfg80211_remain_on_channel(struct wiphy *wiphy,
 }
 
 static int sprdwl_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
-						    struct wireless_dev *wdev,
-						    u64 cookie)
+							struct wireless_dev *wdev,
+							u64 cookie)
 {
 	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
 
@@ -2672,9 +2706,9 @@ static int sprdwl_cfg80211_mgmt_tx(struct wiphy *wiphy,
 	/* send tx mgmt */
 	if (len > 0) {
 		ret = sprdwl_tx_mgmt(vif->priv, vif->ctx_id,
-				     ieee80211_frequency_to_channel
-				     (chan->center_freq), dont_wait_for_ack,
-				     wait, cookie, buf, len);
+					 ieee80211_frequency_to_channel
+					 (chan->center_freq), dont_wait_for_ack,
+					 wait, cookie, buf, len);
 		if (ret)
 			if (!dont_wait_for_ack)
 				cfg80211_mgmt_tx_status(wdev, *cookie, buf, len,
@@ -2692,9 +2726,10 @@ static void sprdwl_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
 	struct sprdwl_work *misc_work;
 	struct sprdwl_reg_mgmt *reg_mgmt;
 	u16 mgmt_type;
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
-	u16 frame_type = BIT(upd->global_stypes << 4);
-	bool reg = false;
+       u16 frame_type = BIT(upd->global_stypes << 4);
+       bool reg = false;
 #endif
 
 	if (vif->mode == SPRDWL_MODE_NONE)
@@ -2702,7 +2737,7 @@ static void sprdwl_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
 
 	mgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;
 	if ((reg && test_and_set_bit(mgmt_type, &vif->mgmt_reg)) ||
-	    (!reg && !test_and_clear_bit(mgmt_type, &vif->mgmt_reg))) {
+		(!reg && !test_and_clear_bit(mgmt_type, &vif->mgmt_reg))) {
 		wl_ndev_log(L_DBG, wdev->netdev, "%s  mgmt %d has %sreg\n", __func__,
 			   frame_type, reg ? "" : "un");
 		return;
@@ -2749,9 +2784,9 @@ void sprdwl_report_rx_mgmt(struct sprdwl_vif *vif, u8 chan, const u8 *buf,
 	int freq;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
 	freq = ieee80211_channel_to_frequency(chan,
-					      chan <= CH_MAX_2G_CHANNEL ?
-					      NL80211_BAND_2GHZ :
-					      NL80211_BAND_5GHZ);
+						  chan <= CH_MAX_2G_CHANNEL ?
+						  NL80211_BAND_2GHZ :
+						  NL80211_BAND_5GHZ);
 #else
 	freq = ieee80211_channel_to_frequency(chan,
 						chan <= CH_MAX_2G_CHANNEL ?
@@ -2771,7 +2806,7 @@ void sprdwl_report_rx_mgmt(struct sprdwl_vif *vif, u8 chan, const u8 *buf,
 }
 
 void sprdwl_report_mgmt_deauth(struct sprdwl_vif *vif, const u8 *buf,
-			       size_t len)
+				   size_t len)
 {
 	struct sprdwl_work *misc_work;
 
@@ -2807,7 +2842,7 @@ void sprdwl_report_mgmt_disassoc(struct sprdwl_vif *vif, const u8 *buf,
 }
 
 static int sprdwl_cfg80211_start_p2p_device(struct wiphy *wiphy,
-					    struct wireless_dev *wdev)
+						struct wireless_dev *wdev)
 {
 	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
 
@@ -2817,7 +2852,7 @@ static int sprdwl_cfg80211_start_p2p_device(struct wiphy *wiphy,
 }
 
 static void sprdwl_cfg80211_stop_p2p_device(struct wiphy *wiphy,
-					    struct wireless_dev *wdev)
+						struct wireless_dev *wdev)
 {
 	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
 
@@ -2830,10 +2865,10 @@ static void sprdwl_cfg80211_stop_p2p_device(struct wiphy *wiphy,
 }
 
 static int sprdwl_cfg80211_tdls_mgmt(struct wiphy *wiphy,
-				     struct net_device *ndev, const u8 *peer,
-				     u8 action_code, u8 dialog_token,
-				     u16 status_code,  u32 peer_capability,
-				     bool initiator, const u8 *buf, size_t len)
+					 struct net_device *ndev, const u8 *peer,
+					 u8 action_code, u8 dialog_token,
+					 u16 status_code,  u32 peer_capability,
+					 bool initiator, const u8 *buf, size_t len)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	struct sk_buff *tdls_skb;
@@ -2843,7 +2878,7 @@ static int sprdwl_cfg80211_tdls_mgmt(struct wiphy *wiphy,
 	int ret = 0;
 
 	wl_ndev_log(L_DBG, ndev, "%s action_code=%d(%pM)\n", __func__,
-		    action_code, peer);
+			action_code, peer);
 
 	datalen = sizeof(*p) + len + sizeof(end);
 	ielen = len + sizeof(end);
@@ -2921,8 +2956,8 @@ static int sprdwl_cfg80211_tdls_mgmt(struct wiphy *wiphy,
 }
 
 static int sprdwl_cfg80211_tdls_oper(struct wiphy *wiphy,
-				     struct net_device *ndev, const u8 *peer,
-				     enum nl80211_tdls_operation oper)
+					 struct net_device *ndev, const u8 *peer,
+					 enum nl80211_tdls_operation oper)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	int ret;
@@ -2947,7 +2982,7 @@ static int sprdwl_cfg80211_tdls_oper(struct wiphy *wiphy,
 		for (i = 0; i < MAX_LUT_NUM; i++) {
 			if ((0 == memcmp(intf->peer_entry[i].tx.da,
 					 peer, ETH_ALEN)) &&
-			    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+				(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
 				wl_info("%s, %d, lut_index=%d\n",
 					__func__, __LINE__,
 					intf->peer_entry[i].lut_index);
@@ -2961,9 +2996,9 @@ static int sprdwl_cfg80211_tdls_oper(struct wiphy *wiphy,
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
 static int sprdwl_cfg80211_tdls_chan_switch(struct wiphy *wiphy,
-					    struct net_device *ndev,
-					    const u8 *addr, u8 oper_class,
-					    struct cfg80211_chan_def *chandef)
+						struct net_device *ndev,
+						const u8 *addr, u8 oper_class,
+						struct cfg80211_chan_def *chandef)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	u8 chan, band;
@@ -2977,8 +3012,8 @@ static int sprdwl_cfg80211_tdls_chan_switch(struct wiphy *wiphy,
 }
 
 static void sprdwl_cfg80211_tdls_cancel_chan_switch(struct wiphy *wiphy,
-						    struct net_device *ndev,
-						    const u8 *addr)
+							struct net_device *ndev,
+							const u8 *addr)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
@@ -3004,7 +3039,7 @@ int sprdwl_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
 	wl_ndev_log(L_DBG, ndev, "%s rssi_thold %d rssi_hyst %d",
-		    __func__, rssi_thold, rssi_hyst);
+			__func__, rssi_thold, rssi_hyst);
 
 	return sprdwl_set_cqm_rssi(vif->priv, vif->ctx_id,
 				   rssi_thold, rssi_hyst);
@@ -3028,13 +3063,13 @@ int sprdwl_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *ndev,
 	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
 
 	return sprdwl_set_roam_offload(vif->priv, vif->ctx_id,
-				       SPRDWL_ROAM_OFFLOAD_SET_FTIE,
-				       ftie->ie, ftie->ie_len);
+					   SPRDWL_ROAM_OFFLOAD_SET_FTIE,
+					   ftie->ie, ftie->ie_len);
 }
 
 static int sprdwl_cfg80211_set_qos_map(struct wiphy *wiphy,
-				       struct net_device *ndev,
-				       struct cfg80211_qos_map *qos_map)
+					   struct net_device *ndev,
+					   struct cfg80211_qos_map *qos_map)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
@@ -3045,9 +3080,9 @@ static int sprdwl_cfg80211_set_qos_map(struct wiphy *wiphy,
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
 static int sprdwl_cfg80211_add_tx_ts(struct wiphy *wiphy,
-				     struct net_device *ndev,
-				     u8 tsid, const u8 *peer,
-				     u8 user_prio, u16 admitted_time)
+					 struct net_device *ndev,
+					 u8 tsid, const u8 *peer,
+					 u8 user_prio, u16 admitted_time)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
@@ -3058,8 +3093,8 @@ static int sprdwl_cfg80211_add_tx_ts(struct wiphy *wiphy,
 }
 
 static int sprdwl_cfg80211_del_tx_ts(struct wiphy *wiphy,
-				     struct net_device *ndev,
-				     u8 tsid, const u8 *peer)
+					 struct net_device *ndev,
+					 u8 tsid, const u8 *peer)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 
@@ -3070,8 +3105,8 @@ static int sprdwl_cfg80211_del_tx_ts(struct wiphy *wiphy,
 #endif
 
 static int sprdwl_cfg80211_set_mac_acl(struct wiphy *wiphy,
-				       struct net_device *ndev,
-				       const struct cfg80211_acl_data *acl)
+					   struct net_device *ndev,
+					   const struct cfg80211_acl_data *acl)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	int index, num;
@@ -3079,7 +3114,7 @@ static int sprdwl_cfg80211_set_mac_acl(struct wiphy *wiphy,
 	unsigned char *mac_addr = NULL;
 
 	if (!acl || !acl->n_acl_entries) {
-		wl_ndev_log(L_ERR, ndev, "%s no ACL data\n", __func__);
+		//wl_ndev_log(L_ERR, ndev, "%s no ACL data\n", __func__);
 		return 0;
 	}
 
@@ -3103,18 +3138,18 @@ static int sprdwl_cfg80211_set_mac_acl(struct wiphy *wiphy,
 
 	for (index = 0; index < num; index++) {
 		wl_ndev_log(L_DBG, ndev, "%s  MAC: %pM\n", __func__,
-			    &acl->mac_addrs[index]);
+				&acl->mac_addrs[index]);
 		memcpy(mac_addr + index * ETH_ALEN,
-		       &acl->mac_addrs[index], ETH_ALEN);
+			   &acl->mac_addrs[index], ETH_ALEN);
 	}
 
 	if (mode == SPRDWL_ACL_MODE_WHITELIST)
 		return sprdwl_set_whitelist(vif->priv, vif->ctx_id,
-					    SPRDWL_SUBCMD_ENABLE,
-					    num, mac_addr);
+						SPRDWL_SUBCMD_ENABLE,
+						num, mac_addr);
 	else
 		return sprdwl_set_blacklist(vif->priv, vif->ctx_id,
-					    SPRDWL_SUBCMD_ADD, num, mac_addr);
+						SPRDWL_SUBCMD_ADD, num, mac_addr);
 }
 
 int sprdwl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
@@ -3130,7 +3165,7 @@ int sprdwl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
 #ifdef ACS_SUPPORT
 static int
 sprdwl_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *ndev,
-			    int idx, struct survey_info *s_info)
+				int idx, struct survey_info *s_info)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	struct sprdwl_survey_info *info = NULL;
@@ -3180,7 +3215,7 @@ sprdwl_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *ndev,
 		/* There are no more survey info in list */
 		err = -ENOENT;
 		wl_ndev_log(L_DBG, vif->ndev, "%s report %d surveys\n",
-			    __func__, survey_count);
+				__func__, survey_count);
 		survey_count = 0;
 	}
 
@@ -3251,6 +3286,7 @@ static struct cfg80211_ops sprdwl_cfg80211_ops = {
 	.remain_on_channel = sprdwl_cfg80211_remain_on_channel,
 	.cancel_remain_on_channel = sprdwl_cfg80211_cancel_remain_on_channel,
 	.mgmt_tx = sprdwl_cfg80211_mgmt_tx,
+	//.mgmt_frame_register = sprdwl_cfg80211_mgmt_frame_register,
 	.update_mgmt_frame_registrations = sprdwl_cfg80211_mgmt_frame_register,
 	.set_power_mgmt = sprdwl_cfg80211_set_power_mgmt,
 	.set_cqm_rssi_config = sprdwl_cfg80211_set_cqm_rssi_config,
@@ -3326,7 +3362,7 @@ void sprdwl_save_ch_info(struct sprdwl_priv *priv, u32 band, u32 flags, int cent
 
 #if defined(CONFIG_CFG80211_INTERNAL_REGDB) && !defined(CUSTOM_REGDOMAIN)
 static void sprdwl_reg_notify(struct wiphy *wiphy,
-			      struct regulatory_request *request)
+				  struct regulatory_request *request)
 {
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
 	struct sprdwl_intf *intf = (struct sprdwl_intf *)priv->hw_priv;
@@ -3363,7 +3399,7 @@ static void sprdwl_reg_notify(struct wiphy *wiphy,
 			chan = &sband->channels[channel];
 
 			reg_rule =
-			    freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+				freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
 			if (IS_ERR(reg_rule))
 				continue;
 
@@ -3379,12 +3415,12 @@ static void sprdwl_reg_notify(struct wiphy *wiphy,
 	}
 
 	rd_size = sizeof(struct sprdwl_ieee80211_regdomain) +
-	    n_rules * sizeof(struct ieee80211_reg_rule);
+		n_rules * sizeof(struct ieee80211_reg_rule);
 
 	rd = kzalloc(rd_size, GFP_KERNEL);
 	if (!rd) {
 		wl_err("%s failed to alloc sprdwl_ieee80211_regdomain!\n",
-		       __func__);
+			   __func__);
 		return;
 	}
 
@@ -3412,17 +3448,17 @@ static void sprdwl_reg_notify(struct wiphy *wiphy,
 				intf->sta_home_channel = 0;
 #endif
 			reg_rule =
-			    freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+				freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
 			if (IS_ERR(reg_rule))
 				continue;
 
 			freq_range = &reg_rule->freq_range;
 			if (last_start_freq != freq_range->start_freq_khz &&
-			    i < n_rules) {
+				i < n_rules) {
 				last_start_freq = freq_range->start_freq_khz;
 
 				memcpy(&rd->reg_rules[i], reg_rule,
-				       sizeof(struct ieee80211_reg_rule));
+					   sizeof(struct ieee80211_reg_rule));
 				i++;
 
 				wl_info(
@@ -3436,7 +3472,7 @@ static void sprdwl_reg_notify(struct wiphy *wiphy,
 	}
 
 	print_hex_dump_debug("regdom:", DUMP_PREFIX_OFFSET, 16, 1,
-			     rd, rd_size, true);
+				 rd, rd_size, true);
 	if (sprdwl_set_regdom(priv, (u8 *)rd, rd_size))
 		wl_err("%s failed to set regdomain!\n", __func__);
 	if (rd != NULL) {
@@ -3446,7 +3482,7 @@ static void sprdwl_reg_notify(struct wiphy *wiphy,
 }
 #else
 void sprdwl_reg_notify(struct wiphy *wiphy,
-			      struct regulatory_request *request)
+				  struct regulatory_request *request)
 {
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
 #ifdef STA_SOFTAP_SCC_MODE
@@ -3504,7 +3540,7 @@ void sprdwl_reg_notify(struct wiphy *wiphy,
 			chan = &sband->channels[channel];
 
 			reg_rule =
-			    sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
+				sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
 			if (IS_ERR(reg_rule)) {
 				wl_debug("%s, %d, chan=%d\n", __func__, __LINE__, (int)(chan->center_freq));
 				continue;
@@ -3523,15 +3559,15 @@ void sprdwl_reg_notify(struct wiphy *wiphy,
 
 	rd_size = sizeof(struct sprdwl_ieee80211_regdomain) +
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
-	    n_rules * sizeof(struct ieee80211_reg_rule);
+		n_rules * sizeof(struct ieee80211_reg_rule);
 #else
-	    n_rules * sizeof(struct unisoc_reg_rule);
+		n_rules * sizeof(struct unisoc_reg_rule);
 #endif
 
 	rd = kzalloc(rd_size, GFP_KERNEL);
 	if (!rd) {
 		wl_err("%s failed to alloc sprdwl_ieee80211_regdomain!\n",
-		       __func__);
+			   __func__);
 		return;
 	}
 
@@ -3560,17 +3596,17 @@ void sprdwl_reg_notify(struct wiphy *wiphy,
 #endif
 
 			reg_rule =
-			     sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
+				 sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
 			if (IS_ERR(reg_rule))
 				continue;
 
 			freq_range = &reg_rule->freq_range;
 			if (last_start_freq != freq_range->start_freq_khz &&
-			    i < n_rules) {
+				i < n_rules) {
 				last_start_freq = freq_range->start_freq_khz;
 
 				memcpy(&rd->reg_rules[i], reg_rule,
-				       sizeof(struct ieee80211_reg_rule));
+					   sizeof(struct ieee80211_reg_rule));
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
 				rd->reg_rules[i].dfs_cac_ms = 0;
 #endif
@@ -3587,7 +3623,7 @@ void sprdwl_reg_notify(struct wiphy *wiphy,
 	}
 
 	wl_hex_dump(L_DBG, "regdom:", DUMP_PREFIX_OFFSET, 16, 1,
-			     rd, rd_size, true);
+				 rd, rd_size, true);
 	if (sprdwl_set_regdom(priv, (u8 *)rd, rd_size))
 		wl_err("%s failed to set regdomain!\n", __func__);
 
@@ -3642,8 +3678,8 @@ void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv)
 
 	wiphy->mgmt_stypes = sprdwl_mgmt_stypes;
 	wiphy->interface_modes =
-	    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
-	    BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT);
+		BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+		BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT);
 #ifndef CONFIG_P2P_INTF
 	wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
 #endif
@@ -3788,9 +3824,9 @@ void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv)
 
 #if !defined (CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-		wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
 #else
-		wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
 #endif
 		alpha2[0] = '0';
 		alpha2[1] = '0';
@@ -3809,9 +3845,9 @@ void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv)
 	} else {
 		wl_info("\tSCC supported\n");
 		wiphy->software_iftypes =
-		    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
-		    BIT(NL80211_IFTYPE_P2P_CLIENT) |
-		    BIT(NL80211_IFTYPE_P2P_GO);
+			BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+			BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			BIT(NL80211_IFTYPE_P2P_GO);
 #ifndef CONFIG_P2P_INTF
 		wiphy->software_iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
 #endif
@@ -3829,7 +3865,7 @@ void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv)
 	}
 #if 0
 	if (priv->fw_capa & SPRDWL_CAPA_PMK_OKC_OFFLOAD &&
-	    priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD) {
+		priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD) {
 		wl_info("\tRoaming offload supported\n");
 		wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 	}
@@ -3880,7 +3916,7 @@ static void sprdwl_check_intf_ops(struct sprdwl_if_ops *ops)
 }
 
 struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
-				       struct sprdwl_if_ops *ops)
+					   struct sprdwl_if_ops *ops)
 {
 	struct wiphy *wiphy;
 	struct sprdwl_priv *priv;
@@ -3901,7 +3937,7 @@ struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
 	wl_info("hw_type:%d\n", priv->hw_type);
 
 	priv->skb_head_len = sizeof(struct sprdwl_data_hdr) + NET_IP_ALIGN +
-	    SPRDWL_SKB_HEAD_RESERV_LEN + 3;
+		SPRDWL_SKB_HEAD_RESERV_LEN + 3;
 
 	priv->if_ops = ops;
 
@@ -3909,7 +3945,7 @@ struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
 	timer_setup(&priv->scan_timer, sprdwl_scan_timeout, 0);
 #else
 	setup_timer(&priv->scan_timer, sprdwl_scan_timeout,
-		    (unsigned long)priv);
+			(unsigned long)priv);
 #endif
 
 #ifdef WMMAC_WFA_CERTIFICATION
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
index d4ffe102447c..380e7da5f442 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
@@ -21,15 +21,6 @@
 #include <net/cfg80211.h>
 #include <linux/version.h>
 
-#ifndef timespec
-#define timespec timespec64
-#define timespec_to_ns timespec64_to_ns
-#define getnstimeofday ktime_get_real_ts64
-#define timeval __kernel_old_timeval
-#define rtc_time_to_tm rtc_time64_to_tm
-#define timeval_to_ns ktime_to_ns
-#endif
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
 #define NL80211_SCAN_FLAG_RANDOM_ADDR          (1<<3)
 
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
index 8a3081fb819c..55c76b74195a 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
@@ -257,7 +257,11 @@ int sprdwl_cmd_init(void)
 	cmd->wake_lock = wakeup_source_register(sprdwl_dev,
 						"Wi-Fi_cmd_wakelock");
 #else
-	cmd->wake_lock = wakeup_source_register(NULL,"Wi-Fi_cmd_wakelock");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	cmd->wake_lock = wakeup_source_register("Wi-Fi_cmd_wakelock");
+#else
+	cmd->wake_lock = wakeup_source_register(sprdwl_dev, "Wi-Fi_cmd_wakelock");
+#endif
 #endif
 	if (!cmd->wake_lock) {
 		wl_err("%s wakeup source register error.\n", __func__);
@@ -288,7 +292,7 @@ static void sprdwl_cmd_set(struct sprdwl_cmd_hdr *hdr)
 	ktime_t kt;
 
 	kt = ktime_get();
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 	msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
 #else
 	msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
@@ -349,8 +353,8 @@ static int sprdwl_cmd_lock(struct sprdwl_cmd *cmd)
 	if (atomic_inc_return(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
 		atomic_dec(&cmd->refcnt);
 		wl_err("%s failed, cmd->refcnt=%d\n",
-		       __func__,
-		       atomic_read(&cmd->refcnt));
+			   __func__,
+			   atomic_read(&cmd->refcnt));
 		return -1;
 	}
 	mutex_lock(&cmd->cmd_lock);
@@ -396,6 +400,7 @@ struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
 	struct sprdwl_cmd_hdr *hdr;
 	u16 plen = sizeof(*hdr) + len;
 	enum sprdwl_mode mode = SPRDWL_MODE_NONE;/*default to open new device*/
+#if defined(UWE5621_FTR)
 	void *data = NULL;
 	struct sprdwl_vif *vif;
 	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
@@ -405,12 +410,12 @@ struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
 
 #ifdef CP2_RESET_SUPPORT
 	if ((g_sprdwl_priv->sync.scan_not_allowed == true) &&
-		(g_sprdwl_priv->sync.cmd_not_allowed == false)) {
+	   (g_sprdwl_priv->sync.cmd_not_allowed == false)) {
 		if ((cmd_id != WIFI_CMD_SYNC_VERSION) &&
-			(cmd_id != WIFI_CMD_DOWNLOAD_INI) &&
-			(cmd_id != WIFI_CMD_GET_INFO) &&
-			(cmd_id != WIFI_CMD_OPEN) &&
-			(cmd_id != WIFI_CMD_SET_REGDOM)) {
+		   (cmd_id != WIFI_CMD_DOWNLOAD_INI) &&
+		   (cmd_id != WIFI_CMD_GET_INFO) &&
+		   (cmd_id != WIFI_CMD_OPEN) &&
+		   (cmd_id != WIFI_CMD_SET_REGDOM)) {
 			   return NULL;
 		}
 	}
@@ -419,20 +424,22 @@ struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
 	if (cmd_id >= WIFI_CMD_OPEN) {
 		vif = ctx_id_to_vif(priv, ctx_id);
 		if (!vif)
-			wl_err("%s cant't get vif, ctx_id: %d\n",
-			       __func__, ctx_id);
+			;
+			//wl_err("%s cant't get vif, ctx_id: %d\n",
+			//	   __func__, ctx_id);
 		else
 			mode =  vif->mode;
 		sprdwl_put_vif(vif);
 	}
-
+#endif
 	msg = sprdwl_intf_get_msg_buf(priv, SPRDWL_TYPE_CMD, mode, ctx_id);
 	if (!msg) {
 		wl_err("%s, %d, getmsgbuf fail, mode=%d\n",
-		       __func__, __LINE__, mode);
+			   __func__, __LINE__, mode);
 		return NULL;
 	}
 
+#if defined(UWE5621_FTR)
 	data = kzalloc((plen + priv->hw_offset), flags);
 	if (data) {
 		hdr = (struct sprdwl_cmd_hdr *)(data + priv->hw_offset);
@@ -449,7 +456,25 @@ struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
 		sprdwl_intf_free_msg_buf(priv, msg);
 		return NULL;
 	}
-
+#else
+	msg->skb = dev_alloc_skb(plen);
+	if (msg->skb) {
+		memset(msg->skb->data, 0, plen);
+		hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+		hdr->common.type = SPRDWL_TYPE_CMD;
+		hdr->common.reserv = 0;
+		hdr->common.rsp = rsp;
+		hdr->common.ctx_id = ctx_id;
+		hdr->plen = cpu_to_le16(plen);
+		hdr->cmd_id = cmd_id;
+		sprdwl_fill_msg(msg, msg->skb, msg->skb->data, plen);
+		msg->data = hdr + 1;
+	} else {
+		wl_err("%s failed to allocate skb\n", __func__);
+		sprdwl_intf_free_msg_buf(priv, msg);
+		return NULL;
+	}
+#endif
 	return msg;
 }
 
@@ -463,7 +488,11 @@ static int sprdwl_cmd_send_to_ic(struct sprdwl_priv *priv,
 	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
 	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
 
+#if defined(UWE5621_FTR)
 	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
 	/*TODO:consider common this if condition since
 	 * SPRDWL_HEAD_NORSP not used any more
 	 */
@@ -517,7 +546,7 @@ static int sprdwl_atcmd_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_i
 	u8 idx = 0;
 
 	wl_err("%s ctx_id:%d, cmd_id:%d, reason:%d, cp_asserted:%d\n",
-	       __func__, vif_ctx_id, cmd_id, reason, intf->cp_asserted);
+		   __func__, vif_ctx_id, cmd_id, reason, intf->cp_asserted);
 
 	if (intf->cp_asserted == 0) {
 		intf->cp_asserted = 1;
@@ -566,15 +595,22 @@ int sprdwl_cmd_send_recv(struct sprdwl_priv *priv,
 	ret = sprdwl_api_available_check(priv, msg);
 	if (ret || sprdwl_cmd_lock(cmd)) {
 		sprdwl_intf_free_msg_buf(priv, msg);
+#if defined(UWE5621_FTR)
 		kfree(msg->tran_data);
+#else
+		dev_kfree_skb(msg->skb);
+#endif
 		if (rlen)
 			*rlen = 0;
 		if (ret)
 			wl_err("API check fail, return!!\n");
 		goto out;
 	}
-
+#if defined(UWE5621_FTR)
 	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
 	cmd_id = hdr->cmd_id;
 	ctx_id = hdr->common.ctx_id;
 
@@ -617,8 +653,8 @@ int sprdwl_cmd_send_recv(struct sprdwl_priv *priv,
 		}
 	} else {
 		wl_err("ctx_id:%d cmd: %s[%d] rsp timeout (mstime = %d), num=%d\n",
-		       ctx_id, cmd2str(cmd_id), cmd_id, le32_to_cpu(hdr->mstime),
-		       tx_msg->cmd_send);
+			   ctx_id, cmd2str(cmd_id), cmd_id, le32_to_cpu(cmd->mstime),
+			   tx_msg->cmd_send);
 		if (cmd_id == WIFI_CMD_CLOSE) {
 			sprdwl_atcmd_assert(priv, ctx_id, cmd_id, CMD_RSP_TIMEOUT_ERROR);
 			sprdwl_cmd_unlock(cmd);
@@ -656,11 +692,18 @@ int sprdwl_cmd_send_recv_no_wait(struct sprdwl_priv *priv,
 	if (sprdwl_cmd_lock(cmd)) {
 		wl_err("%s, %d, error!\n", __func__, __LINE__);
 		sprdwl_intf_free_msg_buf(priv, msg);
+#if defined(UWE5621_FTR)
 		kfree(msg->tran_data);
+#else
+		dev_kfree_skb(msg->skb);
+#endif
 		goto out;
 	}
-
+#if defined(UWE5621_FTR)
 	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
 	cmd_id = hdr->cmd_id;
 	ctx_id = hdr->common.ctx_id;
 
@@ -822,20 +865,31 @@ int sprdwl_get_fw_info(struct sprdwl_priv *priv)
 	u16 r_len = sizeof(*p) + GET_INFO_TLV_RBUF_SIZE;
 	u16 r_len_ori = r_len;
 	u8 r_buf[r_len];
+#ifdef COMPAT_SAMPILE_CODE
 	u8 compat_ver = 0;
+#endif
 	unsigned int len_count = 0;
 	bool b_tlv_data_chk = true;
-	u16 tlv_len = sizeof(struct ap_version_tlv_elmt);
+	u16 tlv_len;
 #ifdef WL_CONFIG_DEBUG
 	u8 ap_version = NOTIFY_AP_VERSION_USER_DEBUG;
 #else
 	u8 ap_version = NOTIFY_AP_VERSION_USER;
 #endif
-
+	u16 offset = 0;
 #ifdef OTT_UWE
+	u8 bytes_allign = 1;
 #define OTT_UWE_OFFSET_ENABLE 1
-	tlv_len += 1;
 #endif
+	u8 credit_via_data = 1;
+
+	tlv_len = sizeof(*tlv) + 1;
+#ifdef OTT_UWE
+	tlv_len += (sizeof(*tlv) + 1);
+#endif
+
+	if (priv->hw_type == SPRDWL_HW_USB)
+		tlv_len += (sizeof(*tlv) + 1);
 
 	memset(r_buf, 0, r_len);
 	msg = sprdwl_cmd_getbuf(priv, tlv_len, SPRDWL_MODE_NONE,
@@ -843,6 +897,7 @@ int sprdwl_get_fw_info(struct sprdwl_priv *priv)
 	if (!msg)
 		return -ENOMEM;
 
+#ifdef COMPAT_SAMPILE_CODE
 	compat_ver = need_compat_operation(priv, WIFI_CMD_GET_INFO);
 	if (compat_ver) {
 		switch (compat_ver) {
@@ -862,16 +917,25 @@ int sprdwl_get_fw_info(struct sprdwl_priv *priv)
 			break;
 		}
 	}
+#endif
 
-	sprdwl_set_tlv_elmt((u8 *)msg->data, NOTIFY_AP_VERSION,
+	/*to notify CP2 use more CP2 buffer*/
+	sprdwl_set_tlv_elmt((u8 *)(msg->data + offset), NOTIFY_AP_VERSION,
 				sizeof(ap_version), &ap_version);
-
+	offset += (sizeof(*tlv) + 1);
 #ifdef OTT_UWE
-	tlv = (struct sprdwl_tlv_data *)msg->data;
-	tlv->type = OTT_UWE_OFFSET_ENABLE;
-	tlv->len = 1;
-	*((char *)tlv->data) = 1;
+	/*to notify CP2 this is OTT version ,4bytes allign*/
+	sprdwl_set_tlv_elmt((u8 *)(msg->data + offset), OTT_UWE_OFFSET_ENABLE,
+				sizeof(bytes_allign), &bytes_allign);
+	offset += (sizeof(*tlv) + 1);
 #endif
+	if (priv->hw_type == SPRDWL_HW_USB) {
+		/*to notify CP2 data credit disable*/
+		sprdwl_set_tlv_elmt((u8 *)(msg->data + offset), NOTIFY_CREDIT_VIA_RX_DATA,
+				sizeof(credit_via_data), &credit_via_data);
+		offset += (sizeof(*tlv) + 1);
+	}
+
 	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
 	if (!ret && r_len) {
 #if defined COMPAT_SAMPILE_CODE
@@ -950,7 +1014,7 @@ int sprdwl_get_fw_info(struct sprdwl_priv *priv)
 
 				if (b_tlv_data_chk == false) {
 					wl_err("%s TLV check failed: type=%d, len=%d\n",
-					       __func__, tlv->type, tlv->len);
+						   __func__, tlv->type, tlv->len);
 					goto out;
 				}
 
@@ -965,7 +1029,7 @@ int sprdwl_get_fw_info(struct sprdwl_priv *priv)
 
 			if (len_count != r_len) {
 				wl_err("%s length mismatch: len_count=%d, r_len=%d\n",
-				       __func__, len_count, r_len);
+					   __func__, len_count, r_len);
 				goto out;
 			}
 		}
@@ -1056,7 +1120,7 @@ int sprdwl_open_fw(struct sprdwl_priv *priv, u8 *vif_ctx_id,
 	}
 
 	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
-				    vif_ctx_id, &rlen);
+					vif_ctx_id, &rlen);
 }
 
 int sprdwl_close_fw(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 mode)
@@ -1077,7 +1141,7 @@ int sprdwl_close_fw(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 mode)
 }
 
 int sprdwl_power_save(struct sprdwl_priv *priv, u8 vif_ctx_id,
-		       u8 sub_type, u8 status)
+			   u8 sub_type, u8 status)
 {
 	int ret;
 	s32 ret_code;
@@ -1138,7 +1202,7 @@ int sprdwl_add_key(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *key_data,
 }
 
 int sprdwl_del_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 key_index,
-		    bool pairwise, const u8 *mac_addr)
+			bool pairwise, const u8 *mac_addr)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_del_key *p;
@@ -1222,7 +1286,7 @@ int sprdwl_set_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
 
 #ifdef DFS_MASTER
 int sprdwl_reset_beacon(struct sprdwl_priv *priv,
-		     u8 vif_ctx_id, const u8 *beacon, u16 len)
+			 u8 vif_ctx_id, const u8 *beacon, u16 len)
 {
 	struct sprdwl_msg_buf *msg;
 
@@ -1238,7 +1302,7 @@ int sprdwl_reset_beacon(struct sprdwl_priv *priv,
 #endif
 
 int sprdwl_start_ap(struct sprdwl_priv *priv,
-		     u8 vif_ctx_id, u8 *beacon, u16 len)
+			 u8 vif_ctx_id, u8 *beacon, u16 len)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_start_ap *p;
@@ -1257,7 +1321,7 @@ int sprdwl_start_ap(struct sprdwl_priv *priv,
 }
 
 int sprdwl_del_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
-		       const u8 *mac_addr, u16 reason_code)
+			   const u8 *mac_addr, u16 reason_code)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_del_station *p;
@@ -1346,16 +1410,16 @@ int sprdwl_scan(struct sprdwl_priv *priv, u8 vif_ctx_id,
 	}
 
 	wl_hex_dump(L_DBG, "scan hex:", DUMP_PREFIX_OFFSET,
-			     16, 1, p, data_len, true);
+				 16, 1, p, data_len, true);
 
 	rlen = sizeof(state);
 
 	return	sprdwl_cmd_send_recv(priv, msg, CMD_SCAN_WAIT_TIMEOUT,
-			     (u8 *)&state, &rlen);
+				 (u8 *)&state, &rlen);
 }
 
 int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			     struct sprdwl_sched_scan_buf *buf)
+				 struct sprdwl_sched_scan_buf *buf)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_sched_scan_hd *sscan_head = NULL;
@@ -1366,12 +1430,12 @@ int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
 	int len = 0, i, hd_len;
 
 	datalen = sizeof(*sscan_head) + sizeof(*ie_head) + sizeof(*sscan_ifrc)
-	    + buf->n_ssids * IEEE80211_MAX_SSID_LEN
-	    + buf->n_match_ssids * IEEE80211_MAX_SSID_LEN + buf->ie_len;
+		+ buf->n_ssids * IEEE80211_MAX_SSID_LEN
+		+ buf->n_match_ssids * IEEE80211_MAX_SSID_LEN + buf->ie_len;
 	hd_len = sizeof(*ie_head);
 	datalen = datalen + (buf->n_ssids ? hd_len : 0)
-	    + (buf->n_match_ssids ? hd_len : 0)
-	    + (buf->ie_len ? hd_len : 0);
+		+ (buf->n_match_ssids ? hd_len : 0)
+		+ (buf->ie_len ? hd_len : 0);
 
 	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
 				SPRDWL_HEAD_RSP, WIFI_CMD_SCHED_SCAN);
@@ -1406,7 +1470,7 @@ int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
 		len += sizeof(*ie_head);
 		for (i = 0; i < buf->n_ssids; i++) {
 			memcpy((p + len + i * IEEE80211_MAX_SSID_LEN),
-			       buf->ssid[i], IEEE80211_MAX_SSID_LEN);
+				   buf->ssid[i], IEEE80211_MAX_SSID_LEN);
 		}
 		len += ie_head->ie_len;
 	}
@@ -1418,7 +1482,7 @@ int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
 		len += sizeof(*ie_head);
 		for (i = 0; i < buf->n_match_ssids; i++) {
 			memcpy((p + len + i * IEEE80211_MAX_SSID_LEN),
-			       buf->mssid[i], IEEE80211_MAX_SSID_LEN);
+				   buf->mssid[i], IEEE80211_MAX_SSID_LEN);
 		}
 		len += ie_head->ie_len;
 	}
@@ -1455,7 +1519,7 @@ int sprdwl_sched_scan_stop(struct sprdwl_priv *priv, u8 vif_ctx_id)
 }
 
 int sprdwl_connect(struct sprdwl_priv *priv, u8 vif_ctx_id,
-		    struct sprdwl_cmd_connect *p)
+			struct sprdwl_cmd_connect *p)
 {
 	struct sprdwl_msg_buf *msg;
 
@@ -1534,12 +1598,16 @@ int sprdwl_set_qos_map(struct sprdwl_priv *priv, u8 vif_ctx_id, void *qos_map)
 	if (!qos_map)
 		return 0;
 	msg =
-	    sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
-			      WIFI_CMD_SET_QOS_MAP);
+		sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+				  WIFI_CMD_SET_QOS_MAP);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprdwl_cmd_qos_map *)msg->data;
+#else
+	p = (struct sprdwl_cmd_qos_map *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	memset((u8 *)p, 0, sizeof(*p));
 	memcpy((u8 *)p, qos_map, sizeof(*p));
 	memcpy(&g_11u_qos_map.qos_exceptions[0], &p->dscp_exception[0],
@@ -1565,8 +1633,12 @@ int sprdwl_gscan_subcmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
 
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = subcmd;
 
 	if (data != NULL) {
@@ -1580,7 +1652,7 @@ int sprdwl_gscan_subcmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
 }
 
 int sprdwl_set_gscan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			    void *data, u16 len, u8 *r_buf, u16 *r_len)
+				void *data, u16 len, u8 *r_buf, u16 *r_len)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprd_cmd_gscan_header *p;
@@ -1589,8 +1661,12 @@ int sprdwl_set_gscan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
 				vif_ctx_id, 1, WIFI_CMD_GSCAN);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_CONFIG;
 	p->data_len = len;
 	memcpy(p->data, data, len);
@@ -1607,8 +1683,12 @@ int sprdwl_set_gscan_scan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
 				vif_ctx_id, 1, WIFI_CMD_GSCAN);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)(msg->skb->data +
+						 sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_SCAN_CONFIG;
 	p->data_len = len;
 	memcpy(p->data, data, len);
@@ -1625,8 +1705,12 @@ int sprdwl_enable_gscan(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
 				vif_ctx_id, 1, WIFI_CMD_GSCAN);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN;
 	p->data_len = sizeof(int);
 	memcpy(p->data, data, p->data_len);
@@ -1643,8 +1727,12 @@ int sprdwl_get_gscan_capabilities(struct sprdwl_priv *priv, u8 vif_ctx_id,
 				SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES;
 	p->data_len = 0;
 
@@ -1663,19 +1751,29 @@ int sprdwl_get_gscan_channel_list(struct sprdwl_priv *priv, u8 vif_ctx_id,
 	if (!msg)
 		return -ENOMEM;
 
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_GSCAN_SUBCMD_GET_CHANNEL_LIST;
 	p->data_len = sizeof(*band);
 
+#if defined(UWE5621_FTR)
 	band = (int *)(msg->data + sizeof(struct sprd_cmd_gscan_header));
+#else
+	band = (int *)(msg->skb->data + sizeof(struct sprdwl_cmd_hdr) +
+			   sizeof(struct sprd_cmd_gscan_header));
+#endif
+
 	*band = *((int *)data);
 
 	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
 }
 
 int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			    void *data, u16 len, u8 *r_buf, u16 *r_len)
+				void *data, u16 len, u8 *r_buf, u16 *r_len)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprd_cmd_gscan_header *p;
@@ -1684,8 +1782,12 @@ int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
 				vif_ctx_id, 1, WIFI_CMD_GSCAN);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_HOTLIST;
 	p->data_len = len;
 	memcpy(p->data, data, len);
@@ -1693,7 +1795,7 @@ int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
 }
 
 int sprdwl_set_gscan_bssid_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			    void *data, u16 len, u8 *r_buf, u16 *r_len)
+				void *data, u16 len, u8 *r_buf, u16 *r_len)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprd_cmd_gscan_header *p;
@@ -1702,15 +1804,19 @@ int sprdwl_set_gscan_bssid_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id,
 				vif_ctx_id, 1, WIFI_CMD_GSCAN);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	p->subcmd = SPRDWL_WIFI_SUBCMD_SET_BSSID_BLACKLIST;
 	p->data_len = len;
 	memcpy(p->data, data, len);
 	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
 }
 int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
-		     const u8 *peer, u8 user_prio, u16 admitted_time)
+			 const u8 *peer, u8 user_prio, u16 admitted_time)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_tx_ts *p;
@@ -1722,8 +1828,12 @@ int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
 				WIFI_CMD_ADD_TX_TS);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprdwl_cmd_tx_ts *)msg->data;
+#else
+	p = (struct sprdwl_cmd_tx_ts *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	memset((u8 *)p, 0, sizeof(*p));
 
 	p->tsid = tsid;
@@ -1740,7 +1850,7 @@ int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
 }
 
 int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
-		     const u8 *peer)
+			 const u8 *peer)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_tx_ts *p;
@@ -1749,8 +1859,12 @@ int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
 				WIFI_CMD_DEL_TX_TS);
 	if (!msg)
 		return -ENOMEM;
-
+#if defined(UWE5621_FTR)
 	p = (struct sprdwl_cmd_tx_ts *)msg->data;
+#else
+	p = (struct sprdwl_cmd_tx_ts *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
 	memset((u8 *)p, 0, sizeof(*p));
 
 	p->tsid = tsid;
@@ -1764,9 +1878,9 @@ int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
 }
 
 int sprdwl_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
-		       struct ieee80211_channel *channel,
-		       enum nl80211_channel_type channel_type,
-		       u32 duration, u64 *cookie)
+			   struct ieee80211_channel *channel,
+			   enum nl80211_channel_type channel_type,
+			   u32 duration, u64 *cookie)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_remain_chan *p;
@@ -1785,7 +1899,7 @@ int sprdwl_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
 }
 
 int sprdwl_cancel_remain_chan(struct sprdwl_priv *priv,
-			       u8 vif_ctx_id, u64 cookie)
+				   u8 vif_ctx_id, u64 cookie)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_cancel_remain_chan *p;
@@ -1886,7 +2000,7 @@ int sprdwl_set_cqm_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id,
 }
 
 int sprdwl_set_roam_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			    u8 sub_type, const u8 *data, u8 len)
+				u8 sub_type, const u8 *data, u8 len)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_roam_offload_data *p;
@@ -1909,19 +2023,37 @@ int sprdwl_set_roam_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
 
 int sprdwl_tdls_mgmt(struct sprdwl_vif *vif, struct sk_buff *skb)
 {
+#ifndef UWE5621_FTR
+	struct sprdwl_msg_buf *msg;
+#endif
 	int ret;
 
+#ifndef UWE5621_FTR
+	msg = sprdwl_intf_get_msg_buf(vif->priv, SPRDWL_TYPE_DATA,
+					   SPRDWL_MODE_STATION, vif->ctx_id);
+	if (!msg) {
+		if (vif->priv->hw_type == SPRDWL_HW_SDIO_BA)
+			sprdwl_stop_net(vif);
+		vif->ndev->stats.tx_fifo_errors++;
+		wl_err("%s, %d, get msg bug failed\n", __func__, __LINE__);
+		return -NETDEV_TX_BUSY;
+	}
+#endif
 	/* temp debug use */
 	if (skb_headroom(skb) < vif->ndev->needed_headroom)
 		wl_err("%s skb head len err:%d %d\n",
-		       __func__, skb_headroom(skb),
-		       vif->ndev->needed_headroom);
-
+			   __func__, skb_headroom(skb),
+			   vif->ndev->needed_headroom);
+#ifdef UWE5621_FTR
 	/*send TDLS mgmt through cmd port instead of data port,needed by CP2*/
 	ret = sprdwl_send_tdlsdata_use_cmd(skb, vif, 1);
+#else
+	/* sprdwl_send_data: offset use 2 for cp bytes align */
+	ret = sprdwl_send_data(vif, msg, skb, 2, false);
+#endif
 	if (ret) {
-		wl_err("%s drop msg due to TX Err\n",
-		       __func__);
+		//wl_err("%s drop msg due to TX Err\n",
+		//	   __func__);
 		goto out;
 	}
 
@@ -1933,14 +2065,14 @@ int sprdwl_tdls_mgmt(struct sprdwl_vif *vif, struct sk_buff *skb)
 	netif_trans_update(vif->ndev);
 #endif
 	wl_hex_dump(L_DBG, "TX packet: ", DUMP_PREFIX_OFFSET,
-			     16, 1, skb->data, skb->len, 0);
+				 16, 1, skb->data, skb->len, 0);
 
 out:
 	return ret;
 }
 
 int sprdwl_send_tdls_cmd(struct sprdwl_vif *vif, u8 vif_ctx_id, const u8 *peer,
-		     int oper)
+			 int oper)
 {
 	struct sprdwl_work *misc_work;
 	struct sprdwl_tdls_work tdls;
@@ -1964,7 +2096,7 @@ int sprdwl_send_tdls_cmd(struct sprdwl_vif *vif, u8 vif_ctx_id, const u8 *peer,
 }
 
 int sprdwl_tdls_oper(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *peer,
-		     int oper)
+			 int oper)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_tdls *p;
@@ -1982,8 +2114,8 @@ int sprdwl_tdls_oper(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *peer,
 }
 
 int sprdwl_start_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
-				     const u8 *peer_mac, u8 primary_chan,
-				     u8 second_chan_offset, u8 band)
+					 const u8 *peer_mac, u8 primary_chan,
+					 u8 second_chan_offset, u8 band)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_tdls *p;
@@ -2008,7 +2140,7 @@ int sprdwl_start_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
 }
 
 int sprdwl_cancel_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
-				      const u8 *peer_mac)
+					  const u8 *peer_mac)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_tdls *p;
@@ -2027,7 +2159,7 @@ int sprdwl_cancel_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
 }
 
 int sprdwl_notify_ip(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 ip_type,
-		     u8 *ip_addr)
+			 u8 *ip_addr)
 {
 	struct sprdwl_msg_buf *msg;
 	u8 *ip_value;
@@ -2036,7 +2168,7 @@ int sprdwl_notify_ip(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 ip_type,
 	if (ip_type != SPRDWL_IPV4 && ip_type != SPRDWL_IPV6)
 		return -EINVAL;
 	ip_len = (ip_type == SPRDWL_IPV4) ?
-	    SPRDWL_IPV4_ADDR_LEN : SPRDWL_IPV6_ADDR_LEN;
+		SPRDWL_IPV4_ADDR_LEN : SPRDWL_IPV6_ADDR_LEN;
 	msg = sprdwl_cmd_getbuf(priv, ip_len, vif_ctx_id,
 				SPRDWL_HEAD_RSP, WIFI_CMD_NOTIFY_IP_ACQUIRED);
 	if (!msg)
@@ -2141,11 +2273,11 @@ int sprdwl_set_11v_feature_support(struct sprdwl_priv *priv,
 	p->len = 8;
 
 	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
-				    (u8 *)&state, &rlen);
+					(u8 *)&state, &rlen);
 }
 
 int sprdwl_set_11v_sleep_mode(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			      u8 status, u16 interval)
+				  u8 status, u16 interval)
 {
 	struct sprdwl_msg_buf *msg = NULL;
 	struct sprdwl_cmd_rsp_state_code state;
@@ -2168,7 +2300,7 @@ int sprdwl_set_11v_sleep_mode(struct sprdwl_priv *priv, u8 vif_ctx_id,
 	p->len = 8;
 
 	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
-				    (u8 *)&state, &rlen);
+					(u8 *)&state, &rlen);
 }
 
 int sprdwl_send_ba_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id,
@@ -2327,7 +2459,7 @@ int sprdwl_xmit_data2cmd(struct sk_buff *skb, struct net_device *ndev)
 
 	if (unlikely(atomic_read(&cmd->refcnt) > 0)) {
 		wl_err("%s, cmd->refcnt = %d, Try later again\n",
-		       __func__, atomic_read(&cmd->refcnt));
+			   __func__, atomic_read(&cmd->refcnt));
 		return -EAGAIN;
 	}
 
@@ -2352,18 +2484,18 @@ int sprdwl_xmit_data2cmd(struct sk_buff *skb, struct net_device *ndev)
 	memcpy(skb->data, temp_flag, FLAG_SIZE);
 	/*malloc msg buffer*/
 	msg = sprdwl_cmd_getbuf_atomic(vif->priv, skb->len, vif->ctx_id,
-				       SPRDWL_HEAD_RSP, WIFI_CMD_TX_DATA);
+					   SPRDWL_HEAD_RSP, WIFI_CMD_TX_DATA);
 	if (!msg) {
 		wl_err("%s, %d, getmsgbuf fail, free skb\n",
-		       __func__, __LINE__);
+			   __func__, __LINE__);
 		dev_kfree_skb(skb);
 		return -ENOMEM;
 	}
 	/*send group in BK to avoid FW hang*/
 	dscr = (struct tx_msdu_dscr *)skb->data;
 	if ((vif->mode == SPRDWL_MODE_AP ||
-	     vif->mode == SPRDWL_MODE_P2P_GO) &&
-	     (dscr->sta_lut_index < 6)) {
+		 vif->mode == SPRDWL_MODE_P2P_GO) &&
+		 (dscr->sta_lut_index < 6)) {
 		dscr->buffer_info.msdu_tid = prio_1;
 		wl_info("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
 	}
@@ -2495,7 +2627,7 @@ int sprdwl_cmd_host_wakeup_fw(struct sprdwl_priv *priv, u8 ctx_id)
 	p->value = 0;
 
 	ret =  sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
-				    &r_buf, &r_len);
+					&r_buf, &r_len);
 
 	if (!ret && (1 == r_buf)) {
 		intf->fw_awake = 1;
@@ -2567,10 +2699,10 @@ unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg)
 	if (hdr->common.ctx_id >= STAP_MODE_COEXI_NUM ||
 #endif
 		hdr->cmd_id > WIFI_CMD_MAX ||
-	    plen > 2048) {
+		plen > 2048) {
 		wl_err("%s wrong CMD_RSP: ctx_id:%d;cmd_id:%d\n",
-		       __func__, hdr->common.ctx_id,
-		       hdr->cmd_id);
+			   __func__, hdr->common.ctx_id,
+			   hdr->cmd_id);
 		return 0;
 	}
 	if (atomic_inc_return(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
@@ -2588,14 +2720,14 @@ unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg)
 
 	spin_lock_bh(&cmd->lock);
 	if (!cmd->data && SPRDWL_GET_LE32(hdr->mstime) == cmd->mstime &&
-	    hdr->cmd_id == cmd->cmd_id) {
+		hdr->cmd_id == cmd->cmd_id) {
 		wl_debug("ctx_id %d recv rsp[%s]\n",
 			hdr->common.ctx_id, cmd2str(hdr->cmd_id));
 		if (unlikely(hdr->status != 0)) {
 			wl_debug("%s ctx_id %d recv rsp[%s] status[%s]\n",
-			       __func__, hdr->common.ctx_id,
-			       cmd2str(hdr->cmd_id),
-			       err2str(hdr->status));
+				   __func__, hdr->common.ctx_id,
+				   cmd2str(hdr->cmd_id),
+				   err2str(hdr->status));
 			handle_flag = handle_rsp_status_err(hdr->cmd_id,
 						hdr->status);
 		}
@@ -2603,12 +2735,12 @@ unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg)
 		complete(&cmd->completed);
 	} else {
 		kfree(data);
-		wl_err("%s ctx_id %d recv mismatched rsp[%s] status[%s]\n",
-		       __func__, hdr->common.ctx_id,
-		       cmd2str(hdr->cmd_id),
-		       err2str(hdr->status));
-		wl_err("%s mstime:[%u %u]\n", __func__,
-		       SPRDWL_GET_LE32(hdr->mstime), cmd->mstime);
+		//wl_err("%s ctx_id %d recv mismatched rsp[%s] status[%s]\n",
+		//	   __func__, hdr->common.ctx_id,
+		//	   cmd2str(hdr->cmd_id),
+		//	   err2str(hdr->status));
+		//wl_err("%s mstime:[%u %u]\n", __func__,
+		//	   SPRDWL_GET_LE32(hdr->mstime), cmd->mstime);
 	}
 	spin_unlock_bh(&cmd->lock);
 	atomic_dec(&cmd->refcnt);
@@ -2624,44 +2756,44 @@ unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg)
 void sprdwl_event_station(struct sprdwl_vif *vif, u8 *data, u16 len)
 {
 	struct sprdwl_event_new_station *sta =
-	    (struct sprdwl_event_new_station *)data;
+		(struct sprdwl_event_new_station *)data;
 
 	sprdwl_report_softap(vif, sta->is_connect,
-			     sta->mac, sta->ie, sta->ie_len);
+				 sta->mac, sta->ie, sta->ie_len);
 }
 
 void sprdwl_event_scan_done(struct sprdwl_vif *vif, u8 *data, u16 len)
 {
 	struct sprdwl_event_scan_done *p =
-	    (struct sprdwl_event_scan_done *)data;
+		(struct sprdwl_event_scan_done *)data;
 	u8 bucket_id = 0;
 
 	switch (p->type) {
 	case SPRDWL_SCAN_DONE:
 		sprdwl_scan_done(vif, false);
 		wl_ndev_log(L_DBG, vif->ndev, "%s got %d BSSes\n", __func__,
-			    bss_count);
+				bss_count);
 		break;
 	case SPRDWL_SCHED_SCAN_DONE:
 		sprdwl_sched_scan_done(vif, false);
 		wl_ndev_log(L_DBG, vif->ndev, "%s schedule scan got %d BSSes\n",
-			    __func__, bss_count);
+				__func__, bss_count);
 		break;
 	case SPRDWL_GSCAN_DONE:
 		bucket_id = ((struct sprdwl_event_gscan_done *)data)->bucket_id;
 		sprdwl_gscan_done(vif, bucket_id);
 		wl_ndev_log(L_DBG, vif->ndev, "%s gscan got %d bucketid done\n",
-			    __func__, bucket_id);
+				__func__, bucket_id);
 		break;
 	case SPRDWL_SCAN_ERROR:
 	default:
 		sprdwl_scan_done(vif, true);
 		sprdwl_sched_scan_done(vif, false);
-		if (p->type == SPRDWL_SCAN_ERROR)
-			wl_ndev_log(L_ERR, vif->ndev, "%s error!\n", __func__);
-		else
-			wl_ndev_log(L_ERR, vif->ndev, "%s invalid scan done type: %d\n",
-				   __func__, p->type);
+		//if (p->type == SPRDWL_SCAN_ERROR)
+		//	wl_ndev_log(L_ERR, vif->ndev, "%s error!\n", __func__);
+		//else
+		//	wl_ndev_log(L_ERR, vif->ndev, "%s invalid scan done type: %d\n",
+		//		   __func__, p->type);
 		break;
 	}
 	bss_count = 0;
@@ -2700,7 +2832,7 @@ void sprdwl_event_connect(struct sprdwl_vif *vif, u8 *data, u16 len)
 	/* the first byte is status code */
 	memcpy(&conn_info.status, pos, sizeof(conn_info.status));
 	if (conn_info.status != SPRDWL_CONNECT_SUCCESS &&
-	    conn_info.status != SPRDWL_ROAM_SUCCESS){
+		conn_info.status != SPRDWL_ROAM_SUCCESS){
 		/*Assoc response status code by set in the 3 byte if failure*/
 		memcpy(&status_code, pos+2, sizeof(status_code));
 		goto out;
@@ -2765,32 +2897,29 @@ void sprdwl_event_disconnect(struct sprdwl_vif *vif, u8 *data, u16 len)
 	u16 reason_code;
 
 	memcpy(&reason_code, data, sizeof(reason_code));
+	wl_info("%s reason code = %d\n", __func__, reason_code);
 #ifdef SYNC_DISCONNECT
-	/*Report disconnection on version > 4.9.60, even though disconnect
-	 is from wpas, otherwise it returns -EALREADY on next connect.*/
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 60)
 	if (atomic_read(&vif->sync_disconnect_event)) {
 		vif->disconnect_event_code = reason_code;
 		atomic_set(&vif->sync_disconnect_event, 0);
 		wake_up(&vif->disconnect_wq);
-		wl_err("%s reason code = %d\n", __func__, reason_code);
 	} else
 #endif
-#endif
-	sprdwl_report_disconnection(vif, reason_code);
+		sprdwl_report_disconnection(vif, reason_code);
+
 }
 
 void sprdwl_event_mic_failure(struct sprdwl_vif *vif, u8 *data, u16 len)
 {
 	struct sprdwl_event_mic_failure *mic_failure =
-	    (struct sprdwl_event_mic_failure *)data;
+		(struct sprdwl_event_mic_failure *)data;
 
 	sprdwl_report_mic_failure(vif, mic_failure->is_mcast,
 				  mic_failure->key_id);
 }
 
 void sprdwl_event_remain_on_channel_expired(struct sprdwl_vif *vif,
-					    u8 *data, u16 len)
+						u8 *data, u16 len)
 {
 	sprdwl_report_remain_on_channel_expired(vif);
 }
@@ -2798,12 +2927,12 @@ void sprdwl_event_remain_on_channel_expired(struct sprdwl_vif *vif,
 void sprdwl_event_mlme_tx_status(struct sprdwl_vif *vif, u8 *data, u16 len)
 {
 	struct sprdwl_event_mgmt_tx_status *tx_status =
-	    (struct sprdwl_event_mgmt_tx_status *)data;
+		(struct sprdwl_event_mgmt_tx_status *)data;
 
 	sprdwl_report_mgmt_tx_status(vif, SPRDWL_GET_LE64(tx_status->cookie),
-				     tx_status->buf,
-				     SPRDWL_GET_LE16(tx_status->len),
-				     tx_status->ack);
+					 tx_status->buf,
+					 SPRDWL_GET_LE16(tx_status->len),
+					 tx_status->ack);
 }
 
 /* @flag: 1 for data, 0 for event */
@@ -2862,7 +2991,7 @@ void sprdwl_event_epno_results(struct sprdwl_vif *vif, u8 *data, u16 data_len)
 	struct wiphy *wiphy = priv->wiphy;
 
 	wl_hex_dump(L_DBG, "epno result:", DUMP_PREFIX_OFFSET,
-			     16, 1, data, data_len, true);
+				 16, 1, data, data_len, true);
 
 	epno_results = (struct sprdwl_epno_results *)data;
 	if (epno_results->nr_scan_results <= 0) {
@@ -2884,7 +3013,7 @@ void sprdwl_event_epno_results(struct sprdwl_vif *vif, u8 *data, u16 data_len)
 
 	nla_put_u32(skb, GSCAN_RESULTS_REQUEST_ID, epno_results->request_id);
 	nla_put_u32(skb, GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
-		    epno_results->nr_scan_results);
+			epno_results->nr_scan_results);
 	nla_put_u8(skb, GSCAN_RESULTS_SCAN_RESULT_MORE_DATA, 0);
 
 	attr = nla_nest_start(skb, GSCAN_RESULTS_LIST);
@@ -2912,19 +3041,19 @@ void sprdwl_event_epno_results(struct sprdwl_vif *vif, u8 *data, u16 data_len)
 		nla_put(skb, GSCAN_RESULTS_SCAN_RESULT_BSSID, ETH_ALEN,
 			epno_results->results[i].bssid);
 		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
-			    epno_results->results[i].channel);
+				epno_results->results[i].channel);
 		nla_put_s32(skb, GSCAN_RESULTS_SCAN_RESULT_RSSI,
-			    epno_results->results[i].rssi);
+				epno_results->results[i].rssi);
 		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_RTT,
-			    epno_results->results[i].rtt);
+				epno_results->results[i].rtt);
 		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
-			    epno_results->results[i].rtt_sd);
+				epno_results->results[i].rtt_sd);
 		nla_put_u16(skb, GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
-			    epno_results->results[i].beacon_period);
+				epno_results->results[i].beacon_period);
 		nla_put_u16(skb, GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
-			    epno_results->results[i].capability);
+				epno_results->results[i].capability);
 		nla_put_string(skb, GSCAN_RESULTS_SCAN_RESULT_SSID,
-			       epno_results->results[i].ssid);
+				   epno_results->results[i].ssid);
 
 		nla_nest_end(skb, sub_attr);
 	}
@@ -2993,8 +3122,8 @@ void sprdwl_event_gscan_frame(struct sprdwl_vif *vif, u8 *data, u16 len)
 		pos += sizeof(struct sprdwl_gscan_result) + buf_len;
 
 		wl_ndev_log(L_DBG, vif->ndev, "%s ch:%d id:%d len:%d aval:%d, report_event:%d\n",
-			    __func__, frame->channel, bucket_id,
-			    buf_len, avail_len, report_event);
+				__func__, frame->channel, bucket_id,
+				buf_len, avail_len, report_event);
 	}
 
 	if (report_event == REPORT_EVENTS_BUFFER_FULL)
@@ -3145,12 +3274,12 @@ void sprdwl_event_thermal_warn(struct sprdwl_vif *vif, u8 *data, u16 len)
 		break;
 	case THERMAL_TX_STOP:
 		wl_err("%s, %d, netif_stop_queue because of thermal warn\n",
-		       __func__, __LINE__);
+			   __func__, __LINE__);
 		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, false);
 		break;
 	case THERMAL_WIFI_DOWN:
 		wl_err("%s, %d, close wifi because of thermal warn\n",
-		       __func__, __LINE__);
+			   __func__, __LINE__);
 		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, false);
 		for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
 			if (intf->priv->fw_stat[mode] == SPRDWL_INTF_OPEN)
@@ -3219,8 +3348,8 @@ int sprdwl_fw_power_down_ack(struct sprdwl_priv *priv, u8 ctx_id)
 	}
 
 	if (tx_num > 0 ||
-	    !list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
-	    !list_empty(&tx_msg->xmit_msg_list.to_free_list)) {
+		!list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+		!list_empty(&tx_msg->xmit_msg_list.to_free_list)) {
 		if (intf->fw_power_down == 1)
 			goto err;
 		p->value = 0;
@@ -3244,6 +3373,7 @@ int sprdwl_fw_power_down_ack(struct sprdwl_priv *priv, u8 ctx_id)
 	ret =  sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
 
 	if (intf->fw_power_down == 1) {
+		sprdwcn_bus_allow_sleep(WIFI);
 		sprdwl_unboost();
 	}
 
@@ -3386,8 +3516,8 @@ unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg)
 	plen = SPRDWL_GET_LE16(hdr->plen);
 	if (!priv) {
 		wl_err("%s priv is NULL [%u]ctx_id %d recv[%s]len: %d\n",
-		       __func__, le32_to_cpu(hdr->mstime), ctx_id,
-		       evt2str(hdr->cmd_id), hdr->plen);
+			   __func__, le32_to_cpu(hdr->mstime), ctx_id,
+			   evt2str(hdr->cmd_id), hdr->plen);
 		return plen;
 	}
 
@@ -3396,7 +3526,7 @@ unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg)
 		evt2str(hdr->cmd_id), plen);
 
 	wl_hex_dump(L_DBG, "EVENT: ", DUMP_PREFIX_OFFSET, 16, 1,
-			     (u8 *)hdr, hdr->plen, 0);
+				 (u8 *)hdr, hdr->plen, 0);
 
 	len = plen - sizeof(*hdr);
 	vif = ctx_id_to_vif(priv, ctx_id);
@@ -3470,9 +3600,11 @@ unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg)
 		sprdwl_event_nan(vif, data, len);
 		break;
 #endif /* NAN_SUPPORT */
+#ifdef UWE5621_FTR
 	case WIFI_EVENT_STA_LUT_INDEX:
 		sprdwl_event_sta_lut(vif, data, len);
 		break;
+#endif
 	case WIFI_EVENT_BA:
 		sprdwl_event_ba_mgmt(vif, data, len);
 		break;
@@ -3592,8 +3724,8 @@ int sprdwl_sync_disconnect_event(struct sprdwl_vif *vif, unsigned int timeout)
 #endif
 
 int sprdwl_set_packet_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
-			      u32 req, u8 enable, u32 interval,
-			      u32 len, u8 *data)
+				  u32 req, u8 enable, u32 interval,
+				  u32 len, u8 *data)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_packet_offload *p;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
index 8dd59bc2c841..ce8c774e8968 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
@@ -907,6 +907,7 @@ struct sprdwl_tlv_data {
 /* TLV type list */
 #define GET_INFO_TLV_TP_OTT	1
 #define NOTIFY_AP_VERSION	2
+#define NOTIFY_CREDIT_VIA_RX_DATA 5
 
 struct ap_version_tlv_elmt {
 #define NOTIFY_AP_VERSION_USER 0
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c b/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c
index 70415e79b311..264e9f7559ab 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c
@@ -264,9 +264,9 @@ int sprdwl_dbg_new_beacon_tail(const u8 *beacon_tail, int tail_len, u8 *new_tail
 
 #define ERP_INFO_BARKER_PREAMBLE_MODE 4
 	if (chn <= 14) {
-	    *tail++ = WLAN_EID_ERP_INFO;
-	    *tail++ = 1;
-	    *tail++ = ERP_INFO_BARKER_PREAMBLE_MODE;
+		*tail++ = WLAN_EID_ERP_INFO;
+		*tail++ = 1;
+		*tail++ = ERP_INFO_BARKER_PREAMBLE_MODE;
 	}
 
 	while (tail_len > 2) {
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/debug.c b/drivers/net/wireless/uwe5622/unisocwifi/debug.c
index 5f25f078ff5c..84fe30f7e70e 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/debug.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/debug.c
@@ -175,12 +175,12 @@ void adjust_ts_cnt_debug(char *buf, unsigned char offset)
 		spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
 	} else {
 		memset(g_debug_ts, 0,
-		       (MAX_DEBUG_TS_INDEX *
+			   (MAX_DEBUG_TS_INDEX *
 			sizeof(struct debug_time_stamp)));
 		memset(g_debug_cnt, 0,
-		       (MAX_DEBUG_CNT_INDEX * sizeof(struct debug_cnt)));
+			   (MAX_DEBUG_CNT_INDEX * sizeof(struct debug_cnt)));
 		memset(g_debug_record, 0,
-		       (MAX_RECORD_NUM * sizeof(struct debug_record)));
+			   (MAX_RECORD_NUM * sizeof(struct debug_record)));
 		debug_ctrl.start = true;
 		spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
 	}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/defrag.c b/drivers/net/wireless/uwe5622/unisocwifi/defrag.c
index 0b3cfb767681..816940b47dca 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/defrag.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/defrag.c
@@ -26,11 +26,11 @@ static struct rx_defrag_node
 
 	list_for_each_entry(pos_node, &defrag_entry->list, list) {
 		if ((pos_node->desc.sta_lut_index ==
-		     msdu_desc->sta_lut_index) &&
-		    (pos_node->desc.tid == msdu_desc->tid)) {
+			 msdu_desc->sta_lut_index) &&
+			(pos_node->desc.tid == msdu_desc->tid)) {
 			if ((pos_node->desc.seq_num == msdu_desc->seq_num) &&
-			    ((pos_node->last_frag_num + 1) ==
-			     msdu_desc->frag_num)) {
+				((pos_node->last_frag_num + 1) ==
+				 msdu_desc->frag_num)) {
 				/* Node alive & fragment avail */
 				pos_node->last_frag_num = msdu_desc->frag_num;
 				wl_debug("%s: last_frag_num: %d\n",
@@ -65,7 +65,7 @@ static inline void __init_first_frag_node(struct rx_defrag_node *node,
 
 static struct rx_defrag_node
 *init_first_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
-		      struct rx_msdu_desc *msdu_desc)
+			  struct rx_msdu_desc *msdu_desc)
 {
 	struct rx_defrag_node *node = NULL, *pos_node = NULL;
 	bool ret = true;
@@ -73,20 +73,20 @@ static struct rx_defrag_node
 	/* Check whether this entry alive or this fragment avail */
 	list_for_each_entry(pos_node, &defrag_entry->list, list) {
 		if ((pos_node->desc.sta_lut_index ==
-		     msdu_desc->sta_lut_index) &&
-		    (pos_node->desc.tid == msdu_desc->tid)) {
+			 msdu_desc->sta_lut_index) &&
+			(pos_node->desc.tid == msdu_desc->tid)) {
 			if (!seqno_leq(msdu_desc->seq_num,
-				       pos_node->desc.seq_num)) {
+					   pos_node->desc.seq_num)) {
 				/* Replace this entry */
 				wl_err("%s: fragment replace: %d, %d\n",
-				       __func__, msdu_desc->seq_num,
-				       pos_node->desc.seq_num);
+					   __func__, msdu_desc->seq_num,
+					   pos_node->desc.seq_num);
 				node = pos_node;
 			} else {
 				/* fragment not avail */
 				wl_err("%s: fragment not avail: %d, %d\n",
-				       __func__, msdu_desc->seq_num,
-				       pos_node->desc.seq_num);
+					   __func__, msdu_desc->seq_num,
+					   pos_node->desc.seq_num);
 				ret = false;
 			}
 			break;
@@ -135,7 +135,7 @@ static struct rx_defrag_node
 
 static struct sk_buff
 *defrag_single_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
-			    struct sk_buff *pskb)
+				struct sk_buff *pskb)
 {
 	struct rx_defrag_node *node = NULL;
 	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)pskb->data;
@@ -192,7 +192,7 @@ static struct sk_buff
 				wl_debug("%s: frag_len: %d, frag_offset: %d\n",
 					 __func__, frag_len, frag_offset);
 				memcpy((skb->data + offset),
-				       (pos_skb->data + frag_offset), frag_len);
+					   (pos_skb->data + frag_offset), frag_len);
 				offset += frag_len;
 
 				dev_kfree_skb(pos_skb);
@@ -204,7 +204,7 @@ static struct sk_buff
 			/* Move this entry to tail */
 			if (!list_is_last(&node->list, &defrag_entry->list))
 				list_move_tail(&node->list,
-					       &defrag_entry->list);
+						   &defrag_entry->list);
 		}
 	} else {
 		dev_kfree_skb(pskb);
@@ -215,7 +215,7 @@ static struct sk_buff
 
 struct sk_buff
 *defrag_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
-		     struct sk_buff *pskb)
+			 struct sk_buff *pskb)
 {
 	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)pskb->data;
 	struct sk_buff *skb = NULL;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c b/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c
index 5a320b6b55e1..f45bc8043f9c 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c
@@ -23,7 +23,7 @@
 
 extern struct sprdwl_intf_ops g_intf_ops;
 extern int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
-		     int len, int chn);
+			 int len, int chn);
 
 unsigned long loop;
 
@@ -69,7 +69,7 @@ void edma_transceive_test_deinit(void)
 	for (i = 0; i < PCIE_CHANNEL_PAIR; i++) {
 		if (!IS_ERR_OR_NULL(task_array[i])) {
 			wl_err(" %s, Destory thread, thread_num=%d,\n",
-			       __func__, i);
+				   __func__, i);
 			kthread_stop(task_array[i]);
 			task_array[i] = NULL;
 		}
@@ -120,8 +120,8 @@ int do_tx(int channel)
 
 #define SPRDWL_SDIO_DEBUG_BUFLEN 128
 static ssize_t pcie_read_info(struct file *file,
-			      char __user *user_buf,
-			      size_t count, loff_t *ppos)
+				  char __user *user_buf,
+				  size_t count, loff_t *ppos)
 {
 	size_t ret = 0;
 	unsigned int buflen, len;
@@ -181,14 +181,14 @@ void edma_transceive_test_run(int pairs)
 		chn_tx_fail[i] = 0;
 
 		task_array[i] = kthread_create(edma_transceive_test_exec,
-							    (unsigned long *)loop,
-							    "edma_transceive_%d", i);
+								(unsigned long *)loop,
+								"edma_transceive_%d", i);
 		chn_tx_dentry[i] = debugfs_create_file(tx_name[i], S_IRUSR, priv->debugfs, (unsigned long *)loop, &pcie_debug_fops);
 		loop++;
 		if (IS_ERR(task_array[i])) {
 			err = PTR_ERR(task_array[i]);
 			wl_err("%s, Fail, thread_num=%d,error_num=%d.",
-			       __func__, i, err);
+				   __func__, i, err);
 		} else {
 			wl_info(" %s, Start thread, thread_num=%d,\n",
 				__func__, i);
@@ -208,7 +208,7 @@ void edma_transceive_test_stop(void)
 	for (i = 0; i < PCIE_CHANNEL_PAIR; i++) {
 		if (!IS_ERR_OR_NULL(task_array[i])) {
 			wl_err(" %s, Stop thread, thread_num=%d,\n",
-			       __func__, i);
+				   __func__, i);
 			kthread_stop(task_array[i]);
 			task_array[i] = NULL;
 		}
@@ -335,7 +335,7 @@ void edma_transceive_test_trigger(char *cmd)
 
 	if (pairs <= 0 || pairs > PCIE_CHANNEL_PAIR) {
 		wl_err("%s, Invalid chn pairs(%ld), use default val(8)\n",
-		       __func__, pairs);
+			   __func__, pairs);
 		pairs = PCIE_CHANNEL_PAIR;
 	}
 
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/ibss.c b/drivers/net/wireless/uwe5622/unisocwifi/ibss.c
index d335635bc262..822a17c6bb47 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/ibss.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/ibss.c
@@ -28,8 +28,8 @@
 
 /* cfg80211 */
 int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
-				     struct net_device *ndev,
-				     struct cfg80211_ibss_params *params)
+					 struct net_device *ndev,
+					 struct cfg80211_ibss_params *params)
 {
 	int ret = 0;
 	struct ieee80211_channel *chan;
@@ -74,7 +74,7 @@ int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
 
 	wl_ndev_log(L_INFO, ndev, "%s params->ssid=%s\n", __func__, params->ssid);
 	wl_ndev_log(L_INFO, ndev, "%s params->ssid_len=%d\n",
-		    __func__, params->ssid_len);
+			__func__, params->ssid_len);
 	join_params_size = sizeof(join_params);
 	memset(&join_params, 0, join_params_size);
 	memcpy(join_params.ssid, params->ssid, params->ssid_len);
@@ -88,9 +88,9 @@ int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
 		memset(join_params.bssid, 0, ETH_ALEN);
 	}
 	wl_ndev_log(L_INFO, ndev, "%s join_params.ssid=%s\n",
-		    __func__, join_params.ssid);
+			__func__, join_params.ssid);
 	wl_ndev_log(L_INFO, ndev, "%s join_params.ssid_len=%d\n",
-		    __func__, join_params.ssid_len);
+			__func__, join_params.ssid_len);
 
 	/* attribute */
 	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
@@ -129,7 +129,7 @@ int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
 #endif /* IBSS_RSN_SUPPORT */
 
 	ret = sprdwl_ibss_join(vif->priv, vif->mode,
-			       &join_params, join_params_size);
+				   &join_params, join_params_size);
 	if (ret) {
 		wl_ndev_log(L_ERR, ndev, "%s join failed (%d)\n", __func__, ret);
 		return ret;
@@ -144,7 +144,7 @@ int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
 }
 
 int sprdwl_cfg80211_leave_ibss(struct wiphy *wiphy,
-				      struct net_device *ndev)
+					  struct net_device *ndev)
 {
 	struct sprdwl_vif *vif = netdev_priv(ndev);
 	enum sm_state old_state = vif->sm_state;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/intf.h b/drivers/net/wireless/uwe5622/unisocwifi/intf.h
index 41b9bd5a3fe9..c17356251e02 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/intf.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/intf.h
@@ -24,17 +24,35 @@ struct sprdwl_priv;
 struct sprdwl_if_ops {
 	struct sprdwl_msg_buf *(*get_msg_buf)(void *sdev,
 					      enum sprdwl_head_type type,
+#if defined(UWE5621_FTR)
 					      enum sprdwl_mode mode,
 					      u8 ctx_id);
-
+#else
+					      enum sprdwl_mode mode);
+#endif
 	void (*free_msg_buf)(void *sdev, struct sprdwl_msg_buf *msg);
 	int (*tx)(void *spdev, struct sprdwl_msg_buf *msg);
+
+#if defined(UWE5621_FTR)
 	void (*force_exit)(void *spdev);
 	int (*is_exit)(void *spdev);
+#else
+	void (*force_exit)(void);
+	int (*is_exit)(void);
+#endif /* UWE5621_FTR */
 	int (*suspend)(struct sprdwl_priv *priv);
 	int (*resume)(struct sprdwl_priv *priv);
+#if defined(UWE5621_FTR)
 	void (*debugfs)(void *spdev, struct dentry *dir);
+#else
+	void (*debugfs)(struct dentry *dir);
+#endif /* UWE5621_FTR */
+
+#if defined(UWE5621_FTR)
 	void (*tcp_drop_msg)(void *spdev, struct sprdwl_msg_buf *msg);
+#else
+	void (*tcp_drop_msg)(struct sprdwl_msg_buf *msg);
+#endif /* UWE5621_FTR*/
 	int (*ini_download_status)(void);
 };
 
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h b/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
index c580b3040260..3844b0b06767 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
@@ -28,7 +28,11 @@ inline struct sprdwl_msg_buf *sprdwl_intf_get_msg_buf(struct sprdwl_priv *priv,
 						      enum sprdwl_mode mode,
 						      u8 ctx_id)
 {
+#if defined(UWE5621_FTR)
 	return priv->if_ops->get_msg_buf(priv->hw_priv, type, mode, ctx_id);
+#else
+	return priv->if_ops->get_msg_buf(priv->hw_priv, type, mode);
+#endif
 }
 
 static inline void sprdwl_intf_free_msg_buf(struct sprdwl_priv *priv,
@@ -49,12 +53,20 @@ static inline int sprdwl_intf_tx(struct sprdwl_priv *priv,
 
 static inline void sprdwl_intf_force_exit(struct sprdwl_priv *priv)
 {
+#if defined(UWE5621_FTR)
 	priv->if_ops->force_exit(priv->hw_priv);
+#else
+	priv->if_ops->force_exit();
+#endif
 }
 
 static inline int sprdwl_intf_is_exit(struct sprdwl_priv *priv)
 {
+#if defined(UWE5621_FTR)
 	return priv->if_ops->is_exit(priv->hw_priv);
+#else
+	return priv->if_ops->is_exit();
+#endif
 }
 
 static inline int sprdwl_intf_suspend(struct sprdwl_priv *priv)
@@ -76,15 +88,25 @@ static inline int sprdwl_intf_resume(struct sprdwl_priv *priv)
 static inline void sprdwl_intf_debugfs(struct sprdwl_priv *priv,
 				       struct dentry *dir)
 {
+#if defined(UWE5621_FTR)
 	if (priv->if_ops->debugfs)
 		priv->if_ops->debugfs(priv->hw_priv, dir);
+#else
+	if (priv->if_ops->debugfs)
+		priv->if_ops->debugfs(dir);
+#endif /* UWE5621_FTR */
 }
 
 static inline void sprdwl_intf_tcp_drop_msg(struct sprdwl_priv *priv,
 					    struct sprdwl_msg_buf *msg)
 {
+#if defined(UWE5621_FTR)
 	if (priv->if_ops->tcp_drop_msg)
 		priv->if_ops->tcp_drop_msg(priv->hw_priv, msg);
+#else
+	if (priv->if_ops->tcp_drop_msg)
+		priv->if_ops->tcp_drop_msg(msg);
+#endif
 }
 
 static inline int sprdwl_get_ini_status(struct sprdwl_priv *priv)
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/main.c b/drivers/net/wireless/uwe5622/unisocwifi/main.c
index 21efdf4e0855..46b9039519cd 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/main.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/main.c
@@ -24,10 +24,13 @@
 #include "intf_ops.h"
 #include "vendor.h"
 #include "work.h"
+#if defined(UWE5621_FTR)
 #include "tx_msg.h"
 #include "rx_msg.h"
 #include "wl_core.h"
+#endif
 #include "tcp_ack.h"
+#include "rnd_mac_addr.h"
 #ifdef DFS_MASTER
 #include "11h.h"
 #endif
@@ -68,7 +71,7 @@ void sprdwl_netif_rx(struct sk_buff *skb, struct net_device *ndev)
 	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
 
 	wl_hex_dump(L_DBG, "RX packet: ", DUMP_PREFIX_OFFSET,
-			     16, 1, skb->data, skb->len, 0);
+				 16, 1, skb->data, skb->len, 0);
 
 	skb->dev = ndev;
 	skb->protocol = eth_type_trans(skb, ndev);
@@ -108,7 +111,7 @@ void sprdwl_stop_net(struct sprdwl_vif *vif)
 }
 
 static void sprdwl_netflowcontrl_mode(struct sprdwl_priv *priv,
-				      enum sprdwl_mode mode, bool state)
+					  enum sprdwl_mode mode, bool state)
 {
 	struct sprdwl_vif *vif;
 
@@ -241,8 +244,8 @@ static int sprdwl_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	if (skb->protocol == cpu_to_be16(ETH_P_PAE) ||
 		skb->protocol == cpu_to_be16(WAPI_TYPE)) {
 		wl_info("send %s frame by WIFI_CMD_TX_DATA\n",
-		       skb->protocol == cpu_to_be16(ETH_P_PAE) ?
-		       "802.1X" : "WAI");
+			   skb->protocol == cpu_to_be16(ETH_P_PAE) ?
+			   "802.1X" : "WAI");
 		if (sprdwl_xmit_data2cmd_wq(skb, ndev) == -EAGAIN)
 			return NETDEV_TX_BUSY;
 		return NETDEV_TX_OK;
@@ -255,14 +258,15 @@ static int sprdwl_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	/*mode not open, so we will not send data*/
 	if (vif->priv->fw_stat[vif->mode] != SPRDWL_INTF_OPEN) {
 		wl_err_ratelimited("%s, %d, should not send this data\n",
-		       __func__, __LINE__);
-		return NETDEV_TX_BUSY;
+			   __func__, __LINE__);
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
 	}
 
 	msg = sprdwl_intf_get_msg_buf(vif->priv,
-				      SPRDWL_TYPE_DATA,
-				      vif->mode,
-				      vif->ctx_id);
+					  SPRDWL_TYPE_DATA,
+					  vif->mode,
+					  vif->ctx_id);
 	if (!msg) {
 		wl_err("%s, %d, get msg bug failed\n", __func__, __LINE__);
 		ndev->stats.tx_fifo_errors++;
@@ -289,7 +293,12 @@ static int sprdwl_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 		return NETDEV_TX_OK;
 	}
 #endif
+#if !defined(UWE5621_FTR)
+	/* sprdwl_send_data: offset use 2 for cp bytes align */
+	ret = sprdwl_send_data(vif, msg, skb, 2);
+#else
 	ret = sprdwl_send_data(vif, msg, skb, 0);
+#endif /* UWE5621_FTR */
 	if (ret) {
 		wl_ndev_log(L_ERR, ndev, "%s drop msg due to TX Err\n", __func__);
 		/* FIXME as debug sdiom later, here just drop the msg
@@ -308,7 +317,7 @@ static int sprdwl_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	netif_trans_update(vif->ndev);
 #endif
 	wl_hex_dump(L_DBG, "TX packet: ", DUMP_PREFIX_OFFSET,
-			     16, 1, skb->data, skb->len, 0);
+				 16, 1, skb->data, skb->len, 0);
 
 out:
 	return NETDEV_TX_OK;
@@ -360,8 +369,11 @@ static struct net_device_stats *sprdwl_get_stats(struct net_device *ndev)
 {
 	return &ndev->stats;
 }
-
-static void sprdwl_tx_timeout(struct net_device *ndev, unsigned int val)
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+static void sprdwl_tx_timeout(struct net_device *ndev, unsigned int txqueue)
+#else
+static void sprdwl_tx_timeout(struct net_device *ndev)
+#endif
 {
 	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
@@ -500,7 +512,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 		skip = strlen(CMD_ENABLE_WHITELIST) + 1;
 		counter = command[skip];
 		wl_ndev_log(L_INFO, ndev, "%s: enable whitelist counter : %d\n",
-			    __func__, counter);
+				__func__, counter);
 		if (!counter) {
 			ret = sprdwl_set_whitelist(priv, vif->ctx_id,
 						   SPRDWL_SUBCMD_ENABLE,
@@ -520,7 +532,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 			if (!is_valid_ether_addr(mac_addr))
 				goto out;
 			wl_ndev_log(L_INFO, ndev, "%s: enable whitelist %pM\n",
-				    __func__, mac_addr);
+					__func__, mac_addr);
 			mac_addr += ETH_ALEN;
 			tmp += 18;
 		}
@@ -533,7 +545,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 		skip = strlen(CMD_DISABLE_WHITELIST) + 1;
 		counter = command[skip];
 		wl_ndev_log(L_INFO, ndev, "%s: disable whitelist counter : %d\n",
-			    __func__, counter);
+				__func__, counter);
 		if (!counter) {
 			ret = sprdwl_set_whitelist(priv, vif->ctx_id,
 						   SPRDWL_SUBCMD_DISABLE,
@@ -553,7 +565,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 			if (!is_valid_ether_addr(mac_addr))
 				goto out;
 			wl_ndev_log(L_INFO, ndev, "%s: disable whitelist %pM\n",
-				    __func__, mac_addr);
+					__func__, mac_addr);
 			mac_addr += ETH_ALEN;
 			tmp += 18;
 		}
@@ -595,7 +607,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 			interval = command[skip + 1];
 
 		wl_ndev_log(L_INFO, ndev, "%s: 11v sleep, status %d, interval %d\n",
-			    __func__, status, interval);
+				__func__, status, interval);
 		sprdwl_set_11v_sleep_mode(priv, vif->ctx_id, status, interval);
 	} else if (!strncasecmp(command, CMD_SET_COUNTRY,
 				strlen(CMD_SET_COUNTRY))) {
@@ -609,7 +621,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 			goto out;
 		}
 		wl_ndev_log(L_INFO, ndev, "%s country code:%c%c\n", __func__,
-			    toupper(country[0]), toupper(country[1]));
+				toupper(country[0]), toupper(country[1]));
 		ret = regulatory_hint(priv->wiphy, country);
 	} else if (!strncasecmp(command, CMD_SET_MAX_CLIENTS,
 		   strlen(CMD_SET_MAX_CLIENTS))) {
@@ -620,7 +632,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 			goto out;
 		}
 		ret = sprdwl_set_max_clients_allowed(priv, vif->ctx_id,
-						     n_clients);
+							 n_clients);
 	} else if (!strncasecmp(command, CMD_SETSUSPENDMODE,
 			 strlen(CMD_SETSUSPENDMODE))) {
 		skip = strlen(CMD_SETSUSPENDMODE) + 1;
@@ -628,7 +640,7 @@ static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
 		if (ret)
 			goto out;
 		wl_ndev_log(L_INFO, ndev, "%s: set suspend mode,value : %d\n",
-			    __func__, value);
+				__func__, value);
 		ret = sprdwl_power_save(priv, vif->ctx_id,
 					SPRDWL_SCREEN_ON_OFF, value);
 	} else {
@@ -708,7 +720,7 @@ static int sprdwl_set_power_save(struct net_device *ndev, struct ifreq *ifr)
 		if (ret)
 			goto out;
 		wl_ndev_log(L_INFO, ndev, "%s: set suspend mode,value : %d\n",
-			    __func__, value);
+				__func__, value);
 		ret = sprdwl_power_save(priv, vif->ctx_id,
 					SPRDWL_SCREEN_ON_OFF, value);
 	} else if (!strncasecmp(command, CMD_SET_FCC_CHANNEL,
@@ -718,7 +730,7 @@ static int sprdwl_set_power_save(struct net_device *ndev, struct ifreq *ifr)
 		if (ret)
 			goto out;
 		wl_ndev_log(L_INFO, ndev, "%s: set fcc channel,value : %d\n",
-			    __func__, value);
+				__func__, value);
 		ret = sprdwl_power_save(priv, vif->ctx_id,
 					SPRDWL_SET_FCC_CHANNEL, value);
 	} else {
@@ -884,12 +896,12 @@ static void sprdwl_set_multicast(struct net_device *ndev)
 		mac_addr = vif->mc_filter->mac_addr;
 		netdev_for_each_mc_addr(ha, ndev) {
 			wl_ndev_log(L_DBG, ndev, "%s set mac: %pM\n", __func__,
-				    ha->addr);
+					ha->addr);
 			if ((ha->addr[0] != 0x33 || ha->addr[1] != 0x33) &&
-			    (ha->addr[0] != 0x01 || ha->addr[1] != 0x00 ||
-			     ha->addr[2] != 0x5e || ha->addr[3] > 0x7f)) {
+				(ha->addr[0] != 0x01 || ha->addr[1] != 0x00 ||
+				 ha->addr[2] != 0x5e || ha->addr[3] > 0x7f)) {
 				wl_ndev_log(L_INFO, ndev, "%s invalid addr\n",
-					    __func__);
+						__func__);
 				return;
 			}
 			ether_addr_copy(mac_addr, ha->addr);
@@ -915,11 +927,31 @@ static void sprdwl_set_multicast(struct net_device *ndev)
 
 static int sprdwl_set_mac(struct net_device *dev, void *addr)
 {
+	struct sprdwl_vif *vif = netdev_priv(dev);
+	struct sockaddr *sa = (struct sockaddr *)addr;
+
 	if (!dev) {
 		netdev_err(dev, "Invalid net device\n");
+	}
+
+	netdev_info(dev, "start set random mac: %pM\n", sa->sa_data);
+	if (is_multicast_ether_addr(sa->sa_data)) {
+		netdev_err(dev, "invalid, it is multicast addr: %pM\n", sa->sa_data);
 		return -EINVAL;
 	}
 
+	if (vif->mode == SPRDWL_MODE_STATION) {
+		if (!is_zero_ether_addr(sa->sa_data)) {
+			vif->has_rand_mac = true;
+			memcpy(vif->random_mac, sa->sa_data, ETH_ALEN);
+			memcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);
+		} else {
+			vif->has_rand_mac = false;
+			netdev_info(dev, "need clear random mac for sta/softap mode\n");
+			memset(vif->random_mac, 0, ETH_ALEN);
+			memcpy(dev->dev_addr, vif->mac, ETH_ALEN);
+		}
+	}
 	/*return success to pass vts test*/
 	return 0;
 }
@@ -962,10 +994,11 @@ static int sprdwl_inetaddr_event(struct notifier_block *this,
 				if (entry->ctx_id == vif->ctx_id)
 					entry->ip_acquired = 1;
 				else
-					wl_err("ctx_id(%d) mismatch\n",
-					       entry->ctx_id);
+					;
+					//wl_err("ctx_id(%d) mismatch\n",
+					//	   entry->ctx_id);
 			} else {
-			    wl_err("failed to find entry\n");
+				wl_err("failed to find entry\n");
 			}
 
 			sprdwl_notify_ip(vif->priv, vif->ctx_id, SPRDWL_IPV4,
@@ -1017,7 +1050,7 @@ static int sprdwl_inetaddr6_event(struct notifier_block *this,
 			work->id = SPRDWL_WORK_NOTIFY_IP;
 			ipv6_addr = (u8 *)work->data;
 			memcpy(ipv6_addr, (u8 *)&inet6_ifa->addr,
-			       SPRDWL_IPV6_ADDR_LEN);
+				   SPRDWL_IPV6_ADDR_LEN);
 			sprdwl_queue_work(vif->priv, work);
 		}
 		break;
@@ -1136,7 +1169,7 @@ void clean_survey_info_list(struct sprdwl_vif *vif)
 }
 
 static unsigned short cal_total_beacon(struct sprdwl_vif *vif,
-				       struct sprdwl_survey_info *info)
+					   struct sprdwl_survey_info *info)
 {
 	unsigned short total_beacon = 0;
 	short pos_chan, chan;
@@ -1149,14 +1182,14 @@ static unsigned short cal_total_beacon(struct sprdwl_vif *vif,
 		list_for_each_entry(info, &vif->survey_info_list, survey_list) {
 			pos_chan = (short)info->chan;
 			if (pos_chan > (chan - 4) && pos_chan < (chan + 4) &&
-			    pos_chan != chan) {
+				pos_chan != chan) {
 				total_beacon += info->beacon_num;
 			}
 		}
 	}
 
 	wl_ndev_log(L_DBG, vif->ndev, "survey chan: %d, total beacon: %d!\n",
-		    chan, total_beacon);
+			chan, total_beacon);
 	return total_beacon;
 }
 
@@ -1230,7 +1263,7 @@ static struct sprdwl_survey_info *find_survey_info(struct sprdwl_vif *vif,
 }
 
 void acs_scan_result(struct sprdwl_vif *vif, u16 chan,
-		     struct ieee80211_mgmt *mgmt)
+			 struct ieee80211_mgmt *mgmt)
 {
 	struct sprdwl_survey_info *info = NULL;
 	struct sprdwl_bssid *bssid = NULL;
@@ -1253,7 +1286,7 @@ void acs_scan_result(struct sprdwl_vif *vif, u16 chan,
 #endif /* ACS_SUPPORT */
 
 static void sprdwl_init_vif(struct sprdwl_priv *priv, struct sprdwl_vif *vif,
-			    const char *name)
+				const char *name)
 {
 	WARN_ON(strlen(name) >= sizeof(vif->name));
 
@@ -1276,8 +1309,8 @@ static void sprdwl_deinit_vif(struct sprdwl_vif *vif)
 	 */
 #ifdef SYNC_DISCONNECT
 	if (vif->sm_state == SPRDWL_CONNECTING ||
-	    vif->sm_state == SPRDWL_CONNECTED  ||
-	    vif->sm_state == SPRDWL_DISCONNECTING)
+		vif->sm_state == SPRDWL_CONNECTED  ||
+		vif->sm_state == SPRDWL_DISCONNECTING)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
 		cfg80211_disconnected(vif->ndev, 3,
 		NULL, 0, false, GFP_KERNEL);
@@ -1307,9 +1340,9 @@ static void sprdwl_deinit_vif(struct sprdwl_vif *vif)
 
 #ifndef CONFIG_P2P_INTF
 static struct sprdwl_vif *sprdwl_register_wdev(struct sprdwl_priv *priv,
-					       const char *name,
-					       enum nl80211_iftype type,
-					       u8 *addr)
+						   const char *name,
+						   enum nl80211_iftype type,
+						   u8 *addr)
 {
 	struct sprdwl_vif *vif;
 	struct wireless_dev *wdev;
@@ -1383,8 +1416,8 @@ static struct sprdwl_vif *sprdwl_register_netdev(struct sprdwl_priv *priv,
 	if (priv->fw_capa & SPRDWL_CAPA_MC_FILTER) {
 		wl_info("\tMulticast Filter supported\n");
 		vif->mc_filter =
-		    kzalloc(sizeof(struct sprdwl_mc_filter) +
-			    priv->max_mc_mac_addrs * ETH_ALEN, GFP_KERNEL);
+			kzalloc(sizeof(struct sprdwl_mc_filter) +
+				priv->max_mc_mac_addrs * ETH_ALEN, GFP_KERNEL);
 		if (!vif->mc_filter) {
 			ret = -ENOMEM;
 			goto err;
@@ -1445,8 +1478,8 @@ static void sprdwl_unregister_netdev(struct sprdwl_vif *vif)
 }
 
 struct wireless_dev *sprdwl_add_iface(struct sprdwl_priv *priv,
-				      const char *name,
-				      enum nl80211_iftype type, u8 *addr)
+					  const char *name,
+					  enum nl80211_iftype type, u8 *addr)
 {
 	struct sprdwl_vif *vif;
 
@@ -1523,7 +1556,6 @@ static void sprdwl_init_debugfs(struct sprdwl_priv *priv)
 
 int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv)
 {
-	u8 *efuse_mac_addr = NULL;
 	struct wiphy *wiphy = priv->wiphy;
 	struct wireless_dev *wdev;
 	int ret;
@@ -1548,8 +1580,6 @@ int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv)
 	}
 	sprdwl_init_debugfs(priv);
 
-	if (is_valid_ether_addr(priv->mac_addr))
-		efuse_mac_addr = priv->mac_addr;
 	rtnl_lock();
 	wdev = sprdwl_add_iface(priv, "wlan%d", NL80211_IFTYPE_STATION, NULL);
 	rtnl_unlock();
@@ -1572,21 +1602,23 @@ int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv)
 
 #ifdef RX_NAPI
 	sprdwl_rx_napi_init(wdev->netdev,
-			    ((struct sprdwl_intf *)priv->hw_priv));
+				((struct sprdwl_intf *)priv->hw_priv));
 #endif
 
+#if defined(UWE5621_FTR)
 	qos_enable(1);
+#endif
 	sprdwl_init_npi();
 	ret = register_inetaddr_notifier(&sprdwl_inetaddr_cb);
 	if (ret)
 		wl_err("%s failed to register inetaddr notifier(%d)!\n",
-		       __func__, ret);
+			   __func__, ret);
 	if (priv->fw_capa & SPRDWL_CAPA_NS_OFFLOAD) {
 		wl_info("\tIPV6 NS Offload supported\n");
 		ret = register_inet6addr_notifier(&sprdwl_inet6addr_cb);
 		if (ret)
 			wl_err("%s failed to register inet6addr notifier(%d)!\n",
-			       __func__, ret);
+				   __func__, ret);
 	}
 
 	trace_info_init();
@@ -1594,7 +1626,7 @@ int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv)
 	ret = marlin_reset_register_notify(priv->if_ops->force_exit, priv->hw_priv);
 	if (ret) {
 		wl_err("%s failed to register wcn cp rest notify(%d)!\n",
-		       __func__, ret);
+			   __func__, ret);
 	}
 
 out:
@@ -1608,7 +1640,9 @@ int sprdwl_core_deinit(struct sprdwl_priv *priv)
 	if (priv->fw_capa & SPRDWL_CAPA_NS_OFFLOAD)
 		unregister_inet6addr_notifier(&sprdwl_inet6addr_cb);
 	sprdwl_deinit_npi();
+#if defined(UWE5621_FTR)
 	qos_enable(0);
+#endif
 	sprdwl_del_all_ifaces(priv);
 	sprdwl_vendor_deinit(priv->wiphy);
 	wiphy_unregister(priv->wiphy);
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/mm.c b/drivers/net/wireless/uwe5622/unisocwifi/mm.c
index eaf6554f2310..f33d87185de3 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/mm.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/mm.c
@@ -30,7 +30,7 @@
 	SKB_DATA_ALIGN(SPRDWL_MAX_DATA_RXLEN + NET_SKB_PAD)
 
 void check_mh_buffer(struct device *dev, void *buffer, dma_addr_t pa,
-		     size_t size, enum dma_data_direction direction)
+			 size_t size, enum dma_data_direction direction)
 {
 #define MAX_RETRY_NUM 8
 	int retry = 0;
@@ -40,10 +40,10 @@ void check_mh_buffer(struct device *dev, void *buffer, dma_addr_t pa,
 
 		/* Check whether this buffer is ok to use */
 		while ((desc->data_write_done != 1) ||
-		       (retry < MAX_RETRY_NUM)) {
+			   (retry < MAX_RETRY_NUM)) {
 			wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
-			       __func__, (unsigned long)buffer,
-			       (unsigned long)pa);
+				   __func__, (unsigned long)buffer,
+				   (unsigned long)pa);
 			/* FIXME: Should we delay here? */
 			dma_sync_single_for_device(dev, pa, size, direction);
 			retry++;
@@ -53,8 +53,8 @@ void check_mh_buffer(struct device *dev, void *buffer, dma_addr_t pa,
 			buffer_ctrl.buffer_inuse) != 0) ||
 			(retry < MAX_RETRY_NUM)) {
 			wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
-			       __func__, (unsigned long)buffer,
-			       (unsigned long)pa);
+				   __func__, (unsigned long)buffer,
+				   (unsigned long)pa);
 			dma_sync_single_for_device(dev, pa, size, direction);
 			retry++;
 		}
@@ -64,12 +64,12 @@ void check_mh_buffer(struct device *dev, void *buffer, dma_addr_t pa,
 		/* TODO: How to deal with this situation? */
 		dma_sync_single_for_device(dev, pa, size, direction);
 		wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
-		       __func__, (unsigned long)buffer, (unsigned long)pa);
+			   __func__, (unsigned long)buffer, (unsigned long)pa);
 	}
 }
 
 unsigned long mm_virt_to_phys(struct device *dev, void *buffer, size_t size,
-			      enum dma_data_direction direction)
+				  enum dma_data_direction direction)
 {
 	dma_addr_t pa = 0;
 	unsigned long pcie_addr = 0;
@@ -82,7 +82,7 @@ unsigned long mm_virt_to_phys(struct device *dev, void *buffer, size_t size,
 }
 
 void *mm_phys_to_virt(struct device *dev, unsigned long pcie_addr, size_t size,
-		      enum dma_data_direction direction, bool is_mh)
+			  enum dma_data_direction direction, bool is_mh)
 {
 	dma_addr_t pa = 0;
 	void *buffer = NULL;
@@ -178,7 +178,7 @@ static inline int mm_do_addr_buf(struct sprdwl_mm *mm_entry)
 		/* FIXME: temporary solution, would TX supply API for us? */
 		/* TODO: How to do with tx fail? */
 		if ((if_tx_addr_trans(rx_if->intf, mm_entry->hdr,
-				      addr_trans_len) >= 0)) {
+					  addr_trans_len) >= 0)) {
 			mm_alloc_addr_buf(mm_entry);
 			if (unlikely(!mm_entry->addr_trans)) {
 				wl_err("%s: alloc addr buf fail!\n", __func__);
@@ -204,7 +204,7 @@ static int mm_w_addr_buf(struct sprdwl_mm *mm_entry, unsigned long pcie_addr)
 
 		/* NOTE: MH is little endian */
 		memcpy((void *)value->address[value->num],
-		       &pcie_addr, SPRDWL_PHYS_LEN);
+			   &pcie_addr, SPRDWL_PHYS_LEN);
 		value->num++;
 		/* do not care the result here */
 		mm_do_addr_buf(mm_entry);
@@ -231,14 +231,14 @@ static int mm_single_buffer_alloc(struct sprdwl_mm *mm_entry)
 		memcpy((void *)skb_end_pointer(skb), &skb, sizeof(skb));
 		/* transfer virt to phys */
 		pcie_addr = mm_virt_to_phys(&rx_if->intf->pdev->dev,
-					    skb->data, SPRDWL_MAX_DATA_RXLEN,
-					    DMA_FROM_DEVICE);
+						skb->data, SPRDWL_MAX_DATA_RXLEN,
+						DMA_FROM_DEVICE);
 
 		if (unlikely(!pcie_addr)) {
 			ret = mm_w_addr_buf(mm_entry, pcie_addr);
 			if (ret) {
 				wl_err("%s: write addr buf fail: %d\n",
-				       __func__, ret);
+					   __func__, ret);
 				dev_kfree_skb(skb);
 			} else {
 				/* queue skb */
@@ -260,7 +260,7 @@ int mm_buffer_alloc(struct sprdwl_mm *mm_entry, int need_num)
 		ret = mm_single_buffer_alloc(mm_entry);
 		if (ret) {
 			wl_err("%s: alloc num: %d, need num: %d, ret: %d\n",
-			       __func__, num, need_num, ret);
+				   __func__, num, need_num, ret);
 			break;
 		}
 	}
@@ -269,7 +269,7 @@ int mm_buffer_alloc(struct sprdwl_mm *mm_entry, int need_num)
 }
 
 static struct sk_buff *mm_single_buffer_unlink(struct sprdwl_mm *mm_entry,
-					       unsigned long pcie_addr)
+						   unsigned long pcie_addr)
 {
 	struct sprdwl_rx_if *rx_if =
 			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
@@ -287,11 +287,11 @@ static struct sk_buff *mm_single_buffer_unlink(struct sprdwl_mm *mm_entry,
 }
 
 static int mm_buffer_relink(struct sprdwl_mm *mm_entry,
-			    struct sprdwl_addr_trans_value *value,
-			    int total_len)
+				struct sprdwl_addr_trans_value *value,
+				int total_len)
 {
 	int num = 0;
-	unsigned long pcie_addr = 0;
+	uint64_t pcie_addr = 0;
 	struct sk_buff *skb = NULL;
 	int len = 0, ret = 0;
 
@@ -299,9 +299,9 @@ static int mm_buffer_relink(struct sprdwl_mm *mm_entry,
 		len += SPRDWL_PHYS_LEN;
 		if (unlikely(len > total_len)) {
 			wl_err("%s: total_len:%d < len:%d\n",
-			       __func__, total_len, len);
+				   __func__, total_len, len);
 			wl_err("%s: total %d pkts, relink %d pkts\n",
-			       __func__, value->num, num);
+				   __func__, value->num, num);
 			len = -EINVAL;
 			break;
 		}
@@ -327,11 +327,11 @@ static int mm_buffer_relink(struct sprdwl_mm *mm_entry,
 }
 
 static int mm_buffer_unlink(struct sprdwl_mm *mm_entry,
-			    struct sprdwl_addr_trans_value *value,
-			    int total_len)
+				struct sprdwl_addr_trans_value *value,
+				int total_len)
 {
 	int num = 0;
-	unsigned long pcie_addr = 0;
+	uint64_t pcie_addr = 0;
 	struct sk_buff *skb = NULL;
 	struct rx_msdu_desc *msdu_desc = NULL;
 	int len = 0;
@@ -343,9 +343,9 @@ static int mm_buffer_unlink(struct sprdwl_mm *mm_entry,
 		len += SPRDWL_PHYS_LEN;
 		if (unlikely(len > total_len)) {
 			wl_err("%s: total_len:%d < len:%d\n",
-			       __func__, total_len, len);
+				   __func__, total_len, len);
 			wl_err("%s: total %d pkts, unlink %d pkts\n",
-			       __func__, value->num, num);
+				   __func__, value->num, num);
 			len = -EINVAL;
 			break;
 		}
@@ -414,7 +414,7 @@ mm_compound_data_process(struct sprdwl_mm *mm_entry, void *compound_data,
 		len += ALIGN_8BYTE(msdu_len);
 		if (unlikely(len > total_len)) {
 			wl_err("%s: total_len:%d < len:%d, leave %d pkts\n",
-			       __func__, total_len, len, (num + 1));
+				   __func__, total_len, len, (num + 1));
 			break;
 		}
 
@@ -424,7 +424,7 @@ mm_compound_data_process(struct sprdwl_mm *mm_entry, void *compound_data,
 		skb = mm_data2skb_process(mm_entry, pos_data, msdu_len);
 		if (unlikely(!skb)) {
 			wl_err("%s: alloc skb fail, leave %d pkts\n",
-			       __func__, (num + 1));
+				   __func__, (num + 1));
 			break;
 		}
 
@@ -452,7 +452,7 @@ static void mm_normal_data_process(struct sprdwl_mm *mm_entry,
 
 	if (unlikely(len < sizeof(struct rx_msdu_desc))) {
 		wl_err("%s: data len is %d, too short\n",
-		       __func__, len);
+			   __func__, len);
 		free_data = true;
 	} else {
 		csum = get_sdio_data_csum((void *)rx_if->intf, data);
@@ -546,7 +546,7 @@ static int mm_single_event_process(struct sprdwl_mm *mm_entry,
 
 /* PCIE DATA EVENT */
 void mm_mh_data_event_process(struct sprdwl_mm *mm_entry, void *data,
-			      int len, int buffer_type)
+				  int len, int buffer_type)
 {
 	int offset = 0;
 	struct sprdwl_addr_hdr *hdr =
@@ -568,7 +568,7 @@ void mm_mh_data_event_process(struct sprdwl_mm *mm_entry, void *data,
 		offset = mm_single_event_process(mm_entry, value, remain_len);
 		if (offset < 0) {
 			wl_err("%s: do mh event fail: %d!\n",
-			       __func__, offset);
+				   __func__, offset);
 			break;
 		}
 	}
@@ -593,7 +593,7 @@ int sprdwl_mm_init(struct sprdwl_mm *mm_entry, void *intf)
 	mm_entry->hif_offset = ((struct sprdwl_intf *)intf)->hif_offset;
 
 	if (((struct sprdwl_intf *)intf)->priv->hw_type ==
-	    SPRDWL_HW_PCIE) {
+		SPRDWL_HW_PCIE) {
 		skb_queue_head_init(&mm_entry->buffer_list);
 
 		ret = mm_buffer_alloc(mm_entry, SPRDWL_MAX_MH_BUF);
@@ -607,7 +607,7 @@ int sprdwl_mm_init(struct sprdwl_mm *mm_entry, void *intf)
 int sprdwl_mm_deinit(struct sprdwl_mm *mm_entry, void *intf)
 {
 	if (((struct sprdwl_intf *)intf)->priv->hw_type ==
-	    SPRDWL_HW_PCIE) {
+		SPRDWL_HW_PCIE) {
 		/* NOTE: pclint says kfree(NULL) is safe */
 		kfree(mm_entry->hdr);
 		mm_entry->hdr = NULL;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/msg.c b/drivers/net/wireless/uwe5622/unisocwifi/msg.c
index 511baf91f5de..f71a6879615d 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/msg.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/msg.c
@@ -17,7 +17,7 @@
 
 #include "sprdwl.h"
 #include "msg.h"
-
+#include "wcn_wrapper.h"
 /* static struct sprdwl_msg_list msg_list */
 
 int sprdwl_msg_init(int num, struct sprdwl_msg_list *list)
@@ -141,7 +141,7 @@ struct sprdwl_msg_buf *sprdwl_peek_msg_buf(struct sprdwl_msg_list *list)
 }
 
 void sprdwl_dequeue_msg_buf(struct sprdwl_msg_buf *msg_buf,
-			    struct sprdwl_msg_list *list)
+				struct sprdwl_msg_list *list)
 {
 	spin_lock_bh(&list->busylock);
 	list_del(&msg_buf->list);
@@ -169,6 +169,7 @@ struct sprdwl_msg_buf *sprdwl_get_msgbuf_by_data(void *data,
 	return find ? msg_buf : NULL;
 }
 
+#if defined(UWE5621_FTR)
 struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list)
 {
 	struct sprdwl_msg_buf *msg_buf = NULL;
@@ -180,4 +181,5 @@ struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list)
 	spin_unlock_bh(&list->busylock);
 	return msg_buf;
 }
+#endif
 
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/msg.h b/drivers/net/wireless/uwe5622/unisocwifi/msg.h
index dd57521ae708..67a4b474e74e 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/msg.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/msg.h
@@ -215,5 +215,7 @@ void sprdwl_dequeue_msg_buf(struct sprdwl_msg_buf *msg_buf,
 			    struct sprdwl_msg_list *list);
 struct sprdwl_msg_buf *sprdwl_get_msgbuf_by_data(void *data,
 						 struct sprdwl_msg_list *list);
+#if defined(UWE5621_FTR)
 struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list);
 #endif
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/nan.c b/drivers/net/wireless/uwe5622/unisocwifi/nan.c
index a08a3c076964..740ea0ad38a2 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/nan.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/nan.c
@@ -43,7 +43,7 @@ int sprdwl_vendor_nan_cmds(struct wiphy *wiphy,
 
 	memcpy(msg->data, data, len);
 	ret = sprdwl_cmd_send_recv(vif->priv, msg,
-				    CMD_WAIT_TIMEOUT, rsp, &rsp_len);
+					CMD_WAIT_TIMEOUT, rsp, &rsp_len);
 
 	if (!ret && rsp_len)
 		sprdwl_event_nan(vif, rsp, rsp_len);
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/npi.c b/drivers/net/wireless/uwe5622/unisocwifi/npi.c
index 00908c1a862f..42fe960c8289 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/npi.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/npi.c
@@ -148,7 +148,7 @@ static bool sprdwl_npi_cmd_is_start(void *buf)
 
 	msg = (struct sprdwl_npi_cmd_hdr *)buf;
 	if ((msg->type == SPRDWL_HT2CP_CMD) &&
-	    (msg->subtype == SPRDWL_NPI_CMD_START))
+		(msg->subtype == SPRDWL_NPI_CMD_START))
 		return true;
 	else
 		return false;
@@ -201,7 +201,7 @@ static int sprdwl_nl_npi_handler(struct sk_buff *skb_2, struct genl_info *info)
 		memcpy(r_buf, hdr, sizeof(*hdr));
 		memcpy(r_buf + sizeof(*hdr), &err, hdr->len);
 		ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
-					     SPRDWL_NL_CMD_NPI, r_len, r_buf);
+						 SPRDWL_NL_CMD_NPI, r_len, r_buf);
 		kfree(hdr);
 		kfree(r_buf);
 		return ret;
@@ -234,7 +234,7 @@ static int sprdwl_nl_npi_handler(struct sk_buff *skb_2, struct genl_info *info)
 #endif
 
 	ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
-				     SPRDWL_NL_CMD_NPI, r_len, r_buf);
+					 SPRDWL_NL_CMD_NPI, r_len, r_buf);
 
 	if (sprdwl_npi_cmd_is_start(s_buf)) {
 		msleep(100);
@@ -245,7 +245,7 @@ static int sprdwl_nl_npi_handler(struct sk_buff *skb_2, struct genl_info *info)
 }
 
 static int sprdwl_nl_get_info_handler(struct sk_buff *skb_2,
-				      struct genl_info *info)
+					  struct genl_info *info)
 {
 	struct net_device *ndev = info->user_ptr[0];
 	struct sprdwl_vif *vif = netdev_priv(ndev);
@@ -258,8 +258,8 @@ static int sprdwl_nl_get_info_handler(struct sk_buff *skb_2,
 		sprdwl_put_vif(vif);
 		r_len = 6;
 		ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
-					     SPRDWL_NL_CMD_GET_INFO, r_len,
-					     r_buf);
+						 SPRDWL_NL_CMD_GET_INFO, r_len,
+						 r_buf);
 	} else {
 		wl_err("%s NULL vif!\n", __func__);
 		ret = -1;
@@ -275,18 +275,14 @@ static struct nla_policy sprdwl_genl_policy[SPRDWL_NL_ATTR_MAX + 1] = {
 static struct genl_ops sprdwl_nl_ops[] = {
 	{
 		.cmd = SPRDWL_NL_CMD_NPI,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
-//		.policy = sprdwl_genl_policy,
-#else
+#if KERNEL_VERSION(5, 2, 0) > LINUX_VERSION_CODE
 		.policy = sprdwl_genl_policy,
 #endif
 		.doit = sprdwl_nl_npi_handler,
 	},
 	{
 		.cmd = SPRDWL_NL_CMD_GET_INFO,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
-//		.policy = sprdwl_genl_policy,
-#else
+#if KERNEL_VERSION(5, 2, 0) > LINUX_VERSION_CODE
 		.policy = sprdwl_genl_policy,
 #endif
 		.doit = sprdwl_nl_get_info_handler,
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/qos.c b/drivers/net/wireless/uwe5622/unisocwifi/qos.c
index c01d88fba346..d0e42a882cb4 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/qos.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/qos.c
@@ -192,7 +192,7 @@ void qos_set_dscp2up_table(unsigned char *dscp2up_table,
 			if (!qos_up_table_set(dscp2up_table, i / 2, range)) {
 				/* reset the table on failure */
 				memcpy(dscp2up_table, default_dscp2priomap,
-				       DSCP_MAX_VALUE);
+					   DSCP_MAX_VALUE);
 				return;
 			}
 		}
@@ -211,7 +211,7 @@ void qos_set_dscp2up_table(unsigned char *dscp2up_table,
 		}
 	}
 	wl_hex_dump(L_DBG, "qos up table: ", DUMP_PREFIX_OFFSET,
-			     16, 1, dscp2up_table, DSCP_MAX_VALUE, 0);
+				 16, 1, dscp2up_table, DSCP_MAX_VALUE, 0);
 }
 
 /*Todo*/
@@ -240,8 +240,8 @@ int fd_special_table[2][2] = {
 
 /*time slot ratio based on WFA spec*/
 int fd_ratio_table[3] = {7, /*vo: 87%, vi:13%*/
-			      9, /*vi:90%, be:10%*/
-			      5};/*be:81%, bk:19%*/
+				  9, /*vi:90%, be:10%*/
+				  5};/*be:81%, bk:19%*/
 #endif
 void qos_enable(int flag)
 {
@@ -267,7 +267,7 @@ void qos_init(struct tx_t *tx_t_list)
 			wl_err("%s malloc dscp2up_table fail\n", __func__);
 		else
 			memcpy(tx_t_list->dscp2up_table, default_dscp2priomap,
-			       DSCP_MAX_VALUE);
+				   DSCP_MAX_VALUE);
 	}
 #endif
 }
@@ -552,9 +552,15 @@ void wmm_ac_init(struct sprdwl_priv *priv)
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	timer_setup(&priv->wmmac.wmmac_edcaf_timer, update_wmmac_edcaftime_timeout, 0);
+	timer_setup(&priv->wmmac.wmmac_vo_timer, update_wmmac_vo_timeout, 0);
+	timer_setup(&priv->wmmac.wmmac_vi_timer, update_wmmac_vi_timeout, 0);
 #else
 	setup_timer(&priv->wmmac.wmmac_edcaf_timer, update_wmmac_edcaftime_timeout,
-		    (unsigned long)priv);
+			(unsigned long)priv);
+	setup_timer(&priv->wmmac.wmmac_vo_timer, update_wmmac_vo_timeout,
+			(unsigned long)priv);
+	setup_timer(&priv->wmmac.wmmac_vi_timer, update_wmmac_vi_timeout,
+			(unsigned long)priv);
 #endif
 	memset(&priv->wmmac.ac[0], 0, 4*sizeof(struct wmm_ac_params));
 }
@@ -570,6 +576,12 @@ void reset_wmmac_parameters(struct sprdwl_priv *priv)
 	if (timer_pending(&priv->wmmac.wmmac_edcaf_timer))
 		del_timer_sync(&priv->wmmac.wmmac_edcaf_timer);
 
+	if (timer_pending(&priv->wmmac.wmmac_vo_timer))
+		del_timer_sync(&priv->wmmac.wmmac_vo_timer);
+
+	if (timer_pending(&priv->wmmac.wmmac_vi_timer))
+		del_timer_sync(&priv->wmmac.wmmac_vi_timer);
+
 	memset(&priv->wmmac.ac[0], 0, 4*sizeof(struct wmm_ac_params));
 }
 
@@ -685,6 +697,14 @@ void update_admitted_time(struct sprdwl_priv *priv, u8 tsid, u16 medium_time, bo
 		g_wmmac_admittedtime[ac] += (medium_time<<5);
 		mod_timer(&priv->wmmac.wmmac_edcaf_timer,
 				jiffies + WMMAC_EDCA_TIMEOUT_MS * HZ / 1000);
+
+		/*replace the usedtime logic method with timer counter, just for simplify for the WFA certification*/
+		if (ac == AC_VO)
+			mod_timer(&priv->wmmac.wmmac_vo_timer,
+				jiffies + usecs_to_jiffies(g_wmmac_admittedtime[ac] * WMMAC_TIME_RATIO));
+		else if (ac == AC_VI)
+			mod_timer(&priv->wmmac.wmmac_vi_timer,
+				jiffies + usecs_to_jiffies(g_wmmac_admittedtime[ac] * WMMAC_TIME_RATIO));
 	} else {
 		if (g_wmmac_admittedtime[ac] > (medium_time<<5))
 			g_wmmac_admittedtime[ac] -= (medium_time<<5);
@@ -692,6 +712,12 @@ void update_admitted_time(struct sprdwl_priv *priv, u8 tsid, u16 medium_time, bo
 			g_wmmac_admittedtime[ac] = 0;
 			if (timer_pending(&priv->wmmac.wmmac_edcaf_timer))
 				del_timer_sync(&priv->wmmac.wmmac_edcaf_timer);
+
+			if (timer_pending(&priv->wmmac.wmmac_vo_timer))
+				del_timer_sync(&priv->wmmac.wmmac_vo_timer);
+
+			if (timer_pending(&priv->wmmac.wmmac_vi_timer))
+				del_timer_sync(&priv->wmmac.wmmac_vi_timer);
 		}
 	}
 
@@ -712,13 +738,38 @@ void update_wmmac_edcaftime_timeout(unsigned long data)
 	if (g_wmmac_admittedtime[AC_VO] > 0) {
 		g_wmmac_usedtime[AC_VO] = 0;
 		g_wmmac_available[AC_VO] = true;
+		mod_timer(&priv->wmmac.wmmac_vo_timer,
+			jiffies + usecs_to_jiffies(g_wmmac_admittedtime[AC_VO] * WMMAC_TIME_RATIO));
 	}
 	if (g_wmmac_admittedtime[AC_VI] > 0) {
 		g_wmmac_usedtime[AC_VI] = 0;
 		g_wmmac_available[AC_VI] = true;
+		mod_timer(&priv->wmmac.wmmac_vi_timer,
+			jiffies + usecs_to_jiffies(g_wmmac_admittedtime[AC_VI] * WMMAC_TIME_RATIO));
 	}
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_vo_timeout(struct timer_list *t)
+#else
+void update_wmmac_vo_timeout(unsigned long data)
+#endif
+{
+	g_wmmac_usedtime[AC_VO] = g_wmmac_admittedtime[AC_VO];
+	g_wmmac_available[AC_VO] = false;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_vi_timeout(struct timer_list *t)
+#else
+void update_wmmac_vi_timeout(unsigned long data)
+#endif
+{
+	g_wmmac_usedtime[AC_VI] = g_wmmac_admittedtime[AC_VI];
+	g_wmmac_available[AC_VI] = false;
+
+}
+
 /*change priority according to the g_wmmac_available value */
 unsigned int change_priority_if(struct sprdwl_priv *priv, unsigned char *tid, unsigned char *tos, u16 len)
 {
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/qos.h b/drivers/net/wireless/uwe5622/unisocwifi/qos.h
index 2a99178bcea4..3d69d1c5730a 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/qos.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/qos.h
@@ -79,6 +79,7 @@ struct qos_map_set {
 #define NUM_AC 4
 #define NUM_TID 16
 #define WMMAC_EDCA_TIMEOUT_MS		1000
+#define WMMAC_TIME_RATIO	12
 
 #define WLAN_EID_VENDOR_SPECIFIC 221
 #define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
@@ -236,11 +237,13 @@ u16 get_wmmac_admitted_time(u8 tsid);
 void reset_wmmac_parameters(struct sprdwl_priv *priv);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 void update_wmmac_edcaftime_timeout(struct timer_list *t);
+void update_wmmac_vo_timeout(struct timer_list *t);
+void update_wmmac_vi_timeout(struct timer_list *t);
 #else
 void update_wmmac_edcaftime_timeout(unsigned long data);
-#endif
 void update_wmmac_vo_timeout(unsigned long data);
 void update_wmmac_vi_timeout(unsigned long data);
+#endif
 unsigned int change_priority_if(struct sprdwl_priv *priv, unsigned char *tid, unsigned char *tos, u16 len);
 const u8 *get_wmm_ie(u8 *res, u16 ie_len, u8 ie, uint oui, uint oui_type);
 #endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c b/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
index 5a9857757f53..fb15045e1764 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
@@ -253,7 +253,7 @@ void ShowChannel(struct wiphy *pWiphy)
 
 			if (chan->flags & IEEE80211_CHAN_DISABLED) {
 				wl_info("disable channels[%d][%d]: ch%d (freq = %d) flags=0x%x\n",
-				    band_idx, ch_idx, chan->hw_value, chan->center_freq, chan->flags);
+					band_idx, ch_idx, chan->hw_value, chan->center_freq, chan->flags);
 				continue;
 			}
 
@@ -272,7 +272,7 @@ void ShowChannel(struct wiphy *pWiphy)
 }
 
 static bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,
-			      u32 freq_khz)
+				  u32 freq_khz)
 {
 #define ONE_GHZ_IN_KHZ	1000000
 	/*
@@ -290,7 +290,7 @@ static bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,
 #undef ONE_GHZ_IN_KHZ
 }
 static bool reg_does_bw_fit(const struct ieee80211_freq_range *freq_range,
-			    u32 center_freq_khz, u32 bw_khz)
+				u32 center_freq_khz, u32 bw_khz)
 {
 	u32 start_freq_khz, end_freq_khz;
 
@@ -298,7 +298,7 @@ static bool reg_does_bw_fit(const struct ieee80211_freq_range *freq_range,
 	end_freq_khz = center_freq_khz + (bw_khz/2);
 
 	if (start_freq_khz >= freq_range->start_freq_khz &&
-	    end_freq_khz <= freq_range->end_freq_khz)
+		end_freq_khz <= freq_range->end_freq_khz)
 		return true;
 
 	return false;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/reorder.c b/drivers/net/wireless/uwe5622/unisocwifi/reorder.c
index 1cb3f9178eeb..c6c77648ddde 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/reorder.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/reorder.c
@@ -49,7 +49,7 @@ set_ba_node_desc(struct rx_ba_node_desc *ba_node_desc,
 	ba_node_desc->win_size = win_size;
 	ba_node_desc->win_start = win_start;
 	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
-					    (ba_node_desc->win_size - 1));
+						(ba_node_desc->win_size - 1));
 	ba_node_desc->win_tail = SEQNO_SUB(ba_node_desc->win_start, 1);
 	ba_node_desc->index_mask = index_mask;
 	ba_node_desc->buff_cnt = 0;
@@ -70,7 +70,7 @@ static inline void set_ba_pkt_desc(struct rx_ba_pkt_desc *ba_pkt_desc,
 
 static inline void
 reorder_set_skb_list(struct sprdwl_rx_ba_entry *ba_entry,
-		     struct sk_buff *skb_head, struct sk_buff *skb_last)
+			 struct sk_buff *skb_head, struct sk_buff *skb_last)
 {
 	spin_lock_bh(&ba_entry->skb_list_lock);
 	if (!ba_entry->skb_head) {
@@ -114,16 +114,16 @@ static inline void mod_reorder_timer(struct rx_ba_node *ba_node)
 }
 
 static inline bool is_same_pn(struct rx_ba_pkt_desc *ba_pkt_desc,
-			      struct rx_msdu_desc *msdu_desc)
+				  struct rx_msdu_desc *msdu_desc)
 {
 	bool ret = true;
 	unsigned char cipher_type = 0;
 
 	cipher_type = ba_pkt_desc->cipher_type;
 	if ((cipher_type == SPRDWL_HW_TKIP) ||
-	    (cipher_type == SPRDWL_HW_CCMP)) {
+		(cipher_type == SPRDWL_HW_CCMP)) {
 		if ((ba_pkt_desc->pn_l != msdu_desc->pn_l) ||
-		    (ba_pkt_desc->pn_h != msdu_desc->pn_h))
+			(ba_pkt_desc->pn_h != msdu_desc->pn_h))
 			ret = false;
 	}
 
@@ -131,7 +131,7 @@ static inline bool is_same_pn(struct rx_ba_pkt_desc *ba_pkt_desc,
 }
 
 static inline bool replay_detection(struct rx_ba_pkt_desc *ba_pkt_desc,
-				    struct rx_ba_node_desc *ba_node_desc)
+					struct rx_ba_node_desc *ba_node_desc)
 {
 	bool ret = true;
 	unsigned int old_val_low = 0;
@@ -147,7 +147,7 @@ static inline bool replay_detection(struct rx_ba_pkt_desc *ba_pkt_desc,
 	 *	  HW do not support other cipher type now
 	 */
 	if ((cipher_type == SPRDWL_HW_TKIP) ||
-	    (cipher_type == SPRDWL_HW_CCMP)) {
+		(cipher_type == SPRDWL_HW_CCMP)) {
 		old_val_low = ba_node_desc->pn_l;
 		old_val_high = ba_node_desc->pn_h;
 		rx_val_low = ba_pkt_desc->pn_l;
@@ -156,13 +156,13 @@ static inline bool replay_detection(struct rx_ba_pkt_desc *ba_pkt_desc,
 		if ((1 == ba_node_desc->reset_pn) &&
 			(old_val_low >= rx_val_low) && (old_val_high >= rx_val_high)) {
 			wl_err("%s: clear reset_pn,old_val_low: %d, old_val_high: %d, rx_val_low: %d, rx_val_high: %d\n",
-			       __func__, old_val_low, old_val_high, rx_val_low, rx_val_high);
+				   __func__, old_val_low, old_val_high, rx_val_low, rx_val_high);
 			ba_node_desc->reset_pn = 0;
 			ba_node_desc->pn_l = rx_val_low;
 			ba_node_desc->pn_h = rx_val_high;
 		} else if (((old_val_high == rx_val_high) &&
-		     (old_val_low < rx_val_low)) ||
-		    (old_val_high < rx_val_high)) {
+			 (old_val_low < rx_val_low)) ||
+			(old_val_high < rx_val_high)) {
 			ba_node_desc->pn_l = rx_val_low;
 			ba_node_desc->pn_h = rx_val_high;
 		} else {
@@ -295,11 +295,11 @@ send_msdu_with_gap(struct sprdwl_rx_ba_entry *ba_entry,
 }
 
 static inline void between_seqlo_seqhi(struct sprdwl_rx_ba_entry *ba_entry,
-				       struct rx_ba_node_desc *ba_node_desc)
+					   struct rx_ba_node_desc *ba_node_desc)
 {
 	ba_node_desc->win_start = send_msdu_in_order(ba_entry, ba_node_desc);
 	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
-					    (ba_node_desc->win_size - 1));
+						(ba_node_desc->win_size - 1));
 }
 
 static inline void
@@ -315,12 +315,12 @@ greater_than_seqhi(struct sprdwl_rx_ba_entry *ba_entry,
 	ba_node_desc->win_start = pos_win_start;
 	ba_node_desc->win_start = send_msdu_in_order(ba_entry, ba_node_desc);
 	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
-					    (ba_node_desc->win_size - 1));
+						(ba_node_desc->win_size - 1));
 }
 
 static inline void bar_send_ba_buffer(struct sprdwl_rx_ba_entry *ba_entry,
-				      struct rx_ba_node_desc *ba_node_desc,
-				      unsigned short seq_num)
+					  struct rx_ba_node_desc *ba_node_desc,
+					  unsigned short seq_num)
 {
 	if (!seqno_leq(seq_num, ba_node_desc->win_start)) {
 		send_msdu_with_gap(ba_entry, ba_node_desc, seq_num);
@@ -335,7 +335,7 @@ static inline void bar_send_ba_buffer(struct sprdwl_rx_ba_entry *ba_entry,
 
 static inline int
 insert_msdu(struct rx_msdu_desc *msdu_desc, struct sk_buff *skb,
-	    struct rx_ba_node_desc *ba_node_desc)
+		struct rx_ba_node_desc *ba_node_desc)
 {
 	int ret = 0;
 	unsigned short seq_num = msdu_desc->seq_num;
@@ -347,7 +347,7 @@ insert_msdu(struct rx_msdu_desc *msdu_desc, struct sk_buff *skb,
 
 	if (insert->desc.msdu_num != 0) {
 		if ((insert->desc.seq == seq_num) && (insert->desc.last != 1) &&
-		    is_same_pn(&insert->desc, msdu_desc)) {
+			is_same_pn(&insert->desc, msdu_desc)) {
 			joint_msdu(insert, skb);
 			insert->desc.msdu_num++;
 			insert->desc.last = last_msdu_flag;
@@ -385,7 +385,7 @@ static int reorder_msdu(struct sprdwl_rx_ba_entry *ba_entry,
 			ba_node_desc->win_tail = seq_num;
 	} else {
 		wl_debug("%s: seq_num: %d is less than win_start: %d\n",
-		       __func__, seq_num, ba_node_desc->win_start);
+			   __func__, seq_num, ba_node_desc->win_start);
 	}
 
 	if (ret && skb) {
@@ -417,7 +417,7 @@ static void reorder_msdu_process(struct sprdwl_rx_ba_entry *ba_entry,
 
 		/* FIXME: Data come in sequence in default */
 		if ((seq_num == ba_node_desc->win_start) &&
-		    !ba_node_desc->buff_cnt && last_msdu_flag) {
+			!ba_node_desc->buff_cnt && last_msdu_flag) {
 			send_order_msdu(ba_entry, msdu_desc, skb, ba_node_desc);
 			goto out;
 		}
@@ -426,7 +426,7 @@ static void reorder_msdu_process(struct sprdwl_rx_ba_entry *ba_entry,
 		ret = reorder_msdu(ba_entry, msdu_desc, skb, ba_node);
 		if (!ret) {
 			if (last_msdu_flag &&
-			    (seq_num == ba_node_desc->win_start)) {
+				(seq_num == ba_node_desc->win_start)) {
 				between_seqlo_seqhi(ba_entry, ba_node_desc);
 				mod_reorder_timer(ba_node);
 			} else if (!timer_pending(&ba_node->reorder_timer) ||
@@ -440,8 +440,8 @@ static void reorder_msdu_process(struct sprdwl_rx_ba_entry *ba_entry,
 			ba_node->timeout_cnt = 0;
 		}
 	} else {
-		wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
-		       __func__, msdu_desc->sta_lut_index, msdu_desc->tid);
+		//wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
+		//	   __func__, msdu_desc->sta_lut_index, msdu_desc->tid);
 		reorder_set_skb_list(ba_entry, skb, skb);
 	}
 
@@ -472,13 +472,13 @@ static inline void init_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
 }
 
 static inline bool is_same_ba(struct rx_ba_node *ba_node,
-			      unsigned char sta_lut_index, unsigned char tid)
+				  unsigned char sta_lut_index, unsigned char tid)
 {
 	bool ret = false;
 
 	if (ba_node) {
 		if ((ba_node->sta_lut_index == sta_lut_index) &&
-		    (ba_node->tid == tid))
+			(ba_node->tid == tid))
 			ret = true;
 	}
 
@@ -487,7 +487,7 @@ static inline bool is_same_ba(struct rx_ba_node *ba_node,
 
 static struct rx_ba_node
 *find_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
-	      unsigned char sta_lut_index, unsigned char tid)
+		  unsigned char sta_lut_index, unsigned char tid)
 {
 	struct rx_ba_node *ba_node = NULL;
 
@@ -500,7 +500,7 @@ static struct rx_ba_node
 			if (!hlist_empty(head)) {
 				hlist_for_each_entry(ba_node, head, hlist) {
 					if (sta_lut_index ==
-					    ba_node->sta_lut_index) {
+						ba_node->sta_lut_index) {
 						ba_entry->current_ba_node =
 							ba_node;
 						break;
@@ -510,7 +510,7 @@ static struct rx_ba_node
 		}
 	} else {
 		wl_err("%s: TID is too large sta_lut_index: %d, tid: %d\n",
-		       __func__, sta_lut_index, tid);
+			   __func__, sta_lut_index, tid);
 	}
 
 	return ba_node;
@@ -569,16 +569,16 @@ void reset_pn(struct sprdwl_priv *priv, const u8 *mac_addr)
 			spin_lock_bh(&ba_node->ba_node_lock);
 			ba_node->rx_ba->reset_pn = 1;
 			wl_info("%s: set,lut=%d,tid=%d,pn_l=%d,pn_h=%d\n",
-			       __func__, lut_id, tid,
-			       ba_node->rx_ba->pn_l,
-			       ba_node->rx_ba->pn_h);
+				   __func__, lut_id, tid,
+				   ba_node->rx_ba->pn_l,
+				   ba_node->rx_ba->pn_h);
 			spin_unlock_bh(&ba_node->ba_node_lock);
 		}
 	}
 }
 
 struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
-				     struct sk_buff *pskb)
+					 struct sk_buff *pskb)
 {
 	struct rx_ba_node *ba_node = NULL;
 	struct rx_msdu_desc *msdu_desc = NULL;
@@ -592,11 +592,11 @@ struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
 
 		if (!msdu_desc->bc_mc_flag && msdu_desc->qos_flag) {
 			ba_node = find_ba_node(ba_entry,
-					       msdu_desc->sta_lut_index,
-					       msdu_desc->tid);
+						   msdu_desc->sta_lut_index,
+						   msdu_desc->tid);
 			if (ba_node)
 				reorder_msdu_process(ba_entry, msdu_desc,
-						     pskb, ba_node);
+							 pskb, ba_node);
 			else
 				reorder_set_skb_list(ba_entry, pskb, pskb);
 		} else {
@@ -612,13 +612,13 @@ struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
 }
 
 static void wlan_filter_event(struct sprdwl_rx_ba_entry *ba_entry,
-			      struct sprdwl_event_ba *ba_event)
+				  struct sprdwl_event_ba *ba_event)
 {
 	struct rx_ba_node *ba_node = NULL;
 	struct rx_msdu_desc msdu_desc;
 
 	ba_node = find_ba_node(ba_entry,
-			       ba_event->sta_lut_index, ba_event->tid);
+				   ba_event->sta_lut_index, ba_event->tid);
 	if (ba_node) {
 		msdu_desc.last_msdu_of_mpdu = 1;
 		msdu_desc.seq_num = ba_event->msdu_param.seq_num;
@@ -631,17 +631,17 @@ static void wlan_filter_event(struct sprdwl_rx_ba_entry *ba_entry,
 }
 
 static void wlan_delba_event(struct sprdwl_rx_ba_entry *ba_entry,
-			     struct sprdwl_event_ba *ba_event)
+				 struct sprdwl_event_ba *ba_event)
 {
 	struct rx_ba_node *ba_node = NULL;
 	struct rx_ba_node_desc *ba_node_desc = NULL;
 
 	wl_info("enter %s\n", __func__);
 	ba_node = find_ba_node(ba_entry,
-			       ba_event->sta_lut_index, ba_event->tid);
+				   ba_event->sta_lut_index, ba_event->tid);
 	if (!ba_node) {
 		wl_err("%s: NOT FOUND sta_lut_index: %d, tid: %d\n",
-		       __func__, ba_event->sta_lut_index, ba_event->tid);
+			   __func__, ba_event->sta_lut_index, ba_event->tid);
 		return;
 	}
 
@@ -672,10 +672,10 @@ static void wlan_bar_event(struct sprdwl_rx_ba_entry *ba_entry,
 
 	wl_info("enter %s\n", __func__);
 	ba_node = find_ba_node(ba_entry,
-			       ba_event->sta_lut_index, ba_event->tid);
+				   ba_event->sta_lut_index, ba_event->tid);
 	if (!ba_node) {
 		wl_err("%s: NOT FOUND sta_lut_index: %d, tid: %d\n",
-		       __func__, ba_event->sta_lut_index, ba_event->tid);
+			   __func__, ba_event->sta_lut_index, ba_event->tid);
 		return;
 	}
 
@@ -683,7 +683,7 @@ static void wlan_bar_event(struct sprdwl_rx_ba_entry *ba_entry,
 	if (ba_node->active) {
 		ba_node_desc = ba_node->rx_ba;
 		if (!seqno_leq(ba_event->win_param.win_start,
-			       ba_node_desc->win_start)) {
+				   ba_node_desc->win_start)) {
 			bar_send_ba_buffer(ba_entry, ba_node_desc,
 					   ba_event->win_param.win_start);
 			mod_reorder_timer(ba_node);
@@ -696,7 +696,7 @@ static void wlan_bar_event(struct sprdwl_rx_ba_entry *ba_entry,
 			ba_node_desc->win_start, ba_node_desc->win_tail);
 	} else {
 		wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
-		       __func__, ba_event->sta_lut_index, ba_event->tid);
+			   __func__, ba_event->sta_lut_index, ba_event->tid);
 	}
 	spin_unlock_bh(&ba_node->ba_node_lock);
 }
@@ -733,7 +733,7 @@ static void send_addba_rsp(struct sprdwl_rx_ba_entry *ba_entry,
 }
 
 static void send_delba(struct sprdwl_rx_ba_entry *ba_entry,
-		       unsigned short tid, unsigned char sta_lut_index)
+			   unsigned short tid, unsigned char sta_lut_index)
 {
 	struct sprdwl_cmd_ba delba;
 	struct sprdwl_intf *intf = NULL;
@@ -760,7 +760,7 @@ static void send_delba(struct sprdwl_rx_ba_entry *ba_entry,
 }
 
 static int wlan_addba_event(struct sprdwl_rx_ba_entry *ba_entry,
-			    struct sprdwl_event_ba *ba_event)
+				struct sprdwl_event_ba *ba_event)
 {
 	struct rx_ba_node *ba_node = NULL;
 	int ret = 0;
@@ -797,7 +797,7 @@ static int wlan_addba_event(struct sprdwl_rx_ba_entry *ba_entry,
 	} else {
 		/* Should never happen */
 		wl_err("%s: BA SESSION IS ACTIVE sta_lut_index: %d, tid: %d\n",
-		       __func__, sta_lut_index, tid);
+			   __func__, sta_lut_index, tid);
 		ret = -EINVAL;
 	}
 	spin_unlock_bh(&ba_node->ba_node_lock);
@@ -823,7 +823,7 @@ void wlan_ba_session_event(void *hw_intf,
 	case SPRDWL_ADDBA_REQ_EVENT:
 		ret = wlan_addba_event(ba_entry, ba_event);
 		send_addba_rsp(ba_entry, ba_event->tid,
-			       ba_event->sta_lut_index, ret);
+				   ba_event->sta_lut_index, ret);
 		break;
 	case SPRDWL_DELBA_EVENT:
 		wlan_delba_event(ba_entry, ba_event);
@@ -927,7 +927,7 @@ static void ba_reorder_timeout(unsigned long data)
 	debug_cnt_inc(REORDER_TIMEOUT_CNT);
 	spin_lock_bh(&ba_node->ba_node_lock);
 	if (ba_node->active && ba_node_desc->buff_cnt &&
-	    !timer_pending(&ba_node->reorder_timer)) {
+		!timer_pending(&ba_node->reorder_timer)) {
 		pos_seqno = get_first_seqno_in_buff(ba_node_desc);
 		send_msdu_with_gap(ba_entry, ba_node_desc, pos_seqno);
 		ba_node_desc->win_start = pos_seqno;
@@ -1009,8 +1009,8 @@ void sprdwl_active_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
 
 	ba_node = find_ba_node(ba_entry, sta_lut_index, tid);
 	if (ba_node == NULL) {
-	    wl_err("BA node not found, tid = %d\n", tid);
-	    return;
+		wl_err("BA node not found, tid = %d\n", tid);
+		return;
 	}
 
 	spin_lock_bh(&ba_node->ba_node_lock);
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c b/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
index a2f6cc394ce1..ca307f12ac99 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
@@ -181,9 +181,9 @@ static struct nvm_name_table g_config_table[] = {
 	CF_TAB("Chain0_149", tx_scale.chain0[34][0], 1),
 	CF_TAB("Chain1_149", tx_scale.chain1[34][0], 1),
 	CF_TAB("Chain0_153", tx_scale.chain0[35][0], 1),
-	CF_TAB("Chain1_153", tx_scale.chain0[35][0], 1),
+	CF_TAB("Chain1_153", tx_scale.chain1[35][0], 1),
 	CF_TAB("Chain0_157", tx_scale.chain0[36][0], 1),
-	CF_TAB("Chain1_157", tx_scale.chain0[36][0], 1),
+	CF_TAB("Chain1_157", tx_scale.chain1[36][0], 1),
 	CF_TAB("Chain0_161", tx_scale.chain0[37][0], 1),
 	CF_TAB("Chain1_161", tx_scale.chain1[37][0], 1),
 	CF_TAB("Chain0_165", tx_scale.chain0[38][0], 1),
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rtt.c b/drivers/net/wireless/uwe5622/unisocwifi/rtt.c
index 69d6965638fb..9f0e9f2d3dd0 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/rtt.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rtt.c
@@ -203,8 +203,8 @@ static u8 sprdwl_ftm_get_channel(struct wiphy *wiphy,
 		channel = chan->hw_value;
 	} else {
 		bss = cfg80211_get_bss(wiphy, NULL, mac_addr,
-				       NULL, 0, WLAN_CAPABILITY_ESS,
-				       WLAN_CAPABILITY_ESS);
+					   NULL, 0, WLAN_CAPABILITY_ESS,
+					   WLAN_CAPABILITY_ESS);
 		if (!bss) {
 			wl_err("Unable to find BSS\n");
 			return 0;
@@ -232,7 +232,7 @@ static int sprdwl_ftm_parse_meas_params(struct sprdwl_vif *vif,
 	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	rc = nla_parse_nested(tb, SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX,
-			      attr, sprdwl_nl80211_ftm_meas_param_policy, NULL);
+				  attr, sprdwl_nl80211_ftm_meas_param_policy, NULL);
 #else
 	rc = nla_parse_nested(tb, SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX,
 				attr, sprdwl_nl80211_ftm_meas_param_policy);
@@ -262,7 +262,7 @@ sprdwl_ftm_validate_meas_params(struct sprdwl_vif *vif,
 				struct sprdwl_ftm_meas_params *params)
 {
 	if (params->meas_per_burst > FTM_MAX_MEAS_PER_BURST ||
-	    params->num_of_bursts_exp != 0) {
+		params->num_of_bursts_exp != 0) {
 		wl_ndev_log(L_ERR, vif->ndev, "%s: invalid meas per burst\n", __func__);
 		return -EINVAL;
 	}
@@ -281,12 +281,12 @@ static int sprdwl_ftm_append_meas_params(struct sprdwl_priv *priv,
 	if (!nl_p)
 		goto out_put_failure;
 	if (nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST,
-		       params->meas_per_burst) ||
-	    nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP,
-		       params->num_of_bursts_exp) ||
-	    nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION,
-		       params->burst_duration) ||
-	    nla_put_u16(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD,
+			   params->meas_per_burst) ||
+		nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP,
+			   params->num_of_bursts_exp) ||
+		nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION,
+			   params->burst_duration) ||
+		nla_put_u16(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD,
 			params->burst_period))
 		goto out_put_failure;
 	nla_nest_end(msg, nl_p);
@@ -303,19 +303,19 @@ static int sprdwl_ftm_append_peer_meas_res(struct sprdwl_priv *priv,
 	int i;
 
 	if (nla_put(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR,
-		    ETH_ALEN, res->mac_addr) ||
-	    nla_put_u32(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS,
+			ETH_ALEN, res->mac_addr) ||
+		nla_put_u32(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS,
 			res->flags) ||
-	    nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS,
-		       res->status))
+		nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS,
+			   res->status))
 		goto out_put_failure;
 	if (res->status == SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED &&
-	    nla_put_u8(msg,
-		       SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS,
-		       res->value_seconds))
+		nla_put_u8(msg,
+			   SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS,
+			   res->value_seconds))
 		goto out_put_failure;
 	if (res->has_params &&
-	    sprdwl_ftm_append_meas_params(priv, msg, &res->params))
+		sprdwl_ftm_append_meas_params(priv, msg, &res->params))
 		goto out_put_failure;
 	nl_mres = nla_nest_start(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS);
 	if (!nl_mres)
@@ -327,21 +327,21 @@ static int sprdwl_ftm_append_peer_meas_res(struct sprdwl_priv *priv,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
 		if (nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
 				res->meas[i].t1, 0) ||
-		    nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+			nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
 				res->meas[i].t2, 0) ||
-		    nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+			nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
 				res->meas[i].t3, 0) ||
-		    nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+			nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
 				res->meas[i].t4, 0))
 			goto out_put_failure;
 #else
 		if (nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
 				res->meas[i].t1) ||
-		    nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+			nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
 				res->meas[i].t2) ||
-		    nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+			nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
 				res->meas[i].t3) ||
-		    nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+			nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
 				res->meas[i].t4))
 			goto out_put_failure;
 #endif
@@ -444,26 +444,26 @@ sprdwl_ftm_cfg80211_start_session(struct sprdwl_priv *priv,
 
 	for (i = 0; i < request->n_peers; i++) {
 		if (request->peers[i].flags &
-		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
 			has_lci = true;
 		if (request->peers[i].flags &
-		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
 			has_lcr = true;
 		max_meas = max(max_meas,
-			       request->peers[i].params.meas_per_burst);
+				   request->peers[i].params.meas_per_burst);
 	}
 
 	priv->ftm.ftm_res = kzalloc(sizeof(*priv->ftm.ftm_res) +
-		      max_meas * sizeof(struct sprdwl_ftm_peer_meas) +
-		      (has_lci ? FTM_MAX_LCI_LENGTH : 0) +
-		      (has_lcr ? FTM_MAX_LCR_LENGTH : 0), GFP_KERNEL);
+			  max_meas * sizeof(struct sprdwl_ftm_peer_meas) +
+			  (has_lci ? FTM_MAX_LCI_LENGTH : 0) +
+			  (has_lcr ? FTM_MAX_LCR_LENGTH : 0), GFP_KERNEL);
 	if (!priv->ftm.ftm_res) {
 		ret = -ENOMEM;
 		goto out;
 	}
 	ptr = (u8 *)priv->ftm.ftm_res;
 	ptr += sizeof(struct sprdwl_ftm_peer_meas_res) +
-	       max_meas * sizeof(struct sprdwl_ftm_peer_meas);
+		   max_meas * sizeof(struct sprdwl_ftm_peer_meas);
 	if (has_lci) {
 		priv->ftm.ftm_res->lci = ptr;
 		ptr += FTM_MAX_LCI_LENGTH;
@@ -490,13 +490,13 @@ sprdwl_ftm_cfg80211_start_session(struct sprdwl_priv *priv,
 						 request->peers[i].freq);
 		if (!channel) {
 			wl_err("%s: can't find FTM target at index %d\n",
-			       __func__, i);
+				   __func__, i);
 			ret = -EINVAL;
 			goto out_cmd;
 		}
 		cmd->dest_info[i].channel = channel - 1;
 		if (request->peers[i].flags &
-		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE) {
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE) {
 			cmd->dest_info[i].flags |=
 				FTM_SESSION_START_FLAG_SECURED;
 			cmd->dest_info[i].initial_token =
@@ -506,15 +506,15 @@ sprdwl_ftm_cfg80211_start_session(struct sprdwl_priv *priv,
 				FTM_DEFAULT_INITIAL_TOKEN;
 		}
 		if (request->peers[i].flags &
-		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP)
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP)
 			cmd->dest_info[i].flags |=
 				FTM_SESSION_START_FLAG_ASAP;
 		if (request->peers[i].flags &
-		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
 			cmd->dest_info[i].flags |=
 				FTM_SESSION_START_FLAG_LCI_REQ;
 		if (request->peers[i].flags &
-		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
 			cmd->dest_info[i].flags |=
 				FTM_SESSION_START_FLAG_LCR_REQ;
 		cmd->dest_info[i].num_of_ftm_per_burst =
@@ -595,13 +595,13 @@ sprdwl_ftm_session_ended(struct sprdwl_priv *priv, u32 status)
 	if (nla_put_u64_64bit(skb,
 				SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
 				priv->ftm.session_cookie, 0) ||
-	    nla_put_u32(skb,
+		nla_put_u32(skb,
 			SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS, status)) {
 #else
 	if (nla_put_u64(skb,
 			SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
 			priv->ftm.session_cookie) ||
-	    nla_put_u32(skb,
+		nla_put_u32(skb,
 			SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS, status)) {
 #endif
 		wl_err("%s: failed to fill session done event\n", __func__);
@@ -625,13 +625,13 @@ void sprdwl_ftm_event_per_dest_res(struct sprdwl_priv *priv,
 
 	if (!priv->ftm.session_started || !priv->ftm.ftm_res) {
 		wl_err("%s: Session not running, ignoring res event\n",
-		       __func__);
+			   __func__);
 		goto out;
 	}
 	if (priv->ftm.has_ftm_res &&
-	    !ether_addr_equal(res->dst_mac, priv->ftm.ftm_res->mac_addr)) {
+		!ether_addr_equal(res->dst_mac, priv->ftm.ftm_res->mac_addr)) {
 		wl_err("%s: previous peer not properly terminated\n",
-		       __func__);
+			   __func__);
 		sprdwl_ftm_send_peer_res(priv);
 	}
 
@@ -670,16 +670,16 @@ void sprdwl_ftm_event_per_dest_res(struct sprdwl_priv *priv,
 			break;
 		}
 		memcpy(&tmp, res->responder_ftm_res[i].t1,
-		       sizeof(res->responder_ftm_res[i].t1));
+			   sizeof(res->responder_ftm_res[i].t1));
 		priv->ftm.ftm_res->meas[index].t1 = le64_to_cpu(tmp);
 		memcpy(&tmp, res->responder_ftm_res[i].t2,
-		       sizeof(res->responder_ftm_res[i].t2));
+			   sizeof(res->responder_ftm_res[i].t2));
 		priv->ftm.ftm_res->meas[index].t2 = le64_to_cpu(tmp);
 		memcpy(&tmp, res->responder_ftm_res[i].t3,
-		       sizeof(res->responder_ftm_res[i].t3));
+			   sizeof(res->responder_ftm_res[i].t3));
 		priv->ftm.ftm_res->meas[index].t3 = le64_to_cpu(tmp);
 		memcpy(&tmp, res->responder_ftm_res[i].t4,
-		       sizeof(res->responder_ftm_res[i].t4));
+			   sizeof(res->responder_ftm_res[i].t4));
 		priv->ftm.ftm_res->meas[index].t4 = le64_to_cpu(tmp);
 		priv->ftm.ftm_res->n_meas++;
 	}
@@ -753,19 +753,19 @@ int sprdwl_ftm_get_capabilities(struct wiphy *wiphy,
 		return -ENOMEM;
 	attr = nla_nest_start(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA);
 	if (!attr ||
-	    nla_put_u32(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS,
+		nla_put_u32(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS,
 			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER |
 			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR |
 			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP |
 			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA) ||
-	    nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS,
+		nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS,
 			1) ||
-	    nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS, 1) ||
-	    nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP,
-		       0) ||
-	    nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST,
-		       4) ||
-	    nla_put_u32(skb, SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES,
+		nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS, 1) ||
+		nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP,
+			   0) ||
+		nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST,
+			   4) ||
+		nla_put_u32(skb, SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES,
 			BIT(SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE))) {
 		wl_ndev_log(L_ERR, vif->ndev,
 			   "%s: fail to fill capabilities\n", __func__);
@@ -778,8 +778,8 @@ int sprdwl_ftm_get_capabilities(struct wiphy *wiphy,
 }
 
 int sprdwl_ftm_start_session(struct wiphy *wiphy,
-			     struct wireless_dev *wdev,
-			     const void *data, int data_len)
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len)
 {
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -790,7 +790,7 @@ int sprdwl_ftm_start_session(struct wiphy *wiphy,
 	int rc, n_peers = 0, index = 0, rem;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	rc = nla_parse(tb, SPRDWL_VENDOR_ATTR_LOC_MAX, data, data_len,
-		       sprdwl_nl80211_loc_policy, NULL);
+			   sprdwl_nl80211_loc_policy, NULL);
 #else
 	rc = nla_parse(tb, SPRDWL_VENDOR_ATTR_LOC_MAX, data, data_len,
 			sprdwl_nl80211_loc_policy);
@@ -812,7 +812,7 @@ int sprdwl_ftm_start_session(struct wiphy *wiphy,
 	}
 
 	nla_for_each_nested(peer, tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS],
-			    rem)
+				rem)
 		n_peers++;
 
 	if (!n_peers) {
@@ -837,10 +837,10 @@ int sprdwl_ftm_start_session(struct wiphy *wiphy,
 		nla_get_u64(tb[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE]);
 	request->n_peers = n_peers;
 	nla_for_each_nested(peer, tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS],
-			    rem) {
+				rem) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 		rc = nla_parse_nested(tb2, SPRDWL_VENDOR_ATTR_FTM_PEER_MAX,
-				      peer, sprdwl_nl80211_ftm_peer_policy, NULL);
+					  peer, sprdwl_nl80211_ftm_peer_policy, NULL);
 #else
 		rc = nla_parse_nested(tb2, SPRDWL_VENDOR_ATTR_FTM_PEER_MAX,
 				peer, sprdwl_nl80211_ftm_peer_policy);
@@ -851,8 +851,8 @@ int sprdwl_ftm_start_session(struct wiphy *wiphy,
 			goto out;
 		}
 		if (!tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR] ||
-		    nla_len(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR])
-			    != ETH_ALEN) {
+			nla_len(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR])
+				!= ETH_ALEN) {
 			wl_ndev_log(L_ERR, vif->ndev,
 				   "%s: peer MAC address missing or invalid\n",
 				   __func__);
@@ -860,8 +860,8 @@ int sprdwl_ftm_start_session(struct wiphy *wiphy,
 			goto out;
 		}
 		memcpy(request->peers[index].mac_addr,
-		       nla_data(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR]),
-		       ETH_ALEN);
+			   nla_data(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR]),
+			   ETH_ALEN);
 		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ])
 			request->peers[index].freq = nla_get_u32(
 				tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ]);
@@ -890,8 +890,8 @@ int sprdwl_ftm_start_session(struct wiphy *wiphy,
 }
 
 int sprdwl_ftm_abort_session(struct wiphy *wiphy,
-			     struct wireless_dev *wdev,
-			     const void *data, int len)
+				 struct wireless_dev *wdev,
+				 const void *data, int len)
 {
 	struct sprdwl_msg_buf *msg;
 	struct sprdwl_cmd_rtt *cmd;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c b/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
index b6604ee547ce..b51207d19c89 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
@@ -31,8 +31,8 @@
 bool mh_ipv6_ext_hdr(unsigned char nexthdr)
 {
 	return (nexthdr == NEXTHDR_HOP) ||
-	       (nexthdr == NEXTHDR_ROUTING) ||
-	       (nexthdr == NEXTHDR_DEST);
+		   (nexthdr == NEXTHDR_ROUTING) ||
+		   (nexthdr == NEXTHDR_DEST);
 }
 
 int ipv6_csum(void *data, __wsum csum)
@@ -65,8 +65,8 @@ int ipv6_csum(void *data, __wsum csum)
 			 (msdu_desc->msdu_len - dataoff));
 
 		if (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,
-				     (msdu_desc->msdu_len - dataoff),
-				     nexthdr, csum)) {
+					 (msdu_desc->msdu_len - dataoff),
+					 nexthdr, csum)) {
 			ret = 1;
 		} else {
 			ret = -1;
@@ -300,20 +300,20 @@ static void sprdwl_rx_work_queue(struct work_struct *work)
 
 					r_buf = (unsigned char *)data;
 					sprdwl_intf_tx_data_fpga_test(intf,
-								      r_buf,
-								      len);
+									  r_buf,
+									  len);
 				}
 #else
 				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
 					wl_err("err rx data too long:%d > %d\n",
-					       len, SPRDWL_MAX_DATA_RXLEN);
+						   len, SPRDWL_MAX_DATA_RXLEN);
 				sprdwl_rx_data_process(priv, data);
 #endif /* FPGA_LOOPBACK_TEST */
 				break;
 			case SPRDWL_TYPE_CMD:
 				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
 					wl_err("err rx cmd too long:%d > %d\n",
-					       len, SPRDWL_MAX_CMD_RXLEN);
+						   len, SPRDWL_MAX_CMD_RXLEN);
 				sprdwl_rx_rsp_process(priv, data);
 				break;
 			case SPRDWL_TYPE_PKT_LOG:
@@ -324,7 +324,7 @@ static void sprdwl_rx_work_queue(struct work_struct *work)
 			case SPRDWL_TYPE_EVENT:
 				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
 					wl_err("err rx event too long:%d > %d\n",
-					       len, SPRDWL_MAX_CMD_RXLEN);
+						   len, SPRDWL_MAX_CMD_RXLEN);
 				sprdwl_rx_event_process(priv, data);
 				break;
 			case SPRDWL_TYPE_DATA_SPECIAL:
@@ -333,7 +333,7 @@ static void sprdwl_rx_work_queue(struct work_struct *work)
 
 				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
 					wl_err("err data trans too long:%d > %d\n",
-					       len, SPRDWL_MAX_CMD_RXLEN);
+						   len, SPRDWL_MAX_CMD_RXLEN);
 				sprdwl_rx_mh_data_process(rx_if, tran_data, len,
 							  msg->buffer_type);
 				tran_data = NULL;
@@ -346,7 +346,7 @@ static void sprdwl_rx_work_queue(struct work_struct *work)
 				}
 				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
 					wl_err("err rx mh data too long:%d > %d\n",
-					       len, SPRDWL_MAX_DATA_RXLEN);
+						   len, SPRDWL_MAX_DATA_RXLEN);
 				sprdwl_rx_mh_addr_process(rx_if, tran_data, len,
 							  msg->buffer_type);
 				tran_data = NULL;
@@ -354,7 +354,7 @@ static void sprdwl_rx_work_queue(struct work_struct *work)
 				break;
 			default:
 				wl_err("rx unknown type:%d\n",
-				       SPRDWL_HEAD_GET_TYPE(data));
+					   SPRDWL_HEAD_GET_TYPE(data));
 				break;
 			}
 
@@ -370,7 +370,7 @@ static void sprdwl_rx_work_queue(struct work_struct *work)
 next:
 		/* TODO: Should we free mbuf one by one? */
 		sprdwl_free_rx_data(intf, msg->fifo_id, msg->tran_data,
-				    msg->data, msg->len);
+					msg->data, msg->len);
 		sprdwl_dequeue_msg_buf(msg, &rx_if->rx_list);
 	}
 }
@@ -495,7 +495,7 @@ static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
 				print_len = 100;
 			else
 				print_len = ((struct sdiohal_puh *)
-					     tran_data)->len;
+						 tran_data)->len;
 			sprdwl_hex_dump("rx data",
 					(unsigned char *)data, print_len);
 
@@ -506,7 +506,7 @@ static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
 			case SPRDWL_TYPE_DATA_SPECIAL:
 				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
 					wl_err("err data trans too long:%d > %d\n",
-					       len, SPRDWL_MAX_CMD_RXLEN);
+						   len, SPRDWL_MAX_CMD_RXLEN);
 				sprdwl_rx_mh_data_process(rx_if, tran_data, len,
 							  msg->buffer_type);
 				tran_data = NULL;
@@ -515,7 +515,7 @@ static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
 			case SPRDWL_TYPE_DATA_PCIE_ADDR:
 				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
 					wl_err("err rx mh data too long:%d > %d\n",
-					       len, SPRDWL_MAX_DATA_RXLEN);
+						   len, SPRDWL_MAX_DATA_RXLEN);
 				sprdwl_rx_mh_addr_process(rx_if, tran_data, len,
 							  msg->buffer_type);
 				tran_data = NULL;
@@ -523,7 +523,7 @@ static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
 				break;
 			default:
 				wl_err("rx unknown type:%d\n",
-				       SPRDWL_HEAD_GET_TYPE(data));
+					   SPRDWL_HEAD_GET_TYPE(data));
 				break;
 			}
 free:
@@ -539,7 +539,7 @@ static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
 next:
 		/* TODO: Should we free mbuf one by one? */
 		sprdwl_free_rx_data(intf, msg->fifo_id, msg->tran_data,
-				    msg->data, msg->len);
+					msg->data, msg->len);
 		sprdwl_dequeue_msg_buf(msg, &rx_if->rx_data_list);
 		quota--;
 	}
@@ -575,7 +575,7 @@ int sprdwl_rx_init(struct sprdwl_intf *intf)
 	ret = sprdwl_msg_init(SPRDWL_RX_MSG_NUM, &rx_if->rx_list);
 	if (ret) {
 		wl_err("%s tx_buf create failed: %d\n",
-		       __func__, ret);
+			   __func__, ret);
 		goto err_rx_list;
 	}
 
@@ -583,7 +583,7 @@ int sprdwl_rx_init(struct sprdwl_intf *intf)
 	ret = sprdwl_msg_init(SPRDWL_RX_MSG_NUM, &rx_if->rx_data_list);
 	if (ret) {
 		wl_err("%s tx_buf create failed: %d\n",
-		       __func__, ret);
+			   __func__, ret);
 		goto err_rx_data_list;
 	}
 #endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c b/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
index 5cdc8eff9df5..4a859e724ed8 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
@@ -76,7 +76,7 @@ static int sprdwl_get_softap_chan(u8 *path)
 }
 
 void sprdwl_hook_reset_channel(struct wiphy *wiphy,
-			       struct cfg80211_ap_settings *settings)
+				   struct cfg80211_ap_settings *settings)
 {
 	u8 *ie, *ds_param_ch;
 	int channel = 1;
@@ -95,8 +95,8 @@ void sprdwl_hook_reset_channel(struct wiphy *wiphy,
 
 	mgmt = (struct ieee80211_mgmt *)settings->beacon.head;
 	ie = (u8 *)cfg80211_find_ie(WLAN_EID_DS_PARAMS,
-				    &mgmt->u.beacon.variable[0],
-				    settings->beacon.head_len);
+					&mgmt->u.beacon.variable[0],
+					settings->beacon.head_len);
 	if (ie == NULL) {
 		wl_err("IE WLAN_EID_DS_PARAMS not found in beacon\n");
 		return;
@@ -105,8 +105,8 @@ void sprdwl_hook_reset_channel(struct wiphy *wiphy,
 	ds_param_ch = ie + 2;
 
 	ie = (u8 *)cfg80211_find_ie(WLAN_EID_HT_OPERATION,
-				    settings->beacon.tail,
-				    settings->beacon.tail_len);
+					settings->beacon.tail,
+					settings->beacon.tail_len);
 	if (ie == NULL) {
 		wl_err("IE WLAN_EID_HT_OPERATION not found in beacon\n");
 		return;
@@ -116,7 +116,7 @@ void sprdwl_hook_reset_channel(struct wiphy *wiphy,
 	oper = (struct ieee80211_ht_operation *)ie;
 
 	wl_info("%s done, reset channel %d -> %d\n", __func__,
-	       oper->primary_chan, channel);
+		   oper->primary_chan, channel);
 
 	*ds_param_ch = oper->primary_chan = channel;
 }
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h b/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
index e430bfbace8f..a1b2f8544ec4 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
@@ -35,6 +35,7 @@
 #include <linux/dcache.h>
 #include <linux/udp.h>
 #include <linux/version.h>
+#include "wcn_wrapper.h"
 
 #include "cfg80211.h"
 #include "cmdevt.h"
@@ -175,6 +176,8 @@ struct wmm_params_element {
 struct sprdwl_wmmac_params {
 	struct wmm_ac_params ac[4];
 	struct timer_list wmmac_edcaf_timer;
+	struct timer_list wmmac_vo_timer;
+	struct timer_list wmmac_vi_timer;
 };
 #endif
 
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c b/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
index d360f9f57990..4db766fbac3b 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
@@ -26,7 +26,7 @@ static void sprdwl_tcp_ack_timeout(unsigned long data)
 	ack_info = (struct sprdwl_tcp_ack_info *)data;
 #endif
 	ack_m = container_of(ack_info, struct sprdwl_tcp_ack_manage,
-			     ack_info[ack_info->ack_info_num]);
+				 ack_info[ack_info->ack_info_num]);
 
 	write_seqlock_bh(&ack_info->seqlock);
 	msg = ack_info->msgbuf;
@@ -64,7 +64,7 @@ void sprdwl_tcp_ack_init(struct sprdwl_priv *priv)
 		timer_setup(&ack_info->timer, sprdwl_tcp_ack_timeout, 0);
 #else
 		setup_timer(&ack_info->timer, sprdwl_tcp_ack_timeout,
-			    (unsigned long)ack_info);
+				(unsigned long)ack_info);
 #endif
 	}
 
@@ -95,7 +95,7 @@ void sprdwl_tcp_ack_deinit(struct sprdwl_priv *priv)
 }
 
 static int sprdwl_tcp_check_quick_ack(unsigned char *buf,
-				      struct sprdwl_tcp_ack_msg *msg)
+					  struct sprdwl_tcp_ack_msg *msg)
 {
 	int ip_hdr_len;
 	unsigned char *temp;
@@ -240,10 +240,10 @@ static int sprdwl_tcp_ack_match(struct sprdwl_tcp_ack_manage *ack_m,
 
 			ack = &ack_info->ack_msg;
 			if (ack_info->busy &&
-			    ack->dest == ack_msg->dest &&
-			    ack->source == ack_msg->source &&
-			    ack->saddr == ack_msg->saddr &&
-			    ack->daddr == ack_msg->daddr)
+				ack->dest == ack_msg->dest &&
+				ack->source == ack_msg->source &&
+				ack->saddr == ack_msg->saddr &&
+				ack->daddr == ack_msg->daddr)
 				ret = i;
 		} while (read_seqretry(&ack_info->seqlock, start));
 	}
@@ -263,8 +263,8 @@ static void sprdwl_tcp_ack_update(struct sprdwl_tcp_ack_manage *ack_m)
 			ack_info = &ack_m->ack_info[i];
 			write_seqlock_bh(&ack_info->seqlock);
 			if (ack_info->busy &&
-			    time_after(jiffies, ack_info->last_time +
-				       ack_info->timeout)) {
+				time_after(jiffies, ack_info->last_time +
+					   ack_info->timeout)) {
 				ack_m->free_index = i;
 				ack_m->max_num--;
 				ack_info->busy = 0;
@@ -334,8 +334,8 @@ int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
 		if (SPRDWL_U32_BEFORE(ack->seq, ack_msg->seq)) {
 			ack->seq = ack_msg->seq;
 			if (ack_info->psh_flag &&
-			    !SPRDWL_U32_BEFORE(ack_msg->seq,
-					       ack_info->psh_seq)) {
+				!SPRDWL_U32_BEFORE(ack_msg->seq,
+						   ack_info->psh_seq)) {
 				ack_info->psh_flag = 0;
 			}
 
@@ -349,7 +349,7 @@ int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
 			ack_info->drop_cnt = atomic_read(&ack_m->max_drop_cnt);
 		} else {
 			wl_err("%s before abnormal ack: %d, %d\n",
-			       __func__, ack->seq, ack_msg->seq);
+				   __func__, ack->seq, ack_msg->seq);
 			drop_msg = new_msgbuf;
 			ret = 1;
 		}
@@ -360,7 +360,7 @@ int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
 		}
 
 		if (ack_info->psh_flag &&
-		    !SPRDWL_U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			!SPRDWL_U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
 			ack_info->psh_flag = 0;
 			quick_ack = 1;
 		} else {
@@ -384,7 +384,7 @@ int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
 		}
 	} else {
 		wl_err("%s before ack: %d, %d\n",
-		       __func__, ack->seq, ack_msg->seq);
+			   __func__, ack->seq, ack_msg->seq);
 		drop_msg = new_msgbuf;
 		ret = 1;
 	}
@@ -398,7 +398,7 @@ int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
 }
 
 void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
-			      unsigned char *buf, unsigned plen)
+				  unsigned char *buf, unsigned plen)
 {
 	int index;
 	struct sprdwl_tcp_ack_msg ack_msg;
@@ -409,7 +409,7 @@ void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
 		return;
 
 	if ((plen > MAX_TCP_ACK) ||
-	    !sprdwl_tcp_check_quick_ack(buf, &ack_msg))
+		!sprdwl_tcp_check_quick_ack(buf, &ack_msg))
 		return;
 
 	index = sprdwl_tcp_ack_match(ack_m, &ack_msg);
@@ -424,8 +424,8 @@ void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
 
 /* return val: 0 for not filter, 1 for filter */
 int sprdwl_filter_send_tcp_ack(struct sprdwl_priv *priv,
-			       struct sprdwl_msg_buf *msgbuf,
-			       unsigned char *buf, unsigned int plen)
+				   struct sprdwl_msg_buf *msgbuf,
+				   unsigned char *buf, unsigned int plen)
 {
 	int ret = 0;
 	int index, drop;
@@ -494,7 +494,7 @@ int sprdwl_filter_send_tcp_ack(struct sprdwl_priv *priv,
 }
 
 void sprdwl_move_tcpack_msg(struct sprdwl_priv *priv,
-			    struct sprdwl_msg_buf *msg)
+				struct sprdwl_msg_buf *msg)
 {
 	struct sprdwl_tcp_ack_info *ack_info;
 	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c b/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
index 7be652187be2..40d51a7130d9 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
@@ -109,7 +109,7 @@ struct sprdwl_msg_buf *sprdwl_get_msg_buf(void *pdev,
 }
 
 static void sprdwl_dequeue_cmd_buf(struct sprdwl_msg_buf *msg_buf,
-				    struct sprdwl_msg_list *list)
+					struct sprdwl_msg_list *list)
 {
 	spin_lock_bh(&list->busylock);
 	list_del(&msg_buf->list);
@@ -295,10 +295,10 @@ void sprdwl_dequeue_data_list(struct mbuf_t *head, int num)
 		msg_pos = GET_MSG_BUF(mbuf_pos);
 		/*TODO, check msg_buf after pop link*/
 		if (msg_pos == NULL ||
-		    !virt_addr_valid(msg_pos) ||
-		    !virt_addr_valid(msg_pos->skb)) {
+			!virt_addr_valid(msg_pos) ||
+			!virt_addr_valid(msg_pos->skb)) {
 			wl_err("%s,%d, error! wrong sprdwl_msg_buf\n",
-			       __func__, __LINE__);
+				   __func__, __LINE__);
 			BUG_ON(1);
 		}
 		dev_kfree_skb(msg_pos->skb);
@@ -405,7 +405,7 @@ add_xmit_list_tail(struct sprdwl_tx_msg *tx_msg,
 	}
 	if (num != add_num)
 		wl_err("%s, %d, error! add_num:%d, num:%d\n",
-		       __func__, __LINE__, add_num, num);
+			   __func__, __LINE__, add_num, num);
 	INIT_LIST_HEAD(&temp_list);
 	list_cut_position(&temp_list,
 			  &p_list->head_list,
@@ -444,8 +444,8 @@ unsigned int queue_is_empty(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode)
 }
 
 void sprdwl_wake_net_ifneed(struct sprdwl_intf *dev,
-			    struct sprdwl_msg_list *list,
-			    enum sprdwl_mode mode)
+				struct sprdwl_msg_list *list,
+				enum sprdwl_mode mode)
 {
 	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
 
@@ -496,7 +496,7 @@ static int sprdwl_tx_cmd(struct sprdwl_intf *intf, struct sprdwl_msg_list *list)
 		if (time_after(jiffies, msgbuf->timeout)) {
 			tx_msg->drop_cmd_cnt++;
 			wl_err("tx drop cmd msg,dropcnt:%lu\n",
-			       tx_msg->drop_cmd_cnt);
+				   tx_msg->drop_cmd_cnt);
 			kfree(msgbuf->tran_data);
 			msgbuf->tran_data = NULL;
 			sprdwl_dequeue_msg_buf(msgbuf, list);
@@ -531,8 +531,8 @@ void sprdwl_fc_add_share_credit(struct sprdwl_vif *vif)
 	for (i = 0; i < MAX_COLOR_BIT; i++) {
 		if (tx_msg->flow_ctrl[i].mode == vif->mode) {
 			wl_err("%s, %d, mode:%d closed, index:%d, share it\n",
-			       __func__, __LINE__,
-			       vif->mode, i);
+				   __func__, __LINE__,
+				   vif->mode, i);
 			tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
 			break;
 		}
@@ -606,8 +606,8 @@ int sprdwl_fc_get_shared_num(struct sprdwl_tx_msg *tx_msg, u8 num)
 }
 
 int sprdwl_fc_get_send_num(struct sprdwl_tx_msg *tx_msg,
-			     enum sprdwl_mode mode,
-			     int data_num)
+				 enum sprdwl_mode mode,
+				 int data_num)
 {
 	int excusive_flow_num = 0, shared_flow_num = 0;
 	int send_num = 0;
@@ -644,9 +644,9 @@ int sprdwl_fc_get_send_num(struct sprdwl_tx_msg *tx_msg,
 
 		if (send_num <= 0) {
 			wl_err("%s, %d, mode:%d, e_num:%d, s_num:%d, d_num:%d\n",
-			       __func__, __LINE__,
-			       (u8)mode, excusive_flow_num,
-			       shared_flow_num, data_num);
+				   __func__, __LINE__,
+				   (u8)mode, excusive_flow_num,
+				   shared_flow_num, data_num);
 			return -ENOMEM;
 		}
 		wl_debug("%s, %d, mode:%d, e_num:%d, s_num:%d, d_num:%d\n"
@@ -657,11 +657,11 @@ int sprdwl_fc_get_send_num(struct sprdwl_tx_msg *tx_msg,
 			tx_msg->color_num[2], tx_msg->color_num[3]);
 	} else {
 		wl_err("%s, %d, wrong mode:%d?\n",
-		       __func__, __LINE__,
-		       (u8)mode);
+			   __func__, __LINE__,
+			   (u8)mode);
 		for (i = 0; i < MAX_COLOR_BIT; i++)
 			wl_err("color[%d] assigned mode%d\n",
-			       i, (u8)tx_msg->flow_ctrl[i].mode);
+				   i, (u8)tx_msg->flow_ctrl[i].mode);
 		return -ENOMEM;
 	}
 
@@ -686,8 +686,8 @@ int sprdwl_fc_test_shared_num(struct sprdwl_tx_msg *tx_msg)
 }
 /*to check flow number, no flow number, no send*/
 int sprdwl_fc_test_send_num(struct sprdwl_tx_msg *tx_msg,
-			     enum sprdwl_mode mode,
-			     int data_num)
+				 enum sprdwl_mode mode,
+				 int data_num)
 {
 	int excusive_flow_num = 0, shared_flow_num = 0;
 	int send_num = 0;
@@ -720,11 +720,11 @@ int sprdwl_fc_test_send_num(struct sprdwl_tx_msg *tx_msg,
 			 shared_flow_num, data_num);
 	} else {
 		wl_err("%s, %d, wrong mode:%d?\n",
-		       __func__, __LINE__,
-		       (u8)mode);
+			   __func__, __LINE__,
+			   (u8)mode);
 		for (i = 0; i < MAX_COLOR_BIT; i++)
 			wl_err_ratelimited("color[%d] assigned mode%d\n",
-			       i, (u8)tx_msg->flow_ctrl[i].mode);
+				   i, (u8)tx_msg->flow_ctrl[i].mode);
 		return -ENOMEM;
 	}
 
@@ -782,8 +782,8 @@ void sprdwl_handle_tx_return(struct sprdwl_tx_msg *tx_msg,
 }
 
 int handle_tx_timeout(struct sprdwl_tx_msg *tx_msg,
-		      struct sprdwl_msg_list *msg_list,
-		      struct peer_list *p_list, int ac_index)
+			  struct sprdwl_msg_list *msg_list,
+			  struct peer_list *p_list, int ac_index)
 {
 	u8 mode;
 	char *pinfo;
@@ -853,7 +853,7 @@ int handle_tx_timeout(struct sprdwl_tx_msg *tx_msg,
 }
 
 static int sprdwl_handle_to_send_list(struct sprdwl_intf *intf,
-				      enum sprdwl_mode mode)
+					  enum sprdwl_mode mode)
 {
 	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
 	struct list_head *to_send_list, tx_list_head;
@@ -876,8 +876,8 @@ static int sprdwl_handle_to_send_list(struct sprdwl_intf *intf,
 		credit = sprdwl_fc_get_send_num(tx_msg, mode, tosendnum);
 		if (credit < tosendnum)
 			wl_err("%s, %d,error! credit:%d,tosendnum:%d\n",
-			       __func__, __LINE__,
-			       credit, tosendnum);
+				   __func__, __LINE__,
+				   credit, tosendnum);
 		if (credit <= 0)
 			return -ENOMEM;
 		tx_msg->xmit_msg_list.mode = mode;
@@ -891,7 +891,7 @@ static int sprdwl_handle_to_send_list(struct sprdwl_intf *intf,
 		sprdwl_handle_tx_return(tx_msg, list, credit, ret);
 		if (0 != ret) {
 			wl_err("%s, %d: tx return err!\n",
-			       __func__, __LINE__);
+				   __func__, __LINE__);
 			tx_msg->xmit_msg_list.failcount++;
 			if (tx_msg->xmit_msg_list.failcount > 10) {
 				sprdwl_flush_tosendlist(tx_msg);
@@ -929,14 +929,14 @@ static int sprdwl_tx_eachmode_data(struct sprdwl_intf *intf,
 			p_list = &tx_list->q_list[i].p_list[j];
 			if (atomic_read(&p_list->l_num) > 0) {
 				if (0 != handle_tx_timeout(tx_msg,
-						       list,
-						       p_list,
-						       i))
+							   list,
+							   p_list,
+							   i))
 					wl_err("TID=%s%s%s%s, timeout!\n",
-					       (i == SPRDWL_AC_VO) ? "VO" : "",
-					       (i == SPRDWL_AC_VI) ? "VI" : "",
-					       (i == SPRDWL_AC_BE) ? "BE" : "",
-					       (i == SPRDWL_AC_BK) ? "BK" : "");
+						   (i == SPRDWL_AC_VO) ? "VO" : "",
+						   (i == SPRDWL_AC_VI) ? "VI" : "",
+						   (i == SPRDWL_AC_BE) ? "BE" : "",
+						   (i == SPRDWL_AC_BK) ? "BK" : "");
 				p_list_num[i][j] = atomic_read(&p_list->l_num);
 				/*wl_info("TID=%d,PEER=%d,l_num=%d\n",i,j,p_list_num[i][j]);*/
 				q_list_num[i] += p_list_num[i][j];
@@ -945,16 +945,16 @@ static int sprdwl_tx_eachmode_data(struct sprdwl_intf *intf,
 		total += q_list_num[i];
 		if (q_list_num[i] != 0)
 			wl_debug("TID%s%s%s%snum=%d, total=%d\n",
-			       (i == SPRDWL_AC_VO) ? "VO" : "",
-			       (i == SPRDWL_AC_VI) ? "VI" : "",
-			       (i == SPRDWL_AC_BE) ? "BE" : "",
-			       (i == SPRDWL_AC_BK) ? "BK" : "",
-			       q_list_num[i], total);
+				   (i == SPRDWL_AC_VO) ? "VO" : "",
+				   (i == SPRDWL_AC_VI) ? "VI" : "",
+				   (i == SPRDWL_AC_BE) ? "BE" : "",
+				   (i == SPRDWL_AC_BK) ? "BK" : "",
+				   q_list_num[i], total);
 	}
 	send_num = sprdwl_fc_test_send_num(tx_msg, mode, total);
 	if (total != 0 && send_num <= 0) {
 		wl_err("%s, %d: _fc_ no credit!\n",
-		       __func__, __LINE__);
+			   __func__, __LINE__);
 		return -ENOMEM;
 	}
 
@@ -1081,6 +1081,10 @@ int sprdwl_sdio_process_credit(void *pdev, void *data)
 	if (common->type == SPRDWL_TYPE_DATA_SPECIAL) {
 		int offset = (size_t)&((struct rx_msdu_desc *)0)->rsvd5;
 
+		if (intf->priv->hw_type == SPRDWL_HW_USB) {
+			return -2;
+		}
+
 		flow = data + offset;
 		goto out;
 	}
@@ -1368,9 +1372,9 @@ static int sprdwl_tx_work_queue(void *data)
 
 		/* if tx list, send wakeup firstly */
 		if (intf->fw_power_down == 1 &&
-		    (atomic_read(&tx_msg->tx_list_qos_pool.ref) > 0 ||
-		     !list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
-		     !list_empty(&tx_msg->xmit_msg_list.to_free_list))) {
+			(atomic_read(&tx_msg->tx_list_qos_pool.ref) > 0 ||
+			 !list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+			 !list_empty(&tx_msg->xmit_msg_list.to_free_list))) {
 				struct sprdwl_vif *vif;
 
 				sprdwcn_bus_sleep_wakeup(WIFI);
@@ -1450,7 +1454,7 @@ int sprdwl_tx_init(struct sprdwl_intf *intf)
 	}
 
 	ret = sprdwl_msg_init(SPRDWL_TX_QOS_POOL_SIZE,
-			      &tx_msg->tx_list_qos_pool);
+				  &tx_msg->tx_list_qos_pool);
 	if (ret) {
 		wl_err("%s tx_list_qos_pool alloc failed\n", __func__);
 		goto err_tx_list_cmd;
@@ -1466,7 +1470,7 @@ int sprdwl_tx_init(struct sprdwl_intf *intf)
 
 	tx_msg->tx_thread =
 		kthread_create(sprdwl_tx_work_queue,
-			       (void *)tx_msg, "SPRDWL_TX_QUEUE");
+				   (void *)tx_msg, "SPRDWL_TX_QUEUE");
 	if (!tx_msg->tx_thread) {
 		wl_err("%s SPRDWL_TX_QUEUE create failed", __func__);
 		ret = -ENOMEM;
@@ -1527,7 +1531,7 @@ void sprdwl_tx_deinit(struct sprdwl_intf *intf)
 	*/
 	if (!list_empty(&tx_msg->tx_list_cmd.cmd_to_free))
 		wl_err("%s cmd not yet transmited, cmd_send:%d, cmd_poped:%d\n",
-		       __func__, tx_msg->cmd_send, tx_msg->cmd_poped);
+			   __func__, tx_msg->cmd_send, tx_msg->cmd_poped);
 
 	sprdwl_flush_all_txlist(tx_msg);
 
@@ -1697,7 +1701,7 @@ bool is_vowifi_pkt(struct sk_buff *skb, bool *b_cmd_path)
 	switch (dscp) {
 	case VOWIFI_IKE_DSCP:
 		if ((udphdr->dest == htons(VOWIFI_IKE_SIP_PORT)) ||
-		    (udphdr->dest == htons(VOWIFI_IKE_ONLY_PORT))) {
+			(udphdr->dest == htons(VOWIFI_IKE_ONLY_PORT))) {
 			ret = true;
 			(*b_cmd_path) = true;
 		}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/txrx.c b/drivers/net/wireless/uwe5622/unisocwifi/txrx.c
index b0a24a3615ba..227339ada73f 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/txrx.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/txrx.c
@@ -23,7 +23,9 @@
 #include "cmdevt.h"
 #include "intf_ops.h"
 #include "work.h"
+#if defined(UWE5621_FTR)
 #include "wl_intf.h"
+#endif
 #include "rx_msg.h"
 #include "tcp_ack.h"
 #include "wl_core.h"
@@ -32,20 +34,33 @@
  * here just free the msg buf to the freelist
  */
 int sprdwl_send_data(struct sprdwl_vif *vif, struct sprdwl_msg_buf *msg,
-		     struct sk_buff *skb, u8 offset)
+			 struct sk_buff *skb, u8 offset)
 {
 	int ret;
 	int delta;
 	unsigned long align_addr;
 	unsigned char *buf = NULL;
+/*TODO temp for MARLIN2*/
+#ifndef UWE5621_FTR
+	struct sprdwl_data_hdr *hdr;
+#endif
 	struct sprdwl_intf *intf;
 	unsigned int plen = cpu_to_le16(skb->len);
 
 	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
 	buf = skb->data;
-
+/*TODO temp for MARLIN2*/
+#ifndef UWE5621_FTR
+	skb_push(skb, sizeof(*hdr) + offset);
+	hdr = (struct sprdwl_data_hdr *)skb->data;
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->common.type = SPRDWL_TYPE_DATA;
+	hdr->common.ctx_id = vif->ctx_id;
+	hdr->plen = cpu_to_le16(skb->len);
+#else
 	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_DATA, offset))
 		return -EPERM;
+#endif /* UWE5621_FTR */
 #ifdef OTT_UWE
 	skb_push(skb, 3);
 	if ((unsigned long)skb->data & 0x3) {
@@ -105,6 +120,10 @@ int sprdwl_send_cmd(struct sprdwl_priv *priv, struct sprdwl_msg_buf *msg)
 	ret = sprdwl_intf_tx(priv, msg);
 	if (ret) {
 		wl_err("%s TX cmd Err: %d\n", __func__, ret);
+		/* now cmd msg droped */
+#if !defined(UWE5621_FTR)
+		dev_kfree_skb(skb);
+#endif
 	}
 
 	return ret;
@@ -124,7 +143,7 @@ void sprdwl_rx_send_cmd_process(struct sprdwl_priv *priv, void *data, int len,
 		vif = ctx_id_to_vif(priv, ctx_id);
 		if (!vif) {
 			wl_err("%s cant't get vif from ctx_id%d\n",
-			       __func__, ctx_id);
+				   __func__, ctx_id);
 		} else {
 			misc_work = sprdwl_alloc_work(len);
 			if (!misc_work) {
@@ -165,14 +184,14 @@ void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *skb)
 	vif = ctx_id_to_vif(priv, msdu_desc->ctx_id);
 	if (!vif) {
 		wl_err("%s cannot get vif, ctx_id: %d\n",
-		       __func__, msdu_desc->ctx_id);
+			   __func__, msdu_desc->ctx_id);
 		goto err;
 	}
 
 	/* Sanity check for bug 846454 */
 	if (vif->ndev == NULL) {
 		wl_err("%s ndev is NULL, ctx_id = %d\n",
-		       __func__, msdu_desc->ctx_id);
+			   __func__, msdu_desc->ctx_id);
 		BUG_ON(1);
 	}
 
@@ -196,17 +215,17 @@ void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *skb)
 
 	/* FIXME: We would remove mode in furture, how to modify? */
 	if (((vif->mode == SPRDWL_MODE_AP) ||
-	     (vif->mode == SPRDWL_MODE_P2P_GO)) && msdu_desc->uc_w2w_flag) {
+		 (vif->mode == SPRDWL_MODE_P2P_GO)) && msdu_desc->uc_w2w_flag) {
 		skb->dev = ndev;
 		dev_queue_xmit(skb);
 	} else {
 		if (((vif->mode == SPRDWL_MODE_AP) ||
-		     (vif->mode == SPRDWL_MODE_P2P_GO)) &&
-		    msdu_desc->bc_mc_w2w_flag) {
+			 (vif->mode == SPRDWL_MODE_P2P_GO)) &&
+			msdu_desc->bc_mc_w2w_flag) {
 			struct ethhdr *eth = (struct ethhdr *)skb->data;
 
 			if (eth->h_proto != ETH_P_IP &&
-			    eth->h_proto != ETH_P_IPV6) {
+				eth->h_proto != ETH_P_IPV6) {
 				tx_skb = pskb_copy(skb, GFP_ATOMIC);
 				if (likely(tx_skb)) {
 					tx_skb->dev = ndev;
@@ -232,7 +251,7 @@ void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *skb)
 #endif
 }
 unsigned short sprdwl_rx_data_process(struct sprdwl_priv *priv,
-				      unsigned char *msg)
+					  unsigned char *msg)
 {
 	return 0;
 }
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/vendor.c b/drivers/net/wireless/uwe5622/unisocwifi/vendor.c
index 733591184c17..6fba95b60d62 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/vendor.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/vendor.c
@@ -17,7 +17,6 @@
 #include "sprdwl.h"
 #include "cmdevt.h"
 #include "vendor.h"
-#include "npi.h"
 #ifdef NAN_SUPPORT
 #include "nan.h"
 #include <linux/version.h>
@@ -112,8 +111,8 @@ static int sprdwl_vendor_roaming_enable(struct wiphy *wiphy,
 }
 
 static int sprdwl_vendor_nan_enable(struct wiphy *wiphy,
-				    struct wireless_dev *wdev,
-				    const void *data, int len)
+					struct wireless_dev *wdev,
+					const void *data, int len)
 {
 	return WIFI_SUCCESS;
 }
@@ -141,13 +140,13 @@ static int sprdwl_llstat(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 subtype,
 		return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, 0, 0);
 	else
 		return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf,
-					    r_len);
+						r_len);
 }
 
 /*set link layer status function-----CMD ID:14*/
 static int sprdwl_vendor_set_llstat_handler(struct wiphy *wiphy,
-					    struct wireless_dev *wdev,
-					    const void *data, int len)
+						struct wireless_dev *wdev,
+						const void *data, int len)
 {
 	int ret = 0, err = 0;
 	struct sprdwl_priv *priv = wiphy_priv(wiphy);
@@ -189,7 +188,7 @@ static int sprdwl_vendor_set_llstat_handler(struct wiphy *wiphy,
 			ll_params->aggressive_statistics_gathering);
 	if (ll_params->aggressive_statistics_gathering)
 		ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_SET,
-				    ll_params, sizeof(*ll_params),
+					ll_params, sizeof(*ll_params),
 							0, 0);
 	kfree(ll_params);
 	return ret;
@@ -218,8 +217,8 @@ static int sprdwl_compose_radio_st(struct sk_buff *reply,
 		goto out_put_fail;
 	if (radio_st->num_tx_levels > 0) {
 		if (nla_put(reply, SPRDWL_LL_STATS_RADIO_TX_TIME_PER_LEVEL,
-			    sizeof(u32)*radio_st->num_tx_levels,
-			    radio_st->tx_time_per_levels))
+				sizeof(u32)*radio_st->num_tx_levels,
+				radio_st->tx_time_per_levels))
 			goto out_put_fail;
 	}
 	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_RX_TIME,
@@ -248,9 +247,9 @@ static int sprdwl_compose_radio_st(struct sk_buff *reply,
 		goto out_put_fail;
 	if (radio_st->num_channels > 0) {
 		if (nla_put(reply, SPRDWL_LL_STATS_CH_INFO,
-			    radio_st->num_channels *
+				radio_st->num_channels *
 				sizeof(struct wifi_channel_stat),
-			    radio_st->channels))
+				radio_st->channels))
 			goto out_put_fail;
 	}
 	return 0;
@@ -268,7 +267,7 @@ static int sprdwl_compose_iface_st(struct sk_buff *reply,
 			iface_st->info.mode))
 		goto out_put_fail;
 	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_MAC_ADDR,
-		    sizeof(iface_st->info.mac_addr), iface_st->info.mac_addr))
+			sizeof(iface_st->info.mac_addr), iface_st->info.mac_addr))
 		goto out_put_fail;
 	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_STATE,
 			iface_st->info.state))
@@ -280,18 +279,18 @@ static int sprdwl_compose_iface_st(struct sk_buff *reply,
 			iface_st->info.capabilities))
 		goto out_put_fail;
 	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_SSID,
-		    sizeof(iface_st->info.ssid), iface_st->info.ssid))
+			sizeof(iface_st->info.ssid), iface_st->info.ssid))
 		goto out_put_fail;
 	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_BSSID,
-		    sizeof(iface_st->info.bssid), iface_st->info.bssid))
+			sizeof(iface_st->info.bssid), iface_st->info.bssid))
 		goto out_put_fail;
 	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_AP_COUNTRY_STR,
-		    sizeof(iface_st->info.ap_country_str),
-		    iface_st->info.ap_country_str))
+			sizeof(iface_st->info.ap_country_str),
+			iface_st->info.ap_country_str))
 		goto out_put_fail;
 	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_COUNTRY_STR,
-		    sizeof(iface_st->info.country_str),
-		    iface_st->info.country_str))
+			sizeof(iface_st->info.country_str),
+			iface_st->info.country_str))
 		goto out_put_fail;
 	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_BEACON_RX,
 			iface_st->beacon_rx))
@@ -400,7 +399,7 @@ static int sprdwl_compose_iface_st(struct sk_buff *reply,
 }
 
 void calc_radio_dif(struct sprdwl_llstat_radio *dif_radio,
-		    struct sprdwl_llstat_data *llst,
+			struct sprdwl_llstat_data *llst,
 			struct sprdwl_llstat_radio *pre_radio)
 {
 	int i;
@@ -445,8 +444,8 @@ void calc_radio_dif(struct sprdwl_llstat_radio *dif_radio,
 
 /*get link layer status function---CMD ID:15*/
 static int sprdwl_vendor_get_llstat_handler(struct wiphy *wiphy,
-					    struct wireless_dev *wdev,
-					    const void *data, int len)
+						struct wireless_dev *wdev,
+						const void *data, int len)
 {
 	struct sk_buff *reply_radio, *reply_iface;
 	struct sprdwl_llstat_data *llst;
@@ -475,7 +474,7 @@ static int sprdwl_vendor_get_llstat_handler(struct wiphy *wiphy,
 	if (!radio_st || !iface_st || !dif_radio)
 		goto out_put_fail;
 	ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_GET, NULL, 0,
-			    r_buf, &r_len);
+				r_buf, &r_len);
 	if (ret)
 		goto out_put_fail;
 
@@ -486,10 +485,10 @@ static int sprdwl_vendor_get_llstat_handler(struct wiphy *wiphy,
 	/*set data for iface struct*/
 	iface_st->info.mode = vif->mode;
 	memcpy(iface_st->info.mac_addr, vif->ndev->dev_addr,
-	       ETH_ALEN);
+		   ETH_ALEN);
 	iface_st->info.state = vif->sm_state;
 	memcpy(iface_st->info.ssid, vif->ssid,
-	       IEEE80211_MAX_SSID_LEN);
+		   IEEE80211_MAX_SSID_LEN);
 	ether_addr_copy(iface_st->info.bssid, vif->bssid);
 	iface_st->beacon_rx = dif_radio->bcn_rx_cnt;
 	iface_st->rssi_mgmt = dif_radio->rssi_mgmt;
@@ -568,8 +567,8 @@ static int sprdwl_vendor_get_llstat_handler(struct wiphy *wiphy,
 
 /*clear link layer status function--- CMD ID:16*/
 static int sprdwl_vendor_clr_llstat_handler(struct wiphy *wiphy,
-					    struct wireless_dev *wdev,
-					    const void *data, int len)
+						struct wireless_dev *wdev,
+						const void *data, int len)
 {
 	struct sk_buff *reply;
 	struct wifi_clr_llstat_rsp clr_rsp;
@@ -604,7 +603,7 @@ static int sprdwl_vendor_clr_llstat_handler(struct wiphy *wiphy,
 	}
 	wiphy_info(wiphy, "stats_clear_req_mask = %u\n", stats_clear_req_mask);
 	ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_DEL,
-			    &stats_clear_req_mask, r_len, r_buf, &r_len);
+				&stats_clear_req_mask, r_len, r_buf, &r_len);
 	stats_clear_rsp_mask = (u32 *)r_buf;
 	clr_rsp.stats_clear_rsp_mask = *stats_clear_rsp_mask;
 	clr_rsp.stop_rsp = 1;
@@ -634,8 +633,8 @@ static int sprdwl_vendor_clr_llstat_handler(struct wiphy *wiphy,
 }
 /*start gscan functon, including scan params configuration------ CMD ID:20*/
 static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
-				    struct wireless_dev *wdev,
-				    const void *data, int len)
+					struct wireless_dev *wdev,
+					const void *data, int len)
 {
 	u64 tlen;
 	int i, j, ret = 0, enable;
@@ -689,7 +688,7 @@ static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
 		i = 0;
 		nla_for_each_nested(outer_iter, pos, rem_outer_len) {
 			nla_for_each_nested(inner_iter, outer_iter,
-					    rem_inner_len){
+						rem_inner_len){
 				type = nla_type(inner_iter);
 				switch (type) {
 				case GSCAN_ATTR_BUCKET_SPEC_INDEX:
@@ -735,10 +734,10 @@ static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
 				case GSCAN_ATTR_CHANNEL_SPEC:
 				j = 0;
 				nla_for_each_nested(outer_iter1,
-						    inner_iter,
+							inner_iter,
 					rem_outer_len1) {
 					nla_for_each_nested(inner_iter1,
-							    outer_iter1,
+								outer_iter1,
 						rem_inner_len1) {
 						type = nla_type(inner_iter1);
 
@@ -788,7 +787,7 @@ static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
 	}
 
 	wl_ndev_log(L_INFO, vif->ndev, "parse config %s\n",
-		    !ret ? "success" : "failture");
+			!ret ? "success" : "failture");
 
 	kfree(vif->priv->gscan_res);
 	vif->priv->gscan_buckets_num = params->num_buckets;
@@ -805,7 +804,7 @@ static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
 	}
 
 	memset(vif->priv->gscan_res, 0x0,
-	       vif->priv->gscan_buckets_num *
+		   vif->priv->gscan_buckets_num *
 		sizeof(struct sprdwl_gscan_cached_results));
 
 	tlen = sizeof(struct sprdwl_cmd_gscan_set_config);
@@ -842,8 +841,8 @@ static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
 
 /*stop gscan functon------ CMD ID:21*/
 static int sprdwl_vendor_gscan_stop(struct wiphy *wiphy,
-				    struct wireless_dev *wdev,
-				      const void *data, int len)
+					struct wireless_dev *wdev,
+					  const void *data, int len)
 {
 	int enable;
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -894,13 +893,13 @@ static int sprdwl_vendor_get_channel_list(struct wiphy *wiphy,
 				   type);
 			ret = -EINVAL;
 		break;
-	    }
-	    if (ret < 0)
+		}
+		if (ret < 0)
 		break;
 	}
 
 	wl_ndev_log(L_INFO, vif->ndev, "parse channel list %s band=%d\n",
-		    !ret ? "success" : "failture", band);
+			!ret ? "success" : "failture", band);
 
 	payload = rlen + 0x100;
 	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
@@ -962,7 +961,7 @@ static int sprdwl_vendor_get_gscan_capabilities(struct wiphy *wiphy,
 	wl_info("%s enter\n", __func__);
 
 	rlen = sizeof(struct sprdwl_gscan_capa) +
-	    sizeof(struct sprdwl_cmd_gscan_rsp_header);
+		sizeof(struct sprdwl_cmd_gscan_rsp_header);
 	rbuf = kmalloc(rlen, GFP_KERNEL);
 	if (!rbuf)
 		return -ENOMEM;
@@ -978,7 +977,7 @@ static int sprdwl_vendor_get_gscan_capabilities(struct wiphy *wiphy,
 	}
 	hdr = (struct sprdwl_cmd_gscan_rsp_header *)rbuf;
 	p = (struct sprdwl_gscan_capa *)
-	    (rbuf + sizeof(struct sprdwl_cmd_gscan_rsp_header));
+		(rbuf + sizeof(struct sprdwl_cmd_gscan_rsp_header));
 	wl_info("cache_size: %d scan_bucket:%d\n",
 		p->max_scan_cache_size, p->max_scan_buckets);
 	wl_info("max AP per scan:%d,max_rssi_sample_size:%d\n",
@@ -995,29 +994,29 @@ static int sprdwl_vendor_get_gscan_capabilities(struct wiphy *wiphy,
 	if (nla_put_u32(reply, GSCAN_SCAN_CACHE_SIZE,
 			p->max_scan_cache_size) ||
 		nla_put_u32(reply, GSCAN_MAX_SCAN_BUCKETS,
-			    p->max_scan_buckets) ||
+				p->max_scan_buckets) ||
 		nla_put_u32(reply, GSCAN_MAX_AP_CACHE_PER_SCAN,
-			    p->max_ap_cache_per_scan) ||
+				p->max_ap_cache_per_scan) ||
 		nla_put_u32(reply, GSCAN_MAX_RSSI_SAMPLE_SIZE,
-			    p->max_rssi_sample_size) ||
+				p->max_rssi_sample_size) ||
 		nla_put_s32(reply, GSCAN_MAX_SCAN_REPORTING_THRESHOLD,
-			    p->max_scan_reporting_threshold) ||
+				p->max_scan_reporting_threshold) ||
 		nla_put_u32(reply, GSCAN_MAX_HOTLIST_BSSIDS,
-			    p->max_hotlist_bssids) ||
+				p->max_hotlist_bssids) ||
 		nla_put_u32(reply, GSCAN_MAX_SIGNIFICANT_WIFI_CHANGE_APS,
-			    p->max_significant_wifi_change_aps) ||
+				p->max_significant_wifi_change_aps) ||
 		nla_put_u32(reply, GSCAN_MAX_BSSID_HISTORY_ENTRIES,
-			    p->max_bssid_history_entries) ||
+				p->max_bssid_history_entries) ||
 		nla_put_u32(reply, GSCAN_MAX_HOTLIST_SSIDS,
-			    p->max_hotlist_bssids) ||
+				p->max_hotlist_bssids) ||
 		nla_put_u32(reply, GSCAN_MAX_NUM_EPNO_NETS,
-			    p->max_number_epno_networks) ||
+				p->max_number_epno_networks) ||
 		nla_put_u32(reply, GSCAN_MAX_NUM_EPNO_NETS_BY_SSID,
-			    p->max_number_epno_networks_by_ssid) ||
+				p->max_number_epno_networks_by_ssid) ||
 		nla_put_u32(reply, GSCAN_MAX_NUM_WHITELISTED_SSID,
-			    p->max_whitelist_ssid) ||
+				p->max_whitelist_ssid) ||
 		nla_put_u32(reply, GSCAN_MAX_NUM_BLACKLISTED_BSSID,
-			    p->max_blacklist_size)){
+				p->max_blacklist_size)){
 		wl_err("failed to put Gscan capabilies\n");
 		goto out_put_fail;
 	}
@@ -1097,14 +1096,14 @@ static int sprdwl_vendor_get_cached_gscan_results(struct wiphy *wiphy,
 		if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
 				request_id) ||
 			nla_put_u32(reply,
-				    GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+					GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
 			(vif->priv->gscan_res + i)->num_results)) {
 			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
 			goto out_put_fail;
 		}
 
 		if (nla_put_u8(reply,
-			       GSCAN_RESULTS_SCAN_RESULT_MORE_DATA,
+				   GSCAN_RESULTS_SCAN_RESULT_MORE_DATA,
 			moredata)) {
 			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
 			goto out_put_fail;
@@ -1201,7 +1200,7 @@ static int sprdwl_vendor_get_cached_gscan_results(struct wiphy *wiphy,
 					goto out_put_fail;
 				}
 				if (nla_put(reply,
-					    GSCAN_RESULTS_SCAN_RESULT_BSSID,
+						GSCAN_RESULTS_SCAN_RESULT_BSSID,
 					sizeof(p->results[j].bssid),
 					p->results[j].bssid)) {
 					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
@@ -1252,8 +1251,8 @@ static int sprdwl_vendor_get_cached_gscan_results(struct wiphy *wiphy,
 
 /*buffer scan result in host driver when receive frame from cp2*/
 int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
-					    u8 bucket_id,
-					    struct sprdwl_gscan_result *item)
+						u8 bucket_id,
+						struct sprdwl_gscan_result *item)
 {
 	struct sprdwl_priv *priv = vif->priv;
 	u32 i;
@@ -1281,9 +1280,9 @@ int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
 
 	for (i = 0; i < p->num_results; i++) {
 		if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
-			       p->results[i].ts)) {
+				   p->results[i].ts)) {
 			memcpy((void *)(&p->results[i]),
-			       (void *)(&p->results[i+1]),
+				   (void *)(&p->results[i+1]),
 				sizeof(struct sprdwl_gscan_result)
 				* (p->num_results - i - 1));
 
@@ -1291,20 +1290,20 @@ int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
 		}
 
 		if (!memcmp(p->results[i].bssid, item->bssid, ETH_ALEN) &&
-		    strlen(p->results[i].ssid) == strlen(item->ssid) &&
-		    !memcmp(p->results[i].ssid, item->ssid,
-			    strlen(item->ssid))) {
+			strlen(p->results[i].ssid) == strlen(item->ssid) &&
+			!memcmp(p->results[i].ssid, item->ssid,
+				strlen(item->ssid))) {
 			wl_ndev_log(L_ERR, vif->ndev, "%s BSS : %s  %pM exist, but also update it.\n",
 				   __func__, item->ssid, item->bssid);
 
 			memcpy((void *)(&p->results[i]),
-			       (void *)item,
+				   (void *)item,
 				sizeof(struct sprdwl_gscan_result));
 			return 0;
 		}
 	}
 	memcpy((void *)(&p->results[p->num_results]),
-	       (void *)item, sizeof(struct sprdwl_gscan_result));
+		   (void *)item, sizeof(struct sprdwl_gscan_result));
 	p->results[p->num_results].ie_length = 0;
 	p->results[p->num_results].ie_data[0] = 0;
 	p->num_results++;
@@ -1312,7 +1311,7 @@ int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
 }
 
 int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
-					      struct sprdwl_gscan_result *item)
+						  struct sprdwl_gscan_result *item)
 {
 	struct sprdwl_priv *priv = vif->priv;
 	u32 i;
@@ -1332,9 +1331,9 @@ int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
 
 	for (i = 0; i < p->num_results; i++) {
 		if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
-			       p->results[i].ts)) {
+				   p->results[i].ts)) {
 			memcpy((void *)(&p->results[i]),
-			       (void *)(&p->results[i+1]),
+				   (void *)(&p->results[i+1]),
 				sizeof(struct sprdwl_gscan_result)
 				* (p->num_results - i - 1));
 
@@ -1342,20 +1341,20 @@ int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
 		}
 
 		if (!memcmp(p->results[i].bssid, item->bssid, ETH_ALEN) &&
-		    strlen(p->results[i].ssid) == strlen(item->ssid) &&
-		    !memcmp(p->results[i].ssid, item->ssid,
-			    strlen(item->ssid))) {
+			strlen(p->results[i].ssid) == strlen(item->ssid) &&
+			!memcmp(p->results[i].ssid, item->ssid,
+				strlen(item->ssid))) {
 			wl_ndev_log(L_ERR, vif->ndev, "%s BSS : %s  %pM exist, but also update it.\n",
 				   __func__, item->ssid, item->bssid);
 
 			memcpy((void *)(&p->results[i]),
-			       (void *)item,
+				   (void *)item,
 				sizeof(struct sprdwl_gscan_result));
 			return 0;
 		}
 	}
 	memcpy((void *)(&p->results[p->num_results]),
-	       (void *)item, sizeof(struct sprdwl_gscan_result));
+		   (void *)item, sizeof(struct sprdwl_gscan_result));
 	p->results[p->num_results].ie_length = 0;
 	p->results[p->num_results].ie_data[0] = 0;
 	p->num_results++;
@@ -1395,7 +1394,7 @@ int sprdwl_vendor_cache_significant_change_result(struct sprdwl_vif *vif,
 		frame = (struct significant_change_info *)pos;
 
 		memcpy((void *)(&p->results[p->num_results]),
-		       (void *)pos, sizeof(struct significant_change_info));
+			   (void *)pos, sizeof(struct significant_change_info));
 		p->num_results++;
 
 		avail_len -= sizeof(struct significant_change_info) + 1;
@@ -1422,7 +1421,7 @@ int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
 #else
 	reply = cfg80211_vendor_event_alloc(wiphy,
 #endif
-					    payload,
+						payload,
 		NL80211_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT_INDEX,
 		GFP_KERNEL);
 	if (!reply) {
@@ -1434,7 +1433,7 @@ int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
 			priv->gscan_req_id) ||
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
 	nla_put_u64_64bit(reply,
-		    GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
 		item->ts, 0)
 #else
 	nla_put_u64(reply,
@@ -1449,29 +1448,29 @@ int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
 		6,
 		item->bssid) ||
 	nla_put_u32(reply,
-		    GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+			GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
 		item->channel) ||
 	nla_put_s32(reply, GSCAN_RESULTS_SCAN_RESULT_RSSI,
-		    item->rssi) ||
+			item->rssi) ||
 	nla_put_u32(reply, GSCAN_RESULTS_SCAN_RESULT_RTT,
-		    item->rtt) ||
+			item->rtt) ||
 	nla_put_u32(reply,
-		    GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+			GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
 		item->rtt_sd) ||
 	nla_put_u16(reply,
-		    GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
+			GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
 		item->beacon_period) ||
 	nla_put_u16(reply,
-		    GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
+			GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
 		item->capability) ||
 	nla_put_u32(reply,
-		    GSCAN_RESULTS_SCAN_RESULT_IE_LENGTH,
+			GSCAN_RESULTS_SCAN_RESULT_IE_LENGTH,
 		item->ie_length))	{
 		wl_ndev_log(L_ERR, vif->ndev, "%s nla put fail\n", __func__);
 		goto out_put_fail;
 	}
 	if (nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_IE_DATA,
-		    item->ie_length,
+			item->ie_length,
 		item->ie_data)) {
 		wl_ndev_log(L_ERR, vif->ndev, "%s nla put fail\n", __func__);
 		goto out_put_fail;
@@ -1505,7 +1504,7 @@ void sprdwl_report_gscan_result(struct sprdwl_vif *vif,
 	const u8 *ssid;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
 	freq = ieee80211_channel_to_frequency(chan,
-					      chan <= CH_MAX_2G_CHANNEL ?
+						  chan <= CH_MAX_2G_CHANNEL ?
 						NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
 #else
 	freq = ieee80211_channel_to_frequency(chan,
@@ -1560,7 +1559,7 @@ void sprdwl_report_gscan_result(struct sprdwl_vif *vif,
 		   mgmt->bssid, gscan_res->ssid, report_event);
 
 	if ((report_event == REPORT_EVENTS_BUFFER_FULL) ||
-	    (report_event & REPORT_EVENTS_EACH_SCAN) ||
+		(report_event & REPORT_EVENTS_EACH_SCAN) ||
 		(report_event & REPORT_EVENTS_FULL_RESULTS) ||
 		(report_event & REPORT_EVENTS_SIGNIFICANT_CHANGE)) {
 		sprdwl_vendor_cache_scan_result(vif, bucket_id, gscan_res);
@@ -1592,7 +1591,7 @@ int sprdwl_buffer_full_event(struct sprdwl_vif *vif)
 #else
 	reply = cfg80211_vendor_event_alloc(wiphy,
 #endif
-					    payload,
+						payload,
 		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
 		GFP_KERNEL);
 	if (!reply) {
@@ -1628,7 +1627,7 @@ int sprdwl_available_event(struct sprdwl_vif *vif)
 #else
 	reply = cfg80211_vendor_event_alloc(wiphy,
 #endif
-					    payload,
+						payload,
 		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
 		GFP_KERNEL);
 	if (!reply) {
@@ -1665,7 +1664,7 @@ int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid)
 #else
 	reply = cfg80211_vendor_event_alloc(wiphy,
 #endif
-					    payload,
+						payload,
 		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_EVENT_INDEX,
 		GFP_KERNEL);
 	if (!reply) {
@@ -1679,7 +1678,7 @@ int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid)
 
 	event_type = WIFI_SCAN_COMPLETE;
 	if (nla_put_u8(reply, GSCAN_RESULTS_SCAN_EVENT_TYPE,
-		       event_type))
+			   event_type))
 		goto out_put_fail;
 
 	cfg80211_vendor_event(reply, GFP_KERNEL);
@@ -1694,7 +1693,7 @@ int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid)
 /*set_ssid_hotlist function---CMD ID:29*/
 static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
 					   struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int i, ret = 0, tlen;
 	int type;
@@ -1721,7 +1720,7 @@ static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
 	}
 
 	memset(vif->priv->hotlist_res, 0x0,
-	       sizeof(struct sprdwl_gscan_hotlist_results));
+		   sizeof(struct sprdwl_gscan_hotlist_results));
 
 	nla_for_each_attr(pos, (void *)data, len, rem_len) {
 			type = nla_type(pos);
@@ -1748,19 +1747,19 @@ static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
 					type = nla_type(inner_iter);
 					switch (type) {
 					case GSCAN_ATTR_AP_THR_PARAM_BSSID:
-					    memcpy(
-					    bssid_hotlist_params->ap[i].bssid,
-					    nla_data(inner_iter),
-					    6 * sizeof(unsigned char));
+						memcpy(
+						bssid_hotlist_params->ap[i].bssid,
+						nla_data(inner_iter),
+						6 * sizeof(unsigned char));
 					break;
 
 					case GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW:
-					    bssid_hotlist_params->ap[i].low
+						bssid_hotlist_params->ap[i].low
 						= nla_get_s32(inner_iter);
 					break;
 
 					case GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH:
-					    bssid_hotlist_params->ap[i].high
+						bssid_hotlist_params->ap[i].high
 						= nla_get_s32(inner_iter);
 					break;
 					default:
@@ -1793,7 +1792,7 @@ static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
 		}
 
 	wl_ndev_log(L_INFO, vif->ndev, "parse bssid hotlist %s\n",
-		    !ret ? "success" : "failture");
+			!ret ? "success" : "failture");
 
 	tlen = sizeof(struct wifi_bssid_hotlist_params);
 
@@ -1814,7 +1813,7 @@ static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
 /*reset_bssid_hotlist function---CMD ID:30*/
 static int sprdwl_vendor_reset_bssid_hotlist(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int flush = 1;
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -1835,7 +1834,7 @@ static int sprdwl_vendor_reset_bssid_hotlist(struct wiphy *wiphy,
 /*set_significant_change function---CMD ID:32*/
 static int sprdwl_vendor_set_significant_change(struct wiphy *wiphy,
 						struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int i, ret = 0, tlen;
 	int type;
@@ -1862,7 +1861,7 @@ static int sprdwl_vendor_set_significant_change(struct wiphy *wiphy,
 	}
 
 	memset(vif->priv->significant_res, 0x0,
-	       sizeof(struct sprdwl_significant_change_result));
+		   sizeof(struct sprdwl_significant_change_result));
 
 
 	nla_for_each_attr(pos, (void *)data, len, rem_len) {
@@ -1961,7 +1960,7 @@ static int sprdwl_vendor_set_significant_change(struct wiphy *wiphy,
 /*set_significant_change function---CMD ID:33*/
 static int sprdwl_vendor_reset_significant_change(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int flush = 1;
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -1985,7 +1984,7 @@ static int sprdwl_vendor_reset_significant_change(struct wiphy *wiphy,
 
 /*get support feature function---CMD ID:38*/
 static int sprdwl_vendor_get_support_feature(struct wiphy *wiphy,
-					     struct wireless_dev *wdev,
+						 struct wireless_dev *wdev,
 						const void *data, int len)
 {
 	int ret;
@@ -2014,7 +2013,7 @@ static int sprdwl_vendor_get_support_feature(struct wiphy *wiphy,
 		feature |= WIFI_FEATURE_HOTSPOT;
 	/*bit 4:P2P*/
 	if ((wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_CLIENT)) &&
-	    (wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_GO))) {
+		(wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_GO))) {
 		wl_info("P2P is supported\n");
 		feature |= WIFI_FEATURE_P2P;
 	}
@@ -2148,8 +2147,8 @@ static int sprdwl_vendor_get_support_feature(struct wiphy *wiphy,
 
 /*set_mac_oui functon------ CMD ID:39*/
 static int sprdwl_vendor_set_mac_oui(struct wiphy *wiphy,
-					      struct wireless_dev *wdev,
-				     const void *data, int len)
+						  struct wireless_dev *wdev,
+					 const void *data, int len)
 {
 	struct nlattr *pos;
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -2177,7 +2176,7 @@ static int sprdwl_vendor_set_mac_oui(struct wiphy *wiphy,
 			ret = -EINVAL;
 			goto out;
 		break;
-	    }
+		}
 	}
 
 	tlen = sizeof(struct v_MACADDR_t);
@@ -2214,7 +2213,7 @@ static int sprdwl_vendor_get_concurrency_matrix(struct wiphy *wiphy,
 	struct sk_buff *reply_skb;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	if (nla_parse(tb, SPRDWL_ATTR_CO_MATRIX_MAX,
-		      data, len, NULL, NULL)) {
+			  data, len, NULL, NULL)) {
 #else
 	if (nla_parse(tb, SPRDWL_ATTR_CO_MATRIX_MAX,
 			data, len, NULL)) {
@@ -2275,8 +2274,8 @@ static int sprdwl_vendor_get_concurrency_matrix(struct wiphy *wiphy,
 
 /*get support feature function---CMD ID:55*/
 static int sprdwl_vendor_get_feature(struct wiphy *wiphy,
-				     struct wireless_dev *wdev,
-				     const void *data, int len)
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
 {
 	return 0;
 }
@@ -2297,12 +2296,12 @@ static int sprdwl_vendor_get_wake_state(struct wiphy *wiphy,
 	wake_cnt = &priv->wakeup_tracer;
 	buf_len = NLMSG_HDRLEN;
 	buf_len += WLAN_GET_WAKE_STATS_MAX *
-		     (NLMSG_HDRLEN + sizeof(uint32_t));
+			 (NLMSG_HDRLEN + sizeof(uint32_t));
 	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, buf_len);
 
 	if (!skb) {
 				wl_err("cfg80211_vendor_cmd_alloc_reply_skb failed\n");
-			    return -ENOMEM;
+				return -ENOMEM;
 	}
 
 	ipv4_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.ipv4_mc_cnt;
@@ -2381,8 +2380,8 @@ static int sprdwl_vendor_enable_nd_offload(struct wiphy *wiphy,
 }
 
 static int sprdwl_vendor_start_logging(struct wiphy *wiphy,
-				       struct wireless_dev *wdev,
-				       const void *data, int len)
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
 {
 	wiphy_info(wiphy, "%s\n", __func__);
 
@@ -2390,8 +2389,8 @@ static int sprdwl_vendor_start_logging(struct wiphy *wiphy,
 }
 
 static int sprdwl_vendor_get_ring_data(struct wiphy *wiphy,
-				       struct wireless_dev *wdev,
-				       const void *data, int len)
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
 {
 	wiphy_info(wiphy, "%s\n", __func__);
 
@@ -2399,8 +2398,8 @@ static int sprdwl_vendor_get_ring_data(struct wiphy *wiphy,
 }
 
 static int sprdwl_vendor_memory_dump(struct wiphy *wiphy,
-				     struct wireless_dev *wdev,
-				     const void *data, int len)
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
 {
 	wiphy_info(wiphy, "%s\n", __func__);
 
@@ -2410,8 +2409,8 @@ static int sprdwl_vendor_memory_dump(struct wiphy *wiphy,
 /*CMD ID:61*/
 static const struct nla_policy sprdwl_get_wifi_info_policy[
 		SPRDWL_ATTR_WIFI_INFO_GET_MAX + 1] = {
-		[SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION] = {.type = NLA_U32},
-		[SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION] = {.type = NLA_U32},
+		[SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION] = {.type = NLA_U8},
+		[SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION] = {.type = NLA_U8},
 };
 
 static int sprdwl_vendor_get_driver_info(struct wiphy *wiphy,
@@ -2428,7 +2427,7 @@ static int sprdwl_vendor_get_driver_info(struct wiphy *wiphy,
 	wl_info("%s enter\n", __func__);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	if (nla_parse(tb_vendor, SPRDWL_ATTR_WIFI_INFO_GET_MAX, data,
-		      len, sprdwl_get_wifi_info_policy, NULL)) {
+			  len, sprdwl_get_wifi_info_policy, NULL)) {
 #else
 	if (nla_parse(tb_vendor, SPRDWL_ATTR_WIFI_INFO_GET_MAX, data,
 			len, sprdwl_get_wifi_info_policy)) {
@@ -2456,7 +2455,7 @@ static int sprdwl_vendor_get_driver_info(struct wiphy *wiphy,
 		return -ENOMEM;
 
 	if (nla_put(reply, SPRDWL_VENDOR_ATTR_WIFI_INFO_DRIVER_VERSION,
-		    payload, version)) {
+			payload, version)) {
 		wiphy_err(wiphy, "%s put version error\n", __func__);
 		goto out_put_fail;
 	}
@@ -2517,13 +2516,13 @@ static int sprdwl_vendor_set_roam_params(struct wiphy *wiphy,
 	case SPRDWL_ATTR_ROAM_SUBCMD_SSID_WHITE_LIST:
 		if (!tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST])
 			break;
-	    i = 0;
+		i = 0;
 		nla_for_each_nested(curr_attr,
-				    tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST],
+					tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST],
 					rem) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 			if (nla_parse(tb2, SPRDWL_ATTR_ROAM_SUBCMD_MAX,
-				      nla_data(curr_attr),
+					  nla_data(curr_attr),
 					nla_len(curr_attr),
 					NULL, NULL)) {
 #else
@@ -2550,7 +2549,7 @@ static int sprdwl_vendor_set_roam_params(struct wiphy *wiphy,
 			white_limit = min(fw_max_whitelist, MAX_WHITE_SSID);
 
 			if (buf_len && (i < white_limit) &&
-			    ((buf_len - 1) <= IEEE80211_MAX_SSID_LEN)) {
+				((buf_len - 1) <= IEEE80211_MAX_SSID_LEN)) {
 				nla_memcpy(
 					white_params.white_list[i].ssid_str,
 					tb2[SPRDWL_ROAM_WHITE_LIST_SSID],
@@ -2597,10 +2596,10 @@ static int sprdwl_vendor_set_roam_params(struct wiphy *wiphy,
 		}
 		i = 0;
 		nla_for_each_nested(curr_attr,
-				    tb[SPRDWL_ROAM_SET_BSSID_PARAMS], rem) {
+					tb[SPRDWL_ROAM_SET_BSSID_PARAMS], rem) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 			if (nla_parse(tb2, SPRDWL_ROAM_MAX,
-				      nla_data(curr_attr), nla_len(curr_attr),
+					  nla_data(curr_attr), nla_len(curr_attr),
 					NULL, NULL)) {
 #else
 			if (nla_parse(tb2, SPRDWL_ROAM_MAX,
@@ -2640,7 +2639,7 @@ static int sprdwl_vendor_set_roam_params(struct wiphy *wiphy,
 /*set_ssid_hotlist function---CMD ID:65*/
 static int sprdwl_vendor_set_ssid_hotlist(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int i, ret = 0, tlen;
 	int type, request_id;
@@ -2727,7 +2726,7 @@ static int sprdwl_vendor_set_ssid_hotlist(struct wiphy *wiphy,
 	}
 
 	wl_ndev_log(L_INFO, vif->ndev, "parse bssid hotlist %s\n",
-		    !ret ? "success" : "failture");
+			!ret ? "success" : "failture");
 
 	tlen = sizeof(struct wifi_ssid_hotlist_params);
 	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
@@ -2742,7 +2741,7 @@ static int sprdwl_vendor_set_ssid_hotlist(struct wiphy *wiphy,
 /*reset_ssid_hotlist function---CMD ID:66*/
 static int sprdwl_vendor_reset_ssid_hotlist(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int flush = 1;
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -2760,8 +2759,8 @@ static int sprdwl_vendor_reset_ssid_hotlist(struct wiphy *wiphy,
 
 /*set_passpoint_list functon------ CMD ID:70*/
 static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
-					    struct wireless_dev *wdev,
-				     const void *data, int len)
+						struct wireless_dev *wdev,
+					 const void *data, int len)
 {
 	struct nlattr *tb[GSCAN_MAX + 1];
 	struct nlattr *tb2[GSCAN_MAX + 1];
@@ -2773,13 +2772,13 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	if (nla_parse(tb, GSCAN_MAX, data, len,
-		      wlan_gscan_config_policy, NULL)) {
+			  wlan_gscan_config_policy, NULL)) {
 #else
 	if (nla_parse(tb, GSCAN_MAX, data, len,
 			wlan_gscan_config_policy)) {
 #endif
 		wl_ndev_log(L_INFO, vif->ndev,
-			    "%s :Fail to parse attribute\n",
+				"%s :Fail to parse attribute\n",
 			__func__);
 		return -EINVAL;
 	}
@@ -2791,7 +2790,7 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 	/* Parse and fetch */
 	if (!tb[GSCAN_ANQPO_LIST_FLUSH]) {
 		wl_ndev_log(L_INFO, vif->ndev,
-			    "%s :Fail to parse GSCAN_ANQPO_LIST_FLUSH\n",
+				"%s :Fail to parse GSCAN_ANQPO_LIST_FLUSH\n",
 			__func__);
 		ret = -EINVAL;
 		goto out;
@@ -2815,10 +2814,10 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 	hs_num = nla_get_u32(tb[GSCAN_ANQPO_HS_LIST_SIZE]);
 
 	nla_for_each_nested(HS_list,
-			    tb[GSCAN_ANQPO_HS_LIST], rem) {
+				tb[GSCAN_ANQPO_HS_LIST], rem) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 		if (nla_parse(tb2, GSCAN_MAX,
-			      nla_data(HS_list), nla_len(HS_list),
+				  nla_data(HS_list), nla_len(HS_list),
 					NULL, NULL)) {
 #else
 		if (nla_parse(tb2, GSCAN_MAX,
@@ -2826,15 +2825,15 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 				NULL)) {
 #endif
 			wl_ndev_log(L_INFO, vif->ndev,
-				    "%s :Fail to parse tb2\n",
+					"%s :Fail to parse tb2\n",
 				__func__);
 			ret = -EINVAL;
-			     goto out;
+				 goto out;
 		}
 
 		if (!tb2[GSCAN_ANQPO_HS_NETWORK_ID]) {
 			wl_ndev_log(L_INFO, vif->ndev,
-				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NETWORK_ID\n",
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NETWORK_ID\n",
 				__func__);
 			ret = -EINVAL;
 			goto out;
@@ -2845,7 +2844,7 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 
 		if (!tb2[GSCAN_ANQPO_HS_NAI_REALM]) {
 			wl_ndev_log(L_INFO, vif->ndev,
-				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NAI_REALM\n",
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NAI_REALM\n",
 				__func__);
 			ret = -EINVAL;
 			goto out;
@@ -2856,7 +2855,7 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 
 		if (!tb2[GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID]) {
 			wl_ndev_log(L_INFO, vif->ndev,
-				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_ROAM_CONSORTIUM_ID\n",
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_ROAM_CONSORTIUM_ID\n",
 				__func__);
 			ret = -EINVAL;
 			goto out;
@@ -2868,7 +2867,7 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 
 		if (!tb2[GSCAN_ANQPO_HS_PLMN]) {
 			wl_ndev_log(L_INFO, vif->ndev,
-				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_PLMN\n",
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_PLMN\n",
 				__func__);
 			ret = -EINVAL;
 			goto out;
@@ -2894,7 +2893,7 @@ static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
 /*reset_passpoint_list functon------ CMD ID:71*/
 static int sprdwl_vendor_reset_passpoint_list(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
-				     const void *data, int len)
+					 const void *data, int len)
 {
 	int flush = 1;
 	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
@@ -2930,7 +2929,7 @@ static int send_rssi_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
 #define MIN_RSSI         SPRDWL_ATTR_RSSI_MONITORING_MIN_RSSI
 #define MAX_RSSI         SPRDWL_ATTR_RSSI_MONITORING_MAX_RSSI
 static int sprdwl_vendor_monitor_rssi(struct wiphy *wiphy,
-				      struct wireless_dev *wdev,
+					  struct wireless_dev *wdev,
 		const void *data, int len)
 {
 	struct nlattr *tb[MONITOR_MAX + 1];
@@ -2989,7 +2988,7 @@ static int sprdwl_vendor_monitor_rssi(struct wiphy *wiphy,
 
 		if (!(req.min_rssi < req.max_rssi)) {
 			wl_err("min rssi %d must be less than max_rssi:%d\n",
-			       req.min_rssi, req.max_rssi);
+				   req.min_rssi, req.max_rssi);
 			return -EINVAL;
 		}
 		wl_info("min_rssi:%d max_rssi:%d\n",
@@ -3047,8 +3046,8 @@ void sprdwl_event_rssi_monitor(struct sprdwl_vif *vif, u8 *data, u16 len)
 }
 
 static int sprdwl_vendor_get_logger_feature(struct wiphy *wiphy,
-					    struct wireless_dev *wdev,
-					    const void *data, int len)
+						struct wireless_dev *wdev,
+						const void *data, int len)
 {
 	int ret;
 	struct sk_buff *reply;
@@ -3098,8 +3097,8 @@ static int sprdwl_flush_epno_list(struct sprdwl_vif *vif)
 }
 
 static int sprdwl_vendor_set_epno_list(struct wiphy *wiphy,
-				       struct wireless_dev *wdev,
-				       const void *data, int len)
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
 {
 	int i, ret = 0;
 	int type;
@@ -3158,23 +3157,23 @@ static int sprdwl_vendor_set_epno_list(struct wiphy *wiphy,
 			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
 				epno_network = &epno_params.networks[i];
 				nla_for_each_nested(inner_iter, outer_iter,
-						    rem_inner_len) {
+							rem_inner_len) {
 					type = nla_type(inner_iter);
 					switch (type) {
 					case SPRDWL_EPNO_PARAM_NETWORK_SSID:
 						memcpy(epno_network->ssid,
-						       nla_data(inner_iter),
-						       IEEE80211_MAX_SSID_LEN);
+							   nla_data(inner_iter),
+							   IEEE80211_MAX_SSID_LEN);
 						break;
 
 					case SPRDWL_EPNO_PARAM_NETWORK_FLAGS:
 						epno_network->flags =
-						    nla_get_u8(inner_iter);
+							nla_get_u8(inner_iter);
 						break;
 
 					case SPRDWL_EPNO_PARAM_NETWORK_AUTH_BIT:
 						epno_network->auth_bit_field =
-						    nla_get_u8(inner_iter);
+							nla_get_u8(inner_iter);
 						break;
 
 					default:
@@ -3210,7 +3209,7 @@ static int sprdwl_vendor_set_epno_list(struct wiphy *wiphy,
 	epno_params.boot_time = jiffies;
 
 	wl_ndev_log(L_INFO, vif->ndev, "parse epno list %s\n",
-		    !ret ? "success" : "failture");
+			!ret ? "success" : "failture");
 	if (!ret)
 		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
 					  (void *)&epno_params,
@@ -3249,7 +3248,7 @@ int sprdwl_hotlist_change_event(struct sprdwl_vif *vif, u32 report_event)
 #else
 	reply = cfg80211_vendor_event_alloc(wiphy, payload,
 #endif
-					    event_idx, GFP_KERNEL);
+						event_idx, GFP_KERNEL);
 
 	if (!reply)
 		return -ENOMEM;
@@ -3512,9 +3511,9 @@ static int sprdwl_vendor_set_sar_limits(struct wiphy *wiphy,
 }
 
 static int sprdwl_start_offload_packet(struct sprdwl_priv *priv,
-				       u8 vif_ctx_id,
-				       struct nlattr **tb,
-				       u32 request_id)
+					   u8 vif_ctx_id,
+					   struct nlattr **tb,
+					   u32 request_id)
 {
 	u8 src[ETH_ALEN], dest[ETH_ALEN];
 	u32 period, len;
@@ -3560,15 +3559,15 @@ static int sprdwl_start_offload_packet(struct sprdwl_priv *priv,
 }
 
 static int sprdwl_stop_offload_packet(struct sprdwl_priv *priv,
-				      u8 vif_ctx_id, u32 request_id)
+					  u8 vif_ctx_id, u32 request_id)
 {
 	return sprdwl_set_packet_offload(priv, vif_ctx_id,
 					 request_id, 0, 0, 0, NULL);
 }
 
 static int sprdwl_set_offload_packet(struct wiphy *wiphy,
-				     struct wireless_dev *wdev,
-				     const void *data, int len)
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
 {
 	int err;
 	u8 control;
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h b/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h
new file mode 100755
index 000000000000..31042f86d6b1
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h
@@ -0,0 +1,20 @@
+#ifndef __WCN_WRAPPER_H__
+#define __WCN_WRAPPER_H__
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+#ifndef timespec
+#define timespec timespec64
+#define timespec_to_ns timespec64_to_ns
+#define getnstimeofday ktime_get_real_ts64
+#define do_gettimeofday ktime_get_real_ts64
+#define timeval_to_ns timespec64_to_ns
+#define timeval timespec64
+#endif
+
+#elif KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE
+#define timeval timespec
+#define do_gettimeofday getnstimeofday
+#define timeval_to_ns timespec_to_ns
+
+#endif
+#endif//__WCN_WRAPPER_H__
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
index a4ef854b62e6..042a4df0161e 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
@@ -18,7 +18,6 @@
 #include <linux/platform_device.h>
 #include <linux/utsname.h>
 #include <linux/debugfs.h>
-#include <linux/kthread.h>
 #include <linux/version.h>
 #include <marlin_platform.h>
 #include <linux/of.h>
@@ -87,7 +86,7 @@ void adjust_qos_ratio(char *buf, unsigned char offset)
 	}
 
 	wl_err("vo ratio:%u, vi ratio:%u, be ratio:%u, wmmac_ratio:%u\n",
-	       vo_ratio, vi_ratio, be_ratio, wmmac_ratio);
+		   vo_ratio, vi_ratio, be_ratio, wmmac_ratio);
 }
 #endif
 unsigned int new_threshold;
@@ -148,10 +147,10 @@ void sprdwl_tdls_flow_flush(struct sprdwl_vif *vif, const u8 *peer, u8 oper)
 	if (oper == NL80211_TDLS_SETUP || oper == NL80211_TDLS_ENABLE_LINK) {
 		for (i = 0; i < MAX_TDLS_PEER; i++) {
 			if (ether_addr_equal(intf->tdls_flow_count[i].da,
-					     peer)) {
+						 peer)) {
 				memset(&intf->tdls_flow_count[i],
-				       0,
-				       sizeof(struct tdls_flow_count_para));
+					   0,
+					   sizeof(struct tdls_flow_count_para));
 				break;
 			}
 		}
@@ -173,7 +172,7 @@ void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len)
 	}
 	for (i = 0; i < MAX_TDLS_PEER; i++) {
 		if (ether_addr_equal(intf->tdls_flow_count[i].da,
-				     peer_info->da)) {
+					 peer_info->da)) {
 			found = 1;
 			break;
 		}
@@ -185,8 +184,8 @@ void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len)
 			return;
 		}
 		memset(&intf->tdls_flow_count[i],
-		       0,
-		       sizeof(struct tdls_flow_count_para));
+			   0,
+			   sizeof(struct tdls_flow_count_para));
 
 		for (i = 0; i < MAX_TDLS_PEER; i++) {
 			if (intf->tdls_flow_count[i].valid == 1)
@@ -220,7 +219,7 @@ void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len)
 			peer_info->timer, peer_info->da);
 
 		kt = ktime_get();
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 		intf->tdls_flow_count[i].start_mstime =
 			(u32)(div_u64(kt, NSEC_PER_MSEC));
 #else
@@ -247,7 +246,7 @@ void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len)
 
 	for (i = 0; i < MAX_TDLS_PEER; i++) {
 		if ((intf->tdls_flow_count[i].valid == 1) &&
-		    (ether_addr_equal(data, intf->tdls_flow_count[i].da)))
+			(ether_addr_equal(data, intf->tdls_flow_count[i].da)))
 			goto count_it;
 	}
 	return;
@@ -256,7 +255,7 @@ void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len)
 	if (new_threshold != 0)
 		intf->tdls_flow_count[i].threshold = new_threshold;
 	kt = ktime_get();
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 	msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
 #else
 	msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
@@ -272,28 +271,28 @@ void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len)
 		msec, elapsed_time, unit_time);
 
 	if ((intf->tdls_flow_count[i].data_len_counted == 0 &&
-	     len > (intf->tdls_flow_count[i].threshold * 1024)) ||
-	    (intf->tdls_flow_count[i].data_len_counted > 0 &&
-	    ((intf->tdls_flow_count[i].data_len_counted + len) >
-	     intf->tdls_flow_count[i].threshold * 1024 *
-	     ((unit_time == 0) ? 1 : unit_time)))) {
+		 len > (intf->tdls_flow_count[i].threshold * 1024)) ||
+		(intf->tdls_flow_count[i].data_len_counted > 0 &&
+		((intf->tdls_flow_count[i].data_len_counted + len) >
+		 intf->tdls_flow_count[i].threshold * 1024 *
+		 ((unit_time == 0) ? 1 : unit_time)))) {
 		ret = sprdwl_send_tdls_cmd(vif, vif->ctx_id,
 					   (u8 *)intf->tdls_flow_count[i].da,
 					   SPRDWL_TDLS_CMD_CONNECT);
 		memset(&intf->tdls_flow_count[i], 0,
-			       sizeof(struct tdls_flow_count_para));
+				   sizeof(struct tdls_flow_count_para));
 	} else {
 		if (intf->tdls_flow_count[i].data_len_counted == 0) {
 			intf->tdls_flow_count[i].start_mstime = msec;
 			intf->tdls_flow_count[i].data_len_counted += len;
 		}
 		if ((intf->tdls_flow_count[i].data_len_counted > 0) &&
-		    unit_time > 1) {
+			unit_time > 1) {
 			intf->tdls_flow_count[i].start_mstime = msec;
 			intf->tdls_flow_count[i].data_len_counted = len;
 		}
 		if ((intf->tdls_flow_count[i].data_len_counted > 0) &&
-		    unit_time <= 1) {
+			unit_time <= 1) {
 			intf->tdls_flow_count[i].data_len_counted += len;
 		}
 	}
@@ -307,8 +306,8 @@ void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len)
 
 #define SPRDWL_SDIO_DEBUG_BUFLEN 128
 static ssize_t sprdwl_intf_read_info(struct file *file,
-				     char __user *user_buf,
-				     size_t count, loff_t *ppos)
+					 char __user *user_buf,
+					 size_t count, loff_t *ppos)
 {
 	size_t ret = 0;
 	unsigned int buflen, len;
@@ -367,7 +366,7 @@ static ssize_t sprdwl_intf_write(struct file *file,
 	wl_debug("write info:%s\n", buf);
 	for (type = 0; type < debug_size; type++)
 		if (!strncmp(debuginfo[type].str, buf,
-			     strlen(debuginfo[type].str))) {
+				 strlen(debuginfo[type].str))) {
 			wl_err("write info:type %d\n", type);
 			debuginfo[type].func(buf, strlen(debuginfo[type].str));
 			break;
@@ -443,7 +442,7 @@ void sprdwl_debugfs(void *spdev, struct dentry *dir)
 
 	intf = (struct sprdwl_intf *)spdev;
 	debugfs_create_file("sprdwlinfo", S_IRUSR,
-			    dir, intf, &sprdwl_intf_debug_fops);
+				dir, intf, &sprdwl_intf_debug_fops);
 }
 
 static struct dentry *sprdwl_debug_root;
@@ -539,12 +538,20 @@ static struct notifier_block boost_notifier = {
 extern struct sprdwl_priv *g_sprdwl_priv;
 extern void sprdwl_cancel_scan(struct sprdwl_vif *vif);
 extern void sprdwl_cancel_sched_scan(struct sprdwl_vif *vif);
+extern void sprdwl_flush_all_txlist(struct sprdwl_tx_msg *sprdwl_tx_dev);
+extern int sprdwl_cmd_init(void);
+extern void sprdwl_cmd_deinit(void);
+extern void sprdwl_net_flowcontrl(struct sprdwl_priv *priv,
+			   enum sprdwl_mode mode, bool state);
+extern void sprdwl_reg_notify(struct wiphy *wiphy, struct regulatory_request *request);
+struct work_struct wifi_rst_begin;
+struct work_struct wifi_rst_down;
 struct completion wifi_reset_ready;
-extern void sprdwl_net_flowcontrl(struct sprdwl_priv *priv, enum sprdwl_mode mode, bool state);
 extern struct sprdwl_cmd g_sprdwl_cmd;
 
-static void sprdwl_wifi_reset(void)
+static void wifi_reset_wq(struct work_struct *work)
 {
+	struct sprdwl_vif *vif, *tmp_vif;
 	struct sprdwl_intf *intf = NULL;
 	struct sprdwl_tx_msg *tx_msg = NULL;
 	struct sprdwl_rx_if *rx_if = NULL;
@@ -553,38 +560,103 @@ static void sprdwl_wifi_reset(void)
 	tx_msg = (void *)intf->sprdwl_tx;
 	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
 
+	reinit_completion(&wifi_reset_ready);
+
 	wl_err("cp2 reset begin..........\n");
 	g_sprdwl_priv->sync.scan_not_allowed = true;
 	g_sprdwl_priv->sync.cmd_not_allowed = true;
 	intf->cp_asserted = 1;
-	intf->exit = 1;
-	if (tx_msg->tx_thread) {
+	sprdwl_reorder_init(&rx_if->ba_entry);
+	sprdwl_net_flowcontrl(g_sprdwl_priv, SPRDWL_MODE_NONE, false);
+	if (tx_msg->tx_thread)
 		tx_up(tx_msg);
-		kthread_stop(tx_msg->tx_thread);
-		tx_msg->tx_thread = NULL;
+
+	sprdwl_flush_all_txlist(tx_msg);
+	flush_workqueue(rx_if->rx_queue);
+	list_for_each_entry_safe(vif, tmp_vif, &g_sprdwl_priv->vif_list, vif_node) {
+		g_sprdwl_priv->sync.fw_stat[vif->mode] =  g_sprdwl_priv->fw_stat[vif->mode];
+		g_sprdwl_priv->fw_stat[vif->mode] = SPRDWL_INTF_CLOSE;
+		sprdwl_report_disconnection(vif, true);
+		if (g_sprdwl_priv->scan_vif)
+			sprdwl_cancel_scan(g_sprdwl_priv->scan_vif);
+		if (g_sprdwl_priv->sched_scan_vif) {
+			sprdwl_sched_scan_done(g_sprdwl_priv->sched_scan_vif, true);
+			sprdwl_cancel_sched_scan(g_sprdwl_priv->sched_scan_vif);
+		}
 	}
 
+	sprdwl_vendor_deinit(g_sprdwl_priv->wiphy);
+	sprdwl_cmd_wake_upall();
+	sprdwl_tcp_ack_deinit(g_sprdwl_priv);
+	sprdwl_intf_deinit(intf);
+	// sprdwl_cmd_deinit();
+	complete(&wifi_reset_ready);
 	wl_err("cp2 reset finish..........\n");
+
 }
 
-static int wifi_exception_event(void)
+static void wifi_resume_wq(struct work_struct *work)
 {
-	char *envp[2];
-	envp[0] = "CP2-EXCEPTION-EVENT";
-	envp[1] = NULL;
-	kobject_uevent_env(&sprdwl_dev->kobj, KOBJ_CHANGE, envp);
-	return 0;
+	struct sprdwl_vif *vif, *tmp_vif;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_rx_if *rx_if = NULL;
+	wl_err("cp2 resume begin...............\n");
+
+	intf = (struct sprdwl_intf *)g_sprdwl_priv->hw_priv;
+	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	wait_for_completion(&wifi_reset_ready);
+
+	sprdwl_intf_init(g_sprdwl_priv, intf);
+	// sprdwl_cmd_init();
+	wl_err("sprdwl cmd init finish.\n");
+	g_sprdwl_priv->sync.cmd_not_allowed = false;
+	intf->cp_asserted = 0;
+	sprdwl_net_flowcontrl(g_sprdwl_priv, SPRDWL_MODE_NONE, true);
+	sprdwl_reorder_init(&rx_if->ba_entry);
+	sprdwl_sync_version(g_sprdwl_priv);
+	sprdwl_download_ini(g_sprdwl_priv);
+	sprdwl_tcp_ack_init(g_sprdwl_priv);
+	sprdwl_get_fw_info(g_sprdwl_priv);
+	sprdwl_setup_wiphy(g_sprdwl_priv->wiphy, g_sprdwl_priv);
+	sprdwl_vendor_init(g_sprdwl_priv->wiphy);
+
+	sprdwl_reg_notify(g_sprdwl_priv->wiphy, &g_sprdwl_priv->sync.request);
+
+	list_for_each_entry_safe(vif, tmp_vif, &g_sprdwl_priv->vif_list, vif_node) {
+		if (SPRDWL_INTF_OPEN == g_sprdwl_priv->sync.fw_stat[vif->mode]) {
+			vif->mode = SPRDWL_MODE_NONE;
+			sprdwl_init_fw(vif);
+		}
+	}
+	g_sprdwl_priv->sync.scan_not_allowed = false;
+	wl_err("cp2 resume complete...............\n");
+}
+
+static void wifi_reset_init(void)
+{
+	INIT_WORK(&wifi_rst_begin, wifi_reset_wq);
+	INIT_WORK(&wifi_rst_down, wifi_resume_wq);
+	init_completion(&wifi_reset_ready);
+	return;
 }
 
 int wifi_reset_callback(struct notifier_block *nb, unsigned long event, void *v)
 {
-	sprdwl_wifi_reset();
-	wifi_exception_event();
+	wl_info("%s[%d]: %s %d\n", __func__, __LINE__, (char *)v, (int)event);
+	switch (event) {
+	case 1:
+		schedule_work(&wifi_rst_begin);
+		break;
+	case 0:
+		schedule_work(&wifi_rst_down);
+		break;
+	}
+
 	return NOTIFY_OK;
 }
-
 static struct notifier_block wifi_reset_notifier = {
-    .notifier_call = wifi_reset_callback,
+	.notifier_call = wifi_reset_callback,
 };
 #endif
 
@@ -596,6 +668,7 @@ static int sprdwl_probe(struct platform_device *pdev)
 	u8 i;
 
 #ifdef CP2_RESET_SUPPORT
+	wifi_reset_init();
 	marlin_reset_callback_register(MARLIN_WIFI, &wifi_reset_notifier);
 #endif
 
@@ -692,6 +765,7 @@ static int sprdwl_probe(struct platform_device *pdev)
 	return ret;
 
 err_core_init:
+	sprdwl_bus_deinit();
 	sprdwl_tx_deinit(intf);
 err_tx_init:
 	sprdwl_rx_deinit(intf);
@@ -717,6 +791,7 @@ static int sprdwl_remove(struct platform_device *pdev)
 	cpufreq_unregister_notifier(&boost_notifier, CPUFREQ_POLICY_NOTIFIER);
 	sprdwl_debugfs_deinit();
 	sprdwl_core_deinit(priv);
+	sprdwl_bus_deinit();
 	sprdwl_tx_deinit(intf);
 	sprdwl_rx_deinit(intf);
 	sprdwl_intf_deinit(intf);
@@ -762,8 +837,8 @@ static int __init unisoc_wlan_init(void)
 
 static void __exit unisoc_wlan_exit(void)
 {
-    platform_driver_unregister(&sprdwl_driver);
-    platform_device_del(unisoc_pdev);
+	platform_driver_unregister(&sprdwl_driver);
+	platform_device_del(unisoc_pdev);
 }
 
 module_init(unisoc_wlan_init);
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
index 8bad5a5fd538..0d039c18e226 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
@@ -17,7 +17,7 @@
 
 #ifndef __WL_CORE_H__
 #define __WL_CORE_H__
-
+#include "wcn_wrapper.h"
 #include <linux/types.h>
 #include <linux/wait.h>
 #include <linux/spinlock.h>
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
index b05a57678264..a6def0e0682d 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
@@ -24,9 +24,6 @@
 #include "rx_msg.h"
 #include "work.h"
 #include "tcp_ack.h"
-#ifndef CPUFREQ_ADJUST
-#define CPUFREQ_ADJUST			(0)
-#endif
 
 #define INIT_INTF(num, type, out, interval, bsize, psize, max,\
 			 threshold, time, pop, push, complete, suspend) \
@@ -46,7 +43,7 @@ static inline struct sprdwl_intf *get_intf(void)
 	(get_intf()->priv->hw_type == SPRDWL_HW_PCIE)
 
 void sprdwl_hex_dump(unsigned char *name,
-		     unsigned char *data, unsigned short len)
+			 unsigned char *data, unsigned short len)
 {
 	int i, p = 0, ret;
 	unsigned char buf[255] = {0};
@@ -105,19 +102,19 @@ void sprdwl_dump_stats(struct sprdwl_intf *intf)
 {
 	wl_err("++print txrx statistics++\n");
 	wl_err("tx packets: %lu, tx bytes: %lu\n",  intf->stats.tx_packets,
-	       intf->stats.tx_bytes);
+		   intf->stats.tx_bytes);
 	wl_err("tx filter num: %lu\n",  intf->stats.tx_filter_num);
 	wl_err("tx errors: %lu, tx dropped: %lu\n",  intf->stats.tx_errors,
-	       intf->stats.tx_dropped);
+		   intf->stats.tx_dropped);
 	wl_err("tx avg time: %lu\n",  intf->stats.tx_avg_time);
 	wl_err("tx realloc: %lu\n",  intf->stats.tx_realloc);
 	wl_err("tx arp num: %lu\n",  intf->stats.tx_arp_num);
 	wl_err("rx packets: %lu, rx bytes: %lu\n",  intf->stats.rx_packets,
-	       intf->stats.rx_bytes);
+		   intf->stats.rx_bytes);
 	wl_err("rx errors: %lu, rx dropped: %lu\n",  intf->stats.rx_errors,
-	       intf->stats.rx_dropped);
+		   intf->stats.rx_dropped);
 	wl_err("rx multicast: %lu, tx multicast: %lu\n",
-	       intf->stats.rx_multicast, intf->stats.tx_multicast);
+		   intf->stats.rx_multicast, intf->stats.tx_multicast);
 	wl_err("--print txrx statistics--\n");
 }
 
@@ -130,7 +127,7 @@ void sprdwl_clear_stats(struct sprdwl_intf *intf)
 *from network stack to freed by HIF every STATS_COUNT packets
 */
 void sprdwl_get_tx_avg_time(struct sprdwl_intf *intf,
-			    unsigned long tx_start_time)
+				unsigned long tx_start_time)
 {
 	struct timespec tx_end;
 
@@ -159,7 +156,7 @@ void set_coex_bt_on_off(u8 action)
 unsigned long mbufalloc;
 unsigned long mbufpop;
 int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
-	      int len, int chn)
+		  int len, int chn)
 {
 	int ret;
 	struct mbuf_t *head = NULL, *tail = NULL, *mbuf = NULL;
@@ -168,7 +165,7 @@ int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
 	ret = sprdwcn_bus_list_alloc(chn, &head, &tail, &num);
 	if (ret || head == NULL || tail == NULL) {
 		wl_err("%s:%d sprdwcn_bus_list_alloc fail\n",
-		       __func__, __LINE__);
+			   __func__, __LINE__);
 		return -1;
 	}
 	mbufalloc += num;
@@ -181,7 +178,7 @@ int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
 		sprdwl_hex_dump("tx to cp2 cmd data dump", data + 4, len);
 	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
 		mbuf->phy = mm_virt_to_phys(&intf->pdev->dev, mbuf->buf,
-					    mbuf->len, DMA_TO_DEVICE);
+						mbuf->len, DMA_TO_DEVICE);
 	}
 
 	ret = sprdwcn_bus_push_list(chn, head, tail, num);
@@ -208,7 +205,7 @@ inline int if_tx_cmd(struct sprdwl_intf *intf, unsigned char *data, int len)
 }
 
 inline int if_tx_addr_trans(struct sprdwl_intf *intf,
-			    unsigned char *data, int len)
+				unsigned char *data, int len)
 {
 	/* FIXME: Which port is used to send ADDR TRNAS*/
 	return if_tx_one(intf, data, len, intf->tx_data_port);
@@ -251,15 +248,15 @@ static inline struct pcie_addr_buffer
 	mbuf->len = ADDR_OFFSET + tx_count * SPRDWL_PHYS_LEN;
 	mbuf->buf = (unsigned char *)addr_buffer;
 	mbuf->phy = mm_virt_to_phys(&intf->pdev->dev, mbuf->buf,
-				    mbuf->len, DMA_TO_DEVICE);
+					mbuf->len, DMA_TO_DEVICE);
 
 	return addr_buffer;
 }
 
 void sprdwl_add_tx_list_head(struct list_head *tx_fail_list,
-			     struct list_head *tx_list,
-			     int ac_index,
-			     int tx_count)
+				 struct list_head *tx_list,
+				 int ac_index,
+				 int tx_count)
 {
 	struct sprdwl_msg_buf *msg_buf = NULL;
 	struct list_head *xmit_free_list;
@@ -433,20 +430,20 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 			pcie_count = num + 1;
 		}
 		ret = sprdwcn_bus_list_alloc(dev->tx_data_port, &head,
-				      &tail, &pcie_count);
+					  &tail, &pcie_count);
 	} else {
 		ret = sprdwcn_bus_list_alloc(dev->tx_data_port, &head,
-				      &tail, &tx_count);
+					  &tail, &tx_count);
 	}
 	if (ret != 0 || head == NULL || tail == NULL) {
 		wl_err("%s, %d, mbuf alloc fail\n",
-		       __func__, __LINE__);
+			   __func__, __LINE__);
 		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
 		return -ENOMEM;
 	}
 	if (tx_count_saved != tx_count) {
 		wl_err("%s, %d error!mbuf not enough%d\n",
-		       __func__, __LINE__, (tx_count_saved - tx_count));
+			   __func__, __LINE__, (tx_count_saved - tx_count));
 		tx_msg->mbuf_short += (tx_count_saved - tx_count);
 		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
 		return -ENOMEM;
@@ -458,15 +455,15 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 		if (pcie_count > 1) {
 			addr_buffer =
 			sprdwl_set_pcie_addr_to_mbuf(tx_msg,
-						     mbuf_pos, PCIE_TX_NUM);
+							 mbuf_pos, PCIE_TX_NUM);
 		} else {
 			addr_buffer =
 			sprdwl_set_pcie_addr_to_mbuf(tx_msg,
-						     mbuf_pos, tx_count);
+							 mbuf_pos, tx_count);
 		}
 		if (addr_buffer == NULL) {
 			wl_err("%s:%d alloc pcie addr buf fail\n",
-			       __func__, __LINE__);
+				   __func__, __LINE__);
 			return -1;
 		}
 	}
@@ -518,7 +515,7 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 				}
 				if (addr_buffer == NULL) {
 					wl_err("%s:%d alloc pcie addr buf fail\n",
-					       __func__, __LINE__);
+						   __func__, __LINE__);
 					return -1;
 				}
 			}
@@ -528,14 +525,14 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 						msg_pos->tran_data,
 						msg_pos->len, DMA_TO_DEVICE);
 			memcpy(&addr_buffer->pcie_addr[i],
-			       &pcie_addr, SPRDWL_PHYS_LEN);
+				   &pcie_addr, SPRDWL_PHYS_LEN);
 		} else {
 			mbuf_pos->buf = data_ptr;
 			mbuf_pos->len = msg_pos->len;
 			/*TODO, to check msgbuf before list push*/
 			msg_temp = GET_MSG_BUF(mbuf_pos);
 			if (!virt_addr_valid(msg_temp) ||
-			    !virt_addr_valid(msg_temp->skb))
+				!virt_addr_valid(msg_temp->skb))
 				BUG_ON(1);
 		}
 		mbuf_pos = mbuf_pos->next;
@@ -563,12 +560,12 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 					break;
 			}
 			sprdwcn_bus_list_free(dev->tx_data_port, head, tail,
-				       pcie_count);
+					   pcie_count);
 			/*add data list to tx list header if tx fail*/
 			sprdwl_add_tx_list_head(tx_list_head,
 						tx_list, ac_index, tx_count);
 			wl_err("%s:%d Tx pcie addr buf fail\n",
-			       __func__, __LINE__);
+				   __func__, __LINE__);
 		} else {
 #if defined(MORE_DEBUG)
 			UPDATE_TX_PACKETS(dev, tx_count, tx_bytes);
@@ -582,13 +579,13 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 	if (dev->priv->hw_type == SPRDWL_HW_SDIO) {
 		if (coex_bt_on)
 			ret = sprdwcn_bus_push_list(dev->tx_data_port,
-						    head, tail, tx_count);
+							head, tail, tx_count);
 		else
 			ret = sprdwcn_bus_push_list_direct(dev->tx_data_port,
 							   head, tail, tx_count);
 	} else {
 		ret = sprdwcn_bus_push_list(dev->tx_data_port,
-					    head, tail, tx_count);
+						head, tail, tx_count);
 	}
 
 	if (ret != 0) {
@@ -609,7 +606,7 @@ int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
 		if (dev->priv->hw_type == SPRDWL_HW_SDIO) {
 			if (!coex_bt_on)
 				sprdwl_add_topop_list(dev->tx_data_port,
-						      head, tail, tx_count);
+							  head, tail, tx_count);
 		}
 	}
 
@@ -638,7 +635,7 @@ struct sprdwl_peer_entry
 
 /* It is tx private function, just use in sprdwl_intf_fill_msdu_dscr()  */
 unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
-				    struct sprdwl_vif *vif)
+					struct sprdwl_vif *vif)
 {
 	u8 ret;
 	unsigned char i;
@@ -650,10 +647,10 @@ unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
 		 intf->skb_da[0], intf->skb_da[1], intf->skb_da[2],
 		 intf->skb_da[3], intf->skb_da[4], intf->skb_da[5]);
 	if (sprdwl_is_group(intf->skb_da) &&
-	    (vif->mode == SPRDWL_MODE_AP || vif->mode == SPRDWL_MODE_P2P_GO)) {
+		(vif->mode == SPRDWL_MODE_AP || vif->mode == SPRDWL_MODE_P2P_GO)) {
 		for (i = 0; i < MAX_LUT_NUM; i++) {
 			if ((sprdwl_is_group(intf->peer_entry[i].tx.da)) &&
-			    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+				(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
 				wl_info("%s, %d, group lut_index=%d\n",
 					__func__, __LINE__,
 					intf->peer_entry[i].lut_index);
@@ -677,7 +674,7 @@ unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
 	for (i = 0; i < MAX_LUT_NUM; i++) {
 		if ((0 == memcmp(intf->peer_entry[i].tx.da,
 				 intf->skb_da, ETH_ALEN)) &&
-		    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+			(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
 			wl_debug("%s, %d, lut_index=%d\n",
 				 __func__, __LINE__,
 				 intf->peer_entry[i].lut_index);
@@ -687,8 +684,8 @@ unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
 
 	for (i = 0; i < MAX_LUT_NUM; i++) {
 		if ((vif->mode == SPRDWL_MODE_STATION ||
-		     vif->mode == SPRDWL_MODE_P2P_CLIENT) &&
-		    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+			 vif->mode == SPRDWL_MODE_P2P_CLIENT) &&
+			(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
 			wl_debug("%s, %d, lut_index=%d\n",
 				 __func__, __LINE__,
 				 intf->peer_entry[i].lut_index);
@@ -711,16 +708,16 @@ unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
 		break;
 	}
 
-	wl_err("ctx_id = %d, sm_state = %d, bssid =%pM\n",
-			vif->ctx_id, vif->sm_state, intf->skb_da);
+	//wl_err("ctx_id = %d, sm_state = %d, bssid =%pM\n",
+	//		vif->ctx_id, vif->sm_state, intf->skb_da);
 
 	return ret;
 }
 
 int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
-			       struct sk_buff *skb,
+				   struct sk_buff *skb,
 				   u8 type,
-			       u8 offset)
+				   u8 offset)
 {
 	u8 protocol;
 	struct tx_msdu_dscr *dscr;
@@ -753,7 +750,7 @@ int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
 		kfree_skb(temp_skb);
 		if (skb == NULL) {
 			wl_err("%s:%d failed to unshare skbuff: NULL\n",
-			       __func__, __LINE__);
+				   __func__, __LINE__);
 			return -EPERM;
 		}
 #if defined(MORE_DEBUG)
@@ -765,7 +762,7 @@ int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
 
 	lut_index = sprdwl_find_lut_index(dev, vif);
 	if ((lut_index < 6) && (!sprdwl_is_group(dev->skb_da))) {
-		wl_err("%s, %d, sta disconn, no data tx!", __func__, __LINE__);
+		//wl_err("%s, %d, sta disconn, no data tx!", __func__, __LINE__);
 		return -EPERM;
 	}
 	skb_push(skb, sizeof(struct tx_msdu_dscr) + offset + dscr_rsvd);
@@ -885,9 +882,9 @@ int sprdwl_intf_tx_data_fpga_test(struct sprdwl_intf *intf,
 }
 
 int sprdwl_intf_fill_msdu_dscr_test(struct sprdwl_priv *priv,
-				    struct sk_buff *skb,
-				    u8 type,
-				    u8 offset)
+					struct sk_buff *skb,
+					u8 type,
+					u8 offset)
 {
 	struct tx_msdu_dscr *dscr;
 	struct sprdwl_intf *dev;
@@ -904,7 +901,7 @@ int sprdwl_intf_fill_msdu_dscr_test(struct sprdwl_priv *priv,
 		kfree_skb(temp_skb);
 		if (skb == NULL) {
 			wl_err("%s:%d failed to realloc skbuff: NULL\n",
-			       __func__, __LINE__);
+				   __func__, __LINE__);
 			return 0;
 		}
 	}
@@ -1015,7 +1012,7 @@ inline void sprdwl_free_rx_data(struct sprdwl_intf *intf,
 		if (ret) {
 			wl_err("%s: alloc buf fail\n", __func__);
 			sprdwcn_bus_list_free(chn, (struct mbuf_t *)head,
-				       (struct mbuf_t *)tail, num);
+					   (struct mbuf_t *)tail, num);
 			head = NULL;
 			tail = NULL;
 			num = 0;
@@ -1051,6 +1048,20 @@ void sprdwl_count_rx_tp(struct sprdwl_rx_if *rx_if, int num)
 		rx_if->rx_data_num = 0;
 	}
 }
+
+static int check_msdu_early(struct sprdwl_intf *intf, struct mbuf_t *mbuf)
+{
+	struct rx_msdu_desc *msdu_desc =
+		(struct rx_msdu_desc *)(mbuf->buf + intf->hif_offset);
+
+	if (mbuf->len < msdu_desc->msdu_len ||
+		msdu_desc->msdu_len > 1600) {
+		wl_err("%s, %d, %d, %d\n", __func__, __LINE__, mbuf->len, msdu_desc->msdu_len);
+		return -1;
+	}
+	return 0;
+}
+
 static int intf_rx_handle(int chn, struct mbuf_t *head,
 				   struct mbuf_t *tail, int num)
 {
@@ -1074,6 +1085,13 @@ static int intf_rx_handle(int chn, struct mbuf_t *head,
 		for (i = num; i > 0; i--) {
 			sprdwl_sdio_process_credit(intf,
 				(void *)(mbuf->buf + intf->hif_offset));
+			if (intf->priv->hw_type == SPRDWL_HW_USB &&
+				chn == USB_RX_DATA_PORT &&
+				check_msdu_early(intf, mbuf)) {
+				sprdwcn_bus_push_list(chn, head, tail, num);
+				return 0;
+			}
+
 			mbuf = mbuf->next;
 		}
 	}
@@ -1160,9 +1178,9 @@ void sprdwl_handle_pop_list(void *data)
 	list_splice_tail(&tmp_list, &msg_pos->msglist->freelist);
 	spin_unlock_bh(&tx_msg->tx_list_qos_pool.freelock);
 	sprdwcn_bus_list_free(pop->chn,
-			      pop->head,
-			      pop->tail,
-			      pop->num);
+				  pop->head,
+				  pop->tail,
+				  pop->num);
 	mbufpop += pop->num;
 }
 
@@ -1208,12 +1226,13 @@ int sprdwl_tx_data_pop_list(int channel, struct mbuf_t *head, struct mbuf_t *tai
 
 /*free PCIe data when receive txc event from cp*/
 int sprdwl_tx_free_pcie_data(struct sprdwl_intf *dev, unsigned char *data,
-			     unsigned short len)
+				 unsigned short len)
 {
 	int i;
 	struct sprdwl_tx_msg *tx_msg;
 	unsigned char *data_addr_ptr;
-	unsigned long pcie_addr, timeout;
+	uint64_t pcie_addr;
+	unsigned long timeout;
 	unsigned short  data_num;
 	struct list_head *free_list;
 	struct txc_addr_buff *txc_addr;
@@ -1312,13 +1331,13 @@ int sprdwl_tx_cmd_pop_list(int channel, struct mbuf_t *head, struct mbuf_t *tail
 int sprdwl_rx_cmd_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
 {
 	return sprdwl_rx_common_push(chn, head, tail,
-				     num, SPRDWL_MAX_CMD_RXLEN);
+					 num, SPRDWL_MAX_CMD_RXLEN);
 }
 
 int sprdwl_rx_data_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
 {
 	return sprdwl_rx_common_push(chn, head, tail,
-				     num, SPRDWL_MAX_DATA_RXLEN);
+					 num, SPRDWL_MAX_DATA_RXLEN);
 }
 
 /*
@@ -1558,7 +1577,7 @@ void sprdwl_event_sta_lut(struct sprdwl_vif *vif, u8 *data, u16 len)
 		}
 		peer_entry_delba((void *)intf, i);
 		memset(&intf->peer_entry[i], 0x00,
-		       sizeof(struct sprdwl_peer_entry));
+			   sizeof(struct sprdwl_peer_entry));
 		intf->peer_entry[i].ctx_id = 0xFF;
 		intf->tx_num[i] = 0;
 		sprdwl_dis_flush_txlist(intf, i);
@@ -1587,7 +1606,7 @@ void sprdwl_event_sta_lut(struct sprdwl_vif *vif, u8 *data, u16 len)
 }
 
 void sprdwl_tx_ba_mgmt(struct sprdwl_priv *priv, void *data, int len,
-		       unsigned char cmd_id, unsigned char ctx_id)
+			   unsigned char cmd_id, unsigned char ctx_id)
 {
 	struct sprdwl_msg_buf *msg;
 	unsigned char *data_ptr;
@@ -1626,12 +1645,12 @@ void sprdwl_tx_ba_mgmt(struct sprdwl_priv *priv, void *data, int len,
 		tid = addba->addba_param.tid;
 		if (!test_and_clear_bit(tid, &peer_entry->ba_tx_done_map))
 			goto out;
-		wl_err("%s, %d, tx_addba failed, reason=%d, lut_index=%d, tid=%d, map=%lu\n",
-		       __func__, __LINE__,
-		       rbuf[0],
-		       addba->lut_index,
-		       tid,
-		       peer_entry->ba_tx_done_map);
+		//wl_err("%s, %d, tx_addba failed, reason=%d, lut_index=%d, tid=%d, map=%lu\n",
+		//	   __func__, __LINE__,
+		//	   rbuf[0],
+		//	   addba->lut_index,
+		//	   tid,
+		//	   peer_entry->ba_tx_done_map);
 	}
 out:
 	kfree(rbuf);
@@ -1657,7 +1676,7 @@ void sprdwl_tx_send_delba(struct sprdwl_vif *vif, void *data, int len)
 }
 
 void sprdwl_tx_addba(struct sprdwl_intf *intf,
-		     struct sprdwl_peer_entry *peer_entry, unsigned char tid)
+			 struct sprdwl_peer_entry *peer_entry, unsigned char tid)
 {
 #define WIN_SIZE 64
 	struct host_addba_param addba;
@@ -1692,7 +1711,7 @@ void sprdwl_tx_addba(struct sprdwl_intf *intf,
 }
 
 void sprdwl_tx_delba(struct sprdwl_intf *intf,
-		     struct sprdwl_peer_entry *peer_entry,  unsigned int ac_index)
+			 struct sprdwl_peer_entry *peer_entry,  unsigned int ac_index)
 {
 	struct host_delba_param delba[SPRDWL_AC_MAX];
 	struct sprdwl_work *misc_work;
@@ -1721,7 +1740,7 @@ void sprdwl_tx_delba(struct sprdwl_intf *intf,
 	misc_work->vif = vif;
 	misc_work->id = SPRDWL_WORK_DELBA;
 	memcpy(misc_work->data, delba,
-	       sizeof(struct host_delba_param) * SPRDWL_AC_MAX);
+		   sizeof(struct host_delba_param) * SPRDWL_AC_MAX);
 	peer_entry->ht_enable = 0;
 	peer_entry->ba_tx_done_map = 0;
 
@@ -1731,17 +1750,26 @@ void sprdwl_tx_delba(struct sprdwl_intf *intf,
 
 int sprdwl_notifier_boost(struct notifier_block *nb, unsigned long event, void *data)
 {
+#if KERNEL_VERSION(5, 4, 19) <= LINUX_VERSION_CODE
 	struct cpufreq_policy_data *policy = data;
+#else
+	struct cpufreq_policy *policy = data;
+#endif
 	unsigned long min_freq;
 	unsigned long max_freq = policy->cpuinfo.max_freq;
 	struct sprdwl_intf *intf = get_intf();
 	u8 boost;
+
 	if (NULL == intf)
 		return NOTIFY_DONE;
 
 	boost = intf->boost;
 
+#if KERNEL_VERSION(5, 4, 0) <= LINUX_VERSION_CODE
+	if (event != CPUFREQ_CREATE_POLICY)
+#else
 	if (event != CPUFREQ_ADJUST)
+#endif
 		return NOTIFY_DONE;
 
 	min_freq = boost ? 1200000 : 400000;
@@ -1818,7 +1846,7 @@ void adjust_rxnum_level(char *buf, unsigned char offset)
 #undef MAX_LEN
 }
 
-int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf)
+int sprdwl_bus_init(struct sprdwl_priv *priv)
 {
 	int ret = -EINVAL, chn = 0;
 
@@ -1845,44 +1873,58 @@ int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf)
 			if (ret < 0)
 				goto err;
 		}
-
-		g_intf_ops.intf = (void *)intf;
-		/* TODO: Need we reserve g_intf_ops? */
-		intf->hw_intf = (void *)&g_intf_ops;
-
-		priv->hw_priv = intf;
-		priv->hw_offset = intf->hif_offset;
-		intf->priv = priv;
-		intf->fw_awake = 1;
-		intf->fw_power_down = 0;
-		intf->txnum_level = BOOST_TXNUM_LEVEL;
-		intf->rxnum_level = BOOST_RXNUM_LEVEL;
-		intf->boost = 0;
-#ifdef UNISOC_WIFI_PS
-		init_completion(&intf->suspend_completed);
-#endif
-	} else {
+		return 0;
+	}
 err:
-		wl_err("%s: unregister %d ops\n",
-		       __func__, g_intf_ops.max_num);
+	wl_err("%s: unregister %d ops\n",
+			 __func__, g_intf_ops.max_num);
 
-		for (; chn > 0; chn--)
-			sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
+	for (; chn > 0; chn--)
+		sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
 
-		g_intf_ops.hif_ops = NULL;
-		g_intf_ops.max_num = 0;
-	}
+	g_intf_ops.hif_ops = NULL;
+	g_intf_ops.max_num = 0;
 
 	return ret;
 }
 
-void sprdwl_intf_deinit(struct sprdwl_intf *dev)
+void sprdwl_bus_deinit(void)
 {
 	int chn = 0;
 
 	for (chn = 0; chn < g_intf_ops.max_num; chn++)
 		sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
+}
+
+int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf)
+{
+	int ret = -EINVAL;
 
+	ret = sprdwl_bus_init(priv);
+	if (ret < 0)
+		return ret;
+
+	g_intf_ops.intf = (void *)intf;
+	/* TODO: Need we reserve g_intf_ops? */
+	intf->hw_intf = (void *)&g_intf_ops;
+
+	priv->hw_priv = intf;
+	priv->hw_offset = intf->hif_offset;
+	intf->priv = priv;
+	intf->fw_awake = 1;
+	intf->fw_power_down = 0;
+	intf->txnum_level = BOOST_TXNUM_LEVEL;
+	intf->rxnum_level = BOOST_RXNUM_LEVEL;
+	intf->boost = 0;
+#ifdef UNISOC_WIFI_PS
+	init_completion(&intf->suspend_completed);
+#endif
+
+	return ret;
+}
+
+void sprdwl_intf_deinit(struct sprdwl_intf *dev)
+{
 	g_intf_ops.intf = NULL;
 	g_intf_ops.max_num = 0;
 	dev->hw_intf = NULL;
@@ -1894,8 +1936,8 @@ int sprdwl_dis_flush_txlist(struct sprdwl_intf *intf, u8 lut_index)
 	int i, j;
 
 	if (lut_index <= 5) {
-		wl_err("err lut_index:%d, %s, %d\n",
-				lut_index, __func__, __LINE__);
+		//wl_err("err lut_index:%d, %s, %d\n",
+		//		lut_index, __func__, __LINE__);
 		return -1;
 	}
 	wl_debug("disconnect, flush qoslist, %s, %d\n", __func__, __LINE__);
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
index e55a35a66b63..b159c685a5e0 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
@@ -299,4 +299,5 @@ void sprdwl_boost(void);
 void sprdwl_unboost(void);
 void adjust_txnum_level(char *buf, unsigned char offset);
 void adjust_rxnum_level(char *buf, unsigned char offset);
+void sprdwl_bus_deinit(void);
 #endif /* __SPRDWL_INTF_SDIO_SC2355_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/work.c b/drivers/net/wireless/uwe5622/unisocwifi/work.c
index b7c0c8bbbf99..4d7e016ea686 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/work.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/work.c
@@ -44,7 +44,7 @@ static struct sprdwl_work *sprdwl_get_work(struct sprdwl_priv *priv)
 	spin_lock_bh(&priv->work_lock);
 	if (!list_empty(&priv->work_list)) {
 		sprdwl_work = list_first_entry(&priv->work_list,
-					       struct sprdwl_work, list);
+						   struct sprdwl_work, list);
 		list_del(&sprdwl_work->list);
 	}
 	spin_unlock_bh(&priv->work_lock);
@@ -76,21 +76,21 @@ static void sprdwl_do_work(struct work_struct *work)
 		case SPRDWL_WORK_REG_MGMT:
 			reg_mgmt = (struct sprdwl_reg_mgmt *)sprdwl_work->data;
 			sprdwl_register_frame(priv, vif->ctx_id,
-					      reg_mgmt->type,
-					      reg_mgmt->reg ? 1 : 0);
+						  reg_mgmt->type,
+						  reg_mgmt->reg ? 1 : 0);
 			break;
 		case SPRDWL_WORK_DEAUTH:
 		case SPRDWL_WORK_DISASSOC:
 			cfg80211_rx_unprot_mlme_mgmt(vif->ndev,
-						     sprdwl_work->data,
-						     sprdwl_work->len);
+							 sprdwl_work->data,
+							 sprdwl_work->len);
 			break;
 		case SPRDWL_WORK_MC_FILTER:
 			if (vif->mc_filter->mc_change)
 				sprdwl_set_mc_filter(priv, vif->ctx_id,
-						     vif->mc_filter->subtype,
-						     vif->mc_filter->mac_num,
-						     vif->mc_filter->mac_addr);
+							 vif->mc_filter->subtype,
+							 vif->mc_filter->mac_num,
+							 vif->mc_filter->mac_addr);
 			break;
 		case SPRDWL_WORK_NOTIFY_IP:
 			sprdwl_notify_ip(priv, vif->ctx_id, SPRDWL_IPV6,
@@ -99,10 +99,10 @@ static void sprdwl_do_work(struct work_struct *work)
 		case SPRDWL_WORK_BA_MGMT:
 			ba_data = (struct sprdwl_ba_event_data *)sprdwl_work->data;
 			sprdwl_send_ba_mgmt(priv, vif->ctx_id,
-					    &ba_data->addba_rsp,
-					    sizeof(ba_data->addba_rsp));
+						&ba_data->addba_rsp,
+						sizeof(ba_data->addba_rsp));
 			sprdwl_active_ba_node(ba_data->ba_entry, ba_data->sta_lut_index,
-					      ba_data->addba_rsp.tid);
+						  ba_data->addba_rsp.tid);
 			break;
 		case SPRDWL_WORK_ADDBA:
 			sprdwl_tx_send_addba(vif, sprdwl_work->data,
@@ -148,8 +148,8 @@ static void sprdwl_do_work(struct work_struct *work)
 			break;
 		case SPRDWL_WORK_VOWIFI_DATA_PROTECTION:
 			sprdwl_send_vowifi_data_prot(vif->priv, vif->ctx_id,
-						     sprdwl_work->data,
-						     sprdwl_work->len);
+							 sprdwl_work->data,
+							 sprdwl_work->len);
 			break;
 		default:
 			wl_ndev_log(L_DBG, vif->ndev, "Unknown delayed work: %d\n",
@@ -162,7 +162,7 @@ static void sprdwl_do_work(struct work_struct *work)
 }
 
 void sprdwl_queue_work(struct sprdwl_priv *priv,
-		       struct sprdwl_work *sprdwl_work)
+			   struct sprdwl_work *sprdwl_work)
 {
 	spin_lock_bh(&priv->work_lock);
 	list_add_tail(&sprdwl_work->list, &priv->work_list);
-- 
2.34.1

