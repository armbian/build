From 8515a2e8cc76827b4cc35636456db9eb50b599ca Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Sat, 24 Feb 2024 07:29:05 -0500
Subject: [PATCH] bananapi: sunxi h618: v2021.07

https://github.com/BPI-SINOVOIP/pi-u-boot/commits/v2021.07-sunxi/

Signed-off-by: Banana Pi -BPI <lionwang@sinovoip.com.cn>
Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 arch/arm/Kconfig                              |   2 +
 arch/arm/include/asm/arch-sunxi/boot0.h       |  21 +-
 arch/arm/include/asm/arch-sunxi/clock_sun6i.h |   1 +
 .../include/asm/arch-sunxi/dram_sun50i_h616.h |   6 +-
 arch/arm/mach-sunxi/Kconfig                   |  71 ++-
 arch/arm/mach-sunxi/board.c                   |  17 +-
 arch/arm/mach-sunxi/clock_sun6i.c             |  15 +-
 arch/arm/mach-sunxi/dram_sun50i_h616.c        | 522 ++++++++++++++----
 arch/arm/mach-sunxi/dram_timings/Makefile     |   5 +-
 .../arm/mach-sunxi/dram_timings/h616_lpddr3.c |  95 ++++
 .../arm/mach-sunxi/dram_timings/h616_lpddr4.c |  97 ++++
 arch/arm/mach-sunxi/pmic_bus.c                |   7 +
 arch/arm/mach-sunxi/spl_spi_sunxi.c           |  38 +-
 board/sunxi/board.c                           | 119 +++-
 cmd/Kconfig                                   |   1 +
 cmd/fdt.c                                     |   6 +-
 common/Kconfig.boot                           |   3 +-
 drivers/mtd/spi/spi-nor-ids.c                 |   2 +
 drivers/power/Kconfig                         |  14 +-
 drivers/power/Makefile                        |   1 +
 drivers/power/axp313a.c                       |  86 +++
 drivers/spi/Kconfig                           |   5 +
 drivers/spi/Makefile                          |   1 +
 drivers/spi/sun4i_spi.c                       | 456 +++++++++++++++
 drivers/video/bridge/anx6345.c                |  92 ++-
 dts/Kconfig                                   |   6 +
 include/axp313a.h                             |  17 +
 include/axp_pmic.h                            |   3 +
 include/config_distro_bootcmd.h               |   9 +
 include/configs/sun8i.h                       |   2 +
 include/configs/sunxi-common.h                |  15 +
 lib/efi_loader/efi_var_seed.S                 |  17 -
 32 files changed, 1559 insertions(+), 193 deletions(-)
 create mode 100644 arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c
 create mode 100644 arch/arm/mach-sunxi/dram_timings/h616_lpddr4.c
 create mode 100644 drivers/power/axp313a.c
 create mode 100644 drivers/spi/sun4i_spi.c
 create mode 100644 include/axp313a.h
 delete mode 100644 lib/efi_loader/efi_var_seed.S

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 0448787b8b..ecae081180 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1012,6 +1012,8 @@ config ARCH_SUNXI
 	select USB_KEYBOARD if DISTRO_DEFAULTS
 	select USB_STORAGE if DISTRO_DEFAULTS
 	select SPL_USE_TINY_PRINTF
+	imply AUTOBOOT_KEYED
+	imply AUTOBOOT_KEYED_CTRLC 
 	select USE_PREBOOT
 	select SYS_RELOC_GD_ENV_ADDR
 	imply BOARD_LATE_INIT
diff --git a/arch/arm/include/asm/arch-sunxi/boot0.h b/arch/arm/include/asm/arch-sunxi/boot0.h
index e8e8e38f05..8fb8083454 100644
--- a/arch/arm/include/asm/arch-sunxi/boot0.h
+++ b/arch/arm/include/asm/arch-sunxi/boot0.h
@@ -16,8 +16,8 @@
 	b       reset
 	.space  0x7c
 
-	.word	0xe28f0058	// add     r0, pc, #88
-	.word	0xe59f1054	// ldr     r1, [pc, #84]
+	.word	0xe28f0070	// add     r0, pc, #112	 // @(fel_stash - .)
+	.word	0xe59f106c	// ldr     r1, [pc, #108] // fel_stash - .
 	.word	0xe0800001	// add     r0, r0, r1
 	.word	0xe580d000	// str     sp, [r0]
 	.word	0xe580e004	// str     lr, [r0, #4]
@@ -28,8 +28,12 @@
 	.word	0xee1cef10	// mrc     15, 0, lr, cr12, cr0, {0}
 	.word	0xe580e010	// str     lr, [r0, #16]
 
-	.word	0xe59f1024	// ldr     r1, [pc, #36] ; 0x170000a0
-	.word	0xe59f0024	// ldr     r0, [pc, #36] ; CONFIG_*_TEXT_BASE
+	.word	0xe59f1034	// ldr     r1, [pc, #52] ; RVBAR_ADDRESS
+	.word	0xe59f0034	// ldr     r0, [pc, #52] ; SUNXI_SRAMC_BASE
+	.word	0xe5900024	// ldr     r0, [r0, #36] ; SRAM_VER_REG
+	.word	0xe21000ff	// ands    r0, r0, #255    ; 0xff
+	.word	0x159f102c	// ldrne   r1, [pc, #44] ; RVBAR_ALTERNATIVE
+	.word	0xe59f002c	// ldr     r0, [pc, #44] ; CONFIG_*TEXT_BASE
 	.word	0xe5810000	// str     r0, [r1]
 	.word	0xf57ff04f	// dsb     sy
 	.word	0xf57ff06f	// isb     sy
@@ -39,11 +43,10 @@
 	.word	0xf57ff06f	// isb     sy
 	.word	0xe320f003	// wfi
 	.word	0xeafffffd	// b       @wfi
-#ifndef CONFIG_SUN50I_GEN_H6
-	.word	0x017000a0	// writeable RVBAR mapping address
-#else
-	.word	0x09010040	// writeable RVBAR mapping address
-#endif
+
+	.word	CONFIG_SUNXI_RVBAR_ADDRESS	// writable RVBAR mapping addr
+	.word	SUNXI_SRAMC_BASE
+	.word	CONFIG_SUNXI_RVBAR_ALTERNATIVE	// address for die variant
 #ifdef CONFIG_SPL_BUILD
 	.word	CONFIG_SPL_TEXT_BASE
 #else
diff --git a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
index ee387127f3..296f9d11bc 100644
--- a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
+++ b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
@@ -208,6 +208,7 @@ struct sunxi_ccm_reg {
 #define CCM_PLL1_CTRL_N(n)		((((n) - 1) & 0x1f) << 8)
 #define CCM_PLL1_CTRL_P(n)		(((n) & 0x3) << 16)
 #define CCM_PLL1_CTRL_EN		(0x1 << 31)
+#define CCM_PLL1_CTRL_LOCK		(0x1 << 28)
 
 #define CCM_PLL3_CTRL_M_SHIFT		0
 #define CCM_PLL3_CTRL_M_MASK		(0xf << CCM_PLL3_CTRL_M_SHIFT)
diff --git a/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h b/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
index 134679d552..bd3f1b432b 100644
--- a/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
+++ b/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
@@ -36,7 +36,9 @@ struct sunxi_mctl_com_reg {
 	u32 maer0;		/* 0x020 master enable register 0 */
 	u32 maer1;		/* 0x024 master enable register 1 */
 	u32 maer2;		/* 0x028 master enable register 2 */
-	u8 reserved_0x02c[468];	/* 0x02c */
+	u8 reserved_0x02c[36];	/* 0x02c */
+	u32 unk_0x050;		/* 0x050 */
+	u8 reserved_0x054[428];	/* 0x054 */
 	u32 bwcr;		/* 0x200 bandwidth control register */
 	u8 reserved_0x204[12];	/* 0x204 */
 	/*
@@ -130,6 +132,7 @@ check_member(sunxi_mctl_ctl_reg, unk_0x4240, 0x4240);
 #define MSTR_DEVICETYPE_LPDDR2	BIT(2)
 #define MSTR_DEVICETYPE_LPDDR3	BIT(3)
 #define MSTR_DEVICETYPE_DDR4	BIT(4)
+#define MSTR_DEVICETYPE_LPDDR4	BIT(5)
 #define MSTR_DEVICETYPE_MASK	GENMASK(5, 0)
 #define MSTR_2TMODE		BIT(10)
 #define MSTR_BUSWIDTH_FULL	(0 << 12)
@@ -144,6 +147,7 @@ struct dram_para {
 	u8 rows;
 	u8 ranks;
 	u8 bus_full_width;
+	bool size_fix;
 };
 
 
diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index bc8509b72a..060d71b177 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -86,6 +86,36 @@ config DRAM_SUN50I_H616_UNKNOWN_FEATURE
 	---help---
 	  Select this when DRAM on your H616 board needs this unknown
 	  feature.
+
+config DRAM_SUN50I_H616_TRIM_SIZE
+	bool "H616 DRAM trim size"
+	help
+	  Due to unknown issue, some H616 based boards may need to trim
+	  size a bit.
+
+choice
+	prompt "H616 DRAM Type and Timing"
+	default SUNXI_DRAM_H616_DDR3_1333
+
+config SUNXI_DRAM_H616_DDR3_1333
+	bool "DDR3-1333 timings on the H616 DRAM controller"
+	help
+	  This option is the DDR3-1333 timing used by the stock boot0
+	  by Allwinner.
+
+config SUNXI_DRAM_H616_LPDDR3
+	bool "LPDDR3 timings on the H616 DRAM controller"
+	help
+	  This option is the LPDDR3 timing used by the stock boot0 by
+	  Allwinner.
+
+config SUNXI_DRAM_H616_LPDDR4
+	bool "LPDDR4 timings on the H616 DRAM controller"
+	help
+	  This option is the LPDDR4 timing used by the stock boot0 by
+	  Allwinner.
+
+endchoice
 endif
 
 config SUN6I_P2WI
@@ -130,6 +160,32 @@ config SUNXI_SRAM_ADDRESS
 	Some newer SoCs map the boot ROM at address 0 instead and move the
 	SRAM to a different address.
 
+config SUNXI_RVBAR_ADDRESS
+	hex
+	depends on ARM64
+	default 0x09010040 if SUN50I_GEN_H6
+	default 0x017000a0
+	---help---
+	The read-only RVBAR system register holds the address of the first
+	instruction to execute after a reset. Allwinner cores provide a
+	writable MMIO backing store for this register, to allow to set the
+	entry point when switching to AArch64. This store is on different
+	addresses, depending on the SoC.
+
+config SUNXI_RVBAR_ALTERNATIVE
+	hex
+	depends on ARM64
+	default 0x08100040 if MACH_SUN50I_H616
+	default SUNXI_RVBAR_ADDRESS
+	---help---
+	The H616 die exists in at least two variants, with one having the
+	RVBAR registers at a different address. If the SoC variant ID
+	(stored in SRAM_VER_REG[7:0]) is not 0, we need to use the
+	other address.
+	Set this alternative address to the same as the normal address
+	for all other SoCs, so the content of the SRAM_VER_REG becomes
+	irrelevant there, and we can use the same code.
+
 config SUNXI_A64_TIMER_ERRATUM
 	bool
 
@@ -190,10 +246,10 @@ config MACH_SUNXI_H3_H5
 	select SUPPORT_SPL
 
 # TODO: try out A80's 8GiB DRAM space
-# TODO: H616 supports 4 GiB DRAM space
 config SUNXI_DRAM_MAX_SIZE
 	hex
-	default 0xC0000000 if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN50I_H6 || MACH_SUN50I_H616
+	default 0x100000000 if MACH_SUN50I_H616
+	default 0xC0000000 if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN50I_H6
 	default 0x80000000
 
 choice
@@ -469,7 +525,7 @@ config DRAM_CLK
 	default 312 if MACH_SUN6I || MACH_SUN8I
 	default 360 if MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || \
 		       MACH_SUN8I_V3S
-	default 672 if MACH_SUN50I
+	default 648 if MACH_SUN50I || MACH_SUN50I_H5
 	default 744 if MACH_SUN50I_H6
 	default 720 if MACH_SUN50I_H616
 	---help---
@@ -642,6 +698,13 @@ config MACPWR
 	  Set the pin used to power the MAC. This takes a string in the format
 	  understood by sunxi_name_to_gpio, e.g. PH1 for pin 1 of port H.
 
+config PWRLED
+        string "Power led pin"
+        default ""
+        help
+          Set the pin used to power the led. This takes a string in the format
+          understood by sunxi_name_to_gpio, e.g. PC12 for pin 1 of port H.
+
 config MMC0_CD_PIN
 	string "Card detect pin for mmc0"
 	default "PF6" if MACH_SUN8I_A83T || MACH_SUNXI_H3_H5 || MACH_SUN50I
@@ -1054,7 +1117,7 @@ config SPL_STACK_R_ADDR
 
 config SPL_SPI_SUNXI
 	bool "Support for SPI Flash on Allwinner SoCs in SPL"
-	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNXI_H3_H5 || MACH_SUN50I || MACH_SUN8I_R40 || MACH_SUN50I_H6
+	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNXI_H3_H5 || MACH_SUN50I || MACH_SUN8I_R40 || SUN50I_GEN_H6
 	help
 	  Enable support for SPI Flash. This option allows SPL to read from
 	  sunxi SPI Flash. It uses the same method as the boot ROM, so does
diff --git a/arch/arm/mach-sunxi/board.c b/arch/arm/mach-sunxi/board.c
index 9b84132eda..0537c29b22 100644
--- a/arch/arm/mach-sunxi/board.c
+++ b/arch/arm/mach-sunxi/board.c
@@ -27,6 +27,7 @@
 #include <asm/arch/timer.h>
 #include <asm/arch/tzpc.h>
 #include <asm/arch/mmc.h>
+#include <asm/arch/prcm.h>
 
 #include <linux/compiler.h>
 
@@ -56,7 +57,7 @@ static struct mm_region sunxi_mem_map[] = {
 		/* RAM */
 		.virt = 0x40000000UL,
 		.phys = 0x40000000UL,
-		.size = 0xC0000000UL,
+		.size = CONFIG_SUNXI_DRAM_MAX_SIZE,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_INNER_SHARE
 	}, {
@@ -65,10 +66,24 @@ static struct mm_region sunxi_mem_map[] = {
 	}
 };
 struct mm_region *mem_map = sunxi_mem_map;
+
+ulong board_get_usable_ram_top(ulong total_size)
+{
+	/* Some devices (like the EMAC) have a 32-bit DMA limit. */
+	if (gd->ram_top > (1ULL << 32))
+		return 1ULL << 32;
+
+	return gd->ram_top;
+}
 #endif
 
 static int gpio_init(void)
 {
+#if defined(CONFIG_MACH_SUNXI_H3_H5)
+	/* enable R_PIO GPIO access */
+	prcm_apb0_enable(PRCM_APB0_GATE_PIO);
+#endif
+
 	__maybe_unused uint val;
 #if CONFIG_CONS_INDEX == 1 && defined(CONFIG_UART0_PORT_F)
 #if defined(CONFIG_MACH_SUN4I) || \
diff --git a/arch/arm/mach-sunxi/clock_sun6i.c b/arch/arm/mach-sunxi/clock_sun6i.c
index 8e84062bd7..1b9afd574b 100644
--- a/arch/arm/mach-sunxi/clock_sun6i.c
+++ b/arch/arm/mach-sunxi/clock_sun6i.c
@@ -117,11 +117,10 @@ void clock_set_pll1(unsigned int clk)
 	int k = 1;
 	int m = 1;
 
-	if (clk > 1152000000) {
-		k = 2;
-	} else if (clk > 768000000) {
+	if (clk >= 1368000000) {
 		k = 4;
-		m = 2;
+	} else if (clk >= 768000000) {
+		k = 2;
 	}
 
 	/* Switch to 24MHz clock while changing PLL1 */
@@ -137,11 +136,13 @@ void clock_set_pll1(unsigned int clk)
 	writel(CCM_PLL1_CTRL_EN | CCM_PLL1_CTRL_P(p) |
 	       CCM_PLL1_CTRL_N(clk / (24000000 * k / m)) |
 	       CCM_PLL1_CTRL_K(k) | CCM_PLL1_CTRL_M(m), &ccm->pll1_cfg);
-	sdelay(200);
+
+	while (!(readl(&ccm->pll1_cfg) & CCM_PLL1_CTRL_LOCK))
+		;
 
 	/* Switch CPU to PLL1 */
-	writel(AXI_DIV_3 << AXI_DIV_SHIFT |
-	       ATB_DIV_2 << ATB_DIV_SHIFT |
+	writel(AXI_DIV_4 << AXI_DIV_SHIFT |
+	       ATB_DIV_4 << ATB_DIV_SHIFT |
 	       CPU_CLK_SRC_PLL1 << CPU_CLK_SRC_SHIFT,
 	       &ccm->cpu_axi_cfg);
 }
diff --git a/arch/arm/mach-sunxi/dram_sun50i_h616.c b/arch/arm/mach-sunxi/dram_sun50i_h616.c
index ef5876971c..205c78bb67 100644
--- a/arch/arm/mach-sunxi/dram_sun50i_h616.c
+++ b/arch/arm/mach-sunxi/dram_sun50i_h616.c
@@ -6,8 +6,6 @@
  * unknown. That's why this driver has plenty of magic numbers. Some
  * meaning was nevertheless deduced from strings found in boot0 and
  * known meaning of some dram parameters.
- * This driver only supports DDR3 memory and omits logic for all
- * other supported types supported by hardware.
  *
  * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
  *
@@ -233,37 +231,79 @@ static const u8 phy_init[] = {
 	0x09, 0x05, 0x18
 };
 
-static void mctl_phy_configure_odt(void)
+static const u8 phy_init_lpddr3[] = {
+	0x18, 0x06, 0x00, 0x05, 0x04, 0x03, 0x09, 0x02,
+	0x08, 0x01, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x07,
+	0x17, 0x19, 0x1a
+};
+
+static const u8 phy_init_lpddr4[] = {
+	0x02, 0x00, 0x17, 0x05, 0x04, 0x19, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x01,
+	0x18, 0x03, 0x1a
+};
+
+static void mctl_phy_configure_odt(struct dram_para *para)
 {
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x388);
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x38c);
+	unsigned int val;
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0xd;
+	else
+		val = 0xe;
 
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x3c8);
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x3cc);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x388);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3c8);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x408);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x448);
 
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x408);
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x40c);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0xd;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x4;
+	else
+		val = 0xe;
 
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x448);
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x44c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x38c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3cc);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x40c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x44c);
 
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x340);
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x344);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0xd;
+	else
+		val = 0xe;
 
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x348);
-	writel_relaxed(0xe, SUNXI_DRAM_PHY0_BASE + 0x34c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x340);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x344);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x348);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x34c);
 
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x380);
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x384);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x7;
+	else
+		val = 0x8;
 
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x3c0);
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x3c4);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x380);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3c0);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x400);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x440);
 
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x400);
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x404);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x6;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x0;
+	else
+		val = 0x8;
 
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x440);
-	writel_relaxed(0x8, SUNXI_DRAM_PHY0_BASE + 0x444);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x384);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3c4);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x404);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x444);
 
 	dmb();
 }
@@ -360,7 +400,7 @@ static bool mctl_phy_read_calibration(struct dram_para *para)
 			}
 		}
 
-		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
 	}
 
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30);
@@ -388,6 +428,11 @@ static bool mctl_phy_read_training(struct dram_para *para)
 	bool result = true;
 	int i;
 
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4) {
+		writel(0, SUNXI_DRAM_PHY0_BASE + 0x800);
+		writel(0, SUNXI_DRAM_PHY0_BASE + 0x81c);
+	}
+
 	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 3, 2);
 	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x804, 0x3f, 0xf);
 	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x808, 0x3f, 0xf);
@@ -561,56 +606,118 @@ static bool mctl_phy_write_training(struct dram_para *para)
 
 static bool mctl_phy_bit_delay_compensation(struct dram_para *para)
 {
-	u32 *ptr;
+	u32 *ptr, val;
 	int i;
 
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x60, 1);
 	setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 8);
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x10);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x4, 0x80);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0a;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x23;
+	else
+		val = 0x16;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x484);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x16, ptr);
-		writel_relaxed(0x16, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x4d0);
-	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x590);
-	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x4cc);
-	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x58c);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x10;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x14;
+	else
+		val = 0x1c;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x4d0);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x590);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x4cc);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x58c);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0a;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x23;
+	else
+		val = 0x1a;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x4d8);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x1a, ptr);
-		writel_relaxed(0x1a, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x524);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x5e4);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x520);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x5e0);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x10;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x14;
+	else
+		val = 0x1e;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x524);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5e4);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x520);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5e0);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0d;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x24;
+	else
+		val = 0x1a;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x604);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x1a, ptr);
-		writel_relaxed(0x1a, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x650);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x710);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x64c);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x70c);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x12;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x14;
+	else
+		val = 0x1e;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x650);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x710);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x64c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x70c);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0d;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x24;
+	else
+		val = 0x1a;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x658);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x1a, ptr);
-		writel_relaxed(0x1a, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x6a4);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x764);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x6a0);
-	writel_relaxed(0x1e, SUNXI_DRAM_PHY0_BASE + 0x760);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x12;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x14;
+	else
+		val = 0x1a;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x6a4);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x764);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x6a0);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x760);
 
 	dmb();
 
@@ -620,45 +727,98 @@ static bool mctl_phy_bit_delay_compensation(struct dram_para *para)
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x54, 0x80);
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 4);
 
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0a;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x0e;
+	else
+		val = 0x10;
+
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x480);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x10, ptr);
-		writel_relaxed(0x10, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x18, SUNXI_DRAM_PHY0_BASE + 0x528);
-	writel_relaxed(0x18, SUNXI_DRAM_PHY0_BASE + 0x5e8);
-	writel_relaxed(0x18, SUNXI_DRAM_PHY0_BASE + 0x4c8);
-	writel_relaxed(0x18, SUNXI_DRAM_PHY0_BASE + 0x588);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x1c;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x1c;
+	else
+		val = 0x18;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x528);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5e8);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x4c8);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x588);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0b;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x0e;
+	else
+		val = 0x12;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x4d4);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x12, ptr);
-		writel_relaxed(0x12, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x52c);
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x5ec);
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x51c);
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x5dc);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x1c;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x1c;
+	else
+		val = 0x1a;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x52c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5ec);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x51c);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5dc);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0e;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x0e;
+	else
+		val = 0x12;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x600);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x12, ptr);
-		writel_relaxed(0x12, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x6a8);
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x768);
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x648);
-	writel_relaxed(0x1a, SUNXI_DRAM_PHY0_BASE + 0x708);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x1c;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x1c;
+	else
+		val = 0x1a;
+
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x6a8);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x768);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x648);
+	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x708);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0x0d;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x0e;
+	else
+		val = 0x14;
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x654);
 	for (i = 0; i < 9; i++) {
-		writel_relaxed(0x14, ptr);
-		writel_relaxed(0x14, ptr + 0x30);
+		writel_relaxed(val, ptr);
+		writel_relaxed(val, ptr + 0x30);
 		ptr += 2;
 	}
+
 	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x6ac);
 	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x76c);
 	writel_relaxed(0x1c, SUNXI_DRAM_PHY0_BASE + 0x69c);
@@ -677,38 +837,60 @@ static bool mctl_phy_init(struct dram_para *para)
 			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
 	struct sunxi_mctl_ctl_reg * const mctl_ctl =
 			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
-	u32 val, *ptr;
+	u32 val, *ptr, pat1, pat2;
 	int i;
 
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x4, 0x80);
+
 	if (para->bus_full_width)
 		val = 0xf;
 	else
 		val = 3;
 	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x3c, 0xf, val);
 
-	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x14);
-	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x35c);
-	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x368);
-	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x374);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
+		pat1 = 0xe;
+		pat2 = 0x8;
+	} else if (para->type == SUNXI_DRAM_TYPE_LPDDR4) {
+		pat1 = 0x14;
+		pat2 = 0xa;
+	} else {
+		pat1 = 0xd;
+		pat2 = 0x9;
+	}
+
+	writel(pat1, SUNXI_DRAM_PHY0_BASE + 0x14);
+	writel(pat1, SUNXI_DRAM_PHY0_BASE + 0x35c);
+	writel(pat1, SUNXI_DRAM_PHY0_BASE + 0x368);
+	writel(pat1, SUNXI_DRAM_PHY0_BASE + 0x374);
 
 	writel(0, SUNXI_DRAM_PHY0_BASE + 0x18);
 	writel(0, SUNXI_DRAM_PHY0_BASE + 0x360);
 	writel(0, SUNXI_DRAM_PHY0_BASE + 0x36c);
 	writel(0, SUNXI_DRAM_PHY0_BASE + 0x378);
 
-	writel(9, SUNXI_DRAM_PHY0_BASE + 0x1c);
-	writel(9, SUNXI_DRAM_PHY0_BASE + 0x364);
-	writel(9, SUNXI_DRAM_PHY0_BASE + 0x370);
-	writel(9, SUNXI_DRAM_PHY0_BASE + 0x37c);
+	writel(pat2, SUNXI_DRAM_PHY0_BASE + 0x1c);
+	writel(pat2, SUNXI_DRAM_PHY0_BASE + 0x364);
+	writel(pat2, SUNXI_DRAM_PHY0_BASE + 0x370);
+	writel(pat2, SUNXI_DRAM_PHY0_BASE + 0x37c);
 
 	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xc0);
-	for (i = 0; i < ARRAY_SIZE(phy_init); i++)
-		writel(phy_init[i], &ptr[i]);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		for (i = 0; i < ARRAY_SIZE(phy_init_lpddr3); i++)
+			writel(phy_init_lpddr3[i], &ptr[i]);
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		for (i = 0; i < ARRAY_SIZE(phy_init_lpddr4); i++)
+			writel(phy_init_lpddr4[i], &ptr[i]);
+	else
+		for (i = 0; i < ARRAY_SIZE(phy_init); i++)
+			writel(phy_init[i], &ptr[i]);
 
-	if (IS_ENABLED(CONFIG_DRAM_SUN50I_H616_UNKNOWN_FEATURE)) {
+	if (IS_ENABLED(CONFIG_DRAM_SUN50I_H616_UNKNOWN_FEATURE) &&
+	    para->type == SUNXI_DRAM_TYPE_DDR3) {
 		ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x780);
 		for (i = 0; i < 32; i++)
-			writel(0x16, &ptr[i]);
+			writel(0xc, &ptr[i]);
 		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x78c);
 		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7a4);
 		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7b8);
@@ -717,13 +899,51 @@ static bool mctl_phy_init(struct dram_para *para)
 		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7e0);
 	}
 
-	writel(0x80, SUNXI_DRAM_PHY0_BASE + 0x3dc);
-	writel(0x80, SUNXI_DRAM_PHY0_BASE + 0x45c);
+	if (IS_ENABLED(CONFIG_DRAM_SUN50I_H616_UNKNOWN_FEATURE) &&
+	    para->type == SUNXI_DRAM_TYPE_LPDDR3) {
+		ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x780);
+		for (i = 0; i < 32; i++)
+			writel(0x4, &ptr[i]);
+		writel(0x12, SUNXI_DRAM_PHY0_BASE + 0x7dc);
+		writel(0x12, SUNXI_DRAM_PHY0_BASE + 0x7e0);
+		writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x7e8);
+		if (para->ranks == 2)
+			writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x7f8);
+	}
+
+	if (IS_ENABLED(CONFIG_DRAM_SUN50I_H616_UNKNOWN_FEATURE) &&
+	    para->type == SUNXI_DRAM_TYPE_LPDDR4) {
+		ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x780);
+		for (i = 0; i < 32; i++)
+			writel(0xc, &ptr[i]);
+		/* TODO: check! */
+		writel(0x6, SUNXI_DRAM_PHY0_BASE + 0x7d8);
+		writel(0x6, SUNXI_DRAM_PHY0_BASE + 0x7dc);
+		writel(0x6, SUNXI_DRAM_PHY0_BASE + 0x7e0);
+		writel(0x6, SUNXI_DRAM_PHY0_BASE + 0x7f4);
+	}
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0xb2;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0x44;
+	else
+		val = 0x80;
+
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x3dc);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x45c);
+
+	if (IS_ENABLED(CONFIG_DRAM_ODT_EN))
+		mctl_phy_configure_odt(para);
 
-	if (IS_ENABLED(DRAM_ODT_EN))
-		mctl_phy_configure_odt();
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		val = 0xb;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		val = 0xd;
+	else
+		val = 0xa;
 
-	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 7, 0xa);
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 7, val);
 
 	if (para->clk <= 672)
 		writel(0xf, SUNXI_DRAM_PHY0_BASE + 0x20);
@@ -765,21 +985,72 @@ static bool mctl_phy_init(struct dram_para *para)
 	writel(1, &mctl_ctl->swctl);
 	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
 
-	writel(0x1f14, &mctl_ctl->mrctrl1);
-	writel(0x80000030, &mctl_ctl->mrctrl0);
-	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+	if (para->type == SUNXI_DRAM_TYPE_DDR3) {
+		writel(0x1f14, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
 
-	writel(4, &mctl_ctl->mrctrl1);
-	writel(0x80001030, &mctl_ctl->mrctrl0);
-	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+		writel(4, &mctl_ctl->mrctrl1);
+		writel(0x80001030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x20, &mctl_ctl->mrctrl1);
+		writel(0x80002030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0, &mctl_ctl->mrctrl1);
+		writel(0x80003030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+	}
 
-	writel(0x20, &mctl_ctl->mrctrl1);
-	writel(0x80002030, &mctl_ctl->mrctrl0);
-	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
+		writel(0x83 | 0x100, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
 
-	writel(0, &mctl_ctl->mrctrl1);
-	writel(0x80003030, &mctl_ctl->mrctrl0);
-	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+		writel(0x1c | 0x200, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x01 | 0x300, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+	}
+
+	/* FIXME: check! */
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4) {
+		writel(0x34 | 0x100, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x1b | 0x200, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x33 | 0x300, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x03 | 0x400, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x04 | 0xb00, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x72 | 0xc00, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x09 | 0xe00, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x24 | 0x1600, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+	}
 
 	writel(0, SUNXI_DRAM_PHY0_BASE + 0x54);
 
@@ -848,14 +1119,25 @@ static bool mctl_ctrl_init(struct dram_para *para)
 
 	setbits_le32(&mctl_com->unk_0x008, 0xff00);
 
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		mctl_com->unk_0x050 = 1;
+
 	clrsetbits_le32(&mctl_ctl->sched[0], 0xff00, 0x3000);
 
 	writel(0, &mctl_ctl->hwlpctl);
 
 	setbits_le32(&mctl_com->unk_0x008, 0xff00);
 
-	reg_val = MSTR_BURST_LENGTH(8) | MSTR_ACTIVE_RANKS(para->ranks);
-	reg_val |= MSTR_DEVICETYPE_DDR3 | MSTR_2TMODE;
+	reg_val = MSTR_ACTIVE_RANKS(para->ranks);
+
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
+		reg_val |= MSTR_BURST_LENGTH(8) | MSTR_DEVICETYPE_LPDDR3;
+	else if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		reg_val |= MSTR_BURST_LENGTH(16) | MSTR_DEVICETYPE_LPDDR4;
+	else
+		reg_val |= MSTR_BURST_LENGTH(8) |
+			   MSTR_DEVICETYPE_DDR3 | MSTR_2TMODE;
+
 	if (para->bus_full_width)
 		reg_val |= MSTR_BUSWIDTH_FULL;
 	else
@@ -867,12 +1149,22 @@ static bool mctl_ctrl_init(struct dram_para *para)
 	else
 		writel(0x0201, &mctl_ctl->odtmap);
 
-	writel(0x06000400, &mctl_ctl->odtcfg);
-	writel(0x06000400, &mctl_ctl->unk_0x2240);
-	writel(0x06000400, &mctl_ctl->unk_0x3240);
-	writel(0x06000400, &mctl_ctl->unk_0x4240);
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
+		u32 wr_delay = (para->clk >= 400) ? 4 : 3;
+		u32 ru = (7 * para->clk) / 2000;
+		reg_val = ((ru + 7) << 24) | ((wr_delay - ru) << 16) | 0x400;
+	} else if (para->type == SUNXI_DRAM_TYPE_LPDDR4) {
+		reg_val = 0x04000400;
+	} else {
+		reg_val = 0x06000400;
+	}
+
+	writel(reg_val, &mctl_ctl->odtcfg);
+	writel(reg_val, &mctl_ctl->unk_0x2240);
+	writel(reg_val, &mctl_ctl->unk_0x3240);
+	writel(reg_val, &mctl_ctl->unk_0x4240);
 
-	setbits_le32(&mctl_com->cr, BIT(31));
+	writel(BIT(31), &mctl_com->cr);
 
 	mctl_set_addrmap(para);
 
@@ -994,19 +1286,33 @@ static void mctl_auto_detect_dram_size(struct dram_para *para)
 static unsigned long mctl_calc_size(struct dram_para *para)
 {
 	u8 width = para->bus_full_width ? 4 : 2;
+	unsigned long size;
 
 	/* 8 banks */
-	return (1ULL << (para->cols + para->rows + 3)) * width * para->ranks;
+	size = (1ULL << (para->cols + para->rows + 3)) * width * para->ranks;
+
+	if (para->size_fix)
+		size = (size * 3) / 4;
+
+	return size;
 }
 
 unsigned long sunxi_dram_init(void)
 {
 	struct dram_para para = {
 		.clk = CONFIG_DRAM_CLK,
-		.type = SUNXI_DRAM_TYPE_DDR3,
 	};
 	unsigned long size;
 
+	if (IS_ENABLED(CONFIG_SUNXI_DRAM_H616_DDR3_1333))
+		para.type = SUNXI_DRAM_TYPE_DDR3;
+	if (IS_ENABLED(CONFIG_SUNXI_DRAM_H616_LPDDR3))
+		para.type = SUNXI_DRAM_TYPE_LPDDR3;
+	if (IS_ENABLED(CONFIG_SUNXI_DRAM_H616_LPDDR4))
+		para.type = SUNXI_DRAM_TYPE_LPDDR4;
+	if (IS_ENABLED(CONFIG_DRAM_SUN50I_H616_TRIM_SIZE))
+		para.size_fix = true;
+
 	setbits_le32(0x7010310, BIT(8));
 	clrbits_le32(0x7010318, 0x3f);
 
diff --git a/arch/arm/mach-sunxi/dram_timings/Makefile b/arch/arm/mach-sunxi/dram_timings/Makefile
index 39a8756c29..08b891e4a0 100644
--- a/arch/arm/mach-sunxi/dram_timings/Makefile
+++ b/arch/arm/mach-sunxi/dram_timings/Makefile
@@ -3,5 +3,6 @@ obj-$(CONFIG_SUNXI_DRAM_LPDDR3_STOCK)	+= lpddr3_stock.o
 obj-$(CONFIG_SUNXI_DRAM_DDR2_V3S)	+= ddr2_v3s.o
 obj-$(CONFIG_SUNXI_DRAM_H6_LPDDR3)	+= h6_lpddr3.o
 obj-$(CONFIG_SUNXI_DRAM_H6_DDR3_1333)	+= h6_ddr3_1333.o
-# currently only DDR3 is supported on H616
-obj-$(CONFIG_MACH_SUN50I_H616)		+= h616_ddr3_1333.o
+obj-$(CONFIG_SUNXI_DRAM_H616_DDR3_1333)	+= h616_ddr3_1333.o
+obj-$(CONFIG_SUNXI_DRAM_H616_LPDDR4)	+= h616_lpddr4.o
+obj-$(CONFIG_SUNXI_DRAM_H616_LPDDR3)	+= h616_lpddr3.o
diff --git a/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c b/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c
new file mode 100644
index 0000000000..a59a8aa87f
--- /dev/null
+++ b/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c
@@ -0,0 +1,95 @@
+/*
+ * sun50i H616 DDR3-1333 timings, as programmed by Allwinner's boot0
+ *
+ * The chips are probably able to be driven by a faster clock, but boot0
+ * uses a more conservative timing (as usual).
+ *
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ * Based on H6 DDR3 timings:
+ * (C) Copyright 2018,2019 Arm Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/cpu.h>
+
+void mctl_set_timing_params(struct dram_para *para)
+{
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+
+	u8 tccd		= 2;			/* JEDEC: 4nCK */
+	u8 tfaw		= max(ns_to_t(50), 4);	/* JEDEC: 30 ns w/ 1K pages */
+	u8 trrd		= max(ns_to_t(10), 1);	/* JEDEC: max(6 ns, 4nCK) */
+	u8 trcd		= max(ns_to_t(24), 2);	/* JEDEC: 13.5 ns */
+	u8 trc		= ns_to_t(70);		/* JEDEC: 49.5 ns */
+	u8 txp		= max(ns_to_t(8), 2);	/* JEDEC: max(6 ns, 3nCK) */
+	u8 trtp		= max(ns_to_t(8), 2);	/* JEDEC: max(7.5 ns, 4nCK) */
+	u8 trp		= ns_to_t(27);		/* JEDEC: >= 13.75 ns */
+	u8 tras		= ns_to_t(42);		/* JEDEC >= 36 ns, <= 9*trefi */
+	u16 trefi	= ns_to_t(3900) / 32;	/* JEDEC: 7.8us@Tcase <= 85C */
+	u16 trfc	= ns_to_t(210);		/* JEDEC: 160 ns for 2Gb */
+	u16 txsr	= ns_to_t(220);		/* ? */
+
+	u8 tmrw		= 5;			/* ? */
+	u8 tmrd		= 5;			/* JEDEC: 4nCK */
+	u8 tmod		= 12;			/* JEDEC: max(15 ns, 12nCK) */
+	u8 tcke		= 3;			/* JEDEC: max(5.625 ns, 3nCK) */
+	u8 tcksrx	= 5;			/* JEDEC: max(10 ns, 5nCK) */
+	u8 tcksre	= 5;			/* JEDEC: max(10 ns, 5nCK) */
+	u8 tckesr	= 5;			/* JEDEC: tCKE(min) + 1nCK */
+	u8 trasmax	= 24;			/* JEDEC: tREFI * 9 */
+	u8 txs		= 4;			/* JEDEC: max(5nCK,tRFC+10ns) */
+	u8 txsdll	= 16;			/* JEDEC: 512 nCK */
+	u8 txsabort	= 4;			/* ? */
+	u8 txsfast	= 4;			/* ? */
+	u8 tcl		= 7;			/* JEDEC: CL / 2 => 6 */
+	u8 tcwl		= 4;			/* JEDEC: 8 */
+	u8 t_rdata_en	= 0xc;			/* ? */
+
+	u8 twtp		= 16;			/* (WL + BL / 2 + tWR) / 2 */
+	u8 twr2rd	= trtp + 9;		/* (WL + BL / 2 + tWTR) / 2 */
+	u8 trd2wr	= 13;			/* (RL + BL / 2 + 2 - WL) / 2 */
+
+	/* set DRAM timing */
+	writel((twtp << 24) | (tfaw << 16) | (trasmax << 8) | tras,
+	       &mctl_ctl->dramtmg[0]);
+	writel((txp << 16) | (trtp << 8) | trc, &mctl_ctl->dramtmg[1]);
+	writel((tcwl << 24) | (tcl << 16) | (trd2wr << 8) | twr2rd,
+	       &mctl_ctl->dramtmg[2]);
+	writel((tmrw << 20) | (tmrd << 12) | tmod, &mctl_ctl->dramtmg[3]);
+	writel((trcd << 24) | (tccd << 16) | (trrd << 8) | trp,
+	       &mctl_ctl->dramtmg[4]);
+	writel((tcksrx << 24) | (tcksre << 16) | (tckesr << 8) | tcke,
+	       &mctl_ctl->dramtmg[5]);
+	/* Value suggested by ZynqMP manual and used by libdram */
+	writel((txp + 2) | 0x02020000, &mctl_ctl->dramtmg[6]);
+	writel((txsfast << 24) | (txsabort << 16) | (txsdll << 8) | txs,
+	       &mctl_ctl->dramtmg[8]);
+	writel(0x00020208, &mctl_ctl->dramtmg[9]);
+	writel(0xE0C05, &mctl_ctl->dramtmg[10]);
+	writel(0x440C021C, &mctl_ctl->dramtmg[11]);
+	writel(8, &mctl_ctl->dramtmg[12]);
+	writel(0xA100002, &mctl_ctl->dramtmg[13]);
+	writel(txsr, &mctl_ctl->dramtmg[14]);
+
+	//clrsetbits_le32(&mctl_ctl->init[0], 0x3C00FFFF, 0x4F0000);
+	writel(0x4f0112, &mctl_ctl->init[0]);
+	writel(0x420000, &mctl_ctl->init[1]);
+	writel(0xd05, &mctl_ctl->init[2]);
+	writel(0x83001c, &mctl_ctl->init[3]);
+	writel(0x10000, &mctl_ctl->init[4]);
+
+	writel(0, &mctl_ctl->dfimisc);
+	clrsetbits_le32(&mctl_ctl->rankctl, 0xff0, 0x660);
+
+	/* Configure DFI timing */
+	writel((tcl - 1) | 0x2000000 | (t_rdata_en << 16) | 0x808000,
+	       &mctl_ctl->dfitmg0);
+	writel(0x100202, &mctl_ctl->dfitmg1);
+
+	/* set refresh timing */
+	writel((trefi << 16) | trfc, &mctl_ctl->rfshtmg);
+}
diff --git a/arch/arm/mach-sunxi/dram_timings/h616_lpddr4.c b/arch/arm/mach-sunxi/dram_timings/h616_lpddr4.c
new file mode 100644
index 0000000000..ca36899fe7
--- /dev/null
+++ b/arch/arm/mach-sunxi/dram_timings/h616_lpddr4.c
@@ -0,0 +1,97 @@
+/*
+ * sun50i H616 DDR3-1333 timings, as programmed by Allwinner's boot0
+ *
+ * The chips are probably able to be driven by a faster clock, but boot0
+ * uses a more conservative timing (as usual).
+ *
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ * Based on H6 DDR3 timings:
+ * (C) Copyright 2018,2019 Arm Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/cpu.h>
+
+void mctl_set_timing_params(struct dram_para *para)
+{
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+
+	u8 tccd		= 4;			/* JEDEC: 4nCK */
+	u8 tfaw		= ns_to_t(40);		/* JEDEC: 40 ns w/ 1K pages */
+	u8 trrd		= max(ns_to_t(10), 2);	/* JEDEC: max(10 ns, 2nCK) */
+	u8 trcd		= max(ns_to_t(18), 2);	/* JEDEC: 13.5 ns */
+	u8 trc		= ns_to_t(65);		/* JEDEC: 49.5 ns */
+	u8 txp		= max(ns_to_t(8), 2);	/* JEDEC: max(6 ns, 3nCK) */
+	u8 trtp		= max(ns_to_t(8), 4);	/* JEDEC: max(7.5 ns, 4nCK) */
+	u8 trp		= ns_to_t(21);		/* JEDEC: >= 13.75 ns */
+	u8 tras		= ns_to_t(42);		/* JEDEC >= 36 ns, <= 9*trefi */
+	u16 trefi	= ns_to_t(3904) / 32;	/* JEDEC: 7.8us@Tcase <= 85C */
+	u16 trfc	= ns_to_t(180);		/* JEDEC: 160 ns for 2Gb */
+	u16 txsr	= ns_to_t(190);		/* ? */
+
+	u8 tmrw		= max(ns_to_t(14), 5);	/* ? */
+	u8 tmrd		= tmrw;			/* JEDEC: 4nCK */
+	u8 tmod		= 12;			/* JEDEC: max(15 ns, 12nCK) */
+	u8 tcke		= max(ns_to_t(15), 2);	/* JEDEC: max(5.625 ns, 3nCK) */
+	u8 tcksrx	= max(ns_to_t(2), 2);	/* JEDEC: max(10 ns, 5nCK) */
+	u8 tcksre	= max(ns_to_t(5), 2);	/* JEDEC: max(10 ns, 5nCK) */
+	u8 tckesr	= tcke;			/* JEDEC: tCKE(min) + 1nCK */
+	u8 trasmax	= (trefi * 9) / 32;	/* JEDEC: tREFI * 9 */
+	u8 txs		= 4;			/* JEDEC: max(5nCK,tRFC+10ns) */
+	u8 txsdll	= 16;			/* JEDEC: 512 nCK */
+	u8 txsabort	= 4;			/* ? */
+	u8 txsfast	= 4;			/* ? */
+	u8 tcl		= 10;			/* JEDEC: CL / 2 => 6 */
+	u8 tcwl		= 5;			/* JEDEC: 8 */
+	u8 t_rdata_en	= 17;			/* ? */
+	u8 tphy_wrlat	= 5;
+
+	u8 twtp		= 24;			/* (WL + BL / 2 + tWR) / 2 */
+	u8 twr2rd	= max(trrd, (u8)4) + 14;/* (WL + BL / 2 + tWTR) / 2 */
+	u8 trd2wr	= (ns_to_t(4) + 17) - ns_to_t(1);/* (RL + BL / 2 + 2 - WL) / 2 */
+
+	/* set DRAM timing */
+	writel((twtp << 24) | (tfaw << 16) | (trasmax << 8) | tras,
+	       &mctl_ctl->dramtmg[0]);
+	writel((txp << 16) | (trtp << 8) | trc, &mctl_ctl->dramtmg[1]);
+	writel((tcwl << 24) | (tcl << 16) | (trd2wr << 8) | twr2rd,
+	       &mctl_ctl->dramtmg[2]);
+	writel((tmrw << 20) | (tmrd << 12) | tmod, &mctl_ctl->dramtmg[3]);
+	writel((trcd << 24) | (tccd << 16) | (trrd << 8) | trp,
+	       &mctl_ctl->dramtmg[4]);
+	writel((tcksrx << 24) | (tcksre << 16) | (tckesr << 8) | tcke,
+	       &mctl_ctl->dramtmg[5]);
+	/* Value suggested by ZynqMP manual and used by libdram */
+	writel((txp + 2) | 0x02020000, &mctl_ctl->dramtmg[6]);
+	writel((txsfast << 24) | (txsabort << 16) | (txsdll << 8) | txs,
+	       &mctl_ctl->dramtmg[8]);
+	writel(0x00020208, &mctl_ctl->dramtmg[9]);
+	writel(0xE0C05, &mctl_ctl->dramtmg[10]);
+	writel(0x440C021C, &mctl_ctl->dramtmg[11]);
+	writel(8, &mctl_ctl->dramtmg[12]);
+	writel(0xA100002, &mctl_ctl->dramtmg[13]);
+	writel(txsr, &mctl_ctl->dramtmg[14]);
+
+	clrsetbits_le32(&mctl_ctl->init[0], 0xC0000FFF, 0x3f0);
+	writel(0x01f20000, &mctl_ctl->init[1]);
+	writel(0x00000d05, &mctl_ctl->init[2]);
+	writel(0, &mctl_ctl->dfimisc);
+	writel(0x0034001b, &mctl_ctl->init[3]);
+	writel(0x00330000, &mctl_ctl->init[4]);
+	writel(0x00040072, &mctl_ctl->init[6]);
+	writel(0x00240009, &mctl_ctl->init[7]);
+
+	clrsetbits_le32(&mctl_ctl->rankctl, 0xff0, 0x660);
+
+	/* Configure DFI timing */
+	writel(tphy_wrlat | 0x2000000 | (t_rdata_en << 16) | 0x808000,
+	       &mctl_ctl->dfitmg0);
+	writel(0x100202, &mctl_ctl->dfitmg1);
+
+	/* set refresh timing */
+	writel((trefi << 16) | trfc, &mctl_ctl->rfshtmg);
+}
diff --git a/arch/arm/mach-sunxi/pmic_bus.c b/arch/arm/mach-sunxi/pmic_bus.c
index 0394ce8564..74d14e4053 100644
--- a/arch/arm/mach-sunxi/pmic_bus.c
+++ b/arch/arm/mach-sunxi/pmic_bus.c
@@ -19,6 +19,7 @@
 #define AXP209_I2C_ADDR			0x34
 
 #define AXP305_I2C_ADDR			0x36
+#define AXP313A_I2C_ADDR		0x36
 
 #define AXP221_CHIP_ADDR		0x68
 #define AXP221_CTRL_ADDR		0x3e
@@ -68,6 +69,9 @@ int pmic_bus_read(u8 reg, u8 *data)
 	return i2c_read(AXP209_I2C_ADDR, reg, 1, data, 1);
 #elif defined CONFIG_AXP305_POWER
 	return i2c_read(AXP305_I2C_ADDR, reg, 1, data, 1);
+#elif defined CONFIG_AXP313A_POWER
+	return i2c_read(AXP313A_I2C_ADDR, reg, 1, data, 1);
+#elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 #elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 # ifdef CONFIG_MACH_SUN6I
 	return p2wi_read(reg, data);
@@ -87,6 +91,9 @@ int pmic_bus_write(u8 reg, u8 data)
 	return i2c_write(AXP209_I2C_ADDR, reg, 1, &data, 1);
 #elif defined CONFIG_AXP305_POWER
 	return i2c_write(AXP305_I2C_ADDR, reg, 1, &data, 1);
+#elif defined CONFIG_AXP313A_POWER
+	return i2c_write(AXP313A_I2C_ADDR, reg, 1, &data, 1);
+#elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 #elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 # ifdef CONFIG_MACH_SUN6I
 	return p2wi_write(reg, data);
diff --git a/arch/arm/mach-sunxi/spl_spi_sunxi.c b/arch/arm/mach-sunxi/spl_spi_sunxi.c
index 15e86cbac8..53b7c0324b 100644
--- a/arch/arm/mach-sunxi/spl_spi_sunxi.c
+++ b/arch/arm/mach-sunxi/spl_spi_sunxi.c
@@ -7,6 +7,7 @@
 #include <image.h>
 #include <log.h>
 #include <spl.h>
+#include <asm/arch/spl.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <linux/bitops.h>
@@ -77,7 +78,7 @@
 
 #define CCM_AHB_GATING0             (0x01C20000 + 0x60)
 #define CCM_H6_SPI_BGR_REG          (0x03001000 + 0x96c)
-#ifdef CONFIG_MACH_SUN50I_H6
+#ifdef CONFIG_SUN50I_GEN_H6
 #define CCM_SPI0_CLK                (0x03001000 + 0x940)
 #else
 #define CCM_SPI0_CLK                (0x01C20000 + 0xA0)
@@ -95,7 +96,7 @@
 /*
  * Allwinner A10/A20 SoCs were using pins PC0,PC1,PC2,PC23 for booting
  * from SPI Flash, everything else is using pins PC0,PC1,PC2,PC3.
- * The H6 uses PC0, PC2, PC3, PC5.
+ * The H6 uses PC0, PC2, PC3, PC5, the H616 PC0, PC2, PC3, PC4.
  */
 static void spi0_pinmux_setup(unsigned int pin_function)
 {
@@ -103,12 +104,16 @@ static void spi0_pinmux_setup(unsigned int pin_function)
 	sunxi_gpio_set_cfgpin(SUNXI_GPC(0), pin_function);
 	sunxi_gpio_set_cfgpin(SUNXI_GPC(2), pin_function);
 
-	/* All chips except H6 use PC1, and only H6 uses PC5. */
-	if (!IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	/* All chips except H6 and H616 use PC1. */
+	if (!IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		sunxi_gpio_set_cfgpin(SUNXI_GPC(1), pin_function);
-	else
+
+	if (IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		sunxi_gpio_set_cfgpin(SUNXI_GPC(5), pin_function);
 
+	if (IS_ENABLED(CONFIG_SUN50I_GEN_H616))
+		sunxi_gpio_set_cfgpin(SUNXI_GPC(4), pin_function);
+
 	/* Older generations use PC23 for CS, newer ones use PC3. */
 	if (IS_ENABLED(CONFIG_MACH_SUN4I) || IS_ENABLED(CONFIG_MACH_SUN7I) ||
 	    IS_ENABLED(CONFIG_MACH_SUN8I_R40))
@@ -120,7 +125,7 @@ static void spi0_pinmux_setup(unsigned int pin_function)
 static bool is_sun6i_gen_spi(void)
 {
 	return IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I) ||
-	       IS_ENABLED(CONFIG_MACH_SUN50I_H6);
+	       IS_ENABLED(CONFIG_SUN50I_GEN_H6);
 }
 
 static uintptr_t spi0_base_address(void)
@@ -128,7 +133,7 @@ static uintptr_t spi0_base_address(void)
 	if (IS_ENABLED(CONFIG_MACH_SUN8I_R40))
 		return 0x01C05000;
 
-	if (IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	if (IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		return 0x05010000;
 
 	if (!is_sun6i_gen_spi())
@@ -145,14 +150,14 @@ static void spi0_enable_clock(void)
 	uintptr_t base = spi0_base_address();
 
 	/* Deassert SPI0 reset on SUN6I */
-	if (IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	if (IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		setbits_le32(CCM_H6_SPI_BGR_REG, (1U << 16) | 0x1);
 	else if (is_sun6i_gen_spi())
 		setbits_le32(SUN6I_BUS_SOFT_RST_REG0,
 			     (1 << AHB_RESET_SPI0_SHIFT));
 
 	/* Open the SPI0 gate */
-	if (!IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	if (!IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		setbits_le32(CCM_AHB_GATING0, (1 << AHB_GATE_OFFSET_SPI0));
 
 	/* Divide by 4 */
@@ -193,11 +198,11 @@ static void spi0_disable_clock(void)
 	writel(0, CCM_SPI0_CLK);
 
 	/* Close the SPI0 gate */
-	if (!IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	if (!IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		clrbits_le32(CCM_AHB_GATING0, (1 << AHB_GATE_OFFSET_SPI0));
 
 	/* Assert SPI0 reset on SUN6I */
-	if (IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	if (IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		clrbits_le32(CCM_H6_SPI_BGR_REG, (1U << 16) | 0x1);
 	else if (is_sun6i_gen_spi())
 		clrbits_le32(SUN6I_BUS_SOFT_RST_REG0,
@@ -209,7 +214,7 @@ static void spi0_init(void)
 	unsigned int pin_function = SUNXI_GPC_SPI0;
 
 	if (IS_ENABLED(CONFIG_MACH_SUN50I) ||
-	    IS_ENABLED(CONFIG_MACH_SUN50I_H6))
+	    IS_ENABLED(CONFIG_SUN50I_GEN_H6))
 		pin_function = SUN50I_GPC_SPI0;
 
 	spi0_pinmux_setup(pin_function);
@@ -326,10 +331,13 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 	int ret = 0;
 	struct image_header *header;
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
+	int load_offset = readl(SPL_ADDR + 0x10);
+
+	load_offset = max(load_offset, CONFIG_SYS_SPI_U_BOOT_OFFS);
 
 	spi0_init();
 
-	spi0_read_data((void *)header, CONFIG_SYS_SPI_U_BOOT_OFFS, 0x40);
+	spi0_read_data((void *)header, load_offset, 0x40);
 
         if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 		image_get_magic(header) == FDT_MAGIC) {
@@ -342,14 +350,14 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 		load.bl_len = 1;
 		load.read = spi_load_read;
 		ret = spl_load_simple_fit(spl_image, &load,
-					  CONFIG_SYS_SPI_U_BOOT_OFFS, header);
+					  load_offset, header);
 	} else {
 		ret = spl_parse_image_header(spl_image, header);
 		if (ret)
 			return ret;
 
 		spi0_read_data((void *)spl_image->load_addr,
-			       CONFIG_SYS_SPI_U_BOOT_OFFS, spl_image->size);
+			       load_offset, spl_image->size);
 	}
 
 	spi0_deinit();
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 21651a1bfc..a5b0e4f152 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -233,7 +233,7 @@ static void mmc_pinmux_setup(int sdc);
 /* add board specific code here */
 int board_init(void)
 {
-	__maybe_unused int id_pfr1, ret, satapwr_pin, macpwr_pin;
+	__maybe_unused int id_pfr1, ret, satapwr_pin, macpwr_pin, pwrled_pin;
 
 	gd->bd->bi_boot_params = (PHYS_SDRAM_0 + 0x100);
 
@@ -293,6 +293,24 @@ int board_init(void)
 		}
 	}
 
+	if (CONFIG_PWRLED[0]) {
+		pwrled_pin = sunxi_name_to_gpio(CONFIG_PWRLED);
+		if (pwrled_pin >= 0) {
+			gpio_request(pwrled_pin, "pwrled");
+			gpio_direction_output(pwrled_pin, 1);
+		}
+	}
+
+#if CONFIG_MACH_SUN50I_H616
+	/*
+	 * The bit[16] of register reg[0x03000000] must be zero for the THS
+	 * driver to work properly in the kernel. The BSP u-boot is putting
+	 * the whole register to zero so we are doing the same.
+	 */
+	writel(0x0, SUNXI_SRAMC_BASE);
+	writel(0x0, 0x07010254);
+#endif
+
 #if CONFIG_IS_ENABLED(DM_I2C)
 	/*
 	 * Temporary workaround for enabling I2C clocks until proper sunxi DM
@@ -645,24 +663,34 @@ void sunxi_board_init(void)
 {
 	int power_failed = 0;
 
+#ifdef CONFIG_MACH_SUN8I_H3
+	/* turn on power LED (PL10) on H3 boards */
+	gpio_direction_output(SUNXI_GPL(10), 1);
+#endif
+
 #ifdef CONFIG_SY8106A_POWER
 	power_failed = sy8106a_set_vout1(CONFIG_SY8106A_VOUT1_VOLT);
 #endif
 
 #if defined CONFIG_AXP152_POWER || defined CONFIG_AXP209_POWER || \
 	defined CONFIG_AXP221_POWER || defined CONFIG_AXP305_POWER || \
-	defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
+	defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER || \
+	defined CONFIG_AXP313A_POWER
 	power_failed = axp_init();
 
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
 	defined CONFIG_AXP818_POWER
 	power_failed |= axp_set_dcdc1(CONFIG_AXP_DCDC1_VOLT);
 #endif
-#if !defined(CONFIG_AXP305_POWER)
+#if !defined(CONFIG_AXP305_POWER) && !defined(CONFIG_AXP313A_POWER)
 	power_failed |= axp_set_dcdc2(CONFIG_AXP_DCDC2_VOLT);
 	power_failed |= axp_set_dcdc3(CONFIG_AXP_DCDC3_VOLT);
 #endif
-#if !defined(CONFIG_AXP209_POWER) && !defined(CONFIG_AXP818_POWER)
+#if defined(CONFIG_AXP313A_POWER)
+	power_failed |= axp_set_dcdc3(CONFIG_AXP_DCDC3_VOLT);
+#endif
+#if !defined(CONFIG_AXP209_POWER) && !defined(CONFIG_AXP818_POWER) && \
+    !defined(CONFIG_AXP313A_POWER)
 	power_failed |= axp_set_dcdc4(CONFIG_AXP_DCDC4_VOLT);
 #endif
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
@@ -674,10 +702,11 @@ void sunxi_board_init(void)
 	defined CONFIG_AXP818_POWER
 	power_failed |= axp_set_aldo1(CONFIG_AXP_ALDO1_VOLT);
 #endif
-#if !defined(CONFIG_AXP305_POWER)
+#if !defined(CONFIG_AXP305_POWER) && !defined(CONFIG_AXP313A_POWER)
 	power_failed |= axp_set_aldo2(CONFIG_AXP_ALDO2_VOLT);
 #endif
-#if !defined(CONFIG_AXP152_POWER) && !defined(CONFIG_AXP305_POWER)
+#if !defined(CONFIG_AXP152_POWER) && !defined(CONFIG_AXP305_POWER) && \
+    !defined(CONFIG_AXP313A_POWER)
 	power_failed |= axp_set_aldo3(CONFIG_AXP_ALDO3_VOLT);
 #endif
 #ifdef CONFIG_AXP209_POWER
@@ -888,6 +917,74 @@ static void setup_environment(const void *fdt)
 	}
 }
 
+#if defined(CONFIG_BOOT_PROCESS_MULTI_DTB) && !defined(CONFIG_SPL_BUILD)
+
+#define NP_NEO2_DT_SS			"nanopi-neo2."
+
+#define NP_NEO2_DT_EXT_V1_1		"-v1.1.dtb"
+
+#define NP_NEO2_BOARD_ID_GPIO		"PL3"
+#define NP_NEO2_BOARD_ID_1_0		1
+#define NP_NEO2_BOARD_ID_1_1		0
+
+void boot_process_multi_dtb(void)
+{
+	const char *fdtfile = env_get("fdtfile");
+	if (fdtfile == NULL) {
+		return;
+	}
+
+	/* check for a NanoPi NEO2 */
+	if (strstr(fdtfile, NP_NEO2_DT_SS) != NULL) {
+		int board_id_pin, prev_cfg, ret, rev_1_1;
+
+		/* NEO2 DT found; process board revision and select corresponding DT */
+
+		board_id_pin = sunxi_name_to_gpio(NP_NEO2_BOARD_ID_GPIO);
+		if (board_id_pin < 0) {
+			return;
+		}
+
+		ret = gpio_request(board_id_pin, "board_id_pin");
+		if (ret) {
+			return;
+		}
+
+		prev_cfg = sunxi_gpio_get_cfgpin(board_id_pin);
+
+		gpio_direction_input(board_id_pin);
+		sunxi_gpio_set_pull(board_id_pin, SUNXI_GPIO_PULL_DISABLE);
+
+		mdelay(2);
+
+		rev_1_1 = gpio_get_value(board_id_pin) == NP_NEO2_BOARD_ID_1_1;
+
+		sunxi_gpio_set_cfgpin(board_id_pin, prev_cfg);
+		gpio_free(board_id_pin);
+
+		printf("NanoPi NEO2 v1.%d detected\n", rev_1_1);
+
+		if (rev_1_1) {
+			int ddt_len = sizeof(CONFIG_DEFAULT_DEVICE_TREE);
+			int fdt_len = strlen(fdtfile);
+
+			char *n_fdtfile = (char *)malloc(max(fdt_len, ddt_len) + sizeof(NP_NEO2_DT_EXT_V1_1) + 1);
+			if (n_fdtfile != NULL) {
+				char *cp = strstr(strcpy(n_fdtfile, fdtfile), CONFIG_DEFAULT_DEVICE_TREE);
+				if (cp != NULL) {
+					cp[ddt_len - 1] = '\0';
+					strcat(cp, NP_NEO2_DT_EXT_V1_1);
+
+					env_set("fdtfile", n_fdtfile);
+				}
+
+				free(n_fdtfile);
+			}
+		}
+	}
+}
+#endif
+
 int misc_init_r(void)
 {
 	const char *spl_dt_name;
@@ -930,6 +1027,10 @@ int board_late_init(void)
 	usb_ether_init();
 #endif
 
+#if defined(CONFIG_BOOT_PROCESS_MULTI_DTB) && !defined(CONFIG_SPL_BUILD)
+	boot_process_multi_dtb();
+#endif
+
 	return 0;
 }
 
@@ -970,10 +1071,12 @@ int ft_board_setup(void *blob, struct bd_info *bd)
 	int __maybe_unused r;
 
 	/*
-	 * Call setup_environment again in case the boot fdt has
-	 * ethernet aliases the u-boot copy does not have.
+	 * Call setup_environment and fdt_fixup_ethernet again
+	 * in case the boot fdt has ethernet aliases the u-boot
+	 * copy does not have.
 	 */
 	setup_environment(blob);
+	fdt_fixup_ethernet(blob);
 
 	bluetooth_dt_fixup(blob);
 
diff --git a/cmd/Kconfig b/cmd/Kconfig
index a9fb4eead2..da9524447f 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -1653,6 +1653,7 @@ menu "Misc commands"
 config CMD_BMP
 	bool "Enable 'bmp' command"
 	depends on LCD || DM_VIDEO || VIDEO
+	default y
 	help
 	  This provides a way to obtain information about a BMP-format image
 	  and to display it. BMP (which presumably stands for BitMaP) is a
diff --git a/cmd/fdt.c b/cmd/fdt.c
index f1e2fc2fd8..1f6e5e510c 100644
--- a/cmd/fdt.c
+++ b/cmd/fdt.c
@@ -18,6 +18,7 @@
 #include <fdt_support.h>
 #include <mapmem.h>
 #include <asm/io.h>
+#include <asm/unaligned.h>
 
 #define MAX_LEVEL	32		/* how deeply nested we will go */
 #define SCRATCHPAD	1024		/* bytes of scratchpad memory */
@@ -771,7 +772,10 @@ static int fdt_parse_prop(char * const *newval, int count, char *data, int *len)
 			cp = newp;
 			tmp = simple_strtoul(cp, &newp, 0);
 			if (*cp != '?')
-				*(fdt32_t *)data = cpu_to_fdt32(tmp);
+			{
+				tmp = cpu_to_fdt32(tmp);
+				put_unaligned(tmp, (fdt32_t *)data);
+			}
 			else
 				newp++;
 
diff --git a/common/Kconfig.boot b/common/Kconfig.boot
index 89a3161f1f..c89c6afea4 100644
--- a/common/Kconfig.boot
+++ b/common/Kconfig.boot
@@ -793,7 +793,7 @@ config AUTOBOOT_KEYED
 config AUTOBOOT_PROMPT
 	string "Autoboot stop prompt"
 	depends on AUTOBOOT_KEYED
-	default "Autoboot in %d seconds\\n"
+	default "Autoboot in %d seconds, press <Space> to stop\\n"
 	help
 	  This string is displayed before the boot delay selected by
 	  CONFIG_BOOTDELAY starts. If it is not defined	there is no
@@ -833,6 +833,7 @@ config AUTOBOOT_DELAY_STR
 config AUTOBOOT_STOP_STR
 	string "Stop autobooting via specific input key / string"
 	depends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION
+	default " "
 	help
 	  This option enables stopping (aborting) of the automatic
 	  boot feature only by issuing a specific input key or
diff --git a/drivers/mtd/spi/spi-nor-ids.c b/drivers/mtd/spi/spi-nor-ids.c
index 2b57797954..45dabc94dc 100644
--- a/drivers/mtd/spi/spi-nor-ids.c
+++ b/drivers/mtd/spi/spi-nor-ids.c
@@ -337,5 +337,7 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("XM25QH64A", 0x207017, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("XM25QH128A", 0x207018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 #endif
+	{ INFO("zb25vq128a", 0x5e4018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ INFO("zb25vq16as", 0x5e6015, 0, 64 * 1024, 32, SECT_4K) },
 	{ },
 };
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index c5fbf1f832..ccef04121b 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -58,6 +58,15 @@ config AXP305_POWER
 	Select this to enable support for the axp305 pmic found on most
 	H616 boards.
 
+config AXP313A_POWER
+	bool "axp313a pmic support"
+	depends on MACH_SUN50I_H616
+	select AXP_PMIC_BUS
+	select CMD_POWEROFF
+	---help---
+	Select this to enable support for the axp313a pmic found on most
+	H616 boards.
+
 config AXP809_POWER
 	bool "axp809 pmic support"
 	depends on MACH_SUN9I
@@ -118,11 +127,11 @@ config AXP_DCDC2_VOLT
 
 config AXP_DCDC3_VOLT
 	int "axp pmic dcdc3 voltage"
-	depends on AXP152_POWER || AXP209_POWER || AXP221_POWER || AXP809_POWER || AXP818_POWER
+	depends on AXP152_POWER || AXP209_POWER || AXP221_POWER || AXP809_POWER || AXP818_POWER || AXP313A_POWER
 	default 900 if AXP809_POWER || AXP818_POWER
 	default 1500 if AXP152_POWER
 	default 1250 if AXP209_POWER
-	default 1100 if MACH_SUN8I_R40
+	default 1100 if MACH_SUN8I_R40 || AXP313A_POWER
 	default 1200 if MACH_SUN6I || MACH_SUN8I
 	---help---
 	Set the voltage (mV) to program the axp pmic dcdc3 at, set to 0 to
@@ -130,6 +139,7 @@ config AXP_DCDC3_VOLT
 	On A10(s) / A13 / A20 boards with an axp209 dcdc3 is VDD-INT-DLL and
 	should be 1.25V.
 	On A10s boards with an axp152 dcdc3 is VCC-DRAM and should be 1.5V.
+	On H616 boards with an axp313a dcdc3 is VCC-DRAM(LPDDR4) and should be 1.1V.
 	On A23 / A31 / A33 boards dcdc3 is VDD-CPU and should be 1.2V.
 	On A80 boards dcdc3 is used for VDD-CPUA(cluster 0) and should be 0.9V.
 	On A83T boards dcdc3 is used for VDD-CPUB(cluster 1) and should be 0.9V.
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index 0bef06920a..24a9113942 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_AXP221_POWER)	+= axp221.o
 obj-$(CONFIG_AXP305_POWER)	+= axp305.o
 obj-$(CONFIG_AXP809_POWER)	+= axp809.o
 obj-$(CONFIG_AXP818_POWER)	+= axp818.o
+obj-$(CONFIG_AXP313A_POWER)	+= axp313a.o
 obj-$(CONFIG_EXYNOS_TMU)	+= exynos-tmu.o
 obj-$(CONFIG_FTPMU010_POWER)	+= ftpmu010.o
 obj-$(CONFIG_SY8106A_POWER)	+= sy8106a.o
diff --git a/drivers/power/axp313a.c b/drivers/power/axp313a.c
new file mode 100644
index 0000000000..b3bcb2bef9
--- /dev/null
+++ b/drivers/power/axp313a.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * AXP313a driver
+ *
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * Based on axp221.c
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ * (C) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <asm/arch/pmic_bus.h>
+#include <axp_pmic.h>
+
+#define AXP313A_DCDC4_1600MV_OFFSET 46
+
+static u8 axp313a_mvolt_to_cfg(int mvolt, int min, int max, int div)
+{
+	if (mvolt < min)
+		mvolt = min;
+	else if (mvolt > max)
+		mvolt = max;
+
+	return  (mvolt - min) / div;
+}
+
+#define AXP313A_DCDC3_1200MV_OFFSET 71
+int axp_set_dcdc3(unsigned int mvolt)
+{
+	int ret;
+	u8 cfg;
+
+	if (mvolt >= 1220)
+		cfg = AXP313A_DCDC3_1200MV_OFFSET +
+			axp313a_mvolt_to_cfg(mvolt, 1220, 1840, 20);
+	else
+		cfg = axp313a_mvolt_to_cfg(mvolt, 500, 1200, 10);
+
+	if (mvolt == 0)
+		return pmic_bus_clrbits(AXP313A_OUTPUT_CTRL1,
+					AXP313A_OUTPUT_CTRL1_DCDCD_EN);
+
+	ret = pmic_bus_write(AXP313A_DCDCD_VOLTAGE, cfg);
+	if (ret)
+		return ret;
+
+	return pmic_bus_setbits(AXP313A_OUTPUT_CTRL1,
+				0x1f);
+}
+
+int axp_init(void)
+{
+	u8 axp_chip_id;
+	int ret;
+
+	ret = pmic_bus_init();
+	if (ret)
+		return ret;
+
+	ret = pmic_bus_read(AXP313A_CHIP_VERSION, &axp_chip_id);
+	if (ret)
+		return ret;
+
+	if ((axp_chip_id & AXP313A_CHIP_VERSION_MASK) != 0x4b)
+		return -ENODEV;
+
+        //printf("axp313a pmic id is 0x%x\n",axp_chip_id);
+
+	return ret;
+}
+
+#ifndef CONFIG_PSCI_RESET
+int do_poweroff(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	pmic_bus_write(AXP313A_SHUTDOWN, AXP313A_POWEROFF);
+
+	/* infinite loop during shutdown */
+	while (1) {}
+
+	/* not reached */
+	return 0;
+}
+#endif
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 1494c91763..c5080c1c5b 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -383,6 +383,11 @@ config STM32_SPI
 	  SoCs. This uses driver model and requires a device tree binding to
 	  operate.
 
+config SUN4I_SPI
+	bool "Allwinner A10 SoCs SPI controller"
+	help
+	  SPI driver for Allwinner sun4i, sun5i and sun7i SoCs
+
 config TEGRA114_SPI
 	bool "nVidia Tegra114 SPI driver"
 	help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index cfe4fae1d4..e452bf0d77 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -59,6 +59,7 @@ obj-$(CONFIG_SPI_SUNXI) += spi-sunxi.o
 obj-$(CONFIG_SH_QSPI) += sh_qspi.o
 obj-$(CONFIG_STM32_QSPI) += stm32_qspi.o
 obj-$(CONFIG_STM32_SPI) += stm32_spi.o
+obj-$(CONFIG_SUN4I_SPI) += sun4i_spi.o
 obj-$(CONFIG_TEGRA114_SPI) += tegra114_spi.o
 obj-$(CONFIG_TEGRA20_SFLASH) += tegra20_sflash.o
 obj-$(CONFIG_TEGRA20_SLINK) += tegra20_slink.o
diff --git a/drivers/spi/sun4i_spi.c b/drivers/spi/sun4i_spi.c
new file mode 100644
index 0000000000..b86b5a00ad
--- /dev/null
+++ b/drivers/spi/sun4i_spi.c
@@ -0,0 +1,456 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * (C) Copyright 2017 Olimex Ltd..
+ * Stefan Mavrodiev <stefan@olimex.com>
+ *
+ * Based on linux spi driver. Original copyright follows:
+ * linux/drivers/spi/spi-sun4i.c
+ *
+ * Copyright (C) 2012 - 2014 Allwinner Tech
+ * Pan Nan <pannan@allwinnertech.com>
+ *
+ * Copyright (C) 2014 Maxime Ripard
+ * Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <spi.h>
+#include <errno.h>
+#include <fdt_support.h>
+#include <wait_bit.h>
+
+#include <asm/bitops.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+
+#include <asm/arch/clock.h>
+
+#define SUN4I_FIFO_DEPTH	64
+
+#define SUN4I_RXDATA_REG	0x00
+
+#define SUN4I_TXDATA_REG	0x04
+
+#define SUN4I_CTL_REG		0x08
+#define SUN4I_CTL_ENABLE		BIT(0)
+#define SUN4I_CTL_MASTER		BIT(1)
+#define SUN4I_CTL_CPHA			BIT(2)
+#define SUN4I_CTL_CPOL			BIT(3)
+#define SUN4I_CTL_CS_ACTIVE_LOW		BIT(4)
+#define SUN4I_CTL_LMTF			BIT(6)
+#define SUN4I_CTL_TF_RST		BIT(8)
+#define SUN4I_CTL_RF_RST		BIT(9)
+#define SUN4I_CTL_XCH_MASK		0x0400
+#define SUN4I_CTL_XCH			BIT(10)
+#define SUN4I_CTL_CS_MASK		0x3000
+#define SUN4I_CTL_CS(cs)		(((cs) << 12) & SUN4I_CTL_CS_MASK)
+#define SUN4I_CTL_DHB			BIT(15)
+#define SUN4I_CTL_CS_MANUAL		BIT(16)
+#define SUN4I_CTL_CS_LEVEL		BIT(17)
+#define SUN4I_CTL_TP			BIT(18)
+
+#define SUN4I_INT_CTL_REG	0x0c
+#define SUN4I_INT_CTL_RF_F34		BIT(4)
+#define SUN4I_INT_CTL_TF_E34		BIT(12)
+#define SUN4I_INT_CTL_TC		BIT(16)
+
+#define SUN4I_INT_STA_REG	0x10
+
+#define SUN4I_DMA_CTL_REG	0x14
+
+#define SUN4I_WAIT_REG		0x18
+
+#define SUN4I_CLK_CTL_REG	0x1c
+#define SUN4I_CLK_CTL_CDR2_MASK		0xff
+#define SUN4I_CLK_CTL_CDR2(div)		((div) & SUN4I_CLK_CTL_CDR2_MASK)
+#define SUN4I_CLK_CTL_CDR1_MASK		0xf
+#define SUN4I_CLK_CTL_CDR1(div)		(((div) & SUN4I_CLK_CTL_CDR1_MASK) << 8)
+#define SUN4I_CLK_CTL_DRS		BIT(12)
+
+#define SUN4I_MAX_XFER_SIZE		0xffffff
+
+#define SUN4I_BURST_CNT_REG	0x20
+#define SUN4I_BURST_CNT(cnt)		((cnt) & SUN4I_MAX_XFER_SIZE)
+
+#define SUN4I_XMIT_CNT_REG	0x24
+#define SUN4I_XMIT_CNT(cnt)		((cnt) & SUN4I_MAX_XFER_SIZE)
+
+#define SUN4I_FIFO_STA_REG	0x28
+#define SUN4I_FIFO_STA_RF_CNT_MASK	0x7f
+#define SUN4I_FIFO_STA_RF_CNT_BITS	0
+#define SUN4I_FIFO_STA_TF_CNT_MASK	0x7f
+#define SUN4I_FIFO_STA_TF_CNT_BITS	16
+
+#define SUN4I_SPI_MAX_RATE	24000000
+#define SUN4I_SPI_MIN_RATE	3000
+#define SUN4I_SPI_DEFAULT_RATE	1000000
+#define SUN4I_SPI_TIMEOUT_US	1000000
+
+/* sun4i spi register set */
+struct sun4i_spi_regs {
+	u32 rxdata;
+	u32 txdata;
+	u32 ctl;
+	u32 intctl;
+	u32 st;
+	u32 dmactl;
+	u32 wait;
+	u32 cctl;
+	u32 bc;
+	u32 tc;
+	u32 fifo_sta;
+};
+
+struct sun4i_spi_platdata {
+	u32 base_addr;
+	u32 max_hz;
+};
+
+struct sun4i_spi_priv {
+	struct sun4i_spi_regs *regs;
+	u32 freq;
+	u32 mode;
+
+	const u8 *tx_buf;
+	u8 *rx_buf;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static inline void sun4i_spi_drain_fifo(struct sun4i_spi_priv *priv, int len)
+{
+	u8 byte;
+
+	while (len--) {
+		byte = readb(&priv->regs->rxdata);
+		*priv->rx_buf++ = byte;
+	}
+}
+
+static inline void sun4i_spi_fill_fifo(struct sun4i_spi_priv *priv, int len)
+{
+	u8 byte;
+
+	while (len--) {
+		byte = priv->tx_buf ? *priv->tx_buf++ : 0;
+		writeb(byte, &priv->regs->txdata);
+	}
+}
+
+static void sun4i_spi_set_cs(struct udevice *bus, u8 cs, bool enable)
+{
+	struct sun4i_spi_priv *priv = dev_get_priv(bus);
+	u32 reg;
+
+	reg = readl(&priv->regs->ctl);
+
+	reg &= ~SUN4I_CTL_CS_MASK;
+	reg |= SUN4I_CTL_CS(cs);
+
+	if (enable)
+		reg &= ~SUN4I_CTL_CS_LEVEL;
+	else
+		reg |= SUN4I_CTL_CS_LEVEL;
+
+	writel(reg, &priv->regs->ctl);
+}
+
+static int sun4i_spi_parse_pins(struct udevice *dev)
+{
+	const void *fdt = gd->fdt_blob;
+	const char *pin_name;
+	const fdt32_t *list;
+	u32 phandle;
+	int drive, pull = 0, pin, i;
+	int offset;
+	int size;
+
+	list = fdt_getprop(fdt, dev_of_offset(dev), "pinctrl-0", &size);
+	if (!list) {
+		printf("WARNING: sun4i_spi: cannot find pinctrl-0 node\n");
+		return -EINVAL;
+	}
+
+	while (size) {
+		phandle = fdt32_to_cpu(*list++);
+		size -= sizeof(*list);
+
+		offset = fdt_node_offset_by_phandle(fdt, phandle);
+		if (offset < 0)
+			return offset;
+
+		drive = fdt_getprop_u32_default_node(fdt, offset, 0,
+						     "drive-strength", 0);
+		if (drive) {
+			if (drive <= 10)
+				drive = 0;
+			else if (drive <= 20)
+				drive = 1;
+			else if (drive <= 30)
+				drive = 2;
+			else
+				drive = 3;
+		} else {
+			drive = fdt_getprop_u32_default_node(fdt, offset, 0,
+							     "allwinner,drive",
+							      0);
+			drive = min(drive, 3);
+		}
+
+		if (fdt_get_property(fdt, offset, "bias-disable", NULL))
+			pull = 0;
+		else if (fdt_get_property(fdt, offset, "bias-pull-up", NULL))
+			pull = 1;
+		else if (fdt_get_property(fdt, offset, "bias-pull-down", NULL))
+			pull = 2;
+		else
+			pull = fdt_getprop_u32_default_node(fdt, offset, 0,
+							    "allwinner,pull",
+							     0);
+		pull = min(pull, 2);
+
+		for (i = 0; ; i++) {
+			pin_name = fdt_stringlist_get(fdt, offset,
+						      "pins", i, NULL);
+			if (!pin_name) {
+				pin_name = fdt_stringlist_get(fdt, offset,
+							      "allwinner,pins",
+							       i, NULL);
+				if (!pin_name)
+					break;
+			}
+
+			pin = name_to_gpio(pin_name);
+			if (pin < 0)
+				break;
+
+			sunxi_gpio_set_cfgpin(pin, SUNXI_GPC_SPI0);
+			sunxi_gpio_set_drv(pin, drive);
+			sunxi_gpio_set_pull(pin, pull);
+		}
+	}
+	return 0;
+}
+
+static inline void sun4i_spi_enable_clock(void)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *const)SUNXI_CCM_BASE;
+
+	setbits_le32(&ccm->ahb_gate0, (1 << AHB_GATE_OFFSET_SPI0));
+	writel((1 << 31), &ccm->spi0_clk_cfg);
+}
+
+static int sun4i_spi_ofdata_to_platdata(struct udevice *bus)
+{
+	struct sun4i_spi_platdata *plat = dev_get_platdata(bus);
+	int node = dev_of_offset(bus);
+
+	plat->base_addr = devfdt_get_addr(bus);
+	plat->max_hz = fdtdec_get_int(gd->fdt_blob, node,
+				      "spi-max-frequency",
+				      SUN4I_SPI_DEFAULT_RATE);
+
+	if (plat->max_hz > SUN4I_SPI_MAX_RATE)
+		plat->max_hz = SUN4I_SPI_MAX_RATE;
+
+	return 0;
+}
+
+static int sun4i_spi_probe(struct udevice *bus)
+{
+	struct sun4i_spi_platdata *plat = dev_get_platdata(bus);
+	struct sun4i_spi_priv *priv = dev_get_priv(bus);
+
+	sun4i_spi_enable_clock();
+	sun4i_spi_parse_pins(bus);
+
+	priv->regs = (struct sun4i_spi_regs *)(uintptr_t)plat->base_addr;
+	priv->freq = plat->max_hz;
+
+	return 0;
+}
+
+static int sun4i_spi_claim_bus(struct udevice *dev)
+{
+	struct sun4i_spi_priv *priv = dev_get_priv(dev->parent);
+
+	writel(SUN4I_CTL_ENABLE | SUN4I_CTL_MASTER | SUN4I_CTL_TP |
+	       SUN4I_CTL_CS_MANUAL | SUN4I_CTL_CS_ACTIVE_LOW,
+	       &priv->regs->ctl);
+	return 0;
+}
+
+static int sun4i_spi_release_bus(struct udevice *dev)
+{
+	struct sun4i_spi_priv *priv = dev_get_priv(dev->parent);
+	u32 reg;
+
+	reg = readl(&priv->regs->ctl);
+	reg &= ~SUN4I_CTL_ENABLE;
+	writel(reg, &priv->regs->ctl);
+
+	return 0;
+}
+
+static int sun4i_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			  const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct sun4i_spi_priv *priv = dev_get_priv(bus);
+	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
+
+	u32 len = bitlen / 8;
+	u32 reg;
+	u8 nbytes;
+	int ret;
+
+	priv->tx_buf = dout;
+	priv->rx_buf = din;
+
+	if (bitlen % 8) {
+		debug("%s: non byte-aligned SPI transfer.\n", __func__);
+		return -ENAVAIL;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		sun4i_spi_set_cs(bus, slave_plat->cs, true);
+
+	reg = readl(&priv->regs->ctl);
+
+	/* Reset FIFOs */
+	writel(reg | SUN4I_CTL_RF_RST | SUN4I_CTL_TF_RST, &priv->regs->ctl);
+
+	while (len) {
+		/* Setup the transfer now... */
+		nbytes = min(len, (u32)(SUN4I_FIFO_DEPTH - 1));
+
+		/* Setup the counters */
+		writel(SUN4I_BURST_CNT(nbytes), &priv->regs->bc);
+		writel(SUN4I_XMIT_CNT(nbytes), &priv->regs->tc);
+
+		/* Fill the TX FIFO */
+		sun4i_spi_fill_fifo(priv, nbytes);
+
+		/* Start the transfer */
+		reg = readl(&priv->regs->ctl);
+		writel(reg | SUN4I_CTL_XCH, &priv->regs->ctl);
+
+		/* Wait transfer to complete */
+		ret = wait_for_bit_le32(&priv->regs->ctl, SUN4I_CTL_XCH_MASK,
+					false, SUN4I_SPI_TIMEOUT_US, false);
+		if (ret) {
+			printf("ERROR: sun4i_spi: Timeout transferring data\n");
+			sun4i_spi_set_cs(bus, slave_plat->cs, false);
+			return ret;
+		}
+
+		/* Drain the RX FIFO */
+		sun4i_spi_drain_fifo(priv, nbytes);
+
+		len -= nbytes;
+	}
+
+	if (flags & SPI_XFER_END)
+		sun4i_spi_set_cs(bus, slave_plat->cs, false);
+
+	return 0;
+}
+
+static int sun4i_spi_set_speed(struct udevice *dev, uint speed)
+{
+	struct sun4i_spi_platdata *plat = dev_get_platdata(dev);
+	struct sun4i_spi_priv *priv = dev_get_priv(dev);
+	unsigned int div;
+	u32 reg;
+
+	if (speed > plat->max_hz)
+		speed = plat->max_hz;
+
+	if (speed < SUN4I_SPI_MIN_RATE)
+		speed = SUN4I_SPI_MIN_RATE;
+	/*
+	 * Setup clock divider.
+	 *
+	 * We have two choices there. Either we can use the clock
+	 * divide rate 1, which is calculated thanks to this formula:
+	 * SPI_CLK = MOD_CLK / (2 ^ (cdr + 1))
+	 * Or we can use CDR2, which is calculated with the formula:
+	 * SPI_CLK = MOD_CLK / (2 * (cdr + 1))
+	 * Whether we use the former or the latter is set through the
+	 * DRS bit.
+	 *
+	 * First try CDR2, and if we can't reach the expected
+	 * frequency, fall back to CDR1.
+	 */
+
+	div = SUN4I_SPI_MAX_RATE / (2 * speed);
+	reg = readl(&priv->regs->cctl);
+
+	if (div <= (SUN4I_CLK_CTL_CDR2_MASK + 1)) {
+		if (div > 0)
+			div--;
+
+		reg &= ~(SUN4I_CLK_CTL_CDR2_MASK | SUN4I_CLK_CTL_DRS);
+		reg |= SUN4I_CLK_CTL_CDR2(div) | SUN4I_CLK_CTL_DRS;
+	} else {
+		div = __ilog2(SUN4I_SPI_MAX_RATE) - __ilog2(speed);
+		reg &= ~((SUN4I_CLK_CTL_CDR1_MASK << 8) | SUN4I_CLK_CTL_DRS);
+		reg |= SUN4I_CLK_CTL_CDR1(div);
+	}
+
+	priv->freq = speed;
+	writel(reg, &priv->regs->cctl);
+
+	return 0;
+}
+
+static int sun4i_spi_set_mode(struct udevice *dev, uint mode)
+{
+	struct sun4i_spi_priv *priv = dev_get_priv(dev);
+	u32 reg;
+
+	reg = readl(&priv->regs->ctl);
+	reg &= ~(SUN4I_CTL_CPOL | SUN4I_CTL_CPHA);
+
+	if (mode & SPI_CPOL)
+		reg |= SUN4I_CTL_CPOL;
+
+	if (mode & SPI_CPHA)
+		reg |= SUN4I_CTL_CPHA;
+
+	priv->mode = mode;
+	writel(reg, &priv->regs->ctl);
+
+	return 0;
+}
+
+static const struct dm_spi_ops sun4i_spi_ops = {
+	.claim_bus		= sun4i_spi_claim_bus,
+	.release_bus		= sun4i_spi_release_bus,
+	.xfer			= sun4i_spi_xfer,
+	.set_speed		= sun4i_spi_set_speed,
+	.set_mode		= sun4i_spi_set_mode,
+};
+
+static const struct udevice_id sun4i_spi_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10-spi"  },
+	{ }
+};
+
+U_BOOT_DRIVER(sun4i_spi) = {
+	.name	= "sun4i_spi",
+	.id	= UCLASS_SPI,
+	.of_match	= sun4i_spi_ids,
+	.ops	= &sun4i_spi_ops,
+	.ofdata_to_platdata	= sun4i_spi_ofdata_to_platdata,
+	.platdata_auto_alloc_size	= sizeof(struct sun4i_spi_platdata),
+	.priv_auto_alloc_size	= sizeof(struct sun4i_spi_priv),
+	.probe	= sun4i_spi_probe,
+};
diff --git a/drivers/video/bridge/anx6345.c b/drivers/video/bridge/anx6345.c
index 93fa25f16e..0fa56c75a2 100644
--- a/drivers/video/bridge/anx6345.c
+++ b/drivers/video/bridge/anx6345.c
@@ -3,6 +3,8 @@
  * Copyright (C) 2017 Vasily Khoruzhick <anarsoul@gmail.com>
  */
 
+#define DEBUG
+
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
@@ -250,13 +252,77 @@ static int anx6345_read_dpcd(struct udevice *dev, u32 reg, u8 *val)
 	return 0;
 }
 
+static u8 pinebook14_edid[] = {
+	/* Header */
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	/* ID Manufacturer Name */
+	0x09, 0xe5,
+	/* ID Product Code */
+	0x37, 0x00,
+	/* 32-bit serial No. */
+	0x00, 0x00, 0x00, 0x00,
+	/* Week of manufacture */
+	0x01,
+	/* Year of manufacture */
+	0x16,
+	/* EDID Structure Ver. */
+	0x01,
+	/* EDID revision # */
+	0x04,
+	/* Video input definition */
+	0x80,
+	/* Max H image size */
+	0x1f,
+	/* Max V image size */
+	0x11,
+	/* Display Gamma */
+	0x78,
+	/* Feature support */
+	0x0a,
+	/* Color bits */
+	0xb0, 0x90, 0x97, 0x58, 0x54, 0x92, 0x26, 0x1d, 0x50, 0x54,
+	/* Established timings */
+	0x00, 0x00, 0x00,
+	/* Standard timings */
+	0x01, 0x01,
+	0x01, 0x01,
+	0x01, 0x01,
+	0x01, 0x01,
+	0x01, 0x01,
+	0x01, 0x01,
+	0x01, 0x01,
+	0x01, 0x01,
+	/* Detailed timing/monitor descriptor #1 */
+	0x3e, 0x1c, 0x56, 0xa0, 0x50, 0x00, 0x16, 0x30,
+	0x30, 0x20, 0x36, 0x00, 0x35, 0xad, 0x10, 0x00,
+	0x00, 0x1a,
+	/* Detailed timing/monitor descriptor #2 */
+	0x3e, 0x1c, 0x56, 0xa0, 0x50, 0x00, 0x16, 0x30,
+	0x30, 0x20, 0x36, 0x00, 0x35, 0xad, 0x10, 0x00,
+	0x00, 0x1a,
+	/* Detailed timing/monitor descriptor #3 */
+	0x00, 0x00, 0x00, 0xfe, 0x00, 0x42, 0x4f, 0x45,
+	0x20, 0x48, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20,
+	/* Detailed timing/monitor descriptor #4 */
+	0x00, 0x00, 0x00, 0xfe, 0x00, 0x48, 0x42, 0x31,
+	0x34, 0x30, 0x57, 0x58, 0x31, 0x2d, 0x35, 0x30,
+	0x31, 0x0a,
+	/* Extension flag */
+	0x00,
+	/* Checksum */
+	0x81
+};
+
 static int anx6345_read_edid(struct udevice *dev, u8 *buf, int size)
 {
-	struct anx6345_priv *priv = dev_get_priv(dev);
-
 	if (size > EDID_SIZE)
 		size = EDID_SIZE;
-	memcpy(buf, priv->edid, size);
+
+	if (anx6345_read_aux_i2c(dev, 0x50, 0x0, size, buf) != 0) {
+		debug("%s: EDID read failed, using static EDID\n", __func__);
+		memcpy(buf, pinebook14_edid, size);
+	}
 
 	return size;
 }
@@ -270,7 +336,7 @@ static int anx6345_attach(struct udevice *dev)
 static int anx6345_enable(struct udevice *dev)
 {
 	u8 chipid, colordepth, lanes, data_rate, c;
-	int ret, i, bpp;
+	int ret, i;
 	struct display_timing timing;
 	struct anx6345_priv *priv = dev_get_priv(dev);
 
@@ -338,27 +404,19 @@ static int anx6345_enable(struct udevice *dev)
 	anx6345_write_r0(dev, ANX9804_HDCP_CONTROL_0_REG, 0x00);
 	anx6345_write_r0(dev, 0xa7, 0x00);
 
-	anx6345_read_aux_i2c(dev, 0x50, 0x0, EDID_SIZE, priv->edid);
-	if (edid_get_timing(priv->edid, EDID_SIZE, &timing, &bpp) != 0) {
-		debug("Failed to parse EDID\n");
-		return -EIO;
-	}
-	debug("%s: panel found: %dx%d, bpp %d\n", __func__,
-	      timing.hactive.typ, timing.vactive.typ, bpp);
-	if (bpp == 6)
-		colordepth = 0x00; /* 6 bit */
-	else
-		colordepth = 0x10; /* 8 bit */
+	/* XXXJDM hard-coded for HB140WX1-501 14" TFT-LCD */
+	colordepth = 0x00; /* 6 bit */
+
 	anx6345_write_r1(dev, ANX9804_VID_CTRL2_REG, colordepth);
 
 	if (anx6345_read_dpcd(dev, DP_MAX_LINK_RATE, &data_rate)) {
 		debug("%s: Failed to DP_MAX_LINK_RATE\n", __func__);
-		return -EIO;
+		data_rate = 10;
 	}
 	debug("%s: data_rate: %d\n", __func__, (int)data_rate);
 	if (anx6345_read_dpcd(dev, DP_MAX_LANE_COUNT, &lanes)) {
 		debug("%s: Failed to read DP_MAX_LANE_COUNT\n", __func__);
-		return -EIO;
+		lanes = 1;
 	}
 	lanes &= DP_MAX_LANE_COUNT_MASK;
 	debug("%s: lanes: %d\n", __func__, (int)lanes);
diff --git a/dts/Kconfig b/dts/Kconfig
index dabe0080c1..e382f2c52e 100644
--- a/dts/Kconfig
+++ b/dts/Kconfig
@@ -259,6 +259,12 @@ config SPL_OF_LIST
 	  device tree files (without the directory or .dtb suffix)
 	  separated by <space>.
 
+if ARCH_SUNXI
+config BOOT_PROCESS_MULTI_DTB
+	bool "Adjust default board DT as necessary at boot"
+	default n
+endif
+
 choice
 	prompt "SPL OF LIST compression"
 	depends on SPL_MULTI_DTB_FIT
diff --git a/include/axp313a.h b/include/axp313a.h
new file mode 100644
index 0000000000..7aa72ff368
--- /dev/null
+++ b/include/axp313a.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+enum axp313a_reg {
+	AXP313A_CHIP_VERSION = 0x3,
+	AXP313A_OUTPUT_CTRL1 = 0x10,
+	AXP313A_DCDCD_VOLTAGE = 0x15,
+	AXP313A_SHUTDOWN = 0x32,
+};
+
+#define AXP313A_CHIP_VERSION_MASK	0xcf
+
+#define AXP313A_OUTPUT_CTRL1_DCDCD_EN	(1 << 3)
+
+#define AXP313A_POWEROFF		(1 << 7)
diff --git a/include/axp_pmic.h b/include/axp_pmic.h
index 405044c3a3..fa3946f895 100644
--- a/include/axp_pmic.h
+++ b/include/axp_pmic.h
@@ -18,6 +18,9 @@
 #ifdef CONFIG_AXP305_POWER
 #include <axp305.h>
 #endif
+#ifdef CONFIG_AXP313A_POWER
+#include <axp313a.h>
+#endif
 #ifdef CONFIG_AXP809_POWER
 #include <axp809.h>
 #endif
diff --git a/include/config_distro_bootcmd.h b/include/config_distro_bootcmd.h
index 2627c2a6a5..96f0e89135 100644
--- a/include/config_distro_bootcmd.h
+++ b/include/config_distro_bootcmd.h
@@ -430,6 +430,15 @@
 	BOOTENV_SHARED_EFI \
 	BOOTENV_SHARED_VIRTIO \
 	"boot_prefixes=/ /boot/\0" \
+	"splashpos=m,m\0" \
+	"splashimage=66000000\0" \
+	"loadsplash= " \
+		"for prefix in ${boot_prefixes}; do " \
+			"if test -e mmc 0 ${prefix}boot.bmp; then " \
+				"load mmc 0 ${splashimage} ${prefix}boot.bmp; " \
+				"bmp d ${splashimage}; " \
+			"fi; " \
+		"done\0" \
 	"boot_scripts=boot.scr.uimg boot.scr\0" \
 	"boot_script_dhcp=boot.scr.uimg\0" \
 	BOOTENV_BOOT_TARGETS \
diff --git a/include/configs/sun8i.h b/include/configs/sun8i.h
index 9b4675e4c3..221761ee47 100644
--- a/include/configs/sun8i.h
+++ b/include/configs/sun8i.h
@@ -17,4 +17,6 @@
  */
 #include <configs/sunxi-common.h>
 
+#define CONFIG_MACH_TYPE	(0x1029)
+
 #endif /* __CONFIG_H */
diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h
index 9e37e99684..eb9ccf47c8 100644
--- a/include/configs/sunxi-common.h
+++ b/include/configs/sunxi-common.h
@@ -223,6 +223,16 @@ extern int soft_i2c_gpio_scl;
 #define CONFIG_VIDEO_LCD_I2C_BUS	-1 /* NA, but necessary to compile */
 #endif
 
+#if defined CONFIG_VIDEO || defined CONFIG_DM_VIDEO
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_BMP_24BPP
+#define CONFIG_BMP_32BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#endif
+
 /* Ethernet support */
 
 #ifdef CONFIG_USB_EHCI_HCD
@@ -396,6 +406,11 @@ extern int soft_i2c_gpio_scl;
 #ifdef CONFIG_USB_KEYBOARD
 #define CONSOLE_STDIN_SETTINGS \
 	"stdin=serial,usbkbd\0"
+#if defined CONFIG_VIDEO || defined CONFIG_DM_VIDEO
+#define CONSOLE_STDIN_SETTINGS \
+	"preboot=run loadsplash; usb start\0" \
+	"stdin=serial,usbkbd\0"
+#endif
 #else
 #define CONSOLE_STDIN_SETTINGS \
 	"stdin=serial\0"
diff --git a/lib/efi_loader/efi_var_seed.S b/lib/efi_loader/efi_var_seed.S
deleted file mode 100644
index e0a40cf46c..0000000000
--- a/lib/efi_loader/efi_var_seed.S
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Predefined UEFI variables
- *
- * Copyright (c) 2020, Heinrich Schuchardt <xypron.glpk@gmx.de>
- */
-
-#include <config.h>
-
-.section .rodata.efi_seed.init,"a"
-.balign 16
-.global __efi_var_file_begin
-__efi_var_file_begin:
-.incbin CONFIG_EFI_VAR_SEED_FILE
-.global __efi_var_file_end
-__efi_var_file_end:
-.balign 16
-- 
2.39.2

