From ba4875aa434f5507c9ef3a71e069e818a9eedee2 Mon Sep 17 00:00:00 2001
From: Vyacheslav Bocharov <adeep@lexina.in>
Date: Wed, 29 Jun 2022 09:26:35 +0300
Subject: [PATCH 3/6] Copy and update amlogic-2019 aml partition/keyman code to
 mainline

---
 .../meson-axg-jethome-jethub-j100-u-boot.dtsi |    92 +
 cmd/Kconfig                                   |     5 +
 cmd/Makefile                                  |     3 +
 cmd/aml_mmc.c                                 |  3542 ++
 cmd/storage.c                                 |  1503 +
 common/Makefile                               |     3 +
 common/aml_dt.c                               |   600 +
 common/partitions.c                           |   206 +
 configs/jethub_j100_defconfig                 |     7 +
 configs/jethub_j80_defconfig                  |     8 +
 disk/Kconfig                                  |    13 +
 disk/Makefile                                 |     1 +
 disk/part_aml.c                               |   110 +
 drivers/Kconfig                               |     4 +
 drivers/Makefile                              |     3 +
 drivers/amlogic/Kconfig                       |    14 +
 drivers/amlogic/Makefile                      |     5 +
 drivers/amlogic/keymanage/Kconfig             |    21 +
 drivers/amlogic/keymanage/Makefile            |    32 +
 drivers/amlogic/keymanage/key_manage.c        |   689 +
 drivers/amlogic/keymanage/key_manage.h        |    61 +
 drivers/amlogic/keymanage/key_manage_i.h      |    65 +
 drivers/amlogic/keymanage/key_unify.c         |   610 +
 drivers/amlogic/keymanage/km_dts.c            |   392 +
 drivers/amlogic/keymanage/km_efuse_key.c      |   156 +
 drivers/amlogic/keymanage/km_provision_key.c  |   102 +
 drivers/amlogic/keymanage/km_secure_key.c     |   263 +
 .../amlogic/keymanage/km_secure_key_2015.c    |   118 +
 drivers/amlogic/storagekey/Kconfig            |     2 +
 drivers/amlogic/storagekey/Makefile           |     3 +
 drivers/amlogic/storagekey/normal_key.c       |   672 +
 drivers/amlogic/storagekey/normal_key.h       |    49 +
 drivers/amlogic/storagekey/securestorage.c    |   389 +
 drivers/amlogic/storagekey/storagekey.c       |   587 +
 drivers/efuse/Kconfig                         |     4 +
 drivers/efuse/Makefile                        |     9 +
 drivers/efuse/aml_efuse.c                     |   123 +
 drivers/efuse/bl31_apis.c                     |   474 +
 drivers/efuse/efuse.c                         |   141 +
 drivers/efuse/efuse_usr_space_api.c           |   379 +
 drivers/mmc/Makefile                          |     3 +
 drivers/mmc/aml_emmc_partition.c              |  1715 +
 drivers/mmc/mmc.c                             |    99 +-
 drivers/mmc/mmc_aml copy.c                    |  3299 ++
 drivers/mmc/mmc_aml.c                         |   416 +
 drivers/mmc/storage_emmc.c                    |   946 +
 include/amlogic/aml_cec.h                     |    86 +
 include/amlogic/aml_efuse.h                   |    79 +
 include/amlogic/aml_gpio.h                    |    54 +
 include/amlogic/aml_hdmirx.h                  |    19 +
 include/amlogic/aml_irblaster.h               |    29 +
 include/amlogic/aml_is31fl32xx.h              |     9 +
 include/amlogic/aml_led.h                     |    68 +
 include/amlogic/aml_mmc.h                     |   105 +
 include/amlogic/aml_mtd.h                     |    31 +
 include/amlogic/aml_nand.h                    |    24 +
 include/amlogic/aml_rsv.h                     |   106 +
 include/amlogic/aml_tlv.h                     |   157 +
 include/amlogic/aml_v2_burning.h              |    31 +
 include/amlogic/aml_v3_burning.h              |    14 +
 include/amlogic/amlkey_if.h                   |    85 +
 include/amlogic/anti-rollback.h               |    40 +
 include/amlogic/asm/bl31_apis.h               |   166 +
 include/amlogic/asm/clock.h                   |    41 +
 include/amlogic/asm/cpu_config.h              |   101 +
 include/amlogic/asm/cpu_sdio.h                |   264 +
 include/amlogic/asm/efuse.h                   |    62 +
 include/amlogic/asm/io.h                      |   118 +
 include/amlogic/asm/register.h                |    98 +
 include/amlogic/asm/regs.h                    | 32964 ++++++++++++++++
 include/amlogic/asm/romboot.h                 |    53 +
 include/amlogic/asm/sd_emmc.h                 |   136 +
 include/amlogic/asm/secure_apb.h              |  4235 ++
 include/amlogic/auge_sound.h                  |    24 +
 include/amlogic/blxx2bl33_param.h             |    27 +
 include/amlogic/canvas.h                      |    68 +
 include/amlogic/color.h                       |    51 +
 include/amlogic/cpu_id.h                      |    90 +
 include/amlogic/enc_clk_config.h              |     1 +
 include/amlogic/fb.h                          |   399 +
 include/amlogic/instaboot.h                   |    24 +
 include/amlogic/jtag.h                        |    61 +
 include/amlogic/keyunify.h                    |    56 +
 include/amlogic/media/vout/aml_cvbs.h         |    13 +
 include/amlogic/media/vout/aml_vinfo.h        |   148 +
 include/amlogic/media/vout/aml_vmode.h        |    98 +
 include/amlogic/media/vout/aml_vout.h         |    25 +
 .../amlogic/media/vout/hdmitx/hdmi_common.h   |   655 +
 include/amlogic/media/vout/hdmitx/hdmitx.h    |    11 +
 .../amlogic/media/vout/hdmitx/hdmitx_ext.h    |     6 +
 .../amlogic/media/vout/hdmitx/hdmitx_module.h |   106 +
 .../amlogic/media/vout/hdmitx/hdmitx_reg.h    |  1041 +
 include/amlogic/media/vout/hdmitx/mach_reg.h  |   625 +
 include/amlogic/media/vout/lcd/aml_lcd.h      |   168 +
 include/amlogic/media/vout/lcd/bl_extern.h    |    88 +
 include/amlogic/media/vout/lcd/bl_ldim.h      |   118 +
 include/amlogic/media/vout/lcd/lcd_extern.h   |   116 +
 include/amlogic/media/vout/lcd/lcd_vout.h     |   520 +
 include/amlogic/media/vpp/vpp.h               |    24 +
 include/amlogic/media/vpu/vpu.h               |    11 +
 include/amlogic/saradc.h                      |   103 +
 include/amlogic/secure_storage.h              |    46 +
 include/amlogic/sound.h                       |   180 +
 include/amlogic/spicc.h                       |    44 +
 include/amlogic/spifc.h                       |    44 +
 include/amlogic/storage.h                     |   501 +
 include/amlogic/storagekey.h                  |    57 +
 include/amlogic/store_wrapper.h               |    56 +
 include/amlstorage/emmc_partitions.h          |   271 +
 include/amlstorage/emmc_storage.h             |    76 +
 include/amlstorage/partition_table.h          |    72 +
 include/mmc.h                                 |    26 +-
 include/part.h                                |     3 +
 113 files changed, 63164 insertions(+), 2 deletions(-)
 create mode 100644 cmd/aml_mmc.c
 create mode 100644 cmd/storage.c
 create mode 100644 common/aml_dt.c
 create mode 100644 common/partitions.c
 create mode 100644 disk/part_aml.c
 create mode 100644 drivers/amlogic/Kconfig
 create mode 100644 drivers/amlogic/Makefile
 create mode 100644 drivers/amlogic/keymanage/Kconfig
 create mode 100644 drivers/amlogic/keymanage/Makefile
 create mode 100644 drivers/amlogic/keymanage/key_manage.c
 create mode 100644 drivers/amlogic/keymanage/key_manage.h
 create mode 100644 drivers/amlogic/keymanage/key_manage_i.h
 create mode 100644 drivers/amlogic/keymanage/key_unify.c
 create mode 100644 drivers/amlogic/keymanage/km_dts.c
 create mode 100644 drivers/amlogic/keymanage/km_efuse_key.c
 create mode 100644 drivers/amlogic/keymanage/km_provision_key.c
 create mode 100644 drivers/amlogic/keymanage/km_secure_key.c
 create mode 100644 drivers/amlogic/keymanage/km_secure_key_2015.c
 create mode 100644 drivers/amlogic/storagekey/Kconfig
 create mode 100644 drivers/amlogic/storagekey/Makefile
 create mode 100644 drivers/amlogic/storagekey/normal_key.c
 create mode 100644 drivers/amlogic/storagekey/normal_key.h
 create mode 100644 drivers/amlogic/storagekey/securestorage.c
 create mode 100644 drivers/amlogic/storagekey/storagekey.c
 create mode 100644 drivers/efuse/Kconfig
 create mode 100644 drivers/efuse/Makefile
 create mode 100644 drivers/efuse/aml_efuse.c
 create mode 100644 drivers/efuse/bl31_apis.c
 create mode 100644 drivers/efuse/efuse.c
 create mode 100644 drivers/efuse/efuse_usr_space_api.c
 create mode 100644 drivers/mmc/aml_emmc_partition.c
 create mode 100644 drivers/mmc/mmc_aml copy.c
 create mode 100644 drivers/mmc/mmc_aml.c
 create mode 100644 drivers/mmc/storage_emmc.c
 create mode 100644 include/amlogic/aml_cec.h
 create mode 100644 include/amlogic/aml_efuse.h
 create mode 100644 include/amlogic/aml_gpio.h
 create mode 100644 include/amlogic/aml_hdmirx.h
 create mode 100644 include/amlogic/aml_irblaster.h
 create mode 100644 include/amlogic/aml_is31fl32xx.h
 create mode 100644 include/amlogic/aml_led.h
 create mode 100644 include/amlogic/aml_mmc.h
 create mode 100644 include/amlogic/aml_mtd.h
 create mode 100644 include/amlogic/aml_nand.h
 create mode 100644 include/amlogic/aml_rsv.h
 create mode 100644 include/amlogic/aml_tlv.h
 create mode 100644 include/amlogic/aml_v2_burning.h
 create mode 100644 include/amlogic/aml_v3_burning.h
 create mode 100644 include/amlogic/amlkey_if.h
 create mode 100644 include/amlogic/anti-rollback.h
 create mode 100644 include/amlogic/asm/bl31_apis.h
 create mode 100644 include/amlogic/asm/clock.h
 create mode 100644 include/amlogic/asm/cpu_config.h
 create mode 100644 include/amlogic/asm/cpu_sdio.h
 create mode 100644 include/amlogic/asm/efuse.h
 create mode 100644 include/amlogic/asm/io.h
 create mode 100644 include/amlogic/asm/register.h
 create mode 100644 include/amlogic/asm/regs.h
 create mode 100644 include/amlogic/asm/romboot.h
 create mode 100644 include/amlogic/asm/sd_emmc.h
 create mode 100644 include/amlogic/asm/secure_apb.h
 create mode 100644 include/amlogic/auge_sound.h
 create mode 100644 include/amlogic/blxx2bl33_param.h
 create mode 100644 include/amlogic/canvas.h
 create mode 100644 include/amlogic/color.h
 create mode 100644 include/amlogic/cpu_id.h
 create mode 100644 include/amlogic/enc_clk_config.h
 create mode 100644 include/amlogic/fb.h
 create mode 100644 include/amlogic/instaboot.h
 create mode 100644 include/amlogic/jtag.h
 create mode 100644 include/amlogic/keyunify.h
 create mode 100644 include/amlogic/media/vout/aml_cvbs.h
 create mode 100644 include/amlogic/media/vout/aml_vinfo.h
 create mode 100644 include/amlogic/media/vout/aml_vmode.h
 create mode 100644 include/amlogic/media/vout/aml_vout.h
 create mode 100644 include/amlogic/media/vout/hdmitx/hdmi_common.h
 create mode 100644 include/amlogic/media/vout/hdmitx/hdmitx.h
 create mode 100644 include/amlogic/media/vout/hdmitx/hdmitx_ext.h
 create mode 100644 include/amlogic/media/vout/hdmitx/hdmitx_module.h
 create mode 100644 include/amlogic/media/vout/hdmitx/hdmitx_reg.h
 create mode 100644 include/amlogic/media/vout/hdmitx/mach_reg.h
 create mode 100644 include/amlogic/media/vout/lcd/aml_lcd.h
 create mode 100644 include/amlogic/media/vout/lcd/bl_extern.h
 create mode 100644 include/amlogic/media/vout/lcd/bl_ldim.h
 create mode 100644 include/amlogic/media/vout/lcd/lcd_extern.h
 create mode 100644 include/amlogic/media/vout/lcd/lcd_vout.h
 create mode 100644 include/amlogic/media/vpp/vpp.h
 create mode 100644 include/amlogic/media/vpu/vpu.h
 create mode 100644 include/amlogic/saradc.h
 create mode 100644 include/amlogic/secure_storage.h
 create mode 100644 include/amlogic/sound.h
 create mode 100644 include/amlogic/spicc.h
 create mode 100644 include/amlogic/spifc.h
 create mode 100644 include/amlogic/storage.h
 create mode 100644 include/amlogic/storagekey.h
 create mode 100644 include/amlogic/store_wrapper.h
 create mode 100644 include/amlstorage/emmc_partitions.h
 create mode 100644 include/amlstorage/emmc_storage.h
 create mode 100644 include/amlstorage/partition_table.h

diff --git a/arch/arm/dts/meson-axg-jethome-jethub-j100-u-boot.dtsi b/arch/arm/dts/meson-axg-jethome-jethub-j100-u-boot.dtsi
index 3ecb233f8e..e0e6b2259c 100644
--- a/arch/arm/dts/meson-axg-jethome-jethub-j100-u-boot.dtsi
+++ b/arch/arm/dts/meson-axg-jethome-jethub-j100-u-boot.dtsi
@@ -4,6 +4,98 @@
  * Author: Vyacheslav Bocharov <adeep@lexina.in>
  */
 
+/ {
+	partitions: partitions {
+		parts = <1>;
+		part-0 = <&rootfs>;
+		rootfs: rootfs {
+			pname = "rootfs";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	efusekey: efusekey {
+		keynum = <5>;
+		key0 = <&key_0>;
+		key1 = <&key_1>;
+		key2 = <&key_2>;
+		key3 = <&key_3>;
+		key4 = <&key_4>;
+
+		key_0: key_0 {
+			keyname = "mac";
+			offset = <0>;
+			size = <6>;
+		};
+		key_1: key_1 {
+			keyname = "mac_bt";
+			offset = <6>;
+			size = <6>;
+		};
+		key_2: key_2 {
+			keyname = "mac_wifi";
+			offset = <12>;
+			size = <6>;
+		};
+		key_3: key_3 {
+			keyname = "usid";
+			offset = <18>;
+			size = <32>;
+		};
+		key_4: key_4 {
+			keyname = "serial";
+			offset = <50>;
+			size = <32>;
+		};
+	}; //End efusekey
+
+	unifykey {
+		compatible = "amlogic, unifykey";
+		status = "ok";
+		unifykey-num = <6>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+
+		keysn_0: key_0 {
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read";
+		};
+		keysn_1: key_1 {
+			key-name = "mac";
+			key-device = "normal";
+			key-permit = "read";
+		};
+		keysn_2: key_2 {
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+			key-type  = "mac";
+		};
+		keysn_3: key_3 {
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+			key-type = "mac";
+		};
+		keysn_4: key_4 {
+			key-name = "serial";
+			key-device = "normal";
+			key-permit = "read";
+		};
+		keysn_5:key_5 {
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+	}; //End unifykey
+};
+
 &saradc {
 	status = "okay";
 	vref-supply = <&vddio_ao18>;
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 09193b61b9..c2d8ac7595 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -2411,6 +2411,11 @@ config CMD_REISER
 	    reiserls - list files
 	    reiserload - load a file
 
+config AML_STORAGE
+	bool "aml storage support"
+	help
+	  storage cmd support
+
 config CMD_YAFFS2
 	bool "yaffs2 - Access of YAFFS2 filesystem"
 	depends on YAFFS2
diff --git a/cmd/Makefile b/cmd/Makefile
index 5e43a1e022..18e994730d 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -193,6 +193,9 @@ obj-$(CONFIG_CMD_ETHSW) += ethsw.o
 obj-$(CONFIG_CMD_AXI) += axi.o
 obj-$(CONFIG_CMD_PVBLOCK) += pvblock.o
 
+obj-$(CONFIG_AML_STORAGE) += storage.o
+obj-$(CONFIG_CMD_MMC) += aml_mmc.o
+
 # Power
 obj-$(CONFIG_CMD_PMIC) += pmic.o
 obj-$(CONFIG_CMD_REGULATOR) += regulator.o
diff --git a/cmd/aml_mmc.c b/cmd/aml_mmc.c
new file mode 100644
index 0000000000..06e0d9ea0c
--- /dev/null
+++ b/cmd/aml_mmc.c
@@ -0,0 +1,3542 @@
+/*
+ * (C) Copyright 2003
+ * Kyle Harris, kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <command.h>
+#include <linux/ctype.h>
+#include <linux/crc32.h>
+#include <linux/bug.h>
+#include <mmc.h>
+#include "../drivers/mmc/mmc_private.h"
+#include <amlstorage/partition_table.h>
+#include <amlstorage/emmc_partitions.h>
+#include <amlogic/asm/cpu_sdio.h>
+#include <amlogic/asm/sd_emmc.h>
+#include <linux/sizes.h>
+//#include <amlogic/cpu_id.h>
+#include <amlogic/aml_mmc.h>
+#include <linux/delay.h>
+
+/* info system. */
+#define dtb_err(fmt, ...) printf( "%s()-%d: " fmt , \
+				  __func__, __LINE__, ##__VA_ARGS__)
+
+#define dtb_wrn(fmt, ...) printf( "%s()-%d: " fmt , \
+				  __func__, __LINE__, ##__VA_ARGS__)
+
+/* for detail debug info */
+#define dtb_info(fmt, ...) printf( "%s()-%d: " fmt , \
+				  __func__, __LINE__, ##__VA_ARGS__)
+
+#define fb_err(fmt, ...)   printf("%s()-%d: " fmt , \
+				__func__, __LINE__, ##__VA_ARGS__)
+#define CONFIG_SYS_MMC_ENV_DEV		1
+struct aml_dtb_rsv {
+	u8 data[DTB_BLK_SIZE*DTB_BLK_CNT - 4*sizeof(u32)];
+	u32 magic;
+	u32 version;
+	u32 timestamp;
+	u32 checksum;
+};
+
+struct aml_dtb_info {
+	u32 stamp[2];
+	u8 valid[2];
+};
+
+#define stamp_after(a,b)   ((int)(b) - (int)(a)  < 0)
+/* glb dtb infos */
+static struct aml_dtb_info dtb_infos = {{0, 0}, {0, 0}};
+
+#define CONFIG_SECURITYKEY
+
+#if !defined(CONFIG_SYS_MMC_BOOT_DEV)
+	#define CONFIG_SYS_MMC_BOOT_DEV (CONFIG_SYS_MMC_ENV_DEV)
+#endif
+
+#define GXB_START_BLK   0
+#define GXL_START_BLK   1
+
+/* max 2MB for emmc in blks */
+#define UBOOT_SIZE  (0x1000)
+
+
+extern int mmc_key_write(unsigned char *buf, unsigned int size, uint32_t *actual_lenth);
+extern int mmc_key_read(unsigned char *buf, unsigned int size, uint32_t *actual_lenth);
+
+/* move this out to storage */
+//int info_disprotect = 0;
+
+
+int mmc_read_status(struct mmc *mmc, int timeout)
+{
+	struct mmc_cmd cmd;
+	int err, retries = 5;
+	int status;
+
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	if (!mmc_host_is_spi(mmc))
+		cmd.cmdarg = mmc->rca << 16;
+	do {
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (!err) {
+			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
+				(cmd.response[0] & MMC_STATUS_CURR_STATE) !=
+				 MMC_STATE_PRG)
+				break;
+			else if (cmd.response[0] & MMC_STATUS_MASK) {
+				printf("Status Error: 0x%08X\n",
+					cmd.response[0]);
+				return -18;
+			}
+		} else if (--retries < 0)
+			return err;
+
+		udelay(1000);
+
+	} while (timeout--);
+
+	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
+	printf("CURR STATE:%d, status = 0x%x\n", status, cmd.response[0]);
+
+	if (timeout <= 0) {
+		printf("read status Timeout waiting card ready\n");
+		return -19;
+	}
+	if (cmd.response[0] & MMC_STATUS_SWITCH_ERROR) {
+		printf("mmc status swwitch error status =0x%x\n", status);
+		return -21;
+	}
+	return 0;
+}
+
+bool emmckey_is_protected (struct mmc *mmc)
+{
+#ifdef CONFIG_STORE_COMPATIBLE
+#ifdef CONFIG_SECURITYKEY
+	if (info_disprotect & DISPROTECT_KEY) {
+		printf("%s(): disprotect\n", __func__);
+		return 0;
+	}else{
+		printf("%s(): protect\n", __func__);
+		return 1;
+	}
+#else
+		return 0;
+#endif
+#else
+#ifdef CONFIG_SECURITYKEY
+		//return mmc->key_protect;
+		return 0; /* fixme, */
+#else
+		return 0;
+#endif
+#endif
+}
+
+unsigned emmc_cur_partition = 0;
+
+
+static int get_off_size(struct mmc * mmc, char * name, uint64_t offset, uint64_t  size, u64 * blk, u64 * cnt, u64 * sz_byte)
+{
+		struct partitions *part_info = NULL;
+		uint64_t off = 0;
+		int blk_shift = 0;
+
+		blk_shift =  ffs(mmc->read_bl_len) - 1;
+		// printf("blk_shift:%d , off:0x%llx , size:0x%llx.\n ",blk_shift,off,size );
+		part_info = find_mmc_partition_by_name(name);
+		if (part_info == NULL) {
+				printf("get partition info failed !!\n");
+				return -1;
+		}
+		off = part_info->offset + offset;
+
+		// printf("part_info->offset:0x%llx , off:0x%llx , size:0x%llx.\n",part_info->offset ,off,size);
+
+		*blk = off >>  blk_shift ;
+		*cnt = size >>  blk_shift ;
+		*sz_byte = size - ((*cnt) << blk_shift) ;
+
+		// printf("get_partition_off_size : blk:0x%llx , cnt:0x%llx.\n",*blk,*cnt);
+		return 0;
+}
+
+static int get_partition_size(unsigned char* name, uint64_t* addr)
+{
+		struct partitions *part_info = NULL;
+		part_info = find_mmc_partition_by_name((char *)name);
+		if (part_info == NULL) {
+				printf("get partition info failed !!\n");
+				return -1;
+		}
+
+		*addr = part_info->size >> 9; // unit: 512 bytes
+		return 0;
+}
+
+static inline int isstring(char *p)
+{
+	char *endptr = p;
+	while (*endptr != '\0') {
+		if (!(((*endptr >= '0') && (*endptr <= '9'))
+				|| ((*endptr >= 'a') && (*endptr <= 'f'))
+				|| ((*endptr >= 'A') && (*endptr <= 'F'))
+				|| (*endptr == 'x') || (*endptr == 'X')))
+			return 1;
+		endptr++;
+	}
+
+	return 0;
+}
+
+/*
+	erase bootloader on user/boot0/boot1 which indicate by map.
+	bit 0: user
+	bit 1: boot0
+	bit 2: boot1
+*/
+int amlmmc_erase_bootloader(int dev, int map)
+{
+	int ret = 0, i, count = 3;
+	int blk_shift;
+	unsigned long n;
+	char *partname[3] = {"user", "boot0", "boot1"};
+	// cpu_id_t cpu_id = get_cpu_id();
+	struct mmc *mmc = find_mmc_device(dev);
+
+	/* do nothing */
+	if (0 == map)
+		goto _out;
+
+	if (!mmc) {
+		printf("%s() %d: not valid emmc %d\n", __func__, __LINE__, dev);
+		ret = -1;
+		goto _out;
+	}
+	/* make sure mmc is initilized! */
+	ret = mmc_init(mmc);
+	if (ret) {
+		printf("%s() %d: emmc %d init %d\n", __func__, __LINE__, dev, ret);
+		ret = -2;
+		goto _out;
+	}
+
+	blk_shift = ffs(mmc->read_bl_len) -1;
+	/* erase bootloader in user/boot0/boot1 */
+	for (i = 0; i < count; i++) {
+		if (map & (0x1 << i)) {
+			if (!blk_select_hwpart_devnum(IF_TYPE_MMC, 1, i)) {
+				lbaint_t start = 0, blkcnt;
+
+				blkcnt = mmc->capacity >> blk_shift;
+				if (0 == i) {
+					struct partitions *part_info;
+					/* get info by partition */
+					part_info = find_mmc_partition_by_name(MMC_BOOT_NAME);
+					if (part_info == NULL) {
+						printf("%s() %d: error!!\n", __func__, __LINE__);
+						/* fixme, do somthing! */
+						continue;
+					} else {
+						start = part_info->offset>> blk_shift;
+						blkcnt = part_info->size>> blk_shift;
+						if (1) { //cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+							start = GXL_START_BLK;
+							blkcnt -= GXL_START_BLK;
+						}
+					}
+				}
+/* some customer may use boot1 higher 2M as private data. */
+#ifdef CONFIG_EMMC_BOOT1_TOUCH_REGION
+				if (2 == i && CONFIG_EMMC_BOOT1_TOUCH_REGION <= mmc->capacity) {
+					blkcnt = CONFIG_EMMC_BOOT1_TOUCH_REGION >> blk_shift;
+				}
+#endif/* CONFIG_EMMC_BOOT1_TOUCH_REGION */
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+				printf("Erasing blocks " LBAFU " to " LBAFU " @ %s\n",
+				   start, blkcnt, partname[i]);
+				n = blk_derase(mmc_get_blk_desc(mmc), start, blkcnt);
+				if (n != 0) {
+					printf("mmc erase %s failed\n", partname[i]);
+					ret = -3;
+					break;
+				}
+			} else
+				printf("%s() %d: switch dev %d to %s fail\n",
+						__func__, __LINE__, dev, partname[i]);
+		}
+	}
+	/* try to switch back to user. */
+	blk_select_hwpart(mmc->dev, 0);
+
+_out:
+	return ret;
+}
+
+/*
+	write bootloader on user/boot0/boot1 which indicate by map.
+	bit 0: user
+	bit 1: boot0
+	bit 2: boot1
+*/
+int amlmmc_write_bootloader(int dev, int map, unsigned int size, const void *src)
+{
+	int ret = 0, i, count = 3;
+	unsigned long n;
+	char *partname[3] = {"user", "boot0", "boot1"};
+	struct mmc *mmc = find_mmc_device(dev);
+	lbaint_t start = GXB_START_BLK, blkcnt;
+	//cpu_id_t cpu_id = get_cpu_id();
+
+	/* do nothing */
+	if (0 == map)
+		goto _out;
+
+	if (!mmc) {
+		printf("%s() %d: not valid emmc %d\n", __func__, __LINE__, dev);
+		ret = -1;
+		goto _out;
+	}
+	/* make sure mmc is initilized! */
+	ret = mmc_init(mmc);
+	if (ret) {
+		printf("%s() %d: emmc %d init %d\n", __func__, __LINE__, dev, ret);
+		ret = -2;
+		goto _out;
+	}
+
+	if(1) //(cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL)
+		start = GXL_START_BLK;
+	blkcnt = (size + mmc->read_bl_len - 1) / mmc->read_bl_len;
+
+	/* erase bootloader in user/boot0/boot1 */
+	for (i = 0; i < count; i++) {
+		if (map & (0x1 << i)) {
+			if (!blk_select_hwpart_devnum(IF_TYPE_MMC, 1, i)) {
+/* some customer may use boot1 higher 2M as private data. */
+#ifdef CONFIG_EMMC_BOOT1_TOUCH_REGION
+				if (2 == i && CONFIG_EMMC_BOOT1_TOUCH_REGION <= size) {
+					printf("%s(), size %d exceeds TOUCH_REGION %d, skip\n",
+						__func__, size, CONFIG_EMMC_BOOT1_TOUCH_REGION);
+					break;
+				}
+#endif /* CONFIG_EMMC_BOOT1_TOUCH_REGION */
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+				printf("Wrting blocks " LBAFU " to " LBAFU " @ %s\n",
+				   start, blkcnt, partname[i]);
+				n = blk_dwrite(mmc_get_blk_desc(mmc), start, blkcnt, src);
+				if (n != blkcnt) {
+					printf("mmc write %s failed\n", partname[i]);
+					ret = -3;
+					break;
+				}
+			} else
+				printf("%s() %d: switch dev %d to %s fail\n",
+						__func__, __LINE__, dev, partname[i]);
+		}
+	}
+	/* try to switch back to user. */
+	blk_select_hwpart(mmc->dev, 0);
+
+_out:
+	return ret;
+}
+
+static int amlmmc_erase_in_dev(int argc, char *const argv[])
+{
+	int dev = 0;
+	u64 cnt = 0, blk = 0, n = 0;
+	struct mmc *mmc;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	blk = simple_strtoull(argv[3], NULL, 16);
+	cnt = simple_strtoull(argv[4], NULL, 16);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+
+	printf("MMC erase: dev # %d, start_erase_address(in block) # %#llx,\
+			several blocks  # %lld will be erased ...\n ",
+			dev, blk, cnt);
+
+	mmc_init(mmc);
+
+	if (cnt != 0)
+		n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+
+	printf("dev # %d, %s, several blocks erased %s\n",
+				dev, " ", (n == 0) ? "OK" : "ERROR");
+
+	return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_in_card(int argc, char *const argv[])
+{
+	int dev = 0;
+	u64 cnt = 0, blk = 0, n = 0;
+	/*sz_byte =0;*/
+	char *name = NULL;
+	u64 offset_addr = 0, size = 0;
+	struct mmc *mmc;
+	int tmp_shift;
+
+	name = argv[2];
+	dev = find_dev_num_by_partition_name (name);
+	offset_addr = simple_strtoull(argv[3], NULL, 16);
+	size = simple_strtoull(argv[4], NULL, 16);
+	mmc = find_mmc_device(dev);
+
+	tmp_shift = ffs(mmc->read_bl_len) -1;
+	cnt = size >> tmp_shift;
+	blk = offset_addr >> tmp_shift;
+	/* sz_byte = size - (cnt<<tmp_shift); */
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+
+	printf("MMC erase: dev # %d, start_erase_address(in block) # %#llx,\
+			several blocks  # %lld will be erased ...\n ",
+			dev, blk, cnt);
+
+	mmc_init(mmc);
+
+	if (cnt != 0)
+		n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+
+	printf("dev # %d, %s, several blocks erased %s\n",
+				dev, argv[2], (n == 0) ? "OK" : "ERROR");
+
+	return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_in_part(int argc, char *const argv[])
+{
+	int dev = 0;
+	u64 cnt = 0, blk = 0, n = 0, sz_byte =0;
+	char *name = NULL;
+	u64 offset_addr = 0, size = 0;
+	struct mmc *mmc;
+	struct partitions *part_info;
+
+	name = argv[2];
+	dev = find_dev_num_by_partition_name (name);
+	offset_addr = simple_strtoull(argv[3], NULL, 16);
+	size = simple_strtoull(argv[4], NULL, 16);
+	part_info = find_mmc_partition_by_name(name);
+	mmc = find_mmc_device(dev);
+
+	if (offset_addr >= part_info->size) {
+		printf("Start address out #%s# partition'address region,(addr_byte < 0x%llx)\n",
+						name, part_info->size);
+		return 1;
+	}
+	if ((offset_addr+size) > part_info->size) {
+		printf("End address exceeds #%s# partition,(offset = 0x%llx,size = 0x%llx)\n",
+						name, part_info->offset,part_info->size);
+		return 1;
+	}
+	get_off_size(mmc, name, offset_addr, size, &blk, &cnt, &sz_byte);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+
+	if (!mmc)
+		return 1;
+
+	printf("MMC erase: dev # %d, start_erase_address(in block) # %#llx,\
+			several blocks  # %lld will be erased ...\n ",
+			dev, blk, cnt);
+
+	mmc_init(mmc);
+
+	if (cnt != 0)
+		n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+
+	printf("dev # %d, %s, several blocks erased %s\n",
+				dev, argv[2], (n == 0) ? "OK" : "ERROR");
+	return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_by_add(int argc, char *const argv[])
+{
+	int ret = 0;
+
+	if (argc != 5)
+		return CMD_RET_USAGE;
+
+	if (isdigit(argv[2][0]))
+		ret = amlmmc_erase_in_dev(argc, argv);
+	else if (strcmp(argv[2], "card") == 0)
+		ret = amlmmc_erase_in_card(argc, argv);
+	else if (isstring(argv[2]))
+		ret = amlmmc_erase_in_part(argc, argv);
+
+	return ret;
+}
+
+static int amlmmc_erase_non_loader(int argc, char *const argv[])
+{
+	int dev;
+	u32 n = 0;
+	int blk_shift;
+	u64 blk = 0, start_blk = 0;
+	struct partitions *part_info;
+	struct mmc *mmc;
+
+	dev = 1;
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+
+	mmc_init(mmc);
+
+	blk_shift = ffs(mmc->read_bl_len) -1;
+	part_info = find_mmc_partition_by_name(MMC_BOOT_NAME);
+
+	if (part_info == NULL) {
+		start_blk = 0;
+		printf("no uboot partition for eMMC boot, just erase from 0\n");
+	}
+	else
+		start_blk = (part_info->offset + part_info->size) >> blk_shift;
+
+	if (emmckey_is_protected(mmc)) {
+		part_info = find_mmc_partition_by_name(MMC_RESERVED_NAME);
+		if (part_info == NULL) {
+			return 1;
+		}
+		blk = part_info->offset;
+		// it means: there should be other partitions before reserve-partition.
+		if (blk > 0)
+			blk -= PARTITION_RESERVED;
+		blk >>= blk_shift;
+		blk -= start_blk;
+		// (1) erase all the area before reserve-partition
+		if (blk > 0)
+			n = blk_derase(mmc_get_blk_desc(mmc), start_blk, blk);
+		if (n == 0) { // not error
+			// (2) erase all the area after reserve-partition
+			start_blk = (part_info->offset + part_info->size + PARTITION_RESERVED)
+						 >> blk_shift;
+			u64 erase_cnt = (mmc->capacity >> blk_shift) - start_blk;
+			n = blk_derase(mmc_get_blk_desc(mmc), start_blk, erase_cnt);
+		}
+	} else {
+		n = blk_derase(mmc_get_blk_desc(mmc), start_blk, 0); // erase the whole card
+	}
+	return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_single_part(int argc, char *const argv[])
+{
+	char *name = NULL;
+	int dev;
+	u32 n = 0;
+	int blk_shift;
+	u64 cnt = 0, blk = 0;
+	struct partitions *part_info;
+	struct mmc *mmc;
+	name = argv[2];
+	dev = find_dev_num_by_partition_name(name);
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+
+	mmc_init(mmc);
+
+	blk_shift = ffs(mmc->read_bl_len) -1;
+	if (emmckey_is_protected(mmc)
+		&& (strncmp(name, MMC_RESERVED_NAME, sizeof(MMC_RESERVED_NAME)) == 0x00)) {
+		printf("\"%s-partition\" is been protecting and should no be erased!\n",
+				MMC_RESERVED_NAME);
+		return 1;
+	}
+
+	part_info = find_mmc_partition_by_name(name);
+	if (part_info == NULL) {
+		return 1;
+	}
+
+	blk = part_info->offset >> blk_shift;
+	if (emmc_cur_partition && !strncmp(name, "bootloader", strlen("bootloader")))
+		cnt = 0;
+	else
+	cnt = part_info->size >> blk_shift;
+	n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+
+	return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_whole(int argc, char *const argv[])
+{
+	char *name = NULL;
+	int dev;
+	u32 n = 0;
+	int blk_shift;
+	//u64 cnt = 0,
+	u64 blk = 0, start_blk = 0;
+	struct partitions *part_info;
+	struct mmc *mmc;
+	int map;
+
+	name = "logo";
+	dev = find_dev_num_by_partition_name(name);
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+	mmc_init(mmc);
+	blk_shift = ffs(mmc->read_bl_len) -1;
+	start_blk = 0;
+
+	if (emmckey_is_protected(mmc)) {
+		part_info = find_mmc_partition_by_name(MMC_RESERVED_NAME);
+		if (part_info == NULL) {
+			return 1;
+		}
+		blk = part_info->offset;
+		// it means: there should be other partitions before reserve-partition.
+		if (blk > 0)
+			blk -= PARTITION_RESERVED;
+		blk >>= blk_shift;
+		blk -= start_blk;
+		// (1) erase all the area before reserve-partition
+		if (blk > 0)
+			n = blk_derase(mmc_get_blk_desc(mmc), start_blk, blk);
+		if (n == 0) { // not error
+			// (2) erase all the area after reserve-partition
+			start_blk = (part_info->offset + part_info->size + PARTITION_RESERVED)
+						 >> blk_shift;
+			u64 erase_cnt = (mmc->capacity >> blk_shift) - start_blk;
+			n = blk_derase(mmc_get_blk_desc(mmc), start_blk, erase_cnt);
+		}
+	} else {
+		n = blk_derase(mmc_get_blk_desc(mmc), start_blk, 0); // erase the whole card
+	}
+	map = AML_BL_BOOT;
+	if (n == 0)
+		n = amlmmc_erase_bootloader(dev, map);
+	if (n)
+		printf("erase bootloader in boot partition failed\n");
+	return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_non_cache(int arc, char *const argv[])
+{
+	char *name = NULL;
+	int dev;
+	u32 n = 0;
+	int blk_shift;
+	u64 blk = 0, start_blk = 0;
+	struct partitions *part_info;
+	struct mmc *mmc;
+	int map;
+
+	name = "logo";
+	dev = find_dev_num_by_partition_name(name);
+	if (dev < 0) {
+		 printf("Cannot find dev.\n");
+		 return 1;
+	 }
+	 mmc = find_mmc_device(dev);
+	 if (!mmc)
+		 return 1;
+	 mmc_init(mmc);
+	 blk_shift = ffs(mmc->read_bl_len) -1;
+	 if (emmckey_is_protected(mmc)) {
+		 part_info = find_mmc_partition_by_name(MMC_RESERVED_NAME);
+		 if (part_info == NULL) {
+			 return 1;
+		 }
+
+		 blk = part_info->offset;
+		 // it means: there should be other partitions before reserve-partition.
+		if (blk > 0) {
+			blk -= PARTITION_RESERVED;
+		 }
+		 blk >>= blk_shift;
+		 blk -= start_blk;
+		 // (1) erase all the area before reserve-partition
+		 if (blk > 0) {
+			 n = blk_derase(mmc_get_blk_desc(mmc), start_blk, blk);
+			 // printf("(1) erase blk: 0 --> %llx %s\n", blk, (n == 0) ? "OK" : "ERROR");
+		 }
+		 if (n == 0) { // not error
+			 // (2) erase all the area after reserve-partition
+			 part_info = find_mmc_partition_by_name(MMC_CACHE_NAME);
+			 if (part_info == NULL) {
+				 return 1;
+			 }
+			 start_blk = (part_info->offset + part_info->size + PARTITION_RESERVED)
+						  >> blk_shift;
+			 u64 erase_cnt = (mmc->capacity >> blk_shift) - start_blk;
+			 n = blk_derase(mmc_get_blk_desc(mmc), start_blk, erase_cnt);
+		 }
+	 } else {
+		 n = blk_derase(mmc_get_blk_desc(mmc), start_blk, 0); // erase the whole card
+	 }
+	 map = AML_BL_BOOT;
+	 if (n == 0) {
+		 n = amlmmc_erase_bootloader(dev, map);
+		 if (n)
+			 printf("erase bootloader in boot partition failed\n");
+	 }
+	 return (n == 0) ? 0 : 1;
+}
+
+static int amlmmc_erase_dev(int argc, char *const argv[])
+{
+	return amlmmc_erase_whole(argc, argv);
+}
+
+static int amlmmc_erase_allbootloader(int argc, char*const argv[])
+{
+	int map;
+	int rc;
+	char *name = NULL;
+	int dev;
+	map = AML_BL_ALL;
+
+	name = "bootloader";
+	dev = find_dev_num_by_partition_name(name);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	rc = amlmmc_erase_bootloader(dev, map);
+	return rc;
+}
+
+static int amlmmc_erase_by_part(int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+
+	if (argc != 3)
+		return ret;
+
+	if (isdigit(argv[2][0]))
+		ret = amlmmc_erase_dev(argc, argv);
+	else if (strcmp(argv[2], "whole") == 0)
+		ret = amlmmc_erase_whole(argc, argv);
+	else if (strcmp(argv[2], "non_cache") == 0)
+		ret = amlmmc_erase_non_cache(argc, argv);
+	else if (strcmp(argv[2], "non_loader") == 0)
+		ret = amlmmc_erase_non_loader(argc, argv);
+	else if (strcmp(argv[2], "allbootloader") == 0)
+		ret = amlmmc_erase_allbootloader(argc, argv);
+	else
+		ret = amlmmc_erase_single_part(argc, argv);
+	return ret;
+}
+
+static int do_amlmmc_erase(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+
+	if (argc == 3)
+		ret = amlmmc_erase_by_part(argc, argv);
+	else if (argc == 5)
+		ret = amlmmc_erase_by_add(argc, argv);
+
+	return ret;
+}
+
+static int amlmmc_write_in_part(int argc, char *const argv[])
+{
+	int dev;
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+	char *name = NULL;
+	u64 offset = 0, size = 0;
+	//cpu_id_t cpu_id = get_cpu_id();
+	struct mmc *mmc;
+
+	name = argv[2];
+	if (strcmp(name, "bootloader") == 0)
+		dev = CONFIG_SYS_MMC_BOOT_DEV;
+	else
+		dev = find_dev_num_by_partition_name (name);
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	offset  = simple_strtoull(argv[4], NULL, 16);
+	size = simple_strtoull(argv[5], NULL, 16);
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+
+	if (strcmp(name, "bootloader") == 0) {
+		cnt = UBOOT_SIZE;
+		if (1) { //(cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+			blk = GXL_START_BLK;
+			cnt -= GXL_START_BLK;
+		}
+		else
+			blk = GXB_START_BLK;
+	} else
+		get_off_size(mmc, name, offset, size, &blk, &cnt, &sz_byte);
+
+	mmc_init(mmc);
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	//write sz_byte bytes
+	if ((n == cnt) && (sz_byte != 0)) {
+		// printf("sz_byte=%#llx bytes\n",sz_byte);
+		void *addr_tmp = malloc(mmc->write_bl_len);
+		void *addr_byte = (void*)(addr+cnt*(mmc->write_bl_len));
+		ulong start_blk = blk+cnt;
+
+		if (addr_tmp == NULL) {
+			printf("mmc write: malloc fail\n");
+			return 1;
+		}
+
+		if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+			free(addr_tmp);
+			printf("mmc read 1 block fail\n");
+			return 1;
+		}
+
+		memcpy(addr_tmp, addr_byte, sz_byte);
+		if (blk_dwrite(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // write 1 block
+			free(addr_tmp);
+			printf("mmc write 1 block fail\n");
+			return 1;
+		}
+		free(addr_tmp);
+	}
+	//printf("%#llx blocks , %#llx bytes written: %s\n", n, sz_byte, (n==cnt) ? "OK" : "ERROR");
+	return (n == cnt) ? 0 : 1;
+}
+
+static int amlmmc_write_in_card(int argc, char *const argv[])
+{
+	int dev;
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+	char *name = NULL;
+	u64 offset = 0, size = 0;
+	struct mmc *mmc;
+
+	name = argv[2];
+	dev = find_dev_num_by_partition_name (name);
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	offset  = simple_strtoull(argv[4], NULL, 16);
+	size = simple_strtoull(argv[5], NULL, 16);
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+
+	int blk_shift = ffs( mmc->read_bl_len) -1;
+	cnt = size >> blk_shift;
+	blk = offset >> blk_shift;
+	sz_byte = size - (cnt<<blk_shift);
+	 mmc_init(mmc);
+
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+
+	//write sz_byte bytes
+	if ((n == cnt) && (sz_byte != 0)) {
+		// printf("sz_byte=%#llx bytes\n",sz_byte);
+		void *addr_tmp = malloc(mmc->write_bl_len);
+		void *addr_byte = (void*)(addr+cnt*(mmc->write_bl_len));
+		ulong start_blk = blk+cnt;
+
+		if (addr_tmp == NULL) {
+			printf("mmc write: malloc fail\n");
+			return 1;
+		}
+
+		if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+			free(addr_tmp);
+			printf("mmc read 1 block fail\n");
+			return 1;
+		}
+
+		memcpy(addr_tmp, addr_byte, sz_byte);
+		if (blk_dwrite(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // write 1 block
+			free(addr_tmp);
+			printf("mmc write 1 block fail\n");
+			return 1;
+		}
+		free(addr_tmp);
+	}
+	//printf("%#llx blocks , %#llx bytes written: %s\n", n, sz_byte, (n==cnt) ? "OK" : "ERROR");
+	return (n == cnt) ? 0 : 1;
+}
+
+static int amlmmc_write_in_dev(int argc, char *const argv[])
+{
+	int dev;
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0;
+	struct mmc *mmc;
+	dev = simple_strtoul(argv[2], NULL, 10);
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	blk = simple_strtoull(argv[4], NULL, 16);
+	cnt = simple_strtoull(argv[5], NULL, 16);
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+
+	 //printf("MMC write: dev # %d, block # %#llx, count # %#llx ... ",
+	 //dev, blk, cnt);
+
+	mmc_init(mmc);
+
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	return (n == cnt) ? 0 : 1;
+}
+
+static int do_amlmmc_write(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = 0;
+	if (argc != 6)
+		return CMD_RET_USAGE;
+
+	if (isdigit(argv[2][0]))
+		ret = amlmmc_write_in_dev(argc, argv);
+	else if (strcmp(argv[2], "card") == 0)
+		ret = amlmmc_write_in_card(argc, argv);
+	else if (isstring(argv[2]))
+		ret = amlmmc_write_in_part(argc, argv);
+
+	return ret;
+}
+
+static int amlmmc_read_in_dev(int argc, char *const argv[])
+{
+	int dev;
+	void *addr = NULL;
+	u64 cnt =0, n = 0, blk = 0;
+	struct mmc *mmc;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	blk = simple_strtoull(argv[4], NULL, 16);
+	cnt = simple_strtoull(argv[5], NULL, 16);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	return (n == cnt) ? 0 : 1;
+}
+
+static int amlmmc_read_in_card(int argc, char *const argv[])
+{
+	int dev;
+	void *addr = NULL;
+	//u32 flag =0;
+	u64 cnt =0, n = 0, blk = 0, sz_byte = 0;
+	char *name = NULL;
+	u64 offset = 0, size = 0;
+	int blk_shift;
+	struct mmc *mmc;
+	void *addr_tmp;
+	void *addr_byte;
+	ulong start_blk;
+
+	name = argv[2];
+	dev = find_dev_num_by_partition_name (name);
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	size = simple_strtoull(argv[5], NULL, 16);
+	offset = simple_strtoull(argv[4], NULL, 16);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+
+	blk_shift = ffs( mmc->read_bl_len) - 1;
+	cnt = size >> blk_shift;
+	blk = offset >> blk_shift;
+	sz_byte = size - (cnt<<blk_shift);
+
+	mmc_init(mmc);
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+
+	//read sz_byte bytes
+	if ((n == cnt) && (sz_byte != 0)) {
+	   addr_tmp = malloc(mmc->read_bl_len);
+	   addr_byte = (void *)(addr+cnt*(mmc->read_bl_len));
+	   start_blk = blk+cnt;
+	   if (addr_tmp == NULL) {
+		   printf("mmc read: malloc fail\n");
+		   return 1;
+	   }
+	   if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+		   free(addr_tmp);
+		   printf("mmc read 1 block fail\n");
+		   return 1;
+	   }
+	   memcpy(addr_byte, addr_tmp, sz_byte);
+	   free(addr_tmp);
+	}
+	return (n == cnt) ? 0 : 1;
+}
+
+static int amlmmc_read_in_part(int argc, char *const argv[])
+{
+	int dev;
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+	char *name = NULL;
+	u64 offset = 0, size = 0;
+	struct mmc *mmc;
+	void *addr_tmp;
+	void *addr_byte;
+	ulong start_blk;
+
+	name = argv[2];
+	dev = find_dev_num_by_partition_name (name);
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	offset = simple_strtoull(argv[4], NULL, 16);
+	size = simple_strtoull(argv[5], NULL, 16);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+
+	get_off_size(mmc, name, offset, size, &blk, &cnt, &sz_byte);
+	mmc_init(mmc);
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+
+	//read sz_byte bytes
+	if ((n == cnt) && (sz_byte != 0)) {
+	   /*printf("sz_byte=%#llx bytes\n",sz_byte);*/
+	   addr_tmp = malloc(mmc->read_bl_len);
+	   addr_byte = (void *)(addr+cnt*(mmc->read_bl_len));
+	   start_blk = blk+cnt;
+
+	   if (addr_tmp == NULL) {
+		   printf("mmc read: malloc fail\n");
+		   return 1;
+	   }
+
+	   if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+		   free(addr_tmp);
+		   printf("mmc read 1 block fail\n");
+		   return 1;
+	   }
+
+	   memcpy(addr_byte, addr_tmp, sz_byte);
+	   free(addr_tmp);
+	}
+	return (n == cnt) ? 0 : 1;
+}
+
+static int do_amlmmc_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = 0;
+	if (argc != 6)
+		return CMD_RET_USAGE;
+
+	if (isdigit(argv[2][0]))
+		ret = amlmmc_read_in_dev(argc, argv);
+	else if (strcmp(argv[2], "card") == 0)
+		ret = amlmmc_read_in_card(argc, argv);
+	else if (isstring(argv[2]))
+		ret = amlmmc_read_in_part(argc, argv);
+
+	return ret;
+}
+
+static int do_amlmmc_env(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	printf("herh\n");
+	env_relocate();
+	return 0;
+}
+
+static int do_amlmmc_list(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	print_mmc_devices('\n');
+	return 0;
+}
+
+static int do_amlmmc_size(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	char *name;
+	uint64_t* addr = NULL;
+	int dev;
+	struct mmc *mmc = NULL;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	name = argv[2];
+	addr = (uint64_t *)simple_strtoul(argv[3], NULL, 16);
+	if (!strcmp(name, "wholeDev")) {
+		dev = CONFIG_SYS_MMC_BOOT_DEV;
+		mmc = find_mmc_device(dev);
+		if (!mmc) {
+			puts("no mmc devices available\n");
+			return 1;
+		}
+		mmc_init(mmc);
+
+		*addr = mmc->capacity >> 9; // unit: 512 bytes
+		return 0;
+	}
+	return get_partition_size((unsigned char *)name, addr);
+}
+
+static int amlmmc_get_ext_csd(int argc, char *const argv[])
+{
+	int ret= 0;
+	u8 ext_csd[512] = {0};
+	int dev, byte;
+	struct mmc *mmc;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	byte = simple_strtoul(argv[3], NULL, 10);
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+	mmc_init(mmc);
+	ret = mmc_get_ext_csd(mmc, ext_csd);
+	printf("read EXT_CSD byte[%d] val[0x%x] %s\n",
+			byte, ext_csd[byte], (ret == 0) ? "ok" : "fail");
+	ret = ret || ret;
+	return ret;
+}
+
+static int amlmmc_set_ext_csd(int argc, char *const argv[])
+{
+	int ret = 0;
+	int dev, byte;
+	struct mmc *mmc;
+	int val;
+
+	if (argc != 5)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	byte = simple_strtoul(argv[3], NULL, 10);
+	val = simple_strtoul(argv[4], NULL, 16);
+	if ((byte > 191) || (byte < 0)) {
+		printf("byte is not able to write!\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	mmc_init(mmc);
+
+	ret = mmc_set_ext_csd(mmc, byte, val);
+	printf("write EXT_CSD byte[%d] val[0x%x] %s\n",
+			byte, val, (ret == 0) ? "ok" : "fail");
+	ret =ret || ret;
+	return ret;
+}
+
+static int do_amlmmc_ext_csd(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+
+	if (argc == 4)
+		ret = amlmmc_get_ext_csd(argc,argv);
+	else if (argc == 5)
+		ret = amlmmc_set_ext_csd(argc,argv);
+
+	return ret;
+}
+
+static int do_amlmmc_switch(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int rc = 0;
+	int dev;
+	struct mmc *mmc;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	mmc_init(mmc);
+	printf("mmc switch to ");
+
+	if (strcmp(argv[3], "boot0") == 0) {
+		rc = mmc_switch_part(mmc, 1);
+		if (rc == 0) {
+			emmc_cur_partition = 1;
+			printf("boot0 success\n");
+		} else {
+			printf("boot0 failed\n");
+		}
+	}
+	else if(strcmp(argv[3], "boot1") == 0) {
+		rc = mmc_switch_part(mmc, 2);
+		if (rc == 0) {
+			emmc_cur_partition = 2;
+			printf("boot1 success\n");
+		} else {
+			printf("boot1 failed\n");
+		}
+	}
+	else if(strcmp(argv[3], "user") == 0) {
+		rc = mmc_switch_part(mmc, 0);
+		if (rc == 0) {
+			emmc_cur_partition = 0;
+			printf("user success\n");
+		} else {
+			printf("user failed\n");
+	   }
+	}
+#ifdef CONFIG_SUPPORT_EMMC_RPMB
+	else if(strcmp(argv[3], "rpmb") == 0) {
+		rc = mmc_switch_part(mmc, 3);
+		if (rc == 0) {
+			emmc_cur_partition = 3;
+			printf("rpmb success\n");
+		} else {
+			printf("rpmb failed\n");
+		}
+	}
+#endif
+	else
+		printf("%s failed\n", argv[3]);
+	return rc;
+}
+
+static int do_amlmmc_controller(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	/*int dev;
+	struct mmc *mmc;
+	struct aml_card_sd_info *aml_priv;
+	struct sd_emmc_global_regs *sd_emmc_reg;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+
+	aml_priv = mmc->priv;
+	sd_emmc_reg = aml_priv->sd_emmc_reg;
+
+	printf("sd_emmc_reg->gclock = 0x%x\n", sd_emmc_reg->gclock);
+	printf("sd_emmc_reg->gdelay = 0x%x\n", sd_emmc_reg->gdelay);
+	printf("sd_emmc_reg->gadjust = 0x%x\n", sd_emmc_reg->gadjust);
+	printf("sd_emmc_reg->gcalout = 0x%x\n", sd_emmc_reg->gcalout);
+	if (!mmc->has_init) {
+		printf("mmc dev %d has not been initialed\n", dev);
+		return 1;
+	}
+	printf("sd_emmc_reg->gstart = 0x%x\n", sd_emmc_reg->gstart);
+	printf("sd_emmc_reg->gcfg = 0x%x\n", sd_emmc_reg->gcfg);
+	printf("sd_emmc_reg->gstatus = 0x%x\n", sd_emmc_reg->gstatus);
+	printf("sd_emmc_reg->girq_en = 0x%x\n", sd_emmc_reg->girq_en);
+	printf("sd_emmc_reg->gcmd_cfg = 0x%x\n", sd_emmc_reg->gcmd_cfg);
+	printf("sd_emmc_reg->gcmd_arg = 0x%x\n", sd_emmc_reg->gcmd_arg);
+	printf("sd_emmc_reg->gcmd_dat = 0x%x\n", sd_emmc_reg->gcmd_dat);
+	printf("sd_emmc_reg->gcmd_rsp0 = 0x%x\n", sd_emmc_reg->gcmd_rsp0);
+	printf("sd_emmc_reg->gcmd_rsp1 = 0x%x\n", sd_emmc_reg->gcmd_rsp1);
+	printf("sd_emmc_reg->gcmd_rsp2 = 0x%x\n", sd_emmc_reg->gcmd_rsp2);
+	printf("sd_emmc_reg->gcmd_rsp3 = 0x%x\n", sd_emmc_reg->gcmd_rsp3);*/
+	return 0;
+}
+
+static int do_amlmmc_response(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	/*int dev;
+	struct mmc *mmc;
+	struct aml_card_sd_info *aml_priv;
+	struct sd_emmc_global_regs *sd_emmc_reg;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+	if (!mmc->has_init) {
+		printf("mmc dev %d has not been initialed\n", dev);
+		return 1;
+	}
+
+	aml_priv = mmc->priv;
+	sd_emmc_reg = aml_priv->sd_emmc_reg;
+
+	printf("last cmd = %d, response0 = 0x%x\n",
+		(sd_emmc_reg->gcmd_cfg & 0x3f), sd_emmc_reg->gcmd_rsp0);*/
+	return 0;
+}
+
+static int do_amlmmc_status(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int rc = 0;
+	int dev;
+	struct mmc *mmc;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+	if (!mmc->has_init) {
+		printf("mmc dev %d has not been initialed\n", dev);
+		return 1;
+	}
+	rc = mmc_read_status(mmc, 1000);
+	if (rc)
+		return 1;
+	else
+		return 0;
+}
+
+static int do_amlmmc_part(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int dev;
+	struct blk_desc *mmc_dev;
+	struct mmc *mmc;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+	mmc_init(mmc);
+	mmc_dev = mmc_get_blk_desc(mmc);
+	if (mmc_dev != NULL &&
+		mmc_dev->type != DEV_TYPE_UNKNOWN) {
+		part_print(mmc_dev);
+		return 0;
+	}
+	puts("get mmc type error!\n");
+	return 1;
+}
+
+static int do_amlmmc_rescan(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int dev;
+	struct mmc *mmc;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+
+	if (dev < 0) {
+		printf("Cannot find dev.\n");
+		return 1;
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+			return 1;
+	mmc->has_init =0;
+	return mmc_init(mmc);
+}
+
+#ifdef CONFIG_SECURITYKEY
+static int do_amlmmc_key(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	struct mmc *mmc;
+	int dev;
+
+	//char *name = "logo";
+	dev = CONFIG_SYS_MMC_BOOT_DEV;
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		printf("device %d is invalid\n",dev);
+		return 1;
+	}
+	//mmc->key_protect = 0;
+#ifdef CONFIG_STORE_COMPATIBLE
+	info_disprotect |= DISPROTECT_KEY;  //disprotect
+	printf("emmc disprotect key\n");
+#endif
+	return 0;
+}
+#endif
+
+static int set_write_prot(struct mmc *mmc, u64 start)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	cmd.cmdidx = MMC_CMD_SET_WRITE_PROTECT;
+	cmd.cmdarg = start;
+	cmd.resp_type = MMC_RSP_R1b;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	puts("Failed: mmc write protect failed\n");
+	return err;
+}
+
+static int set_us_wp_en(struct mmc *mmc, u8 *ext_csd, u8 wp_enable_type)
+{
+	u8 index = EXT_CSD_USER_WP;
+	u8 user_wp = ext_csd[index];
+	user_wp = user_wp & (~WP_ENABLE_MASK);
+	user_wp = user_wp | wp_enable_type;
+	int err = 0;
+	err = mmc_set_ext_csd(mmc, index, user_wp);
+	if (err)
+		printf("Failed: set write protect enable failed\n");
+	return err;
+}
+
+static int mmc_set_us_perm_wp_dis(struct mmc *mmc, u8 *ext_csd)
+{
+	u8 usr_wp = ext_csd[EXT_CSD_USER_WP];
+	u8 perm_disable_bit = US_PERM_WP_DIS_BIT;
+
+	int err;
+	if (usr_wp & perm_disable_bit)
+		return 0;
+
+	usr_wp = usr_wp | perm_disable_bit;
+	err = mmc_set_ext_csd(mmc, EXT_CSD_USER_WP, usr_wp);
+	if (err) {
+		printf("Failed: set permanent write protect disable failed\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int mmc_is_us_pwr_wp_dis(u8 user_wp)
+{
+   return user_wp & US_PWR_WP_DIS_BIT;
+}
+
+static int mmc_is_us_perm_wp_dis(u8 user_wp)
+{
+   return user_wp & US_PERM_WP_DIS_BIT;
+}
+
+static int check_wp_type(u8 *addr, u8 wp_type, u64 set_protect_cnt)
+{
+	u8 type_mask = WP_TYPE_MASK;
+	u64 cnt = set_protect_cnt;
+	u8 times = 0;
+	u8 index = 7;
+	u8 cur_group_wp_type = addr[index];
+
+	while (cnt != 0) {
+		if (wp_type != ((type_mask)&(cur_group_wp_type))) {
+			return 1;
+		}
+		if (times == 3) {
+			times = 0;
+			index--;
+			cur_group_wp_type = addr[index];
+		}
+		else {
+			cur_group_wp_type = cur_group_wp_type >> 2;
+			times++;
+		}
+		cnt--;
+	}
+	return 0;
+}
+
+static int set_register_to_temporary(struct mmc *mmc, u8 *ext_csd)
+{
+	int err;
+	u8 wp_enable_type = WP_TEMPORARY_EN_BIT;
+	err = set_us_wp_en(mmc, ext_csd, wp_enable_type);
+	if (err)
+		printf("Failed: set temporary write protect failed\n");
+	return err;
+}
+
+static int set_register_to_pwr(struct mmc *mmc, u8 *ext_csd)
+{
+	int err;
+	u8 user_wp = ext_csd[EXT_CSD_USER_WP];
+	u8 wp_enable_type = WP_POWER_ON_EN_BIT;
+	if (mmc_is_us_pwr_wp_dis(user_wp)) {
+		printf("Failed: power on protection had been disabled\n");
+		return 1;
+	}
+
+	err = mmc_set_us_perm_wp_dis(mmc, ext_csd);
+	if (err) {
+		printf("Failed: set permanent protection diable failed\n");
+		return 1;
+	}
+
+	err = set_us_wp_en(mmc, ext_csd, wp_enable_type);
+	if (err) {
+		printf("Failed: set power on write protect enable failed\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int set_register_to_perm(struct mmc *mmc, u8 *ext_csd)
+{
+	int err;
+	u8 wp_enable_type = WP_PERM_EN_BIT;
+	u8 user_wp = ext_csd[EXT_CSD_USER_WP];
+
+	if (mmc_is_us_perm_wp_dis(user_wp)) {
+		printf("Failed: Permanent protection had been disabled\n");
+		return 1;
+	}
+
+	err = set_us_wp_en(mmc, ext_csd, wp_enable_type);
+	if (err) {
+		printf("Failed: set permanent write protect enable failed\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int set_wp_register(struct mmc *mmc, u8 *ext_csd, u8 wp_type)
+{
+	int ret = 1;
+	if (wp_type == WP_POWER_ON_TYPE)
+		ret = set_register_to_pwr(mmc, ext_csd);
+	else if (wp_type == WP_PERMANENT_TYPE)
+		ret = set_register_to_perm(mmc, ext_csd);
+	else if (wp_type == WP_TEMPORARY_TYPE)
+		ret = set_register_to_temporary(mmc, ext_csd);
+	return ret;
+}
+
+static u64 write_protect_group_size(struct mmc *mmc, u8 *ext_csd)
+{
+	int erase_group_def = ext_csd[EXT_CSD_ERASE_GROUP_DEF];
+	u64 write_protect_group_size;
+	int wp_grp_size = mmc->csd[2] & WP_GRP_SIZE_MASK;
+	int hc_wp_grp_size = ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+
+	if (erase_group_def == 0)
+		write_protect_group_size = (wp_grp_size + 1) * mmc->erase_grp_size;
+	else
+		write_protect_group_size =  hc_wp_grp_size * mmc->erase_grp_size;
+
+	return write_protect_group_size;
+}
+
+int is_write_protect_valid(u8 *ext_csd)
+{
+	u8 class_6_ctrl = ext_csd[EXT_CSD_CLASS_6_CTRL];
+	if (class_6_ctrl == 0)
+		return 1;
+	return 0;
+}
+
+static int compute_write_protect_range(struct mmc *mmc, char *name,
+		u8 *ext_csd, u64 *wp_grp_size_addr, u64 *start_addr, u64 *end)
+{
+	int blk_shift;
+	struct partitions *part_info;
+	u64 cnt;
+	u64 start = *start_addr;
+	u64 align_start = *start_addr;
+	u64 wp_grp_size = *wp_grp_size_addr;
+	u64 group_num ;
+	u64 partition_end;
+
+	wp_grp_size = write_protect_group_size(mmc, ext_csd);
+
+	blk_shift = ffs(mmc->read_bl_len) -1;
+
+	part_info = find_mmc_partition_by_name(name);
+	if (part_info == NULL)
+		return 1;
+
+	start = part_info->offset >> blk_shift;
+	printf("start:%d   wp_grp_size:%d",(int)start,(int)wp_grp_size);
+	if ((start % wp_grp_size)) {
+		align_start = (start + wp_grp_size - 1) / wp_grp_size * wp_grp_size;
+		printf("Caution! The partition start address isn't' aligned"
+				"to group size\n"
+			   "the start address is change from 0x%llx to 0x%llx\n",
+			   start, align_start);
+	} else {
+		align_start = start;
+	}
+	if (emmc_cur_partition && !strncmp(name, "bootloader", strlen("bootloader")))
+		cnt =0;
+	else
+	cnt = part_info->size >> blk_shift;
+	if (cnt < wp_grp_size) {
+		printf("Caution: The partition size is 0x%llx sector smaller than "
+				"the group size 0x%llx sector, \n"
+				"so the partition can't be protect\n", cnt, wp_grp_size);
+		return 1;
+	}
+
+	*start_addr = align_start;
+	*wp_grp_size_addr = wp_grp_size;
+	partition_end = start + cnt - 1;
+	group_num = (cnt - (align_start - start)) / wp_grp_size;
+	*end = align_start + group_num * wp_grp_size - 1;
+
+	if (partition_end != *end) {
+		printf("Caution! The boundary of partition isn't aligned with write "
+				"protected group,\n"
+				"so the write protected boundry of the "
+				"partition is 0x%llx, rather than 0x%llx\n",
+				*end, partition_end);
+	}
+
+	printf("write_protect group size is 0x%llx sector\n", wp_grp_size);
+	printf("The %s partition write protect group number is %lld\n", name, group_num);
+#ifdef WP_DEBUG
+	printf("the start address is 0x%llx, group size is 0x%llx, end is 0x%llx\n",
+		   *start_addr, *wp_grp_size_addr, *end);
+#endif
+	return 0;
+}
+
+static int send_wp_prot_type(struct mmc *mmc, void *dst, u64 blk)
+{
+	struct mmc_cmd cmd;
+	int err;
+	struct mmc_data data;
+
+	cmd.cmdidx = MMC_CMD_SEND_WRITE_PROT_TYPE;
+	cmd.cmdarg = blk;
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = dst;
+	data.blocks = 1;
+	data.blocksize = 8;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	puts("Failed: mmc send write protect type failed\n");
+	return err;
+}
+
+static int is_wp_set_failed(struct mmc *mmc, u8 wp_type, u64 start, u64 group_cnt)
+{
+	u8 *addr = NULL;
+	u8 err = 0;
+
+	addr = malloc(sizeof(u64));
+	if (addr == NULL) {
+		printf("Failed: malloc failed\n");
+		return 1;
+	}
+
+	err = send_wp_prot_type(mmc, addr, start);
+	if (err)
+		goto err_out;
+
+#ifdef WP_DEBUG
+	int  i;
+	for (i = 0; i < 8; i++)
+		printf("write_protect status is %x\n", ((u8 *)addr)[i]);
+#endif
+	if (check_wp_type(addr, wp_type, group_cnt)) {
+		printf("Failed: Write Protection set failed\n");
+		goto err_out;
+	}
+	return 0;
+
+err_out:
+	free(addr);
+	return 1;
+}
+
+static int send_part_wp_type(struct mmc *mmc, char *name)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	u64 wp_grp_size, start, part_end;
+	u64 group_start;
+	void *addr = NULL;
+	int i;
+	int ret;
+
+	ret = mmc_get_ext_csd(mmc, ext_csd);
+	if (ret) {
+		printf("Failed: get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("Failed: CLASS_6_CTRL isn't '0' "
+				"write protect process is invalid\n");
+		return 1;
+	}
+
+	addr = malloc(sizeof(u64));
+	if (addr == NULL) {
+		printf("Failed: malloc failed\n");
+		return 1;
+	}
+
+	err = compute_write_protect_range(mmc, name, ext_csd,
+			&wp_grp_size, &start, &part_end);
+	if (err)
+		return 1;
+
+	group_start = start;
+
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = send_wp_prot_type(mmc, addr, group_start);
+		if (err)
+			return 1;
+		printf("The write protect type for the 32 groups after 0x%llx is: \n0x",
+				group_start);
+		for (i = 0; i < 8; i++)
+			printf("%02x", ((u8*)addr)[i]);
+		printf("\n");
+		group_start += 32 * wp_grp_size;
+	}
+	return 0;
+}
+
+static int send_add_wp_type(struct mmc *mmc, u64 start, u64 cnt)
+{
+	u8 ext_csd[512] = {0};
+	u64 wp_grp_size = 0;
+	u64 part_end = 0;
+	u64 group_start;
+	u64 mmc_boundary;
+	int blk_shift;
+	void *addr = NULL;
+	int i;
+	int ret;
+
+	ret = mmc_get_ext_csd(mmc, ext_csd);
+	if (ret) {
+		printf("Failed: get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("Failed: CLASS_6_CTRL isn't '0' "
+				"write protect process is invalid\n");
+		return 1;
+	}
+
+	addr = malloc(sizeof(u64));
+	if (addr == NULL) {
+		printf("Failed: malloc failed\n");
+		return 1;
+	}
+
+	wp_grp_size = write_protect_group_size(mmc, ext_csd);
+
+   if ((start % wp_grp_size)) {
+		group_start = (start + wp_grp_size - 1) / wp_grp_size * wp_grp_size;
+		printf("Caution! The partition start address isn't' aligned"
+				"to group size\n"
+			   "the start address is change from 0x%llx to 0x%llx\n",
+			   start, group_start);
+		part_end = group_start + (cnt - 1) * wp_grp_size - 1;
+		printf("The write protect group number is 0x%llx, rather than 0x%lld\n",
+				cnt - 1, cnt);
+	} else {
+		group_start = start;
+		part_end = group_start + cnt * wp_grp_size - 1;
+	}
+
+	blk_shift = ffs(mmc->read_bl_len) - 1;
+	mmc_boundary = mmc->capacity>>blk_shift;
+
+	if ((part_end + 1) > mmc_boundary) {
+		printf("Error: the operation cross the boundary of mmc\n");
+		return 1;
+	}
+
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		ret = send_wp_prot_type(mmc, addr, group_start);
+		if (ret)
+			return 1;
+		printf("The write protect type for the 32 groups after 0x%llx is: \n0x",
+				group_start);
+		for (i = 0; i < 8; i++)
+			printf("%02x", ((u8*)addr)[i]);
+		printf("\n");
+		group_start += 32 * wp_grp_size;
+	}
+	return 0;
+}
+
+static int set_part_write_protect(struct mmc *mmc, u8 wp_type, char *name)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	u8 group_num  = 32;
+	u64 wp_grp_size, start, part_end;
+	u64 group_start;
+	u64 check_group_start;
+	u64 set_protect_cnt = 0;
+
+	err = mmc_get_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("Failed: get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("Failed: CLASS_6_CTRL isn't '0' "
+				"write protect process is invalid\n");
+		return 1;
+	}
+
+	err = compute_write_protect_range(mmc, name, ext_csd,
+			&wp_grp_size, &start, &part_end);
+	if (err)
+		return 1;
+
+	group_start = start;
+	err = set_wp_register(mmc, ext_csd, wp_type);
+	if (err)
+		return 1;
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = set_write_prot(mmc, group_start);
+		if (err)
+			return 1;
+		group_start += wp_grp_size;
+		set_protect_cnt++;
+//check write protect type every 32 group
+		if (set_protect_cnt % 32 == 0) {
+			check_group_start = group_start -  group_num * wp_grp_size;
+			err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+			if (err)
+				return 1;
+		}
+	}
+
+	group_num = set_protect_cnt % 32;
+	check_group_start = group_start - group_num * wp_grp_size;
+
+	if (group_num) {
+		err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+		if (err)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int set_add_write_protect(struct mmc *mmc, u8 wp_type, u64 start, u64 cnt)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	int group_num = 32;
+	u64 wp_grp_size, part_end;
+	u64 group_start;
+	u64 check_group_start;
+	u64 set_protect_cnt = 0;
+	u64 mmc_boundary = 0;
+	int blk_shift;
+	err = mmc_get_ext_csd(mmc, ext_csd);
+
+	if (err) {
+		printf("Failed: get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("Failed: CLASS_6_CTRL isn't '0' "
+				"write protect process is invalid\n");
+		return 1;
+	}
+
+	if (err)
+		return 1;
+
+	wp_grp_size = write_protect_group_size(mmc, ext_csd);
+
+	if ((start % wp_grp_size)) {
+	  group_start = (start + wp_grp_size - 1) / wp_grp_size * wp_grp_size;
+	  printf("Caution! The partition start address isn't' aligned"
+			  "to group size\n"
+			 "the start address is change from 0x%llx to 0x%llx\n",
+			 start, group_start);
+	  part_end = group_start + (cnt - 1) * wp_grp_size - 1;
+	  printf("The write protect group number is 0x%llx, rather than 0x%lld\n",
+			  cnt - 1, cnt);
+	} else {
+	  group_start = start;
+	  part_end = group_start + cnt * wp_grp_size - 1;
+	}
+
+	blk_shift = ffs(mmc->read_bl_len) - 1;
+	mmc_boundary = mmc->capacity>>blk_shift;
+
+	if ((part_end + 1) > mmc_boundary) {
+		printf("Error: the operation cross the boundary of mmc\n");
+		return 1;
+	}
+
+	err = set_wp_register(mmc, ext_csd, wp_type);
+	if (err)
+		return 1;
+
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = set_write_prot(mmc, group_start);
+		if (err)
+			return 1;
+		group_start += wp_grp_size;
+		set_protect_cnt++;
+//check write protect type every 32 group
+		if (set_protect_cnt % 32 == 0) {
+			check_group_start = group_start -  group_num * wp_grp_size;
+			err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+			if (err)
+				return 1;
+		}
+	}
+
+	group_num = set_protect_cnt % 32;
+	check_group_start = group_start - group_num * wp_grp_size;
+
+	if (group_num) {
+		err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+		if (err)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int do_amlmmc_write_protect(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+	struct mmc *mmc;
+	int dev = 1;
+	char *name = NULL;
+	char *wp_type_str = NULL;
+	u8 write_protect_type;
+	u64 start, cnt;
+
+	if (argc > 5 || argc < 4)
+		return ret;
+	if (argc == 4) {
+		name = argv[2];
+		wp_type_str = argv[3];
+		dev = find_dev_num_by_partition_name(name);
+		if (dev < 0) {
+			printf("Error: Cannot find dev.\n");
+			return CMD_RET_USAGE;
+		}
+	} else {
+		start = simple_strtoull(argv[2], NULL, 16);
+		cnt = simple_strtoull(argv[3], NULL, 0);
+		wp_type_str = argv[4];
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (IS_SD(mmc)) {
+		mmc = find_mmc_device(~dev);
+		if (IS_SD(mmc)) {
+			printf("SD card can not be write protect\n");
+			return 1;
+		}
+	}
+
+	if (!mmc)
+		return 1;
+
+	mmc_init(mmc);
+	if (!mmc)
+		return 1;
+
+	if (strcmp(wp_type_str, "temporary") == 0)
+		write_protect_type = WP_TEMPORARY_TYPE;
+	else if (strcmp(wp_type_str, "power_on") == 0 )
+		write_protect_type = WP_POWER_ON_TYPE;
+	else if (strcmp(wp_type_str, "permanent") == 0)
+		write_protect_type = WP_PERMANENT_TYPE;
+	else
+		return ret;
+
+	if (argc == 4)
+		ret = set_part_write_protect(mmc, write_protect_type, name);
+	else
+		ret = set_add_write_protect(mmc, write_protect_type, start, cnt);
+
+	return ret;
+}
+
+static int clear_write_prot_per_group(struct mmc *mmc, u64 blk)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	cmd.cmdidx = MMC_CMD_CLR_WRITE_PROT;
+	cmd.cmdarg = blk;
+	cmd.resp_type = MMC_RSP_R1b;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	return err;
+}
+
+static int set_part_clear_wp(struct mmc *mmc, char *name)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	u8 group_num  = 32;
+	u64 wp_grp_size, start, part_end;
+	u64 group_start;
+	u64 check_group_start;
+	u64 set_protect_cnt = 0;
+	u8 wp_type = WP_CLEAR_TYPE;
+
+	err = mmc_get_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("CLASS_6_CTRL isn't '0' write protect process is invalid\n");
+		return 1;
+	}
+
+	err = compute_write_protect_range(mmc, name, ext_csd,
+			&wp_grp_size, &start, &part_end);
+	if (err)
+		return 1;
+
+	group_start = start;
+/*
+	if (!is_wp_type_temporary(ext_csd)) {
+		printf("The write protect can't be clear\n");
+		return 1;
+	}
+*/
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = clear_write_prot_per_group(mmc, group_start);
+		if (err) {
+			printf("Error: The write protect can't be clear\n");
+			return 1;
+		}
+		group_start += wp_grp_size;
+		set_protect_cnt++;
+//check write protect type every 32 group
+		if (set_protect_cnt % 32 == 0) {
+			check_group_start = group_start -  group_num * wp_grp_size;
+			err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+			if (err)
+				return 1;
+		}
+	}
+
+	group_num = set_protect_cnt % 32;
+	check_group_start = group_start - group_num * wp_grp_size;
+
+	if (group_num) {
+		err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+		if (err)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int set_add_clear_wp(struct mmc *mmc, u64 start, u64 cnt)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	u8 group_num  = 32;
+	u64 wp_grp_size, part_end;
+	u64 group_start;
+	u64 check_group_start;
+	u64 set_protect_cnt = 0;
+	u8 wp_type = WP_CLEAR_TYPE;
+	int blk_shift;
+	u64 mmc_boundary;
+
+	err = mmc_get_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("CLASS_6_CTRL isn't '0' write protect process is invalid\n");
+		return 1;
+	}
+
+	wp_grp_size = write_protect_group_size(mmc, ext_csd);
+
+	if ((start % wp_grp_size)) {
+		 group_start = (start + wp_grp_size - 1) / wp_grp_size * wp_grp_size;
+		 printf("Caution! The partition start address isn't' aligned"
+				 "to group size\n"
+				"the start address is change from 0x%llx to 0x%llx\n",
+				start, group_start);
+		 part_end = group_start + (cnt - 1) * wp_grp_size - 1;
+		 printf("The write protect group number is 0x%llx, rather than 0x%lld\n",
+				 cnt - 1, cnt);
+	 } else {
+		 group_start = start;
+		 part_end = group_start + cnt * wp_grp_size - 1;
+	 }
+
+	 blk_shift = ffs(mmc->read_bl_len) - 1;
+	 mmc_boundary = mmc->capacity>>blk_shift;
+
+	 if ((part_end + 1) > mmc_boundary) {
+		 printf("Error: the operation cross the boundary of mmc\n");
+		 return 1;
+	 }
+
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = clear_write_prot_per_group(mmc, group_start);
+		if (err) {
+			printf("Error: The write protect can't be clear\n");
+			return 1;
+		}
+		group_start += wp_grp_size;
+		set_protect_cnt++;
+//check write protect type every 32 group
+		if (set_protect_cnt % 32 == 0) {
+			check_group_start = group_start -  group_num * wp_grp_size;
+			err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+			if (err)
+				return 1;
+		}
+	}
+
+	group_num = set_protect_cnt % 32;
+	check_group_start = group_start - group_num * wp_grp_size;
+
+	if (group_num) {
+		err = is_wp_set_failed(mmc, wp_type, check_group_start, group_num);
+		if (err)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int do_amlmmc_clear_wp(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+	struct mmc *mmc;
+	int dev = 1;
+	char *name = NULL;
+	u64 start, cnt;
+
+	if (argc < 3 || argc > 4)
+		return ret;
+
+	if (argc == 3) {
+		 name = argv[2];
+		 dev = find_dev_num_by_partition_name(name);
+		 if (dev < 0) {
+			 printf("Error: Cannot find dev.\n");
+			 return CMD_RET_USAGE;
+		 }
+	 } else {
+		 start = simple_strtoull(argv[2], NULL, 16);
+		 cnt = simple_strtoull(argv[3], NULL, 10);
+	 }
+
+	mmc = find_mmc_device(dev);
+	if (!mmc)
+		return 1;
+
+	if (IS_SD(mmc)) {
+		mmc = find_mmc_device(~dev);
+		if (IS_SD(mmc)) {
+			printf("SD card can not be write protect\n");
+			return 1;
+		}
+	}
+
+	mmc_init(mmc);
+	if (!mmc)
+		return 1;
+
+	if (argc == 3)
+		ret = set_part_clear_wp(mmc, name);
+	else
+		ret = set_add_clear_wp(mmc, start, cnt);
+
+	return ret;
+}
+
+static int send_write_prot_status_group(struct mmc *mmc, u64 blk)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+	void *addr = NULL;
+	int i = 0;
+	addr = malloc(4*sizeof(u8));
+
+	if (addr == NULL) {
+		printf("Failed: malloc failed\n");
+		return 1;
+	}
+
+	cmd.cmdidx = MMC_CMD_SEND_WRITE_PROT;
+	cmd.cmdarg = blk;
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = addr;
+	data.blocks = 1;
+	data.blocksize = 4;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err)
+		goto err_out;
+
+	printf("The write protect type for the 32 groups after 0x%llx is:\n0x",
+			blk);
+	for (i = 0 ; i < 4; i++)
+		printf("%02x", ((u8 *)addr)[i]);
+	printf("\n");
+
+	free(addr);
+	return 0;
+err_out:
+	free(addr);
+	return 1;
+}
+
+static int send_part_wp_status(struct mmc *mmc, char *name)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	u64 wp_grp_size, start, part_end;
+	u64 group_start;
+
+	err = mmc_get_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("Failed: get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("Failed: CLASS_6_CTRL isn't '0' "
+				"write protect process is invalid\n");
+		return 1;
+	}
+
+	err = compute_write_protect_range(mmc, name, ext_csd,
+			&wp_grp_size, &start, &part_end);
+	if (err)
+		return 1;
+
+	group_start = start;
+
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = send_write_prot_status_group(mmc, group_start);
+		if (err)
+			return 1;
+		group_start += 32 * wp_grp_size;
+	}
+
+	return 0;
+}
+
+static int send_add_wp_status(struct mmc *mmc, u64 start, u64 cnt)
+{
+	int err = 0;
+	u8 ext_csd[512] = {0};
+	u64 wp_grp_size, part_end;
+	u64 group_start;
+	int blk_shift;
+	u64 mmc_boundary;
+	err = mmc_get_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("Failed: get ext_csd failed\n");
+		return 1;
+	}
+
+	if (!is_write_protect_valid(ext_csd)) {
+		printf("Failed: CLASS_6_CTRL isn't '0' "
+				"write protect process is invalid\n");
+		return 1;
+	}
+
+	wp_grp_size = write_protect_group_size(mmc, ext_csd);
+
+	if ((start % wp_grp_size)) {
+		 group_start = (start + wp_grp_size - 1) / wp_grp_size * wp_grp_size;
+		 printf("Caution! The partition start address isn't' aligned"
+				 "to group size\n"
+				"the start address is change from 0x%llx to 0x%llx\n",
+				start, group_start);
+		 part_end = group_start + (cnt - 1) * wp_grp_size - 1;
+		 printf("The write protect group number is 0x%llx, rather than 0x%lld\n",
+				 cnt - 1, cnt);
+	 } else {
+		 group_start = start;
+		 part_end = group_start + cnt * wp_grp_size - 1;
+	 }
+
+	blk_shift = ffs(mmc->read_bl_len) - 1;
+	mmc_boundary = mmc->capacity>>blk_shift;
+
+	if ((part_end + 1) > mmc_boundary) {
+		printf("Error: the operation cross the boundary of mmc\n");
+		return 1;
+	}
+
+	while ((group_start + wp_grp_size - 1) <= part_end) {
+		err = send_write_prot_status_group(mmc, group_start);
+		if (err)
+			return 1;
+		group_start += 32 * wp_grp_size;
+	}
+
+	return 0;
+}
+
+static int do_amlmmc_send_wp_status(struct cmd_tbl *cmdtp,
+		int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+	struct mmc *mmc;
+	int dev = 1;
+	char *name = NULL;
+	u64 start, cnt;
+
+	if (argc < 3 || argc > 4)
+		return ret;
+
+	if (argc == 3) {
+		name = argv[2];
+		dev = find_dev_num_by_partition_name(name);
+		if (dev < 0) {
+			printf("Error: Cannot find dev.\n");
+			return 1;
+		}
+	} else {
+		start = simple_strtoull(argv[2], NULL, 16);
+		cnt = simple_strtoull(argv[3], NULL, 0);
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (IS_SD(mmc)) {
+		mmc = find_mmc_device(~dev);
+		if (IS_SD(mmc)) {
+			printf("SD card can not be write protect\n");
+			return 1;
+		}
+	}
+
+	if (!mmc)
+		return 1;
+
+	mmc_init(mmc);
+	if (!mmc)
+		return 1;
+
+	if (argc == 3)
+		ret = send_part_wp_status(mmc, name);
+	else
+		ret = send_add_wp_status(mmc, start, cnt);
+
+	if (ret) {
+		printf("Failed: send partition write protect status failed\n");
+	}
+
+	return ret;
+}
+
+static int do_amlmmc_send_wp_type(struct cmd_tbl *cmdtp,
+		int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+	struct mmc *mmc;
+	int dev = 1;
+	char *name = NULL;
+	u64 start, cnt;
+
+	if (argc < 3 || argc > 4)
+		return ret;
+
+	if (argc == 3) {
+		name = argv[2];
+		dev = find_dev_num_by_partition_name(name);
+		if (dev < 0) {
+			printf("Error: Cannot find dev.\n");
+			return 1;
+		}
+	} else {
+		start = simple_strtoull(argv[2], NULL, 16);
+		cnt = simple_strtoull(argv[3], NULL, 0);
+	}
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc)
+		return 1;
+
+	if (IS_SD(mmc)) {
+		mmc = find_mmc_device(~dev);
+		if (IS_SD(mmc)) {
+			printf("SD card can not be write protect\n");
+			return 1;
+		}
+	}
+
+	mmc_init(mmc);
+	if (!mmc)
+		return 1;
+	if (argc == 3)
+		ret = send_part_wp_type(mmc, name);
+	else
+		ret = send_add_wp_type(mmc, start, cnt);
+
+	if (ret) {
+		printf("Failed: send parittion write protect type failed\n");
+	}
+
+	return ret;
+}
+
+static int set_driver_strength(struct mmc *mmc, int strength)
+{
+	int ret = 0;
+	u8 ext_csd[512] = {0};
+	u8 strength_type = 0;
+	u8 driver_strength;
+	u8 hs_timing = 0;
+	ret = mmc_get_ext_csd(mmc, ext_csd);
+	if (ret) {
+		printf("get ext_csd failed\n");
+		return ret;
+	}
+	strength_type = 1 << strength;
+	driver_strength = ext_csd[EXT_CSD_DRIVER_STRENGTH];
+	if (0 == (strength_type & driver_strength)) {
+		printf("Failed: This device didn't support strength type %d\n", strength);
+		return 1;
+	}
+
+	hs_timing = ext_csd[EXT_CSD_HS_TIMING];
+	if ((hs_timing >> 4) > 0) {
+		printf("Failed: The driver strength has been set already, \
+			  please reset the device\n");
+		return 1;
+	}
+
+	hs_timing = hs_timing | (strength << 4);
+
+	ret = mmc_set_ext_csd(mmc, EXT_CSD_HS_TIMING, hs_timing);
+	if (ret) {
+		printf("set ext_csd hs_timing field failed\n");
+		return ret;
+	}
+	ret = mmc_get_ext_csd(mmc, ext_csd);
+	if (ret) {
+		printf("get ext_csd failed\n");
+		return ret;
+	}
+	printf("The ext_csd[HS_TIMING] has been set to 0x%x\n",
+		  ext_csd[EXT_CSD_HS_TIMING]);
+	return ret;
+}
+
+static int get_driver_strength(struct mmc *mmc)
+{
+	int ret = 0;
+	u8 ext_csd[512] = {0};
+	u8 support_ds_type = 0;
+	u8 cur_driver_strength;
+	u8 hs_timing = 0;
+	ret = mmc_get_ext_csd(mmc, ext_csd);
+	if (ret) {
+		printf("get ext_csd failed\n");
+		return ret;
+	}
+
+	support_ds_type = ext_csd[EXT_CSD_DRIVER_STRENGTH];
+
+	hs_timing = ext_csd[EXT_CSD_HS_TIMING];
+	cur_driver_strength = hs_timing >> 4;
+
+	printf("current strength type is: ");
+	int strength_type = 0;
+	while (support_ds_type) {
+		if (support_ds_type & 1) {
+			if (cur_driver_strength == strength_type)
+				printf("[%d] ", strength_type);
+			else
+				printf("%d ", strength_type);
+		}
+		strength_type++;
+		support_ds_type = support_ds_type >> 1;
+	}
+	printf("\n");
+	return ret;
+}
+
+static int amlmmc_set_driver_strength(int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+	int dev, strength;
+	struct mmc *mmc;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	strength = simple_strtoul(argv[3], NULL, 10);
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+	mmc_init(mmc);
+	if (!mmc)
+		return 1;
+
+	ret = set_driver_strength(mmc, strength);
+
+	return ret;
+}
+
+static int amlmmc_get_driver_strength(int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+	int dev;
+	struct mmc *mmc;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[2], NULL, 10);
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+	mmc_init(mmc);
+	if (!mmc)
+		return 1;
+
+	ret = get_driver_strength(mmc);
+
+	return ret;
+}
+
+static int do_amlmmc_driver_strength(struct cmd_tbl *cmdtp,
+		int flag, int argc, char *const argv[])
+{
+	int ret = CMD_RET_USAGE;
+
+	if (argc == 3)
+		ret = amlmmc_get_driver_strength(argc,argv);
+	else if (argc == 4)
+		ret = amlmmc_set_driver_strength(argc,argv);
+
+	return ret;
+}
+
+static struct cmd_tbl cmd_amlmmc[] = {
+	U_BOOT_CMD_MKENT(read,          6, 0, do_amlmmc_read,          "", ""),
+	U_BOOT_CMD_MKENT(write,         6, 0, do_amlmmc_write,         "", ""),
+	U_BOOT_CMD_MKENT(erase,         5, 0, do_amlmmc_erase,         "", ""),
+	U_BOOT_CMD_MKENT(rescan,        3, 0, do_amlmmc_rescan,        "", ""),
+	U_BOOT_CMD_MKENT(part,          3, 0, do_amlmmc_part,          "", ""),
+	U_BOOT_CMD_MKENT(list,          2, 0, do_amlmmc_list,          "", ""),
+	U_BOOT_CMD_MKENT(switch,        4, 0, do_amlmmc_switch,        "", ""),
+	U_BOOT_CMD_MKENT(status,        3, 0, do_amlmmc_status,        "", ""),
+	U_BOOT_CMD_MKENT(ext_csd,       5, 0, do_amlmmc_ext_csd,       "", ""),
+	U_BOOT_CMD_MKENT(response,      3, 0, do_amlmmc_response,      "", ""),
+	U_BOOT_CMD_MKENT(controller,    3, 0, do_amlmmc_controller,    "", ""),
+	U_BOOT_CMD_MKENT(size,          4, 0, do_amlmmc_size,          "", ""),
+	U_BOOT_CMD_MKENT(env,           2, 0, do_amlmmc_env,           "", ""),
+	U_BOOT_CMD_MKENT(write_protect, 5, 0, do_amlmmc_write_protect,  "", ""),
+	U_BOOT_CMD_MKENT(send_wp_status, 4, 0, do_amlmmc_send_wp_status, "", ""),
+	U_BOOT_CMD_MKENT(send_wp_type,   4, 0, do_amlmmc_send_wp_type, "", ""),
+	U_BOOT_CMD_MKENT(clear_wp,      4, 0, do_amlmmc_clear_wp,      "", ""),
+	U_BOOT_CMD_MKENT(ds,            4, 0, do_amlmmc_driver_strength, "", ""),
+#ifdef CONFIG_SECURITYKEY
+	U_BOOT_CMD_MKENT(key,           2, 0, do_amlmmc_key,           "", ""),
+#endif
+};
+
+static int do_amlmmcops(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct cmd_tbl *cp;
+
+	cp = find_cmd_tbl(argv[1], cmd_amlmmc, ARRAY_SIZE(cmd_amlmmc));
+
+	if (cp == NULL || argc > cp->maxargs)
+		return CMD_RET_USAGE;
+
+	if (flag == CMD_FLAG_REPEAT && !cmd_is_repeatable(cp))
+		return CMD_RET_SUCCESS;
+
+	return cp->cmd(cmdtp, flag, argc, argv);
+}
+
+U_BOOT_CMD(
+	amlmmc, 6, 1, do_amlmmcops,
+	"AMLMMC sub system",
+	"read  <partition_name> ram_addr addr_byte# cnt_byte\n"
+	"amlmmc write <partition_name> ram_addr addr_byte# cnt_byte\n"
+	"amlmmc erase <partition_name> addr_byte# cnt_byte\n"
+	"amlmmc erase <partition_name>/<device num>\n"
+	"amlmmc rescan <device_num>\n"
+	"amlmmc part <device_num> - show partition infomation of mmc\n"
+	"amlmmc list - lists available devices\n"
+	"amlmmc env -  display env partition offset\n"
+	"amlmmc switch <device_num> <part name> - part name : boot0, boot1, user\n"
+	"amlmmc status <device_num> - read sd/emmc device status\n"
+	"amlmmc ext_csd <device_num> <byte> - read sd/emmc device EXT_CSD [byte]\n"
+	"amlmmc ext_csd <device_num> <byte> <value> - write sd/emmc device EXT_CSD [byte] value\n"
+	"amlmmc response <device_num> - read sd/emmc last command response\n"
+	"amlmmc controller <device_num> - read sd/emmc controller register\n"
+	"amlmmc write_protect <partition_name> <write_protect_type>\n"
+	"        - set write protect on partition through power_on or temporary\n"
+	"amlmmc write_protect <addr_base16> <cnt_base10> <write_protect_type>\n"
+	"        - set write protect on specified address through power_on or temporary\n"
+	"amlmmc send_wp_status <partition_name> send protect status of partition\n"
+	"amlmmc send_wp_status <addr_base16> <cnt_base10> send protect status on specified address\n"
+	"amlmmc send_wp_type <partition_name> send protect type of partition\n"
+	"amlmmc send_wp_type <addr_base16> <cnt_base10> send protect type on specified address\n"
+	"amlmmc clear_wp <partition_name> clear write protect of partition\n"
+	"amlmmc clear_wp <addr_base16> <cnt_base10> clear write protect on specified addresst\n"
+	"amlmmc ds <dev_num> <val> set driver strength\n"
+#ifdef CONFIG_SECURITYKEY
+	"amlmmc key - disprotect key partition\n"
+#endif
+);
+
+/* dtb read&write operation with backup updates */
+static u32 _calc_dtb_checksum(struct aml_dtb_rsv * dtb)
+{
+	int i = 0;
+	int size = sizeof(struct aml_dtb_rsv) - sizeof(u32);
+	u32 * buffer;
+	u32 checksum = 0;
+
+	if ((u64)dtb % 4 != 0) {
+		BUG();
+	}
+
+	size = size >> 2;
+	buffer = (u32*) dtb;
+	while (i < size)
+		checksum += buffer[i++];
+
+	return checksum;
+}
+
+static int _verify_dtb_checksum(struct aml_dtb_rsv * dtb)
+{
+	u32 checksum;
+
+	checksum = _calc_dtb_checksum(dtb);
+	dtb_info("calc %x, store %x\n", checksum, dtb->checksum);
+
+	return !(checksum == dtb->checksum);
+}
+
+static int _dtb_read(struct mmc *mmc, u64 blk, u64 cnt, void * addr)
+{
+	int dev = EMMC_DTB_DEV;
+	u64 n;
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if (n != cnt) {
+		dtb_err("%s: dev # %d, block # %#llx, count # %#llx ERROR!\n",
+				__func__, dev, blk, cnt);
+	}
+
+	return (n != cnt);
+}
+
+static int _dtb_write(struct mmc *mmc, u64 blk, u64 cnt, void * addr)
+{
+	int dev = EMMC_DTB_DEV;
+	u64 n;
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if (n != cnt) {
+		dtb_err("%s: dev # %d, block # %#llx, count # %#llx ERROR!\n",
+				__func__, dev, blk, cnt);
+	}
+
+	return (n != cnt);
+}
+
+static struct mmc *_dtb_init(void)
+{
+	struct mmc *mmc = find_mmc_device(EMMC_DTB_DEV);
+	if (!mmc) {
+		dtb_err("not find mmc\n");
+		return NULL;
+	}
+
+	if (mmc_init(mmc)) {
+		dtb_err("mmc init failed\n");
+		return NULL;
+	}
+	return mmc;
+}
+
+static int dtb_read_shortcut(struct mmc * mmc, void *addr)
+{
+	u64 blk, cnt, dtb_glb_offset;
+	int dev = EMMC_DTB_DEV;
+	struct aml_dtb_info *info = &dtb_infos;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	dtb_glb_offset = part->offset + vpart->offset;
+	/* short cut */
+	if (info->valid[0]) {
+		dtb_info("short cut in...\n");
+		blk = dtb_glb_offset / mmc->read_bl_len;
+		cnt = vpart->size / mmc->read_bl_len;
+		if (_dtb_read(mmc, blk, cnt, addr)) {
+			dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+					__func__, dev, blk, cnt);
+			/*try dtb2 if it's valid */
+			if (info->valid[1]) {
+				blk = (dtb_glb_offset + vpart->size) / mmc->read_bl_len;
+				cnt = vpart->size / mmc->read_bl_len;
+				if (_dtb_read(mmc, blk, cnt, addr)) {
+					dtb_err("%s: dev # %d, block # %#llx, cnt # %#llx ERROR!\n",
+						__func__, dev, blk, cnt);
+					return -1;
+				}
+			}
+		}
+		return 0;
+	}
+	return -2;
+}
+
+static int update_dtb_info(struct mmc *mmc, void *addr)
+{
+	int ret = 0, dev = EMMC_DTB_DEV;
+	u64 blk, cnt, dtb_glb_offset;
+	struct aml_dtb_rsv * dtb = (struct aml_dtb_rsv *) addr;
+	struct aml_dtb_info *info = &dtb_infos;
+	int cpy = 1, valid = 0;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	dtb_glb_offset = part->offset + vpart->offset;
+
+	while (cpy >= 0) {
+		blk = (dtb_glb_offset + cpy * (vpart->size)) / mmc->read_bl_len;
+		cnt = vpart->size / mmc->read_bl_len;
+		ret = _dtb_read(mmc, blk, cnt, addr);
+		if (ret) {
+			dtb_err("%s: dev # %d, block # %#llx, cnt # %#llx ERROR!\n",
+				__func__, dev, blk, cnt);
+		} else {
+			ret = _verify_dtb_checksum(dtb);
+			/* check magic avoid whole 0 issue */
+			if (!ret && (dtb->magic != 0)) {
+				info->stamp[cpy] = dtb->timestamp;
+				info->valid[cpy] = 1;
+			}
+			else
+				dtb_wrn("cpy %d is not valid\n", cpy);
+		}
+		valid += info->valid[cpy];
+		cpy --;
+	}
+	return valid;
+}
+
+static int update_invalid_dtb(struct mmc *mmc, void *addr)
+{
+	int ret = 0, dev = EMMC_DTB_DEV;
+	u64 blk, cnt, dtb_glb_offset;
+	struct aml_dtb_rsv * dtb = (struct aml_dtb_rsv *) addr;
+	struct aml_dtb_info *info = &dtb_infos;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	dtb_glb_offset = part->offset + vpart->offset;
+	cnt = vpart->size / mmc->read_bl_len;
+
+	if (info->valid[1]) {
+		blk = (dtb_glb_offset + vpart->size) / mmc->read_bl_len;
+		if (_dtb_read(mmc, blk, cnt, addr)) {
+		dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+				__func__, dev, blk, cnt);
+			ret = -2;
+		}
+		/* fixme, update the invalid one - dtb1 */
+		blk = (dtb_glb_offset) / mmc->read_bl_len;
+		if (_dtb_write(mmc, blk, cnt, addr)) {
+			dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+				__func__, dev, blk, cnt);
+			ret = -4;
+		}
+		info->valid[0] = 1;
+		info->stamp[0] = dtb->timestamp;
+		ret = 0;
+	} else {
+		dtb_info("update dtb2");
+		blk = (dtb_glb_offset + vpart->size) / mmc->read_bl_len;
+		if (_dtb_write(mmc, blk, cnt, addr)) {
+			dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+				__func__, dev, blk, cnt);
+			ret = -2;
+		}
+		info->valid[1] = 1;
+		info->stamp[1] = dtb->timestamp;
+	}
+	return ret;
+}
+
+int update_old_dtb(struct mmc *mmc, void *addr)
+{
+	int ret = 0, dev = EMMC_DTB_DEV;
+	u64 blk, cnt, dtb_glb_offset;
+	struct aml_dtb_rsv * dtb = (struct aml_dtb_rsv *) addr;
+	struct aml_dtb_info *info = &dtb_infos;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	dtb_glb_offset = part->offset + vpart->offset;
+	cnt = vpart->size / mmc->read_bl_len;
+	if (stamp_after(info->stamp[1], info->stamp[0])) {
+		blk = (dtb_glb_offset + vpart->size) / mmc->read_bl_len;
+		if (_dtb_read(mmc, blk, cnt, addr)) {
+			dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+					__func__, dev, blk, cnt);
+			ret = -3;
+		}
+		/*update dtb1*/
+		blk = dtb_glb_offset / mmc->read_bl_len;
+		if (_dtb_write(mmc, blk, cnt, addr)) {
+			dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+					__func__, dev, blk, cnt);
+			ret = -3;
+		}
+		info->stamp[0] = dtb->timestamp;
+		ret = 0;
+	} else if (stamp_after(info->stamp[0], info->stamp[1])) {
+		/*update dtb2*/
+		blk = (dtb_glb_offset + vpart->size) / mmc->read_bl_len;
+		if (_dtb_write(mmc, blk, cnt, addr)) {
+			dtb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+					__func__, dev, blk, cnt);
+			ret = -3;
+		}
+		info->stamp[1] = dtb->timestamp;
+	} else {
+		dtb_info("do nothing\n");
+	}
+	return ret;
+}
+
+int dtb_read(void *addr)
+{
+	int ret = 0;
+	int valid = 0;
+	struct mmc *mmc;
+
+	mmc = _dtb_init();
+	if (mmc == NULL)
+		return -10;
+
+	if (dtb_read_shortcut(mmc, addr) == 0)
+		return ret;
+
+	valid = update_dtb_info(mmc, addr);
+	dtb_info("total valid %d\n", valid);
+	/* check valid */
+	switch (valid) {
+		/* none is valid, using the 1st one for compatibility*/
+		case 0:
+			ret = -1;
+			goto _out;
+		break;
+		/* only 1 is valid, using the valid one */
+		case 1:
+			update_invalid_dtb(mmc, addr);
+		break;
+		/* both are valid, pickup new one. */
+		case 2:
+			update_old_dtb(mmc, addr);
+		break;
+		default:
+			dtb_err("impossble valid values.\n");
+			BUG();
+		break;
+	}
+_out:
+	return ret;
+}
+
+
+int dtb_write(void *addr)
+{
+	int ret = 0;
+	struct aml_dtb_rsv * dtb = (struct aml_dtb_rsv *) addr;
+	struct aml_dtb_info *info = &dtb_infos;
+	u64 blk, cnt, dtb_glb_offset;
+	int cpy, valid;
+	struct mmc * mmc;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	dtb_glb_offset = part->offset + vpart->offset;
+
+	mmc = _dtb_init();
+	if (NULL == mmc)
+		return -10;
+
+	/* stamp */
+	valid = info->valid[0] + info->valid[1];
+	dtb_info("valid %d\n", valid);
+	if (0 == valid)
+		dtb->timestamp = 0;
+	else if (1 == valid) {
+		dtb->timestamp = 1 + info->stamp[info->valid[0]?0:1];
+	} else {
+		/* both are valid */
+		if (info->stamp[0] != info->stamp[1]) {
+			dtb_wrn("timestamp are not same %d:%d\n",
+				info->stamp[0], info->stamp[1]);
+			dtb->timestamp = 1 + stamp_after(info->stamp[1], info->stamp[0])?
+				info->stamp[1]:info->stamp[0];
+		} else
+			dtb->timestamp = 1 + info->stamp[0];
+	}
+	/*setting version and magic*/
+	dtb->version = 1; /* base version */
+	dtb->magic = 0x00447e41; /*A~D\0*/
+	dtb->checksum = _calc_dtb_checksum(dtb);
+	dtb_info("new stamp %d, checksum 0x%x, version %d, magic %s\n",
+		dtb->timestamp, dtb->checksum, dtb->version, (char *)&dtb->magic);
+
+	for (cpy = 0; cpy < DTB_COPIES; cpy++) {
+		blk = (dtb_glb_offset + cpy * (vpart->size)) / mmc->read_bl_len;
+		cnt = vpart->size / mmc->read_bl_len;
+		ret |= _dtb_write(mmc, blk, cnt, addr);
+		info->valid[cpy] = 1;
+		info->stamp[cpy] = dtb->timestamp;
+	}
+
+	return ret;
+}
+
+extern int check_valid_dts(unsigned char *buffer);
+int renew_partition_tbl(unsigned char *buffer)
+{
+	int ret = 0;
+
+	unsigned char *temp = NULL;
+	if (!buffer)
+		return 1;
+	temp = malloc (AML_DTB_IMG_MAX_SZ);
+	if (!temp)
+		return 1;
+	memcpy(temp, buffer, AML_DTB_IMG_MAX_SZ);
+	     /* todo, check new dts imcoming.... */
+	ret = check_valid_dts(temp);
+		free(temp);
+	/* todo, check new dts imcoming.... */
+/*	ret = check_valid_dts(buffer);*/
+	/* only the dts new is valid */
+	if (!ret) {
+		free_partitions();
+		get_partition_from_dts(buffer);
+		if (0 == mmc_device_init(_dtb_init())) {
+			printf("partition table success\n");
+			ret = 0;
+			goto _out;
+		}
+		printf("partition table error\n");
+		ret = 1;
+	}
+
+_out:
+	return ret;
+}
+
+int do_amlmmc_dtb_key(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int dev, ret = 0;
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0;
+	//u64 size;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	switch (argc) {
+		case 3:
+			if (strcmp(argv[1], "erase") == 0) {
+				if (strcmp(argv[2], "dtb") == 0) {
+					printf("start erase dtb......\n");
+					dev = EMMC_DTB_DEV;
+					struct mmc *mmc = find_mmc_device(dev);
+					if (!mmc) {
+						printf("not find mmc\n");
+						return 1;
+					}
+					blk = (part->offset + vpart->offset) / mmc->read_bl_len;
+					cnt = (vpart->size * 2) / mmc->read_bl_len;
+					if (cnt != 0)
+						n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+					printf("dev # %d, %s, several blocks erased %s\n",
+							dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+					return (n == 0) ? 0 : 1;
+				}else if (strcmp(argv[2], "key") == 0){
+					printf("start erase key......\n");
+					dev = 1;
+					struct mmc *mmc = find_mmc_device(dev);
+					if (!mmc) {
+						printf("not find mmc\n");
+						return 1;
+					}
+					n = mmc_key_erase();
+					printf("dev # %d, %s, several blocks erased %s\n",
+							dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+					return (n == 0) ? 0 : 1;
+				}
+			} else if (strcmp(argv[1], "cali_pattern") == 0) {
+
+				if (strcmp(argv[2], "write") == 0) {
+					dev = EMMC_DTB_DEV;
+					struct mmc *mmc = find_mmc_device(dev);
+					if (!mmc) {
+						printf("not find mmc\n");
+						return 1;
+					}
+					vpart = aml_get_virtual_partition_by_name(MMC_PATTERN_NAME);
+					part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+					addr = (void *)malloc(vpart->size);
+					if (addr == NULL) {
+						printf("cali_pattern malloc fail\n");
+						return 1;
+					}
+					mmc_write_cali_mattern(addr);
+					blk = (part->offset + vpart->offset) / mmc->read_bl_len;
+					cnt = vpart->size / mmc->read_bl_len;
+					if (cnt != 0)
+						n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+					printf("dev # %d, %s, several calibration pattern blocks write %s\n",
+							dev, (flag == 0) ? " ":(argv[2]),(n == cnt) ? "OK" : "ERROR");
+					free(addr);
+					return (n == cnt) ? 0 : 1;
+				}
+			}
+		case 4:
+			addr = (void *)simple_strtoul(argv[2], NULL, 16);
+			if (strcmp(argv[1], "dtb_read") == 0) {
+				/* fixme, */
+				ret = dtb_read(addr);
+				return 0;
+
+			} else if (strcmp(argv[1], "dtb_write") == 0) {
+				/* fixme, should we check the return value? */
+				ret = dtb_write(addr);
+				ret |= renew_partition_tbl(addr);
+				return ret;
+			}
+			return 0;
+		default:
+			break;
+	}
+	return 1;
+}
+
+/* update partition table in reserved partition. */
+__weak int emmc_update_ept(unsigned char *buffer)
+{
+	int ret = 0;
+
+#ifndef DTB_BIND_KERNEL
+	dtb_write(buffer);
+#endif
+	ret = renew_partition_tbl(buffer);
+	return ret;
+}
+
+/* fixme, should use renew_partition_tbl here! */
+__weak int emmc_update_mbr(unsigned char *buffer)
+{
+	int ret = 0;
+	//cpu_id_t cpu_id = get_cpu_id();
+
+	if (0) { //(cpu_id.family_id < MESON_CPU_MAJOR_ID_GXL) {
+		ret = -1;
+		printf("MBR not support, try dtb\n");
+		goto _out;
+	}
+#ifndef DTB_BIND_KERNEL
+	dtb_write(buffer);
+#endif
+	ret = get_partition_from_dts(buffer);
+	if (ret) {
+		printf("Fail to get partition talbe from dts\n");
+		goto _out;
+	}
+	ret = mmc_device_init(_dtb_init());
+	printf("%s: update mbr %s\n", __func__, ret?"Fail":"Success");
+_out:
+	return ret;
+}
+
+int emmc_erase_rsv(struct mmc *mmc, char *rsv_part)
+{
+	u64 cnt = 0, n = 0, blk = 0;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+
+	if (rsv_part == NULL)
+		return -1;
+
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	if (strcmp(rsv_part, "dtb") == 0) {
+		blk = (part->offset + vpart->offset) / mmc->read_bl_len;
+		cnt = (vpart->size * 2) / mmc->read_bl_len;
+		if (cnt != 0)
+			n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+		printf("%s is erased %s\n",
+				rsv_part, (n == 0) ? "OK" : "ERROR");
+		return (n == 0) ? 0 : 1;
+	} else if (strcmp(rsv_part, "key") == 0) {
+		n = mmc_key_erase();
+		printf("%s is erased %s\n",
+				rsv_part, (n == 0) ? "OK" : "ERROR");
+		return (n == 0) ? 0 : 1;
+	}
+	return 1;
+}
+
+int do_emmc_erase(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int dev;
+	u64 cnt = 0, n = 0, blk = 0;
+	//u64 size;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+	struct mmc *mmc;
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	if (strcmp(argv[2], "dtb") == 0) {
+		printf("start erase dtb......\n");
+		dev = EMMC_DTB_DEV;
+		mmc = find_mmc_device(dev);
+		if (!mmc) {
+			printf("not find mmc\n");
+			return 1;
+		}
+		blk = (part->offset + vpart->offset) / mmc->read_bl_len;
+		cnt = (vpart->size * 2) / mmc->read_bl_len;
+		if (cnt != 0)
+			n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+		printf("dev # %d, %s, several blocks erased %s\n",
+				dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+		return (n == 0) ? 0 : 1;
+	} else if (strcmp(argv[2], "key") == 0) {
+		printf("start erase key......\n");
+		dev = 1;
+		mmc = find_mmc_device(dev);
+		if (!mmc) {
+			printf("not find mmc\n");
+			return 1;
+		}
+		n = mmc_key_erase();
+		printf("dev # %d, %s, several blocks erased %s\n",
+				dev, (flag == 0) ? " ":(argv[2]),(n == 0) ? "OK" : "ERROR");
+		return (n == 0) ? 0 : 1;
+	}
+	return 1;
+}
+
+int do_emmc_dtb_read(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	void *addr = NULL;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	ret = dtb_read(addr);
+	return ret;
+}
+
+int do_emmc_dtb_write(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	void *addr = NULL;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	ret = dtb_write(addr);
+	ret |= renew_partition_tbl(addr);
+	return ret;
+}
+
+static int _fastboot_context_read(struct mmc *mmc, u64 blk,
+		u64 cnt, void *addr)
+{
+	int dev = EMMC_FASTBOOT_CONTEXT_DEV;
+	u64 n;
+
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if (n != cnt) {
+		fb_err("%s: dev # %d, block # %#llx, count # %#llx ERROR!\n",
+			__func__, dev, blk, cnt);
+	}
+
+	return n != cnt;
+}
+
+int fastboot_context_read(void *buf, size_t size)
+{
+	uint32_t crc_result;
+	struct mmc *mmc;
+	struct FastbootContext *fb_cont;
+	int fb_size = sizeof(struct FastbootContext);
+	u64 blk, cnt, fb_glb_offset;
+	int dev = EMMC_FASTBOOT_CONTEXT_DEV;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	if (mmc_init(mmc)) {
+		printf("%s() %d: emmc init failed\n", __func__, __LINE__);
+		return 1;
+	}
+
+	vpart = aml_get_virtual_partition_by_name(MMC_FASTBOOT_CONTEXT_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	fb_glb_offset = part->offset + vpart->offset;
+
+	blk = fb_glb_offset / mmc->read_bl_len;
+	cnt = size / mmc->read_bl_len;
+
+	if (_fastboot_context_read(mmc, blk, cnt, buf))
+		return 1;
+
+	fb_cont = (struct FastbootContext *)buf;
+	crc_result = crc32(0, buf, fb_size - 4);
+
+	if (crc_result != fb_cont->crc32) {
+		printf("%s %d: crc checksum ERROR!\n", __func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+int do_emmc_fb_read(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	void *addr = NULL;
+	u64 size;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	size = simple_strtoull(argv[3], NULL, 16);
+	ret = fastboot_context_read(addr, size);
+	return ret;
+}
+
+static int _fastboot_context_write(struct mmc *mmc, u64 blk,
+		u64 cnt, void *addr)
+{
+	int dev = EMMC_FASTBOOT_CONTEXT_DEV;
+	int n;
+
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+
+	if (n != cnt) {
+		fb_err("%s: dev # %d, block # %#llx,cnt # %#llx ERROR!\n",
+			__func__, dev, blk, cnt);
+	}
+
+	return n != cnt;
+}
+
+int fastboot_context_write(void *buf, size_t size)
+{
+	int ret = 0;
+	struct FastbootContext *fb_cont = (struct FastbootContext *)buf;
+	u64 blk, cnt, fb_glb_offset;
+	struct mmc *mmc;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+	int dev = EMMC_FASTBOOT_CONTEXT_DEV;
+	int fb_size = sizeof(struct FastbootContext);
+
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	ret = mmc_init(mmc);
+	if (ret) {
+		printf("%s() %d: emmc init failed\n", __func__, __LINE__);
+		return 1;
+	}
+
+	vpart = aml_get_virtual_partition_by_name(MMC_FASTBOOT_CONTEXT_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	fb_glb_offset = part->offset + vpart->offset;
+	fb_cont->crc32 = crc32(0, buf, fb_size - 4);
+	blk = fb_glb_offset / mmc->read_bl_len;
+	cnt = size / mmc->read_bl_len;
+	ret = _fastboot_context_write(mmc, blk, cnt, buf);
+
+	return ret;
+}
+
+int do_emmc_fb_write(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	void *addr = NULL;
+	u64 size;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	size = simple_strtoull(argv[3], NULL, 16);
+	ret = fastboot_context_write(addr, size);
+	return ret;
+}
+
+int do_emmc_key_read(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	void *addr = NULL;
+	u64 size;
+	uint32_t *actual_lenth=0;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	size = simple_strtoull(argv[3], NULL, 16);
+	printf("enter emmc key read !!\n");
+	printf("addr:%p   size:%llx\n",addr,size);
+	ret = mmc_key_read(addr, size,actual_lenth);
+	printf("ret:%d\n",ret);
+	return ret;
+}
+
+int do_emmc_key_write(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[]) {
+
+	int ret = 0;
+	void *addr = NULL;
+	u64 size;
+	uint32_t *actual_lenth=0;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	size = simple_strtoull(argv[3], NULL, 16);
+	ret = mmc_key_write(addr, size,actual_lenth);
+	return ret;
+
+
+}
+
+
+
+
+static struct cmd_tbl cmd_emmc[] = {
+	U_BOOT_CMD_MKENT(dtb_read,  4, 0, do_emmc_dtb_read,  "", ""),
+	U_BOOT_CMD_MKENT(dtb_write, 4, 0, do_emmc_dtb_write, "", ""),
+	U_BOOT_CMD_MKENT(erase,     3, 0, do_emmc_erase,     "", ""),
+	U_BOOT_CMD_MKENT(fastboot_read, 4, 0, do_emmc_fb_read, "", ""),
+	U_BOOT_CMD_MKENT(fastboot_write, 4, 0, do_emmc_fb_write, "", ""),
+	U_BOOT_CMD_MKENT(key_read, 4, 0, do_emmc_key_read, "", ""),
+	U_BOOT_CMD_MKENT(key_write, 4, 0, do_emmc_key_write, "", ""),
+};
+
+static int do_emmc_dtb_key(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct cmd_tbl *cp;
+
+	cp = find_cmd_tbl(argv[1], cmd_emmc, ARRAY_SIZE(cmd_emmc));
+
+	if (cp == NULL || argc > cp->maxargs)
+		return CMD_RET_USAGE;
+	if (flag == CMD_FLAG_REPEAT && !cmd_is_repeatable(cp))
+		return CMD_RET_SUCCESS;
+	return cp->cmd(cmdtp, flag, argc, argv);
+}
+
+
+U_BOOT_CMD(
+	emmc, 4, 1, do_emmc_dtb_key,
+	"EMMC sub system",
+	"dtb_read addr size\n"
+	"emmc dtb_write addr size\n"
+	"emmc erase dtb\n"
+	"emmc erase key\n"
+	"emmc fastboot_read addr size\n"
+	"emmc fastboot_write addr size\n"
+	"emmc key_read addr size\n"
+	"emmc key_write addr size\n"
+);
+
diff --git a/cmd/storage.c b/cmd/storage.c
new file mode 100644
index 0000000000..98147fbe22
--- /dev/null
+++ b/cmd/storage.c
@@ -0,0 +1,1503 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Storage interface module
+ *
+ * Copyright (C) 2018 Amlogic Corporation
+ *
+ */
+#include <amlogic/storage.h>
+#include <div64.h>
+#include <linux/math64.h>
+//#include <amlogic/cpu_id.h>
+#include <amlogic/store_wrapper.h>
+#include <amlogic/aml_efuse.h>
+#include <amlogic/blxx2bl33_param.h>
+#include <amlogic/aml_mtd.h>
+
+#include <amlogic/asm/romboot.h>
+#include <amlogic/asm/cpu_config.h>
+//#include <amlogic/asm/register.h>
+#include <amlogic/asm/bl31_apis.h>
+#include <amlogic/asm/secure_apb.h>
+
+#undef pr_info
+#define pr_info       printf
+
+#ifdef CONFIG_SPI_FLASH
+extern int spi_nor_pre(void);
+extern int spi_nor_probe(u32 init_flag);
+#endif
+
+#ifdef CONFIG_SPI_NAND
+extern int spi_nand_pre(void);
+extern int spi_nand_probe(u32 init_flag);
+#endif
+
+#ifdef CONFIG_MTD_SPI_NAND
+extern int spi_nand_pre(void);
+extern int spi_nand_probe(u32 init_flag);
+#endif
+
+#ifdef CONFIG_AML_NAND
+extern int amlnf_pre(void);
+extern int amlnf_probe(u32 init_flag);
+#endif
+
+#ifdef CONFIG_MESON_NFC
+extern int nand_pre(void);
+extern int nand_probe(uint32_t init_flag);
+#endif
+
+#ifdef CONFIG_MMC_MESON_GX
+extern int emmc_pre(void);
+extern int emmc_probe(u32 init_flag);
+#endif
+
+#ifdef CONFIG_MMC_MESON_GX
+extern int sdcard_pre(void);
+extern int sdcard_probe(u32 init_flag);
+#endif
+/* for info protect, fixme later */
+int info_disprotect = 0;
+
+static struct storage_t *current;
+static struct device_node_t device_list[] = {
+#ifdef CONFIG_MESON_NFC
+	{BOOT_NAND_MTD, "mtd", nand_pre, nand_probe},
+#endif
+#ifdef CONFIG_AML_NAND
+	{BOOT_NAND_NFTL, "nftl", amlnf_pre, amlnf_probe},
+#endif
+#ifdef CONFIG_SPI_NAND
+	/* old drivers will be removed later */
+	{BOOT_SNAND, "spi-nand", spi_nand_pre, spi_nand_probe},
+#endif
+#ifdef CONFIG_MTD_SPI_NAND
+	{BOOT_SNAND, "spi-nand", spi_nand_pre, spi_nand_probe},
+#endif
+#if CONFIG_SPI_FLASH
+	{BOOT_SNOR, "spi-nor", spi_nor_pre, spi_nor_probe},
+#endif
+#if 0
+	{BOOT_SD, "sd", sdcard_pre, sdcard_probe},
+#endif
+
+#ifdef CONFIG_MMC_MESON_GX
+	{BOOT_EMMC, "emmc", emmc_pre, emmc_probe},
+#endif
+
+};
+
+int store_register(struct storage_t *store_dev)
+{
+	if (!store_dev)
+		return 1;
+	if (!current) {
+		INIT_LIST_HEAD(&store_dev->list);
+		current = store_dev;
+		return 0;
+	}
+	/**
+	 * the head node will not be a valid node
+	 * usually when we use the list, but in storage
+	 * interface module, we init the device node as
+	 * a head instead a global list_head pointer,
+	 * it should be traversaled.
+	 */
+	if (store_dev == current)
+		return 0;
+	struct storage_t *dev;
+
+	if (store_dev->type == current->type)
+		return 1;
+	list_for_each_entry(dev, &current->list, list) {
+		if (dev == store_dev)
+			return 0;
+		else if (dev->type == store_dev->type)
+			return 1;
+	}
+	list_add_tail(&store_dev->list, &current->list);
+	current = store_dev;
+	return 0;
+}
+
+void store_unregister(struct storage_t *store_dev)
+{
+	if (store_dev == current) {
+		if (list_empty_careful(&store_dev->list)) {
+			current = NULL;
+		} else {
+			current = list_entry((current->list).next,
+					     struct storage_t, list);
+			list_del_init(&store_dev->list);
+		}
+	} else {
+		list_del_init(&store_dev->list);
+	}
+}
+
+int sheader_need(void)
+{
+	//const cpu_id_t cpuid = get_cpu_id();
+	//const int familyId = cpuid.family_id;
+
+	return 0; //(MESON_CPU_MAJOR_ID_SC2 == familyId);
+}
+
+unsigned char *ubootdata = NULL;
+void sheader_load(void *addr)
+{
+	ubootdata = addr;
+}
+
+/*
+ * storage header which size is 512B
+ * is bind into the tail of bl2.bin.
+ * @addr: uboot address.
+ */
+static p_payload_info_t parse_uboot_sheader(void *addr)
+{
+	p_payload_info_t pInfo = (p_payload_info_t)(addr + BL2_SIZE);
+
+	if (AML_MAGIC_HDR_L == pInfo->hdr.nMagicL &&
+	    AML_MAGIC_HDR_R == pInfo->hdr.nMagicR) {
+		printf("aml log : bootloader blxx mode!\n");
+		return pInfo;
+	}
+	return NULL;
+}
+
+boot_area_entry_t general_boot_part_entry[MAX_BOOT_AREA_ENTRIES] = {
+	{BOOT_BL2, BOOT_AREA_BB1ST, 0, BOOT_FIRST_BLOB_SIZE},
+	{BOOT_BL2E, BOOT_AREA_BL2E, 0, 0x40000},
+	{BOOT_BL2X, BOOT_AREA_BL2X, 0, 0x40000},
+	{BOOT_DDRFIP, BOOT_AREA_DDRFIP, 0, 0x40000},
+	{BOOT_DEVFIP, BOOT_AREA_DEVFIP, 0, 0x300000},
+};
+
+struct boot_layout general_boot_layout = {.boot_entry = general_boot_part_entry};
+struct storage_startup_parameter g_ssp;
+struct storage_bl *g_storage = NULL;
+
+static void storage_boot_layout_debug_info(
+			struct boot_layout *boot_layout)
+{
+	boot_area_entry_t *boot_entry = boot_layout->boot_entry;
+	int i;
+
+	printf("boot area list: \n");
+	for (i = 0; i < MAX_BOOT_AREA_ENTRIES && boot_entry[i].size; i++) {
+		printf("%10s    ", boot_entry[i].name);
+		printf("%10llx    ", boot_entry[i].offset);
+		printf("%10llx\n", boot_entry[i].size);
+	}
+}
+
+/* use STORAGE_ROUND_UP, y must be power of 2 */
+#define STORAGE_ROUND_UP_IF_UNALIGN(x, y) ((x) = (((x) + (y) - 1) & (~(y - 1))))
+#define NAND_RSV_OFFSET	1024
+#define ALIGN_SIZE	(4096)
+static int storage_boot_layout_rebuild(struct boot_layout *boot_layout,
+				       unsigned int bl2e_size,
+				       unsigned int bl2x_size)
+{
+	struct storage_startup_parameter *ssp = &g_ssp;
+	boot_area_entry_t *boot_entry = boot_layout->boot_entry;
+	uint64_t align_size, reserved_size = 0;
+	uint8_t i, cal_copy = ssp->boot_bakups;
+
+	align_size = ALIGN_SIZE;
+	if ((ssp->boot_device == BOOT_NAND_NFTL) ||
+		(ssp->boot_device == BOOT_NAND_MTD)) {
+		reserved_size = ssp->sip.nsp.layout_reserve_size;
+		align_size = ((NAND_RSV_OFFSET / cal_copy) * ssp->sip.nsp.page_size);
+		printf("reserved_size:0x%llx 0x%llx\n", reserved_size, align_size);
+	} else if (ssp->boot_device == BOOT_SNAND) {
+		reserved_size = ssp->sip.snasp.layout_reserve_size;
+		align_size = ((NAND_RSV_OFFSET / cal_copy) * ssp->sip.snasp.pagesize);
+	} else 	if (ssp->boot_device == BOOT_EMMC) {
+		ssp->boot_entry[0].offset = boot_entry[0].offset +=
+			BL2_CORE_BASE_OFFSET_EMMC;
+		cal_copy = 1;
+	}
+	STORAGE_ROUND_UP_IF_UNALIGN(boot_entry[0].size, align_size);
+	ssp->boot_entry[0].size = boot_entry[0].size;
+	printf("ssp->boot_entry[0] offset:0x%x, size:0x%x\n",
+			ssp->boot_entry[0].offset, ssp->boot_entry[0].size);
+	printf("cal_copy:0x%x\n", cal_copy);
+	printf("align_size:0x%llx\n", align_size);
+	printf("reserved_size:0x%llx\n", reserved_size);
+	if ((ssp->boot_device == BOOT_NAND_NFTL) ||
+		(ssp->boot_device == BOOT_NAND_MTD))
+		align_size = ssp->sip.nsp.block_size;
+	else if (ssp->boot_device == BOOT_SNAND)
+		align_size = ssp->sip.snasp.pagesize *
+			     ssp->sip.snasp.pages_per_eraseblock;
+	printf("align_size2:%llu\n", align_size);
+
+	boot_entry[BOOT_AREA_BL2E].size = bl2e_size;
+	boot_entry[BOOT_AREA_BL2X].size = bl2x_size;
+
+	for (i = 1; i < MAX_BOOT_AREA_ENTRIES && boot_entry[i - 1].size; i++) {
+		STORAGE_ROUND_UP_IF_UNALIGN(boot_entry[i].size, align_size);
+		boot_entry[i].offset = boot_entry[i-1].offset +
+				boot_entry[i-1].size * cal_copy + reserved_size;
+		reserved_size = 0;
+		ssp->boot_entry[i].size = boot_entry[i].size;
+		ssp->boot_entry[i].offset = boot_entry[i].offset;
+	}
+
+	return 0;
+}
+
+/* use STORAGE_ROUND_UP, y must be power of 2 */
+#define STORAGE_ROUND_UP_IF_UNALIGN(x, y) ((x) = (((x) + (y) - 1) & (~(y - 1))))
+#define NAND_RSV_OFFSET	1024
+#define ALIGN_SIZE	(4096)
+static int storage_boot_layout_general_setting(struct boot_layout *boot_layout,
+					       int need_build)
+{
+	//struct storage_startup_parameter *ssp = &g_ssp;
+	boot_area_entry_t *boot_entry = boot_layout->boot_entry;
+	struct storage_boot_entry *sbentry = g_ssp.boot_entry;
+	p_payload_info_t pInfo = parse_uboot_sheader(ubootdata);;
+	p_payload_info_hdr_t hdr = &pInfo->hdr;
+	p_payload_info_item_t pItem = pInfo->arrItems;
+	int offPayload = 0, szPayload = 0;
+	unsigned int bl2e_size, bl2x_size;
+	char name[8] = {0};
+	int nIndex = 0;
+
+	if (need_build == BOOT_ID_USB) {
+		for (nIndex = 1, pItem += 1;
+		     nIndex < hdr->byItemNum; ++nIndex, ++pItem) {
+			memcpy(name, &pItem->nMagic, sizeof(unsigned int));
+			offPayload = pItem->nOffset;
+			if (nIndex == BOOT_AREA_BL2E)
+				bl2e_size = pItem->nPayLoadSize;
+			if (nIndex == BOOT_AREA_BL2X)
+				bl2x_size = pItem->nPayLoadSize;
+			szPayload = pItem->nPayLoadSize;
+			pr_info("Item[%d]%4s offset 0x%08x sz 0x%x\n",
+			       nIndex, name, offPayload, szPayload);
+		}
+		storage_boot_layout_rebuild(boot_layout, bl2e_size, bl2x_size);
+	} else {
+		/* may be sdcard boot and also have to rebuild layout */
+		if (need_build == BOOT_ID_SDCARD) {
+			bl2e_size = sbentry[BOOT_AREA_BL2E].size;
+			bl2x_size = sbentry[BOOT_AREA_BL2X].size;
+			printf("bl2e_size=%x bl2x_size=%x current->type=%d\n",
+				bl2e_size, bl2x_size, current->type);
+			storage_boot_layout_rebuild(boot_layout,
+						    bl2e_size, bl2x_size);
+			return 0;
+		}
+		/* normal boot */
+		for (nIndex = 0;
+		     nIndex < MAX_BOOT_AREA_ENTRIES && sbentry->size;
+		     nIndex++, sbentry++) {
+			boot_entry[nIndex].size = sbentry->size;
+			boot_entry[nIndex].offset = sbentry->offset;
+		}
+	}
+
+	return 0;
+}
+
+uint8_t emmc_boot_seqs_tbl[8][2] = {
+		{0, 3}, {0, 2}, {0, 3}, {0, 1},
+		{1, 2}, {1, 1}, {2, 1}, {0, 0}
+	};
+
+static int _get_emmc_boot_seqs(void)
+{
+	uint8_t ebcfg = 0;
+	if (IS_FEAT_DIS_EMMC_USER())
+		ebcfg |= (1<<2);
+	if (IS_FEAT_DIS_EMMC_BOOT_0())
+		ebcfg |= (1<<1);
+	if (IS_FEAT_DIS_EMMC_BOOT_1())
+		ebcfg |= (1<<0);
+
+	return ebcfg;
+}
+
+static int storage_get_emmc_boot_seqs(void)
+{
+	return emmc_boot_seqs_tbl[_get_emmc_boot_seqs()][1];;
+}
+
+static int storage_get_emmc_boot_start(void)
+{
+	return emmc_boot_seqs_tbl[_get_emmc_boot_seqs()][0];;
+}
+
+#define NAND_RSV_BLOCK_NUM 48
+#define NSP_PAGE0_DISABLE 1
+extern unsigned char *ubootdata;
+static int storage_get_and_parse_ssp(int *need_build) // boot_device:
+{
+	struct storage_startup_parameter *ssp = &g_ssp;
+	union storage_independent_parameter *sip;
+	static struct param_e *storage_param_e;
+	int usb_boot = *need_build;
+
+	memset(ssp, 0, sizeof(struct storage_startup_parameter));
+	if (!usb_boot) {
+		storage_param_e = param_of(STORAGE_PARAM_TPYE);
+		if (!storage_param_e)
+			return -1;
+		memcpy(ssp, storage_param_e->data,
+			sizeof(struct storage_startup_parameter));
+		/* may be sdcard boot and also have to rebuild layout */
+		if (ssp->boot_device == BOOT_ID_SDCARD ||
+		    ssp->boot_device == BOOT_ID_USB) {
+			/* need change the storage base here */
+			*need_build = ssp->boot_device;
+		}
+	}
+
+	if (*need_build) {
+		sip = &ssp->sip;
+		ssp->boot_device = current->type;
+		switch (ssp->boot_device) {
+		case BOOT_EMMC:
+			ssp->boot_bakups = storage_get_emmc_boot_seqs();
+			break;
+		case BOOT_SNOR:
+			if (IS_FEAT_EN_4BL2_SNOR())
+				ssp->boot_bakups = 4;
+			if (IS_FEAT_DIS_NBL2_SNOR())
+				ssp->boot_bakups = 1;
+			break;
+		case BOOT_SNAND:
+			if (IS_FEAT_EN_8BL2_SNAND())
+				ssp->boot_bakups = 8;
+			if (IS_FEAT_DIS_NBL2_SNAND())
+				ssp->boot_bakups = 1;
+			sip->snasp.pagesize = current->info.write_unit;
+			sip->snasp.pages_per_eraseblock =
+			current->info.erase_unit / current->info.write_unit;
+			sip->snasp.eraseblocks_per_lun =
+			(current->info.caps >> 20) / current->info.erase_unit;
+			sip->snasp.planes_per_lun = 1;
+			sip->snasp.luns_per_target = 1;
+			sip->snasp.ntargets = 1;
+			sip->snasp.layout_reserve_size =
+				NAND_RSV_BLOCK_NUM * current->info.erase_unit;
+			break;
+		case BOOT_NAND_NFTL:
+		case BOOT_NAND_MTD:
+			if (IS_FEAT_DIS_8BL2_NAND())
+				ssp->boot_bakups = 4;
+			if (IS_FEAT_DIS_NBL2_NAND())
+				ssp->boot_bakups = 1;
+			ssp->boot_bakups = 8; //FIXIT?? efuse do not work now.
+			sip->nsp.page_size =  current->info.write_unit;
+			sip->nsp.block_size = current->info.erase_unit;
+			sip->nsp.pages_per_block =
+			current->info.erase_unit / current->info.write_unit;
+			sip->nsp.layout_reserve_size =
+				NAND_RSV_BLOCK_NUM * sip->nsp.block_size;
+			sip->nsp.page0_disable =  NSP_PAGE0_DISABLE;
+			break;
+		default:
+			/* do nothing. */
+			break;
+		}
+
+	}
+
+	/* sanity check */
+
+	printf("boot_device:%d\n", ssp->boot_device);
+	printf("boot_seq:%d\n", ssp->boot_seq);
+	printf("boot_bakups:%d\n", ssp->boot_bakups);
+	printf("rebuid_id :%d\n", *need_build);
+
+	return 0;
+}
+
+int storage_post_init(void)
+{
+	int ret = -1;
+	int need_build = 0;
+
+	ret = storage_get_and_parse_ssp(&need_build);
+	if (ret < 0)
+		return -1;
+	storage_boot_layout_general_setting(&general_boot_layout, need_build);
+	storage_boot_layout_debug_info(&general_boot_layout);
+
+	return ret;
+}
+
+int store_init(u32 init_flag)
+{
+	// cpu_id_t cpu_id = get_cpu_id();
+	int i, ret = 0;
+	u8 record = 0;
+
+	/*1. pre scan*/
+	for (i = 0; i < ARRAY_SIZE(device_list); i++) {
+		if (!device_list[i].pre()) {
+			record |= BIT(i);
+		}
+	}
+
+	if (!record) {
+		pr_info("No Valid storage device\n");
+		return record;
+	}
+
+	if (0) //(cpu_id.family_id == MESON_CPU_MAJOR_ID_SC2)
+		storage_post_init();
+
+	/*2. Enter the probe of the valid device*/
+	for (i = 0; i < ARRAY_SIZE(device_list); i++) {
+		if (record & BIT(i)) {
+			ret = device_list[i].probe(init_flag);
+			if (ret)
+				pr_info("the 0x%x storage device probe failed\n",
+			device_list[i].index);
+		}
+	}
+
+	return record;
+}
+
+static struct storage_t *store_get_current(void)
+{
+	return current;
+}
+
+int store_set_device(enum boot_type_e type)
+{
+	struct list_head *entry;
+	struct storage_t *dev, *store_dev = store_get_current();
+
+	if (!store_dev) {
+		pr_info("%s %d no current device\n", __func__, __LINE__);
+		return 1;
+	}
+	if (store_dev->type == type)
+		return 0;
+	list_for_each(entry, &store_dev->list) {
+		dev = list_entry(entry, struct storage_t, list);
+		if (dev->type == type) {
+			current = dev;
+			return 0;
+		}
+	}
+	pr_info("%s %d please confirm the %d device is valid\n",
+		__func__, __LINE__, type);
+	return 1;
+}
+
+enum boot_type_e store_get_type(void)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return BOOT_NONE;
+	}
+
+	return store->type;
+}
+
+int store_get_device_info(struct storage_info_t *info)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+
+	memcpy((char *)info, (char *)&store->info,
+	       sizeof(struct storage_info_t));
+	return 0;
+}
+
+int store_get_device_bootloader_mode(void)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return -1;
+	}
+	return store->info.mode;
+}
+
+int store_read(const char *name, loff_t off, size_t size, void *buf)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->read(name, off, size, buf);
+}
+
+int store_write(const char *name, loff_t off, size_t size, void *buf)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->write(name, off, size, buf);
+}
+
+int store_erase(const char *name, loff_t off, size_t size, int scrub)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->erase(name, off, size, scrub);
+}
+
+u64 store_part_size(const char *name)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->get_part_size(name);
+}
+
+u8 store_boot_copy_num(const char *name)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->get_copies(name);
+}
+
+
+#ifndef  SYSCTRL_SEC_STATUS_REG2
+static u32 fake_reg = 0;
+#define SYSCTRL_SEC_STATUS_REG2		(&fake_reg)
+#endif
+u8 store_boot_copy_start(void)
+{
+	struct storage_t *store = store_get_current();
+	//cpu_id_t cpu_id = get_cpu_id();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 0;
+	}
+	if (store->type != BOOT_EMMC)
+		return 0;
+	if (0) // (cpu_id.family_id == MESON_CPU_MAJOR_ID_SC2)
+		return storage_get_emmc_boot_start();
+	return 0;
+}
+
+u8 store_bootup_bootidx(const char *name)
+{
+	// cpu_id_t cpu_id = get_cpu_id();
+	u8 bl2_idx = 0, fip_idx = 0;
+	u32 val = 0;
+
+	if (0) { // cpu_id.family_id == MESON_CPU_MAJOR_ID_SC2) {
+			bl2_idx = readl(SYSCTRL_SEC_STATUS_REG2) & 0xF;
+			//TODO: fixme after robust devfip is finished.
+			fip_idx = bl2_idx;
+	} else {
+		/* accroding to the:
+			commit 975b4acbcfa686601999d56843471d98e9c0a2cd
+			storage: robust boot: record bootlog in SEC_AO_SEC_GP_CFG2 [1/2]
+			PD#SWPL-4850
+			...
+			record the bootup bl2/fip into SEC_AO_SEC_GP_CFG2
+			bit[27-25] bl2
+			bit[24-22] fip
+		*/
+		val = readl(SEC_AO_SEC_GP_CFG2);
+		bl2_idx = (val >> 25) & 0x7;
+		fip_idx = (val >> 22) & 0x7;
+	}
+	if (!strncmp(name, "bl2", sizeof("bl2")) ||
+			!strncmp(name, "spl", sizeof("spl")))
+		return bl2_idx;
+	else
+		return fip_idx;
+}
+
+void store_restore_bootidx(void)
+{
+	// cpu_id_t cpu_id = get_cpu_id();
+	if (0) { // (cpu_id.family_id == MESON_CPU_MAJOR_ID_SC2) {
+		extern void aml_set_bootsequence(uint32_t val);
+		aml_set_bootsequence(0x55);
+	}
+	return;
+}
+
+u64 store_boot_copy_size(const char *name)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->get_copy_size(name);
+}
+
+int store_boot_read(const char *name, u8 copy, size_t size, void *buf)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->boot_read(name, copy, size, buf);
+}
+
+int store_boot_write(const char *name, u8 copy, size_t size, void *buf)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->boot_write(name, copy, size, buf);
+}
+
+int store_boot_erase(const char *name, u8 copy)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->boot_erase(name, copy);
+}
+
+u32 store_rsv_size(const char *name)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->get_rsv_size(name);
+}
+
+int store_rsv_read(const char *name, size_t size, void *buf)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->read_rsv(name, size, buf);
+}
+
+int store_rsv_write(const char *name, size_t size, void *buf)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->write_rsv(name, size, buf);
+}
+
+int store_rsv_erase(const char *name)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->erase_rsv(name);
+}
+
+int store_rsv_protect(const char *name, bool ops)
+{
+	struct storage_t *store = store_get_current();
+
+	if (!store) {
+		pr_info("%s %d please init storage device first\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return store->protect_rsv(name, ops);
+}
+
+static int do_store_init(struct cmd_tbl *cmdtp,
+			 int flag, int argc, char * const argv[])
+{
+	u32 init_flag = 1;
+	u8 ret = 0;
+
+	if (unlikely(argc != 2 && argc != 3))
+		return CMD_RET_USAGE;
+
+	if (argc == 3)
+		init_flag = simple_strtoul(argv[2], NULL, 10);
+
+	/*Returns a nonzero value: device index*/
+	if (store_init(init_flag))
+		ret = 0;
+	else ret = 1;
+	return ret;
+}
+
+void store_print_device(struct storage_t *store_dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(device_list); i++)
+		if (store_dev->type & device_list[i].index)
+			pr_info("device type: [%s]\n", device_list[i].type);
+	pr_info("name %s\n", store_dev->info.name);
+	pr_info("id :");
+	for (i = 0; i < ARRAY_SIZE(store_dev->info.id); i++)
+		pr_info(" 0x%x", store_dev->info.id[i]);
+	pr_info("\n");
+	pr_info("read unit %d\n", store_dev->info.read_unit);
+	pr_info("write unit %d\n", store_dev->info.write_unit);
+	pr_info("erase unit %d\n", store_dev->info.erase_unit);
+	pr_info("total size %lld\n", store_dev->info.caps);
+	if (store_dev->info.mode)
+		pr_info("bootloader in discrete mode : %d\n",
+			store_dev->info.mode);
+	else
+		pr_info("bootloader in compact mode : %d\n",
+			store_dev->info.mode);
+}
+
+static int do_store_device(struct cmd_tbl *cmdtp,
+			int flag, int argc, char * const argv[])
+{
+	if (argc == 2) {
+		struct storage_t *store_dev, *dev;
+		struct list_head *entry;
+
+		store_dev = store_get_current();
+		pr_info("current device:\n");
+		pr_info("----------------------------------\n");
+		store_print_device(store_dev);
+		pr_info("----------------------------------\n");
+		list_for_each(entry, &store_dev->list) {
+			dev = list_entry(entry, struct storage_t, list);
+			pr_info("valid device:\n");
+			pr_info("----------------------------------\n");
+			store_print_device(dev);
+			pr_info("----------------------------------\n");
+		}
+		return 0;
+	} else if (argc == 3) {
+		char *name = NULL;
+		int i = 0, ret = 0;
+		name = argv[2];
+		for (i = 0; i < ARRAY_SIZE(device_list); i++)
+			if (!strcmp(name, device_list[i].type)) {
+
+				ret = store_set_device(device_list[i].index);
+				if (!ret) {
+					pr_info("now current device is: %s\n",
+						name);
+					return 0;
+				}
+			}
+		pr_info("%s %d no such device: %s\n",
+			__func__, __LINE__, name);
+		return ret;
+	}
+	return CMD_RET_USAGE;
+}
+
+static int do_store_partition(struct cmd_tbl *cmdtp,
+			int flag, int argc, char * const argv[])
+{
+	struct storage_t *store_dev;
+	int i = 0, partitions = 0;
+	int ret = 0;
+	char name[16];
+
+	if (argc > 2)
+		return CMD_RET_USAGE;
+	else {
+		store_dev = store_get_current();
+		if (store_dev->get_part_count)
+			partitions = store_dev->get_part_count();
+		pr_info("%d partitions of device %s:\n",
+			partitions, store_dev->info.name);
+
+		if (store_dev->list_part_name)
+			ret = store_dev->list_part_name(i, name);
+
+		return ret;
+	}
+}
+
+#ifdef CONFIG_AML_MTD
+extern int is_mtd_store_boot_area(const char *part_name);
+#endif
+static int do_store_erase(struct cmd_tbl *cmdtp,
+			  int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	unsigned long offset;
+	size_t size = 0;
+	char *name = NULL;
+	char *s;
+	int scrub_flag = 0, ret;
+	unsigned long time;
+
+	const char *scrub =
+		"Warning: scrub_flag is 1!!!!"
+		"scrub operation!!!\n"
+		"will erase oob area\n"
+		"There is no reliable way to recover them.\n"
+		"		  "
+		"are sure of what you are doing!\n"
+		"\nReally erase this NAND flash? <y/N>\n";
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (strncmp(argv[1], "scrub", 5) == 0)
+		scrub_flag = 1;
+
+	if (scrub_flag == 1) {
+		puts(scrub);
+		if (!confirm_yesno()) {
+			printf("erase aborted\n");
+			return 1;
+		}
+	}
+
+	/*store erase.chip*/
+	s = strchr(argv[1], '.');
+	if (s != NULL && strcmp(s, ".chip") == 0) {
+		offset = 0;
+	} else {
+		/*store erase normal, partition name can't NULL*/
+		if (unlikely(argc != 5))
+			return CMD_RET_USAGE;
+
+		size = (size_t)simple_strtoul(argv[argc - 1], NULL, 16);
+		offset = simple_strtoul(argv[argc - 2], NULL, 16);
+		name = argv[2];
+#ifdef CONFIG_AML_MTD
+		if (is_mtd_store_boot_area(name)) {
+			pr_info("%s %d please enter normal partition name except tpl area!\n",
+				__func__, __LINE__);
+			return CMD_RET_FAILURE;
+		}
+#endif
+	}
+
+	time = get_timer(0);
+	ret = store->erase(name, offset, size, scrub_flag);
+	time = get_timer(time);
+
+	if (size != 0)
+		printf("%lu bytes ", size);
+
+	printf("erased in %lu ms", time);
+	if ((time > 0) && (size != 0)) {
+		puts(" (");
+		print_size(div_u64(size, time) * 1000, "/s");
+		puts(")");
+	}
+	puts("\n");
+
+	return ret;
+}
+
+static int do_store_read(struct cmd_tbl *cmdtp,
+			 int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	unsigned long offset, addr, time;
+	size_t size;
+	char *name = NULL;
+	int ret;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (unlikely(argc != 5 && argc != 6))
+		return CMD_RET_USAGE;
+
+	addr = simple_strtoul(argv[2], NULL, 16);
+	size = (size_t)simple_strtoul(argv[argc - 1], NULL, 16);
+	offset = simple_strtoul(argv[argc - 2], NULL, 16);
+	if (argc == 6)
+		name = argv[3];
+#ifdef CONFIG_AML_MTD
+	if (is_mtd_store_boot_area(name)) {
+			pr_info("%s %d please enter normal partition name except tpl area!\n",
+				__func__, __LINE__);
+			return CMD_RET_FAILURE;
+		}
+#endif
+	time = get_timer(0);
+	ret = store->read(name, offset, size, (u_char *)addr);
+	time = get_timer(time);
+
+	if (size != 0)
+		printf("%lu bytes ", size);
+
+	printf("read in %lu ms", time);
+	if ((time > 0) && (size != 0)) {
+		puts(" (");
+		print_size(div_u64(size, time) * 1000, "/s");
+		puts(")");
+	}
+	puts("\n");
+
+	return ret;
+}
+
+static int name2index(struct boot_layout *boot_layout, const char *img)
+{
+	boot_area_entry_t *boot_entry = NULL;
+	int i;
+
+	boot_entry = boot_layout->boot_entry;
+	for (i = 1; i < MAX_BOOT_AREA_ENTRIES && boot_entry[i].size; i++) {
+		if (!strncmp(img, boot_entry[i].name, strlen(boot_entry[i].name)))
+			return i;
+	}
+
+	return -1;
+}
+
+static int do_store_write_bl2img(struct cmd_tbl *cmdtp,
+			  int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	unsigned long offset, addr;
+	size_t size, size_src;
+	char *name = NULL;
+	int ret = -1, index;
+	struct boot_layout *boot_layout = &general_boot_layout;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	addr = simple_strtoul(argv[2], NULL, 16);
+	name = argv[3];
+	size = simple_strtoul(argv[4], NULL, 16);
+
+	index = name2index(&general_boot_layout, name);
+	offset = boot_layout->boot_entry[index].offset;
+	size_src = boot_layout->boot_entry[index].size;
+	printf("[%s] offset:0x%lx, index:%d\n", name, offset, index);
+
+	if (size_src != size)
+		printf("new img size:0x%lx != img src:0x%lx\n", size, size_src);
+
+	ret = store->boot_write(name, offset, size, (u_char *)addr);
+
+	return ret;
+}
+
+int store_write_bl2img(void* addr, const char *name, size_t size)
+{
+	struct storage_t *store = store_get_current();
+	unsigned long offset;
+	size_t size_src;
+	int ret = -1, index;
+	struct boot_layout *boot_layout = &general_boot_layout;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	index = name2index(&general_boot_layout, name);
+	offset = boot_layout->boot_entry[index].offset;
+	size_src = boot_layout->boot_entry[index].size;
+	printf("[%s] offset:0x%lx, index:%d\n", name, offset, index);
+
+	if (size_src != size)
+		printf("new img size:0x%zx != img src:0x%zx\n", size, size_src);
+
+	ret = store->boot_write(name, offset, size, (u_char *)addr);
+	if (size != 0)
+		printf("[%s][%d]%lx bytes\n", __func__, __LINE__, size);
+
+	return ret;
+}
+
+static int do_store_write(struct cmd_tbl *cmdtp,
+			  int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	unsigned long offset, addr, time;
+	size_t size;
+	char *name = NULL;
+	int ret;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (unlikely(argc != 5 && argc != 6))
+		return CMD_RET_USAGE;
+
+	addr = simple_strtoul(argv[2], NULL, 16);
+	offset = simple_strtoul(argv[argc - 2], NULL, 16);
+	size = (size_t)simple_strtoul(argv[argc - 1], NULL, 16);
+	if (argc == 6)
+		name = argv[3];
+#ifdef CONFIG_AML_MTD
+	if (is_mtd_store_boot_area(name)) {
+			pr_info("%s %d please enter normal partition name except tpl area!\n",
+				__func__, __LINE__);
+			return CMD_RET_FAILURE;
+		}
+#endif
+	time = get_timer(0);
+	ret = store->write(name, offset, size, (u_char *)addr);
+	time = get_timer(time);
+
+	if (size != 0)
+		printf("%lu bytes ", size);
+
+	printf("write in %lu ms", time);
+	if ((time > 0) && (size != 0)) {
+		puts(" (");
+		print_size(div_u64(size, time) * 1000, "/s");
+		puts(")");
+	}
+	puts("\n");
+
+	return ret;
+}
+
+static int do_store_boot_read(struct cmd_tbl *cmdtp,
+			      int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	unsigned long addr;
+	size_t size;
+	u8 cpy;
+	char *name;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (unlikely(argc != 6))
+		return CMD_RET_USAGE;
+
+	name = argv[2];
+	addr = (unsigned long)simple_strtoul(argv[3], NULL, 16);
+	cpy = (u8)simple_strtoul(argv[4], NULL, 16);
+	size = (size_t)simple_strtoul(argv[5], NULL, 16);
+
+	return store->boot_read(name, cpy, size, (u_char *)addr);
+}
+
+static int bl2x_mode_check_header(p_payload_info_t pInfo)
+{
+	p_payload_info_hdr_t hdr    = &pInfo->hdr;
+	const int nItemNum = hdr->byItemNum;
+	p_payload_info_item_t pItem = pInfo->arrItems;
+	u8 i = 0;
+	int sz_payload = 0;
+	uint64_t align_size = 1;
+	struct storage_startup_parameter *ssp = &g_ssp;
+	u8 cal_copy = ssp->boot_bakups;
+
+	printf("\naml log : info parse...\n");
+	printf("\tsztimes : %s\n",hdr->szTimeStamp);
+	printf("\tversion : %d\n",hdr->byVersion);
+	printf("\tItemNum : %d\n",nItemNum);
+	printf("\tSize    : %d(0x%x)\n",    hdr->nSize, hdr->nSize);
+	if (nItemNum > 8 || nItemNum < 3) {
+		pr_info("illegal nitem num %d\n", nItemNum);
+		return __LINE__;
+	}
+	if (ssp->boot_device == BOOT_NAND_MTD)
+		align_size = ((NAND_RSV_OFFSET / cal_copy) * ssp->sip.nsp.page_size);
+	else if (ssp->boot_device == BOOT_SNAND)
+		align_size = ((NAND_RSV_OFFSET / cal_copy) * ssp->sip.snasp.pagesize);
+
+	sz_payload = pItem->nPayLoadSize;
+	STORAGE_ROUND_UP_IF_UNALIGN(sz_payload, align_size);
+	if (sz_payload > ssp->boot_entry[0].size)
+		return __LINE__;
+	if (ssp->boot_device == BOOT_NAND_MTD)
+		align_size = ssp->sip.nsp.block_size;
+	else if (ssp->boot_device == BOOT_SNAND)
+		align_size = ssp->sip.snasp.pagesize *
+		ssp->sip.snasp.pages_per_eraseblock;
+	++pItem;
+
+	for (i = 1; i < nItemNum; i++, ++pItem) {
+		sz_payload = pItem->nPayLoadSize;
+		STORAGE_ROUND_UP_IF_UNALIGN(sz_payload, align_size);
+		if (sz_payload > ssp->boot_entry[i].size)
+			return __LINE__;
+	}
+
+	return 0;
+}
+
+static int _store_boot_write(const char *part_name, u8 cpy, size_t size, void *addr)
+{
+	// cpu_id_t cpu_id = get_cpu_id();
+	enum boot_type_e medium_type = store_get_type();
+	struct storage_startup_parameter *ssp = &g_ssp;
+	//struct storage_boot_entry *boot_entry = ssp->boot_entry;
+	//u8 i;
+	int ret = 0;
+	struct storage_t *store = store_get_current();
+	int bl2_size = BL2_SIZE;
+	int bl2_cpynum = 0;
+	int tpl_per_size = CONFIG_TPL_SIZE_PER_COPY;
+	int tpl_cpynum = 0;
+	int bootloader_maxsize = 0;
+
+	if (store_get_device_bootloader_mode() != DISCRETE_BOOTLOADER)
+		return store->boot_write(part_name, cpy, size, (u_char *)addr);
+
+	if (BOOT_NAND_MTD == medium_type ||  BOOT_SNAND == medium_type)
+		tpl_cpynum = CONFIG_NAND_TPL_COPY_NUM;
+	else if (medium_type == BOOT_SNOR)
+		tpl_cpynum = CONFIG_NOR_TPL_COPY_NUM;
+
+	if (0) { // cpu_id.family_id == MESON_CPU_MAJOR_ID_SC2) {
+		bl2_cpynum = ssp->boot_bakups;
+	} else	{
+		bootloader_maxsize = bl2_size + tpl_per_size;
+		bl2_cpynum = CONFIG_BL2_COPY_NUM;
+		if (size > bootloader_maxsize) {
+			pr_info("bootloader sz 0x%lx too large,max sz 0x%x\n",
+				size, bootloader_maxsize);
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	if ((cpy >= tpl_cpynum || cpy >= bl2_cpynum) && (cpy != BOOT_OPS_ALL)) {
+		pr_info("update copy %d invalid, must < min(%d, %d)\n",
+			cpy, tpl_cpynum, bl2_cpynum);
+		return CMD_RET_FAILURE;
+	}
+
+	p_payload_info_t pinfo = parse_uboot_sheader((u8 *)addr);
+
+	if (!pinfo) {
+		ret = store->boot_write("tpl", cpy, size - bl2_size, (u_char *)(addr +bl2_size));
+		if (ret) {
+			pr_info("failed update tpl\n");
+			return CMD_RET_FAILURE;
+		}
+	} else {
+		if (bl2x_mode_check_header(pinfo)) {
+			pr_info("!!!warning bl2xx size is bigger than bl2x layout size\n");
+			pr_info("plase check bl2x,or erase flash and turn off\n");
+			pr_info("then turn on, and update uboot again\n");
+			return CMD_RET_FAILURE;
+		}
+
+		char name[8];
+		int nindex = 0;
+		p_payload_info_hdr_t hdr    = &pinfo->hdr;
+		p_payload_info_item_t pitem = pinfo->arrItems;
+		int off_payload = 0;
+		int sz_payload = 0;
+
+		memset(name, 0, 8);
+		for (nindex = 1, pitem +=1; nindex < hdr->byItemNum; ++nindex, ++pitem) {
+			memcpy(name, &pitem->nMagic, sizeof(unsigned int));
+			off_payload = pitem->nOffset;
+			sz_payload = pitem->nPayLoadSize;
+			pr_info("item[%d]%4s offset 0x%08x sz 0x%x\n",
+				nindex, name, off_payload, sz_payload);
+			if (!sz_payload)
+				continue;
+			ret = store->boot_write(general_boot_part_entry[nindex].name, cpy, sz_payload, (u_char *)(addr + off_payload));
+			if (ret) {
+				pr_info("Fail in flash payload %s\n",name);
+				return CMD_RET_FAILURE;
+			}
+		}
+	}
+
+	ret =  store->boot_write("bl2", cpy, bl2_size, (u_char *)addr);
+	if (ret) {
+		pr_info("Fail in flash payload bl2\n");
+		return CMD_RET_FAILURE;
+	}
+	return ret;
+
+}
+
+static int do_store_boot_write(struct cmd_tbl *cmdtp,
+			       int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	unsigned long addr;
+	size_t size;
+	u8 cpy = BOOT_OPS_ALL;
+	char *name;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (unlikely(argc != 5 && argc != 6))
+		return CMD_RET_USAGE;
+
+	name = argv[2];
+	addr = (unsigned long)simple_strtoul(argv[3], NULL, 16);
+	size = (size_t)simple_strtoul(argv[argc - 1], NULL, 16);
+	if (argc == 6)
+		cpy = (u8)simple_strtoul(argv[4], NULL, 16);
+
+	if (strcmp(name, "bootloader") == 0) {
+		return _store_boot_write(name, cpy, size, (u_char *)addr);
+	}
+
+	return store->boot_write(name, cpy, size, (u_char *)addr);
+}
+
+static int do_store_boot_erase(struct cmd_tbl *cmdtp,
+			       int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	u8 cpy = BOOT_OPS_ALL;
+	char *name;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (unlikely(argc != 3 && argc != 4))
+		return CMD_RET_USAGE;
+
+	name = argv[2];
+	if (argc == 4)
+		cpy = (u8)simple_strtoul(argv[3], NULL, 16);
+
+	return store->boot_erase(name, cpy);
+}
+
+static int do_store_rsv_ops(struct cmd_tbl *cmdtp,
+			    int flag, int argc, char * const argv[])
+{
+	struct storage_t *store = store_get_current();
+	char *name = NULL;
+
+	if (!store) {
+		pr_info("%s %d please init your storage device first!\n",
+			__func__, __LINE__);
+		return CMD_RET_FAILURE;
+	}
+
+	if (!strcmp(argv[2], "erase")) {
+		if (argc == 3)
+			;
+		else if (argc == 4)
+			name = argv[3];
+		else
+			return CMD_RET_USAGE;
+		return store->erase_rsv(name);
+	} else if (!strcmp(argv[2], "read") ||
+			   !strcmp(argv[2], "write")) {
+		u8 cmd = strcmp(argv[2], "read") ? 0 : 1;
+		unsigned long addr = simple_strtoul(argv[4], NULL, 16);
+		size_t size = (size_t)simple_strtoul(argv[5], NULL, 16);
+
+		name = argv[3];
+		if (unlikely(argc != 6))
+			return CMD_RET_USAGE;
+		if (cmd)
+			return store->read_rsv(name, size, (u_char *)addr);
+		else
+			return store->write_rsv(name, size, (u_char *)addr);
+	} else if (!strcmp(argv[2], "protect")) {
+		bool flag = false;
+		char *ops;
+
+		if (unlikely(argc != 4 && argc != 5))
+			return CMD_RET_USAGE;
+
+		name = (argc == 4) ? NULL : argv[3];
+		ops = argv[argc - 1];
+		if (!strcmp(ops, "on"))
+			flag = true;
+		else if (!strcmp(ops, "off"))
+			flag = false;
+		return store->protect_rsv(name, flag);
+	}
+	return CMD_RET_USAGE;
+}
+
+static struct cmd_tbl cmd_store_sub[] = {
+	U_BOOT_CMD_MKENT(init, 4, 0, do_store_init, "", ""),
+	U_BOOT_CMD_MKENT(device, 4, 0, do_store_device, "", ""),
+	U_BOOT_CMD_MKENT(partition, 3, 0, do_store_partition, "", ""),
+	U_BOOT_CMD_MKENT(scrub, 5, 0, do_store_erase, "", ""),
+	U_BOOT_CMD_MKENT(erase, 5, 0, do_store_erase, "", ""),
+	U_BOOT_CMD_MKENT(read, 6, 0, do_store_read, "", ""),
+	U_BOOT_CMD_MKENT(write, 7, 0, do_store_write, "", ""),
+	U_BOOT_CMD_MKENT(write_bl2img, 5, 0, do_store_write_bl2img, "", ""),
+	U_BOOT_CMD_MKENT(boot_read,	6, 0, do_store_boot_read, "", ""),
+	U_BOOT_CMD_MKENT(boot_write, 6, 0, do_store_boot_write, "", ""),
+	U_BOOT_CMD_MKENT(boot_erase, 4, 0, do_store_boot_erase, "", ""),
+	U_BOOT_CMD_MKENT(rsv, 6, 0, do_store_rsv_ops, "", ""),
+};
+
+static int do_store(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct cmd_tbl *c;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	c = find_cmd_tbl(argv[1], cmd_store_sub, ARRAY_SIZE(cmd_store_sub));
+	if (c)
+		return c->cmd(cmdtp, flag, argc, argv);
+
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(store, CONFIG_SYS_MAXARGS, 1, do_store,
+	"STORE sub-system:",
+	"store init [flag]\n"
+	"	init storage device\n"
+	"store device [name]\n"
+	"	show or set storage device\n"
+	"	'store device' command will list\n"
+	"	all valid storage device and print.\n"
+	"	'store device [name]' will set the\n"
+	"	[name] device to the current device\n"
+	"store partition\n"
+	"	show partitions of current device\n"
+	"store read addr [partition name] off size\n"
+	"	read 'size' bytes from offset 'off'\n"
+	"	of device/partition 'partition name' to.\n"
+	"	address 'addr' of memory.\n"
+	"	if partition name not value. read start with\n"
+	"	offset in normal logic area,if tpl area exist\n"
+	"	read offset at end of tpl area\n"
+	"store write addr [partition name] off size\n"
+	"	write 'size' bytes to offset 'off' of\n"
+	"	device/partition [partition name] from\n"
+	"	address 'addr' of memory.\n"
+	"	if partition name not value. write start with\n"
+	"	offset in normal logic area,if tpl area exist\n"
+	"	write offset at end of tpl area\n"
+	"store erase partition name off size.\n"
+	"	erase 'size' bytes from offset 'off'\n"
+	"	of device/partition [partition name]\n"
+	"	partition name must't NULL\n"
+	"store scrub partition name off size.\n"
+	"	erase 'size' bytes from offset 'off'\n"
+	"	of device/partition [partition name]\n"
+	"	includes oob area if the device has.\n"
+	"	partition name must't NULL\n"
+	"store erase.chip\n"
+	"	erase all nand chip,except bad block\n"
+	"store scrub.chip\n"
+	"	erase all nand chip,include bad block\n"
+	"store boot_read name addr copy size\n"
+	"	read 'size' bytes from 'copy'th backup\n"
+	"	in name partition, 'copy' can't be null.\n"
+	"	name:\n"
+	"	in discrete mode: 'bl2'/'tpl'(fip)\n"
+	"	in compact mode: 'bootloader'\n"
+	"store boot_write name addr [copy] size\n"
+	"	write 'size' bytes to 'copy'th backup\n"
+	"	in [name] partition from address\n"
+	"	'addr' of memory. when the optional 'copy'\n"
+	"	is null, it will writes to all copies\n"
+	"	name:\n"
+	"	in discrete mode:\n"
+	"	'bl2/bl2e/bl2x/ddrfip/tpl(fip), only update part\n"
+	"	'bootloader', update whole uboot.bin, in this case\n"
+	"	@copy:if used, must < min(tplCpyNum, Bl2CpyNum), update only the specified copy\n"
+	"	if not used, update all the copies of bl2 bl2e bl2x ddrfip tpl!\n"
+	"	in compact mode: 'bootloader'\n"
+	"store boot_erase name [copy]\n"
+	"	erase the name info from 'copy'th backup\n"
+	"	when the optional 'copy' not value, it\n"
+	"	will erase all copies.\n"
+	"	name:\n"
+	"	in discrete mode: \n"
+	"	'bl2'/'tpl'(fip): erase bl2/tpl partition\n"
+	"	'bootloader':erase bl2 + tpl partition\n"
+	"	in compact mode: 'bootloader'\n"
+	"store rsv read name addr size\n"
+	"	read 'size' bytes 'name' rsv info\n"
+	"	to address 'addr' of memory\n"
+	"	'name' could be key/dtb/env etc...\n"
+	"store rsv write name addr size\n"
+	"	write 'size' bytes 'name' rsv info\n"
+	"	from address 'addr' of memory\n"
+	"store rsv erase name\n"
+	"	erase 'name' rsv info\n"
+	"	name must't null\n"
+	"store rsv protect name on/off\n"
+	"	turn on/off the rsv info protection\n"
+	"	name must't null\n"
+);
diff --git a/common/Makefile b/common/Makefile
index 75c24e3249..acb06adad4 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -11,6 +11,9 @@ obj-y += exports.o
 obj-$(CONFIG_HUSH_PARSER) += cli_hush.o
 obj-$(CONFIG_AUTOBOOT) += autoboot.o
 
+obj-$(CONFIG_AML_STORAGE) += partitions.o
+obj-$(CONFIG_AML_STORAGE) += aml_dt.o
+
 # # boards
 obj-y += board_f.o
 obj-y += board_r.o
diff --git a/common/aml_dt.c b/common/aml_dt.c
new file mode 100644
index 0000000000..a6888999d4
--- /dev/null
+++ b/common/aml_dt.c
@@ -0,0 +1,600 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+* *
+This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+* *
+This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+* *
+You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+* *
+Description:
+*/
+#include <common.h>
+#include <bootm.h>
+#include <command.h>
+#include <image.h>
+#include <malloc.h>
+#include <amlogic/asm/io.h>
+#include <amlogic/asm/secure_apb.h>
+#include <amlstorage/partition_table.h>
+#include <gzip.h>
+
+//#define AML_DT_DEBUG
+#ifdef AML_DT_DEBUG
+#define dbg_printf(...) printf(__VA_ARGS__)
+#else
+#define dbg_printf(...) ((void)0)
+#endif
+
+#define  AML_MULTI_DTB_API_NEW
+//#define AML_MULTI_DTB_CHECK_CMD //command for multi-dtb test
+
+#ifdef AML_MULTI_DTB_API_NEW
+
+/*for multi-dtb gzip buffer*/
+#define GUNZIP_BUF_SIZE         (1<<20)     /*1MB  is enough?*/
+
+/*magic for multi-dtb*/
+#define MAGIC_GZIP_MASK         (0x0000FFFF)
+#define MAGIC_GZIP_ID           (0x00008B1F)
+#define IS_GZIP_PACKED(nMagic)  (MAGIC_GZIP_ID == (MAGIC_GZIP_MASK & nMagic))
+#define MAGIC_DTB_SGL_ID        (0xedfe0dd0)
+#define MAGIC_DTB_MLT_ID        (0x5f4c4d41)
+
+/*amlogic multi-dtb version*/
+#define AML_MUL_DTB_VER_1       (1)
+#define AML_MUL_DTB_VER_2       (2)
+
+/*max char for dtb name, fixed to soc_package_board format*/
+#define AML_MAX_DTB_NAME_SIZE   (128)
+#define AML_DTB_TOKEN_MAX_COUNT (AML_MAX_DTB_NAME_SIZE>>1)
+
+typedef struct{
+	unsigned int nMagic;
+	unsigned int nVersion;
+	unsigned int nDTBCount;
+}st_dtb_hdr_t,*p_st_dtb_hdr_t;
+
+/*v1,v2 multi-dtb only support max to 3 tokens for each DTB name*/
+#define MULTI_DTB_TOKEN_MAX_COUNT      (3)
+#define MULTI_DTB_TOKEN_UNIT_SIZE_V1   (4)      //v1 support 4bytes for each token
+#define MULTI_DTB_TOKEN_UNIT_SIZE_V2   (16)     //v2 support 16bytes for each token
+
+/*v1 multi-dtb*/
+typedef struct{
+	unsigned char     szToken[MULTI_DTB_TOKEN_MAX_COUNT][MULTI_DTB_TOKEN_UNIT_SIZE_V1];
+	int               nDTBOffset;
+	int               nDTBIMGSize;
+}st_dtb_token_v1_t,*p_st_dtb_token_v1_t;
+
+typedef struct{
+	st_dtb_hdr_t      hdr;
+	st_dtb_token_v1_t dtb[1];
+}st_dtb_v1_t,*p_st_dtb_v1_t;
+
+
+/*v2 multi-dtb*/
+typedef struct{
+	unsigned char     szToken[MULTI_DTB_TOKEN_MAX_COUNT][MULTI_DTB_TOKEN_UNIT_SIZE_V2];
+	int               nDTBOffset;
+	int               nDTBIMGSize;
+}st_dtb_token_v2_t,*p_st_dtb_token_v2_t;
+
+typedef struct{
+	st_dtb_hdr_t      hdr;
+	st_dtb_token_v2_t dtb[1];
+}st_dtb_v2_t,*p_st_dtb_v2_t;
+
+
+/*to get the valid DTB index with matched DTB name*/
+static int get_dtb_index(const char aml_dt_buf[128],unsigned long fdt_addr)
+{
+	int nReturn = -1;
+
+	if (!aml_dt_buf)
+		goto exit;
+
+	p_st_dtb_hdr_t pDTBHdr = (p_st_dtb_hdr_t)fdt_addr;
+	char sz_aml_dt_msb[10][MULTI_DTB_TOKEN_UNIT_SIZE_V2];
+	memset(sz_aml_dt_msb,0,sizeof(sz_aml_dt_msb));
+
+	/* split aml_dt with token '_',  e.g "tm2-revb_t962x3_ab301" */
+	//printf("		aml_dt : %s\n",aml_dt_buf);
+
+	char *tokens[AML_DTB_TOKEN_MAX_COUNT];
+	char sz_temp[AML_MAX_DTB_NAME_SIZE+4];
+	memset(tokens,0,sizeof(tokens));
+	memset(sz_temp,0,sizeof(sz_temp));
+	strncpy(sz_temp,aml_dt_buf,128);
+	int i,j;
+	int nLen = strlen(sz_temp);
+	sz_temp[nLen]='_';
+	sz_temp[nLen+1]='\0';
+	nLen +=1;
+	tokens[0]=sz_temp;
+	for (i = 1; i < sizeof(tokens)/sizeof(tokens[0]); i++)
+	{
+		tokens[i] = strstr(tokens[i-1],"_");
+		if (!tokens[i])
+			break;
+
+		*tokens[i]='\0';
+
+		tokens[i]=tokens[i]+1;
+
+		if (!(*tokens[i]))
+		{
+			tokens[i] = 0;
+			break;
+		}
+	}
+
+	//for (i=0;i<10 && tokens[i];++i)
+	//	printf("token-%d:%s\n",i,tokens[i]);
+
+	int nTokenLen = 0;
+
+	switch (pDTBHdr->nVersion)
+	{
+	case AML_MUL_DTB_VER_1:
+	{
+		nTokenLen = MULTI_DTB_TOKEN_UNIT_SIZE_V1;
+	}break;
+	case AML_MUL_DTB_VER_2:
+	{
+		nTokenLen = MULTI_DTB_TOKEN_UNIT_SIZE_V2;
+	}break;
+	default: goto exit; break;
+	}
+
+
+	for (i = 0;i<MULTI_DTB_TOKEN_MAX_COUNT;++i)
+	{
+		if (tokens[i])
+		{
+			char *pbyswap = (char*)sz_aml_dt_msb+(nTokenLen*i);
+			strcpy(pbyswap,tokens[i]);
+			unsigned int nValSwap;
+			for (j = 0;j< nTokenLen;j+=4)
+			{
+				int m;
+				/*swap byte order with unit@4bytes*/
+				nValSwap = *(unsigned int *)(pbyswap+j);
+				for (m=0;m<4;m++)
+					pbyswap[j+m] = (nValSwap >> ((3-m)<<3)) & 0xFF;
+
+				/*replace 0 with 0x20*/
+				for (m=0;m<MULTI_DTB_TOKEN_UNIT_SIZE_V2;++m)
+					if (0 == pbyswap[m])
+						pbyswap[m]=0x20;
+			}
+		}
+		else
+			break;
+	}
+
+	switch (pDTBHdr->nVersion)
+	{
+	case AML_MUL_DTB_VER_1:
+	{
+		p_st_dtb_v1_t pDTB_V1 = (p_st_dtb_v1_t)fdt_addr;
+		for (i=0;i< pDTB_V1->hdr.nDTBCount;++i)
+		{
+			if (!memcmp(pDTB_V1->dtb[i].szToken,sz_aml_dt_msb,
+				MULTI_DTB_TOKEN_MAX_COUNT*nTokenLen))
+			{
+				nReturn = i;
+				break;
+			}
+		}
+
+	}break;
+	case AML_MUL_DTB_VER_2:
+	{
+		p_st_dtb_v2_t pDTB_V2 = (p_st_dtb_v2_t)fdt_addr;
+		for (i=0;i< pDTB_V2->hdr.nDTBCount;++i)
+		{
+			if (!memcmp(pDTB_V2->dtb[i].szToken,sz_aml_dt_msb,
+				MULTI_DTB_TOKEN_MAX_COUNT*nTokenLen))
+			{
+				nReturn = i;
+				break;
+			}
+		}
+
+	}break;
+	default: goto exit; break;
+	}
+
+exit:
+
+	return nReturn;
+
+}
+
+unsigned long __attribute__((unused))	get_multi_dt_entry(unsigned long fdt_addr)
+{
+	unsigned long lReturn = 0; //return buffer for valid DTB;
+	void * gzip_buf = NULL;
+	unsigned long pInputFDT  = fdt_addr;
+	p_st_dtb_hdr_t pDTBHdr   = (p_st_dtb_hdr_t)pInputFDT;
+	unsigned long unzip_size = GUNZIP_BUF_SIZE;
+
+	printf("      Amlogic Multi-DTB tool\n");
+
+	/* first check the blob header, support GZIP format */
+	if ( IS_GZIP_PACKED(pDTBHdr->nMagic))
+	{
+		printf("      GZIP format, decompress...\n");
+		gzip_buf = malloc(GUNZIP_BUF_SIZE);
+		if (!gzip_buf)
+		{
+			printf("      ERROR! fail to allocate memory for GUNZIP...\n");
+			goto exit;
+		}
+		memset(gzip_buf, 0, GUNZIP_BUF_SIZE);
+		if (gunzip(gzip_buf, GUNZIP_BUF_SIZE, (void *)pInputFDT, &unzip_size) < 0)
+		{
+			printf("      ERROR! GUNZIP process fail...\n");
+			goto exit;
+		}
+		if (unzip_size > GUNZIP_BUF_SIZE)
+		{
+			printf("      ERROR! GUNZIP overflow...\n");
+			goto exit;
+		}
+		//memcpy((void*)fdt_addr,gzip_buf,unzip_size);
+		pInputFDT = (unsigned long)gzip_buf;
+		pDTBHdr   = (p_st_dtb_hdr_t)pInputFDT;
+	}
+
+
+	switch (pDTBHdr->nMagic)
+	{
+	case MAGIC_DTB_SGL_ID:
+	{
+		printf("      Single DTB detected\n");
+
+		if (fdt_addr != (unsigned long)pInputFDT) //in case of GZIP single DTB
+			memcpy((void*)fdt_addr,(void*)pInputFDT,unzip_size);
+
+		lReturn = fdt_addr;
+
+	}break;
+	case MAGIC_DTB_MLT_ID:
+	{
+		printf("      Multi DTB detected.\n");
+		printf("      Multi DTB tool version: v%d.\n", pDTBHdr->nVersion);
+		printf("      Support %d DTBS.\n", pDTBHdr->nDTBCount);
+
+
+		/* check and set aml_dt */
+		char aml_dt_buf[AML_MAX_DTB_NAME_SIZE+4];
+		memset(aml_dt_buf, 0, sizeof(aml_dt_buf));
+
+		/* update 2016.07.27, checkhw and setenv everytime,
+		or else aml_dt will set only once if it is reserved */
+		extern int checkhw(char * name);
+#if 1
+		if (checkhw(aml_dt_buf) < 0 || strlen(aml_dt_buf) <= 0)
+		{
+			printf("      Get env aml_dt failed!\n");
+			goto exit;
+		}
+#else
+		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
+		/* if aml_dt not exist or env not ready, get correct dtb by name */
+		if (NULL == aml_dt)
+			checkhw(aml_dt_buf);
+		else
+			memcpy(aml_dt_buf, aml_dt,
+			(strlen(aml_dt)>AML_MAX_DTB_NAME_SIZE?AML_MAX_DTB_NAME_SIZE:(strlen(aml_dt)+1)));
+#endif
+
+		int dtb_match_num = get_dtb_index(aml_dt_buf,(unsigned long)pInputFDT);
+
+		/*check valid dtb index*/
+		if (dtb_match_num < 0 || dtb_match_num >= pDTBHdr->nDTBCount)
+		{
+			printf("      NOT found matched DTB for \"%s\"\n",aml_dt_buf);
+			goto exit;
+		}
+
+		printf("      Found DTB for \"%s\"\n",aml_dt_buf);
+
+		switch (pDTBHdr->nVersion)
+		{
+		case AML_MUL_DTB_VER_1:
+		{
+			p_st_dtb_v1_t pDTB_V1 = (p_st_dtb_v1_t)pInputFDT;
+			lReturn = pDTB_V1->dtb[dtb_match_num].nDTBOffset + pInputFDT;
+
+			if (pInputFDT != fdt_addr)
+			{
+				memcpy((void*)fdt_addr, (void*)lReturn,pDTB_V1->dtb[dtb_match_num].nDTBIMGSize);
+				lReturn = fdt_addr;
+			}
+
+		}break;
+		case AML_MUL_DTB_VER_2:
+		{
+			p_st_dtb_v2_t pDTB_V2 = (p_st_dtb_v2_t)pInputFDT;
+			lReturn = pDTB_V2->dtb[dtb_match_num].nDTBOffset + pInputFDT;
+
+			if (pInputFDT != fdt_addr)
+			{
+				memcpy((void*)fdt_addr, (void*)lReturn,pDTB_V2->dtb[dtb_match_num].nDTBIMGSize);
+				lReturn = fdt_addr;
+			}
+
+		}break;
+		default:
+		{
+			printf("      Invalid Multi-DTB Version [%d]!\n",
+				pDTBHdr->nVersion);
+			goto exit;
+		}break;
+		}
+
+	}break;
+	default: goto exit; break;
+	}
+
+exit:
+
+	if (gzip_buf)
+	{
+		free(gzip_buf);
+		gzip_buf = 0;
+	}
+
+	return lReturn;
+}
+
+#else //#ifdef AML_MULTI_DTB_API_NEW
+
+#define AML_DT_IND_LENGTH_V1		4	/*fixed*/
+#define AML_DT_IND_LENGTH_V2		16	/*fixed*/
+
+#define AML_DT_IND_LENGTH			16
+#define AML_DT_ID_VARI_TOTAL		3	//Total 3 strings
+#define AML_DT_EACH_ID_INT			(AML_DT_IND_LENGTH / 4)
+
+/*Latest version: v2*/
+#define AML_DT_VERSION_OFFSET		4
+#define AML_DT_TOTAL_DTB_OFFSET		8
+#define AML_DT_FIRST_DTB_OFFSET		12
+//#define AML_DT_DTB_HEADER_SIZE	(8+(AML_DT_IND_LENGTH * AML_DT_ID_VARI_TOTAL))
+#define AML_DT_DTB_DT_INFO_OFFSET	0
+//#define AML_DT_DTB_OFFSET_OFFSET	(AML_DT_IND_LENGTH * AML_DT_ID_VARI_TOTAL)
+//#define AML_DT_DTB_SIZE_OFFSET	16
+
+#define AML_DT_UBOOT_ENV	"aml_dt"
+#define DT_HEADER_MAGIC		0xedfe0dd0	/*header of dtb file*/
+#define AML_DT_HEADER_MAGIC	0x5f4c4d41	/*"AML_", multi dtbs supported*/
+
+#define IS_GZIP_FORMAT(data)		((data & (0x0000FFFF)) == (0x00008B1F))
+#define GUNZIP_BUF_SIZE				(0x500000) /* 5MB */
+#define DTB_MAX_SIZE				(AML_DTB_IMG_MAX_SZ)
+
+//#define readl(addr) (*(volatile unsigned int*)(addr))
+extern int checkhw(char * name);
+
+unsigned long __attribute__((unused))
+	get_multi_dt_entry(unsigned long fdt_addr){
+	unsigned int dt_magic = readl(fdt_addr);
+	unsigned int dt_total = 0;
+	unsigned int dt_tool_version = 0;
+	unsigned int gzip_format = 0;
+	void * gzip_buf = NULL;
+	unsigned long dt_entry = fdt_addr;
+
+	printf("      Amlogic multi-dtb tool\n");
+
+	/* first check the file header, support GZIP format */
+	gzip_format = IS_GZIP_FORMAT(dt_magic);
+	if (gzip_format) {
+		printf("      GZIP format, decompress...\n");
+		gzip_buf = malloc(GUNZIP_BUF_SIZE);
+		memset(gzip_buf, 0, GUNZIP_BUF_SIZE);
+		unsigned long unzip_size = GUNZIP_BUF_SIZE;
+		gunzip(gzip_buf, GUNZIP_BUF_SIZE, (void *)fdt_addr, &unzip_size);
+		dbg_printf("      DBG: unzip_size: 0x%x\n", (unsigned int)unzip_size);
+		if (unzip_size > GUNZIP_BUF_SIZE) {
+			printf("      Warning! GUNZIP overflow...\n");
+		}
+		fdt_addr = (unsigned long)gzip_buf;
+		dt_magic = readl(fdt_addr);
+	}
+
+	dbg_printf("      DBG: fdt_addr: 0x%x\n", (unsigned int)fdt_addr);
+	dbg_printf("      DBG: dt_magic: 0x%x\n", (unsigned int)dt_magic);
+
+	/*printf("      Process device tree. dt magic: %x\n", dt_magic);*/
+	if (dt_magic == DT_HEADER_MAGIC) {/*normal dtb*/
+		printf("      Single dtb detected\n");
+		if (gzip_format) {
+			memcpy((void *)dt_entry, (void *)fdt_addr, DTB_MAX_SIZE);
+			fdt_addr = dt_entry;
+			if (gzip_buf)
+				free(gzip_buf);
+		}
+		return fdt_addr;
+	}
+	else if (dt_magic == AML_DT_HEADER_MAGIC) {/*multi dtb*/
+		printf("      Multi dtb detected\n");
+		/* check and set aml_dt */
+		int i = 0;
+		char *aml_dt_buf;
+		aml_dt_buf = (char *)malloc(sizeof(char)*64);
+		printf("Multi dtb malloc aml_dt_buf addr = %p\n", aml_dt_buf);
+		memset(aml_dt_buf, 0, sizeof(aml_dt_buf));
+
+		/* update 2016.07.27, checkhw and setenv everytime,
+		or else aml_dt will set only once if it is reserved */
+#if 1
+		checkhw(aml_dt_buf);
+#else
+		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
+		/* if aml_dt not exist or env not ready, get correct dtb by name */
+		if (NULL == aml_dt)
+			checkhw(aml_dt_buf);
+		else
+			memcpy(aml_dt_buf, aml_dt, (strlen(aml_dt)>64?64:(strlen(aml_dt)+1)));
+#endif
+
+		unsigned int aml_dt_len = aml_dt_buf ? strlen(aml_dt_buf) : 0;
+		if (aml_dt_len <= 0) {
+			printf("      Get env aml_dt failed!\n");
+			if (aml_dt_buf)
+				free(aml_dt_buf);
+			if (gzip_buf)
+				free(gzip_buf);
+			return fdt_addr;
+		}
+
+		/*version control, compatible with v1*/
+		dt_tool_version = readl(fdt_addr + AML_DT_VERSION_OFFSET);
+		unsigned int aml_each_id_length=0;
+		unsigned int aml_dtb_offset_offset;
+		unsigned int aml_dtb_header_size;
+		if (dt_tool_version == 1)
+			aml_each_id_length = 4;
+		else if(dt_tool_version == 2)
+			aml_each_id_length = 16;
+
+		aml_dtb_offset_offset = aml_each_id_length * AML_DT_ID_VARI_TOTAL;
+		aml_dtb_header_size = 8+(aml_each_id_length * AML_DT_ID_VARI_TOTAL);
+		printf("      Multi dtb tool version: v%d .\n", dt_tool_version);
+
+		/*fdt_addr + 0x8: num of dtbs*/
+		dt_total = readl(fdt_addr + AML_DT_TOTAL_DTB_OFFSET);
+		printf("      Support %d dtbs.\n", dt_total);
+
+		/* split aml_dt to 3 strings */
+		char *tokens[3] = {NULL, NULL, NULL};
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++) {
+			tokens[i] = strsep(&aml_dt_buf, "_");
+		}
+		//if (aml_dt_buf)
+			//free(aml_dt_buf);
+		printf("        aml_dt soc: %s platform: %s variant: %s\n", tokens[0], tokens[1], tokens[2]);
+
+		/*match and print result*/
+		char **dt_info;
+		dt_info = (char **)malloc(sizeof(char *)*AML_DT_ID_VARI_TOTAL);
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++)
+			dt_info[i] = (char *)malloc(sizeof(char)*aml_each_id_length);
+		unsigned int dtb_match_num = 0xffff;
+		unsigned int x = 0, y = 0, z = 0; //loop counter
+		unsigned int read_data;
+		for (i = 0; i < dt_total; i++) {
+			for (x = 0; x < AML_DT_ID_VARI_TOTAL; x++) {
+				for (y = 0; y < aml_each_id_length; y+=4) {
+					read_data = readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+						 i * aml_dtb_header_size + AML_DT_DTB_DT_INFO_OFFSET + \
+						 (x * aml_each_id_length) + y);
+					dt_info[x][y+0] = (read_data >> 24) & 0xff;
+					dt_info[x][y+1] = (read_data >> 16) & 0xff;
+					dt_info[x][y+2] = (read_data >> 8) & 0xff;
+					dt_info[x][y+3] = (read_data >> 0) & 0xff;
+				}
+				for (z=0; z<aml_each_id_length; z++) {
+					/*fix string with \0*/
+					if (0x20 == (uint)dt_info[x][z]) {
+						dt_info[x][z] = '\0';
+					}
+				}
+				//printf("dt_info[x]: %s\n", dt_info[x]);
+				//printf("strlen(dt_info[x]): %d\n", strlen(dt_info[x]));
+			}
+			if (dt_tool_version == 1)
+				printf("        dtb %d soc: %.4s   plat: %.4s   vari: %.4s\n", i, (char *)(dt_info[0]), (char *)(dt_info[1]), (char *)(dt_info[2]));
+			else if(dt_tool_version == 2)
+				printf("        dtb %d soc: %.16s   plat: %.16s   vari: %.16s\n", i, (char *)(dt_info[0]), (char *)(dt_info[1]), (char *)(dt_info[2]));
+			uint match_str_counter = 0;
+			for (z=0; z<AML_DT_ID_VARI_TOTAL; z++) {
+				/*must match 3 strings*/
+				if (!strncmp(tokens[z], (char *)(dt_info[z]), strlen(tokens[z])) && \
+					(strlen(tokens[z]) == strlen(dt_info[z])))
+					match_str_counter++;
+			}
+			if (match_str_counter == AML_DT_ID_VARI_TOTAL) {
+				//printf("Find match dtb\n");
+				dtb_match_num = i;
+			}
+			for (z=0; z<AML_DT_ID_VARI_TOTAL; z++) {
+				/*clear data for next loop*/
+				memset(dt_info[z], 0, sizeof(aml_each_id_length));
+			}
+		}
+		/*clean malloc memory*/
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++) {
+			if (dt_info[i])
+				free(dt_info[i]);
+		}
+		if (dt_info)
+			free(dt_info);
+
+		/*if find match dtb, return address, or else return main entrance address*/
+		if (0xffff != dtb_match_num) {
+			printf("      Find match dtb: %d\n", dtb_match_num);
+			/*this offset is based on dtb image package, so should add on base address*/
+			fdt_addr = (fdt_addr + readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+				dtb_match_num * aml_dtb_header_size + aml_dtb_offset_offset));
+			if (gzip_format) {
+				memcpy((void *)dt_entry, (void *)fdt_addr, DTB_MAX_SIZE);
+				fdt_addr = dt_entry;
+				if (gzip_buf)
+					free(gzip_buf);
+			}
+			return fdt_addr;
+		}
+		else{
+			printf("      Not match any dtb.\n");
+			if (gzip_buf)
+				free(gzip_buf);
+			return fdt_addr;
+		}
+	}
+	else {
+		printf("      Cannot find legal dtb!\n");
+		if (gzip_buf)
+			free(gzip_buf);
+		return fdt_addr;
+	}
+}
+#endif //#ifdef AML_MULTI_DTB_API_NEW
+
+extern int check_valid_dts(unsigned char *buffer);
+#ifdef 	AML_MULTI_DTB_CHECK_CMD
+static int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned long loadaddr = 0x1080000;
+
+	if (argc > 1)
+		loadaddr = simple_strtoul(argv[1],NULL,16);
+
+	check_valid_dts((void*)loadaddr);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+   dtb_chk,           //command name
+   2,                 //maxargs
+   0,                 //repeatable
+   do_test,           //command function
+   "multi-dtb check command",             //description
+   "    argv: dtb_chk <dtbLoadaddr> \n"   //usage
+   "    do dtb check, which already loaded at <dtbLoadaddr>.\n"
+);
+#endif //#ifdef 	AML_MULTI_DTB_CHECK_CMD
diff --git a/common/partitions.c b/common/partitions.c
new file mode 100644
index 0000000000..25ad5e447d
--- /dev/null
+++ b/common/partitions.c
@@ -0,0 +1,206 @@
+#include <common.h>
+#include <malloc.h>
+#include <linux/err.h>
+#include <amlstorage/partition_table.h>
+#include <linux/libfdt.h>
+#include <amlogic/asm/bl31_apis.h>
+#include <amlogic/aml_efuse.h>
+
+#ifdef CONFIG_MULTI_DTB
+	extern unsigned long get_multi_dt_entry(unsigned long fdt_addr);
+#endif
+
+struct partitions_data{
+	int nr;
+	struct partitions *parts;
+};
+
+struct partitions *part_table = NULL;
+static int parts_total_num;
+int has_boot_slot = 0;
+int has_system_slot = 0;
+bool dynamic_partition = false;
+bool vendor_boot_partition = false;
+
+int get_partitions_table(struct partitions **table)
+{
+	int ret = 0;
+	if (part_table && parts_total_num) {
+		*table = part_table;
+		ret = parts_total_num;
+	}
+	return ret;
+}
+int get_partition_count(void)
+{
+	return parts_total_num;
+}
+struct partitions *get_partitions(void)
+{
+	return part_table;
+}
+
+void free_partitions(void)
+{
+	if (part_table)
+		free(part_table);
+	part_table = NULL;
+}
+
+#ifndef IS_FEAT_BOOT_VERIFY
+#define IS_FEAT_BOOT_VERIFY() 0
+#endif// #ifndef IS_FEAT_BOOT_VERIFY
+
+/*
+  return 0 if dts is valid
+  other value are falure.
+*/
+int check_valid_dts(unsigned char *buffer)
+{
+	int ret = -__LINE__;
+	char *dt_addr;
+	/* fixme, a work around way */
+	unsigned char *sbuffer = (unsigned char *)env_get_hex("loadaddr", 0x1000000 + 0x100000);
+	/* g12a merge to trunk, use trunk code */
+	//unsigned char *sbuffer = (unsigned char *)0x1000000;
+
+	if (IS_FEAT_BOOT_VERIFY()) {
+		memcpy(sbuffer, buffer, AML_DTB_IMG_MAX_SZ);
+		flush_cache((unsigned long)sbuffer, AML_DTB_IMG_MAX_SZ);
+		ret = aml_sec_boot_check(AML_D_P_IMG_DECRYPT, (long unsigned)sbuffer, AML_DTB_IMG_MAX_SZ, 0);
+		if (ret) {
+			printf("\n %s() %d: Decrypt dtb: Sig Check %d\n", __func__, __LINE__, ret);
+			return -__LINE__;
+		}
+		memcpy(buffer, sbuffer, AML_DTB_IMG_MAX_SZ);
+	}
+#ifdef CONFIG_MULTI_DTB
+	dt_addr = (char *)get_multi_dt_entry((unsigned long)buffer);
+#else
+	dt_addr = (char *)buffer;
+#endif
+	pr_debug("start dts,buffer=%p,dt_addr=%p\n", buffer, dt_addr);
+	ret = fdt_check_header(dt_addr);
+	if ( ret < 0 )
+		printf("%s: %s\n",__func__,fdt_strerror(ret));
+	/* fixme, is it 0 when ok? */
+	return ret;
+}
+
+int get_partition_from_dts(unsigned char *buffer)
+{
+	char *dt_addr;
+	int nodeoffset,poffset=0;
+	int *parts_num;
+	char propname[8];
+	const uint32_t *phandle;
+	const char *uname;
+	const char *usize;
+	const char *umask;
+	int index;
+	int ret = -1;
+
+	if ( buffer == NULL)
+		goto _err;
+
+	ret = check_valid_dts(buffer);
+	printf("%s() %d: ret %d\n",__func__, __LINE__, ret);
+	if ( ret < 0 )
+	{
+		printf("%s() %d: ret %d\n",__func__, __LINE__, ret);
+		goto _err;
+	}
+#ifdef CONFIG_MULTI_DTB
+	dt_addr = (char *)get_multi_dt_entry((unsigned long)buffer);
+#else
+	dt_addr = (char *)buffer;
+#endif
+	nodeoffset = fdt_path_offset(dt_addr, "/partitions");
+	if (nodeoffset < 0)
+	{
+		printf("%s: not find /partitions node %s.\n",__func__,fdt_strerror(nodeoffset));
+		ret = -1;
+		goto _err;
+	}
+	parts_num = (int *)fdt_getprop(dt_addr, nodeoffset, "parts", NULL);
+	printf("parts: %d\n",be32_to_cpup((u32*)parts_num));
+
+	if (parts_num > 0)
+	{
+		part_table = (struct partitions *)malloc(sizeof(struct partitions)*(be32_to_cpup((u32*)parts_num)));
+		if (!part_table) {
+			printk("%s part_table alloc _err\n",__func__);
+			//kfree(data);
+			return -1;
+		}
+		memset(part_table, 0, sizeof(struct partitions)*(be32_to_cpup((u32*)parts_num)));
+		parts_total_num = be32_to_cpup((u32*)parts_num);
+	}
+	dynamic_partition = false;
+	env_set("partiton_mode","normal");
+	vendor_boot_partition = false;
+	env_set("vendor_boot_mode","false");
+	for (index = 0; index < be32_to_cpup((u32*)parts_num); index++)
+	{
+		sprintf(propname,"part-%d", index);
+
+		phandle = fdt_getprop(dt_addr, nodeoffset, propname, NULL);
+		if (!phandle) {
+			printf("don't find  match part-%d\n",index);
+			goto _err;
+		}
+		if (phandle) {
+			poffset = fdt_node_offset_by_phandle(dt_addr, be32_to_cpup((u32*)phandle));
+			if (!poffset) {
+				printf("%s:%d,can't find device node\n",__func__,__LINE__);
+				goto _err;
+			}
+		}
+		uname = fdt_getprop(dt_addr, poffset, "pname", NULL);
+		//printf("%s:%d  uname: %s\n",__func__,__LINE__, uname);
+		/* a string but not */
+		usize = fdt_getprop(dt_addr, poffset, "size", NULL);
+		//printf("%s:%d size: 0x%x  0x%x\n",__func__,__LINE__, be32_to_cpup((u32*)usize), be32_to_cpup((((u32*)usize)+1)));
+		umask = fdt_getprop(dt_addr, poffset, "mask", NULL);
+		//printf("%s:%d mask: 0x%x\n",__func__,__LINE__, be32_to_cpup((u32*)umask));
+		/* fill parition table */
+		if (uname != NULL)
+			memcpy(part_table[index].name, uname, strlen(uname));
+		part_table[index].size = ((unsigned long)be32_to_cpup((u32*)usize) << 32) | (unsigned long)be32_to_cpup((((u32*)usize)+1));
+		part_table[index].mask_flags = be32_to_cpup((u32*)umask);
+		printf("%02d:%10s\t%016llx %01x\n", index, uname, part_table[index].size, part_table[index].mask_flags);
+
+		if (strcmp(uname, "boot_a") == 0) {
+			has_boot_slot = 1;
+			printf("set has_boot_slot = 1\n");
+		}
+		else if (strcmp(uname, "boot") == 0) {
+			has_boot_slot = 0;
+			printf("set has_boot_slot = 0\n");
+		}
+		if (strcmp(uname, "system_a") == 0)
+			has_system_slot = 1;
+		else if (strcmp(uname, "system") == 0)
+			has_system_slot = 0;
+
+		if (strcmp(uname, "super") == 0) {
+			dynamic_partition = true;
+			env_set("partiton_mode","dynamic");
+			printf("enable dynamic_partition\n");
+		}
+
+		if (strncmp(uname, "vendor_boot", 11) == 0) {
+			vendor_boot_partition = true;
+			env_set("vendor_boot_mode","true");
+			printf("enable vendor_boot\n");
+		}
+	}
+	return 0;
+
+_err:
+	if (part_table != NULL) {
+		free(part_table);
+		part_table = NULL;
+	}
+	return ret;
+}
diff --git a/configs/jethub_j100_defconfig b/configs/jethub_j100_defconfig
index 188860feb7..08131b517d 100644
--- a/configs/jethub_j100_defconfig
+++ b/configs/jethub_j100_defconfig
@@ -70,3 +70,10 @@ CONFIG_USB_GADGET_PRODUCT_NUM=0xfada
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_USB_GADGET_DOWNLOAD=y
 CONFIG_OF_LIBFDT_OVERLAY=y
+
+CONFIG_AML_DRIVER=y
+CONFIG_UNIFY_KEY_MANAGE=y
+CONFIG_SECURE_STORAGE=y
+CONFIG_AML_STORAGE=y
+CONFIG_EFUSE=y
+CONFIG_AML_PARTITION=y
diff --git a/configs/jethub_j80_defconfig b/configs/jethub_j80_defconfig
index 8746ed9c80..43d0c62b50 100644
--- a/configs/jethub_j80_defconfig
+++ b/configs/jethub_j80_defconfig
@@ -69,3 +69,11 @@ CONFIG_USB_GADGET_PRODUCT_NUM=0xfada
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_USB_GADGET_DOWNLOAD=y
 CONFIG_OF_LIBFDT_OVERLAY=y
+
+CONFIG_AML_DRIVER=y
+CONFIG_UNIFY_KEY_MANAGE=y
+CONFIG_SECURE_STORAGE=y
+CONFIG_AML_STORAGE=y
+CONFIG_EFUSE=y
+CONFIG_AML_PARTITION=y
+
diff --git a/disk/Kconfig b/disk/Kconfig
index 359af3b27e..ae79fc872b 100644
--- a/disk/Kconfig
+++ b/disk/Kconfig
@@ -155,4 +155,17 @@ config PARTITION_TYPE_GUID
 	  Activate the configuration of GUID type
 	  for EFI partition
 
+config AML_PARTITION
+	bool "Enable AML partition table"
+	depends on PARTITIONS
+	help
+	   "AML_PARTITION_HELP"
+
+config AML_GPT
+	bool "Enable AML GPT partition table"
+	depends on PARTITIONS
+	select RANDOM_UUID
+	help
+	   "AML_GPT_HELP"
+
 endmenu
diff --git a/disk/Makefile b/disk/Makefile
index ec148832b3..73c06bf8be 100644
--- a/disk/Makefile
+++ b/disk/Makefile
@@ -14,3 +14,4 @@ obj-$(CONFIG_$(SPL_TPL_)DOS_PARTITION)   += part_dos.o
 obj-$(CONFIG_$(SPL_TPL_)ISO_PARTITION)   += part_iso.o
 obj-$(CONFIG_$(SPL_TPL_)AMIGA_PARTITION) += part_amiga.o
 obj-$(CONFIG_$(SPL_TPL_)EFI_PARTITION)   += part_efi.o
+#obj-$(CONFIG_AML_PARTITION) += part_aml.o
diff --git a/disk/part_aml.c b/disk/part_aml.c
new file mode 100644
index 0000000000..fba10916c2
--- /dev/null
+++ b/disk/part_aml.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2001
+ * Yonghui.yu , Amlogic Inc, yonghui.yu@amlogic.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <memalign.h>
+
+#include <common.h>
+#include <blk.h>
+#include <command.h>
+#include <ide.h>
+#include <memalign.h>
+#include <asm/unaligned.h>
+#include <linux/compiler.h>
+#include <part.h>
+
+#ifdef CONFIG_HAVE_BLOCK_DEVICE
+extern int get_part_info_from_tbl(struct blk_desc * dev_desc,
+	int part_num, struct disk_partition * info);
+int get_part_info_by_name(struct blk_desc *dev_desc,
+	const char *name, struct disk_partition *info);
+#define	AML_PART_DEBUG	(0)
+
+#if	(AML_PART_DEBUG)
+#define	PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define PRINTF(fmt,args...)
+#endif
+
+#define AML_SEC_SIZE	(512)
+#define MAGIC_OFFSET	(1)
+
+/* read back boot partitons */
+static int _get_partition_info_aml(struct blk_desc * dev_desc,
+	int part_num, struct disk_partition * info, int verb)
+{
+	int ret = 0;
+
+	if (IF_TYPE_MMC != dev_desc->if_type)
+		return -1;
+
+	info->blksz=dev_desc->blksz;
+	sprintf ((char *)info->type, "U-Boot");
+	/* using partition name in partition tables */
+	ret = get_part_info_from_tbl(dev_desc, part_num, info);
+	if (ret) {
+		/*printf ("** Partition %d not found on device %d **\n",
+			part_num,dev_desc->devnum);*/
+		return -1;
+	}
+
+	PRINTF(" part %d found @ %lx size %lx\n",part_num,info->start,info->size);
+	return 0;
+}
+
+int get_partition_info_aml(struct blk_desc * dev_desc,
+	int part_num, struct disk_partition * info)
+{
+	return(_get_partition_info_aml(dev_desc, part_num, info, 1));
+}
+
+int get_partition_info_aml_by_name(struct blk_desc *dev_desc,
+	const char *name, struct disk_partition *info)
+{
+	return (get_part_info_by_name(dev_desc,
+		name, info));
+}
+
+void print_part_aml(struct blk_desc * dev_desc)
+{
+	struct disk_partition info;
+	int i;
+	if (_get_partition_info_aml(dev_desc,0,&info,0) == -1) {
+		printf("** No boot partition found on device %d **\n",dev_desc->devnum);
+		return;
+	}
+	printf("Part   Start     Sect x Size Type  name\n");
+	i=0;
+	do {
+		printf(" %02d " LBAFU " " LBAFU " %6ld %.32s %.32s\n",
+		       i++, info.start, info.size, info.blksz, info.type, info.name);
+	} while (_get_partition_info_aml(dev_desc,i,&info,0)!=-1);
+}
+#define AML_MPT_OFFSET	(73728)	/* 36M */
+/* fix 40Mbyte to check the MPT magic */
+int test_part_aml (struct blk_desc *dev_desc)
+{
+	ALLOC_CACHE_ALIGN_BUFFER(char, buffer, dev_desc->blksz);
+	if (blk_dread(dev_desc, AML_MPT_OFFSET, 1, (ulong *) buffer) != 1)
+		return -1;
+	if (!strncmp(buffer, "MPT", 3))
+		return 1; // FIXME: return negative result for AML partition for normal u-boot bootsequence
+	return 1;
+}
+
+
+U_BOOT_PART_TYPE(aml) = {
+	.name		= "AML",
+	.part_type	= PART_TYPE_AML,
+	.max_entries	= AML_ENTRY_NUMBERS,
+	.get_info	= get_partition_info_aml,
+	.print		= print_part_aml,
+	.test		= test_part_aml,
+};
+
+#endif
diff --git a/drivers/Kconfig b/drivers/Kconfig
index b26ca8cf70..4be5558e8e 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -146,6 +146,10 @@ source "drivers/watchdog/Kconfig"
 
 source "drivers/xen/Kconfig"
 
+source "drivers/amlogic/Kconfig"
+
+source "drivers/efuse/Kconfig"
+
 config PHYS_TO_BUS
 	bool "Custom physical to bus address mapping"
 	help
diff --git a/drivers/Makefile b/drivers/Makefile
index 67c8af7442..c092d31d9c 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -37,6 +37,9 @@ obj-$(CONFIG_$(SPL_TPL_)TPM) += tpm/
 obj-$(CONFIG_XEN) += xen/
 obj-$(CONFIG_$(SPL_)FPGA) += fpga/
 
+obj-$(CONFIG_AML_DRIVER) += amlogic/
+obj-$(CONFIG_EFUSE) += efuse/
+
 ifndef CONFIG_TPL_BUILD
 ifndef CONFIG_VPL_BUILD
 ifdef CONFIG_SPL_BUILD
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
new file mode 100644
index 0000000000..ff94c4b85e
--- /dev/null
+++ b/drivers/amlogic/Kconfig
@@ -0,0 +1,14 @@
+menu "AMLOGIC Drivers"
+
+config AML_DRIVER
+	bool "AML drivers Support"
+	select SHA1
+	select SHA256
+	help
+	  Enable support for the Amlogic drivers.
+
+source "drivers/amlogic/keymanage/Kconfig"
+
+source "drivers/amlogic/storagekey/Kconfig"
+
+endmenu
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
new file mode 100644
index 0000000000..544cc608b5
--- /dev/null
+++ b/drivers/amlogic/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_UNIFY_KEY_MANAGE) += keymanage/
+
+obj-$(CONFIG_SECURE_STORAGE) += storagekey/
diff --git a/drivers/amlogic/keymanage/Kconfig b/drivers/amlogic/keymanage/Kconfig
new file mode 100644
index 0000000000..0c77689ae4
--- /dev/null
+++ b/drivers/amlogic/keymanage/Kconfig
@@ -0,0 +1,21 @@
+menuconfig UNIFY_KEY_MANAGE
+    bool "Amlogic unifykey"
+	depends on OF_LIBFDT
+    help
+        This enables support for keyman (Amlogic key manage),
+        A driver providing APIs for flash key and efuse key
+if UNIFY_KEY_MANAGE
+    config AML_SECURITY_KEY
+        depends on SECURE_STORAGE
+        bool "Amlogic flash key"
+        default y
+        select SHA256
+        select SHA1
+        help
+            "security key wrapper for APIs bl31"
+    config KEYMAN_PROVISION_KEY
+        bool "Amlogic burn provision key"
+        default n
+        help
+            "provision key wrapper for burn tool"
+endif #if UNIFY_KEY_MANAGE
diff --git a/drivers/amlogic/keymanage/Makefile b/drivers/amlogic/keymanage/Makefile
new file mode 100644
index 0000000000..08dd44eaec
--- /dev/null
+++ b/drivers/amlogic/keymanage/Makefile
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+obj-$(CONFIG_UNIFY_KEY_MANAGE) += aml_key_manage.o
+
+aml_key_manage-y 						 		= key_unify.o
+aml_key_manage-y 						 	   += key_manage.o
+aml_key_manage-$(CONFIG_OF_LIBFDT) 				+= km_dts.o
+aml_key_manage-$(CONFIG_EFUSE) 					+= km_efuse_key.o
+aml_key_manage-$(CONFIG_AML_SECURITY_KEY) 		+= km_secure_key.o
+aml_key_manage-$(CONFIG_KEYMAN_PROVISION_KEY) 	+= km_provision_key.o
+
diff --git a/drivers/amlogic/keymanage/key_manage.c b/drivers/amlogic/keymanage/key_manage.c
new file mode 100644
index 0000000000..f8e0700b0a
--- /dev/null
+++ b/drivers/amlogic/keymanage/key_manage.c
@@ -0,0 +1,689 @@
+/*
+ * \file        key_encrypt_decrypt.c
+ * \brief       encrypt a key before burn to target deive,
+ *              decrypt a key after read from target device
+ *
+ * \version     1.0.0
+ * \date        15/07/17
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "key_manage_i.h"
+#include <u-boot/sha1.h>
+#include <linux/ctype.h>
+#include <command.h>
+#include <env.h>
+#include <u-boot/sha1.h>
+
+
+#if defined(CONFIG_AML_SECURITY_KEY)
+extern int _burn_key_in_type_hdcp2(const char* keyname,
+        void* databuf, const unsigned bufLen, char* decryptBuf);
+extern int _read_key_in_type_hdcp2(const char* keyname,
+        void* databuf, const unsigned bufLen, char* decryptBuf);
+extern int _km_hdcp2_size(void);
+#else
+static int _burn_key_in_type_hdcp2(const char* keyname,
+        void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    KM_ERR("CONFIG_AML_SECURITY_KEY undefined\n");
+    return -__LINE__;
+}
+static int _read_key_in_type_hdcp2(const char* keyname,
+        void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    KM_ERR("CONFIG_AML_SECURITY_KEY undefined\n");
+    return -__LINE__;
+}
+int _km_hdcp2_size(void)
+{
+    KM_ERR("CONFIG_AML_SECURITY_KEY undefined\n");
+    return 0;
+}
+#endif// #if defined(CONFIG_AML_SECURITY_KEY)
+
+enum _KmUsrKeyType{
+    KM_USER_KEY_TYPE_MAC        = 0 ,//key format is all ascii, and splitted by :
+    KM_USER_KEY_TYPE_SHA1           ,//key format is end with 20 bytes sha1sum
+    KM_USER_KEY_TYPE_HDCP2          ,//special case, can only identified with name
+    KM_USER_KEY_TYPE_RAW            ,//raw format which can burn to target directly
+};
+
+static const char* _cfgKeyTypes[] = {
+    [KM_USER_KEY_TYPE_MAC]          = "mac"     ,
+    [KM_USER_KEY_TYPE_SHA1]         = "sha1"    ,
+    [KM_USER_KEY_TYPE_HDCP2]        = "hdcp2"   ,
+    [KM_USER_KEY_TYPE_RAW]          = "raw"     ,
+};
+#define _SUPPORTED_CFG_TYPES_NUM    ( sizeof(_cfgKeyTypes) / sizeof(char*) )
+
+
+static int km_get_user_key_format(const char* srcKeyName, int* key_type)
+{
+    int ret                 = 0;
+    int   srcKeyType        = 0;
+    const char* cfgType     = NULL;
+
+    cfgType = keymanage_dts_get_key_type (srcKeyName) ;
+    if (NULL == cfgType) {
+        KM_ERR("Fail in get keytype cfg in dts for key[%s]\n", srcKeyName);
+        return __LINE__;
+    }
+
+    for (srcKeyType = 0; srcKeyType < _SUPPORTED_CFG_TYPES_NUM; ++srcKeyType)
+    {
+        ret = strcmp(cfgType, _cfgKeyTypes[srcKeyType]);
+        if (!ret) break;
+    }
+    if (srcKeyType == _SUPPORTED_CFG_TYPES_NUM) {
+        KM_ERR("prop key-type[%s] unsupported in key[%s]\n", cfgType, srcKeyName);
+        return __LINE__;
+    }
+
+    if (KM_USER_KEY_TYPE_RAW == srcKeyType)
+    {
+        do
+        {
+            ret = !strcmp(srcKeyName, "mac") || !strcmp(srcKeyName, "mac_bt") || !strcmp(srcKeyName, "mac_wifi");
+            if (ret) { srcKeyType = KM_USER_KEY_TYPE_MAC; break; }
+
+            /*ret = !strcmp(srcKeyName, "hdcp") ;*/
+            /*if (ret) { srcKeyType = KM_USER_KEY_TYPE_SHA1; break; }*/
+
+            ret = !strcmp(srcKeyName, "hdcp2") ;
+            if (ret) { srcKeyType = KM_USER_KEY_TYPE_HDCP2; break; }
+
+        }while(0);
+    }
+
+    *key_type = srcKeyType;
+    return 0;
+}
+
+#if 1//START MAC
+const int _UsrMacKeyLen = 17;
+
+//key manager user interface: mac format check and change format if needed
+static int _burn_key_in_type_mac(const char* keyname, const char* srcKeyVal, const unsigned srcKeyLen, void* decryptBuf)
+{
+    int ret = 0;
+    int index = 0;
+    ssize_t     targetKeyLen    = 0;
+    char*       dstKeyVal       = (char*)decryptBuf;
+
+    if (_UsrMacKeyLen != srcKeyLen) {
+        KM_ERR("mac len %d is invalid, must be %d\n", srcKeyLen, _UsrMacKeyLen);
+        return -EINVAL;
+    }
+
+    for (index = 0; index < _UsrMacKeyLen; index += 3)
+    {
+        int k = 0;
+        const char* p = srcKeyVal + index;
+        for (k = 0; k < 2; ++k) {
+            const char c = *p++;
+            if (!isxdigit(c)) {
+                KM_ERR("mac str(%s) fmt err at index[%d]\n", srcKeyVal, index + k);
+                return __LINE__;
+            }
+        }
+        if (':' != *p && index + k < _UsrMacKeyLen) {
+            KM_ERR("mac str(%s) fmt err at index[%d], must be :, but %c\n", srcKeyVal, index + 2, *p);
+            return __LINE__;
+        }
+    }
+
+    enum key_manager_dev_e keyDev = keymanage_dts_get_key_device(keyname);
+    if (KEY_M_MAX_DEV == keyDev) {
+        KM_ERR("Fail get key dev for key[%s]\n", keyname);
+        return __LINE__;
+    }
+    if (KEY_M_EFUSE_NORMAL != keyDev) { targetKeyLen = _UsrMacKeyLen; }
+    else
+    {//efusekey, check configure size
+        ret = key_unify_query_size(keyname, &targetKeyLen);
+        if (ret) {
+            KM_ERR("Fail at get key size, ret=%d\n", ret);
+            return __LINE__;
+        }
+
+        if (6 != targetKeyLen && targetKeyLen != _UsrMacKeyLen) {
+            KM_ERR("efuse key[%s] len %zd err\n", keyname, targetKeyLen);
+            return __LINE__;
+        }
+    }
+
+    if (_UsrMacKeyLen == targetKeyLen) {//say its target not efuse ?
+        ret =  key_unify_write(keyname, srcKeyVal, srcKeyLen);
+        return ret;
+    }
+
+    KM_DBG("targetKeyLen=%zd\n", targetKeyLen);
+    for (index = 0; index < targetKeyLen; ++index) {
+        char theByteStr[4] ;
+        theByteStr[0] = srcKeyVal[index * 3 + 0];
+        theByteStr[1] = srcKeyVal[index * 3 + 1];
+        theByteStr[2] = '\0';
+        unsigned byteSum = 0;
+
+        byteSum = simple_strtoul(theByteStr, NULL, 16);
+        KM_DBG("byteSum[%d]=0x%x\n", index, byteSum);
+        if (byteSum > 0xff) {
+            KM_ERR("theByteStr=%s err\n", theByteStr);
+            return __LINE__;
+        }
+        dstKeyVal[index] = byteSum;
+    }
+
+    ret = key_unify_write(keyname, dstKeyVal, targetKeyLen);
+    return ret;
+}
+
+//Return value: key size that user wanted, ok if > 0
+static int _read_key_in_type_mac(const char* keyname, char* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    int ret = 0;
+    int index = 0;
+    ssize_t keyDevSz = 0;
+
+    if (_UsrMacKeyLen > bufLen) {
+        KM_ERR("mac len %d is invalid, must be %d\n", bufLen, _UsrMacKeyLen);
+        return -__LINE__;
+    }
+
+    ret = key_unify_query_size (keyname, &keyDevSz) ;
+    if (ret) {
+        KM_ERR("Fail in get key sz, ret=%d\n", ret);
+        return -__LINE__;
+    }
+
+    ret = key_unify_read (keyname, decryptBuf, (unsigned)keyDevSz) ;
+    if (ret) {
+        KM_ERR("fail in read key[%s]\n", keyname);
+        return -__LINE__;
+    }
+
+    if (_UsrMacKeyLen == keyDevSz) {
+        memcpy(databuf, decryptBuf, keyDevSz);
+        return 0;
+    }
+
+    databuf[0] = '\0';
+    for (index = 0; index < keyDevSz; ++index)
+    {
+        const unsigned byteSum = decryptBuf[index];
+
+        sprintf(databuf, "%s%02x:", databuf, byteSum);
+    }
+
+    return ret;
+}
+#endif//END MAC
+
+#if 1//Start sha1sum
+//key value which end up 20 bytes sha1sum
+//check the sha1sum and remove it after checked ok
+static int _burn_key_in_type_sha1(const char* keyname, void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    int ret = 0;
+    const unsigned srcKeyLen    = bufLen;
+    const char* srcKeyVal       = (char*)databuf;
+    const unsigned shaSumLen = 20;
+    const unsigned licLen = srcKeyLen - shaSumLen;
+    const u8* orgSum = (u8*)srcKeyVal + licLen;
+    u8 genSum[shaSumLen];
+
+    if (srcKeyLen <= 20) {
+        KM_ERR("Err key len %d for sha1 fmt\n", srcKeyLen);
+        return __LINE__;
+    }
+
+    sha1_csum((u8*)srcKeyVal, licLen, genSum);
+
+    ret = memcmp(orgSum, genSum, shaSumLen);
+    if (ret) {
+        const unsigned fmtStrLen = shaSumLen * 2 + 2;
+        char org_sha1Str[fmtStrLen + 2];
+        char gen_sha1Str[fmtStrLen + 2];
+        int byteIndex = 0;
+
+        org_sha1Str[0] = gen_sha1Str[0] = '\0';
+        for (byteIndex = 0; byteIndex < shaSumLen; ++byteIndex)
+        {
+            sprintf(org_sha1Str, "%s%02x", org_sha1Str, orgSum[byteIndex]);
+            sprintf(gen_sha1Str, "%s%02x", gen_sha1Str, genSum[byteIndex]);
+        }
+        KM_ERR("sha1sum, orgSum[%s] != genSum[%s]\n", org_sha1Str, gen_sha1Str);
+
+        return __LINE__;
+    }
+    KM_MSG("Verify key with sha1sum OK\n");
+
+    ret = key_unify_write(keyname, srcKeyVal, licLen);
+    return ret;
+}
+#endif//END sha1sum
+/* *
+ * APIs of key manage
+*/
+
+int key_manage_init(const char* seednum, const char* dtbaddr)
+{
+    int ret = key_unify_init(seednum, dtbaddr);
+
+    return ret;
+}
+
+int key_manage_exit(void)
+{
+    return key_unify_uninit();
+}
+
+int key_manage_write(const char* keyname, const void* keydata, const unsigned dataLen)
+{
+    int ret = 0;
+    int srcKeyType;
+    char* decryptBuf = NULL;
+    const int DecryptBufMaxLen = 64<<10;
+
+    ret = key_unify_query_key_has_configure(keyname);
+    if (!ret) {
+        KM_ERR ("There isn't cfg for key[%s]\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = km_get_user_key_format(keyname, &srcKeyType);
+    if (ret) {
+        KM_ERR ("Fail in get user key type\n") ;
+        return __LINE__;
+    }
+
+    decryptBuf = (char*)malloc(DecryptBufMaxLen);
+    switch (srcKeyType)
+    {
+        case KM_USER_KEY_TYPE_MAC:
+            {
+                ret = _burn_key_in_type_mac(keyname, (char*)keydata, dataLen, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_SHA1:
+            {
+                ret = _burn_key_in_type_sha1(keyname, (char*)keydata, dataLen, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_HDCP2:
+            {
+                ret = _burn_key_in_type_hdcp2(keyname, (char*)keydata, dataLen, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_RAW:
+            {
+                ret = key_unify_write(keyname, (char*)keydata, dataLen);
+            }
+            break;
+    }
+
+    free(decryptBuf);
+    return ret;
+}
+
+int key_manage_read(const char* keyname, void* keydata, const unsigned bufLen)
+{
+    int ret = 0;
+    ssize_t keysize = 0;
+    int srcKeyType = 0;
+    char* decryptBuf = NULL;
+    const int DecryptBufMaxLen = 64<<10;
+
+    ret = key_manage_query_size(keyname, &keysize);
+    if (ret) {
+        KM_ERR ("Fail in query key size for key[%s]\n", keyname) ;
+        return __LINE__;
+    }
+    if (keysize > bufLen) {
+        KM_ERR ("keysize %zd > bufLen %d\n", keysize, bufLen) ;
+        return __LINE__;
+    }
+
+    ret = km_get_user_key_format(keyname, &srcKeyType);
+    if (ret) {
+        KM_ERR ("Fail in get user key type\n") ;
+        return __LINE__;
+    }
+
+    decryptBuf = (char*)malloc(DecryptBufMaxLen);
+    switch (srcKeyType)
+    {
+        case KM_USER_KEY_TYPE_MAC:
+            {
+                ret = _read_key_in_type_mac(keyname, (char*)keydata, (unsigned)keysize, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_HDCP2:
+            {
+                ret = _read_key_in_type_hdcp2(keyname, keydata, (unsigned)keysize, decryptBuf);
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_SHA1:
+        case KM_USER_KEY_TYPE_RAW:
+        default:
+            {
+                ret = key_unify_read(keyname, keydata, (unsigned)keysize);
+            }
+            break;
+    }
+
+    free(decryptBuf);
+    return ret;
+}
+
+int key_manage_query_size(const char* keyname, ssize_t* keysize)
+{
+    int ret = 0;
+    int exist = 0;
+    int srcKeyType = 0;
+
+    ret = key_manage_query_exist(keyname, &exist);
+    if (ret) {
+        KM_ERR ("Fail in query key exist\n") ;
+        return __LINE__;
+    }
+    if (!exist) {
+        KM_ERR ("key[%s] not programed yet\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = km_get_user_key_format(keyname, &srcKeyType);
+    if (ret) {
+        KM_ERR ("Fail in get user key type\n") ;
+        return __LINE__;
+    }
+
+    switch (srcKeyType)
+    {
+        case KM_USER_KEY_TYPE_MAC:
+            {
+                *keysize = _UsrMacKeyLen;
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_HDCP2:
+            {
+                *keysize = _km_hdcp2_size();
+            }
+            break;
+
+        case KM_USER_KEY_TYPE_RAW:
+        case KM_USER_KEY_TYPE_SHA1:
+        default:
+            ret = key_unify_query_size(keyname, keysize);
+    }
+
+    return ret;
+}
+
+int key_manage_query_exist(const char* keyname, int* exist)
+{
+    int ret = 0;
+
+    ret = key_unify_query_key_has_configure(keyname);
+    if (!ret) {
+        KM_ERR ("There isn't dts cfg for key[%s]\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = key_unify_query_exist(keyname, exist);
+
+    return ret;
+}
+
+int key_manage_query_secure(const char* keyname, int* isSecure)
+{
+    int ret = 0;
+    int exist = 0;
+
+    ret = key_manage_query_exist(keyname, &exist);
+    if (ret) {
+        KM_ERR ("Fail in query key exist, ret=%d\n", ret) ;
+        return __LINE__;
+    }
+    if (!exist) {
+        KM_ERR ("Key[%s] not programed yet\n", keyname) ;
+        return __LINE__;
+    }
+
+    ret = key_unify_query_secure(keyname, isSecure);
+
+    return ret;
+}
+
+int key_manage_query_canOverWrite(const char* keyname, int* canOverWrite)
+{
+    return key_unify_query_canOverWrite(keyname, canOverWrite);
+}
+
+static int do_keyman_init(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* seedNum = argv[1];
+    const char* dtbAddr = argc > 2 ? argv[2] : NULL;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    ret = key_manage_init(seedNum, dtbAddr);
+    return ret;
+}
+
+static int do_keyman_exit(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    return key_manage_exit();
+}
+
+//read keyname addr <fmt>
+//fmt can be hex/str, if str, env keyname will be setted
+static int do_keyman_read(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* keyname = argv[1];
+    char* dataBuf = NULL;
+    const char* dataFmt = argc > 3 ? argv[3] : NULL;
+    ssize_t keyLen = 0;
+    if (argc < 3) return CMD_RET_USAGE;
+
+    dataBuf = (char*)simple_strtoul(argv[2], NULL, 16);
+    if (!dataBuf) {
+        KM_ERR("Fail in parse argv[2] to dataBuf\n");
+        return __LINE__;
+    }
+
+    ret = key_manage_query_size(keyname, &keyLen);
+    if (ret) {
+        KM_DBG("Fail get sz for[%s]\n", keyname);//here occure in booting if key not burned yet!
+        return __LINE__;
+    }
+    ret = key_manage_read(keyname, dataBuf, keyLen);
+    if (ret) {
+        KM_ERR("Fail in read key[%s] at sz %zd\n", keyname, keyLen);
+        return __LINE__;
+    }
+    if (dataFmt)
+    {
+        if (!strcmp("hex", dataFmt))
+        {
+            _keyman_buf_to_hex_ascii((uint8_t*)dataBuf, keyLen, NULL);
+            return 0;
+        }
+        else if(!strcmp("str", dataFmt))
+        {
+            int i = 0;
+
+            dataBuf[keyLen] = '\0';
+            for (; i < keyLen; ++i) {
+                ret = isascii(dataBuf[i]);
+                if (!ret) {
+                    KM_MSG("key value has non ascii, can't pr\n");
+                    return CMD_RET_FAILURE;
+                }
+            }
+            env_set(keyname, dataBuf);//setenv for bootargs
+            KM_DBG("env:%s=%s\n", keyname, dataBuf);
+            return 0;
+        }
+        else KM_MSG("Err key dataFmt(%s)\n", dataFmt);
+    }
+
+    return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+//argv: 1       2       3
+//write keyname size    addr
+//write keyname hex/str value
+static int do_keyman_write(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* keyname     = argv[1];
+    const char* databuf     = NULL;
+    char*       tmpBuf      = NULL;
+    const char* inputFmt    = argv[2];
+    unsigned    dataLen     = 0;
+    if (argc < 4) return CMD_RET_USAGE;
+
+    if (!strcmp("hex", inputFmt))
+    {
+        databuf = argv[3];
+        dataLen = strlen(databuf) / 2;
+
+        tmpBuf = (char*)malloc(dataLen);
+        ret = _keyman_hex_ascii_to_buf(databuf, tmpBuf, dataLen);
+        if (ret) {
+            KM_ERR("Fail in change hex argv[3] to bin, err=%d\n", ret);
+            free(tmpBuf);
+            return CMD_RET_FAILURE;
+        }
+        databuf = tmpBuf;
+    }
+    else if(!strcmp("str", inputFmt))
+    {
+        databuf = argv[3];
+        dataLen = strlen(databuf);
+
+        const char* p = databuf;
+        for (; *p; ++p) {
+            if (!isascii(*p)) {
+                KM_ERR("inputFmt is %s, but argv[3] contain non ascii\n", inputFmt);
+                return CMD_RET_FAILURE;
+            }
+        }
+        KM_DBG("str:%s, len=%d\n", databuf, dataLen);
+    }
+    else
+    {
+        dataLen = simple_strtoul(argv[2], NULL, 0);
+        if (!dataLen) {
+            KM_ERR("dataLen err\n");
+            return __LINE__;
+        }
+        if (dataLen > (64*1024)) {
+            KM_ERR("keylen 0x%x too large!\n", dataLen);
+            return __LINE__;
+        }
+        databuf = (char*)simple_strtoul(argv[3], NULL, 16);
+    }
+
+    ret = key_manage_write(keyname, databuf, dataLen);
+    if (tmpBuf) free(tmpBuf) ;
+    return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+//query: 1          2
+//      exist       keyname
+//      secure      keyname
+//      size        keyname
+static int do_keyman_query(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* cmd     = argv[1];
+    const char* keyname = argv[2];
+    if (argc < 3) return CMD_RET_USAGE;
+
+    if (!strcmp("exist", cmd))
+    {
+        int exist = 0;
+        ret = key_manage_query_exist(keyname, &exist);
+        if (ret) {
+            KM_ERR("Fail in query key exist, err=%d", ret);
+            return CMD_RET_FAILURE;
+        }
+        KM_MSG("key[%s] is %s Exist\n", keyname, exist ? "" : "NOT");
+        ret = exist ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+    }
+    else if(!strcmp("secure", cmd))
+    {
+        int isSecure = 0;
+        ret = key_manage_query_secure(keyname, &isSecure);
+        if (ret) {
+            KM_ERR("Fail in query key secure, err=%d\n", ret);
+            return CMD_RET_FAILURE;
+        }
+        KM_MSG("key[%s] is %s Secure\n", keyname, isSecure ? "" : "NOT");
+        ret = isSecure ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+    }
+    else if(!strcmp("size", cmd))
+    {
+        ssize_t keysize = 0;
+        ret = key_manage_query_size(keyname, &keysize);
+        if (ret) {
+            KM_ERR("Fail in query key size, err=%d\n", ret);
+            return CMD_RET_FAILURE;
+        }
+        KM_MSG("key[%s] size is %zd\n", keyname, keysize);
+        ret = keysize ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+    }
+    else return CMD_RET_USAGE;
+
+    return ret;
+}
+
+static struct cmd_tbl cmd_keyman_sub[] = {
+    U_BOOT_CMD_MKENT(init,          3, 0, do_keyman_init, "", ""),
+    U_BOOT_CMD_MKENT(exit,          2, 0, do_keyman_exit, "", ""),
+    U_BOOT_CMD_MKENT(read,          4, 0, do_keyman_read, "", ""),
+    U_BOOT_CMD_MKENT(write,         4, 0, do_keyman_write, "", ""),
+    U_BOOT_CMD_MKENT(query,         3, 0, do_keyman_query, "", ""),
+};
+
+static int do_keymanage(struct cmd_tbl * cmdtp, int flag, int argc, char * const argv[])
+{
+    struct cmd_tbl *c;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    c = find_cmd_tbl(argv[1], cmd_keyman_sub, ARRAY_SIZE(cmd_keyman_sub));
+
+	if (!c) { return CMD_RET_USAGE;}
+
+    return	c->cmd(cmdtp, flag, --argc, ++argv);
+}
+
+U_BOOT_CMD(
+   keyman,           //command name
+   5,                   //maxargs
+   0,                   //repeatable
+   do_keymanage,   //command function
+   "Unify key ops interfaces based dts cfg",           //description
+   "    argv:  \n"   //usage
+   "    init seedNum <dtbAddr>\n"
+   "    read keyname addr <hex/str>\n"
+   "    write keyname size addr \n"
+   "    write keyname hex/str value\n"
+   "    query exist/secure/size keyname\n"
+   "    exit \n"
+);
+
diff --git a/drivers/amlogic/keymanage/key_manage.h b/drivers/amlogic/keymanage/key_manage.h
new file mode 100644
index 0000000000..ab482f45a0
--- /dev/null
+++ b/drivers/amlogic/keymanage/key_manage.h
@@ -0,0 +1,61 @@
+#ifndef __KEY_MANAGE_H__
+#define __KEY_MANAGE_H__
+
+enum key_manager_dev_e{
+    KEY_M_UNKNOW_DEV=0,
+    KEY_M_EFUSE_NORMAL,
+    KEY_M_SECURE_KEY,       //secure nandkey/emmckey
+    KEY_M_NORAML_KEY,       //non-secure nandkey/emmckey
+    KEY_M_PROVISION_KEY,    //provision key
+    KEY_M_MAX_DEV,
+};
+
+/*key data format*/
+enum key_manager_df_e{
+       KEY_M_HEXDATA=0,
+       KEY_M_HEXASCII,
+       KEY_M_ALLASCII,
+       KEY_M_MAX_DF,
+};
+
+enum key_manager_permit_e{
+       KEY_M_PERMIT_READ = (1<<0),
+       KEY_M_PERMIT_WRITE = (1<<1),
+       KEY_M_PERMIT_DEL    = (1<<2),
+       KEY_M_PERMIT_MASK   = 0Xf,
+};
+
+enum key_manager_type_e{
+    KEY_M_TYPE_NORMAL       = 0 ,
+    KEY_M_TYPE_MAC              ,
+    KEY_M_TYPE_SHA1             ,
+    KEY_M_TYPE_HDCP2            ,
+
+    KEY_M_TYPE_TOTAL_NUM
+};
+
+#define KEY_UNIFY_NAME_LEN	    48
+#define KEY_UNIFY_TYPE_LEN_MAX  ( 16 - 1 )
+
+struct key_item_t{
+    char name[KEY_UNIFY_NAME_LEN];
+    char keyType[KEY_UNIFY_TYPE_LEN_MAX + 1];//mac/sha1/hdcp2/normal
+    char encType[KEY_UNIFY_TYPE_LEN_MAX + 1];//mac/sha1/hdcp2/normal
+    int id;
+    unsigned int dev; //key save in device //efuse,
+    unsigned int datFmt;  //data format
+    unsigned int permit;
+    int flag;
+    int reserv;//reserve and align to 64
+};
+
+struct key_info_t{
+    int key_num;
+    int efuse_version;
+    int key_flag;
+    int encrypt_type;
+};
+
+
+#endif // #ifndef __KEY_MANAGE_H__
+
diff --git a/drivers/amlogic/keymanage/key_manage_i.h b/drivers/amlogic/keymanage/key_manage_i.h
new file mode 100644
index 0000000000..73404c1dbf
--- /dev/null
+++ b/drivers/amlogic/keymanage/key_manage_i.h
@@ -0,0 +1,65 @@
+/*
+ * \file        key_manage_i.h
+ * \brief       common included files for key manager
+ *
+ * \version     1.0.0
+ * \date        15/06/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __KEY_MANAGE_I_H__
+#define __KEY_MANAGE_I_H__
+
+#include <config.h>
+#include <common.h>
+#include <linux/string.h>
+#include <errno.h>
+#include <malloc.h>
+#include "key_manage.h"
+#include <amlogic/keyunify.h>
+#include <amlogic/amlkey_if.h>
+
+#define KM_DBG(fmt ...)     //printf("[KM]Dbg:"fmt)
+#define KM_MSG(fmt ...)     printf("[KM]Msg:"fmt)
+#define KM_ERR(fmt ...)     printf("[KM]Error:f[%s]L%d:", __func__, __LINE__),printf(fmt)
+
+int _keyman_hex_ascii_to_buf(const char* input, char* buf, const unsigned bufSz);
+int _keyman_buf_to_hex_ascii(const uint8_t* pdata, const unsigned dataLen, char* fmtStr/*pr if NULL*/);
+
+int keymanage_dts_parse(const void* dt_addr);
+enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname);
+enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname);
+const char* keymanage_dts_get_key_type(const char* keyname);
+const char* keymanage_dts_get_enc_type(const char* keyname);
+char unifykey_get_efuse_version(void);
+int unifykey_get_encrypt_type(void);
+
+int keymanage_efuse_init(const char *buf, int len);
+int keymange_efuse_exit(void);
+int keymanage_efuse_write(const char *keyname, const void* keydata, unsigned int datalen);
+int keymanage_efuse_exist(const char* keyname);
+ssize_t keymanage_efuse_size(const char* keyname);
+int keymanage_efuse_query_can_read(const char* keyname);
+int keymanage_efuse_read(const char *keyname, void* databuf, const unsigned bufsz);
+
+int keymanage_securekey_init(const char* buf, int len);
+int keymanage_securekey_exit(void);
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen);
+ssize_t keymanage_secukey_size(const char* keyname);
+int keymanage_secukey_exist(const char* keyname);
+int keymanage_secukey_can_read(const char* keyname);
+int keymanage_secukey_read(const char* keyname, void* databuf,  unsigned buflen);
+
+//provision key ops
+int keymanage_provision_init(const char *buf, int len);
+int keymanage_provision_exit(void);
+int keymanage_provision_write(const char *keyname, const void* keydata, unsigned int datalen);
+ssize_t keymanage_provision_size(const char* keyname);
+int keymanage_provision_exist(const char* keyname);
+int keymanage_provision_query_can_read(const char* keyname);
+int keymanage_provision_read(const char *keyname, void* databuf, const unsigned bufSz);
+
+#endif//#ifndef __KEY_MANAGE_I_H__
+
diff --git a/drivers/amlogic/keymanage/key_unify.c b/drivers/amlogic/keymanage/key_unify.c
new file mode 100644
index 0000000000..91d50b9c7b
--- /dev/null
+++ b/drivers/amlogic/keymanage/key_unify.c
@@ -0,0 +1,610 @@
+/*
+ * Unify interfaces for read/write nandkey/emmckey/efuse key
+ */
+#include "key_manage_i.h"
+#include <amlogic/keyunify.h>
+#include <linux/ctype.h>
+#include <command.h>
+#include <env.h>
+
+#define KEY_NO_EXIST	0
+#define KEY_BURNED		1
+
+#define KEY_READ_PERMIT		10
+#define KEY_READ_PROHIBIT	11
+
+#define KEY_WRITE_MASK		(0x0f<<4)
+#define KEY_WRITE_PERMIT	(10<<4)
+#define KEY_WRITE_PROHIBIT	(11<<4)
+
+typedef struct _devKeyOps{
+    int     (*pInitFunc) (const char* buf, int len);
+    int     (*pUninitFunc)(void);
+    int     (*pWriteFunc)(const char *keyname, const void* keydata, unsigned int datalen);
+    ssize_t (*pGetSize)(const char* keyname);
+    int     (*pKeyExist)(const char* keyname);
+    int     (*pKeyCanRead)(const char* keyname);
+    int     (*pReadFunc)(const char* keyname, void* dataBuf,  unsigned buflen);
+
+    //Fields:
+    int     can_overwrite;//is OTP
+
+}KmDevKeyOps;
+
+static KmDevKeyOps _SecukeyOps = {
+        .pInitFunc           = keymanage_securekey_init        ,
+        .pUninitFunc         = keymanage_securekey_exit        ,
+        .pWriteFunc          = keymanage_secukey_write         ,
+        .pGetSize            = keymanage_secukey_size          ,
+        .pKeyExist           = keymanage_secukey_exist         ,
+        .pKeyCanRead         = keymanage_secukey_can_read      ,
+        .pReadFunc           = keymanage_secukey_read          ,
+
+        .can_overwrite       = 1                               ,
+};
+
+#if defined(CONFIG_EFUSE)
+static KmDevKeyOps _efuseKeyOps = {
+        .pInitFunc           = keymanage_efuse_init            ,
+        .pUninitFunc         = keymange_efuse_exit             ,
+        .pWriteFunc          = keymanage_efuse_write           ,
+        .pGetSize            = keymanage_efuse_size            ,
+        .pKeyExist           = keymanage_efuse_exist           ,
+        .pKeyCanRead         = keymanage_efuse_query_can_read  ,
+        .pReadFunc           = keymanage_efuse_read            ,
+
+        .can_overwrite       = 0                               ,
+};
+#endif//#if defined(CONFIG_EFUSE)
+
+#if defined(CONFIG_KEYMAN_PROVISION_KEY)
+static KmDevKeyOps _provisionKeyOps = {
+        .pInitFunc           = keymanage_provision_init             ,
+        .pUninitFunc         = keymanage_provision_exit             ,
+        .pWriteFunc          = keymanage_provision_write            ,
+        .pGetSize            = keymanage_provision_size             ,
+        .pKeyExist           = keymanage_provision_exist            ,
+        .pKeyCanRead         = keymanage_provision_query_can_read   ,
+        .pReadFunc           = keymanage_provision_read             ,
+
+        .can_overwrite       = 1                                    ,
+};
+#endif//#if defined(CONFIG_KEYMAN_PROVISION_KEY)
+
+#define _KM_DEV_INDEX_SECUREKEY         0
+#define _KM_DEV_INDEX_PROVISION         1
+#if defined(CONFIG_KEYMAN_PROVISION_KEY)
+#define _KM_DEV_INDEX_EFUSE             2
+#else
+#define _KM_DEV_INDEX_EFUSE             1
+#endif//#if defined(CONFIG_KEYMAN_PROVISION_KEY)
+
+static KmDevKeyOps* _km_devKeyOpsArr[] = {
+            [_KM_DEV_INDEX_SECUREKEY]      = &_SecukeyOps,
+#if defined(CONFIG_KEYMAN_PROVISION_KEY)
+            [_KM_DEV_INDEX_PROVISION]	   = &_provisionKeyOps,
+#endif//#if defined(CONFIG_KEYMAN_PROVISION_KEY)
+#if defined(CONFIG_EFUSE)
+            [_KM_DEV_INDEX_EFUSE]          = &_efuseKeyOps,
+#endif//#if defined(CONFIG_EFUSE)
+};
+
+static const int _KM_DEVCNT = sizeof(_km_devKeyOpsArr) / sizeof(_km_devKeyOpsArr[0]);
+
+int _keyman_hex_ascii_to_buf(const char* input, char* buf, const unsigned bufSz)
+{
+    int ret = 0;
+    const char* tmpStr = input;
+    const unsigned inputLen = strlen(input);
+    int i = 0;
+
+    if (!inputLen) {
+        KM_ERR("err input len 0\n");
+        return __LINE__;
+    }
+    if (inputLen & 1) {
+        KM_ERR("inputLen %d not even\n", inputLen);
+        return __LINE__;
+    }
+    if (bufSz * 2 > inputLen) {
+        KM_ERR("bufSz %d not enough\n", bufSz);
+        return __LINE__;
+    }
+    for (tmpStr = input; *tmpStr; ++tmpStr)
+    {
+        char c = *tmpStr;
+        ret = isxdigit(c);
+        if (!ret) {
+            KM_ERR("input(%s) contain non xdigit, c=%c\n", input, c);
+            return __LINE__;
+        }
+    }
+
+    for (i = 0; i < inputLen; i += 2)
+    {
+        char tmpByte[8];
+        tmpByte[2] = '\0';
+        tmpByte[0] = input[i];
+        tmpByte[1] = input[i + 1];
+
+        const unsigned val = simple_strtoul(tmpByte, NULL, 16);
+        if (val > 0xff) {
+            KM_ERR("Exception: val 0x%x > 0xff\n", val);
+            return __LINE__;
+        }
+        buf[i>>1] = val;
+    }
+
+    return 0;
+}
+
+int _keyman_buf_to_hex_ascii(const uint8_t* pdata, const unsigned dataLen, char* fmtStr/*pr if NULL*/)
+{
+    if (NULL == fmtStr) //Only print
+    {
+        int i = 0;
+        KM_MSG("key len is %d, hex value in hexdump:", dataLen);
+        for (; i < dataLen; ++i, ++pdata)
+        {
+            if (!(i & 0xf)) printf("\n\t[0x%04x]:\t\t", i);
+            printf("%02x ", *pdata);
+        }
+        printf("\n");
+    }
+    else
+    {
+        int i = 0;
+
+        *fmtStr = '\0';
+        for (; i < dataLen; ++i, ++pdata)
+        {
+            sprintf(fmtStr, "%s%02x", fmtStr, *pdata);
+        }
+    }
+
+    return 0;
+}
+
+/*
+ * function name: key_unify_init
+ * buf : input
+ * len  : > 0
+ * return : >=0: ok, other: fail
+ * */
+int key_unify_init(const char* seedStr, const char* dtbLoadaddr)
+{
+    int err=EINVAL;
+    int i;
+    uint64_t seedNum = 0;
+
+    if (!dtbLoadaddr)
+    {
+        dtbLoadaddr = (char*) env_get_ulong("fdtcontroladdr", 16, CONFIG_SYS_SDRAM_BASE + (16U<<20));
+    }
+
+    if (keymanage_dts_parse(dtbLoadaddr)) {
+        KM_DBG("Fail parse /unifykey at addr[0x%p]\n", dtbLoadaddr);
+        return err;
+    }
+
+    seedNum = simple_strtoull(seedStr, NULL, 0);
+    if (!seedNum) {
+        KM_ERR("Seed is 0 err\n");
+        return __LINE__;
+    }
+
+    if (amlkey_if_init(dtbLoadaddr)) {
+        KM_ERR("amlkey interface init fail\n");
+        return __LINE__;
+    }
+
+    for (i=0; i < _KM_DEVCNT; i++)
+    {
+        KmDevKeyOps* theDevOps = _km_devKeyOpsArr[i];
+        err = theDevOps->pInitFunc((char*)&seedNum, sizeof(uint64_t)/sizeof(char));
+        if (err) {
+            KM_ERR("Device[%d] init failed, err=%d\n", i, err);
+            return err;
+        }
+    }
+
+    return 0;
+}
+
+/* function name: key_unify_uninit
+ * functiion : uninit
+ * return : >=0 ok, <0 fail
+ * */
+int key_unify_uninit(void)
+{
+    int err=-EINVAL;
+    int i;
+
+    for (i=0; i < _KM_DEVCNT; i++)
+    {
+        KmDevKeyOps* theDevOps = _km_devKeyOpsArr[i];
+        err = theDevOps->pUninitFunc();
+        if (err) {
+            KM_ERR("device[%d] unini fail\n", i);
+            /*return err;*/
+        }
+    }
+
+    return 0;
+}
+
+static const KmDevKeyOps* _get_km_ops_by_name(const char* keyname)
+{
+    KmDevKeyOps* theDevOps  = NULL;
+
+    //step 1: get device ops by configured key-device
+    enum key_manager_dev_e theDevice = keymanage_dts_get_key_device(keyname);
+
+    switch (theDevice)
+    {
+        case KEY_M_EFUSE_NORMAL:
+            {
+                theDevOps = _km_devKeyOpsArr[_KM_DEV_INDEX_EFUSE];
+            }
+            break;
+
+        case KEY_M_NORAML_KEY:
+        case KEY_M_SECURE_KEY:
+            {
+                theDevOps = _km_devKeyOpsArr[_KM_DEV_INDEX_SECUREKEY];
+            }
+            break;
+
+        case KEY_M_PROVISION_KEY:
+            theDevOps = _km_devKeyOpsArr[_KM_DEV_INDEX_PROVISION];
+            break;
+
+        case KEY_M_UNKNOW_DEV:
+        default:
+            KM_ERR("key %s not know device %d\n", keyname, theDevice);
+            return NULL;
+    }
+
+    return theDevOps;
+}
+
+int key_unify_query_key_has_configure(const char* keyname)
+{
+    return _get_km_ops_by_name(keyname) ? 1 : 0;
+}
+
+/* funtion name: key_unify_write
+ * keyname : key name is ascii string
+ * keydata : key data buf
+ * datalen : key buf len
+ * return  0: ok, -0x1fe: no space, other fail
+ *
+ * Step 1: Get burn target from dtb
+ * Step 2: check whether can burned, OTP can't burned twice
+ *          2.1)check is programmed yet, burn directly if not programmed yet.
+ *          2.2)if programmed yet, check if OTP
+ * Step 3: burn the key to the target
+ * */
+int key_unify_write(const char *keyname, const void* keydata, const unsigned datalen)
+{
+    int err=0;
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    if (!theDevOps->can_overwrite) {
+        KM_DBG("can't overwrite\n");
+        int ret = theDevOps->pKeyExist(keyname);
+        if (ret) {
+            KM_ERR("OTP key[%s] already existed, can't program twice!\n", keyname);
+            return __LINE__;
+        }
+    }
+
+    err = theDevOps->pWriteFunc(keyname, keydata, datalen);
+
+    return err;
+}
+
+/*
+ *function name: key_unify_read
+ * keyname : key name is ascii string
+ * keydata : key data buf
+ * datalen : key buf len
+ * reallen : key real len
+ * return : <0 fail, >=0 ok
+ * */
+int key_unify_read(const char *keyname, void* keydata, const unsigned bufLen)
+{
+    int err=0;
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    int ret = theDevOps->pKeyExist(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] not programed yet\n", keyname);
+        return __LINE__;
+    }
+
+    ret = theDevOps->pKeyCanRead(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read as it's secure\n", keyname);
+        return __LINE__;
+    }
+
+    const ssize_t keySz = theDevOps->pGetSize(keyname);
+    if (keySz > bufLen && bufLen) {
+        KM_ERR("keySz[%lu] > bufLen[%d]\n", keySz, bufLen);
+        return __LINE__;
+    }
+
+    err = theDevOps->pReadFunc(keyname, keydata, keySz);
+
+    return err;
+}
+
+int key_unify_query_size(const char* keyname, ssize_t* keysize)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] not cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+#if 0
+    int ret = theDevOps->pKeyCanRead(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read as it's secure\n", keyname);
+        return __LINE__;
+    }
+#endif
+
+    *keysize = theDevOps->pGetSize(keyname);
+
+    return 0;
+}
+
+int key_unify_query_exist(const char* keyname, int* exist)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name (keyname) ;
+    if (!theDevOps) {
+        KM_ERR("key[%s] not cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    *exist = theDevOps->pKeyExist(keyname);
+
+    return 0;
+}
+
+int key_unify_query_secure(const char* keyname, int* isSecure)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name (keyname) ;
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    int ret = theDevOps->pKeyExist (keyname) ;
+    if (!ret) {
+        KM_ERR("key[%s] not programed yet\n", keyname);
+        return __LINE__;
+    }
+
+    *isSecure = !theDevOps->pKeyCanRead (keyname) ;
+    if (!ret) {
+        KM_ERR ("key[%s] can't read as it's secure\n", keyname) ;
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+int key_unify_query_canOverWrite(const char* keyname, int* canOverWrite)
+{
+    const KmDevKeyOps* theDevOps  = NULL;
+
+    theDevOps = _get_km_ops_by_name(keyname);
+    if (!theDevOps) {
+        KM_ERR("key[%s] no cfg in dts\n", keyname);
+        return __LINE__;
+    }
+
+    *canOverWrite = theDevOps->can_overwrite;
+    return 0;
+}
+
+int do_keyunify (struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    int err;
+    char *cmd;
+    int ret = 0;
+
+    if (argc < 2) return CMD_RET_USAGE;
+
+    cmd = argv[1];
+    //keyman init seedNum <dtbLoadAddr>
+    if (!strcmp(cmd,"init"))
+    {
+        if (argc < 3) {
+            return CMD_RET_USAGE;
+        }
+        const char* seedNum     = argv[2];
+        const char* dtbLoadaddr = argc > 3 ? argv[3] : NULL;
+        err = key_unify_init(seedNum, dtbLoadaddr);
+        return err ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+    }
+
+    //keyunify write keyname addr <size>
+    //keyunify write keyname hexascii
+    if (!strcmp(cmd,"write"))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const char* keyname = argv[2];
+        const char* keyData = (char*)simple_strtoul(argv[3], NULL, 16);
+        unsigned len  = argc > 4 ? simple_strtoul(argv[4], NULL, 0) : 0;
+        char*  dataBuf = NULL;
+
+        if (argc == 4)
+        {
+            const char* hexascii = argv[3];
+
+            len = strlen(hexascii) / 2;
+            dataBuf = (char*)malloc(len);
+            if (!dataBuf) {
+                KM_ERR("Fail in malloc len %d\n", len);
+                return CMD_RET_FAILURE;
+            }
+
+            err = _keyman_hex_ascii_to_buf(hexascii, dataBuf, len);
+            if (err) {
+                KM_ERR("Fail in decrypt hexascii to buf, err=%d\n", err);
+                free(dataBuf);
+                return CMD_RET_FAILURE;
+            }
+            keyData = dataBuf;
+        }
+
+        KM_DBG("write key[%s], addr=%p, len=%d\n", keyname, keyData, len);
+        err = key_unify_write(keyname, keyData, len);
+        if (err ) {
+            KM_ERR("%s key write fail, err=%d\n", keyname, err);
+            return CMD_RET_FAILURE;
+        }
+        if (dataBuf)free(dataBuf) ;
+
+        return CMD_RET_SUCCESS;
+    }
+
+    //keyman query size/secure/exist keyname
+    if (!strcmp(cmd,"query"))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const char* subCmd  = argv[2];
+        const char* keyname = argv[3];
+
+        ret = CMD_RET_FAILURE;
+        if (!strcmp("size", subCmd))
+        {
+            ssize_t keysize = 0;
+            err = key_unify_query_size(keyname, &keysize);
+            if (!err) {
+                ret = CMD_RET_SUCCESS;
+                KM_MSG("key[%s] is %u bytes\n", keyname, (unsigned)keysize);
+            }
+        }
+        else if(!strcmp("secure", subCmd))
+        {
+            int isSecure = 0;
+
+            err = key_unify_query_secure(keyname, &isSecure);
+            if (!err) {
+                ret = CMD_RET_SUCCESS;
+                KM_MSG("key[%s] is %s Secure\n", keyname, isSecure ? "DO" : "NON");
+            }
+        }
+        else if(!strcmp("exist", subCmd))
+        {
+            int exist = 0;
+            err = key_unify_query_exist(keyname, &exist);
+            if (!err) {
+                ret = CMD_RET_SUCCESS;
+                KM_MSG("key[%s] is %s existed\n", keyname, exist ? "DO" : "NON");
+            }
+        }
+        else{
+            return CMD_RET_USAGE;
+        }
+
+        return ret;
+    }
+
+    //keyman read keyname memAddr
+    if (!strcmp(cmd,"read"))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+
+        const char* keyname = argv[2];
+        void* keydata = (void*)simple_strtoul(argv[3], NULL, 16);
+
+        ssize_t keysize = 0;
+        err = key_unify_query_size(keyname, &keysize);
+        if (err) {
+            KM_ERR("Fail in get keysz, err=%d\n", err);
+            return __LINE__;
+        }
+
+        err = key_unify_read(keyname, keydata, (unsigned)keysize);
+        if (err) {
+            KM_ERR("%s key read fail\n", keyname);
+            return CMD_RET_FAILURE;
+        }
+        _keyman_buf_to_hex_ascii(keydata, (unsigned)keysize, NULL);
+
+        return err;
+    }
+
+    if (!strcmp(cmd,"uninit"))
+    {
+        return key_unify_uninit();
+    }
+
+    return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+        keyunify, CONFIG_SYS_MAXARGS, 1, do_keyunify,
+        "key unify sub-system",
+        "init seedNum [dtbAddr] --init the drivers\n"
+        "keyunify uninit - init key in device\n"
+        "keyunify write keyname data <len>  ---- wirte key data. len non-exist if data is ascii str\n"
+        "keyunify read keyname data-addr <len> \n"
+);
+
+
+#if !defined(CONFIG_AML_SECURITY_KEY)
+int keymanage_securekey_init(const char* buf, int len) { return -EINVAL; }
+int keymanage_securekey_exit(void){ return -EINVAL; }
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen){ return -EINVAL; }
+ssize_t keymanage_secukey_size(const char* keyname){ return 0; }
+int keymanage_secukey_exist(const char* keyname){ return 0; }
+int keymanage_secukey_can_read(const char* keyname){ return 0; }
+int keymanage_secukey_read(const char* keyname, void* dataBuf,  unsigned buflen){ return -EINVAL; }
+#endif// #if CONFIG_AML_SECURITY_KEY
+
+#if !defined(CONFIG_EFUSE)
+int keymanage_efuse_init(const char *buf, int len) { return -EINVAL; }
+int keymange_efuse_exit(void) {return -EINVAL;}
+int keymanage_efuse_write(const char *keyname, const void* keydata, unsigned int datalen) { return -EINVAL; }
+int keymanage_efuse_exist(const char* keyname) { return -EINVAL; }
+ssize_t keymanage_efuse_size(const char* keyname) { return 0; }
+int keymanage_efuse_read(const char *keyname, void* dataBuf, const unsigned bufsz) { return -EINVAL; }
+int keymanage_efuse_query_is_burned(const char* keyname) { return -EINVAL; }
+int keymanage_efuse_query_can_read(const char* keyname) { return -EINVAL; }
+#endif// #ifdef CONFIG_EFUSE
+
+#if !defined(CONFIG_OF_LIBFDT)
+int keymanage_dts_parse(const void* dt_addr){ return -EINVAL; }
+enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname){ return -EINVAL; }
+enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname){ return -EINVAL; }
+char unifykey_get_efuse_version(void) { return -1; }
+#endif//#ifdef CONFIG_OF_LIBFDT
+
+
diff --git a/drivers/amlogic/keymanage/km_dts.c b/drivers/amlogic/keymanage/km_dts.c
new file mode 100644
index 0000000000..d2a2186147
--- /dev/null
+++ b/drivers/amlogic/keymanage/km_dts.c
@@ -0,0 +1,392 @@
+#include "key_manage_i.h"
+//#include <fdt.h>
+#include <linux/libfdt.h>
+
+#define UNIFYKEY_DATAFORMAT_HEXDATA	    "hexdata"
+#define UNIFYKEY_DATAFORMAT_HEXASCII	"hexascii"
+#define UNIFYKEY_DATAFORMAT_ALLASCII	"allascii"
+
+#define UNIFYKEY_DEVICE_EFUSEKEY	    "efuse"
+#define UNIFYKEY_DEVICE_NORMAL		    "normal"
+#define UNIFYKEY_DEVICE_SECURESKEY	    "secure"
+#define UNIFYKEY_DEVICE_PROVISIONKEY    "provision"
+
+#define UNIFYKEY_PERMIT_READ		"read"
+#define UNIFYKEY_PERMIT_WRITE		"write"
+#define UNIFYKEY_PERMIT_DEL			"del"
+
+static struct key_info_t unify_key_info={.key_num =0, .key_flag = 0, .efuse_version = -1, .encrypt_type = 0};
+static struct key_item_t *unifykey_item=NULL;
+static struct key_item_t* _defProvisonItem =NULL;//keyname start with "KEY_PROVISION_" and device is "provison"
+#define _PROVSION_DEFAULT_KEY_NAME  "KEY_PROVISION_XXX"
+
+static int unifykey_item_verify_check(struct key_item_t *key_item)
+{
+	if (!key_item) {
+		KM_ERR("unify key item is invalid\n");
+		return -1;
+	}
+
+	if (!key_item->name || (key_item->dev == KEY_M_UNKNOW_DEV) ||(key_item->datFmt == KEY_M_MAX_DF)) {
+		KM_ERR("unify key item is invalid\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct key_item_t *unifykey_find_item_by_name(const char *name)
+{
+	struct key_item_t *pre_item;
+    int i = 0;
+    const unsigned cnt = unify_key_info.key_num;
+
+    for (pre_item = unifykey_item; i < cnt; ++pre_item, ++i)
+    {
+        if (!strcmp(pre_item->name,name)) {
+            return pre_item;
+        }
+    }
+
+    if (!strncmp(_PROVSION_DEFAULT_KEY_NAME, name, strlen(_PROVSION_DEFAULT_KEY_NAME) - 3)) {
+        return _defProvisonItem;
+    }
+	return NULL;
+}
+
+enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname)
+{
+	struct key_item_t *key_manage;
+    enum key_manager_df_e keyValFmt = KEY_M_MAX_DF;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return KEY_M_MAX_DF;
+    }
+
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR ("%s key name is not exist\n", keyname) ;
+		return keyValFmt;
+	}
+	if (unifykey_item_verify_check(key_manage)) {
+		KM_ERR ("%s key name is invalid\n", keyname) ;
+		return keyValFmt;
+	}
+
+    keyValFmt = key_manage->datFmt;
+	return keyValFmt;
+}
+
+//which device does the key stored in
+enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname)
+{
+	struct key_item_t *key_manage;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return KEY_M_MAX_DEV;
+    }
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR("%s key name is not exist\n",keyname);
+		return KEY_M_MAX_DEV;
+	}
+	if (unifykey_item_verify_check(key_manage)) {
+		KM_ERR("%s key name is invalid\n",keyname);
+		return KEY_M_MAX_DEV;
+	}
+
+	return key_manage->dev;
+}
+
+const char* keymanage_dts_get_enc_type(const char* keyname)
+{
+	struct key_item_t *key_manage;
+
+    if (!unify_key_info.key_flag) {
+		KM_ERR("/unify not parsed yet!\n");
+		return NULL;
+	}
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR("%s key name is not exist\n",keyname);
+		return NULL;
+	}
+
+	return key_manage->encType;
+}
+
+const char* keymanage_dts_get_key_type(const char* keyname)
+{
+	struct key_item_t *key_manage;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return NULL;
+    }
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR("%s key name is not exist\n",keyname);
+		return NULL;
+	}
+
+	return key_manage->keyType;
+}
+
+char unifykey_get_efuse_version(void)
+{
+	char ver=0;
+
+    if (!unify_key_info.key_flag) {
+        KM_ERR("/unify not parsed yet!\n");
+        return 0;
+    }
+
+	if (unify_key_info.efuse_version != -1) {
+		ver = (char)unify_key_info.efuse_version;
+	}
+	return ver;
+}
+
+int unifykey_get_encrypt_type(void)
+{
+	return unify_key_info.encrypt_type;
+}
+
+static int unifykey_item_dt_parse(const void* dt_addr,int nodeoffset,int id,char *item_path)
+{
+	struct key_item_t *temp_item=NULL;
+	char *propdata;
+	struct fdt_property *prop;
+	int count;
+
+	temp_item = unifykey_item + id;
+
+	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-encrypt", NULL);
+	if (propdata) {
+		count = strlen(propdata);
+        if ( count > KEY_UNIFY_TYPE_LEN_MAX ) {
+			KM_ERR("key-encrypt [%s] too long\n", propdata);
+			return __LINE__;
+		}
+		memcpy(temp_item->encType, propdata, count);
+	}
+
+	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-name",NULL);
+	if (!propdata) {
+		printf("%s get key-name fail,%s:%d\n",item_path,__func__,__LINE__);
+        return __LINE__;
+	}
+
+	count = strlen(propdata);
+	if (count >= KEY_UNIFY_NAME_LEN) {
+        KM_ERR("key-name strlen (%d) > max(%d) at key_%d\n", count, KEY_UNIFY_NAME_LEN - 1, id);
+        return __LINE__;
+	}
+    memcpy(temp_item->name, propdata, count);
+    temp_item->name[count] = 0;
+
+	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-device",NULL);
+	if (!propdata) {
+		KM_ERR("%s get key-device fail at key_%d\n",item_path, id);
+        return __LINE__;
+	}
+
+    if (strcmp(propdata,UNIFYKEY_DEVICE_EFUSEKEY) == 0) {
+        temp_item->dev = KEY_M_EFUSE_NORMAL;
+    }
+    else if(strcmp(propdata,UNIFYKEY_DEVICE_SECURESKEY) == 0){
+        temp_item->dev = KEY_M_SECURE_KEY;
+    }
+    else if(strcmp(propdata,UNIFYKEY_DEVICE_NORMAL) == 0){
+        temp_item->dev = KEY_M_NORAML_KEY;
+    }
+    else{
+        KM_ERR("key-device %s is unknown at key_%d\n", propdata, id);
+        return __LINE__;
+    }
+
+	propdata = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "key-type",NULL);
+	if (!propdata) //prop 'key-type' not configured, default to raw except special names
+    {
+        strcpy(temp_item->keyType, "raw");
+	}
+    else
+    {
+        const int keyTypeLen = strlen(propdata);
+        if (keyTypeLen > KEY_UNIFY_TYPE_LEN_MAX) {
+            KM_ERR("key[%s]cfg key-type[%s] sz %d > max %d\n", temp_item->name, propdata, keyTypeLen, KEY_UNIFY_TYPE_LEN_MAX);
+            return __LINE__;
+        }
+        strcpy(temp_item->keyType, propdata);
+    }
+
+	prop = (struct fdt_property*)fdt_get_property((const void *)dt_addr,nodeoffset,"key-permit",NULL) ;
+	if (!prop) {
+		KM_ERR("%s get key-permit fail at  key_%d\n",item_path, id);
+        return __LINE__;
+	}
+
+    temp_item->permit = 0;
+    const int propLen = prop->len > 512 ? strnlen(prop->data, 512) : prop->len;
+    if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_READ)) {
+        temp_item->permit |= KEY_M_PERMIT_READ;
+    }
+    if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_WRITE)) {
+        temp_item->permit |= KEY_M_PERMIT_WRITE;
+    }
+    if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_DEL)) {
+        temp_item->permit |= KEY_M_PERMIT_DEL;
+    }
+
+	temp_item->id = id;
+
+    KM_DBG("key[%02d] keyname %s, %d\n", id, temp_item->name, temp_item->dev);
+
+	return 0;
+}
+
+static int unifykey_item_create(const void* dt_addr,int num)
+{
+    int ret = 0;
+    int i,nodeoffset;
+    char item_path[100];
+
+    for (i=0;i<num;i++)
+    {
+        sprintf(item_path, "/unifykey/key_%d", i);
+
+        nodeoffset = fdt_path_offset (dt_addr, item_path) ;
+        if (nodeoffset < 0) {
+            KM_ERR(" dts: not find  node %s.\n",fdt_strerror(nodeoffset));
+            return __LINE__;
+        }
+
+        ret = unifykey_item_dt_parse(dt_addr,nodeoffset, i, item_path);
+        if (ret) {
+            KM_ERR("Fail at parse %s\n", item_path);
+            return __LINE__;
+        }
+    }
+
+    //	printf("unifykey-num fact is %x\n",count);
+    return 0;
+}
+
+//parse and cache the dts cfg
+//TODO: check keys names has no duplicated
+int keymanage_dts_parse(const void* dt_addr)
+{
+    int ret = 0;
+	int child;
+	int nodeoffset, provisionOffset;
+	int unifykeyNum = 0, provisionNum = 0;
+	char *punifykey_num, *encrypt_type;
+
+	if (fdt_check_header(dt_addr)!= 0) {
+        KM_ERR("not a fdt at 0x%p\n", dt_addr);
+        return __LINE__;
+    }
+
+	nodeoffset = fdt_path_offset(dt_addr, "/unifykey");
+	if (nodeoffset < 0) {
+		KM_ERR("dts: err(%s) in find /unifykey.\n",fdt_strerror(nodeoffset));
+		return __LINE__;
+	}
+
+	unify_key_info.efuse_version = -1;
+	punifykey_num = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "efuse-version",NULL);
+	if (punifykey_num) {
+		unify_key_info.efuse_version = be32_to_cpup((unsigned int*)punifykey_num);
+		KM_MSG("efuse-version config is %x\n",unify_key_info.efuse_version);
+	}
+
+	unify_key_info.key_num = 0;
+	fdt_for_each_subnode(child, dt_addr, nodeoffset) {
+		unifykeyNum++;
+	}
+
+	provisionOffset = fdt_path_offset(dt_addr, "/provisionkey");
+	if (provisionOffset >= 0) {
+		fdt_for_each_subnode(child, dt_addr, provisionOffset) {
+			provisionNum++;
+		}
+	}
+	unify_key_info.key_num = unifykeyNum + provisionNum;
+	KM_MSG("key_num: %d\n", unify_key_info.key_num);
+
+	unify_key_info.encrypt_type = -1;
+	encrypt_type = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "unifykey-encrypt",NULL);
+	if (encrypt_type) {
+		unify_key_info.encrypt_type = be32_to_cpup((unsigned int*)encrypt_type);
+	}
+
+	if (unify_key_info.key_num <= 0) {
+		KM_ERR("unifykey-num is not configured\n");
+        return __LINE__;
+	}
+    if (unify_key_info.key_num > 256) {
+        KM_ERR("Cfg key_num is %d > 32,pls check!\n", unify_key_info.key_num);
+        return __LINE__;
+    }
+
+    if (unifykey_item) {
+        free(unifykey_item);
+    }
+    const unsigned keyInfBufLen = unify_key_info.key_num * sizeof(struct key_item_t);
+    unifykey_item = (struct key_item_t*)malloc(keyInfBufLen);
+    memset(unifykey_item, 0 , keyInfBufLen);
+
+    ret = unifykey_item_create(dt_addr,unifykeyNum);
+    unify_key_info.key_flag = ret ? 0 : 1;
+
+    if (provisionOffset >= 0)
+    {
+        KM_DBG("dts: in find /provisionkey.\n");
+
+        int defPermits = 0;
+        const struct fdt_property *prop = fdt_get_property(dt_addr, provisionOffset,"key-permit-default",NULL) ;
+        if (prop) {
+            const int propLen = prop->len > 512 ? strnlen(prop->data, 512) : prop->len;
+            if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_READ)) {
+                defPermits |= KEY_M_PERMIT_READ;
+            }
+            if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_WRITE)) {
+                defPermits |= KEY_M_PERMIT_WRITE;
+            }
+            if (fdt_stringlist_contains(prop->data, propLen, UNIFYKEY_PERMIT_DEL)) {
+                defPermits |= KEY_M_PERMIT_DEL;
+            }
+        }
+
+        int node = 0;
+        int id = unifykeyNum;
+        int szlen = 0;
+        fdt_for_each_subnode(node, dt_addr, provisionOffset) {
+            int len = 0;
+            const char* keyName = fdt_get_name(dt_addr, node, &len);
+            KM_DBG("provisionkey[%s] len %d\n", keyName, len);
+
+            struct key_item_t *pItem= unifykey_item + id;
+
+            szlen = strnlen(keyName, KEY_UNIFY_NAME_LEN - 1);
+            memcpy(pItem->name, keyName, szlen);
+            if (szlen < KEY_UNIFY_NAME_LEN) pItem->name[szlen] = '\0';
+
+            strcpy(pItem->keyType, "raw");
+            pItem->dev = KEY_M_PROVISION_KEY;
+            pItem->permit = defPermits;
+            pItem->id      = id++;
+            if (!strcmp(_PROVSION_DEFAULT_KEY_NAME, keyName)) _defProvisonItem = pItem;
+        }
+
+        if ((node < 0) && (node != -FDT_ERR_NOTFOUND)) {
+            KM_ERR("in parse /provisionkey, err(%s)\n", fdt_strerror(node));
+            return __LINE__;
+        }
+    }
+
+	return ret;
+}
+
diff --git a/drivers/amlogic/keymanage/km_efuse_key.c b/drivers/amlogic/keymanage/km_efuse_key.c
new file mode 100644
index 0000000000..32c373cbbb
--- /dev/null
+++ b/drivers/amlogic/keymanage/km_efuse_key.c
@@ -0,0 +1,156 @@
+/*
+ * \file        km_efuse_key.c
+ * \brief       efuse key ops for key manage
+ *
+ * \version     1.0.0
+ * \date        15/06/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "key_manage_i.h"
+#include <amlogic/asm/secure_apb.h>
+#include <asm/io.h>
+
+#include <command.h>
+#include <amlogic/aml_efuse.h>
+
+#define SECURE_BOOT_KEY_NAME    "secure_boot_set"
+
+extern int efuse_usr_api_init_dtb(const char*  dt_addr);
+extern int efuse_usr_api_get_cfg_key_size(const char* keyname, unsigned* pSz);
+extern int efuse_usr_api_write_key(const char* keyname, const void* keydata, const unsigned dataSz);
+extern int efuse_usr_api_read_key(const char* keyname, void* databuf, const unsigned bufSz);
+
+int keymanage_efuse_init(const char *buf, int len)
+{
+    char ver;
+    int ret = 0;
+
+    const char* dtbLoadAddr;
+    dtbLoadAddr = (char*) env_get_ulong("fdtcontroladdr", 16, CONFIG_SYS_SDRAM_BASE + (16U<<20));
+
+    ret = efuse_usr_api_init_dtb(dtbLoadAddr);
+    if (ret) {
+        KM_ERR("efuse init failed\n");
+        return __LINE__;
+    }
+
+    ver = unifykey_get_efuse_version();
+    if (ver == 0) {
+        KM_DBG("efuse version not cfg\n");
+        return 0;
+    }
+
+    //TODO: program the efuse version
+
+    return ret;
+}
+
+int keymange_efuse_exit(void)
+{
+    return 0;
+}
+
+//must be hexdata if stored in efuse
+int keymanage_efuse_write(const char *keyname, const void* keydata, unsigned int datalen)
+{
+    int ret = 0;
+
+    if (!strcmp(SECURE_BOOT_KEY_NAME, keyname))
+    {
+            char _cmdbuf[96];
+            sprintf(_cmdbuf, "efuse %s %p", keyname, keydata);
+            ret = run_command(_cmdbuf, 0);;
+    }
+    else
+    {
+            ret = efuse_usr_api_write_key(keyname,  keydata, datalen);
+    }
+
+    return ret;
+}
+
+ssize_t keymanage_efuse_size(const char* keyname)
+{
+    int ret = 0;
+    unsigned cfgSz = 0;
+
+    ret = efuse_usr_api_get_cfg_key_size(keyname, &cfgSz);
+    if (ret || !cfgSz) {
+        KM_ERR("Fail at get cfg size for efuse key[%s]\n", keyname);
+        return 0;
+    }
+
+    return cfgSz;
+}
+
+int keymanage_efuse_exist(const char* keyname)
+{
+
+        if (!strcmp(SECURE_BOOT_KEY_NAME, keyname))
+        {
+                const unsigned long cfg10 = IS_FEAT_BOOT_VERIFY();
+                KM_MSG("cfg10=0x%lX\n", cfg10);
+                return ( cfg10 );
+        }
+        else
+        {
+                int ret = 0;
+                const ssize_t cfgSz = keymanage_efuse_size(keyname);
+                char* databuf = NULL;
+                int isEmpty = 1;
+                int i = 0;
+
+                databuf = (char*)malloc(cfgSz);
+                if (!databuf) {
+                        KM_ERR("Fail to alloc bufsz 0x%x for key %s\n", (unsigned)cfgSz, keyname);
+                        return 0;
+                }
+                ret = keymanage_efuse_read(keyname, databuf, cfgSz);
+                if (ret) {
+                        KM_ERR("Fail at read key[%s]\n", keyname);
+                        goto _exit;
+                }
+                for (i = 0; i < cfgSz && isEmpty; ++i) {
+                        isEmpty = !databuf[i];
+                }
+
+_exit:
+                free(databuf);
+                return !isEmpty;
+        }
+
+        return __LINE__;
+}
+
+int keymanage_efuse_query_can_read(const char* keyname)
+{
+        if (!strcmp(SECURE_BOOT_KEY_NAME, keyname))
+        {
+                return 0;
+        }
+        else
+        {
+                return 1;//user space always can be read
+        }
+}
+
+//data format is hexdata
+int keymanage_efuse_read(const char *keyname, void* databuf, const unsigned bufSz)
+{
+    int ret = 0;
+    unsigned cfgSz = 0;
+
+    cfgSz = keymanage_efuse_size(keyname);
+    if (cfgSz > bufSz) {
+        KM_ERR("buf sz 0x%x < dts cfg sz 0x%x\n", bufSz, cfgSz);
+        return __LINE__;
+    }
+
+    ret = efuse_usr_api_read_key(keyname, databuf, cfgSz);
+
+    return ret;
+}
+
diff --git a/drivers/amlogic/keymanage/km_provision_key.c b/drivers/amlogic/keymanage/km_provision_key.c
new file mode 100644
index 0000000000..954a42b28a
--- /dev/null
+++ b/drivers/amlogic/keymanage/km_provision_key.c
@@ -0,0 +1,102 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+* *
+This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+* *
+This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+* *
+You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+* *
+Description:
+*/
+
+#include "key_manage_i.h"
+#include <cli.h>
+
+#define _CMD_BUF_LEN 512
+static char _cmdBuf[_CMD_BUF_LEN];
+
+int keymanage_provision_init(const char *buf, int len)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+	return 0;
+}
+
+int keymanage_provision_exit(void)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+    return 0;
+}
+
+//must be hexdata if stored in efuse
+int keymanage_provision_write(const char *keyname, const void* keydata, unsigned int datalen)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+
+	snprintf(_cmdBuf, _CMD_BUF_LEN, "factory_provision write %s 0x%p 0x%x", keyname, keydata, datalen);
+	int iRet = run_command(_cmdBuf, 0);
+	KM_MSG("factory provision[%s], query sta=%d\n", keyname, iRet);
+
+	return iRet;
+}
+
+ssize_t keymanage_provision_size(const char* keyname)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+	uint32_t retBuf[12];
+	snprintf(_cmdBuf, _CMD_BUF_LEN, "factory_provision query %s 0x%p", keyname, retBuf);
+	int iRet = run_command(_cmdBuf, 0);
+	if (iRet) {
+		KM_MSG("factory provision[%s], query sta=%d\n", keyname, iRet);
+		return 0;
+	}
+
+	return retBuf[0];
+}
+
+int keymanage_provision_exist(const char* keyname)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+	snprintf(_cmdBuf, _CMD_BUF_LEN, "factory_provision query %s", keyname);
+	int iRet = run_command(_cmdBuf, 0);
+	if (iRet) KM_MSG("factory provision[%s], query sta=%d\n", keyname, iRet);
+
+	return !iRet;
+}
+
+int keymanage_provision_query_can_read(const char* keyname)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+
+	return 0;//always cannot be read
+}
+
+//read hash instead of actual value
+int keymanage_provision_read(const char *keyname, void* databuf, const unsigned bufSz)
+{
+	KM_DBG("f(%s)L%d\n", __func__, __LINE__);
+	uint32_t retBuf[12];
+	snprintf(_cmdBuf, _CMD_BUF_LEN, "factory_provision query %s 0x%p", keyname, retBuf);
+	int iRet = run_command(_cmdBuf, 0);
+	if (iRet) {
+		KM_MSG("factory provision[%s], query sta=%d\n", keyname, iRet);
+		return __LINE__;
+	}
+	if (bufSz < 32) {
+		KM_ERR("bufsz %d not enough for sha256sum\n", bufSz);
+		return -__LINE__;
+	}
+
+	KM_MSG("provision read return sha256sum, but not original data\n");
+	memcpy(databuf, retBuf + 1, 32);
+	return 0;//
+}
+
diff --git a/drivers/amlogic/keymanage/km_secure_key.c b/drivers/amlogic/keymanage/km_secure_key.c
new file mode 100644
index 0000000000..f33652b1b6
--- /dev/null
+++ b/drivers/amlogic/keymanage/km_secure_key.c
@@ -0,0 +1,263 @@
+/*
+ * \file        km_secure_key.c
+ * \brief       secure storage key ops for key manage
+ *
+ * \version     1.0.0
+ * \date        15/06/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include "key_manage_i.h"
+#include <amlogic/amlkey_if.h>
+#include <u-boot/sha256.h>
+
+int keymanage_securekey_init(const char* buf, int len)
+{
+	int encrypt_type;
+
+	encrypt_type = unifykey_get_encrypt_type();
+	return amlkey_init((uint8_t*)buf, len, encrypt_type);	//confirm
+}
+
+int keymanage_securekey_exit(void)
+{
+    return 0;
+}
+
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen)
+{
+    int ret = 0;
+    uint8_t origSum[SHA256_SUM_LEN];
+    const int isSecure =  ( KEY_M_SECURE_KEY == keymanage_dts_get_key_device(keyname) ) ? 1 : 0;
+    const int isEncrypt= strlen(keymanage_dts_get_enc_type(keyname)) ? 1 : 0;
+    const unsigned int keyAttr = ( isSecure << 0 ) | ( isEncrypt << 8 );
+    ssize_t writenLen = 0;
+
+    if (isSecure)
+    {
+        sha256_context ctx;
+        sha256_starts(&ctx);
+        sha256_update(&ctx, keydata, datalen);
+        sha256_finish(&ctx, origSum);
+    }
+
+    KM_MSG("isEncrypt=%s\n", keymanage_dts_get_enc_type(keyname));
+    KM_DBG("%s, keyname=%s, keydata=%p, datalen=%d, isSecure=%d\n", __func__, keyname, keydata, datalen, isSecure);
+    KM_MSG("keyAttr is 0x%08X\n", keyAttr);
+    writenLen = amlkey_write((uint8_t*)keyname, (uint8_t*)keydata, datalen, keyAttr);
+    if (writenLen != datalen) {
+        KM_ERR("Want to write %u bytes, but only %zd Bytes\n", datalen, writenLen);
+        return __LINE__;
+    }
+
+    if (isSecure)
+    {
+        uint8_t genSum[SHA256_SUM_LEN];
+
+        ret = amlkey_hash_4_secure((uint8_t*)keyname, genSum);
+        if (ret) {
+            KM_ERR("Failed when gen hash for secure key[%s], ret=%d\n", keyname, ret);
+            return __LINE__;
+        }
+
+        ret = memcmp(origSum, genSum, SHA256_SUM_LEN);
+        if (ret)
+        {
+            int index = 0;
+            char origSum_str[SHA256_SUM_LEN * 2 + 2];
+            char genSum_str[SHA256_SUM_LEN * 2 + 2];
+
+            origSum_str[0] = genSum_str[0] = '\0';
+            for (index = 0; index < SHA256_SUM_LEN; ++index) {
+
+                sprintf(origSum_str, "%s%02x", origSum_str, origSum[index]);
+                sprintf(genSum_str, "%s%02x", genSum_str, genSum[index]);
+            }
+
+            KM_ERR("Failed in check hash, origSum[%s] != genSum[%s]\n", origSum_str, genSum_str);
+            return __LINE__;
+        }
+        KM_MSG("OK in check sha1256 in burn key[%s]\n", keyname);
+    }
+
+    return ret;
+}
+
+ssize_t keymanage_secukey_size(const char* keyname)
+{
+	return amlkey_size((uint8_t*)keyname);	//actully size
+}
+
+int keymanage_secukey_exist(const char* keyname)
+{
+	return amlkey_isexsit((uint8_t*)keyname);	//exsit 1, non 0
+}
+
+int keymanage_secukey_can_read(const char* keyname)
+{
+	return !amlkey_issecure((uint8_t*)keyname);	//secure 1, non 0
+}
+
+int keymanage_secukey_read(const char* keyname, void* databuf,  unsigned buflen)
+{
+    int ret = 0;
+
+    ret = keymanage_secukey_can_read(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read, is configured secured?\n", keyname);
+        return __LINE__;
+    }
+
+	const ssize_t readLen = amlkey_read((uint8_t*)keyname, (uint8_t*)databuf, buflen);
+    if (readLen != buflen) {
+        KM_ERR("key[%s], want read %u Bytes, but %zd bytes\n", keyname, buflen, readLen);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+#if 1//hdcp2 rx start
+#define HDCP2_RX_LC128_LEN         (36)
+#define HDCP2_RX_KEY_LEN           (862)
+#pragma pack(push, 1)
+typedef struct _Hdcp2RxKeyFmt{
+    unsigned                version;
+    char                    lc128[HDCP2_RX_LC128_LEN];
+    char                    keyVal[HDCP2_RX_KEY_LEN];
+}Hdcp2RxKeyFmt_t;
+#pragma pack(pop)
+
+#define HDCP2_RX_KEY_TOTAL_LEN        sizeof(Hdcp2RxKeyFmt_t)
+#define HDCP2_RX_KEY_LC128_NAME       "hdcp2lc128"
+#define HDCP2_RX_KEY_NAME             "hdcp2key"
+#define HDCP2_RX_KEY_VERSION           (0x02000000U)
+#define HDCP2_VERSION_LEN               ( 4 )
+
+static char generalDataChange(const char input)
+{
+    int i;
+    char result = 0;
+
+    for (i=0; i<8; i++) {
+        if ((input & (1<<i)) != 0)
+            result |= (1<<(7-i));
+        else
+            result &= ~(1<<(7-i));
+    }
+
+    return result;
+}
+
+static void hdcp2DataEncryption(const unsigned len, const char *input, char *out)
+{
+    int i = 0;
+
+    for (i=0; i<len; i++)
+        *out++ = generalDataChange(*input++);
+}
+
+static void hdcp2DataDecryption(const unsigned len, const char *input, char *out)
+{
+    int i = 0;
+
+    for (i=0; i<len; i++)
+        *out++ = generalDataChange(*input++);
+}
+
+int _burn_key_in_type_hdcp2(const char* keyname, void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    Hdcp2RxKeyFmt_t* pHdcp2RxKey = (Hdcp2RxKeyFmt_t*)databuf;
+    const int keyLen = HDCP2_RX_KEY_TOTAL_LEN;
+
+    if (keyLen > bufLen) {
+        KM_ERR("hdcp2 rx len unsupported. want %d but get %d\n", keyLen, bufLen);
+        return __LINE__;
+    }
+    if (HDCP2_RX_KEY_VERSION != pHdcp2RxKey->version) {
+        KM_ERR("Version value 0x%x is error, should be 0x%x\n", pHdcp2RxKey->version, HDCP2_RX_KEY_VERSION);
+        return __LINE__;
+    }
+
+    hdcp2DataEncryption(keyLen, databuf, decryptBuf);
+    KM_MSG("Ecnrypt hdcp2 END.\n");
+    pHdcp2RxKey = (Hdcp2RxKeyFmt_t*)decryptBuf;
+
+    const uint8_t* tmpName      = (uint8_t*)HDCP2_RX_KEY_LC128_NAME;
+    unsigned        tmpLen      = HDCP2_RX_LC128_LEN;
+    unsigned        isSecure    = 0;
+    ssize_t retLen = 0;
+    retLen = amlkey_write(tmpName, (uint8_t*)&pHdcp2RxKey->lc128, tmpLen , isSecure);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in write hdcp2 lc128, retLen %zd != want len %d\n", retLen, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpName = (uint8_t*)HDCP2_RX_KEY_NAME;
+    tmpLen = HDCP2_RX_KEY_LEN;
+    retLen = amlkey_write(tmpName, (uint8_t*)&pHdcp2RxKey->keyVal, tmpLen , isSecure);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in write hdcp2 key, retLen %zd != want len %d\n", retLen, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpLen = HDCP2_VERSION_LEN;
+    retLen = amlkey_write((uint8_t*)keyname, (uint8_t*)&pHdcp2RxKey->version, tmpLen, isSecure);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in write hdcp2 key, retLen %zd != want len %d\n", retLen, tmpLen) ;
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+int _read_key_in_type_hdcp2(const char* keyname, void* databuf, const unsigned bufLen, char* decryptBuf)
+{
+    const unsigned srcKeyLen    = HDCP2_RX_KEY_TOTAL_LEN;
+    Hdcp2RxKeyFmt_t* pHdcp2RxKey = (Hdcp2RxKeyFmt_t*)decryptBuf;
+    const uint8_t* tmpName = NULL;
+    int tmpLen = 0;
+
+    if (bufLen < srcKeyLen) {
+        KM_ERR("hdcp2 rx len unsupported. want %d but only %d\n", srcKeyLen, bufLen);
+        return __LINE__;
+    }
+
+    ssize_t retLen = 0;
+    tmpName = (uint8_t*)keyname;
+    tmpLen = HDCP2_VERSION_LEN;
+    retLen = amlkey_read(tmpName, (uint8_t*)&pHdcp2RxKey->version, tmpLen);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in read key[%s] at len %d\n", tmpName, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpName = (uint8_t*)HDCP2_RX_KEY_NAME;
+    tmpLen  = HDCP2_RX_KEY_LEN;
+    retLen = amlkey_read(tmpName, (uint8_t*)&pHdcp2RxKey->keyVal, tmpLen);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in read key[%s] at len %d\n", tmpName, tmpLen) ;
+        return __LINE__;
+    }
+
+    tmpName = (uint8_t*)HDCP2_RX_KEY_LC128_NAME;
+    tmpLen  = HDCP2_RX_LC128_LEN;
+    retLen = amlkey_read(tmpName, (uint8_t*)&pHdcp2RxKey->lc128, tmpLen);
+    if (retLen != tmpLen) {
+        KM_ERR ("Fail in read key[%s] at len %d\n", tmpName, tmpLen) ;
+        return __LINE__;
+    }
+
+    hdcp2DataDecryption(srcKeyLen, (char*)pHdcp2RxKey, databuf);
+
+    return 0;
+}
+int _km_hdcp2_size(void)
+{
+    return HDCP2_RX_KEY_TOTAL_LEN;
+}
+#endif//hdcp2 rx end
+
+
diff --git a/drivers/amlogic/keymanage/km_secure_key_2015.c b/drivers/amlogic/keymanage/km_secure_key_2015.c
new file mode 100644
index 0000000000..5baabb88f0
--- /dev/null
+++ b/drivers/amlogic/keymanage/km_secure_key_2015.c
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * drivers/keymanage/km_secure_key.c
+ *
+ * Copyright (C) 2020 Amlogic, Inc. All rights reserved.
+ *
+ */
+
+#include "key_manage_i.h"
+#include <amlogic/amlkey_if.h>
+#include <u-boot/sha256.h>
+
+int keymanage_securekey_init(const char* buf, int len)
+{
+	int encrypt_type;
+
+	encrypt_type = unifykey_get_encrypt_type();
+	return amlkey_init((uint8_t*)buf, len, encrypt_type);	//confirm
+}
+
+int keymanage_securekey_exit(void)
+{
+    return 0;
+}
+
+int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned int datalen)
+{
+    int ret = 0;
+    uint8_t origSum[SHA256_SUM_LEN];
+    const int isSecure =  ( KEY_M_SECURE_KEY == keymanage_dts_get_key_device(keyname) ) ? 1 : 0;
+    const int isEncrypt= strlen(keymanage_dts_get_enc_type(keyname)) ? 1 : 0;
+    const unsigned int keyAttr = ( isSecure << 0 ) | ( isEncrypt << 8 );
+    ssize_t writenLen = 0;
+
+    if (isSecure)
+    {
+        sha256_context ctx;
+        sha256_starts(&ctx);
+        sha256_update(&ctx, keydata, datalen);
+        sha256_finish(&ctx, origSum);
+    }
+
+    KM_MSG("isEncrypt=%s\n", keymanage_dts_get_enc_type(keyname));
+    KM_DBG("%s, keyname=%s, keydata=%p, datalen=%d, isSecure=%d\n", __func__, keyname, keydata, datalen, isSecure);
+    KM_MSG("keyAttr is 0x%08X\n", keyAttr);
+    writenLen = amlkey_write((uint8_t*)keyname, (uint8_t*)keydata, datalen, keyAttr);
+    if (writenLen != datalen) {
+        KM_ERR("Want to write %u bytes, but only %zd Bytes\n", datalen, writenLen);
+        return __LINE__;
+    }
+
+    if (isSecure)
+    {
+        uint8_t genSum[SHA256_SUM_LEN];
+
+        ret = amlkey_hash_4_secure((uint8_t*)keyname, genSum);
+        if (ret) {
+            KM_ERR("Failed when gen hash for secure key[%s], ret=%d\n", keyname, ret);
+            return __LINE__;
+        }
+
+        ret = memcmp(origSum, genSum, SHA256_SUM_LEN);
+        if (ret)
+        {
+            int index = 0;
+            char origSum_str[SHA256_SUM_LEN * 2 + 2];
+            char genSum_str[SHA256_SUM_LEN * 2 + 2];
+
+            origSum_str[0] = genSum_str[0] = '\0';
+            for (index = 0; index < SHA256_SUM_LEN; ++index) {
+
+                sprintf(origSum_str, "%s%02x", origSum_str, origSum[index]);
+                sprintf(genSum_str, "%s%02x", genSum_str, genSum[index]);
+            }
+
+            KM_ERR("Failed in check hash, origSum[%s] != genSum[%s]\n", origSum_str, genSum_str);
+            return __LINE__;
+        }
+        KM_MSG("OK in check sha1256 in burn key[%s]\n", keyname);
+    }
+
+    return ret;
+}
+
+ssize_t keymanage_secukey_size(const char* keyname)
+{
+	return amlkey_size((uint8_t*)keyname);	//actully size
+}
+
+int keymanage_secukey_exist(const char* keyname)
+{
+	return amlkey_isexsit((uint8_t*)keyname);	//exsit 1, non 0
+}
+
+int keymanage_secukey_can_read(const char* keyname)
+{
+	return !amlkey_issecure((uint8_t*)keyname);	//secure 1, non 0
+}
+
+int keymanage_secukey_read(const char* keyname, void* databuf,  unsigned buflen)
+{
+    int ret = 0;
+
+    ret = keymanage_secukey_can_read(keyname);
+    if (!ret) {
+        KM_ERR("key[%s] can't read, is configured secured?\n", keyname);
+        return __LINE__;
+    }
+
+    const ssize_t readLen = amlkey_read((uint8_t*)keyname, (uint8_t*)databuf, buflen);
+    if (readLen != buflen) {
+        KM_ERR("key[%s], want read %u Bytes, but %zd bytes\n", keyname, buflen, readLen);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
diff --git a/drivers/amlogic/storagekey/Kconfig b/drivers/amlogic/storagekey/Kconfig
new file mode 100644
index 0000000000..311ab7e8ec
--- /dev/null
+++ b/drivers/amlogic/storagekey/Kconfig
@@ -0,0 +1,2 @@
+config SECURE_STORAGE
+    bool "Amlogic bl31 storage key"
diff --git a/drivers/amlogic/storagekey/Makefile b/drivers/amlogic/storagekey/Makefile
new file mode 100644
index 0000000000..6e7ccb4ba3
--- /dev/null
+++ b/drivers/amlogic/storagekey/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SECURE_STORAGE) += storagekey.o
+obj-$(CONFIG_SECURE_STORAGE) += securestorage.o
+obj-$(CONFIG_SECURE_STORAGE) += normal_key.o
diff --git a/drivers/amlogic/storagekey/normal_key.c b/drivers/amlogic/storagekey/normal_key.c
new file mode 100644
index 0000000000..9e40c8fdfe
--- /dev/null
+++ b/drivers/amlogic/storagekey/normal_key.c
@@ -0,0 +1,672 @@
+/*
+ * drivers/storagekey/normal_key.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <u-boot/sha256.h>
+#include <malloc.h>
+#include "normal_key.h"
+
+#undef pr_info
+#define pr_info(fmt ...)     printf("[KM]Msg:"fmt)
+#undef pr_err
+#define pr_err(fmt ...)     printf("[KM]Error:f[%s]L%d:", __func__, __LINE__),printf(fmt)
+
+#define DBG 0
+
+/* Storage BLOCK RAW HEAD: fixed 512B*/
+#define ENC_TYPE_DEFAULT 0
+#define ENC_TYPE_EFUSE	1
+#define ENC_TYPE_FIXED	2
+
+#define STORAGE_BLOCK_RAW_HEAD_SIZE 512
+
+#define BLOCK_VERSION_0		0
+
+#define ERR_HEADER	0x1
+#define ERR_KEYMEMFAIL	0x2
+#define ERR_KEYRDFAIL	0x4
+#define ERR_KEYCHKFAIL	0x8
+#define ERR_ENCHDFAIL	0x10
+#define ERR_DATASZ	0x20
+struct storage_block_raw_head {
+	u8 mark[16]; /* AMLNORMAL*/
+	u32 version;
+	u32 enctype; /*from EFUSE, from default, from fixed*/
+	u32 keycnt;
+	u32 initcnt;
+	u32 wrtcnt;
+	u32 errcnt;
+	u32 flags;
+	u8  headhash[32];
+	u8  hash[32];
+};
+
+/* Storage BLOCK ENC HEAD: fixed 512B*/
+#define STORAGE_BLOCK_ENC_HEAD_SIZE 512
+struct storage_block_enc_head {
+	u32 blocksize;
+	u32 flashsize;
+};
+
+/* Storage Format: TLV*/
+enum emTLVTag {
+	EMTLVNONE,
+
+	EMTLVHEAD,
+	EMTLVHEADSIZE,
+
+	EMTLVOBJECT,
+	EMTLVOBJNAMESIZE,
+	EMTLVOBJNAME,
+	EMTLVOBJDATASIZE,
+	EMTLVOBJDATABUF,
+	EMTLVOBJTYPE,
+	EMTLVOBJATTR,
+	EMTLVOBJHASHBUF,
+
+	EMTLVHEADFLASHSIZE,
+};
+
+struct storage_node {
+	struct list_head node;
+	struct storage_object object;
+};
+
+static LIST_HEAD(keys);
+static int blockinited;
+static struct storage_block_raw_head rawhead;
+static struct storage_block_enc_head enchead;
+static char *blockmark = "AMLNORMAL";
+
+#if DBG
+static void dump_raw_head(struct storage_block_raw_head *prawhead)
+{
+	pr_info("rawhead:\n");
+	pr_info("mark: %s\n", prawhead->mark);
+	pr_info("keycnt: %u\n", prawhead->keycnt);
+	pr_info("initcnt: %u\n", prawhead->initcnt);
+	pr_info("wrtcnt: %u\n", prawhead->wrtcnt);
+	pr_info("errcnt: %u\n", prawhead->errcnt);
+	pr_info("flags: 0x%x\n", prawhead->flags);
+}
+
+static void dump_enc_head(struct storage_block_enc_head *penchead)
+{
+	pr_info("enchead:\n");
+	pr_info("blocksize: %u\n", penchead->blocksize);
+	pr_info("flashsize: %u\n", penchead->flashsize);
+}
+
+static void dump_mem(const u8 *p, int len)
+{
+	int idx = 0, j, tmp;
+	char buf[64];
+	int total;
+
+	while (idx < len) {
+		total = 0;
+		tmp = min(((int)len - idx), 16);
+		for (j = 0; j < tmp; j++)
+			total += snprintf(buf + total, 64 - total,
+					  "%02x ", p[idx + j]);
+		buf[total] = 0;
+		pr_info("%s\n", buf);
+		idx += tmp;
+	}
+}
+
+static void dump_object(struct storage_object *obj)
+{
+	pr_info("key: [%u, %.*s, %x, %x, %u]\n",
+		obj->namesize, obj->namesize, obj->name,
+		obj->type, obj->attribute, obj->datasize);
+	if (obj->dataptr) {
+		pr_info("data:\n");
+		dump_mem(obj->dataptr, obj->datasize);
+	}
+}
+#endif
+
+static u32 Tlv_WriteUint32(u8 *output, s32 len,
+			   u32 tag, u32 value)
+{
+	u32 *out = (u32 *)output;
+
+	if (len < 12)
+		return 0;
+
+	out[0] = tag;
+	out[1] = 4;
+	out[2] = value;
+	return 12;
+}
+
+static u32 Tlv_WriteBuf(u8 *output, s32 len,
+			u32 tag,
+			u32 length, u8 *input)
+{
+	u8 *out = output;
+	u32 tmplen = (((length + 3) / 4) * 4);
+
+	if (len < (s32)(8 + tmplen))
+		return 0;
+
+	*((u32 *)out) = tag;
+	*((u32 *)(out + 4)) = tmplen;
+	memset(out + 8, 0, tmplen);
+	memcpy(out + 8, input, length);
+
+	return tmplen + 8;
+}
+
+static u32 Tlv_ReadTl(u8 *input, int32_t len,
+		      u32 *tag, u32 *length,
+		      u32 *idx)
+{
+	if (len < 8)
+		return 0;
+
+	*tag = *((u32 *)input);
+	*length =  *((u32 *)(input + 4));
+
+	if ((8 + *length) > len)
+		return 0;
+	*idx += 8;
+
+	return 8;
+}
+
+static u32 Tlv_ReadHead(u8 *input, int32_t len,
+			struct storage_block_enc_head *pblockhead)
+{
+	u32 tag;
+	u32 sum;
+	u32 length;
+	u32 idx = 0;
+	u32 ret;
+
+	ret = Tlv_ReadTl(input, len,
+			 &tag, &sum, &idx);
+	if (!ret)
+		return 0;
+
+	if (tag != EMTLVHEAD)
+		return 0;
+
+	sum += ret;
+	while (idx < sum) {
+		ret = Tlv_ReadTl(input + idx, len - idx,
+				 &tag, &length, &idx);
+		if (!ret)
+			return 0;
+
+		switch (tag) {
+		case EMTLVHEADSIZE:
+			pblockhead->blocksize = *((u32 *)(input + idx));
+			break;
+		case EMTLVHEADFLASHSIZE:
+			pblockhead->flashsize = *((u32 *)(input + idx));
+			break;
+		default:
+			break;
+		}
+		idx += length;
+	}
+	return sum;
+}
+
+static u32 Tlv_ReadObject(u8 *input, int32_t len,
+			  struct storage_object *pcontent)
+{
+	u32 tag;
+	u32 length;
+	u32 sum;
+	u32 idx = 0;
+	u32 ret;
+
+	memset(pcontent, 0, sizeof(*pcontent));
+	ret = Tlv_ReadTl(input, len,
+			 &tag, &sum, &idx);
+	if (!ret)
+		return 0;
+
+	if (tag != EMTLVOBJECT)
+		return 0;
+
+	sum += ret;
+	while (idx < sum) {
+		ret = Tlv_ReadTl(input + idx, len - idx,
+				 &tag, &length, &idx);
+		if (!ret)
+			goto tlv_readkeycontent_err;
+
+		switch (tag) {
+		case EMTLVOBJNAMESIZE:
+			pcontent->namesize = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJNAME:
+			memset(pcontent->name, 0, MAX_OBJ_NAME_LEN);
+			memcpy(pcontent->name, input + idx, pcontent->namesize);
+			break;
+		case EMTLVOBJTYPE:
+			pcontent->type = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJATTR:
+			pcontent->attribute = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJDATASIZE:
+			pcontent->datasize = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJHASHBUF:
+			if (length != 32)
+				goto tlv_readkeycontent_err;
+			memcpy(pcontent->hashptr, input + idx, length);
+			break;
+		case EMTLVOBJDATABUF:
+			pcontent->dataptr = malloc(pcontent->datasize);
+			if (!pcontent->dataptr)
+				goto tlv_readkeycontent_err;
+			memcpy(pcontent->dataptr,
+			       input + idx, pcontent->datasize);
+			break;
+		default:
+			break;
+		}
+		idx += length;
+	}
+	return sum;
+
+tlv_readkeycontent_err:
+	free(pcontent->dataptr);
+	return 0;
+}
+
+#define WRT_UINT32(tag, field) \
+	({ \
+		u32 __tmp; \
+		__tmp = Tlv_WriteUint32(output + idx, len - idx, \
+					tag, field); \
+		if (__tmp) \
+			idx += __tmp; \
+		__tmp; \
+	})
+
+#define WRT_BUF(tag, buflen, buf) \
+	({ \
+		u32 __tmp; \
+		__tmp = Tlv_WriteBuf(output + idx, len - idx, \
+				     tag, buflen, buf); \
+		if (__tmp) \
+			idx += __tmp; \
+		__tmp; \
+	})
+
+u32 Tlv_WriteHead(struct storage_block_enc_head *enchead,
+		  u8 *output, int32_t len)
+{
+	u32 *sum;
+	u32 idx = 0;
+
+	if (len < 8)
+		return 0;
+
+	*(u32 *)output = EMTLVHEAD;
+	sum = (u32 *)(output + 4);
+	idx += 8;
+
+	if (!WRT_UINT32(EMTLVHEADSIZE, enchead->blocksize))
+		return 0;
+	if (!WRT_UINT32(EMTLVHEADFLASHSIZE, enchead->flashsize))
+		return 0;
+
+	*sum = idx - 8;
+	return idx;
+}
+
+u32 Tlv_WriteObject(struct storage_object *object,
+		    u8 *output, int32_t len)
+{
+	u32 *sum;
+	u32 idx = 0;
+
+	if (len < 8)
+		return 0;
+
+	*(u32 *)output = EMTLVOBJECT;
+	sum = (u32 *)(output + 4);
+	idx += 8;
+
+	if (object->namesize != 0) {
+		if (!WRT_UINT32(EMTLVOBJNAMESIZE, object->namesize))
+			return 0;
+		if (!WRT_BUF(EMTLVOBJNAME, object->namesize,
+			     (u8 *)object->name))
+			return 0;
+	}
+
+	if (object->dataptr && object->datasize != 0) {
+		if (!WRT_UINT32(EMTLVOBJDATASIZE, object->datasize))
+			return 0;
+		if (!WRT_BUF(EMTLVOBJDATABUF, object->datasize,
+			     object->dataptr))
+			return 0;
+	}
+
+	if (!WRT_BUF(EMTLVOBJHASHBUF, 32, object->hashptr))
+		return 0;
+	if (!WRT_UINT32(EMTLVOBJTYPE, object->type))
+		return 0;
+	if (!WRT_UINT32(EMTLVOBJATTR, object->attribute))
+		return 0;
+
+	*sum = idx - 8;
+	return idx;
+}
+
+static int normalkey_hash(u8 *data, u32 len, u8 *hash)
+{
+	sha256_context ctx;
+	sha256_starts(&ctx);
+	sha256_update(&ctx, data, len);
+	sha256_finish(&ctx, hash);
+	return 0;
+}
+
+int normalkey_init(void)
+{
+	if (blockinited)
+		return 0;
+
+	blockinited = 1;
+	return 0;
+}
+
+void normalkey_deinit(void)
+{
+	struct storage_node *pos, *n;
+
+	if (!blockinited)
+		return;
+
+	blockinited = 0;
+
+	list_for_each_entry_safe(pos, n, &keys, node) {
+		list_del(&pos->node);
+		free(pos->object.dataptr);
+		free(pos);
+	}
+}
+
+struct storage_object *normalkey_get(const u8 *name)
+{
+	struct storage_node *pos;
+	struct storage_object *obj;
+	u32 len;
+
+	if (!name)
+		return NULL;
+
+	len = strlen((const char*)name);
+	list_for_each_entry(pos, &keys, node) {
+		obj = &pos->object;
+		if (len == obj->namesize &&
+		    !memcmp(name, obj->name, len))
+			return obj;
+	}
+
+	return NULL;
+}
+
+int normalkey_add(const u8 *name, u8 *buffer, u32 len, u32 attr)
+{
+	struct storage_object *obj;
+	struct storage_node *node;
+	u32 namelen;
+	u8 *data;
+
+	if (blockinited != 2)
+		return -1;
+
+	if (!name || !buffer || !len || (attr & OBJ_ATTR_SECURE))
+		return -1;
+
+	namelen = strlen((const char*)name);
+	if (namelen > MAX_OBJ_NAME_LEN)
+		return -1;
+
+	obj = normalkey_get(name);
+	if (obj) {
+		if (attr != obj->attribute)
+			return -1;
+		if (len > obj->datasize) {
+			data = malloc(len);
+			if (!data)
+				return -1;
+			free(obj->dataptr);
+			obj->dataptr = data;
+		}
+	} else {
+		node = malloc(sizeof(*node));
+		if (!node)
+			return -1;
+		data = malloc(len);
+		if (!data) {
+			free(node);
+			return -1;
+		}
+		obj = &node->object;
+		memcpy(obj->name, name, namelen);
+		obj->namesize = namelen;
+		obj->attribute = attr;
+		obj->type = OBJ_TYPE_GENERIC;
+		obj->dataptr = data;
+		list_add(&node->node, &keys);
+	}
+	obj->datasize = len;
+	memcpy(obj->dataptr, buffer, len);
+	normalkey_hash(buffer, len, obj->hashptr);
+	return 0;
+}
+
+int normalkey_del(const u8 *name)
+{
+	struct storage_object *obj;
+	struct storage_node *node;
+
+	if (blockinited != 2)
+		return -1;
+
+	obj = normalkey_get(name);
+	if (!obj)
+		return -1;
+
+	node = container_of(obj, struct storage_node, object);
+	list_del(&node->node);
+	free(obj->dataptr);
+	free(node);
+
+	return 0;
+}
+
+int normalkey_readfromblock(void *block, unsigned long size)
+{
+	struct storage_block_raw_head *prawhead;
+	u8 *penchead, *pdata;
+	struct storage_node *node = NULL;
+	u8 hash[32];
+	u32 idx;
+	u32 ret;
+
+	if (blockinited != 1)
+		return -1;
+
+	prawhead = (struct storage_block_raw_head *)block;
+	penchead = (u8 *)block + STORAGE_BLOCK_RAW_HEAD_SIZE;
+	pdata = penchead + STORAGE_BLOCK_ENC_HEAD_SIZE;
+
+	if (!block || size <=
+	    (STORAGE_BLOCK_ENC_HEAD_SIZE + STORAGE_BLOCK_RAW_HEAD_SIZE))
+		return -1;
+
+	blockinited = 2;
+
+	memset(&rawhead, 0, sizeof(rawhead));
+	strncpy((char*)rawhead.mark, blockmark, 15);
+	rawhead.version = BLOCK_VERSION_0;
+
+	enchead.flashsize = size;
+	if (strcmp((const char *)prawhead->mark, blockmark) != 0) {
+		pr_info("mark is not found\n");
+		return 0;
+	}
+
+	normalkey_hash((u8 *)prawhead, sizeof(*prawhead) - 64,
+		       rawhead.headhash);
+	if (memcmp(rawhead.headhash, prawhead->headhash, 32)) {
+		pr_info("rawhead hash check fail\n");
+		rawhead.flags |= ERR_HEADER;
+	} else {
+		pr_info("rawhead hash check successful\n");
+		rawhead.keycnt = prawhead->keycnt;
+		rawhead.initcnt = prawhead->initcnt;
+		rawhead.wrtcnt = prawhead->wrtcnt;
+		rawhead.errcnt = prawhead->errcnt;
+		rawhead.flags = prawhead->flags;
+	}
+
+	rawhead.initcnt++;
+
+#if DBG
+	dump_raw_head(&rawhead);
+#endif
+
+	normalkey_hash(penchead, size - STORAGE_BLOCK_RAW_HEAD_SIZE,
+		       rawhead.hash);
+	if (memcmp(rawhead.hash, prawhead->hash, 32)) {
+		pr_info("data hash check fail\n");
+		rawhead.errcnt++;
+		return 0;
+	}
+
+	ret = Tlv_ReadHead(penchead, STORAGE_BLOCK_ENC_HEAD_SIZE,
+			   &enchead);
+	if (!ret) {
+		pr_info("read head fail\n");
+		rawhead.flags |= ERR_ENCHDFAIL;
+		return 0;
+	}
+
+#if DBG
+	dump_enc_head(&enchead);
+#endif
+
+	if (size < (enchead.blocksize + STORAGE_BLOCK_ENC_HEAD_SIZE +
+	    STORAGE_BLOCK_RAW_HEAD_SIZE)) {
+		rawhead.flags |= ERR_DATASZ;
+		return 0;
+	}
+
+	idx = 0;
+	while (idx < enchead.blocksize) {
+		struct storage_object *obj = NULL;
+
+		if (!node) {
+			node = malloc(sizeof(*node));
+			if (!node) {
+				rawhead.flags |= ERR_KEYMEMFAIL;
+				break;
+			}
+		}
+		obj = &node->object;
+		ret = Tlv_ReadObject(pdata + idx,
+				     enchead.blocksize - idx, obj);
+		if (!ret) {
+			rawhead.flags |= ERR_KEYRDFAIL;
+			break;
+		}
+		idx += ret;
+
+		normalkey_hash(obj->dataptr, obj->datasize, hash);
+		if (memcmp(hash, obj->hashptr, 32)) {
+			free(obj->dataptr);
+			rawhead.flags |= ERR_KEYCHKFAIL;
+			continue;
+		}
+#if DBG
+		dump_object(obj);
+#endif
+		list_add(&node->node, &keys);
+		node = NULL;
+	}
+
+	free(node);
+	return 0;
+}
+
+int normalkey_writetoblock(void *block, unsigned long size)
+{
+	u8 *prawhead;
+	u8 *penchead, *pdata;
+	struct storage_object *obj = NULL;
+	struct storage_node *node = NULL;
+	u32 idx;
+	u32 ret;
+
+	if (blockinited != 2)
+		return -1;
+
+	prawhead = (u8 *)block;
+	penchead = prawhead + STORAGE_BLOCK_RAW_HEAD_SIZE;
+	pdata = penchead + STORAGE_BLOCK_ENC_HEAD_SIZE;
+
+	if (!block || size <=
+	    (STORAGE_BLOCK_ENC_HEAD_SIZE + STORAGE_BLOCK_RAW_HEAD_SIZE))
+		return -1;
+
+	enchead.flashsize = size;
+	size -= (STORAGE_BLOCK_ENC_HEAD_SIZE + STORAGE_BLOCK_RAW_HEAD_SIZE);
+	idx = 0;
+	rawhead.keycnt = 0;
+	list_for_each_entry(node, &keys, node) {
+		obj = &node->object;
+		ret = Tlv_WriteObject(obj, pdata + idx, size - idx);
+		if (!ret)
+			return -1;
+		idx += ret;
+		rawhead.keycnt++;
+	}
+	enchead.blocksize = idx;
+
+	ret = Tlv_WriteHead(&enchead, penchead, STORAGE_BLOCK_ENC_HEAD_SIZE);
+	if (!ret)
+		return -1;
+
+	rawhead.wrtcnt++;
+	normalkey_hash((u8 *)&rawhead, sizeof(rawhead) - 64,
+		       rawhead.headhash);
+	normalkey_hash(penchead,
+		       enchead.flashsize - STORAGE_BLOCK_RAW_HEAD_SIZE,
+		       rawhead.hash);
+	memcpy(prawhead, &rawhead, sizeof(rawhead));
+
+	return 0;
+}
diff --git a/drivers/amlogic/storagekey/normal_key.h b/drivers/amlogic/storagekey/normal_key.h
new file mode 100644
index 0000000000..18772db67e
--- /dev/null
+++ b/drivers/amlogic/storagekey/normal_key.h
@@ -0,0 +1,49 @@
+/*
+ * drivers/amlogic/storagekey/normal_key.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _AML_NORMAL_KEY_H_
+#define _AML_NORMAL_KEY_H_
+
+#define MAX_OBJ_NAME_LEN	80
+
+/*Attribute*/
+#define OBJ_ATTR_SECURE	BIT(0)
+#define OBJ_ATTR_OTP	BIT(1)
+#define OBJ_ATTR_ENC	BIT(8)
+
+/* Type */
+#define OBJ_TYPE_GENERIC	0xA00000BF
+
+struct storage_object {
+	char name[MAX_OBJ_NAME_LEN];
+	u32 namesize;
+	u32 attribute; /*secure, OTP*/
+	u32 type; /*AES, RSA, GENERIC, ...*/
+	u32 datasize;
+	u8 *dataptr;
+	u8 hashptr[32];
+};
+
+int normalkey_init(void);
+void normalkey_deinit(void);
+struct storage_object *normalkey_get(const u8 *name);
+int normalkey_add(const u8 *name, u8 *buffer, u32 len, u32 attr);
+int normalkey_del(const u8 *name);
+int normalkey_readfromblock(void *block, unsigned long size);
+int normalkey_writetoblock(void *block, unsigned long size);
+
+#endif
diff --git a/drivers/amlogic/storagekey/securestorage.c b/drivers/amlogic/storagekey/securestorage.c
new file mode 100644
index 0000000000..c65fee5586
--- /dev/null
+++ b/drivers/amlogic/storagekey/securestorage.c
@@ -0,0 +1,389 @@
+#include <common.h>
+#include <linux/types.h>
+#include <amlogic/secure_storage.h>
+
+// TODO: refactor
+#include <amlogic/asm/secure_apb.h>
+#include <amlogic/asm/bl31_apis.h>
+
+static uint64_t storage_share_in_base;
+static uint64_t storage_share_out_base;
+static uint64_t storage_share_block_base;
+static uint64_t storage_share_block_size;
+static int32_t storage_init_status;
+
+static uint64_t bl31_storage_ops(uint64_t function_id)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: "+r" (function_id));
+
+	return function_id;
+}
+uint64_t bl31_storage_ops2(uint64_t function_id, uint64_t arg1)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		"smc    #0\n"
+		: "+r" (function_id)
+		: "r"(arg1));
+
+	return function_id;
+}
+uint64_t bl31_storage_ops3(uint64_t function_id, uint64_t arg1, uint32_t arg2)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		__asmeq("%2", "x2")
+		"smc    #0\n"
+		: "+r" (function_id)
+		: "r"(arg1), "r"(arg2));
+
+	return function_id;
+}
+
+static uint64_t bl31_storage_write(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t keyattr)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint8_t *data;
+	uint32_t namelen;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	*input++ = keylen;
+	*input++ = keyattr;
+	data = (uint8_t *)input;
+	memcpy(data, keyname, namelen);
+	data += namelen;
+	memcpy(data, keybuf, keylen);
+	return bl31_storage_ops(SECURITY_KEY_WRITE);
+}
+
+static uint64_t bl31_storage_read(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t *readlen)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name, *buf;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	*input++ = keylen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_READ);
+	if (ret == RET_OK) {
+		*readlen = *output;
+		buf = (uint8_t *)(output+1);
+		memcpy(keybuf, buf, *readlen);
+	}
+	return ret;
+}
+
+static uint64_t bl31_storage_query(uint8_t *keyname, uint32_t *retval)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_QUERY);
+	if (ret == RET_OK)
+		*retval = *output;
+	return ret;
+}
+
+static uint64_t bl31_storage_status(uint8_t *keyname, uint32_t *retval)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_STATUS);
+	if (ret == RET_OK)
+		*retval = *output;
+	return ret;
+}
+static uint64_t bl31_storage_tell(uint8_t *keyname, uint32_t *retval)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_TELL);
+	if (ret == RET_OK)
+		*retval = *output;
+	return ret;
+}
+
+static uint64_t bl31_storage_verify(uint8_t *keyname, uint8_t *hashbuf)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint32_t namelen;
+	uint8_t *name;
+	uint64_t ret;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	ret = bl31_storage_ops(SECURITY_KEY_VERIFY);
+
+	if (ret == RET_OK)
+		memcpy(hashbuf, (uint8_t *)output, 32);
+	return ret;
+}
+
+static uint64_t bl31_storage_list(uint8_t *listbuf,
+	uint32_t outlen, uint32_t *readlen)
+{
+	uint32_t *output = (uint32_t *)storage_share_out_base;
+	uint64_t ret;
+
+	ret = bl31_storage_ops(SECURITY_KEY_LIST);
+	if (ret == RET_OK) {
+		if (*output > outlen)
+			*readlen = outlen;
+		else
+			*readlen = *output;
+		memcpy(listbuf, (uint8_t *)(output+1), *readlen);
+	}
+	return ret;
+}
+
+static uint64_t bl31_storage_remove(uint8_t *keyname)
+{
+	uint32_t *input = (uint32_t *)storage_share_in_base;
+	uint32_t namelen;
+	uint8_t *name;
+
+	namelen = strlen((const char *)keyname);
+	*input++ = namelen;
+	name = (uint8_t *)input;
+	memcpy(name, keyname, namelen);
+	return bl31_storage_ops(SECURITY_KEY_REMOVE);
+}
+
+static inline int32_t smc_to_ns_errno(uint64_t errno)
+{
+	int32_t ret = (int32_t)(errno&0xffffffff);
+	return ret;
+}
+
+void secure_storage_init(void)
+{
+		storage_share_in_base =
+				bl31_storage_ops(GET_SHARE_STORAGE_IN_BASE);
+		storage_share_out_base =
+				bl31_storage_ops(GET_SHARE_STORAGE_OUT_BASE);
+		storage_share_block_base =
+				bl31_storage_ops(GET_SHARE_STORAGE_BLOCK_BASE);
+		storage_share_block_size =
+				bl31_storage_ops(GET_SHARE_STORAGE_BLOCK_SIZE);
+
+		if (storage_share_in_base == SMC_UNK
+				|| storage_share_out_base == SMC_UNK
+				|| storage_share_block_base == SMC_UNK
+				|| storage_share_block_size == SMC_UNK)
+			storage_init_status = -1;
+		else
+			storage_init_status = 1;
+}
+
+void *secure_storage_getbuffer(uint32_t *size)
+{
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1) {
+			storage_share_block_size =
+				bl31_storage_ops(GET_SHARE_STORAGE_BLOCK_SIZE);
+		*size = (uint32_t)storage_share_block_size;
+		return (void *)storage_share_block_base;
+	}
+	else {
+		*size = 0;
+		return NULL;
+	}
+}
+void secure_storage_notifier(void)
+{
+	bl31_storage_ops(SECURITY_KEY_NOTIFY);
+}
+
+void secure_storage_notifier_ex(uint32_t storagesize, uint32_t rsvarg)
+{
+	bl31_storage_ops3(SECURITY_KEY_NOTIFY_EX, storagesize, rsvarg);
+}
+
+int32_t secure_storage_write(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t keyattr)
+{
+	uint32_t ret;
+
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_write(keyname, keybuf, keylen, keyattr);
+	else
+		ret = RET_EUND;
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_read(uint8_t *keyname, uint8_t *keybuf,
+			uint32_t keylen, uint32_t *readlen)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_read(keyname, keybuf, keylen, readlen);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_query(uint8_t *keyname, uint32_t *retval)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_query(keyname, retval);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_status(uint8_t *keyname, uint32_t *retval)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_status(keyname, retval);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_tell(uint8_t *keyname, uint32_t *retval)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_tell(keyname, retval);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_verify(uint8_t *keyname, uint8_t *hashbuf)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_verify(keyname, hashbuf);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_list(uint8_t *listbuf,
+		uint32_t buflen, uint32_t *readlen)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_list(listbuf, buflen, readlen);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_remove(uint8_t *keyname)
+{
+	uint64_t ret;
+	if (storage_init_status == 0)
+		secure_storage_init();
+
+	if (storage_init_status == 1)
+		ret = bl31_storage_remove(keyname);
+	else
+		ret = RET_EUND;
+
+	return smc_to_ns_errno(ret);
+}
+
+void secure_storage_set_info(uint32_t info)
+{
+	register uint64_t x0 asm("x0")= SET_STORAGE_INFO;
+	register uint64_t x1 asm("x1") = info;
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		"smc    #0\n"
+		: :"r" (x0), "r"(x1));
+
+}
+
+int32_t secure_storage_set_enctype(uint32_t type)
+{
+	uint64_t  ret;
+	ret = bl31_storage_ops2(SECURITY_KEY_SET_ENCTYPE, type);
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_get_enctype(void)
+{
+	uint64_t ret;
+	ret = bl31_storage_ops(SECURITY_KEY_GET_ENCTYPE);
+	return smc_to_ns_errno(ret);
+}
+
+int32_t secure_storage_version(void)
+{
+	uint64_t ret;
+	ret = bl31_storage_ops(SECURITY_KEY_VERSION);
+	return smc_to_ns_errno(ret);
+}
diff --git a/drivers/amlogic/storagekey/storagekey.c b/drivers/amlogic/storagekey/storagekey.c
new file mode 100644
index 0000000000..646ad3f0de
--- /dev/null
+++ b/drivers/amlogic/storagekey/storagekey.c
@@ -0,0 +1,587 @@
+/*
+ * drivers/storagekey/storagekey.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/* extern from bl31 */
+/*
+ * when RET_OK
+ * query: retval=1: key exsit,=0: key not exsit
+ * tell: retvak = key size
+ * status: retval=1: secure, retval=0: non-secure
+
+ */
+
+#include <common.h>
+#include <linux/types.h>
+#include <amlogic/secure_storage.h>
+#include <amlogic/amlkey_if.h>
+#include <amlogic/storage.h>
+#include <fdtdec.h>
+#ifdef CONFIG_STORE_COMPATIBLE
+#include <partition_table.h>
+#endif
+#include "normal_key.h"
+
+/* key buffer status */
+/* bit0, dirty flag*/
+#define KEYBUFFER_CLEAN		(0 << 0)
+#define KEYBUFFER_DIRTY		(1 << 0)
+#define SECUESTORAGE_HEAD_SIZE		(256)
+#define SECUESTORAGE_WHOLE_SIZE		(0x40000)
+
+struct storagekey_info_t {
+	uint8_t * buffer;
+	uint32_t size;
+	uint32_t status;
+};
+
+static struct storagekey_info_t storagekey_info = {
+	.buffer = NULL,
+	/* default size */
+	.size = SECUESTORAGE_WHOLE_SIZE,
+	.status = KEYBUFFER_CLEAN,
+};
+
+/**
+ *1.init
+ * return ok 0, fail 1
+ */
+static int32_t _amlkey_init(uint8_t *seed, uint32_t len, int encrypt_type)
+{
+	int32_t ret = 0;
+	uint32_t buffer_size, actual_size;
+
+	/* do nothing for now*/
+	printf("%s() enter!\n", __func__);
+	if (storagekey_info.buffer != NULL) {
+		printf("%s() %d: already init!\n", __func__, __LINE__);
+		goto _out;
+	}
+
+	/* get buffer from bl31 */
+	storagekey_info.buffer = secure_storage_getbuffer(&buffer_size);
+	if (storagekey_info.buffer == NULL) {
+		printf("%s() %d: can't get buffer from bl31!\n",
+			__func__, __LINE__);
+		ret = -1;
+		goto _out;
+	}
+
+	if (encrypt_type == -1)
+		encrypt_type = 0;
+	secure_storage_set_enctype(encrypt_type);
+	actual_size = store_rsv_size("key");
+	printf("%s %d actual_size: 0x%x\n", __func__, __LINE__,
+		actual_size);
+
+	storagekey_info.size = min_t(uint32_t, actual_size, buffer_size);
+	ret = store_rsv_read("key", storagekey_info.size, storagekey_info.buffer);
+	/* When the key is invalid at the first burn, it should be initialized again. */
+	if (ret == RSV_UNVAIL)
+		ret = 0;
+	if (ret) {
+		printf("amlkey init rsv read key faill\n");
+		/* memset head info for bl31 */
+		memset(storagekey_info.buffer, 0, SECUESTORAGE_HEAD_SIZE);
+		ret = 0;
+		goto _out;
+	}
+
+	secure_storage_notifier_ex(storagekey_info.size, 0);
+
+	storagekey_info.buffer = secure_storage_getbuffer(&buffer_size);
+	if (buffer_size != storagekey_info.size) {
+		ret = -1;
+		goto _out;
+	}
+
+#ifdef CONFIG_STORE_COMPATIBLE
+	info_disprotect &= ~DISPROTECT_KEY;  //protect
+#endif
+_out:
+	return ret;
+}
+
+/**
+ *2. query if the key already programmed
+ * return: exsit 1, non 0
+ */
+static int32_t _amlkey_isexsit(const uint8_t * name)
+{
+	int32_t ret = 0;
+	uint32_t retval;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+
+	ret = secure_storage_query((uint8_t *)name, &retval);
+	if (ret) {
+		printf("%s() %d: ret %d\n", __func__, __LINE__, ret);
+		retval = 0;
+	}
+
+	return (int32_t)retval;
+}
+
+static uint32_t _amlkey_get_attr(const uint8_t * name)
+{
+	int32_t ret = 0;
+	uint32_t retval;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+
+	ret = secure_storage_status((uint8_t *)name, &retval);
+	if (ret) {
+		printf("%s() %d: ret %d\n", __func__, __LINE__, ret);
+		retval = 0;
+	}
+
+	return retval;
+}
+
+/**
+ * 3.1 query if the prgrammed key is secure. key must exsit!
+ * return secure 1, non 0;
+ */
+int32_t amlkey_issecure(const uint8_t * name)
+{
+	return (amlkey_get_attr(name)&UNIFYKEY_ATTR_SECURE_MASK);
+}
+
+/**
+ * 3.2 query if the prgrammed key is encrypt
+ * return encrypt 1, non-encrypt 0;
+ */
+int32_t amlkey_isencrypt(const uint8_t * name)
+{
+	return (amlkey_get_attr(name)&UNIFYKEY_ATTR_ENCRYPT_MASK);
+}
+/**
+ * 4. actual bytes of key value
+ *  return actual size.
+ */
+static ssize_t _amlkey_size(const uint8_t *name)
+{
+	ssize_t size = 0;
+	int32_t ret = 0;
+	uint32_t retval;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+
+	ret = secure_storage_tell((uint8_t *)name, &retval);
+	if (ret) {
+		printf("%s() %d: ret %d\n", __func__, __LINE__, ret);
+		retval = 0;
+	}
+	size = (ssize_t)retval;
+	return size;
+}
+
+/**
+ *5. read non-secure key in bytes, return bytes readback actully.
+ * return actual size read back.
+ */
+static ssize_t _amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len)
+{
+	int32_t ret = 0;
+	ssize_t retval = 0;
+	uint32_t actul_len;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return 0;
+	}
+	ret = secure_storage_read((uint8_t *)name, buffer, len, &actul_len);
+	if (ret) {
+		printf("%s() %d: return %d\n", __func__, __LINE__, ret);
+		retval = 0;
+		goto _out;
+	}
+	retval = actul_len;
+_out:
+	return retval;
+}
+
+/**
+ * 6.write secure/non-secure key in bytes , return bytes readback actully
+ * attr: bit0, secure/non-secure;
+ *		 bit8, encrypt/non-encrypt;
+ * return actual size write down.
+ */
+static ssize_t _amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t attr)
+{
+	int32_t ret = 0;
+	ssize_t retval = 0;
+	uint32_t actual_size;
+
+	if ( NULL == name ) {
+		printf("%s() %d, invalid key ", __func__, __LINE__);
+		return retval;
+	}
+	ret = secure_storage_write((uint8_t *)name, buffer, len, attr);
+	if (ret) {
+		printf("%s() %d: return %d\n", __func__, __LINE__, ret);
+		retval = 0;
+		goto _out;
+	} else {
+		retval = (ssize_t)len;
+		/* write down! */
+		if (storagekey_info.buffer != NULL) {
+            ret = store_rsv_write("key", storagekey_info.size, storagekey_info.buffer);
+			if (ret) {
+				printf("%s() %d, store_key_write fail\n",
+					__func__, __LINE__);
+				retval = 0;
+			}
+            actual_size = storagekey_info.size;
+		}
+	}
+_out:
+	return retval;
+}
+/**
+ * 7. get the hash value of programmed secure key | 32bytes length, sha256
+ * return success 0, fail -1
+ */
+static int32_t _amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash)
+{
+	int32_t ret = 0;
+
+	ret = secure_storage_verify((uint8_t *)name, hash);
+
+	return ret;
+}
+
+/**
+ * 7. del key by name
+ * return success 0, fail -1
+ */
+static int32_t _amlkey_del(const uint8_t * name)
+{
+	int32_t ret = 0;
+	uint32_t actual_size;
+
+	ret = secure_storage_remove((uint8_t *)name);
+	if ((ret == 0) && (storagekey_info.buffer != NULL)) {
+		/* flush back */
+        ret = store_rsv_write("key", storagekey_info.size, storagekey_info.buffer);
+		if (ret) {
+			printf("%s() %d, store_key_write fail\n",
+				__func__, __LINE__);
+		}
+	} else {
+		printf("%s() %d, remove key fail\n",
+			__func__, __LINE__);
+	}
+
+	return ret;
+}
+
+
+
+#define DEFINE_MUTEX(...)
+#define mutex_lock(...)
+#define mutex_unlock(...)
+#define PAGE_ALIGNED(a) (((a)&0xFFF)==0)
+#undef pr_info
+#define pr_info(fmt ...)     printf("[KM]Msg:"fmt)
+#undef pr_err
+#define pr_err(fmt ...)     printf("[KM]Error:f[%s]L%d:", __func__, __LINE__),printf(fmt)
+
+#define DEF_NORMAL_BLOCK_SIZE	(256 * 1024)
+//static DEFINE_MUTEX(normalkey_lock);
+static uint32_t normal_blksz = DEF_NORMAL_BLOCK_SIZE;
+static uint32_t normal_flashsize = DEF_NORMAL_BLOCK_SIZE;
+static uint8_t *normal_block;
+
+static int _store_key_read(uint8_t * buffer, uint32_t length, uint32_t *actual_lenth)
+{
+	int ret;
+	uint32_t actual_size;
+	actual_size = store_rsv_size("key");
+	if (actual_size <= 1024)
+		return -1;
+
+	length = min_t(uint32_t, actual_size, length);
+	ret = store_rsv_read("key", length, buffer);
+	/* When the key is invalid at the first burn, it should be initialized again. */
+	if (ret && ret != RSV_UNVAIL) {
+		printf("amlkey init rsv read key faill\n");
+		return -1;
+	}
+	if (actual_lenth)
+		*actual_lenth = length;
+	return 0;
+}
+static int _store_key_write(uint8_t * buffer, uint32_t length, uint32_t *actual_lenth)
+{
+	int32_t ret;
+	ret = store_rsv_write("key", length, buffer);
+	if (ret)
+		return -1;
+	if (actual_lenth)
+		*actual_lenth = length;
+	return 0;
+}
+
+static int32_t _amlkey_init_normal(uint8_t *seed, uint32_t len, int encrypt_type)
+{
+	static int inited = 0;
+	int ret;
+
+	if (inited)
+		return 0;
+	inited = 1;
+
+	if (!normal_block)
+		return -1;
+
+	if (normalkey_init())
+		return -1;
+
+	mutex_lock(&normalkey_lock);
+	ret = _store_key_read(normal_block,
+			     normal_blksz,
+			     &normal_flashsize);
+	if (ret) {
+		pr_err("read storage fail\n");
+		goto finish;
+	}
+
+	ret = normalkey_readfromblock(normal_block, normal_flashsize);
+	if (ret) {
+		pr_err("init block key fail\n");
+		goto finish;
+	}
+
+#ifdef CONFIG_STORE_COMPATIBLE
+	info_disprotect &= ~DISPROTECT_KEY;  //protect
+#endif
+	ret = 0;
+finish:
+	if (ret)
+		normalkey_deinit();
+	mutex_unlock(&normalkey_lock);
+
+	return ret;
+}
+
+static int32_t _amlkey_exist_normal(const uint8_t *name)
+{
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	mutex_unlock(&normalkey_lock);
+
+	return !!obj;
+}
+
+static uint32_t _amlkey_get_attr_normal(const uint8_t *name)
+{
+	uint32_t attr = 0;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj)
+		attr = obj->attribute;
+	mutex_unlock(&normalkey_lock);
+
+	return attr;
+}
+
+static ssize_t _amlkey_size_normal(const uint8_t *name)
+{
+	unsigned int size = 0;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj)
+		size = obj->datasize;
+	mutex_unlock(&normalkey_lock);
+
+	return size;
+}
+
+static ssize_t _amlkey_read_normal(const uint8_t *name, uint8_t *buffer, uint32_t len)
+{
+	unsigned int size = 0;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj && len >= obj->datasize) {
+		size = obj->datasize;
+		memcpy(buffer, obj->dataptr, size);
+	}
+	mutex_unlock(&normalkey_lock);
+
+	return size;
+}
+
+static ssize_t _amlkey_write_normal(const uint8_t *name, uint8_t *buffer,
+				    uint32_t len, uint32_t attr)
+{
+	int ret;
+	uint32_t wrtsz = 0;
+
+	if (attr & OBJ_ATTR_SECURE) {
+		pr_err("can't write secure key\n");
+		return 0;
+	}
+
+	mutex_lock(&normalkey_lock);
+	ret = normalkey_add(name, buffer, len, attr);
+	if (ret) {
+		pr_err("write key fail\n");
+		ret = 0;
+		goto unlock;
+	}
+
+	ret = normalkey_writetoblock(normal_block, normal_flashsize);
+	if (ret) {
+		pr_err("write block fail\n");
+		ret = 0;
+		goto unlock;
+	}
+
+	ret = _store_key_write(normal_block,
+			      normal_flashsize,
+			      &wrtsz);
+	if (ret) {
+		pr_err("write storage fail\n");
+		ret = 0;
+		goto unlock;
+	}
+	ret = len;
+unlock:
+	mutex_unlock(&normalkey_lock);
+	return ret;
+}
+
+static int32_t _amlkey_hash_normal(const uint8_t *name, uint8_t *hash)
+{
+	int ret = -1;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj) {
+		ret = 0;
+		memcpy(hash, obj->hashptr, 32);
+	}
+	mutex_unlock(&normalkey_lock);
+
+	return ret;
+}
+
+int normal_key_init(const void* dt_addr)
+{
+	uint32_t blksz = 0;
+	int nodeoffset;
+	char *pblksz;
+
+	if (!dt_addr || fdt_check_header(dt_addr)!= 0) {
+		goto blkalloc;
+	}
+
+	nodeoffset = fdt_path_offset(dt_addr, "/unifykey");
+	if (nodeoffset < 0) {
+		goto blkalloc;
+	}
+
+	pblksz = (char*)fdt_getprop((const void *)dt_addr, nodeoffset, "blocksize",NULL);
+	if (pblksz) {
+		blksz = be32_to_cpup((unsigned int*)pblksz);
+	}
+
+	if (blksz && PAGE_ALIGNED(blksz)) {
+		normal_blksz = blksz;
+		pr_info("block size from config: %x\n", blksz);
+	}
+
+blkalloc:
+	normal_block = malloc(normal_blksz);
+	if (!normal_block) {
+		pr_err("malloc block buffer fail: %x\n", normal_blksz);
+		return -1;
+	}
+
+	return 0;
+}
+
+enum amlkey_if_type {
+	IFTYPE_SECURE_STORAGE,
+	IFTYPE_NORMAL_STORAGE,
+	IFTYPE_MAX
+};
+
+struct amlkey_if amlkey_ifs[] = {
+	[IFTYPE_SECURE_STORAGE] = {
+		.init = _amlkey_init,
+		.exsit = _amlkey_isexsit,
+		.get_attr = _amlkey_get_attr,
+		.size = _amlkey_size,
+		.read = _amlkey_read,
+		.write = _amlkey_write,
+		.hash = _amlkey_hash_4_secure,
+	},
+	[IFTYPE_NORMAL_STORAGE] = {
+		.init = _amlkey_init_normal,
+		.exsit = _amlkey_exist_normal,
+		.get_attr = _amlkey_get_attr_normal,
+		.size = _amlkey_size_normal,
+		.read = _amlkey_read_normal,
+		.write = _amlkey_write_normal,
+		.hash = _amlkey_hash_normal,
+	}
+};
+
+struct amlkey_if *amlkey_if = &amlkey_ifs[IFTYPE_SECURE_STORAGE];
+int amlkey_if_init(const void* dt_addr)
+{
+	static int inited = 0;
+	uint32_t buffer_size;
+	int ret = 0;
+
+	if (inited)
+		return 0;
+	inited = 1;
+
+	if (secure_storage_getbuffer(&buffer_size)) {
+		amlkey_if = &amlkey_ifs[IFTYPE_SECURE_STORAGE];
+		return ret;
+	}
+
+	pr_info("normal key used!\n");
+	ret = normal_key_init(dt_addr);
+	amlkey_if = &amlkey_ifs[IFTYPE_NORMAL_STORAGE];
+
+	return ret;
+}
diff --git a/drivers/efuse/Kconfig b/drivers/efuse/Kconfig
new file mode 100644
index 0000000000..3ee40478a1
--- /dev/null
+++ b/drivers/efuse/Kconfig
@@ -0,0 +1,4 @@
+config EFUSE
+	bool "AML EFUSE Support"
+	help
+	  Enable support for the Amlogic EFUSE controller.
diff --git a/drivers/efuse/Makefile b/drivers/efuse/Makefile
new file mode 100644
index 0000000000..62ab0325ba
--- /dev/null
+++ b/drivers/efuse/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_EFUSE) += aml_efuse.o
+
+obj-$(CONFIG_EFUSE) += efuse.o
+
+obj-$(CONFIG_EFUSE) += efuse_usr_space_api.o
+
+obj-$(CONFIG_EFUSE) += bl31_apis.o
diff --git a/drivers/efuse/aml_efuse.c b/drivers/efuse/aml_efuse.c
new file mode 100644
index 0000000000..a553a201f7
--- /dev/null
+++ b/drivers/efuse/aml_efuse.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014-2018 Amlogic, Inc. All rights reserved.
+ *
+ * All information contained herein is Amlogic confidential.
+ *
+ * This software is provided to you pursuant to Software License Agreement
+ * (SLA) with Amlogic Inc ("Amlogic"). This software may be used
+ * only in accordance with the terms of this agreement.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification is strictly prohibited without prior written permission from
+ * Amlogic.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+*/
+
+#include <common.h>
+#include <amlogic/aml_efuse.h>
+#include <amlogic/asm/io.h>
+#include <amlogic/asm/secure_apb.h>
+
+//weak function for EFUSE license query
+//all following functions are defined with "weak" for customization of each SoC
+//EFUSE_LICX	--> AO_SEC_SD_CFG10/9 --> EFUSE mirror
+int  __attribute__((weak)) IS_FEAT_BOOT_VERIFY(void)
+{
+	#ifndef ADDR_IS_FEAT_BOOT_VERIFY
+	  #ifdef EFUSE_LIC0
+		  #define ADDR_IS_FEAT_BOOT_VERIFY (EFUSE_LIC0)
+		  #define OSET_IS_FEAT_BOOT_VERIFY (0)
+	  #elif defined(OTP_LIC0)
+		  #define ADDR_IS_FEAT_BOOT_VERIFY (OTP_LIC0)
+		  #define OSET_IS_FEAT_BOOT_VERIFY (0)
+	  #else
+		  #define ADDR_IS_FEAT_BOOT_VERIFY (AO_SEC_SD_CFG10)
+		  #define OSET_IS_FEAT_BOOT_VERIFY (4)
+	  #endif
+	#endif
+
+	return ((readl(ADDR_IS_FEAT_BOOT_VERIFY) >> OSET_IS_FEAT_BOOT_VERIFY) & 1);
+
+	#undef ADDR_IS_FEAT_BOOT_VERIFY
+	#undef OSET_IS_FEAT_BOOT_VERIFY
+}
+int  __attribute__((weak)) IS_FEAT_BOOT_ENCRYPT(void)
+{
+	#ifndef ADDR_IS_FEAT_BOOT_ENCRYPT
+	  #ifdef EFUSE_LIC0
+		#define ADDR_IS_FEAT_BOOT_ENCRYPT (EFUSE_LIC0)
+		#define OSET_IS_FEAT_BOOT_ENCRYPT (1)
+	  #elif defined(OTP_LIC0)
+		#define ADDR_IS_FEAT_BOOT_ENCRYPT (OTP_LIC0)
+		#define OSET_IS_FEAT_BOOT_ENCRYPT (1)
+	  #else
+		#define ADDR_IS_FEAT_BOOT_ENCRYPT (AO_SEC_SD_CFG10)
+		#define OSET_IS_FEAT_BOOT_ENCRYPT (28)
+	  #endif
+	#endif
+
+	return ((readl(ADDR_IS_FEAT_BOOT_ENCRYPT) >> OSET_IS_FEAT_BOOT_ENCRYPT) & 1);
+
+	#undef ADDR_IS_FEAT_BOOT_ENCRYPT
+	#undef OSET_IS_FEAT_BOOT_ENCRYPT
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_EMMC_USER(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_EMMC_BOOT_0(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_EMMC_BOOT_1(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_EN_4BL2_SNOR(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_NBL2_SNOR(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_EN_8BL2_SNAND(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_NBL2_SNAND(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_8BL2_NAND(void)
+{
+	return 0;
+}
+
+int  __attribute__((weak)) IS_FEAT_DIS_NBL2_NAND(void)
+{
+	return 1;
+}
diff --git a/drivers/efuse/bl31_apis.c b/drivers/efuse/bl31_apis.c
new file mode 100644
index 0000000000..18f6fc6968
--- /dev/null
+++ b/drivers/efuse/bl31_apis.c
@@ -0,0 +1,474 @@
+/*
+ * arch/arm/cpu/armv8/txlx/bl31_apis.c
+ *
+ * Copyright (C) 2014-2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/*
+ * Trustzone API
+ */
+
+#include <amlogic/asm/io.h>
+#include <amlogic/asm/efuse.h>
+#include <asm/cache.h>
+#include <amlogic/asm/bl31_apis.h>
+#include <amlogic/cpu_id.h>
+#include <amlogic/asm/secure_apb.h>
+
+static long sharemem_input_base;
+static long sharemem_output_base;
+
+long get_sharemem_info(unsigned long function_id)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: "+r" (function_id));
+
+	return function_id;
+}
+
+int32_t set_boot_params(const keymaster_boot_params *boot_params)
+{
+	const unsigned cmd = SET_BOOT_PARAMS;
+
+	if (!boot_params)
+		return -1;
+
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+
+	memcpy((void *)sharemem_input_base,
+			(const void *)boot_params, sizeof(keymaster_boot_params));
+
+	asm __volatile__("" : : : "memory");
+	register uint64_t x0 asm("x0") = cmd;
+	register uint64_t x1 asm("x1") = sizeof(keymaster_boot_params);
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1));
+	} while (0);
+
+	return (!x0)? -1: 0;
+}
+
+#ifdef CONFIG_EFUSE
+int32_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg)
+{
+	int ret;
+	unsigned cmd, offset, size;
+	unsigned long *retcnt = (unsigned long *)(arg->retcnt_phy);
+
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+
+	if (arg->cmd == EFUSE_HAL_API_READ)
+		cmd = EFUSE_READ;
+	else if (arg->cmd == EFUSE_HAL_API_WRITE)
+		cmd = EFUSE_WRITE;
+	else
+		cmd = EFUSE_WRITE_PATTERN;
+	offset = arg->offset;
+	size = arg->size;
+
+	if (arg->cmd == EFUSE_HAL_API_WRITE)
+		memcpy((void *)sharemem_input_base,
+		       (const void *)arg->buffer_phy, size);
+		asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = cmd;
+	register uint64_t x1 asm("x1") = offset;
+	register uint64_t x2 asm("x2") = size;
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2));
+	} while (0);
+	ret = x0;
+	*retcnt = x0;
+
+	if ((arg->cmd == EFUSE_HAL_API_READ) && (ret != 0))
+		memcpy((void *)arg->buffer_phy,
+		       (const void *)sharemem_output_base, ret);
+
+	if (!ret)
+		return -1;
+	else
+		return 0;
+}
+
+int32_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg)
+{
+	int32_t ret;
+	unsigned cmd;
+
+	if (arg->cmd == EFUSE_HAL_API_USER_MAX)
+		cmd = EFUSE_USER_MAX;
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = cmd;
+
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0));
+	} while (0);
+	ret = x0;
+
+	if (!ret)
+		return -1;
+	else
+		return ret;
+}
+
+ssize_t meson_trustzone_efuse_writepattern(const char *buf, size_t count)
+{
+	struct efuse_hal_api_arg arg;
+	unsigned long retcnt;
+
+	if (count != EFUSE_BYTES)
+		return 0;	/* Past EOF */
+
+	arg.cmd = EFUSE_HAL_API_WRITE_PATTERN;
+	arg.offset = 0;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	int ret;
+	ret = meson_trustzone_efuse(&arg);
+	return ret;
+}
+#endif
+
+uint64_t meson_trustzone_efuse_check(unsigned char *addr)
+{
+	uint64_t ret = 0;
+	struct sram_hal_api_arg arg = {};
+
+	arg.cmd = SRAM_HAL_API_CHECK_EFUSE;
+	arg.req_len = 0x1000000;
+	arg.res_len = 0;
+	arg.req_phy_addr = (unsigned long)addr;
+	arg.res_phy_addr = (unsigned long)NULL;
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = CALL_TRUSTZONE_HAL_API;
+	register uint64_t x1 asm("x1") = TRUSTZONE_HAL_API_SRAM;
+	register uint64_t x2 asm("x2") = (unsigned long)(&arg);
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    "smc #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2));
+	} while (0);
+
+	ret = x0;
+
+	return ret;
+}
+
+void debug_efuse_cmd(unsigned long cmd)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: : "r" (cmd));
+}
+
+void bl31_debug_efuse_write_pattern(const char *buf)
+{
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+	memcpy((void *)sharemem_input_base, (const void *)buf, 512);
+
+	debug_efuse_cmd(DEBUG_EFUSE_WRITE_PATTERN);
+}
+
+void bl31_debug_efuse_read_pattern(char *buf)
+{
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+	debug_efuse_cmd(DEBUG_EFUSE_READ_PATTERN);
+
+	memcpy((void *)buf, (const void *)sharemem_output_base, 512);
+}
+
+void aml_set_jtag_state(unsigned state, unsigned select)
+{
+	uint64_t command;
+	if (state == JTAG_STATE_ON)
+		command = JTAG_ON;
+	else
+		command = JTAG_OFF;
+	asm __volatile__("" : : : "memory");
+
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		"smc    #0\n"
+		: : "r" (command), "r"(select));
+}
+
+unsigned aml_get_reboot_reason(void)
+{
+	unsigned reason;
+	uint64_t ret;
+
+	register uint64_t x0 asm("x0") = GET_REBOOT_REASON;
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc #0\n"
+		:"+r"(x0));
+		ret = x0;
+		reason = (unsigned)(ret&0xffffffff);
+		return reason;
+}
+
+void set_viu_probe_enable(void)
+{
+	register uint64_t x0 asm("x0") = VIU_PREOBE_EN;
+
+	asm volatile(
+			__asmeq("%0", "x0")
+			"smc #0\n"
+			:"+r"(x0));
+}
+unsigned aml_reboot(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2)
+{
+	register long x0 asm("x0") = function_id;
+	register long x1 asm("x1") = arg0;
+	register long x2 asm("x2") = arg1;
+	register long x3 asm("x3") = arg2;
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			__asmeq("%2", "x2")
+			__asmeq("%3", "x3")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1), "r" (x2), "r" (x3));
+
+	return function_id;
+}
+
+void aml_set_reboot_reason(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2)
+{
+	register long x0 asm("x0") = function_id;
+	register long x1 asm("x1") = arg0;
+	register long x2 asm("x2") = arg1;
+	register long x3 asm("x3") = arg2;
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			__asmeq("%2", "x2")
+			__asmeq("%3", "x3")
+			"smc	#0\n"
+			: "+r" (x0)
+			: "r" (x1), "r" (x2), "r" (x3));
+
+	return ;
+}
+
+unsigned long aml_sec_boot_check(unsigned long nType,
+	unsigned long pBuffer,
+	unsigned long nLength,
+	unsigned long nOption)
+{
+	uint64_t ret = 1;
+
+//#define AML_SECURE_LOG_TE
+
+#if defined(AML_SECURE_LOG_TE)
+	#define AML_GET_TE(a) do{a = *((volatile unsigned int*)0xc1109988);}while(0);
+	unsigned nT1,nT2,nT3;
+#else
+	#define AML_GET_TE(...)
+#endif
+
+	AML_GET_TE(nT1);
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = AML_DATA_PROCESS;
+	register uint64_t x1 asm("x1") = nType;
+	register uint64_t x2 asm("x2") = pBuffer;
+	register uint64_t x3 asm("x3") = nLength;
+	register uint64_t x4 asm("x4") = nOption;
+
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    __asmeq("%4", "x3")
+		    __asmeq("%5", "x4")
+		    "smc #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2),"r"(x3),"r"(x4));
+	} while (0);
+
+	ret = x0;
+
+	AML_GET_TE(nT2);;
+
+	flush_dcache_range((unsigned long )pBuffer, (unsigned long )pBuffer+nLength);
+
+	AML_GET_TE(nT3);
+
+#if defined(AML_SECURE_LOG_TE)
+	printf("aml log : dec use %d(us) , flush cache used %d(us)\n",
+		nT2 - nT1, nT3 - nT2);
+#endif
+
+	return ret;
+}
+
+void set_usb_boot_function(unsigned long command)
+{
+	register long x0 asm("x0") = SET_USB_BOOT_FUNC;
+	register long x1 asm("x1") = command;
+
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1));
+}
+
+void aml_system_off(void)
+{
+	/* TODO: Add poweroff capability */
+	aml_reboot(0x82000042, 1, 0, 0);
+	aml_reboot(0x84000008, 0, 0, 0);
+}
+
+int __get_chip_id(unsigned char *buff, unsigned int size)
+{
+	if (buff == NULL || size < 16)
+		return -1;
+
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+
+	if (sharemem_output_base) {
+		register long x0 asm("x0") = GET_CHIP_ID;
+		register long x1 asm("x1") = 2;
+
+		asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+				"smc	#0\n"
+			: "+r" (x0)
+			: "r" (x1));
+
+		if (x0 == 0) {
+			int version = *((unsigned int *)sharemem_output_base);
+
+			if (version == 2) {
+				memcpy(buff, (void *)sharemem_output_base + 4, 16);
+			}
+			else {
+				/**
+				 * Legacy 12-byte chip ID read out, transform data
+				 * to expected order format.
+				 */
+				uint32_t chip_info = readl(P_AO_SEC_SD_CFG8);
+				uint8_t *ch;
+				int i;
+
+				((uint32_t *)buff)[0] =
+					((chip_info & 0xff000000)	|	// Family ID
+					((chip_info << 8) & 0xff0000)	|	// Chip Revision
+					((chip_info >> 8) & 0xff00));		// Package ID
+
+				((uint32_t *)buff)[0] = htonl(((uint32_t *)buff)[0]);
+
+				/* Transform into expected order for display */
+				ch = (uint8_t *)(sharemem_output_base + 4);
+				for (i = 0; i < 12; i++)
+					buff[i + 4] = ch[11 - i];
+			}
+
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+int32_t get_avbkey_from_fip(uint8_t *buf, uint32_t buflen)
+{
+	const unsigned cmd = GET_AVBKEY_FROM_FIP;
+	uint32_t retlen = 0;
+	uint32_t ret = 0;
+
+	if (!buf)
+		return -1;
+
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+
+	asm __volatile__("" : : : "memory");
+	register uint64_t x0 asm("x0") = cmd;
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0));
+	} while (0);
+
+	if (!x0)
+		ret = -1;
+	retlen = x0;
+
+	if (ret != -1 && buflen >= retlen)
+		memcpy(buf, (const void *)sharemem_output_base, retlen);
+
+	return ret;
+}
diff --git a/drivers/efuse/efuse.c b/drivers/efuse/efuse.c
new file mode 100644
index 0000000000..5560bcd384
--- /dev/null
+++ b/drivers/efuse/efuse.c
@@ -0,0 +1,141 @@
+/*
+ * drivers/efuse/efuse.c
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <amlogic/asm/io.h>
+#include <amlogic/asm/efuse.h>
+
+char efuse_buf[EFUSE_BYTES] = {0};
+
+ssize_t efuse_read(char *buf, size_t count, loff_t *ppos)
+{
+	unsigned int pos = *ppos;
+
+	struct efuse_hal_api_arg arg;
+	unsigned int retcnt;
+	int ret;
+
+	arg.cmd = EFUSE_HAL_API_READ;
+	arg.offset = pos;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	ret = meson_trustzone_efuse(&arg);
+	if (ret == 0) {
+		*ppos += retcnt;
+		return retcnt;
+	} else{
+		return ret;
+	}
+}
+
+ssize_t efuse_write(const char *buf, size_t count, loff_t *ppos)
+{
+	unsigned int pos = *ppos;
+
+	if ((pos & 0xffff) >= EFUSE_BYTES)
+		return 0;	/* Past EOF */
+	if (count > EFUSE_BYTES - pos)
+		count = EFUSE_BYTES - pos;
+	if (count > EFUSE_BYTES)
+		return -1;
+
+	struct efuse_hal_api_arg arg;
+	unsigned int retcnt;
+
+	arg.cmd = EFUSE_HAL_API_WRITE;
+	arg.offset = pos;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	int ret;
+
+	ret = meson_trustzone_efuse(&arg);
+	if (ret == 0) {
+		*ppos = retcnt;
+		return retcnt;
+	} else{
+		return ret;
+	}
+}
+
+int efuse_read_usr(char *buf, size_t count, loff_t *ppos)
+{
+	char data[EFUSE_BYTES];
+	char *pdata = NULL;
+	int ret;
+	loff_t pos;
+
+	memset(data, 0, count);
+
+	pdata = data;
+	pos = *ppos;
+	ret = efuse_read(pdata, count, (loff_t *)&pos);
+
+	memcpy(buf, data, count);
+
+	return ret;
+}
+
+int efuse_write_usr(char *buf, size_t count, loff_t *ppos)
+{
+	char data[EFUSE_BYTES];
+	char *pdata = NULL;
+	char *penc = NULL;
+	int ret;
+	loff_t pos;
+
+	if (count == 0) {
+		printf("data length: 0 is error!\n");
+		return -1;
+	}
+
+	memset(data, 0, EFUSE_BYTES);
+	memset(efuse_buf, 0, EFUSE_BYTES);
+
+	memcpy(data, buf, count);
+	pdata = data;
+	penc = efuse_buf;
+
+	memcpy(penc, pdata, count);
+	pos = *ppos;
+
+	ret = efuse_write(efuse_buf, count, (loff_t *)&pos);
+
+	return ret;
+}
+
+uint32_t efuse_get_max(void)
+{
+	struct efuse_hal_api_arg arg;
+	int ret;
+
+	arg.cmd = EFUSE_HAL_API_USER_MAX;
+
+	ret = meson_trustzone_efuse_get_max(&arg);
+	if (ret == 0) {
+		printf("ERROR: can not get efuse user max bytes!!!\n");
+		return -1;
+	} else{
+		return ret;
+	}
+}
diff --git a/drivers/efuse/efuse_usr_space_api.c b/drivers/efuse/efuse_usr_space_api.c
new file mode 100644
index 0000000000..cf9d8edb16
--- /dev/null
+++ b/drivers/efuse/efuse_usr_space_api.c
@@ -0,0 +1,379 @@
+/*
+ * \file        efuse_usr_space_api.c
+ * \brief       support read/write user space using keyname mode
+ *              mapping keyname to offset by looking /efusekey in dtb
+ *
+ * \version     1.0.0
+ * \date        15/07/14
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <linux/ctype.h>
+#include <amlogic/asm/efuse.h>
+#include <linux/libfdt.h>
+
+#define EFUSE_DBG(fmt...)   //printf("[EFUSE_DBG]"fmt)
+#define EFUSE_MSG(fmt...)   printf("[EFUSE_MSG]"fmt)
+#define EFUSE_ERR(fmt...)   printf("[EFUSE_ERR]f(%s)L%d:", __func__, __LINE__),printf(fmt)
+
+struct efusekey_info{
+	char keyname[32];
+	unsigned offset;
+	unsigned size;
+};
+
+static struct _efuseCfgInf{
+    unsigned                initMaigc;//magic to indicate whether inited
+    unsigned                totalCfgKeyNums;
+    struct efusekey_info *  pKeyInf;
+}
+_efuseKeyInfos = {.totalCfgKeyNums = 0, .pKeyInf = NULL};
+
+int efuse_usr_api_init_dtb(const char*  dt_addr)
+{
+	int nodeoffset, poffset = 0;
+	char propname[32];
+	const void* phandle;
+	int ret;
+	int index;
+	uint32_t max_size;
+    unsigned efusekeynum = 0;
+    struct efusekey_info * efusekey_infos = NULL;
+
+	ret = fdt_check_header(dt_addr);
+	if (ret < 0) {
+		EFUSE_ERR("fdt check failed [%s]\n", fdt_strerror(ret));
+        return __LINE__;
+    }
+    _efuseKeyInfos.initMaigc = 0;
+
+	nodeoffset = fdt_path_offset(dt_addr, "/efusekey");
+	if (nodeoffset < 0) {
+		EFUSE_ERR("not find /efusekey node [%s].\n", fdt_strerror(nodeoffset));
+        return __LINE__;
+    }
+
+	phandle = fdt_getprop(dt_addr, nodeoffset, "keynum", NULL);
+	efusekeynum = be32_to_cpup((u32 *)phandle);
+	EFUSE_MSG("keynum is %x\n", efusekeynum);
+
+    if (efusekey_infos) free(efusekey_infos) ;
+    efusekey_infos = (struct efusekey_info *)malloc(sizeof (struct efusekey_info) *efusekeynum);
+    if (!efusekey_infos) {
+        EFUSE_ERR("malloc err\n");
+        return __LINE__;
+    }
+
+	max_size = efuse_get_max();
+
+	for (index = 0; index < efusekeynum; index++)
+    {
+        struct efusekey_info* theKeyInf = efusekey_infos + index;
+		sprintf(propname, "key%d", index);
+		/* printf("%s: propname: %s\n",__func__,propname); */
+		phandle = fdt_getprop(dt_addr, nodeoffset, propname, NULL);
+		if (!phandle) {
+			EFUSE_ERR("don't find  match %s\n", propname);
+			goto err;
+		}
+        poffset = fdt_node_offset_by_phandle(dt_addr,
+                be32_to_cpup((u32 *)phandle));
+        if (!poffset) {
+            EFUSE_ERR("can't find device node for key[%s]\n", propname);
+            goto err;
+        }
+
+
+		phandle = fdt_getprop(dt_addr, poffset, "keyname", NULL);
+        if (!phandle) {
+            EFUSE_ERR("Can't find keyname for key[%d]\n", index);
+            goto err;
+        }
+		strcpy(theKeyInf->keyname, phandle);
+
+		phandle = fdt_getprop(dt_addr, poffset, "offset", NULL);
+        if (!phandle) {
+            EFUSE_ERR("Can't find offset for key[%s]\n", theKeyInf->keyname);
+            goto err;
+        }
+		theKeyInf->offset = be32_to_cpup((u32 *)phandle);
+
+		phandle = fdt_getprop(dt_addr, poffset, "size", NULL);
+        if (!phandle) {
+            EFUSE_ERR("Can't find size for key[%s]\n", theKeyInf->keyname);
+            goto err;
+        }
+		theKeyInf->size = be32_to_cpup((u32 *)phandle);
+
+		EFUSE_DBG("key[%02d] name=%12s, offset=0x%04x, size=0x%04x\n",
+                index, theKeyInf->keyname, theKeyInf->offset, theKeyInf->size);
+        if (theKeyInf->offset + theKeyInf->size > max_size) {
+            EFUSE_ERR("\n offset (0x%x) + size (0x%x) > max [0x%x]!\n", theKeyInf->offset, theKeyInf->size, max_size);
+            return __LINE__;
+        }
+	}
+
+    _efuseKeyInfos.totalCfgKeyNums = efusekeynum;
+    _efuseKeyInfos.pKeyInf         = efusekey_infos;
+    EFUSE_DBG("%s success!\n", __func__);
+    _efuseKeyInfos.initMaigc = 0xee;
+	return 0;
+
+err:
+	free(efusekey_infos);
+	EFUSE_ERR("%s error!\n", __func__);
+	return -1;
+}
+
+static int _get_cfg_key_inf_byname(const char* keyname, const struct efusekey_info ** pKeyInf)
+{
+    int index = 0;
+    struct efusekey_info* theKeyInf = _efuseKeyInfos.pKeyInf;
+    int ret = 0;
+
+    if (0xee != _efuseKeyInfos.initMaigc) {
+        EFUSE_ERR("Pls init first.\n");
+        return __LINE__;
+    }
+    for (; index < _efuseKeyInfos.totalCfgKeyNums; ++index, ++theKeyInf)
+    {
+        const char* theKeyname = theKeyInf->keyname;
+        ret = strcmp(theKeyname, keyname);
+        if (ret) continue;
+
+        *pKeyInf = theKeyInf;
+        return 0;
+    }
+
+    EFUSE_ERR("efuse keyname(%s) not configured\n", keyname);
+    return __LINE__;//Not found the matched name
+}
+
+int efuse_usr_api_get_cfg_key_size(const char* keyname, unsigned* pSz)
+{
+    int ret = 0;
+    const struct efusekey_info* theCfgKeyInf = NULL;
+
+    ret = _get_cfg_key_inf_byname(keyname, &theCfgKeyInf);
+    if (ret) {
+        EFUSE_ERR("not name cfg in dts.\n");
+        return __LINE__;
+    }
+
+    *pSz = theCfgKeyInf->size;
+    return 0;
+}
+
+int efuse_usr_api_write_key(const char* keyname, const void* keydata, const unsigned dataSz)
+{
+    int ret = 0;
+    const struct efusekey_info* theCfgKeyInf = NULL;
+
+    ret = _get_cfg_key_inf_byname(keyname, &theCfgKeyInf);
+    if (ret) {
+        EFUSE_ERR("not name cfg in dts.\n");
+        return __LINE__;
+    }
+    if (dataSz != theCfgKeyInf->size) {
+        EFUSE_ERR("dataSz 0x%x != cfg size 0x%x\n", dataSz, theCfgKeyInf->size);
+        return __LINE__;
+    }
+
+    ret = efuse_write_usr((char*)keydata, theCfgKeyInf->size, (loff_t*)&theCfgKeyInf->offset);
+    if (ret < 0) {
+        EFUSE_ERR("error: efuse write fail.\n");
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+//usrefuse read mac $loadaddr (size)
+int efuse_usr_api_read_key(const char* keyname, void* databuf, const unsigned bufSz)
+{
+    int ret = 0;
+    const struct efusekey_info* theCfgKeyInf = NULL;
+    loff_t offset = 0;
+
+    ret = _get_cfg_key_inf_byname(keyname, &theCfgKeyInf);
+    if (ret) {
+        EFUSE_ERR("not name cfg in dts.\n");
+        return __LINE__;
+    }
+    const unsigned cfgCnt = theCfgKeyInf->size;
+    if (cfgCnt > bufSz && bufSz) {
+        EFUSE_ERR("cfg size 0x%x > bufsz 0x%x\n", cfgCnt, bufSz);
+        return __LINE__;
+    }
+    EFUSE_DBG("keyname=%s, databuf=%p, bufSz=%d, cfgCnt=%u\n", keyname, databuf, bufSz, cfgCnt);
+
+    offset = theCfgKeyInf->offset;
+    memset(databuf, cfgCnt, 0);
+    ret = efuse_read_usr((char*)databuf, cfgCnt, &offset);
+    if (ret == -1) {
+        EFUSE_ERR("ERROR: efuse read user data fail!, size=%u, offset=%llu\n", cfgCnt, offset);
+        return __LINE__;
+    }
+
+    if (ret != cfgCnt) {
+        EFUSE_ERR("ERROR: read %d byte(s) not wanted %d byte(s) data\n", ret, cfgCnt);
+        return __LINE__;
+    }
+
+    return 0;
+}
+
+static int hex_ascii_to_buf(const char* input, uint8_t* buf, const unsigned bufSz)
+{
+    int ret = 0;
+    const char* tmpStr = input;
+    const unsigned inputLen = strlen(input);
+    int i = 0;
+
+    if (!inputLen) {
+        EFUSE_ERR("err input len 0\n");
+        return __LINE__;
+    }
+    if ( ((inputLen>>1)<<1) != inputLen ) {
+        EFUSE_ERR("inputLen %d not even\n", inputLen);
+        return __LINE__;
+    }
+    if (bufSz * 2 > inputLen) {
+        EFUSE_ERR("bufSz %d not enough\n", bufSz);
+        return __LINE__;
+    }
+    for (tmpStr = input; *tmpStr; ++tmpStr)
+    {
+        char c = *tmpStr;
+        ret = isxdigit(c);
+        if (!ret) {
+            EFUSE_ERR("input(%s) contain non xdigit, c=%c\n", input, c);
+            return __LINE__;
+        }
+    }
+
+    for (i = 0; i < inputLen; i += 2)
+    {
+        char tmpByte[8];
+        tmpByte[2] = '\0';
+        tmpByte[0] = input[i];
+        tmpByte[1] = input[i + 1];
+
+        const unsigned val = simple_strtoul(tmpByte, NULL, 16);
+        if (val > 0xff) {
+            EFUSE_ERR("Exception: val 0x%x > 0xff\n", val);
+            return __LINE__;
+        }
+        buf[i>>1] = val;
+    }
+
+    return 0;
+}
+
+static int do_usr_efuse_api(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0;
+    const char* subcmd = argv[1];
+    if (argc < 2) return CMD_RET_USAGE;
+
+    if (!strcmp("init", subcmd))
+    {
+        const char* dtbLoadAddr = NULL;
+        if (argc > 2)
+        {
+            dtbLoadAddr = (char*)simple_strtoul(argv[2], NULL, 0);
+        }
+        else
+        {
+            dtbLoadAddr = env_get("dtb_mem_addr");
+            if (!dtbLoadAddr) {
+                env_set("dtb_mem_addr", simple_itoa(CONFIG_SYS_SDRAM_BASE + (16U<<20)));
+            }
+            dtbLoadAddr = (char*)simple_strtoul(dtbLoadAddr, NULL, 0);
+        }
+        ret = efuse_usr_api_init_dtb(dtbLoadAddr);
+    }
+    else if(!strcmp("size", subcmd))
+    {
+        const char* keyname = argv[2];
+        unsigned keysize = argc > 3 ? simple_strtoul(argv[3], NULL, 0) : 0;
+
+        ret = efuse_usr_api_get_cfg_key_size(keyname, &keysize);
+        EFUSE_MSG("keysize=%d\n", keysize);
+    }
+    else if(!strcmp("read", subcmd))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+        const char* keyname = argv[2];
+        char* databuf = (char*)simple_strtoul(argv[3], NULL, 16);
+        unsigned bufSz = argc > 4 ? simple_strtoul(argv[4], NULL, 0) : 0;
+
+        if (!bufSz)
+        {
+            ret =  efuse_usr_api_get_cfg_key_size(keyname, &bufSz);
+            if (ret) {
+                EFUSE_ERR("Fail in get sz for key[%s]\n", keyname);
+                return __LINE__;
+            }
+        }
+
+        ret = efuse_usr_api_read_key(keyname, databuf, bufSz);
+        if (!ret)
+        {
+            int i = 0;
+            printf("efuse read data");
+            for (i = 0; i < bufSz; i++) {
+                if (i%8 == 0) printf("\n[0x%02x]:", i);
+                printf("%02x ", databuf[i]);
+            }
+            printf("\n");
+        }
+    }
+    else if(!strcmp("write", subcmd))
+    {
+        if (argc < 4) return CMD_RET_USAGE;
+        const char* keyname = argv[2];
+        char* keydata = (char*)simple_strtoul(argv[3], NULL, 16);
+        unsigned bufSz = argc > 4 ? simple_strtoul(argv[4], NULL, 0) : 0;
+        uint8_t* tmpBuf = NULL;
+
+        if (!bufSz)
+        {
+            const char* input = argv[3];
+            bufSz = ( strlen(input) >> 1 );
+            tmpBuf = malloc(bufSz);
+
+            ret = hex_ascii_to_buf(input, tmpBuf, bufSz);
+            if (ret) {
+                EFUSE_ERR("Failed in change hex ascii to buf\n");
+                return __LINE__;
+            }
+            keydata = (char*)tmpBuf;
+        }
+        ret = efuse_usr_api_write_key(keyname, keydata, bufSz);
+        if (tmpBuf) free(tmpBuf) ;
+    }
+
+    return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	efuse_user,
+    5,  //max argc
+    1,	//repeatable
+    do_usr_efuse_api,
+	"efuse user space read write ops",
+	"init <dtbAddr>  --- init efuse user space\n"
+	"size keyname <addr>  --- get key size configured in dts\n"
+	"read keyname addr <size> --- read key value to mem addr \n"
+	"write --- write key value\n"
+	"       efuse_user write keyname hexstring --- write key value in hex string\n"
+	"       efuse_user write keyname addr size --- write key value, U need load you key value into mem addr first\n"
+);
+
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 9627509302..e15653b3f3 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -4,7 +4,10 @@
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 
 obj-y += mmc.o
+obj-y += mmc_aml.o
 obj-$(CONFIG_$(SPL_)DM_MMC) += mmc-uclass.o
+obj-$(CONFIG_CMD_MMC) += storage_emmc.o
+obj-$(CONFIG_MMC_MESON_GX) += aml_emmc_partition.o
 
 ifdef CONFIG_$(SPL_TPL_)DM_MMC
 obj-$(CONFIG_$(SPL_TPL_)BOOTSTD) += mmc_bootdev.o
diff --git a/drivers/mmc/aml_emmc_partition.c b/drivers/mmc/aml_emmc_partition.c
new file mode 100644
index 0000000000..d27419db95
--- /dev/null
+++ b/drivers/mmc/aml_emmc_partition.c
@@ -0,0 +1,1715 @@
+/*
+ * Copyright 2016, Amlogic Inc
+ * yonghui.yu
+ *
+ * Based vaguely on the Linux code
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <mmc.h>
+#include <part.h>
+#include <memalign.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <div64.h>
+#include "mmc_private.h"
+#include <amlstorage/emmc_partitions.h>
+#include <amlogic/cpu_id.h>
+#include <part_efi.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+/* using mbr*/
+#define CONFIG_PTBL_MBR	(1)
+#if (CONFIG_PTBL_MBR)
+	/* cmpare partition name? */
+	#define CONFIG_CMP_PARTNAME	(0)
+	/* cmpare partition mask */
+	#define CONFIG_CMP_PARTMASK	(0)
+#else
+	#define CONFIG_CMP_PARTNAME	(1)
+	#define CONFIG_CMP_PARTMASK	(1)
+#endif
+/* debug info*/
+#define CONFIG_MPT_DEBUG 	(0)
+#define GPT_PRIORITY             (1)
+
+#define apt_err(fmt, ...) printf( "%s()-%d: " fmt , \
+                  __func__, __LINE__, ##__VA_ARGS__)
+
+#define apt_wrn(fmt, ...) printf( "%s()-%d: " fmt , \
+                  __func__, __LINE__, ##__VA_ARGS__)
+#if (CONFIG_MPT_DEBUG)
+/* for detail debug info */
+#define apt_info(fmt, ...) printf( "%s()-%d: " fmt , \
+                  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define apt_info(fmt, ...)
+#endif
+
+/* creat MBR for emmc */
+#define MAX_PNAME_LEN 	(16)
+#define MAX_PART_COUNT	(32)
+
+/*
+  Global offset of reserved partition is 36MBytes
+  since MMC_BOOT_PARTITION_RESERVED is 32MBytes and
+  MMC_BOOT_DEVICE_SIZE is 4MBytes.
+  MMC_RESERVED_SIZE is 64MBytes for now.
+  layout detail inside reserved partition.
+  0x000000 - 0x003fff: partition table
+  0x004000 - 0x03ffff: storage key area	(16k offset & 256k size)
+  0x400000 - 0x47ffff: dtb area  (4M offset & 512k size)
+  0x480000 - 64MBytes: resv for other usage.
+  ...
+ */
+/*
+#define RSV_DTB_OFFSET_GLB	(SZ_1M*40)
+#define RSV_DTB_SIZE		(512*1024UL)
+#define RSV_PTBL_OFFSET		(SZ_1M*0)
+#define RSV_PTBL_SIZE		(16*1024UL)
+#define RSV_SKEY_OFFSET		(16*1024UL)
+#define RSV_SKEY_SIZE		(256*1024UL)
+#define RSV_DTB_OFFSET		(SZ_1M*4)
+*/
+
+/* virtual partitions which are in "reserved" */
+#define MAX_MMC_VIRTUAL_PART_CNT	(5)
+
+
+/* BinaryLayout of partition table stored in rsv area */
+struct ptbl_rsv {
+    char magic[4];				/* MPT */
+    unsigned char version[12];	/* binary version */
+    int count;	/* partition count in using */
+    int checksum;
+    struct partitions partitions[MAX_MMC_PART_NUM];
+};
+
+/* partition table for innor usage*/
+struct _iptbl {
+	struct partitions *partitions;
+	int count;	/* partition count in use */
+};
+
+unsigned device_boot_flag = 0xff;
+bool is_partition_checked = false;
+
+#ifndef CONFIG_AML_MMC_INHERENT_PART
+/* fixme, name should be changed as aml_inherent_ptbl */
+struct partitions emmc_partition_table[] = {
+#ifndef CONFIG_AML_GPT
+	PARTITION_ELEMENT(MMC_BOOT_NAME, MMC_BOOT_DEVICE_SIZE, 0),
+#endif
+	PARTITION_ELEMENT(MMC_RESERVED_NAME, MMC_RESERVED_SIZE, 0),
+	/* prior partitions, same partition name with dts*/
+	/* partition size will be overide by dts*/
+	PARTITION_ELEMENT(MMC_CACHE_NAME, 0, 0),
+	PARTITION_ELEMENT(MMC_ENV_NAME, MMC_ENV_SIZE, 0),
+};
+
+struct virtual_partition virtual_partition_table[] = {
+    /* partition for name idx, off & size will not be used! */
+#if (CONFIG_PTBL_MBR)
+    VIRTUAL_PARTITION_ELEMENT(MMC_MBR_NAME, MMC_MBR_OFFSET, MMC_MBR_SIZE),
+#endif
+    VIRTUAL_PARTITION_ELEMENT(MMC_BOOT_NAME0, 0, 0),
+    VIRTUAL_PARTITION_ELEMENT(MMC_BOOT_NAME1, 0, 0),
+
+    /* virtual partition in reserved partition, take care off and size */
+#ifdef CONFIG_AML_PARTITION
+	VIRTUAL_PARTITION_ELEMENT(MMC_TABLE_NAME, MMC_TABLE_OFFSET, MMC_TABLE_SIZE),
+#endif
+	VIRTUAL_PARTITION_ELEMENT(MMC_KEY_NAME, EMMCKEY_RESERVE_OFFSET, MMC_KEY_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_PATTERN_NAME, CALI_PATTERN_OFFSET, CALI_PATTERN_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_MAGIC_NAME, MAGIC_OFFSET, MAGIC_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_RANDOM_NAME, RANDOM_OFFSET, RANDOM_SIZE),
+#ifndef DTB_BIND_KERNEL
+	VIRTUAL_PARTITION_ELEMENT(MMC_DTB_NAME, DTB_OFFSET, DTB_SIZE),
+#endif
+	VIRTUAL_PARTITION_ELEMENT(MMC_FASTBOOT_CONTEXT_NAME,
+			FASTBOOT_CONTEXT_OFFSET, FASTBOOT_CONTEXT_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_DDR_PARAMETER_NAME,DDR_PARAMETER_OFFSET, DDR_PARAMETER_SIZE),
+};
+
+int get_emmc_partition_arraysize(void)
+{
+    return ARRAY_SIZE(emmc_partition_table);
+}
+
+int get_emmc_virtual_partition_arraysize(void)
+{
+    return ARRAY_SIZE(virtual_partition_table);
+}
+
+#endif
+
+void __attribute__((unused)) _dump_part_tbl(struct partitions *p, int count)
+{
+	int i = 0;
+	apt_info("count %d\n", count);
+	while (i < count) {
+		printf("%02d %10s %016llx %016llx\n", i, p[i].name, p[i].offset, p[i].size);
+		i++;
+	}
+	return;
+}
+
+static int _get_part_index_by_name(struct partitions *tbl,
+					   int cnt, const char *name)
+{
+	   int i=0;
+	   struct partitions *part = NULL;
+
+       while (i < cnt) {
+			   part = &tbl[i];
+               if (!strcmp(name, part->name)) {
+					   apt_info("find %s @ tbl[%d]\n", name, i);
+					   break;
+			   }
+			   i++;
+	   };
+       if (i == cnt) {
+			   i = -1;
+			   apt_wrn("do not find match in table %s\n", name);
+	   }
+	   return i;
+}
+
+
+
+static struct partitions *_find_partition_by_name(struct partitions *tbl,
+			int cnt, const char *name)
+{
+	int i = 0;
+	struct partitions *part = NULL;
+
+	while (i < cnt) {
+
+		part = &tbl[i];
+		if (!strcmp(name, part->name)) {
+			apt_info("find %s @ tbl[%d]\n", name, i);
+			break;
+		}
+		i++;
+	};
+	if (i == cnt) {
+		part = NULL;
+		apt_wrn("do not find match in table %s\n", name);
+	}
+	return part;
+}
+
+/* fixme, must called after offset was calculated. */
+static ulong _get_inherent_offset(const char *name)
+{
+	struct partitions *part;
+
+	part = _find_partition_by_name(emmc_partition_table,
+			get_emmc_partition_arraysize(), name);
+	if (NULL == part)
+		return -1;
+	else
+		return part->offset;
+}
+/* partition table (Emmc Partition Table) */
+struct _iptbl *p_iptbl_ept = NULL;
+
+/* trans byte into lba manner for rsv area read/write */
+#ifdef CONFIG_AML_PARTITION
+static ulong _mmc_rsv_read(struct mmc *mmc, ulong offset, ulong size, void * buffer)
+{
+	lbaint_t _blk, _cnt;
+	if (0 == size)
+		return 0;
+
+	_blk = offset / mmc->read_bl_len;
+	_cnt = size / mmc->read_bl_len;
+	_cnt = blk_dread(mmc_get_blk_desc(mmc), _blk, _cnt, buffer);
+
+	return (ulong)(_cnt * mmc->read_bl_len);
+}
+
+static ulong _mmc_rsv_write(struct mmc *mmc, ulong offset, ulong size, void * buffer)
+{
+	lbaint_t _blk, _cnt;
+	if (0 == size)
+		return 0;
+
+	_blk = offset / mmc->read_bl_len;
+	_cnt = size / mmc->read_bl_len;
+	_cnt = blk_dwrite(mmc_get_blk_desc(mmc), _blk, _cnt, buffer);
+
+	return (ulong)(_cnt * mmc->read_bl_len);
+}
+#endif
+
+
+static struct partitions * get_ptbl_from_dtb(struct mmc *mmc)
+{
+	struct partitions * ptbl = NULL;
+#ifdef CONFIG_AML_PARTITION
+#ifndef DTB_BIND_KERNEL
+	unsigned char * buffer = NULL;
+	ulong ret, offset;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+
+	/* try get dtb table from ddr, which may exsit while usb burning */
+	if (NULL == get_partitions()) {
+		/* if failed, try rsv dtb area then. */
+		buffer = malloc(vpart->size * DTB_COPIES);
+		if (NULL == buffer) {
+			apt_err("Can not alloc enough buffer\n");
+			goto _err;
+		}
+		offset = _get_inherent_offset(MMC_RESERVED_NAME) + vpart->offset;
+		ret = _mmc_rsv_read(mmc, offset, (vpart->size * DTB_COPIES), buffer);
+		if (ret != (vpart->size * DTB_COPIES)) {
+			apt_err("Can not alloc enough buffer\n");
+			goto _err1;
+		}
+		/* parse it */
+		if (get_partition_from_dts(buffer)) {
+			apt_err("get partition table from dts failed. try from internal dts\n");
+			if (buffer)
+				free(buffer);
+			buffer = (char*) env_get_ulong("fdtcontroladdr", 16, CONFIG_SYS_SDRAM_BASE + (16U<<20));
+			if (get_partition_from_dts(buffer)) {
+				apt_err("get partition table from internal dts failed.\n");
+				goto _err;
+			}
+			buffer = NULL;
+		}
+		/* double check part_table(glb) */
+		if (NULL == get_partitions()) {
+			goto _err1;
+		}
+		apt_info("get partition table from dts successfully\n");
+
+		if (buffer)
+			free(buffer);
+		buffer = NULL;
+	}
+#endif
+#endif
+	/* asign partition info to *ptbl */
+	ptbl = get_partitions();
+	return ptbl;
+#ifdef CONFIG_AML_PARTITION
+#ifndef DTB_BIND_KERNEL
+_err1:
+	if (buffer)
+		free(buffer);
+_err:
+	free (ptbl);
+	return NULL;
+#endif
+#endif
+}
+
+
+
+
+static struct partitions *is_prio_partition(struct _iptbl *list, struct partitions *part)
+{
+	int i;
+	struct partitions *plist = NULL;
+
+	if (list->count == 0)
+		goto _out;
+
+	apt_info("count %d\n", list->count);
+	for (i=0; i<list->count; i++) {
+		plist = &list->partitions[i];
+		apt_info("%d: %s, %s\n", i, part->name, plist->name);
+		if (!strcmp(plist->name, part->name)) {
+			apt_info("%s is prio in list[%d]\n", part->name, i);
+			break;
+		}
+	}
+	if (i == list->count)
+		plist = NULL;
+_out:
+	return plist;
+}
+
+/*  calculate offset of each partitions.
+	bottom is a flag for considering
+ */
+static int _calculate_offset(struct mmc *mmc, struct _iptbl *itbl, u32 bottom)
+{
+	int i;
+	struct partitions *part;
+	ulong  gap = PARTITION_RESERVED;
+	int ret = 0;
+
+	if (itbl->count <= 0)
+		return -1;
+	part = itbl->partitions;
+#if (CONFIG_MPT_DEBUG)
+	_dump_part_tbl(part, itbl->count);
+#endif
+
+#if CONFIG_AML_GPT
+	part->offset = RESERVED_GPT_OFFSET;
+#endif
+
+	if (!strcmp(part->name, "bootloader")) {
+		part->offset = 0;
+		gap = MMC_BOOT_PARTITION_RESERVED;
+	}
+	for (i=1; i<itbl->count; i++) {
+		/**/
+		part[i].offset = part[i-1].offset + part[i-1].size + gap;
+		/* check capicity overflow ?*/
+		if (((part[i].offset + part[i].size) > mmc->capacity) ||
+				(part[i].size == -1)) {
+			part[i].size = mmc->capacity - part[i].offset;
+			/* reserv space @ the bottom */
+			if (bottom && (part[i].size > MMC_BOTTOM_RSV_SIZE)) {
+				apt_info("reserv %d bytes at bottom\n", MMC_BOTTOM_RSV_SIZE);
+				part[i].size -= MMC_BOTTOM_RSV_SIZE;
+			}
+			break;
+		}
+		gap = PARTITION_RESERVED;
+	}
+	if (i < (itbl->count - 1)) {
+		apt_err("too large partition table for current emmc, overflow!\n");
+		ret = -1;
+	}
+#if (CONFIG_MPT_DEBUG)
+	_dump_part_tbl(part, itbl->count);
+#endif
+	return ret;
+}
+
+static void compose_ept(struct _iptbl *dtb, struct _iptbl *inh,
+			struct _iptbl *ept)
+{
+	int i;
+	struct partitions *partition = NULL;
+	struct partitions *dst, *src, *prio;
+
+	/* overide inh info by dts */
+	apt_info("dtb %p, inh %p, ept %p\n", dtb, inh, ept);
+	apt_info("ept->partitions %p\n", ept->partitions);
+	partition = ept->partitions;
+	apt_info("partition %p\n", partition);
+	for (i=0; i<MAX_PART_COUNT; i++) {
+		apt_info("i %d, ept->count %d\n", i, ept->count);
+		dst = &partition[ept->count];
+		src = (i < inh->count) ? &inh->partitions[i]:&dtb->partitions[i-inh->count];
+
+		prio = is_prio_partition(ept, src);
+		if (prio) {
+			/* overide prio partition by new */
+			apt_info("override %d: %s\n", ept->count, prio->name);
+			//*prio = *src;
+			dst = prio;
+		} else
+			ept->count ++;
+		*dst = *src;
+		if (-1 == src->size) {
+			apt_info("break! %s\n", src->name);
+			break;
+		}
+	}
+
+	return;
+}
+#ifdef CONFIG_AML_PARTITION
+static int _get_version(unsigned char * s)
+{
+	int version = 0;
+	if (!strncmp((char *)s, MMC_MPT_VERSION_2, sizeof(MMC_MPT_VERSION_2)))
+		version = 2;
+	else if (!strncmp((char *)s, MMC_MPT_VERSION_1, sizeof(MMC_MPT_VERSION_1)))
+		version = 1;
+	else
+		version = -1;
+
+	return version;
+}
+
+/*  calc checksum.
+	there's a bug on v1 which did not calculate all the partitios.
+ */
+static int _calc_iptbl_check_v2(struct partitions * part, int count)
+{
+	int ret = 0, i;
+	int size = count * sizeof(struct partitions) >> 2;
+	int *buf = (int *)part;
+
+	for (i = 0; i < size; i++)
+		ret +=buf[i];
+
+	return ret;
+}
+
+static int _calc_iptbl_check_v1(struct partitions *part, int count)
+{
+    int i, j;
+	u32 checksum = 0, *p;
+
+	for (i = 0; i < count; i++) {
+		p = (u32*)part;
+		/*BUG here, do not fix it!!*/
+		for (j = sizeof(struct partitions)/sizeof(checksum); j > 0; j--) {
+			checksum += *p;
+			p++;
+	    }
+    }
+
+	return checksum;
+}
+
+static int _calc_iptbl_check(struct partitions * part, int count, int version)
+{
+	if (1 == version)
+		return _calc_iptbl_check_v1(part, count);
+	else if (2 == version)
+		return _calc_iptbl_check_v2(part, count);
+	else
+		return -1;
+}
+
+/* ept is malloced out side */
+static int _cpy_iptbl(struct _iptbl * dst, struct _iptbl * src)
+{
+	int ret = 0;
+	if (!dst || !src) {
+		apt_err("invalid arg %s\n", !dst ? "dst" : "src");
+		ret = -1;
+		goto _out;
+	}
+	if (!dst->partitions || !src->partitions) {
+		apt_err("invalid arg %s->partitions\n", !dst ? "dst" : "src");
+		ret = -2;
+		goto _out;
+	}
+
+	dst->count = src->count;
+	memcpy(dst->partitions, src->partitions, sizeof(struct partitions) * src->count);
+
+_out:
+	return ret;
+}
+
+
+/* get ptbl from rsv area from emmc */
+static int get_ptbl_rsv(struct mmc *mmc, struct _iptbl *rsv)
+{
+	struct ptbl_rsv * ptbl_rsv = NULL;
+	uchar * buffer = NULL;
+	ulong size, offset;
+	int checksum, version, ret = 0;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_TABLE_NAME);
+
+	size = (sizeof(struct ptbl_rsv) + 511) / 512 * 512;
+	if (vpart->size < size) {
+		apt_err("too much partitons\n");
+		ret = -1;
+		goto _out;
+	}
+	buffer = malloc(size);
+	if (NULL == buffer) {
+		apt_err("no enough memory for ptbl rsv\n");
+		ret = -2;
+		goto _out;
+	}
+	/* read it from emmc. */
+	offset = _get_inherent_offset(MMC_RESERVED_NAME) + vpart->offset;
+	if (size != _mmc_rsv_read(mmc, offset, size, buffer)) {
+		apt_err("read ptbl from rsv failed\n");
+		ret = -3;
+		goto _out;
+	}
+
+	ptbl_rsv = (struct ptbl_rsv *) buffer;
+	apt_info("magic %3.3s, version %8.8s, checksum %x\n", ptbl_rsv->magic,
+			ptbl_rsv->version, ptbl_rsv->checksum);
+	/* fixme, check magic ?*/
+	if (strncmp(ptbl_rsv->magic, MMC_PARTITIONS_MAGIC, sizeof(MMC_PARTITIONS_MAGIC))) {
+		apt_err("magic faild %s, %3.3s\n", MMC_PARTITIONS_MAGIC, ptbl_rsv->magic);
+		ret = -4;
+		goto _out;
+	}
+	/* check version*/
+	version = _get_version(ptbl_rsv->version);
+	if (version < 0) {
+		apt_err("version faild %s, %3.3s\n", MMC_PARTITIONS_MAGIC, ptbl_rsv->magic);
+		ret = -5;
+		goto _out;
+	}
+	if (ptbl_rsv->count > MAX_MMC_PART_NUM) {
+		apt_err("invalid partition count %d\n", ptbl_rsv->count);
+		ret = -1;
+		goto _out;
+	}
+	/* check sum */
+	checksum = _calc_iptbl_check(ptbl_rsv->partitions, ptbl_rsv->count, version);
+	if (checksum != ptbl_rsv->checksum) {
+		apt_err("checksum faild 0x%x, 0x%x\n", ptbl_rsv->checksum, checksum);
+		ret = -6;
+		goto _out;
+	}
+
+	rsv->count = ptbl_rsv->count;
+	memcpy(rsv->partitions, ptbl_rsv->partitions, rsv->count * sizeof(struct partitions));
+
+_out:
+	if (buffer)
+		free (buffer);
+	return ret;
+}
+
+
+/* update partition tables from src
+	if success, return 0;
+	else, return 1
+	*/
+static int update_ptbl_rsv(struct mmc *mmc, struct _iptbl *src)
+{
+	struct ptbl_rsv *ptbl_rsv = NULL;
+	uchar *buffer;
+	ulong size, offset;
+	int ret = 0, version;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_TABLE_NAME);
+
+	size = (sizeof(struct ptbl_rsv) + 511) / 512 * 512;
+	buffer = malloc(size);
+	if (NULL == buffer) {
+		apt_err("no enough memory for ptbl rsv\n");
+		return -1;
+	}
+	memset(buffer, 0 , size);
+	/* version, magic and checksum */
+	ptbl_rsv = (struct ptbl_rsv *) buffer;
+	strcpy((char *)ptbl_rsv->version, MMC_MPT_VERSION);
+	strcpy(ptbl_rsv->magic, MMC_PARTITIONS_MAGIC);
+	if (src->count > MAX_MMC_PART_NUM) {
+		apt_err("too much partitions\n");
+		ret = -1;
+		goto _err;
+	}
+	ptbl_rsv->count = src->count;
+	memcpy(ptbl_rsv->partitions, src->partitions,
+		sizeof(struct partitions)*src->count);
+	version = _get_version(ptbl_rsv->version);
+	ptbl_rsv->checksum = _calc_iptbl_check(src->partitions, src->count, version);
+	/* write it to emmc. */
+	apt_info("magic %3.3s, version %8.8s, checksum %x\n", ptbl_rsv->magic, ptbl_rsv->version, ptbl_rsv->checksum);
+	offset = _get_inherent_offset(MMC_RESERVED_NAME) + vpart->offset;
+	if (_mmc_rsv_write(mmc, offset, size, buffer) != size) {
+		apt_err("write ptbl to rsv failed\n");
+		ret = -1;
+		goto _err;
+	}
+_err:
+	free (buffer);
+	return ret;
+}
+
+static void _free_iptbl(struct _iptbl *iptbl)
+{
+	if (iptbl && iptbl->partitions) {
+		free(iptbl->partitions);
+		iptbl->partitions = NULL;
+	}
+	if (iptbl) {
+		free(iptbl);
+		iptbl = NULL;
+	}
+
+	return;
+}
+
+#endif
+static int _cmp_partition(struct partitions *dst, struct partitions *src, int overide)
+{
+	int ret = 0;
+#if (CONFIG_CMP_PARTNAME)
+	if (strncmp(dst->name, src->name, sizeof(src->name)))
+		ret = -2;
+#endif
+	if (dst->size != src->size)
+		ret = -3;
+	if (dst->offset != src->offset)
+		ret = -4;
+#if (CONFIG_CMP_PARTMASK)
+	if (dst->mask_flags != src->mask_flags)
+		ret = -5;
+#endif
+
+	if (ret && (!overide)) {
+		apt_err("name: %10.10s<->%10.10s\n", dst->name, src->name);
+		apt_err("size: %llx<->%llx\n", dst->size, src->size);
+		apt_err("offset: %llx<->%llx\n", dst->offset, src->offset);
+		apt_err("mask: %08x<->%08x\n", dst->mask_flags, src->mask_flags);
+	}
+
+	if (overide) {
+		*dst = *src;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* compare partition tables
+	if same, do nothing then return 0;
+	else, print the diff ones and return -x
+	-1:count
+	-2:name
+	-3:size
+	-4:offset
+	*/
+static int _cmp_iptbl(struct _iptbl * dst, struct _iptbl * src)
+{
+	int ret = 0, i = 0;
+	struct partitions *dstp;
+	struct partitions *srcp;
+
+	if (dst->count != src->count) {
+		apt_err("partition count is not same %d:%d\n", dst->count, src->count);
+		ret = -1;
+		goto _out;
+	}
+
+	while (i < dst->count) {
+		dstp = &dst->partitions[i];
+		srcp = &src->partitions[i];
+		ret = _cmp_partition(dstp, srcp, 0);
+		if (ret) {
+			apt_err("partition %d has changed\n", i);
+			break;
+		}
+		i++;
+	}
+
+_out:
+	return ret;
+}
+
+
+/* iptbl buffer opt. */
+static int _zalloc_iptbl(struct _iptbl **_iptbl)
+{
+	int ret = 0;
+	struct _iptbl *iptbl;
+	struct partitions *partition = NULL;
+
+	partition = malloc(sizeof(struct partitions)*MAX_PART_COUNT);
+	if (NULL == partition) {
+		ret = -1;
+		apt_err("no enough memory for partitions\n");
+		goto _out;
+	}
+
+	iptbl = malloc(sizeof(struct _iptbl));
+	if (NULL == iptbl) {
+		ret = -2;
+		apt_err("no enough memory for ept\n");
+		free(partition);
+		goto _out;
+	}
+	memset(partition, 0, sizeof(struct partitions)*MAX_PART_COUNT);
+	memset(iptbl, 0, sizeof(struct _iptbl));
+
+	iptbl->partitions = partition;
+	apt_info("iptbl %p, partition %p, iptbl->partitions %p\n",
+		iptbl, partition, iptbl->partitions);
+	*_iptbl = iptbl;
+_out:
+	return ret;
+}
+
+
+/*
+ * fixme, need check space size later.
+ */
+
+static inline int le32_to_int(unsigned char *le32)
+{
+	return ((le32[3] << 24) +
+	    (le32[2] << 16) +
+	    (le32[1] << 8) +
+	     le32[0]
+	   );
+}
+
+static int test_block_type(unsigned char *buffer)
+{
+	int slot;
+	struct dos_partition *p;
+
+	if ((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
+	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
+		return (-1);
+	} /* no DOS Signature at all */
+	p = (struct dos_partition *)&buffer[DOS_PART_TBL_OFFSET];
+	for (slot = 0; slot < 3; slot++) {
+		if (p->boot_ind != 0 && p->boot_ind != 0x80) {
+			if (!slot &&
+			    (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],
+				     "FAT", 3) == 0 ||
+			     strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],
+				     "FAT32", 5) == 0)) {
+				return DOS_PBR; /* is PBR */
+			} else {
+				return -1;
+			}
+		}
+	}
+	return DOS_MBR;	    /* Is MBR */
+}
+
+//DOS_MBR OR DOS_PBR
+/*
+ * re-constructe iptbl from mbr&ebr infos.
+ * memory for  iptbl_mbr must be alloced outside.
+ *
+ */
+static void _construct_ptbl_by_mbr(struct mmc *mmc, struct _iptbl *iptbl_mbr)
+{
+	int ret,i;
+	int flag = 0;
+	lbaint_t read_offset = 0;
+	int part_num = 0;
+	int primary_num = 0;
+	uint64_t logic_start = 0;
+	uint64_t externed_start = 0;
+	struct dos_partition *pt;
+	struct partitions *partitions = iptbl_mbr->partitions;
+
+	apt_info("aml MBR&EBR debug...\n");
+	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, 512);
+	for (;;) {
+		apt_info("**%02d: read_offset %016llx\n", part_num, (uint64_t)read_offset<<9);
+		ret = blk_dread(mmc_get_blk_desc(mmc), read_offset, 1, buffer);
+		if (read_offset == 0)
+			flag = 1;
+		else
+			flag = 0;
+		/* debug code */
+		// print_buffer(0,buffer,1,512,16);
+		if (ret != 1) {
+			apt_err("ret %d fail to read current ebr&mbr from emmc! \n", ret);
+			break;
+		}
+		ret = test_block_type(buffer);
+		if (ret != 0 && ret != 1) {
+			apt_err("invalid magic value: 0x%02x%02x\n",
+				buffer[DOS_PART_MAGIC_OFFSET], buffer[DOS_PART_MAGIC_OFFSET + 1]);
+			break;
+		}
+
+		pt = (dos_partition_t *)(&buffer[0] + DOS_PART_TBL_OFFSET);
+		for (i = 0; i < 4; i++, pt++) {
+			if ( (pt->boot_ind == 0x00 || pt->boot_ind == 0x80) && pt->sys_ind == 0x83 ) {
+				//emmc_partition[part_num]->name = NULL;
+				partitions[part_num].offset = ((uint64_t)(le32_to_int(pt->start4)+read_offset) << 9ULL);
+				partitions[part_num].size = (uint64_t)le32_to_int(pt->size4) << 9ULL;
+				partitions[part_num].mask_flags = pt->sys_ind;
+
+				apt_info("--partition[%d]: %016llx, %016llx, 0x%08x \n",
+					part_num, partitions[part_num].offset,
+					partitions[part_num].size,
+					le32_to_int(pt->size4));
+				part_num++;
+				if ( flag )
+					primary_num++;
+			}else{/* get the next externed partition info */
+				if ( pt->boot_ind == 0x00 && pt->sys_ind == 0x05) {
+					logic_start = (uint64_t)le32_to_int (pt->start4);
+					//logic_size = (uint64_t)le32_to_int (pt->size4);
+				}
+			}
+		}
+		/* mbr & ebr debug infos */
+		apt_info("******%02d: read_offset=%016llx, logic_start=%016llx\n",
+			part_num,(uint64_t)read_offset*512ULL,logic_start*512ULL);
+
+		if (part_num == primary_num) {
+			externed_start = logic_start;
+			read_offset = externed_start;
+		}else
+			read_offset = externed_start + logic_start;
+		if (logic_start == 0)
+			break;
+		logic_start = 0;
+
+	}
+	iptbl_mbr->count = part_num;
+	apt_info("iptbl_mbr->count = %d\n", iptbl_mbr->count);
+
+	return;
+}
+
+static int __attribute__((unused)) _check_ptbl_mbr(struct mmc *mmc, struct _iptbl *ept)
+{
+	int ret = 0;
+	/* re-constructed by mbr */
+	struct _iptbl *iptbl_mbr = NULL, *ept2 = NULL;
+	struct partitions *partitions = NULL;
+	int i,j;
+
+	iptbl_mbr = malloc(sizeof(struct _iptbl));
+	if (NULL == iptbl_mbr) {
+		apt_err("no enough memory for iptbl_mbr\n");
+		return -1;
+	}
+	memset(iptbl_mbr , 0, sizeof(struct _iptbl));
+	partitions = (struct partitions *)malloc(sizeof(struct partitions) * DOS_PARTITION_COUNT);
+	if (NULL == partitions) {
+		apt_err("no enough memory for partitions\n");
+		free(iptbl_mbr);
+		return -1;
+	}
+	memset(partitions, 0, sizeof(struct partitions) * DOS_PARTITION_COUNT);
+	iptbl_mbr->partitions = partitions;
+
+	_construct_ptbl_by_mbr(mmc, iptbl_mbr);
+        if (iptbl_mbr->count > 0)
+	{
+		ret = 0;
+		goto _check_return;
+	}
+
+	ept2 = (struct _iptbl*) malloc(sizeof(struct _iptbl));
+	if (!ept2) 
+		return -1;
+
+	ept2 -> partitions = (struct partitions*) malloc (sizeof(struct partitions) * ept->count);
+	if (!ept2->partitions) 
+		return -1;
+	memset (ept2->partitions, 0, sizeof(struct partitions) * ept->count);
+	ept2 -> count = 0;
+
+	for (i=4,j=0;i<ept->count;i++)
+	{
+		apt_info("-!check partition name %s\n",ept->partitions[i].name);
+		memcpy(&ept2->partitions[j],&ept->partitions[i], sizeof(struct partitions));
+		j++;
+
+	}
+	ept2->count = j;
+
+	ret = _cmp_iptbl(iptbl_mbr, ept2);
+	if (ept2->partitions)
+		free (ept2->partitions);
+	if (ept2)
+		free (ept2);
+
+	if (partitions)
+		free(partitions);
+	if (iptbl_mbr)
+		free(iptbl_mbr);
+ _check_return:
+	apt_wrn("MBR is %s\n", ret?"Improper!":"OK!");
+	return ret;
+}
+
+/* construct a partition table entry of EBR */
+static int _construct_ebr_1st_entry(struct _iptbl *p_iptbl,struct dos_partition *p_ebr, int part_num )
+{
+	uint64_t start_offset = 0;
+	uint64_t logic_size = 0;
+
+	p_ebr->boot_ind = 0x00;
+	p_ebr->sys_ind = 0x83;
+	/* Starting = relative offset between this EBR sector and the first sector of the logical partition
+	* the gap between two partition is a fixed value of PARTITION_RESERVED ,otherwise the emmc partiton
+	* is different with reserved */
+	start_offset = PARTITION_RESERVED >> 9;
+	/* Number of sectors = total count of sectors for this logical partition */
+	// logic_size = (p_iptbl->partitions[part_num].size) >> 9ULL;
+	logic_size = lldiv(p_iptbl->partitions[part_num].size, 512);
+	apt_info("*** %02d: size 0x%016llx, logic_size 0x%016llx\n", part_num, p_iptbl->partitions[part_num].size, logic_size);
+	memcpy((unsigned char *)(p_ebr->start4), &start_offset, 4);
+	memcpy((unsigned char *)(p_ebr->size4), &logic_size, 4);
+	return 0;
+}
+
+static int _construct_ebr_2nd_entry(struct _iptbl *p_iptbl, struct dos_partition *p_ebr, int part_num)
+{
+	uint64_t start_offset = 0;
+	uint64_t logic_size = 0;
+
+	if ((part_num+2) > p_iptbl->count)
+		return 0;
+
+	p_ebr->boot_ind = 0x00;
+	p_ebr->sys_ind = 0x05;
+	/* Starting sector = LBA address of next EBR minus LBA address of extended partition's first EBR */
+	start_offset = (p_iptbl->partitions[part_num+1].offset - PARTITION_RESERVED -
+					(p_iptbl->partitions[3].offset - PARTITION_RESERVED)) >> 9;
+	/* total count of sectors for next logical partition, but count starts from the next EBR sector */
+	logic_size = (p_iptbl->partitions[part_num+1].size + PARTITION_RESERVED) >> 9;
+
+	memcpy((unsigned char *)(p_ebr->start4), &start_offset, 4);
+	memcpy((unsigned char *)(p_ebr->size4), &logic_size, 4);
+
+	return 0;
+}
+
+/* construct a partition table entry of MBR OR EBR */
+static int _construct_mbr_entry(struct _iptbl *p_iptbl, struct dos_partition *p_entry, int part_num)
+{
+	uint64_t start_offset = 0;
+	uint64_t primary_size = 0;
+	uint64_t externed_size = 0;
+	int i;
+	/* the entry is active or not */
+	if (part_num == 0 )
+		p_entry->boot_ind = 0x00;
+	else
+		p_entry->boot_ind = 0x00;
+
+	if (part_num == 3) {/* the logic partion entry */
+		/* the entry type */
+		p_entry->sys_ind = 0x05;
+		start_offset = (p_iptbl->partitions[3].offset - PARTITION_RESERVED) >> 9;
+		for ( i = 3;i< p_iptbl->count;i++)
+			externed_size = p_iptbl->partitions[i].size >> 9;
+
+		memcpy((unsigned char *)p_entry->start4, &start_offset, 4);
+		memcpy((unsigned char *)p_entry->size4, &externed_size, 4);
+	}else{/* the primary partion entry */
+		/* the entry type */
+		p_entry->sys_ind = 0x83;
+		start_offset = (p_iptbl->partitions[part_num].offset) >> 9;
+		primary_size = (p_iptbl->partitions[part_num].size)>>9;
+		memcpy((unsigned char *)p_entry->start4, &start_offset, 4);
+		memcpy((unsigned char *)p_entry->size4, &primary_size, 4);
+	}
+
+	return 0;
+}
+
+static int _construct_mbr_or_ebr(struct _iptbl *p_iptbl, struct dos_mbr_or_ebr *p_br,
+	int part_num, int type)
+{
+	int i;
+
+        apt_info("!!!++++ %0d(%0d) my count:%i\n",part_num, p_iptbl->count,p_iptbl->count<4?p_iptbl->count:4);
+	if (DOS_MBR == type) {
+		/* constuct a integral MBR */
+		for (i = 0; i< ((p_iptbl->count<4)?p_iptbl->count:4) ; i++)
+			_construct_mbr_entry(p_iptbl, &p_br->part_entry[i], i);
+
+	}else{
+		/* constuct a integral EBR */
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET] = 'F';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 1] = 'A';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 2] = 'T';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 3] = '3';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 4] = '2';
+
+		_construct_ebr_1st_entry(p_iptbl, &p_br->part_entry[0], part_num);
+		_construct_ebr_2nd_entry(p_iptbl, &p_br->part_entry[1], part_num);
+	}
+
+	p_br->magic[0] = 0x55 ;
+	p_br->magic[1] = 0xAA ;
+	return 0;
+}
+
+static __attribute__((unused)) int _update_ptbl_mbr(struct mmc *mmc, struct _iptbl *p_iptbl)
+{
+	int ret = 0, start_blk = 0, blk_cnt = 1;
+	unsigned char *src;
+	int i,j;
+	struct dos_mbr_or_ebr *mbr;
+	struct _iptbl *ptb ;
+	struct _iptbl *ptb2;
+
+	ptb = p_iptbl;
+	ptb2 = (struct _iptbl*) malloc(sizeof(struct _iptbl));
+
+	ptb2 -> partitions = (struct partitions*) malloc (sizeof(struct partitions) * ptb->count);
+	memset (ptb2->partitions, 0, sizeof(struct partitions) * ptb->count);
+	ptb2 -> count = 0;
+
+	for (i=4,j=0;i<ptb->count;i++)
+	{
+		apt_info("-!check partition name %s\n",ptb->partitions[i].name);
+		memcpy(&ptb2->partitions[j],&ptb->partitions[i], sizeof(struct partitions));
+		j++;
+
+	}
+	ptb2->count = j;
+	ptb = ptb2;
+
+	mbr = malloc(sizeof(struct dos_mbr_or_ebr));
+
+	for (i=0;i<ptb->count;i++) {
+		apt_info("-update MBR-: partition[%02d]: %016llx - %016llx skipped:%s name:%s parts count:%02d\n",i,
+			ptb->partitions[i].offset, ptb->partitions[i].size, ptb->partitions[i].size==0? "yes" :"no", ptb->partitions[i].name, ptb->count);
+	}
+
+	for (i = 0;i < ptb->count;) {
+		apt_info("!!!!--- update_ptbl_mbr %02d (%02d)\n", i, ptb->count);
+		memset(mbr ,0 ,sizeof(struct dos_mbr_or_ebr));
+		if (i == 0) {
+			_construct_mbr_or_ebr(ptb, mbr, i, 0);
+			i = i+2;
+		} else
+			_construct_mbr_or_ebr(ptb, mbr, i, 2);
+		src = (unsigned char *)mbr;
+		apt_info("--%s(): %02d(%02d), off %x\n", __func__, i, ptb->count, start_blk);
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), start_blk, blk_cnt, src);
+		i++;
+		if (ret != blk_cnt) {
+			apt_err("write current MBR failed! ret: %d != cnt: %d\n",ret,blk_cnt);
+			break;
+		}
+		start_blk = (ptb->partitions[i].offset - PARTITION_RESERVED) >> 9;
+		apt_info("!!!!end update_ptbl_mbr %02d (%02d)\n", i, ptb->count);
+	}
+	free(mbr);
+	free(ptb->partitions);
+	free(ptb);
+
+	ret = !ret;
+	if (ret)
+		apt_err("write MBR failed!\n");
+	else
+		apt_err("write MBR ok!!!!\n");
+
+	return ret;
+}
+
+#ifdef CONFIG_AML_GPT
+int is_gpt_changed(struct mmc *mmc, struct _iptbl *p_iptbl_ept)
+{
+	int i, k;
+	gpt_entry *gpt_pte = NULL;
+	size_t efiname_len;
+	struct _iptbl *ept = p_iptbl_ept;
+	struct partitions *partitions = ept->partitions;
+	int parts_num = ept->count;
+	uint64_t offset;
+	uint64_t size;
+	char name[PARTNAME_SZ];
+	int gpt_changed = 0;
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+
+	if (!dev_desc) {
+		printf("%s: Invalid Argument(s)\n", __func__);
+		return 1;
+	}
+
+	if (is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				gpt_head, &gpt_pte) != 1) {
+		printf("%s: ***ERROR:Invalid GPT ***\n", __func__);
+		if (is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+					gpt_head, &gpt_pte) != 1) {
+			printf("%s: ***ERROR: Invalid Backup GPT ***\n",
+					__func__);
+			return 1;
+		} else {
+			printf("%s: *** Using Backup GPT ***\n",
+					__func__);
+		}
+			//return 1;
+	}
+	for (i = 0; i < le32_to_cpu(gpt_head->num_partition_entries); i++) {
+		if (!is_pte_valid(&gpt_pte[i]))
+			break;
+
+		offset = le64_to_cpu(gpt_pte[i].starting_lba<<9ULL);
+		if (partitions[i].offset != offset) {
+			printf("Caution! GPT offset had been changed\n");
+			gpt_changed = 1;
+			break;
+		}
+
+		size = ((le64_to_cpu(gpt_pte[i].ending_lba)+1) -
+			le64_to_cpu(gpt_pte[i].starting_lba)) << 9ULL;
+		if (i == parts_num - 1) {
+			if ((partitions[i].size - GPT_TOTAL_SIZE) != size) {
+				printf("Caution! GPT size had been changed\n");
+				gpt_changed = 1;
+				break;
+			}
+		} else {
+		if (partitions[i].size != size) {
+			printf("Caution! GPT size had been changed\n");
+			gpt_changed = 1;
+			break;
+			}
+		}
+
+		/* partition name */
+		efiname_len = sizeof(gpt_pte[i].partition_name)
+			/ sizeof(efi_char16_t);
+
+		memset(name, 0, PARTNAME_SZ);
+		for (k = 0; k < efiname_len; k++)
+			name[k] = (char)gpt_pte[i].partition_name[k];
+		if (strcmp(name, partitions[i].name) != 0) {
+			printf("Caution! GPT name had been changed\n");
+			gpt_changed = 1;
+			break;
+		}
+
+	}
+	if ((i != parts_num) && (gpt_changed == 0)) {
+		gpt_changed = 1;
+		printf("Caution! GPT number had been changed\n");
+	}
+
+	free(gpt_pte);
+	return gpt_changed;
+}
+int is_gpt_broken(struct mmc *mmc)
+{
+	gpt_entry *gpt_pte = NULL;
+	int broken_status = 0;
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+
+	if (!dev_desc) {
+		printf("%s: Invalid Argument(s)\n", __func__);
+		return 1;
+	}
+
+	if (is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				gpt_head, &gpt_pte) != 1) {
+		broken_status += 1;
+		printf("%s: ***ERROR:Invalid GPT ***\n", __func__);
+	}
+	if (is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+				gpt_head, &gpt_pte) != 1) {
+		printf("%s: ***ERROR: Invalid Backup GPT ***\n",
+					__func__);
+		broken_status += 2;
+	}
+
+	if (broken_status != 3)
+		free(gpt_pte);
+	return broken_status;
+
+}
+
+int fill_ept_by_gpt(struct mmc *mmc, struct _iptbl *p_iptbl_ept)
+{
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+	gpt_entry *gpt_pte = NULL;
+	int i, k;
+	size_t efiname_len, dosname_len;
+	struct _iptbl *ept = p_iptbl_ept;
+	struct partitions *partitions = ept->partitions;
+
+	if (!dev_desc) {
+		printf("%s: Invalid Argument(s)\n", __func__);
+		return 1;
+	}
+
+	if (is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				gpt_head, &gpt_pte) != 1) {
+		printf("%s: ***ERROR:Invalid GPT ***\n", __func__);
+		if (is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+					gpt_head, &gpt_pte) != 1) {
+			printf("%s: ***ERROR: Invalid Backup GPT ***\n",
+					__func__);
+			return 1;
+		} else {
+			printf("%s: *** Using Backup GPT ***\n",
+					__func__);
+		}
+			//return 1;
+	}
+
+	for (i = 0; i < le32_to_cpu(gpt_head->num_partition_entries); i++) {
+		if (!is_pte_valid(&gpt_pte[i]))
+			break;
+
+		partitions[i].offset = le64_to_cpu(gpt_pte[i].starting_lba<<9ULL);
+		partitions[i].size = ((le64_to_cpu(gpt_pte[i].ending_lba)+1) -
+			le64_to_cpu(gpt_pte[i].starting_lba)) << 9ULL;
+		/* mask flag */
+		partitions[i].mask_flags = (uint32_t)le64_to_cpu(gpt_pte[i].attributes.fields.reserved);
+		/* partition name */
+		efiname_len = sizeof(gpt_pte[i].partition_name)
+			/ sizeof(efi_char16_t);
+		dosname_len = sizeof(partitions[i].name);
+
+		memset(partitions[i].name, 0, sizeof(partitions[i].name));
+		for (k = 0; k < min(dosname_len, efiname_len); k++)
+			partitions[i].name[k] = (char)gpt_pte[i].partition_name[k];
+
+	}
+	ept->count = i;
+	free(gpt_pte);
+	return 0;
+}
+
+void trans_ept_to_diskpart(struct _iptbl *ept, struct disk_partition *disk_part) {
+	struct partitions *part = ept->partitions;
+	int count = ept->count;
+	int i;
+	for (i = 0; i < count; i++) {
+		disk_part[i].start = part[i].offset >> 9;
+		strcpy((char *)disk_part[i].name, part[i].name);
+		/* store maskflag into type, 8bits ONLY! */
+		disk_part[i].type[0] = (uchar)part[i].mask_flags;
+	#ifdef CONFIG_PARTITION_TYPE_GUID
+		strcpy((char *)disk_part[i].type_guid, part[i].name);
+	#endif
+	#ifdef CONFIG_RANDOM_UUID
+		gen_rand_uuid_str(disk_part[i].uuid, UUID_STR_FORMAT_STD);
+	#endif
+		disk_part[i].bootable = 0;
+		if ( i == (count - 1))
+			disk_part[i].size = 0;
+		else
+			disk_part[i].size = (part[i].size) >> 9;
+	}
+	return;
+}
+
+
+
+
+#endif
+
+/***************************************************
+ *	init partition table for emmc device.
+ *	returns 0 means ok.
+ *			other means failure.
+ ***************************************************
+ *  work flows:
+ *	source of logic partition table(LPT) is from dts
+ *	no matter MACRO is on/off
+ *		1. try to get LPT from dtb
+ *			1.1 if dtb exist, compose ept by LPT&inh
+ *			1.2 if not, go ahead
+ *      2. try to get ept from emmc rsv partition
+ *			2.1 if not:
+ * 				2.1.1 when dtb exists
+ *					2.1.1.1 check ept with dtb
+ *					2.1.1.2 update rsv if needed
+ * 				2.1.1 without dtb, exit
+ *			2.2 if got:
+ *				2.2.1 try to reconstruct ept by MBR
+ *				2.2.2 check it with ept
+ *				2.2.3 update MBR if needed
+ ***************************************************
+ *	when normal boot:
+ *		without dtb, with rsv, with MBR
+ *  when blank emmc:
+ *		without dtb, without rsv, without MBR
+ *  when burning MBR on a blank emmc:
+ *		with dtb, without rsv, without MBR
+ *  when burning MBR on a emmc with rsv:
+ *		with dtb, with rsv, without MBR
+ *  when burning MBR on a emmc with rsv&MBR:
+ *		with dtb, with rsv, with MBR
+ ***************************************************/
+int mmc_device_init (struct mmc *mmc)
+{
+	int ret = 1;
+#if (CONFIG_PTBL_MBR)  || (!CONFIG_AML_PARTITION)
+	//cpu_id_t cpu_id = get_cpu_id();
+#endif
+	/* partition table from dtb/code/emmc rsv */
+	struct _iptbl iptbl_dtb, iptbl_inh;
+
+	/* calculate inherent offset */
+	iptbl_inh.count = get_emmc_partition_arraysize();
+	if (iptbl_inh.count) {
+		iptbl_inh.partitions = emmc_partition_table;
+		_calculate_offset(mmc, &iptbl_inh, 0);
+	}
+	apt_info("inh count %d\n",  iptbl_inh.count);
+#if (CONFIG_MPT_DEBUG)
+	apt_info("inherent partition table\n");
+	_dump_part_tbl(iptbl_inh.partitions, iptbl_inh.count);
+#endif
+	/* For re-entry */
+	if (NULL == p_iptbl_ept) {
+		ret = _zalloc_iptbl(&p_iptbl_ept);
+		if (ret)
+			goto _out;
+	} else {
+		p_iptbl_ept->count = 0;
+		memset(p_iptbl_ept->partitions, 0,
+			sizeof(struct partitions)*MAX_PART_COUNT);
+	}
+
+	/* try to get partition table from dtb(ddr or emmc) */
+	iptbl_dtb.partitions = get_ptbl_from_dtb(mmc);
+	/* construct ept by dtb if exist */
+	if (iptbl_dtb.partitions) {
+		iptbl_dtb.count = get_partition_count();
+		apt_info("dtb %p, count %d\n", iptbl_dtb.partitions, iptbl_dtb.count);
+		/* reserved partition must exist! */
+		if (iptbl_inh.count) {
+			compose_ept(&iptbl_dtb, &iptbl_inh, p_iptbl_ept);
+			if (0 == p_iptbl_ept->count) {
+				apt_err("compose partition table failed!\n");
+				goto _out;
+			}
+			/* calculate offset infos. considering GAPs */
+			if (_calculate_offset(mmc, p_iptbl_ept, 1)) {
+				goto _out;
+			}
+		#if (CONFIG_MPT_DEBUG)
+			apt_info("ept partition table\n");
+			_dump_part_tbl(p_iptbl_ept->partitions, p_iptbl_ept->count);
+		#endif
+		} else {
+			/* report fail, because there is no reserved partitions */
+			apt_err("compose partition table failed!\n");
+			ret = -1;
+			goto _out;
+		}
+	} else
+		apt_wrn("get partition table from dtb failed\n");
+#ifndef CONFIG_AML_PARTITION
+	if (0) { //(cpu_id.family_id < MESON_CPU_MAJOR_ID_G12B) {
+		printf("CONFIG_AML_PARTITION should define before G12B\n");
+		goto _out;
+	}
+#endif
+
+#ifdef CONFIG_AML_PARTITION
+	int update = 1;
+	struct _iptbl *p_iptbl_rsv = NULL;
+	/* try to get partiton table from rsv */
+	ret = _zalloc_iptbl(&p_iptbl_rsv);
+	if (ret)
+		goto _out;
+	ret = get_ptbl_rsv(mmc, p_iptbl_rsv);
+        apt_info("!!!! after call get_ptbl_rsv got %i parts\n",p_iptbl_rsv->count);
+
+	if (p_iptbl_rsv->count) {
+		/* dtb exist, p_iptbl_ept already inited */
+		if (iptbl_dtb.partitions) {
+			ret = _cmp_iptbl(p_iptbl_ept, p_iptbl_rsv);
+			if (!ret) {
+				update = 0;
+			}
+		} else {
+			/* without dtb, update ept with rsv */
+		        apt_info("!!!! call _cpy_iptbl from rsv to ept %i\n",p_iptbl_rsv->count);
+			_cpy_iptbl(p_iptbl_ept, p_iptbl_rsv);
+			update = 0;
+		}
+	} else {
+		/* without dtb& rsv */
+		if (!iptbl_dtb.partitions) {
+			apt_err("dtb&rsv are not exist, no LPT source\n");
+			ret = -9;
+			goto _out;
+		}
+	}
+
+	if (update && iptbl_dtb.partitions) {
+		apt_wrn("update rsv with dtb!\n");
+		ret = update_ptbl_rsv(mmc, p_iptbl_ept);
+	}
+#endif
+	//apt_wrn("ept source is %s\n", (ept_source == p_iptbl_ept)?"ept":"rsv");
+#if (CONFIG_PTBL_MBR)
+	/* 1st sector was reserved by romboot after gxl */
+	if (1) { //(cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+		if (_check_ptbl_mbr(mmc, p_iptbl_ept)) {
+			apt_info("!!!! after _check_ptbl_mbr, see %i ept parts, check result %i\n",p_iptbl_ept->count, _check_ptbl_mbr(mmc, p_iptbl_ept));
+			/*fixme, comaptible for mbr&ebr */
+			ret |= _update_ptbl_mbr(mmc, p_iptbl_ept);
+			apt_wrn("MBR Updated!\n");
+		}
+	}
+#endif
+#ifdef CONFIG_AML_GPT
+	char *str_disk_guid;
+	int gpt_priority = GPT_PRIORITY;
+	struct disk_partition *disk_partition;
+	int dcount = p_iptbl_ept->count;
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	disk_partition = calloc(1, PAD_TO_BLOCKSIZE(sizeof(struct disk_partition) * dcount, dev_desc));
+	trans_ept_to_diskpart(p_iptbl_ept, disk_partition);
+	str_disk_guid = malloc(UUID_STR_LEN + 1);
+	if (str_disk_guid == NULL) {
+		free(disk_partition);
+		return -ENOMEM;
+	}
+#ifdef CONFIG_RANDOM_UUID
+	gen_rand_uuid_str(str_disk_guid, UUID_STR_FORMAT_STD);
+#endif
+	if (part_test_efi(mmc_get_blk_desc(mmc)) != 0) {
+		ret = gpt_restore(mmc_get_blk_desc(mmc), str_disk_guid, disk_partition, dcount);
+		printf("GPT IS RESTORED %s\n", ret ? "Failed!" : "OK!");
+	} else if (is_gpt_changed(mmc, p_iptbl_ept)) {
+		if (gpt_priority) {
+			fill_ept_by_gpt(mmc, p_iptbl_ept);
+			printf("and gpt has higher priority, so ept had been update\n");
+		} else {
+			gpt_restore(mmc_get_blk_desc(mmc), str_disk_guid, disk_partition, dcount);
+			printf("but EPT has higher priority, so gpt had been recover\n");
+		}
+	}
+
+	int broken_status = is_gpt_broken(mmc);
+	if (broken_status != 0 && broken_status != 3) {
+		fill_ept_by_gpt(mmc, p_iptbl_ept);
+		free(disk_partition);
+		dcount = p_iptbl_ept->count;
+		disk_partition = calloc(1, PAD_TO_BLOCKSIZE(sizeof(struct disk_partition) * dcount, dev_desc));
+		trans_ept_to_diskpart(p_iptbl_ept, disk_partition);
+		ret = gpt_restore(mmc_get_blk_desc(mmc), str_disk_guid, disk_partition, p_iptbl_ept->count);
+		if (broken_status == 1)
+			printf("The first gpt has been restore\n");
+		else if (broken_status == 2)
+			printf("The second gpt has been restore\n");
+		else
+			printf("Both gpt has been restore\n");
+	}
+
+	free(str_disk_guid);
+	free(disk_partition);
+#endif
+	/* init part again */
+	apt_info("!!!! init part again\n");
+	part_init(mmc_get_blk_desc(mmc));
+
+_out:
+#ifdef CONFIG_AML_PARTITION
+	if (p_iptbl_rsv)
+		_free_iptbl(p_iptbl_rsv);
+#endif
+	return ret;
+}
+
+
+struct partitions *find_mmc_partition_by_name (char const *name)
+{
+	struct partitions *partition = NULL;
+
+	apt_info("p_iptbl_ept %p\n", p_iptbl_ept);
+	if (NULL == p_iptbl_ept) {
+		goto _out;
+	}
+	partition = p_iptbl_ept->partitions;
+	partition = _find_partition_by_name(partition,
+			p_iptbl_ept->count, name);
+	apt_info("partition %p\n", partition);
+	if (!partition) {
+		partition = _find_partition_by_name(emmc_partition_table,
+			get_emmc_partition_arraysize(), name);
+	}
+	apt_info("partition %p\n", partition);
+_out:
+	return partition;
+}
+
+/*
+ find virtual partition in inherent table.
+*/
+int find_virtual_partition_by_name (char const *name, struct partitions *partition)
+{
+	int ret = 0;
+	ulong offset;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	if (NULL == partition)
+		return -1;
+
+	offset = _get_inherent_offset(MMC_RESERVED_NAME);
+	if (-1 == offset) {
+		apt_err("can't find %s in inherent\n", MMC_RESERVED_NAME);
+		return -1;
+	}
+
+	if (!strcmp(name, "dtb")) {
+		strcpy(partition->name, name);
+		partition->offset = offset + vpart->offset;
+		partition->size = (vpart->size * DTB_COPIES);
+	}
+
+	return ret;
+}
+
+int find_dev_num_by_partition_name (char const *name)
+{
+	int dev = -1;
+
+	/* card */
+	if (!strcmp(name, MMC_CARD_PARTITION_NAME)) {
+		dev = 0;
+    } else { /* eMMC OR TSD */
+		/* partition name is valid */
+		if (find_mmc_partition_by_name(name)) {
+			dev = 1;
+		}
+	}
+	return dev;
+}
+
+static inline uint64_t get_part_size(struct partitions *part, int num)
+{
+    return part[num].size;
+}
+
+static inline uint64_t get_part_offset(struct partitions *part, int num)
+{
+    return part[num].offset;
+}
+
+static inline char * get_part_name(struct partitions *part, int num)
+{
+    return (char *)part[num].name;
+}
+
+int get_part_info_from_tbl(struct blk_desc *dev_desc,
+	int num, struct disk_partition *info)
+{
+    int ret = 0;
+    struct partitions *part;
+
+	if (NULL == p_iptbl_ept)
+        return -1;
+	if (num > (p_iptbl_ept->count-1))
+        return -1;
+    part = p_iptbl_ept->partitions;
+
+    /*get partition info by index! */
+    info->start = (lbaint_t)(get_part_offset(part, num)/dev_desc->blksz);
+    info->size = (lbaint_t)(get_part_size(part, num)/dev_desc->blksz);
+	info->blksz = dev_desc->blksz;
+    strcpy((char *)info->name, get_part_name(part, num));
+
+    return ret;
+}
+#if (CONFIG_MPT_DEBUG)
+void show_partition_info(struct disk_partition *info)
+{
+	printf("----------%s----------\n", __func__);
+	printf("name %10s\n", info->name);
+	printf("blksz " LBAFU "\n", info->blksz);
+	printf("sart %ld\n", info->start);
+	printf("size %ld\n", info->size);
+	printf("----------end----------\n");
+}
+#endif
+
+
+struct partitions *aml_get_partition_by_name(const char *name)
+{
+	struct partitions *partition = NULL;
+	partition = _find_partition_by_name(emmc_partition_table,
+			get_emmc_partition_arraysize(), name);
+	if (partition == NULL)
+		apt_wrn("do not find match in inherent table %s\n", name);
+	return partition;
+}
+
+struct virtual_partition *aml_get_virtual_partition_by_name(const char *name)
+{
+	int i = 0, cnt;
+	struct virtual_partition *part = NULL;
+	cnt = get_emmc_virtual_partition_arraysize();
+	while (i < cnt) {
+
+		part = &virtual_partition_table[i];
+		if (!strcmp(name, part->name)) {
+			apt_info("find %10s @ tbl[%d]\n", name, i);
+			break;
+		}
+		i++;
+	};
+	if (i == cnt) {
+		part = NULL;
+		apt_wrn("do not find match in table %10s\n", name);
+	}
+	return part;
+}
+
+int get_part_info_by_name(struct blk_desc *dev_desc,
+	const char *name, struct disk_partition *info)
+{
+	struct partitions *partition = NULL;
+	struct partitions virtual;
+	int ret = 0;
+	cpu_id_t cpu_id = get_cpu_id();
+
+	partition = find_mmc_partition_by_name((char *)name);
+	if (partition) {
+		info->start = (lbaint_t)(partition->offset/dev_desc->blksz);
+		info->size = (lbaint_t)(partition->size/dev_desc->blksz);
+		info->blksz = dev_desc->blksz;
+		strcpy((char *)info->name, partition->name);
+	} else if (!find_virtual_partition_by_name((char *)name, &virtual)) {
+		/* try virtual partitions */
+		apt_wrn("Got %s in virtual table\n", name);
+		info->start = (lbaint_t)(virtual.offset/dev_desc->blksz);
+		info->size = (lbaint_t)(virtual.size/dev_desc->blksz);
+		info->blksz = dev_desc->blksz;
+		strcpy((char *)info->name, virtual.name);
+	} else {
+		/* all partitions were tried, fail */
+		ret = -1;
+		goto _out;
+	}
+	/* for bootloader */
+	if ((0 == info->start) && (cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL)) {
+		info->start = 1;
+		info->size -= 1;
+	}
+
+#if (CONFIG_MPT_DEBUG)
+	show_partition_info(info);
+#endif
+_out:
+	return ret;
+}
+
+
+/*
+ * get the partition number by name
+ * return value
+ *     < 0 means no partition found
+ *     >= 0 means valid partition
+ */
+__weak int get_partition_num_by_name(char const *name)
+{
+	   int ret = -1;
+	   struct partitions *partition = NULL;
+
+       if (NULL == p_iptbl_ept)
+			   goto _out;
+	   partition = p_iptbl_ept->partitions;
+	   ret = _get_part_index_by_name(partition,
+					   p_iptbl_ept->count, name);
+_out:
+	   return ret;
+}
+
+/*
+ * get the partition info by number
+ * return value
+ *     < 0 means no partition found
+ *     >= 0 means valid partition
+ */
+__weak struct partitions *get_partition_info_by_num(const int num)
+{
+	struct partitions *partition = NULL;
+
+	if ((NULL == p_iptbl_ept)
+		|| (num >= p_iptbl_ept->count))
+		goto _out;
+	partition = &p_iptbl_ept->partitions[num];
+
+_out:
+	return partition;
+}
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 12d29da528..c63bca2e08 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -26,6 +26,24 @@
 #include <div64.h>
 #include "mmc_private.h"
 
+
+// TODO amlogic 
+#include <linux/crc32.h>
+#include <rand.h>
+#include <amlstorage/partition_table.h>
+#include <amlstorage/emmc_partitions.h>
+
+struct aml_pattern aml_pattern_table[] = {
+	AML_PATTERN_ELEMENT(MMC_PATTERN_NAME, CALI_PATTERN),
+	AML_PATTERN_ELEMENT(MMC_MAGIC_NAME, MAGIC_PATTERN),
+	AML_PATTERN_ELEMENT(MMC_RANDOM_NAME, RANDOM_PATTERN),
+};
+
+int mmc_pattern_check(struct mmc *mmc, struct aml_pattern *table);
+void mmc_write_cali_mattern(void *addr, struct aml_pattern *table);
+
+// end TODO
+
 #define DEFAULT_CMD6_TIMEOUT_MS  500
 
 static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
@@ -2343,6 +2361,12 @@ static int mmc_startup_v4(struct mmc *mmc)
 	}
 #endif
 
+	/* dev life time estimate type A/B */
+	mmc->dev_lifetime_est_typ_a
+		= ext_csd[EXT_CSD_DEV_LIFETIME_EST_TYP_A];
+	mmc->dev_lifetime_est_typ_b
+		= ext_csd[EXT_CSD_DEV_LIFETIME_EST_TYP_B];
+
 	/*
 	 * Host needs to enable ERASE_GRP_DEF bit if device is
 	 * partitioned. This bit will be lost every time after a reset
@@ -2933,7 +2957,7 @@ static int mmc_complete_init(struct mmc *mmc)
 
 int mmc_init(struct mmc *mmc)
 {
-	int err = 0;
+	int err = 0, i;
 	__maybe_unused ulong start;
 #if CONFIG_IS_ENABLED(DM_MMC)
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(mmc->dev);
@@ -2952,6 +2976,18 @@ int mmc_init(struct mmc *mmc)
 		err = mmc_complete_init(mmc);
 	if (err)
 		pr_info("%s: %d, time %lu\n", __func__, err, get_timer(start));
+	info_disprotect |= DISPROTECT_KEY;
+	if (IS_MMC(mmc)) {
+		if (!is_partition_checked) {
+			if (mmc_device_init(mmc) == 0) {
+				is_partition_checked = true;
+				pr_info("eMMC/TSD partition table have been checked OK!\n");
+				for (i = 0; i < ARRAY_SIZE(aml_pattern_table); i++)
+					mmc_pattern_check(mmc, &aml_pattern_table[i]);
+			}
+		}
+	}
+	info_disprotect &= ~DISPROTECT_KEY;
 
 	return err;
 }
@@ -3136,3 +3172,64 @@ __weak int mmc_get_env_dev(void)
 	return 0;
 #endif
 }
+
+/// TODO: amlogic 
+int mmc_pattern_check(struct mmc *mmc, struct aml_pattern *table)
+{
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0;
+	u32 *buf = NULL;
+	u32 crc32_s = 0;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+
+	vpart = aml_get_virtual_partition_by_name(table->name);
+
+	addr = (void *)malloc(vpart->size);
+	if (!addr) {
+		printf("%s malloc failed\n", table->name);
+		return 1;
+	}
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	blk = (part->offset + vpart->offset) / mmc->read_bl_len;
+	cnt = vpart->size / mmc->read_bl_len;
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if (n != cnt) {
+		printf("read pattern failed\n");
+		free(addr);
+		return 1;
+	} else {
+		buf = (u32 *)addr;
+		crc32_s = crc32(0, (u8 *)addr, (vpart->size - 4));
+		if (crc32_s != buf[vpart->size/4 - 1]) {
+			printf("check %s failed,need to write\n",
+						table->name);
+			mmc_write_cali_mattern(addr, table);
+			n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+			printf("several 0x%x pattern blocks write %s\n",
+				table->pattern, (n == cnt) ? "OK" : "ERROR");
+		}
+		printf("crc32_s:0x%x == storage crc_pattern:0x%x!!!\n",
+				crc32_s, buf[vpart->size/4 - 1]);
+	}
+	free(addr);
+	return (n == cnt) ? 0 : 1;
+}
+
+
+void mmc_write_cali_mattern(void *addr, struct aml_pattern *table)
+{
+	int i = 0;
+	unsigned int s = 10;
+	u32 *mattern = (u32 *)addr;
+	struct virtual_partition *vpart =
+		aml_get_virtual_partition_by_name(table->name);
+	for (i = 0;i < (vpart->size)/4 - 1;i++) {
+		if (!strcmp(table->name, "random"))
+			mattern[i] = rand_r(&s);
+		else
+			mattern[i] = table->pattern;
+	}
+	mattern[i] = crc32(0, (u8 *)addr, (vpart->size - 4));
+	return;
+}
diff --git a/drivers/mmc/mmc_aml copy.c b/drivers/mmc/mmc_aml copy.c
new file mode 100644
index 0000000000..66c0203dc6
--- /dev/null
+++ b/drivers/mmc/mmc_aml copy.c	
@@ -0,0 +1,3299 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2008, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the Linux code
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <errno.h>
+#include <mmc.h>
+#include <part.h>
+#include <power/regulator.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <linux/list.h>
+#include <div64.h>
+#include "mmc_private.h"
+#include <amlstorage/emmc_partitions.h>
+#include <amlstorage/partition_table.h>
+#include <amlogic/storage.h>
+#include <amlogic/asm/secure_apb.h>
+#include <amlogic/asm/sd_emmc.h>
+
+struct aml_pattern aml_pattern_table[] = {
+	AML_PATTERN_ELEMENT(MMC_PATTERN_NAME, CALI_PATTERN),
+	AML_PATTERN_ELEMENT(MMC_MAGIC_NAME, MAGIC_PATTERN),
+	AML_PATTERN_ELEMENT(MMC_RANDOM_NAME, RANDOM_PATTERN),
+};
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
+static int mmc_power_cycle(struct mmc *mmc);
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+static int mmc_select_mode_and_width(struct mmc *mmc, uint card_caps);
+#endif
+
+extern int emmc_probe(uint32_t init_flag);
+
+bool emmckey_is_access_range_legal (struct mmc *mmc, ulong start, lbaint_t blkcnt) {
+	ulong key_start_blk, key_end_blk;
+	u64 key_glb_offset;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	if (IS_MMC(mmc)) {
+		vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+		part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+		key_glb_offset = part->offset + vpart->offset;
+		key_start_blk = (key_glb_offset / MMC_BLOCK_SIZE);
+		key_end_blk = ((key_glb_offset + vpart->size) / MMC_BLOCK_SIZE - 1);
+		if (!(info_disprotect & DISPROTECT_KEY)) {
+			if ((key_start_blk <= (start + blkcnt -1))
+				&& (key_end_blk >= start)
+				&& (blkcnt != start)) {
+				pr_info("%s, keys %ld, keye %ld, start %ld, blkcnt %ld\n",
+						mmc->cfg->name, key_start_blk,
+						key_end_blk, start, blkcnt);
+				pr_err("Emmckey: Access range is illegal!\n");
+				return 0;
+			}
+		}
+	}
+	return 1;
+}
+
+int emmc_boot_chk(struct mmc *mmc)
+{
+	u32 val = 0;
+
+	if (strcmp(mmc->dev->name, "emmc"))
+		return 0;
+
+	val = readl(SEC_AO_SEC_GP_CFG0);
+	pr_info("SEC_AO_SEC_GP_CFG0 = %x\n", val);
+	if ((val & 0xf) == 0x1)
+		return 1;
+
+	return 0;
+}
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+static struct mmc mmc_static;
+struct mmc *find_mmc_device(int dev_num)
+{
+	return &mmc_static;
+}
+
+void mmc_do_preinit(void)
+{
+	struct mmc *m = &mmc_static;
+#ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
+	mmc_set_preinit(m, 1);
+#endif
+	if (m->preinit)
+		mmc_start_init(m);
+}
+
+struct blk_desc *mmc_get_blk_desc(struct mmc *mmc)
+{
+	return &mmc->block_dev;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+static int mmc_wait_dat0(struct mmc *mmc, int state, int timeout)
+{
+	return -ENOSYS;
+}
+#endif
+
+__weak int board_mmc_getwp(struct mmc *mmc)
+{
+	return -1;
+}
+
+int mmc_getwp(struct mmc *mmc)
+{
+	int wp;
+
+	wp = board_mmc_getwp(mmc);
+
+	if (wp < 0) {
+		if (mmc->cfg->ops->getwp)
+			wp = mmc->cfg->ops->getwp(mmc);
+		else
+			wp = 0;
+	}
+
+	return wp;
+}
+
+__weak int board_mmc_getcd(struct mmc *mmc)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_MMC_TRACE
+void mmmc_trace_before_send(struct mmc *mmc, struct mmc_cmd *cmd)
+{
+	pr_info("CMD_SEND:%d\n", cmd->cmdidx);
+	pr_info("\t\tARG\t\t\t 0x%08X\n", cmd->cmdarg);
+}
+
+void mmmc_trace_after_send(struct mmc *mmc, struct mmc_cmd *cmd, int ret)
+{
+	int i;
+	u8 *ptr;
+
+	if (ret) {
+		pr_info("\t\tRET\t\t\t %d\n", ret);
+	} else {
+		switch (cmd->resp_type) {
+		case MMC_RSP_NONE:
+			pr_info("\t\tMMC_RSP_NONE\n");
+			break;
+		case MMC_RSP_R1:
+			pr_info("\t\tMMC_RSP_R1,5,6,7 \t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		case MMC_RSP_R1b:
+			pr_info("\t\tMMC_RSP_R1b\t\t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		case MMC_RSP_R2:
+			pr_info("\t\tMMC_RSP_R2\t\t 0x%08X \n",
+				cmd->response[0]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[1]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[2]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[3]);
+			pr_info("\n");
+			pr_info("\t\t\t\t\tDUMPING DATA\n");
+			for (i = 0; i < 4; i++) {
+				int j;
+				pr_info("\t\t\t\t\t%03d - ", i*4);
+				ptr = (u8 *)&cmd->response[i];
+				ptr += 3;
+				for (j = 0; j < 4; j++)
+					pr_info("%02X ", *ptr--);
+				pr_info("\n");
+			}
+			break;
+		case MMC_RSP_R3:
+			pr_info("\t\tMMC_RSP_R3,4\t\t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		default:
+			pr_info("\t\tERROR MMC rsp not supported\n");
+			break;
+		}
+	}
+}
+
+void mmc_trace_state(struct mmc *mmc, struct mmc_cmd *cmd)
+{
+	int status;
+
+	status = (cmd->response[0] & MMC_STATUS_CURR_STATE) >> 9;
+	pr_info("CURR STATE:%d\n", status);
+}
+#endif
+
+#if CONFIG_IS_ENABLED(MMC_VERBOSE) || defined(DEBUG)
+const char *mmc_mode_name(enum bus_mode mode)
+{
+	static const char *const names[] = {
+	      [MMC_LEGACY]	= "MMC legacy",
+	      [SD_LEGACY]	= "SD Legacy",
+	      [MMC_HS]		= "MMC High Speed (26MHz)",
+	      [SD_HS]		= "SD High Speed (50MHz)",
+	      [UHS_SDR12]	= "UHS SDR12 (25MHz)",
+	      [UHS_SDR25]	= "UHS SDR25 (50MHz)",
+	      [UHS_SDR50]	= "UHS SDR50 (100MHz)",
+	      [UHS_SDR104]	= "UHS SDR104 (208MHz)",
+	      [UHS_DDR50]	= "UHS DDR50 (50MHz)",
+	      [MMC_HS_52]	= "MMC High Speed (52MHz)",
+	      [MMC_DDR_52]	= "MMC DDR52 (52MHz)",
+	      [MMC_HS_200]	= "HS200 (200MHz)",
+	      [MMC_HS_400]	= "HS400 (200MHz)",
+	};
+
+	if (mode >= MMC_MODES_END)
+		return "Unknown mode";
+	else
+		return names[mode];
+}
+#endif
+
+static uint mmc_mode2freq(struct mmc *mmc, enum bus_mode mode)
+{
+	static const int freqs[] = {
+	      [MMC_LEGACY]	= 25000000,
+	      [SD_LEGACY]	= 25000000,
+	      [MMC_HS]		= 26000000,
+	      [SD_HS]		= 50000000,
+	      [MMC_HS_52]	= 52000000,
+	      [MMC_DDR_52]	= 52000000,
+	      [UHS_SDR12]	= 25000000,
+	      [UHS_SDR25]	= 50000000,
+	      [UHS_SDR50]	= 100000000,
+	      [UHS_DDR50]	= 50000000,
+	      [UHS_SDR104]	= 208000000,
+	      [MMC_HS_200]	= 200000000,
+	      [MMC_HS_400]	= 200000000,
+	};
+
+	if (mode == MMC_LEGACY)
+		return mmc->legacy_speed;
+	else if (mode >= MMC_MODES_END)
+		return 0;
+	else
+		return freqs[mode];
+}
+
+static int mmc_select_mode(struct mmc *mmc, enum bus_mode mode)
+{
+	mmc->selected_mode = mode;
+	mmc->tran_speed = mmc_mode2freq(mmc, mode);
+	mmc->ddr_mode = mmc_is_mode_ddr(mode);
+	pr_debug("selecting mode %s (freq : %d MHz)\n", mmc_mode_name(mode),
+		 mmc->tran_speed / 1000000);
+	return 0;
+}
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	int ret;
+
+	mmmc_trace_before_send(mmc, cmd);
+	ret = mmc->cfg->ops->send_cmd(mmc, cmd, data);
+	mmmc_trace_after_send(mmc, cmd, ret);
+
+	return ret;
+}
+#endif
+
+int mmc_send_status(struct mmc *mmc, int timeout)
+{
+	struct mmc_cmd cmd;
+	int err, retries = 5;
+	int status;
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	if (!mmc_host_is_spi(mmc))
+		cmd.cmdarg = mmc->rca << 16;
+
+	while (1) {
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (!err) {
+			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
+			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
+			     MMC_STATE_PRG)
+				break;
+
+			if (cmd.response[0] & MMC_STATUS_MASK) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+				pr_err("Status Error: 0x%08X\n",
+				       cmd.response[0]);
+#endif
+				return -ECOMM;
+			}
+		} else if (--retries < 0)
+			return err;
+
+		if (timeout-- <= 0)
+			break;
+
+		udelay(1000);
+	}
+
+	mmc_trace_state(mmc, &cmd);
+	if (timeout <= 0) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+		pr_debug("Timeout waiting card ready\n");
+#endif
+		return -ETIMEDOUT;
+	}
+	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
+	if (cmd.response[0] & MMC_STATUS_SWITCH_ERROR) {
+		pr_err("mmc status switch error status =0x%x\n", status);
+		return -21;
+	}
+	return 0;
+}
+
+int mmc_set_blocklen(struct mmc *mmc, int len)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	if (mmc->ddr_mode)
+		return 0;
+
+	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = len;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+#ifdef CONFIG_MMC_QUIRKS
+	if (err && (mmc->quirks & MMC_QUIRK_RETRY_SET_BLOCKLEN)) {
+		int retries = 4;
+		/*
+		 * It has been seen that SET_BLOCKLEN may fail on the first
+		 * attempt, let's try a few more time
+		 */
+		do {
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+			if (!err)
+				break;
+		} while (retries--);
+	}
+#endif
+
+	return err;
+}
+
+#ifdef MMC_SUPPORTS_TUNING
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
+
+int mmc_send_tuning(struct mmc *mmc, u32 opcode, int *cmd_error)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	const u8 *tuning_block_pattern;
+	int size, err;
+
+	if (mmc->bus_width == 8) {
+		tuning_block_pattern = tuning_blk_pattern_8bit;
+		size = sizeof(tuning_blk_pattern_8bit);
+	} else if (mmc->bus_width == 4) {
+		tuning_block_pattern = tuning_blk_pattern_4bit;
+		size = sizeof(tuning_blk_pattern_4bit);
+	} else {
+		return -EINVAL;
+	}
+
+	ALLOC_CACHE_ALIGN_BUFFER(u8, data_buf, size);
+
+	cmd.cmdidx = opcode;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = (void *)data_buf;
+	data.blocks = 1;
+	data.blocksize = size;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err)
+		return err;
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		return -EIO;
+
+	return 0;
+}
+#endif
+
+static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
+			   lbaint_t blkcnt)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+
+	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * mmc->read_bl_len;
+
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = dst;
+	data.blocks = blkcnt;
+	data.blocksize = mmc->read_bl_len;
+	data.flags = MMC_DATA_READ;
+
+	if (mmc_send_cmd(mmc, &cmd, &data))
+		return 0;
+
+	if (blkcnt > 1) {
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
+		if (mmc_send_cmd(mmc, &cmd, NULL)) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+			pr_err("mmc fail to send stop cmd\n");
+#endif
+			return 0;
+		}
+	}
+
+	return blkcnt;
+}
+
+#if CONFIG_IS_ENABLED(BLK)
+ulong mmc_bread(struct udevice *dev, lbaint_t start, lbaint_t blkcnt, void *dst)
+#else
+ulong mmc_bread(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
+		void *dst)
+#endif
+{
+#if CONFIG_IS_ENABLED(BLK)
+	struct blk_desc *block_dev = dev_get_uclass_platdata(dev);
+#endif
+	int dev_num = block_dev->devnum;
+	int err;
+	lbaint_t cur, blocks_todo = blkcnt;
+
+	if (blkcnt == 0)
+		return 0;
+
+	struct mmc *mmc = find_mmc_device(dev_num);
+	if (!mmc)
+		return 0;
+
+	if (CONFIG_IS_ENABLED(MMC_TINY))
+		err = mmc_switch_part(mmc, block_dev->hwpart);
+	else
+		err = blk_dselect_hwpart(block_dev, block_dev->hwpart);
+
+	if (err < 0)
+		return 0;
+
+	if ((start + blkcnt) > block_dev->lba) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+		pr_err("MMC: block number 0x" LBAF " exceeds max(0x" LBAF ")\n",
+		       start + blkcnt, block_dev->lba);
+#endif
+		return 0;
+	}
+
+	if (mmc_set_blocklen(mmc, mmc->read_bl_len)) {
+		pr_debug("%s: Failed to set blocklen\n", __func__);
+		return 0;
+	}
+	if (!emmckey_is_access_range_legal(mmc, start, blkcnt))
+		return 0;
+
+	do {
+		cur = (blocks_todo > mmc->cfg->b_max) ?
+			mmc->cfg->b_max : blocks_todo;
+		if (mmc_read_blocks(mmc, dst, start, cur) != cur) {
+			pr_debug("%s: Failed to read blocks\n", __func__);
+			return 0;
+		}
+		blocks_todo -= cur;
+		start += cur;
+		dst += cur * mmc->read_bl_len;
+	} while (blocks_todo > 0);
+
+	return blkcnt;
+}
+
+static int mmc_go_idle(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	udelay(1000);
+
+	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_NONE;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	udelay(2000);
+
+	return 0;
+}
+
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
+{
+	struct mmc_cmd cmd;
+	int err = 0;
+
+	/*
+	 * Send CMD11 only if the request is to switch the card to
+	 * 1.8V signalling.
+	 */
+	if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
+		return mmc_set_signal_voltage(mmc, signal_voltage);
+
+	cmd.cmdidx = SD_CMD_SWITCH_UHS18V;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_R1;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	if (!mmc_host_is_spi(mmc) && (cmd.response[0] & MMC_STATUS_ERROR))
+		return -EIO;
+
+	/*
+	 * The card should drive cmd and dat[0:3] low immediately
+	 * after the response of cmd11, but wait 100 us to be sure
+	 */
+	err = mmc_wait_dat0(mmc, 0, 100);
+	if (err == -ENOSYS)
+		udelay(100);
+	else if (err)
+		return -ETIMEDOUT;
+
+	/*
+	 * During a signal voltage level switch, the clock must be gated
+	 * for 5 ms according to the SD spec
+	 */
+	mmc_set_clock(mmc, mmc->clock, MMC_CLK_DISABLE);
+
+	err = mmc_set_signal_voltage(mmc, signal_voltage);
+	if (err)
+		return err;
+
+	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
+	mdelay(10);
+	mmc_set_clock(mmc, mmc->clock, MMC_CLK_ENABLE);
+
+	/*
+	 * Failure to switch is indicated by the card holding
+	 * dat[0:3] low. Wait for at least 1 ms according to spec
+	 */
+	err = mmc_wait_dat0(mmc, 1, 1000);
+	if (err == -ENOSYS)
+		udelay(1000);
+	else if (err)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+#endif
+
+static int sd_send_op_cond(struct mmc *mmc, bool uhs_en)
+{
+	int timeout = 1000;
+	int err;
+	struct mmc_cmd cmd;
+
+	while (1) {
+		cmd.cmdidx = MMC_CMD_APP_CMD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+		cmd.resp_type = MMC_RSP_R3;
+
+		/*
+		 * Most cards do not answer if some reserved bits
+		 * in the ocr are set. However, Some controller
+		 * can set bit 7 (reserved for low voltages), but
+		 * how to manage low voltages SD card is not yet
+		 * specified.
+		 */
+		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
+			(mmc->cfg->voltages & 0xff8000);
+
+		if (mmc->version == SD_VERSION_2)
+			cmd.cmdarg |= OCR_HCS;
+
+		if (uhs_en)
+			cmd.cmdarg |= OCR_S18R;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		if (cmd.response[0] & OCR_BUSY)
+			break;
+
+		if (timeout-- <= 0)
+			return -EOPNOTSUPP;
+
+		udelay(1000);
+	}
+
+	if (mmc->version != SD_VERSION_2)
+		mmc->version = SD_VERSION_1_0;
+
+	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
+		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
+		cmd.resp_type = MMC_RSP_R3;
+		cmd.cmdarg = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+	}
+
+	mmc->ocr = cmd.response[0];
+
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+	if (uhs_en && !(mmc_host_is_spi(mmc)) && (cmd.response[0] & 0x41000000)
+	    == 0x41000000) {
+		err = mmc_switch_voltage(mmc, MMC_SIGNAL_VOLTAGE_180);
+		if (err)
+			return err;
+	}
+#endif
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
+
+	return 0;
+}
+
+static int mmc_send_op_cond_iter(struct mmc *mmc, int use_arg)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
+	cmd.resp_type = MMC_RSP_R3;
+	cmd.cmdarg = 0;
+	if (use_arg && !mmc_host_is_spi(mmc))
+		cmd.cmdarg = OCR_HCS |
+			(mmc->cfg->voltages &
+			(mmc->ocr & OCR_VOLTAGE_MASK)) |
+			(mmc->ocr & OCR_ACCESS_MODE);
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+	mmc->ocr = cmd.response[0];
+	return 0;
+}
+
+static int mmc_send_op_cond(struct mmc *mmc)
+{
+	int err, i;
+
+	/* Some cards seem to need this */
+	mmc_go_idle(mmc);
+
+ 	/* Asking to the card its capabilities */
+	for (i = 0; i < 2; i++) {
+		err = mmc_send_op_cond_iter(mmc, i != 0);
+		if (err)
+			return err;
+
+		/* exit if not busy (flag seems to be inverted) */
+		if (mmc->ocr & OCR_BUSY)
+			break;
+	}
+	mmc->op_cond_pending = 1;
+	return 0;
+}
+
+static int mmc_complete_op_cond(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int timeout = 1000;
+	ulong start;
+	int err;
+
+	mmc->op_cond_pending = 0;
+	if (!(mmc->ocr & OCR_BUSY)) {
+		/* Some cards seem to need this */
+		mmc_go_idle(mmc);
+
+		start = get_timer(0);
+		while (1) {
+			err = mmc_send_op_cond_iter(mmc, 1);
+			if (err)
+				return err;
+			if (mmc->ocr & OCR_BUSY)
+				break;
+			if (get_timer(start) > timeout)
+				return -EOPNOTSUPP;
+			udelay(100);
+		}
+	}
+
+	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
+		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
+		cmd.resp_type = MMC_RSP_R3;
+		cmd.cmdarg = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		mmc->ocr = cmd.response[0];
+	}
+
+	mmc->version = MMC_VERSION_UNKNOWN;
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 1;
+
+	return 0;
+}
+
+static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+
+	/* Get the Card Status Register */
+	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	data.dest = (char *)ext_csd;
+	data.blocks = 1;
+	data.blocksize = MMC_MAX_BLOCK_LEN;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	return err;
+}
+
+int mmc_get_ext_csd(struct mmc *mmc, u8 *ext_csd)
+{
+	return mmc_send_ext_csd(mmc, ext_csd);
+}
+
+int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+{
+	struct mmc_cmd cmd;
+	int timeout = 1000;
+	int retries = 3;
+	int ret;
+
+	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+				 (index << 16) |
+				 (value << 8);
+
+	while (retries > 0) {
+		ret = mmc_send_cmd(mmc, &cmd, NULL);
+
+		/* Waiting for the ready status */
+		if (!ret) {
+			ret = mmc_send_status(mmc, timeout);
+			return ret;
+		}
+
+		retries--;
+	}
+
+	return ret;
+
+}
+
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+u8 ext_csd_w[] = {191, 187, 185, 183, 179, 178, 177, 175,
+					173, 171, 169, 167, 165, 164, 163, 162,
+					161, 156, 155, 143, 140, 136, 134, 133,
+					132, 131, 62, 59, 56, 52, 37, 34,
+					33, 32, 31, 30, 29, 22, 17, 16, 15};
+
+int mmc_set_ext_csd(struct mmc *mmc, u8 index, u8 value)
+{
+	int ret = -21, i;
+
+	for (i = 0; i < sizeof(ext_csd_w); i++) {
+		if (ext_csd_w[i] == index)
+			break;
+	}
+	if (i != sizeof(ext_csd_w))
+		ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, index, value);
+
+	return ret;
+}
+
+static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode)
+{
+	int err;
+	int speed_bits;
+
+	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
+
+	switch (mode) {
+	case MMC_HS:
+	case MMC_HS_52:
+	case MMC_DDR_52:
+		speed_bits = EXT_CSD_TIMING_HS;
+		break;
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+	case MMC_HS_200:
+		speed_bits = EXT_CSD_TIMING_HS200;
+		break;
+#endif
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	case MMC_HS_400:
+		speed_bits = EXT_CSD_TIMING_HS400;
+		break;
+#endif
+	case MMC_LEGACY:
+		speed_bits = EXT_CSD_TIMING_LEGACY;
+		break;
+	default:
+		return -EINVAL;
+	}
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+			 speed_bits);
+	if (err)
+		return err;
+
+	if ((mode == MMC_HS) || (mode == MMC_HS_52)) {
+		/* Now check to see that it worked */
+		err = mmc_send_ext_csd(mmc, test_csd);
+		if (err)
+			return err;
+
+		/* No high-speed support */
+		if (!test_csd[EXT_CSD_HS_TIMING])
+			return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static int mmc_get_capabilities(struct mmc *mmc)
+{
+	u8 *ext_csd = mmc->ext_csd;
+	char cardtype;
+
+	mmc->card_caps = MMC_MODE_1BIT | MMC_CAP(MMC_LEGACY);
+
+	if (mmc_host_is_spi(mmc))
+		return 0;
+
+	/* Only version 4 supports high-speed */
+	if (mmc->version < MMC_VERSION_4)
+		return 0;
+
+	if (!ext_csd) {
+		pr_err("No ext_csd found!\n"); /* this should enver happen */
+		return -ENOTSUPP;
+	}
+
+	mmc->card_caps |= MMC_MODE_4BIT | MMC_MODE_8BIT;
+
+	cardtype = ext_csd[EXT_CSD_CARD_TYPE];
+	mmc->cardtype = cardtype;
+
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+	if (cardtype & (EXT_CSD_CARD_TYPE_HS200_1_2V |
+			EXT_CSD_CARD_TYPE_HS200_1_8V)) {
+		mmc->card_caps |= MMC_MODE_HS200;
+	}
+#endif
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	if (cardtype & (EXT_CSD_CARD_TYPE_HS400_1_2V |
+			EXT_CSD_CARD_TYPE_HS400_1_8V)) {
+		mmc->card_caps |= MMC_MODE_HS400;
+	}
+#endif
+	if (cardtype & EXT_CSD_CARD_TYPE_52) {
+		if (cardtype & EXT_CSD_CARD_TYPE_DDR_52)
+			mmc->card_caps |= MMC_MODE_DDR_52MHz;
+		mmc->card_caps |= MMC_MODE_HS_52MHz;
+	}
+	if (cardtype & EXT_CSD_CARD_TYPE_26)
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+#endif
+
+static int mmc_set_capacity(struct mmc *mmc, int part_num)
+{
+	switch (part_num) {
+	case 0:
+		mmc->capacity = mmc->capacity_user;
+		break;
+	case 1:
+	case 2:
+		mmc->capacity = mmc->capacity_boot;
+		break;
+	case 3:
+		mmc->capacity = mmc->capacity_rpmb;
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		mmc->capacity = mmc->capacity_gp[part_num - 4];
+		break;
+	default:
+		return -1;
+	}
+
+	mmc_get_blk_desc(mmc)->lba = lldiv(mmc->capacity, mmc->read_bl_len);
+
+	return 0;
+}
+
+int mmc_switch_part(struct mmc *mmc, unsigned int part_num)
+{
+	int ret;
+
+	ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
+			 (mmc->part_config & ~PART_ACCESS_MASK)
+			 | (part_num & PART_ACCESS_MASK));
+
+	/*
+	 * Set the capacity if the switch succeeded or was intended
+	 * to return to representing the raw device.
+	 */
+	if ((ret == 0) || ((ret == -ENODEV) && (part_num == 0))) {
+		ret = mmc_set_capacity(mmc, part_num);
+		mmc_get_blk_desc(mmc)->hwpart = part_num;
+	}
+
+	return ret;
+}
+
+#if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
+int mmc_hwpart_config(struct mmc *mmc,
+		      const struct mmc_hwpart_conf *conf,
+		      enum mmc_hwpart_conf_mode mode)
+{
+	u8 part_attrs = 0;
+	u32 enh_size_mult;
+	u32 enh_start_addr;
+	u32 gp_size_mult[4];
+	u32 max_enh_size_mult;
+	u32 tot_enh_size_mult = 0;
+	u8 wr_rel_set;
+	int i, pidx, err;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	if (mode < MMC_HWPART_CONF_CHECK || mode > MMC_HWPART_CONF_COMPLETE)
+		return -EINVAL;
+
+	if (IS_SD(mmc) || (mmc->version < MMC_VERSION_4_41)) {
+		pr_err("eMMC >= 4.4 required for enhanced user data area\n");
+		return -EMEDIUMTYPE;
+	}
+
+	if (!(mmc->part_support & PART_SUPPORT)) {
+		pr_err("Card does not support partitioning\n");
+		return -EMEDIUMTYPE;
+	}
+
+	if (!mmc->hc_wp_grp_size) {
+		pr_err("Card does not define HC WP group size\n");
+		return -EMEDIUMTYPE;
+	}
+
+	/* check partition alignment and total enhanced size */
+	if (conf->user.enh_size) {
+		if (conf->user.enh_size % mmc->hc_wp_grp_size ||
+		    conf->user.enh_start % mmc->hc_wp_grp_size) {
+			pr_err("User data enhanced area not HC WP group "
+			       "size aligned\n");
+			return -EINVAL;
+		}
+		part_attrs |= EXT_CSD_ENH_USR;
+		enh_size_mult = conf->user.enh_size / mmc->hc_wp_grp_size;
+		if (mmc->high_capacity) {
+			enh_start_addr = conf->user.enh_start;
+		} else {
+			enh_start_addr = (conf->user.enh_start << 9);
+		}
+	} else {
+		enh_size_mult = 0;
+		enh_start_addr = 0;
+	}
+	tot_enh_size_mult += enh_size_mult;
+
+	for (pidx = 0; pidx < 4; pidx++) {
+		if (conf->gp_part[pidx].size % mmc->hc_wp_grp_size) {
+			pr_err("GP%i partition not HC WP group size "
+			       "aligned\n", pidx+1);
+			return -EINVAL;
+		}
+		gp_size_mult[pidx] = conf->gp_part[pidx].size / mmc->hc_wp_grp_size;
+		if (conf->gp_part[pidx].size && conf->gp_part[pidx].enhanced) {
+			part_attrs |= EXT_CSD_ENH_GP(pidx);
+			tot_enh_size_mult += gp_size_mult[pidx];
+		}
+	}
+
+	if (part_attrs && ! (mmc->part_support & ENHNCD_SUPPORT)) {
+		pr_err("Card does not support enhanced attribute\n");
+		return -EMEDIUMTYPE;
+	}
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err)
+		return err;
+
+	max_enh_size_mult =
+		(ext_csd[EXT_CSD_MAX_ENH_SIZE_MULT+2] << 16) +
+		(ext_csd[EXT_CSD_MAX_ENH_SIZE_MULT+1] << 8) +
+		ext_csd[EXT_CSD_MAX_ENH_SIZE_MULT];
+	if (tot_enh_size_mult > max_enh_size_mult) {
+		pr_err("Total enhanced size exceeds maximum (%u > %u)\n",
+		       tot_enh_size_mult, max_enh_size_mult);
+		return -EMEDIUMTYPE;
+	}
+
+	/* The default value of EXT_CSD_WR_REL_SET is device
+	 * dependent, the values can only be changed if the
+	 * EXT_CSD_HS_CTRL_REL bit is set. The values can be
+	 * changed only once and before partitioning is completed. */
+	wr_rel_set = ext_csd[EXT_CSD_WR_REL_SET];
+	if (conf->user.wr_rel_change) {
+		if (conf->user.wr_rel_set)
+			wr_rel_set |= EXT_CSD_WR_DATA_REL_USR;
+		else
+			wr_rel_set &= ~EXT_CSD_WR_DATA_REL_USR;
+	}
+	for (pidx = 0; pidx < 4; pidx++) {
+		if (conf->gp_part[pidx].wr_rel_change) {
+			if (conf->gp_part[pidx].wr_rel_set)
+				wr_rel_set |= EXT_CSD_WR_DATA_REL_GP(pidx);
+			else
+				wr_rel_set &= ~EXT_CSD_WR_DATA_REL_GP(pidx);
+		}
+	}
+
+	if (wr_rel_set != ext_csd[EXT_CSD_WR_REL_SET] &&
+	    !(ext_csd[EXT_CSD_WR_REL_PARAM] & EXT_CSD_HS_CTRL_REL)) {
+		puts("Card does not support host controlled partition write "
+		     "reliability settings\n");
+		return -EMEDIUMTYPE;
+	}
+
+	if (ext_csd[EXT_CSD_PARTITION_SETTING] &
+	    EXT_CSD_PARTITION_SETTING_COMPLETED) {
+		pr_err("Card already partitioned\n");
+		return -EPERM;
+	}
+
+	if (mode == MMC_HWPART_CONF_CHECK)
+		return 0;
+
+	/* Partitioning requires high-capacity size definitions */
+	if (!(ext_csd[EXT_CSD_ERASE_GROUP_DEF] & 0x01)) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_ERASE_GROUP_DEF, 1);
+
+		if (err)
+			return err;
+
+		ext_csd[EXT_CSD_ERASE_GROUP_DEF] = 1;
+
+		/* update erase group size to be high-capacity */
+		mmc->erase_grp_size =
+			ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 1024;
+	}
+
+	/* all OK, write the configuration */
+	for (i = 0; i < 4; i++) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_ENH_START_ADDR+i,
+				 (enh_start_addr >> (i*8)) & 0xFF);
+		if (err)
+			return err;
+	}
+	for (i = 0; i < 3; i++) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_ENH_SIZE_MULT+i,
+				 (enh_size_mult >> (i*8)) & 0xFF);
+		if (err)
+			return err;
+	}
+	for (pidx = 0; pidx < 4; pidx++) {
+		for (i = 0; i < 3; i++) {
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					 EXT_CSD_GP_SIZE_MULT+pidx*3+i,
+					 (gp_size_mult[pidx] >> (i*8)) & 0xFF);
+			if (err)
+				return err;
+		}
+	}
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_PARTITIONS_ATTRIBUTE, part_attrs);
+	if (err)
+		return err;
+
+	if (mode == MMC_HWPART_CONF_SET)
+		return 0;
+
+	/* The WR_REL_SET is a write-once register but shall be
+	 * written before setting PART_SETTING_COMPLETED. As it is
+	 * write-once we can only write it when completing the
+	 * partitioning. */
+	if (wr_rel_set != ext_csd[EXT_CSD_WR_REL_SET]) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_WR_REL_SET, wr_rel_set);
+		if (err)
+			return err;
+	}
+
+	/* Setting PART_SETTING_COMPLETED confirms the partition
+	 * configuration but it only becomes effective after power
+	 * cycle, so we do not adjust the partition related settings
+	 * in the mmc struct. */
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_PARTITION_SETTING,
+			 EXT_CSD_PARTITION_SETTING_COMPLETED);
+	if (err)
+		return err;
+
+	return 0;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+int mmc_getcd(struct mmc *mmc)
+{
+	int cd;
+
+	cd = board_mmc_getcd(mmc);
+
+	if (cd < 0) {
+		if (mmc->cfg->ops->getcd)
+			cd = mmc->cfg->ops->getcd(mmc);
+		else
+			cd = 1;
+	}
+
+	return cd;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+static int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	/* Switch the frequency */
+	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = (mode << 31) | 0xffffff;
+	cmd.cmdarg &= ~(0xf << (group * 4));
+	cmd.cmdarg |= value << (group * 4);
+
+	data.dest = (char *)resp;
+	data.blocksize = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	return mmc_send_cmd(mmc, &cmd, &data);
+}
+
+static int sd_get_capabilities(struct mmc *mmc)
+{
+	int err;
+	struct mmc_cmd cmd;
+	ALLOC_CACHE_ALIGN_BUFFER(__be32, scr, 2);
+	ALLOC_CACHE_ALIGN_BUFFER(__be32, switch_status, 16);
+	struct mmc_data data;
+	int timeout;
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+	u32 sd3_bus_mode;
+#endif
+
+	mmc->card_caps = MMC_MODE_1BIT | MMC_CAP(SD_LEGACY);
+
+	if (mmc_host_is_spi(mmc))
+		return 0;
+
+	/* Read the SCR to find out if this card supports higher speeds */
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	timeout = 3;
+
+retry_scr:
+	data.dest = (char *)scr;
+	data.blocksize = 8;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	if (err) {
+		if (timeout--)
+			goto retry_scr;
+
+		return err;
+	}
+
+	mmc->scr[0] = __be32_to_cpu(scr[0]);
+	mmc->scr[1] = __be32_to_cpu(scr[1]);
+
+	switch ((mmc->scr[0] >> 24) & 0xf) {
+	case 0:
+		mmc->version = SD_VERSION_1_0;
+		break;
+	case 1:
+		mmc->version = SD_VERSION_1_10;
+		break;
+	case 2:
+		mmc->version = SD_VERSION_2;
+		if ((mmc->scr[0] >> 15) & 0x1)
+			mmc->version = SD_VERSION_3;
+		break;
+	default:
+		mmc->version = SD_VERSION_1_0;
+		break;
+	}
+
+	if (mmc->scr[0] & SD_DATA_4BIT)
+		mmc->card_caps |= MMC_MODE_4BIT;
+
+	/* Version 1.0 doesn't support switching */
+	if (mmc->version == SD_VERSION_1_0)
+		return 0;
+
+	timeout = 4;
+	while (timeout--) {
+		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
+				(u8 *)switch_status);
+
+		if (err)
+			return err;
+
+		/* The high-speed function is busy.  Try again */
+		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
+			break;
+	}
+
+	/* If high-speed isn't supported, we return */
+	if (__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED)
+		mmc->card_caps |= MMC_CAP(SD_HS);
+
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+	/* Version before 3.0 don't support UHS modes */
+	if (mmc->version < SD_VERSION_3)
+		return 0;
+
+	sd3_bus_mode = __be32_to_cpu(switch_status[3]) >> 16 & 0x1f;
+	if (sd3_bus_mode & SD_MODE_UHS_SDR104)
+		mmc->card_caps |= MMC_CAP(UHS_SDR104);
+	if (sd3_bus_mode & SD_MODE_UHS_SDR50)
+		mmc->card_caps |= MMC_CAP(UHS_SDR50);
+	if (sd3_bus_mode & SD_MODE_UHS_SDR25)
+		mmc->card_caps |= MMC_CAP(UHS_SDR25);
+	if (sd3_bus_mode & SD_MODE_UHS_SDR12)
+		mmc->card_caps |= MMC_CAP(UHS_SDR12);
+	if (sd3_bus_mode & SD_MODE_UHS_DDR50)
+		mmc->card_caps |= MMC_CAP(UHS_DDR50);
+#endif
+
+	return 0;
+}
+
+static int sd_set_card_speed(struct mmc *mmc, enum bus_mode mode)
+{
+	int err;
+
+	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
+	int speed;
+
+	/* SD version 1.00 and 1.01 does not support CMD 6 */
+	if (mmc->version == SD_VERSION_1_0)
+		return 0;
+
+	switch (mode) {
+	case SD_LEGACY:
+		speed = UHS_SDR12_BUS_SPEED;
+		break;
+	case SD_HS:
+		speed = HIGH_SPEED_BUS_SPEED;
+		break;
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+	case UHS_SDR12:
+		speed = UHS_SDR12_BUS_SPEED;
+		break;
+	case UHS_SDR25:
+		speed = UHS_SDR25_BUS_SPEED;
+		break;
+	case UHS_SDR50:
+		speed = UHS_SDR50_BUS_SPEED;
+		break;
+	case UHS_DDR50:
+		speed = UHS_DDR50_BUS_SPEED;
+		break;
+	case UHS_SDR104:
+		speed = UHS_SDR104_BUS_SPEED;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, speed, (u8 *)switch_status);
+	if (err)
+		return err;
+
+	if (((__be32_to_cpu(switch_status[4]) >> 24) & 0xF) != speed)
+		return -ENOTSUPP;
+
+	return 0;
+}
+
+static int sd_select_bus_width(struct mmc *mmc, int w)
+{
+	int err;
+	struct mmc_cmd cmd;
+
+	if ((w != 4) && (w != 1))
+		return -EINVAL;
+
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
+	cmd.resp_type = MMC_RSP_R1;
+	if (w == 4)
+		cmd.cmdarg = 2;
+	else if (w == 1)
+		cmd.cmdarg = 0;
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	return 0;
+}
+#endif
+
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+static int sd_read_ssr(struct mmc *mmc)
+{
+	static const unsigned int sd_au_size[] = {
+		0,		SZ_16K / 512,		SZ_32K / 512,
+		SZ_64K / 512,	SZ_128K / 512,		SZ_256K / 512,
+		SZ_512K / 512,	SZ_1M / 512,		SZ_2M / 512,
+		SZ_4M / 512,	SZ_8M / 512,		(SZ_8M + SZ_4M) / 512,
+		SZ_16M / 512,	(SZ_16M + SZ_8M) / 512,	SZ_32M / 512,
+		SZ_64M / 512,
+	};
+	int err, i;
+	struct mmc_cmd cmd;
+	ALLOC_CACHE_ALIGN_BUFFER(uint, ssr, 16);
+	struct mmc_data data;
+	int timeout = 3;
+	unsigned int au, eo, et, es;
+
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SD_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+retry_ssr:
+	data.dest = (char *)ssr;
+	data.blocksize = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err) {
+		if (timeout--)
+			goto retry_ssr;
+
+		return err;
+	}
+
+	for (i = 0; i < 16; i++)
+		ssr[i] = be32_to_cpu(ssr[i]);
+
+	au = (ssr[2] >> 12) & 0xF;
+	if ((au <= 9) || (mmc->version == SD_VERSION_3)) {
+		mmc->ssr.au = sd_au_size[au];
+		es = (ssr[3] >> 24) & 0xFF;
+		es |= (ssr[2] & 0xFF) << 8;
+		et = (ssr[3] >> 18) & 0x3F;
+		if (es && et) {
+			eo = (ssr[3] >> 16) & 0x3;
+			mmc->ssr.erase_timeout = (et * 1000) / es;
+			mmc->ssr.erase_offset = eo * 1000;
+		}
+	} else {
+		pr_debug("Invalid Allocation Unit Size.\n");
+	}
+
+	return 0;
+}
+#endif
+/* frequency bases */
+/* divided by 10 to be nice to platforms without floating point */
+static const int fbase[] = {
+	10000,
+	100000,
+	1000000,
+	10000000,
+};
+
+/* Multiplier values for TRAN_SPEED.  Multiplied by 10 to be nice
+ * to platforms without floating point.
+ */
+static const u8 multipliers[] = {
+	0,	/* reserved */
+	10,
+	12,
+	13,
+	15,
+	20,
+	25,
+	30,
+	35,
+	40,
+	45,
+	50,
+	55,
+	60,
+	70,
+	80,
+};
+
+static inline int bus_width(uint cap)
+{
+	if (cap == MMC_MODE_8BIT)
+		return 8;
+	if (cap == MMC_MODE_4BIT)
+		return 4;
+	if (cap == MMC_MODE_1BIT)
+		return 1;
+	pr_warn("invalid bus witdh capability 0x%x\n", cap);
+	return 0;
+}
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#ifdef MMC_SUPPORTS_TUNING
+static int mmc_execute_tuning(struct mmc *mmc, uint opcode)
+{
+	return -ENOTSUPP;
+}
+#endif
+
+static void mmc_send_init_stream(struct mmc *mmc)
+{
+}
+
+static int mmc_set_ios(struct mmc *mmc)
+{
+	int ret = 0;
+
+	if (mmc->cfg->ops->set_ios)
+		ret = mmc->cfg->ops->set_ios(mmc);
+
+	return ret;
+}
+#endif
+
+int mmc_set_clock(struct mmc *mmc, uint clock, bool disable)
+{
+	if (!disable) {
+		if (clock > mmc->cfg->f_max)
+			clock = mmc->cfg->f_max;
+
+		if (clock < mmc->cfg->f_min)
+			clock = mmc->cfg->f_min;
+	}
+
+	mmc->clock = clock;
+	mmc->clk_disable = disable;
+
+	pr_debug("clock is %s (%dHz)\n",
+			disable ? "disabled" : "enabled", clock);
+
+	return mmc_set_ios(mmc);
+}
+
+static int mmc_set_bus_width(struct mmc *mmc, uint width)
+{
+	mmc->bus_width = width;
+
+	return mmc_set_ios(mmc);
+}
+
+#if CONFIG_IS_ENABLED(MMC_VERBOSE) || defined(DEBUG)
+/*
+ * helper function to display the capabilities in a human
+ * friendly manner. The capabilities include bus width and
+ * supported modes.
+ */
+void mmc_dump_capabilities(const char *text, uint caps)
+{
+	enum bus_mode mode;
+
+	pr_debug("%s: widths [", text);
+	if (caps & MMC_MODE_8BIT)
+		pr_debug("8, ");
+	if (caps & MMC_MODE_4BIT)
+		pr_debug("4, ");
+	if (caps & MMC_MODE_1BIT)
+		pr_debug("1, ");
+	pr_debug("\b\b] modes [");
+	for (mode = MMC_LEGACY; mode < MMC_MODES_END; mode++)
+		if (MMC_CAP(mode) & caps)
+			pr_debug("%s, ", mmc_mode_name(mode));
+	pr_debug("\b\b]\n");
+}
+#endif
+
+struct mode_width_tuning {
+	enum bus_mode mode;
+	uint widths;
+#ifdef MMC_SUPPORTS_TUNING
+	uint tuning;
+#endif
+};
+
+#if CONFIG_IS_ENABLED(MMC_IO_VOLTAGE)
+int mmc_voltage_to_mv(enum mmc_voltage voltage)
+{
+	switch (voltage) {
+	case MMC_SIGNAL_VOLTAGE_000: return 0;
+	case MMC_SIGNAL_VOLTAGE_330: return 3300;
+	case MMC_SIGNAL_VOLTAGE_180: return 1800;
+	case MMC_SIGNAL_VOLTAGE_120: return 1200;
+	}
+	return -EINVAL;
+}
+
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	int err;
+
+	if (mmc->signal_voltage == signal_voltage)
+		return 0;
+
+	mmc->signal_voltage = signal_voltage;
+	err = mmc_set_ios(mmc);
+	if (err)
+		pr_debug("unable to set voltage (err %d)\n", err);
+
+	return err;
+}
+#else
+static inline int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	return 0;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+static const struct mode_width_tuning sd_modes_by_pref[] = {
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef MMC_SUPPORTS_TUNING
+	{
+		.mode = UHS_SDR104,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+		.tuning = MMC_CMD_SEND_TUNING_BLOCK
+	},
+#endif
+	{
+		.mode = UHS_SDR50,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+	},
+	{
+		.mode = UHS_DDR50,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+	},
+	{
+		.mode = UHS_SDR25,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+	},
+#endif
+	{
+		.mode = SD_HS,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+#ifdef MMC_SUPPORTS_TUNING
+		.tuning = MMC_SD_HS_TUNING
+#endif
+	},
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+	{
+		.mode = UHS_SDR12,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+	},
+#endif
+	{
+		.mode = SD_LEGACY,
+		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
+	}
+};
+
+#define for_each_sd_mode_by_pref(caps, mwt) \
+	for (mwt = sd_modes_by_pref;\
+	     mwt < sd_modes_by_pref + ARRAY_SIZE(sd_modes_by_pref);\
+	     mwt++) \
+		if (caps & MMC_CAP(mwt->mode))
+
+static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
+{
+	int err;
+	uint widths[] = {MMC_MODE_4BIT, MMC_MODE_1BIT};
+	const struct mode_width_tuning *mwt;
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+	bool uhs_en = (mmc->ocr & OCR_S18R) ? true : false;
+#else
+	bool uhs_en = false;
+#endif
+	uint caps;
+
+#ifdef DEBUG
+	mmc_dump_capabilities("sd card", card_caps);
+	mmc_dump_capabilities("host", mmc->host_caps);
+#endif
+
+	/* Restrict card's capabilities by what the host can do */
+	caps = card_caps & mmc->host_caps;
+
+	if (!uhs_en)
+		caps &= ~UHS_CAPS;
+
+	for_each_sd_mode_by_pref(caps, mwt) {
+		uint *w;
+
+		for (w = widths; w < widths + ARRAY_SIZE(widths); w++) {
+			if (*w & caps & mwt->widths) {
+				pr_debug("trying mode %s width %d (at %d MHz)\n",
+					 mmc_mode_name(mwt->mode),
+					 bus_width(*w),
+					 mmc_mode2freq(mmc, mwt->mode) / 1000000);
+
+				/* configure the bus width (card + host) */
+				err = sd_select_bus_width(mmc, bus_width(*w));
+				if (err)
+					goto error;
+				mmc_set_bus_width(mmc, bus_width(*w));
+
+				/* configure the bus mode (card) */
+				err = sd_set_card_speed(mmc, mwt->mode);
+				if (err)
+					goto error;
+
+				/* configure the bus mode (host) */
+				mmc_select_mode(mmc, mwt->mode);
+				mmc_set_clock(mmc, mmc->tran_speed,
+						MMC_CLK_ENABLE);
+
+#ifdef MMC_SUPPORTS_TUNING
+				/* execute tuning if needed */
+				if (mwt->tuning && !mmc_host_is_spi(mmc)) {
+					err = mmc_execute_tuning(mmc,
+								 mwt->tuning);
+					if (err) {
+						pr_debug("tuning failed\n");
+						goto error;
+					}
+				}
+#endif
+
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+				err = sd_read_ssr(mmc);
+				if (err)
+					pr_warn("unable to read ssr\n");
+#endif
+				if (!err)
+					return 0;
+
+error:
+				/* revert to a safer bus speed */
+				mmc_select_mode(mmc, SD_LEGACY);
+				mmc_set_clock(mmc, mmc->tran_speed,
+						MMC_CLK_ENABLE);
+			}
+		}
+	}
+
+	pr_err("unable to select a mode\n");
+	return -ENOTSUPP;
+}
+
+/*
+ * read the compare the part of ext csd that is constant.
+ * This can be used to check that the transfer is working
+ * as expected.
+ */
+static int mmc_read_and_compare_ext_csd(struct mmc *mmc)
+{
+	int err;
+	const u8 *ext_csd = mmc->ext_csd;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
+
+	if (mmc->version < MMC_VERSION_4)
+		return 0;
+
+	err = mmc_send_ext_csd(mmc, test_csd);
+	if (err)
+		return err;
+
+	/* Only compare read only fields */
+	if (ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
+		== test_csd[EXT_CSD_PARTITIONING_SUPPORT] &&
+	    ext_csd[EXT_CSD_HC_WP_GRP_SIZE]
+		== test_csd[EXT_CSD_HC_WP_GRP_SIZE] &&
+	    ext_csd[EXT_CSD_REV]
+		== test_csd[EXT_CSD_REV] &&
+	    ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+		== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE] &&
+	    memcmp(&ext_csd[EXT_CSD_SEC_CNT],
+		   &test_csd[EXT_CSD_SEC_CNT], 4) == 0)
+		return 0;
+
+	return -EBADMSG;
+}
+
+#if CONFIG_IS_ENABLED(MMC_IO_VOLTAGE)
+static int mmc_set_lowest_voltage(struct mmc *mmc, enum bus_mode mode,
+				  uint32_t allowed_mask)
+{
+	u32 card_mask = 0;
+
+	switch (mode) {
+	case MMC_HS_400:
+	case MMC_HS_200:
+		if (mmc->cardtype & (EXT_CSD_CARD_TYPE_HS200_1_8V |
+		    EXT_CSD_CARD_TYPE_HS400_1_8V))
+			card_mask |= MMC_SIGNAL_VOLTAGE_180;
+		if (mmc->cardtype & (EXT_CSD_CARD_TYPE_HS200_1_2V |
+		    EXT_CSD_CARD_TYPE_HS400_1_2V))
+			card_mask |= MMC_SIGNAL_VOLTAGE_120;
+		break;
+	case MMC_DDR_52:
+		if (mmc->cardtype & EXT_CSD_CARD_TYPE_DDR_1_8V)
+			card_mask |= MMC_SIGNAL_VOLTAGE_330 |
+				     MMC_SIGNAL_VOLTAGE_180;
+		if (mmc->cardtype & EXT_CSD_CARD_TYPE_DDR_1_2V)
+			card_mask |= MMC_SIGNAL_VOLTAGE_120;
+		break;
+	default:
+		card_mask |= MMC_SIGNAL_VOLTAGE_330;
+		break;
+	}
+
+	while (card_mask & allowed_mask) {
+		enum mmc_voltage best_match;
+
+		best_match = 1 << (ffs(card_mask & allowed_mask) - 1);
+		if (!mmc_set_signal_voltage(mmc,  best_match))
+			return 0;
+
+		allowed_mask &= ~best_match;
+	}
+
+	return -ENOTSUPP;
+}
+#else
+static inline int mmc_set_lowest_voltage(struct mmc *mmc, enum bus_mode mode,
+					 uint32_t allowed_mask)
+{
+	return 0;
+}
+#endif
+
+static const struct mode_width_tuning mmc_modes_by_pref[] = {
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	{
+		.mode = MMC_HS_400,
+		.widths = MMC_MODE_8BIT,
+		.tuning = MMC_CMD_SEND_TUNING_BLOCK_HS200
+	},
+#endif
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+	{
+		.mode = MMC_HS_200,
+		.widths = MMC_MODE_8BIT | MMC_MODE_4BIT,
+		.tuning = MMC_CMD_SEND_TUNING_BLOCK_HS200
+	},
+#endif
+	{
+		.mode = MMC_DDR_52,
+		.widths = MMC_MODE_8BIT | MMC_MODE_4BIT,
+	},
+	{
+		.mode = MMC_HS_52,
+		.widths = MMC_MODE_8BIT | MMC_MODE_4BIT | MMC_MODE_1BIT,
+#ifdef MMC_SUPPORTS_TUNING
+		.tuning = MMC_SD_HS_TUNING
+#endif
+	},
+	{
+		.mode = MMC_HS,
+		.widths = MMC_MODE_8BIT | MMC_MODE_4BIT | MMC_MODE_1BIT,
+	},
+	{
+		.mode = MMC_LEGACY,
+		.widths = MMC_MODE_8BIT | MMC_MODE_4BIT | MMC_MODE_1BIT,
+	}
+};
+
+#define for_each_mmc_mode_by_pref(caps, mwt) \
+	for (mwt = mmc_modes_by_pref;\
+	    mwt < mmc_modes_by_pref + ARRAY_SIZE(mmc_modes_by_pref);\
+	    mwt++) \
+		if (caps & MMC_CAP(mwt->mode))
+
+static const struct ext_csd_bus_width {
+	uint cap;
+	bool is_ddr;
+	uint ext_csd_bits;
+} ext_csd_bus_width[] = {
+	{MMC_MODE_8BIT, true, EXT_CSD_DDR_BUS_WIDTH_8},
+	{MMC_MODE_4BIT, true, EXT_CSD_DDR_BUS_WIDTH_4},
+	{MMC_MODE_8BIT, false, EXT_CSD_BUS_WIDTH_8},
+	{MMC_MODE_4BIT, false, EXT_CSD_BUS_WIDTH_4},
+	{MMC_MODE_1BIT, false, EXT_CSD_BUS_WIDTH_1},
+};
+
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+static int mmc_select_hs400(struct mmc *mmc)
+{
+	int err;
+
+	/* Set timing to HS200 for tuning */
+	err = mmc_set_card_speed(mmc, MMC_HS_200);
+	if (err)
+		return err;
+
+	/* configure the bus mode (host) */
+	mmc_select_mode(mmc, MMC_HS_200);
+	mmc_set_clock(mmc, mmc->tran_speed, false);
+
+	/* execute tuning if needed */
+	err = mmc_execute_tuning(mmc, MMC_CMD_SEND_TUNING_BLOCK_HS200);
+	if (err) {
+		pr_debug("tuning failed\n");
+		return err;
+	}
+
+	/* Set back to HS */
+	mmc_set_card_speed(mmc, MMC_HS);
+	mmc_set_clock(mmc, mmc_mode2freq(mmc, MMC_HS), false);
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BUS_WIDTH,
+			 EXT_CSD_BUS_WIDTH_8 | EXT_CSD_DDR_FLAG);
+	if (err)
+		return err;
+
+	err = mmc_set_card_speed(mmc, MMC_HS_400);
+	if (err)
+		return err;
+
+	mmc_select_mode(mmc, MMC_HS_400);
+	err = mmc_set_clock(mmc, mmc->tran_speed, false);
+	if (err)
+		return err;
+
+	return 0;
+}
+#else
+static int mmc_select_hs400(struct mmc *mmc)
+{
+	return -ENOTSUPP;
+}
+#endif
+
+#define for_each_supported_width(caps, ddr, ecbv) \
+	for (ecbv = ext_csd_bus_width;\
+	    ecbv < ext_csd_bus_width + ARRAY_SIZE(ext_csd_bus_width);\
+	    ecbv++) \
+		if ((ddr == ecbv->is_ddr) && (caps & ecbv->cap))
+
+static int mmc_select_mode_and_width(struct mmc *mmc, uint card_caps)
+{
+	int err;
+	const struct mode_width_tuning *mwt;
+	const struct ext_csd_bus_width *ecbw;
+
+#ifdef DEBUG
+	mmc_dump_capabilities("mmc", card_caps);
+	mmc_dump_capabilities("host", mmc->host_caps);
+#endif
+
+	/* Restrict card's capabilities by what the host can do */
+	card_caps &= mmc->host_caps;
+
+	/* Only version 4 of MMC supports wider bus widths */
+	if (mmc->version < MMC_VERSION_4)
+		return 0;
+
+	if (!mmc->ext_csd) {
+		pr_debug("No ext_csd found!\n"); /* this should enver happen */
+		return -ENOTSUPP;
+	}
+
+	for_each_mmc_mode_by_pref(card_caps, mwt) {
+		for_each_supported_width(card_caps & mwt->widths,
+					 mmc_is_mode_ddr(mwt->mode), ecbw) {
+			enum mmc_voltage old_voltage;
+			pr_debug("trying mode %s width %d (at %d MHz)\n",
+				 mmc_mode_name(mwt->mode),
+				 bus_width(ecbw->cap),
+				 mmc_mode2freq(mmc, mwt->mode) / 1000000);
+			old_voltage = mmc->signal_voltage;
+			err = mmc_set_lowest_voltage(mmc, mwt->mode,
+						     MMC_ALL_SIGNAL_VOLTAGE);
+			if (err)
+				continue;
+
+			/* configure the bus width (card + host) */
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				    EXT_CSD_BUS_WIDTH,
+				    ecbw->ext_csd_bits & ~EXT_CSD_DDR_FLAG);
+			if (err)
+				goto error;
+			mmc_set_bus_width(mmc, bus_width(ecbw->cap));
+
+			if (mwt->mode == MMC_HS_400) {
+				err = mmc_select_hs400(mmc);
+				if (err) {
+					pr_err("Select HS400 failed %d\n", err);
+					goto error;
+				}
+			} else {
+				/* configure the bus speed (card) */
+				err = mmc_set_card_speed(mmc, mwt->mode);
+				if (err)
+					goto error;
+
+				/*
+				 * configure the bus width AND the ddr mode
+				 * (card). The host side will be taken care
+				 * of in the next step
+				 */
+				if (ecbw->ext_csd_bits & EXT_CSD_DDR_FLAG) {
+					err = mmc_switch(mmc,
+							 EXT_CSD_CMD_SET_NORMAL,
+							 EXT_CSD_BUS_WIDTH,
+							 ecbw->ext_csd_bits);
+					if (err)
+						goto error;
+				}
+
+				/* configure the bus mode (host) */
+				mmc_select_mode(mmc, mwt->mode);
+				mmc_set_clock(mmc, mmc->tran_speed,
+					      MMC_CLK_ENABLE);
+#ifdef MMC_SUPPORTS_TUNING
+
+				/* execute tuning if needed */
+				if (mwt->tuning) {
+					err = mmc_execute_tuning(mmc,
+								 mwt->tuning);
+					if (err) {
+						pr_debug("tuning failed\n");
+						goto error;
+					}
+				}
+#endif
+			}
+
+			/* do a transfer to check the configuration */
+			err = mmc_read_and_compare_ext_csd(mmc);
+			if (!err)
+				return 0;
+error:
+			mmc_set_signal_voltage(mmc, old_voltage);
+			/* if an error occured, revert to a safer bus mode */
+			mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				   EXT_CSD_BUS_WIDTH, EXT_CSD_BUS_WIDTH_1);
+			mmc_select_mode(mmc, MMC_LEGACY);
+			mmc_set_bus_width(mmc, 1);
+		}
+	}
+
+	pr_err("unable to select a mode\n");
+
+	return -ENOTSUPP;
+}
+#endif
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+DEFINE_CACHE_ALIGN_BUFFER(u8, ext_csd_bkup, MMC_MAX_BLOCK_LEN);
+#endif
+
+static int mmc_startup_v4(struct mmc *mmc)
+{
+	int err, i;
+	u64 capacity;
+	bool has_parts = false;
+	bool part_completed;
+	static const u32 mmc_versions[] = {
+		MMC_VERSION_4,
+		MMC_VERSION_4_1,
+		MMC_VERSION_4_2,
+		MMC_VERSION_4_3,
+		MMC_VERSION_4_4,
+		MMC_VERSION_4_41,
+		MMC_VERSION_4_5,
+		MMC_VERSION_5_0,
+		MMC_VERSION_5_1
+	};
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+	u8 *ext_csd = ext_csd_bkup;
+
+	if (IS_SD(mmc) || mmc->version < MMC_VERSION_4)
+		return 0;
+
+	if (!mmc->ext_csd)
+		memset(ext_csd_bkup, 0, sizeof(ext_csd_bkup));
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err)
+		goto error;
+
+	/* store the ext csd for future reference */
+	if (!mmc->ext_csd)
+		mmc->ext_csd = ext_csd;
+#else
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	if (IS_SD(mmc) || (mmc->version < MMC_VERSION_4))
+		return 0;
+
+	/* check  ext_csd version and capacity */
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err)
+		goto error;
+
+	/* store the ext csd for future reference */
+	if (!mmc->ext_csd)
+		mmc->ext_csd = malloc(MMC_MAX_BLOCK_LEN);
+	if (!mmc->ext_csd)
+		return -ENOMEM;
+	memcpy(mmc->ext_csd, ext_csd, MMC_MAX_BLOCK_LEN);
+#endif
+	if (ext_csd[EXT_CSD_REV] >= ARRAY_SIZE(mmc_versions))
+		return -EINVAL;
+
+	mmc->version = mmc_versions[ext_csd[EXT_CSD_REV]];
+
+	if (mmc->version >= MMC_VERSION_4_2) {
+		/*
+		 * According to the JEDEC Standard, the value of
+		 * ext_csd's capacity is valid if the value is more
+		 * than 2GB
+		 */
+		capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
+				| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
+				| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
+				| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
+		capacity *= MMC_MAX_BLOCK_LEN;
+		if ((capacity >> 20) > 2 * 1024)
+			mmc->capacity_user = capacity;
+	}
+
+	/* The partition data may be non-zero but it is only
+	 * effective if PARTITION_SETTING_COMPLETED is set in
+	 * EXT_CSD, so ignore any data if this bit is not set,
+	 * except for enabling the high-capacity group size
+	 * definition (see below).
+	 */
+	part_completed = !!(ext_csd[EXT_CSD_PARTITION_SETTING] &
+			    EXT_CSD_PARTITION_SETTING_COMPLETED);
+
+	/* store the partition info of emmc */
+	mmc->part_support = ext_csd[EXT_CSD_PARTITIONING_SUPPORT];
+	if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
+	    ext_csd[EXT_CSD_BOOT_MULT])
+		mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
+	if (part_completed &&
+	    (ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & ENHNCD_SUPPORT))
+		mmc->part_attr = ext_csd[EXT_CSD_PARTITIONS_ATTRIBUTE];
+
+	mmc->capacity_boot = ext_csd[EXT_CSD_BOOT_MULT] << 17;
+
+	mmc->capacity_rpmb = ext_csd[EXT_CSD_RPMB_MULT] << 17;
+
+	for (i = 0; i < 4; i++) {
+		int idx = EXT_CSD_GP_SIZE_MULT + i * 3;
+		uint mult = (ext_csd[idx + 2] << 16) +
+			(ext_csd[idx + 1] << 8) + ext_csd[idx];
+		if (mult)
+			has_parts = true;
+		if (!part_completed)
+			continue;
+		mmc->capacity_gp[i] = mult;
+		mmc->capacity_gp[i] *=
+			ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE];
+		mmc->capacity_gp[i] *= ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+		mmc->capacity_gp[i] <<= 19;
+	}
+
+#ifndef CONFIG_SPL_BUILD
+	if (part_completed) {
+		mmc->enh_user_size =
+			(ext_csd[EXT_CSD_ENH_SIZE_MULT + 2] << 16) +
+			(ext_csd[EXT_CSD_ENH_SIZE_MULT + 1] << 8) +
+			ext_csd[EXT_CSD_ENH_SIZE_MULT];
+		mmc->enh_user_size *= ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE];
+		mmc->enh_user_size *= ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+		mmc->enh_user_size <<= 19;
+		mmc->enh_user_start =
+			(ext_csd[EXT_CSD_ENH_START_ADDR + 3] << 24) +
+			(ext_csd[EXT_CSD_ENH_START_ADDR + 2] << 16) +
+			(ext_csd[EXT_CSD_ENH_START_ADDR + 1] << 8) +
+			ext_csd[EXT_CSD_ENH_START_ADDR];
+		if (mmc->high_capacity)
+			mmc->enh_user_start <<= 9;
+	}
+#endif
+
+	/* dev life time estimate type A/B */
+	mmc->dev_lifetime_est_typ_a
+		= ext_csd[EXT_CSD_DEV_LIFETIME_EST_TYP_A];
+	mmc->dev_lifetime_est_typ_b
+		= ext_csd[EXT_CSD_DEV_LIFETIME_EST_TYP_B];
+
+	/*
+	 * Host needs to enable ERASE_GRP_DEF bit if device is
+	 * partitioned. This bit will be lost every time after a reset
+	 * or power off. This will affect erase size.
+	 */
+	if (part_completed)
+		has_parts = true;
+	if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) &&
+	    (ext_csd[EXT_CSD_PARTITIONS_ATTRIBUTE] & PART_ENH_ATTRIB))
+		has_parts = true;
+	if (has_parts) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_ERASE_GROUP_DEF, 1);
+
+		if (err)
+			goto error;
+
+		ext_csd[EXT_CSD_ERASE_GROUP_DEF] = 1;
+	}
+
+	if (ext_csd[EXT_CSD_ERASE_GROUP_DEF] & 0x01) {
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+		/* Read out group size from ext_csd */
+		mmc->erase_grp_size =
+			ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 1024;
+#endif
+		/*
+		 * if high capacity and partition setting completed
+		 * SEC_COUNT is valid even if it is smaller than 2 GiB
+		 * JEDEC Standard JESD84-B45, 6.2.4
+		 */
+		if (mmc->high_capacity && part_completed) {
+			capacity = (ext_csd[EXT_CSD_SEC_CNT]) |
+				(ext_csd[EXT_CSD_SEC_CNT + 1] << 8) |
+				(ext_csd[EXT_CSD_SEC_CNT + 2] << 16) |
+				(ext_csd[EXT_CSD_SEC_CNT + 3] << 24);
+			capacity *= MMC_MAX_BLOCK_LEN;
+			mmc->capacity_user = capacity;
+		}
+	}
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+	else {
+		/* Calculate the group size from the csd value. */
+		int erase_gsz, erase_gmul;
+		erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
+		erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
+		mmc->erase_grp_size = (erase_gsz + 1)
+			* (erase_gmul + 1);
+	}
+#endif
+#if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
+	mmc->hc_wp_grp_size = 1024
+		* ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+		* ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+#endif
+
+	mmc->wr_rel_set = ext_csd[EXT_CSD_WR_REL_SET];
+
+	return 0;
+error:
+	if (mmc->ext_csd) {
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+		free(mmc->ext_csd);
+#endif
+		mmc->ext_csd = NULL;
+	}
+	return err;
+}
+
+static int mmc_startup(struct mmc *mmc)
+{
+	int err, i;
+	uint mult, freq;
+	u64 cmult, csize;
+	struct mmc_cmd cmd;
+	struct blk_desc *bdesc;
+
+#ifdef CONFIG_MMC_SPI_CRC_ON
+	if (mmc_host_is_spi(mmc)) { /* enable CRC check for spi */
+		cmd.cmdidx = MMC_CMD_SPI_CRC_ON_OFF;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = 1;
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+	}
+#endif
+
+#ifdef CONFIG_MMC_FBOOT
+	if (emmc_boot_chk(mmc)) {
+		mmc_switch_part(mmc, 0);
+
+		/* disSelect the card, and put it into detect Mode */
+		if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
+			cmd.cmdidx = MMC_CMD_SELECT_CARD;
+			cmd.resp_type = MMC_RSP_NONE;
+			cmd.cmdarg = 0;
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+
+			if (err)
+				return err;
+		}
+
+		/* Put the Card in Identify Mode */
+		cmd.cmdidx = MMC_CMD_SEND_CID;
+		cmd.resp_type = MMC_RSP_R2;
+		cmd.cmdarg = mmc->rca << 16;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+
+		memcpy(mmc->cid, cmd.response, 16);
+	} else {
+#endif
+		/* Put the Card in Identify Mode */
+		cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
+			MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
+		cmd.resp_type = MMC_RSP_R2;
+		cmd.cmdarg = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+#ifdef CONFIG_MMC_QUIRKS
+		if (err && (mmc->quirks & MMC_QUIRK_RETRY_SEND_CID)) {
+			int retries = 4;
+			/*
+			 * It has been seen that SEND_CID may fail on the first
+			 * attempt, let's try a few more time
+			 */
+			do {
+				err = mmc_send_cmd(mmc, &cmd, NULL);
+				if (!err)
+					break;
+			} while (retries--);
+		}
+#endif
+
+		if (err)
+			return err;
+
+		memcpy(mmc->cid, cmd.response, 16);
+
+		/*
+		 * For MMC cards, set the Relative Address.
+		 * For SD cards, get the Relatvie Address.
+		 * This also puts the cards into Standby State
+		 */
+		if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
+			cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
+			cmd.cmdarg = mmc->rca << 16;
+			cmd.resp_type = MMC_RSP_R6;
+
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+
+			if (err)
+				return err;
+
+			if (IS_SD(mmc))
+				mmc->rca = (cmd.response[0] >> 16) & 0xffff;
+		}
+#ifdef CONFIG_MMC_FBOOT
+	}
+#endif
+
+	/* Get the Card-Specific Data */
+	cmd.cmdidx = MMC_CMD_SEND_CSD;
+	cmd.resp_type = MMC_RSP_R2;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	mmc->csd[0] = cmd.response[0];
+	mmc->csd[1] = cmd.response[1];
+	mmc->csd[2] = cmd.response[2];
+	mmc->csd[3] = cmd.response[3];
+
+	if (mmc->version == MMC_VERSION_UNKNOWN) {
+		int version = (cmd.response[0] >> 26) & 0xf;
+
+		switch (version) {
+		case 0:
+			mmc->version = MMC_VERSION_1_2;
+			break;
+		case 1:
+			mmc->version = MMC_VERSION_1_4;
+			break;
+		case 2:
+			mmc->version = MMC_VERSION_2_2;
+			break;
+		case 3:
+			mmc->version = MMC_VERSION_3;
+			break;
+		case 4:
+			mmc->version = MMC_VERSION_4;
+			break;
+		default:
+			mmc->version = MMC_VERSION_1_2;
+			break;
+		}
+	}
+
+	/* divide frequency by 10, since the mults are 10x bigger */
+	freq = fbase[(cmd.response[0] & 0x7)];
+	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
+
+	mmc->legacy_speed = freq * mult;
+	mmc_select_mode(mmc, MMC_LEGACY);
+
+	mmc->dsr_imp = ((cmd.response[1] >> 12) & 0x1);
+	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+
+	if (IS_SD(mmc))
+		mmc->write_bl_len = mmc->read_bl_len;
+	else
+		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
+#endif
+
+	if (mmc->high_capacity) {
+		csize = (mmc->csd[1] & 0x3f) << 16
+			| (mmc->csd[2] & 0xffff0000) >> 16;
+		cmult = 8;
+	} else {
+		csize = (mmc->csd[1] & 0x3ff) << 2
+			| (mmc->csd[2] & 0xc0000000) >> 30;
+		cmult = (mmc->csd[2] & 0x00038000) >> 15;
+	}
+
+	mmc->capacity_user = (csize + 1) << (cmult + 2);
+	mmc->capacity_user *= mmc->read_bl_len;
+	mmc->capacity_boot = 0;
+	mmc->capacity_rpmb = 0;
+	for (i = 0; i < 4; i++)
+		mmc->capacity_gp[i] = 0;
+
+	if (mmc->read_bl_len > MMC_MAX_BLOCK_LEN)
+		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
+
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+	if (mmc->write_bl_len > MMC_MAX_BLOCK_LEN)
+		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
+#endif
+
+	if ((mmc->dsr_imp) && (0xffffffff != mmc->dsr)) {
+		cmd.cmdidx = MMC_CMD_SET_DSR;
+		cmd.cmdarg = (mmc->dsr & 0xffff) << 16;
+		cmd.resp_type = MMC_RSP_NONE;
+		if (mmc_send_cmd(mmc, &cmd, NULL))
+			pr_warn("MMC: SET_DSR failed\n");
+	}
+
+	/* Select the card, and put it into Transfer Mode */
+	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
+		cmd.cmdidx = MMC_CMD_SELECT_CARD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = mmc->rca << 16;
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+	}
+
+	/*
+	 * For SD, its erase group is always one sector
+	 */
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+	mmc->erase_grp_size = 1;
+#endif
+	mmc->part_config = MMCPART_NOAVAILABLE;
+
+	err = mmc_startup_v4(mmc);
+	if (err)
+		return err;
+
+	err = mmc_set_capacity(mmc, mmc_get_blk_desc(mmc)->hwpart);
+	if (err)
+		return err;
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+	mmc_set_clock(mmc, mmc->legacy_speed, false);
+	mmc_select_mode(mmc, IS_SD(mmc) ? SD_LEGACY : MMC_LEGACY);
+	mmc_set_bus_width(mmc, 1);
+#else
+	if (IS_SD(mmc)) {
+		err = sd_get_capabilities(mmc);
+		if (err)
+			return err;
+		err = sd_select_mode_and_width(mmc, mmc->card_caps);
+	} else {
+		err = mmc_get_capabilities(mmc);
+		if (err)
+			return err;
+		mmc_select_mode_and_width(mmc, mmc->card_caps);
+	}
+#endif
+	if (err)
+		return err;
+
+	mmc->best_mode = mmc->selected_mode;
+
+	/* Fix the block length for DDR mode */
+	if (mmc->ddr_mode) {
+		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
+#endif
+	}
+
+	/* fill in device description */
+	bdesc = mmc_get_blk_desc(mmc);
+	bdesc->lun = 0;
+	bdesc->hwpart = 0;
+	bdesc->type = 0;
+	bdesc->blksz = mmc->read_bl_len;
+	bdesc->log2blksz = LOG2(bdesc->blksz);
+	bdesc->lba = lldiv(mmc->capacity, mmc->read_bl_len);
+#if !defined(CONFIG_SPL_BUILD) || \
+		(defined(CONFIG_SPL_LIBCOMMON_SUPPORT) && \
+		!defined(CONFIG_USE_TINY_PRINTF))
+	sprintf(bdesc->vendor, "Man %06x Snr %04x%04x",
+		mmc->cid[0] >> 24, (mmc->cid[2] & 0xffff),
+		(mmc->cid[3] >> 16) & 0xffff);
+	sprintf(bdesc->product, "%c%c%c%c%c%c", mmc->cid[0] & 0xff,
+		(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
+		(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff,
+		(mmc->cid[2] >> 24) & 0xff);
+	sprintf(bdesc->revision, "%d.%d", (mmc->cid[2] >> 20) & 0xf,
+		(mmc->cid[2] >> 16) & 0xf);
+#else
+	bdesc->vendor[0] = 0;
+	bdesc->product[0] = 0;
+	bdesc->revision[0] = 0;
+#endif
+
+#if !defined(CONFIG_DM_MMC) && (!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT))
+	part_init(bdesc);
+#endif
+
+	return 0;
+}
+
+static int mmc_send_if_cond(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	cmd.cmdidx = SD_CMD_SEND_IF_COND;
+	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
+	cmd.cmdarg = ((mmc->cfg->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	cmd.resp_type = MMC_RSP_R7;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	if ((cmd.response[0] & 0xff) != 0xaa)
+		return -EOPNOTSUPP;
+	else
+		mmc->version = SD_VERSION_2;
+
+	return 0;
+}
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+/* board-specific MMC power initializations. */
+__weak void board_mmc_power_init(void)
+{
+}
+#endif
+
+static int mmc_power_init(struct mmc *mmc)
+{
+#if CONFIG_IS_ENABLED(DM_MMC)
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
+	int ret;
+
+	ret = device_get_supply_regulator(mmc->dev, "vmmc-supply",
+					  &mmc->vmmc_supply);
+	if (ret)
+		pr_debug("%s: No vmmc supply\n", mmc->dev->name);
+
+	ret = device_get_supply_regulator(mmc->dev, "vqmmc-supply",
+					  &mmc->vqmmc_supply);
+	if (ret)
+		pr_debug("%s: No vqmmc supply\n", mmc->dev->name);
+#endif
+#else /* !CONFIG_DM_MMC */
+	/*
+	 * Driver model should use a regulator, as above, rather than calling
+	 * out to board code.
+	 */
+	board_mmc_power_init();
+#endif
+	return 0;
+}
+
+/*
+ * put the host in the initial state:
+ * - turn on Vdd (card power supply)
+ * - configure the bus width and clock to minimal values
+ */
+static void mmc_set_initial_state(struct mmc *mmc)
+{
+	int err;
+
+	/* First try to set 3.3V. If it fails set to 1.8V */
+	err = mmc_set_signal_voltage(mmc, MMC_SIGNAL_VOLTAGE_330);
+	if (err != 0)
+		err = mmc_set_signal_voltage(mmc, MMC_SIGNAL_VOLTAGE_180);
+	if (err != 0)
+		pr_warn("mmc: failed to set signal voltage\n");
+
+	mmc_select_mode(mmc, MMC_LEGACY);
+	mmc_set_bus_width(mmc, 1);
+	mmc_set_clock(mmc, 0, MMC_CLK_ENABLE);
+}
+
+static int mmc_power_on(struct mmc *mmc)
+{
+#if CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(DM_REGULATOR)
+	if (mmc->vmmc_supply) {
+		int ret = regulator_set_enable(mmc->vmmc_supply, true);
+
+		if (ret) {
+			puts("Error enabling VMMC supply\n");
+			return ret;
+		}
+	}
+#endif
+	return 0;
+}
+
+static int mmc_power_off(struct mmc *mmc)
+{
+	mmc_set_clock(mmc, 0, MMC_CLK_DISABLE);
+#if CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(DM_REGULATOR)
+	if (mmc->vmmc_supply) {
+		int ret = regulator_set_enable(mmc->vmmc_supply, false);
+
+		if (ret) {
+			pr_debug("Error disabling VMMC supply\n");
+			return ret;
+		}
+	}
+#endif
+	return 0;
+}
+
+static int mmc_power_cycle(struct mmc *mmc)
+{
+	int ret;
+
+	ret = mmc_power_off(mmc);
+	if (ret)
+		return ret;
+	/*
+	 * SD spec recommends at least 1ms of delay. Let's wait for 2ms
+	 * to be on the safer side.
+	 */
+	udelay(2000);
+	return mmc_power_on(mmc);
+}
+
+int mmc_get_op_cond(struct mmc *mmc)
+{
+	bool uhs_en = supports_uhs(mmc->cfg->host_caps);
+	int err;
+
+	if (mmc->has_init)
+		return 0;
+
+#ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
+	mmc_adapter_card_type_ident();
+#endif
+	err = mmc_power_init(mmc);
+	if (err)
+		return err;
+
+#ifdef CONFIG_MMC_QUIRKS
+	mmc->quirks = MMC_QUIRK_RETRY_SET_BLOCKLEN |
+		      MMC_QUIRK_RETRY_SEND_CID;
+#endif
+
+	err = mmc_power_cycle(mmc);
+	if (err) {
+		/*
+		 * if power cycling is not supported, we should not try
+		 * to use the UHS modes, because we wouldn't be able to
+		 * recover from an error during the UHS initialization.
+		 */
+		pr_debug("Unable to do a full power cycle. Disabling the UHS modes for safety\n");
+		uhs_en = false;
+		mmc->host_caps &= ~UHS_CAPS;
+		err = mmc_power_on(mmc);
+	}
+	if (err)
+		return err;
+
+#if CONFIG_IS_ENABLED(DM_MMC)
+	/* The device has already been probed ready for use */
+#else
+	/* made sure it's not NULL earlier */
+	err = mmc->cfg->ops->init(mmc);
+	if (err)
+		return err;
+#endif
+	mmc->ddr_mode = 0;
+
+retry:
+	mmc_set_initial_state(mmc);
+	mmc_send_init_stream(mmc);
+
+	/* Reset the Card */
+	err = mmc_go_idle(mmc);
+	if (err)
+		return err;
+
+	/* The internal partition reset to user partition(0) at every CMD0*/
+	mmc_get_blk_desc(mmc)->hwpart = 0;
+
+	/* Test for SD version 2 */
+	err = mmc_send_if_cond(mmc);
+
+	/* Now try to get the SD card's operating condition */
+	err = sd_send_op_cond(mmc, uhs_en);
+	if (err && uhs_en) {
+		uhs_en = false;
+		mmc_power_cycle(mmc);
+		goto retry;
+	}
+
+	/* If the command timed out, we check for an MMC card */
+	if (err == -ETIMEDOUT) {
+		err = mmc_send_op_cond(mmc);
+
+		if (err) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+			pr_err("Card did not respond to voltage select!\n");
+#endif
+			return -EOPNOTSUPP;
+		}
+	}
+
+	return err;
+}
+
+int mmc_start_init(struct mmc *mmc)
+{
+	bool no_card;
+	int err = 0;
+
+	/*
+	 * all hosts are capable of 1 bit bus-width and able to use the legacy
+	 * timings.
+	 */
+	mmc->host_caps = mmc->cfg->host_caps | MMC_CAP(SD_LEGACY) |
+			 MMC_CAP(MMC_LEGACY) | MMC_MODE_1BIT;
+
+#if !defined(CONFIG_MMC_BROKEN_CD)
+	/* we pretend there's no card when init is NULL */
+	no_card = mmc_getcd(mmc) == 0;
+#else
+	no_card = 0;
+#endif
+#if !CONFIG_IS_ENABLED(DM_MMC)
+	no_card = no_card || (mmc->cfg->ops->init == NULL);
+#endif
+	if (no_card) {
+		mmc->has_init = 0;
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+		pr_err("MMC: no card present\n");
+#endif
+		return -ENOMEDIUM;
+	}
+
+#ifdef CONFIG_MMC_FBOOT
+	if (emmc_boot_chk(mmc)) {
+		mmc->high_capacity = 1;
+		mmc->rca = 1;
+		mmc->version = MMC_VERSION_UNKNOWN;
+	} else
+#endif
+		err = mmc_get_op_cond(mmc);
+
+	if (!err)
+		mmc->init_in_progress = 1;
+
+	return err;
+}
+
+static int mmc_complete_init(struct mmc *mmc)
+{
+	int err = 0;
+
+	mmc->init_in_progress = 0;
+	if (mmc->op_cond_pending)
+		err = mmc_complete_op_cond(mmc);
+
+	if (!err)
+		err = mmc_startup(mmc);
+	if (err)
+		mmc->has_init = 0;
+	else
+		mmc->has_init = 1;
+	return err;
+}
+
+void mmc_write_cali_mattern(void *addr, struct aml_pattern *table)
+{
+	int i = 0;
+	unsigned int s = 10;
+	u32 *mattern = (u32 *)addr;
+	struct virtual_partition *vpart =
+		aml_get_virtual_partition_by_name(table->name);
+	for (i = 0;i < (vpart->size)/4 - 1;i++) {
+		if (!strcmp(table->name, "random"))
+			mattern[i] = rand_r(&s);
+		else
+			mattern[i] = table->pattern;
+	}
+	mattern[i] = crc32(0, (u8 *)addr, (vpart->size - 4));
+	return;
+}
+
+int mmc_pattern_check(struct mmc *mmc, struct aml_pattern *table)
+{
+	void *addr = NULL;
+	u64 cnt = 0, n = 0, blk = 0;
+	u32 *buf = NULL;
+	u32 crc32_s = 0;
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+
+	vpart = aml_get_virtual_partition_by_name(table->name);
+
+	addr = (void *)malloc(vpart->size);
+	if (!addr) {
+		printf("%s malloc failed\n", table->name);
+		return 1;
+	}
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	blk = (part->offset + vpart->offset) / mmc->read_bl_len;
+	cnt = vpart->size / mmc->read_bl_len;
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if (n != cnt) {
+		printf("read pattern failed\n");
+		free(addr);
+		return 1;
+	} else {
+		buf = (u32 *)addr;
+		crc32_s = crc32(0, (u8 *)addr, (vpart->size - 4));
+		if (crc32_s != buf[vpart->size/4 - 1]) {
+			printf("check %s failed,need to write\n",
+						table->name);
+			mmc_write_cali_mattern(addr, table);
+			n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+			printf("several 0x%x pattern blocks write %s\n",
+				table->pattern, (n == cnt) ? "OK" : "ERROR");
+		}
+		printf("crc32_s:0x%x == storage crc_pattern:0x%x!!!\n",
+				crc32_s, buf[vpart->size/4 - 1]);
+	}
+	free(addr);
+	return (n == cnt) ? 0 : 1;
+}
+
+int mmc_init(struct mmc *mmc)
+{
+	int err = 0, i;
+	__maybe_unused ulong start;
+#if CONFIG_IS_ENABLED(DM_MMC)
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(mmc->dev);
+
+	upriv->mmc = mmc;
+#endif
+	if (mmc->has_init)
+		return 0;
+
+	start = get_timer(0);
+
+	if (!mmc->init_in_progress)
+		err = mmc_start_init(mmc);
+
+	if (!err)
+		err = mmc_complete_init(mmc);
+	if (err)
+		pr_info("%s: %d, time %lu\n", __func__, err, get_timer(start));
+	info_disprotect |= DISPROTECT_KEY;
+	if (IS_MMC(mmc)) {
+		if (!is_partition_checked) {
+			if (mmc_device_init(mmc) == 0) {
+				is_partition_checked = true;
+				pr_info("eMMC/TSD partition table have been checked OK!\n");
+				for (i = 0; i < ARRAY_SIZE(aml_pattern_table); i++)
+					mmc_pattern_check(mmc, &aml_pattern_table[i]);
+			}
+		}
+	}
+	info_disprotect &= ~DISPROTECT_KEY;
+	return err;
+
+}
+
+ulong mmc_ffu_write(int dev_num, lbaint_t start, lbaint_t blkcnt, const void *src)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int ret, timeout = 1000;
+	struct mmc *mmc = find_mmc_device(dev_num);
+	if (!mmc || !blkcnt)
+		return 0;
+
+	printf("mmc ffu start = %lx, cnt = %lx, addr = %p\n", start, blkcnt, src);
+
+	cmd.cmdidx = MMC_CMD_SET_BLOCK_COUNT;
+	cmd.cmdarg = blkcnt & 0xFFFF;
+	cmd.resp_type = MMC_RSP_R1;
+	ret = mmc_send_cmd(mmc, &cmd, NULL);
+	if (ret) {
+		printf("mmc set blkcnt failed\n");
+		return 0;
+	}
+
+	cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
+	cmd.cmdarg = start;
+	cmd.resp_type = MMC_RSP_R1b;
+
+	data.src = src;
+	data.blocks = blkcnt;
+	data.blocksize = mmc->write_bl_len;
+	data.flags = MMC_DATA_WRITE;
+
+	ret = mmc_send_cmd(mmc, &cmd, &data);
+	if (ret) {
+		printf("mmc write failed\n");
+		return 0;
+	}
+
+	/* Waiting for the ready status */
+	if (mmc_send_status(mmc, timeout))
+		return 0;
+
+	return blkcnt;
+}
+
+int mmc_ffu_op(int dev, u64 ffu_ver, void *addr, u64 cnt)
+{
+	int err, i, supported_modes, fw_cfg, ffu_status;
+	u64 fw_ver = 0, n;
+	u8 ext_csd_ffu[512] = {0};
+	lbaint_t ffu_addr=0;
+	struct mmc *mmc = find_mmc_device(dev);
+	if (!mmc)
+		return -ENODEV;
+
+	printf("ffu update start\n");
+	/* check Manufacturer MID */
+	if ((mmc->cid[0] >> 24) == SAMSUNG_MID) {
+		ffu_addr = SAMSUNG_FFU_ADDR;
+	} else if ((mmc->cid[0] >> 24) == KINGSTON_MID) {
+		ffu_addr = KINGSTON_FFU_ADDR;
+	} else if ((mmc->cid[0] >> 24) == BIWIN_MID) {
+		ffu_addr = BIWIN_FFU_ADDR;
+	} else {
+		printf("FFU update for this manufacturer not support yet\n");
+		return -1;
+	}
+
+	/*
+	 * check FFU Supportability
+	 * check FFU Prohibited or not
+	 * check current firmware version
+	 */
+	memset(ext_csd_ffu, 0, 512);
+	err = mmc_get_ext_csd(mmc, ext_csd_ffu);
+	if (err)
+		return err;
+
+	supported_modes = ext_csd_ffu[EXT_CSD_SUPPORTED_MODES] & 0x1;
+	fw_cfg = ext_csd_ffu[EXT_CSD_FW_CFG] & 0x1;
+	for (i = 0; i < 8; i++) {
+		fw_ver |= ext_csd_ffu[EXT_CSD_FW_VERSION + 7 - i];
+		if (i < 7)
+			fw_ver <<= 8;
+	}
+	if ((mmc->cid[0] >> 24) == BIWIN_MID)
+		fw_ver = ((fw_ver >> 16) & 0xffffffff);
+	printf("old fw_ver = %llx\n", fw_ver);
+	if (!supported_modes || fw_cfg || (fw_ver >= ffu_ver))
+		return -1;
+
+	/* Set FFU Mode */
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_MODE_CFG, 1);
+	if (err) {
+		printf("Failed: set FFU mode\n");
+		return err;
+	}
+
+	/* Write patch file at one write command */
+	n = mmc_ffu_write(dev, ffu_addr, cnt, addr);
+	if (n != cnt) {
+		printf("target is %llx block, but only %llx block has been write\n", cnt, n);
+		return -1;
+	}
+
+	memset(ext_csd_ffu, 0, 512);
+	err = mmc_get_ext_csd(mmc, ext_csd_ffu);
+	if (err)
+		return err;
+
+	for (i = 0; i < 8; i++) {
+		fw_ver |= ext_csd_ffu[EXT_CSD_FW_VERSION + 7 - i];
+		if (i < 7)
+			fw_ver <<= 8;
+	}
+	if ((mmc->cid[0] >> 24) == BIWIN_MID)
+		fw_ver = ((fw_ver >> 16) & 0xffffffff);
+	printf("new fw_ver = %llx\n", fw_ver);
+	if ((mmc->cid[0] >> 24) == SAMSUNG_MID) {
+		/* Set Normal Mode */
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_MODE_CFG, 0);
+		if (err)
+			return err;
+	}
+
+	/* reset devices */
+	err = mmc_go_idle(mmc);
+	if (err)
+		return err;
+
+	/* Initialization */
+	mmc->has_init = 0;
+	err = mmc_init(mmc);
+	if (err)
+		return err;
+
+	/* Read ffu_status, check ffu_version */
+	memset(ext_csd_ffu, 0, 512);
+	err = mmc_get_ext_csd(mmc, ext_csd_ffu);
+	if (err)
+		return err;
+	ffu_status = ext_csd_ffu[EXT_CSD_FFU_STATUS] & 0xff;
+	fw_ver = 0;
+	for (i = 0; i < 8; i++) {
+		fw_ver |= ext_csd_ffu[EXT_CSD_FW_VERSION + 7 - i];
+		if (i < 7)
+			fw_ver <<= 8;
+	}
+	if ((mmc->cid[0] >> 24) == BIWIN_MID)
+		fw_ver = ((fw_ver >> 16) & 0xffffffff);
+	printf("new fw_ver = %llx\n", fw_ver);
+	if (ffu_status || (fw_ver != ffu_ver))
+		return ffu_status;
+
+	printf("FFU update ok!\n");
+	return 0;
+}
+
+int mmc_set_dsr(struct mmc *mmc, u16 val)
+{
+	mmc->dsr = val;
+	return 0;
+}
+
+/* CPU-specific MMC initializations */
+__weak int cpu_mmc_init(bd_t *bis)
+{
+	return -1;
+}
+
+/* board-specific MMC initializations. */
+__weak int board_mmc_init(bd_t *bis)
+{
+	return -1;
+}
+
+void mmc_set_preinit(struct mmc *mmc, int preinit)
+{
+	mmc->preinit = preinit;
+}
+
+#if CONFIG_IS_ENABLED(DM_MMC)
+static int mmc_probe(bd_t *bis)
+{
+	int ret, i;
+	struct uclass *uc;
+	struct udevice *dev;
+
+	ret = uclass_get(UCLASS_MMC, &uc);
+	if (ret)
+		return ret;
+
+	/*
+	 * Try to add them in sequence order. Really with driver model we
+	 * should allow holes, but the current MMC list does not allow that.
+	 * So if we request 0, 1, 3 we will get 0, 1, 2.
+	 */
+	for (i = 0; ; i++) {
+		ret = uclass_get_device_by_seq(UCLASS_MMC, i, &dev);
+		if (ret == -ENODEV)
+			break;
+	}
+	uclass_foreach_dev(dev, uc) {
+		ret = device_probe(dev);
+		if (ret)
+			pr_err("%s - probe failed: %d\n", dev->name, ret);
+	}
+
+	return 0;
+}
+#else
+static int mmc_probe(bd_t *bis)
+{
+	if (board_mmc_init(bis) < 0)
+		cpu_mmc_init(bis);
+
+	return 0;
+}
+#endif
+
+int mmc_initialize(bd_t *bis)
+{
+	static int initialized = 0;
+	int ret;
+	if (initialized)	/* Avoid initializing mmc multiple times */
+		return 0;
+	initialized = 1;
+
+#if !CONFIG_IS_ENABLED(BLK)
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+	mmc_list_init();
+#endif
+#endif
+	ret = mmc_probe(bis);
+	if (ret)
+		return ret;
+
+#ifndef CONFIG_SPL_BUILD
+	//print_mmc_devices(',');
+#endif
+
+	mmc_do_preinit();
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BKOPS_ENABLE
+int mmc_set_bkops_enable(struct mmc *mmc)
+{
+	int err;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err) {
+		puts("Could not get ext_csd register values\n");
+		return err;
+	}
+
+	if (!(ext_csd[EXT_CSD_BKOPS_SUPPORT] & 0x1)) {
+		puts("Background operations not supported on device\n");
+		return -EMEDIUMTYPE;
+	}
+
+	if (ext_csd[EXT_CSD_BKOPS_EN] & 0x1) {
+		puts("Background operations already enabled\n");
+		return 0;
+	}
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BKOPS_EN, 1);
+	if (err) {
+		puts("Failed to enable manual background operations\n");
+		return err;
+	}
+
+	puts("Enabled manual background operations\n");
+
+	return 0;
+}
+#endif
+
+extern unsigned long blk_dwrite(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt, const void *buffer);
+
+int mmc_key_write(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
+{
+	ulong start, start_blk, blkcnt, ret;
+	unsigned char * temp_buf = buf;
+	int i = 2, dev = EMMC_DTB_DEV;
+	struct partitions * part = NULL;
+	struct mmc *mmc;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	mmc = find_mmc_device(dev);
+
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	info_disprotect |= DISPROTECT_KEY;
+	do {
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), start_blk, blkcnt, temp_buf);
+		if (ret != blkcnt) {
+			pr_err("[%s] %d, mmc_bwrite error\n",
+				__func__, __LINE__);
+			return 1;
+		}
+		start_blk += vpart->size / MMC_BLOCK_SIZE;
+	} while (--i);
+	info_disprotect &= ~DISPROTECT_KEY;
+	return 0;
+}
+
+
+
+
+extern unsigned long blk_derase(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt);
+
+int mmc_key_erase(void)
+{
+	ulong start, start_blk, blkcnt, ret;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	struct mmc *mmc;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	int dev = EMMC_DTB_DEV;
+
+	mmc = find_mmc_device(dev);
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (vpart->size / MMC_BLOCK_SIZE) * 2;//key and backup key
+	info_disprotect |= DISPROTECT_KEY;
+	ret = blk_derase(mmc_get_blk_desc(mmc), start_blk, blkcnt);
+	info_disprotect &= ~DISPROTECT_KEY;
+	if (ret) {
+		pr_err("[%s] %d mmc_berase error\n",
+				__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+int mmc_key_read(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
+{
+	ulong start, start_blk, blkcnt, ret;
+	int dev = EMMC_DTB_DEV;
+	unsigned char *temp_buf = buf;
+	struct partitions * part = NULL;
+	struct mmc *mmc;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	mmc = find_mmc_device(dev);
+	*actual_lenth =  0x40000;/*key size is 256KB*/
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	info_disprotect |= DISPROTECT_KEY;
+	ret = blk_dread(mmc_get_blk_desc(mmc), start_blk, blkcnt, temp_buf);
+	info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != blkcnt) {
+		pr_err("[%s] %d, mmc_bread error\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+
diff --git a/drivers/mmc/mmc_aml.c b/drivers/mmc/mmc_aml.c
new file mode 100644
index 0000000000..a9b0ff780f
--- /dev/null
+++ b/drivers/mmc/mmc_aml.c
@@ -0,0 +1,416 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2008, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the Linux code
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <errno.h>
+#include <mmc.h>
+#include <part.h>
+#include <power/regulator.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <linux/list.h>
+#include <linux/crc32.h>
+#include <rand.h>
+#include <div64.h>
+#include "mmc_private.h"
+#include <amlstorage/emmc_partitions.h>
+#include <amlstorage/partition_table.h>
+#include <amlogic/storage.h>
+#include <amlogic/asm/secure_apb.h>
+#include <amlogic/asm/sd_emmc.h>
+
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
+
+extern int emmc_probe(uint32_t init_flag);
+
+bool emmckey_is_access_range_legal (struct mmc *mmc, ulong start, lbaint_t blkcnt) {
+	ulong key_start_blk, key_end_blk;
+	u64 key_glb_offset;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	if (IS_MMC(mmc)) {
+		vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+		part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+		key_glb_offset = part->offset + vpart->offset;
+		key_start_blk = (key_glb_offset / MMC_BLOCK_SIZE);
+		key_end_blk = ((key_glb_offset + vpart->size) / MMC_BLOCK_SIZE - 1);
+		if (!(info_disprotect & DISPROTECT_KEY)) {
+			if ((key_start_blk <= (start + blkcnt -1))
+				&& (key_end_blk >= start)
+				&& (blkcnt != start)) {
+				pr_info("%s, keys %ld, keye %ld, start %ld, blkcnt %ld\n",
+						mmc->cfg->name, key_start_blk,
+						key_end_blk, start, blkcnt);
+				pr_err("Emmckey: Access range is illegal!\n");
+				return 0;
+			}
+		}
+	}
+	return 1;
+}
+
+int emmc_boot_chk(struct mmc *mmc)
+{
+	u32 val = 0;
+
+	if (strcmp(mmc->dev->name, "emmc"))
+		return 0;
+
+	val = readl(SEC_AO_SEC_GP_CFG0);
+	pr_info("SEC_AO_SEC_GP_CFG0 = %x\n", val);
+	if ((val & 0xf) == 0x1)
+		return 1;
+
+	return 0;
+}
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+static struct mmc mmc_static;
+struct mmc *find_mmc_device(int dev_num)
+{
+	return &mmc_static;
+}
+
+void mmc_do_preinit(void)
+{
+	struct mmc *m = &mmc_static;
+#ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
+	mmc_set_preinit(m, 1);
+#endif
+	if (m->preinit)
+		mmc_start_init(m);
+}
+
+struct blk_desc *mmc_get_blk_desc(struct mmc *mmc)
+{
+	return &mmc->block_dev;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+static int mmc_wait_dat0(struct mmc *mmc, int state, int timeout)
+{
+	return -ENOSYS;
+}
+#endif
+
+__weak int board_mmc_getwp(struct mmc *mmc)
+{
+	return -1;
+}
+
+int mmc_getwp(struct mmc *mmc)
+{
+	int wp;
+
+	wp = board_mmc_getwp(mmc);
+
+	if (wp < 0) {
+		if (mmc->cfg->ops->getwp)
+			wp = mmc->cfg->ops->getwp(mmc);
+		else
+			wp = 0;
+	}
+
+	return wp;
+}
+
+__weak int board_mmc_getcd(struct mmc *mmc)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_MMC_TRACE
+void mmmc_trace_before_send(struct mmc *mmc, struct mmc_cmd *cmd)
+{
+	pr_info("CMD_SEND:%d\n", cmd->cmdidx);
+	pr_info("\t\tARG\t\t\t 0x%08X\n", cmd->cmdarg);
+}
+
+void mmmc_trace_after_send(struct mmc *mmc, struct mmc_cmd *cmd, int ret)
+{
+	int i;
+	u8 *ptr;
+
+	if (ret) {
+		pr_info("\t\tRET\t\t\t %d\n", ret);
+	} else {
+		switch (cmd->resp_type) {
+		case MMC_RSP_NONE:
+			pr_info("\t\tMMC_RSP_NONE\n");
+			break;
+		case MMC_RSP_R1:
+			pr_info("\t\tMMC_RSP_R1,5,6,7 \t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		case MMC_RSP_R1b:
+			pr_info("\t\tMMC_RSP_R1b\t\t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		case MMC_RSP_R2:
+			pr_info("\t\tMMC_RSP_R2\t\t 0x%08X \n",
+				cmd->response[0]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[1]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[2]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[3]);
+			pr_info("\n");
+			pr_info("\t\t\t\t\tDUMPING DATA\n");
+			for (i = 0; i < 4; i++) {
+				int j;
+				pr_info("\t\t\t\t\t%03d - ", i*4);
+				ptr = (u8 *)&cmd->response[i];
+				ptr += 3;
+				for (j = 0; j < 4; j++)
+					pr_info("%02X ", *ptr--);
+				pr_info("\n");
+			}
+			break;
+		case MMC_RSP_R3:
+			pr_info("\t\tMMC_RSP_R3,4\t\t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		default:
+			pr_info("\t\tERROR MMC rsp not supported\n");
+			break;
+		}
+	}
+}
+
+#endif
+
+int mmc_get_ext_csd(struct mmc *mmc, u8 *ext_csd)
+{
+	return mmc_send_ext_csd(mmc, ext_csd);
+}
+
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+u8 ext_csd_w[] = {191, 187, 185, 183, 179, 178, 177, 175,
+					173, 171, 169, 167, 165, 164, 163, 162,
+					161, 156, 155, 143, 140, 136, 134, 133,
+					132, 131, 62, 59, 56, 52, 37, 34,
+					33, 32, 31, 30, 29, 22, 17, 16, 15};
+
+int mmc_set_ext_csd(struct mmc *mmc, u8 index, u8 value)
+{
+	int ret = -21, i;
+
+	for (i = 0; i < sizeof(ext_csd_w); i++) {
+		if (ext_csd_w[i] == index)
+			break;
+	}
+	if (i != sizeof(ext_csd_w))
+		ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, index, value);
+
+	return ret;
+}
+
+
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#ifdef MMC_SUPPORTS_TUNING
+static int mmc_execute_tuning(struct mmc *mmc, uint opcode)
+{
+	return -ENOTSUPP;
+}
+#endif
+
+static int mmc_set_ios(struct mmc *mmc)
+{
+	int ret = 0;
+
+	if (mmc->cfg->ops->set_ios)
+		ret = mmc->cfg->ops->set_ios(mmc);
+
+	return ret;
+}
+#endif
+
+struct mode_width_tuning {
+	enum bus_mode mode;
+	uint widths;
+#ifdef MMC_SUPPORTS_TUNING
+	uint tuning;
+#endif
+};
+
+#if CONFIG_IS_ENABLED(MMC_IO_VOLTAGE)
+int mmc_voltage_to_mv(enum mmc_voltage voltage)
+{
+	switch (voltage) {
+	case MMC_SIGNAL_VOLTAGE_000: return 0;
+	case MMC_SIGNAL_VOLTAGE_330: return 3300;
+	case MMC_SIGNAL_VOLTAGE_180: return 1800;
+	case MMC_SIGNAL_VOLTAGE_120: return 1200;
+	}
+	return -EINVAL;
+}
+
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	int err;
+
+	if (mmc->signal_voltage == signal_voltage)
+		return 0;
+
+	mmc->signal_voltage = signal_voltage;
+	err = mmc_set_ios(mmc);
+	if (err)
+		pr_debug("unable to set voltage (err %d)\n", err);
+
+	return err;
+}
+#else
+static inline int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	return 0;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+/* board-specific MMC power initializations. */
+__weak void board_mmc_power_init(void)
+{
+}
+#endif
+
+#ifdef CONFIG_CMD_BKOPS_ENABLE
+int mmc_set_bkops_enable(struct mmc *mmc)
+{
+	int err;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err) {
+		puts("Could not get ext_csd register values\n");
+		return err;
+	}
+
+	if (!(ext_csd[EXT_CSD_BKOPS_SUPPORT] & 0x1)) {
+		puts("Background operations not supported on device\n");
+		return -EMEDIUMTYPE;
+	}
+
+	if (ext_csd[EXT_CSD_BKOPS_EN] & 0x1) {
+		puts("Background operations already enabled\n");
+		return 0;
+	}
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BKOPS_EN, 1);
+	if (err) {
+		puts("Failed to enable manual background operations\n");
+		return err;
+	}
+
+	puts("Enabled manual background operations\n");
+
+	return 0;
+}
+#endif
+
+extern unsigned long blk_dwrite(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt, const void *buffer);
+
+int mmc_key_write(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
+{
+	ulong start, start_blk, blkcnt, ret;
+	unsigned char * temp_buf = buf;
+	int i = 2, dev = EMMC_DTB_DEV;
+	struct partitions * part = NULL;
+	struct mmc *mmc;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	mmc = find_mmc_device(dev);
+
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	info_disprotect |= DISPROTECT_KEY;
+	do {
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), start_blk, blkcnt, temp_buf);
+		if (ret != blkcnt) {
+			pr_err("[%s] %d, mmc_bwrite error\n",
+				__func__, __LINE__);
+			return 1;
+		}
+		start_blk += vpart->size / MMC_BLOCK_SIZE;
+	} while (--i);
+	info_disprotect &= ~DISPROTECT_KEY;
+	return 0;
+}
+
+extern unsigned long blk_derase(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt);
+
+int mmc_key_erase(void)
+{
+	ulong start, start_blk, blkcnt, ret;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	struct mmc *mmc;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	int dev = EMMC_DTB_DEV;
+
+	mmc = find_mmc_device(dev);
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (vpart->size / MMC_BLOCK_SIZE) * 2;//key and backup key
+	info_disprotect |= DISPROTECT_KEY;
+	ret = blk_derase(mmc_get_blk_desc(mmc), start_blk, blkcnt);
+	info_disprotect &= ~DISPROTECT_KEY;
+	if (ret) {
+		pr_err("[%s] %d mmc_berase error\n",
+				__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+int mmc_key_read(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
+{
+	ulong start, start_blk, blkcnt, ret;
+	int dev = EMMC_DTB_DEV;
+	unsigned char *temp_buf = buf;
+	struct partitions * part = NULL;
+	struct mmc *mmc;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	mmc = find_mmc_device(dev);
+	*actual_lenth =  0x40000;/*key size is 256KB*/
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	info_disprotect |= DISPROTECT_KEY;
+	ret = blk_dread(mmc_get_blk_desc(mmc), start_blk, blkcnt, temp_buf);
+	info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != blkcnt) {
+		pr_err("[%s] %d, mmc_bread error\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+
diff --git a/drivers/mmc/storage_emmc.c b/drivers/mmc/storage_emmc.c
new file mode 100644
index 0000000000..48519a6eea
--- /dev/null
+++ b/drivers/mmc/storage_emmc.c
@@ -0,0 +1,946 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+#include <amlogic/storage.h>
+#include <amlstorage/partition_table.h>
+#include <amlstorage/emmc_partitions.h>
+#include <amlogic/cpu_id.h>
+#include <amlogic/asm/bl31_apis.h>
+#include <linux/compat.h>
+#include <amlogic/aml_mmc.h>
+
+#include <asm/global_data.h>
+#include <dm/pinctrl.h>
+
+
+#define USER_PARTITION 0
+#define BOOT0_PARTITION 1
+#define BOOT1_PARTITION 2
+#define RPMB_PARTITION 3
+
+#define NOMAL_INIT 0
+#define ERASE_ALL 3
+#define ERASE_RESERVED 2
+
+#define GXB_START_BLK   0
+#define GXL_START_BLK   1
+#define STORAGE_EMMC 1
+/* max 2MB for emmc in blks */
+#define UBOOT_SIZE  (0x1000)
+#define BLOCK_SIZE 512
+
+
+
+
+
+extern int find_dev_num_by_partition_name (char const *name);
+extern struct partitions *get_partition_info_by_num(const int num);
+extern bool emmckey_is_protected(struct mmc *mmc);
+extern int info_disprotect;
+extern int dtb_read(void *addr);
+extern int dtb_write(void *addr);
+extern int renew_partition_tbl(unsigned char *buffer);
+
+static int storage_range_check(struct mmc *mmc,char const *part_name,loff_t offset, size_t *size,loff_t *off) {
+
+	struct partitions *part_info = NULL;
+
+	//cpu_id_t cpu_id = get_cpu_id();
+
+
+	if (strcmp(part_name, "bootloader") == 0) {
+		*off = 0;
+		if (1) { //if (cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+			*off += 512;
+		}
+		if (*size == 0) {
+			*size =mmc->capacity_boot;
+			if (1) { //if (cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+				*size = *size - 512;
+			}
+		}
+	} else {
+		part_info = find_mmc_partition_by_name(part_name);
+		if (!part_info) {
+			printf("error partition name!\n");
+			return 1;
+		}
+		if ((part_info->mask_flags & PART_PROTECT_FLAG) &&
+			!(info_disprotect & DISPROTECT_KEY)) {
+				printf("%s is protected, pls open it in Dts\n",
+				part_info->name);
+				return 1;
+		}
+
+		*off = part_info->offset+offset;
+		if (offset >= part_info->size) {
+			printf("Start address out #%s# partition'address region,(off < 0x%llx)\n",
+						part_name, part_info->size);
+			return 1;
+		}
+		if ((*off+*size) > (part_info->size+part_info->offset)) {
+			printf("End address exceeds #%s# partition,(offset = 0x%llx,size = 0x%llx)\n",
+						part_name, part_info->offset,part_info->size);
+			return 1;
+		}
+
+		if (*size == 0) {
+			*size = part_info->size - offset;
+		}
+	}
+	return 0;
+}
+
+
+
+static int storage_rsv_range_check(char const *part_name, size_t *size,loff_t *off) {
+
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+
+
+	vpart = aml_get_virtual_partition_by_name(part_name);
+
+	if (!vpart) {
+		printf("error partition name!\n");
+		return 1;
+	}
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	if (!part) {
+		printf("error partition name!\n");
+		return 1;
+	}
+	*off = part->offset + vpart->offset;
+	if ((*size) > vpart->size) {
+		printf("End address exceeds #%s# partition,(offset = 0x%llx,size = 0x%llx)\n",
+						part_name, vpart->offset,vpart->size);
+		return 1;
+	}
+	if (*size == 0)
+		*size = vpart->size;
+	return 0;
+}
+
+
+static int storage_byte_read(struct mmc *mmc,loff_t off, size_t  size,void *addr) {
+
+	int blk_shift = 0;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+	ulong start_blk;
+	void *addr_tmp;
+	void *addr_byte;
+
+	blk_shift =  ffs(mmc->read_bl_len) - 1;
+	blk = off >>  blk_shift ;
+	cnt = size >>  blk_shift ;
+	sz_byte = size - ((cnt) << blk_shift) ;
+	mmc_init(mmc);
+
+	pr_info("blk:%lld   cnt:%lld \n",blk,cnt);
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if ((n == cnt) && (sz_byte != 0)) {
+	   /*printf("sz_byte=%#llx bytes\n",sz_byte);*/
+	   addr_tmp = malloc(mmc->read_bl_len);
+	   addr_byte = (void *)(addr+cnt*(mmc->read_bl_len));
+	   start_blk = blk+cnt;
+
+	   if (addr_tmp == NULL) {
+		   printf("mmc read: malloc fail\n");
+		   return 1;
+	   }
+
+	   if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+		   free(addr_tmp);
+		   printf("mmc read 1 block fail\n");
+		   return 1;
+	   }
+
+	   memcpy(addr_byte, addr_tmp, sz_byte);
+	   free(addr_tmp);
+	}
+	return (n == cnt) ? 0 : 1;
+
+
+}
+
+static int storage_byte_write(struct mmc *mmc,loff_t off, size_t  size,void *addr) {
+
+	int blk_shift = 0;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+
+	blk_shift =  ffs(mmc->read_bl_len) - 1;
+	blk = off >>  blk_shift ;
+	cnt = size >>  blk_shift ;
+	sz_byte = size - ((cnt) << blk_shift);
+	mmc_init(mmc);
+	pr_info("blk:%lld   cnt:%lld \n",blk,cnt);
+
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if ((n == cnt) && (sz_byte != 0)) {
+		// printf("sz_byte=%#llx bytes\n",sz_byte);
+		void *addr_tmp = malloc(mmc->write_bl_len);
+		void *addr_byte = (void*)(addr+cnt*(mmc->write_bl_len));
+		ulong start_blk = blk+cnt;
+
+		if (addr_tmp == NULL) {
+			printf("mmc write: malloc fail\n");
+			return 1;
+		}
+
+		if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+			free(addr_tmp);
+			printf("mmc read 1 block fail\n");
+			return 1;
+		}
+
+		memcpy(addr_tmp, addr_byte, sz_byte);
+		if (blk_dwrite(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // write 1 block
+			free(addr_tmp);
+			printf("mmc write 1 block fail\n");
+			return 1;
+		}
+		free(addr_tmp);
+	}
+	//printf("%#llx blocks , %#llx bytes written: %s\n", n, sz_byte, (n==cnt) ? "OK" : "ERROR");
+	return (n == cnt) ? 0 : 1;
+}
+
+
+static int storage_byte_erase(struct mmc *mmc,loff_t off, size_t  size) {
+
+	int blk_shift = 0;
+	u64 cnt = 0, n = 0, blk = 0;
+
+	blk_shift =  ffs(mmc->read_bl_len) - 1;
+	blk = off >>  blk_shift ;
+	cnt = size >>  blk_shift ;
+	mmc_init(mmc);
+	pr_info("blk:%lld   cnt:%lld \n",blk,cnt);
+	if (cnt)
+		n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+	printf("%lld blocks erased: %s\n", cnt, (n == 0) ? "OK" : "ERROR");
+	return (n == 0) ? 0 : 1;
+}
+
+static int storage_erase_in_part(char const *part_name, loff_t off, size_t size)
+{
+	int ret = 1;
+	struct mmc *mmc;
+	loff_t offset;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	ret = storage_range_check(mmc,part_name, off, &size, &offset);
+	if (ret)
+		return ret;
+
+	ret = storage_byte_erase(mmc, offset, size);
+	return (ret == 0) ? 0 : 1;
+}
+
+
+
+static int storage_read_in_part(char const *part_name, loff_t off, size_t size, void *dest)
+{
+	int ret =1;
+	struct mmc *mmc;
+	loff_t offset;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	ret = storage_range_check(mmc,part_name,off,&size,&offset);
+
+	if (ret) return ret;
+
+	ret = storage_byte_read(mmc, offset, size, dest);
+
+	return ret;
+}
+
+
+static int storage_write_in_part(char const *part_name, loff_t off, size_t size, void *source)
+{
+	int ret = 1;
+	loff_t offset;
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		printf("Cannot find mmc. \n");
+		return 1;
+	}
+	ret = storage_range_check(mmc,part_name, off, &size, &offset);
+	if (ret) return ret;
+
+	ret = storage_byte_write(mmc, offset, size, source);
+	return ret;
+}
+
+static int storage_mmc_erase_user(struct mmc *mmc) {
+	int ret = 0, i;
+	struct partitions *part_info = NULL;
+
+	if (info_disprotect & DISPROTECT_KEY) {//key disprotect,erase all
+		ret = blk_derase(mmc_get_blk_desc(mmc), 0, 0);
+	} else {//key protect partition with the protect_flag
+		for (i = 0;;i++) {
+			part_info = get_partition_info_by_num(i);
+			if (part_info == NULL)
+				break;
+			if (!strcmp("reserved", part_info->name)) {
+				printf("Part:reserved is skiped\n");
+				continue;
+			}
+			if (part_info->mask_flags & PART_PROTECT_FLAG) {
+				printf("Part:%s is protected\n", part_info->name);
+				continue;
+			}
+			ret = blk_derase(mmc_get_blk_desc(mmc),
+					part_info->offset / BLOCK_SIZE,
+					part_info->size / BLOCK_SIZE);
+			printf("Erased: %s %s\n",
+					part_info->name,
+					(ret == 0)? "OK" : "ERR");
+		}
+	}
+	printf("User partition erased: %s\n", (ret == 0) ? "OK" : "ERROR");
+	return ret;
+}
+
+static int storage_mmc_erase(int flag, struct mmc *mmc) {
+
+	int ret = 0;
+	loff_t off = 0;
+	size_t size = 0;
+
+	if (flag >= ERASE_ALL) {//erase all except reserved
+		ret = storage_mmc_erase_user(mmc);
+		if (ret != 0) {
+			return -1;
+		}
+
+		ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, BOOT0_PARTITION);
+		if (ret) goto R_SWITCH_BACK;
+		ret = blk_derase(mmc_get_blk_desc(mmc), 0, 0);
+		printf("boot0 partition erased: %s\n", (ret == 0) ? "OK" : "ERROR");
+
+		ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, BOOT1_PARTITION);
+
+		if (ret) goto R_SWITCH_BACK;
+		ret = blk_derase(mmc_get_blk_desc(mmc), 0, 0);
+		printf("boot1 partition erased: %s\n", (ret == 0) ? "OK" : "ERROR");
+R_SWITCH_BACK:
+		ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+
+	} else if (flag == ERASE_RESERVED) {//erase reserved
+
+		info_disprotect |= DISPROTECT_KEY;
+		ret = storage_rsv_range_check("reserved", &size, &off);
+		if (ret != 0) {
+			return -1;
+		}
+		ret = storage_erase_in_part("reserved", off, size);
+		info_disprotect &= ~DISPROTECT_KEY;
+	}
+
+	return ret;
+
+
+}
+
+
+
+int mmc_storage_init(unsigned char init_flag) {
+
+	int ret =1;
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	mmc->has_init=0;
+	pinctrl_select_state(mmc->dev, "default");
+	if (!mmc) {
+		return -1;
+	}
+	ret = mmc_init(mmc);
+	if (ret != 0) {
+		return -1;
+	}
+	ret = storage_mmc_erase(init_flag, mmc);
+	return ret;
+}
+
+
+
+
+
+uint64_t mmc_storage_get_part_size(const char *part_name) {
+
+	struct partitions *part_info = NULL;
+
+	part_info = find_mmc_partition_by_name(part_name);
+
+	if (part_info == NULL) {
+		printf("get partition info failed !!\n");
+		return -1;
+	}
+	return part_info->size;
+}
+
+int mmc_storage_read(const char *part_name, loff_t off, size_t size, void *dest) {
+
+	int ret=1;
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+
+	if (!mmc)
+		return 1;
+
+	if (!part_name) {//the operating object is the device,the unit of operation is block.
+		info_disprotect |= DISPROTECT_KEY;
+		ret = blk_dread(mmc_get_blk_desc(mmc), off, size, dest);
+		info_disprotect &= ~DISPROTECT_KEY;
+		printf("%d blocks read: %s\n", ret, (ret == size) ? "OK" : "ERROR");
+		return (ret == size) ? 0 : 1;
+
+	} else {//the opering object is partition,the unit of operation is byte.
+		ret = storage_read_in_part(part_name, off,size, dest);
+	}
+
+	return ret;
+
+}
+
+
+int mmc_storage_write(const char *part_name, loff_t off, size_t size, void *source) {
+
+	int ret=1;
+
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	if (!part_name) {//the operating object is the device,the unit of operation is block.
+		info_disprotect |= DISPROTECT_KEY;
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), off, size, source);
+		info_disprotect &= ~DISPROTECT_KEY;
+		printf("%d blocks written: %s\n", ret, (ret == size) ? "OK" : "ERROR");
+		return (ret == size) ? 0 : 1;
+	} else {//the opering object is partition,the unit of operation is byte.
+		ret = storage_write_in_part(part_name, off, size, source);
+	}
+	return ret;
+}
+
+int mmc_storage_erase(const char *part_name, loff_t off, size_t size, int scrub_flag) {
+
+	int ret=1;
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	if (!part_name) {//the operating object is the device,the unit of operation is block.
+		ret = storage_mmc_erase(ERASE_ALL, mmc);
+		return (ret == 0) ? 0 : 1;
+	} else {//the opering object is partition,the unit of operation is byte.
+		ret = storage_erase_in_part(part_name, off, size);
+	}
+	return ret;
+}
+
+uint8_t mmc_storage_get_copies(const char *part_name) {
+
+	char ret=3;
+
+	return ret;
+
+}
+
+
+uint64_t mmc_get_copy_size(const char *part_name) {
+
+	struct partitions *part_info = NULL;
+
+#ifdef CONFIG_AML_GPT
+	return UBOOT_SIZE*512;
+#else
+	part_info = find_mmc_partition_by_name("bootloader");
+	if (part_info == NULL) {
+		printf("get partition info failed !!\n");
+		return -1;
+	}
+	return part_info->size;
+#endif
+}
+
+/* dtb read&write operation with backup updates */
+static u32 _calc_boot_info_checksum(struct storage_emmc_boot_info *boot_info)
+{
+	u32 *buffer = (u32*)boot_info;
+	u32 checksum = 0;
+	int i = 0;
+
+	do {
+		checksum += buffer[i];
+	} while (i++ < ((EMMC_BOOT_INFO_SIZE >> 2) - 2));
+
+	return checksum;
+}
+
+static int fill_mask8_part(struct part_property *mask8)
+{
+	struct partitions *part;
+	int i = 0, mask8_cnt = 0;
+
+	part = get_partition_info_by_num(i);
+	while (part) {
+		if ((part->mask_flags == 8)
+			&& (mask8_cnt++ < BOOTINFO_MAX_PARTITIONS)) {
+			strncpy(mask8->name, part->name, strlen(part->name));
+			mask8->addr = part->offset / MMC_BLOCK_SIZE;
+			mask8->size = part->size / MMC_BLOCK_SIZE;
+			mask8++;
+		}
+		if (mask8_cnt == BOOTINFO_MAX_PARTITIONS)
+			break;
+		i++;
+		part = get_partition_info_by_num(i);
+	}
+
+	return mask8_cnt;
+}
+
+static int amlmmc_write_info_sector(struct mmc *mmc)
+{
+	struct storage_emmc_boot_info *boot_info;
+	struct virtual_partition *ddr_part;
+	struct partitions *part;
+	/* partitons with mask = 8 need to fill to bootinfo */
+	struct part_property *mask8;
+	int mask8_partition_count;
+	u8 *buffer;
+	int ret = 0, i;
+
+	buffer = malloc(MMC_BLOCK_SIZE);
+	if (!buffer)
+		return -ENOMEM;
+
+	memset(buffer, 0, sizeof(*boot_info));
+	boot_info = (struct storage_emmc_boot_info *)buffer;
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	boot_info->rsv_base_addr = part->offset / MMC_BLOCK_SIZE;
+	ddr_part =  aml_get_virtual_partition_by_name(MMC_DDR_PARAMETER_NAME);
+	boot_info->ddr.addr = ddr_part->offset / MMC_BLOCK_SIZE;
+	boot_info->ddr.size = ddr_part->size / MMC_BLOCK_SIZE;
+
+	mask8 = boot_info->parts;
+	mask8_partition_count = fill_mask8_part(mask8);
+
+	boot_info->version = 1;
+	boot_info->checksum = _calc_boot_info_checksum(boot_info);
+
+	printf("boot_info.rsv_base_addr:\t%04x\n", boot_info->rsv_base_addr);
+	printf("boot_info.ddr.addr:%04x\n", boot_info->ddr.addr);
+	printf("boot_info.ddr.size:%04x\n", boot_info->ddr.size);
+	printf("boot info: parts %d\n", mask8_partition_count);
+	for (i = 0; i < mask8_partition_count; i++) {
+		printf("boot_info.part[%d]\n", i);
+		printf("\t.name:%s\n", boot_info->parts[i].name);
+		printf("\t.addr:%04x\n", boot_info->parts[i].addr);
+		printf("\t.size:%04x\n", boot_info->parts[i].size);
+	}
+	printf("boot_info.version:%04x\n", boot_info->version);
+	printf("boot_info.checksum:%04x\n", boot_info->checksum);
+
+	if (blk_dwrite(mmc_get_blk_desc(mmc), 0, 1, buffer) != 1)
+		ret = -EIO;
+
+	free(buffer);
+	return ret;
+}
+
+int mmc_boot_read(const char *part_name, uint8_t cpy, size_t size, void *dest) {
+
+	char ret=1;
+	int i;
+
+	if (cpy == 0)
+		cpy = 1;
+	else if (cpy == 1)
+		cpy = 2;
+	else if (cpy == 2)
+		cpy = 4;
+	else if (cpy == 0xff)
+		cpy = 7;
+	for (i=0;i<3;i++) {//cpy:
+
+		if (cpy & 1) {
+			ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, i);
+			if (ret) goto R_SWITCH_BACK;
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+			ret = storage_read_in_part(part_name, 0, size, dest);
+
+			if (ret != 0) {
+				printf("storage read bootloader failed \n");
+				goto R_SWITCH_BACK;
+			}
+		}
+		cpy = cpy >> 1;
+	}
+
+
+R_SWITCH_BACK:
+	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+	if (ret != 0) {
+		printf("switch part  failed \n");
+		return -1;
+	}
+
+	return ret;
+
+}
+
+int mmc_boot_write(const char *part_name, uint8_t cpy, size_t size, void *source) {
+
+	char ret=1;
+	int i = 0;
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+
+	if (cpy == 0)
+		cpy = 1;
+	else if (cpy == 1)
+		cpy = 2;
+	else if (cpy == 2)
+		cpy = 4;
+	else if (cpy == 0xff)
+		cpy = 7;
+
+	for (i=0;i<3;i++) {//cpy:bin 100 is oprate boot1,bin 010 is oprate boot0,bin 001 is oprate user bootloader.bin 111 is operate all boot.
+
+		if (cpy & 1) {
+			ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, i);
+			if (ret) goto W_SWITCH_BACK;
+#ifdef CONFIG_EMMC_BOOT1_TOUCH_REGION
+			if (i == 2) {
+				size = CONFIG_EMMC_BOOT1_TOUCH_REGION;
+			}
+#endif
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+			ret = storage_write_in_part(part_name, 0, size, source);
+
+			if (ret != 0) {
+				printf("storage write bootloader failed \n");
+				goto W_SWITCH_BACK;
+			}
+			if (i != 0)
+				amlmmc_write_info_sector(mmc);
+		}
+		cpy = cpy >> 1;
+	}
+
+
+W_SWITCH_BACK:
+	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+	if (ret != 0) {
+		printf("switch part failed \n");
+		return -1;
+	}
+
+	return ret;
+
+}
+
+int mmc_boot_erase(const char *part_name, uint8_t cpy) {
+
+	char ret=1;
+	int i;
+	size_t size = 0;
+
+	if (cpy == 0)
+		cpy = 1;
+	else if (cpy == 1)
+		cpy = 2;
+	else if (cpy == 2)
+		cpy = 4;
+	else if (cpy == 0xff)
+		cpy = 7;
+	for (i=0;i<3;i++) {//cpy:
+
+		if (cpy & 1) {
+			ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, i);
+			if (ret) goto E_SWITCH_BACK;
+#ifdef CONFIG_EMMC_BOOT1_TOUCH_REGION
+			if (i == 2) {
+				size = CONFIG_EMMC_BOOT1_TOUCH_REGION;
+			}
+#endif
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+			ret = storage_erase_in_part(part_name, 0, size);
+
+			if (ret != 0) {
+				printf("storage read bootloader failed \n");
+				goto E_SWITCH_BACK;
+			}
+		}
+		cpy = cpy >> 1;
+	}
+
+
+E_SWITCH_BACK:
+	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+	if (ret != 0) {
+		printf("switch part faild \n");
+		return -1;
+	}
+
+
+	return ret;
+}
+
+uint32_t mmc_get_rsv_size(const char *rsv_name) {
+
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(rsv_name);
+	printf("the %s partition size is:%llx   byte\n",rsv_name,vpart->size);
+	return vpart->size;
+
+}
+
+static inline int env_read(size_t size, void *buf) {
+	return storage_read_in_part("env", 0, size, buf);
+}
+
+static inline int env_write(size_t size, void *buf) {
+	return storage_write_in_part("env", 0, size, buf);
+}
+
+int mmc_read_rsv(const char *rsv_name, size_t size, void *buf) {
+
+	char ret=1;
+	struct mmc *mmc;
+	loff_t off =0;
+	/*unsigned long dtImgAddr = simple_strtoul(buf, NULL, 16);*/
+	ret = !strcmp("env", rsv_name) || !strcmp("key", rsv_name)
+		|| !strcmp("dtb", rsv_name)||!strcmp("fastboot", rsv_name)
+		||!strcmp("ddr-parameter", rsv_name);
+	if (!ret) return 1;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	if (!strcmp("env", rsv_name)) {
+		ret = env_read(size, buf);
+		return ret;
+	}
+
+	ret = storage_rsv_range_check(rsv_name, &size, &off);
+	if (ret) return ret;
+	if (!strcmp("dtb", rsv_name)) {
+		ret = dtb_read(buf);
+		return ret;
+	}
+
+	if (!strcmp("key", rsv_name))
+		info_disprotect |= DISPROTECT_KEY;
+	ret = storage_byte_read(mmc, off, size, buf);
+	if (!strcmp("key", rsv_name))
+		info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != 0) {
+		printf("read resv failed\n");
+	}
+
+	return ret;
+}
+int mmc_write_rsv(const char *rsv_name, size_t size, void *buf) {
+
+	char ret=1;
+
+	struct mmc *mmc;
+	loff_t off = 0;
+
+	ret = !strcmp("env", rsv_name) || !strcmp("key", rsv_name)
+		|| !strcmp("dtb", rsv_name)||!strcmp("fastboot", rsv_name)
+		||!strcmp("ddr-parameter", rsv_name);
+	if (!ret)
+		return 1;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	if (!strcmp("env", rsv_name)) {
+		ret = env_write(size, buf);
+		return ret;
+	}
+
+	ret = storage_rsv_range_check(rsv_name, &size, &off);
+	if (ret) return ret;
+
+	if (!strcmp("dtb", rsv_name)) {
+		ret = dtb_write(buf);
+		ret |= renew_partition_tbl(buf);
+	} else {
+		if (!strcmp("key", rsv_name))
+			info_disprotect |= DISPROTECT_KEY;
+		ret = storage_byte_write(mmc, off, size, buf);
+		if (!strcmp("key", rsv_name))
+			info_disprotect &= ~DISPROTECT_KEY;
+	}
+
+	if (ret != 0)
+		printf("write rsv failed\n");
+
+	return ret;
+}
+int mmc_erase_rsv(const char *rsv_name) {
+
+	char ret=1;
+	struct mmc *mmc;
+	loff_t off = 0;
+	size_t size = 0;
+	ret = !strcmp("key", rsv_name) || !strcmp("dtb", rsv_name)
+		||!strcmp("fastboot", rsv_name)
+		||!strcmp("ddr-parameter", rsv_name);
+	if (!ret) return 1;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+	ret = storage_rsv_range_check(rsv_name, &size, &off);
+	if (ret) return ret;
+	if (!strcmp("key", rsv_name))
+		info_disprotect |= DISPROTECT_KEY;
+	ret = storage_byte_erase(mmc, off, size);
+	if (!strcmp("key", rsv_name))
+		info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != 0) {
+		printf("erase resv failed\n");
+	}
+	return ret;
+}
+
+int mmc_protect_rsv(const char *rsv_name, bool ops) {
+
+	char ret=1;
+	ret = strcmp("key", rsv_name);
+	if (ret) return 1;
+
+	if (ops) {
+
+		info_disprotect &= ~DISPROTECT_KEY;
+		printf("Protect the key partition!\n");
+	} else {
+		info_disprotect |= DISPROTECT_KEY;
+		printf("Disprotect the key partition!\n");
+	}
+	return ret;
+
+}
+
+void config_storage_dev_func(struct storage_t *dev, struct mmc* mmc)
+{
+	/******basic info*******/
+	dev->type = BOOT_EMMC;
+	printf("store flag: %d, types: %d\n", dev->init_flag, dev->type);
+	/*dev->info.name = mmc->cid[0] & 0xff,
+		(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
+		(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff;
+	dev->info.id = mmc->cid[0] >> 24;*/
+	dev->info.read_unit = mmc->read_bl_len;
+	dev->info.write_unit = mmc->write_bl_len;
+	dev->info.erase_unit = mmc->erase_grp_size;
+	dev->info.caps = mmc->capacity_user;
+	dev->info.mode = COMPACT_BOOTLOADER;
+
+	dev->get_part_size = mmc_storage_get_part_size;
+	dev->read = mmc_storage_read;
+	dev->write = mmc_storage_write;
+	dev->erase = mmc_storage_erase;
+
+	dev->get_copies = mmc_storage_get_copies;
+	dev->get_copy_size = mmc_get_copy_size;
+	dev->boot_read = mmc_boot_read;
+	dev->boot_write = mmc_boot_write;
+	dev->boot_erase = mmc_boot_erase;
+
+	dev->get_rsv_size = mmc_get_rsv_size;
+	dev->read_rsv = mmc_read_rsv;
+	dev->write_rsv = mmc_write_rsv;
+	dev->erase_rsv = mmc_erase_rsv;
+	dev->protect_rsv = mmc_protect_rsv;
+
+	return;
+}
+
+DECLARE_GLOBAL_DATA_PTR;
+int sdcard_pre(void)
+{
+	return 0;
+}
+
+
+int sdcard_probe(uint32_t init_flag)
+{
+	return 0;
+}
+
+int emmc_pre(void)
+{
+	char ret = 1;
+	struct mmc *mmc;
+	static struct storage_t *storage_dev = NULL;
+
+	mmc_initialize(gd->bd);
+	mmc = find_mmc_device(STORAGE_EMMC);
+	mmc->has_init = 0;
+	ret = mmc_start_init(mmc);
+	if (ret == 0) {
+	/*struct store_operation *storage_opera = NULL;*/
+		storage_dev = kzalloc(sizeof(struct storage_t), GFP_KERNEL);
+		if (storage_dev == NULL) {
+			printf("malloc failed for storage_dev\n");
+			ret = -1;
+			return ret;
+		}
+		config_storage_dev_func(storage_dev, mmc);
+		store_register(storage_dev);
+		printf("emmc init success!\n");
+	} else
+		printf("emmc init fail!\n");
+	return ret;
+}
+
+
+int emmc_probe(uint32_t init_flag)
+{
+	char ret = 0;
+
+	ret = mmc_storage_init(init_flag); /*flag 0*/
+	if (ret) {
+		printf("mmc init failed ret:%x\n", ret);
+		goto exit_error;
+	}
+	printf("emmc probe success\n");
+
+exit_error:
+	return ret;
+}
+
diff --git a/include/amlogic/aml_cec.h b/include/amlogic/aml_cec.h
new file mode 100644
index 0000000000..4f0b2bd3a1
--- /dev/null
+++ b/include/amlogic/aml_cec.h
@@ -0,0 +1,86 @@
+/*
+ * include/amlogic/aml_cec.h
+ *
+ * Copyright (C) 2012 AMLOGIC, INC. All Rights Reserved.
+ * Author: hongmin hua <hongmin hua@amlogic.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the smems of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+
+#ifndef _AML_CEC_H
+#define _AML_CEC_H
+
+/*
+ * CEC OPCODES
+ */
+#define	CEC_OC_ABORT_MESSAGE 					0xFF
+#define	CEC_OC_ACTIVE_SOURCE 					0x82
+#define	CEC_OC_CEC_VERSION 					0x9E
+#define	CEC_OC_CLEAR_ANALOGUE_TIMER 				0x33
+#define	CEC_OC_CLEAR_DIGITAL_TIMER 				0x99
+#define	CEC_OC_CLEAR_EXTERNAL_TIMER 				0xA1
+#define	CEC_OC_DECK_CONTROL 					0x42
+#define	CEC_OC_DECK_STATUS 					0x1B
+#define	CEC_OC_DEVICE_VENDOR_ID 				0x87
+#define	CEC_OC_FEATURE_ABORT 					0x00
+#define	CEC_OC_GET_CEC_VERSION 					0x9F
+#define	CEC_OC_GET_MENU_LANGUAGE 				0x91
+#define	CEC_OC_GIVE_AUDIO_STATUS 				0x71
+#define	CEC_OC_GIVE_DECK_STATUS 				0x1A
+#define	CEC_OC_GIVE_DEVICE_POWER_STATUS 			0x8F
+#define	CEC_OC_GIVE_DEVICE_VENDOR_ID 				0x8C
+#define	CEC_OC_GIVE_OSD_NAME 					0x46
+#define	CEC_OC_GIVE_PHYSICAL_ADDRESS 				0x83
+#define	CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS 			0x7D
+#define	CEC_OC_GIVE_TUNER_DEVICE_STATUS 			0x08
+#define	CEC_OC_IMAGE_VIEW_ON 					0x04
+#define	CEC_OC_INACTIVE_SOURCE 					0x9D
+#define	CEC_OC_MENU_REQUEST 					0x8D
+#define	CEC_OC_MENU_STATUS 					0x8E
+#define	CEC_OC_PLAY 						0x41
+#define	CEC_OC_POLLING_MESSAGE 					0xFC	/* Fake Code - <Poll Message> has no OP Code and requires only the header byte */
+#define	CEC_OC_RECORD_OFF 					0x0B
+#define	CEC_OC_RECORD_ON 					0x09
+#define	CEC_OC_RECORD_STATUS 					0x0A
+#define	CEC_OC_RECORD_TV_SCREEN 				0x0F
+#define	CEC_OC_REPORT_AUDIO_STATUS 				0x7A
+#define	CEC_OC_REPORT_PHYSICAL_ADDRESS 				0x84
+#define	CEC_OC_REPORT_POWER_STATUS 				0x90
+#define	CEC_OC_REQUEST_ACTIVE_SOURCE 				0x85
+#define	CEC_OC_ROUTING_CHANGE 					0x80
+#define	CEC_OC_ROUTING_INFORMATION 				0x81
+#define	CEC_OC_SELECT_ANALOGUE_SERVICE 				0x92
+#define	CEC_OC_SELECT_DIGITAL_SERVICE 				0x93
+#define	CEC_OC_SET_ANALOGUE_TIMER 				0x34
+#define	CEC_OC_SET_AUDIO_RATE 					0x9A
+#define	CEC_OC_SET_DIGITAL_TIMER 				0x97
+#define	CEC_OC_SET_EXTERNAL_TIMER 				0xA2
+#define	CEC_OC_SET_MENU_LANGUAGE 				0x32
+#define	CEC_OC_SET_OSD_NAME 					0x47
+#define	CEC_OC_SET_OSD_STRING 					0x64
+#define	CEC_OC_SET_STREAM_PATH 					0x86
+#define	CEC_OC_SET_SYSTEM_AUDIO_MODE 				0x72
+#define	CEC_OC_SET_TIMER_PROGRAM_TITLE 				0x67
+#define	CEC_OC_STANDBY 						0x36
+#define	CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 			0x70
+#define	CEC_OC_SYSTEM_AUDIO_MODE_STATUS 			0x7E
+#define	CEC_OC_TEXT_VIEW_ON 					0x0D
+#define	CEC_OC_TIMER_CLEARED_STATUS 				0x43
+#define	CEC_OC_TIMER_STATUS 					0x35
+#define	CEC_OC_TUNER_DEVICE_STATUS 				0x07
+#define	CEC_OC_TUNER_STEP_DECREMENT 				0x06
+#define	CEC_OC_TUNER_STEP_INCREMENT 				0x05
+#define	CEC_OC_USER_CONTROL_PRESSED 				0x44
+#define	CEC_OC_USER_CONTROL_RELEASED 				0x45
+#define	CEC_OC_VENDOR_COMMAND 					0x89
+#define	CEC_OC_VENDOR_COMMAND_WITH_ID 				0xA0
+#define	CEC_OC_VENDOR_REMOTE_BUTTON_DOWN 			0x8A
+#define	CEC_OC_VENDOR_REMOTE_BUTTON_UP 				0x8B
+
+int cec_hw_init(int logic_addr, unsigned char fun_cfg);
+
+#endif/*_AML_CEC_H*/
+
diff --git a/include/amlogic/aml_efuse.h b/include/amlogic/aml_efuse.h
new file mode 100644
index 0000000000..4dece0725d
--- /dev/null
+++ b/include/amlogic/aml_efuse.h
@@ -0,0 +1,79 @@
+
+/*
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+*/
+
+#ifndef __BL2_EFUSE_H__
+#define __BL2_EFUSE_H__
+
+#if 0
+//just keep following CFG10/9 for new API implement
+#define IS_FEAT_USB_PD_CHK_ENABLE()   (readl(AO_SEC_SD_CFG10) & (1 << 1))
+#define IS_FEAT_THERMAL_CALIBRATED()  (readl(AO_SEC_SD_CFG10) & (1 << 2))
+#define IS_FEAT_BOOT_VERIFY()         (readl(AO_SEC_SD_CFG10) & (1 << 4))
+#define IS_FEAT_ROOT_KEY_BURNED()     (readl(AO_SEC_SD_CFG10) & (1 << 5))
+#define IS_FEAT_PLL_SET_BURNED()      (readl(AO_SEC_SD_CFG10) & (1 << 6))
+#define IS_FEAT_M3_PLL_ENABLE()       (readl(AO_SEC_SD_CFG10) & (1 << 7))
+#define IS_FEAT_M4_PLL_ENABLE()       (readl(AO_SEC_SD_CFG10) & (1 << 7))
+#define IS_FEAT_A53_PLL_ENABLE()      (readl(AO_SEC_SD_CFG10) & (1 << 8))
+#define IS_FEAT_NAMD_EXT_CMD_BURNED() (readl(AO_SEC_SD_CFG10) & (1 << 9))
+#define IS_FEAT_JTG_PD_CHK_ENABLE()   (readl(AO_SEC_SD_CFG10) & (1 << 11))
+#define IS_FEAT_JTG_ENABLE()          (readl(AO_SEC_SD_CFG10) & (1 << 12))
+#define IS_FEAT_CHIP_ID_BURNED        (readl(AO_SEC_SD_CFG10) & (1 << 13))
+#define IS_FEAT_DTS_ENABLE            (readl(AO_SEC_SD_CFG10) & (1 << 14))
+#define IS_FEAT_DISK_ENC_ENABLE       (readl(AO_SEC_SD_CFG10) & (1 << 15))
+#define IS_FEAT_DOLBY_AUDIO_ENABLE    (readl(AO_SEC_SD_CFG10) & (1 << 16))
+#define IS_FEAT_SCN_PD_CHK_ENABLE     (readl(AO_SEC_SD_CFG10) & (1 << 17))
+#define IS_FEAT_USB_BOOT_ENABLE       (readl(AO_SEC_SD_CFG10) & (1 << 19))
+#define IS_FEAT_SPI_BOOT_ENABLE       (readl(AO_SEC_SD_CFG10) & (1 << 20))
+#define IS_FEAT_RECOVERY_BOOT_ENABLE  (readl(AO_SEC_SD_CFG10) & (1 << 21))
+#define IS_FEAT_SD_BOOT_ENABLE        (readl(AO_SEC_SD_CFG10) & (1 << 22))
+#define IS_FEAT_NAND_EMMC_BOOT_ENABLE (readl(AO_SEC_SD_CFG10) & (1 << 23))
+#define IS_FEAT_ANTIROLLBACK_ENABLE   (readl(AO_SEC_SD_CFG10) & (1 << 25))
+#define IS_FEAT_BOOT_ENCRYPT()        (readl(AO_SEC_SD_CFG10) & (1 << 28))
+#define IS_FEAT_A53_L1_ENABLE()       (readl(AO_SEC_SD_CFG10) & (1 << 29))
+#define IS_FEAT_KEY_LDR_INIT()        (readl(AO_SEC_SD_CFG10) & (1 << 30))
+#define IS_FEAT_AP_COLD_BOOT_LOCK()   (readl(AO_SEC_SD_CFG10) & (1 << 31))
+#define IS_FEAT_BOOT_M3_ENCRYPT()     (readl(AO_SEC_SD_CFG9) & (1 << 5))
+#define IS_FEAT_BOOT_M4_ENCRYPT()     (readl(AO_SEC_SD_CFG9) & (1 << 6))
+#define IS_FEAT_NAND_BL2_BKP_RETRY()  (readl(AO_SEC_SD_CFG9) & (1 << 10))
+#define IS_FEAT_EMMC_BL2_BKP_RETRY()  (readl(AO_SEC_SD_CFG9) & (1 << 11))
+#define IS_FEAT_SCAN_DISABLE()        (readl(AO_SEC_SD_CFG9) & (1 << 12))
+#define IS_FEAT_NAND_128P_DISABLE()   (readl(AO_SEC_SD_CFG9) & (1 << 13))
+#define IS_FEAT_EMMC_LAST_ENABLE()    (readl(AO_SEC_SD_CFG9) & (1 << 14))
+#define IS_FEAT_HIGH_USB_ENABLE()     (readl(AO_SEC_SD_CFG9) & (1 << 15))
+#define IS_FEAT_BOOT_M3_VERIFY()      (readl(AO_SEC_SD_CFG9) & (1 << 16))
+#define IS_FEAT_BOOT_M4_VERIFY()      (readl(AO_SEC_SD_CFG9) & (1 << 17))
+#define IS_FEAT_CORNOR_INFO_BURNED()  (readl(AO_SEC_SD_CFG9) & (1 << 19))
+#define IS_FEAT_SCK_BURNED()          (readl(AO_SEC_SD_CFG9) & (1 << 20))
+#define IS_FEAT_BLK0_WR_LOCKED()      (readl(AO_SEC_SD_CFG9) & (1 << 21))
+#define IS_FEAT_M4_DISABLE()          (readl(AO_SEC_SD_CFG9) & (1 << 22))
+#define IS_FEAT_M4_SP_MODE_ENABLE()   (readl(AO_SEC_SD_CFG9) & (1 << 23))
+#define IS_FEAT_A53_CLK_12G()         (readl(AO_SEC_SD_CFG9) & (1 << 24))
+#define IS_FEAT_A53_CLK_15G()         (readl(AO_SEC_SD_CFG9) & (1 << 25))
+#define IS_FEAT_A53_CLK_20G()         (readl(AO_SEC_SD_CFG9) & (1 << 26))
+#define IS_FEAT_USB_PLL_ENABLE()      (readl(AO_SEC_SD_CFG9) & (1 << 27))
+#define IS_FEAT_RMA_ENABLE()          (readl(AO_SEC_SD_CFG9) & (1 << 28))
+#define IS_FEAT_OPS_CLI_BURNED()      (readl(AO_SEC_SD_CFG9) & (1 << 29))
+#define IS_FEAT_M4_UNLOCK_ENABLE()    (readl(AO_SEC_SD_CFG9) & (1 << 31))
+#define IS_FEAT_DISABLE_PRINT()       (readl(EFUSE_LIC0) & (1 << 22)))
+#endif
+
+//weak function for each SoC implement
+//Unify EFUSE license query API
+//all following functions are defined with "weak" for customization of each SoC
+//EFUSE_LICX	--> AO_SEC_SD_CFG10/9 --> EFUSE mirror
+int IS_FEAT_BOOT_VERIFY(void);
+int IS_FEAT_BOOT_ENCRYPT(void);
+int IS_FEAT_DIS_EMMC_USER(void);
+int IS_FEAT_DIS_EMMC_BOOT_0(void);
+int IS_FEAT_DIS_EMMC_BOOT_1(void);
+int IS_FEAT_EN_4BL2_SNOR(void);
+int IS_FEAT_DIS_NBL2_SNOR(void);
+int IS_FEAT_EN_8BL2_SNAND(void);
+int IS_FEAT_DIS_NBL2_SNAND(void);
+int IS_FEAT_DIS_8BL2_NAND(void);
+int IS_FEAT_DIS_NBL2_NAND(void);
+
+#endif /* __BL2_EFUSE_H__ */
diff --git a/include/amlogic/aml_gpio.h b/include/amlogic/aml_gpio.h
new file mode 100644
index 0000000000..c1e1ed1ef5
--- /dev/null
+++ b/include/amlogic/aml_gpio.h
@@ -0,0 +1,54 @@
+#ifndef __AML_GPIO__
+#define __AML_GPIO__
+#include <asm/io.h>
+/**
+ * struct meson_reg_desc - a register descriptor
+ *
+ * @reg:	register offset in the regmap
+ * @bit:	bit index in register
+ *
+ * The structure describes the information needed to control pull,
+ * pull-enable, direction, etc. for a single pin
+ */
+struct meson_reg_desc {
+	unsigned int reg;
+	unsigned int bit;
+};
+
+/**
+ * enum meson_reg_type - type of registers encoded in @meson_reg_desc
+ */
+enum meson_reg_type {
+	REG_PULLEN,
+	REG_PULL,
+	REG_DIR,
+	REG_OUT,
+	REG_IN,
+	NUM_REG,
+};
+
+
+
+
+struct meson_bank {
+	const char *name;
+	unsigned int first;
+	unsigned int last;
+	struct meson_reg_desc regs[NUM_REG];
+};
+#define GPIO_REG_BIT(reg, bit) ((reg<<5)|bit)
+#define GPIO_REG(value) ((value>>5))
+#define GPIO_BIT(value) ((value&0x1F))
+//#define BIT(bit)    (1<<bit)
+static inline void regmap_update_bits(unsigned long reg,unsigned mask,unsigned val)
+{
+
+	unsigned int tmp, orig;
+	orig = readl(reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	writel(tmp,reg);
+	return;
+}
+
+#endif
diff --git a/include/amlogic/aml_hdmirx.h b/include/amlogic/aml_hdmirx.h
new file mode 100644
index 0000000000..b4b0f5a84a
--- /dev/null
+++ b/include/amlogic/aml_hdmirx.h
@@ -0,0 +1,19 @@
+/*
+ * include/amlogic/aml_hdmirx.h
+ *
+ * Copyright (C) 2012 AMLOGIC, INC. All Rights Reserved.
+ * Author: hongmin hua <hongmin hua@amlogic.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the smems of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+#ifndef _AML_HDMIRX_H
+#define _AML_HDMIRX_H
+
+void hdmirx_hw_init(unsigned int port_map,
+		unsigned char *pedid_data,
+		int edid_size);
+
+#endif /* _AML_HDMIRX_H */
diff --git a/include/amlogic/aml_irblaster.h b/include/amlogic/aml_irblaster.h
new file mode 100644
index 0000000000..b2c4ef703e
--- /dev/null
+++ b/include/amlogic/aml_irblaster.h
@@ -0,0 +1,29 @@
+#ifndef __AML_IRBLATER_H
+#define __AML_IRBLATER_H
+
+#define MAX_WINDOWS_LEN 512
+struct aml_irblaster_drv_s {
+	unsigned int protocol;
+	unsigned int frequency;
+	unsigned int sendvalue;
+	unsigned int windows[MAX_WINDOWS_LEN];
+	unsigned int windows_num;
+	unsigned int dutycycle;
+	unsigned int openflag;
+	int (*open)(void);
+	int (*close)(void);
+	int (*test)(unsigned int);
+	int (*send)(unsigned int);
+	int (*setprotocol)(char *);
+	const char *(*getprocotol)(void);
+	int (*setfrequency)(unsigned int);
+	unsigned int (*getfrequency)(void);
+	void (*print_windows)(void);
+	int (*read_reg)(volatile unsigned int *, unsigned int);
+	int (*write_reg)(volatile unsigned int *, unsigned int);
+};
+
+struct aml_irblaster_drv_s *aml_irblaster_get_driver(void);
+#endif
+
+
diff --git a/include/amlogic/aml_is31fl32xx.h b/include/amlogic/aml_is31fl32xx.h
new file mode 100644
index 0000000000..6211ebc956
--- /dev/null
+++ b/include/amlogic/aml_is31fl32xx.h
@@ -0,0 +1,9 @@
+#ifndef __AML_IS31F132XX
+#define __AML_IS31F132XX
+
+#define IS31F132XX_DEVICE_ADDR 0x3c
+
+void board_is31fl32xx_init(void);
+void board_is31fl32xx_light_on(void);
+
+#endif
diff --git a/include/amlogic/aml_led.h b/include/amlogic/aml_led.h
new file mode 100644
index 0000000000..b2f3bda3f7
--- /dev/null
+++ b/include/amlogic/aml_led.h
@@ -0,0 +1,68 @@
+#ifndef __AML_LED_H__
+#define __AML_LED_H__
+
+#define LED_TIMER_INTERVAL 10 //ms
+
+#define LED_EVENT_NULL 0
+#define LED_EVENT_OFF 1
+#define LED_EVENT_ON 2
+#define LED_EVENT_FLASH 3
+#define LED_EVENT_BREATH 4
+
+#define SHUTDOWN_MODE 0
+#define SUSPEND_RESUME_MODE 1
+#define RECOVERY_MODE 2
+
+
+enum led_workmode {
+	LWM_OFF,
+	LWM_ON,
+	LWM_FLASH,
+	LWM_BREATH,
+	LWM_NULL,
+};
+
+/* s,b,w type is enum led_workmode */
+#define lwm_set_standby(mode, s) do {mode |= (s) << 0;} while(0)
+#define lwm_set_booting(mode, b) do {mode |= (b) << 4;} while(0)
+#define lwm_set_working(mode, w) do {mode |= (w) << 8;} while(0)
+#define lwm_set_suspend(mode, s) do {mode |= (s) << 12;} while(0)
+
+#define lwm_get_standby(mode) (((mode) >> 0) & 0xF)
+#define lwm_get_booting(mode) (((mode) >> 4) & 0xF)
+#define lwm_get_working(mode) (((mode) >> 8) & 0xF)
+#define lwm_get_suspend(mode) (((mode) >> 12) & 0xF)
+
+struct coord {
+	int x;
+	int y;
+};
+
+struct aml_led_config {
+	int off_brightness;
+	int on_brightness;
+	int flash_off_brightness;
+	int flash_off_time;
+	int flash_on_brightness;
+	int flash_on_time;
+	struct coord *breath_inflections;
+	int breath_inflections_num;
+	void (*set_brightness)(int brightness);
+};
+
+#define LED_EVENT_BUF_SIZE 3
+struct aml_led {
+	int event[LED_EVENT_BUF_SIZE];
+	int event_data[LED_EVENT_BUF_SIZE];
+	int state;
+	int brightness;
+	int time;
+	int count;
+	struct aml_led_config *config;
+};
+
+void aml_led_init(struct aml_led *led, struct aml_led_config *config);
+void aml_led_timer_proc(struct aml_led *led);
+void aml_led_event(struct aml_led *led, int event, int event_data);
+
+#endif
\ No newline at end of file
diff --git a/include/amlogic/aml_mmc.h b/include/amlogic/aml_mmc.h
new file mode 100644
index 0000000000..4d7801c04e
--- /dev/null
+++ b/include/amlogic/aml_mmc.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ * 	yonghui.yu@amlogic.com
+ */
+
+
+#ifndef __AML_MMC_H__
+#define __AML_MMC_H__
+
+#include <common.h>
+
+
+/* bootloader operation */
+#define AML_BL_USER		(0x1 << 0)
+#define AML_BL_BOOT0	(0x1 << 1)
+#define AML_BL_BOOT1	(0x1 << 2)
+#define AML_BL_BOOT     (0x6)
+#define AML_BL_ALL		(0x7)
+
+/** For actul partitions with mask 8 store into bootinfo
+ * name: partition name.
+ * addr: sector addr of the partition
+ * size: sector cont of the partition
+*/
+struct part_property
+{
+	char name[8];
+	uint32_t addr;
+	uint32_t size;
+};
+#define PART_PROPERTY_SIZE sizeof(struct part_property)
+#define BOOTINFO_MAX_PARTITIONS (4)
+#define BOOTINFO_PARITIONS_SIZE (PART_PROPERTY_SIZE * BOOTINFO_MAX_PARTITIONS)
+
+
+#define VPART_PROPERTY_SIZE sizeof(struct vpart_property)
+struct vpart_property {
+	u32 addr;
+	u32 size;
+};
+
+/*
+ * sizeof(struct storage_emmc_boot_info) is strictly
+ * smaller than or equal to one sector. we will bind
+ * it in one sector with u-boot.bin together and
+ * write into boot loader area.
+ * @rsv_base_addr : the sector address of reserved area
+ * @dtb  : the sector address and size of dtb property
+ * @ddr  : the sector address and size of ddr property
+ */
+#define EMMC_BOOT_INFO_SIZE	512
+struct storage_emmc_boot_info {
+	u32 version;
+	u32 rsv_base_addr;
+	struct vpart_property dtb;
+	struct vpart_property ddr;
+
+	struct part_property parts[BOOTINFO_MAX_PARTITIONS];
+	uint8_t reserved[512 - 2 * VPART_PROPERTY_SIZE - BOOTINFO_PARITIONS_SIZE - 12];
+	u32 checksum;
+};
+
+int amlmmc_write_bootloader(int dev, int map,
+		unsigned int size, const void *src);
+int amlmmc_erase_bootloader(int dev, int map);
+
+
+/* interface on reserved area. */
+void mmc_write_cali_mattern(void *addr);
+
+/* dtb operation */
+int dtb_write(void *addr);
+
+/* emmc key operation */
+int mmc_key_read(unsigned char *buf,
+		unsigned int size, uint32_t *actual_lenth);
+int mmc_key_write(unsigned char *buf,
+		unsigned int size, uint32_t *actual_lenth);
+int mmc_key_erase(void);
+
+/* partition operation */
+int renew_partition_tbl(unsigned char *buffer);
+int find_dev_num_by_partition_name (char const *name);
+
+#ifdef CONFIG_AML_PARTITION
+int emmc_update_mbr(unsigned char *buffer);
+#endif
+
+/*mmc ext_csd register operation*/
+int mmc_get_ext_csd(struct mmc *mmc, u8 *ext_csd);
+int mmc_set_ext_csd(struct mmc *mmc, u8 index, u8 value);
+
+
+
+#endif /* __AML_MMC_H__ */
diff --git a/include/amlogic/aml_mtd.h b/include/amlogic/aml_mtd.h
new file mode 100644
index 0000000000..4eb17e4fa2
--- /dev/null
+++ b/include/amlogic/aml_mtd.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Header file of amlogic mtd driver
+ *
+ * Copyright (C) 2018 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ */
+
+#ifndef __AMLMTD_H_
+#define __AMLMTD_H_
+#define BOOT_TOTAL_PAGES			1024
+
+#define CONFIG_BL2_COPY_NUM			8
+#define CONFIG_TPL_SIZE_PER_COPY	0x200000
+#define CONFIG_NOR_TPL_COPY_NUM		1 //for spi-nor
+#define CONFIG_NAND_TPL_COPY_NUM	4 // for slc & spi-nand
+
+#define BOOT_LOADER			"bootloader"
+#define BOOT_BL2			"bl2"
+#define BOOT_SPL			"spl"
+#define BOOT_BL2E                       "bl2e"
+#define BOOT_BL2X                       "bl2x"
+#define BOOT_DDRFIP                     "ddrfip"
+#define BOOT_DEVFIP                     "devfip"
+#define BOOT_TPL			"tpl"
+#define BOOT_FIP			"fip"
+#define MAX_MTD_CNT			2
+
+#endif/* __AMLMTD_H_ */
diff --git a/include/amlogic/aml_nand.h b/include/amlogic/aml_nand.h
new file mode 100644
index 0000000000..8be3974681
--- /dev/null
+++ b/include/amlogic/aml_nand.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef __AML_NAND_H__
+#define __AML_NAND_H__
+
+int amlnf_dtb_save(u8 *buf, unsigned int len);
+int amlnf_dtb_erase(void);
+int get_boot_num(struct mtd_info *mtd, size_t rwsize);
+
+/*#define RESERVED_BLOCK_NUM 48*/
+
+#endif/* __AML_NAND_H__ */
diff --git a/include/amlogic/aml_rsv.h b/include/amlogic/aml_rsv.h
new file mode 100644
index 0000000000..7e17c83435
--- /dev/null
+++ b/include/amlogic/aml_rsv.h
@@ -0,0 +1,106 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Header file of amlogic reserve manager
+ *
+ * Copyright (C) 2018 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ */
+
+#ifndef __MESON_RSV_H_
+#define __MESON_RSV_H_
+
+#define NAND_RSV_BLOCK_NUM 48
+
+#define NAND_GAP_BLOCK_NUM 4
+#define NAND_BBT_BLOCK_NUM 4
+#define NAND_ENV_BLOCK_NUM 8
+#define NAND_KEY_BLOCK_NUM 8
+#define NAND_DTB_BLOCK_NUM 4
+
+#define BBT_NAND_MAGIC	"nbbt"
+#define ENV_NAND_MAGIC	"nenv"
+#define KEY_NAND_MAGIC	"nkey"
+#define SEC_NAND_MAGIC	"nsec"
+#define DTB_NAND_MAGIC	"ndtb"
+
+/*define abnormal state for reserved area*/
+#define POWER_ABNORMAL_FLAG	0x01
+#define ECC_ABNORMAL_FLAG	0x02
+
+
+struct meson_rsv_info_t {
+	struct mtd_info *mtd;
+	struct valid_node_t *nvalid;
+	struct free_node_t *nfree;
+	unsigned int start;
+	unsigned int end;
+	unsigned int size;
+	char name[8];
+	u_char valid;
+	u_char init;
+	void *handler;
+};
+
+struct valid_node_t {
+	s16 ec;
+	s16	blk_addr;
+	s16	page_addr;
+	int timestamp;
+	s16 status;
+};
+
+struct free_node_t {
+	unsigned int index;
+	s16 ec;
+	s16	blk_addr;
+	int dirty_flag;
+	struct free_node_t *next;
+};
+
+struct oobinfo_t {
+	char name[4];
+	s16 ec;
+	unsigned timestamp:15;
+	unsigned status_page:1;
+};
+
+struct meson_rsv_handler_t {
+	struct mtd_info *mtd;
+	unsigned long long fn_bitmask;
+	struct free_node_t *free_node[NAND_RSV_BLOCK_NUM];
+	struct meson_rsv_info_t *bbt;
+#ifndef CONFIG_ENV_IS_IN_NAND
+	struct meson_rsv_info_t *env;
+#endif
+	struct meson_rsv_info_t *key;
+	struct meson_rsv_info_t *dtb;
+	void *priv;
+};
+
+int meson_rsv_bbt_read(u_char *dest, size_t size);
+int meson_rsv_key_read(u_char *dest, size_t size);
+int meson_rsv_env_read(u_char *dest, size_t size);
+int meson_rsv_dtb_read(u_char *dest, size_t size);
+/* do not provide bbt write operates */
+int meson_rsv_key_write(u_char *source, size_t size);
+int meson_rsv_env_write(u_char *source, size_t size);
+int meson_rsv_dtb_write(u_char *source, size_t size);
+uint32_t meson_rsv_bbt_size(void);
+uint32_t meson_rsv_key_size(void);
+uint32_t meson_rsv_env_size(void);
+uint32_t meson_rsv_dtb_size(void);
+/* do not provide bbt erase operates */
+int meson_rsv_key_erase(void);
+int meson_rsv_env_erase(void);
+int meson_rsv_dtb_erase(void);
+int meson_rsv_check(struct meson_rsv_info_t *rsv_info);
+int meson_rsv_init(struct mtd_info *mtd, struct meson_rsv_handler_t *handler);
+int meson_rsv_scan(struct meson_rsv_info_t *rsv_info);
+int meson_rsv_read(struct meson_rsv_info_t *rsv_info, u_char *buf);
+int meson_rsv_save(struct meson_rsv_info_t *rsv_info, u_char *buf);
+int meson_rsv_write(struct meson_rsv_info_t *rsv_info, u_char *buf);
+int meson_rsv_erase_protect(struct meson_rsv_handler_t *handler,
+uint32_t block_addr);
+#endif/* __MESON_RSV_H_ */
diff --git a/include/amlogic/aml_tlv.h b/include/amlogic/aml_tlv.h
new file mode 100644
index 0000000000..93fa0a305f
--- /dev/null
+++ b/include/amlogic/aml_tlv.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * All information contained herein is Amlogic confidential.
+ *
+ * This software is provided to you pursuant to Software License Agreement
+ * (SLA) with Amlogic Inc ("Amlogic"). This software may be used
+ * only in accordance with the terms of this agreement.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification is strictly prohibited without prior written permission from
+ * Amlogic.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Created by haixiang.bao@amlogic.com
+ *
+ * Revision history:  1. 2018.05.31 v0.1 init for transfer data from BL2 to BL3X
+ *
+ */
+
+
+#ifndef __AMLOGIC_TLV_H_
+#define __AMLOGIC_TLV_H_
+
+typedef struct __s_bl2_tlv_item_t{
+	unsigned    int    nType;   //type: user defined, should sync between BL2 and BL3X
+	unsigned    int    nLength; //length: length of szContent, no alignment
+	unsigned    int    nStoreLength; //length: length of szContent, alignment to 16
+	unsigned    char   szRserved1[4];//reserved for future
+	struct __s_bl2_tlv_item_t * pNextItem;//next item, list for fetch all quickly
+	unsigned    char   szContent[4]; //data transfered from BL2
+}s_bl2_tlv_item_t;
+
+typedef struct __s_bl2_to_bl3x_hdr_t{
+	unsigned    int    nMagic;         //magic for identify itself, AML_BL2_TMASTER_MAGIC (@BL2)
+	unsigned    int    nVersion;       //version for control
+	unsigned    int    nHeadSize;      //sizeof(this)
+	unsigned    char   szRserved1[4];  //reserved for furture
+
+	unsigned    char   szBL2Info[96];  //BL2 build information
+
+	s_bl2_tlv_item_t * pNextBlob;      //next active valid blob item
+	unsigned    int    nTLVCount;      //current valid TLV item number
+	unsigned    int    nTotalSize;     //total size of all TLV items
+	unsigned    char   szSHA2TLV[32];  //SHA2 of all TLV items, size is nTotalSize
+
+} s_bl2_to_bl3x_hdr_t;
+
+typedef struct __s_bl2_to_bl3x_send_t{
+
+	s_bl2_to_bl3x_hdr_t hdr;
+
+	unsigned     char   szSHA2Head[32];
+
+	s_bl2_tlv_item_t	blob[1];
+
+} s_bl2_to_bl3x_send_t;
+
+typedef enum{
+	e_ok_ret      = 0,
+
+	e_err_not_support = 0x01,
+
+	e_err_no_item = 0x10,
+	e_err_sha_hdr = 0x11,
+	e_err_sha_tlv = 0x12,
+
+	e_err_in_data = 0x20,
+	e_err_in_size = 0x21,
+	e_err_over_size=0x22,
+	e_err_item_exit=0x23,
+
+}e_ret_type;
+
+typedef enum{
+	e_t_ap_ver    = 0x10,
+	e_t_scp_ver   = 0x11,
+	e_t_sp_ver    = 0x12,
+	e_t_bl2z_ver  = 0x13,
+	e_t_bl30_ver  = 0x14,
+	e_t_bl301_ver = 0x15,
+	e_t_bl31_ver  = 0x16,
+	e_t_bl32_ver  = 0x17,
+	e_t_bl33_ver  = 0x18,
+
+	e_t_root_aes          = 0x20,
+	e_t_root_rsa_sha_all  = 0x21,
+	e_t_root_rsa_sha  	  = 0x22,
+	e_t_root_rsa_puk      = 0x23,
+
+	e_t_user_aes          = 0x30,
+	e_t_user_rsa_sha_all  = 0x31,
+	e_t_user_rsa_sha  	  = 0x32,
+	e_t_user_rsa_puk  	  = 0x33,
+
+	e_t_bl30_rsa_puk      = 0x50,
+	e_t_bl30_aes          = 0x51,
+
+	e_t_bl31_rsa_puk	  = 0x60,
+	e_t_bl31_aes          = 0x61,
+
+	e_t_bl32_rsa_puk      = 0x70,
+	e_t_bl32_aes          = 0x71,
+
+	e_t_bl33_rsa_puk      = 0x80,
+	e_t_bl33_aes          = 0x81,
+
+
+	//....
+
+}e_item_type;
+
+
+//magic ID
+#define	 AML_BL2_TMASTER_MAGIC     (0x324c4240) 	//@BL2
+
+//major & minor version
+#define  AML_BL2_TMASTER_MAJ_VER   (0x00)         //major version
+#define	 AML_BL2_TMASTER_MIN_VER   (0x01)			    //minor version
+#define	 AML_BL2_TMASTER_VERSION   ((AML_BL2_TMASTER_MAJ_VER << 16) |\
+									AML_BL2_TMASTER_MIN_VER)        //major << 16 | minor version
+
+//item data length alignment
+#define  AML_BL2_TMASTER_ITEM_UNIT_LEN            (16)
+#define  AML_BL2_TMASTER_ITEM_ALIGN_LEN(len)      ((len) + (AML_BL2_TMASTER_ITEM_UNIT_LEN-1)) & (~(AML_BL2_TMASTER_ITEM_UNIT_LEN-1))
+
+//CFG reg to store DDR address
+#define  AML_BL2_TMASTER_CFG_REG  (AO_SEC_GP_CFG6)
+
+//DDR buffer size
+#ifndef AML_BL2_TMASTER_DDR_MLEN
+#define  AML_BL2_TMASTER_DDR_MLEN  ((1<<20) - sizeof(s_bl2_to_bl3x_send_t))  //1MB for transfer data from BL2 to BL3X
+#endif
+
+//flag to pass BL2 build info to BL3X
+//#define CONFIG_AML_TLV_BL2_VER_INFO
+
+//IMPORTANT: BECAUSE THOSE FUNCTIONS WILL USE DDR AS STORAGE(DEFAULT) THEN
+//                    ALL THE APIS MSUT BE USED AFTER DDR INIT DONE
+//global APIs to pad & fetch item
+//pad item with data, type and length
+e_ret_type aml_append_item(unsigned int nType, unsigned int nLength, unsigned char *pData);
+//fetch item with type
+e_ret_type aml_fetch_item(unsigned int nType, s_bl2_tlv_item_t **ppItem);
+
+#endif /* __AMLOGIC_TLV_H_ */
diff --git a/include/amlogic/aml_v2_burning.h b/include/amlogic/aml_v2_burning.h
new file mode 100644
index 0000000000..1ecdad65b0
--- /dev/null
+++ b/include/amlogic/aml_v2_burning.h
@@ -0,0 +1,31 @@
+/*
+ * \file        aml_v2_burning.h
+ * \brief       common interfaces for version burning
+ *
+ * \version     1.0.0
+ * \date        09/15/2013
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2013 Amlogic. All Rights Reserved.
+ *
+ */
+
+//is the uboot loaded from usb otg
+int is_tpl_loaded_from_usb(void);
+
+//is the uboot loaded from sdcard mmc 0
+//note only sdmmc supported by romcode when external device boot
+int is_tpl_loaded_from_ext_sdmmc(void);
+
+//Check if uboot loaded from external sdmmc or usb otg
+int aml_burn_check_uboot_loaded_for_burn(int flag);
+
+int aml_burn_factory_producing(int flag, bd_t* bis);
+
+//usb producing mode, if tpl loaded from usb pc tool and auto enter producing mode
+int aml_try_factory_usb_burning(int flag, bd_t* bis);
+
+//Auto enter sdcard burning if booted from sdcard and aml_sdc_burn.ini existed
+int aml_try_factory_sdcard_burning(int flag, bd_t* bis);
+
+
diff --git a/include/amlogic/aml_v3_burning.h b/include/amlogic/aml_v3_burning.h
new file mode 100644
index 0000000000..545ef33b1c
--- /dev/null
+++ b/include/amlogic/aml_v3_burning.h
@@ -0,0 +1,14 @@
+/*
+ * \file        aml_v3_burning.h
+ * \brief       v3 burning entry
+ *
+ * \version     1.0.0
+ * \date        2018/12/20
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2018 Amlogic. All Rights Reserved.
+ *
+ */
+
+int aml_v3_factory_usb_burning(int flag, bd_t* bis);
+
diff --git a/include/amlogic/amlkey_if.h b/include/amlogic/amlkey_if.h
new file mode 100644
index 0000000000..d15bbe7eee
--- /dev/null
+++ b/include/amlogic/amlkey_if.h
@@ -0,0 +1,85 @@
+/*
+ * \file        amlkey_if.h
+ * \brief       APIs of secure key for users
+ *
+ * \version     1.0.0
+ * \date        15/07/10
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __AMLKEY_IF_H__
+#define __AMLKEY_IF_H__
+
+#define AMLKEY_NAME_LEN_MAX     (80)
+
+struct amlkey_if {
+	int32_t (*init)(uint8_t *seed, uint32_t len, int encrypt_type);
+	int32_t (*exsit)(const uint8_t *name);
+	ssize_t (*size)(const uint8_t *name);
+	uint32_t (*get_attr)(const uint8_t *name);
+	ssize_t (*read)(const uint8_t *name, uint8_t *buffer, uint32_t len);
+	ssize_t (*write)(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t attr);
+	int32_t (*hash)(const uint8_t *name, uint8_t *hash);
+};
+
+extern struct amlkey_if *amlkey_if;
+
+static inline uint32_t amlkey_get_attr(const uint8_t *name)
+{
+	return amlkey_if->get_attr(name);
+}
+
+int amlkey_if_init(const void* dt_addr);
+
+//1.init
+static inline int32_t amlkey_init(uint8_t *seed, uint32_t len, int encrypt_type)
+{
+	return amlkey_if->init(seed, len, encrypt_type);
+}
+
+//2. query if the key already programmed, exsit 1, non 0
+static inline int32_t amlkey_isexsit(const uint8_t * name)
+{
+	return amlkey_if->exsit(name);
+}
+
+//3. query attr, key must exsit before those functions were called.
+	//3.1 whether the prgrammed key is secure, secure 1, non 0
+int32_t amlkey_issecure(const uint8_t * name);
+
+	//3.2 whether the prgrammed key is encrypt, encrypt 1, non 0
+int32_t amlkey_isencrypt(const uint8_t * name);
+
+//4. actual bytes of key value
+static inline ssize_t amlkey_size(const uint8_t *name)
+{
+	return amlkey_if->size(name);
+}
+
+//5. read non-secure key in bytes, return byets readback actully.
+static inline ssize_t amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len)
+{
+	return amlkey_if->read(name, buffer, len);
+}
+
+//6.write key with attribute in bytes , return byets readback actully
+	//attr: bit0: secure/non-secure;
+	//		bit8: encrypt/non-encrypt
+#define UNIFYKEY_ATTR_SECURE_MASK	(1<<0)
+#define UNIFYKEY_ATTR_ENCRYPT_MASK	(1<<8)
+static inline ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len,
+				   uint32_t attr)
+{
+	return amlkey_if->write(name, buffer, len, attr);
+}
+
+//7. get the hash value of programmed secure key | 32bytes length, sha256
+static inline int32_t amlkey_hash_4_secure(const uint8_t *name, uint8_t *hash)
+{
+	return amlkey_if->hash(name, hash);
+}
+
+#endif// #ifndef __AMLKEY_IF_H__
+
diff --git a/include/amlogic/anti-rollback.h b/include/amlogic/anti-rollback.h
new file mode 100644
index 0000000000..95d42651ea
--- /dev/null
+++ b/include/amlogic/anti-rollback.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014-2017 Amlogic, Inc. All rights reserved.
+ *
+ * All information contained herein is Amlogic confidential.
+ *
+ * This software is provided to you pursuant to Software License Agreement
+ * (SLA) with Amlogic Inc ("Amlogic"). This software may be used
+ * only in accordance with the terms of this agreement.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification is strictly prohibited without prior written permission from
+ * Amlogic.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ANTI_ROLLBACK_
+#define __ANTI_ROLLBACK_
+
+#include <linux/types.h>
+
+bool check_antirollback(uint32_t kernel_version);
+
+bool set_avb_antirollback(uint32_t index, uint32_t version);
+bool get_avb_antirollback(uint32_t index, uint32_t* version);
+bool get_avb_lock_state(uint32_t* lock_state);
+bool avb_lock(void);
+bool avb_unlock(void);
+
+#endif
diff --git a/include/amlogic/asm/bl31_apis.h b/include/amlogic/asm/bl31_apis.h
new file mode 100644
index 0000000000..4227494b93
--- /dev/null
+++ b/include/amlogic/asm/bl31_apis.h
@@ -0,0 +1,166 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/bl31_apis.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/*
+ * Trustzone API
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef __GXBB_BL31_APIS_H
+#define __GXBB_BL31_APIS_H
+
+#include <amlogic/asm/io.h>
+
+/*#define SRAM_READ				0x82000010
+#define CORE_RD_REV1			0x82000011
+#define SRAM_ACS_READ		0x82000012
+#define SRAM_ACS_INDIRECT_READ		0x82000013*/
+
+#define GET_SHARE_MEM_INPUT_BASE		0x82000020
+#define GET_SHARE_MEM_OUTPUT_BASE		0x82000021
+#define GET_REBOOT_REASON		0x82000022
+#define GET_SHARE_STORAGE_IN_BASE		0x82000023
+#define GET_SHARE_STORAGE_OUT_BASE		0x82000024
+#define GET_SHARE_STORAGE_BLOCK_BASE	0x82000025
+#define GET_SHARE_STORAGE_MESSAGE_BASE	0x82000026
+#define GET_SHARE_STORAGE_BLOCK_SIZE		0x82000027
+#define SET_STORAGE_INFO		0x82000028
+#define SET_REBOOT_REASON		0x82000049
+
+/* Set Reboot Reason then Reboot*/
+#define PSCI_SYS_REBOOT		0x84000009
+
+/* SECUREOS DEFINITION*/
+/* SMC Identifiers for non-secure world functions */
+#define CALL_TRUSTZONE_HAL_API                  0x5
+
+/* EFUSE */
+#define EFUSE_READ					0x82000030
+#define EFUSE_WRITE				0x82000031
+#define EFUSE_WRITE_PATTERN		0x82000032
+#define EFUSE_USER_MAX    0x82000033
+
+#define DEBUG_EFUSE_WRITE_PATTERN	0x820000F0
+#define DEBUG_EFUSE_READ_PATTERN	0x820000F1
+
+/* JTAG*/
+#define JTAG_ON                                0x82000040
+#define JTAG_OFF                               0x82000041
+
+#define SET_USB_BOOT_FUNC	0x82000043
+	/* USB BOOT FUNC sub command list*/
+	#define CLEAR_USB_BOOT			1
+	#define FORCE_USB_BOOT			2
+	#define RUN_COMD_USB_BOOT		3
+	#define PANIC_DUMP_USB_BOOT	4
+
+#define GET_CHIP_ID			0x82000044
+/* Security Key*/
+#define SECURITY_KEY_QUERY	0x82000060
+#define SECURITY_KEY_READ	0x82000061
+#define SECURITY_KEY_WRITE	0x82000062
+#define SECURITY_KEY_TELL		0x82000063
+#define SECURITY_KEY_VERIFY	0x82000064
+#define SECURITY_KEY_STATUS	0x82000065
+#define SECURITY_KEY_NOTIFY	0x82000066
+#define SECURITY_KEY_LIST		0x82000067
+#define SECURITY_KEY_REMOVE	0x82000068
+#define SECURITY_KEY_NOTIFY_EX	0x82000069
+#define SECURITY_KEY_SET_ENCTYPE	0x8200006A
+#define SECURITY_KEY_GET_ENCTYPE	0x8200006B
+#define SECURITY_KEY_VERSION		0x8200006C
+
+/*viu probe en*/
+#define VIU_PREOBE_EN		0x82000080
+
+/* KEYMASTER */
+#define SET_BOOT_PARAMS		0x82000072
+#define SHA256_DIGEST_SIZE  32
+typedef struct {
+	uint32_t device_locked;
+	uint32_t verified_boot_state;
+	uint8_t verified_boot_key[SHA256_DIGEST_SIZE];
+	uint8_t verified_boot_hash[SHA256_DIGEST_SIZE];
+} keymaster_boot_params;
+
+/* Secure HAL APIs */
+#define TRUSTZONE_HAL_API_SRAM                  0x400
+
+
+#define SRAM_HAL_API_CHECK_EFUSE 0x403
+struct sram_hal_api_arg {
+	unsigned int cmd;
+	unsigned int req_len;
+	unsigned int res_len;
+	unsigned long req_phy_addr;
+	unsigned long res_phy_addr;
+	unsigned long ret_phy_addr;
+};
+
+#define JTAG_STATE_ON  0
+#define JTAG_STATE_OFF 1
+#define JTAG_M3_AO     0
+#define JTAG_M3_EE     1
+#define JTAG_A53_AO    2
+#define JTAG_A53_EE 3
+#define CLUSTER_BIT 2
+
+#define GET_AVBKEY_FROM_FIP              0x820000b0
+
+/////////////////////////////////////////////////////////////////////////////////
+#define AML_DATA_PROCESS                 (0x820000FF)
+	#define AML_D_P_W_EFUSE_SECURE_BOOT  (0x10)
+	#define AML_D_P_W_EFUSE_PASSWORD     (0x11)
+	#define AML_D_P_W_EFUSE_CUSTOMER_ID  (0x12)
+	#define AML_D_P_W_EFUSE_AMLOGIC 	 (0x20)
+	#define AML_D_P_IMG_DECRYPT          (0x40)
+	#define AML_D_P_UPGRADE_CHECK        (0x80)
+	#define AML_D_Q_IMG_SIG_HDR_SIZE     (0x100)
+
+#define GXB_EFUSE_PATTERN_SIZE      (0x500)
+#define GXB_IMG_SIZE                (24<<20)
+#define GXB_IMG_LOAD_ADDR           (0x1080000)
+	#define GXB_IMG_DEC_KNL   (1<<0)
+	#define GXB_IMG_DEC_RMD   (1<<1)
+	#define GXB_IMG_DEC_DTB   (1<<2)
+	#define GXB_IMG_DEC_ALL   (GXB_IMG_DEC_KNL|GXB_IMG_DEC_RMD|GXB_IMG_DEC_DTB)
+
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+
+void aml_set_jtag_state(unsigned state, unsigned select);
+unsigned aml_get_reboot_reason(void);
+unsigned aml_reboot(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2);
+void aml_set_reboot_reason(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2);
+unsigned long aml_sec_boot_check(unsigned long ,unsigned long ,unsigned long,unsigned long );
+long get_sharemem_info(unsigned long);
+void set_usb_boot_function(unsigned long command);
+void aml_system_off(void);
+
+void bl31_get_chipid(unsigned int *, unsigned int *,
+	unsigned int *, unsigned int *);
+void set_viu_probe_enable(void);
+int32_t set_boot_params(const keymaster_boot_params*);
+int32_t get_avbkey_from_fip(uint8_t *buf, uint32_t buflen);
+#endif
diff --git a/include/amlogic/asm/clock.h b/include/amlogic/asm/clock.h
new file mode 100644
index 0000000000..3a24778206
--- /dev/null
+++ b/include/amlogic/asm/clock.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2018 - AmLogic, Inc.
+ */
+#ifndef _ARCH_MESON_G12A_CLOCK_H_
+#define _ARCH_MESON_G12A_CLOCK_H_
+
+/*
+ * Clock controller register offsets
+ *
+ * Register offsets from the data sheet are listed in comment blocks below.
+ * Those offsets must be multiplied by 4 before adding them to the base address
+ * to get the right value
+ */
+
+#define HHI_GCLK_MPEG0			0x140 /* 0x50 offset in data sheet1 */
+#define HHI_GCLK_MPEG1			0x144 /* 0x51 offset in data sheet1 */
+#define HHI_GCLK_MPEG2			0x148 /* 0x52 offset in data sheet1 */
+#define HHI_GCLK_OTHER			0x150 /* 0x54 offset in data sheet1 */
+#define HHI_FIX_PLL_CNTL0		0x2A0 /* 0xa8 offset in data sheet1 */
+#define HHI_FIX_PLL_CNTL1		0x2A4 /* 0xa9 offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL0		0x2f4 /* 0xbd offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL1		0x2f8 /* 0xbe offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL2		0x2fc /* 0xbf offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL3		0x300 /* 0xc0 offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL4		0x304 /* 0xc1 offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL5		0x308 /* 0xc2 offset in data sheet1 */
+#define HHI_SYS_PLL_CNTL6		0x30c /* 0xc3 offset in data sheet1 */
+#define HHI_SPICC_CLK_CNTL		0x3dc /* 0xf7 offset in data sheet1 */
+#define HHI_NAND_CLK_CNTL		0x25c /* 0x97 offset in data sheet1 */
+#define HHI_SD_EMMC_CLK_CNTL		0x264 /* 0x99 offset in data sheet1 */
+
+#define CLKID_UNREALIZED		0xfff
+
+/* AO registers */
+#define AO_SAR_CLK			0x90
+#define AO_CLK_GATE0			0x4c
+
+ulong meson_measure_clk_rate(unsigned int clk);
+
+#endif
diff --git a/include/amlogic/asm/cpu_config.h b/include/amlogic/asm/cpu_config.h
new file mode 100644
index 0000000000..7e7c758f86
--- /dev/null
+++ b/include/amlogic/asm/cpu_config.h
@@ -0,0 +1,101 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/cpu_config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _BOOT_ROM_CONFIG_H_
+#define _BOOT_ROM_CONFIG_H_
+
+/***********************************************************
+ * The following constants are GXBB definition
+ **********************************************************/
+#define ROMBOOT_START   0xD9040000
+#define ROM_SIZE        (64*1024)
+#define ROMBOOT_END     (ROMBOOT_START+ROM_SIZE)
+
+/***********************************************************
+ * AHB-SRAM Total Size 80KB, layout shown as below
+ *
+ * ROMCODE use the top 32KB
+ *
+ * [	128]	0xD901_3F80 - 0xD901_3FFF	Reserved
+ * [	128]	0xD901_3F00 - 0xD901_3F7F	CPUs Boot Entry
+ * [	256]	0xD901_3E00 - 0xD901_3EFF	Debug Info
+ * [	512]	0xD901_3C00 - 0xD901_3DFF	eFuse mirror
+ * [	 1K]	0xD901_3800 - 0xD901_3BFF	Secure Mailbox (3)
+ * [	 1K]	0xD901_3400 - 0xD901_37FF	High Mailbox (2) *
+ * [	 1K]	0xD901_3000 - 0xD901_33FF	High Mailbox (1) *
+ * [	26K]	0xD900_C800 - 0xD901_2FFF	BL1 Stack, BSS
+ * [	 1K]	0xD900_C400 - 0xD900_C7FF	NAND, USB Buffer
+ * [	 1K]	0xD900_C000 - 0xD900_C3FF	Reserved
+ *
+ **********************************************************/
+#define RAM_START			0xD9000000
+#define RAM_SIZE			(80 * 1024)
+#define BL1_RAM_START			(RAM_START + 0xC000)
+#define BL1_RAM_SIZE			(32 * 1024)
+#define BL1_RAM_END			(BL1_RAM_START + BL1_RAM_SIZE)
+#define BSS_START			(BL1_RAM_START + (2 * 1024))
+#define BSS_SIZE			(18 * 1024)
+#define _STACK_END			(BSS_START + BSS_SIZE + 8*1024)
+#define BL1_EFUSE_MIRROR		(BL1_RAM_END - 1024)
+#define P_SHARED_EFUSE_MIRROR		(volatile uint32_t *)(BL1_EFUSE_MIRROR)
+#define BL1_DEBUG_BUFFER		(BL1_RAM_END - 512)
+#define CPU_BOOT_ENTRY		(BL1_DEBUG_BUFFER + 256)
+#define P_SHARED_DEBUG_BUFF		(volatile uint32_t *)(BL1_DEBUG_BUFFER)
+#define BL1_SEC_MBX			(BL1_RAM_END - 2*1024)
+#define BL1_NAND_BUFF			(BL1_RAM_START + 1024)
+#define BL1_USB_BUFF			(BL1_NAND_BUFF)
+
+#define MEMORY_LOC			RAM_START
+
+#define SRAM_DEBUG_BUFF_SIZE		256
+
+/* BL2 SPL size */
+#define BL2_SIZE			(64 * 1024)
+
+//for signature test
+//#define CONFIG_AML_SIG_TEST_BUILD
+
+/* Software SHA2 */
+#define CONFIG_SHA2_SW
+
+/* Hardware SHA2 */
+#define CONFIG_SHA2_HW
+#define SHA2_HW_UPDATE_API
+
+/* Keep timer config in conf.h */
+#define CONFIG_TIMER
+
+/* Bootrom debug info */
+#define CONFIG_DEBUG_INFO
+
+/* Mincrypt RSA library */
+//#define CONFIG_MINCRYPT
+
+/* PolarSSL RSA library */
+#define CONFIG_POLARSSL_RSA
+
+#ifdef CONFIG_POLARSSL_RSA
+#ifndef CONFIG_MALLOC
+#define CONFIG_MALLOC
+#endif /* ! CONFIG_MALLOC */
+#endif /* CONFIG_POLARSSL_RSA */
+
+#endif /* _BOOT_ROM_CONFIG_H_ */
diff --git a/include/amlogic/asm/cpu_sdio.h b/include/amlogic/asm/cpu_sdio.h
new file mode 100644
index 0000000000..baf8706584
--- /dev/null
+++ b/include/amlogic/asm/cpu_sdio.h
@@ -0,0 +1,264 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/cpu_sdio.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __CPU_SDIO_H__
+#define __CPU_SDIO_H__
+
+#define SD_EMMC_BASE_A 0xFFE03000
+#define SD_EMMC_BASE_B 0xFFE05000
+#define SD_EMMC_BASE_C 0xFFE07000
+
+#define SDIO_PORT_A 0
+#define SDIO_PORT_B 1
+#define SDIO_PORT_C 2
+
+#if 0
+#define	SD_EMMC_RXD_ERROR				1
+#define	SD_EMMC_TXD_ERROR				1<<1
+#define	SD_EMMC_DESC_ERROR				1<<2
+#define	SD_EMMC_RESP_CRC_ERROR			1<<3
+#define	SD_EMMC_RESP_TIMEOUT_ERROR		1<<4
+#define	SD_EMMC_DESC_TIMEOUT_ERROR		1<<5
+#endif
+
+struct sd_emmc_global_regs {
+    volatile uint32_t gclock;     // 0x00
+    volatile uint32_t gdelay;     // 0x04
+	volatile uint32_t gdelay1;    //0x08
+    volatile uint32_t gadjust;    // 0x0c
+    volatile uint32_t gcalout;    // 0x10
+    volatile uint32_t reserved_14[11];   // 0x14~0x3c
+    volatile uint32_t gstart;     // 0x40
+    volatile uint32_t gcfg;       // 0x44
+    volatile uint32_t gstatus;    // 0x48
+    volatile uint32_t girq_en;    // 0x4c
+    volatile uint32_t gcmd_cfg;   // 0x50
+    volatile uint32_t gcmd_arg;   // 0x54
+    volatile uint32_t gcmd_dat;   // 0x58
+    volatile uint32_t gcmd_rsp0;   // 0x5c
+    volatile uint32_t gcmd_rsp1;  // 0x60
+    volatile uint32_t gcmd_rsp2;  // 0x64
+    volatile uint32_t gcmd_rsp3;  // 0x68
+    volatile uint32_t reserved_6c;       // 0x6c
+    volatile uint32_t gcurr_cfg;  // 0x70
+    volatile uint32_t gcurr_arg;  // 0x74
+    volatile uint32_t gcurr_dat;  // 0x78
+    volatile uint32_t gcurr_rsp;  // 0x7c
+    volatile uint32_t gnext_cfg;  // 0x80
+    volatile uint32_t gnext_arg;  // 0x84
+    volatile uint32_t gnext_dat;  // 0x88
+    volatile uint32_t gnext_rsp;  // 0x8c
+    volatile uint32_t grxd;       // 0x90
+    volatile uint32_t gtxd;       // 0x94
+    volatile uint32_t reserved_98[90];   // 0x98~0x1fc
+    volatile uint32_t gdesc[128]; // 0x200
+    volatile uint32_t gping[128]; // 0x400
+    volatile uint32_t gpong[128]; // 0x800
+};
+
+union sd_emmc_setup {
+    uint32_t d32;
+    struct {
+        unsigned bw:3;
+        unsigned fast:1;
+        unsigned par:3;
+        unsigned hcs:1;
+        unsigned sd:1;
+        unsigned sdhc:1;
+        unsigned type:6;
+        unsigned rca:16;
+    } b;
+};
+
+struct sd_emmc_desc_info{
+    uint32_t cmd_info;
+    uint32_t cmd_arg;
+    uint32_t data_addr;
+    uint32_t resp_addr;
+};
+
+struct cmd_cfg{
+    uint32_t length:9;
+    uint32_t block_mode:1;
+    uint32_t r1b:1;
+    uint32_t end_of_chain:1;
+    uint32_t timeout:4;
+    uint32_t no_resp:1;
+    uint32_t no_cmd:1;
+    uint32_t data_io:1;
+    uint32_t data_wr:1;
+    uint32_t resp_nocrc:1;
+    uint32_t resp_128:1;
+    uint32_t resp_num:1;
+    uint32_t data_num:1;
+    uint32_t cmd_index:6;
+    uint32_t error:1;
+    uint32_t owner:1;
+};
+
+struct sd_emmc_status{
+	uint32_t rxd_err:8;      /*[7:0]     RX data CRC error per wire, for multiple block read, the CRC errors are ORed together.*/
+	uint32_t txd_err:1;      /*[8]       TX data CRC error, for multiple block write, any one of blocks CRC error. */
+	uint32_t desc_err:1;     /*[9]       SD/eMMC controller doesnt own descriptor. The owner bit is 0, set cfg_ignore_owner to ignore this error.*/
+	uint32_t resp_err:1;     /*[10]      Response CRC error.*/
+	uint32_t resp_timeout:1; /*[11]      No response received before time limit. The timeout limit is set by cfg_resp_timeout.*/
+	uint32_t desc_timeout:1; /*[12]      Descriptor execution time over time limit. The timeout limit is set by descriptor itself.*/
+                            /*      Consider the multiple block read/write, set the proper timeout limits.*/
+	uint32_t end_of_chain:1; /*[13]      End of Chain IRQ, Normal IRQ. */
+	uint32_t desc_irq:1;     /*[14]      This descriptor requests an IRQ, Normal IRQ, the descriptor chain execution keeps going on.*/
+	uint32_t irq_sdio:1;     /*[15]      SDIO device uses DAT[1] to request IRQ. */
+	uint32_t dat_i:8;        /*[23:16]   Input data signals. */
+	uint32_t cmd_i:1;        /*[24]      nput response signal. */
+	uint32_t ds:1;           /*[25]      Input data strobe. */
+	uint32_t bus_fsm:4;      /*[29:26]   BUS fsm */
+    uint32_t desc_wr_rdy:1;  /*[30]      Descriptor write back process is done and it is ready for CPU to read.*/
+	uint32_t core_rdy:1;	 /*[31]       desc_busy or sd_emmc_irq or bus_fsm is not idle.*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_clock{
+    uint32_t div:6;          /*[5:0]     Clock divider. Frequency = clock source/cfg_div, Maximum divider 63. */
+                            /*Clock off: cfg_div==0, the clock is disabled */
+                            /*Divider bypass: cfg_div==1, clock source is used as core clock without divider. */
+    uint32_t src:2;          /*[7:6]     Clock source, 0: Crystal 24MHz, 1: Fix PLL, 850MHz*/
+                            /* 2: MPLL, <637MHz, used for 400MHz exactly. 3: different PLL */
+    uint32_t core_phase:2;   /*[9:8]     Core clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t tx_phase:2;     /*[11:10]   TX clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t rx_phase:2;     /*[13:12]   RX clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t reserved14:2;
+    uint32_t tx_delay:6;     /*[21:16]   TX clock delay line. 0: no delay, n: delay n*200ps. Maximum delay 3ns.*/
+    uint32_t rx_delay:6;     /*[27:22]   RX clock delay line. 0: no delay, n: delay n*200ps. Maximum delay 3ns.*/
+    uint32_t always_on:1;    /*[28]      1: Keep clock always on. 0: Clock on/off controlled by activities. */
+                            /*Any APB3 access or descriptor execution will keep clock on.*/
+    uint32_t irq_sdio_sleep:1; /*[29]    1: enable IRQ sdio when in sleep mode. */
+	uint32_t irq_sdio_sleep_ds:1;/*[30] 1:enable ds as irq*/
+    uint32_t reserved26:1;
+};
+
+struct sd_emmc_delay{
+    uint32_t dat0:6;         /*[3:0]       Data 0 delay line. */
+    uint32_t dat1:6;         /*[7:4]       Data 1 delay line. */
+    uint32_t dat2:6;         /*[11:8]      Data 2 delay line. */
+    uint32_t dat3:6;         /*[15:12]     Data 3 delay line. */
+    uint32_t dat4:6;         /*[19:16]     Data 4 delay line. */
+	uint32_t spare:2;
+};
+
+struct sd_emmc_delay1{
+    uint32_t dat5:6;         /*[23:20]     Data 5 delay line. */
+    uint32_t dat6:6;         /*[27:24]     Data 6 delay line. */
+    uint32_t dat7:6;         /*[31:28]     Data 7 delay line. */
+	uint32_t dat8:6;         /*[31:28]     Data 7 delay line. */
+	uint32_t dat9:6;         /*[31:28]     Data 7 delay line. */
+	uint32_t spare:2;
+};
+
+struct sd_emmc_adjust{
+    uint32_t cmd_delay:4;           /*[3:0]       Command delay line. */
+    uint32_t ds_delay:4;            /*[7:4]       DS delay line. */
+    uint32_t cali_sel:4;            /*[11:8]      Select one signal to be tested.*/
+                                        /*Signals are labeled from 0 to 9 the same as delay lines. */
+    uint32_t cali_enable:1;         /*[12]        Enable calibration. */
+    uint32_t adj_enable:1;          /*[13]       Adjust interface timing by resampling the input signals. */
+    uint32_t cali_rise:1;           /*[14]       1: test the rising edge. 0: test the falling edge. */
+    uint32_t ds_enable:1;			/*[15]		Sampling the DAT based on DS in HS400 mode*/
+    uint32_t adj_delay:6;           /*[21:16]       Resample the input signals when clock index==adj_delay. */
+    uint32_t adj_auto:1;			/*[22]			Use cali_dut first falling edge to adjust the timing */
+										/*set cali_enable to 1 to use this function*/
+	uint32_t reserved23:9;
+};
+
+
+struct sd_emmc_calout{
+    uint32_t cali_idx:6;         /*[5:0]       Calibration reading. The event happens at this index. */
+    uint32_t reserved6:1;
+    uint32_t cali_vld:1;         /*[7]         The reading is valid. */
+    uint32_t cali_setup:8;       /*[15:8]      Copied from BASE+0x8 [15:8] include cali_sel, cali_enable, adj_enable, cali_rise. */
+    uint32_t reserved16:16;
+};
+
+
+struct sd_emmc_start{
+	uint32_t init:1;         /*[0]   1: Read descriptor from internal SRAM, limited to 32 descriptors. */
+                            /*  0: Read descriptor from external DDR */
+	uint32_t busy:1;         /*[1]   1: Start command chain execution process. 0: Stop */
+	uint32_t addr:30;        /*[31:2] Descriptor address, the last 2 bits are 0, 4 bytes aligned. */
+                            /*  When internal SRAM is used, the valid address range is from 0x200~0x3ff */
+                            /*  When external DDR is used, the valid address is anywhere in DDR, the length of chain is unlimited.*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_config{
+	uint32_t bus_width:2;    /*[1:0]     0: 1 bit, 1: 4 bits, 2: 8 bits, 3: 2 bits (not supported)*/
+	uint32_t ddr:1;          /*[2]       1: DDR mode, 0: SDR mode */
+	uint32_t dc_ugt:1;       /*[3]       1: DDR access urgent, 0: DDR access normal. */
+	uint32_t bl_len:4;       /*[7:4]     Block length 2^cfg_bl_len, because internal buffer size is limited to 512 bytes, the cfg_bl_len <=9. */
+	uint32_t resp_timeout:4; /*[11:8]    Wait response till 2^cfg_resp_timeout core clock cycles. Maximum 32768 core cycles. */
+	uint32_t rc_cc:4;        /*[15:12]   Wait response-command, command-command gap before next command, 2^cfg_rc_cc core clock cycles. */
+	uint32_t out_fall:1;     /*[16]      DDR mode only. The command and TXD start from rising edge. Set 1 to start from falling edge. */
+	uint32_t blk_gap_ip:1;   /*[17]      1: Enable SDIO data block gap interrupt period. 0: Disabled.*/
+	uint32_t spare:1;        /*[18]      Spare,  ??? need check*/
+	uint32_t ignore_owner:1; /*[19]      Use this descriptor even if its owner bit is 0.*/
+	uint32_t chk_ds:1;       /*[20]      Check data strobe in HS400.*/
+	uint32_t cmd_low:1;      /*[21]      Hold CMD as output Low, eMMC boot mode.*/
+	uint32_t stop_clk:1;     /*[22]      1: stop clock. 0: normal clock.*/
+	                        /*In normal mode, the clock is automatically on/off during reading mode to back off reading in case of*/
+	                        /*DDR slow response, stop clock is used in voltage switch.*/
+	uint32_t auto_clk:1;     /*[23]      1: when BUS is idle and no descriptor is available, turn off clock, to save power.*/
+                            /*      0: core clock is always on.*/
+    uint32_t txd_add_err:1;	/*[24]   	TXD add error test*/
+							/*Test feature, should not be used in normal condition.*/
+							/*It will inverted the first CRC bits of the 3rd block.*/
+							/*Block index starts from 0, 1, 2, */
+    uint32_t txd_retry:1;	/*[25]   	When TXD CRC error, host sends the block again.*/
+							/*The total number of retries of one descriptor is limited to 15, */
+							/*after 15 retries, the TXD_err is set to high.*/
+    uint32_t revd:8;	        /*[31:26]   reved*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_irq_en{
+	uint32_t rxd_err:8;      /*[7:0]     RX data CRC error per wire.*/
+	uint32_t txd_err:1;      /*[8]       TX data CRC error. */
+	uint32_t desc_err:1;     /*[9]       SD/eMMC controller doesnt own descriptor. */
+	uint32_t resp_err:1;     /*[10]      Response CRC error.*/
+	uint32_t resp_timeout:1; /*[11]      No response received before time limit. */
+	uint32_t desc_timeout:1; /*[12]      Descriptor execution time over time limit. */
+	uint32_t end_of_chain:1; /*[13]      End of Chain IRQ. */
+	uint32_t desc_irq:1;     /*[14]      This descriptor requests an IRQ. */
+	uint32_t irq_sdio:1;     /*[15]      Enable sdio interrupt. */
+    uint32_t revd:16;	    /*[31:16]   reved*/
+};
+
+struct sd_emmc_data_info{
+	uint32_t cnt:10;         /*[9:0]     Rxd words received from BUS. Txd words received from DDR.*/
+	uint32_t blk:9;          /*[24:16]   Rxd Blocks received from BUS. Txd blocks received from DDR.*/
+	uint32_t revd:30;        /*[31:17]   Reved. */
+};
+
+
+struct sd_emmc_card_info{
+	uint32_t txd_cnt:10;     /*[9:0]     Txd BUS cycle counter. */
+	uint32_t txd_blk:9;      /*[24:16]   Txd BUS block counter.*/
+	uint32_t revd:30;        /*[31:17]   Reved. */
+};
+
+#endif
diff --git a/include/amlogic/asm/efuse.h b/include/amlogic/asm/efuse.h
new file mode 100644
index 0000000000..b5ea02723f
--- /dev/null
+++ b/include/amlogic/asm/efuse.h
@@ -0,0 +1,62 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/efuse.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __EFUSE_H
+#define __EFUSE_H
+
+#include <config.h>
+#include <common.h>
+
+/* efuse HAL_API arg */
+struct efuse_hal_api_arg {
+	unsigned int cmd;		/* R/W */
+	unsigned int offset;
+	unsigned int size;
+	unsigned long buffer_phy;
+	unsigned long retcnt_phy;
+};
+
+
+#define EFUSE_BYTES				512   /* (EFUSE_BITS/8) */
+
+#define EFUSE_HAL_API_READ	0
+#define EFUSE_HAL_API_WRITE 1
+#define EFUSE_HAL_API_WRITE_PATTERN 2
+#define EFUSE_HAL_API_USER_MAX 3
+
+#define EFUSE_USER_MASK            (0x1 << 16)
+#define EFUSE_THERMAL_MASK         (0x1 << 17)
+#define EFUSE_THERMAL_VERFLAG_MASK (0x1 << 18)
+#define EFUSE_ENCRYPT_MASK         (0x1 << 19)
+
+//#define ASSIST_HW_REV                              0x1f53
+
+int efuse_read_usr(char *buf, size_t count, loff_t *ppos);
+int efuse_write_usr(char *buf, size_t count, loff_t *ppos);
+uint32_t efuse_get_max(void);
+ssize_t efuse_read(char *buf, size_t count, loff_t *ppos);
+ssize_t efuse_write(const char *buf, size_t count, loff_t *ppos);
+
+int32_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg);
+int32_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg);
+
+#endif
+
diff --git a/include/amlogic/asm/io.h b/include/amlogic/asm/io.h
new file mode 100644
index 0000000000..8640303b51
--- /dev/null
+++ b/include/amlogic/asm/io.h
@@ -0,0 +1,118 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/io.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __MACH_MESSON_REGS_IO_H
+#define __MACH_MESSON_REGS_IO_H
+
+#ifndef __ASSEMBLY__
+
+#include <asm/io.h>
+#define IO_CBUS_BASE                    (0xFFD00000L)
+#define IO_AXI_BUS_BASE                 (0xFFB00000L) /* gpv */
+#define IO_AHB_BUS_BASE                 (0xFF500000L) /* usb0 */
+#define IO_APB_BUS_BASE                 (0xFFFC0000L) /* AHB SRAM, sec/sys ahb? txlx_mem_map.xlsx */
+#define IO_APB_HDMI_BUS_BASE            (0xFFE00000L) /*  */
+#define IO_VPU_BUS_BASE                 (0xFF900000L) /* VPU */
+
+#define CBUS_REG_OFFSET(reg) ((reg) << 2)
+#define CBUS_REG_ADDR(reg)	 (IO_CBUS_BASE + CBUS_REG_OFFSET(reg))
+
+#define AXI_REG_OFFSET(reg)  ((reg) << 2)
+#define AXI_REG_ADDR(reg)	 (IO_AXI_BUS_BASE + AXI_REG_OFFSET(reg))
+
+#define AHB_REG_OFFSET(reg)  ((reg) << 2)
+#define AHB_REG_ADDR(reg)	 (IO_AHB_BUS_BASE + AHB_REG_OFFSET(reg))
+
+#define VPU_REG_OFFSET(reg)  ((reg) << 2)
+#define VPU_REG_ADDR(reg)	 (IO_VPU_BUS_BASE + VPU_REG_OFFSET(reg))
+
+
+#define APB_REG_OFFSET(reg)  (reg)
+#define APB_REG_ADDR(reg)	 (IO_APB_BUS_BASE + APB_REG_OFFSET(reg))
+#define APB_REG_ADDR_VALID(reg) (((unsigned long)(reg) & 3) == 0)
+
+#define APB_HDMI_REG_OFFSET(reg)  (reg)
+#define APB_HDMI_REG_ADDR(reg)	 (IO_APB_HDMI_BUS_BASE + APB_HDMI_REG_OFFSET(reg))
+#define APB_HDMI_REG_ADDR_VALID(reg) (((unsigned long)(reg) & 3) == 0)
+
+
+#define WRITE_CBUS_REG(reg, val) __raw_writel(val, CBUS_REG_ADDR(reg))
+#define READ_CBUS_REG(reg) (__raw_readl(CBUS_REG_ADDR(reg)))
+#define WRITE_CBUS_REG_BITS(reg, val, start, len) \
+    WRITE_CBUS_REG(reg,	(READ_CBUS_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_CBUS_REG_BITS(reg, start, len) \
+    ((READ_CBUS_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_CBUS_REG_MASK(reg, mask) WRITE_CBUS_REG(reg, (READ_CBUS_REG(reg)&(~(mask))))
+#define SET_CBUS_REG_MASK(reg, mask)   WRITE_CBUS_REG(reg, (READ_CBUS_REG(reg)|(mask)))
+
+#define WRITE_AXI_REG(reg, val) __raw_writel(val, AXI_REG_ADDR(reg))
+#define READ_AXI_REG(reg) (__raw_readl(AXI_REG_ADDR(reg)))
+#define WRITE_AXI_REG_BITS(reg, val, start, len) \
+    WRITE_AXI_REG(reg,	(READ_AXI_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_AXI_REG_BITS(reg, start, len) \
+    ((READ_AXI_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_AXI_REG_MASK(reg, mask) WRITE_AXI_REG(reg, (READ_AXI_REG(reg)&(~(mask))))
+#define SET_AXI_REG_MASK(reg, mask)   WRITE_AXI_REG(reg, (READ_AXI_REG(reg)|(mask)))
+
+#define WRITE_AHB_REG(reg, val) __raw_writel(val, AHB_REG_ADDR(reg))
+#define READ_AHB_REG(reg) (__raw_readl(AHB_REG_ADDR(reg)))
+#define WRITE_AHB_REG_BITS(reg, val, start, len) \
+    WRITE_AHB_REG(reg,	(READ_AHB_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_AHB_REG_BITS(reg, start, len) \
+    ((READ_AHB_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_AHB_REG_MASK(reg, mask) WRITE_AHB_REG(reg, (READ_AHB_REG(reg)&(~(mask))))
+#define SET_AHB_REG_MASK(reg, mask)   WRITE_AHB_REG(reg, (READ_AHB_REG(reg)|(mask)))
+
+#define WRITE_APB_REG(reg, val) __raw_writel(val, APB_REG_ADDR(reg))
+#define READ_APB_REG(reg) (__raw_readl(APB_REG_ADDR(reg)))
+#define WRITE_APB_REG_BITS(reg, val, start, len) \
+    WRITE_APB_REG(reg,	(READ_APB_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_APB_REG_BITS(reg, start, len) \
+    ((READ_APB_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_APB_REG_MASK(reg, mask) WRITE_APB_REG(reg, (READ_APB_REG(reg)&(~(mask))))
+#define SET_APB_REG_MASK(reg, mask)   WRITE_APB_REG(reg, (READ_APB_REG(reg)|(mask)))
+
+#define WRITE_APB_HDMI_REG(reg, val) __raw_writel(val, APB_HDMI_REG_ADDR(reg))
+#define READ_APB_HDMI_REG(reg) (__raw_readl(APB_HDMI_REG_ADDR(reg)))
+#define WRITE_APB_HDMI_REG_BITS(reg, val, start, len) \
+    WRITE_APB_HDMI_REG(reg,	(READ_APB_HDMI_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_APB_HDMI_REG_BITS(reg, start, len) \
+    ((READ_APB_HDMI_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_APB_HDMI_REG_MASK(reg, mask) WRITE_APB_HDMI_REG(reg, (READ_APB_HDMI_REG(reg)&(~(mask))))
+#define SET_APB_HDMI_REG_MASK(reg, mask)   WRITE_APB_HDMI_REG(reg, (READ_APB_HDMI_REG(reg)|(mask)))
+
+/* for back compatible alias */
+#define WRITE_MPEG_REG(reg, val) \
+	WRITE_CBUS_REG(reg, val)
+#define READ_MPEG_REG(reg) \
+	READ_CBUS_REG(reg)
+#define WRITE_MPEG_REG_BITS(reg, val, start, len) \
+	WRITE_CBUS_REG_BITS(reg, val, start, len)
+#define READ_MPEG_REG_BITS(reg, start, len) \
+	READ_CBUS_REG_BITS(reg, start, len)
+#define CLEAR_MPEG_REG_MASK(reg, mask) \
+	CLEAR_CBUS_REG_MASK(reg, mask)
+#define SET_MPEG_REG_MASK(reg, mask) \
+	SET_CBUS_REG_MASK(reg, mask)
+#endif
+
+
+#endif
diff --git a/include/amlogic/asm/register.h b/include/amlogic/asm/register.h
new file mode 100644
index 0000000000..aa342a50fd
--- /dev/null
+++ b/include/amlogic/asm/register.h
@@ -0,0 +1,98 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/register.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __REGISTER_H__
+#define __REGISTER_H__
+
+#define IO_CBUS_BASE			0xFFD00000
+#define IO_AXI_BUS_BASE			0xFFB00000
+#define IO_AHB_BUS_BASE			0xFF500000
+#define IO_APB_BUS_BASE			0xFFFC0000
+#define IO_APB_HDMI_BUS_BASE	0xFFE00000
+#define IO_VPU_BUS_BASE			0xFF900000
+
+#define CBUS_REG_OFFSET(reg) ((reg) << 2)
+#define CBUS_REG_ADDR(reg)	 (IO_CBUS_BASE + CBUS_REG_OFFSET(reg))
+
+#if 0
+/* below UART0,UART1,AO_UART is m8 addr,it is placed is for compiling pass */
+/* -------------------------------
+// UART0
+// ---------------------------- */
+#define UART0_WFIFO                                0x2130
+#define UART0_RFIFO                                0x2131
+#define UART0_CONTROL                              0x2132
+#define UART0_STATUS                               0x2133
+#define UART0_MISC                                 0x2134
+#define UART0_REG5                                 0x2135
+/* ----------------------------
+// UART1
+----------------------------*/
+#define UART1_WFIFO                                0x2137
+#define UART1_RFIFO                                0x2138
+#define UART1_CONTROL                              0x2139
+#define UART1_STATUS                               0x213a
+#define UART1_MISC                                 0x213b
+#define UART1_REG5                                 0x213c
+
+/* ------------------------------------------------------
+ The following are handled by $periphs/rtl/periphs_reg.v
+  ----------------------------------------              */
+#define PREG_CTLREG0_ADDR                          0x2000
+#define P_PREG_CTLREG0_ADDR CBUS_REG_ADDR(PREG_CTLREG0_ADDR)
+
+/* ----------------------------
+ clock measure (4)
+ ---------------------------- */
+#define MSR_CLK_DUTY                               0x21d6
+#define MSR_CLK_REG0                               0x21d7
+#define MSR_CLK_REG1                               0x21d8
+#define MSR_CLK_REG2                               0x21d9
+#define P_MSR_CLK_DUTY CBUS_REG_ADDR(MSR_CLK_DUTY)
+#define P_MSR_CLK_REG0 CBUS_REG_ADDR(MSR_CLK_REG0)
+#define P_MSR_CLK_REG1 CBUS_REG_ADDR(MSR_CLK_REG1)
+#define P_MSR_CLK_REG2 CBUS_REG_ADDR(MSR_CLK_REG2)
+#endif
+
+#if 0
+/* --------------------------------
+ *  AO uart
+ * -------------------------------*/
+#define IO_AOBUS_BASE			0xc8100000  ///1M
+
+#define AOBUS_REG_OFFSET(reg)   ((reg) )
+#define AOBUS_REG_ADDR(reg)	    (IO_AOBUS_BASE + AOBUS_REG_OFFSET(reg))
+
+#define AO_UART_WFIFO ((0x01 << 10) | (0x30 << 2)) 	///../ucode/c_always_on_pointer.h:89
+#define P_AO_UART_WFIFO 		AOBUS_REG_ADDR(AO_UART_WFIFO)
+#define AO_UART_RFIFO ((0x01 << 10) | (0x31 << 2)) 	///../ucode/c_always_on_pointer.h:90
+#define P_AO_UART_RFIFO 		AOBUS_REG_ADDR(AO_UART_RFIFO)
+#define AO_UART_CONTROL ((0x01 << 10) | (0x32 << 2)) 	///../ucode/c_always_on_pointer.h:91
+#define P_AO_UART_CONTROL 		AOBUS_REG_ADDR(AO_UART_CONTROL)
+#define AO_UART_STATUS ((0x01 << 10) | (0x33 << 2)) 	///../ucode/c_always_on_pointer.h:92
+#define P_AO_UART_STATUS 		AOBUS_REG_ADDR(AO_UART_STATUS)
+#define AO_UART_MISC ((0x01 << 10) | (0x34 << 2)) 	///../ucode/c_always_on_pointer.h:93
+#define P_AO_UART_MISC 		AOBUS_REG_ADDR(AO_UART_MISC)
+#define AO_UART_REG5 ((0x01 << 10) | (0x35 << 2)) 	///../ucode/c_always_on_pointer.h:94
+#define P_AO_UART_REG5 		AOBUS_REG_ADDR(AO_UART_REG5)
+#endif
+
+#endif //__REGISTER_H__
diff --git a/include/amlogic/asm/regs.h b/include/amlogic/asm/regs.h
new file mode 100644
index 0000000000..26df3071cc
--- /dev/null
+++ b/include/amlogic/asm/regs.h
@@ -0,0 +1,32964 @@
+// ----------------------------------------------------------------------
+// regs.h header
+//
+// bus base define, update manually
+//
+// ----------------------------------------------------------------------
+//
+#ifndef _BASE_REGISTER
+#define _BASE_REGISTER
+#define REG_BASE_AOBUS                  (0xFF800000L)
+#define REG_BASE_PERIPHS                (0xFF634000L)
+#define REG_BASE_CBUS                   (0xFFD00000L)
+#define REG_BASE_HIU                    (0xFF63C000L)
+#define REG_BASE_VCBUS                  (0xFF900000L)
+#define DMC_REG_BASE                    (0xFF638000L)
+#define REG_BASE_DSI_HOST          		(0xFFD00000L)/* 0xFFD07000L*/
+
+#endif /*_BASE_REGISTER*/
+
+#ifndef REG_OTHERS
+#define REG_OTHERS
+/* other regs */
+#define   SPI_START_ADDR                             0xFB000000
+#define P_SPI_START_ADDR    (volatile unsigned int *)0xFB000000
+
+#endif /*REG_OTHERS*/
+
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_register_map_h.pl
+//
+// and was applied to the file
+//
+// ./register_map.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#ifdef REGISTER_H
+#else
+#define REGISTER_H
+#endif
+
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_dos_params_h.pl
+//
+// and was applied to the file
+//
+// ./dos_param.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#ifdef DOS_REGISTER_H
+#else
+#define DOS_REGISTER_H
+
+
+//
+// Reading file:  ./dos_param.h
+//
+//------------------------------------------------------------------------------
+// Define all modules' base address under DOS
+// APB allocation from 32'hd0050000
+//------------------------------------------------------------------------------
+// Define base address for VDEC module under DOS:
+//  DOS_VDEC_ASSIST_BASE_ADDR       14'h0000
+//  DOS_VDEC_MDEC_BASE_ADDR         14'h0900
+//  DOS_VDEC_VLD_BASE_ADDR          14'h0c00
+//  DOS_VDEC_IQIDCT_BASE_ADDR       14'h0e00
+//  DOS_VDEC_VCPU_BASE_ADDR         14'h0300
+//  DOS_VDEC_RESERVED_BASE_ADDR     14'h0f00 // Do not use this offset
+// Define base address for DOS top-level register module:
+//  DOS_TOP_BASE_ADDR               14'h3f00
+//------------------------------------------------------------------------------
+// VDEC_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define   VDEC_ASSIST_MMC_CTRL0                    (0x0001)
+#define P_VDEC_ASSIST_MMC_CTRL0                    (volatile unsigned int *)((0x0001  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MMC_CTRL1                    (0x0002)
+#define P_VDEC_ASSIST_MMC_CTRL1                    (volatile unsigned int *)((0x0002  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MMC_CTRL2                    (0x0003)
+#define P_VDEC_ASSIST_MMC_CTRL2                    (volatile unsigned int *)((0x0003  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MMC_CTRL3                    (0x0004)
+#define P_VDEC_ASSIST_MMC_CTRL3                    (volatile unsigned int *)((0x0004  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT0                    (0x0025)
+#define P_VDEC_ASSIST_AMR1_INT0                    (volatile unsigned int *)((0x0025  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT1                    (0x0026)
+#define P_VDEC_ASSIST_AMR1_INT1                    (volatile unsigned int *)((0x0026  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT2                    (0x0027)
+#define P_VDEC_ASSIST_AMR1_INT2                    (volatile unsigned int *)((0x0027  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT3                    (0x0028)
+#define P_VDEC_ASSIST_AMR1_INT3                    (volatile unsigned int *)((0x0028  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT4                    (0x0029)
+#define P_VDEC_ASSIST_AMR1_INT4                    (volatile unsigned int *)((0x0029  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT5                    (0x002a)
+#define P_VDEC_ASSIST_AMR1_INT5                    (volatile unsigned int *)((0x002a  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT6                    (0x002b)
+#define P_VDEC_ASSIST_AMR1_INT6                    (volatile unsigned int *)((0x002b  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT7                    (0x002c)
+#define P_VDEC_ASSIST_AMR1_INT7                    (volatile unsigned int *)((0x002c  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT8                    (0x002d)
+#define P_VDEC_ASSIST_AMR1_INT8                    (volatile unsigned int *)((0x002d  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INT9                    (0x002e)
+#define P_VDEC_ASSIST_AMR1_INT9                    (volatile unsigned int *)((0x002e  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INTA                    (0x002f)
+#define P_VDEC_ASSIST_AMR1_INTA                    (volatile unsigned int *)((0x002f  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INTB                    (0x0030)
+#define P_VDEC_ASSIST_AMR1_INTB                    (volatile unsigned int *)((0x0030  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INTC                    (0x0031)
+#define P_VDEC_ASSIST_AMR1_INTC                    (volatile unsigned int *)((0x0031  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INTD                    (0x0032)
+#define P_VDEC_ASSIST_AMR1_INTD                    (volatile unsigned int *)((0x0032  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INTE                    (0x0033)
+#define P_VDEC_ASSIST_AMR1_INTE                    (volatile unsigned int *)((0x0033  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR1_INTF                    (0x0034)
+#define P_VDEC_ASSIST_AMR1_INTF                    (volatile unsigned int *)((0x0034  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT0                    (0x0035)
+#define P_VDEC_ASSIST_AMR2_INT0                    (volatile unsigned int *)((0x0035  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT1                    (0x0036)
+#define P_VDEC_ASSIST_AMR2_INT1                    (volatile unsigned int *)((0x0036  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT2                    (0x0037)
+#define P_VDEC_ASSIST_AMR2_INT2                    (volatile unsigned int *)((0x0037  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT3                    (0x0038)
+#define P_VDEC_ASSIST_AMR2_INT3                    (volatile unsigned int *)((0x0038  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT4                    (0x0039)
+#define P_VDEC_ASSIST_AMR2_INT4                    (volatile unsigned int *)((0x0039  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT5                    (0x003a)
+#define P_VDEC_ASSIST_AMR2_INT5                    (volatile unsigned int *)((0x003a  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT6                    (0x003b)
+#define P_VDEC_ASSIST_AMR2_INT6                    (volatile unsigned int *)((0x003b  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT7                    (0x003c)
+#define P_VDEC_ASSIST_AMR2_INT7                    (volatile unsigned int *)((0x003c  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT8                    (0x003d)
+#define P_VDEC_ASSIST_AMR2_INT8                    (volatile unsigned int *)((0x003d  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INT9                    (0x003e)
+#define P_VDEC_ASSIST_AMR2_INT9                    (volatile unsigned int *)((0x003e  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INTA                    (0x003f)
+#define P_VDEC_ASSIST_AMR2_INTA                    (volatile unsigned int *)((0x003f  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INTB                    (0x0040)
+#define P_VDEC_ASSIST_AMR2_INTB                    (volatile unsigned int *)((0x0040  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INTC                    (0x0041)
+#define P_VDEC_ASSIST_AMR2_INTC                    (volatile unsigned int *)((0x0041  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INTD                    (0x0042)
+#define P_VDEC_ASSIST_AMR2_INTD                    (volatile unsigned int *)((0x0042  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INTE                    (0x0043)
+#define P_VDEC_ASSIST_AMR2_INTE                    (volatile unsigned int *)((0x0043  << 2) + 0xff620000)
+#define   VDEC_ASSIST_AMR2_INTF                    (0x0044)
+#define P_VDEC_ASSIST_AMR2_INTF                    (volatile unsigned int *)((0x0044  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBX_SSEL                     (0x0045)
+#define P_VDEC_ASSIST_MBX_SSEL                     (volatile unsigned int *)((0x0045  << 2) + 0xff620000)
+#define   VDEC_ASSIST_TIMER0_LO                    (0x0060)
+#define P_VDEC_ASSIST_TIMER0_LO                    (volatile unsigned int *)((0x0060  << 2) + 0xff620000)
+#define   VDEC_ASSIST_TIMER0_HI                    (0x0061)
+#define P_VDEC_ASSIST_TIMER0_HI                    (volatile unsigned int *)((0x0061  << 2) + 0xff620000)
+#define   VDEC_ASSIST_TIMER1_LO                    (0x0062)
+#define P_VDEC_ASSIST_TIMER1_LO                    (volatile unsigned int *)((0x0062  << 2) + 0xff620000)
+#define   VDEC_ASSIST_TIMER1_HI                    (0x0063)
+#define P_VDEC_ASSIST_TIMER1_HI                    (volatile unsigned int *)((0x0063  << 2) + 0xff620000)
+#define   VDEC_ASSIST_DMA_INT                      (0x0064)
+#define P_VDEC_ASSIST_DMA_INT                      (volatile unsigned int *)((0x0064  << 2) + 0xff620000)
+#define   VDEC_ASSIST_DMA_INT_MSK                  (0x0065)
+#define P_VDEC_ASSIST_DMA_INT_MSK                  (volatile unsigned int *)((0x0065  << 2) + 0xff620000)
+#define   VDEC_ASSIST_DMA_INT2                     (0x0066)
+#define P_VDEC_ASSIST_DMA_INT2                     (volatile unsigned int *)((0x0066  << 2) + 0xff620000)
+#define   VDEC_ASSIST_DMA_INT_MSK2                 (0x0067)
+#define P_VDEC_ASSIST_DMA_INT_MSK2                 (volatile unsigned int *)((0x0067  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX0_IRQ_REG                (0x0070)
+#define P_VDEC_ASSIST_MBOX0_IRQ_REG                (volatile unsigned int *)((0x0070  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX0_CLR_REG                (0x0071)
+#define P_VDEC_ASSIST_MBOX0_CLR_REG                (volatile unsigned int *)((0x0071  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX0_MASK                   (0x0072)
+#define P_VDEC_ASSIST_MBOX0_MASK                   (volatile unsigned int *)((0x0072  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX0_FIQ_SEL                (0x0073)
+#define P_VDEC_ASSIST_MBOX0_FIQ_SEL                (volatile unsigned int *)((0x0073  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX1_IRQ_REG                (0x0074)
+#define P_VDEC_ASSIST_MBOX1_IRQ_REG                (volatile unsigned int *)((0x0074  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX1_CLR_REG                (0x0075)
+#define P_VDEC_ASSIST_MBOX1_CLR_REG                (volatile unsigned int *)((0x0075  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX1_MASK                   (0x0076)
+#define P_VDEC_ASSIST_MBOX1_MASK                   (volatile unsigned int *)((0x0076  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX1_FIQ_SEL                (0x0077)
+#define P_VDEC_ASSIST_MBOX1_FIQ_SEL                (volatile unsigned int *)((0x0077  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX2_IRQ_REG                (0x0078)
+#define P_VDEC_ASSIST_MBOX2_IRQ_REG                (volatile unsigned int *)((0x0078  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX2_CLR_REG                (0x0079)
+#define P_VDEC_ASSIST_MBOX2_CLR_REG                (volatile unsigned int *)((0x0079  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX2_MASK                   (0x007a)
+#define P_VDEC_ASSIST_MBOX2_MASK                   (volatile unsigned int *)((0x007a  << 2) + 0xff620000)
+#define   VDEC_ASSIST_MBOX2_FIQ_SEL                (0x007b)
+#define P_VDEC_ASSIST_MBOX2_FIQ_SEL                (volatile unsigned int *)((0x007b  << 2) + 0xff620000)
+//------------------------------------------------------------------------------
+// VDEC2_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC2_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define   VDEC2_ASSIST_MMC_CTRL0                   (0x2001)
+#define P_VDEC2_ASSIST_MMC_CTRL0                   (volatile unsigned int *)((0x2001  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MMC_CTRL1                   (0x2002)
+#define P_VDEC2_ASSIST_MMC_CTRL1                   (volatile unsigned int *)((0x2002  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT0                   (0x2025)
+#define P_VDEC2_ASSIST_AMR1_INT0                   (volatile unsigned int *)((0x2025  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT1                   (0x2026)
+#define P_VDEC2_ASSIST_AMR1_INT1                   (volatile unsigned int *)((0x2026  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT2                   (0x2027)
+#define P_VDEC2_ASSIST_AMR1_INT2                   (volatile unsigned int *)((0x2027  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT3                   (0x2028)
+#define P_VDEC2_ASSIST_AMR1_INT3                   (volatile unsigned int *)((0x2028  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT4                   (0x2029)
+#define P_VDEC2_ASSIST_AMR1_INT4                   (volatile unsigned int *)((0x2029  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT5                   (0x202a)
+#define P_VDEC2_ASSIST_AMR1_INT5                   (volatile unsigned int *)((0x202a  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT6                   (0x202b)
+#define P_VDEC2_ASSIST_AMR1_INT6                   (volatile unsigned int *)((0x202b  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT7                   (0x202c)
+#define P_VDEC2_ASSIST_AMR1_INT7                   (volatile unsigned int *)((0x202c  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT8                   (0x202d)
+#define P_VDEC2_ASSIST_AMR1_INT8                   (volatile unsigned int *)((0x202d  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INT9                   (0x202e)
+#define P_VDEC2_ASSIST_AMR1_INT9                   (volatile unsigned int *)((0x202e  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INTA                   (0x202f)
+#define P_VDEC2_ASSIST_AMR1_INTA                   (volatile unsigned int *)((0x202f  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INTB                   (0x2030)
+#define P_VDEC2_ASSIST_AMR1_INTB                   (volatile unsigned int *)((0x2030  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INTC                   (0x2031)
+#define P_VDEC2_ASSIST_AMR1_INTC                   (volatile unsigned int *)((0x2031  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INTD                   (0x2032)
+#define P_VDEC2_ASSIST_AMR1_INTD                   (volatile unsigned int *)((0x2032  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INTE                   (0x2033)
+#define P_VDEC2_ASSIST_AMR1_INTE                   (volatile unsigned int *)((0x2033  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR1_INTF                   (0x2034)
+#define P_VDEC2_ASSIST_AMR1_INTF                   (volatile unsigned int *)((0x2034  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT0                   (0x2035)
+#define P_VDEC2_ASSIST_AMR2_INT0                   (volatile unsigned int *)((0x2035  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT1                   (0x2036)
+#define P_VDEC2_ASSIST_AMR2_INT1                   (volatile unsigned int *)((0x2036  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT2                   (0x2037)
+#define P_VDEC2_ASSIST_AMR2_INT2                   (volatile unsigned int *)((0x2037  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT3                   (0x2038)
+#define P_VDEC2_ASSIST_AMR2_INT3                   (volatile unsigned int *)((0x2038  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT4                   (0x2039)
+#define P_VDEC2_ASSIST_AMR2_INT4                   (volatile unsigned int *)((0x2039  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT5                   (0x203a)
+#define P_VDEC2_ASSIST_AMR2_INT5                   (volatile unsigned int *)((0x203a  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT6                   (0x203b)
+#define P_VDEC2_ASSIST_AMR2_INT6                   (volatile unsigned int *)((0x203b  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT7                   (0x203c)
+#define P_VDEC2_ASSIST_AMR2_INT7                   (volatile unsigned int *)((0x203c  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT8                   (0x203d)
+#define P_VDEC2_ASSIST_AMR2_INT8                   (volatile unsigned int *)((0x203d  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INT9                   (0x203e)
+#define P_VDEC2_ASSIST_AMR2_INT9                   (volatile unsigned int *)((0x203e  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INTA                   (0x203f)
+#define P_VDEC2_ASSIST_AMR2_INTA                   (volatile unsigned int *)((0x203f  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INTB                   (0x2040)
+#define P_VDEC2_ASSIST_AMR2_INTB                   (volatile unsigned int *)((0x2040  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INTC                   (0x2041)
+#define P_VDEC2_ASSIST_AMR2_INTC                   (volatile unsigned int *)((0x2041  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INTD                   (0x2042)
+#define P_VDEC2_ASSIST_AMR2_INTD                   (volatile unsigned int *)((0x2042  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INTE                   (0x2043)
+#define P_VDEC2_ASSIST_AMR2_INTE                   (volatile unsigned int *)((0x2043  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_AMR2_INTF                   (0x2044)
+#define P_VDEC2_ASSIST_AMR2_INTF                   (volatile unsigned int *)((0x2044  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBX_SSEL                    (0x2045)
+#define P_VDEC2_ASSIST_MBX_SSEL                    (volatile unsigned int *)((0x2045  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_TIMER0_LO                   (0x2060)
+#define P_VDEC2_ASSIST_TIMER0_LO                   (volatile unsigned int *)((0x2060  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_TIMER0_HI                   (0x2061)
+#define P_VDEC2_ASSIST_TIMER0_HI                   (volatile unsigned int *)((0x2061  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_TIMER1_LO                   (0x2062)
+#define P_VDEC2_ASSIST_TIMER1_LO                   (volatile unsigned int *)((0x2062  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_TIMER1_HI                   (0x2063)
+#define P_VDEC2_ASSIST_TIMER1_HI                   (volatile unsigned int *)((0x2063  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_DMA_INT                     (0x2064)
+#define P_VDEC2_ASSIST_DMA_INT                     (volatile unsigned int *)((0x2064  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_DMA_INT_MSK                 (0x2065)
+#define P_VDEC2_ASSIST_DMA_INT_MSK                 (volatile unsigned int *)((0x2065  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_DMA_INT2                    (0x2066)
+#define P_VDEC2_ASSIST_DMA_INT2                    (volatile unsigned int *)((0x2066  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_DMA_INT_MSK2                (0x2067)
+#define P_VDEC2_ASSIST_DMA_INT_MSK2                (volatile unsigned int *)((0x2067  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX0_IRQ_REG               (0x2070)
+#define P_VDEC2_ASSIST_MBOX0_IRQ_REG               (volatile unsigned int *)((0x2070  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX0_CLR_REG               (0x2071)
+#define P_VDEC2_ASSIST_MBOX0_CLR_REG               (volatile unsigned int *)((0x2071  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX0_MASK                  (0x2072)
+#define P_VDEC2_ASSIST_MBOX0_MASK                  (volatile unsigned int *)((0x2072  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX0_FIQ_SEL               (0x2073)
+#define P_VDEC2_ASSIST_MBOX0_FIQ_SEL               (volatile unsigned int *)((0x2073  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX1_IRQ_REG               (0x2074)
+#define P_VDEC2_ASSIST_MBOX1_IRQ_REG               (volatile unsigned int *)((0x2074  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX1_CLR_REG               (0x2075)
+#define P_VDEC2_ASSIST_MBOX1_CLR_REG               (volatile unsigned int *)((0x2075  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX1_MASK                  (0x2076)
+#define P_VDEC2_ASSIST_MBOX1_MASK                  (volatile unsigned int *)((0x2076  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX1_FIQ_SEL               (0x2077)
+#define P_VDEC2_ASSIST_MBOX1_FIQ_SEL               (volatile unsigned int *)((0x2077  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX2_IRQ_REG               (0x2078)
+#define P_VDEC2_ASSIST_MBOX2_IRQ_REG               (volatile unsigned int *)((0x2078  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX2_CLR_REG               (0x2079)
+#define P_VDEC2_ASSIST_MBOX2_CLR_REG               (volatile unsigned int *)((0x2079  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX2_MASK                  (0x207a)
+#define P_VDEC2_ASSIST_MBOX2_MASK                  (volatile unsigned int *)((0x207a  << 2) + 0xff620000)
+#define   VDEC2_ASSIST_MBOX2_FIQ_SEL               (0x207b)
+#define P_VDEC2_ASSIST_MBOX2_FIQ_SEL               (volatile unsigned int *)((0x207b  << 2) + 0xff620000)
+//------------------------------------------------------------------------------
+// HCODEC_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define   HCODEC_ASSIST_MMC_CTRL0                  (0x1001)
+#define P_HCODEC_ASSIST_MMC_CTRL0                  (volatile unsigned int *)((0x1001  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MMC_CTRL1                  (0x1002)
+#define P_HCODEC_ASSIST_MMC_CTRL1                  (volatile unsigned int *)((0x1002  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MMC_CTRL2                  (0x1003)
+#define P_HCODEC_ASSIST_MMC_CTRL2                  (volatile unsigned int *)((0x1003  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MMC_CTRL3                  (0x1004)
+#define P_HCODEC_ASSIST_MMC_CTRL3                  (volatile unsigned int *)((0x1004  << 2) + 0xff620000)
+//cfg_soft_rst = mfdin_reg0_crst[0]; // Soft Reset
+//cfg_cg_cfe   = mfdin_reg0_crst[1]; // Clock Gating Forcing Enable
+//cfg_dbuf_rst = mfdin_reg0_crst[2]; // Reset DBUF information
+#define   HCODEC_MFDIN_REG0_CRST                   (0x1008)
+#define P_HCODEC_MFDIN_REG0_CRST                   (volatile unsigned int *)((0x1008  << 2) + 0xff620000)
+//cfg_iformat       = mfdin_reg1_ctrl[3:0]; // Data In Format: 0 :CANVAS 422 YCbCr<-one canvas,
+                                                     //        1 :CANVAS 444 YCbCr(or RGB)<-one canvas,
+                                                     //        2 :CANVAS 420 Y<-one CrCb<-one (NV21)
+                                                     //        3 :CANVAS 420 Y<-one CbCr<-one (NV12)
+                                                     //        4 :CANVAS 420 Y<-one Cb<-one Cr<-one
+                                                     //        5 :CANVAS 444 Y<-one Cb<-one Cr<-one
+                                                     //        6 : Reserved for other canvas mode
+                                                     //        7 : should combine with cfg_ifmt_extra, for 10-12bits
+                                                     //        8 :LINEAR RGB888 (24bit)
+                                                     //        9 :LINEAR RGB565 (16bit)
+                                                     //        10:LINEAR YUV422
+                                                     //        11:LINEAR YUV420 (Note:Legacy mode not supported)
+                                                     //        12~15: Reserved for other linear mode
+//cfg_oformat       = mfdin_reg1_ctrl[5:4];  // Data Out Format: 0:420 1:422 2:444 3:reserved
+//cfg_dsample_enable= mfdin_reg1_ctrl[6];    // Downsample Enable
+//cfg_dsample_trunc = mfdin_reg1_ctrl[7];    // Downsample Addition Option: 0:Round 1:Truncated
+//cfg_block_ysize   = mfdin_reg1_ctrl[8];    // 0:block-y-size=16, 1:block-y-size=8(for JPEG's efficiency)
+//cfg_interp_enable = mfdin_reg1_ctrl[9];    // Chroma Interpolation Enable
+//cfg_interp_mode   = mfdin_reg1_ctrl[11:10];// 0:average round 1:average truncated 2:repeat left 3:repeat right
+//cfg_r2y_enable    = mfdin_reg1_ctrl[12];   // RGb->YUV Enable
+//cfg_r2y_mode      = mfdin_reg1_ctrl[14:13];// RGb->YUV Mode
+//cfg_rgb565_mode   = mfdin_reg1_ctrl[15];   // RGB565 mode: 0:fill zero in tail 1:fill zero in head
+//cfg_ifmt_extra    = mfdin_reg1_ctrl[17:16];// when cfg_iformat==7,
+                                             //        0: CANVAS 12bit 422, YCbCr<-one canvas{...Y1[11:0],C1[11:0],Y0[11:0],C0[11:0]}
+                                             //        1: CANVAS 10bit 444, YCbCr<-one canvas{...2'b0,Y0[9:0],U0[9:0],V0[9:0]}
+                                             //        2: CANVAS 10bit 422, YCbCr<-one canvas{...Y1[9:0],C1[9:0],Y0[9:0],C0[9:0]}
+//cfg_reserved1     = mfdin_reg1_ctrl[18];   // Reserved
+//cfg_nr_enable     = mfdin_reg1_ctrl[19];   // Noise Reduction Enable
+//cfg_outofpic      = mfdin_reg1_ctrl[28:20];// Out Of Picture Control: [8]mode:0:extend 1:fixed, [7:0]fixed value
+//cfg_rd_blktype    = mfdin_reg1_ctrl[30:29];// Block Type: 0:H264_I_PIC_ALL_4x4, 1:H264_P_PIC_Y_16x16_C_8x8, 2:JPEG_ALL_8x8, 3:Reserved
+//cfg_rd_nonycintl  = mfdin_reg1_ctrl[31];   // 0:YC interleaved 1:YC non-interleaved(for JPEG)
+#define   HCODEC_MFDIN_REG1_CTRL                   (0x1009)
+#define P_HCODEC_MFDIN_REG1_CTRL                   (volatile unsigned int *)((0x1009  << 2) + 0xff620000)
+//mfdin_reg2: DEBUG Only Status
+#define   HCODEC_MFDIN_REG2_STAT                   (0x100a)
+#define P_HCODEC_MFDIN_REG2_STAT                   (volatile unsigned int *)((0x100a  << 2) + 0xff620000)
+//cfg_canvas_index0  = mfdin_reg3_canv[7:0];  //canvas index 0
+//cfg_canvas_index1  = mfdin_reg3_canv[15:8]; //canvas index 1
+//cfg_canvas_index2  = mfdin_reg3_canv[23:16];//canvas index 2
+//cfg_canv_idx0_bppx = mfdin_reg3_canv[25:24];//canvas bytes per pixel in x direction for index0, 0:half 1:1 2:2 3:3
+//cfg_canv_idx1_bppx = mfdin_reg3_canv[27:26];//canvas bytes per pixel in x direction for index1, 0:half 1:1 2:2 3:3
+//cfg_canv_idx0_bppy = mfdin_reg3_canv[29:28];//canvas bytes per pixel in y direction for index0, 0:half 1:1 2:2 3:3
+//cfg_canv_idx1_bppy = mfdin_reg3_canv[31:30];//canvas bytes per pixel in y direction for index1, 0:half 1:1 2:2 3:3
+#define   HCODEC_MFDIN_REG3_CANV                   (0x100b)
+#define P_HCODEC_MFDIN_REG3_CANV                   (volatile unsigned int *)((0x100b  << 2) + 0xff620000)
+//cfg_bytes_per_line  = mfdin_reg4_lnr0[15:0];  //linear Bytes per line
+//cfg_linear_bytes4p  = mfdin_reg4_lnr0[17:16]; //linear (Bytes per pixel) - 1
+//cfg_linear_dbl2line = mfdin_reg4_lnr0[18];    //linear double size for odd line
+#define   HCODEC_MFDIN_REG4_LNR0                   (0x100c)
+#define P_HCODEC_MFDIN_REG4_LNR0                   (volatile unsigned int *)((0x100c  << 2) + 0xff620000)
+//cfg_base_address    = mfdin_reg5_lnr1[31:0];  //linear base address
+#define   HCODEC_MFDIN_REG5_LNR1                   (0x100d)
+#define P_HCODEC_MFDIN_REG5_LNR1                   (volatile unsigned int *)((0x100d  << 2) + 0xff620000)
+//assign cfg_r2y_trunc     = mfdin_reg6_dcfg[9];   //RGb->YUV Addition Option: 0:Round 1:Truncated
+//assign cfg_dma_ugt       = mfdin_reg6_dcfg[8];   //DMA Urgent
+//assign cfg_dma_thread_id = mfdin_reg6_dcfg[7:6]; //DMA Thread ID
+//assign cfg_dma_burst_num = mfdin_reg6_dcfg[5:0]; //DMA Burst Number
+#define   HCODEC_MFDIN_REG6_DCFG                   (0x100e)
+#define P_HCODEC_MFDIN_REG6_DCFG                   (volatile unsigned int *)((0x100e  << 2) + 0xff620000)
+//cfg_soft_cmd = mfdin_reg7_scmd; // Soft Command [28]selfcleared start,[27:14]dmb_x,[13:0]dmb_y
+#define   HCODEC_MFDIN_REG7_SCMD                   (0x100f)
+#define P_HCODEC_MFDIN_REG7_SCMD                   (volatile unsigned int *)((0x100f  << 2) + 0xff620000)
+//cfg_pic_xsize = mfdin_reg8_dmbl[23:12]; //pixel (x,y) at the begining of last dmb in the picturem, picture x size
+//cfg_pic_ysize = mfdin_reg8_dmbl[11:0];  //picture y size
+#define   HCODEC_MFDIN_REG8_DMBL                   (0x1010)
+#define P_HCODEC_MFDIN_REG8_DMBL                   (volatile unsigned int *)((0x1010  << 2) + 0xff620000)
+//cfg_endian = mfdin_reg9_endn; //Endian Control
+#define   HCODEC_MFDIN_REG9_ENDN                   (0x1011)
+#define P_HCODEC_MFDIN_REG9_ENDN                   (volatile unsigned int *)((0x1011  << 2) + 0xff620000)
+//cfg_canv_biasx = mfdin_rega_cav1[23:12]; //canvas bias address x
+//cfg_canv_biasy = mfdin_rega_cav1[11:0];  //canvas bias address y
+#define   HCODEC_MFDIN_REGA_CAV1                   (0x1012)
+#define P_HCODEC_MFDIN_REGA_CAV1                   (volatile unsigned int *)((0x1012  << 2) + 0xff620000)
+//cfg_amp_en = mfdin_regb_ampc[24];      //Amplitude Enable
+//cfg_amp_cy = mfdin_regb_ampc[23:16];   //Amplitude Coeff Y
+//cfg_amp_cu = mfdin_regb_ampc[15:8];    //Amplitude Coeff U
+//cfg_amp_cv = mfdin_regb_ampc[7:0];     //Amplitude Coeff V
+#define   HCODEC_MFDIN_REGB_AMPC                   (0x1013)
+#define P_HCODEC_MFDIN_REGB_AMPC                   (volatile unsigned int *)((0x1013  << 2) + 0xff620000)
+//cfg_mb_end = mfdin_regc_mblp; // Soft Command [28]mb end enable,[27:14]dmb_x,[13:0]dmb_y
+#define   HCODEC_MFDIN_REGC_MBLP                   (0x1014)
+#define P_HCODEC_MFDIN_REGC_MBLP                   (volatile unsigned int *)((0x1014  << 2) + 0xff620000)
+//       cfg_y_snr_en               = mfdin_reg0d[0];
+//       cfg_y_snr_err_norm         = mfdin_reg0d[1];
+// [3:0] cfg_y_snr_gau_bld_core     = mfdin_reg0d[5:2];
+// [7:0] cfg_y_snr_gau_bld_ofst     = mfdin_reg0d[13:6];
+// [5:0] cfg_y_snr_gau_bld_rate     = mfdin_reg0d[19:14];
+// [5:0] cfg_y_snr_gau_alp0_min     = mfdin_reg0d[25:20];
+// [5:0] cfg_y_snr_gau_alp0_max     = mfdin_reg0d[31:26];
+#define   HCODEC_MFDIN_REG0D                       (0x1015)
+#define P_HCODEC_MFDIN_REG0D                       (volatile unsigned int *)((0x1015  << 2) + 0xff620000)
+//       cfg_y_tnr_en               = mfdin_reg0e[0];
+//       cfg_y_tnr_mc_en            = mfdin_reg0e[1];
+//       cfg_y_tnr_txt_mode         = mfdin_reg0e[2];
+// [3:0] cfg_y_tnr_mot_sad_margin   = mfdin_reg0e[6:3];
+// [5:0] cfg_y_tnr_alpha_min        = mfdin_reg0e[12:7];
+// [5:0] cfg_y_tnr_alpha_max        = mfdin_reg0e[18:13];
+// [5:0] cfg_y_tnr_deghost_os       = mfdin_reg0e[24:19];
+#define   HCODEC_MFDIN_REG0E                       (0x1016)
+#define P_HCODEC_MFDIN_REG0E                       (volatile unsigned int *)((0x1016  << 2) + 0xff620000)
+// [3:0] cfg_y_tnr_mot_cortxt_rate  = mfdin_reg0f[3:0];
+// [7:0] cfg_y_tnr_mot_distxt_ofst  = mfdin_reg0f[15:8];
+// [3:0] cfg_y_tnr_mot_distxt_rate  = mfdin_reg0f[7:4];
+// [7:0] cfg_y_tnr_mot_dismot_ofst  = mfdin_reg0f[23:16];
+// [7:0] cfg_y_tnr_mot_frcsad_lock  = mfdin_reg0f[31:24];
+#define   HCODEC_MFDIN_REG0F                       (0x1017)
+#define P_HCODEC_MFDIN_REG0F                       (volatile unsigned int *)((0x1017  << 2) + 0xff620000)
+// [7:0] cfg_y_tnr_mot2alp_frc_gain = mfdin_reg10[7:0];
+// [7:0] cfg_y_tnr_mot2alp_nrm_gain = mfdin_reg10[15:8];
+// [7:0] cfg_y_tnr_mot2alp_dis_gain = mfdin_reg10[23:16];
+// [5:0] cfg_y_tnr_mot2alp_dis_ofst = mfdin_reg10[29:24];
+#define   HCODEC_MFDIN_REG10                       (0x1018)
+#define P_HCODEC_MFDIN_REG10                       (volatile unsigned int *)((0x1018  << 2) + 0xff620000)
+// [7:0] cfg_y_bld_beta2alp_rate    = mfdin_reg11[7:0];
+// [5:0] cfg_y_bld_beta_min         = mfdin_reg11[13:8];
+// [5:0] cfg_y_bld_beta_max         = mfdin_reg11[19:14];
+#define   HCODEC_MFDIN_REG11                       (0x1019)
+#define P_HCODEC_MFDIN_REG11                       (volatile unsigned int *)((0x1019  << 2) + 0xff620000)
+// REG12~16 for Chroma, same as Luma
+#define   HCODEC_MFDIN_REG12                       (0x101a)
+#define P_HCODEC_MFDIN_REG12                       (volatile unsigned int *)((0x101a  << 2) + 0xff620000)
+#define   HCODEC_MFDIN_REG13                       (0x101b)
+#define P_HCODEC_MFDIN_REG13                       (volatile unsigned int *)((0x101b  << 2) + 0xff620000)
+#define   HCODEC_MFDIN_REG14                       (0x101c)
+#define P_HCODEC_MFDIN_REG14                       (volatile unsigned int *)((0x101c  << 2) + 0xff620000)
+#define   HCODEC_MFDIN_REG15                       (0x101d)
+#define P_HCODEC_MFDIN_REG15                       (volatile unsigned int *)((0x101d  << 2) + 0xff620000)
+#define   HCODEC_MFDIN_REG16                       (0x101e)
+#define P_HCODEC_MFDIN_REG16                       (volatile unsigned int *)((0x101e  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT0                  (0x1025)
+#define P_HCODEC_ASSIST_AMR1_INT0                  (volatile unsigned int *)((0x1025  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT1                  (0x1026)
+#define P_HCODEC_ASSIST_AMR1_INT1                  (volatile unsigned int *)((0x1026  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT2                  (0x1027)
+#define P_HCODEC_ASSIST_AMR1_INT2                  (volatile unsigned int *)((0x1027  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT3                  (0x1028)
+#define P_HCODEC_ASSIST_AMR1_INT3                  (volatile unsigned int *)((0x1028  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT4                  (0x1029)
+#define P_HCODEC_ASSIST_AMR1_INT4                  (volatile unsigned int *)((0x1029  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT5                  (0x102a)
+#define P_HCODEC_ASSIST_AMR1_INT5                  (volatile unsigned int *)((0x102a  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT6                  (0x102b)
+#define P_HCODEC_ASSIST_AMR1_INT6                  (volatile unsigned int *)((0x102b  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT7                  (0x102c)
+#define P_HCODEC_ASSIST_AMR1_INT7                  (volatile unsigned int *)((0x102c  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT8                  (0x102d)
+#define P_HCODEC_ASSIST_AMR1_INT8                  (volatile unsigned int *)((0x102d  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INT9                  (0x102e)
+#define P_HCODEC_ASSIST_AMR1_INT9                  (volatile unsigned int *)((0x102e  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INTA                  (0x102f)
+#define P_HCODEC_ASSIST_AMR1_INTA                  (volatile unsigned int *)((0x102f  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INTB                  (0x1030)
+#define P_HCODEC_ASSIST_AMR1_INTB                  (volatile unsigned int *)((0x1030  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INTC                  (0x1031)
+#define P_HCODEC_ASSIST_AMR1_INTC                  (volatile unsigned int *)((0x1031  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INTD                  (0x1032)
+#define P_HCODEC_ASSIST_AMR1_INTD                  (volatile unsigned int *)((0x1032  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INTE                  (0x1033)
+#define P_HCODEC_ASSIST_AMR1_INTE                  (volatile unsigned int *)((0x1033  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR1_INTF                  (0x1034)
+#define P_HCODEC_ASSIST_AMR1_INTF                  (volatile unsigned int *)((0x1034  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT0                  (0x1035)
+#define P_HCODEC_ASSIST_AMR2_INT0                  (volatile unsigned int *)((0x1035  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT1                  (0x1036)
+#define P_HCODEC_ASSIST_AMR2_INT1                  (volatile unsigned int *)((0x1036  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT2                  (0x1037)
+#define P_HCODEC_ASSIST_AMR2_INT2                  (volatile unsigned int *)((0x1037  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT3                  (0x1038)
+#define P_HCODEC_ASSIST_AMR2_INT3                  (volatile unsigned int *)((0x1038  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT4                  (0x1039)
+#define P_HCODEC_ASSIST_AMR2_INT4                  (volatile unsigned int *)((0x1039  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT5                  (0x103a)
+#define P_HCODEC_ASSIST_AMR2_INT5                  (volatile unsigned int *)((0x103a  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT6                  (0x103b)
+#define P_HCODEC_ASSIST_AMR2_INT6                  (volatile unsigned int *)((0x103b  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT7                  (0x103c)
+#define P_HCODEC_ASSIST_AMR2_INT7                  (volatile unsigned int *)((0x103c  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT8                  (0x103d)
+#define P_HCODEC_ASSIST_AMR2_INT8                  (volatile unsigned int *)((0x103d  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INT9                  (0x103e)
+#define P_HCODEC_ASSIST_AMR2_INT9                  (volatile unsigned int *)((0x103e  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INTA                  (0x103f)
+#define P_HCODEC_ASSIST_AMR2_INTA                  (volatile unsigned int *)((0x103f  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INTB                  (0x1040)
+#define P_HCODEC_ASSIST_AMR2_INTB                  (volatile unsigned int *)((0x1040  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INTC                  (0x1041)
+#define P_HCODEC_ASSIST_AMR2_INTC                  (volatile unsigned int *)((0x1041  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INTD                  (0x1042)
+#define P_HCODEC_ASSIST_AMR2_INTD                  (volatile unsigned int *)((0x1042  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INTE                  (0x1043)
+#define P_HCODEC_ASSIST_AMR2_INTE                  (volatile unsigned int *)((0x1043  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_AMR2_INTF                  (0x1044)
+#define P_HCODEC_ASSIST_AMR2_INTF                  (volatile unsigned int *)((0x1044  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBX_SSEL                   (0x1045)
+#define P_HCODEC_ASSIST_MBX_SSEL                   (volatile unsigned int *)((0x1045  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_TIMER0_LO                  (0x1060)
+#define P_HCODEC_ASSIST_TIMER0_LO                  (volatile unsigned int *)((0x1060  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_TIMER0_HI                  (0x1061)
+#define P_HCODEC_ASSIST_TIMER0_HI                  (volatile unsigned int *)((0x1061  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_TIMER1_LO                  (0x1062)
+#define P_HCODEC_ASSIST_TIMER1_LO                  (volatile unsigned int *)((0x1062  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_TIMER1_HI                  (0x1063)
+#define P_HCODEC_ASSIST_TIMER1_HI                  (volatile unsigned int *)((0x1063  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_DMA_INT                    (0x1064)
+#define P_HCODEC_ASSIST_DMA_INT                    (volatile unsigned int *)((0x1064  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_DMA_INT_MSK                (0x1065)
+#define P_HCODEC_ASSIST_DMA_INT_MSK                (volatile unsigned int *)((0x1065  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_DMA_INT2                   (0x1066)
+#define P_HCODEC_ASSIST_DMA_INT2                   (volatile unsigned int *)((0x1066  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_DMA_INT_MSK2               (0x1067)
+#define P_HCODEC_ASSIST_DMA_INT_MSK2               (volatile unsigned int *)((0x1067  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX0_IRQ_REG              (0x1070)
+#define P_HCODEC_ASSIST_MBOX0_IRQ_REG              (volatile unsigned int *)((0x1070  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX0_CLR_REG              (0x1071)
+#define P_HCODEC_ASSIST_MBOX0_CLR_REG              (volatile unsigned int *)((0x1071  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX0_MASK                 (0x1072)
+#define P_HCODEC_ASSIST_MBOX0_MASK                 (volatile unsigned int *)((0x1072  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX0_FIQ_SEL              (0x1073)
+#define P_HCODEC_ASSIST_MBOX0_FIQ_SEL              (volatile unsigned int *)((0x1073  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX1_IRQ_REG              (0x1074)
+#define P_HCODEC_ASSIST_MBOX1_IRQ_REG              (volatile unsigned int *)((0x1074  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX1_CLR_REG              (0x1075)
+#define P_HCODEC_ASSIST_MBOX1_CLR_REG              (volatile unsigned int *)((0x1075  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX1_MASK                 (0x1076)
+#define P_HCODEC_ASSIST_MBOX1_MASK                 (volatile unsigned int *)((0x1076  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX1_FIQ_SEL              (0x1077)
+#define P_HCODEC_ASSIST_MBOX1_FIQ_SEL              (volatile unsigned int *)((0x1077  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX2_IRQ_REG              (0x1078)
+#define P_HCODEC_ASSIST_MBOX2_IRQ_REG              (volatile unsigned int *)((0x1078  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX2_CLR_REG              (0x1079)
+#define P_HCODEC_ASSIST_MBOX2_CLR_REG              (volatile unsigned int *)((0x1079  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX2_MASK                 (0x107a)
+#define P_HCODEC_ASSIST_MBOX2_MASK                 (volatile unsigned int *)((0x107a  << 2) + 0xff620000)
+#define   HCODEC_ASSIST_MBOX2_FIQ_SEL              (0x107b)
+#define P_HCODEC_ASSIST_MBOX2_FIQ_SEL              (volatile unsigned int *)((0x107b  << 2) + 0xff620000)
+//------------------------------------------------------------------------------
+// MDEC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define   MC_CTRL_REG                              (0x0900)
+#define P_MC_CTRL_REG                              (volatile unsigned int *)((0x0900  << 2) + 0xff620000)
+#define   MC_MB_INFO                               (0x0901)
+#define P_MC_MB_INFO                               (volatile unsigned int *)((0x0901  << 2) + 0xff620000)
+#define   MC_PIC_INFO                              (0x0902)
+#define P_MC_PIC_INFO                              (volatile unsigned int *)((0x0902  << 2) + 0xff620000)
+#define   MC_HALF_PEL_ONE                          (0x0903)
+#define P_MC_HALF_PEL_ONE                          (volatile unsigned int *)((0x0903  << 2) + 0xff620000)
+#define   MC_HALF_PEL_TWO                          (0x0904)
+#define P_MC_HALF_PEL_TWO                          (volatile unsigned int *)((0x0904  << 2) + 0xff620000)
+#define   POWER_CTL_MC                             (0x0905)
+#define P_POWER_CTL_MC                             (volatile unsigned int *)((0x0905  << 2) + 0xff620000)
+#define   MC_CMD                                   (0x0906)
+#define P_MC_CMD                                   (volatile unsigned int *)((0x0906  << 2) + 0xff620000)
+#define   MC_CTRL0                                 (0x0907)
+#define P_MC_CTRL0                                 (volatile unsigned int *)((0x0907  << 2) + 0xff620000)
+#define   MC_PIC_W_H                               (0x0908)
+#define P_MC_PIC_W_H                               (volatile unsigned int *)((0x0908  << 2) + 0xff620000)
+#define   MC_STATUS0                               (0x0909)
+#define P_MC_STATUS0                               (volatile unsigned int *)((0x0909  << 2) + 0xff620000)
+#define   MC_STATUS1                               (0x090a)
+#define P_MC_STATUS1                               (volatile unsigned int *)((0x090a  << 2) + 0xff620000)
+#define   MC_CTRL1                                 (0x090b)
+#define P_MC_CTRL1                                 (volatile unsigned int *)((0x090b  << 2) + 0xff620000)
+#define   MC_MIX_RATIO0                            (0x090c)
+#define P_MC_MIX_RATIO0                            (volatile unsigned int *)((0x090c  << 2) + 0xff620000)
+#define   MC_MIX_RATIO1                            (0x090d)
+#define P_MC_MIX_RATIO1                            (volatile unsigned int *)((0x090d  << 2) + 0xff620000)
+#define   MC_DP_MB_XY                              (0x090e)
+#define P_MC_DP_MB_XY                              (volatile unsigned int *)((0x090e  << 2) + 0xff620000)
+#define   MC_OM_MB_XY                              (0x090f)
+#define P_MC_OM_MB_XY                              (volatile unsigned int *)((0x090f  << 2) + 0xff620000)
+#define   PSCALE_RST                               (0x0910)
+#define P_PSCALE_RST                               (volatile unsigned int *)((0x0910  << 2) + 0xff620000)
+#define   PSCALE_CTRL                              (0x0911)
+#define P_PSCALE_CTRL                              (volatile unsigned int *)((0x0911  << 2) + 0xff620000)
+#define   PSCALE_PICI_W                            (0x0912)
+#define P_PSCALE_PICI_W                            (volatile unsigned int *)((0x0912  << 2) + 0xff620000)
+#define   PSCALE_PICI_H                            (0x0913)
+#define P_PSCALE_PICI_H                            (volatile unsigned int *)((0x0913  << 2) + 0xff620000)
+#define   PSCALE_PICO_W                            (0x0914)
+#define P_PSCALE_PICO_W                            (volatile unsigned int *)((0x0914  << 2) + 0xff620000)
+#define   PSCALE_PICO_H                            (0x0915)
+#define P_PSCALE_PICO_H                            (volatile unsigned int *)((0x0915  << 2) + 0xff620000)
+#define   PSCALE_PICO_START_X                      (0x0916)
+#define P_PSCALE_PICO_START_X                      (volatile unsigned int *)((0x0916  << 2) + 0xff620000)
+#define   PSCALE_PICO_START_Y                      (0x0917)
+#define P_PSCALE_PICO_START_Y                      (volatile unsigned int *)((0x0917  << 2) + 0xff620000)
+#define   PSCALE_DUMMY                             (0x0918)
+#define P_PSCALE_DUMMY                             (volatile unsigned int *)((0x0918  << 2) + 0xff620000)
+#define   PSCALE_FILT0_COEF0                       (0x0919)
+#define P_PSCALE_FILT0_COEF0                       (volatile unsigned int *)((0x0919  << 2) + 0xff620000)
+#define   PSCALE_FILT0_COEF1                       (0x091a)
+#define P_PSCALE_FILT0_COEF1                       (volatile unsigned int *)((0x091a  << 2) + 0xff620000)
+#define   PSCALE_CMD_CTRL                          (0x091b)
+#define P_PSCALE_CMD_CTRL                          (volatile unsigned int *)((0x091b  << 2) + 0xff620000)
+#define   PSCALE_CMD_BLK_X                         (0x091c)
+#define P_PSCALE_CMD_BLK_X                         (volatile unsigned int *)((0x091c  << 2) + 0xff620000)
+#define   PSCALE_CMD_BLK_Y                         (0x091d)
+#define P_PSCALE_CMD_BLK_Y                         (volatile unsigned int *)((0x091d  << 2) + 0xff620000)
+#define   PSCALE_STATUS                            (0x091e)
+#define P_PSCALE_STATUS                            (volatile unsigned int *)((0x091e  << 2) + 0xff620000)
+#define   PSCALE_BMEM_ADDR                         (0x091f)
+#define P_PSCALE_BMEM_ADDR                         (volatile unsigned int *)((0x091f  << 2) + 0xff620000)
+#define   PSCALE_BMEM_DAT                          (0x0920)
+#define P_PSCALE_BMEM_DAT                          (volatile unsigned int *)((0x0920  << 2) + 0xff620000)
+#define   PSCALE_DRAM_BUF_CTRL                     (0x0921)
+#define P_PSCALE_DRAM_BUF_CTRL                     (volatile unsigned int *)((0x0921  << 2) + 0xff620000)
+#define   PSCALE_MCMD_CTRL                         (0x0922)
+#define P_PSCALE_MCMD_CTRL                         (volatile unsigned int *)((0x0922  << 2) + 0xff620000)
+#define   PSCALE_MCMD_XSIZE                        (0x0923)
+#define P_PSCALE_MCMD_XSIZE                        (volatile unsigned int *)((0x0923  << 2) + 0xff620000)
+#define   PSCALE_MCMD_YSIZE                        (0x0924)
+#define P_PSCALE_MCMD_YSIZE                        (volatile unsigned int *)((0x0924  << 2) + 0xff620000)
+#define   PSCALE_RBUF_START_BLKX                   (0x0925)
+#define P_PSCALE_RBUF_START_BLKX                   (volatile unsigned int *)((0x0925  << 2) + 0xff620000)
+#define   PSCALE_RBUF_START_BLKY                   (0x0926)
+#define P_PSCALE_RBUF_START_BLKY                   (volatile unsigned int *)((0x0926  << 2) + 0xff620000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define   PSCALE_PICO_SHIFT_XY                     (0x0928)
+#define P_PSCALE_PICO_SHIFT_XY                     (volatile unsigned int *)((0x0928  << 2) + 0xff620000)
+#define   PSCALE_CTRL1                             (0x0929)
+#define P_PSCALE_CTRL1                             (volatile unsigned int *)((0x0929  << 2) + 0xff620000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less,
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define   PSCALE_SRCKEY_CTRL0                      (0x092a)
+#define P_PSCALE_SRCKEY_CTRL0                      (volatile unsigned int *)((0x092a  << 2) + 0xff620000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define   PSCALE_SRCKEY_CTRL1                      (0x092b)
+#define P_PSCALE_SRCKEY_CTRL1                      (volatile unsigned int *)((0x092b  << 2) + 0xff620000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define   PSCALE_CANVAS_RD_ADDR                    (0x092c)
+#define P_PSCALE_CANVAS_RD_ADDR                    (volatile unsigned int *)((0x092c  << 2) + 0xff620000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define   PSCALE_CANVAS_WR_ADDR                    (0x092d)
+#define P_PSCALE_CANVAS_WR_ADDR                    (volatile unsigned int *)((0x092d  << 2) + 0xff620000)
+//bit 13:8 pscale thread ID and token
+//bit 7 disable write response count adding to busy bit
+//bit 5:0  pscale prearbitor burst num
+#define   PSCALE_CTRL2                             (0x092e)
+#define P_PSCALE_CTRL2                             (volatile unsigned int *)((0x092e  << 2) + 0xff620000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define   HDEC_MC_OMEM_AUTO                        (0x0930)
+#define P_HDEC_MC_OMEM_AUTO                        (volatile unsigned int *)((0x0930  << 2) + 0xff620000)
+#define   HDEC_MC_MBRIGHT_IDX                      (0x0931)
+#define P_HDEC_MC_MBRIGHT_IDX                      (volatile unsigned int *)((0x0931  << 2) + 0xff620000)
+#define   HDEC_MC_MBRIGHT_RD                       (0x0932)
+#define P_HDEC_MC_MBRIGHT_RD                       (volatile unsigned int *)((0x0932  << 2) + 0xff620000)
+#define   MC_MPORT_CTRL                            (0x0940)
+#define P_MC_MPORT_CTRL                            (volatile unsigned int *)((0x0940  << 2) + 0xff620000)
+#define   MC_MPORT_DAT                             (0x0941)
+#define P_MC_MPORT_DAT                             (volatile unsigned int *)((0x0941  << 2) + 0xff620000)
+#define   MC_WT_PRED_CTRL                          (0x0942)
+#define P_MC_WT_PRED_CTRL                          (volatile unsigned int *)((0x0942  << 2) + 0xff620000)
+#define   MC_MBBOT_ST_EVEN_ADDR                    (0x0944)
+#define P_MC_MBBOT_ST_EVEN_ADDR                    (volatile unsigned int *)((0x0944  << 2) + 0xff620000)
+#define   MC_MBBOT_ST_ODD_ADDR                     (0x0945)
+#define P_MC_MBBOT_ST_ODD_ADDR                     (volatile unsigned int *)((0x0945  << 2) + 0xff620000)
+#define   MC_DPDN_MB_XY                            (0x0946)
+#define P_MC_DPDN_MB_XY                            (volatile unsigned int *)((0x0946  << 2) + 0xff620000)
+#define   MC_OMDN_MB_XY                            (0x0947)
+#define P_MC_OMDN_MB_XY                            (volatile unsigned int *)((0x0947  << 2) + 0xff620000)
+#define   MC_HCMDBUF_H                             (0x0948)
+#define P_MC_HCMDBUF_H                             (volatile unsigned int *)((0x0948  << 2) + 0xff620000)
+#define   MC_HCMDBUF_L                             (0x0949)
+#define P_MC_HCMDBUF_L                             (volatile unsigned int *)((0x0949  << 2) + 0xff620000)
+#define   MC_HCMD_H                                (0x094a)
+#define P_MC_HCMD_H                                (volatile unsigned int *)((0x094a  << 2) + 0xff620000)
+#define   MC_HCMD_L                                (0x094b)
+#define P_MC_HCMD_L                                (volatile unsigned int *)((0x094b  << 2) + 0xff620000)
+#define   MC_IDCT_DAT                              (0x094c)
+#define P_MC_IDCT_DAT                              (volatile unsigned int *)((0x094c  << 2) + 0xff620000)
+#define   MC_CTRL_GCLK_CTRL                        (0x094d)
+#define P_MC_CTRL_GCLK_CTRL                        (volatile unsigned int *)((0x094d  << 2) + 0xff620000)
+#define   MC_OTHER_GCLK_CTRL                       (0x094e)
+#define P_MC_OTHER_GCLK_CTRL                       (volatile unsigned int *)((0x094e  << 2) + 0xff620000)
+//Bit 29:24, mbbot thread ID and token
+//Bit 21:16, mc read/write thread ID and token
+//Bit 13:8,  mbbot pre-arbitor burst number
+//Bit 5:0,   mc pre-arbitor burst number
+#define   MC_CTRL2                                 (0x094f)
+#define P_MC_CTRL2                                 (volatile unsigned int *)((0x094f  << 2) + 0xff620000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+// mdec_pic_dc_mux_ctrl[31]  -- mcr_hevc_mode
+#define   MDEC_PIC_DC_MUX_CTRL                     (0x098d)
+#define P_MDEC_PIC_DC_MUX_CTRL                     (volatile unsigned int *)((0x098d  << 2) + 0xff620000)
+#define   MDEC_PIC_DC_CTRL                         (0x098e)
+#define P_MDEC_PIC_DC_CTRL                         (volatile unsigned int *)((0x098e  << 2) + 0xff620000)
+#define   MDEC_PIC_DC_STATUS                       (0x098f)
+#define P_MDEC_PIC_DC_STATUS                       (volatile unsigned int *)((0x098f  << 2) + 0xff620000)
+#define   ANC0_CANVAS_ADDR                         (0x0990)
+#define P_ANC0_CANVAS_ADDR                         (volatile unsigned int *)((0x0990  << 2) + 0xff620000)
+#define   ANC1_CANVAS_ADDR                         (0x0991)
+#define P_ANC1_CANVAS_ADDR                         (volatile unsigned int *)((0x0991  << 2) + 0xff620000)
+#define   ANC2_CANVAS_ADDR                         (0x0992)
+#define P_ANC2_CANVAS_ADDR                         (volatile unsigned int *)((0x0992  << 2) + 0xff620000)
+#define   ANC3_CANVAS_ADDR                         (0x0993)
+#define P_ANC3_CANVAS_ADDR                         (volatile unsigned int *)((0x0993  << 2) + 0xff620000)
+#define   ANC4_CANVAS_ADDR                         (0x0994)
+#define P_ANC4_CANVAS_ADDR                         (volatile unsigned int *)((0x0994  << 2) + 0xff620000)
+#define   ANC5_CANVAS_ADDR                         (0x0995)
+#define P_ANC5_CANVAS_ADDR                         (volatile unsigned int *)((0x0995  << 2) + 0xff620000)
+#define   ANC6_CANVAS_ADDR                         (0x0996)
+#define P_ANC6_CANVAS_ADDR                         (volatile unsigned int *)((0x0996  << 2) + 0xff620000)
+#define   ANC7_CANVAS_ADDR                         (0x0997)
+#define P_ANC7_CANVAS_ADDR                         (volatile unsigned int *)((0x0997  << 2) + 0xff620000)
+#define   ANC8_CANVAS_ADDR                         (0x0998)
+#define P_ANC8_CANVAS_ADDR                         (volatile unsigned int *)((0x0998  << 2) + 0xff620000)
+#define   ANC9_CANVAS_ADDR                         (0x0999)
+#define P_ANC9_CANVAS_ADDR                         (volatile unsigned int *)((0x0999  << 2) + 0xff620000)
+#define   ANC10_CANVAS_ADDR                        (0x099a)
+#define P_ANC10_CANVAS_ADDR                        (volatile unsigned int *)((0x099a  << 2) + 0xff620000)
+#define   ANC11_CANVAS_ADDR                        (0x099b)
+#define P_ANC11_CANVAS_ADDR                        (volatile unsigned int *)((0x099b  << 2) + 0xff620000)
+#define   ANC12_CANVAS_ADDR                        (0x099c)
+#define P_ANC12_CANVAS_ADDR                        (volatile unsigned int *)((0x099c  << 2) + 0xff620000)
+#define   ANC13_CANVAS_ADDR                        (0x099d)
+#define P_ANC13_CANVAS_ADDR                        (volatile unsigned int *)((0x099d  << 2) + 0xff620000)
+#define   ANC14_CANVAS_ADDR                        (0x099e)
+#define P_ANC14_CANVAS_ADDR                        (volatile unsigned int *)((0x099e  << 2) + 0xff620000)
+#define   ANC15_CANVAS_ADDR                        (0x099f)
+#define P_ANC15_CANVAS_ADDR                        (volatile unsigned int *)((0x099f  << 2) + 0xff620000)
+#define   ANC16_CANVAS_ADDR                        (0x09a0)
+#define P_ANC16_CANVAS_ADDR                        (volatile unsigned int *)((0x09a0  << 2) + 0xff620000)
+#define   ANC17_CANVAS_ADDR                        (0x09a1)
+#define P_ANC17_CANVAS_ADDR                        (volatile unsigned int *)((0x09a1  << 2) + 0xff620000)
+#define   ANC18_CANVAS_ADDR                        (0x09a2)
+#define P_ANC18_CANVAS_ADDR                        (volatile unsigned int *)((0x09a2  << 2) + 0xff620000)
+#define   ANC19_CANVAS_ADDR                        (0x09a3)
+#define P_ANC19_CANVAS_ADDR                        (volatile unsigned int *)((0x09a3  << 2) + 0xff620000)
+#define   ANC20_CANVAS_ADDR                        (0x09a4)
+#define P_ANC20_CANVAS_ADDR                        (volatile unsigned int *)((0x09a4  << 2) + 0xff620000)
+#define   ANC21_CANVAS_ADDR                        (0x09a5)
+#define P_ANC21_CANVAS_ADDR                        (volatile unsigned int *)((0x09a5  << 2) + 0xff620000)
+#define   ANC22_CANVAS_ADDR                        (0x09a6)
+#define P_ANC22_CANVAS_ADDR                        (volatile unsigned int *)((0x09a6  << 2) + 0xff620000)
+#define   ANC23_CANVAS_ADDR                        (0x09a7)
+#define P_ANC23_CANVAS_ADDR                        (volatile unsigned int *)((0x09a7  << 2) + 0xff620000)
+#define   ANC24_CANVAS_ADDR                        (0x09a8)
+#define P_ANC24_CANVAS_ADDR                        (volatile unsigned int *)((0x09a8  << 2) + 0xff620000)
+#define   ANC25_CANVAS_ADDR                        (0x09a9)
+#define P_ANC25_CANVAS_ADDR                        (volatile unsigned int *)((0x09a9  << 2) + 0xff620000)
+#define   ANC26_CANVAS_ADDR                        (0x09aa)
+#define P_ANC26_CANVAS_ADDR                        (volatile unsigned int *)((0x09aa  << 2) + 0xff620000)
+#define   ANC27_CANVAS_ADDR                        (0x09ab)
+#define P_ANC27_CANVAS_ADDR                        (volatile unsigned int *)((0x09ab  << 2) + 0xff620000)
+#define   ANC28_CANVAS_ADDR                        (0x09ac)
+#define P_ANC28_CANVAS_ADDR                        (volatile unsigned int *)((0x09ac  << 2) + 0xff620000)
+#define   ANC29_CANVAS_ADDR                        (0x09ad)
+#define P_ANC29_CANVAS_ADDR                        (volatile unsigned int *)((0x09ad  << 2) + 0xff620000)
+#define   ANC30_CANVAS_ADDR                        (0x09ae)
+#define P_ANC30_CANVAS_ADDR                        (volatile unsigned int *)((0x09ae  << 2) + 0xff620000)
+#define   ANC31_CANVAS_ADDR                        (0x09af)
+#define P_ANC31_CANVAS_ADDR                        (volatile unsigned int *)((0x09af  << 2) + 0xff620000)
+#define   DBKR_CANVAS_ADDR                         (0x09b0)
+#define P_DBKR_CANVAS_ADDR                         (volatile unsigned int *)((0x09b0  << 2) + 0xff620000)
+#define   DBKW_CANVAS_ADDR                         (0x09b1)
+#define P_DBKW_CANVAS_ADDR                         (volatile unsigned int *)((0x09b1  << 2) + 0xff620000)
+#define   REC_CANVAS_ADDR                          (0x09b2)
+#define P_REC_CANVAS_ADDR                          (volatile unsigned int *)((0x09b2  << 2) + 0xff620000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define   CURR_CANVAS_CTRL                         (0x09b3)
+#define P_CURR_CANVAS_CTRL                         (volatile unsigned int *)((0x09b3  << 2) + 0xff620000)
+#define   MDEC_PIC_DC_THRESH                       (0x09b8)
+#define P_MDEC_PIC_DC_THRESH                       (volatile unsigned int *)((0x09b8  << 2) + 0xff620000)
+#define   MDEC_PICR_BUF_STATUS                     (0x09b9)
+#define P_MDEC_PICR_BUF_STATUS                     (volatile unsigned int *)((0x09b9  << 2) + 0xff620000)
+#define   MDEC_PICW_BUF_STATUS                     (0x09ba)
+#define P_MDEC_PICW_BUF_STATUS                     (volatile unsigned int *)((0x09ba  << 2) + 0xff620000)
+#define   MCW_DBLK_WRRSP_CNT                       (0x09bb)
+#define P_MCW_DBLK_WRRSP_CNT                       (volatile unsigned int *)((0x09bb  << 2) + 0xff620000)
+#define   MC_MBBOT_WRRSP_CNT                       (0x09bc)
+#define P_MC_MBBOT_WRRSP_CNT                       (volatile unsigned int *)((0x09bc  << 2) + 0xff620000)
+#define   MDEC_PICW_BUF2_STATUS                    (0x09bd)
+#define P_MDEC_PICW_BUF2_STATUS                    (volatile unsigned int *)((0x09bd  << 2) + 0xff620000)
+#define   WRRSP_FIFO_PICW_DBK                      (0x09be)
+#define P_WRRSP_FIFO_PICW_DBK                      (volatile unsigned int *)((0x09be  << 2) + 0xff620000)
+#define   WRRSP_FIFO_PICW_MC                       (0x09bf)
+#define P_WRRSP_FIFO_PICW_MC                       (volatile unsigned int *)((0x09bf  << 2) + 0xff620000)
+#define   AV_SCRATCH_0                             (0x09c0)
+#define P_AV_SCRATCH_0                             (volatile unsigned int *)((0x09c0  << 2) + 0xff620000)
+#define   AV_SCRATCH_1                             (0x09c1)
+#define P_AV_SCRATCH_1                             (volatile unsigned int *)((0x09c1  << 2) + 0xff620000)
+#define   AV_SCRATCH_2                             (0x09c2)
+#define P_AV_SCRATCH_2                             (volatile unsigned int *)((0x09c2  << 2) + 0xff620000)
+#define   AV_SCRATCH_3                             (0x09c3)
+#define P_AV_SCRATCH_3                             (volatile unsigned int *)((0x09c3  << 2) + 0xff620000)
+#define   AV_SCRATCH_4                             (0x09c4)
+#define P_AV_SCRATCH_4                             (volatile unsigned int *)((0x09c4  << 2) + 0xff620000)
+#define   AV_SCRATCH_5                             (0x09c5)
+#define P_AV_SCRATCH_5                             (volatile unsigned int *)((0x09c5  << 2) + 0xff620000)
+#define   AV_SCRATCH_6                             (0x09c6)
+#define P_AV_SCRATCH_6                             (volatile unsigned int *)((0x09c6  << 2) + 0xff620000)
+#define   AV_SCRATCH_7                             (0x09c7)
+#define P_AV_SCRATCH_7                             (volatile unsigned int *)((0x09c7  << 2) + 0xff620000)
+#define   AV_SCRATCH_8                             (0x09c8)
+#define P_AV_SCRATCH_8                             (volatile unsigned int *)((0x09c8  << 2) + 0xff620000)
+#define   AV_SCRATCH_9                             (0x09c9)
+#define P_AV_SCRATCH_9                             (volatile unsigned int *)((0x09c9  << 2) + 0xff620000)
+#define   AV_SCRATCH_A                             (0x09ca)
+#define P_AV_SCRATCH_A                             (volatile unsigned int *)((0x09ca  << 2) + 0xff620000)
+#define   AV_SCRATCH_B                             (0x09cb)
+#define P_AV_SCRATCH_B                             (volatile unsigned int *)((0x09cb  << 2) + 0xff620000)
+#define   AV_SCRATCH_C                             (0x09cc)
+#define P_AV_SCRATCH_C                             (volatile unsigned int *)((0x09cc  << 2) + 0xff620000)
+#define   AV_SCRATCH_D                             (0x09cd)
+#define P_AV_SCRATCH_D                             (volatile unsigned int *)((0x09cd  << 2) + 0xff620000)
+#define   AV_SCRATCH_E                             (0x09ce)
+#define P_AV_SCRATCH_E                             (volatile unsigned int *)((0x09ce  << 2) + 0xff620000)
+#define   AV_SCRATCH_F                             (0x09cf)
+#define P_AV_SCRATCH_F                             (volatile unsigned int *)((0x09cf  << 2) + 0xff620000)
+#define   AV_SCRATCH_G                             (0x09d0)
+#define P_AV_SCRATCH_G                             (volatile unsigned int *)((0x09d0  << 2) + 0xff620000)
+#define   AV_SCRATCH_H                             (0x09d1)
+#define P_AV_SCRATCH_H                             (volatile unsigned int *)((0x09d1  << 2) + 0xff620000)
+#define   AV_SCRATCH_I                             (0x09d2)
+#define P_AV_SCRATCH_I                             (volatile unsigned int *)((0x09d2  << 2) + 0xff620000)
+#define   AV_SCRATCH_J                             (0x09d3)
+#define P_AV_SCRATCH_J                             (volatile unsigned int *)((0x09d3  << 2) + 0xff620000)
+#define   AV_SCRATCH_K                             (0x09d4)
+#define P_AV_SCRATCH_K                             (volatile unsigned int *)((0x09d4  << 2) + 0xff620000)
+#define   AV_SCRATCH_L                             (0x09d5)
+#define P_AV_SCRATCH_L                             (volatile unsigned int *)((0x09d5  << 2) + 0xff620000)
+#define   AV_SCRATCH_M                             (0x09d6)
+#define P_AV_SCRATCH_M                             (volatile unsigned int *)((0x09d6  << 2) + 0xff620000)
+#define   AV_SCRATCH_N                             (0x09d7)
+#define P_AV_SCRATCH_N                             (volatile unsigned int *)((0x09d7  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define   WRRSP_CO_MB                              (0x09d8)
+#define P_WRRSP_CO_MB                              (volatile unsigned int *)((0x09d8  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define   WRRSP_DCAC                               (0x09d9)
+#define P_WRRSP_DCAC                               (volatile unsigned int *)((0x09d9  << 2) + 0xff620000)
+// bit[11:0] wrrsp_count_vld
+#define   WRRSP_VLD                                (0x09da)
+#define P_WRRSP_VLD                                (volatile unsigned int *)((0x09da  << 2) + 0xff620000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define   MDEC_DOUBLEW_CFG0                        (0x09db)
+#define P_MDEC_DOUBLEW_CFG0                        (volatile unsigned int *)((0x09db  << 2) + 0xff620000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write -
+// doublew_cfg1[17];    //       Reverse to original version -
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define   MDEC_DOUBLEW_CFG1                        (0x09dc)
+#define P_MDEC_DOUBLEW_CFG1                        (volatile unsigned int *)((0x09dc  << 2) + 0xff620000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define   MDEC_DOUBLEW_CFG2                        (0x09dd)
+#define P_MDEC_DOUBLEW_CFG2                        (volatile unsigned int *)((0x09dd  << 2) + 0xff620000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma -
+#define   MDEC_DOUBLEW_CFG3                        (0x09de)
+#define P_MDEC_DOUBLEW_CFG3                        (volatile unsigned int *)((0x09de  << 2) + 0xff620000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma -
+#define   MDEC_DOUBLEW_CFG4                        (0x09df)
+#define P_MDEC_DOUBLEW_CFG4                        (volatile unsigned int *)((0x09df  << 2) + 0xff620000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma -
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma -
+#define   MDEC_DOUBLEW_CFG5                        (0x09e0)
+#define P_MDEC_DOUBLEW_CFG5                        (volatile unsigned int *)((0x09e0  << 2) + 0xff620000)
+// doublew_cfg6: reserved
+#define   MDEC_DOUBLEW_CFG6                        (0x09e1)
+#define P_MDEC_DOUBLEW_CFG6                        (volatile unsigned int *)((0x09e1  << 2) + 0xff620000)
+// doublew_cfg7: reserved
+#define   MDEC_DOUBLEW_CFG7                        (0x09e2)
+#define P_MDEC_DOUBLEW_CFG7                        (volatile unsigned int *)((0x09e2  << 2) + 0xff620000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define   MDEC_DOUBLEW_STATUS                      (0x09e3)
+#define P_MDEC_DOUBLEW_STATUS                      (volatile unsigned int *)((0x09e3  << 2) + 0xff620000)
+#define   MDEC_EXTIF_CFG0                          (0x09e4)
+#define P_MDEC_EXTIF_CFG0                          (volatile unsigned int *)((0x09e4  << 2) + 0xff620000)
+#define   MDEC_EXTIF_CFG1                          (0x09e5)
+#define P_MDEC_EXTIF_CFG1                          (volatile unsigned int *)((0x09e5  << 2) + 0xff620000)
+#define   MDEC_EXTIF_STS0                          (0x09e6)
+#define P_MDEC_EXTIF_STS0                          (volatile unsigned int *)((0x09e6  << 2) + 0xff620000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    #define MC_ENABLE	    0x0001
+    //`define MC_RESET	    16'h0002
+    #define SKIP_MB		    0x0004
+
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+    #define INTRA_MB	    0x0001
+
+    #define BWD_PRED	    0x0004
+    #define FWD_PRED	    0x0008
+
+    #define FLD_MOT		    0x0100
+    #define FRM_16x8_MOT	0x0200
+    #define DUAL_PRM_MOT	0x0300
+
+    #define FRM_DCT		    0x0000	    // Bit 10
+    #define FLD_DCT		    0x0400
+
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+    #define I_PIC		    0x0001
+    #define P_PIC		    0x0002
+    #define B_PIC		    0x0003
+
+    #define FLD_PIC		    0x0000	    // Bit 8
+    #define FRM_PIC		    0x0100
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f
+//========================================================================
+#define   DBLK_RST                                 (0x0950)
+#define P_DBLK_RST                                 (volatile unsigned int *)((0x0950  << 2) + 0xff620000)
+#define   DBLK_CTRL                                (0x0951)
+#define P_DBLK_CTRL                                (volatile unsigned int *)((0x0951  << 2) + 0xff620000)
+#define   DBLK_MB_WID_HEIGHT                       (0x0952)
+#define P_DBLK_MB_WID_HEIGHT                       (volatile unsigned int *)((0x0952  << 2) + 0xff620000)
+#define   DBLK_STATUS                              (0x0953)
+#define P_DBLK_STATUS                              (volatile unsigned int *)((0x0953  << 2) + 0xff620000)
+#define   DBLK_CMD_CTRL                            (0x0954)
+#define P_DBLK_CMD_CTRL                            (volatile unsigned int *)((0x0954  << 2) + 0xff620000)
+#define   DBLK_MB_XY                               (0x0955)
+#define P_DBLK_MB_XY                               (volatile unsigned int *)((0x0955  << 2) + 0xff620000)
+#define   DBLK_QP                                  (0x0956)
+#define P_DBLK_QP                                  (volatile unsigned int *)((0x0956  << 2) + 0xff620000)
+#define   DBLK_Y_BHFILT                            (0x0957)
+#define P_DBLK_Y_BHFILT                            (volatile unsigned int *)((0x0957  << 2) + 0xff620000)
+#define   DBLK_Y_BHFILT_HIGH                       (0x0958)
+#define P_DBLK_Y_BHFILT_HIGH                       (volatile unsigned int *)((0x0958  << 2) + 0xff620000)
+#define   DBLK_Y_BVFILT                            (0x0959)
+#define P_DBLK_Y_BVFILT                            (volatile unsigned int *)((0x0959  << 2) + 0xff620000)
+#define   DBLK_CB_BFILT                            (0x095a)
+#define P_DBLK_CB_BFILT                            (volatile unsigned int *)((0x095a  << 2) + 0xff620000)
+#define   DBLK_CR_BFILT                            (0x095b)
+#define P_DBLK_CR_BFILT                            (volatile unsigned int *)((0x095b  << 2) + 0xff620000)
+#define   DBLK_Y_HFILT                             (0x095c)
+#define P_DBLK_Y_HFILT                             (volatile unsigned int *)((0x095c  << 2) + 0xff620000)
+#define   DBLK_Y_HFILT_HIGH                        (0x095d)
+#define P_DBLK_Y_HFILT_HIGH                        (volatile unsigned int *)((0x095d  << 2) + 0xff620000)
+#define   DBLK_Y_VFILT                             (0x095e)
+#define P_DBLK_Y_VFILT                             (volatile unsigned int *)((0x095e  << 2) + 0xff620000)
+#define   DBLK_CB_FILT                             (0x095f)
+#define P_DBLK_CB_FILT                             (volatile unsigned int *)((0x095f  << 2) + 0xff620000)
+#define   DBLK_CR_FILT                             (0x0960)
+#define P_DBLK_CR_FILT                             (volatile unsigned int *)((0x0960  << 2) + 0xff620000)
+#define   DBLK_BETAX_QP_SEL                        (0x0961)
+#define P_DBLK_BETAX_QP_SEL                        (volatile unsigned int *)((0x0961  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL0                          (0x0962)
+#define P_DBLK_CLIP_CTRL0                          (volatile unsigned int *)((0x0962  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL1                          (0x0963)
+#define P_DBLK_CLIP_CTRL1                          (volatile unsigned int *)((0x0963  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL2                          (0x0964)
+#define P_DBLK_CLIP_CTRL2                          (volatile unsigned int *)((0x0964  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL3                          (0x0965)
+#define P_DBLK_CLIP_CTRL3                          (volatile unsigned int *)((0x0965  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL4                          (0x0966)
+#define P_DBLK_CLIP_CTRL4                          (volatile unsigned int *)((0x0966  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL5                          (0x0967)
+#define P_DBLK_CLIP_CTRL5                          (volatile unsigned int *)((0x0967  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL6                          (0x0968)
+#define P_DBLK_CLIP_CTRL6                          (volatile unsigned int *)((0x0968  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL7                          (0x0969)
+#define P_DBLK_CLIP_CTRL7                          (volatile unsigned int *)((0x0969  << 2) + 0xff620000)
+#define   DBLK_CLIP_CTRL8                          (0x096a)
+#define P_DBLK_CLIP_CTRL8                          (volatile unsigned int *)((0x096a  << 2) + 0xff620000)
+#define   DBLK_STATUS1                             (0x096b)
+#define P_DBLK_STATUS1                             (volatile unsigned int *)((0x096b  << 2) + 0xff620000)
+#define   DBLK_GCLK_FREE                           (0x096c)
+#define P_DBLK_GCLK_FREE                           (volatile unsigned int *)((0x096c  << 2) + 0xff620000)
+#define   DBLK_GCLK_OFF                            (0x096d)
+#define P_DBLK_GCLK_OFF                            (volatile unsigned int *)((0x096d  << 2) + 0xff620000)
+#define   DBLK_AVSFLAGS                            (0x096e)
+#define P_DBLK_AVSFLAGS                            (volatile unsigned int *)((0x096e  << 2) + 0xff620000)
+// bit 15:0
+#define   DBLK_CBPY                                (0x0970)
+#define P_DBLK_CBPY                                (volatile unsigned int *)((0x0970  << 2) + 0xff620000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define   DBLK_CBPY_ADJ                            (0x0971)
+#define P_DBLK_CBPY_ADJ                            (volatile unsigned int *)((0x0971  << 2) + 0xff620000)
+// bit 7:0 -- deblk_cbpc
+#define   DBLK_CBPC                                (0x0972)
+#define P_DBLK_CBPC                                (volatile unsigned int *)((0x0972  << 2) + 0xff620000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define   DBLK_CBPC_ADJ                            (0x0973)
+#define P_DBLK_CBPC_ADJ                            (volatile unsigned int *)((0x0973  << 2) + 0xff620000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0}
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0}
+#define   DBLK_VHMVD                               (0x0974)
+#define P_DBLK_VHMVD                               (volatile unsigned int *)((0x0974  << 2) + 0xff620000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s
+#define   DBLK_STRONG                              (0x0975)
+#define P_DBLK_STRONG                              (volatile unsigned int *)((0x0975  << 2) + 0xff620000)
+// bit 14:10 -- PQUANT
+// bit 9:5 -- left_PQUANT
+// bit 4:0 -- top_PQUANT
+#define   DBLK_RV8_QUANT                           (0x0976)
+#define P_DBLK_RV8_QUANT                           (volatile unsigned int *)((0x0976  << 2) + 0xff620000)
+#define   DBLK_CBUS_HCMD2                          (0x0977)
+#define P_DBLK_CBUS_HCMD2                          (volatile unsigned int *)((0x0977  << 2) + 0xff620000)
+#define   DBLK_CBUS_HCMD1                          (0x0978)
+#define P_DBLK_CBUS_HCMD1                          (volatile unsigned int *)((0x0978  << 2) + 0xff620000)
+#define   DBLK_CBUS_HCMD0                          (0x0979)
+#define P_DBLK_CBUS_HCMD0                          (volatile unsigned int *)((0x0979  << 2) + 0xff620000)
+#define   DBLK_VLD_HCMD2                           (0x097a)
+#define P_DBLK_VLD_HCMD2                           (volatile unsigned int *)((0x097a  << 2) + 0xff620000)
+#define   DBLK_VLD_HCMD1                           (0x097b)
+#define P_DBLK_VLD_HCMD1                           (volatile unsigned int *)((0x097b  << 2) + 0xff620000)
+#define   DBLK_VLD_HCMD0                           (0x097c)
+#define P_DBLK_VLD_HCMD0                           (volatile unsigned int *)((0x097c  << 2) + 0xff620000)
+#define   DBLK_OST_YBASE                           (0x097d)
+#define P_DBLK_OST_YBASE                           (volatile unsigned int *)((0x097d  << 2) + 0xff620000)
+#define   DBLK_OST_CBCRDIFF                        (0x097e)
+#define P_DBLK_OST_CBCRDIFF                        (volatile unsigned int *)((0x097e  << 2) + 0xff620000)
+//13:8 dblk thread ID and token
+//5:0  dblk prearbitor burst num
+#define   DBLK_CTRL1                               (0x097f)
+#define P_DBLK_CTRL1                               (volatile unsigned int *)((0x097f  << 2) + 0xff620000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define   MCRCC_CTL1                               (0x0980)
+#define P_MCRCC_CTL1                               (volatile unsigned int *)((0x0980  << 2) + 0xff620000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define   MCRCC_CTL2                               (0x0981)
+#define P_MCRCC_CTL2                               (volatile unsigned int *)((0x0981  << 2) + 0xff620000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define   MCRCC_CTL3                               (0x0982)
+#define P_MCRCC_CTL3                               (volatile unsigned int *)((0x0982  << 2) + 0xff620000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define   GCLK_EN                                  (0x0983)
+#define P_GCLK_EN                                  (volatile unsigned int *)((0x0983  << 2) + 0xff620000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define   MDEC_SW_RESET                            (0x0984)
+#define P_MDEC_SW_RESET                            (volatile unsigned int *)((0x0984  << 2) + 0xff620000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//------------------------------------------------------------------------------
+// VLD module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define   VLD_STATUS_CTRL                          (0x0c00)
+#define P_VLD_STATUS_CTRL                          (volatile unsigned int *)((0x0c00  << 2) + 0xff620000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define   MPEG1_2_REG                              (0x0c01)
+#define P_MPEG1_2_REG                              (volatile unsigned int *)((0x0c01  << 2) + 0xff620000)
+#define   F_CODE_REG                               (0x0c02)
+#define P_F_CODE_REG                               (volatile unsigned int *)((0x0c02  << 2) + 0xff620000)
+#define   PIC_HEAD_INFO                            (0x0c03)
+#define P_PIC_HEAD_INFO                            (volatile unsigned int *)((0x0c03  << 2) + 0xff620000)
+#define   SLICE_VER_POS_PIC_TYPE                   (0x0c04)
+#define P_SLICE_VER_POS_PIC_TYPE                   (volatile unsigned int *)((0x0c04  << 2) + 0xff620000)
+#define   QP_VALUE_REG                             (0x0c05)
+#define P_QP_VALUE_REG                             (volatile unsigned int *)((0x0c05  << 2) + 0xff620000)
+#define   MBA_INC                                  (0x0c06)
+#define P_MBA_INC                                  (volatile unsigned int *)((0x0c06  << 2) + 0xff620000)
+#define   MB_MOTION_MODE                           (0x0c07)
+#define P_MB_MOTION_MODE                           (volatile unsigned int *)((0x0c07  << 2) + 0xff620000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en
+// bit 5:0 -- vld_power_ctl
+#define   POWER_CTL_VLD                            (0x0c08)
+#define P_POWER_CTL_VLD                            (volatile unsigned int *)((0x0c08  << 2) + 0xff620000)
+#define   MB_WIDTH                                 (0x0c09)
+#define P_MB_WIDTH                                 (volatile unsigned int *)((0x0c09  << 2) + 0xff620000)
+#define   SLICE_QP                                 (0x0c0a)
+#define P_SLICE_QP                                 (volatile unsigned int *)((0x0c0a  << 2) + 0xff620000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define   PRE_START_CODE                           (0x0c0b)
+#define P_PRE_START_CODE                           (volatile unsigned int *)((0x0c0b  << 2) + 0xff620000)
+#define   SLICE_START_BYTE_01                      (0x0c0c)
+#define P_SLICE_START_BYTE_01                      (volatile unsigned int *)((0x0c0c  << 2) + 0xff620000)
+#define   SLICE_START_BYTE_23                      (0x0c0d)
+#define P_SLICE_START_BYTE_23                      (volatile unsigned int *)((0x0c0d  << 2) + 0xff620000)
+#define   RESYNC_MARKER_LENGTH                     (0x0c0e)
+#define P_RESYNC_MARKER_LENGTH                     (volatile unsigned int *)((0x0c0e  << 2) + 0xff620000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define   DECODER_BUFFER_INFO                      (0x0c0f)
+#define P_DECODER_BUFFER_INFO                      (volatile unsigned int *)((0x0c0f  << 2) + 0xff620000)
+#define   FST_FOR_MV_X                             (0x0c10)
+#define P_FST_FOR_MV_X                             (volatile unsigned int *)((0x0c10  << 2) + 0xff620000)
+#define   FST_FOR_MV_Y                             (0x0c11)
+#define P_FST_FOR_MV_Y                             (volatile unsigned int *)((0x0c11  << 2) + 0xff620000)
+#define   SCD_FOR_MV_X                             (0x0c12)
+#define P_SCD_FOR_MV_X                             (volatile unsigned int *)((0x0c12  << 2) + 0xff620000)
+#define   SCD_FOR_MV_Y                             (0x0c13)
+#define P_SCD_FOR_MV_Y                             (volatile unsigned int *)((0x0c13  << 2) + 0xff620000)
+#define   FST_BAK_MV_X                             (0x0c14)
+#define P_FST_BAK_MV_X                             (volatile unsigned int *)((0x0c14  << 2) + 0xff620000)
+#define   FST_BAK_MV_Y                             (0x0c15)
+#define P_FST_BAK_MV_Y                             (volatile unsigned int *)((0x0c15  << 2) + 0xff620000)
+#define   SCD_BAK_MV_X                             (0x0c16)
+#define P_SCD_BAK_MV_X                             (volatile unsigned int *)((0x0c16  << 2) + 0xff620000)
+#define   SCD_BAK_MV_Y                             (0x0c17)
+#define P_SCD_BAK_MV_Y                             (volatile unsigned int *)((0x0c17  << 2) + 0xff620000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- disable_new_stcode_search_fix // From GXM
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag
+#define   VLD_DECODE_CONTROL                       (0x0c18)
+#define P_VLD_DECODE_CONTROL                       (volatile unsigned int *)((0x0c18  << 2) + 0xff620000)
+#define   VLD_REVERVED_19                          (0x0c19)
+#define P_VLD_REVERVED_19                          (volatile unsigned int *)((0x0c19  << 2) + 0xff620000)
+#define   VIFF_BIT_CNT                             (0x0c1a)
+#define P_VIFF_BIT_CNT                             (volatile unsigned int *)((0x0c1a  << 2) + 0xff620000)
+#define   BYTE_ALIGN_PEAK_HI                       (0x0c1b)
+#define P_BYTE_ALIGN_PEAK_HI                       (volatile unsigned int *)((0x0c1b  << 2) + 0xff620000)
+#define   BYTE_ALIGN_PEAK_LO                       (0x0c1c)
+#define P_BYTE_ALIGN_PEAK_LO                       (volatile unsigned int *)((0x0c1c  << 2) + 0xff620000)
+#define   NEXT_ALIGN_PEAK                          (0x0c1d)
+#define P_NEXT_ALIGN_PEAK                          (volatile unsigned int *)((0x0c1d  << 2) + 0xff620000)
+// bit 31    : byte_aligned_zero_23_from_org // From GXM
+// bit 30    : force_shift_out_drop_flag_zero // From GXM
+// bit 29    : en_st_protect_from_org // From GXM
+// bit 28    : enable_halt_decode_start_voff
+// bit 27    : disable_C_pred_check
+// bit 26    : disable_I4_pred_check
+// bit 25    : disable_I16_pred_check
+// bit 24    : check_avs_1st_drop
+// bit 23    : enable_cabac_protect // From GXM
+// bit 22    : enable_avs_drop_more
+// bit 21    : reset_avs_drop_ptr
+// bit 20    : reset_cabac_use_next_at_end_req
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : disable_mv_cal_begin_only
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define   VC1_CONTROL_REG                          (0x0c1e)
+#define P_VC1_CONTROL_REG                          (volatile unsigned int *)((0x0c1e  << 2) + 0xff620000)
+#define   PMV1_X                                   (0x0c20)
+#define P_PMV1_X                                   (volatile unsigned int *)((0x0c20  << 2) + 0xff620000)
+#define   PMV1_Y                                   (0x0c21)
+#define P_PMV1_Y                                   (volatile unsigned int *)((0x0c21  << 2) + 0xff620000)
+#define   PMV2_X                                   (0x0c22)
+#define P_PMV2_X                                   (volatile unsigned int *)((0x0c22  << 2) + 0xff620000)
+#define   PMV2_Y                                   (0x0c23)
+#define P_PMV2_Y                                   (volatile unsigned int *)((0x0c23  << 2) + 0xff620000)
+#define   PMV3_X                                   (0x0c24)
+#define P_PMV3_X                                   (volatile unsigned int *)((0x0c24  << 2) + 0xff620000)
+#define   PMV3_Y                                   (0x0c25)
+#define P_PMV3_Y                                   (volatile unsigned int *)((0x0c25  << 2) + 0xff620000)
+#define   PMV4_X                                   (0x0c26)
+#define P_PMV4_X                                   (volatile unsigned int *)((0x0c26  << 2) + 0xff620000)
+#define   PMV4_Y                                   (0x0c27)
+#define P_PMV4_Y                                   (volatile unsigned int *)((0x0c27  << 2) + 0xff620000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define   M4_TABLE_SELECT                          (0x0c28)
+#define P_M4_TABLE_SELECT                          (volatile unsigned int *)((0x0c28  << 2) + 0xff620000)
+#define   M4_CONTROL_REG                           (0x0c29)
+#define P_M4_CONTROL_REG                           (volatile unsigned int *)((0x0c29  << 2) + 0xff620000)
+#define   BLOCK_NUM                                (0x0c2a)
+#define P_BLOCK_NUM                                (volatile unsigned int *)((0x0c2a  << 2) + 0xff620000)
+#define   PATTERN_CODE                             (0x0c2b)
+#define P_PATTERN_CODE                             (volatile unsigned int *)((0x0c2b  << 2) + 0xff620000)
+#define   MB_INFO                                  (0x0c2c)
+#define P_MB_INFO                                  (volatile unsigned int *)((0x0c2c  << 2) + 0xff620000)
+#define   VLD_DC_PRED                              (0x0c2d)
+#define P_VLD_DC_PRED                              (volatile unsigned int *)((0x0c2d  << 2) + 0xff620000)
+#define   VLD_ERROR_MASK                           (0x0c2e)
+#define P_VLD_ERROR_MASK                           (volatile unsigned int *)((0x0c2e  << 2) + 0xff620000)
+#define   VLD_DC_PRED_C                            (0x0c2f)
+#define P_VLD_DC_PRED_C                            (volatile unsigned int *)((0x0c2f  << 2) + 0xff620000)
+#define   LAST_SLICE_MV_ADDR                       (0x0c30)
+#define P_LAST_SLICE_MV_ADDR                       (volatile unsigned int *)((0x0c30  << 2) + 0xff620000)
+#define   LAST_MVX                                 (0x0c31)
+#define P_LAST_MVX                                 (volatile unsigned int *)((0x0c31  << 2) + 0xff620000)
+#define   LAST_MVY                                 (0x0c32)
+#define P_LAST_MVY                                 (volatile unsigned int *)((0x0c32  << 2) + 0xff620000)
+#define   VLD_C38                                  (0x0c38)
+#define P_VLD_C38                                  (volatile unsigned int *)((0x0c38  << 2) + 0xff620000)
+#define   VLD_C39                                  (0x0c39)
+#define P_VLD_C39                                  (volatile unsigned int *)((0x0c39  << 2) + 0xff620000)
+#define   VLD_STATUS                               (0x0c3a)
+#define P_VLD_STATUS                               (volatile unsigned int *)((0x0c3a  << 2) + 0xff620000)
+#define   VLD_SHIFT_STATUS                         (0x0c3b)
+#define P_VLD_SHIFT_STATUS                         (volatile unsigned int *)((0x0c3b  << 2) + 0xff620000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define   VOFF_STATUS                              (0x0c3c)
+#define P_VOFF_STATUS                              (volatile unsigned int *)((0x0c3c  << 2) + 0xff620000)
+#define   VLD_C3D                                  (0x0c3d)
+#define P_VLD_C3D                                  (volatile unsigned int *)((0x0c3d  << 2) + 0xff620000)
+#define   VLD_DBG_INDEX                            (0x0c3e)
+#define P_VLD_DBG_INDEX                            (volatile unsigned int *)((0x0c3e  << 2) + 0xff620000)
+// vld_buff_info -- (index == 0)
+// Bit11]    halt_decode_start_voff
+// Bit10]    C_pred_error
+// Bit[9]    I4_pred_error
+// Bit[8]    I16_pred_error
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1)
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2)
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3)
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4)
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define   VLD_DBG_DATA                             (0x0c3f)
+#define P_VLD_DBG_DATA                             (volatile unsigned int *)((0x0c3f  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   VLD_MEM_VIFIFO_START_PTR                 (0x0c40)
+#define P_VLD_MEM_VIFIFO_START_PTR                 (volatile unsigned int *)((0x0c40  << 2) + 0xff620000)
+// The current pointer points so some location between the START and END
+// pointers.  The current pointer is a BYTE pointer.  That is, you can
+// point to any BYTE address within the START/END range
+#define   VLD_MEM_VIFIFO_CURR_PTR                  (0x0c41)
+#define P_VLD_MEM_VIFIFO_CURR_PTR                  (volatile unsigned int *)((0x0c41  << 2) + 0xff620000)
+#define   VLD_MEM_VIFIFO_END_PTR                   (0x0c42)
+#define P_VLD_MEM_VIFIFO_END_PTR                   (volatile unsigned int *)((0x0c42  << 2) + 0xff620000)
+#define   VLD_MEM_VIFIFO_BYTES_AVAIL               (0x0c43)
+#define P_VLD_MEM_VIFIFO_BYTES_AVAIL               (volatile unsigned int *)((0x0c43  << 2) + 0xff620000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0]
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0]
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define   VLD_MEM_VIFIFO_CONTROL                   (0x0c44)
+#define P_VLD_MEM_VIFIFO_CONTROL                   (volatile unsigned int *)((0x0c44  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define   VLD_MEM_VIFIFO_WP                        (0x0c45)
+#define P_VLD_MEM_VIFIFO_WP                        (volatile unsigned int *)((0x0c45  << 2) + 0xff620000)
+#define   VLD_MEM_VIFIFO_RP                        (0x0c46)
+#define P_VLD_MEM_VIFIFO_RP                        (volatile unsigned int *)((0x0c46  << 2) + 0xff620000)
+#define   VLD_MEM_VIFIFO_LEVEL                     (0x0c47)
+#define P_VLD_MEM_VIFIFO_LEVEL                     (volatile unsigned int *)((0x0c47  << 2) + 0xff620000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   VLD_MEM_VIFIFO_BUF_CNTL                  (0x0c48)
+#define P_VLD_MEM_VIFIFO_BUF_CNTL                  (volatile unsigned int *)((0x0c48  << 2) + 0xff620000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   VLD_TIME_STAMP_CNTL                      (0x0c49)
+#define P_VLD_TIME_STAMP_CNTL                      (volatile unsigned int *)((0x0c49  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   VLD_TIME_STAMP_SYNC_0                    (0x0c4a)
+#define P_VLD_TIME_STAMP_SYNC_0                    (volatile unsigned int *)((0x0c4a  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   VLD_TIME_STAMP_SYNC_1                    (0x0c4b)
+#define P_VLD_TIME_STAMP_SYNC_1                    (volatile unsigned int *)((0x0c4b  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_0
+#define   VLD_TIME_STAMP_0                         (0x0c4c)
+#define P_VLD_TIME_STAMP_0                         (volatile unsigned int *)((0x0c4c  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_1
+#define   VLD_TIME_STAMP_1                         (0x0c4d)
+#define P_VLD_TIME_STAMP_1                         (volatile unsigned int *)((0x0c4d  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_2
+#define   VLD_TIME_STAMP_2                         (0x0c4e)
+#define P_VLD_TIME_STAMP_2                         (volatile unsigned int *)((0x0c4e  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_3
+#define   VLD_TIME_STAMP_3                         (0x0c4f)
+#define P_VLD_TIME_STAMP_3                         (volatile unsigned int *)((0x0c4f  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   VLD_TIME_STAMP_LENGTH                    (0x0c50)
+#define P_VLD_TIME_STAMP_LENGTH                    (volatile unsigned int *)((0x0c50  << 2) + 0xff620000)
+// bit 15:0 vififo_rd_count
+#define   VLD_MEM_VIFIFO_WRAP_COUNT                (0x0c51)
+#define P_VLD_MEM_VIFIFO_WRAP_COUNT                (volatile unsigned int *)((0x0c51  << 2) + 0xff620000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   VLD_MEM_VIFIFO_MEM_CTL                   (0x0c52)
+#define P_VLD_MEM_VIFIFO_MEM_CTL                   (volatile unsigned int *)((0x0c52  << 2) + 0xff620000)
+#define   VLD_MEM_VBUF_RD_PTR                      (0x0c53)
+#define P_VLD_MEM_VBUF_RD_PTR                      (volatile unsigned int *)((0x0c53  << 2) + 0xff620000)
+#define   VLD_MEM_VBUF2_RD_PTR                     (0x0c54)
+#define P_VLD_MEM_VBUF2_RD_PTR                     (volatile unsigned int *)((0x0c54  << 2) + 0xff620000)
+#define   VLD_MEM_SWAP_ADDR                        (0x0c55)
+#define P_VLD_MEM_SWAP_ADDR                        (volatile unsigned int *)((0x0c55  << 2) + 0xff620000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define   VLD_MEM_SWAP_CTL                         (0x0c56)
+#define P_VLD_MEM_SWAP_CTL                         (volatile unsigned int *)((0x0c56  << 2) + 0xff620000)
+//
+// Closing file:  vld_regs.h
+//
+//------------------------------------------------------------------------------
+// IQ/IDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define   VCOP_CTRL_REG                            (0x0e00)
+#define P_VCOP_CTRL_REG                            (volatile unsigned int *)((0x0e00  << 2) + 0xff620000)
+#define   QP_CTRL_REG                              (0x0e01)
+#define P_QP_CTRL_REG                              (volatile unsigned int *)((0x0e01  << 2) + 0xff620000)
+#define   INTRA_QUANT_MATRIX                       (0x0e02)
+#define P_INTRA_QUANT_MATRIX                       (volatile unsigned int *)((0x0e02  << 2) + 0xff620000)
+#define   NON_I_QUANT_MATRIX                       (0x0e03)
+#define P_NON_I_QUANT_MATRIX                       (volatile unsigned int *)((0x0e03  << 2) + 0xff620000)
+#define   DC_SCALER                                (0x0e04)
+#define P_DC_SCALER                                (volatile unsigned int *)((0x0e04  << 2) + 0xff620000)
+#define   DC_AC_CTRL                               (0x0e05)
+#define P_DC_AC_CTRL                               (volatile unsigned int *)((0x0e05  << 2) + 0xff620000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define   DC_AC_SCALE_MUL                          (0x0e06)
+#define P_DC_AC_SCALE_MUL                          (volatile unsigned int *)((0x0e06  << 2) + 0xff620000)
+#define   DC_AC_SCALE_DIV                          (0x0e07)
+#define P_DC_AC_SCALE_DIV                          (volatile unsigned int *)((0x0e07  << 2) + 0xff620000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define   POWER_CTL_IQIDCT                         (0x0e08)
+#define P_POWER_CTL_IQIDCT                         (volatile unsigned int *)((0x0e08  << 2) + 0xff620000)
+#define   RV_AI_Y_X                                (0x0e09)
+#define P_RV_AI_Y_X                                (volatile unsigned int *)((0x0e09  << 2) + 0xff620000)
+#define   RV_AI_U_X                                (0x0e0a)
+#define P_RV_AI_U_X                                (volatile unsigned int *)((0x0e0a  << 2) + 0xff620000)
+#define   RV_AI_V_X                                (0x0e0b)
+#define P_RV_AI_V_X                                (volatile unsigned int *)((0x0e0b  << 2) + 0xff620000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define   RV_AI_MB_COUNT                           (0x0e0c)
+#define P_RV_AI_MB_COUNT                           (volatile unsigned int *)((0x0e0c  << 2) + 0xff620000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define   NEXT_INTRA_DMA_ADDRESS                   (0x0e0d)
+#define P_NEXT_INTRA_DMA_ADDRESS                   (volatile unsigned int *)((0x0e0d  << 2) + 0xff620000)
+// Bit 16 -- dcac_dma_read_cache_disable
+// Bit 15 -- dcac_dma_urgent
+// Bit 14 -- nv21_swap
+// Bit 13 -- nv21_top_dma
+// Bit 12 -- reset_rv_ai_wait_rd_data
+// Bit 11 -- set_rv_ai_wait_rd_data [12:11] = 3 means only dec 1 (For Skipped MB of MBAFF)
+// Bit 10 -- rv_ai_wait_rd_data (Read Only)
+// Bit 9 -- enable_rv_ai_wait_rd_data
+// Bit 8 -- disable_vc1_mv_update
+// Bit 7 -- pred_dc_signed
+// Bit 6 -- inc_vld_ready_count
+// Bit 5 -- dec_vld_ready_count
+// Bit 4 -- disable_ref_bidir_fix
+// Bit 3 -- disable_MV_UL_l1_bot_fix
+// Bit 2 -- disable_mb_aff_fix
+// Bit 1 -- canvas_addr_7
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define   IQIDCT_CONTROL                           (0x0e0e)
+#define P_IQIDCT_CONTROL                           (volatile unsigned int *)((0x0e0e  << 2) + 0xff620000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define   IQIDCT_DEBUG_INFO_0                      (0x0e0f)
+#define P_IQIDCT_DEBUG_INFO_0                      (volatile unsigned int *)((0x0e0f  << 2) + 0xff620000)
+// For RTL Simulation Only
+#define   DEBLK_CMD                                (0x0e10)
+#define P_DEBLK_CMD                                (volatile unsigned int *)((0x0e10  << 2) + 0xff620000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define   IQIDCT_DEBUG_IDCT                        (0x0e11)
+#define P_IQIDCT_DEBUG_IDCT                        (volatile unsigned int *)((0x0e11  << 2) + 0xff620000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_read_cache_active
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define   DCAC_DMA_CTRL                            (0x0e12)
+#define P_DCAC_DMA_CTRL                            (volatile unsigned int *)((0x0e12  << 2) + 0xff620000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define   DCAC_DMA_ADDRESS                         (0x0e13)
+#define P_DCAC_DMA_ADDRESS                         (volatile unsigned int *)((0x0e13  << 2) + 0xff620000)
+// bit 7:0 -- dcac_cpu_addr
+#define   DCAC_CPU_ADDRESS                         (0x0e14)
+#define P_DCAC_CPU_ADDRESS                         (volatile unsigned int *)((0x0e14  << 2) + 0xff620000)
+// bit 31:0 -- dcac_cpu_data
+#define   DCAC_CPU_DATA                            (0x0e15)
+#define P_DCAC_CPU_DATA                            (volatile unsigned int *)((0x0e15  << 2) + 0xff620000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only
+// bit 15:0 -- dcac_mb_count
+#define   DCAC_MB_COUNT                            (0x0e16)
+#define P_DCAC_MB_COUNT                            (volatile unsigned int *)((0x0e16  << 2) + 0xff620000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant
+//   bit 11:6 -- h264_quant_c
+//   bit  5:0 -- h264_quant_c
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode
+//   bit 11:6  -- AltPQuant
+//   bit  5:0  -- PQuant
+//
+#define   IQ_QUANT                                 (0x0e17)
+#define P_IQ_QUANT                                 (volatile unsigned int *)((0x0e17  << 2) + 0xff620000)
+// bit 31:24  -- bitplane_width
+// bit 23:16  -- bitplane_height
+// bit 15:14  -- bitplane_start_x
+// bit 13:12  -- bitplane_start_y
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define   VC1_BITPLANE_CTL                         (0x0e18)
+#define P_VC1_BITPLANE_CTL                         (volatile unsigned int *)((0x0e18  << 2) + 0xff620000)
+// bit 24:16  -- wq_param1
+// bit  8: 0  -- wq_param0
+#define   AVSP_IQ_WQ_PARAM_01                      (0x0e19)
+#define P_AVSP_IQ_WQ_PARAM_01                      (volatile unsigned int *)((0x0e19  << 2) + 0xff620000)
+// bit 24:16  -- wq_param3
+// bit  8: 0  -- wq_param2
+#define   AVSP_IQ_WQ_PARAM_23                      (0x0e1a)
+#define P_AVSP_IQ_WQ_PARAM_23                      (volatile unsigned int *)((0x0e1a  << 2) + 0xff620000)
+// bit 24:16  -- wq_param5
+// bit  8: 0  -- wq_param4
+#define   AVSP_IQ_WQ_PARAM_45                      (0x0e1b)
+#define P_AVSP_IQ_WQ_PARAM_45                      (volatile unsigned int *)((0x0e1b  << 2) + 0xff620000)
+// bit    31  -- weight_quant_en
+// bit 17:16  -- current_scene_model
+// bit 12: 8  -- chroma_qp_delta_cr
+// bit  4: 0  -- chroma_qp_delta_cb
+#define   AVSP_IQ_CTL                              (0x0e1c)
+#define P_AVSP_IQ_CTL                              (volatile unsigned int *)((0x0e1c  << 2) + 0xff620000)
+    #define RAM_TEST_CMD        0x002
+    #define RAM_TEST_ADDR       0x003
+    #define RAM_TEST_DATAH      0x004
+    #define RAM_TEST_DATAL      0x005
+
+    #define RAM_TEST_RD_CMD	    0x0000
+    #define RAM_TEST_WR_CMD	    0x8000
+    #define IDCT_TM2_PT0	    0x0001
+    #define IDCT_TM2_PT1	    0x0002
+    #define IDCT_TM1_PT0	    0x0004
+    #define IDCT_TM1_PT1	    0x0008
+    #define IQ_OMEM_PT0	        0x0010
+    #define IQ_OMEM_PT1	        0x0020
+    #define MC_IMEM_PT0	        0x0040
+    #define ALL_RAM_PTS	        0x007f
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+    #define QM_WEN		    0x0002	    // Bit 1
+    #define IQIDCT_ENABLE	    0x0004	    // Bit 2
+    #define INTRA_QM	    0x0008	    // Bit 3	0 = Use default; 1 = use loaded
+    #define NINTRA_QM	    0x0010	    // Bit 4	0 = Use default; 1 = use loaded
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+    #define INTRA_MODE	    0x0080	    // Bit 7
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//------------------------------------------------------------------------------
+// VCPU module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define   MSP                                      (0x0300)
+#define P_MSP                                      (volatile unsigned int *)((0x0300  << 2) + 0xff620000)
+#define   MPSR                                     (0x0301)
+#define P_MPSR                                     (volatile unsigned int *)((0x0301  << 2) + 0xff620000)
+#define   MINT_VEC_BASE                            (0x0302)
+#define P_MINT_VEC_BASE                            (volatile unsigned int *)((0x0302  << 2) + 0xff620000)
+#define   MCPU_INTR_GRP                            (0x0303)
+#define P_MCPU_INTR_GRP                            (volatile unsigned int *)((0x0303  << 2) + 0xff620000)
+#define   MCPU_INTR_MSK                            (0x0304)
+#define P_MCPU_INTR_MSK                            (volatile unsigned int *)((0x0304  << 2) + 0xff620000)
+#define   MCPU_INTR_REQ                            (0x0305)
+#define P_MCPU_INTR_REQ                            (volatile unsigned int *)((0x0305  << 2) + 0xff620000)
+#define   MPC_P                                    (0x0306)
+#define P_MPC_P                                    (volatile unsigned int *)((0x0306  << 2) + 0xff620000)
+#define   MPC_D                                    (0x0307)
+#define P_MPC_D                                    (volatile unsigned int *)((0x0307  << 2) + 0xff620000)
+#define   MPC_E                                    (0x0308)
+#define P_MPC_E                                    (volatile unsigned int *)((0x0308  << 2) + 0xff620000)
+#define   MPC_W                                    (0x0309)
+#define P_MPC_W                                    (volatile unsigned int *)((0x0309  << 2) + 0xff620000)
+#define   MINDEX0_REG                              (0x030a)
+#define P_MINDEX0_REG                              (volatile unsigned int *)((0x030a  << 2) + 0xff620000)
+#define   MINDEX1_REG                              (0x030b)
+#define P_MINDEX1_REG                              (volatile unsigned int *)((0x030b  << 2) + 0xff620000)
+#define   MINDEX2_REG                              (0x030c)
+#define P_MINDEX2_REG                              (volatile unsigned int *)((0x030c  << 2) + 0xff620000)
+#define   MINDEX3_REG                              (0x030d)
+#define P_MINDEX3_REG                              (volatile unsigned int *)((0x030d  << 2) + 0xff620000)
+#define   MINDEX4_REG                              (0x030e)
+#define P_MINDEX4_REG                              (volatile unsigned int *)((0x030e  << 2) + 0xff620000)
+#define   MINDEX5_REG                              (0x030f)
+#define P_MINDEX5_REG                              (volatile unsigned int *)((0x030f  << 2) + 0xff620000)
+#define   MINDEX6_REG                              (0x0310)
+#define P_MINDEX6_REG                              (volatile unsigned int *)((0x0310  << 2) + 0xff620000)
+#define   MINDEX7_REG                              (0x0311)
+#define P_MINDEX7_REG                              (volatile unsigned int *)((0x0311  << 2) + 0xff620000)
+#define   MMIN_REG                                 (0x0312)
+#define P_MMIN_REG                                 (volatile unsigned int *)((0x0312  << 2) + 0xff620000)
+#define   MMAX_REG                                 (0x0313)
+#define P_MMAX_REG                                 (volatile unsigned int *)((0x0313  << 2) + 0xff620000)
+#define   MBREAK0_REG                              (0x0314)
+#define P_MBREAK0_REG                              (volatile unsigned int *)((0x0314  << 2) + 0xff620000)
+#define   MBREAK1_REG                              (0x0315)
+#define P_MBREAK1_REG                              (volatile unsigned int *)((0x0315  << 2) + 0xff620000)
+#define   MBREAK2_REG                              (0x0316)
+#define P_MBREAK2_REG                              (volatile unsigned int *)((0x0316  << 2) + 0xff620000)
+#define   MBREAK3_REG                              (0x0317)
+#define P_MBREAK3_REG                              (volatile unsigned int *)((0x0317  << 2) + 0xff620000)
+#define   MBREAK_TYPE                              (0x0318)
+#define P_MBREAK_TYPE                              (volatile unsigned int *)((0x0318  << 2) + 0xff620000)
+#define   MBREAK_CTRL                              (0x0319)
+#define P_MBREAK_CTRL                              (volatile unsigned int *)((0x0319  << 2) + 0xff620000)
+#define   MBREAK_STAUTS                            (0x031a)
+#define P_MBREAK_STAUTS                            (volatile unsigned int *)((0x031a  << 2) + 0xff620000)
+#define   MDB_ADDR_REG                             (0x031b)
+#define P_MDB_ADDR_REG                             (volatile unsigned int *)((0x031b  << 2) + 0xff620000)
+#define   MDB_DATA_REG                             (0x031c)
+#define P_MDB_DATA_REG                             (volatile unsigned int *)((0x031c  << 2) + 0xff620000)
+#define   MDB_CTRL                                 (0x031d)
+#define P_MDB_CTRL                                 (volatile unsigned int *)((0x031d  << 2) + 0xff620000)
+#define   MSFTINT0                                 (0x031e)
+#define P_MSFTINT0                                 (volatile unsigned int *)((0x031e  << 2) + 0xff620000)
+#define   MSFTINT1                                 (0x031f)
+#define P_MSFTINT1                                 (volatile unsigned int *)((0x031f  << 2) + 0xff620000)
+#define   CSP                                      (0x0320)
+#define P_CSP                                      (volatile unsigned int *)((0x0320  << 2) + 0xff620000)
+#define   CPSR                                     (0x0321)
+#define P_CPSR                                     (volatile unsigned int *)((0x0321  << 2) + 0xff620000)
+#define   CINT_VEC_BASE                            (0x0322)
+#define P_CINT_VEC_BASE                            (volatile unsigned int *)((0x0322  << 2) + 0xff620000)
+#define   CCPU_INTR_GRP                            (0x0323)
+#define P_CCPU_INTR_GRP                            (volatile unsigned int *)((0x0323  << 2) + 0xff620000)
+#define   CCPU_INTR_MSK                            (0x0324)
+#define P_CCPU_INTR_MSK                            (volatile unsigned int *)((0x0324  << 2) + 0xff620000)
+#define   CCPU_INTR_REQ                            (0x0325)
+#define P_CCPU_INTR_REQ                            (volatile unsigned int *)((0x0325  << 2) + 0xff620000)
+#define   CPC_P                                    (0x0326)
+#define P_CPC_P                                    (volatile unsigned int *)((0x0326  << 2) + 0xff620000)
+#define   CPC_D                                    (0x0327)
+#define P_CPC_D                                    (volatile unsigned int *)((0x0327  << 2) + 0xff620000)
+#define   CPC_E                                    (0x0328)
+#define P_CPC_E                                    (volatile unsigned int *)((0x0328  << 2) + 0xff620000)
+#define   CPC_W                                    (0x0329)
+#define P_CPC_W                                    (volatile unsigned int *)((0x0329  << 2) + 0xff620000)
+#define   CINDEX0_REG                              (0x032a)
+#define P_CINDEX0_REG                              (volatile unsigned int *)((0x032a  << 2) + 0xff620000)
+#define   CINDEX1_REG                              (0x032b)
+#define P_CINDEX1_REG                              (volatile unsigned int *)((0x032b  << 2) + 0xff620000)
+#define   CINDEX2_REG                              (0x032c)
+#define P_CINDEX2_REG                              (volatile unsigned int *)((0x032c  << 2) + 0xff620000)
+#define   CINDEX3_REG                              (0x032d)
+#define P_CINDEX3_REG                              (volatile unsigned int *)((0x032d  << 2) + 0xff620000)
+#define   CINDEX4_REG                              (0x032e)
+#define P_CINDEX4_REG                              (volatile unsigned int *)((0x032e  << 2) + 0xff620000)
+#define   CINDEX5_REG                              (0x032f)
+#define P_CINDEX5_REG                              (volatile unsigned int *)((0x032f  << 2) + 0xff620000)
+#define   CINDEX6_REG                              (0x0330)
+#define P_CINDEX6_REG                              (volatile unsigned int *)((0x0330  << 2) + 0xff620000)
+#define   CINDEX7_REG                              (0x0331)
+#define P_CINDEX7_REG                              (volatile unsigned int *)((0x0331  << 2) + 0xff620000)
+#define   CMIN_REG                                 (0x0332)
+#define P_CMIN_REG                                 (volatile unsigned int *)((0x0332  << 2) + 0xff620000)
+#define   CMAX_REG                                 (0x0333)
+#define P_CMAX_REG                                 (volatile unsigned int *)((0x0333  << 2) + 0xff620000)
+#define   CBREAK0_REG                              (0x0334)
+#define P_CBREAK0_REG                              (volatile unsigned int *)((0x0334  << 2) + 0xff620000)
+#define   CBREAK1_REG                              (0x0335)
+#define P_CBREAK1_REG                              (volatile unsigned int *)((0x0335  << 2) + 0xff620000)
+#define   CBREAK2_REG                              (0x0336)
+#define P_CBREAK2_REG                              (volatile unsigned int *)((0x0336  << 2) + 0xff620000)
+#define   CBREAK3_REG                              (0x0337)
+#define P_CBREAK3_REG                              (volatile unsigned int *)((0x0337  << 2) + 0xff620000)
+#define   CBREAK_TYPE                              (0x0338)
+#define P_CBREAK_TYPE                              (volatile unsigned int *)((0x0338  << 2) + 0xff620000)
+#define   CBREAK_CTRL                              (0x0339)
+#define P_CBREAK_CTRL                              (volatile unsigned int *)((0x0339  << 2) + 0xff620000)
+#define   CBREAK_STAUTS                            (0x033a)
+#define P_CBREAK_STAUTS                            (volatile unsigned int *)((0x033a  << 2) + 0xff620000)
+#define   CDB_ADDR_REG                             (0x033b)
+#define P_CDB_ADDR_REG                             (volatile unsigned int *)((0x033b  << 2) + 0xff620000)
+#define   CDB_DATA_REG                             (0x033c)
+#define P_CDB_DATA_REG                             (volatile unsigned int *)((0x033c  << 2) + 0xff620000)
+#define   CDB_CTRL                                 (0x033d)
+#define P_CDB_CTRL                                 (volatile unsigned int *)((0x033d  << 2) + 0xff620000)
+#define   CSFTINT0                                 (0x033e)
+#define P_CSFTINT0                                 (volatile unsigned int *)((0x033e  << 2) + 0xff620000)
+#define   CSFTINT1                                 (0x033f)
+#define P_CSFTINT1                                 (volatile unsigned int *)((0x033f  << 2) + 0xff620000)
+#define   IMEM_DMA_CTRL                            (0x0340)
+#define P_IMEM_DMA_CTRL                            (volatile unsigned int *)((0x0340  << 2) + 0xff620000)
+#define   IMEM_DMA_ADR                             (0x0341)
+#define P_IMEM_DMA_ADR                             (volatile unsigned int *)((0x0341  << 2) + 0xff620000)
+#define   IMEM_DMA_COUNT                           (0x0342)
+#define P_IMEM_DMA_COUNT                           (volatile unsigned int *)((0x0342  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define   WRRSP_IMEM                               (0x0343)
+#define P_WRRSP_IMEM                               (volatile unsigned int *)((0x0343  << 2) + 0xff620000)
+#define   LMEM_DMA_CTRL                            (0x0350)
+#define P_LMEM_DMA_CTRL                            (volatile unsigned int *)((0x0350  << 2) + 0xff620000)
+#define   LMEM_DMA_ADR                             (0x0351)
+#define P_LMEM_DMA_ADR                             (volatile unsigned int *)((0x0351  << 2) + 0xff620000)
+#define   LMEM_DMA_COUNT                           (0x0352)
+#define P_LMEM_DMA_COUNT                           (volatile unsigned int *)((0x0352  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem
+#define   WRRSP_LMEM                               (0x0353)
+#define P_WRRSP_LMEM                               (volatile unsigned int *)((0x0353  << 2) + 0xff620000)
+#define   MAC_CTRL1                                (0x0360)
+#define P_MAC_CTRL1                                (volatile unsigned int *)((0x0360  << 2) + 0xff620000)
+#define   ACC0REG1                                 (0x0361)
+#define P_ACC0REG1                                 (volatile unsigned int *)((0x0361  << 2) + 0xff620000)
+#define   ACC1REG1                                 (0x0362)
+#define P_ACC1REG1                                 (volatile unsigned int *)((0x0362  << 2) + 0xff620000)
+#define   MAC_CTRL2                                (0x0370)
+#define P_MAC_CTRL2                                (volatile unsigned int *)((0x0370  << 2) + 0xff620000)
+#define   ACC0REG2                                 (0x0371)
+#define P_ACC0REG2                                 (volatile unsigned int *)((0x0371  << 2) + 0xff620000)
+#define   ACC1REG2                                 (0x0372)
+#define P_ACC1REG2                                 (volatile unsigned int *)((0x0372  << 2) + 0xff620000)
+#define   CPU_TRACE                                (0x0380)
+#define P_CPU_TRACE                                (volatile unsigned int *)((0x0380  << 2) + 0xff620000)
+//
+// Closing file:  vcpu_regs.h
+//
+//------------------------------------------------------------------------------
+// HENC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  henc_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_HENC_CBUS_BASE = 0x0a
+// -----------------------------------------------
+#define   HENC_SCRATCH_0                           (0x1ac0)
+#define P_HENC_SCRATCH_0                           (volatile unsigned int *)((0x1ac0  << 2) + 0xff620000)
+#define   HENC_SCRATCH_1                           (0x1ac1)
+#define P_HENC_SCRATCH_1                           (volatile unsigned int *)((0x1ac1  << 2) + 0xff620000)
+#define   HENC_SCRATCH_2                           (0x1ac2)
+#define P_HENC_SCRATCH_2                           (volatile unsigned int *)((0x1ac2  << 2) + 0xff620000)
+#define   HENC_SCRATCH_3                           (0x1ac3)
+#define P_HENC_SCRATCH_3                           (volatile unsigned int *)((0x1ac3  << 2) + 0xff620000)
+#define   HENC_SCRATCH_4                           (0x1ac4)
+#define P_HENC_SCRATCH_4                           (volatile unsigned int *)((0x1ac4  << 2) + 0xff620000)
+#define   HENC_SCRATCH_5                           (0x1ac5)
+#define P_HENC_SCRATCH_5                           (volatile unsigned int *)((0x1ac5  << 2) + 0xff620000)
+#define   HENC_SCRATCH_6                           (0x1ac6)
+#define P_HENC_SCRATCH_6                           (volatile unsigned int *)((0x1ac6  << 2) + 0xff620000)
+#define   HENC_SCRATCH_7                           (0x1ac7)
+#define P_HENC_SCRATCH_7                           (volatile unsigned int *)((0x1ac7  << 2) + 0xff620000)
+#define   HENC_SCRATCH_8                           (0x1ac8)
+#define P_HENC_SCRATCH_8                           (volatile unsigned int *)((0x1ac8  << 2) + 0xff620000)
+#define   HENC_SCRATCH_9                           (0x1ac9)
+#define P_HENC_SCRATCH_9                           (volatile unsigned int *)((0x1ac9  << 2) + 0xff620000)
+#define   HENC_SCRATCH_A                           (0x1aca)
+#define P_HENC_SCRATCH_A                           (volatile unsigned int *)((0x1aca  << 2) + 0xff620000)
+#define   HENC_SCRATCH_B                           (0x1acb)
+#define P_HENC_SCRATCH_B                           (volatile unsigned int *)((0x1acb  << 2) + 0xff620000)
+#define   HENC_SCRATCH_C                           (0x1acc)
+#define P_HENC_SCRATCH_C                           (volatile unsigned int *)((0x1acc  << 2) + 0xff620000)
+#define   HENC_SCRATCH_D                           (0x1acd)
+#define P_HENC_SCRATCH_D                           (volatile unsigned int *)((0x1acd  << 2) + 0xff620000)
+#define   HENC_SCRATCH_E                           (0x1ace)
+#define P_HENC_SCRATCH_E                           (volatile unsigned int *)((0x1ace  << 2) + 0xff620000)
+#define   HENC_SCRATCH_F                           (0x1acf)
+#define P_HENC_SCRATCH_F                           (volatile unsigned int *)((0x1acf  << 2) + 0xff620000)
+#define   HENC_SCRATCH_G                           (0x1ad0)
+#define P_HENC_SCRATCH_G                           (volatile unsigned int *)((0x1ad0  << 2) + 0xff620000)
+#define   HENC_SCRATCH_H                           (0x1ad1)
+#define P_HENC_SCRATCH_H                           (volatile unsigned int *)((0x1ad1  << 2) + 0xff620000)
+#define   HENC_SCRATCH_I                           (0x1ad2)
+#define P_HENC_SCRATCH_I                           (volatile unsigned int *)((0x1ad2  << 2) + 0xff620000)
+#define   HENC_SCRATCH_J                           (0x1ad3)
+#define P_HENC_SCRATCH_J                           (volatile unsigned int *)((0x1ad3  << 2) + 0xff620000)
+#define   HENC_SCRATCH_K                           (0x1ad4)
+#define P_HENC_SCRATCH_K                           (volatile unsigned int *)((0x1ad4  << 2) + 0xff620000)
+#define   HENC_SCRATCH_L                           (0x1ad5)
+#define P_HENC_SCRATCH_L                           (volatile unsigned int *)((0x1ad5  << 2) + 0xff620000)
+#define   HENC_SCRATCH_M                           (0x1ad6)
+#define P_HENC_SCRATCH_M                           (volatile unsigned int *)((0x1ad6  << 2) + 0xff620000)
+#define   HENC_SCRATCH_N                           (0x1ad7)
+#define P_HENC_SCRATCH_N                           (volatile unsigned int *)((0x1ad7  << 2) + 0xff620000)
+// bit [7:0] data_feed_buff_id
+#define   IE_DATA_FEED_BUFF_INFO                   (0x1ad8)
+#define P_IE_DATA_FEED_BUFF_INFO                   (volatile unsigned int *)((0x1ad8  << 2) + 0xff620000)
+//
+// Closing file:  henc_regs.h
+//
+//------------------------------------------------------------------------------
+// VLC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  vlc_regs.h
+//
+//========================================================================
+//  VLC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VLC_CBUS_BASE = 0x0d
+// -----------------------------------------------
+// Bit[31:28] - henc_status
+// Bit[27:8] - reserved
+// Bit[7]    mc_hcmd_buff_enable
+// Bit[6]    mc_hcmd_use_mc_hcmd_buff
+// Bit[5]    mc_hcmd_use_mc_hcmd_hw_start
+// Bit[4]    no_mc_out_null_non_skipped_mb
+// Bit[3]    mc_out_even_skipped_mb
+// Bit[2] - hcmd_enable
+// Bit[1] - vlc_control_enable (0 will treat as soft_reset)
+// Bit[0] - vlc_input_enable (enable input interface)
+#define   VLC_STATUS_CTRL                          (0x1d00)
+#define P_VLC_STATUS_CTRL                          (volatile unsigned int *)((0x1d00  << 2) + 0xff620000)
+// Bit [31]  - small_luma_ignore_chroma
+// Bit[30:16] - Reserved
+// Bit [15]  - enable_free_clk_mc_hcmd_buff
+// Bit [14]  - enable_free_clk_reg
+// Bit [13]  - enable_free_clk_stream
+// Bit [12]  - enable_free_clk_pre_buff
+// Bit [11]  - enable_free_clk_vb_buff
+// Bit [10]  - enable_free_clk_dc_input
+// Bit [9]   - enable_free_clk_input
+// Bit [8]   - enable_free_clk_mv_cal
+// Bit [7]   - enable_free_clk_status
+// Bit [6]   - enable_free_clk_mc_dblk_cmd_if
+// Bit [5]   - disable_mvd_enc_finished
+// Bit [4]   - I16MB_share_ipred_mode_with_I4MB
+// Bit [3]   - fixed_picture_qp
+// Bit [2]   - use_set_b8_mode ( not used now)
+// Bit [1]   - use_set_mb_skip_run
+// Bit [0]   - pop_coeff_even_all_zero
+#define   VLC_CONFIG                               (0x1d01)
+#define P_VLC_CONFIG                               (volatile unsigned int *)((0x1d01  << 2) + 0xff620000)
+// --------------------------------------------
+// Bitstream DDR Interface
+// --------------------------------------------
+#define   VLC_VB_START_PTR                         (0x1d10)
+#define P_VLC_VB_START_PTR                         (volatile unsigned int *)((0x1d10  << 2) + 0xff620000)
+#define   VLC_VB_END_PTR                           (0x1d11)
+#define P_VLC_VB_END_PTR                           (volatile unsigned int *)((0x1d11  << 2) + 0xff620000)
+#define   VLC_VB_WR_PTR                            (0x1d12)
+#define P_VLC_VB_WR_PTR                            (volatile unsigned int *)((0x1d12  << 2) + 0xff620000)
+// Read Only, VLC_VB_SW_RD_PTR or VLC_VB_HW_RD_PTR
+#define   VLC_VB_RD_PTR                            (0x1d13)
+#define P_VLC_VB_RD_PTR                            (volatile unsigned int *)((0x1d13  << 2) + 0xff620000)
+#define   VLC_VB_SW_RD_PTR                         (0x1d14)
+#define P_VLC_VB_SW_RD_PTR                         (volatile unsigned int *)((0x1d14  << 2) + 0xff620000)
+// Read Only
+#define   VLC_VB_LEFT                              (0x1d15)
+#define P_VLC_VB_LEFT                              (volatile unsigned int *)((0x1d15  << 2) + 0xff620000)
+// VB FIFO Control
+// bit  [31:24] vb_full_int_enable_cpu[7:0]
+// bit  [23:16] vb_full_int_enable_amrisc[7:0]
+//   -bit 23 Video BUFFER LEFT < 0x400 Bytes
+//   -bit 22 Video BUFFER LEFT < 0x200 Bytes
+//   -bit 21 Video BUFFER LEFT < 0x100 Bytes
+//   -bit 20 Video BUFFER LEFT < 0x80 Bytes
+//   -bit 19 Video BUFFER LEFT < 0x40 Bytes
+//   -bit 18 Video BUFFER LEFT < 0x20 Bytes
+//   -bit 17 vbfifo left  < 16 double words (8x64bits)
+//   -bit 16 vbfifo left  < 8 double words (4x64bits)
+// bit  [15]    wr_ptr_int_enable_cpu
+// bit  [14]    wr_ptr_int_enable_amrisc
+// bit  [13]    wr_ptr_int (Read Only, write 1 will clear)
+// bit  [12]    vb_full_int_enable_cpu(Read Only)
+// bit  [11]    vb_full_int_enable_amrisc(Read Only)
+// bit  [10]    reserved
+// bit  [9]     use_vb_hw_rd_ptr
+// bit  [8]     vb_always_ready Set to 1 to ignore vb_level blocking DDR write
+// bit  [7]     vb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   vb_endian       Set VB Endian inside DDR memory
+// bit  [2]     vb_write_busy   Read Only - indicate DDR write busy
+// bit  [1]     vb_write_en     Set to 1 to enable writing data to DDR memory
+// bit  [0]     vb_soft_reset   Soft reset
+#define   VLC_VB_CONTROL                           (0x1d16)
+#define P_VLC_VB_CONTROL                           (volatile unsigned int *)((0x1d16  << 2) + 0xff620000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23:22 reserved
+// bit 21:16 A_id  // default : 0x20
+// bit 15:0  vb_left_hold // default : 0
+#define   VLC_VB_MEM_CTL                           (0x1d17)
+#define P_VLC_VB_MEM_CTL                           (volatile unsigned int *)((0x1d17  << 2) + 0xff620000)
+// vb_wr_ptr address to generate interrupt
+#define   VLC_VB_INT_PTR                           (0x1d18)
+#define P_VLC_VB_INT_PTR                           (volatile unsigned int *)((0x1d18  << 2) + 0xff620000)
+// bit[31:12] reserved
+// bit[11:0] vlc_wrrsp_count
+#define   VLC_WRRSP                                (0x1d19)
+#define P_VLC_WRRSP                                (volatile unsigned int *)((0x1d19  << 2) + 0xff620000)
+#define   VLC_TOTAL_BYTES                          (0x1d1a)
+#define P_VLC_TOTAL_BYTES                          (volatile unsigned int *)((0x1d1a  << 2) + 0xff620000)
+// bit  [31:26] reserved
+// bit  [25]    vb_flush
+// bit  [24]    vb_reg_ready
+// bit  [23:16] vb_buff_left     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define   VLC_VB_BUFF                              (0x1d1b)
+#define P_VLC_VB_BUFF                              (volatile unsigned int *)((0x1d1b  << 2) + 0xff620000)
+// bit[31]    flush_vlc_pre_buff
+// bit[30:27] reserved
+// bit[26:24] vb_pre_buff_level
+// bit[23:0]  vb_pre_buff_data[55:32]
+#define   VLC_VB_PRE_BUFF_HI                       (0x1d1c)
+#define P_VLC_VB_PRE_BUFF_HI                       (volatile unsigned int *)((0x1d1c  << 2) + 0xff620000)
+// bit[31:0] vb_pre_buff_data[31:0]
+#define   VLC_VB_PRE_BUFF_LOW                      (0x1d1d)
+#define P_VLC_VB_PRE_BUFF_LOW                      (volatile unsigned int *)((0x1d1d  << 2) + 0xff620000)
+// bit[31]    stream_encap_enable  // 0x0000(00-03) will be changed to 0x000003(00-03) if enabled
+// bit[30:29] stream_encap_delay   // delay bytes for encap used
+// bit[28:24] stream_buff_point
+// bit[23:0]  stream_buff_data
+#define   VLC_STREAM_BUFF                          (0x1d1e)
+#define P_VLC_STREAM_BUFF                          (volatile unsigned int *)((0x1d1e  << 2) + 0xff620000)
+// bit[31]    push_stream_block - Read Only (Will set if vb_buff full)
+// bit[30]    push_stream_busy  - Read Only (busy when output one byte from stream_buf (max 2 clocks for 8 bits push)
+// bit[29:28] stream_encap_status - Read Only
+// bit[27:21] reserved
+// Long Mode : (Amrisc need movilo and mvihi high to set stream_info)
+//   bit[20:16] push_stream_long_length (0 or 31 : Mid or Short mode)
+//   bit[15:0]  push_stream_data
+// Mid Mode : (Amrisc need movi to set stream_info)
+//   bit[15:12]] push_stream_mid_length (1-12 : mid mode active, 0-short mode, 15 - byte align)
+//   bit[11:0]  push_stream_data
+// Short Mode : (Amrisc can use mtspi to push stream directely)
+//   bit[7:5] push_stream_short_length (0-5 : short length, else - invalid)
+//   bit[4:0]  push_stream_data
+#define   VLC_PUSH_STREAM                          (0x1d1f)
+#define P_VLC_PUSH_STREAM                          (volatile unsigned int *)((0x1d1f  << 2) + 0xff620000)
+// bit[15:8] ELEMENT_LENGTH
+// bit[7:1]  reserved
+// bit[0]  Write - push start, Read - Push Busy
+#define   VLC_PUSH_ELEMENT                         (0x1d20)
+#define P_VLC_PUSH_ELEMENT                         (volatile unsigned int *)((0x1d20  << 2) + 0xff620000)
+#define   VLC_ELEMENT_DATA                         (0x1d21)
+#define P_VLC_ELEMENT_DATA                         (volatile unsigned int *)((0x1d21  << 2) + 0xff620000)
+// bit[7] hcmd_intra_use_sw_info
+// bit[6] hcmd_use_sw_info
+// bit[5] always_use_info_0_cbp_blk
+// bit[4] always_update_info_0_cbp_blk
+// bit[3] reset_left_mb_wr
+// bit[2] reset_top_mb_wr
+// bit[1] set_left_mb_wr
+// bit[0] set_top_mb_wr
+#define   VLC_SPECIAL_CTL                          (0x1d22)
+#define P_VLC_SPECIAL_CTL                          (volatile unsigned int *)((0x1d22  << 2) + 0xff620000)
+// bit[28]    left_intra
+// bit[27:22] left_quant
+// bit[21:16] left_quant_c
+// bit[12]    top_intra
+// bit[11:6]  top_quant
+// bit[5:0]   top_quant_c
+#define   VLC_HCMD_T_L_INFO                        (0x1d23)
+#define P_VLC_HCMD_T_L_INFO                        (volatile unsigned int *)((0x1d23  << 2) + 0xff620000)
+// bit[12]    cur_intra
+// bit[11:6]  cur_quant
+// bit[5:0]   cur_quant_c
+#define   VLC_HCMD_CUR_INFO                        (0x1d24)
+#define P_VLC_HCMD_CUR_INFO                        (volatile unsigned int *)((0x1d24  << 2) + 0xff620000)
+// bit[13]    top_left_info_in_data_mv_cal
+// bit[12]    only_use_info_0_top_left_in_I
+// bit[11]    top_left_info_in_data
+// bit[10]    early_mix_mc_hcmd
+// bit[9]     update_top_left_mix
+// bit[8]     p_top_left_mix
+// bit[7]     mv_cal_mixed_type
+// bit[6]     mc_hcmd_mixed_type
+// bit[5]     use_seperate_int_control
+// bit[4]     hcmd_intra_use_q_info
+// bit[3]     hcmd_left_use_prev_info
+// bit[2]     hcmd_use_q_info
+// bit[1]     use_q_delta_quant
+// bit[0]     detect_I16_from_I4
+#define   VLC_ADV_CONFIG                           (0x1d25)
+#define P_VLC_ADV_CONFIG                           (volatile unsigned int *)((0x1d25  << 2) + 0xff620000)
+//   31 - use_hcmd_mb_xy_auto
+//23:16 - hcmd_max_mb_x
+//15:8  - hcmd_mb_y_auto
+// 7:0  - hcmd_mb_x_auto
+#define   VLC_HCMD_MBXY_AUTO                       (0x1d26)
+#define P_VLC_HCMD_MBXY_AUTO                       (volatile unsigned int *)((0x1d26  << 2) + 0xff620000)
+// bit[31:0] vlc_int_control_inter -- will be used when use_seperate_int_control is set
+#define   VLC_INT_CONTROL_INTER                    (0x1d2f)
+#define P_VLC_INT_CONTROL_INTER                    (volatile unsigned int *)((0x1d2f  << 2) + 0xff620000)
+// --------------------------------------------
+// Picture VLC
+// --------------------------------------------
+// (&(int|(~AND_enable))|(|(int&OR_enable)))
+// bit[31]    OR interrupt Enable Reserved
+// bit[30]    OR interrupt Enable for mv_busy
+// bit[29]    OR interrupt Enable for b8_mode_busy
+// bit[28]    OR interrupt Enable for mb_skip_run_busy
+// bit[27]    OR interrupt Enable for cbp_busy
+// bit[26]    OR interrupt Enable for Reserved
+// bit[25]    OR interrupt Enable for Reserved
+// bit[24]    OR interrupt Enable for mb_info_busy
+// bit[23]    AND interrupt Enable Reserved
+// bit[22]    AND interrupt Enable for mv_busy
+// bit[21]    AND interrupt Enable for b8_mode_busy
+// bit[20]    AND interrupt Enable for mb_skip_run_busy
+// bit[19]    AND interrupt Enable for cbp_busy
+// bit[18]    AND interrupt Enable for Reserved
+// bit[17]    AND interrupt Enable for Reserved
+// bit[16]    AND interrupt Enable for mb_info_busy
+// bit[15]    OR interrupt Enable Reserved
+// bit[14]    OR interrupt Enable for mvd
+// bit[13]    OR interrupt Enable for b8_mode
+// bit[12]    OR interrupt Enable for mb_skip_run
+// bit[11]    OR interrupt Enable for cbp_ready
+// bit[10]    OR interrupt Enable for c_ipred_mode_ready
+// bit[9]     OR interrupt Enable for ipred_mode_ready
+// bit[8]     OR interrupt Enable for mb_info_ready
+// bit[7]     AND interrupt Enable Reserved
+// bit[6]     AND interrupt Enable for mvd
+// bit[5]     AND interrupt Enable for b8_mode
+// bit[4]     AND interrupt Enable for mb_skip_run
+// bit[3]     AND interrupt Enable for cbp_ready
+// bit[2]     AND interrupt Enable for c_ipred_mode_ready
+// bit[1]     AND interrupt Enable for ipred_mode_ready
+// bit[0]     AND interrupt Enable for mb_info_ready
+#define   VLC_INT_CONTROL                          (0x1d30)
+#define P_VLC_INT_CONTROL                          (volatile unsigned int *)((0x1d30  << 2) + 0xff620000)
+// Bit[31:16] picture_height
+// Bit[15:0]  picture_width
+#define   VLC_PIC_SIZE                             (0x1d31)
+#define P_VLC_PIC_SIZE                             (volatile unsigned int *)((0x1d31  << 2) + 0xff620000)
+// [31:16] Reserved
+// [15:3] pic_width_in_mbs_minus1
+// [2:0]  picture_type
+#define   VLC_PIC_INFO                             (0x1d32)
+#define P_VLC_PIC_INFO                             (volatile unsigned int *)((0x1d32  << 2) + 0xff620000)
+// Bit[31:16] MB_NR
+// Bit[15:8] MBY
+// Bit[7:0] MBX
+#define   VLC_PIC_POSITION                         (0x1d33)
+#define P_VLC_PIC_POSITION                         (volatile unsigned int *)((0x1d33  << 2) + 0xff620000)
+// Bit[31] MV_busy
+// Bit[30:6] Reserved
+// Bit[15] Reserved
+// Bit[14] vlc_input_MV_busy
+// Bit[13] vlc_input_b8_mode_busy
+// Bit[12] vlc_input_mb_skip_run_busy
+// Bit[11] vlc_input_cbp_busy
+// Bit[10] Reserved
+// Bit[9]  Reserved
+// Bit[8] vlc_input_mb_info_busy
+// Bit[7] Reserved
+// Bit[6] mvd
+// Bit[5] b8_mode
+// Bit[4] mb_skip_run
+// Bit[3] cbp
+// Bit[2] c_ipred_mode
+// Bit[1] ipred_mode
+// Bit[0] mb_info ( mb_type, mb_x, mb_y)
+#define   VLC_INPUT_STATUS                         (0x1d34)
+#define P_VLC_INPUT_STATUS                         (volatile unsigned int *)((0x1d34  << 2) + 0xff620000)
+// Bit[31:28] detected_mb_type
+// Bit[27:16] mb_y
+// Bit[15:4]  mb_x
+// Bit[3:0]   mb_type
+#define   VLC_MB_INFO                              (0x1d35)
+#define P_VLC_MB_INFO                              (volatile unsigned int *)((0x1d35  << 2) + 0xff620000)
+// commnad 0 -- no pending
+// normal command + 1 is pending command
+//
+// bit 31:28 -- pending command 7
+// bit 27:24 -- pending command 6
+// bit 23:20 -- pending command 5
+// bit 19:16 -- pending command 4
+// bit 15:12 -- pending command 3
+// bit 11:8  -- pending command 2
+// bit  7:4  -- pending command 1
+// bit  3:0  -- pending command 0
+#define   VLC_ENC_PEND_CMD                         (0x1d36)
+#define P_VLC_ENC_PEND_CMD                         (volatile unsigned int *)((0x1d36  << 2) + 0xff620000)
+// For I Slice
+// Bit[31:16] Reserved
+// Bit[15:0] IntraType
+#define   HENC_TOP_INFO_0                          (0x1d37)
+#define P_HENC_TOP_INFO_0                          (volatile unsigned int *)((0x1d37  << 2) + 0xff620000)
+#define   HENC_LEFT_INFO_0                         (0x1d38)
+#define P_HENC_LEFT_INFO_0                         (volatile unsigned int *)((0x1d38  << 2) + 0xff620000)
+// For I Slice
+// Bit[31:24] V_nnz
+// Bit[23:16] U_nnz
+// Bit[15:0]  Y_nnz
+#define   HENC_TOP_INFO_1                          (0x1d39)
+#define P_HENC_TOP_INFO_1                          (volatile unsigned int *)((0x1d39  << 2) + 0xff620000)
+#define   HENC_LEFT_INFO_1                         (0x1d3a)
+#define P_HENC_LEFT_INFO_1                         (volatile unsigned int *)((0x1d3a  << 2) + 0xff620000)
+// bit[63:0] ipred_mode
+#define   VLC_IPRED_MODE_HI                        (0x1d3b)
+#define P_VLC_IPRED_MODE_HI                        (volatile unsigned int *)((0x1d3b  << 2) + 0xff620000)
+#define   VLC_IPRED_MODE_LO                        (0x1d3c)
+#define P_VLC_IPRED_MODE_LO                        (volatile unsigned int *)((0x1d3c  << 2) + 0xff620000)
+// bit[15:8] SE delta quant
+// bit[7:0]  UE delta quant
+#define   VLC_DELTA_QP                             (0x1d3d)
+#define P_VLC_DELTA_QP                             (volatile unsigned int *)((0x1d3d  << 2) + 0xff620000)
+// bit[31:16] Reserved
+// bit[15:12] Reserved
+// bit[11:8] c_ipred_mode
+// bit[7:0] cbp
+#define   VLC_MB_HEADER_INFO                       (0x1d3e)
+#define P_VLC_MB_HEADER_INFO                       (volatile unsigned int *)((0x1d3e  << 2) + 0xff620000)
+// bit[31:16] mb_skip_run
+// bit[15:0]  b8_mode
+#define   VLC_P_MB_HEADER_INFO                     (0x1d3f)
+#define P_VLC_P_MB_HEADER_INFO                     (volatile unsigned int *)((0x1d3f  << 2) + 0xff620000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:20] coeff_buf_level
+// bit[19:10] coeff_buf_write_ptr
+// bit[9:0]   coeff_buf_read_ptr
+#define   VLC_COEFF_BUF_STATUS                     (0x1d40)
+#define P_VLC_COEFF_BUF_STATUS                     (volatile unsigned int *)((0x1d40  << 2) + 0xff620000)
+// bit[31:10] Reserved
+// bit[9:0] read_req_addr
+#define   VLC_COEFF_RD_REQ                         (0x1d41)
+#define P_VLC_COEFF_RD_REQ                         (volatile unsigned int *)((0x1d41  << 2) + 0xff620000)
+// bit[20]   - coeff_buf_read_finished
+// bit[19]   - coeff_first
+// bit[18:4] - coeff_level
+// bit[3:0]  - coeff_run
+#define   VLC_COEFF                                (0x1d42)
+#define P_VLC_COEFF                                (volatile unsigned int *)((0x1d42  << 2) + 0xff620000)
+// bit[31]    - coeff_info_ready
+// bit[30:25] - Reserved
+// bit[24:15] - block_begin_addr
+// bit[14:11] - trailing_one_sign
+// bit[10:6]  - total_coeff
+// bit[5:4]   - trailing_ones
+// bit[3:0]   - total_zeros
+#define   VLC_COEFF_INFO                           (0x1d43)
+#define P_VLC_COEFF_INFO                           (volatile unsigned int *)((0x1d43  << 2) + 0xff620000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:25] Reserved
+// bit[24:20] dc_buf_level -- 0-16
+// bit[19:15] Reserved
+// bit[14:10] dc_buf_write_ptr
+// bit[9:5]   Reserved
+// bit[4:0]   dc_buf_read_ptr
+#define   VLC_DC_BUF_STATUS                        (0x1d44)
+#define P_VLC_DC_BUF_STATUS                        (volatile unsigned int *)((0x1d44  << 2) + 0xff620000)
+// bit[31:10] Reserved
+// bit[9:4]   Reserved
+// bit[3:0]   read_req_addr
+#define   VLC_DC_RD_REQ                            (0x1d45)
+#define P_VLC_DC_RD_REQ                            (volatile unsigned int *)((0x1d45  << 2) + 0xff620000)
+// bit[31:17] - Reserved
+// bit[16]   - dc_first
+// bit[15:1] - dc_level
+// bit[0]    - dc_type  0 - CDC, 1 - LDC
+#define   VLC_DC                                   (0x1d46)
+#define P_VLC_DC                                   (volatile unsigned int *)((0x1d46  << 2) + 0xff620000)
+// bit[31]    - dc_info_ready
+// bit[30:25] - Reserved
+// bit[24:20] - Reserved
+// bit[19:15] - dc_idx_begin_addr
+// bit[14:11] - dc_trailing_one_sign
+// bit[10:6]  - dc_total_coeff
+// bit[5:4]   - dc_trailing_ones
+// bit[3:0]   - dc_total_zeros
+#define   VLC_DC_INFO                              (0x1d47)
+#define P_VLC_DC_INFO                              (volatile unsigned int *)((0x1d47  << 2) + 0xff620000)
+// bit[31:4]  - Reserved
+// bit[3:0]   - mv_rw_idx  (auto increment when read/write VLC_MV)
+#define   VLC_MV_INDEX                             (0x1d48)
+#define P_VLC_MV_INDEX                             (volatile unsigned int *)((0x1d48  << 2) + 0xff620000)
+// bit[31:16] - MVY
+// bit[15:0]  - MVX
+#define   VLC_MV                                   (0x1d49)
+#define P_VLC_MV                                   (volatile unsigned int *)((0x1d49  << 2) + 0xff620000)
+// bit[31:16] - MVY
+// bitp15:0]  - MVX
+// Write to HENC_TOP_MV_0 will cause previous U->UL, UR->U, and UR write
+// Read will read U MV only
+#define   HENC_TOP_MV_0                            (0x1d4a)
+#define P_HENC_TOP_MV_0                            (volatile unsigned int *)((0x1d4a  << 2) + 0xff620000)
+#define   HENC_TOP_MV_1                            (0x1d4b)
+#define P_HENC_TOP_MV_1                            (volatile unsigned int *)((0x1d4b  << 2) + 0xff620000)
+#define   HENC_TOP_MV_2                            (0x1d4c)
+#define P_HENC_TOP_MV_2                            (volatile unsigned int *)((0x1d4c  << 2) + 0xff620000)
+#define   HENC_TOP_MV_3                            (0x1d4d)
+#define P_HENC_TOP_MV_3                            (volatile unsigned int *)((0x1d4d  << 2) + 0xff620000)
+#define   HENC_LEFT_MV_0                           (0x1d4e)
+#define P_HENC_LEFT_MV_0                           (volatile unsigned int *)((0x1d4e  << 2) + 0xff620000)
+#define   HENC_LEFT_MV_1                           (0x1d4f)
+#define P_HENC_LEFT_MV_1                           (volatile unsigned int *)((0x1d4f  << 2) + 0xff620000)
+#define   HENC_LEFT_MV_2                           (0x1d50)
+#define P_HENC_LEFT_MV_2                           (volatile unsigned int *)((0x1d50  << 2) + 0xff620000)
+#define   HENC_LEFT_MV_3                           (0x1d51)
+#define P_HENC_LEFT_MV_3                           (volatile unsigned int *)((0x1d51  << 2) + 0xff620000)
+// Bit[31:1] Reserved
+// Bit[0] top_left_mv_ready
+#define   TOP_LEFT_READY                           (0x1d52)
+#define P_TOP_LEFT_READY                           (volatile unsigned int *)((0x1d52  << 2) + 0xff620000)
+// Bit[31:16] Reserved
+// Bit[15:0] mb_skip_run
+#define   MB_SKIP_RUN                              (0x1d53)
+#define P_MB_SKIP_RUN                              (volatile unsigned int *)((0x1d53  << 2) + 0xff620000)
+// Bit[31:16] Reserved
+// Bit[15]    Reserved
+// Bit[14:13] rd_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[12:11] wr_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[10:5]  mv_buff_id
+// Bit[4:0]   mv_ref
+#define   VLC_HCMD_CONFIG                          (0x1d54)
+#define P_VLC_HCMD_CONFIG                          (volatile unsigned int *)((0x1d54  << 2) + 0xff620000)
+// Bit[9:0] h264_dblk_info
+#define   VLC_HCMD_DBLK_INFO                       (0x1d55)
+#define P_VLC_HCMD_DBLK_INFO                       (volatile unsigned int *)((0x1d55  << 2) + 0xff620000)
+// Bit[3:0] vlc_dbg_idx
+#define   VLC_DBG_IDX                              (0x1d56)
+#define P_VLC_DBG_IDX                              (volatile unsigned int *)((0x1d56  << 2) + 0xff620000)
+// Read Only
+#define   VLC_DBG_READ                             (0x1d57)
+#define P_VLC_DBG_READ                             (volatile unsigned int *)((0x1d57  << 2) + 0xff620000)
+// [   29] RW jpeg_comp2_ac_table_sel.                                                      Default 0.
+// [   28] RW jpeg_comp2_dc_table_sel.                                                      Default 0.
+// [26:25] RW jpeg_comp2_cnt_max.                                                           Default 0.
+// [   24] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   21] RW jpeg_comp1_ac_table_sel.                                                      Default 0.
+// [   20] RW jpeg_comp1_dc_table_sel.                                                      Default 0.
+// [18:17] RW jpeg_comp1_cnt_max.                                                           Default 0.
+// [   16] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [   13] RW jpeg_comp0_ac_table_sel.                                                      Default 0.
+// [   12] RW jpeg_comp0_dc_table_sel.                                                      Default 0.
+// [10: 9] RW jpeg_comp0_cnt_max.                                                           Default 0.
+// [    8] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [    1] W  jpeg_coeff_init. Write 1 to this bit to initialize JPEG run length encoder.
+// [    0] RW jpeg_en. 0=Disable JPEG encoder; 1=Enable JPEG encoder.                       Default 0.
+#define   VLC_JPEG_CTRL                            (0x1d58)
+#define P_VLC_JPEG_CTRL                            (volatile unsigned int *)((0x1d58  << 2) + 0xff620000)
+// [   13] RW jpeg_coeff_buf_overfl. Write this bit to 1 to clear overfl.
+// [   12] RW jpeg_coeff_buf_undrfl. Write this bit to 1 to clear undrfl.
+// [   11] R  jpeg_coeff_buf_full.
+// [   10] R  jpeg_coeff_buf_empty.
+// [ 8: 0] R  jpeg_coeff_buf_level.
+#define   VLC_JPEG_COEFF_BUF_STAT                  (0x1d59)
+#define P_VLC_JPEG_COEFF_BUF_STAT                  (volatile unsigned int *)((0x1d59  << 2) + 0xff620000)
+// [   16] RW JPEG HUFFMAN table access mode. 0=Write; 1=Read.  Default 1.
+// [ 8: 0] RW JPEG HUFFMAN table addr.                          Default 0.
+#define   VLC_HUFFMAN_ADDR                         (0x1d5a)
+#define P_VLC_HUFFMAN_ADDR                         (volatile unsigned int *)((0x1d5a  << 2) + 0xff620000)
+// [19: 0] RW JPEG HUFFMAN table data.
+#define   VLC_HUFFMAN_DATA                         (0x1d5b)
+#define P_VLC_HUFFMAN_DATA                         (volatile unsigned int *)((0x1d5b  << 2) + 0xff620000)
+// bit[31:0] enc_mv_bits - including b8_mode and mvd
+#define   VLC_ENC_MV_BITS                          (0x1d5c)
+#define P_VLC_ENC_MV_BITS                          (volatile unsigned int *)((0x1d5c  << 2) + 0xff620000)
+// bit[31:0] enc_coeff_bits - including cbp, token, trailing_sign, coeff_enc, h264_totzeros, h264_run
+#define   VLC_ENC_COEFF_BITS                       (0x1d5d)
+#define P_VLC_ENC_COEFF_BITS                       (volatile unsigned int *)((0x1d5d  << 2) + 0xff620000)
+//
+// Closing file:  vlc_regs.h
+//
+//------------------------------------------------------------------------------
+// QDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  qdct_regs.h
+//
+//========================================================================
+//  QDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_QDCT_CBUS_BASE = 0x0f
+// -----------------------------------------------
+// bit[31:28] - mb_info_state
+#define   QDCT_STATUS_CTRL                         (0x1f00)
+#define P_QDCT_STATUS_CTRL                         (volatile unsigned int *)((0x1f00  << 2) + 0xff620000)
+// bit[18]    - enable_free_clk_sad_top
+// bit[17]    - enable_free_clk_ie_top
+// bit[16]    - enable_free_clk_ie_sub
+// bit[15]    - enable_free_clk_mc_out
+// bit[14]    - enable_free_clk_i_pred_top
+// bit[13]    - enable_free_clk_idct_top
+// bit[12]    - enable_free_clk_iq_top
+// bit[11]    - enable_free_clk_q_top
+// bit[10]    - enable_free_clk_dc_buff_8
+// bit[9]     - enable_free_clk_dct_top
+// bit[8]     - enable_free_clk_mb_info
+// bit[7]     - enable_free_clk_mb_buff
+// bit[6]     - enable_free_clk_reg
+// bit[5]     - ignore_1_include_2nd_half_c
+// bit[4]     - ignore_1_include_2nd_half
+// bit[3]     - ignore_t_p8x8
+// bit[2]     - not_ignore_dc
+// bit[1]     - ignore_small_lac_intra
+// bit[0]     - disable_fast_zero_block
+#define   QDCT_CONFIG                              (0x1f01)
+#define P_QDCT_CONFIG                              (volatile unsigned int *)((0x1f01  << 2) + 0xff620000)
+// bit[31]    - ignore_lac_coeff_en
+// bit[30:26] - ignore_lac_coeff_else
+// bit[25:21] - ignore_lac_coeff_2
+// bit[20:16] - ignore_lac_coeff_1
+// bit[15]    - ignore_cac_coeff_en
+// bit[14:10] - ignore_cac_coeff_else
+// bit[9:5]   - ignore_cac_coeff_2
+// bit[4:0]   - ignore_cac_coeff_1
+#define   IGNORE_CONFIG                            (0x1f02)
+#define P_IGNORE_CONFIG                            (volatile unsigned int *)((0x1f02  << 2) + 0xff620000)
+// bit[31]    - ignore_t_lac_coeff_en
+// bit[30:26] - ignore_t_lac_coeff_else
+// bit[25:21] - ignore_t_lac_coeff_2
+// bit[20:16] - ignore_t_lac_coeff_1
+// bit[15]    - ignore_cdc_coeff_en
+// bit[14]    - ignore_t_lac_coeff_else_le_3
+// bit[13]    - ignore_t_lac_coeff_else_le_4
+// bit[12]    - ignore_cdc_only_when_empty_cac_inter
+// bit[11]    - ignore_cdc_only_when_one_empty_inter
+// bit[10:9]  - ignore_cdc_range_max_inter // 0-0, 1-1, 2,-2, 3-3
+// bit[8:7]   - ignore_cdc_abs_max_inter // 0-1, 1-2, 2,-3, 3-4
+// bit[6]     - reserved
+// bit[5]     - ignore_cdc_only_when_empty_cac_intra
+// bit[4]     - ignore_cdc_only_when_one_empty_intra
+// bit[3:2]   - ignore_cdc_range_max_intra // 0-0, 1-1, 2,-2, 3-3
+// bit[1:0]   - ignore_cdc_abs_max_intra // 0-1, 1-2, 2,-3, 3-4
+#define   IGNORE_CONFIG_2                          (0x1f03)
+#define P_IGNORE_CONFIG_2                          (volatile unsigned int *)((0x1f03  << 2) + 0xff620000)
+// --------------------------------------------
+// MB DATA DDR Interface
+// --------------------------------------------
+#define   QDCT_MB_START_PTR                        (0x1f10)
+#define P_QDCT_MB_START_PTR                        (volatile unsigned int *)((0x1f10  << 2) + 0xff620000)
+#define   QDCT_MB_END_PTR                          (0x1f11)
+#define P_QDCT_MB_END_PTR                          (volatile unsigned int *)((0x1f11  << 2) + 0xff620000)
+#define   QDCT_MB_WR_PTR                           (0x1f12)
+#define P_QDCT_MB_WR_PTR                           (volatile unsigned int *)((0x1f12  << 2) + 0xff620000)
+#define   QDCT_MB_RD_PTR                           (0x1f13)
+#define P_QDCT_MB_RD_PTR                           (volatile unsigned int *)((0x1f13  << 2) + 0xff620000)
+#define   QDCT_MB_LEVEL                            (0x1f14)
+#define P_QDCT_MB_LEVEL                            (volatile unsigned int *)((0x1f14  << 2) + 0xff620000)
+// bit  [31]    disable_mbxy_ie_save
+// bit  [30]    no_wait_after_q_cdc
+// bit  [29]    ie_start_int_enable
+// bit  [28]    ignore_t_p8x8
+// bit  [27]    zero_mc_out_null_non_skipped_mb
+// bit  [26]    no_mc_out_null_non_skipped_mb
+// bit  [25]    mc_out_even_skipped_mb
+// bit  [24]    mc_out_wait_cbp_ready
+// bit  [23]    mc_out_wait_mb_type_ready
+// bit  [22]    i_pred_int_enable
+// bit  [21]    intra_sat8_enable
+// bit  [20]    ie_sub_enable
+// bit  [19]    i_pred_enable
+// bit  [18]    iq_enable
+// bit  [17]    idct_enable
+// bit  [16]    no_zero_coeff_mb
+// bit  [15]    add_zero_coeff_block
+// bit  [14]    mb_pause_enable
+// bit  [13]    q_enable
+// bit  [12]    dct_enable
+// bit  [11]    ignore_magic_word
+// bit  [10]    mb_info_en
+// bit  [9]     mb_info_soft_reset
+// bit  [8]     mb_always_ready Set to 1 to ignore mb_level blocking DDR read
+// bit  [7]     mb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   mb_endian       Set MB Endian inside DDR memory
+// bit  [2]     mb_read_busy   Read Only - indicate DDR read busy
+// bit  [1]     mb_read_en     Set to 1 to enable reading data from DDR memory
+// bit  [0]     mb_soft_reset   Soft reset
+#define   QDCT_MB_CONTROL                          (0x1f15)
+#define P_QDCT_MB_CONTROL                          (volatile unsigned int *)((0x1f15  << 2) + 0xff620000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23    reserved
+// bit 22    read_till_zero
+// bit 21:16 A_id  // default : 0x21
+// bit 15:0  mb_level_hold // default : 0
+#define   QDCT_MB_MEM_CTL                          (0x1f16)
+#define P_QDCT_MB_MEM_CTL                          (volatile unsigned int *)((0x1f16  << 2) + 0xff620000)
+// bit  [31:24] reserved
+// bit  [23:16] vb_buff_level     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define   QDCT_MB_BUFF                             (0x1f17)
+#define P_QDCT_MB_BUFF                             (volatile unsigned int *)((0x1f17  << 2) + 0xff620000)
+// bit [31:0] mb infor data begin magic word - default : 0xa55aaa55
+#define   QDCT_MB_MAGIC_WORD                       (0x1f18)
+#define P_QDCT_MB_MAGIC_WORD                       (volatile unsigned int *)((0x1f18  << 2) + 0xff620000)
+// Read Only Register
+// bit[19]   dct_ready_1
+// bit[18]   dct_ready_0
+// bit[17]   dct_rd_idx
+// bit[16]   dct_wr_idx
+// bit[15]   dct_srdy
+// bit[14]   dct_rrdy
+// bit[13]   Reserved
+// bit[12:8] dct_block_number
+// bit[7:4]  dct_rw_addr
+// bit[3:0]  dct_status
+#define   QDCT_DCT_STATUS                          (0x1f19)
+#define P_QDCT_DCT_STATUS                          (volatile unsigned int *)((0x1f19  << 2) + 0xff620000)
+// bit[24:23]  vlc_quant_count
+// bit[22:16]  vlc_delta_quant_data
+// bit[15:10]  vlc_quant_data
+// bit[9:4]    vlc_prev_quant_data
+// bit[3:0]    q_status
+#define   QDCT_Q_STATUS                            (0x1f1a)
+#define P_QDCT_Q_STATUS                            (volatile unsigned int *)((0x1f1a  << 2) + 0xff620000)
+// bit[31:3] Reserved
+// bit[2:0]  picture_type
+#define   QDCT_PIC_INFO                            (0x1f1b)
+#define P_QDCT_PIC_INFO                            (volatile unsigned int *)((0x1f1b  << 2) + 0xff620000)
+// bit[31:28] Reserved
+// bit[27:22] I_pic_quant_c
+// bit[21:16] I_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define   QDCT_Q_QUANT_I                           (0x1f1c)
+#define P_QDCT_Q_QUANT_I                           (volatile unsigned int *)((0x1f1c  << 2) + 0xff620000)
+// bit[31:28] Reserved
+// bit[27:22] P_pic_quant_c
+// bit[21:16] P_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define   QDCT_Q_QUANT_P                           (0x1f1d)
+#define P_QDCT_Q_QUANT_P                           (volatile unsigned int *)((0x1f1d  << 2) + 0xff620000)
+// bit[31]    mb_info_pause
+// bit[30:16] pause_mby
+// bit[15:0]  pause_mbx
+#define   QDCT_MB_PAUSE_CTL                        (0x1f1e)
+#define P_QDCT_MB_PAUSE_CTL                        (volatile unsigned int *)((0x1f1e  << 2) + 0xff620000)
+// bit[31]   top_control_ready_i_pred
+// bit[30:28]top_dma_status
+// bit[27]   top_control_ready_ie
+// bit[26:24]Reserved
+// bit[23]   ul_mb
+// bit[22]   right_mb
+// bit[21]   top_mb
+// bit[20]   left_mb
+// bit[19:8] mb_x
+// bit[7:6]  i_pred_ref_idx_L
+// bit[5:4]  i_pred_ref_idx_UL
+// bit[3:2]  i_pred_ref_idx_U
+// bit[1:0]  i_pred_ref_idx_UR
+#define   QDCT_TOP_CONTROL                         (0x1f1f)
+#define P_QDCT_TOP_CONTROL                         (volatile unsigned int *)((0x1f1f  << 2) + 0xff620000)
+// bit[31:0] top_base_addr - DDR Memory start address for save top Pixel
+#define   QDCT_TOP_BASE_MEM                        (0x1f20)
+#define P_QDCT_TOP_BASE_MEM                        (volatile unsigned int *)((0x1f20  << 2) + 0xff620000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x22
+#define   QDCT_TOP_MEM_CTL                         (0x1f21)
+#define P_QDCT_TOP_MEM_CTL                         (volatile unsigned int *)((0x1f21  << 2) + 0xff620000)
+// bit [11:0] top_wrrsp_count
+#define   QDCT_TOP_WRRSP                           (0x1f22)
+#define P_QDCT_TOP_WRRSP                           (volatile unsigned int *)((0x1f22  << 2) + 0xff620000)
+// Bit[3:0] qdct_dbg_idx
+#define   QDCT_DBG_IDX                             (0x1f23)
+#define P_QDCT_DBG_IDX                             (volatile unsigned int *)((0x1f23  << 2) + 0xff620000)
+// Read Only
+#define   QDCT_DBG_READ                            (0x1f24)
+#define P_QDCT_DBG_READ                            (volatile unsigned int *)((0x1f24  << 2) + 0xff620000)
+// [19:18] RW jdct_inflow_ctrl. JPEG DCT input flow control.                                Default 0.
+//            0=No halt;
+//            1=DCT halts request at end of each 8x8 block;
+//            2=DCT halts request at end of each MCU.
+// [17:16] RW jpeg_coeff_last_sel.                                                          Default 0.
+//            Select at which point to finish processing, give update to AmRISC so it can control the next step.
+//            0=Mark last coeff at the end of an 8x8 block;
+//            1=Mark at the end of an MCU;
+//            2=Mark at the end of a scan.
+// [   15] RW jpeg_quant_sel_comp2. 0=Comp2 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   14] RW jpeg_v_factor_comp2. Component 2's vertical sampling factor.                  Default 0.
+// [   13] RW jpeg_h_factor_comp2. Component 2's horizontal sampling factor.                Default 0.
+// [   12] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   11] RW jpeg_quant_sel_comp1. 0=Comp1 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   10] RW jpeg_v_factor_comp1. Component 1's vertical sampling factor.                  Default 0.
+// [    9] RW jpeg_h_factor_comp1. Component 1's horizontal sampling factor.                Default 0.
+// [    8] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [    7] RW jpeg_quant_sel_comp0. 0=Comp0 select Quantization table 0; 1=Select table 1.  Default 0.
+// [    6] RW jpeg_v_factor_comp0. Component 0's vertical sampling factor.                  Default 0.
+// [    5] RW jpeg_h_factor_comp0. Component 0's horizontal sampling factor.                Default 0.
+// [    4] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [ 3: 1] RW jdct_intr_sel. JPEG DCT interrupt select.                                     Default 0.
+//            0=Disable intr;
+//            1=Intr at end of each 8x8 block of DCT input;
+//            2=Intr at end of each MCU of DCT input;
+//            3=Intr at end of a scan of DCT input;
+//            4=Intr at end of each 8x8 block of DCT output;
+//            5=Intr at end of each MCU of DCT output;
+//            6=Intr at end of a scan of DCT output.
+// [    0] RW jpeg_en. 0=Disable JPEG QDCT; 1=Enable JPEG QDCT.                             Default 0.
+#define   QDCT_JPEG_CTRL                           (0x1f25)
+#define P_QDCT_JPEG_CTRL                           (volatile unsigned int *)((0x1f25  << 2) + 0xff620000)
+// [29:16] RW jpeg_x_end.   Picture X end.      Default 0.
+// [13: 0] RW jpeg_x_start. Picture X start.    Default 0.
+#define   QDCT_JPEG_X_START_END                    (0x1f26)
+#define P_QDCT_JPEG_X_START_END                    (volatile unsigned int *)((0x1f26  << 2) + 0xff620000)
+// [29:16] RW jpeg_y_end.   Picture Y end.      Default 0.
+// [13: 0] RW jpeg_y_start. Picture Y start.    Default 0.
+#define   QDCT_JPEG_Y_START_END                    (0x1f27)
+#define P_QDCT_JPEG_Y_START_END                    (volatile unsigned int *)((0x1f27  << 2) + 0xff620000)
+// [    8] RW JPEG QUANT table access mode. 0=Write; 1=Read.    Default 1.
+// [ 5: 0] RW JPEG QUANT table addr.                            Default 0.
+#define   QDCT_JPEG_QUANT_ADDR                     (0x1f28)
+#define P_QDCT_JPEG_QUANT_ADDR                     (volatile unsigned int *)((0x1f28  << 2) + 0xff620000)
+// [31: 0] RW JPEG QUANT table data.
+#define   QDCT_JPEG_QUANT_DATA                     (0x1f29)
+#define P_QDCT_JPEG_QUANT_DATA                     (volatile unsigned int *)((0x1f29  << 2) + 0xff620000)
+// [    1] W  resume_jdct.
+//            Write 1 to this bit will resume JPEG input engine when previously
+//            it is halted by QDCT_JPEG_CTRL.jdct_inflow_ctrl.
+// [    0] W  jpeg_sof.
+//            Write 1 to this bit will start JPEG input engine.
+#define   QDCT_JPEG_SOF_RESUME                     (0x1f2a)
+#define P_QDCT_JPEG_SOF_RESUME                     (volatile unsigned int *)((0x1f2a  << 2) + 0xff620000)
+// [31:30] R  dct_st.       jdct_ctrl state. 0=IDLE; 1=WAIT; 2=DCT_REQ.
+// [29:28] R  mfdin_comp.   Current component at pixel request to MFDIN.
+// [27:14] R  mfdin_y.      Current Y at pixel request to MFDIN.
+// [13: 0] R  mfdin_x.      Current X at pixel request to MFDIN.
+#define   QDCT_JPEG_DCT_STATUS0                    (0x1f2b)
+#define P_QDCT_JPEG_DCT_STATUS0                    (volatile unsigned int *)((0x1f2b  << 2) + 0xff620000)
+// [15:12] R  JPEG Quant read MEM select.
+// [11: 8] R  JPEG DCT2 write MEM select.
+// [ 7: 4] R  JPEG DCT2 read MEM select.
+// [ 3: 0] R  JPEG DCT1 write MEM select.
+#define   QDCT_JPEG_DCT_STATUS1                    (0x1f2c)
+#define P_QDCT_JPEG_DCT_STATUS1                    (volatile unsigned int *)((0x1f2c  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff1.  Default 13'h1D90; // 7568 = 4096 * sqrt(2) * (cos(Pi/8) + sin(Pi/8)) // 7569
+// [12: 0] RW jdct_coeff0.  Default 13'h16A1; // 5793 = 4096 * sqrt(2)
+#define   QDCT_JPEG_DCT_COEFF01                    (0x1f2d)
+#define P_QDCT_JPEG_DCT_COEFF01                    (volatile unsigned int *)((0x1f2d  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff3.  Default 13'h0C3F; // 3135 = 4096 * sqrt(2) * (cos(Pi/8) - sin(Pi/8))
+// [12: 0] RW jdct_coeff2.  Default 13'h08A9; // 2217 = 4096 * sqrt(2) * sin(Pi/8) // 2215
+#define   QDCT_JPEG_DCT_COEFF23                    (0x1f2e)
+#define P_QDCT_JPEG_DCT_COEFF23                    (volatile unsigned int *)((0x1f2e  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff5.  Default 13'h046A; // 1130 = 4096 * (cos(3Pi/16) - sin(3Pi/16))
+// [12: 0] RW jdct_coeff4.  Default 13'h1631; // 5681 = 4096 * (cos(3Pi/16) + sin(3Pi/16)) // 5682
+#define   QDCT_JPEG_DCT_COEFF45                    (0x1f2f)
+#define P_QDCT_JPEG_DCT_COEFF45                    (volatile unsigned int *)((0x1f2f  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff7.  Default 13'h0C92; // 3218 = 4096 * (cos(Pi/16) - sin(Pi/16))
+// [12: 0] RW jdct_coeff6.  Default 13'h12D0; // 4816 = 4096 * (cos(Pi/16) + sin(Pi/16))
+#define   QDCT_JPEG_DCT_COEFF67                    (0x1f30)
+#define P_QDCT_JPEG_DCT_COEFF67                    (volatile unsigned int *)((0x1f30  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff9.  Default 13'h0FB1; // 4017 = 4096 * cos(Pi/16)
+// [12: 0] RW jdct_coeff8.  Default 13'h0D4E; // 3406 = 4096 * cos(3Pi/16)
+#define   QDCT_JPEG_DCT_COEFF89                    (0x1f31)
+#define P_QDCT_JPEG_DCT_COEFF89                    (volatile unsigned int *)((0x1f31  << 2) + 0xff620000)
+#define   QDCT_I_PRED_REF_WR_IDX                   (0x1f32)
+#define P_QDCT_I_PRED_REF_WR_IDX                   (volatile unsigned int *)((0x1f32  << 2) + 0xff620000)
+#define   QDCT_I_PRED_REF_WR_DATA                  (0x1f33)
+#define P_QDCT_I_PRED_REF_WR_DATA                  (volatile unsigned int *)((0x1f33  << 2) + 0xff620000)
+// bit[29]  mb_info_latch_no_I16_pred_mode
+// bit[28]  ie_dma_mbxy_use_i_pred
+// bit[27]  ie_dma_read_write_use_ip_idx
+// bit[26]  ie_start_use_top_dma_count
+// bit[25]  i_pred_top_dma_rd_mbbot
+// bit[24]  i_pred_top_dma_wr_disable
+// bit[23]  i_pred_mix
+// bit[22]  me_ab_rd_when_intra_in_p
+// bit[21]  force_mb_skip_run_when_intra
+// bit[20]  mc_out_mixed_type
+// bit[19]  ie_start_when_quant_not_full
+// bit[18]  mb_info_state_mix
+// bit[17]  mb_type_use_mix_result
+// bit[16]  me_cb_ie_read_enable
+// bit[15]  ie_cur_data_from_me
+// bit[14]  rem_per_use_table
+// bit[13]  q_latch_int_enable
+// bit[12]  q_use_table
+// bit[11]  q_start_wait
+// bit[10]  LUMA_16_LEFT_use_cur
+// bit[9]   DC_16_LEFT_SUM_use_cur
+// bit[8]   c_ref_ie_sel_cur
+// bit[7]   c_ipred_perfect_mode
+// bit[6]   ref_ie_ul_sel 0-old, 1-use next_set
+// bit[5]   mb_type_use_ie_result
+// bit[4]   detect_I16_from_I4
+// bit[3]   ie_not_wait_ref_busy
+// bit[2]   ie_I16_enable
+// bit[1:0] ie_done_sel (0, 1, 2, -1)
+#define   QDCT_ADV_CONFIG                          (0x1f34)
+#define P_QDCT_ADV_CONFIG                          (volatile unsigned int *)((0x1f34  << 2) + 0xff620000)
+// bit [31:16] I16x16_weight
+// bit [15:0]  I4x4_weight
+#define   IE_WEIGHT                                (0x1f35)
+#define P_IE_WEIGHT                                (volatile unsigned int *)((0x1f35  << 2) + 0xff620000)
+// bit [31]  reserved
+// bit [30] q_I16MB
+// bit [29]  reserved
+// bit [28]  reserved
+// bit [27:23] quant_table_addr I4MB:[0,7], I16MB:[8:15], INTER:[16:23], Reserved:[24:31]
+// bit [22]    quant_table_addr_update(when notupdate_rem_per) (read is arb_result : q_intra)
+// bit [21:19] quant_rem_c
+// bit [18:16] quant_rem_y
+// bit [15:12] quant_per_c
+// bit [11:8]  quant_per_y
+// bit [7:2] quant
+// bit [1] update_rem_per
+// bit [0] clear_wait_status
+#define   Q_QUANT_CONTROL                          (0x1f36)
+#define P_Q_QUANT_CONTROL                          (volatile unsigned int *)((0x1f36  << 2) + 0xff620000)
+#define   MBBOT_EVEN_ADDR                          (0x1f37)
+#define P_MBBOT_EVEN_ADDR                          (volatile unsigned int *)((0x1f37  << 2) + 0xff620000)
+#define   MBBOT_ODD_ADDR                           (0x1f38)
+#define P_MBBOT_ODD_ADDR                           (volatile unsigned int *)((0x1f38  << 2) + 0xff620000)
+// bit [29:24] quant_table_data_3
+// bit [21:16] quant_table_data_2
+// bit [13:8]  quant_table_data_1
+// bit [5:0]   quant_table_data_0
+#define   QUANT_TABLE_DATA                         (0x1f39)
+#define P_QUANT_TABLE_DATA                         (volatile unsigned int *)((0x1f39  << 2) + 0xff620000)
+// bit [31:16] ie_sad_offset_I16
+// bit [15:0] ie_sad_offset_I4
+#define   SAD_CONTROL_0                            (0x1f3a)
+#define P_SAD_CONTROL_0                            (volatile unsigned int *)((0x1f3a  << 2) + 0xff620000)
+// bit [31]     sad_soft_reset
+// bit [30:27]  reserved
+// bit [26:24]  ie_sad_shift_I16
+// bit [22:20]  ie_sad_shift_I4
+// bit [18:16]  me_sad_shift_INTER
+// bit [15:0]   me_sad_offset_INTER
+#define   SAD_CONTROL_1                            (0x1f3b)
+#define P_SAD_CONTROL_1                            (volatile unsigned int *)((0x1f3b  << 2) + 0xff620000)
+// bit [31]     vlc_quant_rd_ptr
+// bit [30]     vlc_quant_rd_ptr_update
+// bit [29]     vlc_quant_wr_ptr
+// bit [28]     vlc_quant_wr_ptr_update
+// bit [27:26]  reserved
+// bit [25:19]  vlc_delta_quant_1
+// bit [18:13]  vlc_quant_1
+// bit [12:6]   vlc_delta_quant_0
+// bit [5:0]    vlc_quant_0
+#define   QDCT_VLC_QUANT_CTL_0                     (0x1f3c)
+#define P_QDCT_VLC_QUANT_CTL_0                     (volatile unsigned int *)((0x1f3c  << 2) + 0xff620000)
+// bit [31:30]  me_sad_rd_idx
+// bit [29]     me_sad_rd_idx_update
+// bit [28:27]  me_sad_wr_idx
+// bit [26]     me_sad_wr_idx_update
+// bit [25:24]  ie_sad_rd_idx
+// bit [23]     ie_sad_rd_idx_update
+// bit [22:21]  ie_sad_wr_idx
+// bit [20]     ie_sad_wr_idx_update
+// bit [19:12]  Reserved
+// bit [11:6]   vlc_max_delta_q_neg
+// bit [5:0]    vlc_max_delta_q_pos
+#define   QDCT_VLC_QUANT_CTL_1                     (0x1f3d)
+#define P_QDCT_VLC_QUANT_CTL_1                     (volatile unsigned int *)((0x1f3d  << 2) + 0xff620000)
+// bit[4] jdct_int
+// bit[3] quant_latch
+// bit[2] me_done
+// bit[1] ie_start
+// bit[0] i_pred_start
+#define   QDCT_INT_STATUS                          (0x1f3e)
+#define P_QDCT_INT_STATUS                          (volatile unsigned int *)((0x1f3e  << 2) + 0xff620000)
+// bit[3]   mix_i_pred_wait_left_en
+// bit[2:0] mc_pending_mb_count
+#define   QDCT_MIX_I_PRED_STATUS                   (0x1f3f)
+#define P_QDCT_MIX_I_PRED_STATUS                   (volatile unsigned int *)((0x1f3f  << 2) + 0xff620000)
+// IE/ME share same cbus_base as QDCT
+//
+// bit[31]  active_ur_block
+// bit[30]  active_ul_block
+// bit[21]  disable_HENC_V_PRED_16
+// bit[20]  disable_HENC_H_PRED_16
+// bit[19]  disable_HENC_DC_PRED_16
+// bit[18]  disable_HENC_HENC_HOR_UP_PRED
+// bit[17]  disable_HENC_VERT_LEFT_PRED
+// bit[16]  disable_HENC_HENC_HOR_DOWN_PRED
+// bit[15]  disable_HENC_VERT_RIGHT_PRED
+// bit[14]  disable_HENC_DIAG_DOWN_RIGHT_PRED
+// bit[13]  disable_HENC_DIAG_DOWN_LEFT_PRED
+// bit[12]  disable_HENC_DC_PRED
+// bit[11]  disable_HENC_HOR_PRED
+// bit[10]  disable_HENC_VERT_PRED
+// bit[9]   ie_c_wait_ie_pause
+// bit[8:4] max_ie_result_buff_count
+// bit[3]   ie_wait_for_ie_result  // use for (max_ie_result_buff_count == 0) to wait every block
+// bit[2]   reserved
+// bit[1]   ie_enable
+// bit[0]   ie_soft_reset
+#define   IE_CONTROL                               (0x1f40)
+#define P_IE_CONTROL                               (volatile unsigned int *)((0x1f40  << 2) + 0xff620000)
+// bit[31:12] Reserved
+// bit[11:0]  mb_y
+#define   IE_MB_POSITION                           (0x1f41)
+#define P_IE_MB_POSITION                           (volatile unsigned int *)((0x1f41  << 2) + 0xff620000)
+// bit[31:16] me_skip_run
+// bit[15:8]  reserved
+// bit [7:4]  me_b8_mode
+// bit [3:0]  ie_me_mb_type
+#define   IE_ME_MB_INFO                            (0x1f42)
+#define P_IE_ME_MB_INFO                            (volatile unsigned int *)((0x1f42  << 2) + 0xff620000)
+// bit[3]   ie_result_buff_enable
+// bit[2]   ie_result_buff_soft_reset
+// bit[1]   sad_enable
+// bit[0]   ie_sad_soft_reset
+#define   SAD_CONTROL                              (0x1f43)
+#define P_SAD_CONTROL                              (volatile unsigned int *)((0x1f43  << 2) + 0xff620000)
+// bit[31:16] - ie_result_buff_count - read only
+// bit[14:12] -current_ie_result (pred_mode) - read only
+// bit[11]  top_control_data_buff_wr_ptr - rd/wr
+// bit[10]  top_control_data_buff_rd_ptr - rd/wr
+// bit[9:5] ie_result_buff_wr_ptr        - rd/wr
+// bit[4:0] ie_result_buff_rd_ptr        - rd/wr
+#define   IE_RESULT_BUFFER                         (0x1f44)
+#define P_IE_RESULT_BUFFER                         (volatile unsigned int *)((0x1f44  << 2) + 0xff620000)
+// bit[63:0] ie_i4_pred_mode
+#define   IE_I4_PRED_MODE_HI                       (0x1f45)
+#define P_IE_I4_PRED_MODE_HI                       (volatile unsigned int *)((0x1f45  << 2) + 0xff620000)
+#define   IE_I4_PRED_MODE_LO                       (0x1f46)
+#define P_IE_I4_PRED_MODE_LO                       (volatile unsigned int *)((0x1f46  << 2) + 0xff620000)
+// bit [31:9] reserved
+// bit [8:4] i_pred_block_number
+// bit [3:0] ie_c_pred_mode
+#define   IE_C_PRED_MODE                           (0x1f47)
+#define P_IE_C_PRED_MODE                           (volatile unsigned int *)((0x1f47  << 2) + 0xff620000)
+// 31:16 - Left, 0-select ie_pixel, 1-select mc_data_out
+// 15:0  - Top,  0-select ie_pixel, 1-select mc_data_out
+#define   IE_CUR_REF_SEL                           (0x1f48)
+#define P_IE_CUR_REF_SEL                           (volatile unsigned int *)((0x1f48  << 2) + 0xff620000)
+// bit[31]  enable_f_skip_1_step_3
+// bit[30]  enable_f_skip_1_step_2
+// bit[29]  enable_f_skip_1_step_1
+// bit[28]  step_3_enable
+// bit[27]  step_2_sub_pixel
+// bit[26]  always_f_skip_step_3
+// bit[25]  always_f_skip_step_2
+// bit[24]  always_f_skip_step_1
+// bit[23]  half_pixel_only
+// bit[22:13] reserved
+// bit[12]  adv_mv_enable
+// bit[11]  sad_short_valid
+// bit[10:9] mv_flexable_ctl 00:0x40, 01:0x80, 10:0xc0, 11 : 0x100
+// bit[8]   no_md_ab_rd
+// bit[7]   use_dct_state
+// bit[6]   enable_free_clk_me_ctl
+// bit[5]   enable_free_clk_me_ab
+// bit[4]   enable_free_clk_me_cb
+// bit[3]   reserved
+// bit[2]   me_done_int_enable
+// bit[1]   me_enable
+// bit[0]   me_soft_reset
+#define   ME_CONTROL                               (0x1f49)
+#define P_ME_CONTROL                               (volatile unsigned int *)((0x1f49  << 2) + 0xff620000)
+// bit[31:28] Reserved
+// bit[27:16] me_start_mby
+// bit[15:12] Reserved
+// bit[11:0]  me_start_mbx
+#define   ME_START_POSITION                        (0x1f4a)
+#define P_ME_START_POSITION                        (volatile unsigned int *)((0x1f4a  << 2) + 0xff620000)
+// bit [31:28] me_status - Read only
+// bit [27:24] me_cb_status  // current buffer
+// bit [23:20] me_ab_status  // anc buffer
+// bit [19]    Reserved
+// bit [18:16] me_ab_wr_ptr  // read only
+// bit [15:4]  me_last_mbx
+// bit [3:1]   me_ab_rd_ptr  // read only
+// bit [0]     me_action
+#define   ME_STATUS                                (0x1f4b)
+#define P_ME_STATUS                                (volatile unsigned int *)((0x1f4b  << 2) + 0xff620000)
+// all Read-only
+// bit [31:28] Reserved
+// bit [27:16] me_ab_mbx
+// bit [15:14] me_cb_wr_ptr
+// bit [13:12] me_cb_rd_ptr
+// bit [11:0]  me_cb_mbx
+#define   ME_DEBUG                                 (0x1f4c)
+#define P_ME_DEBUG                                 (volatile unsigned int *)((0x1f4c  << 2) + 0xff620000)
+// bit[29:24] step_3_skip_line
+// bit[23:18] step_2_skip_line
+// bit[17:12] step_1_skip_line
+// bit[11:6]  step_0_skip_line
+// bit[5:0]   read_skip_line
+#define   ME_SKIP_LINE                             (0x1f4d)
+#define P_ME_SKIP_LINE                             (volatile unsigned int *)((0x1f4d  << 2) + 0xff620000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x23
+#define   ME_AB_MEM_CTL                            (0x1f4e)
+#define P_ME_AB_MEM_CTL                            (volatile unsigned int *)((0x1f4e  << 2) + 0xff620000)
+// bit[31:24] anc_pic_canvas
+// bit[23:12] max_me_mby_num
+// bit[11:0]  max_me_mbx_num
+#define   ME_PIC_INFO                              (0x1f4f)
+#define P_ME_PIC_INFO                              (volatile unsigned int *)((0x1f4f  << 2) + 0xff620000)
+// bit [23:12] me_sad_enough_1
+// bit [11:0]  me_sad_enough_0
+#define   ME_SAD_ENOUGH_01                         (0x1f50)
+#define P_ME_SAD_ENOUGH_01                         (volatile unsigned int *)((0x1f50  << 2) + 0xff620000)
+// bit [25:12] adv_mv_8x8_enough
+// bit [11:0]  me_sad_enough_2
+#define   ME_SAD_ENOUGH_23                         (0x1f51)
+#define P_ME_SAD_ENOUGH_23                         (volatile unsigned int *)((0x1f51  << 2) + 0xff620000)
+// bit [21:10] me_step0_big_sad
+// bit [9:5] me_step0_close_mv_y
+// bit [4:0] me_step0_close_mv_x
+#define   ME_STEP0_CLOSE_MV                        (0x1f52)
+#define P_ME_STEP0_CLOSE_MV                        (volatile unsigned int *)((0x1f52  << 2) + 0xff620000)
+// bit[31:24] force_skip_sad_3
+// bit[23:16] force_skip_sad_2
+// bit[15:08] force_skip_sad_1
+// bit[07:00] force_skip_sad_0
+#define   ME_F_SKIP_SAD                            (0x1f53)
+#define P_ME_F_SKIP_SAD                            (volatile unsigned int *)((0x1f53  << 2) + 0xff620000)
+// bit[31:24] force_skip_weight_3
+// bit[23:16] force_skip_weight_2
+// bit[15:08] force_skip_weight_1
+// bit[07:00] force_skip_weight_0
+#define   ME_F_SKIP_WEIGHT                         (0x1f54)
+#define P_ME_F_SKIP_WEIGHT                         (volatile unsigned int *)((0x1f54  << 2) + 0xff620000)
+// Merge when (
+//              (flex & me_merge_flex_en) |
+//              (big_sad & me_merge_sad_en)|
+//              ((~me_merge_flex_en)&(~me_merge_sad_en))
+//            ) &
+//            ( small_mv_diff |(~me_merge_small_mv_en))
+//            & (me_merge_flex_en | me_merge_sad_en | me_merge_small_mv_en)
+// bit[31]   me_merge_mv_en_16
+// bit[30]   me_merge_small_mv_en_16
+// bit[29]   me_merge_flex_en_16
+// bit[28]   me_merge_sad_en_16
+// bit[27]   me_merge_mv_en_8
+// bit[26]   me_merge_small_mv_en_8
+// bit[25]   me_merge_flex_en_8
+// bit[24]   me_merge_sad_en_8
+// bit[23:18] me_merge_mv_diff_16
+// bit[17:12] me_merge_mv_diff_8
+// bit[11:0] me_merge_min_sad
+#define   ME_MV_MERGE_CTL                          (0x1f55)
+#define P_ME_MV_MERGE_CTL                          (volatile unsigned int *)((0x1f55  << 2) + 0xff620000)
+// bit[31:24] mv_step_weight_1
+// bit[23:16] mv_pre_weight_1
+// bit [15:0] mv_step_weight_0
+// bit[7:0]   mv_pre_weight_0
+#define   ME_MV_WEIGHT_01                          (0x1f56)
+#define P_ME_MV_WEIGHT_01                          (volatile unsigned int *)((0x1f56  << 2) + 0xff620000)
+// bit[31:24] mv_step_weight_3 (mv_step_weight_1_2nd)
+// bit[23:16] mv_pre_weight_3 (mv_pre_weight_1_2nd)
+// bit[15:8]  mv_step_weight_2
+// bit[7:0]   mv_pre_weight_2
+#define   ME_MV_WEIGHT_23                          (0x1f57)
+#define P_ME_MV_WEIGHT_23                          (volatile unsigned int *)((0x1f57  << 2) + 0xff620000)
+// bit[31:24] me_sad_range_inc_3
+// bit[23:16] me_sad_range_inc_2
+// bit[15:8] me_sad_range_inc_1
+// bit[7:0] me_sad_range_inc_0
+#define   ME_SAD_RANGE_INC                         (0x1f58)
+#define P_ME_SAD_RANGE_INC                         (volatile unsigned int *)((0x1f58  << 2) + 0xff620000)
+// bit[31:19]  reserved
+// bit[18]     sub_relative_any_1_en
+// bit[17]     sub_relative_any_2_en
+// bit[16]     sub_relative_any_3_en
+// bit[15]     sub_relative_any_4_en
+// bit[14]     sub_relative_any_h_en
+// bit[13]     sub_make_non_flex_fix
+// bit[12]     sub_make_big_non_flex_fix
+// bit[11:8]   sub_normal_mv_diff_16
+// bit[7:4]    sub_normal_mv_diff_8
+// bit[3:2]    Reserved
+// bit[1]      sub_merge_enable_16
+// bit[0]      sub_merge_enable_8
+#define   ME_SUB_MERGE_CTL                         (0x1f59)
+#define P_ME_SUB_MERGE_CTL                         (volatile unsigned int *)((0x1f59  << 2) + 0xff620000)
+// bit[31:28]  sub_ref_mv_diff_near
+// bit[27:24]  sub_ref_mv_diff_near_flex
+// bit[23:20]  sub_ref_mv_diff
+// bit[19:16]  sub_ref_mv_diff_flex
+// bit[15:8]   sub_ref_mv_near_weight
+// bit[7:0]    sub_ref_mv_weight
+#define   ME_SUB_REF_MV_CTL                        (0x1f5a)
+#define P_ME_SUB_REF_MV_CTL                        (volatile unsigned int *)((0x1f5a  << 2) + 0xff620000)
+// bit[31:24]  sub_weight_max_sad
+// bit[23:16]  sub_any_range_sad
+// bit[15:8]   sub_any_min_sad
+// bit[7:0]    sub_any_max_sad
+#define   ME_SUB_ANY_WEIGHT_SAD                    (0x1f5b)
+#define P_ME_SUB_ANY_WEIGHT_SAD                    (volatile unsigned int *)((0x1f5b  << 2) + 0xff620000)
+// bit[31:24]  sub_fix_sad
+// bit[23:16]  sub_fix_diff_sad
+// bit[15:8]   sub_sad_flex_adj
+// bit[7:0]    sub_big_non_flex_fix_sad
+#define   ME_SUB_FIX_SAD                           (0x1f5c)
+#define P_ME_SUB_FIX_SAD                           (volatile unsigned int *)((0x1f5c  << 2) + 0xff620000)
+// bit[31:24]  sub_fix_min_sad
+// bit[23:16]  sub_fix_min_diff_sad
+// bit[15:8]   sub_fix_min_sad_2
+// bit[7:0]    sub_fix_min_diff_sad_2
+#define   ME_SUB_FIX_MIN_SAD                       (0x1f5d)
+#define P_ME_SUB_FIX_MIN_SAD                       (volatile unsigned int *)((0x1f5d  << 2) + 0xff620000)
+// bit[31:24]  sub_snap_to_ref_max_sad
+// bit[23]     sub_snap_to_ref_non_flex
+// bit[22:16]  sub_snap_to_ref_mv_diff
+// bit[15:4]   sub_glitch_mv_sad
+// bit[3:0]    sub_glitch_mv_diff
+#define   ME_SUB_SNAP_GLITCH                       (0x1f5e)
+#define P_ME_SUB_SNAP_GLITCH                       (volatile unsigned int *)((0x1f5e  << 2) + 0xff620000)
+// bit[31:20]  sad_act_limit
+// bit[19:8]   s_a_any_sad
+// bit[7]      Reserved
+// bit[6:5]    sub_merge_method
+// bit[4]      use_sub_act_result
+// bit[3]      s_a_rnd
+// bit[2]      Reserved
+// bit[1]      sub_act_en_16
+// bit[0]      sub_act_en
+#define   ME_SUB_ACT_CTL                           (0x1f5f)
+#define P_ME_SUB_ACT_CTL                           (volatile unsigned int *)((0x1f5f  << 2) + 0xff620000)
+// bit[31:16]  reserved
+// bit[15:0]   me_weight
+#define   ME_WEIGHT                                (0x1f60)
+#define P_ME_WEIGHT                                (volatile unsigned int *)((0x1f60  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_0
+// bit[21]  ie_sad_ready_0
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_0
+// bit[15:0] me_sad_0
+#define   ME_SAD_0                                 (0x1f61)
+#define P_ME_SAD_0                                 (volatile unsigned int *)((0x1f61  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_1
+// bit[21]  me_sad_ready_1
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_1
+// bit[15:0] me_sad_1
+#define   ME_SAD_1                                 (0x1f62)
+#define P_ME_SAD_1                                 (volatile unsigned int *)((0x1f62  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_2
+// bit[21]  me_sad_ready_2
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_2
+// bit[15:0] me_sad_2
+#define   ME_SAD_2                                 (0x1f63)
+#define P_ME_SAD_2                                 (volatile unsigned int *)((0x1f63  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_3
+// bit[21]  me_sad_ready_3
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_3
+// bit[15:0] me_sad_3
+#define   ME_SAD_3                                 (0x1f64)
+#define P_ME_SAD_3                                 (volatile unsigned int *)((0x1f64  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_0
+// bit[21]  ie_sad_ready_0
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_0
+#define   IE_SAD_0                                 (0x1f65)
+#define P_IE_SAD_0                                 (volatile unsigned int *)((0x1f65  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_1
+// bit[21]  ie_sad_ready_1
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_1
+#define   IE_SAD_1                                 (0x1f66)
+#define P_IE_SAD_1                                 (volatile unsigned int *)((0x1f66  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_2
+// bit[21]  ie_sad_ready_2
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_2
+#define   IE_SAD_2                                 (0x1f67)
+#define P_IE_SAD_2                                 (volatile unsigned int *)((0x1f67  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_3
+// bit[21]  ie_sad_ready_3
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_3
+#define   IE_SAD_3                                 (0x1f68)
+#define P_IE_SAD_3                                 (volatile unsigned int *)((0x1f68  << 2) + 0xff620000)
+// bit[31]   enable_large_diff_16x8
+// bit[30]   enable_large_diff_8x16
+// bit[29:16] adv_mv_8x8_weight
+// bit[15:14] reserved
+// bit[13:0] adv_mv_4x4x4_weight
+#define   ADV_MV_CTL0                              (0x1f69)
+#define P_ADV_MV_CTL0                              (volatile unsigned int *)((0x1f69  << 2) + 0xff620000)
+// bit[31:16] adv_mv_16x16_weight
+// bit[15]   enable_large_diff_16x16
+// bit[14:0] adv_mv_16_8_weight
+#define   ADV_MV_CTL1                              (0x1f6a)
+#define P_ADV_MV_CTL1                              (volatile unsigned int *)((0x1f6a  << 2) + 0xff620000)
+#define   ADV_MV_CTL2                              (0x1f6b)
+#define P_ADV_MV_CTL2                              (volatile unsigned int *)((0x1f6b  << 2) + 0xff620000)
+// bit[31]    v3_skip_enable
+// bit[30]    v3_step_1_weight_enable // for step1, will only use pre_weight for block0, only step_weight for block 1,2,3
+// bit[29]    v3_l2_skip_only_use_l2_sad // set to 1 may allow l1 maybe not skip
+// bit[28]    v3_mv_sad_weight_enable
+// bit[27]    v3_ipred_type_enable
+// bit[25:12] force_skip_sad_1
+// bit[11:0]  force_skip_sad_0
+#define   V3_SKIP_CONTROL                          (0x1f6c)
+#define P_V3_SKIP_CONTROL                          (volatile unsigned int *)((0x1f6c  << 2) + 0xff620000)
+// bit[18:16] top_ipred_type_count
+// bit[15:14] Reserved
+// bit[13:12] top_ipred_type_rd_idx
+// bit[11:10] top_ipred_type_wr_idx
+// bit[9]   left_ipred_type_ready
+// bit[8]   top_ipred_type_ready
+// bit[7:6] left_mv_idx
+// bit[5:4] top_mv_idx
+// bit[3] - left_mv_ready
+// bit[2:0] top_mv_ready
+#define   V3_TOP_LEFT_CTL                          (0x1f6d)
+#define P_V3_TOP_LEFT_CTL                          (volatile unsigned int *)((0x1f6d  << 2) + 0xff620000)
+#define   V3_TOP_MV                                (0x1f6e)
+#define P_V3_TOP_MV                                (volatile unsigned int *)((0x1f6e  << 2) + 0xff620000)
+#define   V3_LEFT_MV                               (0x1f6f)
+#define P_V3_LEFT_MV                               (volatile unsigned int *)((0x1f6f  << 2) + 0xff620000)
+// bit[31:30] reserved
+// bit[29:16] v3_skip_weight_1
+// bit[15:12] reserved
+// bit[11:0]  v3_skip_weight_0
+#define   V3_SKIP_WEIGHT                           (0x1f70)
+#define P_V3_SKIP_WEIGHT                           (volatile unsigned int *)((0x1f70  << 2) + 0xff620000)
+// bit[31:28] reserved
+// bit[27:16] v3_l1_f_skip_max_sad
+// bit[15:12] reserved
+// bit[11:0]  v3_l1_skip_max_sad
+#define   V3_L1_SKIP_MAX_SAD                       (0x1f71)
+#define P_V3_L1_SKIP_MAX_SAD                       (volatile unsigned int *)((0x1f71  << 2) + 0xff620000)
+// bit[31:16] force_skip_sad_2
+// bit[15:0]  v3_skip_weight_2
+#define   V3_L2_SKIP_WEIGHT                        (0x1f72)
+#define P_V3_L2_SKIP_WEIGHT                        (volatile unsigned int *)((0x1f72  << 2) + 0xff620000)
+// bit[21:16] v3_mv_sad_table_addr 0-15 table_step_0
+// bit[11:0]  v3_mv_sad
+#define   V3_MV_SAD_TABLE                          (0x1f73)
+#define P_V3_MV_SAD_TABLE                          (volatile unsigned int *)((0x1f73  << 2) + 0xff620000)
+// [31:16] v3_ie_f_zero_sad_i16
+// [15:0]  v3_ie_f_zero_sad_i4
+#define   V3_F_ZERO_CTL_0                          (0x1f74)
+#define P_V3_F_ZERO_CTL_0                          (volatile unsigned int *)((0x1f74  << 2) + 0xff620000)
+// [25]    v3_no_ver_when_top_zero_en
+// [24]    v3_no_hor_when_left_zero_en
+// [23:16] v3_max_I16_H_num    // 0 means no break
+// [15:0]  v3_me_f_zero_sad
+#define   V3_F_ZERO_CTL_1                          (0x1f75)
+#define P_V3_F_ZERO_CTL_1                          (volatile unsigned int *)((0x1f75  << 2) + 0xff620000)
+#define   V3_TOP_INTRA_INFO                        (0x1f76)
+#define P_V3_TOP_INTRA_INFO                        (volatile unsigned int *)((0x1f76  << 2) + 0xff620000)
+#define   V3_LEFT_INTRA_INFO                       (0x1f77)
+#define P_V3_LEFT_INTRA_INFO                       (volatile unsigned int *)((0x1f77  << 2) + 0xff620000)
+// [31:24]  C_ipred_weight_H
+// [23:16]  C_ipred_weight_V
+// [15:8]   I4_ipred_weight_else
+// [7:0]    I4_ipred_weight_most
+#define   V3_IPRED_TYPE_WEIGHT_0                   (0x1f78)
+#define P_V3_IPRED_TYPE_WEIGHT_0                   (volatile unsigned int *)((0x1f78  << 2) + 0xff620000)
+// [31:24]  I16_ipred_weight_DC
+// [23:16]  I16_ipred_weight_H
+// [15:8]   I16_ipred_weight_V
+// [7:0]    C_ipred_weight_DC
+#define   V3_IPRED_TYPE_WEIGHT_1                   (0x1f79)
+#define P_V3_IPRED_TYPE_WEIGHT_1                   (volatile unsigned int *)((0x1f79  << 2) + 0xff620000)
+// [31:16]  v3_left_small_max_me_sad
+// [15:0]   v3_left_small_max_ie_sad
+#define   V3_LEFT_SMALL_MAX_SAD                    (0x1f7a)
+#define P_V3_LEFT_SMALL_MAX_SAD                    (volatile unsigned int *)((0x1f7a  << 2) + 0xff620000)
+// (qr==7) & (qp==15) means force zero block
+// [31:26]  v4_force_q_r_intra
+// [25:20]  v4_force_q_r_inter
+// [19]     v4_force_q_y_enable
+// [18:16]  v4_force_qr_y
+// [15:12]  v4_force_qp_y
+// [11:0]   v4_force_skip_sad
+#define   V4_FORCE_SKIP_CFG                        (0x1f7b)
+#define P_V4_FORCE_SKIP_CFG                        (volatile unsigned int *)((0x1f7b  << 2) + 0xff620000)
+// v5 Complexity // Y(256 pixel per MB) and C(128 pixel per MB)
+// For every 4x4 block, calculate average and Add abs(pixel-average) together
+// bit[31:16] v5_diff_sum_C
+// bit[15:0]  v5_diff_sum_Y
+#define   V5_MB_DIFF_SUM                           (0x1f7c)
+#define P_V5_MB_DIFF_SUM                           (volatile unsigned int *)((0x1f7c  << 2) + 0xff620000)
+// bit[31:24] v5_small_diff_cnt_C
+// bit[23:16] v5_small_diff_C
+// bit[15:8]  v5_small_diff_cnt_Y
+// bit[7:0]   v5_small_diff_Y
+#define   V5_SMALL_DIFF_CNT                        (0x1f7d)
+#define P_V5_SMALL_DIFF_CNT                        (volatile unsigned int *)((0x1f7d  << 2) + 0xff620000)
+// bit[31:29] Reserved
+// bit[28:24] v5_simple_block_cnt // 0 -15 Y 16-23 C
+// bit[23:20] v5_simple_pixel_cnt
+// bit[19:18] v5_simple_dq_wr_ptr
+// bit[17:16] v5_simple_dq_rd_ptr
+// bit[15:12] v5_simple_dq (Read Only)
+// bit[11:8]  v5_simple_me_weight(Read Only)
+// bit[7] v5_use_small_diff_cnt
+// bit[6] v5_simple_mb_inter_all_en
+// bit[5] v5_simple_mb_inter_8x8_en
+// bit[4] v5_simple_mb_inter_16_8_en
+// bit[3] v5_simple_mb_inter_16x16_en
+// bit[2] v5_simple_mb_intra_en
+// bit[1] v5_simple_mb_C_en
+// bit[0] v5_simple_mb_Y_en
+#define   V5_SIMPLE_MB_CTL                         (0x1f7e)
+#define P_V5_SIMPLE_MB_CTL                         (volatile unsigned int *)((0x1f7e  << 2) + 0xff620000)
+// bit[31:28] v5_simple_dq_shift
+// bit[27:24] v5_simple_dq_6(-7 to +7)
+// bit[23:20] v5_simple_dq_5(-7 to +7)
+// bit[19:16] v5_simple_dq_4(-7 to +7)
+// bit[15:12] v5_simple_dq_3(-7 to +7)
+// bit[11:08] v5_simple_dq_2(-7 to +7)
+// bit[07:04] v5_simple_dq_1(-7 to +7)
+// bit[03:00] v5_simple_dq_0(-7 to +7)
+#define   V5_SIMPLE_MB_DQUANT                      (0x1f7f)
+#define P_V5_SIMPLE_MB_DQUANT                      (volatile unsigned int *)((0x1f7f  << 2) + 0xff620000)
+// bit[31:28] v5_simple_me_weight_shift
+// bit[27:24] v5_simple_me_weight_6(-7 to +7)
+// bit[23:20] v5_simple_me_weight_5(-7 to +7)
+// bit[19:16] v5_simple_me_weight_4(-7 to +7)
+// bit[15:12] v5_simple_me_weight_3(-7 to +7)
+// bit[11:08] v5_simple_me_weight_2(-7 to +7)
+// bit[07:04] v5_simple_me_weight_1(-7 to +7)
+// bit[03:00] v5_simple_me_weight_0(-7 to +7)
+#define   V5_SIMPLE_MB_ME_WEIGHT                   (0x1f80)
+#define P_V5_SIMPLE_MB_ME_WEIGHT                   (volatile unsigned int *)((0x1f80  << 2) + 0xff620000)
+//
+// Closing file:  qdct_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC MDEC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_HDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+//`define HCODEC_MC_CTRL_REG         8'h00
+//`define HCODEC_MC_MB_INFO          8'h01
+//`define HCODEC_MC_PIC_INFO         8'h02
+//`define HCODEC_MC_HALF_PEL_ONE     8'h03
+//`define HCODEC_MC_HALF_PEL_TWO     8'h04
+//`define HCODEC_POWER_CTL_MC        8'h05
+//
+//`define HCODEC_MC_CMD			    8'h06
+//`define HCODEC_MC_CTRL0			8'h07
+//`define HCODEC_MC_PIC_W_H  	    8'h08
+//`define HCODEC_MC_STATUS0		    8'h09
+//`define HCODEC_MC_STATUS1		    8'h0a
+//`define HCODEC_MC_CTRL1			8'h0b
+//`define HCODEC_MC_MIX_RATIO0	    8'h0c
+//`define HCODEC_MC_MIX_RATIO1	    8'h0d
+//`define HCODEC_MC_DP_MB_XY  	    8'h0e     //read only
+//`define HCODEC_MC_OM_MB_XY  	    8'h0f     //read only
+//
+//`define HCODEC_MC_MPORT_CTRL  	    8'h40
+//`define HCODEC_MC_MPORT_DAT  	    8'h41
+//`define HCODEC_MC_WT_PRED_CTRL  	8'h42
+//`define HCODEC_MC_MBBOT_ST_EVEN_ADDR 8'h44
+//`define HCODEC_MC_MBBOT_ST_ODD_ADDR 8'h45
+//`define HCODEC_MC_DPDN_MB_XY        8'h46    //read only
+//`define HCODEC_MC_OMDN_MB_XY        8'h47    //read only
+//`define HCODEC_MC_HCMDBUF_H        8'h48
+//`define HCODEC_MC_HCMDBUF_L        8'h49
+//`define HCODEC_MC_HCMD_H           8'h4a     //read only
+//`define HCODEC_MC_HCMD_L           8'h4b     //read only
+//`define HCODEC_MC_IDCT_DAT         8'h4c
+//
+//`define HCODEC_MC_CTRL_GCLK_CTRL   8'h4d
+//`define HCODEC_MC_OTHER_GCLK_CTRL  8'h4e
+//
+////Bit 29:24, mbbot thread ID and token
+////Bit 21:16, mc read/write thread ID and token
+////Bit 13:8,  mbbot pre-arbitor burst number
+////Bit 5:0,   mc pre-arbitor burst number
+//`define HCODEC_MC_CTRL2            8'h4f
+//
+//// `define HCODEC_DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//
+////`define HCODEC_ANC1_CANVAS_ADDR      8'h80
+////`define HCODEC_ANC2_CANVAS_ADDR      8'h81
+//
+////`define HCODEC_REC_CANVAS_ADDR       8'h89
+//
+////`define HCODEC_MDEC_PIC_W          8'h8c
+////`define HCODEC_MDEC_PIC_H          8'h8d
+//`define HCODEC_MDEC_PIC_DC_CTRL    8'h8e
+//`define HCODEC_MDEC_PIC_DC_STATUS  8'h8f
+//
+//`define HCODEC_ANC0_CANVAS_ADDR      8'h90
+//`define HCODEC_ANC1_CANVAS_ADDR      8'h91
+//`define HCODEC_ANC2_CANVAS_ADDR      8'h92
+//`define HCODEC_ANC3_CANVAS_ADDR      8'h93
+//`define HCODEC_ANC4_CANVAS_ADDR      8'h94
+//`define HCODEC_ANC5_CANVAS_ADDR      8'h95
+//`define HCODEC_ANC6_CANVAS_ADDR      8'h96
+//`define HCODEC_ANC7_CANVAS_ADDR      8'h97
+//`define HCODEC_ANC8_CANVAS_ADDR      8'h98
+//`define HCODEC_ANC9_CANVAS_ADDR      8'h99
+//`define HCODEC_ANC10_CANVAS_ADDR     8'h9a
+//`define HCODEC_ANC11_CANVAS_ADDR     8'h9b
+//`define HCODEC_ANC12_CANVAS_ADDR     8'h9c
+//`define HCODEC_ANC13_CANVAS_ADDR     8'h9d
+//`define HCODEC_ANC14_CANVAS_ADDR     8'h9e
+//`define HCODEC_ANC15_CANVAS_ADDR     8'h9f
+//`define HCODEC_ANC16_CANVAS_ADDR     8'ha0
+//`define HCODEC_ANC17_CANVAS_ADDR     8'ha1
+//`define HCODEC_ANC18_CANVAS_ADDR     8'ha2
+//`define HCODEC_ANC19_CANVAS_ADDR     8'ha3
+//`define HCODEC_ANC20_CANVAS_ADDR     8'ha4
+//`define HCODEC_ANC21_CANVAS_ADDR     8'ha5
+//`define HCODEC_ANC22_CANVAS_ADDR     8'ha6
+//`define HCODEC_ANC23_CANVAS_ADDR     8'ha7
+//`define HCODEC_ANC24_CANVAS_ADDR     8'ha8
+//`define HCODEC_ANC25_CANVAS_ADDR     8'ha9
+//`define HCODEC_ANC26_CANVAS_ADDR     8'haa
+//`define HCODEC_ANC27_CANVAS_ADDR     8'hab
+//`define HCODEC_ANC28_CANVAS_ADDR     8'hac
+//`define HCODEC_ANC29_CANVAS_ADDR     8'had
+//`define HCODEC_ANC30_CANVAS_ADDR     8'hae
+//`define HCODEC_ANC31_CANVAS_ADDR     8'haf
+//
+//`define HCODEC_DBKR_CANVAS_ADDR      8'hb0
+//`define HCODEC_DBKW_CANVAS_ADDR      8'hb1
+//`define HCODEC_REC_CANVAS_ADDR       8'hb2
+//
+////28:24, read/write, current canvas idx, used in h264 only now
+////23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+//`define HCODEC_CURR_CANVAS_CTRL      8'hb3
+//
+//`define HCODEC_MDEC_PIC_DC_THRESH    8'hb8
+//`define HCODEC_MDEC_PICR_BUF_STATUS  8'hb9
+//`define HCODEC_MDEC_PICW_BUF_STATUS  8'hba
+//`define HCODEC_MCW_DBLK_WRRSP_CNT    8'hbb
+//
+//`define HCODEC_AV_SCRATCH_0          8'hc0
+//`define HCODEC_AV_SCRATCH_1          8'hc1
+//`define HCODEC_AV_SCRATCH_2          8'hc2
+//`define HCODEC_AV_SCRATCH_3          8'hc3
+//`define HCODEC_AV_SCRATCH_4          8'hc4
+//`define HCODEC_AV_SCRATCH_5          8'hc5
+//`define HCODEC_AV_SCRATCH_6          8'hc6
+//`define HCODEC_AV_SCRATCH_7          8'hc7
+//`define HCODEC_AV_SCRATCH_8          8'hc8
+//`define HCODEC_AV_SCRATCH_9          8'hc9
+//`define HCODEC_AV_SCRATCH_A          8'hca
+//`define HCODEC_AV_SCRATCH_B          8'hcb
+//`define HCODEC_AV_SCRATCH_C          8'hcc
+//`define HCODEC_AV_SCRATCH_D          8'hcd
+//`define HCODEC_AV_SCRATCH_E          8'hce
+//`define HCODEC_AV_SCRATCH_F          8'hcf
+//`define HCODEC_AV_SCRATCH_G          8'hd0
+//`define HCODEC_AV_SCRATCH_H          8'hd1
+//`define HCODEC_AV_SCRATCH_I          8'hd2
+//`define HCODEC_AV_SCRATCH_J          8'hd3
+//`define HCODEC_AV_SCRATCH_K          8'hd4
+//`define HCODEC_AV_SCRATCH_L          8'hd5
+//`define HCODEC_AV_SCRATCH_M          8'hd6
+//`define HCODEC_AV_SCRATCH_N          8'hd7
+//
+//// bit[29:24] A_brst_num_co_mb
+//// bit[21:16] A_id_co_mb
+//// bit[11:0] wrrsp_count_co_mb
+//`define HCODEC_WRRSP_CO_MB           8'hd8
+//// bit[29:24] A_brst_num_dcac
+//// bit[21:16] A_id_dcac
+//// bit[11:0] wrrsp_count_dcac
+//`define HCODEC_WRRSP_DCAC            8'hd9
+//
+////======================================
+////  MC Control Register Bits
+////
+////======================================
+//// For bits, just copy the defines...don't translate to addresses
+//    `define HCODEC_MC_ENABLE	    16'h0001
+//    //`define MC_RESET	    16'h0002
+//    `define HCODEC_SKIP_MB		    16'h0004
+//
+////======================================
+////  MB Info Register Bits
+////
+////======================================
+//    `define HCODEC_INTRA_MB	    16'h0001
+//
+//    `define HCODEC_BWD_PRED	    16'h0004
+//    `define HCODEC_FWD_PRED	    16'h0008
+//
+//    `define HCODEC_FLD_MOT		    16'h0100
+//    `define HCODEC_FRM_16x8_MOT	16'h0200
+//    `define HCODEC_DUAL_PRM_MOT	16'h0300
+//
+//    `define HCODEC_FRM_DCT		    16'h0000	    // Bit 10
+//    `define HCODEC_FLD_DCT		    16'h0400
+//
+////======================================
+////  MB Info Register Bits
+////
+////======================================
+//    `define HCODEC_I_PIC		    16'h0001
+//    `define HCODEC_P_PIC		    16'h0002
+//    `define HCODEC_B_PIC		    16'h0003
+//
+//    `define HCODEC_FLD_PIC		    16'h0000	    // Bit 8
+//    `define HCODEC_FRM_PIC		    16'h0100
+//
+////========================================================================
+//// DBLK Register:  12'h950 - 12'h97f
+////========================================================================
+//`define HCODEC_DBLK_RST                8'h50
+//`define HCODEC_DBLK_CTRL               8'h51
+//`define HCODEC_DBLK_MB_WID_HEIGHT      8'h52
+//`define HCODEC_DBLK_STATUS             8'h53
+//`define HCODEC_DBLK_CMD_CTRL           8'h54
+//`define HCODEC_DBLK_MB_XY              8'h55
+//`define HCODEC_DBLK_QP                 8'h56
+//`define HCODEC_DBLK_Y_BHFILT           8'h57
+//`define HCODEC_DBLK_Y_BHFILT_HIGH      8'h58
+//`define HCODEC_DBLK_Y_BVFILT           8'h59
+//`define HCODEC_DBLK_CB_BFILT           8'h5a
+//`define HCODEC_DBLK_CR_BFILT           8'h5b
+//`define HCODEC_DBLK_Y_HFILT            8'h5c
+//`define HCODEC_DBLK_Y_HFILT_HIGH       8'h5d
+//`define HCODEC_DBLK_Y_VFILT            8'h5e
+//`define HCODEC_DBLK_CB_FILT            8'h5f
+//`define HCODEC_DBLK_CR_FILT            8'h60
+//`define HCODEC_DBLK_BETAX_QP_SEL       8'h61
+//`define HCODEC_DBLK_CLIP_CTRL0         8'h62
+//`define HCODEC_DBLK_CLIP_CTRL1         8'h63
+//`define HCODEC_DBLK_CLIP_CTRL2         8'h64
+//`define HCODEC_DBLK_CLIP_CTRL3         8'h65
+//`define HCODEC_DBLK_CLIP_CTRL4         8'h66
+//`define HCODEC_DBLK_CLIP_CTRL5         8'h67
+//`define HCODEC_DBLK_CLIP_CTRL6         8'h68
+//`define HCODEC_DBLK_CLIP_CTRL7         8'h69
+//`define HCODEC_DBLK_CLIP_CTRL8         8'h6a
+//
+//`define HCODEC_DBLK_STATUS1            8'h6b
+//`define HCODEC_DBLK_GCLK_FREE          8'h6c
+//`define HCODEC_DBLK_GCLK_OFF           8'h6d
+//
+//`define HCODEC_DBLK_AVSFLAGS           8'h6e
+//
+//// bit 15:0
+//`define HCODEC_DBLK_CBPY               8'h70
+//// bit 11:8 -- deblk_cbpy_bottom
+//// bit 7:4 -- deblk_cbpy_left
+//// bit 3:0 -- deblk_cbpy_top
+//`define HCODEC_DBLK_CBPY_ADJ           8'h71
+//// bit 7:0 -- deblk_cbpc
+//`define HCODEC_DBLK_CBPC               8'h72
+//// bit 15 -- bottom_mb
+//// bit 14 -- left_mb
+//// bit 13 -- top_mb
+//// bit 12 -- reserved
+//// bit 11:8 -- deblk_cbpc_bottom
+//// bit 7:4 -- deblk_cbpc_left
+//// bit 3:0 -- deblk_cbpc_top
+//`define HCODEC_DBLK_CBPC_ADJ           8'h73
+//// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0}
+//// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0}
+//`define HCODEC_DBLK_VHMVD              8'h74
+//// bit 13:12 -- right_vmvd
+//// bit 11 -- right_above_vmvd
+//// bit 10 -- left_below_hmvd
+//// bit 9 -- disable_dblk_luma
+//// bit 8 -- disable_dblk_chroma
+//// bit 7 -- bBelowRefDiff
+//// bit 6 -- bLeftRefDiff
+//// bit 5 -- bAboveRefDiff
+//// bit 4 -- reserved
+//// bit 3 -- s_below
+//// bit 2 -- s_left
+//// bit 1 -- s_above
+//// bit 0 -- s
+//`define HCODEC_DBLK_STRONG             8'h75
+//// bit 14:10 -- PQUANT
+//// bit 9:5 -- left_PQUANT
+//// bit 4:0 -- top_PQUANT
+//`define HCODEC_DBLK_RV8_QUANT          8'h76
+//
+//`define HCODEC_DBLK_CBUS_HCMD2         8'h77
+//`define HCODEC_DBLK_CBUS_HCMD1         8'h78
+//`define HCODEC_DBLK_CBUS_HCMD0         8'h79
+//`define HCODEC_DBLK_VLD_HCMD2          8'h7a
+//`define HCODEC_DBLK_VLD_HCMD1          8'h7b
+//`define HCODEC_DBLK_VLD_HCMD0          8'h7c
+//
+//`define HCODEC_DBLK_OST_YBASE          8'h7d
+//`define HCODEC_DBLK_OST_CBCRDIFF       8'h7e
+//
+////13:8 dblk thread ID and token
+////5:0  dblk prearbitor burst num
+//`define HCODEC_DBLK_CTRL1              8'h7f
+//
+////DBLK last address 12'h97f
+//
+// Closing file:  hcodec_mdec_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC VLD module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+//
+//`define HCODEC_VLD_STATUS_CTRL     8'h00
+////
+//// bit 10 -- use_old_shift_en
+//// bit 9 -- output_mv_not_pmv
+//// bit 8:5 -- force_zigzag
+//// bit 4 -- force_zigzag_en
+//// bit 3 -- disable_viff_anempty_int
+//// bit 2 -- disable_m2_ac_coeff_one_cycle
+//// bit 1 -- forced_reset  force reset pmv
+//// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+//`define HCODEC_MPEG1_2_REG         8'h01
+//`define HCODEC_F_CODE_REG          8'h02
+//`define HCODEC_PIC_HEAD_INFO       8'h03
+//`define HCODEC_SLICE_VER_POS_PIC_TYPE  8'h04
+//`define HCODEC_QP_VALUE_REG        8'h05
+//`define HCODEC_MBA_INC             8'h06
+//`define HCODEC_MB_MOTION_MODE      8'h07
+////`define HCODEC_PACKET_BYTE_COUNT   8'h08
+//// bit 15 -- force_search_startcode_en
+//// bit 14 -- int_cpu_when_error (before do anything)
+//// bit 13 -- vld_error_reset
+//// bit 12 -- return_on_slice_header
+//// bit 6 -- jpeg_ff00_en
+//// bit 5:0 -- vld_power_ctl
+//`define HCODEC_POWER_CTL_VLD       8'h08
+//
+//`define HCODEC_MB_WIDTH	    8'h09
+//`define HCODEC_SLICE_QP            8'h0a
+//// `define HCODEC_MB_X_MB_Y           8'h0b   // current MBX and MBY
+//`define HCODEC_PRE_START_CODE      8'h0b  // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define HCODEC_SLICE_START_BYTE_01 8'h0c  // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define HCODEC_SLICE_START_BYTE_23 8'h0d  // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define HCODEC_RESYNC_MARKER_LENGTH 8'h0e  // Does this exist in HW ? used in $ucode/mpeg4
+//
+//// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+//// bit[4:0] - buffer ID
+//// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+//`define HCODEC_DECODER_BUFFER_INFO  8'h0f  // Current Only Used for VC1 Interlace Field
+//
+//`define HCODEC_FST_FOR_MV_X        8'h10
+//`define HCODEC_FST_FOR_MV_Y        8'h11
+//`define HCODEC_SCD_FOR_MV_X        8'h12
+//`define HCODEC_SCD_FOR_MV_Y        8'h13
+//`define HCODEC_FST_BAK_MV_X        8'h14
+//`define HCODEC_FST_BAK_MV_Y        8'h15
+//`define HCODEC_SCD_BAK_MV_X        8'h16
+//`define HCODEC_SCD_BAK_MV_Y        8'h17
+//
+//// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+//// bit 3 -- reserved
+//// bit 2 -- weighting_prediction
+//// bit 1 -- mb_weighting_flag
+//// bit 0 -- slice_weighting_flag
+//`define HCODEC_VLD_DECODE_CONTROL  8'h18
+//`define HCODEC_VLD_REVERVED_19     8'h19
+//
+//`define HCODEC_VIFF_BIT_CNT        8'h1a
+//`define HCODEC_BYTE_ALIGN_PEAK_HI  8'h1b
+//`define HCODEC_BYTE_ALIGN_PEAK_LO  8'h1c
+//`define HCODEC_NEXT_ALIGN_PEAK     8'h1d  // Does this exist in HW ? used in $ucode/mpeg4
+//
+//// bit 19    : vc1_inv_intra_co_mb_ref_rd
+//// bit 18    : vc1_inv_co_mb_ref_rd
+//// bit 17    : vc1_inv_intra_co_mb_ref_wr
+//// bit 16    : vc1_inv_co_mb_ref_wr
+//// bit 15    : reserved
+//// bit 14    : avs_drop_enable
+//// bit 13:12 : avs_drop_ptr
+//// bit 11:8  : avs_demu_ctl_reg
+//// bit 7 : avs_enable
+//// bit 6 : disable_dblk_hcmd
+//// bit 5 : disable_mc_hcmd
+//// bit 4 : first_mode3_set enable
+//// bit 3 : first_mode3
+//// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+//// bit 0   : vc1_enable
+//`define HCODEC_VC1_CONTROL_REG     8'h1e
+//
+//`define HCODEC_PMV1_X              8'h20
+//`define HCODEC_PMV1_Y              8'h21
+//`define HCODEC_PMV2_X              8'h22
+//`define HCODEC_PMV2_Y              8'h23
+//`define HCODEC_PMV3_X              8'h24
+//`define HCODEC_PMV3_Y              8'h25
+//`define HCODEC_PMV4_X              8'h26
+//`define HCODEC_PMV4_Y              8'h27
+//// Can't use the same address for different defines
+//// Therefore, create a single define HCODEC_that covers both
+//// Only appears to be used in micro-code since the VLD hardware is
+//// hard coded.
+//// `define HCODEC_M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+//// `define HCODEC_M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_M4_TABLE_SELECT     8'h28
+//`define HCODEC_M4_CONTROL_REG      8'h29
+//`define HCODEC_BLOCK_NUM           8'h2a  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_PATTERN_CODE        8'h2b  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_MB_INFO             8'h2c  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_VLD_DC_PRED         8'h2d  // Does this exist in HW ? Added from register_mp4.h
+//`define HCODEC_VLD_ERROR_MASK      8'h2e
+//`define HCODEC_VLD_DC_PRED_C       8'h2f  // Does this exist in HW ? Added from register_mp4.h
+//
+//`define HCODEC_LAST_SLICE_MV_ADDR  8'h30
+//`define HCODEC_LAST_MVX            8'h31
+//`define HCODEC_LAST_MVY            8'h32
+//
+//`define HCODEC_VLD_C38             8'h38
+//`define HCODEC_VLD_C39             8'h39
+//
+//`define HCODEC_VLD_STATUS          8'h3a  // Does this exist in HW ? used in $ucode/real/amrisc/rv.s
+//`define HCODEC_VLD_SHIFT_STATUS    8'h3b  // Does this exist in HW ? used in $ucode/real/amrisc/rv.s
+//// `define HCODEC_VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+//`define HCODEC_VOFF_STATUS         8'h3c  // Does this exist in HW ? used in $ucode/mpeg4
+//
+//`define HCODEC_VLD_C3D             8'h3d
+//
+//`define HCODEC_VLD_DBG_INDEX       8'h3e
+//
+//
+//// vld_buff_info -- (index == 0)
+//// Bit[7:6]  mv_UR_ready_cnt;
+//// Bit[5]  vld_wr_idx
+//// Bit[4]  iq_rd_idx
+//// Bit[3]  vld_vi_block_rdy_1
+//// Bit[2]  vld_vi_block_rdy_2
+//// Bit[1]  voff_empty_1
+//// Bit[0]  voff_empty_2
+//
+//// cabac_buff_info_0 -- (index == 1)
+//// Bit[31] shift_data_ready
+//// Bit[30:29] Reserved
+//// Bit[28:24] cabac_buffer_ptr
+//// Bit[23:0] cabac_buffer
+//
+//// cabac_buff_info_1 -- (index == 2)
+//// Bit[31:29] Reserved
+//// Bit[28:20] Drange
+//// Bit[19:16] bin_count_4
+//// Bit[15:13] Reserved
+//// Bit[12:6] context_mem_do
+//// Bit[5:3] coeff_state
+//// Bit[2:0] mvd_state
+//
+//// h264_mv_present -- (index == 3)
+//// Bit[31:16] mv_present_l0
+//// Bit[15:0] mv_present_l1
+//
+//// h264_mv_cal_info_0 -- (index == 4)
+//// [31:28] mv_cal_state
+//// [27:24] direct_spatial_cnt
+//// Bit[23:21] Reserved
+//// Bit[20] mv_UR_ready_for_mv_cal
+//// Bit[19] co_mb_mem_ready_for_mv_cal
+//// Bit[18] mc_dblk_cmd_if_busy
+//// Bit[17] h264_co_mb_wr_busy
+//// Bit[16] H264_cbp_blk_ready
+//// Bit[15] mc_hcmd_rrdy
+//// Bit[14] mc_hcmd_srdy
+//// Bit[13] mc_cmd_if_ready
+//// Bit[12] mc_hcmd_mv_available
+//// Bit[11:8] mc_cmd_if_state
+//// Bit[7] dblk_hcmd_rrdy
+//// Bit[6] dblk_hcmd_srdy
+//// Bit[5] dblk_cmd_if_ready
+//// Bit[4] dblk_hcmd_mv_available
+//// Bit[3:0] dblk_cmd_if_state
+//
+//// h264_mv_cal_info_1 -- (index == 5)
+////  Bit[31:29] Reserved
+////  Bit[28:24] total_mvd_num_l0
+////  Bit[23:21] Reserved
+////  Bit[20:16] mv_cal_ptr_l0
+////  Bit[15:13] Reserved
+////  Bit[12:8] mc_hcmd_ptr_l0
+////  Bit[7:5] Reserved
+////  Bit[4:0] dblk_hcmd_ptr_l0
+//
+//// h264_mv_cal_info_2 -- (index == 6)
+////  Bit[31:29] Reserved
+////  Bit[28:24] total_mvd_num_l1
+////  Bit[23:21] Reserved
+////  Bit[20:16] mv_cal_ptr_l1
+////  Bit[15:13] Reserved
+////  Bit[12:8] mc_hcmd_ptr_l1
+////  Bit[7:5] Reserved
+////  Bit[4:0] dblk_hcmd_ptr_l1
+//
+//// h264_co_mb_info -- (index == 7)
+//// Bit[31:26] Reserved
+//// Bit[25] mv_scale_cal_busy
+//// Bit[24:20] co_mv_count
+//// Bit[19:16] co_mv_process_state
+//// Bit[15] h264_co_mb_rd_busy
+//// Bit[15] h264_co_mb_rd_ready
+//// Bit[13:12] co_mv_transfer_block_cnt
+//// Bit[11:8] co_mv_transfer_ptr
+//// Bit[7] co_mv_POC_l1_busy
+//// Bit[6] h264_weight_scale_cal_en
+//// Bit[5] weight_cal_busy
+//// Bit[4] weight_cal_not_finished
+//// Bit[3:0] weight_process_state
+//
+//`define HCODEC_VLD_DBG_DATA        8'h3f
+//// --------------------------------------------
+//// VIFIFO DDR Interface
+//// --------------------------------------------
+//// The VIFIFO start pointer into DDR memory is a 32-bit number
+//// The Start pointer will automatically be truncated to land on
+//// an 8-byte boundary.  That is, bits [2:0] = 0;
+//`define HCODEC_VLD_MEM_VIFIFO_START_PTR        8'h40
+//// The current pointer points so some location between the START and END
+//// pointers.  The current pointer is a BYTE pointer.  That is, you can
+//// point to any BYTE address within the START/END range
+//`define HCODEC_VLD_MEM_VIFIFO_CURR_PTR         8'h41
+//`define HCODEC_VLD_MEM_VIFIFO_END_PTR          8'h42
+//`define HCODEC_VLD_MEM_VIFIFO_BYTES_AVAIL      8'h43
+//// VIFIFO FIFO Control
+//// bit  [31:24] viff_empty_int_enable_cpu[7:0]
+//// bit  [23:16] viff_empty_int_enable_amrisc[7:0]
+////   -bit 23 Video BUFFER < 0x400 Bytes
+////   -bit 22 Video BUFFER < 0x200 Bytes
+////   -bit 21 Video BUFFER < 0x100 Bytes
+////   -bit 20 Video BUFFER < 0x80 Bytes
+////   -bit 19 Video BUFFER < 0x40 Bytes
+////   -bit 18 Video BUFFER < 0x20 Bytes
+////   -bit 17 vififo  < 16 double words
+////   -bit 16 vififo  < 8 double words
+//// bit  [15:13] unused
+//// bit  [12]    A_urgent
+//// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+//// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+////                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+//// bit  [9]     Data Ready.     This bit is set when data can be popped
+//// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+////                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+////                              After that you can pulse cntl_init to start over
+//// bit  [7]     init_with_cntl_init
+//// bit  [6]     reserved
+//// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+//// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+////                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+//// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+//// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+////                              and read masks, set this bit to 1 and then to 0
+////                              NOTE:  You don't need to pulse cntl_init if only the start address is
+////                              being changed
+//`define HCODEC_VLD_MEM_VIFIFO_CONTROL         8'h44
+//// --------------------------------------------
+//// VIFIFO Buffer Level Manager
+//// --------------------------------------------
+//`define HCODEC_VLD_MEM_VIFIFO_WP              8'h45 // Manual or Parser write pointer
+//`define HCODEC_VLD_MEM_VIFIFO_RP              8'h46
+//`define HCODEC_VLD_MEM_VIFIFO_LEVEL           8'h47 // must be low first to shadow low/high 16-bit words
+////
+//// bit  [8]     use_parser_video2_wp
+//// bit  [7]     vbuf2_out_manual
+//// bit  [6]     vbuf_out_manual
+//// bit  [5]     empty (ReadOnly)
+//// bit  [4]     full (ReadOnly)
+//// bit  [3:2]   reserved
+//// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+//// bit  [0]     Init            Set high then low after everything has been initialized
+//`define HCODEC_VLD_MEM_VIFIFO_BUF_CNTL        8'h48
+//
+//// bit 31:16 -- drop_bytes
+//// bit 15:14 -- drop_status (Read-Only)
+//// bit 13:12 -- sync_match_position (Read-Only)
+//// bit 11:6 -- reserved
+//// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+//// bit 3 -- stamp_soft_reset
+//// bit 2 -- TIME_STAMP_length_enable
+//// bit 1 -- TIME_STAMP_sync64_enable
+//// bit 0 -- TIME_STAMP_enable
+//`define HCODEC_VLD_TIME_STAMP_CNTL            8'h49
+//// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+//`define HCODEC_VLD_TIME_STAMP_SYNC_0          8'h4a
+//// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+//`define HCODEC_VLD_TIME_STAMP_SYNC_1          8'h4b
+//// bit 31:0 TIME_STAMP_0
+//`define HCODEC_VLD_TIME_STAMP_0               8'h4c
+//// bit 31:0 TIME_STAMP_1
+//`define HCODEC_VLD_TIME_STAMP_1               8'h4d
+//// bit 31:0 TIME_STAMP_2
+//`define HCODEC_VLD_TIME_STAMP_2               8'h4e
+//// bit 31:0 TIME_STAMP_3
+//`define HCODEC_VLD_TIME_STAMP_3               8'h4f
+//// bit 31:0 TIME_STAMP_LENGTH
+//`define HCODEC_VLD_TIME_STAMP_LENGTH          8'h50
+//
+//// bit 15:0 vififo_rd_count
+//`define HCODEC_VLD_MEM_VIFIFO_WRAP_COUNT      8'h51
+//
+//// bit 29:24 A_brst_num
+//// bit 21:16 A_id
+//// bit 15:0 level_hold
+//`define HCODEC_VLD_MEM_VIFIFO_MEM_CTL         8'h52
+//
+//`define HCODEC_VLD_MEM_VBUF_RD_PTR            8'h53 // manual read address for VBUF1
+//`define HCODEC_VLD_MEM_VBUF2_RD_PTR           8'h54 // manual read address for VBUF2
+//
+//`define HCODEC_VLD_MEM_SWAP_ADDR              8'h55
+//// bit[23:16] - swap_d_count (Read Only)
+//// bit[15:8]  - swap_a_count (Read Only)
+//// bit [7] - swap busy (Read Only)
+//// bit [6:2] - reserved
+//// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+//// bit [0] - swap active
+//`define HCODEC_VLD_MEM_SWAP_CTL               8'h56
+//
+// Closing file:  hcodec_vld_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC IQIDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+//
+//`define HCODEC_VCOP_CTRL_REG       8'h00
+//`define HCODEC_QP_CTRL_REG         8'h01
+//`define HCODEC_INTRA_QUANT_MATRIX  8'h02
+//`define HCODEC_NON_I_QUANT_MATRIX  8'h03
+//`define HCODEC_DC_SCALER           8'h04
+//`define HCODEC_DC_AC_CTRL          8'h05
+//// `define HCODEC_RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+//`define HCODEC_DC_AC_SCALE_MUL     8'h06
+//`define HCODEC_DC_AC_SCALE_DIV     8'h07
+//// `define HCODEC_DC_AC_SCALE_RESULT  8'h06
+//// `define HCODEC_RESERVED_E07        8'h07
+//`define HCODEC_POWER_CTL_IQIDCT    8'h08
+//`define HCODEC_RV_AI_Y_X           8'h09
+//`define HCODEC_RV_AI_U_X           8'h0a
+//`define HCODEC_RV_AI_V_X           8'h0b
+//// bit 15:0 will count up when rv_ai_mb finished when non zero
+//// and rv_ai_mb_finished_int will be generate when this is not zero
+//`define HCODEC_RV_AI_MB_COUNT      8'h0c
+//// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+//`define HCODEC_NEXT_INTRA_DMA_ADDRESS 8'h0d
+//// Bit 0 -- constrained_intra_pred_flag for H264
+//`define HCODEC_IQIDCT_CONTROL         8'h0e
+//
+//
+//// Bit[31:19] Reserved
+//// Bit[18] iq_waiting
+//// Bit[17] iq_om_wr_idx
+//// Bit[16] iq_om_rd_idx
+//// Bit[15] iq_om_busy
+//// Bit[14] iq_om_2_busy
+//// Bit[13] idx_fifo_0
+//// Bit[12] idx_fifo_1
+//// Bit[11] idx_fifo_2
+//// Bit[10] idx_fifo_3
+//// Bit[9] idx_fifo_4
+//// Bit[8] idx_fifo_5
+//// Bit[7] idx_fifo_6
+//// Bit[6] idx_fifo_7
+//// Bit[5:3] idx_fifo_wp
+//// Bit[2:0] idx_fifo_rp
+//
+//`define HCODEC_IQIDCT_DEBUG_INFO_0    8'h0f
+//
+//// For RTL Simulation Only
+//`define HCODEC_DEBLK_CMD              8'h10
+//
+//// Bit[15+16] ds_mc_valid_2
+//// Bit[14+16] new_idct1_rd_idx_2
+//// Bit[13+16] new_idct1_wr_idx_2
+//// Bit[12+16] idct1_buff0_busy_2
+//// Bit[11+16] idct1_buff1_busy_2
+//// Bit[10+16] new_idct1_busy_2
+//// Bit[9+16] iq_om_8val_2
+//// Bit[8+16] idct1_pipe_busy_2
+//
+//// Bit[7+16] wait_mb_left_finish_hold_2
+//// Bit[6+16] new_idct2_rd_idx_2
+//// Bit[5+16] new_idct2_wr_idx_2
+//// Bit[4+16] idct2_buff0_busy_2
+//// Bit[3+16] idct2_buff1_busy_2
+//// Bit[2+16] idct2_en_2
+//// Bit[1+16] new_idct2_busy_2
+//// Bit[0+16] new_idct1_ready_2
+//
+//// Bit[15] ds_mc_valid_1
+//// Bit[14] new_idct1_rd_idx_1
+//// Bit[13] new_idct1_wr_idx_1
+//// Bit[12] idct1_buff0_busy_1
+//// Bit[11] idct1_buff1_busy_1
+//// Bit[10] new_idct1_busy_1
+//// Bit[9] iq_om_8val_1
+//// Bit[8] idct1_pipe_busy_1
+//
+//// Bit[7] wait_mb_left_finish_hold_1
+//// Bit[6] new_idct2_rd_idx_1
+//// Bit[5] new_idct2_wr_idx_1
+//// Bit[4] idct2_buff0_busy_1
+//// Bit[3] idct2_buff1_busy_1
+//// Bit[2] idct2_en_1
+//// Bit[1] new_idct2_busy_1
+//// Bit[0] new_idct1_ready_1
+//
+//`define HCODEC_IQIDCT_DEBUG_IDCT      8'h11
+//
+//
+//
+//// bit 31 -- convas_enable
+//// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+//// bit 23:16 -- convas_y_count
+//// bit 15   -- dcac_dma_busy
+//// bit 14   -- dcac_dma_urgent
+//// bit 13:8 -- dcac_dma_count
+//// bit 7    -- dcac_dma_rw
+//// bit 6    -- dcac_skip_read_mode
+//// bit 5:0  -- dcac_dma_offset
+//`define HCODEC_DCAC_DMA_CTRL        8'h12
+//// when (convas_enable == 0 )
+////   bit 31:0 dcac_dma_addr
+//// when (convas_enable == 1 )
+////   bit 31:25 canvas_addr (7 bits)
+////   bit 24:12 convas_y_start ( 13 btis )
+////   bit 11:0  convas_x_start ( 12 btis )
+//`define HCODEC_DCAC_DMA_ADDRESS     8'h13
+//// bit 7:0 -- dcac_cpu_addr
+//`define HCODEC_DCAC_CPU_ADDRESS     8'h14
+//// bit 31:0 -- dcac_cpu_data
+//`define HCODEC_DCAC_CPU_DATA        8'h15
+//
+//// bit 31:19 -- reserved
+//// bit 18:16 -- block_num_reg -- Read-Only
+//// bit 15:0 -- dcac_mb_count
+//`define HCODEC_DCAC_MB_COUNT        8'h16
+//
+//// bit 31:18 -- reserved
+//// For H264 :
+////   bit 17:2 -- h264_quant
+////   bit 11:6 -- h264_quant_c
+////   bit  5:0 -- h264_quant_c
+//// For VC1 :
+////   bit    17 -- qindex_GT_8
+////   bit    16 -- HalfQPStep
+////   bit 15:12 -- eQuantMode
+////   bit 11:6  -- AltPQuant
+////   bit  5:0  -- PQuant
+////
+//`define HCODEC_IQ_QUANT             8'h17
+//
+//// bit 31:24  -- bitplane_width
+//// bit 23:16  -- bitplane_height
+//// bit 15:14  -- bitplane_start_x
+//// bit 13:12  -- bitplane_start_y
+//// bit 11:4   -- reserved
+//// bit 3:1    -- bitplane_type
+//// bit 0      -- bitplane_busy
+//`define HCODEC_VC1_BITPLANE_CTL     8'h18
+//
+//
+//
+//    `define HCODEC_RAM_TEST_CMD        12'h002
+//    `define HCODEC_RAM_TEST_ADDR       12'h003
+//    `define HCODEC_RAM_TEST_DATAH      12'h004
+//    `define HCODEC_RAM_TEST_DATAL      12'h005
+//
+//    `define HCODEC_RAM_TEST_RD_CMD	    16'h0000
+//    `define HCODEC_RAM_TEST_WR_CMD	    16'h8000
+//    `define HCODEC_IDCT_TM2_PT0	    16'h0001
+//    `define HCODEC_IDCT_TM2_PT1	    16'h0002
+//    `define HCODEC_IDCT_TM1_PT0	    16'h0004
+//    `define HCODEC_IDCT_TM1_PT1	    16'h0008
+//    `define HCODEC_IQ_OMEM_PT0	        16'h0010
+//    `define HCODEC_IQ_OMEM_PT1	        16'h0020
+//    `define HCODEC_MC_IMEM_PT0	        16'h0040
+//    `define HCODEC_ALL_RAM_PTS	        16'h007f
+//
+////======================================
+////  VCOP Control Register Bits
+////
+////======================================
+//    //`define HCODEC_IQIDCT_RESET	    16'h0001	    // Bit 0
+//    `define HCODEC_QM_WEN		    16'h0002	    // Bit 1
+//    `define HCODEC_IQIDCT_ENABLE	    16'h0004	    // Bit 2
+//    `define HCODEC_INTRA_QM	    16'h0008	    // Bit 3	0 = Use default; 1 = use loaded
+//    `define HCODEC_NINTRA_QM	    16'h0010	    // Bit 4	0 = Use default; 1 = use loaded
+//
+////======================================
+////  QP Control Register Bits
+////
+////======================================
+//    `define HCODEC_INTRA_MODE	    16'h0080	    // Bit 7
+//// Duplicate Address:  When actually used
+//// please move to a different address
+//// `define HCODEC_FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+//
+// Closing file:  hcodec_iqidct_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC IQIDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+//`define HCODEC_MSP                 8'h00
+//`define HCODEC_MPSR                8'h01
+//`define HCODEC_MINT_VEC_BASE       8'h02
+//`define HCODEC_MCPU_INTR_GRP       8'h03
+//`define HCODEC_MCPU_INTR_MSK       8'h04
+//`define HCODEC_MCPU_INTR_REQ       8'h05
+//`define HCODEC_MPC_P               8'h06
+//`define HCODEC_MPC_D               8'h07
+//`define HCODEC_MPC_E			    8'h08
+//`define HCODEC_MPC_W			    8'h09
+//`define HCODEC_MINDEX0_REG			8'h0a
+//`define HCODEC_MINDEX1_REG			8'h0b
+//`define HCODEC_MINDEX2_REG			8'h0c
+//`define HCODEC_MINDEX3_REG			8'h0d
+//`define HCODEC_MINDEX4_REG			8'h0e
+//`define HCODEC_MINDEX5_REG			8'h0f
+//`define HCODEC_MINDEX6_REG			8'h10
+//`define HCODEC_MINDEX7_REG			8'h11
+//`define HCODEC_MMIN_REG			8'h12
+//`define HCODEC_MMAX_REG			8'h13
+//`define HCODEC_MBREAK0_REG			8'h14
+//`define HCODEC_MBREAK1_REG			8'h15
+//`define HCODEC_MBREAK2_REG			8'h16
+//`define HCODEC_MBREAK3_REG			8'h17
+//`define HCODEC_MBREAK_TYPE			8'h18
+//`define HCODEC_MBREAK_CTRL			8'h19
+//`define HCODEC_MBREAK_STAUTS		8'h1a
+//`define HCODEC_MDB_ADDR_REG		8'h1b
+//`define HCODEC_MDB_DATA_REG		8'h1c
+//`define HCODEC_MDB_CTRL			8'h1d
+//`define HCODEC_MSFTINT0            8'h1e
+//`define HCODEC_MSFTINT1            8'h1f
+//
+//`define HCODEC_CSP                 8'h20
+//`define HCODEC_CPSR                8'h21
+//`define HCODEC_CINT_VEC_BASE       8'h22
+//`define HCODEC_CCPU_INTR_GRP       8'h23
+//`define HCODEC_CCPU_INTR_MSK       8'h24
+//`define HCODEC_CCPU_INTR_REQ       8'h25
+//`define HCODEC_CPC_P               8'h26
+//`define HCODEC_CPC_D               8'h27
+//`define HCODEC_CPC_E			    8'h28
+//`define HCODEC_CPC_W			    8'h29
+//`define HCODEC_CINDEX0_REG			8'h2a
+//`define HCODEC_CINDEX1_REG			8'h2b
+//`define HCODEC_CINDEX2_REG			8'h2c
+//`define HCODEC_CINDEX3_REG			8'h2d
+//`define HCODEC_CINDEX4_REG			8'h2e
+//`define HCODEC_CINDEX5_REG			8'h2f
+//`define HCODEC_CINDEX6_REG			8'h30
+//`define HCODEC_CINDEX7_REG			8'h31
+//`define HCODEC_CMIN_REG			8'h32
+//`define HCODEC_CMAX_REG			8'h33
+//`define HCODEC_CBREAK0_REG			8'h34
+//`define HCODEC_CBREAK1_REG			8'h35
+//`define HCODEC_CBREAK2_REG			8'h36
+//`define HCODEC_CBREAK3_REG			8'h37
+//`define HCODEC_CBREAK_TYPE			8'h38
+//`define HCODEC_CBREAK_CTRL			8'h39
+//`define HCODEC_CBREAK_STAUTS		8'h3a
+//`define HCODEC_CDB_ADDR_REG		8'h3b
+//`define HCODEC_CDB_DATA_REG		8'h3c
+//`define HCODEC_CDB_CTRL			8'h3d
+//`define HCODEC_CSFTINT0            8'h3e
+//`define HCODEC_CSFTINT1            8'h3f
+//
+//`define HCODEC_IMEM_DMA_CTRL       8'h40
+//`define HCODEC_IMEM_DMA_ADR        8'h41
+//`define HCODEC_IMEM_DMA_COUNT      8'h42
+//// bit[29:24] A_brst_num_imem
+//// bit[21:16] A_id_imem
+//// bit[11:0] wrrsp_count_imem (reserved)
+//`define HCODEC_WRRSP_IMEM          8'h43
+//
+//`define HCODEC_LMEM_DMA_CTRL       8'h50
+//`define HCODEC_LMEM_DMA_ADR        8'h51
+//`define HCODEC_LMEM_DMA_COUNT      8'h52
+//// bit[29:24] A_brst_num_lmem
+//// bit[21:16] A_id_lmem
+//// bit[11:0] wrrsp_count_lmem
+//`define HCODEC_WRRSP_LMEM          8'h53
+//
+//`define HCODEC_MAC_CTRL1			8'h60
+//`define HCODEC_ACC0REG1			8'h61
+//`define HCODEC_ACC1REG1			8'h62
+//
+//`define HCODEC_MAC_CTRL2			8'h70
+//`define HCODEC_ACC0REG2			8'h71
+//`define HCODEC_ACC1REG2			8'h72
+//`define HCODEC_CPU_TRACE			8'h80
+//
+//
+// Closing file:  hcodec_vcpu_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define   HEVC_ASSIST_AFIFO_CTRL                   (0x3001)
+#define P_HEVC_ASSIST_AFIFO_CTRL                   (volatile unsigned int *)((0x3001  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AFIFO_CTRL1                  (0x3002)
+#define P_HEVC_ASSIST_AFIFO_CTRL1                  (volatile unsigned int *)((0x3002  << 2) + 0xff620000)
+#define   HEVC_ASSIST_GCLK_EN                      (0x3003)
+#define P_HEVC_ASSIST_GCLK_EN                      (volatile unsigned int *)((0x3003  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SW_RESET                     (0x3004)
+#define P_HEVC_ASSIST_SW_RESET                     (volatile unsigned int *)((0x3004  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT0                    (0x3025)
+#define P_HEVC_ASSIST_AMR1_INT0                    (volatile unsigned int *)((0x3025  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT1                    (0x3026)
+#define P_HEVC_ASSIST_AMR1_INT1                    (volatile unsigned int *)((0x3026  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT2                    (0x3027)
+#define P_HEVC_ASSIST_AMR1_INT2                    (volatile unsigned int *)((0x3027  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT3                    (0x3028)
+#define P_HEVC_ASSIST_AMR1_INT3                    (volatile unsigned int *)((0x3028  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT4                    (0x3029)
+#define P_HEVC_ASSIST_AMR1_INT4                    (volatile unsigned int *)((0x3029  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT5                    (0x302a)
+#define P_HEVC_ASSIST_AMR1_INT5                    (volatile unsigned int *)((0x302a  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT6                    (0x302b)
+#define P_HEVC_ASSIST_AMR1_INT6                    (volatile unsigned int *)((0x302b  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT7                    (0x302c)
+#define P_HEVC_ASSIST_AMR1_INT7                    (volatile unsigned int *)((0x302c  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT8                    (0x302d)
+#define P_HEVC_ASSIST_AMR1_INT8                    (volatile unsigned int *)((0x302d  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INT9                    (0x302e)
+#define P_HEVC_ASSIST_AMR1_INT9                    (volatile unsigned int *)((0x302e  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INTA                    (0x302f)
+#define P_HEVC_ASSIST_AMR1_INTA                    (volatile unsigned int *)((0x302f  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INTB                    (0x3030)
+#define P_HEVC_ASSIST_AMR1_INTB                    (volatile unsigned int *)((0x3030  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INTC                    (0x3031)
+#define P_HEVC_ASSIST_AMR1_INTC                    (volatile unsigned int *)((0x3031  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INTD                    (0x3032)
+#define P_HEVC_ASSIST_AMR1_INTD                    (volatile unsigned int *)((0x3032  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INTE                    (0x3033)
+#define P_HEVC_ASSIST_AMR1_INTE                    (volatile unsigned int *)((0x3033  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR1_INTF                    (0x3034)
+#define P_HEVC_ASSIST_AMR1_INTF                    (volatile unsigned int *)((0x3034  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT0                    (0x3035)
+#define P_HEVC_ASSIST_AMR2_INT0                    (volatile unsigned int *)((0x3035  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT1                    (0x3036)
+#define P_HEVC_ASSIST_AMR2_INT1                    (volatile unsigned int *)((0x3036  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT2                    (0x3037)
+#define P_HEVC_ASSIST_AMR2_INT2                    (volatile unsigned int *)((0x3037  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT3                    (0x3038)
+#define P_HEVC_ASSIST_AMR2_INT3                    (volatile unsigned int *)((0x3038  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT4                    (0x3039)
+#define P_HEVC_ASSIST_AMR2_INT4                    (volatile unsigned int *)((0x3039  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT5                    (0x303a)
+#define P_HEVC_ASSIST_AMR2_INT5                    (volatile unsigned int *)((0x303a  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT6                    (0x303b)
+#define P_HEVC_ASSIST_AMR2_INT6                    (volatile unsigned int *)((0x303b  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT7                    (0x303c)
+#define P_HEVC_ASSIST_AMR2_INT7                    (volatile unsigned int *)((0x303c  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT8                    (0x303d)
+#define P_HEVC_ASSIST_AMR2_INT8                    (volatile unsigned int *)((0x303d  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INT9                    (0x303e)
+#define P_HEVC_ASSIST_AMR2_INT9                    (volatile unsigned int *)((0x303e  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INTA                    (0x303f)
+#define P_HEVC_ASSIST_AMR2_INTA                    (volatile unsigned int *)((0x303f  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INTB                    (0x3040)
+#define P_HEVC_ASSIST_AMR2_INTB                    (volatile unsigned int *)((0x3040  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INTC                    (0x3041)
+#define P_HEVC_ASSIST_AMR2_INTC                    (volatile unsigned int *)((0x3041  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INTD                    (0x3042)
+#define P_HEVC_ASSIST_AMR2_INTD                    (volatile unsigned int *)((0x3042  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INTE                    (0x3043)
+#define P_HEVC_ASSIST_AMR2_INTE                    (volatile unsigned int *)((0x3043  << 2) + 0xff620000)
+#define   HEVC_ASSIST_AMR2_INTF                    (0x3044)
+#define P_HEVC_ASSIST_AMR2_INTF                    (volatile unsigned int *)((0x3044  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBX_SSEL                     (0x3045)
+#define P_HEVC_ASSIST_MBX_SSEL                     (volatile unsigned int *)((0x3045  << 2) + 0xff620000)
+#define   HEVC_ASSIST_TIMER0_LO                    (0x3060)
+#define P_HEVC_ASSIST_TIMER0_LO                    (volatile unsigned int *)((0x3060  << 2) + 0xff620000)
+#define   HEVC_ASSIST_TIMER0_HI                    (0x3061)
+#define P_HEVC_ASSIST_TIMER0_HI                    (volatile unsigned int *)((0x3061  << 2) + 0xff620000)
+#define   HEVC_ASSIST_TIMER1_LO                    (0x3062)
+#define P_HEVC_ASSIST_TIMER1_LO                    (volatile unsigned int *)((0x3062  << 2) + 0xff620000)
+#define   HEVC_ASSIST_TIMER1_HI                    (0x3063)
+#define P_HEVC_ASSIST_TIMER1_HI                    (volatile unsigned int *)((0x3063  << 2) + 0xff620000)
+#define   HEVC_ASSIST_DMA_INT                      (0x3064)
+#define P_HEVC_ASSIST_DMA_INT                      (volatile unsigned int *)((0x3064  << 2) + 0xff620000)
+#define   HEVC_ASSIST_DMA_INT_MSK                  (0x3065)
+#define P_HEVC_ASSIST_DMA_INT_MSK                  (volatile unsigned int *)((0x3065  << 2) + 0xff620000)
+#define   HEVC_ASSIST_DMA_INT2                     (0x3066)
+#define P_HEVC_ASSIST_DMA_INT2                     (volatile unsigned int *)((0x3066  << 2) + 0xff620000)
+#define   HEVC_ASSIST_DMA_INT_MSK2                 (0x3067)
+#define P_HEVC_ASSIST_DMA_INT_MSK2                 (volatile unsigned int *)((0x3067  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX0_IRQ_REG                (0x3070)
+#define P_HEVC_ASSIST_MBOX0_IRQ_REG                (volatile unsigned int *)((0x3070  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX0_CLR_REG                (0x3071)
+#define P_HEVC_ASSIST_MBOX0_CLR_REG                (volatile unsigned int *)((0x3071  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX0_MASK                   (0x3072)
+#define P_HEVC_ASSIST_MBOX0_MASK                   (volatile unsigned int *)((0x3072  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX0_FIQ_SEL                (0x3073)
+#define P_HEVC_ASSIST_MBOX0_FIQ_SEL                (volatile unsigned int *)((0x3073  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX1_IRQ_REG                (0x3074)
+#define P_HEVC_ASSIST_MBOX1_IRQ_REG                (volatile unsigned int *)((0x3074  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX1_CLR_REG                (0x3075)
+#define P_HEVC_ASSIST_MBOX1_CLR_REG                (volatile unsigned int *)((0x3075  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX1_MASK                   (0x3076)
+#define P_HEVC_ASSIST_MBOX1_MASK                   (volatile unsigned int *)((0x3076  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX1_FIQ_SEL                (0x3077)
+#define P_HEVC_ASSIST_MBOX1_FIQ_SEL                (volatile unsigned int *)((0x3077  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX2_IRQ_REG                (0x3078)
+#define P_HEVC_ASSIST_MBOX2_IRQ_REG                (volatile unsigned int *)((0x3078  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX2_CLR_REG                (0x3079)
+#define P_HEVC_ASSIST_MBOX2_CLR_REG                (volatile unsigned int *)((0x3079  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX2_MASK                   (0x307a)
+#define P_HEVC_ASSIST_MBOX2_MASK                   (volatile unsigned int *)((0x307a  << 2) + 0xff620000)
+#define   HEVC_ASSIST_MBOX2_FIQ_SEL                (0x307b)
+#define P_HEVC_ASSIST_MBOX2_FIQ_SEL                (volatile unsigned int *)((0x307b  << 2) + 0xff620000)
+// bit[31:24] - read request
+// bit[23:16] - write request
+// bit[7] - disable_aml_axi_clk_gating
+// bit[3:0] - arb_switch_cnt
+#define   HEVC_ASSIST_AXI_CTRL                     (0x307c)
+#define P_HEVC_ASSIST_AXI_CTRL                     (volatile unsigned int *)((0x307c  << 2) + 0xff620000)
+// bit[31:24] - read arb result
+// bit[23:16] - write arb result
+// bit[15:12] - read_ar_cnt
+// bit[11:8] - write_aw_cnt
+// bit[7] - arvalid_axi_s0
+// bit[6] - arready_axi_s0
+// bit[5] - awvalid_axi_s0
+// bit[4] - awready_axi_s0
+// bit[3:0] - write_fifo_cnt
+#define   HEVC_ASSIST_AXI_STATUS                   (0x307d)
+#define P_HEVC_ASSIST_AXI_STATUS                   (volatile unsigned int *)((0x307d  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_0                    (0x30c0)
+#define P_HEVC_ASSIST_SCRATCH_0                    (volatile unsigned int *)((0x30c0  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_1                    (0x30c1)
+#define P_HEVC_ASSIST_SCRATCH_1                    (volatile unsigned int *)((0x30c1  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_2                    (0x30c2)
+#define P_HEVC_ASSIST_SCRATCH_2                    (volatile unsigned int *)((0x30c2  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_3                    (0x30c3)
+#define P_HEVC_ASSIST_SCRATCH_3                    (volatile unsigned int *)((0x30c3  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_4                    (0x30c4)
+#define P_HEVC_ASSIST_SCRATCH_4                    (volatile unsigned int *)((0x30c4  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_5                    (0x30c5)
+#define P_HEVC_ASSIST_SCRATCH_5                    (volatile unsigned int *)((0x30c5  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_6                    (0x30c6)
+#define P_HEVC_ASSIST_SCRATCH_6                    (volatile unsigned int *)((0x30c6  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_7                    (0x30c7)
+#define P_HEVC_ASSIST_SCRATCH_7                    (volatile unsigned int *)((0x30c7  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_8                    (0x30c8)
+#define P_HEVC_ASSIST_SCRATCH_8                    (volatile unsigned int *)((0x30c8  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_9                    (0x30c9)
+#define P_HEVC_ASSIST_SCRATCH_9                    (volatile unsigned int *)((0x30c9  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_A                    (0x30ca)
+#define P_HEVC_ASSIST_SCRATCH_A                    (volatile unsigned int *)((0x30ca  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_B                    (0x30cb)
+#define P_HEVC_ASSIST_SCRATCH_B                    (volatile unsigned int *)((0x30cb  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_C                    (0x30cc)
+#define P_HEVC_ASSIST_SCRATCH_C                    (volatile unsigned int *)((0x30cc  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_D                    (0x30cd)
+#define P_HEVC_ASSIST_SCRATCH_D                    (volatile unsigned int *)((0x30cd  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_E                    (0x30ce)
+#define P_HEVC_ASSIST_SCRATCH_E                    (volatile unsigned int *)((0x30ce  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_F                    (0x30cf)
+#define P_HEVC_ASSIST_SCRATCH_F                    (volatile unsigned int *)((0x30cf  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_G                    (0x30d0)
+#define P_HEVC_ASSIST_SCRATCH_G                    (volatile unsigned int *)((0x30d0  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_H                    (0x30d1)
+#define P_HEVC_ASSIST_SCRATCH_H                    (volatile unsigned int *)((0x30d1  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_I                    (0x30d2)
+#define P_HEVC_ASSIST_SCRATCH_I                    (volatile unsigned int *)((0x30d2  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_J                    (0x30d3)
+#define P_HEVC_ASSIST_SCRATCH_J                    (volatile unsigned int *)((0x30d3  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_K                    (0x30d4)
+#define P_HEVC_ASSIST_SCRATCH_K                    (volatile unsigned int *)((0x30d4  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_L                    (0x30d5)
+#define P_HEVC_ASSIST_SCRATCH_L                    (volatile unsigned int *)((0x30d5  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_M                    (0x30d6)
+#define P_HEVC_ASSIST_SCRATCH_M                    (volatile unsigned int *)((0x30d6  << 2) + 0xff620000)
+#define   HEVC_ASSIST_SCRATCH_N                    (0x30d7)
+#define P_HEVC_ASSIST_SCRATCH_N                    (volatile unsigned int *)((0x30d7  << 2) + 0xff620000)
+//------------------------------------------------------------------------------
+// HEVC_ASSIST module level register offset
+// Same as VDEC/HCODEC to avoid confusing software guy
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+//------------------------------------------------------------------------------
+// HEVC_PARSER module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_parser_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_PARSER_CBUS_BASE = 0x01
+// -----------------------------------------------
+// [31:0] After reset version, can be used for test scratch register
+#define   HEVC_PARSER_VERSION                      (0x3100)
+#define P_HEVC_PARSER_VERSION                      (volatile unsigned int *)((0x3100  << 2) + 0xff620000)
+// [31:16] - axi_setting
+// [15]    - disable_stream_clock_gating
+// [14]    - wstrb_set
+// [13]    - stream_read_pause
+// [6:4]   - stream_fetch_endian
+// [3]     - use_parser_vbuf_wp
+// [2]     - use_parser_vbuf2_wp
+// [1]     - stream_fetch_busy - Read Only
+// [0]     - stream_fetch_enable
+#define   HEVC_STREAM_CONTROL                      (0x3101)
+#define P_HEVC_STREAM_CONTROL                      (volatile unsigned int *)((0x3101  << 2) + 0xff620000)
+#define   HEVC_STREAM_START_ADDR                   (0x3102)
+#define P_HEVC_STREAM_START_ADDR                   (volatile unsigned int *)((0x3102  << 2) + 0xff620000)
+#define   HEVC_STREAM_END_ADDR                     (0x3103)
+#define P_HEVC_STREAM_END_ADDR                     (volatile unsigned int *)((0x3103  << 2) + 0xff620000)
+// SW stream_buffer_wr_ptr
+#define   HEVC_STREAM_WR_PTR                       (0x3104)
+#define P_HEVC_STREAM_WR_PTR                       (volatile unsigned int *)((0x3104  << 2) + 0xff620000)
+#define   HEVC_STREAM_RD_PTR                       (0x3105)
+#define P_HEVC_STREAM_RD_PTR                       (volatile unsigned int *)((0x3105  << 2) + 0xff620000)
+//[31:0] stream_buffer_level - read only
+#define   HEVC_STREAM_LEVEL                        (0x3106)
+#define P_HEVC_STREAM_LEVEL                        (volatile unsigned int *)((0x3106  << 2) + 0xff620000)
+// [31:29] stream_buffer_hole 256*(4^0) bytes
+// [28:23] stream_fifo_hole
+// [22:16] stream_fifo_level
+// [15]    stream_fifo_wr_ptr_update_en
+// [14:8]  stream_fifo_wr_ptr
+// [7]     stream_fifo_rd_ptr_update_en
+// [6:0]   stream_fifo_rd_ptr
+#define   HEVC_STREAM_FIFO_CTL                     (0x3107)
+#define P_HEVC_STREAM_FIFO_CTL                     (volatile unsigned int *)((0x3107  << 2) + 0xff620000)
+// [31:16] - Reserved
+// [15]    - disable_shift_clock_gating
+// [14]    - disable_start_code_protect
+// [10]    - length_zero_startcode_en
+// [9]     - length_valid_startcode_en
+// [8:6]   - sft_valid_wr_position (default : 3 (at least 24 bits available))
+// [5:4]   - emulate_code_length_sub_1(Default : 2)
+// [3]     - emulation_auto_on_startcode(Default : 0)
+// [2:1]   - start_code_length_sub_1(Default : 2)
+// [0]     - stream_shift_enable(Default : 0)
+#define   HEVC_SHIFT_CONTROL                       (0x3108)
+#define P_HEVC_SHIFT_CONTROL                       (volatile unsigned int *)((0x3108  << 2) + 0xff620000)
+// [31:0]  - max 4-bytes start code (Default : 0x00000100)
+#define   HEVC_SHIFT_STARTCODE                     (0x3109)
+#define P_HEVC_SHIFT_STARTCODE                     (volatile unsigned int *)((0x3109  << 2) + 0xff620000)
+// [31:0]  - max 4-bytes emulate code (Default : 0x00000300)
+#define   HEVC_SHIFT_EMULATECODE                   (0x310a)
+#define P_HEVC_SHIFT_EMULATECODE                   (volatile unsigned int *)((0x310a  << 2) + 0xff620000)
+// [2]     - startcode_searching
+// [1]     - emulation_check_on
+// [0]     - startcode_check_on
+#define   HEVC_SHIFT_STATUS                        (0x310b)
+#define P_HEVC_SHIFT_STATUS                        (volatile unsigned int *)((0x310b  << 2) + 0xff620000)
+// [31:0] hevc_shifted_data - read only
+#define   HEVC_SHIFTED_DATA                        (0x310c)
+#define P_HEVC_SHIFTED_DATA                        (volatile unsigned int *)((0x310c  << 2) + 0xff620000)
+// [31:0] shift_byte_count[31:0]
+#define   HEVC_SHIFT_BYTE_COUNT                    (0x310d)
+#define P_HEVC_SHIFT_BYTE_COUNT                    (volatile unsigned int *)((0x310d  << 2) + 0xff620000)
+// [31:28] - shift_byte_count[35:32]
+// [27:20] - element_read_data[31:24]
+// [10]    - bytealign
+// [9]     - signed_element
+// [8]     - start_element_read
+// [7]     - shift_busy
+// [6:0]   - shift_bits
+#define   HEVC_SHIFT_COMMAND                       (0x310e)
+#define P_HEVC_SHIFT_COMMAND                       (volatile unsigned int *)((0x310e  << 2) + 0xff620000)
+// 31:8    - element_read_data[23:0]
+//  7:2    - element_read_length
+//  1:0    - element_read_state
+#define   HEVC_ELEMENT_RESULT                      (0x310f)
+#define P_HEVC_ELEMENT_RESULT                      (volatile unsigned int *)((0x310f  << 2) + 0xff620000)
+// [31:16] - cabac_buffer
+// [15]    - cabac_buffer_init
+// [14]    - cabac_context_init
+// [13]    - disable_cabac_clock_gating
+// [12]    - cabac_init_flag
+// [11]    - Reserved
+// [10]    - VP9_init_mv
+// [9]     - VP9_init_ref_mode
+// [8]     - VP9_init_if_y_mode
+// [7]     - VP9_init_intra_inter
+// [6]     - VP9_init_inter_mode
+// [5]     - VP9_init_coef
+// [4]     - VP9_init_tx_mode
+// [3]     - VP9_init_skip
+// [2]     - VP9_init_partition
+// [1]     - VP9_key_frame
+// [0]     - cabac_enable(Default : 0)
+#define   HEVC_CABAC_CONTROL                       (0x3110)
+#define P_HEVC_CABAC_CONTROL                       (volatile unsigned int *)((0x3110  << 2) + 0xff620000)
+// [31:25] - chromaQPOffset_U
+// [24:18] - chromaQPOffset_V
+// [17:16] - MaxTrSize 0-4x4, 1-8x8, 2-16x16, 3-32x32
+// [15:14] - MinTrSize 0-4x4, 1-8x8, 2-16x16, 3-32x32
+// HEVC
+// [13:12] - MaxCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64
+// [11:10] - MinCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64
+// [9]     - slice_sao_luma_flag
+// [8]     - slice_sao_chroma_flag
+// VP9 -- When vp9_enable
+// [13:11] - MaxCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64, 7-4x4
+// [10:8]  - MinCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64, 7-4x4
+// [7:2]   - slice_quant
+// [1:0]   - slice_type
+// AVS2
+// [13:12] - MaxCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64
+// [11:10] - MinCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64
+// [9]     - reserved
+// [8]     - slice_quant[6]
+// [7:2]   - slice_quant
+// [1:0]   - slice_type
+#define   HEVC_PARSER_SLICE_INFO                   (0x3111)
+#define P_HEVC_PARSER_SLICE_INFO                   (volatile unsigned int *)((0x3111  << 2) + 0xff620000)
+// bit[16]  - 0:command, 1:address(will auto increase when write command)
+// bit[15:0]- command or addr
+#define   HEVC_PARSER_CMD_WRITE                    (0x3112)
+#define P_HEVC_PARSER_CMD_WRITE                    (volatile unsigned int *)((0x3112  << 2) + 0xff620000)
+// [31:16] - reserved
+// [15]    - disable_parser_core_clock_gating
+// [14:1]  - Reserved
+// [0]     - parser_core_enable(Default : 0)
+#define   HEVC_PARSER_CORE_CONTROL                 (0x3113)
+#define P_HEVC_PARSER_CORE_CONTROL                 (volatile unsigned int *)((0x3113  << 2) + 0xff620000)
+// [31:16] - pre_parser_cmd
+// [15]    - start_cmd_fetch/fetch_busy
+// [14]    - parser_cmd_ready
+// [13]    - pre_parser_cmd_ready
+// [12]    - do_not_wait_if_busy
+// [11:8]  - cmd_fetch_status // Read-only
+// [7:0]   - cmd_fetch_addr
+#define   HEVC_PARSER_CMD_FETCH                    (0x3114)
+#define P_HEVC_PARSER_CMD_FETCH                    (volatile unsigned int *)((0x3114  << 2) + 0xff620000)
+// [31:16] - parser_cmd
+// [9:5]   - parser_function
+// [4:0]   - cmd_status
+#define   HEVC_PARSER_CMD_STATUS                   (0x3115)
+#define P_HEVC_PARSER_CMD_STATUS                   (volatile unsigned int *)((0x3115  << 2) + 0xff620000)
+// [31]    - end_of_picture
+// [30]    - uiLeft
+// [39]    - uiTop
+// [28]    - uiTopRight
+// [27:24] - Reserved
+// [23:12] - uiLin
+// [11:0]  - uiCol
+#define   HEVC_PARSER_LCU_INFO                     (0x3116)
+#define P_HEVC_PARSER_LCU_INFO                     (volatile unsigned int *)((0x3116  << 2) + 0xff620000)
+// 29:28 - min_cu_size_qp_delta
+// 27    - cu_qp_delta_enabled_flag
+// 26    - amp_enabled_flag
+// 25:23 - max_num_merge_cand
+// 22    - mvd_l1_zero_flag
+// 21:16 - num_ref_idx_l1_active
+// 15:10 - num_ref_idx_l0_active
+// 9:7   - max_transform_hierarchy_depth_inter
+// 6:4   - max_transform_hierarchy_depth_intra
+// 3     - transquant_bypass_enable_flag
+// 2     - constrained_intra_pred_flag
+// 1     - transform_skip_enabled_flag
+// 0     - sign_data_hiding_flag
+#define   HEVC_PARSER_HEADER_INFO                  (0x3117)
+#define P_HEVC_PARSER_HEADER_INFO                  (volatile unsigned int *)((0x3117  << 2) + 0xff620000)
+#define   HEVC_PARSER_RESULT_0                     (0x3118)
+#define P_HEVC_PARSER_RESULT_0                     (volatile unsigned int *)((0x3118  << 2) + 0xff620000)
+#define   HEVC_PARSER_RESULT_1                     (0x3119)
+#define P_HEVC_PARSER_RESULT_1                     (volatile unsigned int *)((0x3119  << 2) + 0xff620000)
+#define   HEVC_PARSER_RESULT_2                     (0x311a)
+#define P_HEVC_PARSER_RESULT_2                     (volatile unsigned int *)((0x311a  << 2) + 0xff620000)
+#define   HEVC_PARSER_RESULT_3                     (0x311b)
+#define P_HEVC_PARSER_RESULT_3                     (volatile unsigned int *)((0x311b  << 2) + 0xff620000)
+// For HEVC
+// bit[31:24] - quant[47:40]
+// bit[23:16] - quant[39:32]
+// For VP9
+// bit[31:24] - intra_flag
+// bit[23:16] - SplitFlag_4
+// bit[15:8]  - SkipFlag
+// bit[7]     - SliceEnd|end_of_picture
+// bit[6:3]   - SplitFlag_8
+// bit[2:1]   - SplitFlag_16
+// bit[0]     - SplitFlag_32
+#define   HEVC_CABAC_TOP_INFO                      (0x311c)
+#define P_HEVC_CABAC_TOP_INFO                      (volatile unsigned int *)((0x311c  << 2) + 0xff620000)
+// For HEVC
+// bit[31:0]  - quant[31:0]
+// For VP9
+// bit [31:24] - vp9_top_eob_v
+// bit [23:16] - vp9_top_eob_u
+// bit [15:0] - vp9_top_eob_y
+#define   HEVC_CABAC_TOP_INFO_2                    (0x311d)
+#define P_HEVC_CABAC_TOP_INFO_2                    (volatile unsigned int *)((0x311d  << 2) + 0xff620000)
+// For HEVC
+// bit[31:24] - quant[47:40]
+// bit[23:16] - quant[39:32]
+// For VP9
+// bit[31:24] - Reserved
+// bit[23:16] - SplitFlag_4
+// bit[15:8]  - SkipFlag
+// bit[7]     - Reserved
+// bit[6:3]   - SplitFlag_8
+// bit[2:1]   - SplitFlag_16
+// bit[0]     - SplitFlag_32
+#define   HEVC_CABAC_LEFT_INFO                     (0x311e)
+#define P_HEVC_CABAC_LEFT_INFO                     (volatile unsigned int *)((0x311e  << 2) + 0xff620000)
+// For HEVC
+// bit[31:0]  - quant[31:0]
+// For VP9
+// bit [31:24] - vp9_left_eob_v
+// bit [23:16] - vp9_left_eob_u
+// bit [15:0] - vp9_left_eob_y
+#define   HEVC_CABAC_LEFT_INFO_2                   (0x311f)
+#define P_HEVC_CABAC_LEFT_INFO_2                   (volatile unsigned int *)((0x311f  << 2) + 0xff620000)
+// [31:29] - stream_buffer_empty_int_ctl (32bytes - 4k bytes) (default : 4 : 512 bytes interrupt)
+// [28:26] - stream_fifo_empty_int_ctl (0 - 128)(default : 0 - 0 byte interrupt)
+// [25]    - stream_buffer_empty_int_cpu_enable
+// [24]    - stream_buffer_empty_int_amrisc_enable
+// [23]    - stream_fifo_empty_int_cpu_enable
+// [22]    - stream_fifo_empty_int_amrisc_enable
+// [15]    - disable_parser_clock_gating
+// [8]     - dec_done_int_cpu_enable
+// [7]     - dec_done_int_amrisc_enable
+// [6]     - cmd_done_int_cpu_enable
+// [5]     - cmd_done_int_amrisc_enable
+// [4]     - startcode_found_int_cpu_enable
+// [3]     - startcode_found_int_amrisc_enable
+// [2]     - parser_int_cpu_level (default : 0(pulse))
+// [1]     - parser_int_amrisc_level (default : 0(pulse))
+// [0]     - parser_int_enable(Default : 0)
+#define   HEVC_PARSER_INT_CONTROL                  (0x3120)
+#define P_HEVC_PARSER_INT_CONTROL                  (volatile unsigned int *)((0x3120  << 2) + 0xff620000)
+// [7]     - stream_empty_int_cpu
+// [6]     - stream_empty_int_amrisc
+// [2]     - dec_done_int
+// [1]     - cmd_done_int
+// [0]     - startcode_found_int
+#define   HEVC_PARSER_INT_STATUS                   (0x3121)
+#define P_HEVC_PARSER_INT_STATUS                   (volatile unsigned int *)((0x3121  << 2) + 0xff620000)
+// [31]    - parser_mpred_if_busy  -- Read Only
+// [8]     - sao_sw_pred_enable
+// [7]     - sao_top_save_even_no_sao
+// [6]     - disable_parser_sao_if_clock_gating
+// [5]     - parser_sao_if_en
+// [4]     - scaler_if_leave_one_more_space
+// [3]     - disable_parser_mpred_if_clock_gating
+// [2]     - parser_mpred_if_en
+// [1]     - disable_parser_scaler_if_clock_gating
+// [0]     - parser_scaler_if_en
+#define   HEVC_PARSER_IF_CONTROL                   (0x3122)
+#define P_HEVC_PARSER_IF_CONTROL                   (volatile unsigned int *)((0x3122  << 2) + 0xff620000)
+// [31:16] PicHeightInLumaSamples
+// [15:0]  PicWidthInLumaSamples
+#define   HEVC_PARSER_PICTURE_SIZE                 (0x3123)
+#define P_HEVC_PARSER_PICTURE_SIZE                 (volatile unsigned int *)((0x3123  << 2) + 0xff620000)
+// [31]    - start_lcu_mpred_cmd
+// [30]    - lcu_decoding_start
+// [29]    - do_not_wait_if_busy
+// [23:0]  - lcu_idx
+#define   HEVC_PARSER_LCU_START                    (0x3124)
+#define P_HEVC_PARSER_LCU_START                    (volatile unsigned int *)((0x3124  << 2) + 0xff620000)
+// [31:30] - bit_depth_chroma_minus8
+// [29:24] - MAX_QP
+// [23:20] - qpBdOffsetC
+// [19:16] - qpBdOffsetY
+// [15:12] - pcm_sample_bit_depth_chroma
+// [11:8]  - pcm_sample_bit_depth_luma
+// [7:6]   - max_pcm_luma_coding_block_size
+// [5:4]   - min_pcm_luma_coding_block_size
+// [3:2]   - bit_depth_luma_minus8
+// [1]     - enable_negtive_quant
+// [0]     - pcm_enabled_flag
+#define   HEVC_PARSER_HEADER_INFO2                 (0x3125)
+#define P_HEVC_PARSER_HEADER_INFO2                 (volatile unsigned int *)((0x3125  << 2) + 0xff620000)
+// Read Only
+// bit[23]    - 1'b1
+// bit[22]    - Reserved
+// bit[21:16] - quant_V
+// bit[15]    - 1'b1
+// bit[14]    - Reserved
+// bit[13:8]  - quant_U
+// bit[7]     - 1'b1
+// bit[6]     - Reserved
+// bit[5:0]   - quant_Y
+#define   HEVC_PARSER_QUANT_READ                   (0x3126)
+#define P_HEVC_PARSER_QUANT_READ                   (volatile unsigned int *)((0x3126  << 2) + 0xff620000)
+#define   HEVC_PARSER_RESERVED_27                  (0x3127)
+#define P_HEVC_PARSER_RESERVED_27                  (volatile unsigned int *)((0x3127  << 2) + 0xff620000)
+// bit[15:8]  - skip_addr_SaoOffData
+// bit[7:0]   - skip_addr_SaoMerge
+#define   HEVC_PARSER_CMD_SKIP_0                   (0x3128)
+#define P_HEVC_PARSER_CMD_SKIP_0                   (volatile unsigned int *)((0x3128  << 2) + 0xff620000)
+// bit[31:24] - skip_point_coding_unit_slice_type_RET
+// bit[23:16] - skip_point_coding_unit_slice_type_B
+// bit[15:8]  - skip_point_coding_unit_slice_type_P
+// bit[7:0]   - skip_point_coding_unit_slice_type_I
+#define   HEVC_PARSER_CMD_SKIP_1                   (0x3129)
+#define P_HEVC_PARSER_CMD_SKIP_1                   (volatile unsigned int *)((0x3129  << 2) + 0xff620000)
+// bit[31:24] - reserved
+// bit[23:16] - skip_point_coding_unit_pred_mode_RET
+// bit[15:8]  - skip_point_coding_unit_pred_mode_INTER
+// bit[7:0]   - skip_point_coding_unit_pred_mode_INTRA
+#define   HEVC_PARSER_CMD_SKIP_2                   (0x312a)
+#define P_HEVC_PARSER_CMD_SKIP_2                   (volatile unsigned int *)((0x312a  << 2) + 0xff620000)
+// Write :
+// [24:16] context_addr for dec_Bin
+// [15:0]  parser_cmd
+// Read result:
+// cabac_context_decodeBin,       // 31
+// cabac_context_decodeBinEP,     // 30
+// cabac_context_decodeBinTrm,    // 29
+// cabac_context_decodeBinBit,    // 28
+// parser_command,                // 27:22
+// cabac_context_ready,           // 21
+// cmd_status,                    // 20:16
+// cabac_manual_data              // 15:0
+//
+#define   HEVC_PARSER_MANUAL_CMD                   (0x312b)
+#define P_HEVC_PARSER_MANUAL_CMD                   (volatile unsigned int *)((0x312b  << 2) + 0xff620000)
+// bit [9:0] - Read adress :
+//          address 0-255 stream_fifo (128x64)
+//          address 256-319 context_mem (256x7)
+//          address 320-448 parser_cmd_mem (256x16)
+#define   HEVC_PARSER_MEM_RD_ADDR                  (0x312c)
+#define P_HEVC_PARSER_MEM_RD_ADDR                  (volatile unsigned int *)((0x312c  << 2) + 0xff620000)
+// bit [9:0] - Write adress :
+//          address 0-255 stream_fifo (128x64)
+//          address 256-319 context_mem (256x7)
+//          address 512-640 parser_cmd_mem (256x16)
+#define   HEVC_PARSER_MEM_WR_ADDR                  (0x312d)
+#define P_HEVC_PARSER_MEM_WR_ADDR                  (volatile unsigned int *)((0x312d  << 2) + 0xff620000)
+// bit[31:0] read/write data
+#define   HEVC_PARSER_MEM_RW_DATA                  (0x312e)
+#define P_HEVC_PARSER_MEM_RW_DATA                  (volatile unsigned int *)((0x312e  << 2) + 0xff620000)
+// [31:20] sao_lcu_x
+// [19:8]  sao_lcu_y
+// [7] sao_lcu_xy_update
+// [6:2] reserved
+// [1] sao_wait_up_read
+// [0] sao_wait_write
+#define   HEVC_SAO_IF_STATUS                       (0x3130)
+#define P_HEVC_SAO_IF_STATUS                       (volatile unsigned int *)((0x3130  << 2) + 0xff620000)
+// Y_offset_3,    // 31:26
+// Y_offset_2,    // 25:20
+// Y_offset_1,    // 19:14
+// Y_offset_0,    // 13:8
+// Y_typeAuxInfo[3:0], // 7:4
+// Y_typeIdc,     // 3:1 [0, 1, 2, 3]-EO, [4,5]-BO+Y_typeAuxInfo[4]
+// Y_modelIdc     // 0
+#define   HEVC_SAO_IF_DATA_Y                       (0x3131)
+#define P_HEVC_SAO_IF_DATA_Y                       (volatile unsigned int *)((0x3131  << 2) + 0xff620000)
+#define   HEVC_SAO_IF_DATA_U                       (0x3132)
+#define P_HEVC_SAO_IF_DATA_U                       (volatile unsigned int *)((0x3132  << 2) + 0xff620000)
+#define   HEVC_SAO_IF_DATA_V                       (0x3133)
+#define P_HEVC_SAO_IF_DATA_V                       (volatile unsigned int *)((0x3133  << 2) + 0xff620000)
+#define   HEVC_STREAM_SWAP_ADDR                    (0x3134)
+#define P_HEVC_STREAM_SWAP_ADDR                    (volatile unsigned int *)((0x3134  << 2) + 0xff620000)
+// bit[31:24] - swap_wrrsp_count
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only) (7:0 or 9:2)
+// bit [7] - swap busy (Read Only)
+// bit [6:4] - swap_d_count[10:8] (Read Only)
+// bit [3] - swap_a_count[10] (Read Only)
+// bit [2] - swap_wrrsp_count_update
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define   HEVC_STREAM_SWAP_CTRL                    (0x3135)
+#define P_HEVC_STREAM_SWAP_CTRL                    (volatile unsigned int *)((0x3135  << 2) + 0xff620000)
+#define   HEVC_IQIT_IF_WAIT_CNT                    (0x3136)
+#define P_HEVC_IQIT_IF_WAIT_CNT                    (volatile unsigned int *)((0x3136  << 2) + 0xff620000)
+#define   HEVC_MPRED_IF_WAIT_CNT                   (0x3137)
+#define P_HEVC_MPRED_IF_WAIT_CNT                   (volatile unsigned int *)((0x3137  << 2) + 0xff620000)
+#define   HEVC_SAO_IF_WAIT_CNT                     (0x3138)
+#define P_HEVC_SAO_IF_WAIT_CNT                     (volatile unsigned int *)((0x3138  << 2) + 0xff620000)
+// [31:0] packet_length_count
+#define   HEVC_STREAM_PACKET_LENGTH                (0x3139)
+#define P_HEVC_STREAM_PACKET_LENGTH                (volatile unsigned int *)((0x3139  << 2) + 0xff620000)
+// [31]   data_length_protect_enable
+// [30]   data_protect_fill_00_enable
+// [29]   data_protect_fill_ff_enable
+// [28:19] Reserved
+// [18:0] data_length_protect_count
+#define   HEVC_SHIFT_LENGTH_PROTECT                (0x313a)
+#define P_HEVC_SHIFT_LENGTH_PROTECT                (volatile unsigned int *)((0x313a  << 2) + 0xff620000)
+// bit[3:0] parser_debug_idx
+#define   HEVC_PARSER_DEBUG_IDX                    (0x313e)
+#define P_HEVC_PARSER_DEBUG_IDX                    (volatile unsigned int *)((0x313e  << 2) + 0xff620000)
+// bit[31:0] parser_debug_dat -- read only
+#define   HEVC_PARSER_DEBUG_DAT                    (0x313f)
+#define P_HEVC_PARSER_DEBUG_DAT                    (volatile unsigned int *)((0x313f  << 2) + 0xff620000)
+// bit[22]    - vp9_second_pu_use_if_busy_2
+// bit[21]    - parser_mpred_if_busy_when_pu_mpred_busy
+// bit[20:9]  - Reserved
+// bit[8]   - force_skip_1 (SEG_LVL_SKIP)
+// bit[7:3] - vp9_status
+// bit[2] - change_vp9_status
+// bit[1] - vp9_decode_start(W)/vp9_decode_busy
+// bit[0] - vp9_enable
+#define   VP9_CONTROL                              (0x3140)
+#define P_VP9_CONTROL                              (volatile unsigned int *)((0x3140  << 2) + 0xff620000)
+// bit[15:8]- vp9_emd_cmd_parameter
+// bit[3]   - vp9_emd_cmd_busy
+// bit[2:0] - vp9_emd_command (bit[7]-start/busy)
+//            0 - vp9_read
+//                   (
+//                      input : bit[15:8] - prob,
+//                              bit[7:4] - vp9_read_literal_bits(1-16 bits)
+//                      output : bit[31:16] - result)
+//                   )
+//            1 - vp9_diff_update_prob
+//                   (
+//                      input : bit[7:4] - function:
+// `define vp9_read_tx_mode_prob     0
+// `define vp9_read_coef_prob        1
+// `define vp9_read_skip_prob        2
+// `define vp9_read_inter_mode_prob  3
+// `define vp9_read_interp_prob      4
+// `define vp9_read_intra_inter_prob 5
+// `define vp9_read_comp_inter_prob  6
+// `define vp9_read_comp_ref_prob    7
+// `define vp9_read_single_ref_prob  8
+// `define vp9_read_if_y_mode_prob   9
+// `define vp9_read_partition_prob  10
+// `define vp9_read_mv_prob         11
+//                              bit[29:16] - total loop times
+//                              bit[31:30] - probs_common
+//                      output : bit[15:8] - prob)
+//                   )
+#define   VP9_EMD_CMD                              (0x3141)
+#define P_VP9_EMD_CMD                              (volatile unsigned int *)((0x3141  << 2) + 0xff620000)
+// vp9_top_y_mode[31:0]
+#define   VP9_TOP_Y_MODE_0                         (0x3142)
+#define P_VP9_TOP_Y_MODE_0                         (volatile unsigned int *)((0x3142  << 2) + 0xff620000)
+// vp9_top_y_mode[63:32]
+#define   VP9_TOP_Y_MODE_1                         (0x3143)
+#define P_VP9_TOP_Y_MODE_1                         (volatile unsigned int *)((0x3143  << 2) + 0xff620000)
+// vp9_left_y_mode[31:0]
+#define   VP9_LEFT_Y_MODE_0                        (0x3144)
+#define P_VP9_LEFT_Y_MODE_0                        (volatile unsigned int *)((0x3144  << 2) + 0xff620000)
+// vp9_left_y_mode[63:32]
+#define   VP9_LEFT_Y_MODE_1                        (0x3145)
+#define P_VP9_LEFT_Y_MODE_1                        (volatile unsigned int *)((0x3145  << 2) + 0xff620000)
+// bit[31] - 0:write_vp9_quant, 1:write_vp9_seg_feature
+// For write_vp9_seg_feature:
+// bit[24:22] - seg_id
+// bit[21]    - seg_q_enable
+// bit[20]    - seg_q_sign
+// bit[19:12] - seg_q_abs
+// bit[11]    - seg_lf_enable
+// bit[10]    - seg_lf_sign
+// bit[9:4]   - seg_lf_abs
+// bit[3]     - seg_ref_enable
+// bit[2:1]   - seg_ref_abs
+// bit[0]     - seg_skip_enable
+// For write_vp9_quant:
+// bit[19:16] - Write index : Seg_0_Y-0, Seg_0_UV-1, ... Seq_7_Y-14, Seq_7_UV-15
+// bit[15:8] - AC quant
+// bit[7:0]  - DC quant
+#define   VP9_QUANT_WR                             (0x3146)
+#define P_VP9_QUANT_WR                             (volatile unsigned int *)((0x3146  << 2) + 0xff620000)
+// bit [31:16] - vp9_inter_mode_top/{8'h0, vp9_seg_pred_top}
+// bit [15:0] - vp9_top_tx_mode (odd/even mi has same tx_mode)
+#define   HEVC_CABAC_TOP_INFO_3                    (0x3147)
+#define P_HEVC_CABAC_TOP_INFO_3                    (volatile unsigned int *)((0x3147  << 2) + 0xff620000)
+// bit [31:16] - vp9_inter_mode_left/{8'h0, vp9_seg_pred_left}
+// bit [15:0] - vp9_left_tx_mode (odd/even mi has same tx_mode)
+#define   HEVC_CABAC_LEFT_INFO_3                   (0x3148)
+#define P_HEVC_CABAC_LEFT_INFO_3                   (volatile unsigned int *)((0x3148  << 2) + 0xff620000)
+// bit [31:16] - ref_frame[1]
+// bit [15:0]  - ref_frame[0]
+#define   HEVC_CABAC_TOP_INFO_4                    (0x3149)
+#define P_HEVC_CABAC_TOP_INFO_4                    (volatile unsigned int *)((0x3149  << 2) + 0xff620000)
+// bit [31:16] - ref_frame[1]
+// bit [15:0]  - ref_frame[0]
+#define   HEVC_CABAC_LEFT_INFO_4                   (0x314a)
+#define P_HEVC_CABAC_LEFT_INFO_4                   (volatile unsigned int *)((0x314a  << 2) + 0xff620000)
+// bit [31:16]  - interp_filter
+// bit [15:8]   - Reserved
+// bit [7:0]    - vp9_seg_pred_top
+#define   HEVC_CABAC_TOP_INFO_5                    (0x314b)
+#define P_HEVC_CABAC_TOP_INFO_5                    (volatile unsigned int *)((0x314b  << 2) + 0xff620000)
+// bit [31:16]  - interp_filter
+// bit [15:8]   - Reserved
+// bit [7:0]    - vp9_seg_pred_left
+#define   HEVC_CABAC_LEFT_INFO_5                   (0x314c)
+#define P_HEVC_CABAC_LEFT_INFO_5                   (volatile unsigned int *)((0x314c  << 2) + 0xff620000)
+// bit[31]    - operation start (read : busy)
+// bit[30:28] - operation_endian
+// bit[27:24] - Reserved
+// bit[23:22] - operation_mem 00:prob_mem, 01:count_mem
+// bit[21:20] - operation_cmd 0:clear, 1-store, 2-load
+// bit[19:10] - operation_end_addr
+// bit[9:0] - operation_start_addr
+#define   VP9_MEM_OPERATION                        (0x314d)
+#define P_VP9_MEM_OPERATION                        (volatile unsigned int *)((0x314d  << 2) + 0xff620000)
+// bit[27]    - vp9_seg_pred_info_3
+// bit[26]    - vp9_seg_abs_delta
+// bit[25]    - vp9_seg_temporal
+// bit[24]    - vp9_seg_update_map
+// bit[23]    - vp9_seg_enable
+// bit[22]    - vp9_lossless_use_set
+// bit[21]    - vp9_lossless_set_data
+// bit[20]    - vp9_swap_Y_MODE_with_INFO45
+// bit[19]    - vp9_allow_hp
+// bit[18:16] - vp9_interp_filter
+// bit[15]    - vp9_intra_frame
+// bit[14:12] - vp9_tx_mode
+// bit[11:10] - vp9_ref_mode // SINGLE_REFERENCE(0), COMPOUND_REFERENCE(1), REFERENCE_MODE_SELECT(2)
+// bit[9]   - VPX_BITS_10
+// bit[8] - ref_frame_bias[2]
+// bit[7] - ref_frame_bias[1]
+// bit[6] - ref_frame_bias[0]
+// [5:4] - comp_var_ref[1]
+// [3:2] - comp_var_ref[0]
+// [1:0] - comp_fixed_ref
+#define   VP9_DECODING_INFO                        (0x314f)
+#define P_VP9_DECODING_INFO                        (volatile unsigned int *)((0x314f  << 2) + 0xff620000)
+// [7]   -- segment_id_map_from_shadow
+// [6]   -- segment_id_map_to_shadow
+// [5]   -- shadow_rw_addr_update
+// [4:0] -- shadiw_rw_addr
+#define   VP9_SHADOW_CTRL                          (0x3150)
+#define P_VP9_SHADOW_CTRL                          (volatile unsigned int *)((0x3150  << 2) + 0xff620000)
+// [31:0] -- shadow_rw_data
+#define   VP9_SHADOW_DATA                          (0x3151)
+#define P_VP9_SHADOW_DATA                          (volatile unsigned int *)((0x3151  << 2) + 0xff620000)
+// bit[22]    - avs2_second_pu_use_if_busy_2
+// bit[21]    - parser_mpred_if_busy_when_pu_mpred_busy
+// bit[20:9]  - Reserved
+// bit[8]   - force_skip_1 (SEG_LVL_SKIP)
+// bit[7:3] - avs2_status
+// bit[2] - change_avs2_status
+// bit[1] - avs2_decode_start(W)/avs2_decode_busy
+// bit[0] - avs2_enable
+#define   AVS2_CONTROL                             (0x3152)
+#define P_AVS2_CONTROL                             (volatile unsigned int *)((0x3152  << 2) + 0xff620000)
+// bit[7] - useNSIP (nonsquare_intra_prediction_enable)
+// bit[6] - secT_enabled (secondary_transform_enable_flag)
+// bit[5] - slice_alf_enable_Y
+// bit[4] - slice_alf_enable_U
+// bit[3] - slice_alf_enable_V
+// bit[2] - slice_sao_enable_Y
+// bit[1] - slice_sao_enable_U
+// bit[0] - slice_sao_enable_V
+#define   AVS2_DEC_INFO                            (0x3153)
+#define P_AVS2_DEC_INFO                            (volatile unsigned int *)((0x3153  << 2) + 0xff620000)
+//
+// Closing file:  hevc_parser_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_MPRED module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_mpred_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_MPRED_CBUS_BASE = 0x02
+// -----------------------------------------------
+#define   HEVC_MPRED_VERSION                       (0x3200)
+#define P_HEVC_MPRED_VERSION                       (volatile unsigned int *)((0x3200  << 2) + 0xff620000)
+//  [31:0]  reversion               default:32'h00010001
+#define   HEVC_MPRED_CTRL0                         (0x3201)
+#define P_HEVC_MPRED_CTRL0                         (volatile unsigned int *)((0x3201  << 2) + 0xff620000)
+// [1:0]    slice_type[1:0]
+// [2]      new_pic
+// [3]      new_tile
+// [4]      SliceSegment
+// [5]      TMVPFlag_en
+// [6]      LDCFlag
+// [7]      ColFromL0Flag
+// [8]      reserved
+// [9]      above_en
+// [10]     mv_wr_en  :collocated MV write enable: 0=no-write,1=write;default:1'b1
+// [11]     mv_rd_en
+// [12]     col_isIntra
+// [13]     reserved
+// [14]     LongTerm_Curr
+// [15]     LongTerm_Col
+// [19:16]  lcu_size_log2[3:0]
+// [23:20]  cu_size_log2[3:0]
+// [26:24]  plevel[2:0]
+// [31:27]  reserved
+#define   HEVC_MPRED_CTRL1                         (0x3202)
+#define P_HEVC_MPRED_CTRL1                         (volatile unsigned int *)((0x3202  << 2) + 0xff620000)
+//  [3:0]   MERGE_MAX_NUM_CANDS[3:0]
+//  [7:4]   AMVP_MAX_NUM_CANDS[3:0]
+//  [23:8]  reserved
+//  [24]    clk_forceon
+//  [31:25] reserved
+#define   HEVC_MPRED_INT_EN                        (0x3203)
+#define P_HEVC_MPRED_INT_EN                        (volatile unsigned int *)((0x3203  << 2) + 0xff620000)
+//  [0]     mpred_int_enable
+//  [1]     mpred_int_amrisc_level
+//  [2]     mpred_int_cpu_level
+//  [3]     slice_done_int_amrisc_enable
+//  [4]     slice_done_int_cpu_enable
+//  [15]    disable_mpred_int_clock_gating
+#define   HEVC_MPRED_INT_STATUS                    (0x3204)
+#define P_HEVC_MPRED_INT_STATUS                    (volatile unsigned int *)((0x3204  << 2) + 0xff620000)
+//  [0]     slice_done IRQ
+//  [31]    write "1"=slice start(self clear,read always return "0")
+#define   HEVC_MPRED_PIC_SIZE                      (0x3205)
+#define P_HEVC_MPRED_PIC_SIZE                      (volatile unsigned int *)((0x3205  << 2) + 0xff620000)
+//  [15:0]  pic_width[15:0]
+//  [31:16] pic_height[15:0]
+#define   HEVC_MPRED_PIC_SIZE_LCU                  (0x3206)
+#define P_HEVC_MPRED_PIC_SIZE_LCU                  (volatile unsigned int *)((0x3206  << 2) + 0xff620000)
+//  [15:0]  lcu_x_num_1[15:0]   (=lcu_x_total-1)
+//  [31:16] lcu_y_num_1[15:0]   (=lcu_y_total-1)
+#define   HEVC_MPRED_TILE_START                    (0x3207)
+#define P_HEVC_MPRED_TILE_START                    (volatile unsigned int *)((0x3207  << 2) + 0xff620000)
+//  [15:0]  tile_start_lcu_x[15:0]
+//  [31:16] tile_start_lcu_y[15:0]
+#define   HEVC_MPRED_TILE_SIZE_LCU                 (0x3208)
+#define P_HEVC_MPRED_TILE_SIZE_LCU                 (volatile unsigned int *)((0x3208  << 2) + 0xff620000)
+//  [15:0]  tile_width_lcu[15:0]
+//  [31:16] tile_height_lcu[15:0]
+#define   HEVC_MPRED_REF_NUM                       (0x3209)
+#define P_HEVC_MPRED_REF_NUM                       (volatile unsigned int *)((0x3209  << 2) + 0xff620000)
+//  [3:0]   refNum_L0[3:0]
+//  [11:8]  refNum_L1[3:0]
+//  [19:16] col_refNum_L0[3:0]
+//  [27:24] col_refNum_L1[3:0]
+#define   HEVC_MPRED_LT_REF                        (0x320a)
+#define P_HEVC_MPRED_LT_REF                        (volatile unsigned int *)((0x320a  << 2) + 0xff620000)
+//  [00]    LongTerm_L0_Ref00
+//  [01]    LongTerm_L0_Ref01
+//  ......
+//  [15]    LongTerm_L0_Ref15
+//  [16]    LongTerm_L1_Ref00
+//  [17]    LongTerm_L1_Ref01
+//  ......
+//  [31]    LongTerm_L1_Ref15
+#define   HEVC_MPRED_LT_COLREF                     (0x320b)
+#define P_HEVC_MPRED_LT_COLREF                     (volatile unsigned int *)((0x320b  << 2) + 0xff620000)
+//  [00]    LongTerm_Col_L0_Ref00
+//  [01]    LongTerm_Col_L0_Ref01
+//  ......
+//  [15]    LongTerm_Col_L0_Ref15
+//  [16]    LongTerm_Col_L1_Ref00
+//  [17]    LongTerm_Col_L1_Ref01
+//  ......
+//  [31]    LongTerm_Col_L1_Ref15
+#define   HEVC_MPRED_REF_EN_L0                     (0x320c)
+#define P_HEVC_MPRED_REF_EN_L0                     (volatile unsigned int *)((0x320c  << 2) + 0xff620000)
+//  [00]    L0_ref00_en
+//  [01]    L0_ref01_en
+//  ......
+//  [15]    L0_ref15_en
+#define   HEVC_MPRED_REF_EN_L1                     (0x320d)
+#define P_HEVC_MPRED_REF_EN_L1                     (volatile unsigned int *)((0x320d  << 2) + 0xff620000)
+//  [00]    L1_ref00_en
+//  [01]    L1_ref01_en
+//  ......
+//  [15]    L1_ref15_en
+#define   HEVC_MPRED_COLREF_EN_L0                  (0x320e)
+#define P_HEVC_MPRED_COLREF_EN_L0                  (volatile unsigned int *)((0x320e  << 2) + 0xff620000)
+//  [00]    COL_L0_ref00_en
+//  [01]    COL_L0_ref01_en
+//  ......
+//  [15]    COL_L0_ref15_en
+#define   HEVC_MPRED_COLREF_EN_L1                  (0x320f)
+#define P_HEVC_MPRED_COLREF_EN_L1                  (volatile unsigned int *)((0x320f  << 2) + 0xff620000)
+//  [00]    COL_L1_ref00_en
+//  [01]    COL_L1_ref01_en
+//  ......
+//  [15]    COL_L1_ref15_en
+#define   HEVC_MPRED_AXI_WCTRL                     (0x3210)
+#define P_HEVC_MPRED_AXI_WCTRL                     (volatile unsigned int *)((0x3210  << 2) + 0xff620000)
+//  [11:8]  aw_id_set[3:0]
+#define   HEVC_MPRED_AXI_RCTRL                     (0x3211)
+#define P_HEVC_MPRED_AXI_RCTRL                     (volatile unsigned int *)((0x3211  << 2) + 0xff620000)
+//  [11:8]  ar_id_set[3:0]
+#define   HEVC_MPRED_ABV_START_ADDR                (0x3212)
+#define P_HEVC_MPRED_ABV_START_ADDR                (volatile unsigned int *)((0x3212  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_WR_START_ADDR              (0x3213)
+#define P_HEVC_MPRED_MV_WR_START_ADDR              (volatile unsigned int *)((0x3213  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_RD_START_ADDR              (0x3214)
+#define P_HEVC_MPRED_MV_RD_START_ADDR              (volatile unsigned int *)((0x3214  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_WPTR                       (0x3215)
+#define P_HEVC_MPRED_MV_WPTR                       (volatile unsigned int *)((0x3215  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_RPTR                       (0x3216)
+#define P_HEVC_MPRED_MV_RPTR                       (volatile unsigned int *)((0x3216  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_WR_ROW_JUMP                (0x3217)
+#define P_HEVC_MPRED_MV_WR_ROW_JUMP                (volatile unsigned int *)((0x3217  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_RD_ROW_JUMP                (0x3218)
+#define P_HEVC_MPRED_MV_RD_ROW_JUMP                (volatile unsigned int *)((0x3218  << 2) + 0xff620000)
+#define   HEVC_MPRED_CURR_LCU                      (0x3219)
+#define P_HEVC_MPRED_CURR_LCU                      (volatile unsigned int *)((0x3219  << 2) + 0xff620000)
+#define   HEVC_MPRED_ABV_WPTR                      (0x321a)
+#define P_HEVC_MPRED_ABV_WPTR                      (volatile unsigned int *)((0x321a  << 2) + 0xff620000)
+#define   HEVC_MPRED_ABV_RPTR                      (0x321b)
+#define P_HEVC_MPRED_ABV_RPTR                      (volatile unsigned int *)((0x321b  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL2                         (0x321c)
+#define P_HEVC_MPRED_CTRL2                         (volatile unsigned int *)((0x321c  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL3                         (0x321d)
+#define P_HEVC_MPRED_CTRL3                         (volatile unsigned int *)((0x321d  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_WLCUY                      (0x321e)
+#define P_HEVC_MPRED_MV_WLCUY                      (volatile unsigned int *)((0x321e  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_RLCUY                      (0x321f)
+#define P_HEVC_MPRED_MV_RLCUY                      (volatile unsigned int *)((0x321f  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF00_POC                  (0x3220)
+#define P_HEVC_MPRED_L0_REF00_POC                  (volatile unsigned int *)((0x3220  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF01_POC                  (0x3221)
+#define P_HEVC_MPRED_L0_REF01_POC                  (volatile unsigned int *)((0x3221  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF02_POC                  (0x3222)
+#define P_HEVC_MPRED_L0_REF02_POC                  (volatile unsigned int *)((0x3222  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF03_POC                  (0x3223)
+#define P_HEVC_MPRED_L0_REF03_POC                  (volatile unsigned int *)((0x3223  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF04_POC                  (0x3224)
+#define P_HEVC_MPRED_L0_REF04_POC                  (volatile unsigned int *)((0x3224  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF05_POC                  (0x3225)
+#define P_HEVC_MPRED_L0_REF05_POC                  (volatile unsigned int *)((0x3225  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF06_POC                  (0x3226)
+#define P_HEVC_MPRED_L0_REF06_POC                  (volatile unsigned int *)((0x3226  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF07_POC                  (0x3227)
+#define P_HEVC_MPRED_L0_REF07_POC                  (volatile unsigned int *)((0x3227  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF08_POC                  (0x3228)
+#define P_HEVC_MPRED_L0_REF08_POC                  (volatile unsigned int *)((0x3228  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF09_POC                  (0x3229)
+#define P_HEVC_MPRED_L0_REF09_POC                  (volatile unsigned int *)((0x3229  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF10_POC                  (0x322a)
+#define P_HEVC_MPRED_L0_REF10_POC                  (volatile unsigned int *)((0x322a  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF11_POC                  (0x322b)
+#define P_HEVC_MPRED_L0_REF11_POC                  (volatile unsigned int *)((0x322b  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF12_POC                  (0x322c)
+#define P_HEVC_MPRED_L0_REF12_POC                  (volatile unsigned int *)((0x322c  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF13_POC                  (0x322d)
+#define P_HEVC_MPRED_L0_REF13_POC                  (volatile unsigned int *)((0x322d  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF14_POC                  (0x322e)
+#define P_HEVC_MPRED_L0_REF14_POC                  (volatile unsigned int *)((0x322e  << 2) + 0xff620000)
+#define   HEVC_MPRED_L0_REF15_POC                  (0x322f)
+#define P_HEVC_MPRED_L0_REF15_POC                  (volatile unsigned int *)((0x322f  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF00_POC                  (0x3230)
+#define P_HEVC_MPRED_L1_REF00_POC                  (volatile unsigned int *)((0x3230  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF01_POC                  (0x3231)
+#define P_HEVC_MPRED_L1_REF01_POC                  (volatile unsigned int *)((0x3231  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF02_POC                  (0x3232)
+#define P_HEVC_MPRED_L1_REF02_POC                  (volatile unsigned int *)((0x3232  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF03_POC                  (0x3233)
+#define P_HEVC_MPRED_L1_REF03_POC                  (volatile unsigned int *)((0x3233  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF04_POC                  (0x3234)
+#define P_HEVC_MPRED_L1_REF04_POC                  (volatile unsigned int *)((0x3234  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF05_POC                  (0x3235)
+#define P_HEVC_MPRED_L1_REF05_POC                  (volatile unsigned int *)((0x3235  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF06_POC                  (0x3236)
+#define P_HEVC_MPRED_L1_REF06_POC                  (volatile unsigned int *)((0x3236  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF07_POC                  (0x3237)
+#define P_HEVC_MPRED_L1_REF07_POC                  (volatile unsigned int *)((0x3237  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF08_POC                  (0x3238)
+#define P_HEVC_MPRED_L1_REF08_POC                  (volatile unsigned int *)((0x3238  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF09_POC                  (0x3239)
+#define P_HEVC_MPRED_L1_REF09_POC                  (volatile unsigned int *)((0x3239  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF10_POC                  (0x323a)
+#define P_HEVC_MPRED_L1_REF10_POC                  (volatile unsigned int *)((0x323a  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF11_POC                  (0x323b)
+#define P_HEVC_MPRED_L1_REF11_POC                  (volatile unsigned int *)((0x323b  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF12_POC                  (0x323c)
+#define P_HEVC_MPRED_L1_REF12_POC                  (volatile unsigned int *)((0x323c  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF13_POC                  (0x323d)
+#define P_HEVC_MPRED_L1_REF13_POC                  (volatile unsigned int *)((0x323d  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF14_POC                  (0x323e)
+#define P_HEVC_MPRED_L1_REF14_POC                  (volatile unsigned int *)((0x323e  << 2) + 0xff620000)
+#define   HEVC_MPRED_L1_REF15_POC                  (0x323f)
+#define P_HEVC_MPRED_L1_REF15_POC                  (volatile unsigned int *)((0x323f  << 2) + 0xff620000)
+#define   HEVC_MPRED_PIC_SIZE_EXT                  (0x3240)
+#define P_HEVC_MPRED_PIC_SIZE_EXT                  (volatile unsigned int *)((0x3240  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_MODE0                     (0x3241)
+#define P_HEVC_MPRED_DBG_MODE0                     (volatile unsigned int *)((0x3241  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_MODE1                     (0x3242)
+#define P_HEVC_MPRED_DBG_MODE1                     (volatile unsigned int *)((0x3242  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG2_MODE                     (0x3243)
+#define P_HEVC_MPRED_DBG2_MODE                     (volatile unsigned int *)((0x3243  << 2) + 0xff620000)
+#define   HEVC_MPRED_IMP_CMD0                      (0x3244)
+#define P_HEVC_MPRED_IMP_CMD0                      (volatile unsigned int *)((0x3244  << 2) + 0xff620000)
+#define   HEVC_MPRED_IMP_CMD1                      (0x3245)
+#define P_HEVC_MPRED_IMP_CMD1                      (volatile unsigned int *)((0x3245  << 2) + 0xff620000)
+#define   HEVC_MPRED_IMP_CMD2                      (0x3246)
+#define P_HEVC_MPRED_IMP_CMD2                      (volatile unsigned int *)((0x3246  << 2) + 0xff620000)
+#define   HEVC_MPRED_IMP_CMD3                      (0x3247)
+#define P_HEVC_MPRED_IMP_CMD3                      (volatile unsigned int *)((0x3247  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG2_DATA_0                   (0x3248)
+#define P_HEVC_MPRED_DBG2_DATA_0                   (volatile unsigned int *)((0x3248  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG2_DATA_1                   (0x3249)
+#define P_HEVC_MPRED_DBG2_DATA_1                   (volatile unsigned int *)((0x3249  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG2_DATA_2                   (0x324a)
+#define P_HEVC_MPRED_DBG2_DATA_2                   (volatile unsigned int *)((0x324a  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG2_DATA_3                   (0x324b)
+#define P_HEVC_MPRED_DBG2_DATA_3                   (volatile unsigned int *)((0x324b  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL4                         (0x324c)
+#define P_HEVC_MPRED_CTRL4                         (volatile unsigned int *)((0x324c  << 2) + 0xff620000)
+//  [0]     above intermedia data compress: 0=no-compress,1=compress;default:1'b0
+//  [1]     collocated MV intermedia data compress: 0=no-compress,1=compress;default:1'b0
+//  [2]     vp9_mode,0=hevc_mode,1=vp9_mode,default=0
+//  [6]     vp9_use_prev_frame_mvs  0=not allow vp9_use_prev_frame_mvs,1=allow vp9_use_prev_frame_mvs,default=0
+//  [8]     vp9_not_allow_hp    0=vp9_allow_hp,1=vp9_not_allow_hp,default=0
+//  [9]     vp9_is_compound     0=vp9_is_not_compound,1=vp9_is_compound,default=0
+//  [12]    vp9_ref_sign_bias[1]        ref1(last) ref_sign_bias, default=0
+//  [13]    vp9_ref_sign_bias[2]        ref2(golden) ref_sign_bias,default=0
+//  [14]    vp9_ref_sign_bias[3]        ref3(altref) ref_sign_bias,default=0
+#define   HEVC_MPRED_CTRL5                         (0x324d)
+#define P_HEVC_MPRED_CTRL5                         (volatile unsigned int *)((0x324d  << 2) + 0xff620000)
+#define   HEVC_MPRED_POC24_CTRL0                   (0x324e)
+#define P_HEVC_MPRED_POC24_CTRL0                   (volatile unsigned int *)((0x324e  << 2) + 0xff620000)
+#define   HEVC_MPRED_POC24_CTRL1                   (0x324f)
+#define P_HEVC_MPRED_POC24_CTRL1                   (volatile unsigned int *)((0x324f  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_0                    (0x3250)
+#define P_HEVC_MPRED_DBG_DATA_0                    (volatile unsigned int *)((0x3250  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_1                    (0x3251)
+#define P_HEVC_MPRED_DBG_DATA_1                    (volatile unsigned int *)((0x3251  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_2                    (0x3252)
+#define P_HEVC_MPRED_DBG_DATA_2                    (volatile unsigned int *)((0x3252  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_3                    (0x3253)
+#define P_HEVC_MPRED_DBG_DATA_3                    (volatile unsigned int *)((0x3253  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_4                    (0x3254)
+#define P_HEVC_MPRED_DBG_DATA_4                    (volatile unsigned int *)((0x3254  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_5                    (0x3255)
+#define P_HEVC_MPRED_DBG_DATA_5                    (volatile unsigned int *)((0x3255  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_6                    (0x3256)
+#define P_HEVC_MPRED_DBG_DATA_6                    (volatile unsigned int *)((0x3256  << 2) + 0xff620000)
+#define   HEVC_MPRED_DBG_DATA_7                    (0x3257)
+#define P_HEVC_MPRED_DBG_DATA_7                    (volatile unsigned int *)((0x3257  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL6                         (0x3258)
+#define P_HEVC_MPRED_CTRL6                         (volatile unsigned int *)((0x3258  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL7                         (0x3259)
+#define P_HEVC_MPRED_CTRL7                         (volatile unsigned int *)((0x3259  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL8                         (0x325a)
+#define P_HEVC_MPRED_CTRL8                         (volatile unsigned int *)((0x325a  << 2) + 0xff620000)
+#define   HEVC_MPRED_CTRL9                         (0x325b)
+#define P_HEVC_MPRED_CTRL9                         (volatile unsigned int *)((0x325b  << 2) + 0xff620000)
+#define   HEVC_MPRED_CUR_POC                       (0x3260)
+#define P_HEVC_MPRED_CUR_POC                       (volatile unsigned int *)((0x3260  << 2) + 0xff620000)
+#define   HEVC_MPRED_COL_POC                       (0x3261)
+#define P_HEVC_MPRED_COL_POC                       (volatile unsigned int *)((0x3261  << 2) + 0xff620000)
+#define   HEVC_MPRED_MV_RD_END_ADDR                (0x3262)
+#define P_HEVC_MPRED_MV_RD_END_ADDR                (volatile unsigned int *)((0x3262  << 2) + 0xff620000)
+//
+// Closing file:  hevc_mpred_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_IPP module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_ipp_regs.h
+//
+// John A. Thodiyil
+// Register map for intra/inter/pcm pixel-prediction + MCRCC + DECOMP
+// August 14th, 2013
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_IPP_CBUS_BASE = 0x04
+// -----------------------------------------------
+#define   HEVCD_IPP_TOP_CNTL                       (0x3400)
+#define P_HEVCD_IPP_TOP_CNTL                       (volatile unsigned int *)((0x3400  << 2) + 0xff620000)
+// [0]      -- software reset ipp and mpp
+// [1]      -- enable ipp
+// [3:2]    -- reserved
+// [5:4]    -- codec[1:0] 00:hevc 01:vp9 10:avs2 11:reserved
+// [31:6]   -- reserved
+#define   HEVCD_IPP_TOP_STATUS                     (0x3401)
+#define P_HEVCD_IPP_TOP_STATUS                     (volatile unsigned int *)((0x3401  << 2) + 0xff620000)
+// [0]      -- ready for next tile/frame
+// [1]      -- ready for next ctb
+// [2]      -- ready for next slice
+// [3]      -- reserved
+// [4]      -- ipp_axi_rd_idle
+// [5]      -- ipp_axi_wr_idle
+// [6]      -- mpp_axi_rd_idle
+// [31:7]   -- reserved
+#define   HEVCD_IPP_TOP_FRMCONFIG                  (0x3402)
+#define P_HEVCD_IPP_TOP_FRMCONFIG                  (volatile unsigned int *)((0x3402  << 2) + 0xff620000)
+// [14:0]   -- frame width in luma pixels
+// [30:16]  -- frame height in luma pixels
+#define   HEVCD_IPP_TOP_TILECONFIG1                (0x3403)
+#define P_HEVCD_IPP_TOP_TILECONFIG1                (volatile unsigned int *)((0x3403  << 2) + 0xff620000)
+// [11:0]   -- tile_width_in_lcu
+// [27:16]  -- tile_height_in_lcu
+#define   HEVCD_IPP_TOP_TILECONFIG2                (0x3404)
+#define P_HEVCD_IPP_TOP_TILECONFIG2                (volatile unsigned int *)((0x3404  << 2) + 0xff620000)
+// [11:0]   -- tile_offset_x_in_lcu
+// [27:16]  -- tile_offset_y_in_lcu
+#define   HEVCD_IPP_TOP_TILECONFIG3                (0x3405)
+#define P_HEVCD_IPP_TOP_TILECONFIG3                (volatile unsigned int *)((0x3405  << 2) + 0xff620000)
+// [0]      -- tiles_enabled_flag
+// [31:1]   -- reserved
+#define   HEVCD_IPP_TOP_LCUCONFIG                  (0x3406)
+#define P_HEVCD_IPP_TOP_LCUCONFIG                  (volatile unsigned int *)((0x3406  << 2) + 0xff620000)
+// [6:0]    -- lcu size in pixels
+#define   HEVCD_IPP_TOP_FRMCTL                     (0x3407)
+#define P_HEVCD_IPP_TOP_FRMCTL                     (volatile unsigned int *)((0x3407  << 2) + 0xff620000)
+// [x]      -- start ipp tile decode
+#define   HEVCD_IPP_CONFIG                         (0x3408)
+#define P_HEVCD_IPP_CONFIG                         (volatile unsigned int *)((0x3408  << 2) + 0xff620000)
+// [0]      -- ipp_strong_intra_smoothing_enable_flag
+// [1]      -- cfg_ipp_constrained_intra_pred_flag
+// [31:2]   -- reserved
+#define   HEVCD_IPP_LINEBUFF_BASE                  (0x3409)
+#define P_HEVCD_IPP_LINEBUFF_BASE                  (volatile unsigned int *)((0x3409  << 2) + 0xff620000)
+// [31:14]  -- intra-prediction line-buffer 16KByte axi address
+// [13:0]   -- reserved
+#define   HEVCD_IPP_INTR_MASK                      (0x340a)
+#define P_HEVCD_IPP_INTR_MASK                      (volatile unsigned int *)((0x340a  << 2) + 0xff620000)
+// [0]      -- tile/frame ready
+// [1]      -- ctb ready
+// [2]      -- slice ready
+// [31:3]   -- reserved
+#define   HEVCD_IPP_AXIIF_CONFIG                   (0x340b)
+#define P_HEVCD_IPP_AXIIF_CONFIG                   (volatile unsigned int *)((0x340b  << 2) + 0xff620000)
+// [3:0]    -- little_endian
+// [5:4]    -- address_format 00:linear 01:32x32 10:64x32
+// [7:6]    -- reserved
+// [9:8]    -- Linear_LineAlignment 00:16byte 01:32byte 10:64byte
+// [11:10]  -- reserved
+// [12]     -- CbCr_byte_swap
+// [31:13]  -- reserved
+#define   HEVCD_IPP_BITDEPTH_CONFIG                (0x340c)
+#define P_HEVCD_IPP_BITDEPTH_CONFIG                (volatile unsigned int *)((0x340c  << 2) + 0xff620000)
+// [1:0]    -- bit_depth_luma   00:8 01:9 10:10
+// [3:2]    -- bit_depth_chroma 00:8 01:9 10:10
+// [31:4]   -- reserved
+#define   HEVCD_IPP_SWMPREDIF_CONFIG               (0x3410)
+#define P_HEVCD_IPP_SWMPREDIF_CONFIG               (volatile unsigned int *)((0x3410  << 2) + 0xff620000)
+// [0]      -- swmpredif_enable
+// [31:1]   -- reserved
+#define   HEVCD_IPP_SWMPREDIF_STATUS               (0x3411)
+#define P_HEVCD_IPP_SWMPREDIF_STATUS               (volatile unsigned int *)((0x3411  << 2) + 0xff620000)
+// [0]      -- swmpredif_rdy
+// [7:1]    -- reserved
+// [14:8]   -- swmpredif_fifospace
+// [31:15]  -- reserved
+#define   HEVCD_IPP_SWMPREDIF_CTBINFO              (0x3412)
+#define P_HEVCD_IPP_SWMPREDIF_CTBINFO              (volatile unsigned int *)((0x3412  << 2) + 0xff620000)
+// [10:0]   -- swmpredif_ctb_x
+// [15:11]  -- reserved
+// [26:16]  -- swmpredif_ctb_y
+// [30:27]  -- reserved
+// [31]     -- swmpredif_newslice
+#define   HEVCD_IPP_SWMPREDIF_PUINFO0              (0x3413)
+#define P_HEVCD_IPP_SWMPREDIF_PUINFO0              (volatile unsigned int *)((0x3413  << 2) + 0xff620000)
+// [31:0]   -- swmpredif_imp_cmd[31:0]
+#define   HEVCD_IPP_SWMPREDIF_PUINFO1              (0x3414)
+#define P_HEVCD_IPP_SWMPREDIF_PUINFO1              (volatile unsigned int *)((0x3414  << 2) + 0xff620000)
+// [31:0]   -- swmpredif_imp_cmd[63:32]
+#define   HEVCD_IPP_SWMPREDIF_PUINFO2              (0x3415)
+#define P_HEVCD_IPP_SWMPREDIF_PUINFO2              (volatile unsigned int *)((0x3415  << 2) + 0xff620000)
+// [31:0]   -- swmpredif_imp_cmd[95:64]
+#define   HEVCD_IPP_SWMPREDIF_PUINFO3              (0x3416)
+#define P_HEVCD_IPP_SWMPREDIF_PUINFO3              (volatile unsigned int *)((0x3416  << 2) + 0xff620000)
+// [31:0]   -- swmpredif_imp_cmd[127:96]
+#define   HEVCD_IPP_SWMPREDIF_PUINFO4              (0x3417)
+#define P_HEVCD_IPP_SWMPREDIF_PUINFO4              (volatile unsigned int *)((0x3417  << 2) + 0xff620000)
+// [31:0]   -- swmpredif_imp_cmd[159:128]
+#define   HEVCD_IPP_SWMPREDIF_PUINFO5              (0x3418)
+#define P_HEVCD_IPP_SWMPREDIF_PUINFO5              (volatile unsigned int *)((0x3418  << 2) + 0xff620000)
+// [31:0]   -- swmpredif_imp_cmd[191:160]
+//          writing to HEVCD_IPP_SWMPREDIF_PUINFO5
+//          completes command, should be last to write.
+#define   HEVCD_IPP_DYNCLKGATE_CONFIG              (0x3420)
+#define P_HEVCD_IPP_DYNCLKGATE_CONFIG              (volatile unsigned int *)((0x3420  << 2) + 0xff620000)
+// [0]      -- mpp_wpredict_clkgate_disbl
+// [1]      -- mpp_ref_fetch_clkgate_disbl
+// [2]      -- mpp_interpol_top_clkgate_disbl
+// [3]      -- mpp_4x4mcr_clkgate_disbl
+// [4]      -- mpp_ref_pack_clkgate_disbl
+// [5]      -- mpp_mdec_if_clkgate_disbl
+// [7:6]    -- reserved
+// [8]      -- ipp_res_fetch_clkgate_disbl
+// [9]      -- ipp_iqitIf_clkgate_disbl
+// [10]     -- ipp_dblkCmdIf_clkgate_disbl
+// [11]     -- ipp_dblkIf_clkgate_disbl
+// [12]     -- ipp_cntl_clkgate_disbl
+// [13]     -- ipp_nsamples_proc_clkgate_disbl
+// [14]     -- ipp_refroute_clkgate_disbl
+// [15]     -- ipp_spred_clkgate_disbl
+// [16]     -- ipp_reg_clkgate_disbl
+// [17]     -- ipp_recon_clkgate_disbl
+// [19:18]  -- reserved
+// [20]     -- decomp_cntl_clkgate_disbl
+// [21]     -- decomp_axiIf_clkgate_disbl
+// [22]     -- decomp_dcache_clkgate_disbl
+// [23]     -- decomp_hcache_clkgate_disbl
+// [24]     -- decomp_gearup_clkgate_disbl
+// [25]     -- decomp_cores_clkgate_disbl
+// [26]     -- decomp_rdroute_clkgate_disbl
+// [27]     -- reserved
+// [28]     -- master_decomp_clkgate_disbl
+// [29]     -- master_mpp_clkgate_disbl
+// [30]     -- master_ipp_clkgate_disbl
+// [31]     -- master_ipp_mpp_decomp_clkgate_disbl
+#define   HEVCD_IPP_DYNCLKGATE_STATUS              (0x3421)
+#define P_HEVCD_IPP_DYNCLKGATE_STATUS              (volatile unsigned int *)((0x3421  << 2) + 0xff620000)
+// [0]      -- mpp_wpredict_clkgate
+// [1]      -- mpp_ref_fetch_clkgate
+// [2]      -- mpp_interpol_top_clkgate
+// [3]      -- mpp_4x4mcr_clkgate
+// [4]      -- mpp_ref_pack_clkgate
+// [5]      -- mpp_mdec_if_clkgate
+// [7:6]    -- reserved
+// [8]      -- ipp_res_fetch_clkgate
+// [9]      -- ipp_iqitIf_clkgate
+// [10]     -- ipp_dblkCmdIf_clkgate
+// [11]     -- ipp_dblkIf_clkgate
+// [12]     -- ipp_cntl_clkgate
+// [13]     -- ipp_nsamples_proc_clkgate
+// [14]     -- ipp_refroute_clkgate
+// [15]     -- ipp_spred_clkgate
+// [16]     -- ipp_reg_clkgate
+// [17]     -- ipp_recon_clkgate
+// [19:18]  -- reserved
+// [20]     -- decomp_cntl_clkgate
+// [21]     -- decomp_axiIf_clkgate
+// [22]     -- decomp_dcache_clkgate
+// [23]     -- decomp_hcache_clkgate
+// [24]     -- decomp_gearup_clkgate
+// [25]     -- decomp_cores_clkgate
+// [26]     -- decomp_rdroute_clkgate
+// [27]     -- reserved
+// [30:28]  -- reserved
+// [31]     -- mcrcc_axi_clkgate
+#define   HEVCD_IPP_DBG_SEL                        (0x3430)
+#define P_HEVCD_IPP_DBG_SEL                        (volatile unsigned int *)((0x3430  << 2) + 0xff620000)
+// [3:0]    -- module_level_sel
+// [7:4]    -- mpp_ipp_top_level
+// [8]      -- ipp_sel
+// [31:9]   -- reserved
+#define   HEVCD_IPP_DBG_DATA                       (0x3431)
+#define P_HEVCD_IPP_DBG_DATA                       (volatile unsigned int *)((0x3431  << 2) + 0xff620000)
+// [31:0]   -- Debug information
+//////////////////////////////////////////////////////////////////////////////
+///// MPP Registers                                       ////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// Canvas Anchor to Axi-Address translation table
+#define   HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR          (0x3460)
+#define P_HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR          (volatile unsigned int *)((0x3460  << 2) + 0xff620000)
+// [0]      -- anc2axi canvas address translation table switch 0:sw 1:hw
+// [1]      -- access type 1:wr 0:rd
+// [2]      -- auto index increment
+// [7:3]    -- reserved
+// [15:8]   -- start index
+// [31:16]  -- reserved
+//`define     HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR         8'h61
+// [0]      -- anc2axi canvas address translation table access type 1:wr 0:rd
+// [15:8]   -- anc2axi canvas address translation table access index
+// [31:16]  -- anc2axi canvas address translation table access write data, 16KByte axi address
+//          -- obsoleted
+//`define     HEVCD_MPP_ANC2AXI_TBL_WDATA_ADDR       8'h62   // NU
+// [x]      -- not used
+//`define     HEVCD_MPP_ANC2AXI_TBL_RDATA_ADDR       8'h63
+// [15:0]   -- anc2axi canvas address translation table access read data
+//          -- obsoleted
+#define   HEVCD_MPP_ANC2AXI_TBL_DATA               (0x3464)
+#define P_HEVCD_MPP_ANC2AXI_TBL_DATA               (volatile unsigned int *)((0x3464  << 2) + 0xff620000)
+// [26:0]   -- anc2axi address r/w  32byte aligned
+// [31:27]  -- reserved
+#define   HEVCD_MPP_WEIGHTPRED_CNTL_ADDR           (0x347b)
+#define P_HEVCD_MPP_WEIGHTPRED_CNTL_ADDR           (volatile unsigned int *)((0x347b  << 2) + 0xff620000)
+// [0]      -- weighted_pred_flag
+#define   HEVCD_MPP_L0_WEIGHT_FLAG_ADDR            (0x347c)
+#define P_HEVCD_MPP_L0_WEIGHT_FLAG_ADDR            (volatile unsigned int *)((0x347c  << 2) + 0xff620000)
+// [15:0]   -- luma_weght_flag0[15:0], indexed by refidx0
+// [31:16]  -- chroma_weght_flag0[15:0], indexed by refidx0
+#define   HEVCD_MPP_L1_WEIGHT_FLAG_ADDR            (0x347d)
+#define P_HEVCD_MPP_L1_WEIGHT_FLAG_ADDR            (volatile unsigned int *)((0x347d  << 2) + 0xff620000)
+// [15:0]   -- luma_weght_flag1[15:0], indexed by refidx1
+// [31:16]  -- chroma_weght_flag1[15:0], indexed by refidx1
+#define   HEVCD_MPP_YLOG2WGHTDENOM_ADDR            (0x347e)
+#define P_HEVCD_MPP_YLOG2WGHTDENOM_ADDR            (volatile unsigned int *)((0x347e  << 2) + 0xff620000)
+// [3:0]    -- luma_log2_weight_denom
+#define   HEVCD_MPP_DELTACLOG2WGHTDENOM_ADDR       (0x347f)
+#define P_HEVCD_MPP_DELTACLOG2WGHTDENOM_ADDR       (volatile unsigned int *)((0x347f  << 2) + 0xff620000)
+// [4:0]    -- delta_chroma_log2_weight_denom
+#define   HEVCD_MPP_WEIGHT_ADDR                    (0x3480)
+#define P_HEVCD_MPP_WEIGHT_ADDR                    (volatile unsigned int *)((0x3480  << 2) + 0xff620000)
+// [5:0]    -- weight_rw_addr
+// [0]      -- DELTA_WEIGHT0
+// [1]      -- OFFSET0
+// [2]      -- DELTA_WEIGHT1
+// [3]      -- OFFSET1
+// ......
+// [62]     -- DELTA_WEIGHT31
+// [63]     -- OFFSET31
+#define   HEVCD_MPP_WEIGHT_DATA                    (0x3481)
+#define P_HEVCD_MPP_WEIGHT_DATA                    (volatile unsigned int *)((0x3481  << 2) + 0xff620000)
+// For DELTA_WEIGHT :
+// [7:0]    -- delta_y_weight for refidx0:0
+// [15:8]   -- delta_cb_weight for refidx0:0
+// [23:16]  -- delta_cr_weight for refidx0:0
+// For OFFSET :
+// [7:0]    -- luma_offset for refidx0:0
+// [17:8]   -- delta_cb_offset for refidx0:0
+// [27:18]  -- delta_cr_offset for refidx0:0
+// ID to Anchor-Canvas-Address table
+// [31:13]  reserved
+// [12:8]   access_index
+// [7:2]    reserved
+// [1]      auto_inc_read
+// [0]      auto_inc_write
+#define   HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR      (0x34c0)
+#define P_HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR      (volatile unsigned int *)((0x34c0  << 2) + 0xff620000)
+// Id[4:0]  --> {AnchorAddrCr[7:0],AnchorAddrCb[7:0],AnchorAddrY[7:0]}
+#define   HEVCD_MPP_ANC_CANVAS_DATA_ADDR           (0x34c1)
+#define P_HEVCD_MPP_ANC_CANVAS_DATA_ADDR           (volatile unsigned int *)((0x34c1  << 2) + 0xff620000)
+// [0]       -- decomp_nocompress
+// [1]       -- decomp_dcache_bypass
+// [2]       -- reserved
+// [3]       -- decomp_smem_bdepth888
+// [4]       -- decomp_paged_mem_mode
+// [30:5]    -- reserved
+// [31]      -- decomp_axif_lbmode888
+#define   HEVCD_MPP_DECOMP_CTL1                    (0x34c2)
+#define P_HEVCD_MPP_DECOMP_CTL1                    (volatile unsigned int *)((0x34c2  << 2) + 0xff620000)
+// [23:0]    -- header1_offset : 32byte address from canvas base
+// [31:24]   -- reserved
+#define   HEVCD_MPP_DECOMP_CTL2                    (0x34c3)
+#define P_HEVCD_MPP_DECOMP_CTL2                    (volatile unsigned int *)((0x34c3  << 2) + 0xff620000)
+// [9:0]     -- decomp_default_Y
+// [19:10]   -- decomp_default_Cb
+// [29:20]   -- decomp_dafault_Cr
+// [31:30]   -- bitdepth_sel 00:8bit 01:9bit 10:10bit
+#define   HEVCD_MPP_DECOMP_CTL3                    (0x34c4)
+#define P_HEVCD_MPP_DECOMP_CTL3                    (volatile unsigned int *)((0x34c4  << 2) + 0xff620000)
+// HEVCD_MPP_DECOMP_PERFMON_CTL
+// [0]      percount_reset
+// [3:1]    perfcount_sel
+// [31:4]   reserved
+// {1'b0,perfcount_sel[1:0]}    perfcount
+//     0                        raw_hcache_cnt
+//     1                        hit_hcache_cnt
+//     2                        raw_dcache_cnt
+//     3                        hit_dcache_cnt
+// {1'b1,perfcount_sel[1:0]}    perfcount
+//     0                        fast_num_compburst
+//     1                        slow_num_compburst
+//     2,3                      raw_num_ncompburst
+#define   HEVCD_MPP_DECOMP_PERFMON_CTL             (0x34c5)
+#define P_HEVCD_MPP_DECOMP_PERFMON_CTL             (volatile unsigned int *)((0x34c5  << 2) + 0xff620000)
+// HEVCD_MPP_DECOMP_PERFMON_DATA
+// [31:0]   percount_data
+#define   HEVCD_MPP_DECOMP_PERFMON_DATA            (0x34c6)
+#define P_HEVCD_MPP_DECOMP_PERFMON_DATA            (volatile unsigned int *)((0x34c6  << 2) + 0xff620000)
+// HEVCD_MPP_DECOMP_AXIURG_CTL
+// [1:0]      -- decomp_hdrurg  00:Normal 01:Urgent 10:SuperUrgent
+// [2]        -- decomp_fpathurg_en 1->Urgent if below lo_thresh
+// [3]        -- decomp_spathurg_en 1->Urgent if below lo_thresh
+// [10:4]     -- decomp_fpathurg_lothresh [32byte steps : max 96]
+// [17:11]    -- decomp_fpathurg_hithresh [32byte steps : max 96]
+// [24:18]    -- decomp_spathurg_lothresh [32byte steps : max 64]
+// [31:25]    -- decomp_spathurg_hithresh [32byte steps : max 64]
+#define   HEVCD_MPP_DECOMP_AXIURG_CTL              (0x34c7)
+#define P_HEVCD_MPP_DECOMP_AXIURG_CTL              (volatile unsigned int *)((0x34c7  << 2) + 0xff620000)
+// HEVCD_MPP_VDEC_MCR_CTL
+// [0]        -- mcr_mdec_mode : 1:mcr fetch used by vdec:mdec
+// [3:1]      -- reserved
+// [4]        -- mcr_mdec_8byte_endianess : 1:big 0:little
+// [31:5]     -- reserved
+#define   HEVCD_MPP_VDEC_MCR_CTL                   (0x34c8)
+#define P_HEVCD_MPP_VDEC_MCR_CTL                   (volatile unsigned int *)((0x34c8  << 2) + 0xff620000)
+//////////////////////////////////////////////////////////////////////////////
+///// MCRCC_AXI Registers                                 ////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// HEVCD_MCRCC_CTL1
+// 31:12 <reserved[20:0]>
+// 11:10 <cfg_anc11_tb>                           // 01: top 10:bot 11:frame
+// 9:8   <cfg_anc10_tb>
+// 7:6   <cfg_anc01_tb>
+// 5:4   <cfg_anc00_tb>
+// 3     <cfg_clkgate_disbl>
+// 2     <cfg_field_pic>                           // not used for hevc
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define   HEVCD_MCRCC_CTL1                         (0x34f0)
+#define P_HEVCD_MCRCC_CTL1                         (volatile unsigned int *)((0x34f0  << 2) + 0xff620000)
+// HEVCD_MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define   HEVCD_MCRCC_CTL2                         (0x34f1)
+#define P_HEVCD_MCRCC_CTL2                         (volatile unsigned int *)((0x34f1  << 2) + 0xff620000)
+// HEVCD_MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define   HEVCD_MCRCC_CTL3                         (0x34f2)
+#define P_HEVCD_MCRCC_CTL3                         (volatile unsigned int *)((0x34f2  << 2) + 0xff620000)
+// HEVCD_MCRCC_PERFMON_CTL
+// [0]      percount_reset
+// [3:1]    perfcount_sel
+// [31:4]   reserved
+// perfcount_sel[2:0]     perfcount
+//     0                  raw_mcr_cnt
+//     1                  hit_mcr_cnt
+//     2                  byp_mcr_cnt_nchoutwin
+//     3                  byp_mcr_cnt_nchcanv
+//     4                  miss_mcr_cnt_0
+//     5                  miss_mcr_cnt_1
+//     6                  hit_mcr_cnt_0
+//     7                  hit_mcr_cnt_1
+#define   HEVCD_MCRCC_PERFMON_CTL                  (0x34f3)
+#define P_HEVCD_MCRCC_PERFMON_CTL                  (volatile unsigned int *)((0x34f3  << 2) + 0xff620000)
+// HEVCD_MCRCC_PERFMON_DATA
+// [31:0]   percount_data
+#define   HEVCD_MCRCC_PERFMON_DATA                 (0x34f4)
+#define P_HEVCD_MCRCC_PERFMON_DATA                 (volatile unsigned int *)((0x34f4  << 2) + 0xff620000)
+//////////////////////////////////////////////////////////////////////////////
+///// VP9 Decoder Registers                               ////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// VP9D_MPP_INTERPOL_CFG0
+// [2:0]    VP9 MC Interpolation type
+            // 0-3:perframe type 4:per partition type
+// [3]      reserved
+// [4]      V99 MV precision
+            // 1:high precision else  mv=mv*2
+// [31:5]   reserved
+#define   VP9D_MPP_INTERPOL_CFG0                   (0x3440)
+#define P_VP9D_MPP_INTERPOL_CFG0                   (volatile unsigned int *)((0x3440  << 2) + 0xff620000)
+// VP9D_MPP_REF_SCALE_ENBL
+// [7:0]    VP9 MC reference scaled info
+// [15:0]   VP9 MC reference scaled dir 0:Dwn 1:Up
+// [31:16]  reserved
+#define   VP9D_MPP_REF_SCALE_ENBL                  (0x3441)
+#define P_VP9D_MPP_REF_SCALE_ENBL                  (volatile unsigned int *)((0x3441  << 2) + 0xff620000)
+// VP9D_MPP_REFINFO_TBL_ACCCONFIG
+// [1:0]    reserved
+// [2]      auto_inc_index/field
+// [5:3]    reference index   0:last 1:golden 2:altref
+// [8:6]    info field 0:<ref_width[14:0]> 1:<ref_height[14:0]>
+            //         2:<scale_x[26:0]  3:<scale_y[26:0]>
+            //         4:<decomp_header1_offset[23:0]> -- 32byte aligned
+// [31:9]   reserved
+#define   VP9D_MPP_REFINFO_TBL_ACCCONFIG           (0x3442)
+#define P_VP9D_MPP_REFINFO_TBL_ACCCONFIG           (volatile unsigned int *)((0x3442  << 2) + 0xff620000)
+// VP9D_MPP_REFINFO_DATA
+// [n:0]    refinfo_tbl[index]field]  wr_data/rd_data
+#define   VP9D_MPP_REFINFO_DATA                    (0x3443)
+#define P_VP9D_MPP_REFINFO_DATA                    (volatile unsigned int *)((0x3443  << 2) + 0xff620000)
+//
+// Closing file:  hevc_ipp_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_DBLK module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_dblk_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_DBLK_CBUS_BASE = 0x05
+// -----------------------------------------------
+//cfg0[0];        //software_reset
+//cfg0[1];        //status clear, only for axi error or pic_done
+//cfg0[2];        //clock_forced_on_all
+//cfg0[3];        //clock_forced_off_all
+//cfg0[11:8];     //PU FIFO Threshold   , 0:16 1:1 ... 1:15
+//cfg0[15:12];    //TU FIFO Threshold>>4, 0:16<<4 1:1<<4 ... 1:15<<4
+//cfg0[29:16];    //clock_forced_on_submodules
+#define   HEVC_DBLK_CFG0                           (0x3500)
+#define P_HEVC_DBLK_CFG0                           (volatile unsigned int *)((0x3500  << 2) + 0xff620000)
+//cfg1[1:0];      //ctb_size 0:64x64 1:32x32 2:16x16
+//cfg1[2];        //ignore_out_of_boundary
+//cfg1[3];        //pcm_loop_filter_disabled_flag
+//cfg1[8:4];      //pps_cb_qp_offset (-12~12,inclusive)
+//cfg1[13:9];     //pps_cr_qp_offset (-12~12,inclusive)
+//cfg1[14];       //ctbx,y swap in pu i/f
+//cfg1[15];       //sao_corner_45_degree_all_software_control
+#define   HEVC_DBLK_CFG1                           (0x3501)
+#define P_HEVC_DBLK_CFG1                           (volatile unsigned int *)((0x3501  << 2) + 0xff620000)
+//cfg2[15:0];     //picture_size_width
+//cfg2[31:16];    //picture_size_height
+#define   HEVC_DBLK_CFG2                           (0x3502)
+#define P_HEVC_DBLK_CFG2                           (volatile unsigned int *)((0x3502  << 2) + 0xff620000)
+//cfg3[3:0];      //parameter_axi_arid
+//cfg3[7:4];      //parameter_axi_awid
+//cfg3[11:8];     //parameter_axi_wid
+//cfg3[12];       //parameter_axi_not_check_write_response
+//cfg3[19:16];    //data_axi_arid
+//cfg3[23:20];    //data_axi_awid
+//cfg3[27:24];    //data_axi_wid
+//cfg3[28];       //data_axi_not_check_write_response
+#define   HEVC_DBLK_CFG3                           (0x3503)
+#define P_HEVC_DBLK_CFG3                           (volatile unsigned int *)((0x3503  << 2) + 0xff620000)
+//cfg4[31:0];     //parameter_axi_start_address
+#define   HEVC_DBLK_CFG4                           (0x3504)
+#define P_HEVC_DBLK_CFG4                           (volatile unsigned int *)((0x3504  << 2) + 0xff620000)
+//cfg5[31:0];     //data_axi_start_address
+#define   HEVC_DBLK_CFG5                           (0x3505)
+#define P_HEVC_DBLK_CFG5                           (volatile unsigned int *)((0x3505  << 2) + 0xff620000)
+//cfg6[9:0];      //tile_ctbx
+//cfg6[25:16];    //tile_ctby
+//cfg6[31];       //tile_enabled
+#define   HEVC_DBLK_CFG6                           (0x3506)
+#define P_HEVC_DBLK_CFG6                           (volatile unsigned int *)((0x3506  << 2) + 0xff620000)
+//cfg7[9:0];      //tile_ctbxsize
+//cfg7[25:16];    //tile_ctbysize
+#define   HEVC_DBLK_CFG7                           (0x3507)
+#define P_HEVC_DBLK_CFG7                           (volatile unsigned int *)((0x3507  << 2) + 0xff620000)
+//cfg8[9:0];      //start_ctbx, normally equals to tile_ctbx
+//cfg8[25:16];    //start_ctby, normally equals to tile_ctby
+//cfg8[31];       //start, self_cleared signal, normally set it at the begin of tile
+#define   HEVC_DBLK_CFG8                           (0x3508)
+#define P_HEVC_DBLK_CFG8                           (volatile unsigned int *)((0x3508  << 2) + 0xff620000)
+//cfg9[0]         //loop_filter_across_tiles_enabled_flag
+//cfg9[1]         //loop_filter_across_slices_enabled_flag
+//cfg9[2]         //deblocking_filter_disabled_flag
+//cfg9[6:3]       //beta_offset_div2 (-6~6,inclusive)
+//cfg9[10:7]      //tc_offset_div2 (-6~6,inclusive)
+#define   HEVC_DBLK_CFG9                           (0x3509)
+#define P_HEVC_DBLK_CFG9                           (volatile unsigned int *)((0x3509  << 2) + 0xff620000)
+//cfga[4:0]       //corner45degree{FIFO_CNT}
+//cfga[31:27]     //corner45degree{EN,FIFO_CLR,FIFO_PUSH,DATA,DATA_SEL}
+#define   HEVC_DBLK_CFGA                           (0x350a)
+#define P_HEVC_DBLK_CFGA                           (volatile unsigned int *)((0x350a  << 2) + 0xff620000)
+//cfgb[3:0]       //0:HEVC 1:VP9 ...
+#define   HEVC_DBLK_CFGB                           (0x350b)
+#define P_HEVC_DBLK_CFGB                           (volatile unsigned int *)((0x350b  << 2) + 0xff620000)
+//cfgc[31:0]      //cfg_addr_y1
+#define   HEVC_DBLK_CFGC                           (0x350c)
+#define P_HEVC_DBLK_CFGC                           (volatile unsigned int *)((0x350c  << 2) + 0xff620000)
+//TODO description
+#define   HEVC_DBLK_STS0                           (0x350d)
+#define P_HEVC_DBLK_STS0                           (volatile unsigned int *)((0x350d  << 2) + 0xff620000)
+//TODO description
+#define   HEVC_DBLK_STS1                           (0x350e)
+#define P_HEVC_DBLK_STS1                           (volatile unsigned int *)((0x350e  << 2) + 0xff620000)
+//
+// Closing file:  hevc_dblk_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_SAO module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_sao_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_SAO_CBUS_BASE = 0x06
+// -----------------------------------------------
+#define   HEVC_SAO_VERSION                         (0x3600)
+#define P_HEVC_SAO_VERSION                         (volatile unsigned int *)((0x3600  << 2) + 0xff620000)
+//  [31:0]  reversion               default:32'h00010001
+#define   HEVC_SAO_CTRL0                           (0x3601)
+#define P_HEVC_SAO_CTRL0                           (volatile unsigned int *)((0x3601  << 2) + 0xff620000)
+//  [3:0]   lcu_size_log2
+//  [31]    above intermedia data compress: 0=no-compress,1=compress;default:1'b0
+#define   HEVC_SAO_CTRL1                           (0x3602)
+#define P_HEVC_SAO_CTRL1                           (volatile unsigned int *)((0x3602  << 2) + 0xff620000)
+//  [31:24] ar_fifo1_axi_thred
+//  [23:16] ar_fifo0_axi_thred
+//  [15:14] axi_linealign, 0-16bytes, 1-32bytes, 2-64bytes
+//  [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
+//  [11:08] axi_lendian_C
+//  [07:04] axi_lendian_Y
+//  [3]     reserved
+//  [2]     clk_forceon
+//  [1]     dw_disable:disable double write output
+//  [0]     cm_disable:disable compress output
+#define   HEVC_SAO_INT_EN                          (0x3603)
+#define P_HEVC_SAO_INT_EN                          (volatile unsigned int *)((0x3603  << 2) + 0xff620000)
+//  [0]     sao_int_enable
+//  [1]     sao_int_amrisc_level
+//  [2]     sao_int_cpu_level
+//  [3]     slice_done_int_amrisc_enable
+//  [4]     slice_done_int_cpu_enable
+//  [15]    disable_sao_int_clock_gating
+#define   HEVC_SAO_INT_STATUS                      (0x3604)
+#define P_HEVC_SAO_INT_STATUS                      (volatile unsigned int *)((0x3604  << 2) + 0xff620000)
+//  [0]     slice_done IRQ
+//  [31]    write "1"=slice start(self clear,read always return "0")
+#define   HEVC_SAO_PIC_SIZE                        (0x3605)
+#define P_HEVC_SAO_PIC_SIZE                        (volatile unsigned int *)((0x3605  << 2) + 0xff620000)
+//  [15:0]  pic_width[15:0]
+//  [31:16] pic_height[15:0]
+#define   HEVC_SAO_PIC_SIZE_LCU                    (0x3606)
+#define P_HEVC_SAO_PIC_SIZE_LCU                    (volatile unsigned int *)((0x3606  << 2) + 0xff620000)
+//  [15:0]  lcu_x_num_1[15:0]   (=lcu_x_total-1)
+//  [31:16] lcu_y_num_1[15:0]   (=lcu_y_total-1)
+#define   HEVC_SAO_TILE_START                      (0x3607)
+#define P_HEVC_SAO_TILE_START                      (volatile unsigned int *)((0x3607  << 2) + 0xff620000)
+//  [15:0]  tile_start_lcu_x[15:0]
+//  [31:16] tile_start_lcu_y[15:0]
+#define   HEVC_SAO_TILE_SIZE_LCU                   (0x3608)
+#define P_HEVC_SAO_TILE_SIZE_LCU                   (volatile unsigned int *)((0x3608  << 2) + 0xff620000)
+//  [15:0]  tile_width_lcu[15:0]
+//  [31:16] tile_height_lcu[15:0]
+#define   HEVC_SAO_AXI_WCTRL                       (0x3609)
+#define P_HEVC_SAO_AXI_WCTRL                       (volatile unsigned int *)((0x3609  << 2) + 0xff620000)
+#define   HEVC_SAO_AXI_RCTRL                       (0x360a)
+#define P_HEVC_SAO_AXI_RCTRL                       (volatile unsigned int *)((0x360a  << 2) + 0xff620000)
+#define   HEVC_SAO_Y_START_ADDR                    (0x360b)
+#define P_HEVC_SAO_Y_START_ADDR                    (volatile unsigned int *)((0x360b  << 2) + 0xff620000)
+#define   HEVC_SAO_Y_LENGTH                        (0x360c)
+#define P_HEVC_SAO_Y_LENGTH                        (volatile unsigned int *)((0x360c  << 2) + 0xff620000)
+#define   HEVC_SAO_C_START_ADDR                    (0x360d)
+#define P_HEVC_SAO_C_START_ADDR                    (volatile unsigned int *)((0x360d  << 2) + 0xff620000)
+#define   HEVC_SAO_C_LENGTH                        (0x360e)
+#define P_HEVC_SAO_C_LENGTH                        (volatile unsigned int *)((0x360e  << 2) + 0xff620000)
+#define   HEVC_SAO_Y_WPTR                          (0x360f)
+#define P_HEVC_SAO_Y_WPTR                          (volatile unsigned int *)((0x360f  << 2) + 0xff620000)
+#define   HEVC_SAO_C_WPTR                          (0x3610)
+#define P_HEVC_SAO_C_WPTR                          (volatile unsigned int *)((0x3610  << 2) + 0xff620000)
+#define   HEVC_SAO_ABV_START_ADDR                  (0x3611)
+#define P_HEVC_SAO_ABV_START_ADDR                  (volatile unsigned int *)((0x3611  << 2) + 0xff620000)
+#define   HEVC_SAO_VB_WR_START_ADDR                (0x3612)
+#define P_HEVC_SAO_VB_WR_START_ADDR                (volatile unsigned int *)((0x3612  << 2) + 0xff620000)
+#define   HEVC_SAO_VB_RD_START_ADDR                (0x3613)
+#define P_HEVC_SAO_VB_RD_START_ADDR                (volatile unsigned int *)((0x3613  << 2) + 0xff620000)
+#define   HEVC_SAO_ABV_WPTR                        (0x3614)
+#define P_HEVC_SAO_ABV_WPTR                        (volatile unsigned int *)((0x3614  << 2) + 0xff620000)
+#define   HEVC_SAO_ABV_RPTR                        (0x3615)
+#define P_HEVC_SAO_ABV_RPTR                        (volatile unsigned int *)((0x3615  << 2) + 0xff620000)
+#define   HEVC_SAO_VB_WPTR                         (0x3616)
+#define P_HEVC_SAO_VB_WPTR                         (volatile unsigned int *)((0x3616  << 2) + 0xff620000)
+#define   HEVC_SAO_VB_RPTR                         (0x3617)
+#define P_HEVC_SAO_VB_RPTR                         (volatile unsigned int *)((0x3617  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_MODE0                       (0x361e)
+#define P_HEVC_SAO_DBG_MODE0                       (volatile unsigned int *)((0x361e  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_MODE1                       (0x361f)
+#define P_HEVC_SAO_DBG_MODE1                       (volatile unsigned int *)((0x361f  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL2                           (0x3620)
+#define P_HEVC_SAO_CTRL2                           (volatile unsigned int *)((0x3620  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL3                           (0x3621)
+#define P_HEVC_SAO_CTRL3                           (volatile unsigned int *)((0x3621  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL4                           (0x3622)
+#define P_HEVC_SAO_CTRL4                           (volatile unsigned int *)((0x3622  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL5                           (0x3623)
+#define P_HEVC_SAO_CTRL5                           (volatile unsigned int *)((0x3623  << 2) + 0xff620000)
+//[23:22]  dw_h1_ctrl   default:2'b11
+//[21:20]  dw_h0_ctrl   default:2'b11
+//[19:18]  dw_h1_ctrl   default:2'b11
+//[17:16]  dw_h0_ctrl   default:2'b11
+#define   HEVC_SAO_CTRL6                           (0x3624)
+#define P_HEVC_SAO_CTRL6                           (volatile unsigned int *)((0x3624  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL7                           (0x3625)
+#define P_HEVC_SAO_CTRL7                           (volatile unsigned int *)((0x3625  << 2) + 0xff620000)
+#define   HEVC_CM_BODY_START_ADDR                  (0x3626)
+#define P_HEVC_CM_BODY_START_ADDR                  (volatile unsigned int *)((0x3626  << 2) + 0xff620000)
+#define   HEVC_CM_BODY_LENGTH                      (0x3627)
+#define P_HEVC_CM_BODY_LENGTH                      (volatile unsigned int *)((0x3627  << 2) + 0xff620000)
+#define   HEVC_CM_HEADER_START_ADDR                (0x3628)
+#define P_HEVC_CM_HEADER_START_ADDR                (volatile unsigned int *)((0x3628  << 2) + 0xff620000)
+#define   HEVC_CM_HEADER_LENGTH                    (0x3629)
+#define P_HEVC_CM_HEADER_LENGTH                    (volatile unsigned int *)((0x3629  << 2) + 0xff620000)
+#define   HEVC_CM_COLOR                            (0x362a)
+#define P_HEVC_CM_COLOR                            (volatile unsigned int *)((0x362a  << 2) + 0xff620000)
+#define   HEVC_CM_HEADER_OFFSET                    (0x362b)
+#define P_HEVC_CM_HEADER_OFFSET                    (volatile unsigned int *)((0x362b  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL8                           (0x362c)
+#define P_HEVC_SAO_CTRL8                           (volatile unsigned int *)((0x362c  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL9                           (0x362d)
+#define P_HEVC_SAO_CTRL9                           (volatile unsigned int *)((0x362d  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL10                          (0x362e)
+#define P_HEVC_SAO_CTRL10                          (volatile unsigned int *)((0x362e  << 2) + 0xff620000)
+#define   HEVC_SAO_CTRL11                          (0x362f)
+#define P_HEVC_SAO_CTRL11                          (volatile unsigned int *)((0x362f  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_0                      (0x3630)
+#define P_HEVC_SAO_DBG_DATA_0                      (volatile unsigned int *)((0x3630  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_1                      (0x3631)
+#define P_HEVC_SAO_DBG_DATA_1                      (volatile unsigned int *)((0x3631  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_2                      (0x3632)
+#define P_HEVC_SAO_DBG_DATA_2                      (volatile unsigned int *)((0x3632  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_3                      (0x3633)
+#define P_HEVC_SAO_DBG_DATA_3                      (volatile unsigned int *)((0x3633  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_4                      (0x3634)
+#define P_HEVC_SAO_DBG_DATA_4                      (volatile unsigned int *)((0x3634  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_5                      (0x3635)
+#define P_HEVC_SAO_DBG_DATA_5                      (volatile unsigned int *)((0x3635  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_6                      (0x3636)
+#define P_HEVC_SAO_DBG_DATA_6                      (volatile unsigned int *)((0x3636  << 2) + 0xff620000)
+#define   HEVC_SAO_DBG_DATA_7                      (0x3637)
+#define P_HEVC_SAO_DBG_DATA_7                      (volatile unsigned int *)((0x3637  << 2) + 0xff620000)
+#define   HEVC_SAO_MMU_WR                          (0x3638)
+#define P_HEVC_SAO_MMU_WR                          (volatile unsigned int *)((0x3638  << 2) + 0xff620000)
+#define   HEVC_SAO_MMU_STATUS                      (0x3639)
+#define P_HEVC_SAO_MMU_STATUS                      (volatile unsigned int *)((0x3639  << 2) + 0xff620000)
+//Read Only
+//sao_mmu_fifo is 16(depth)x20(bits)
+//[0]   mmu_fifo_empty  1=empty,0=not-empty
+//[1]   mmu_fifo_full   1=full,0=not-full
+//[7:4] mmu_fifo_depth[3:0]
+//[11:8] mmu_fifo_room[3:0]
+#define   HEVC_SAO_MMU_VH0_ADDR                    (0x363a)
+#define P_HEVC_SAO_MMU_VH0_ADDR                    (volatile unsigned int *)((0x363a  << 2) + 0xff620000)
+#define   HEVC_SAO_MMU_VH1_ADDR                    (0x363b)
+#define P_HEVC_SAO_MMU_VH1_ADDR                    (volatile unsigned int *)((0x363b  << 2) + 0xff620000)
+#define   HEVC_SAO_MMU_WPTR                        (0x363c)
+#define P_HEVC_SAO_MMU_WPTR                        (volatile unsigned int *)((0x363c  << 2) + 0xff620000)
+#define   HEVC_SAO_MMU_RPTR                        (0x363d)
+#define P_HEVC_SAO_MMU_RPTR                        (volatile unsigned int *)((0x363d  << 2) + 0xff620000)
+//
+// Closing file:  hevc_sao_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_IQIT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_iqit_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_IQIT_CBUS_BASE = 0x07
+// -----------------------------------------------
+// [    2] RW en_freeclk.   0=Auto-gated clock for saving power;
+//                          1=Free running clock if something wrong with auto-gating.
+//                          Default 0.
+// [    1] RW enable_clk.   0=Disable clock; 1=Enable clock.        Default 0.
+#define   HEVC_IQIT_CLK_RST_CTRL                   (0x3700)
+#define P_HEVC_IQIT_CLK_RST_CTRL                   (volatile unsigned int *)((0x3700  << 2) + 0xff620000)
+// [ 5: 4] RW ctb_size.     0=8x8; 1=16x16; 2=32x32; 3=64x64.                       Default 0.
+// [    3] RW itr_skip_mode. For dealing with discrepancy between Spec and C model for transform_skip.
+//                          0=Follow Spec; 1=Follow C model.                        Default 0.
+// [    2] RW scalelist_mode. Applicable only when scalelist_en=1.
+//                          0=Use default scaling factor list;
+//                          1=Use scaling factor list define in bit stream.
+//                          Default 0.
+// [    1] RW scalelist_en. 0=Use flat scale; 1=Use scaling factor list.            Default 0.
+// [    0] RW diagscan_en.  0=Linear lookup dQ table; 1=Diagonally lookup dQ table. Default 0.
+#define   HEVC_IQIT_DEQUANT_CTRL                   (0x3701)
+#define P_HEVC_IQIT_DEQUANT_CTRL                   (volatile unsigned int *)((0x3701  << 2) + 0xff620000)
+// [31:10] WR Reserved.                                 Default 0.
+// [ 9: 0] WR scalelut_addr.                            Default 0.
+#define   HEVC_IQIT_SCALELUT_WR_ADDR               (0x3702)
+#define P_HEVC_IQIT_SCALELUT_WR_ADDR               (volatile unsigned int *)((0x3702  << 2) + 0xff620000)
+// [31:10] RD Reserved.                                 Default 0.
+// [ 9: 0] RD scalelut_addr.                            Default 0.
+#define   HEVC_IQIT_SCALELUT_RD_ADDR               (0x3703)
+#define P_HEVC_IQIT_SCALELUT_RD_ADDR               (volatile unsigned int *)((0x3703  << 2) + 0xff620000)
+// [ 7: 0] RW LUT data.
+#define   HEVC_IQIT_SCALELUT_DATA                  (0x3704)
+#define P_HEVC_IQIT_SCALELUT_DATA                  (volatile unsigned int *)((0x3704  << 2) + 0xff620000)
+//---------------------------------------------------
+// tab_idx [2:0] -
+//    0-5 use custom table index
+//    6 - reserved
+//    7 - use default table
+//---------------------------------------------------
+// [22:20] 4x4 tab 5
+// [   19] reserved
+// [18:16] 4x4 tab 4
+// [   15] reserved
+// [14:12] 4x4 tab 3
+// [   11] reserved
+// [10: 8] 4x4 tab 2
+// [    7] reserved
+// [ 6: 4] 4x4 tab 1
+// [    3] reserved
+// [ 2: 0] 4x4 tab 0
+#define   HEVC_IQIT_SCALELUT_IDX_4                 (0x3705)
+#define P_HEVC_IQIT_SCALELUT_IDX_4                 (volatile unsigned int *)((0x3705  << 2) + 0xff620000)
+// [22:20] 8x8 tab 5
+// [   19] reserved
+// [18:16] 8x8 tab 4
+// [   15] reserved
+// [14:12] 8x8 tab 3
+// [   11] reserved
+// [10: 8] 8x8 tab 2
+// [    7] reserved
+// [ 6: 4] 8x8 tab 1
+// [    3] reserved
+// [ 2: 0] 8x8 tab 0
+#define   HEVC_IQIT_SCALELUT_IDX_8                 (0x3706)
+#define P_HEVC_IQIT_SCALELUT_IDX_8                 (volatile unsigned int *)((0x3706  << 2) + 0xff620000)
+// [   31] reserved
+// [30:28] 32x32 tab 1
+// [   27] reserved
+// [26:24] 32x32 tab 0
+// [   23] reserved
+// [22:20] 16x16 tab 5
+// [   19] reserved
+// [18:16] 16x16 tab 4
+// [   15] reserved
+// [14:12] 16x16 tab 3
+// [   11] reserved
+// [10: 8] 16x16 tab 2
+// [    7] reserved
+// [ 6: 4] 16x16 tab 1
+// [    3] reserved
+// [ 2: 0] 16x16 tab 0
+#define   HEVC_IQIT_SCALELUT_IDX_16_32             (0x3707)
+#define P_HEVC_IQIT_SCALELUT_IDX_16_32             (volatile unsigned int *)((0x3707  << 2) + 0xff620000)
+// [ 8: 2] R  tuinfo_fifo_cnt.
+// [    1] R  fifo_has_room.
+// [    0] R  mem_init_done.
+#define   HEVC_IQIT_STAT_GEN0                      (0x3708)
+#define P_HEVC_IQIT_STAT_GEN0                      (volatile unsigned int *)((0x3708  << 2) + 0xff620000)
+// [   23] RW cntl_qp_cr_valid.
+// [21:16] RW cntl_qp_cr.
+// [   15] RW cntl_qp_cb_valid.
+// [13: 8] RW cntl_qp_cb.
+// [    7] RW cntl_qp_y_valid.
+// [ 5: 0] RW cntl_qp_y.
+#define   HEVC_QP_WRITE                            (0x3709)
+#define P_HEVC_QP_WRITE                            (volatile unsigned int *)((0x3709  << 2) + 0xff620000)
+// [31:30] R  ipp_size.
+// [28:24] R  ipp_mem_ptr.
+// [23:22] R  itr2_size.
+// [20:16] R  itr2_mem_ptr.
+// [15:14] R  itr1_size.
+// [12: 8] R  itr1_mem_ptr.
+// [ 7: 6] R  iq_size.
+// [ 4: 0] R  iq_mem_ptr.
+#define   HEVC_IQIT_STAT_GEN1                      (0x370a)
+#define P_HEVC_IQIT_STAT_GEN1                      (volatile unsigned int *)((0x370a  << 2) + 0xff620000)
+// [ 5: 4] RW cntl_bitdepth_c. 0=8-bit; 1=9-bit; 2=10-bit.
+// [ 1: 0] RW cntl_bitdepth_y. 0=8-bit; 1=9-bit; 2=10-bit.
+#define   HEVC_IQIT_BITDEPTH                       (0x370b)
+#define P_HEVC_IQIT_BITDEPTH                       (volatile unsigned int *)((0x370b  << 2) + 0xff620000)
+// [   10] R  ipp_active.
+// [    9] R  itr2_active.
+// [    8] R  itr1_active.
+// [ 5: 0] R  mem_spare_num.
+#define   HEVC_IQIT_STAT_GEN2                      (0x370c)
+#define P_HEVC_IQIT_STAT_GEN2                      (volatile unsigned int *)((0x370c  << 2) + 0xff620000)
+#define   HEVC_IQIT_AVS2_WQP_0123                  (0x370d)
+#define P_HEVC_IQIT_AVS2_WQP_0123                  (volatile unsigned int *)((0x370d  << 2) + 0xff620000)
+#define   HEVC_IQIT_AVS2_WQP_45                    (0x370e)
+#define P_HEVC_IQIT_AVS2_WQP_45                    (volatile unsigned int *)((0x370e  << 2) + 0xff620000)
+#define   HEVC_IQIT_AVS2_QP_DELTA                  (0x370f)
+#define P_HEVC_IQIT_AVS2_QP_DELTA                  (volatile unsigned int *)((0x370f  << 2) + 0xff620000)
+//
+// Closing file:  hevc_iqit_regs.h
+//
+//------------------------------------------------------------------------------
+//  DOS top-level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_TOP_CBUS_BASE = 0x3f
+// -----------------------------------------------
+// [0]  reserved
+// [1]  Reset Dos top level registers, except sw_reset0/1/2 which is only reset by external reset_n.
+// [2]  VDEC1 Reset assist, mdec's CBUS
+// [3]  VDEC1 Reset mdec's VLD
+// [4]  VDEC1 Reset mdec's VLD
+// [5]  VDEC1 Reset mdec's VLD
+// [6]  VDEC1 Reset mdec's IQIDCT
+// [7]  VDEC1 Reset mdec's MC
+// [8]  VDEC1 Reset mdec's DBLK
+// [9]  VDEC1 Reset mdec's PIC_DC
+// [10] VDEC1 Reset mdec's Pscale
+// [11] VDEC1 Reset vcpu's MCPU
+// [12] VDEC1 Reset vcpu's CCPU
+// [13] VDEC1 Reset mmc_pre_arb
+#define   DOS_SW_RESET0                            (0x3f00)
+#define P_DOS_SW_RESET0                            (volatile unsigned int *)((0x3f00  << 2) + 0xff620000)
+// [31:27] reserved
+// [26] hcodec clk_en for henc assist
+// [25:22] reserved
+// [21] hcodec clk_en for henc qdct
+// [20] hcodec clk_en for henc vlc
+// [19] hcodec clk_en for assist and cbus
+// [18] hcodec clk_en for ddr
+// [17] hcodec clk_en for vcpu
+// [16] hcodec clk_en for hdec assist
+// [15] hcodec clk_en for hdec dblk
+// [14] reserved
+// [13] hcodec clk_en for hdec mc
+// [12] hcodec clk_en for hdec pic_dc
+// [11:10] reserved
+// [9] vdec clk_en for vdec assist and cbus
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for mdec vld
+// [5] vdec clk_en for mdec psc
+// [4] vdec clk_en for mdec pic_dc
+// [3] vdec clk_en for mdec mc
+// [2] vdec clk_en for mdec iqidct
+// [1] vdec clk_en for mdec dblk
+// [0] vdec clk_en for mdec assist
+#define   DOS_GCLK_EN0                             (0x3f01)
+#define P_DOS_GCLK_EN0                             (volatile unsigned int *)((0x3f01  << 2) + 0xff620000)
+#define   DOS_GEN_CTRL0                            (0x3f02)
+#define P_DOS_GEN_CTRL0                            (volatile unsigned int *)((0x3f02  << 2) + 0xff620000)
+#define   DOS_APB_ERR_CTRL                         (0x3f03)
+#define P_DOS_APB_ERR_CTRL                         (volatile unsigned int *)((0x3f03  << 2) + 0xff620000)
+#define   DOS_APB_ERR_STAT                         (0x3f04)
+#define P_DOS_APB_ERR_STAT                         (volatile unsigned int *)((0x3f04  << 2) + 0xff620000)
+#define   DOS_VDEC_INT_EN                          (0x3f05)
+#define P_DOS_VDEC_INT_EN                          (volatile unsigned int *)((0x3f05  << 2) + 0xff620000)
+#define   DOS_HCODEC_INT_EN                        (0x3f06)
+#define P_DOS_HCODEC_INT_EN                        (volatile unsigned int *)((0x3f06  << 2) + 0xff620000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  HCODEC Reset assist, hdec's CBUS
+// [3]  HCODEC Reset hdec's VLD
+// [4]  HCODEC Reset hdec's VLD
+// [5]  HCODEC Reset hdec's VLD
+// [6]  HCODEC Reset hdec's IQIDCT
+// [7]  HCODEC Reset hdec's MC
+// [8]  HCODEC Reset hdec's DBLK
+// [9]  HCODEC Reset hdec's PIC_DC
+// [10] HCODEC Reset hdec's Pscale
+// [11] HCODEC Reset vcpu's MCPU
+// [12] HCODEC Reset vcpu's CCPU
+// [13] HCODEC Reset mmc_pre_arb
+// [14] HCODEC Reserved
+// [15] HCODEC Reserved
+// [16] HCODEC Reset henc's VLC
+#define   DOS_SW_RESET1                            (0x3f07)
+#define P_DOS_SW_RESET1                            (volatile unsigned int *)((0x3f07  << 2) + 0xff620000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  VDEC2 Reset assist, mdec's CBUS
+// [3]  VDEC2 Reset mdec's VLD
+// [4]  VDEC2 Reset mdec's VLD
+// [5]  VDEC2 Reset mdec's VLD
+// [6]  VDEC2 Reset mdec's IQIDCT
+// [7]  VDEC2 Reset mdec's MC
+// [8]  VDEC2 Reset mdec's DBLK
+// [9]  VDEC2 Reset mdec's PIC_DC
+// [10] VDEC2 Reset mdec's Pscale
+// [11] VDEC2 Reset vcpu's MCPU
+// [12] VDEC2 Reset vcpu's CCPU
+// [13] VDEC2 Reset mmc_pre_arb
+#define   DOS_SW_RESET2                            (0x3f08)
+#define P_DOS_SW_RESET2                            (volatile unsigned int *)((0x3f08  << 2) + 0xff620000)
+// [31:10] Reserved
+// [9] vdec2 clk_en for assist and cbus.
+// [8] vdec2 clk_en for ddr;
+// [7] vdec2 clk_en for vcpu;
+// [6] vdec2 clk_en for mdec vld
+// [5] vdec2 clk_en for mdec psc
+// [4] vdec2 clk_en for mdec pic_dc
+// [3] vdec2 clk_en for mdec mc
+// [2] vdec2 clk_en for mdec iqidct
+// [1] vdec2 clk_en for mdec dblk
+// [0] vdec2 clk_en for mdec assist
+#define   DOS_GCLK_EN1                             (0x3f09)
+#define P_DOS_GCLK_EN1                             (volatile unsigned int *)((0x3f09  << 2) + 0xff620000)
+#define   DOS_VDEC2_INT_EN                         (0x3f0a)
+#define P_DOS_VDEC2_INT_EN                         (volatile unsigned int *)((0x3f0a  << 2) + 0xff620000)
+#define   DOS_VDIN_LCNT                            (0x3f0b)
+#define P_DOS_VDIN_LCNT                            (volatile unsigned int *)((0x3f0b  << 2) + 0xff620000)
+#define   DOS_VDIN_FCNT                            (0x3f0c)
+#define P_DOS_VDIN_FCNT                            (volatile unsigned int *)((0x3f0c  << 2) + 0xff620000)
+#define   DOS_VDIN_CCTL                            (0x3f0d)
+#define P_DOS_VDIN_CCTL                            (volatile unsigned int *)((0x3f0d  << 2) + 0xff620000)
+#define   DOS_SCRATCH0                             (0x3f10)
+#define P_DOS_SCRATCH0                             (volatile unsigned int *)((0x3f10  << 2) + 0xff620000)
+#define   DOS_SCRATCH1                             (0x3f11)
+#define P_DOS_SCRATCH1                             (volatile unsigned int *)((0x3f11  << 2) + 0xff620000)
+#define   DOS_SCRATCH2                             (0x3f12)
+#define P_DOS_SCRATCH2                             (volatile unsigned int *)((0x3f12  << 2) + 0xff620000)
+#define   DOS_SCRATCH3                             (0x3f13)
+#define P_DOS_SCRATCH3                             (volatile unsigned int *)((0x3f13  << 2) + 0xff620000)
+#define   DOS_SCRATCH4                             (0x3f14)
+#define P_DOS_SCRATCH4                             (volatile unsigned int *)((0x3f14  << 2) + 0xff620000)
+#define   DOS_SCRATCH5                             (0x3f15)
+#define P_DOS_SCRATCH5                             (volatile unsigned int *)((0x3f15  << 2) + 0xff620000)
+#define   DOS_SCRATCH6                             (0x3f16)
+#define P_DOS_SCRATCH6                             (volatile unsigned int *)((0x3f16  << 2) + 0xff620000)
+#define   DOS_SCRATCH7                             (0x3f17)
+#define P_DOS_SCRATCH7                             (volatile unsigned int *)((0x3f17  << 2) + 0xff620000)
+#define   DOS_SCRATCH8                             (0x3f18)
+#define P_DOS_SCRATCH8                             (volatile unsigned int *)((0x3f18  << 2) + 0xff620000)
+#define   DOS_SCRATCH9                             (0x3f19)
+#define P_DOS_SCRATCH9                             (volatile unsigned int *)((0x3f19  << 2) + 0xff620000)
+#define   DOS_SCRATCH10                            (0x3f1a)
+#define P_DOS_SCRATCH10                            (volatile unsigned int *)((0x3f1a  << 2) + 0xff620000)
+#define   DOS_SCRATCH11                            (0x3f1b)
+#define P_DOS_SCRATCH11                            (volatile unsigned int *)((0x3f1b  << 2) + 0xff620000)
+#define   DOS_SCRATCH12                            (0x3f1c)
+#define P_DOS_SCRATCH12                            (volatile unsigned int *)((0x3f1c  << 2) + 0xff620000)
+#define   DOS_SCRATCH13                            (0x3f1d)
+#define P_DOS_SCRATCH13                            (volatile unsigned int *)((0x3f1d  << 2) + 0xff620000)
+#define   DOS_SCRATCH14                            (0x3f1e)
+#define P_DOS_SCRATCH14                            (volatile unsigned int *)((0x3f1e  << 2) + 0xff620000)
+#define   DOS_SCRATCH15                            (0x3f1f)
+#define P_DOS_SCRATCH15                            (volatile unsigned int *)((0x3f1f  << 2) + 0xff620000)
+#define   DOS_SCRATCH16                            (0x3f20)
+#define P_DOS_SCRATCH16                            (volatile unsigned int *)((0x3f20  << 2) + 0xff620000)
+#define   DOS_SCRATCH17                            (0x3f21)
+#define P_DOS_SCRATCH17                            (volatile unsigned int *)((0x3f21  << 2) + 0xff620000)
+#define   DOS_SCRATCH18                            (0x3f22)
+#define P_DOS_SCRATCH18                            (volatile unsigned int *)((0x3f22  << 2) + 0xff620000)
+#define   DOS_SCRATCH19                            (0x3f23)
+#define P_DOS_SCRATCH19                            (volatile unsigned int *)((0x3f23  << 2) + 0xff620000)
+#define   DOS_SCRATCH20                            (0x3f24)
+#define P_DOS_SCRATCH20                            (volatile unsigned int *)((0x3f24  << 2) + 0xff620000)
+#define   DOS_SCRATCH21                            (0x3f25)
+#define P_DOS_SCRATCH21                            (volatile unsigned int *)((0x3f25  << 2) + 0xff620000)
+#define   DOS_SCRATCH22                            (0x3f26)
+#define P_DOS_SCRATCH22                            (volatile unsigned int *)((0x3f26  << 2) + 0xff620000)
+#define   DOS_SCRATCH23                            (0x3f27)
+#define P_DOS_SCRATCH23                            (volatile unsigned int *)((0x3f27  << 2) + 0xff620000)
+#define   DOS_SCRATCH24                            (0x3f28)
+#define P_DOS_SCRATCH24                            (volatile unsigned int *)((0x3f28  << 2) + 0xff620000)
+#define   DOS_SCRATCH25                            (0x3f29)
+#define P_DOS_SCRATCH25                            (volatile unsigned int *)((0x3f29  << 2) + 0xff620000)
+#define   DOS_SCRATCH26                            (0x3f2a)
+#define P_DOS_SCRATCH26                            (volatile unsigned int *)((0x3f2a  << 2) + 0xff620000)
+#define   DOS_SCRATCH27                            (0x3f2b)
+#define P_DOS_SCRATCH27                            (volatile unsigned int *)((0x3f2b  << 2) + 0xff620000)
+#define   DOS_SCRATCH28                            (0x3f2c)
+#define P_DOS_SCRATCH28                            (volatile unsigned int *)((0x3f2c  << 2) + 0xff620000)
+#define   DOS_SCRATCH29                            (0x3f2d)
+#define P_DOS_SCRATCH29                            (volatile unsigned int *)((0x3f2d  << 2) + 0xff620000)
+#define   DOS_SCRATCH30                            (0x3f2e)
+#define P_DOS_SCRATCH30                            (volatile unsigned int *)((0x3f2e  << 2) + 0xff620000)
+#define   DOS_SCRATCH31                            (0x3f2f)
+#define P_DOS_SCRATCH31                            (volatile unsigned int *)((0x3f2f  << 2) + 0xff620000)
+#define   DOS_MEM_PD_VDEC                          (0x3f30)
+#define P_DOS_MEM_PD_VDEC                          (volatile unsigned int *)((0x3f30  << 2) + 0xff620000)
+#define   DOS_MEM_PD_VDEC2                         (0x3f31)
+#define P_DOS_MEM_PD_VDEC2                         (volatile unsigned int *)((0x3f31  << 2) + 0xff620000)
+#define   DOS_MEM_PD_HCODEC                        (0x3f32)
+#define P_DOS_MEM_PD_HCODEC                        (volatile unsigned int *)((0x3f32  << 2) + 0xff620000)
+#define   DOS_MEM_PD_HEVC                          (0x3f33)
+#define P_DOS_MEM_PD_HEVC                          (volatile unsigned int *)((0x3f33  << 2) + 0xff620000)
+#define   DOS_SW_RESET3                            (0x3f34)
+#define P_DOS_SW_RESET3                            (volatile unsigned int *)((0x3f34  << 2) + 0xff620000)
+#define   DOS_GCLK_EN3                             (0x3f35)
+#define P_DOS_GCLK_EN3                             (volatile unsigned int *)((0x3f35  << 2) + 0xff620000)
+#define   DOS_HEVC_INT_EN                          (0x3f36)
+#define P_DOS_HEVC_INT_EN                          (volatile unsigned int *)((0x3f36  << 2) + 0xff620000)
+#define   DOS_SW_RESET4                            (0x3f37)
+#define P_DOS_SW_RESET4                            (volatile unsigned int *)((0x3f37  << 2) + 0xff620000)
+#define   DOS_GCLK_EN4                             (0x3f38)
+#define P_DOS_GCLK_EN4                             (volatile unsigned int *)((0x3f38  << 2) + 0xff620000)
+#define   DOS_MEM_PD_VP9DEC                        (0x3f39)
+#define P_DOS_MEM_PD_VP9DEC                        (volatile unsigned int *)((0x3f39  << 2) + 0xff620000)
+// bit[31]    mcrcc_stall_en
+// bit[30:28] Reserved
+// bit[27:20] target_canvas
+// bit[19:10] target_mby
+// bit[ 9: 0] target_mbx
+#define   DOS_VDEC_MCRCC_STALL_CTRL                (0x3f40)
+#define P_DOS_VDEC_MCRCC_STALL_CTRL                (volatile unsigned int *)((0x3f40  << 2) + 0xff620000)
+#define   DOS_VDEC_MCRCC_STALL2_CTRL               (0x3f42)
+#define P_DOS_VDEC_MCRCC_STALL2_CTRL               (volatile unsigned int *)((0x3f42  << 2) + 0xff620000)
+#define   DOS_VDEC2_MCRCC_STALL_CTRL               (0x3f41)
+#define P_DOS_VDEC2_MCRCC_STALL_CTRL               (volatile unsigned int *)((0x3f41  << 2) + 0xff620000)
+#define   DOS_VDEC2_MCRCC_STALL2_CTRL              (0x3f43)
+#define P_DOS_VDEC2_MCRCC_STALL2_CTRL              (volatile unsigned int *)((0x3f43  << 2) + 0xff620000)
+// bit[1] s_clk off
+// bit[0] m_clk off
+#define   DOS_CFG_CMPIF_BRIDGE                     (0x3f44)
+#define P_DOS_CFG_CMPIF_BRIDGE                     (volatile unsigned int *)((0x3f44  << 2) + 0xff620000)
+#define   DOS_SECURE_CTL_INDEX                     (0x3f80)
+#define P_DOS_SECURE_CTL_INDEX                     (volatile unsigned int *)((0x3f80  << 2) + 0xff620000)
+#define   DOS_SECURE_CTL_DATA                      (0x3f81)
+#define P_DOS_SECURE_CTL_DATA                      (volatile unsigned int *)((0x3f81  << 2) + 0xff620000)
+#define   DOS_SECURE_REG_NULL                      (0x3f82)
+#define P_DOS_SECURE_REG_NULL                      (volatile unsigned int *)((0x3f82  << 2) + 0xff620000)
+//
+// Closing file:  ./dos_param.h
+//
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define   HCODEC_MC_CTRL_REG                       (0x1900)
+#define P_HCODEC_MC_CTRL_REG                       (volatile unsigned int *)((0x1900  << 2) + 0xff620000)
+#define   HCODEC_MC_MB_INFO                        (0x1901)
+#define P_HCODEC_MC_MB_INFO                        (volatile unsigned int *)((0x1901  << 2) + 0xff620000)
+#define   HCODEC_MC_PIC_INFO                       (0x1902)
+#define P_HCODEC_MC_PIC_INFO                       (volatile unsigned int *)((0x1902  << 2) + 0xff620000)
+#define   HCODEC_MC_HALF_PEL_ONE                   (0x1903)
+#define P_HCODEC_MC_HALF_PEL_ONE                   (volatile unsigned int *)((0x1903  << 2) + 0xff620000)
+#define   HCODEC_MC_HALF_PEL_TWO                   (0x1904)
+#define P_HCODEC_MC_HALF_PEL_TWO                   (volatile unsigned int *)((0x1904  << 2) + 0xff620000)
+#define   HCODEC_POWER_CTL_MC                      (0x1905)
+#define P_HCODEC_POWER_CTL_MC                      (volatile unsigned int *)((0x1905  << 2) + 0xff620000)
+#define   HCODEC_MC_CMD                            (0x1906)
+#define P_HCODEC_MC_CMD                            (volatile unsigned int *)((0x1906  << 2) + 0xff620000)
+#define   HCODEC_MC_CTRL0                          (0x1907)
+#define P_HCODEC_MC_CTRL0                          (volatile unsigned int *)((0x1907  << 2) + 0xff620000)
+#define   HCODEC_MC_PIC_W_H                        (0x1908)
+#define P_HCODEC_MC_PIC_W_H                        (volatile unsigned int *)((0x1908  << 2) + 0xff620000)
+#define   HCODEC_MC_STATUS0                        (0x1909)
+#define P_HCODEC_MC_STATUS0                        (volatile unsigned int *)((0x1909  << 2) + 0xff620000)
+#define   HCODEC_MC_STATUS1                        (0x190a)
+#define P_HCODEC_MC_STATUS1                        (volatile unsigned int *)((0x190a  << 2) + 0xff620000)
+#define   HCODEC_MC_CTRL1                          (0x190b)
+#define P_HCODEC_MC_CTRL1                          (volatile unsigned int *)((0x190b  << 2) + 0xff620000)
+#define   HCODEC_MC_MIX_RATIO0                     (0x190c)
+#define P_HCODEC_MC_MIX_RATIO0                     (volatile unsigned int *)((0x190c  << 2) + 0xff620000)
+#define   HCODEC_MC_MIX_RATIO1                     (0x190d)
+#define P_HCODEC_MC_MIX_RATIO1                     (volatile unsigned int *)((0x190d  << 2) + 0xff620000)
+#define   HCODEC_MC_DP_MB_XY                       (0x190e)
+#define P_HCODEC_MC_DP_MB_XY                       (volatile unsigned int *)((0x190e  << 2) + 0xff620000)
+#define   HCODEC_MC_OM_MB_XY                       (0x190f)
+#define P_HCODEC_MC_OM_MB_XY                       (volatile unsigned int *)((0x190f  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_RST                        (0x1910)
+#define P_HCODEC_PSCALE_RST                        (volatile unsigned int *)((0x1910  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_CTRL                       (0x1911)
+#define P_HCODEC_PSCALE_CTRL                       (volatile unsigned int *)((0x1911  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_PICI_W                     (0x1912)
+#define P_HCODEC_PSCALE_PICI_W                     (volatile unsigned int *)((0x1912  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_PICI_H                     (0x1913)
+#define P_HCODEC_PSCALE_PICI_H                     (volatile unsigned int *)((0x1913  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_PICO_W                     (0x1914)
+#define P_HCODEC_PSCALE_PICO_W                     (volatile unsigned int *)((0x1914  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_PICO_H                     (0x1915)
+#define P_HCODEC_PSCALE_PICO_H                     (volatile unsigned int *)((0x1915  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_PICO_START_X               (0x1916)
+#define P_HCODEC_PSCALE_PICO_START_X               (volatile unsigned int *)((0x1916  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_PICO_START_Y               (0x1917)
+#define P_HCODEC_PSCALE_PICO_START_Y               (volatile unsigned int *)((0x1917  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_DUMMY                      (0x1918)
+#define P_HCODEC_PSCALE_DUMMY                      (volatile unsigned int *)((0x1918  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_FILT0_COEF0                (0x1919)
+#define P_HCODEC_PSCALE_FILT0_COEF0                (volatile unsigned int *)((0x1919  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_FILT0_COEF1                (0x191a)
+#define P_HCODEC_PSCALE_FILT0_COEF1                (volatile unsigned int *)((0x191a  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_CMD_CTRL                   (0x191b)
+#define P_HCODEC_PSCALE_CMD_CTRL                   (volatile unsigned int *)((0x191b  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_CMD_BLK_X                  (0x191c)
+#define P_HCODEC_PSCALE_CMD_BLK_X                  (volatile unsigned int *)((0x191c  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_CMD_BLK_Y                  (0x191d)
+#define P_HCODEC_PSCALE_CMD_BLK_Y                  (volatile unsigned int *)((0x191d  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_STATUS                     (0x191e)
+#define P_HCODEC_PSCALE_STATUS                     (volatile unsigned int *)((0x191e  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_BMEM_ADDR                  (0x191f)
+#define P_HCODEC_PSCALE_BMEM_ADDR                  (volatile unsigned int *)((0x191f  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_BMEM_DAT                   (0x1920)
+#define P_HCODEC_PSCALE_BMEM_DAT                   (volatile unsigned int *)((0x1920  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_DRAM_BUF_CTRL              (0x1921)
+#define P_HCODEC_PSCALE_DRAM_BUF_CTRL              (volatile unsigned int *)((0x1921  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_MCMD_CTRL                  (0x1922)
+#define P_HCODEC_PSCALE_MCMD_CTRL                  (volatile unsigned int *)((0x1922  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_MCMD_XSIZE                 (0x1923)
+#define P_HCODEC_PSCALE_MCMD_XSIZE                 (volatile unsigned int *)((0x1923  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_MCMD_YSIZE                 (0x1924)
+#define P_HCODEC_PSCALE_MCMD_YSIZE                 (volatile unsigned int *)((0x1924  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_RBUF_START_BLKX            (0x1925)
+#define P_HCODEC_PSCALE_RBUF_START_BLKX            (volatile unsigned int *)((0x1925  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_RBUF_START_BLKY            (0x1926)
+#define P_HCODEC_PSCALE_RBUF_START_BLKY            (volatile unsigned int *)((0x1926  << 2) + 0xff620000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define   HCODEC_PSCALE_PICO_SHIFT_XY              (0x1928)
+#define P_HCODEC_PSCALE_PICO_SHIFT_XY              (volatile unsigned int *)((0x1928  << 2) + 0xff620000)
+#define   HCODEC_PSCALE_CTRL1                      (0x1929)
+#define P_HCODEC_PSCALE_CTRL1                      (volatile unsigned int *)((0x1929  << 2) + 0xff620000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less,
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define   HCODEC_PSCALE_SRCKEY_CTRL0               (0x192a)
+#define P_HCODEC_PSCALE_SRCKEY_CTRL0               (volatile unsigned int *)((0x192a  << 2) + 0xff620000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define   HCODEC_PSCALE_SRCKEY_CTRL1               (0x192b)
+#define P_HCODEC_PSCALE_SRCKEY_CTRL1               (volatile unsigned int *)((0x192b  << 2) + 0xff620000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define   HCODEC_PSCALE_CANVAS_RD_ADDR             (0x192c)
+#define P_HCODEC_PSCALE_CANVAS_RD_ADDR             (volatile unsigned int *)((0x192c  << 2) + 0xff620000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define   HCODEC_PSCALE_CANVAS_WR_ADDR             (0x192d)
+#define P_HCODEC_PSCALE_CANVAS_WR_ADDR             (volatile unsigned int *)((0x192d  << 2) + 0xff620000)
+//bit 13:8 pscale thread ID and token
+//bit 7 disable write response count adding to busy bit
+//bit 5:0  pscale prearbitor burst num
+#define   HCODEC_PSCALE_CTRL2                      (0x192e)
+#define P_HCODEC_PSCALE_CTRL2                      (volatile unsigned int *)((0x192e  << 2) + 0xff620000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define   HCODEC_HDEC_MC_OMEM_AUTO                 (0x1930)
+#define P_HCODEC_HDEC_MC_OMEM_AUTO                 (volatile unsigned int *)((0x1930  << 2) + 0xff620000)
+#define   HCODEC_HDEC_MC_MBRIGHT_IDX               (0x1931)
+#define P_HCODEC_HDEC_MC_MBRIGHT_IDX               (volatile unsigned int *)((0x1931  << 2) + 0xff620000)
+#define   HCODEC_HDEC_MC_MBRIGHT_RD                (0x1932)
+#define P_HCODEC_HDEC_MC_MBRIGHT_RD                (volatile unsigned int *)((0x1932  << 2) + 0xff620000)
+#define   HCODEC_MC_MPORT_CTRL                     (0x1940)
+#define P_HCODEC_MC_MPORT_CTRL                     (volatile unsigned int *)((0x1940  << 2) + 0xff620000)
+#define   HCODEC_MC_MPORT_DAT                      (0x1941)
+#define P_HCODEC_MC_MPORT_DAT                      (volatile unsigned int *)((0x1941  << 2) + 0xff620000)
+#define   HCODEC_MC_WT_PRED_CTRL                   (0x1942)
+#define P_HCODEC_MC_WT_PRED_CTRL                   (volatile unsigned int *)((0x1942  << 2) + 0xff620000)
+#define   HCODEC_MC_MBBOT_ST_EVEN_ADDR             (0x1944)
+#define P_HCODEC_MC_MBBOT_ST_EVEN_ADDR             (volatile unsigned int *)((0x1944  << 2) + 0xff620000)
+#define   HCODEC_MC_MBBOT_ST_ODD_ADDR              (0x1945)
+#define P_HCODEC_MC_MBBOT_ST_ODD_ADDR              (volatile unsigned int *)((0x1945  << 2) + 0xff620000)
+#define   HCODEC_MC_DPDN_MB_XY                     (0x1946)
+#define P_HCODEC_MC_DPDN_MB_XY                     (volatile unsigned int *)((0x1946  << 2) + 0xff620000)
+#define   HCODEC_MC_OMDN_MB_XY                     (0x1947)
+#define P_HCODEC_MC_OMDN_MB_XY                     (volatile unsigned int *)((0x1947  << 2) + 0xff620000)
+#define   HCODEC_MC_HCMDBUF_H                      (0x1948)
+#define P_HCODEC_MC_HCMDBUF_H                      (volatile unsigned int *)((0x1948  << 2) + 0xff620000)
+#define   HCODEC_MC_HCMDBUF_L                      (0x1949)
+#define P_HCODEC_MC_HCMDBUF_L                      (volatile unsigned int *)((0x1949  << 2) + 0xff620000)
+#define   HCODEC_MC_HCMD_H                         (0x194a)
+#define P_HCODEC_MC_HCMD_H                         (volatile unsigned int *)((0x194a  << 2) + 0xff620000)
+#define   HCODEC_MC_HCMD_L                         (0x194b)
+#define P_HCODEC_MC_HCMD_L                         (volatile unsigned int *)((0x194b  << 2) + 0xff620000)
+#define   HCODEC_MC_IDCT_DAT                       (0x194c)
+#define P_HCODEC_MC_IDCT_DAT                       (volatile unsigned int *)((0x194c  << 2) + 0xff620000)
+#define   HCODEC_MC_CTRL_GCLK_CTRL                 (0x194d)
+#define P_HCODEC_MC_CTRL_GCLK_CTRL                 (volatile unsigned int *)((0x194d  << 2) + 0xff620000)
+#define   HCODEC_MC_OTHER_GCLK_CTRL                (0x194e)
+#define P_HCODEC_MC_OTHER_GCLK_CTRL                (volatile unsigned int *)((0x194e  << 2) + 0xff620000)
+//Bit 29:24, mbbot thread ID and token
+//Bit 21:16, mc read/write thread ID and token
+//Bit 13:8,  mbbot pre-arbitor burst number
+//Bit 5:0,   mc pre-arbitor burst number
+#define   HCODEC_MC_CTRL2                          (0x194f)
+#define P_HCODEC_MC_CTRL2                          (volatile unsigned int *)((0x194f  << 2) + 0xff620000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+// mdec_pic_dc_mux_ctrl[31]  -- mcr_hevc_mode
+#define   HCODEC_MDEC_PIC_DC_MUX_CTRL              (0x198d)
+#define P_HCODEC_MDEC_PIC_DC_MUX_CTRL              (volatile unsigned int *)((0x198d  << 2) + 0xff620000)
+#define   HCODEC_MDEC_PIC_DC_CTRL                  (0x198e)
+#define P_HCODEC_MDEC_PIC_DC_CTRL                  (volatile unsigned int *)((0x198e  << 2) + 0xff620000)
+#define   HCODEC_MDEC_PIC_DC_STATUS                (0x198f)
+#define P_HCODEC_MDEC_PIC_DC_STATUS                (volatile unsigned int *)((0x198f  << 2) + 0xff620000)
+#define   HCODEC_ANC0_CANVAS_ADDR                  (0x1990)
+#define P_HCODEC_ANC0_CANVAS_ADDR                  (volatile unsigned int *)((0x1990  << 2) + 0xff620000)
+#define   HCODEC_ANC1_CANVAS_ADDR                  (0x1991)
+#define P_HCODEC_ANC1_CANVAS_ADDR                  (volatile unsigned int *)((0x1991  << 2) + 0xff620000)
+#define   HCODEC_ANC2_CANVAS_ADDR                  (0x1992)
+#define P_HCODEC_ANC2_CANVAS_ADDR                  (volatile unsigned int *)((0x1992  << 2) + 0xff620000)
+#define   HCODEC_ANC3_CANVAS_ADDR                  (0x1993)
+#define P_HCODEC_ANC3_CANVAS_ADDR                  (volatile unsigned int *)((0x1993  << 2) + 0xff620000)
+#define   HCODEC_ANC4_CANVAS_ADDR                  (0x1994)
+#define P_HCODEC_ANC4_CANVAS_ADDR                  (volatile unsigned int *)((0x1994  << 2) + 0xff620000)
+#define   HCODEC_ANC5_CANVAS_ADDR                  (0x1995)
+#define P_HCODEC_ANC5_CANVAS_ADDR                  (volatile unsigned int *)((0x1995  << 2) + 0xff620000)
+#define   HCODEC_ANC6_CANVAS_ADDR                  (0x1996)
+#define P_HCODEC_ANC6_CANVAS_ADDR                  (volatile unsigned int *)((0x1996  << 2) + 0xff620000)
+#define   HCODEC_ANC7_CANVAS_ADDR                  (0x1997)
+#define P_HCODEC_ANC7_CANVAS_ADDR                  (volatile unsigned int *)((0x1997  << 2) + 0xff620000)
+#define   HCODEC_ANC8_CANVAS_ADDR                  (0x1998)
+#define P_HCODEC_ANC8_CANVAS_ADDR                  (volatile unsigned int *)((0x1998  << 2) + 0xff620000)
+#define   HCODEC_ANC9_CANVAS_ADDR                  (0x1999)
+#define P_HCODEC_ANC9_CANVAS_ADDR                  (volatile unsigned int *)((0x1999  << 2) + 0xff620000)
+#define   HCODEC_ANC10_CANVAS_ADDR                 (0x199a)
+#define P_HCODEC_ANC10_CANVAS_ADDR                 (volatile unsigned int *)((0x199a  << 2) + 0xff620000)
+#define   HCODEC_ANC11_CANVAS_ADDR                 (0x199b)
+#define P_HCODEC_ANC11_CANVAS_ADDR                 (volatile unsigned int *)((0x199b  << 2) + 0xff620000)
+#define   HCODEC_ANC12_CANVAS_ADDR                 (0x199c)
+#define P_HCODEC_ANC12_CANVAS_ADDR                 (volatile unsigned int *)((0x199c  << 2) + 0xff620000)
+#define   HCODEC_ANC13_CANVAS_ADDR                 (0x199d)
+#define P_HCODEC_ANC13_CANVAS_ADDR                 (volatile unsigned int *)((0x199d  << 2) + 0xff620000)
+#define   HCODEC_ANC14_CANVAS_ADDR                 (0x199e)
+#define P_HCODEC_ANC14_CANVAS_ADDR                 (volatile unsigned int *)((0x199e  << 2) + 0xff620000)
+#define   HCODEC_ANC15_CANVAS_ADDR                 (0x199f)
+#define P_HCODEC_ANC15_CANVAS_ADDR                 (volatile unsigned int *)((0x199f  << 2) + 0xff620000)
+#define   HCODEC_ANC16_CANVAS_ADDR                 (0x19a0)
+#define P_HCODEC_ANC16_CANVAS_ADDR                 (volatile unsigned int *)((0x19a0  << 2) + 0xff620000)
+#define   HCODEC_ANC17_CANVAS_ADDR                 (0x19a1)
+#define P_HCODEC_ANC17_CANVAS_ADDR                 (volatile unsigned int *)((0x19a1  << 2) + 0xff620000)
+#define   HCODEC_ANC18_CANVAS_ADDR                 (0x19a2)
+#define P_HCODEC_ANC18_CANVAS_ADDR                 (volatile unsigned int *)((0x19a2  << 2) + 0xff620000)
+#define   HCODEC_ANC19_CANVAS_ADDR                 (0x19a3)
+#define P_HCODEC_ANC19_CANVAS_ADDR                 (volatile unsigned int *)((0x19a3  << 2) + 0xff620000)
+#define   HCODEC_ANC20_CANVAS_ADDR                 (0x19a4)
+#define P_HCODEC_ANC20_CANVAS_ADDR                 (volatile unsigned int *)((0x19a4  << 2) + 0xff620000)
+#define   HCODEC_ANC21_CANVAS_ADDR                 (0x19a5)
+#define P_HCODEC_ANC21_CANVAS_ADDR                 (volatile unsigned int *)((0x19a5  << 2) + 0xff620000)
+#define   HCODEC_ANC22_CANVAS_ADDR                 (0x19a6)
+#define P_HCODEC_ANC22_CANVAS_ADDR                 (volatile unsigned int *)((0x19a6  << 2) + 0xff620000)
+#define   HCODEC_ANC23_CANVAS_ADDR                 (0x19a7)
+#define P_HCODEC_ANC23_CANVAS_ADDR                 (volatile unsigned int *)((0x19a7  << 2) + 0xff620000)
+#define   HCODEC_ANC24_CANVAS_ADDR                 (0x19a8)
+#define P_HCODEC_ANC24_CANVAS_ADDR                 (volatile unsigned int *)((0x19a8  << 2) + 0xff620000)
+#define   HCODEC_ANC25_CANVAS_ADDR                 (0x19a9)
+#define P_HCODEC_ANC25_CANVAS_ADDR                 (volatile unsigned int *)((0x19a9  << 2) + 0xff620000)
+#define   HCODEC_ANC26_CANVAS_ADDR                 (0x19aa)
+#define P_HCODEC_ANC26_CANVAS_ADDR                 (volatile unsigned int *)((0x19aa  << 2) + 0xff620000)
+#define   HCODEC_ANC27_CANVAS_ADDR                 (0x19ab)
+#define P_HCODEC_ANC27_CANVAS_ADDR                 (volatile unsigned int *)((0x19ab  << 2) + 0xff620000)
+#define   HCODEC_ANC28_CANVAS_ADDR                 (0x19ac)
+#define P_HCODEC_ANC28_CANVAS_ADDR                 (volatile unsigned int *)((0x19ac  << 2) + 0xff620000)
+#define   HCODEC_ANC29_CANVAS_ADDR                 (0x19ad)
+#define P_HCODEC_ANC29_CANVAS_ADDR                 (volatile unsigned int *)((0x19ad  << 2) + 0xff620000)
+#define   HCODEC_ANC30_CANVAS_ADDR                 (0x19ae)
+#define P_HCODEC_ANC30_CANVAS_ADDR                 (volatile unsigned int *)((0x19ae  << 2) + 0xff620000)
+#define   HCODEC_ANC31_CANVAS_ADDR                 (0x19af)
+#define P_HCODEC_ANC31_CANVAS_ADDR                 (volatile unsigned int *)((0x19af  << 2) + 0xff620000)
+#define   HCODEC_DBKR_CANVAS_ADDR                  (0x19b0)
+#define P_HCODEC_DBKR_CANVAS_ADDR                  (volatile unsigned int *)((0x19b0  << 2) + 0xff620000)
+#define   HCODEC_DBKW_CANVAS_ADDR                  (0x19b1)
+#define P_HCODEC_DBKW_CANVAS_ADDR                  (volatile unsigned int *)((0x19b1  << 2) + 0xff620000)
+#define   HCODEC_REC_CANVAS_ADDR                   (0x19b2)
+#define P_HCODEC_REC_CANVAS_ADDR                   (volatile unsigned int *)((0x19b2  << 2) + 0xff620000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define   HCODEC_CURR_CANVAS_CTRL                  (0x19b3)
+#define P_HCODEC_CURR_CANVAS_CTRL                  (volatile unsigned int *)((0x19b3  << 2) + 0xff620000)
+#define   HCODEC_MDEC_PIC_DC_THRESH                (0x19b8)
+#define P_HCODEC_MDEC_PIC_DC_THRESH                (volatile unsigned int *)((0x19b8  << 2) + 0xff620000)
+#define   HCODEC_MDEC_PICR_BUF_STATUS              (0x19b9)
+#define P_HCODEC_MDEC_PICR_BUF_STATUS              (volatile unsigned int *)((0x19b9  << 2) + 0xff620000)
+#define   HCODEC_MDEC_PICW_BUF_STATUS              (0x19ba)
+#define P_HCODEC_MDEC_PICW_BUF_STATUS              (volatile unsigned int *)((0x19ba  << 2) + 0xff620000)
+#define   HCODEC_MCW_DBLK_WRRSP_CNT                (0x19bb)
+#define P_HCODEC_MCW_DBLK_WRRSP_CNT                (volatile unsigned int *)((0x19bb  << 2) + 0xff620000)
+#define   HCODEC_MC_MBBOT_WRRSP_CNT                (0x19bc)
+#define P_HCODEC_MC_MBBOT_WRRSP_CNT                (volatile unsigned int *)((0x19bc  << 2) + 0xff620000)
+#define   HCODEC_MDEC_PICW_BUF2_STATUS             (0x19bd)
+#define P_HCODEC_MDEC_PICW_BUF2_STATUS             (volatile unsigned int *)((0x19bd  << 2) + 0xff620000)
+#define   HCODEC_WRRSP_FIFO_PICW_DBK               (0x19be)
+#define P_HCODEC_WRRSP_FIFO_PICW_DBK               (volatile unsigned int *)((0x19be  << 2) + 0xff620000)
+#define   HCODEC_WRRSP_FIFO_PICW_MC                (0x19bf)
+#define P_HCODEC_WRRSP_FIFO_PICW_MC                (volatile unsigned int *)((0x19bf  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_0                      (0x19c0)
+#define P_HCODEC_AV_SCRATCH_0                      (volatile unsigned int *)((0x19c0  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_1                      (0x19c1)
+#define P_HCODEC_AV_SCRATCH_1                      (volatile unsigned int *)((0x19c1  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_2                      (0x19c2)
+#define P_HCODEC_AV_SCRATCH_2                      (volatile unsigned int *)((0x19c2  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_3                      (0x19c3)
+#define P_HCODEC_AV_SCRATCH_3                      (volatile unsigned int *)((0x19c3  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_4                      (0x19c4)
+#define P_HCODEC_AV_SCRATCH_4                      (volatile unsigned int *)((0x19c4  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_5                      (0x19c5)
+#define P_HCODEC_AV_SCRATCH_5                      (volatile unsigned int *)((0x19c5  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_6                      (0x19c6)
+#define P_HCODEC_AV_SCRATCH_6                      (volatile unsigned int *)((0x19c6  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_7                      (0x19c7)
+#define P_HCODEC_AV_SCRATCH_7                      (volatile unsigned int *)((0x19c7  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_8                      (0x19c8)
+#define P_HCODEC_AV_SCRATCH_8                      (volatile unsigned int *)((0x19c8  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_9                      (0x19c9)
+#define P_HCODEC_AV_SCRATCH_9                      (volatile unsigned int *)((0x19c9  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_A                      (0x19ca)
+#define P_HCODEC_AV_SCRATCH_A                      (volatile unsigned int *)((0x19ca  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_B                      (0x19cb)
+#define P_HCODEC_AV_SCRATCH_B                      (volatile unsigned int *)((0x19cb  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_C                      (0x19cc)
+#define P_HCODEC_AV_SCRATCH_C                      (volatile unsigned int *)((0x19cc  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_D                      (0x19cd)
+#define P_HCODEC_AV_SCRATCH_D                      (volatile unsigned int *)((0x19cd  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_E                      (0x19ce)
+#define P_HCODEC_AV_SCRATCH_E                      (volatile unsigned int *)((0x19ce  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_F                      (0x19cf)
+#define P_HCODEC_AV_SCRATCH_F                      (volatile unsigned int *)((0x19cf  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_G                      (0x19d0)
+#define P_HCODEC_AV_SCRATCH_G                      (volatile unsigned int *)((0x19d0  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_H                      (0x19d1)
+#define P_HCODEC_AV_SCRATCH_H                      (volatile unsigned int *)((0x19d1  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_I                      (0x19d2)
+#define P_HCODEC_AV_SCRATCH_I                      (volatile unsigned int *)((0x19d2  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_J                      (0x19d3)
+#define P_HCODEC_AV_SCRATCH_J                      (volatile unsigned int *)((0x19d3  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_K                      (0x19d4)
+#define P_HCODEC_AV_SCRATCH_K                      (volatile unsigned int *)((0x19d4  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_L                      (0x19d5)
+#define P_HCODEC_AV_SCRATCH_L                      (volatile unsigned int *)((0x19d5  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_M                      (0x19d6)
+#define P_HCODEC_AV_SCRATCH_M                      (volatile unsigned int *)((0x19d6  << 2) + 0xff620000)
+#define   HCODEC_AV_SCRATCH_N                      (0x19d7)
+#define P_HCODEC_AV_SCRATCH_N                      (volatile unsigned int *)((0x19d7  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define   HCODEC_WRRSP_CO_MB                       (0x19d8)
+#define P_HCODEC_WRRSP_CO_MB                       (volatile unsigned int *)((0x19d8  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define   HCODEC_WRRSP_DCAC                        (0x19d9)
+#define P_HCODEC_WRRSP_DCAC                        (volatile unsigned int *)((0x19d9  << 2) + 0xff620000)
+// bit[11:0] wrrsp_count_vld
+#define   HCODEC_WRRSP_VLD                         (0x19da)
+#define P_HCODEC_WRRSP_VLD                         (volatile unsigned int *)((0x19da  << 2) + 0xff620000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define   HCODEC_MDEC_DOUBLEW_CFG0                 (0x19db)
+#define P_HCODEC_MDEC_DOUBLEW_CFG0                 (volatile unsigned int *)((0x19db  << 2) + 0xff620000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write -
+// doublew_cfg1[17];    //       Reverse to original version -
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define   HCODEC_MDEC_DOUBLEW_CFG1                 (0x19dc)
+#define P_HCODEC_MDEC_DOUBLEW_CFG1                 (volatile unsigned int *)((0x19dc  << 2) + 0xff620000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define   HCODEC_MDEC_DOUBLEW_CFG2                 (0x19dd)
+#define P_HCODEC_MDEC_DOUBLEW_CFG2                 (volatile unsigned int *)((0x19dd  << 2) + 0xff620000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma -
+#define   HCODEC_MDEC_DOUBLEW_CFG3                 (0x19de)
+#define P_HCODEC_MDEC_DOUBLEW_CFG3                 (volatile unsigned int *)((0x19de  << 2) + 0xff620000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma -
+#define   HCODEC_MDEC_DOUBLEW_CFG4                 (0x19df)
+#define P_HCODEC_MDEC_DOUBLEW_CFG4                 (volatile unsigned int *)((0x19df  << 2) + 0xff620000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma -
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma -
+#define   HCODEC_MDEC_DOUBLEW_CFG5                 (0x19e0)
+#define P_HCODEC_MDEC_DOUBLEW_CFG5                 (volatile unsigned int *)((0x19e0  << 2) + 0xff620000)
+// doublew_cfg6: reserved
+#define   HCODEC_MDEC_DOUBLEW_CFG6                 (0x19e1)
+#define P_HCODEC_MDEC_DOUBLEW_CFG6                 (volatile unsigned int *)((0x19e1  << 2) + 0xff620000)
+// doublew_cfg7: reserved
+#define   HCODEC_MDEC_DOUBLEW_CFG7                 (0x19e2)
+#define P_HCODEC_MDEC_DOUBLEW_CFG7                 (volatile unsigned int *)((0x19e2  << 2) + 0xff620000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define   HCODEC_MDEC_DOUBLEW_STATUS               (0x19e3)
+#define P_HCODEC_MDEC_DOUBLEW_STATUS               (volatile unsigned int *)((0x19e3  << 2) + 0xff620000)
+#define   HCODEC_MDEC_EXTIF_CFG0                   (0x19e4)
+#define P_HCODEC_MDEC_EXTIF_CFG0                   (volatile unsigned int *)((0x19e4  << 2) + 0xff620000)
+#define   HCODEC_MDEC_EXTIF_CFG1                   (0x19e5)
+#define P_HCODEC_MDEC_EXTIF_CFG1                   (volatile unsigned int *)((0x19e5  << 2) + 0xff620000)
+#define   HCODEC_MDEC_EXTIF_STS0                   (0x19e6)
+#define P_HCODEC_MDEC_EXTIF_STS0                   (volatile unsigned int *)((0x19e6  << 2) + 0xff620000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    //`define MC_RESET	    16'h0002
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f
+//========================================================================
+#define   HCODEC_DBLK_RST                          (0x1950)
+#define P_HCODEC_DBLK_RST                          (volatile unsigned int *)((0x1950  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CTRL                         (0x1951)
+#define P_HCODEC_DBLK_CTRL                         (volatile unsigned int *)((0x1951  << 2) + 0xff620000)
+#define   HCODEC_DBLK_MB_WID_HEIGHT                (0x1952)
+#define P_HCODEC_DBLK_MB_WID_HEIGHT                (volatile unsigned int *)((0x1952  << 2) + 0xff620000)
+#define   HCODEC_DBLK_STATUS                       (0x1953)
+#define P_HCODEC_DBLK_STATUS                       (volatile unsigned int *)((0x1953  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CMD_CTRL                     (0x1954)
+#define P_HCODEC_DBLK_CMD_CTRL                     (volatile unsigned int *)((0x1954  << 2) + 0xff620000)
+#define   HCODEC_DBLK_MB_XY                        (0x1955)
+#define P_HCODEC_DBLK_MB_XY                        (volatile unsigned int *)((0x1955  << 2) + 0xff620000)
+#define   HCODEC_DBLK_QP                           (0x1956)
+#define P_HCODEC_DBLK_QP                           (volatile unsigned int *)((0x1956  << 2) + 0xff620000)
+#define   HCODEC_DBLK_Y_BHFILT                     (0x1957)
+#define P_HCODEC_DBLK_Y_BHFILT                     (volatile unsigned int *)((0x1957  << 2) + 0xff620000)
+#define   HCODEC_DBLK_Y_BHFILT_HIGH                (0x1958)
+#define P_HCODEC_DBLK_Y_BHFILT_HIGH                (volatile unsigned int *)((0x1958  << 2) + 0xff620000)
+#define   HCODEC_DBLK_Y_BVFILT                     (0x1959)
+#define P_HCODEC_DBLK_Y_BVFILT                     (volatile unsigned int *)((0x1959  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CB_BFILT                     (0x195a)
+#define P_HCODEC_DBLK_CB_BFILT                     (volatile unsigned int *)((0x195a  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CR_BFILT                     (0x195b)
+#define P_HCODEC_DBLK_CR_BFILT                     (volatile unsigned int *)((0x195b  << 2) + 0xff620000)
+#define   HCODEC_DBLK_Y_HFILT                      (0x195c)
+#define P_HCODEC_DBLK_Y_HFILT                      (volatile unsigned int *)((0x195c  << 2) + 0xff620000)
+#define   HCODEC_DBLK_Y_HFILT_HIGH                 (0x195d)
+#define P_HCODEC_DBLK_Y_HFILT_HIGH                 (volatile unsigned int *)((0x195d  << 2) + 0xff620000)
+#define   HCODEC_DBLK_Y_VFILT                      (0x195e)
+#define P_HCODEC_DBLK_Y_VFILT                      (volatile unsigned int *)((0x195e  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CB_FILT                      (0x195f)
+#define P_HCODEC_DBLK_CB_FILT                      (volatile unsigned int *)((0x195f  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CR_FILT                      (0x1960)
+#define P_HCODEC_DBLK_CR_FILT                      (volatile unsigned int *)((0x1960  << 2) + 0xff620000)
+#define   HCODEC_DBLK_BETAX_QP_SEL                 (0x1961)
+#define P_HCODEC_DBLK_BETAX_QP_SEL                 (volatile unsigned int *)((0x1961  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL0                   (0x1962)
+#define P_HCODEC_DBLK_CLIP_CTRL0                   (volatile unsigned int *)((0x1962  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL1                   (0x1963)
+#define P_HCODEC_DBLK_CLIP_CTRL1                   (volatile unsigned int *)((0x1963  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL2                   (0x1964)
+#define P_HCODEC_DBLK_CLIP_CTRL2                   (volatile unsigned int *)((0x1964  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL3                   (0x1965)
+#define P_HCODEC_DBLK_CLIP_CTRL3                   (volatile unsigned int *)((0x1965  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL4                   (0x1966)
+#define P_HCODEC_DBLK_CLIP_CTRL4                   (volatile unsigned int *)((0x1966  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL5                   (0x1967)
+#define P_HCODEC_DBLK_CLIP_CTRL5                   (volatile unsigned int *)((0x1967  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL6                   (0x1968)
+#define P_HCODEC_DBLK_CLIP_CTRL6                   (volatile unsigned int *)((0x1968  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL7                   (0x1969)
+#define P_HCODEC_DBLK_CLIP_CTRL7                   (volatile unsigned int *)((0x1969  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CLIP_CTRL8                   (0x196a)
+#define P_HCODEC_DBLK_CLIP_CTRL8                   (volatile unsigned int *)((0x196a  << 2) + 0xff620000)
+#define   HCODEC_DBLK_STATUS1                      (0x196b)
+#define P_HCODEC_DBLK_STATUS1                      (volatile unsigned int *)((0x196b  << 2) + 0xff620000)
+#define   HCODEC_DBLK_GCLK_FREE                    (0x196c)
+#define P_HCODEC_DBLK_GCLK_FREE                    (volatile unsigned int *)((0x196c  << 2) + 0xff620000)
+#define   HCODEC_DBLK_GCLK_OFF                     (0x196d)
+#define P_HCODEC_DBLK_GCLK_OFF                     (volatile unsigned int *)((0x196d  << 2) + 0xff620000)
+#define   HCODEC_DBLK_AVSFLAGS                     (0x196e)
+#define P_HCODEC_DBLK_AVSFLAGS                     (volatile unsigned int *)((0x196e  << 2) + 0xff620000)
+// bit 15:0
+#define   HCODEC_DBLK_CBPY                         (0x1970)
+#define P_HCODEC_DBLK_CBPY                         (volatile unsigned int *)((0x1970  << 2) + 0xff620000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define   HCODEC_DBLK_CBPY_ADJ                     (0x1971)
+#define P_HCODEC_DBLK_CBPY_ADJ                     (volatile unsigned int *)((0x1971  << 2) + 0xff620000)
+// bit 7:0 -- deblk_cbpc
+#define   HCODEC_DBLK_CBPC                         (0x1972)
+#define P_HCODEC_DBLK_CBPC                         (volatile unsigned int *)((0x1972  << 2) + 0xff620000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define   HCODEC_DBLK_CBPC_ADJ                     (0x1973)
+#define P_HCODEC_DBLK_CBPC_ADJ                     (volatile unsigned int *)((0x1973  << 2) + 0xff620000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0}
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0}
+#define   HCODEC_DBLK_VHMVD                        (0x1974)
+#define P_HCODEC_DBLK_VHMVD                        (volatile unsigned int *)((0x1974  << 2) + 0xff620000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s
+#define   HCODEC_DBLK_STRONG                       (0x1975)
+#define P_HCODEC_DBLK_STRONG                       (volatile unsigned int *)((0x1975  << 2) + 0xff620000)
+// bit 14:10 -- PQUANT
+// bit 9:5 -- left_PQUANT
+// bit 4:0 -- top_PQUANT
+#define   HCODEC_DBLK_RV8_QUANT                    (0x1976)
+#define P_HCODEC_DBLK_RV8_QUANT                    (volatile unsigned int *)((0x1976  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CBUS_HCMD2                   (0x1977)
+#define P_HCODEC_DBLK_CBUS_HCMD2                   (volatile unsigned int *)((0x1977  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CBUS_HCMD1                   (0x1978)
+#define P_HCODEC_DBLK_CBUS_HCMD1                   (volatile unsigned int *)((0x1978  << 2) + 0xff620000)
+#define   HCODEC_DBLK_CBUS_HCMD0                   (0x1979)
+#define P_HCODEC_DBLK_CBUS_HCMD0                   (volatile unsigned int *)((0x1979  << 2) + 0xff620000)
+#define   HCODEC_DBLK_VLD_HCMD2                    (0x197a)
+#define P_HCODEC_DBLK_VLD_HCMD2                    (volatile unsigned int *)((0x197a  << 2) + 0xff620000)
+#define   HCODEC_DBLK_VLD_HCMD1                    (0x197b)
+#define P_HCODEC_DBLK_VLD_HCMD1                    (volatile unsigned int *)((0x197b  << 2) + 0xff620000)
+#define   HCODEC_DBLK_VLD_HCMD0                    (0x197c)
+#define P_HCODEC_DBLK_VLD_HCMD0                    (volatile unsigned int *)((0x197c  << 2) + 0xff620000)
+#define   HCODEC_DBLK_OST_YBASE                    (0x197d)
+#define P_HCODEC_DBLK_OST_YBASE                    (volatile unsigned int *)((0x197d  << 2) + 0xff620000)
+#define   HCODEC_DBLK_OST_CBCRDIFF                 (0x197e)
+#define P_HCODEC_DBLK_OST_CBCRDIFF                 (volatile unsigned int *)((0x197e  << 2) + 0xff620000)
+//13:8 dblk thread ID and token
+//5:0  dblk prearbitor burst num
+#define   HCODEC_DBLK_CTRL1                        (0x197f)
+#define P_HCODEC_DBLK_CTRL1                        (volatile unsigned int *)((0x197f  << 2) + 0xff620000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define   HCODEC_MCRCC_CTL1                        (0x1980)
+#define P_HCODEC_MCRCC_CTL1                        (volatile unsigned int *)((0x1980  << 2) + 0xff620000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define   HCODEC_MCRCC_CTL2                        (0x1981)
+#define P_HCODEC_MCRCC_CTL2                        (volatile unsigned int *)((0x1981  << 2) + 0xff620000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define   HCODEC_MCRCC_CTL3                        (0x1982)
+#define P_HCODEC_MCRCC_CTL3                        (volatile unsigned int *)((0x1982  << 2) + 0xff620000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define   HCODEC_GCLK_EN                           (0x1983)
+#define P_HCODEC_GCLK_EN                           (volatile unsigned int *)((0x1983  << 2) + 0xff620000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define   HCODEC_MDEC_SW_RESET                     (0x1984)
+#define P_HCODEC_MDEC_SW_RESET                     (volatile unsigned int *)((0x1984  << 2) + 0xff620000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define   VDEC2_MC_CTRL_REG                        (0x2900)
+#define P_VDEC2_MC_CTRL_REG                        (volatile unsigned int *)((0x2900  << 2) + 0xff620000)
+#define   VDEC2_MC_MB_INFO                         (0x2901)
+#define P_VDEC2_MC_MB_INFO                         (volatile unsigned int *)((0x2901  << 2) + 0xff620000)
+#define   VDEC2_MC_PIC_INFO                        (0x2902)
+#define P_VDEC2_MC_PIC_INFO                        (volatile unsigned int *)((0x2902  << 2) + 0xff620000)
+#define   VDEC2_MC_HALF_PEL_ONE                    (0x2903)
+#define P_VDEC2_MC_HALF_PEL_ONE                    (volatile unsigned int *)((0x2903  << 2) + 0xff620000)
+#define   VDEC2_MC_HALF_PEL_TWO                    (0x2904)
+#define P_VDEC2_MC_HALF_PEL_TWO                    (volatile unsigned int *)((0x2904  << 2) + 0xff620000)
+#define   VDEC2_POWER_CTL_MC                       (0x2905)
+#define P_VDEC2_POWER_CTL_MC                       (volatile unsigned int *)((0x2905  << 2) + 0xff620000)
+#define   VDEC2_MC_CMD                             (0x2906)
+#define P_VDEC2_MC_CMD                             (volatile unsigned int *)((0x2906  << 2) + 0xff620000)
+#define   VDEC2_MC_CTRL0                           (0x2907)
+#define P_VDEC2_MC_CTRL0                           (volatile unsigned int *)((0x2907  << 2) + 0xff620000)
+#define   VDEC2_MC_PIC_W_H                         (0x2908)
+#define P_VDEC2_MC_PIC_W_H                         (volatile unsigned int *)((0x2908  << 2) + 0xff620000)
+#define   VDEC2_MC_STATUS0                         (0x2909)
+#define P_VDEC2_MC_STATUS0                         (volatile unsigned int *)((0x2909  << 2) + 0xff620000)
+#define   VDEC2_MC_STATUS1                         (0x290a)
+#define P_VDEC2_MC_STATUS1                         (volatile unsigned int *)((0x290a  << 2) + 0xff620000)
+#define   VDEC2_MC_CTRL1                           (0x290b)
+#define P_VDEC2_MC_CTRL1                           (volatile unsigned int *)((0x290b  << 2) + 0xff620000)
+#define   VDEC2_MC_MIX_RATIO0                      (0x290c)
+#define P_VDEC2_MC_MIX_RATIO0                      (volatile unsigned int *)((0x290c  << 2) + 0xff620000)
+#define   VDEC2_MC_MIX_RATIO1                      (0x290d)
+#define P_VDEC2_MC_MIX_RATIO1                      (volatile unsigned int *)((0x290d  << 2) + 0xff620000)
+#define   VDEC2_MC_DP_MB_XY                        (0x290e)
+#define P_VDEC2_MC_DP_MB_XY                        (volatile unsigned int *)((0x290e  << 2) + 0xff620000)
+#define   VDEC2_MC_OM_MB_XY                        (0x290f)
+#define P_VDEC2_MC_OM_MB_XY                        (volatile unsigned int *)((0x290f  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_RST                         (0x2910)
+#define P_VDEC2_PSCALE_RST                         (volatile unsigned int *)((0x2910  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_CTRL                        (0x2911)
+#define P_VDEC2_PSCALE_CTRL                        (volatile unsigned int *)((0x2911  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_PICI_W                      (0x2912)
+#define P_VDEC2_PSCALE_PICI_W                      (volatile unsigned int *)((0x2912  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_PICI_H                      (0x2913)
+#define P_VDEC2_PSCALE_PICI_H                      (volatile unsigned int *)((0x2913  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_PICO_W                      (0x2914)
+#define P_VDEC2_PSCALE_PICO_W                      (volatile unsigned int *)((0x2914  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_PICO_H                      (0x2915)
+#define P_VDEC2_PSCALE_PICO_H                      (volatile unsigned int *)((0x2915  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_PICO_START_X                (0x2916)
+#define P_VDEC2_PSCALE_PICO_START_X                (volatile unsigned int *)((0x2916  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_PICO_START_Y                (0x2917)
+#define P_VDEC2_PSCALE_PICO_START_Y                (volatile unsigned int *)((0x2917  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_DUMMY                       (0x2918)
+#define P_VDEC2_PSCALE_DUMMY                       (volatile unsigned int *)((0x2918  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_FILT0_COEF0                 (0x2919)
+#define P_VDEC2_PSCALE_FILT0_COEF0                 (volatile unsigned int *)((0x2919  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_FILT0_COEF1                 (0x291a)
+#define P_VDEC2_PSCALE_FILT0_COEF1                 (volatile unsigned int *)((0x291a  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_CMD_CTRL                    (0x291b)
+#define P_VDEC2_PSCALE_CMD_CTRL                    (volatile unsigned int *)((0x291b  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_CMD_BLK_X                   (0x291c)
+#define P_VDEC2_PSCALE_CMD_BLK_X                   (volatile unsigned int *)((0x291c  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_CMD_BLK_Y                   (0x291d)
+#define P_VDEC2_PSCALE_CMD_BLK_Y                   (volatile unsigned int *)((0x291d  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_STATUS                      (0x291e)
+#define P_VDEC2_PSCALE_STATUS                      (volatile unsigned int *)((0x291e  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_BMEM_ADDR                   (0x291f)
+#define P_VDEC2_PSCALE_BMEM_ADDR                   (volatile unsigned int *)((0x291f  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_BMEM_DAT                    (0x2920)
+#define P_VDEC2_PSCALE_BMEM_DAT                    (volatile unsigned int *)((0x2920  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_DRAM_BUF_CTRL               (0x2921)
+#define P_VDEC2_PSCALE_DRAM_BUF_CTRL               (volatile unsigned int *)((0x2921  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_MCMD_CTRL                   (0x2922)
+#define P_VDEC2_PSCALE_MCMD_CTRL                   (volatile unsigned int *)((0x2922  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_MCMD_XSIZE                  (0x2923)
+#define P_VDEC2_PSCALE_MCMD_XSIZE                  (volatile unsigned int *)((0x2923  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_MCMD_YSIZE                  (0x2924)
+#define P_VDEC2_PSCALE_MCMD_YSIZE                  (volatile unsigned int *)((0x2924  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_RBUF_START_BLKX             (0x2925)
+#define P_VDEC2_PSCALE_RBUF_START_BLKX             (volatile unsigned int *)((0x2925  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_RBUF_START_BLKY             (0x2926)
+#define P_VDEC2_PSCALE_RBUF_START_BLKY             (volatile unsigned int *)((0x2926  << 2) + 0xff620000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define   VDEC2_PSCALE_PICO_SHIFT_XY               (0x2928)
+#define P_VDEC2_PSCALE_PICO_SHIFT_XY               (volatile unsigned int *)((0x2928  << 2) + 0xff620000)
+#define   VDEC2_PSCALE_CTRL1                       (0x2929)
+#define P_VDEC2_PSCALE_CTRL1                       (volatile unsigned int *)((0x2929  << 2) + 0xff620000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less,
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define   VDEC2_PSCALE_SRCKEY_CTRL0                (0x292a)
+#define P_VDEC2_PSCALE_SRCKEY_CTRL0                (volatile unsigned int *)((0x292a  << 2) + 0xff620000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define   VDEC2_PSCALE_SRCKEY_CTRL1                (0x292b)
+#define P_VDEC2_PSCALE_SRCKEY_CTRL1                (volatile unsigned int *)((0x292b  << 2) + 0xff620000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define   VDEC2_PSCALE_CANVAS_RD_ADDR              (0x292c)
+#define P_VDEC2_PSCALE_CANVAS_RD_ADDR              (volatile unsigned int *)((0x292c  << 2) + 0xff620000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define   VDEC2_PSCALE_CANVAS_WR_ADDR              (0x292d)
+#define P_VDEC2_PSCALE_CANVAS_WR_ADDR              (volatile unsigned int *)((0x292d  << 2) + 0xff620000)
+//bit 13:8 pscale thread ID and token
+//bit 7 disable write response count adding to busy bit
+//bit 5:0  pscale prearbitor burst num
+#define   VDEC2_PSCALE_CTRL2                       (0x292e)
+#define P_VDEC2_PSCALE_CTRL2                       (volatile unsigned int *)((0x292e  << 2) + 0xff620000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define   VDEC2_HDEC_MC_OMEM_AUTO                  (0x2930)
+#define P_VDEC2_HDEC_MC_OMEM_AUTO                  (volatile unsigned int *)((0x2930  << 2) + 0xff620000)
+#define   VDEC2_HDEC_MC_MBRIGHT_IDX                (0x2931)
+#define P_VDEC2_HDEC_MC_MBRIGHT_IDX                (volatile unsigned int *)((0x2931  << 2) + 0xff620000)
+#define   VDEC2_HDEC_MC_MBRIGHT_RD                 (0x2932)
+#define P_VDEC2_HDEC_MC_MBRIGHT_RD                 (volatile unsigned int *)((0x2932  << 2) + 0xff620000)
+#define   VDEC2_MC_MPORT_CTRL                      (0x2940)
+#define P_VDEC2_MC_MPORT_CTRL                      (volatile unsigned int *)((0x2940  << 2) + 0xff620000)
+#define   VDEC2_MC_MPORT_DAT                       (0x2941)
+#define P_VDEC2_MC_MPORT_DAT                       (volatile unsigned int *)((0x2941  << 2) + 0xff620000)
+#define   VDEC2_MC_WT_PRED_CTRL                    (0x2942)
+#define P_VDEC2_MC_WT_PRED_CTRL                    (volatile unsigned int *)((0x2942  << 2) + 0xff620000)
+#define   VDEC2_MC_MBBOT_ST_EVEN_ADDR              (0x2944)
+#define P_VDEC2_MC_MBBOT_ST_EVEN_ADDR              (volatile unsigned int *)((0x2944  << 2) + 0xff620000)
+#define   VDEC2_MC_MBBOT_ST_ODD_ADDR               (0x2945)
+#define P_VDEC2_MC_MBBOT_ST_ODD_ADDR               (volatile unsigned int *)((0x2945  << 2) + 0xff620000)
+#define   VDEC2_MC_DPDN_MB_XY                      (0x2946)
+#define P_VDEC2_MC_DPDN_MB_XY                      (volatile unsigned int *)((0x2946  << 2) + 0xff620000)
+#define   VDEC2_MC_OMDN_MB_XY                      (0x2947)
+#define P_VDEC2_MC_OMDN_MB_XY                      (volatile unsigned int *)((0x2947  << 2) + 0xff620000)
+#define   VDEC2_MC_HCMDBUF_H                       (0x2948)
+#define P_VDEC2_MC_HCMDBUF_H                       (volatile unsigned int *)((0x2948  << 2) + 0xff620000)
+#define   VDEC2_MC_HCMDBUF_L                       (0x2949)
+#define P_VDEC2_MC_HCMDBUF_L                       (volatile unsigned int *)((0x2949  << 2) + 0xff620000)
+#define   VDEC2_MC_HCMD_H                          (0x294a)
+#define P_VDEC2_MC_HCMD_H                          (volatile unsigned int *)((0x294a  << 2) + 0xff620000)
+#define   VDEC2_MC_HCMD_L                          (0x294b)
+#define P_VDEC2_MC_HCMD_L                          (volatile unsigned int *)((0x294b  << 2) + 0xff620000)
+#define   VDEC2_MC_IDCT_DAT                        (0x294c)
+#define P_VDEC2_MC_IDCT_DAT                        (volatile unsigned int *)((0x294c  << 2) + 0xff620000)
+#define   VDEC2_MC_CTRL_GCLK_CTRL                  (0x294d)
+#define P_VDEC2_MC_CTRL_GCLK_CTRL                  (volatile unsigned int *)((0x294d  << 2) + 0xff620000)
+#define   VDEC2_MC_OTHER_GCLK_CTRL                 (0x294e)
+#define P_VDEC2_MC_OTHER_GCLK_CTRL                 (volatile unsigned int *)((0x294e  << 2) + 0xff620000)
+//Bit 29:24, mbbot thread ID and token
+//Bit 21:16, mc read/write thread ID and token
+//Bit 13:8,  mbbot pre-arbitor burst number
+//Bit 5:0,   mc pre-arbitor burst number
+#define   VDEC2_MC_CTRL2                           (0x294f)
+#define P_VDEC2_MC_CTRL2                           (volatile unsigned int *)((0x294f  << 2) + 0xff620000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+// mdec_pic_dc_mux_ctrl[31]  -- mcr_hevc_mode
+#define   VDEC2_MDEC_PIC_DC_MUX_CTRL               (0x298d)
+#define P_VDEC2_MDEC_PIC_DC_MUX_CTRL               (volatile unsigned int *)((0x298d  << 2) + 0xff620000)
+#define   VDEC2_MDEC_PIC_DC_CTRL                   (0x298e)
+#define P_VDEC2_MDEC_PIC_DC_CTRL                   (volatile unsigned int *)((0x298e  << 2) + 0xff620000)
+#define   VDEC2_MDEC_PIC_DC_STATUS                 (0x298f)
+#define P_VDEC2_MDEC_PIC_DC_STATUS                 (volatile unsigned int *)((0x298f  << 2) + 0xff620000)
+#define   VDEC2_ANC0_CANVAS_ADDR                   (0x2990)
+#define P_VDEC2_ANC0_CANVAS_ADDR                   (volatile unsigned int *)((0x2990  << 2) + 0xff620000)
+#define   VDEC2_ANC1_CANVAS_ADDR                   (0x2991)
+#define P_VDEC2_ANC1_CANVAS_ADDR                   (volatile unsigned int *)((0x2991  << 2) + 0xff620000)
+#define   VDEC2_ANC2_CANVAS_ADDR                   (0x2992)
+#define P_VDEC2_ANC2_CANVAS_ADDR                   (volatile unsigned int *)((0x2992  << 2) + 0xff620000)
+#define   VDEC2_ANC3_CANVAS_ADDR                   (0x2993)
+#define P_VDEC2_ANC3_CANVAS_ADDR                   (volatile unsigned int *)((0x2993  << 2) + 0xff620000)
+#define   VDEC2_ANC4_CANVAS_ADDR                   (0x2994)
+#define P_VDEC2_ANC4_CANVAS_ADDR                   (volatile unsigned int *)((0x2994  << 2) + 0xff620000)
+#define   VDEC2_ANC5_CANVAS_ADDR                   (0x2995)
+#define P_VDEC2_ANC5_CANVAS_ADDR                   (volatile unsigned int *)((0x2995  << 2) + 0xff620000)
+#define   VDEC2_ANC6_CANVAS_ADDR                   (0x2996)
+#define P_VDEC2_ANC6_CANVAS_ADDR                   (volatile unsigned int *)((0x2996  << 2) + 0xff620000)
+#define   VDEC2_ANC7_CANVAS_ADDR                   (0x2997)
+#define P_VDEC2_ANC7_CANVAS_ADDR                   (volatile unsigned int *)((0x2997  << 2) + 0xff620000)
+#define   VDEC2_ANC8_CANVAS_ADDR                   (0x2998)
+#define P_VDEC2_ANC8_CANVAS_ADDR                   (volatile unsigned int *)((0x2998  << 2) + 0xff620000)
+#define   VDEC2_ANC9_CANVAS_ADDR                   (0x2999)
+#define P_VDEC2_ANC9_CANVAS_ADDR                   (volatile unsigned int *)((0x2999  << 2) + 0xff620000)
+#define   VDEC2_ANC10_CANVAS_ADDR                  (0x299a)
+#define P_VDEC2_ANC10_CANVAS_ADDR                  (volatile unsigned int *)((0x299a  << 2) + 0xff620000)
+#define   VDEC2_ANC11_CANVAS_ADDR                  (0x299b)
+#define P_VDEC2_ANC11_CANVAS_ADDR                  (volatile unsigned int *)((0x299b  << 2) + 0xff620000)
+#define   VDEC2_ANC12_CANVAS_ADDR                  (0x299c)
+#define P_VDEC2_ANC12_CANVAS_ADDR                  (volatile unsigned int *)((0x299c  << 2) + 0xff620000)
+#define   VDEC2_ANC13_CANVAS_ADDR                  (0x299d)
+#define P_VDEC2_ANC13_CANVAS_ADDR                  (volatile unsigned int *)((0x299d  << 2) + 0xff620000)
+#define   VDEC2_ANC14_CANVAS_ADDR                  (0x299e)
+#define P_VDEC2_ANC14_CANVAS_ADDR                  (volatile unsigned int *)((0x299e  << 2) + 0xff620000)
+#define   VDEC2_ANC15_CANVAS_ADDR                  (0x299f)
+#define P_VDEC2_ANC15_CANVAS_ADDR                  (volatile unsigned int *)((0x299f  << 2) + 0xff620000)
+#define   VDEC2_ANC16_CANVAS_ADDR                  (0x29a0)
+#define P_VDEC2_ANC16_CANVAS_ADDR                  (volatile unsigned int *)((0x29a0  << 2) + 0xff620000)
+#define   VDEC2_ANC17_CANVAS_ADDR                  (0x29a1)
+#define P_VDEC2_ANC17_CANVAS_ADDR                  (volatile unsigned int *)((0x29a1  << 2) + 0xff620000)
+#define   VDEC2_ANC18_CANVAS_ADDR                  (0x29a2)
+#define P_VDEC2_ANC18_CANVAS_ADDR                  (volatile unsigned int *)((0x29a2  << 2) + 0xff620000)
+#define   VDEC2_ANC19_CANVAS_ADDR                  (0x29a3)
+#define P_VDEC2_ANC19_CANVAS_ADDR                  (volatile unsigned int *)((0x29a3  << 2) + 0xff620000)
+#define   VDEC2_ANC20_CANVAS_ADDR                  (0x29a4)
+#define P_VDEC2_ANC20_CANVAS_ADDR                  (volatile unsigned int *)((0x29a4  << 2) + 0xff620000)
+#define   VDEC2_ANC21_CANVAS_ADDR                  (0x29a5)
+#define P_VDEC2_ANC21_CANVAS_ADDR                  (volatile unsigned int *)((0x29a5  << 2) + 0xff620000)
+#define   VDEC2_ANC22_CANVAS_ADDR                  (0x29a6)
+#define P_VDEC2_ANC22_CANVAS_ADDR                  (volatile unsigned int *)((0x29a6  << 2) + 0xff620000)
+#define   VDEC2_ANC23_CANVAS_ADDR                  (0x29a7)
+#define P_VDEC2_ANC23_CANVAS_ADDR                  (volatile unsigned int *)((0x29a7  << 2) + 0xff620000)
+#define   VDEC2_ANC24_CANVAS_ADDR                  (0x29a8)
+#define P_VDEC2_ANC24_CANVAS_ADDR                  (volatile unsigned int *)((0x29a8  << 2) + 0xff620000)
+#define   VDEC2_ANC25_CANVAS_ADDR                  (0x29a9)
+#define P_VDEC2_ANC25_CANVAS_ADDR                  (volatile unsigned int *)((0x29a9  << 2) + 0xff620000)
+#define   VDEC2_ANC26_CANVAS_ADDR                  (0x29aa)
+#define P_VDEC2_ANC26_CANVAS_ADDR                  (volatile unsigned int *)((0x29aa  << 2) + 0xff620000)
+#define   VDEC2_ANC27_CANVAS_ADDR                  (0x29ab)
+#define P_VDEC2_ANC27_CANVAS_ADDR                  (volatile unsigned int *)((0x29ab  << 2) + 0xff620000)
+#define   VDEC2_ANC28_CANVAS_ADDR                  (0x29ac)
+#define P_VDEC2_ANC28_CANVAS_ADDR                  (volatile unsigned int *)((0x29ac  << 2) + 0xff620000)
+#define   VDEC2_ANC29_CANVAS_ADDR                  (0x29ad)
+#define P_VDEC2_ANC29_CANVAS_ADDR                  (volatile unsigned int *)((0x29ad  << 2) + 0xff620000)
+#define   VDEC2_ANC30_CANVAS_ADDR                  (0x29ae)
+#define P_VDEC2_ANC30_CANVAS_ADDR                  (volatile unsigned int *)((0x29ae  << 2) + 0xff620000)
+#define   VDEC2_ANC31_CANVAS_ADDR                  (0x29af)
+#define P_VDEC2_ANC31_CANVAS_ADDR                  (volatile unsigned int *)((0x29af  << 2) + 0xff620000)
+#define   VDEC2_DBKR_CANVAS_ADDR                   (0x29b0)
+#define P_VDEC2_DBKR_CANVAS_ADDR                   (volatile unsigned int *)((0x29b0  << 2) + 0xff620000)
+#define   VDEC2_DBKW_CANVAS_ADDR                   (0x29b1)
+#define P_VDEC2_DBKW_CANVAS_ADDR                   (volatile unsigned int *)((0x29b1  << 2) + 0xff620000)
+#define   VDEC2_REC_CANVAS_ADDR                    (0x29b2)
+#define P_VDEC2_REC_CANVAS_ADDR                    (volatile unsigned int *)((0x29b2  << 2) + 0xff620000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define   VDEC2_CURR_CANVAS_CTRL                   (0x29b3)
+#define P_VDEC2_CURR_CANVAS_CTRL                   (volatile unsigned int *)((0x29b3  << 2) + 0xff620000)
+#define   VDEC2_MDEC_PIC_DC_THRESH                 (0x29b8)
+#define P_VDEC2_MDEC_PIC_DC_THRESH                 (volatile unsigned int *)((0x29b8  << 2) + 0xff620000)
+#define   VDEC2_MDEC_PICR_BUF_STATUS               (0x29b9)
+#define P_VDEC2_MDEC_PICR_BUF_STATUS               (volatile unsigned int *)((0x29b9  << 2) + 0xff620000)
+#define   VDEC2_MDEC_PICW_BUF_STATUS               (0x29ba)
+#define P_VDEC2_MDEC_PICW_BUF_STATUS               (volatile unsigned int *)((0x29ba  << 2) + 0xff620000)
+#define   VDEC2_MCW_DBLK_WRRSP_CNT                 (0x29bb)
+#define P_VDEC2_MCW_DBLK_WRRSP_CNT                 (volatile unsigned int *)((0x29bb  << 2) + 0xff620000)
+#define   VDEC2_MC_MBBOT_WRRSP_CNT                 (0x29bc)
+#define P_VDEC2_MC_MBBOT_WRRSP_CNT                 (volatile unsigned int *)((0x29bc  << 2) + 0xff620000)
+#define   VDEC2_MDEC_PICW_BUF2_STATUS              (0x29bd)
+#define P_VDEC2_MDEC_PICW_BUF2_STATUS              (volatile unsigned int *)((0x29bd  << 2) + 0xff620000)
+#define   VDEC2_WRRSP_FIFO_PICW_DBK                (0x29be)
+#define P_VDEC2_WRRSP_FIFO_PICW_DBK                (volatile unsigned int *)((0x29be  << 2) + 0xff620000)
+#define   VDEC2_WRRSP_FIFO_PICW_MC                 (0x29bf)
+#define P_VDEC2_WRRSP_FIFO_PICW_MC                 (volatile unsigned int *)((0x29bf  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_0                       (0x29c0)
+#define P_VDEC2_AV_SCRATCH_0                       (volatile unsigned int *)((0x29c0  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_1                       (0x29c1)
+#define P_VDEC2_AV_SCRATCH_1                       (volatile unsigned int *)((0x29c1  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_2                       (0x29c2)
+#define P_VDEC2_AV_SCRATCH_2                       (volatile unsigned int *)((0x29c2  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_3                       (0x29c3)
+#define P_VDEC2_AV_SCRATCH_3                       (volatile unsigned int *)((0x29c3  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_4                       (0x29c4)
+#define P_VDEC2_AV_SCRATCH_4                       (volatile unsigned int *)((0x29c4  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_5                       (0x29c5)
+#define P_VDEC2_AV_SCRATCH_5                       (volatile unsigned int *)((0x29c5  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_6                       (0x29c6)
+#define P_VDEC2_AV_SCRATCH_6                       (volatile unsigned int *)((0x29c6  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_7                       (0x29c7)
+#define P_VDEC2_AV_SCRATCH_7                       (volatile unsigned int *)((0x29c7  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_8                       (0x29c8)
+#define P_VDEC2_AV_SCRATCH_8                       (volatile unsigned int *)((0x29c8  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_9                       (0x29c9)
+#define P_VDEC2_AV_SCRATCH_9                       (volatile unsigned int *)((0x29c9  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_A                       (0x29ca)
+#define P_VDEC2_AV_SCRATCH_A                       (volatile unsigned int *)((0x29ca  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_B                       (0x29cb)
+#define P_VDEC2_AV_SCRATCH_B                       (volatile unsigned int *)((0x29cb  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_C                       (0x29cc)
+#define P_VDEC2_AV_SCRATCH_C                       (volatile unsigned int *)((0x29cc  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_D                       (0x29cd)
+#define P_VDEC2_AV_SCRATCH_D                       (volatile unsigned int *)((0x29cd  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_E                       (0x29ce)
+#define P_VDEC2_AV_SCRATCH_E                       (volatile unsigned int *)((0x29ce  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_F                       (0x29cf)
+#define P_VDEC2_AV_SCRATCH_F                       (volatile unsigned int *)((0x29cf  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_G                       (0x29d0)
+#define P_VDEC2_AV_SCRATCH_G                       (volatile unsigned int *)((0x29d0  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_H                       (0x29d1)
+#define P_VDEC2_AV_SCRATCH_H                       (volatile unsigned int *)((0x29d1  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_I                       (0x29d2)
+#define P_VDEC2_AV_SCRATCH_I                       (volatile unsigned int *)((0x29d2  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_J                       (0x29d3)
+#define P_VDEC2_AV_SCRATCH_J                       (volatile unsigned int *)((0x29d3  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_K                       (0x29d4)
+#define P_VDEC2_AV_SCRATCH_K                       (volatile unsigned int *)((0x29d4  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_L                       (0x29d5)
+#define P_VDEC2_AV_SCRATCH_L                       (volatile unsigned int *)((0x29d5  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_M                       (0x29d6)
+#define P_VDEC2_AV_SCRATCH_M                       (volatile unsigned int *)((0x29d6  << 2) + 0xff620000)
+#define   VDEC2_AV_SCRATCH_N                       (0x29d7)
+#define P_VDEC2_AV_SCRATCH_N                       (volatile unsigned int *)((0x29d7  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define   VDEC2_WRRSP_CO_MB                        (0x29d8)
+#define P_VDEC2_WRRSP_CO_MB                        (volatile unsigned int *)((0x29d8  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define   VDEC2_WRRSP_DCAC                         (0x29d9)
+#define P_VDEC2_WRRSP_DCAC                         (volatile unsigned int *)((0x29d9  << 2) + 0xff620000)
+// bit[11:0] wrrsp_count_vld
+#define   VDEC2_WRRSP_VLD                          (0x29da)
+#define P_VDEC2_WRRSP_VLD                          (volatile unsigned int *)((0x29da  << 2) + 0xff620000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define   VDEC2_MDEC_DOUBLEW_CFG0                  (0x29db)
+#define P_VDEC2_MDEC_DOUBLEW_CFG0                  (volatile unsigned int *)((0x29db  << 2) + 0xff620000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write -
+// doublew_cfg1[17];    //       Reverse to original version -
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define   VDEC2_MDEC_DOUBLEW_CFG1                  (0x29dc)
+#define P_VDEC2_MDEC_DOUBLEW_CFG1                  (volatile unsigned int *)((0x29dc  << 2) + 0xff620000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define   VDEC2_MDEC_DOUBLEW_CFG2                  (0x29dd)
+#define P_VDEC2_MDEC_DOUBLEW_CFG2                  (volatile unsigned int *)((0x29dd  << 2) + 0xff620000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma -
+#define   VDEC2_MDEC_DOUBLEW_CFG3                  (0x29de)
+#define P_VDEC2_MDEC_DOUBLEW_CFG3                  (volatile unsigned int *)((0x29de  << 2) + 0xff620000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma -
+#define   VDEC2_MDEC_DOUBLEW_CFG4                  (0x29df)
+#define P_VDEC2_MDEC_DOUBLEW_CFG4                  (volatile unsigned int *)((0x29df  << 2) + 0xff620000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma -
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma -
+#define   VDEC2_MDEC_DOUBLEW_CFG5                  (0x29e0)
+#define P_VDEC2_MDEC_DOUBLEW_CFG5                  (volatile unsigned int *)((0x29e0  << 2) + 0xff620000)
+// doublew_cfg6: reserved
+#define   VDEC2_MDEC_DOUBLEW_CFG6                  (0x29e1)
+#define P_VDEC2_MDEC_DOUBLEW_CFG6                  (volatile unsigned int *)((0x29e1  << 2) + 0xff620000)
+// doublew_cfg7: reserved
+#define   VDEC2_MDEC_DOUBLEW_CFG7                  (0x29e2)
+#define P_VDEC2_MDEC_DOUBLEW_CFG7                  (volatile unsigned int *)((0x29e2  << 2) + 0xff620000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define   VDEC2_MDEC_DOUBLEW_STATUS                (0x29e3)
+#define P_VDEC2_MDEC_DOUBLEW_STATUS                (volatile unsigned int *)((0x29e3  << 2) + 0xff620000)
+#define   VDEC2_MDEC_EXTIF_CFG0                    (0x29e4)
+#define P_VDEC2_MDEC_EXTIF_CFG0                    (volatile unsigned int *)((0x29e4  << 2) + 0xff620000)
+#define   VDEC2_MDEC_EXTIF_CFG1                    (0x29e5)
+#define P_VDEC2_MDEC_EXTIF_CFG1                    (volatile unsigned int *)((0x29e5  << 2) + 0xff620000)
+#define   VDEC2_MDEC_EXTIF_STS0                    (0x29e6)
+#define P_VDEC2_MDEC_EXTIF_STS0                    (volatile unsigned int *)((0x29e6  << 2) + 0xff620000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    //`define MC_RESET	    16'h0002
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f
+//========================================================================
+#define   VDEC2_DBLK_RST                           (0x2950)
+#define P_VDEC2_DBLK_RST                           (volatile unsigned int *)((0x2950  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CTRL                          (0x2951)
+#define P_VDEC2_DBLK_CTRL                          (volatile unsigned int *)((0x2951  << 2) + 0xff620000)
+#define   VDEC2_DBLK_MB_WID_HEIGHT                 (0x2952)
+#define P_VDEC2_DBLK_MB_WID_HEIGHT                 (volatile unsigned int *)((0x2952  << 2) + 0xff620000)
+#define   VDEC2_DBLK_STATUS                        (0x2953)
+#define P_VDEC2_DBLK_STATUS                        (volatile unsigned int *)((0x2953  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CMD_CTRL                      (0x2954)
+#define P_VDEC2_DBLK_CMD_CTRL                      (volatile unsigned int *)((0x2954  << 2) + 0xff620000)
+#define   VDEC2_DBLK_MB_XY                         (0x2955)
+#define P_VDEC2_DBLK_MB_XY                         (volatile unsigned int *)((0x2955  << 2) + 0xff620000)
+#define   VDEC2_DBLK_QP                            (0x2956)
+#define P_VDEC2_DBLK_QP                            (volatile unsigned int *)((0x2956  << 2) + 0xff620000)
+#define   VDEC2_DBLK_Y_BHFILT                      (0x2957)
+#define P_VDEC2_DBLK_Y_BHFILT                      (volatile unsigned int *)((0x2957  << 2) + 0xff620000)
+#define   VDEC2_DBLK_Y_BHFILT_HIGH                 (0x2958)
+#define P_VDEC2_DBLK_Y_BHFILT_HIGH                 (volatile unsigned int *)((0x2958  << 2) + 0xff620000)
+#define   VDEC2_DBLK_Y_BVFILT                      (0x2959)
+#define P_VDEC2_DBLK_Y_BVFILT                      (volatile unsigned int *)((0x2959  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CB_BFILT                      (0x295a)
+#define P_VDEC2_DBLK_CB_BFILT                      (volatile unsigned int *)((0x295a  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CR_BFILT                      (0x295b)
+#define P_VDEC2_DBLK_CR_BFILT                      (volatile unsigned int *)((0x295b  << 2) + 0xff620000)
+#define   VDEC2_DBLK_Y_HFILT                       (0x295c)
+#define P_VDEC2_DBLK_Y_HFILT                       (volatile unsigned int *)((0x295c  << 2) + 0xff620000)
+#define   VDEC2_DBLK_Y_HFILT_HIGH                  (0x295d)
+#define P_VDEC2_DBLK_Y_HFILT_HIGH                  (volatile unsigned int *)((0x295d  << 2) + 0xff620000)
+#define   VDEC2_DBLK_Y_VFILT                       (0x295e)
+#define P_VDEC2_DBLK_Y_VFILT                       (volatile unsigned int *)((0x295e  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CB_FILT                       (0x295f)
+#define P_VDEC2_DBLK_CB_FILT                       (volatile unsigned int *)((0x295f  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CR_FILT                       (0x2960)
+#define P_VDEC2_DBLK_CR_FILT                       (volatile unsigned int *)((0x2960  << 2) + 0xff620000)
+#define   VDEC2_DBLK_BETAX_QP_SEL                  (0x2961)
+#define P_VDEC2_DBLK_BETAX_QP_SEL                  (volatile unsigned int *)((0x2961  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL0                    (0x2962)
+#define P_VDEC2_DBLK_CLIP_CTRL0                    (volatile unsigned int *)((0x2962  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL1                    (0x2963)
+#define P_VDEC2_DBLK_CLIP_CTRL1                    (volatile unsigned int *)((0x2963  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL2                    (0x2964)
+#define P_VDEC2_DBLK_CLIP_CTRL2                    (volatile unsigned int *)((0x2964  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL3                    (0x2965)
+#define P_VDEC2_DBLK_CLIP_CTRL3                    (volatile unsigned int *)((0x2965  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL4                    (0x2966)
+#define P_VDEC2_DBLK_CLIP_CTRL4                    (volatile unsigned int *)((0x2966  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL5                    (0x2967)
+#define P_VDEC2_DBLK_CLIP_CTRL5                    (volatile unsigned int *)((0x2967  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL6                    (0x2968)
+#define P_VDEC2_DBLK_CLIP_CTRL6                    (volatile unsigned int *)((0x2968  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL7                    (0x2969)
+#define P_VDEC2_DBLK_CLIP_CTRL7                    (volatile unsigned int *)((0x2969  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CLIP_CTRL8                    (0x296a)
+#define P_VDEC2_DBLK_CLIP_CTRL8                    (volatile unsigned int *)((0x296a  << 2) + 0xff620000)
+#define   VDEC2_DBLK_STATUS1                       (0x296b)
+#define P_VDEC2_DBLK_STATUS1                       (volatile unsigned int *)((0x296b  << 2) + 0xff620000)
+#define   VDEC2_DBLK_GCLK_FREE                     (0x296c)
+#define P_VDEC2_DBLK_GCLK_FREE                     (volatile unsigned int *)((0x296c  << 2) + 0xff620000)
+#define   VDEC2_DBLK_GCLK_OFF                      (0x296d)
+#define P_VDEC2_DBLK_GCLK_OFF                      (volatile unsigned int *)((0x296d  << 2) + 0xff620000)
+#define   VDEC2_DBLK_AVSFLAGS                      (0x296e)
+#define P_VDEC2_DBLK_AVSFLAGS                      (volatile unsigned int *)((0x296e  << 2) + 0xff620000)
+// bit 15:0
+#define   VDEC2_DBLK_CBPY                          (0x2970)
+#define P_VDEC2_DBLK_CBPY                          (volatile unsigned int *)((0x2970  << 2) + 0xff620000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define   VDEC2_DBLK_CBPY_ADJ                      (0x2971)
+#define P_VDEC2_DBLK_CBPY_ADJ                      (volatile unsigned int *)((0x2971  << 2) + 0xff620000)
+// bit 7:0 -- deblk_cbpc
+#define   VDEC2_DBLK_CBPC                          (0x2972)
+#define P_VDEC2_DBLK_CBPC                          (volatile unsigned int *)((0x2972  << 2) + 0xff620000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define   VDEC2_DBLK_CBPC_ADJ                      (0x2973)
+#define P_VDEC2_DBLK_CBPC_ADJ                      (volatile unsigned int *)((0x2973  << 2) + 0xff620000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0}
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0}
+#define   VDEC2_DBLK_VHMVD                         (0x2974)
+#define P_VDEC2_DBLK_VHMVD                         (volatile unsigned int *)((0x2974  << 2) + 0xff620000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s
+#define   VDEC2_DBLK_STRONG                        (0x2975)
+#define P_VDEC2_DBLK_STRONG                        (volatile unsigned int *)((0x2975  << 2) + 0xff620000)
+// bit 14:10 -- PQUANT
+// bit 9:5 -- left_PQUANT
+// bit 4:0 -- top_PQUANT
+#define   VDEC2_DBLK_RV8_QUANT                     (0x2976)
+#define P_VDEC2_DBLK_RV8_QUANT                     (volatile unsigned int *)((0x2976  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CBUS_HCMD2                    (0x2977)
+#define P_VDEC2_DBLK_CBUS_HCMD2                    (volatile unsigned int *)((0x2977  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CBUS_HCMD1                    (0x2978)
+#define P_VDEC2_DBLK_CBUS_HCMD1                    (volatile unsigned int *)((0x2978  << 2) + 0xff620000)
+#define   VDEC2_DBLK_CBUS_HCMD0                    (0x2979)
+#define P_VDEC2_DBLK_CBUS_HCMD0                    (volatile unsigned int *)((0x2979  << 2) + 0xff620000)
+#define   VDEC2_DBLK_VLD_HCMD2                     (0x297a)
+#define P_VDEC2_DBLK_VLD_HCMD2                     (volatile unsigned int *)((0x297a  << 2) + 0xff620000)
+#define   VDEC2_DBLK_VLD_HCMD1                     (0x297b)
+#define P_VDEC2_DBLK_VLD_HCMD1                     (volatile unsigned int *)((0x297b  << 2) + 0xff620000)
+#define   VDEC2_DBLK_VLD_HCMD0                     (0x297c)
+#define P_VDEC2_DBLK_VLD_HCMD0                     (volatile unsigned int *)((0x297c  << 2) + 0xff620000)
+#define   VDEC2_DBLK_OST_YBASE                     (0x297d)
+#define P_VDEC2_DBLK_OST_YBASE                     (volatile unsigned int *)((0x297d  << 2) + 0xff620000)
+#define   VDEC2_DBLK_OST_CBCRDIFF                  (0x297e)
+#define P_VDEC2_DBLK_OST_CBCRDIFF                  (volatile unsigned int *)((0x297e  << 2) + 0xff620000)
+//13:8 dblk thread ID and token
+//5:0  dblk prearbitor burst num
+#define   VDEC2_DBLK_CTRL1                         (0x297f)
+#define P_VDEC2_DBLK_CTRL1                         (volatile unsigned int *)((0x297f  << 2) + 0xff620000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define   VDEC2_MCRCC_CTL1                         (0x2980)
+#define P_VDEC2_MCRCC_CTL1                         (volatile unsigned int *)((0x2980  << 2) + 0xff620000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define   VDEC2_MCRCC_CTL2                         (0x2981)
+#define P_VDEC2_MCRCC_CTL2                         (volatile unsigned int *)((0x2981  << 2) + 0xff620000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define   VDEC2_MCRCC_CTL3                         (0x2982)
+#define P_VDEC2_MCRCC_CTL3                         (volatile unsigned int *)((0x2982  << 2) + 0xff620000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define   VDEC2_GCLK_EN                            (0x2983)
+#define P_VDEC2_GCLK_EN                            (volatile unsigned int *)((0x2983  << 2) + 0xff620000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define   VDEC2_MDEC_SW_RESET                      (0x2984)
+#define P_VDEC2_MDEC_SW_RESET                      (volatile unsigned int *)((0x2984  << 2) + 0xff620000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define   HEVC_MC_CTRL_REG                         (0x3900)
+#define P_HEVC_MC_CTRL_REG                         (volatile unsigned int *)((0x3900  << 2) + 0xff620000)
+#define   HEVC_MC_MB_INFO                          (0x3901)
+#define P_HEVC_MC_MB_INFO                          (volatile unsigned int *)((0x3901  << 2) + 0xff620000)
+#define   HEVC_MC_PIC_INFO                         (0x3902)
+#define P_HEVC_MC_PIC_INFO                         (volatile unsigned int *)((0x3902  << 2) + 0xff620000)
+#define   HEVC_MC_HALF_PEL_ONE                     (0x3903)
+#define P_HEVC_MC_HALF_PEL_ONE                     (volatile unsigned int *)((0x3903  << 2) + 0xff620000)
+#define   HEVC_MC_HALF_PEL_TWO                     (0x3904)
+#define P_HEVC_MC_HALF_PEL_TWO                     (volatile unsigned int *)((0x3904  << 2) + 0xff620000)
+#define   HEVC_POWER_CTL_MC                        (0x3905)
+#define P_HEVC_POWER_CTL_MC                        (volatile unsigned int *)((0x3905  << 2) + 0xff620000)
+#define   HEVC_MC_CMD                              (0x3906)
+#define P_HEVC_MC_CMD                              (volatile unsigned int *)((0x3906  << 2) + 0xff620000)
+#define   HEVC_MC_CTRL0                            (0x3907)
+#define P_HEVC_MC_CTRL0                            (volatile unsigned int *)((0x3907  << 2) + 0xff620000)
+#define   HEVC_MC_PIC_W_H                          (0x3908)
+#define P_HEVC_MC_PIC_W_H                          (volatile unsigned int *)((0x3908  << 2) + 0xff620000)
+#define   HEVC_MC_STATUS0                          (0x3909)
+#define P_HEVC_MC_STATUS0                          (volatile unsigned int *)((0x3909  << 2) + 0xff620000)
+#define   HEVC_MC_STATUS1                          (0x390a)
+#define P_HEVC_MC_STATUS1                          (volatile unsigned int *)((0x390a  << 2) + 0xff620000)
+#define   HEVC_MC_CTRL1                            (0x390b)
+#define P_HEVC_MC_CTRL1                            (volatile unsigned int *)((0x390b  << 2) + 0xff620000)
+#define   HEVC_MC_MIX_RATIO0                       (0x390c)
+#define P_HEVC_MC_MIX_RATIO0                       (volatile unsigned int *)((0x390c  << 2) + 0xff620000)
+#define   HEVC_MC_MIX_RATIO1                       (0x390d)
+#define P_HEVC_MC_MIX_RATIO1                       (volatile unsigned int *)((0x390d  << 2) + 0xff620000)
+#define   HEVC_MC_DP_MB_XY                         (0x390e)
+#define P_HEVC_MC_DP_MB_XY                         (volatile unsigned int *)((0x390e  << 2) + 0xff620000)
+#define   HEVC_MC_OM_MB_XY                         (0x390f)
+#define P_HEVC_MC_OM_MB_XY                         (volatile unsigned int *)((0x390f  << 2) + 0xff620000)
+#define   HEVC_PSCALE_RST                          (0x3910)
+#define P_HEVC_PSCALE_RST                          (volatile unsigned int *)((0x3910  << 2) + 0xff620000)
+#define   HEVC_PSCALE_CTRL                         (0x3911)
+#define P_HEVC_PSCALE_CTRL                         (volatile unsigned int *)((0x3911  << 2) + 0xff620000)
+#define   HEVC_PSCALE_PICI_W                       (0x3912)
+#define P_HEVC_PSCALE_PICI_W                       (volatile unsigned int *)((0x3912  << 2) + 0xff620000)
+#define   HEVC_PSCALE_PICI_H                       (0x3913)
+#define P_HEVC_PSCALE_PICI_H                       (volatile unsigned int *)((0x3913  << 2) + 0xff620000)
+#define   HEVC_PSCALE_PICO_W                       (0x3914)
+#define P_HEVC_PSCALE_PICO_W                       (volatile unsigned int *)((0x3914  << 2) + 0xff620000)
+#define   HEVC_PSCALE_PICO_H                       (0x3915)
+#define P_HEVC_PSCALE_PICO_H                       (volatile unsigned int *)((0x3915  << 2) + 0xff620000)
+#define   HEVC_PSCALE_PICO_START_X                 (0x3916)
+#define P_HEVC_PSCALE_PICO_START_X                 (volatile unsigned int *)((0x3916  << 2) + 0xff620000)
+#define   HEVC_PSCALE_PICO_START_Y                 (0x3917)
+#define P_HEVC_PSCALE_PICO_START_Y                 (volatile unsigned int *)((0x3917  << 2) + 0xff620000)
+#define   HEVC_PSCALE_DUMMY                        (0x3918)
+#define P_HEVC_PSCALE_DUMMY                        (volatile unsigned int *)((0x3918  << 2) + 0xff620000)
+#define   HEVC_PSCALE_FILT0_COEF0                  (0x3919)
+#define P_HEVC_PSCALE_FILT0_COEF0                  (volatile unsigned int *)((0x3919  << 2) + 0xff620000)
+#define   HEVC_PSCALE_FILT0_COEF1                  (0x391a)
+#define P_HEVC_PSCALE_FILT0_COEF1                  (volatile unsigned int *)((0x391a  << 2) + 0xff620000)
+#define   HEVC_PSCALE_CMD_CTRL                     (0x391b)
+#define P_HEVC_PSCALE_CMD_CTRL                     (volatile unsigned int *)((0x391b  << 2) + 0xff620000)
+#define   HEVC_PSCALE_CMD_BLK_X                    (0x391c)
+#define P_HEVC_PSCALE_CMD_BLK_X                    (volatile unsigned int *)((0x391c  << 2) + 0xff620000)
+#define   HEVC_PSCALE_CMD_BLK_Y                    (0x391d)
+#define P_HEVC_PSCALE_CMD_BLK_Y                    (volatile unsigned int *)((0x391d  << 2) + 0xff620000)
+#define   HEVC_PSCALE_STATUS                       (0x391e)
+#define P_HEVC_PSCALE_STATUS                       (volatile unsigned int *)((0x391e  << 2) + 0xff620000)
+#define   HEVC_PSCALE_BMEM_ADDR                    (0x391f)
+#define P_HEVC_PSCALE_BMEM_ADDR                    (volatile unsigned int *)((0x391f  << 2) + 0xff620000)
+#define   HEVC_PSCALE_BMEM_DAT                     (0x3920)
+#define P_HEVC_PSCALE_BMEM_DAT                     (volatile unsigned int *)((0x3920  << 2) + 0xff620000)
+#define   HEVC_PSCALE_DRAM_BUF_CTRL                (0x3921)
+#define P_HEVC_PSCALE_DRAM_BUF_CTRL                (volatile unsigned int *)((0x3921  << 2) + 0xff620000)
+#define   HEVC_PSCALE_MCMD_CTRL                    (0x3922)
+#define P_HEVC_PSCALE_MCMD_CTRL                    (volatile unsigned int *)((0x3922  << 2) + 0xff620000)
+#define   HEVC_PSCALE_MCMD_XSIZE                   (0x3923)
+#define P_HEVC_PSCALE_MCMD_XSIZE                   (volatile unsigned int *)((0x3923  << 2) + 0xff620000)
+#define   HEVC_PSCALE_MCMD_YSIZE                   (0x3924)
+#define P_HEVC_PSCALE_MCMD_YSIZE                   (volatile unsigned int *)((0x3924  << 2) + 0xff620000)
+#define   HEVC_PSCALE_RBUF_START_BLKX              (0x3925)
+#define P_HEVC_PSCALE_RBUF_START_BLKX              (volatile unsigned int *)((0x3925  << 2) + 0xff620000)
+#define   HEVC_PSCALE_RBUF_START_BLKY              (0x3926)
+#define P_HEVC_PSCALE_RBUF_START_BLKY              (volatile unsigned int *)((0x3926  << 2) + 0xff620000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define   HEVC_PSCALE_PICO_SHIFT_XY                (0x3928)
+#define P_HEVC_PSCALE_PICO_SHIFT_XY                (volatile unsigned int *)((0x3928  << 2) + 0xff620000)
+#define   HEVC_PSCALE_CTRL1                        (0x3929)
+#define P_HEVC_PSCALE_CTRL1                        (volatile unsigned int *)((0x3929  << 2) + 0xff620000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less,
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define   HEVC_PSCALE_SRCKEY_CTRL0                 (0x392a)
+#define P_HEVC_PSCALE_SRCKEY_CTRL0                 (volatile unsigned int *)((0x392a  << 2) + 0xff620000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define   HEVC_PSCALE_SRCKEY_CTRL1                 (0x392b)
+#define P_HEVC_PSCALE_SRCKEY_CTRL1                 (volatile unsigned int *)((0x392b  << 2) + 0xff620000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define   HEVC_PSCALE_CANVAS_RD_ADDR               (0x392c)
+#define P_HEVC_PSCALE_CANVAS_RD_ADDR               (volatile unsigned int *)((0x392c  << 2) + 0xff620000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define   HEVC_PSCALE_CANVAS_WR_ADDR               (0x392d)
+#define P_HEVC_PSCALE_CANVAS_WR_ADDR               (volatile unsigned int *)((0x392d  << 2) + 0xff620000)
+//bit 13:8 pscale thread ID and token
+//bit 7 disable write response count adding to busy bit
+//bit 5:0  pscale prearbitor burst num
+#define   HEVC_PSCALE_CTRL2                        (0x392e)
+#define P_HEVC_PSCALE_CTRL2                        (volatile unsigned int *)((0x392e  << 2) + 0xff620000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define   HEVC_HDEC_MC_OMEM_AUTO                   (0x3930)
+#define P_HEVC_HDEC_MC_OMEM_AUTO                   (volatile unsigned int *)((0x3930  << 2) + 0xff620000)
+#define   HEVC_HDEC_MC_MBRIGHT_IDX                 (0x3931)
+#define P_HEVC_HDEC_MC_MBRIGHT_IDX                 (volatile unsigned int *)((0x3931  << 2) + 0xff620000)
+#define   HEVC_HDEC_MC_MBRIGHT_RD                  (0x3932)
+#define P_HEVC_HDEC_MC_MBRIGHT_RD                  (volatile unsigned int *)((0x3932  << 2) + 0xff620000)
+#define   HEVC_MC_MPORT_CTRL                       (0x3940)
+#define P_HEVC_MC_MPORT_CTRL                       (volatile unsigned int *)((0x3940  << 2) + 0xff620000)
+#define   HEVC_MC_MPORT_DAT                        (0x3941)
+#define P_HEVC_MC_MPORT_DAT                        (volatile unsigned int *)((0x3941  << 2) + 0xff620000)
+#define   HEVC_MC_WT_PRED_CTRL                     (0x3942)
+#define P_HEVC_MC_WT_PRED_CTRL                     (volatile unsigned int *)((0x3942  << 2) + 0xff620000)
+#define   HEVC_MC_MBBOT_ST_EVEN_ADDR               (0x3944)
+#define P_HEVC_MC_MBBOT_ST_EVEN_ADDR               (volatile unsigned int *)((0x3944  << 2) + 0xff620000)
+#define   HEVC_MC_MBBOT_ST_ODD_ADDR                (0x3945)
+#define P_HEVC_MC_MBBOT_ST_ODD_ADDR                (volatile unsigned int *)((0x3945  << 2) + 0xff620000)
+#define   HEVC_MC_DPDN_MB_XY                       (0x3946)
+#define P_HEVC_MC_DPDN_MB_XY                       (volatile unsigned int *)((0x3946  << 2) + 0xff620000)
+#define   HEVC_MC_OMDN_MB_XY                       (0x3947)
+#define P_HEVC_MC_OMDN_MB_XY                       (volatile unsigned int *)((0x3947  << 2) + 0xff620000)
+#define   HEVC_MC_HCMDBUF_H                        (0x3948)
+#define P_HEVC_MC_HCMDBUF_H                        (volatile unsigned int *)((0x3948  << 2) + 0xff620000)
+#define   HEVC_MC_HCMDBUF_L                        (0x3949)
+#define P_HEVC_MC_HCMDBUF_L                        (volatile unsigned int *)((0x3949  << 2) + 0xff620000)
+#define   HEVC_MC_HCMD_H                           (0x394a)
+#define P_HEVC_MC_HCMD_H                           (volatile unsigned int *)((0x394a  << 2) + 0xff620000)
+#define   HEVC_MC_HCMD_L                           (0x394b)
+#define P_HEVC_MC_HCMD_L                           (volatile unsigned int *)((0x394b  << 2) + 0xff620000)
+#define   HEVC_MC_IDCT_DAT                         (0x394c)
+#define P_HEVC_MC_IDCT_DAT                         (volatile unsigned int *)((0x394c  << 2) + 0xff620000)
+#define   HEVC_MC_CTRL_GCLK_CTRL                   (0x394d)
+#define P_HEVC_MC_CTRL_GCLK_CTRL                   (volatile unsigned int *)((0x394d  << 2) + 0xff620000)
+#define   HEVC_MC_OTHER_GCLK_CTRL                  (0x394e)
+#define P_HEVC_MC_OTHER_GCLK_CTRL                  (volatile unsigned int *)((0x394e  << 2) + 0xff620000)
+//Bit 29:24, mbbot thread ID and token
+//Bit 21:16, mc read/write thread ID and token
+//Bit 13:8,  mbbot pre-arbitor burst number
+//Bit 5:0,   mc pre-arbitor burst number
+#define   HEVC_MC_CTRL2                            (0x394f)
+#define P_HEVC_MC_CTRL2                            (volatile unsigned int *)((0x394f  << 2) + 0xff620000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+// mdec_pic_dc_mux_ctrl[31]  -- mcr_hevc_mode
+#define   HEVC_MDEC_PIC_DC_MUX_CTRL                (0x398d)
+#define P_HEVC_MDEC_PIC_DC_MUX_CTRL                (volatile unsigned int *)((0x398d  << 2) + 0xff620000)
+#define   HEVC_MDEC_PIC_DC_CTRL                    (0x398e)
+#define P_HEVC_MDEC_PIC_DC_CTRL                    (volatile unsigned int *)((0x398e  << 2) + 0xff620000)
+#define   HEVC_MDEC_PIC_DC_STATUS                  (0x398f)
+#define P_HEVC_MDEC_PIC_DC_STATUS                  (volatile unsigned int *)((0x398f  << 2) + 0xff620000)
+#define   HEVC_ANC0_CANVAS_ADDR                    (0x3990)
+#define P_HEVC_ANC0_CANVAS_ADDR                    (volatile unsigned int *)((0x3990  << 2) + 0xff620000)
+#define   HEVC_ANC1_CANVAS_ADDR                    (0x3991)
+#define P_HEVC_ANC1_CANVAS_ADDR                    (volatile unsigned int *)((0x3991  << 2) + 0xff620000)
+#define   HEVC_ANC2_CANVAS_ADDR                    (0x3992)
+#define P_HEVC_ANC2_CANVAS_ADDR                    (volatile unsigned int *)((0x3992  << 2) + 0xff620000)
+#define   HEVC_ANC3_CANVAS_ADDR                    (0x3993)
+#define P_HEVC_ANC3_CANVAS_ADDR                    (volatile unsigned int *)((0x3993  << 2) + 0xff620000)
+#define   HEVC_ANC4_CANVAS_ADDR                    (0x3994)
+#define P_HEVC_ANC4_CANVAS_ADDR                    (volatile unsigned int *)((0x3994  << 2) + 0xff620000)
+#define   HEVC_ANC5_CANVAS_ADDR                    (0x3995)
+#define P_HEVC_ANC5_CANVAS_ADDR                    (volatile unsigned int *)((0x3995  << 2) + 0xff620000)
+#define   HEVC_ANC6_CANVAS_ADDR                    (0x3996)
+#define P_HEVC_ANC6_CANVAS_ADDR                    (volatile unsigned int *)((0x3996  << 2) + 0xff620000)
+#define   HEVC_ANC7_CANVAS_ADDR                    (0x3997)
+#define P_HEVC_ANC7_CANVAS_ADDR                    (volatile unsigned int *)((0x3997  << 2) + 0xff620000)
+#define   HEVC_ANC8_CANVAS_ADDR                    (0x3998)
+#define P_HEVC_ANC8_CANVAS_ADDR                    (volatile unsigned int *)((0x3998  << 2) + 0xff620000)
+#define   HEVC_ANC9_CANVAS_ADDR                    (0x3999)
+#define P_HEVC_ANC9_CANVAS_ADDR                    (volatile unsigned int *)((0x3999  << 2) + 0xff620000)
+#define   HEVC_ANC10_CANVAS_ADDR                   (0x399a)
+#define P_HEVC_ANC10_CANVAS_ADDR                   (volatile unsigned int *)((0x399a  << 2) + 0xff620000)
+#define   HEVC_ANC11_CANVAS_ADDR                   (0x399b)
+#define P_HEVC_ANC11_CANVAS_ADDR                   (volatile unsigned int *)((0x399b  << 2) + 0xff620000)
+#define   HEVC_ANC12_CANVAS_ADDR                   (0x399c)
+#define P_HEVC_ANC12_CANVAS_ADDR                   (volatile unsigned int *)((0x399c  << 2) + 0xff620000)
+#define   HEVC_ANC13_CANVAS_ADDR                   (0x399d)
+#define P_HEVC_ANC13_CANVAS_ADDR                   (volatile unsigned int *)((0x399d  << 2) + 0xff620000)
+#define   HEVC_ANC14_CANVAS_ADDR                   (0x399e)
+#define P_HEVC_ANC14_CANVAS_ADDR                   (volatile unsigned int *)((0x399e  << 2) + 0xff620000)
+#define   HEVC_ANC15_CANVAS_ADDR                   (0x399f)
+#define P_HEVC_ANC15_CANVAS_ADDR                   (volatile unsigned int *)((0x399f  << 2) + 0xff620000)
+#define   HEVC_ANC16_CANVAS_ADDR                   (0x39a0)
+#define P_HEVC_ANC16_CANVAS_ADDR                   (volatile unsigned int *)((0x39a0  << 2) + 0xff620000)
+#define   HEVC_ANC17_CANVAS_ADDR                   (0x39a1)
+#define P_HEVC_ANC17_CANVAS_ADDR                   (volatile unsigned int *)((0x39a1  << 2) + 0xff620000)
+#define   HEVC_ANC18_CANVAS_ADDR                   (0x39a2)
+#define P_HEVC_ANC18_CANVAS_ADDR                   (volatile unsigned int *)((0x39a2  << 2) + 0xff620000)
+#define   HEVC_ANC19_CANVAS_ADDR                   (0x39a3)
+#define P_HEVC_ANC19_CANVAS_ADDR                   (volatile unsigned int *)((0x39a3  << 2) + 0xff620000)
+#define   HEVC_ANC20_CANVAS_ADDR                   (0x39a4)
+#define P_HEVC_ANC20_CANVAS_ADDR                   (volatile unsigned int *)((0x39a4  << 2) + 0xff620000)
+#define   HEVC_ANC21_CANVAS_ADDR                   (0x39a5)
+#define P_HEVC_ANC21_CANVAS_ADDR                   (volatile unsigned int *)((0x39a5  << 2) + 0xff620000)
+#define   HEVC_ANC22_CANVAS_ADDR                   (0x39a6)
+#define P_HEVC_ANC22_CANVAS_ADDR                   (volatile unsigned int *)((0x39a6  << 2) + 0xff620000)
+#define   HEVC_ANC23_CANVAS_ADDR                   (0x39a7)
+#define P_HEVC_ANC23_CANVAS_ADDR                   (volatile unsigned int *)((0x39a7  << 2) + 0xff620000)
+#define   HEVC_ANC24_CANVAS_ADDR                   (0x39a8)
+#define P_HEVC_ANC24_CANVAS_ADDR                   (volatile unsigned int *)((0x39a8  << 2) + 0xff620000)
+#define   HEVC_ANC25_CANVAS_ADDR                   (0x39a9)
+#define P_HEVC_ANC25_CANVAS_ADDR                   (volatile unsigned int *)((0x39a9  << 2) + 0xff620000)
+#define   HEVC_ANC26_CANVAS_ADDR                   (0x39aa)
+#define P_HEVC_ANC26_CANVAS_ADDR                   (volatile unsigned int *)((0x39aa  << 2) + 0xff620000)
+#define   HEVC_ANC27_CANVAS_ADDR                   (0x39ab)
+#define P_HEVC_ANC27_CANVAS_ADDR                   (volatile unsigned int *)((0x39ab  << 2) + 0xff620000)
+#define   HEVC_ANC28_CANVAS_ADDR                   (0x39ac)
+#define P_HEVC_ANC28_CANVAS_ADDR                   (volatile unsigned int *)((0x39ac  << 2) + 0xff620000)
+#define   HEVC_ANC29_CANVAS_ADDR                   (0x39ad)
+#define P_HEVC_ANC29_CANVAS_ADDR                   (volatile unsigned int *)((0x39ad  << 2) + 0xff620000)
+#define   HEVC_ANC30_CANVAS_ADDR                   (0x39ae)
+#define P_HEVC_ANC30_CANVAS_ADDR                   (volatile unsigned int *)((0x39ae  << 2) + 0xff620000)
+#define   HEVC_ANC31_CANVAS_ADDR                   (0x39af)
+#define P_HEVC_ANC31_CANVAS_ADDR                   (volatile unsigned int *)((0x39af  << 2) + 0xff620000)
+#define   HEVC_DBKR_CANVAS_ADDR                    (0x39b0)
+#define P_HEVC_DBKR_CANVAS_ADDR                    (volatile unsigned int *)((0x39b0  << 2) + 0xff620000)
+#define   HEVC_DBKW_CANVAS_ADDR                    (0x39b1)
+#define P_HEVC_DBKW_CANVAS_ADDR                    (volatile unsigned int *)((0x39b1  << 2) + 0xff620000)
+#define   HEVC_REC_CANVAS_ADDR                     (0x39b2)
+#define P_HEVC_REC_CANVAS_ADDR                     (volatile unsigned int *)((0x39b2  << 2) + 0xff620000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define   HEVC_CURR_CANVAS_CTRL                    (0x39b3)
+#define P_HEVC_CURR_CANVAS_CTRL                    (volatile unsigned int *)((0x39b3  << 2) + 0xff620000)
+#define   HEVC_MDEC_PIC_DC_THRESH                  (0x39b8)
+#define P_HEVC_MDEC_PIC_DC_THRESH                  (volatile unsigned int *)((0x39b8  << 2) + 0xff620000)
+#define   HEVC_MDEC_PICR_BUF_STATUS                (0x39b9)
+#define P_HEVC_MDEC_PICR_BUF_STATUS                (volatile unsigned int *)((0x39b9  << 2) + 0xff620000)
+#define   HEVC_MDEC_PICW_BUF_STATUS                (0x39ba)
+#define P_HEVC_MDEC_PICW_BUF_STATUS                (volatile unsigned int *)((0x39ba  << 2) + 0xff620000)
+#define   HEVC_MCW_DBLK_WRRSP_CNT                  (0x39bb)
+#define P_HEVC_MCW_DBLK_WRRSP_CNT                  (volatile unsigned int *)((0x39bb  << 2) + 0xff620000)
+#define   HEVC_MC_MBBOT_WRRSP_CNT                  (0x39bc)
+#define P_HEVC_MC_MBBOT_WRRSP_CNT                  (volatile unsigned int *)((0x39bc  << 2) + 0xff620000)
+#define   HEVC_MDEC_PICW_BUF2_STATUS               (0x39bd)
+#define P_HEVC_MDEC_PICW_BUF2_STATUS               (volatile unsigned int *)((0x39bd  << 2) + 0xff620000)
+#define   HEVC_WRRSP_FIFO_PICW_DBK                 (0x39be)
+#define P_HEVC_WRRSP_FIFO_PICW_DBK                 (volatile unsigned int *)((0x39be  << 2) + 0xff620000)
+#define   HEVC_WRRSP_FIFO_PICW_MC                  (0x39bf)
+#define P_HEVC_WRRSP_FIFO_PICW_MC                  (volatile unsigned int *)((0x39bf  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_0                        (0x39c0)
+#define P_HEVC_AV_SCRATCH_0                        (volatile unsigned int *)((0x39c0  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_1                        (0x39c1)
+#define P_HEVC_AV_SCRATCH_1                        (volatile unsigned int *)((0x39c1  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_2                        (0x39c2)
+#define P_HEVC_AV_SCRATCH_2                        (volatile unsigned int *)((0x39c2  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_3                        (0x39c3)
+#define P_HEVC_AV_SCRATCH_3                        (volatile unsigned int *)((0x39c3  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_4                        (0x39c4)
+#define P_HEVC_AV_SCRATCH_4                        (volatile unsigned int *)((0x39c4  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_5                        (0x39c5)
+#define P_HEVC_AV_SCRATCH_5                        (volatile unsigned int *)((0x39c5  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_6                        (0x39c6)
+#define P_HEVC_AV_SCRATCH_6                        (volatile unsigned int *)((0x39c6  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_7                        (0x39c7)
+#define P_HEVC_AV_SCRATCH_7                        (volatile unsigned int *)((0x39c7  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_8                        (0x39c8)
+#define P_HEVC_AV_SCRATCH_8                        (volatile unsigned int *)((0x39c8  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_9                        (0x39c9)
+#define P_HEVC_AV_SCRATCH_9                        (volatile unsigned int *)((0x39c9  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_A                        (0x39ca)
+#define P_HEVC_AV_SCRATCH_A                        (volatile unsigned int *)((0x39ca  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_B                        (0x39cb)
+#define P_HEVC_AV_SCRATCH_B                        (volatile unsigned int *)((0x39cb  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_C                        (0x39cc)
+#define P_HEVC_AV_SCRATCH_C                        (volatile unsigned int *)((0x39cc  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_D                        (0x39cd)
+#define P_HEVC_AV_SCRATCH_D                        (volatile unsigned int *)((0x39cd  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_E                        (0x39ce)
+#define P_HEVC_AV_SCRATCH_E                        (volatile unsigned int *)((0x39ce  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_F                        (0x39cf)
+#define P_HEVC_AV_SCRATCH_F                        (volatile unsigned int *)((0x39cf  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_G                        (0x39d0)
+#define P_HEVC_AV_SCRATCH_G                        (volatile unsigned int *)((0x39d0  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_H                        (0x39d1)
+#define P_HEVC_AV_SCRATCH_H                        (volatile unsigned int *)((0x39d1  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_I                        (0x39d2)
+#define P_HEVC_AV_SCRATCH_I                        (volatile unsigned int *)((0x39d2  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_J                        (0x39d3)
+#define P_HEVC_AV_SCRATCH_J                        (volatile unsigned int *)((0x39d3  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_K                        (0x39d4)
+#define P_HEVC_AV_SCRATCH_K                        (volatile unsigned int *)((0x39d4  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_L                        (0x39d5)
+#define P_HEVC_AV_SCRATCH_L                        (volatile unsigned int *)((0x39d5  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_M                        (0x39d6)
+#define P_HEVC_AV_SCRATCH_M                        (volatile unsigned int *)((0x39d6  << 2) + 0xff620000)
+#define   HEVC_AV_SCRATCH_N                        (0x39d7)
+#define P_HEVC_AV_SCRATCH_N                        (volatile unsigned int *)((0x39d7  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define   HEVC_WRRSP_CO_MB                         (0x39d8)
+#define P_HEVC_WRRSP_CO_MB                         (volatile unsigned int *)((0x39d8  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define   HEVC_WRRSP_DCAC                          (0x39d9)
+#define P_HEVC_WRRSP_DCAC                          (volatile unsigned int *)((0x39d9  << 2) + 0xff620000)
+// bit[11:0] wrrsp_count_vld
+#define   HEVC_WRRSP_VLD                           (0x39da)
+#define P_HEVC_WRRSP_VLD                           (volatile unsigned int *)((0x39da  << 2) + 0xff620000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define   HEVC_MDEC_DOUBLEW_CFG0                   (0x39db)
+#define P_HEVC_MDEC_DOUBLEW_CFG0                   (volatile unsigned int *)((0x39db  << 2) + 0xff620000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write -
+// doublew_cfg1[17];    //       Reverse to original version -
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define   HEVC_MDEC_DOUBLEW_CFG1                   (0x39dc)
+#define P_HEVC_MDEC_DOUBLEW_CFG1                   (volatile unsigned int *)((0x39dc  << 2) + 0xff620000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define   HEVC_MDEC_DOUBLEW_CFG2                   (0x39dd)
+#define P_HEVC_MDEC_DOUBLEW_CFG2                   (volatile unsigned int *)((0x39dd  << 2) + 0xff620000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma -
+#define   HEVC_MDEC_DOUBLEW_CFG3                   (0x39de)
+#define P_HEVC_MDEC_DOUBLEW_CFG3                   (volatile unsigned int *)((0x39de  << 2) + 0xff620000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma -
+#define   HEVC_MDEC_DOUBLEW_CFG4                   (0x39df)
+#define P_HEVC_MDEC_DOUBLEW_CFG4                   (volatile unsigned int *)((0x39df  << 2) + 0xff620000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma -
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma -
+#define   HEVC_MDEC_DOUBLEW_CFG5                   (0x39e0)
+#define P_HEVC_MDEC_DOUBLEW_CFG5                   (volatile unsigned int *)((0x39e0  << 2) + 0xff620000)
+// doublew_cfg6: reserved
+#define   HEVC_MDEC_DOUBLEW_CFG6                   (0x39e1)
+#define P_HEVC_MDEC_DOUBLEW_CFG6                   (volatile unsigned int *)((0x39e1  << 2) + 0xff620000)
+// doublew_cfg7: reserved
+#define   HEVC_MDEC_DOUBLEW_CFG7                   (0x39e2)
+#define P_HEVC_MDEC_DOUBLEW_CFG7                   (volatile unsigned int *)((0x39e2  << 2) + 0xff620000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define   HEVC_MDEC_DOUBLEW_STATUS                 (0x39e3)
+#define P_HEVC_MDEC_DOUBLEW_STATUS                 (volatile unsigned int *)((0x39e3  << 2) + 0xff620000)
+#define   HEVC_MDEC_EXTIF_CFG0                     (0x39e4)
+#define P_HEVC_MDEC_EXTIF_CFG0                     (volatile unsigned int *)((0x39e4  << 2) + 0xff620000)
+#define   HEVC_MDEC_EXTIF_CFG1                     (0x39e5)
+#define P_HEVC_MDEC_EXTIF_CFG1                     (volatile unsigned int *)((0x39e5  << 2) + 0xff620000)
+#define   HEVC_MDEC_EXTIF_STS0                     (0x39e6)
+#define P_HEVC_MDEC_EXTIF_STS0                     (volatile unsigned int *)((0x39e6  << 2) + 0xff620000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    //`define MC_RESET	    16'h0002
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f
+//========================================================================
+#define   HEVC_DBLK_RST                            (0x3950)
+#define P_HEVC_DBLK_RST                            (volatile unsigned int *)((0x3950  << 2) + 0xff620000)
+#define   HEVC_DBLK_CTRL                           (0x3951)
+#define P_HEVC_DBLK_CTRL                           (volatile unsigned int *)((0x3951  << 2) + 0xff620000)
+#define   HEVC_DBLK_MB_WID_HEIGHT                  (0x3952)
+#define P_HEVC_DBLK_MB_WID_HEIGHT                  (volatile unsigned int *)((0x3952  << 2) + 0xff620000)
+#define   HEVC_DBLK_STATUS                         (0x3953)
+#define P_HEVC_DBLK_STATUS                         (volatile unsigned int *)((0x3953  << 2) + 0xff620000)
+#define   HEVC_DBLK_CMD_CTRL                       (0x3954)
+#define P_HEVC_DBLK_CMD_CTRL                       (volatile unsigned int *)((0x3954  << 2) + 0xff620000)
+#define   HEVC_DBLK_MB_XY                          (0x3955)
+#define P_HEVC_DBLK_MB_XY                          (volatile unsigned int *)((0x3955  << 2) + 0xff620000)
+#define   HEVC_DBLK_QP                             (0x3956)
+#define P_HEVC_DBLK_QP                             (volatile unsigned int *)((0x3956  << 2) + 0xff620000)
+#define   HEVC_DBLK_Y_BHFILT                       (0x3957)
+#define P_HEVC_DBLK_Y_BHFILT                       (volatile unsigned int *)((0x3957  << 2) + 0xff620000)
+#define   HEVC_DBLK_Y_BHFILT_HIGH                  (0x3958)
+#define P_HEVC_DBLK_Y_BHFILT_HIGH                  (volatile unsigned int *)((0x3958  << 2) + 0xff620000)
+#define   HEVC_DBLK_Y_BVFILT                       (0x3959)
+#define P_HEVC_DBLK_Y_BVFILT                       (volatile unsigned int *)((0x3959  << 2) + 0xff620000)
+#define   HEVC_DBLK_CB_BFILT                       (0x395a)
+#define P_HEVC_DBLK_CB_BFILT                       (volatile unsigned int *)((0x395a  << 2) + 0xff620000)
+#define   HEVC_DBLK_CR_BFILT                       (0x395b)
+#define P_HEVC_DBLK_CR_BFILT                       (volatile unsigned int *)((0x395b  << 2) + 0xff620000)
+#define   HEVC_DBLK_Y_HFILT                        (0x395c)
+#define P_HEVC_DBLK_Y_HFILT                        (volatile unsigned int *)((0x395c  << 2) + 0xff620000)
+#define   HEVC_DBLK_Y_HFILT_HIGH                   (0x395d)
+#define P_HEVC_DBLK_Y_HFILT_HIGH                   (volatile unsigned int *)((0x395d  << 2) + 0xff620000)
+#define   HEVC_DBLK_Y_VFILT                        (0x395e)
+#define P_HEVC_DBLK_Y_VFILT                        (volatile unsigned int *)((0x395e  << 2) + 0xff620000)
+#define   HEVC_DBLK_CB_FILT                        (0x395f)
+#define P_HEVC_DBLK_CB_FILT                        (volatile unsigned int *)((0x395f  << 2) + 0xff620000)
+#define   HEVC_DBLK_CR_FILT                        (0x3960)
+#define P_HEVC_DBLK_CR_FILT                        (volatile unsigned int *)((0x3960  << 2) + 0xff620000)
+#define   HEVC_DBLK_BETAX_QP_SEL                   (0x3961)
+#define P_HEVC_DBLK_BETAX_QP_SEL                   (volatile unsigned int *)((0x3961  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL0                     (0x3962)
+#define P_HEVC_DBLK_CLIP_CTRL0                     (volatile unsigned int *)((0x3962  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL1                     (0x3963)
+#define P_HEVC_DBLK_CLIP_CTRL1                     (volatile unsigned int *)((0x3963  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL2                     (0x3964)
+#define P_HEVC_DBLK_CLIP_CTRL2                     (volatile unsigned int *)((0x3964  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL3                     (0x3965)
+#define P_HEVC_DBLK_CLIP_CTRL3                     (volatile unsigned int *)((0x3965  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL4                     (0x3966)
+#define P_HEVC_DBLK_CLIP_CTRL4                     (volatile unsigned int *)((0x3966  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL5                     (0x3967)
+#define P_HEVC_DBLK_CLIP_CTRL5                     (volatile unsigned int *)((0x3967  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL6                     (0x3968)
+#define P_HEVC_DBLK_CLIP_CTRL6                     (volatile unsigned int *)((0x3968  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL7                     (0x3969)
+#define P_HEVC_DBLK_CLIP_CTRL7                     (volatile unsigned int *)((0x3969  << 2) + 0xff620000)
+#define   HEVC_DBLK_CLIP_CTRL8                     (0x396a)
+#define P_HEVC_DBLK_CLIP_CTRL8                     (volatile unsigned int *)((0x396a  << 2) + 0xff620000)
+#define   HEVC_DBLK_STATUS1                        (0x396b)
+#define P_HEVC_DBLK_STATUS1                        (volatile unsigned int *)((0x396b  << 2) + 0xff620000)
+#define   HEVC_DBLK_GCLK_FREE                      (0x396c)
+#define P_HEVC_DBLK_GCLK_FREE                      (volatile unsigned int *)((0x396c  << 2) + 0xff620000)
+#define   HEVC_DBLK_GCLK_OFF                       (0x396d)
+#define P_HEVC_DBLK_GCLK_OFF                       (volatile unsigned int *)((0x396d  << 2) + 0xff620000)
+#define   HEVC_DBLK_AVSFLAGS                       (0x396e)
+#define P_HEVC_DBLK_AVSFLAGS                       (volatile unsigned int *)((0x396e  << 2) + 0xff620000)
+// bit 15:0
+#define   HEVC_DBLK_CBPY                           (0x3970)
+#define P_HEVC_DBLK_CBPY                           (volatile unsigned int *)((0x3970  << 2) + 0xff620000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define   HEVC_DBLK_CBPY_ADJ                       (0x3971)
+#define P_HEVC_DBLK_CBPY_ADJ                       (volatile unsigned int *)((0x3971  << 2) + 0xff620000)
+// bit 7:0 -- deblk_cbpc
+#define   HEVC_DBLK_CBPC                           (0x3972)
+#define P_HEVC_DBLK_CBPC                           (volatile unsigned int *)((0x3972  << 2) + 0xff620000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define   HEVC_DBLK_CBPC_ADJ                       (0x3973)
+#define P_HEVC_DBLK_CBPC_ADJ                       (volatile unsigned int *)((0x3973  << 2) + 0xff620000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0}
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0}
+#define   HEVC_DBLK_VHMVD                          (0x3974)
+#define P_HEVC_DBLK_VHMVD                          (volatile unsigned int *)((0x3974  << 2) + 0xff620000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s
+#define   HEVC_DBLK_STRONG                         (0x3975)
+#define P_HEVC_DBLK_STRONG                         (volatile unsigned int *)((0x3975  << 2) + 0xff620000)
+// bit 14:10 -- PQUANT
+// bit 9:5 -- left_PQUANT
+// bit 4:0 -- top_PQUANT
+#define   HEVC_DBLK_RV8_QUANT                      (0x3976)
+#define P_HEVC_DBLK_RV8_QUANT                      (volatile unsigned int *)((0x3976  << 2) + 0xff620000)
+#define   HEVC_DBLK_CBUS_HCMD2                     (0x3977)
+#define P_HEVC_DBLK_CBUS_HCMD2                     (volatile unsigned int *)((0x3977  << 2) + 0xff620000)
+#define   HEVC_DBLK_CBUS_HCMD1                     (0x3978)
+#define P_HEVC_DBLK_CBUS_HCMD1                     (volatile unsigned int *)((0x3978  << 2) + 0xff620000)
+#define   HEVC_DBLK_CBUS_HCMD0                     (0x3979)
+#define P_HEVC_DBLK_CBUS_HCMD0                     (volatile unsigned int *)((0x3979  << 2) + 0xff620000)
+#define   HEVC_DBLK_VLD_HCMD2                      (0x397a)
+#define P_HEVC_DBLK_VLD_HCMD2                      (volatile unsigned int *)((0x397a  << 2) + 0xff620000)
+#define   HEVC_DBLK_VLD_HCMD1                      (0x397b)
+#define P_HEVC_DBLK_VLD_HCMD1                      (volatile unsigned int *)((0x397b  << 2) + 0xff620000)
+#define   HEVC_DBLK_VLD_HCMD0                      (0x397c)
+#define P_HEVC_DBLK_VLD_HCMD0                      (volatile unsigned int *)((0x397c  << 2) + 0xff620000)
+#define   HEVC_DBLK_OST_YBASE                      (0x397d)
+#define P_HEVC_DBLK_OST_YBASE                      (volatile unsigned int *)((0x397d  << 2) + 0xff620000)
+#define   HEVC_DBLK_OST_CBCRDIFF                   (0x397e)
+#define P_HEVC_DBLK_OST_CBCRDIFF                   (volatile unsigned int *)((0x397e  << 2) + 0xff620000)
+//13:8 dblk thread ID and token
+//5:0  dblk prearbitor burst num
+#define   HEVC_DBLK_CTRL1                          (0x397f)
+#define P_HEVC_DBLK_CTRL1                          (volatile unsigned int *)((0x397f  << 2) + 0xff620000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define   HEVC_MCRCC_CTL1                          (0x3980)
+#define P_HEVC_MCRCC_CTL1                          (volatile unsigned int *)((0x3980  << 2) + 0xff620000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define   HEVC_MCRCC_CTL2                          (0x3981)
+#define P_HEVC_MCRCC_CTL2                          (volatile unsigned int *)((0x3981  << 2) + 0xff620000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define   HEVC_MCRCC_CTL3                          (0x3982)
+#define P_HEVC_MCRCC_CTL3                          (volatile unsigned int *)((0x3982  << 2) + 0xff620000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define   HEVC_GCLK_EN                             (0x3983)
+#define P_HEVC_GCLK_EN                             (volatile unsigned int *)((0x3983  << 2) + 0xff620000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define   HEVC_MDEC_SW_RESET                       (0x3984)
+#define P_HEVC_MDEC_SW_RESET                       (volatile unsigned int *)((0x3984  << 2) + 0xff620000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define   HCODEC_VLD_STATUS_CTRL                   (0x1c00)
+#define P_HCODEC_VLD_STATUS_CTRL                   (volatile unsigned int *)((0x1c00  << 2) + 0xff620000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define   HCODEC_MPEG1_2_REG                       (0x1c01)
+#define P_HCODEC_MPEG1_2_REG                       (volatile unsigned int *)((0x1c01  << 2) + 0xff620000)
+#define   HCODEC_F_CODE_REG                        (0x1c02)
+#define P_HCODEC_F_CODE_REG                        (volatile unsigned int *)((0x1c02  << 2) + 0xff620000)
+#define   HCODEC_PIC_HEAD_INFO                     (0x1c03)
+#define P_HCODEC_PIC_HEAD_INFO                     (volatile unsigned int *)((0x1c03  << 2) + 0xff620000)
+#define   HCODEC_SLICE_VER_POS_PIC_TYPE            (0x1c04)
+#define P_HCODEC_SLICE_VER_POS_PIC_TYPE            (volatile unsigned int *)((0x1c04  << 2) + 0xff620000)
+#define   HCODEC_QP_VALUE_REG                      (0x1c05)
+#define P_HCODEC_QP_VALUE_REG                      (volatile unsigned int *)((0x1c05  << 2) + 0xff620000)
+#define   HCODEC_MBA_INC                           (0x1c06)
+#define P_HCODEC_MBA_INC                           (volatile unsigned int *)((0x1c06  << 2) + 0xff620000)
+#define   HCODEC_MB_MOTION_MODE                    (0x1c07)
+#define P_HCODEC_MB_MOTION_MODE                    (volatile unsigned int *)((0x1c07  << 2) + 0xff620000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en
+// bit 5:0 -- vld_power_ctl
+#define   HCODEC_POWER_CTL_VLD                     (0x1c08)
+#define P_HCODEC_POWER_CTL_VLD                     (volatile unsigned int *)((0x1c08  << 2) + 0xff620000)
+#define   HCODEC_MB_WIDTH                          (0x1c09)
+#define P_HCODEC_MB_WIDTH                          (volatile unsigned int *)((0x1c09  << 2) + 0xff620000)
+#define   HCODEC_SLICE_QP                          (0x1c0a)
+#define P_HCODEC_SLICE_QP                          (volatile unsigned int *)((0x1c0a  << 2) + 0xff620000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define   HCODEC_PRE_START_CODE                    (0x1c0b)
+#define P_HCODEC_PRE_START_CODE                    (volatile unsigned int *)((0x1c0b  << 2) + 0xff620000)
+#define   HCODEC_SLICE_START_BYTE_01               (0x1c0c)
+#define P_HCODEC_SLICE_START_BYTE_01               (volatile unsigned int *)((0x1c0c  << 2) + 0xff620000)
+#define   HCODEC_SLICE_START_BYTE_23               (0x1c0d)
+#define P_HCODEC_SLICE_START_BYTE_23               (volatile unsigned int *)((0x1c0d  << 2) + 0xff620000)
+#define   HCODEC_RESYNC_MARKER_LENGTH              (0x1c0e)
+#define P_HCODEC_RESYNC_MARKER_LENGTH              (volatile unsigned int *)((0x1c0e  << 2) + 0xff620000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define   HCODEC_DECODER_BUFFER_INFO               (0x1c0f)
+#define P_HCODEC_DECODER_BUFFER_INFO               (volatile unsigned int *)((0x1c0f  << 2) + 0xff620000)
+#define   HCODEC_FST_FOR_MV_X                      (0x1c10)
+#define P_HCODEC_FST_FOR_MV_X                      (volatile unsigned int *)((0x1c10  << 2) + 0xff620000)
+#define   HCODEC_FST_FOR_MV_Y                      (0x1c11)
+#define P_HCODEC_FST_FOR_MV_Y                      (volatile unsigned int *)((0x1c11  << 2) + 0xff620000)
+#define   HCODEC_SCD_FOR_MV_X                      (0x1c12)
+#define P_HCODEC_SCD_FOR_MV_X                      (volatile unsigned int *)((0x1c12  << 2) + 0xff620000)
+#define   HCODEC_SCD_FOR_MV_Y                      (0x1c13)
+#define P_HCODEC_SCD_FOR_MV_Y                      (volatile unsigned int *)((0x1c13  << 2) + 0xff620000)
+#define   HCODEC_FST_BAK_MV_X                      (0x1c14)
+#define P_HCODEC_FST_BAK_MV_X                      (volatile unsigned int *)((0x1c14  << 2) + 0xff620000)
+#define   HCODEC_FST_BAK_MV_Y                      (0x1c15)
+#define P_HCODEC_FST_BAK_MV_Y                      (volatile unsigned int *)((0x1c15  << 2) + 0xff620000)
+#define   HCODEC_SCD_BAK_MV_X                      (0x1c16)
+#define P_HCODEC_SCD_BAK_MV_X                      (volatile unsigned int *)((0x1c16  << 2) + 0xff620000)
+#define   HCODEC_SCD_BAK_MV_Y                      (0x1c17)
+#define P_HCODEC_SCD_BAK_MV_Y                      (volatile unsigned int *)((0x1c17  << 2) + 0xff620000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- disable_new_stcode_search_fix // From GXM
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag
+#define   HCODEC_VLD_DECODE_CONTROL                (0x1c18)
+#define P_HCODEC_VLD_DECODE_CONTROL                (volatile unsigned int *)((0x1c18  << 2) + 0xff620000)
+#define   HCODEC_VLD_REVERVED_19                   (0x1c19)
+#define P_HCODEC_VLD_REVERVED_19                   (volatile unsigned int *)((0x1c19  << 2) + 0xff620000)
+#define   HCODEC_VIFF_BIT_CNT                      (0x1c1a)
+#define P_HCODEC_VIFF_BIT_CNT                      (volatile unsigned int *)((0x1c1a  << 2) + 0xff620000)
+#define   HCODEC_BYTE_ALIGN_PEAK_HI                (0x1c1b)
+#define P_HCODEC_BYTE_ALIGN_PEAK_HI                (volatile unsigned int *)((0x1c1b  << 2) + 0xff620000)
+#define   HCODEC_BYTE_ALIGN_PEAK_LO                (0x1c1c)
+#define P_HCODEC_BYTE_ALIGN_PEAK_LO                (volatile unsigned int *)((0x1c1c  << 2) + 0xff620000)
+#define   HCODEC_NEXT_ALIGN_PEAK                   (0x1c1d)
+#define P_HCODEC_NEXT_ALIGN_PEAK                   (volatile unsigned int *)((0x1c1d  << 2) + 0xff620000)
+// bit 31    : byte_aligned_zero_23_from_org // From GXM
+// bit 30    : force_shift_out_drop_flag_zero // From GXM
+// bit 29    : en_st_protect_from_org // From GXM
+// bit 28    : enable_halt_decode_start_voff
+// bit 27    : disable_C_pred_check
+// bit 26    : disable_I4_pred_check
+// bit 25    : disable_I16_pred_check
+// bit 24    : check_avs_1st_drop
+// bit 23    : enable_cabac_protect // From GXM
+// bit 22    : enable_avs_drop_more
+// bit 21    : reset_avs_drop_ptr
+// bit 20    : reset_cabac_use_next_at_end_req
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : disable_mv_cal_begin_only
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define   HCODEC_VC1_CONTROL_REG                   (0x1c1e)
+#define P_HCODEC_VC1_CONTROL_REG                   (volatile unsigned int *)((0x1c1e  << 2) + 0xff620000)
+#define   HCODEC_PMV1_X                            (0x1c20)
+#define P_HCODEC_PMV1_X                            (volatile unsigned int *)((0x1c20  << 2) + 0xff620000)
+#define   HCODEC_PMV1_Y                            (0x1c21)
+#define P_HCODEC_PMV1_Y                            (volatile unsigned int *)((0x1c21  << 2) + 0xff620000)
+#define   HCODEC_PMV2_X                            (0x1c22)
+#define P_HCODEC_PMV2_X                            (volatile unsigned int *)((0x1c22  << 2) + 0xff620000)
+#define   HCODEC_PMV2_Y                            (0x1c23)
+#define P_HCODEC_PMV2_Y                            (volatile unsigned int *)((0x1c23  << 2) + 0xff620000)
+#define   HCODEC_PMV3_X                            (0x1c24)
+#define P_HCODEC_PMV3_X                            (volatile unsigned int *)((0x1c24  << 2) + 0xff620000)
+#define   HCODEC_PMV3_Y                            (0x1c25)
+#define P_HCODEC_PMV3_Y                            (volatile unsigned int *)((0x1c25  << 2) + 0xff620000)
+#define   HCODEC_PMV4_X                            (0x1c26)
+#define P_HCODEC_PMV4_X                            (volatile unsigned int *)((0x1c26  << 2) + 0xff620000)
+#define   HCODEC_PMV4_Y                            (0x1c27)
+#define P_HCODEC_PMV4_Y                            (volatile unsigned int *)((0x1c27  << 2) + 0xff620000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define   HCODEC_M4_TABLE_SELECT                   (0x1c28)
+#define P_HCODEC_M4_TABLE_SELECT                   (volatile unsigned int *)((0x1c28  << 2) + 0xff620000)
+#define   HCODEC_M4_CONTROL_REG                    (0x1c29)
+#define P_HCODEC_M4_CONTROL_REG                    (volatile unsigned int *)((0x1c29  << 2) + 0xff620000)
+#define   HCODEC_BLOCK_NUM                         (0x1c2a)
+#define P_HCODEC_BLOCK_NUM                         (volatile unsigned int *)((0x1c2a  << 2) + 0xff620000)
+#define   HCODEC_PATTERN_CODE                      (0x1c2b)
+#define P_HCODEC_PATTERN_CODE                      (volatile unsigned int *)((0x1c2b  << 2) + 0xff620000)
+#define   HCODEC_MB_INFO                           (0x1c2c)
+#define P_HCODEC_MB_INFO                           (volatile unsigned int *)((0x1c2c  << 2) + 0xff620000)
+#define   HCODEC_VLD_DC_PRED                       (0x1c2d)
+#define P_HCODEC_VLD_DC_PRED                       (volatile unsigned int *)((0x1c2d  << 2) + 0xff620000)
+#define   HCODEC_VLD_ERROR_MASK                    (0x1c2e)
+#define P_HCODEC_VLD_ERROR_MASK                    (volatile unsigned int *)((0x1c2e  << 2) + 0xff620000)
+#define   HCODEC_VLD_DC_PRED_C                     (0x1c2f)
+#define P_HCODEC_VLD_DC_PRED_C                     (volatile unsigned int *)((0x1c2f  << 2) + 0xff620000)
+#define   HCODEC_LAST_SLICE_MV_ADDR                (0x1c30)
+#define P_HCODEC_LAST_SLICE_MV_ADDR                (volatile unsigned int *)((0x1c30  << 2) + 0xff620000)
+#define   HCODEC_LAST_MVX                          (0x1c31)
+#define P_HCODEC_LAST_MVX                          (volatile unsigned int *)((0x1c31  << 2) + 0xff620000)
+#define   HCODEC_LAST_MVY                          (0x1c32)
+#define P_HCODEC_LAST_MVY                          (volatile unsigned int *)((0x1c32  << 2) + 0xff620000)
+#define   HCODEC_VLD_C38                           (0x1c38)
+#define P_HCODEC_VLD_C38                           (volatile unsigned int *)((0x1c38  << 2) + 0xff620000)
+#define   HCODEC_VLD_C39                           (0x1c39)
+#define P_HCODEC_VLD_C39                           (volatile unsigned int *)((0x1c39  << 2) + 0xff620000)
+#define   HCODEC_VLD_STATUS                        (0x1c3a)
+#define P_HCODEC_VLD_STATUS                        (volatile unsigned int *)((0x1c3a  << 2) + 0xff620000)
+#define   HCODEC_VLD_SHIFT_STATUS                  (0x1c3b)
+#define P_HCODEC_VLD_SHIFT_STATUS                  (volatile unsigned int *)((0x1c3b  << 2) + 0xff620000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define   HCODEC_VOFF_STATUS                       (0x1c3c)
+#define P_HCODEC_VOFF_STATUS                       (volatile unsigned int *)((0x1c3c  << 2) + 0xff620000)
+#define   HCODEC_VLD_C3D                           (0x1c3d)
+#define P_HCODEC_VLD_C3D                           (volatile unsigned int *)((0x1c3d  << 2) + 0xff620000)
+#define   HCODEC_VLD_DBG_INDEX                     (0x1c3e)
+#define P_HCODEC_VLD_DBG_INDEX                     (volatile unsigned int *)((0x1c3e  << 2) + 0xff620000)
+// vld_buff_info -- (index == 0)
+// Bit11]    halt_decode_start_voff
+// Bit10]    C_pred_error
+// Bit[9]    I4_pred_error
+// Bit[8]    I16_pred_error
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1)
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2)
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3)
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4)
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define   HCODEC_VLD_DBG_DATA                      (0x1c3f)
+#define P_HCODEC_VLD_DBG_DATA                      (volatile unsigned int *)((0x1c3f  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   HCODEC_VLD_MEM_VIFIFO_START_PTR          (0x1c40)
+#define P_HCODEC_VLD_MEM_VIFIFO_START_PTR          (volatile unsigned int *)((0x1c40  << 2) + 0xff620000)
+// The current pointer points so some location between the START and END
+// pointers.  The current pointer is a BYTE pointer.  That is, you can
+// point to any BYTE address within the START/END range
+#define   HCODEC_VLD_MEM_VIFIFO_CURR_PTR           (0x1c41)
+#define P_HCODEC_VLD_MEM_VIFIFO_CURR_PTR           (volatile unsigned int *)((0x1c41  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_VIFIFO_END_PTR            (0x1c42)
+#define P_HCODEC_VLD_MEM_VIFIFO_END_PTR            (volatile unsigned int *)((0x1c42  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_VIFIFO_BYTES_AVAIL        (0x1c43)
+#define P_HCODEC_VLD_MEM_VIFIFO_BYTES_AVAIL        (volatile unsigned int *)((0x1c43  << 2) + 0xff620000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0]
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0]
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define   HCODEC_VLD_MEM_VIFIFO_CONTROL            (0x1c44)
+#define P_HCODEC_VLD_MEM_VIFIFO_CONTROL            (volatile unsigned int *)((0x1c44  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define   HCODEC_VLD_MEM_VIFIFO_WP                 (0x1c45)
+#define P_HCODEC_VLD_MEM_VIFIFO_WP                 (volatile unsigned int *)((0x1c45  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_VIFIFO_RP                 (0x1c46)
+#define P_HCODEC_VLD_MEM_VIFIFO_RP                 (volatile unsigned int *)((0x1c46  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_VIFIFO_LEVEL              (0x1c47)
+#define P_HCODEC_VLD_MEM_VIFIFO_LEVEL              (volatile unsigned int *)((0x1c47  << 2) + 0xff620000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   HCODEC_VLD_MEM_VIFIFO_BUF_CNTL           (0x1c48)
+#define P_HCODEC_VLD_MEM_VIFIFO_BUF_CNTL           (volatile unsigned int *)((0x1c48  << 2) + 0xff620000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   HCODEC_VLD_TIME_STAMP_CNTL               (0x1c49)
+#define P_HCODEC_VLD_TIME_STAMP_CNTL               (volatile unsigned int *)((0x1c49  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   HCODEC_VLD_TIME_STAMP_SYNC_0             (0x1c4a)
+#define P_HCODEC_VLD_TIME_STAMP_SYNC_0             (volatile unsigned int *)((0x1c4a  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   HCODEC_VLD_TIME_STAMP_SYNC_1             (0x1c4b)
+#define P_HCODEC_VLD_TIME_STAMP_SYNC_1             (volatile unsigned int *)((0x1c4b  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_0
+#define   HCODEC_VLD_TIME_STAMP_0                  (0x1c4c)
+#define P_HCODEC_VLD_TIME_STAMP_0                  (volatile unsigned int *)((0x1c4c  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_1
+#define   HCODEC_VLD_TIME_STAMP_1                  (0x1c4d)
+#define P_HCODEC_VLD_TIME_STAMP_1                  (volatile unsigned int *)((0x1c4d  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_2
+#define   HCODEC_VLD_TIME_STAMP_2                  (0x1c4e)
+#define P_HCODEC_VLD_TIME_STAMP_2                  (volatile unsigned int *)((0x1c4e  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_3
+#define   HCODEC_VLD_TIME_STAMP_3                  (0x1c4f)
+#define P_HCODEC_VLD_TIME_STAMP_3                  (volatile unsigned int *)((0x1c4f  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   HCODEC_VLD_TIME_STAMP_LENGTH             (0x1c50)
+#define P_HCODEC_VLD_TIME_STAMP_LENGTH             (volatile unsigned int *)((0x1c50  << 2) + 0xff620000)
+// bit 15:0 vififo_rd_count
+#define   HCODEC_VLD_MEM_VIFIFO_WRAP_COUNT         (0x1c51)
+#define P_HCODEC_VLD_MEM_VIFIFO_WRAP_COUNT         (volatile unsigned int *)((0x1c51  << 2) + 0xff620000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   HCODEC_VLD_MEM_VIFIFO_MEM_CTL            (0x1c52)
+#define P_HCODEC_VLD_MEM_VIFIFO_MEM_CTL            (volatile unsigned int *)((0x1c52  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_VBUF_RD_PTR               (0x1c53)
+#define P_HCODEC_VLD_MEM_VBUF_RD_PTR               (volatile unsigned int *)((0x1c53  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_VBUF2_RD_PTR              (0x1c54)
+#define P_HCODEC_VLD_MEM_VBUF2_RD_PTR              (volatile unsigned int *)((0x1c54  << 2) + 0xff620000)
+#define   HCODEC_VLD_MEM_SWAP_ADDR                 (0x1c55)
+#define P_HCODEC_VLD_MEM_SWAP_ADDR                 (volatile unsigned int *)((0x1c55  << 2) + 0xff620000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define   HCODEC_VLD_MEM_SWAP_CTL                  (0x1c56)
+#define P_HCODEC_VLD_MEM_SWAP_CTL                  (volatile unsigned int *)((0x1c56  << 2) + 0xff620000)
+//
+// Closing file:  vld_regs.h
+//
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define   VDEC2_VLD_STATUS_CTRL                    (0x2c00)
+#define P_VDEC2_VLD_STATUS_CTRL                    (volatile unsigned int *)((0x2c00  << 2) + 0xff620000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define   VDEC2_MPEG1_2_REG                        (0x2c01)
+#define P_VDEC2_MPEG1_2_REG                        (volatile unsigned int *)((0x2c01  << 2) + 0xff620000)
+#define   VDEC2_F_CODE_REG                         (0x2c02)
+#define P_VDEC2_F_CODE_REG                         (volatile unsigned int *)((0x2c02  << 2) + 0xff620000)
+#define   VDEC2_PIC_HEAD_INFO                      (0x2c03)
+#define P_VDEC2_PIC_HEAD_INFO                      (volatile unsigned int *)((0x2c03  << 2) + 0xff620000)
+#define   VDEC2_SLICE_VER_POS_PIC_TYPE             (0x2c04)
+#define P_VDEC2_SLICE_VER_POS_PIC_TYPE             (volatile unsigned int *)((0x2c04  << 2) + 0xff620000)
+#define   VDEC2_QP_VALUE_REG                       (0x2c05)
+#define P_VDEC2_QP_VALUE_REG                       (volatile unsigned int *)((0x2c05  << 2) + 0xff620000)
+#define   VDEC2_MBA_INC                            (0x2c06)
+#define P_VDEC2_MBA_INC                            (volatile unsigned int *)((0x2c06  << 2) + 0xff620000)
+#define   VDEC2_MB_MOTION_MODE                     (0x2c07)
+#define P_VDEC2_MB_MOTION_MODE                     (volatile unsigned int *)((0x2c07  << 2) + 0xff620000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en
+// bit 5:0 -- vld_power_ctl
+#define   VDEC2_POWER_CTL_VLD                      (0x2c08)
+#define P_VDEC2_POWER_CTL_VLD                      (volatile unsigned int *)((0x2c08  << 2) + 0xff620000)
+#define   VDEC2_MB_WIDTH                           (0x2c09)
+#define P_VDEC2_MB_WIDTH                           (volatile unsigned int *)((0x2c09  << 2) + 0xff620000)
+#define   VDEC2_SLICE_QP                           (0x2c0a)
+#define P_VDEC2_SLICE_QP                           (volatile unsigned int *)((0x2c0a  << 2) + 0xff620000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define   VDEC2_PRE_START_CODE                     (0x2c0b)
+#define P_VDEC2_PRE_START_CODE                     (volatile unsigned int *)((0x2c0b  << 2) + 0xff620000)
+#define   VDEC2_SLICE_START_BYTE_01                (0x2c0c)
+#define P_VDEC2_SLICE_START_BYTE_01                (volatile unsigned int *)((0x2c0c  << 2) + 0xff620000)
+#define   VDEC2_SLICE_START_BYTE_23                (0x2c0d)
+#define P_VDEC2_SLICE_START_BYTE_23                (volatile unsigned int *)((0x2c0d  << 2) + 0xff620000)
+#define   VDEC2_RESYNC_MARKER_LENGTH               (0x2c0e)
+#define P_VDEC2_RESYNC_MARKER_LENGTH               (volatile unsigned int *)((0x2c0e  << 2) + 0xff620000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define   VDEC2_DECODER_BUFFER_INFO                (0x2c0f)
+#define P_VDEC2_DECODER_BUFFER_INFO                (volatile unsigned int *)((0x2c0f  << 2) + 0xff620000)
+#define   VDEC2_FST_FOR_MV_X                       (0x2c10)
+#define P_VDEC2_FST_FOR_MV_X                       (volatile unsigned int *)((0x2c10  << 2) + 0xff620000)
+#define   VDEC2_FST_FOR_MV_Y                       (0x2c11)
+#define P_VDEC2_FST_FOR_MV_Y                       (volatile unsigned int *)((0x2c11  << 2) + 0xff620000)
+#define   VDEC2_SCD_FOR_MV_X                       (0x2c12)
+#define P_VDEC2_SCD_FOR_MV_X                       (volatile unsigned int *)((0x2c12  << 2) + 0xff620000)
+#define   VDEC2_SCD_FOR_MV_Y                       (0x2c13)
+#define P_VDEC2_SCD_FOR_MV_Y                       (volatile unsigned int *)((0x2c13  << 2) + 0xff620000)
+#define   VDEC2_FST_BAK_MV_X                       (0x2c14)
+#define P_VDEC2_FST_BAK_MV_X                       (volatile unsigned int *)((0x2c14  << 2) + 0xff620000)
+#define   VDEC2_FST_BAK_MV_Y                       (0x2c15)
+#define P_VDEC2_FST_BAK_MV_Y                       (volatile unsigned int *)((0x2c15  << 2) + 0xff620000)
+#define   VDEC2_SCD_BAK_MV_X                       (0x2c16)
+#define P_VDEC2_SCD_BAK_MV_X                       (volatile unsigned int *)((0x2c16  << 2) + 0xff620000)
+#define   VDEC2_SCD_BAK_MV_Y                       (0x2c17)
+#define P_VDEC2_SCD_BAK_MV_Y                       (volatile unsigned int *)((0x2c17  << 2) + 0xff620000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- disable_new_stcode_search_fix // From GXM
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag
+#define   VDEC2_VLD_DECODE_CONTROL                 (0x2c18)
+#define P_VDEC2_VLD_DECODE_CONTROL                 (volatile unsigned int *)((0x2c18  << 2) + 0xff620000)
+#define   VDEC2_VLD_REVERVED_19                    (0x2c19)
+#define P_VDEC2_VLD_REVERVED_19                    (volatile unsigned int *)((0x2c19  << 2) + 0xff620000)
+#define   VDEC2_VIFF_BIT_CNT                       (0x2c1a)
+#define P_VDEC2_VIFF_BIT_CNT                       (volatile unsigned int *)((0x2c1a  << 2) + 0xff620000)
+#define   VDEC2_BYTE_ALIGN_PEAK_HI                 (0x2c1b)
+#define P_VDEC2_BYTE_ALIGN_PEAK_HI                 (volatile unsigned int *)((0x2c1b  << 2) + 0xff620000)
+#define   VDEC2_BYTE_ALIGN_PEAK_LO                 (0x2c1c)
+#define P_VDEC2_BYTE_ALIGN_PEAK_LO                 (volatile unsigned int *)((0x2c1c  << 2) + 0xff620000)
+#define   VDEC2_NEXT_ALIGN_PEAK                    (0x2c1d)
+#define P_VDEC2_NEXT_ALIGN_PEAK                    (volatile unsigned int *)((0x2c1d  << 2) + 0xff620000)
+// bit 31    : byte_aligned_zero_23_from_org // From GXM
+// bit 30    : force_shift_out_drop_flag_zero // From GXM
+// bit 29    : en_st_protect_from_org // From GXM
+// bit 28    : enable_halt_decode_start_voff
+// bit 27    : disable_C_pred_check
+// bit 26    : disable_I4_pred_check
+// bit 25    : disable_I16_pred_check
+// bit 24    : check_avs_1st_drop
+// bit 23    : enable_cabac_protect // From GXM
+// bit 22    : enable_avs_drop_more
+// bit 21    : reset_avs_drop_ptr
+// bit 20    : reset_cabac_use_next_at_end_req
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : disable_mv_cal_begin_only
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define   VDEC2_VC1_CONTROL_REG                    (0x2c1e)
+#define P_VDEC2_VC1_CONTROL_REG                    (volatile unsigned int *)((0x2c1e  << 2) + 0xff620000)
+#define   VDEC2_PMV1_X                             (0x2c20)
+#define P_VDEC2_PMV1_X                             (volatile unsigned int *)((0x2c20  << 2) + 0xff620000)
+#define   VDEC2_PMV1_Y                             (0x2c21)
+#define P_VDEC2_PMV1_Y                             (volatile unsigned int *)((0x2c21  << 2) + 0xff620000)
+#define   VDEC2_PMV2_X                             (0x2c22)
+#define P_VDEC2_PMV2_X                             (volatile unsigned int *)((0x2c22  << 2) + 0xff620000)
+#define   VDEC2_PMV2_Y                             (0x2c23)
+#define P_VDEC2_PMV2_Y                             (volatile unsigned int *)((0x2c23  << 2) + 0xff620000)
+#define   VDEC2_PMV3_X                             (0x2c24)
+#define P_VDEC2_PMV3_X                             (volatile unsigned int *)((0x2c24  << 2) + 0xff620000)
+#define   VDEC2_PMV3_Y                             (0x2c25)
+#define P_VDEC2_PMV3_Y                             (volatile unsigned int *)((0x2c25  << 2) + 0xff620000)
+#define   VDEC2_PMV4_X                             (0x2c26)
+#define P_VDEC2_PMV4_X                             (volatile unsigned int *)((0x2c26  << 2) + 0xff620000)
+#define   VDEC2_PMV4_Y                             (0x2c27)
+#define P_VDEC2_PMV4_Y                             (volatile unsigned int *)((0x2c27  << 2) + 0xff620000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define   VDEC2_M4_TABLE_SELECT                    (0x2c28)
+#define P_VDEC2_M4_TABLE_SELECT                    (volatile unsigned int *)((0x2c28  << 2) + 0xff620000)
+#define   VDEC2_M4_CONTROL_REG                     (0x2c29)
+#define P_VDEC2_M4_CONTROL_REG                     (volatile unsigned int *)((0x2c29  << 2) + 0xff620000)
+#define   VDEC2_BLOCK_NUM                          (0x2c2a)
+#define P_VDEC2_BLOCK_NUM                          (volatile unsigned int *)((0x2c2a  << 2) + 0xff620000)
+#define   VDEC2_PATTERN_CODE                       (0x2c2b)
+#define P_VDEC2_PATTERN_CODE                       (volatile unsigned int *)((0x2c2b  << 2) + 0xff620000)
+#define   VDEC2_MB_INFO                            (0x2c2c)
+#define P_VDEC2_MB_INFO                            (volatile unsigned int *)((0x2c2c  << 2) + 0xff620000)
+#define   VDEC2_VLD_DC_PRED                        (0x2c2d)
+#define P_VDEC2_VLD_DC_PRED                        (volatile unsigned int *)((0x2c2d  << 2) + 0xff620000)
+#define   VDEC2_VLD_ERROR_MASK                     (0x2c2e)
+#define P_VDEC2_VLD_ERROR_MASK                     (volatile unsigned int *)((0x2c2e  << 2) + 0xff620000)
+#define   VDEC2_VLD_DC_PRED_C                      (0x2c2f)
+#define P_VDEC2_VLD_DC_PRED_C                      (volatile unsigned int *)((0x2c2f  << 2) + 0xff620000)
+#define   VDEC2_LAST_SLICE_MV_ADDR                 (0x2c30)
+#define P_VDEC2_LAST_SLICE_MV_ADDR                 (volatile unsigned int *)((0x2c30  << 2) + 0xff620000)
+#define   VDEC2_LAST_MVX                           (0x2c31)
+#define P_VDEC2_LAST_MVX                           (volatile unsigned int *)((0x2c31  << 2) + 0xff620000)
+#define   VDEC2_LAST_MVY                           (0x2c32)
+#define P_VDEC2_LAST_MVY                           (volatile unsigned int *)((0x2c32  << 2) + 0xff620000)
+#define   VDEC2_VLD_C38                            (0x2c38)
+#define P_VDEC2_VLD_C38                            (volatile unsigned int *)((0x2c38  << 2) + 0xff620000)
+#define   VDEC2_VLD_C39                            (0x2c39)
+#define P_VDEC2_VLD_C39                            (volatile unsigned int *)((0x2c39  << 2) + 0xff620000)
+#define   VDEC2_VLD_STATUS                         (0x2c3a)
+#define P_VDEC2_VLD_STATUS                         (volatile unsigned int *)((0x2c3a  << 2) + 0xff620000)
+#define   VDEC2_VLD_SHIFT_STATUS                   (0x2c3b)
+#define P_VDEC2_VLD_SHIFT_STATUS                   (volatile unsigned int *)((0x2c3b  << 2) + 0xff620000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define   VDEC2_VOFF_STATUS                        (0x2c3c)
+#define P_VDEC2_VOFF_STATUS                        (volatile unsigned int *)((0x2c3c  << 2) + 0xff620000)
+#define   VDEC2_VLD_C3D                            (0x2c3d)
+#define P_VDEC2_VLD_C3D                            (volatile unsigned int *)((0x2c3d  << 2) + 0xff620000)
+#define   VDEC2_VLD_DBG_INDEX                      (0x2c3e)
+#define P_VDEC2_VLD_DBG_INDEX                      (volatile unsigned int *)((0x2c3e  << 2) + 0xff620000)
+// vld_buff_info -- (index == 0)
+// Bit11]    halt_decode_start_voff
+// Bit10]    C_pred_error
+// Bit[9]    I4_pred_error
+// Bit[8]    I16_pred_error
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1)
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2)
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3)
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4)
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define   VDEC2_VLD_DBG_DATA                       (0x2c3f)
+#define P_VDEC2_VLD_DBG_DATA                       (volatile unsigned int *)((0x2c3f  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   VDEC2_VLD_MEM_VIFIFO_START_PTR           (0x2c40)
+#define P_VDEC2_VLD_MEM_VIFIFO_START_PTR           (volatile unsigned int *)((0x2c40  << 2) + 0xff620000)
+// The current pointer points so some location between the START and END
+// pointers.  The current pointer is a BYTE pointer.  That is, you can
+// point to any BYTE address within the START/END range
+#define   VDEC2_VLD_MEM_VIFIFO_CURR_PTR            (0x2c41)
+#define P_VDEC2_VLD_MEM_VIFIFO_CURR_PTR            (volatile unsigned int *)((0x2c41  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_VIFIFO_END_PTR             (0x2c42)
+#define P_VDEC2_VLD_MEM_VIFIFO_END_PTR             (volatile unsigned int *)((0x2c42  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_VIFIFO_BYTES_AVAIL         (0x2c43)
+#define P_VDEC2_VLD_MEM_VIFIFO_BYTES_AVAIL         (volatile unsigned int *)((0x2c43  << 2) + 0xff620000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0]
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0]
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define   VDEC2_VLD_MEM_VIFIFO_CONTROL             (0x2c44)
+#define P_VDEC2_VLD_MEM_VIFIFO_CONTROL             (volatile unsigned int *)((0x2c44  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define   VDEC2_VLD_MEM_VIFIFO_WP                  (0x2c45)
+#define P_VDEC2_VLD_MEM_VIFIFO_WP                  (volatile unsigned int *)((0x2c45  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_VIFIFO_RP                  (0x2c46)
+#define P_VDEC2_VLD_MEM_VIFIFO_RP                  (volatile unsigned int *)((0x2c46  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_VIFIFO_LEVEL               (0x2c47)
+#define P_VDEC2_VLD_MEM_VIFIFO_LEVEL               (volatile unsigned int *)((0x2c47  << 2) + 0xff620000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   VDEC2_VLD_MEM_VIFIFO_BUF_CNTL            (0x2c48)
+#define P_VDEC2_VLD_MEM_VIFIFO_BUF_CNTL            (volatile unsigned int *)((0x2c48  << 2) + 0xff620000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   VDEC2_VLD_TIME_STAMP_CNTL                (0x2c49)
+#define P_VDEC2_VLD_TIME_STAMP_CNTL                (volatile unsigned int *)((0x2c49  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   VDEC2_VLD_TIME_STAMP_SYNC_0              (0x2c4a)
+#define P_VDEC2_VLD_TIME_STAMP_SYNC_0              (volatile unsigned int *)((0x2c4a  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   VDEC2_VLD_TIME_STAMP_SYNC_1              (0x2c4b)
+#define P_VDEC2_VLD_TIME_STAMP_SYNC_1              (volatile unsigned int *)((0x2c4b  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_0
+#define   VDEC2_VLD_TIME_STAMP_0                   (0x2c4c)
+#define P_VDEC2_VLD_TIME_STAMP_0                   (volatile unsigned int *)((0x2c4c  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_1
+#define   VDEC2_VLD_TIME_STAMP_1                   (0x2c4d)
+#define P_VDEC2_VLD_TIME_STAMP_1                   (volatile unsigned int *)((0x2c4d  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_2
+#define   VDEC2_VLD_TIME_STAMP_2                   (0x2c4e)
+#define P_VDEC2_VLD_TIME_STAMP_2                   (volatile unsigned int *)((0x2c4e  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_3
+#define   VDEC2_VLD_TIME_STAMP_3                   (0x2c4f)
+#define P_VDEC2_VLD_TIME_STAMP_3                   (volatile unsigned int *)((0x2c4f  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   VDEC2_VLD_TIME_STAMP_LENGTH              (0x2c50)
+#define P_VDEC2_VLD_TIME_STAMP_LENGTH              (volatile unsigned int *)((0x2c50  << 2) + 0xff620000)
+// bit 15:0 vififo_rd_count
+#define   VDEC2_VLD_MEM_VIFIFO_WRAP_COUNT          (0x2c51)
+#define P_VDEC2_VLD_MEM_VIFIFO_WRAP_COUNT          (volatile unsigned int *)((0x2c51  << 2) + 0xff620000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   VDEC2_VLD_MEM_VIFIFO_MEM_CTL             (0x2c52)
+#define P_VDEC2_VLD_MEM_VIFIFO_MEM_CTL             (volatile unsigned int *)((0x2c52  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_VBUF_RD_PTR                (0x2c53)
+#define P_VDEC2_VLD_MEM_VBUF_RD_PTR                (volatile unsigned int *)((0x2c53  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_VBUF2_RD_PTR               (0x2c54)
+#define P_VDEC2_VLD_MEM_VBUF2_RD_PTR               (volatile unsigned int *)((0x2c54  << 2) + 0xff620000)
+#define   VDEC2_VLD_MEM_SWAP_ADDR                  (0x2c55)
+#define P_VDEC2_VLD_MEM_SWAP_ADDR                  (volatile unsigned int *)((0x2c55  << 2) + 0xff620000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define   VDEC2_VLD_MEM_SWAP_CTL                   (0x2c56)
+#define P_VDEC2_VLD_MEM_SWAP_CTL                   (volatile unsigned int *)((0x2c56  << 2) + 0xff620000)
+//
+// Closing file:  vld_regs.h
+//
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define   HEVC_VLD_STATUS_CTRL                     (0x3c00)
+#define P_HEVC_VLD_STATUS_CTRL                     (volatile unsigned int *)((0x3c00  << 2) + 0xff620000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define   HEVC_MPEG1_2_REG                         (0x3c01)
+#define P_HEVC_MPEG1_2_REG                         (volatile unsigned int *)((0x3c01  << 2) + 0xff620000)
+#define   HEVC_F_CODE_REG                          (0x3c02)
+#define P_HEVC_F_CODE_REG                          (volatile unsigned int *)((0x3c02  << 2) + 0xff620000)
+#define   HEVC_PIC_HEAD_INFO                       (0x3c03)
+#define P_HEVC_PIC_HEAD_INFO                       (volatile unsigned int *)((0x3c03  << 2) + 0xff620000)
+#define   HEVC_SLICE_VER_POS_PIC_TYPE              (0x3c04)
+#define P_HEVC_SLICE_VER_POS_PIC_TYPE              (volatile unsigned int *)((0x3c04  << 2) + 0xff620000)
+#define   HEVC_QP_VALUE_REG                        (0x3c05)
+#define P_HEVC_QP_VALUE_REG                        (volatile unsigned int *)((0x3c05  << 2) + 0xff620000)
+#define   HEVC_MBA_INC                             (0x3c06)
+#define P_HEVC_MBA_INC                             (volatile unsigned int *)((0x3c06  << 2) + 0xff620000)
+#define   HEVC_MB_MOTION_MODE                      (0x3c07)
+#define P_HEVC_MB_MOTION_MODE                      (volatile unsigned int *)((0x3c07  << 2) + 0xff620000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en
+// bit 5:0 -- vld_power_ctl
+#define   HEVC_POWER_CTL_VLD                       (0x3c08)
+#define P_HEVC_POWER_CTL_VLD                       (volatile unsigned int *)((0x3c08  << 2) + 0xff620000)
+#define   HEVC_MB_WIDTH                            (0x3c09)
+#define P_HEVC_MB_WIDTH                            (volatile unsigned int *)((0x3c09  << 2) + 0xff620000)
+#define   HEVC_SLICE_QP                            (0x3c0a)
+#define P_HEVC_SLICE_QP                            (volatile unsigned int *)((0x3c0a  << 2) + 0xff620000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define   HEVC_PRE_START_CODE                      (0x3c0b)
+#define P_HEVC_PRE_START_CODE                      (volatile unsigned int *)((0x3c0b  << 2) + 0xff620000)
+#define   HEVC_SLICE_START_BYTE_01                 (0x3c0c)
+#define P_HEVC_SLICE_START_BYTE_01                 (volatile unsigned int *)((0x3c0c  << 2) + 0xff620000)
+#define   HEVC_SLICE_START_BYTE_23                 (0x3c0d)
+#define P_HEVC_SLICE_START_BYTE_23                 (volatile unsigned int *)((0x3c0d  << 2) + 0xff620000)
+#define   HEVC_RESYNC_MARKER_LENGTH                (0x3c0e)
+#define P_HEVC_RESYNC_MARKER_LENGTH                (volatile unsigned int *)((0x3c0e  << 2) + 0xff620000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define   HEVC_DECODER_BUFFER_INFO                 (0x3c0f)
+#define P_HEVC_DECODER_BUFFER_INFO                 (volatile unsigned int *)((0x3c0f  << 2) + 0xff620000)
+#define   HEVC_FST_FOR_MV_X                        (0x3c10)
+#define P_HEVC_FST_FOR_MV_X                        (volatile unsigned int *)((0x3c10  << 2) + 0xff620000)
+#define   HEVC_FST_FOR_MV_Y                        (0x3c11)
+#define P_HEVC_FST_FOR_MV_Y                        (volatile unsigned int *)((0x3c11  << 2) + 0xff620000)
+#define   HEVC_SCD_FOR_MV_X                        (0x3c12)
+#define P_HEVC_SCD_FOR_MV_X                        (volatile unsigned int *)((0x3c12  << 2) + 0xff620000)
+#define   HEVC_SCD_FOR_MV_Y                        (0x3c13)
+#define P_HEVC_SCD_FOR_MV_Y                        (volatile unsigned int *)((0x3c13  << 2) + 0xff620000)
+#define   HEVC_FST_BAK_MV_X                        (0x3c14)
+#define P_HEVC_FST_BAK_MV_X                        (volatile unsigned int *)((0x3c14  << 2) + 0xff620000)
+#define   HEVC_FST_BAK_MV_Y                        (0x3c15)
+#define P_HEVC_FST_BAK_MV_Y                        (volatile unsigned int *)((0x3c15  << 2) + 0xff620000)
+#define   HEVC_SCD_BAK_MV_X                        (0x3c16)
+#define P_HEVC_SCD_BAK_MV_X                        (volatile unsigned int *)((0x3c16  << 2) + 0xff620000)
+#define   HEVC_SCD_BAK_MV_Y                        (0x3c17)
+#define P_HEVC_SCD_BAK_MV_Y                        (volatile unsigned int *)((0x3c17  << 2) + 0xff620000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- disable_new_stcode_search_fix // From GXM
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag
+#define   HEVC_VLD_DECODE_CONTROL                  (0x3c18)
+#define P_HEVC_VLD_DECODE_CONTROL                  (volatile unsigned int *)((0x3c18  << 2) + 0xff620000)
+#define   HEVC_VLD_REVERVED_19                     (0x3c19)
+#define P_HEVC_VLD_REVERVED_19                     (volatile unsigned int *)((0x3c19  << 2) + 0xff620000)
+#define   HEVC_VIFF_BIT_CNT                        (0x3c1a)
+#define P_HEVC_VIFF_BIT_CNT                        (volatile unsigned int *)((0x3c1a  << 2) + 0xff620000)
+#define   HEVC_BYTE_ALIGN_PEAK_HI                  (0x3c1b)
+#define P_HEVC_BYTE_ALIGN_PEAK_HI                  (volatile unsigned int *)((0x3c1b  << 2) + 0xff620000)
+#define   HEVC_BYTE_ALIGN_PEAK_LO                  (0x3c1c)
+#define P_HEVC_BYTE_ALIGN_PEAK_LO                  (volatile unsigned int *)((0x3c1c  << 2) + 0xff620000)
+#define   HEVC_NEXT_ALIGN_PEAK                     (0x3c1d)
+#define P_HEVC_NEXT_ALIGN_PEAK                     (volatile unsigned int *)((0x3c1d  << 2) + 0xff620000)
+// bit 31    : byte_aligned_zero_23_from_org // From GXM
+// bit 30    : force_shift_out_drop_flag_zero // From GXM
+// bit 29    : en_st_protect_from_org // From GXM
+// bit 28    : enable_halt_decode_start_voff
+// bit 27    : disable_C_pred_check
+// bit 26    : disable_I4_pred_check
+// bit 25    : disable_I16_pred_check
+// bit 24    : check_avs_1st_drop
+// bit 23    : enable_cabac_protect // From GXM
+// bit 22    : enable_avs_drop_more
+// bit 21    : reset_avs_drop_ptr
+// bit 20    : reset_cabac_use_next_at_end_req
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : disable_mv_cal_begin_only
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define   HEVC_VC1_CONTROL_REG                     (0x3c1e)
+#define P_HEVC_VC1_CONTROL_REG                     (volatile unsigned int *)((0x3c1e  << 2) + 0xff620000)
+#define   HEVC_PMV1_X                              (0x3c20)
+#define P_HEVC_PMV1_X                              (volatile unsigned int *)((0x3c20  << 2) + 0xff620000)
+#define   HEVC_PMV1_Y                              (0x3c21)
+#define P_HEVC_PMV1_Y                              (volatile unsigned int *)((0x3c21  << 2) + 0xff620000)
+#define   HEVC_PMV2_X                              (0x3c22)
+#define P_HEVC_PMV2_X                              (volatile unsigned int *)((0x3c22  << 2) + 0xff620000)
+#define   HEVC_PMV2_Y                              (0x3c23)
+#define P_HEVC_PMV2_Y                              (volatile unsigned int *)((0x3c23  << 2) + 0xff620000)
+#define   HEVC_PMV3_X                              (0x3c24)
+#define P_HEVC_PMV3_X                              (volatile unsigned int *)((0x3c24  << 2) + 0xff620000)
+#define   HEVC_PMV3_Y                              (0x3c25)
+#define P_HEVC_PMV3_Y                              (volatile unsigned int *)((0x3c25  << 2) + 0xff620000)
+#define   HEVC_PMV4_X                              (0x3c26)
+#define P_HEVC_PMV4_X                              (volatile unsigned int *)((0x3c26  << 2) + 0xff620000)
+#define   HEVC_PMV4_Y                              (0x3c27)
+#define P_HEVC_PMV4_Y                              (volatile unsigned int *)((0x3c27  << 2) + 0xff620000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define   HEVC_M4_TABLE_SELECT                     (0x3c28)
+#define P_HEVC_M4_TABLE_SELECT                     (volatile unsigned int *)((0x3c28  << 2) + 0xff620000)
+#define   HEVC_M4_CONTROL_REG                      (0x3c29)
+#define P_HEVC_M4_CONTROL_REG                      (volatile unsigned int *)((0x3c29  << 2) + 0xff620000)
+#define   HEVC_BLOCK_NUM                           (0x3c2a)
+#define P_HEVC_BLOCK_NUM                           (volatile unsigned int *)((0x3c2a  << 2) + 0xff620000)
+#define   HEVC_PATTERN_CODE                        (0x3c2b)
+#define P_HEVC_PATTERN_CODE                        (volatile unsigned int *)((0x3c2b  << 2) + 0xff620000)
+#define   HEVC_MB_INFO                             (0x3c2c)
+#define P_HEVC_MB_INFO                             (volatile unsigned int *)((0x3c2c  << 2) + 0xff620000)
+#define   HEVC_VLD_DC_PRED                         (0x3c2d)
+#define P_HEVC_VLD_DC_PRED                         (volatile unsigned int *)((0x3c2d  << 2) + 0xff620000)
+#define   HEVC_VLD_ERROR_MASK                      (0x3c2e)
+#define P_HEVC_VLD_ERROR_MASK                      (volatile unsigned int *)((0x3c2e  << 2) + 0xff620000)
+#define   HEVC_VLD_DC_PRED_C                       (0x3c2f)
+#define P_HEVC_VLD_DC_PRED_C                       (volatile unsigned int *)((0x3c2f  << 2) + 0xff620000)
+#define   HEVC_LAST_SLICE_MV_ADDR                  (0x3c30)
+#define P_HEVC_LAST_SLICE_MV_ADDR                  (volatile unsigned int *)((0x3c30  << 2) + 0xff620000)
+#define   HEVC_LAST_MVX                            (0x3c31)
+#define P_HEVC_LAST_MVX                            (volatile unsigned int *)((0x3c31  << 2) + 0xff620000)
+#define   HEVC_LAST_MVY                            (0x3c32)
+#define P_HEVC_LAST_MVY                            (volatile unsigned int *)((0x3c32  << 2) + 0xff620000)
+#define   HEVC_VLD_C38                             (0x3c38)
+#define P_HEVC_VLD_C38                             (volatile unsigned int *)((0x3c38  << 2) + 0xff620000)
+#define   HEVC_VLD_C39                             (0x3c39)
+#define P_HEVC_VLD_C39                             (volatile unsigned int *)((0x3c39  << 2) + 0xff620000)
+#define   HEVC_VLD_STATUS                          (0x3c3a)
+#define P_HEVC_VLD_STATUS                          (volatile unsigned int *)((0x3c3a  << 2) + 0xff620000)
+#define   HEVC_VLD_SHIFT_STATUS                    (0x3c3b)
+#define P_HEVC_VLD_SHIFT_STATUS                    (volatile unsigned int *)((0x3c3b  << 2) + 0xff620000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define   HEVC_VOFF_STATUS                         (0x3c3c)
+#define P_HEVC_VOFF_STATUS                         (volatile unsigned int *)((0x3c3c  << 2) + 0xff620000)
+#define   HEVC_VLD_C3D                             (0x3c3d)
+#define P_HEVC_VLD_C3D                             (volatile unsigned int *)((0x3c3d  << 2) + 0xff620000)
+#define   HEVC_VLD_DBG_INDEX                       (0x3c3e)
+#define P_HEVC_VLD_DBG_INDEX                       (volatile unsigned int *)((0x3c3e  << 2) + 0xff620000)
+// vld_buff_info -- (index == 0)
+// Bit11]    halt_decode_start_voff
+// Bit10]    C_pred_error
+// Bit[9]    I4_pred_error
+// Bit[8]    I16_pred_error
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1)
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2)
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3)
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4)
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6)
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define   HEVC_VLD_DBG_DATA                        (0x3c3f)
+#define P_HEVC_VLD_DBG_DATA                        (volatile unsigned int *)((0x3c3f  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   HEVC_VLD_MEM_VIFIFO_START_PTR            (0x3c40)
+#define P_HEVC_VLD_MEM_VIFIFO_START_PTR            (volatile unsigned int *)((0x3c40  << 2) + 0xff620000)
+// The current pointer points so some location between the START and END
+// pointers.  The current pointer is a BYTE pointer.  That is, you can
+// point to any BYTE address within the START/END range
+#define   HEVC_VLD_MEM_VIFIFO_CURR_PTR             (0x3c41)
+#define P_HEVC_VLD_MEM_VIFIFO_CURR_PTR             (volatile unsigned int *)((0x3c41  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_VIFIFO_END_PTR              (0x3c42)
+#define P_HEVC_VLD_MEM_VIFIFO_END_PTR              (volatile unsigned int *)((0x3c42  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_VIFIFO_BYTES_AVAIL          (0x3c43)
+#define P_HEVC_VLD_MEM_VIFIFO_BYTES_AVAIL          (volatile unsigned int *)((0x3c43  << 2) + 0xff620000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0]
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0]
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define   HEVC_VLD_MEM_VIFIFO_CONTROL              (0x3c44)
+#define P_HEVC_VLD_MEM_VIFIFO_CONTROL              (volatile unsigned int *)((0x3c44  << 2) + 0xff620000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define   HEVC_VLD_MEM_VIFIFO_WP                   (0x3c45)
+#define P_HEVC_VLD_MEM_VIFIFO_WP                   (volatile unsigned int *)((0x3c45  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_VIFIFO_RP                   (0x3c46)
+#define P_HEVC_VLD_MEM_VIFIFO_RP                   (volatile unsigned int *)((0x3c46  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_VIFIFO_LEVEL                (0x3c47)
+#define P_HEVC_VLD_MEM_VIFIFO_LEVEL                (volatile unsigned int *)((0x3c47  << 2) + 0xff620000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   HEVC_VLD_MEM_VIFIFO_BUF_CNTL             (0x3c48)
+#define P_HEVC_VLD_MEM_VIFIFO_BUF_CNTL             (volatile unsigned int *)((0x3c48  << 2) + 0xff620000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   HEVC_VLD_TIME_STAMP_CNTL                 (0x3c49)
+#define P_HEVC_VLD_TIME_STAMP_CNTL                 (volatile unsigned int *)((0x3c49  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   HEVC_VLD_TIME_STAMP_SYNC_0               (0x3c4a)
+#define P_HEVC_VLD_TIME_STAMP_SYNC_0               (volatile unsigned int *)((0x3c4a  << 2) + 0xff620000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   HEVC_VLD_TIME_STAMP_SYNC_1               (0x3c4b)
+#define P_HEVC_VLD_TIME_STAMP_SYNC_1               (volatile unsigned int *)((0x3c4b  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_0
+#define   HEVC_VLD_TIME_STAMP_0                    (0x3c4c)
+#define P_HEVC_VLD_TIME_STAMP_0                    (volatile unsigned int *)((0x3c4c  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_1
+#define   HEVC_VLD_TIME_STAMP_1                    (0x3c4d)
+#define P_HEVC_VLD_TIME_STAMP_1                    (volatile unsigned int *)((0x3c4d  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_2
+#define   HEVC_VLD_TIME_STAMP_2                    (0x3c4e)
+#define P_HEVC_VLD_TIME_STAMP_2                    (volatile unsigned int *)((0x3c4e  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_3
+#define   HEVC_VLD_TIME_STAMP_3                    (0x3c4f)
+#define P_HEVC_VLD_TIME_STAMP_3                    (volatile unsigned int *)((0x3c4f  << 2) + 0xff620000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   HEVC_VLD_TIME_STAMP_LENGTH               (0x3c50)
+#define P_HEVC_VLD_TIME_STAMP_LENGTH               (volatile unsigned int *)((0x3c50  << 2) + 0xff620000)
+// bit 15:0 vififo_rd_count
+#define   HEVC_VLD_MEM_VIFIFO_WRAP_COUNT           (0x3c51)
+#define P_HEVC_VLD_MEM_VIFIFO_WRAP_COUNT           (volatile unsigned int *)((0x3c51  << 2) + 0xff620000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   HEVC_VLD_MEM_VIFIFO_MEM_CTL              (0x3c52)
+#define P_HEVC_VLD_MEM_VIFIFO_MEM_CTL              (volatile unsigned int *)((0x3c52  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_VBUF_RD_PTR                 (0x3c53)
+#define P_HEVC_VLD_MEM_VBUF_RD_PTR                 (volatile unsigned int *)((0x3c53  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_VBUF2_RD_PTR                (0x3c54)
+#define P_HEVC_VLD_MEM_VBUF2_RD_PTR                (volatile unsigned int *)((0x3c54  << 2) + 0xff620000)
+#define   HEVC_VLD_MEM_SWAP_ADDR                   (0x3c55)
+#define P_HEVC_VLD_MEM_SWAP_ADDR                   (volatile unsigned int *)((0x3c55  << 2) + 0xff620000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define   HEVC_VLD_MEM_SWAP_CTL                    (0x3c56)
+#define P_HEVC_VLD_MEM_SWAP_CTL                    (volatile unsigned int *)((0x3c56  << 2) + 0xff620000)
+//
+// Closing file:  vld_regs.h
+//
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define   HCODEC_VCOP_CTRL_REG                     (0x1e00)
+#define P_HCODEC_VCOP_CTRL_REG                     (volatile unsigned int *)((0x1e00  << 2) + 0xff620000)
+#define   HCODEC_QP_CTRL_REG                       (0x1e01)
+#define P_HCODEC_QP_CTRL_REG                       (volatile unsigned int *)((0x1e01  << 2) + 0xff620000)
+#define   HCODEC_INTRA_QUANT_MATRIX                (0x1e02)
+#define P_HCODEC_INTRA_QUANT_MATRIX                (volatile unsigned int *)((0x1e02  << 2) + 0xff620000)
+#define   HCODEC_NON_I_QUANT_MATRIX                (0x1e03)
+#define P_HCODEC_NON_I_QUANT_MATRIX                (volatile unsigned int *)((0x1e03  << 2) + 0xff620000)
+#define   HCODEC_DC_SCALER                         (0x1e04)
+#define P_HCODEC_DC_SCALER                         (volatile unsigned int *)((0x1e04  << 2) + 0xff620000)
+#define   HCODEC_DC_AC_CTRL                        (0x1e05)
+#define P_HCODEC_DC_AC_CTRL                        (volatile unsigned int *)((0x1e05  << 2) + 0xff620000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define   HCODEC_DC_AC_SCALE_MUL                   (0x1e06)
+#define P_HCODEC_DC_AC_SCALE_MUL                   (volatile unsigned int *)((0x1e06  << 2) + 0xff620000)
+#define   HCODEC_DC_AC_SCALE_DIV                   (0x1e07)
+#define P_HCODEC_DC_AC_SCALE_DIV                   (volatile unsigned int *)((0x1e07  << 2) + 0xff620000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define   HCODEC_POWER_CTL_IQIDCT                  (0x1e08)
+#define P_HCODEC_POWER_CTL_IQIDCT                  (volatile unsigned int *)((0x1e08  << 2) + 0xff620000)
+#define   HCODEC_RV_AI_Y_X                         (0x1e09)
+#define P_HCODEC_RV_AI_Y_X                         (volatile unsigned int *)((0x1e09  << 2) + 0xff620000)
+#define   HCODEC_RV_AI_U_X                         (0x1e0a)
+#define P_HCODEC_RV_AI_U_X                         (volatile unsigned int *)((0x1e0a  << 2) + 0xff620000)
+#define   HCODEC_RV_AI_V_X                         (0x1e0b)
+#define P_HCODEC_RV_AI_V_X                         (volatile unsigned int *)((0x1e0b  << 2) + 0xff620000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define   HCODEC_RV_AI_MB_COUNT                    (0x1e0c)
+#define P_HCODEC_RV_AI_MB_COUNT                    (volatile unsigned int *)((0x1e0c  << 2) + 0xff620000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define   HCODEC_NEXT_INTRA_DMA_ADDRESS            (0x1e0d)
+#define P_HCODEC_NEXT_INTRA_DMA_ADDRESS            (volatile unsigned int *)((0x1e0d  << 2) + 0xff620000)
+// Bit 16 -- dcac_dma_read_cache_disable
+// Bit 15 -- dcac_dma_urgent
+// Bit 14 -- nv21_swap
+// Bit 13 -- nv21_top_dma
+// Bit 12 -- reset_rv_ai_wait_rd_data
+// Bit 11 -- set_rv_ai_wait_rd_data [12:11] = 3 means only dec 1 (For Skipped MB of MBAFF)
+// Bit 10 -- rv_ai_wait_rd_data (Read Only)
+// Bit 9 -- enable_rv_ai_wait_rd_data
+// Bit 8 -- disable_vc1_mv_update
+// Bit 7 -- pred_dc_signed
+// Bit 6 -- inc_vld_ready_count
+// Bit 5 -- dec_vld_ready_count
+// Bit 4 -- disable_ref_bidir_fix
+// Bit 3 -- disable_MV_UL_l1_bot_fix
+// Bit 2 -- disable_mb_aff_fix
+// Bit 1 -- canvas_addr_7
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define   HCODEC_IQIDCT_CONTROL                    (0x1e0e)
+#define P_HCODEC_IQIDCT_CONTROL                    (volatile unsigned int *)((0x1e0e  << 2) + 0xff620000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define   HCODEC_IQIDCT_DEBUG_INFO_0               (0x1e0f)
+#define P_HCODEC_IQIDCT_DEBUG_INFO_0               (volatile unsigned int *)((0x1e0f  << 2) + 0xff620000)
+// For RTL Simulation Only
+#define   HCODEC_DEBLK_CMD                         (0x1e10)
+#define P_HCODEC_DEBLK_CMD                         (volatile unsigned int *)((0x1e10  << 2) + 0xff620000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define   HCODEC_IQIDCT_DEBUG_IDCT                 (0x1e11)
+#define P_HCODEC_IQIDCT_DEBUG_IDCT                 (volatile unsigned int *)((0x1e11  << 2) + 0xff620000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_read_cache_active
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define   HCODEC_DCAC_DMA_CTRL                     (0x1e12)
+#define P_HCODEC_DCAC_DMA_CTRL                     (volatile unsigned int *)((0x1e12  << 2) + 0xff620000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define   HCODEC_DCAC_DMA_ADDRESS                  (0x1e13)
+#define P_HCODEC_DCAC_DMA_ADDRESS                  (volatile unsigned int *)((0x1e13  << 2) + 0xff620000)
+// bit 7:0 -- dcac_cpu_addr
+#define   HCODEC_DCAC_CPU_ADDRESS                  (0x1e14)
+#define P_HCODEC_DCAC_CPU_ADDRESS                  (volatile unsigned int *)((0x1e14  << 2) + 0xff620000)
+// bit 31:0 -- dcac_cpu_data
+#define   HCODEC_DCAC_CPU_DATA                     (0x1e15)
+#define P_HCODEC_DCAC_CPU_DATA                     (volatile unsigned int *)((0x1e15  << 2) + 0xff620000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only
+// bit 15:0 -- dcac_mb_count
+#define   HCODEC_DCAC_MB_COUNT                     (0x1e16)
+#define P_HCODEC_DCAC_MB_COUNT                     (volatile unsigned int *)((0x1e16  << 2) + 0xff620000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant
+//   bit 11:6 -- h264_quant_c
+//   bit  5:0 -- h264_quant_c
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode
+//   bit 11:6  -- AltPQuant
+//   bit  5:0  -- PQuant
+//
+#define   HCODEC_IQ_QUANT                          (0x1e17)
+#define P_HCODEC_IQ_QUANT                          (volatile unsigned int *)((0x1e17  << 2) + 0xff620000)
+// bit 31:24  -- bitplane_width
+// bit 23:16  -- bitplane_height
+// bit 15:14  -- bitplane_start_x
+// bit 13:12  -- bitplane_start_y
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define   HCODEC_VC1_BITPLANE_CTL                  (0x1e18)
+#define P_HCODEC_VC1_BITPLANE_CTL                  (volatile unsigned int *)((0x1e18  << 2) + 0xff620000)
+// bit 24:16  -- wq_param1
+// bit  8: 0  -- wq_param0
+#define   HCODEC_AVSP_IQ_WQ_PARAM_01               (0x1e19)
+#define P_HCODEC_AVSP_IQ_WQ_PARAM_01               (volatile unsigned int *)((0x1e19  << 2) + 0xff620000)
+// bit 24:16  -- wq_param3
+// bit  8: 0  -- wq_param2
+#define   HCODEC_AVSP_IQ_WQ_PARAM_23               (0x1e1a)
+#define P_HCODEC_AVSP_IQ_WQ_PARAM_23               (volatile unsigned int *)((0x1e1a  << 2) + 0xff620000)
+// bit 24:16  -- wq_param5
+// bit  8: 0  -- wq_param4
+#define   HCODEC_AVSP_IQ_WQ_PARAM_45               (0x1e1b)
+#define P_HCODEC_AVSP_IQ_WQ_PARAM_45               (volatile unsigned int *)((0x1e1b  << 2) + 0xff620000)
+// bit    31  -- weight_quant_en
+// bit 17:16  -- current_scene_model
+// bit 12: 8  -- chroma_qp_delta_cr
+// bit  4: 0  -- chroma_qp_delta_cb
+#define   HCODEC_AVSP_IQ_CTL                       (0x1e1c)
+#define P_HCODEC_AVSP_IQ_CTL                       (volatile unsigned int *)((0x1e1c  << 2) + 0xff620000)
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define   VDEC2_VCOP_CTRL_REG                      (0x2e00)
+#define P_VDEC2_VCOP_CTRL_REG                      (volatile unsigned int *)((0x2e00  << 2) + 0xff620000)
+#define   VDEC2_QP_CTRL_REG                        (0x2e01)
+#define P_VDEC2_QP_CTRL_REG                        (volatile unsigned int *)((0x2e01  << 2) + 0xff620000)
+#define   VDEC2_INTRA_QUANT_MATRIX                 (0x2e02)
+#define P_VDEC2_INTRA_QUANT_MATRIX                 (volatile unsigned int *)((0x2e02  << 2) + 0xff620000)
+#define   VDEC2_NON_I_QUANT_MATRIX                 (0x2e03)
+#define P_VDEC2_NON_I_QUANT_MATRIX                 (volatile unsigned int *)((0x2e03  << 2) + 0xff620000)
+#define   VDEC2_DC_SCALER                          (0x2e04)
+#define P_VDEC2_DC_SCALER                          (volatile unsigned int *)((0x2e04  << 2) + 0xff620000)
+#define   VDEC2_DC_AC_CTRL                         (0x2e05)
+#define P_VDEC2_DC_AC_CTRL                         (volatile unsigned int *)((0x2e05  << 2) + 0xff620000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define   VDEC2_DC_AC_SCALE_MUL                    (0x2e06)
+#define P_VDEC2_DC_AC_SCALE_MUL                    (volatile unsigned int *)((0x2e06  << 2) + 0xff620000)
+#define   VDEC2_DC_AC_SCALE_DIV                    (0x2e07)
+#define P_VDEC2_DC_AC_SCALE_DIV                    (volatile unsigned int *)((0x2e07  << 2) + 0xff620000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define   VDEC2_POWER_CTL_IQIDCT                   (0x2e08)
+#define P_VDEC2_POWER_CTL_IQIDCT                   (volatile unsigned int *)((0x2e08  << 2) + 0xff620000)
+#define   VDEC2_RV_AI_Y_X                          (0x2e09)
+#define P_VDEC2_RV_AI_Y_X                          (volatile unsigned int *)((0x2e09  << 2) + 0xff620000)
+#define   VDEC2_RV_AI_U_X                          (0x2e0a)
+#define P_VDEC2_RV_AI_U_X                          (volatile unsigned int *)((0x2e0a  << 2) + 0xff620000)
+#define   VDEC2_RV_AI_V_X                          (0x2e0b)
+#define P_VDEC2_RV_AI_V_X                          (volatile unsigned int *)((0x2e0b  << 2) + 0xff620000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define   VDEC2_RV_AI_MB_COUNT                     (0x2e0c)
+#define P_VDEC2_RV_AI_MB_COUNT                     (volatile unsigned int *)((0x2e0c  << 2) + 0xff620000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define   VDEC2_NEXT_INTRA_DMA_ADDRESS             (0x2e0d)
+#define P_VDEC2_NEXT_INTRA_DMA_ADDRESS             (volatile unsigned int *)((0x2e0d  << 2) + 0xff620000)
+// Bit 16 -- dcac_dma_read_cache_disable
+// Bit 15 -- dcac_dma_urgent
+// Bit 14 -- nv21_swap
+// Bit 13 -- nv21_top_dma
+// Bit 12 -- reset_rv_ai_wait_rd_data
+// Bit 11 -- set_rv_ai_wait_rd_data [12:11] = 3 means only dec 1 (For Skipped MB of MBAFF)
+// Bit 10 -- rv_ai_wait_rd_data (Read Only)
+// Bit 9 -- enable_rv_ai_wait_rd_data
+// Bit 8 -- disable_vc1_mv_update
+// Bit 7 -- pred_dc_signed
+// Bit 6 -- inc_vld_ready_count
+// Bit 5 -- dec_vld_ready_count
+// Bit 4 -- disable_ref_bidir_fix
+// Bit 3 -- disable_MV_UL_l1_bot_fix
+// Bit 2 -- disable_mb_aff_fix
+// Bit 1 -- canvas_addr_7
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define   VDEC2_IQIDCT_CONTROL                     (0x2e0e)
+#define P_VDEC2_IQIDCT_CONTROL                     (volatile unsigned int *)((0x2e0e  << 2) + 0xff620000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define   VDEC2_IQIDCT_DEBUG_INFO_0                (0x2e0f)
+#define P_VDEC2_IQIDCT_DEBUG_INFO_0                (volatile unsigned int *)((0x2e0f  << 2) + 0xff620000)
+// For RTL Simulation Only
+#define   VDEC2_DEBLK_CMD                          (0x2e10)
+#define P_VDEC2_DEBLK_CMD                          (volatile unsigned int *)((0x2e10  << 2) + 0xff620000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define   VDEC2_IQIDCT_DEBUG_IDCT                  (0x2e11)
+#define P_VDEC2_IQIDCT_DEBUG_IDCT                  (volatile unsigned int *)((0x2e11  << 2) + 0xff620000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_read_cache_active
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define   VDEC2_DCAC_DMA_CTRL                      (0x2e12)
+#define P_VDEC2_DCAC_DMA_CTRL                      (volatile unsigned int *)((0x2e12  << 2) + 0xff620000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define   VDEC2_DCAC_DMA_ADDRESS                   (0x2e13)
+#define P_VDEC2_DCAC_DMA_ADDRESS                   (volatile unsigned int *)((0x2e13  << 2) + 0xff620000)
+// bit 7:0 -- dcac_cpu_addr
+#define   VDEC2_DCAC_CPU_ADDRESS                   (0x2e14)
+#define P_VDEC2_DCAC_CPU_ADDRESS                   (volatile unsigned int *)((0x2e14  << 2) + 0xff620000)
+// bit 31:0 -- dcac_cpu_data
+#define   VDEC2_DCAC_CPU_DATA                      (0x2e15)
+#define P_VDEC2_DCAC_CPU_DATA                      (volatile unsigned int *)((0x2e15  << 2) + 0xff620000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only
+// bit 15:0 -- dcac_mb_count
+#define   VDEC2_DCAC_MB_COUNT                      (0x2e16)
+#define P_VDEC2_DCAC_MB_COUNT                      (volatile unsigned int *)((0x2e16  << 2) + 0xff620000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant
+//   bit 11:6 -- h264_quant_c
+//   bit  5:0 -- h264_quant_c
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode
+//   bit 11:6  -- AltPQuant
+//   bit  5:0  -- PQuant
+//
+#define   VDEC2_IQ_QUANT                           (0x2e17)
+#define P_VDEC2_IQ_QUANT                           (volatile unsigned int *)((0x2e17  << 2) + 0xff620000)
+// bit 31:24  -- bitplane_width
+// bit 23:16  -- bitplane_height
+// bit 15:14  -- bitplane_start_x
+// bit 13:12  -- bitplane_start_y
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define   VDEC2_VC1_BITPLANE_CTL                   (0x2e18)
+#define P_VDEC2_VC1_BITPLANE_CTL                   (volatile unsigned int *)((0x2e18  << 2) + 0xff620000)
+// bit 24:16  -- wq_param1
+// bit  8: 0  -- wq_param0
+#define   VDEC2_AVSP_IQ_WQ_PARAM_01                (0x2e19)
+#define P_VDEC2_AVSP_IQ_WQ_PARAM_01                (volatile unsigned int *)((0x2e19  << 2) + 0xff620000)
+// bit 24:16  -- wq_param3
+// bit  8: 0  -- wq_param2
+#define   VDEC2_AVSP_IQ_WQ_PARAM_23                (0x2e1a)
+#define P_VDEC2_AVSP_IQ_WQ_PARAM_23                (volatile unsigned int *)((0x2e1a  << 2) + 0xff620000)
+// bit 24:16  -- wq_param5
+// bit  8: 0  -- wq_param4
+#define   VDEC2_AVSP_IQ_WQ_PARAM_45                (0x2e1b)
+#define P_VDEC2_AVSP_IQ_WQ_PARAM_45                (volatile unsigned int *)((0x2e1b  << 2) + 0xff620000)
+// bit    31  -- weight_quant_en
+// bit 17:16  -- current_scene_model
+// bit 12: 8  -- chroma_qp_delta_cr
+// bit  4: 0  -- chroma_qp_delta_cb
+#define   VDEC2_AVSP_IQ_CTL                        (0x2e1c)
+#define P_VDEC2_AVSP_IQ_CTL                        (volatile unsigned int *)((0x2e1c  << 2) + 0xff620000)
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define   HEVC_VCOP_CTRL_REG                       (0x3e00)
+#define P_HEVC_VCOP_CTRL_REG                       (volatile unsigned int *)((0x3e00  << 2) + 0xff620000)
+#define   HEVC_QP_CTRL_REG                         (0x3e01)
+#define P_HEVC_QP_CTRL_REG                         (volatile unsigned int *)((0x3e01  << 2) + 0xff620000)
+#define   HEVC_INTRA_QUANT_MATRIX                  (0x3e02)
+#define P_HEVC_INTRA_QUANT_MATRIX                  (volatile unsigned int *)((0x3e02  << 2) + 0xff620000)
+#define   HEVC_NON_I_QUANT_MATRIX                  (0x3e03)
+#define P_HEVC_NON_I_QUANT_MATRIX                  (volatile unsigned int *)((0x3e03  << 2) + 0xff620000)
+#define   HEVC_DC_SCALER                           (0x3e04)
+#define P_HEVC_DC_SCALER                           (volatile unsigned int *)((0x3e04  << 2) + 0xff620000)
+#define   HEVC_DC_AC_CTRL                          (0x3e05)
+#define P_HEVC_DC_AC_CTRL                          (volatile unsigned int *)((0x3e05  << 2) + 0xff620000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define   HEVC_DC_AC_SCALE_MUL                     (0x3e06)
+#define P_HEVC_DC_AC_SCALE_MUL                     (volatile unsigned int *)((0x3e06  << 2) + 0xff620000)
+#define   HEVC_DC_AC_SCALE_DIV                     (0x3e07)
+#define P_HEVC_DC_AC_SCALE_DIV                     (volatile unsigned int *)((0x3e07  << 2) + 0xff620000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define   HEVC_POWER_CTL_IQIDCT                    (0x3e08)
+#define P_HEVC_POWER_CTL_IQIDCT                    (volatile unsigned int *)((0x3e08  << 2) + 0xff620000)
+#define   HEVC_RV_AI_Y_X                           (0x3e09)
+#define P_HEVC_RV_AI_Y_X                           (volatile unsigned int *)((0x3e09  << 2) + 0xff620000)
+#define   HEVC_RV_AI_U_X                           (0x3e0a)
+#define P_HEVC_RV_AI_U_X                           (volatile unsigned int *)((0x3e0a  << 2) + 0xff620000)
+#define   HEVC_RV_AI_V_X                           (0x3e0b)
+#define P_HEVC_RV_AI_V_X                           (volatile unsigned int *)((0x3e0b  << 2) + 0xff620000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define   HEVC_RV_AI_MB_COUNT                      (0x3e0c)
+#define P_HEVC_RV_AI_MB_COUNT                      (volatile unsigned int *)((0x3e0c  << 2) + 0xff620000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define   HEVC_NEXT_INTRA_DMA_ADDRESS              (0x3e0d)
+#define P_HEVC_NEXT_INTRA_DMA_ADDRESS              (volatile unsigned int *)((0x3e0d  << 2) + 0xff620000)
+// Bit 16 -- dcac_dma_read_cache_disable
+// Bit 15 -- dcac_dma_urgent
+// Bit 14 -- nv21_swap
+// Bit 13 -- nv21_top_dma
+// Bit 12 -- reset_rv_ai_wait_rd_data
+// Bit 11 -- set_rv_ai_wait_rd_data [12:11] = 3 means only dec 1 (For Skipped MB of MBAFF)
+// Bit 10 -- rv_ai_wait_rd_data (Read Only)
+// Bit 9 -- enable_rv_ai_wait_rd_data
+// Bit 8 -- disable_vc1_mv_update
+// Bit 7 -- pred_dc_signed
+// Bit 6 -- inc_vld_ready_count
+// Bit 5 -- dec_vld_ready_count
+// Bit 4 -- disable_ref_bidir_fix
+// Bit 3 -- disable_MV_UL_l1_bot_fix
+// Bit 2 -- disable_mb_aff_fix
+// Bit 1 -- canvas_addr_7
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define   HEVC_IQIDCT_CONTROL                      (0x3e0e)
+#define P_HEVC_IQIDCT_CONTROL                      (volatile unsigned int *)((0x3e0e  << 2) + 0xff620000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define   HEVC_IQIDCT_DEBUG_INFO_0                 (0x3e0f)
+#define P_HEVC_IQIDCT_DEBUG_INFO_0                 (volatile unsigned int *)((0x3e0f  << 2) + 0xff620000)
+// For RTL Simulation Only
+#define   HEVC_DEBLK_CMD                           (0x3e10)
+#define P_HEVC_DEBLK_CMD                           (volatile unsigned int *)((0x3e10  << 2) + 0xff620000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define   HEVC_IQIDCT_DEBUG_IDCT                   (0x3e11)
+#define P_HEVC_IQIDCT_DEBUG_IDCT                   (volatile unsigned int *)((0x3e11  << 2) + 0xff620000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_read_cache_active
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define   HEVC_DCAC_DMA_CTRL                       (0x3e12)
+#define P_HEVC_DCAC_DMA_CTRL                       (volatile unsigned int *)((0x3e12  << 2) + 0xff620000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define   HEVC_DCAC_DMA_ADDRESS                    (0x3e13)
+#define P_HEVC_DCAC_DMA_ADDRESS                    (volatile unsigned int *)((0x3e13  << 2) + 0xff620000)
+// bit 7:0 -- dcac_cpu_addr
+#define   HEVC_DCAC_CPU_ADDRESS                    (0x3e14)
+#define P_HEVC_DCAC_CPU_ADDRESS                    (volatile unsigned int *)((0x3e14  << 2) + 0xff620000)
+// bit 31:0 -- dcac_cpu_data
+#define   HEVC_DCAC_CPU_DATA                       (0x3e15)
+#define P_HEVC_DCAC_CPU_DATA                       (volatile unsigned int *)((0x3e15  << 2) + 0xff620000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only
+// bit 15:0 -- dcac_mb_count
+#define   HEVC_DCAC_MB_COUNT                       (0x3e16)
+#define P_HEVC_DCAC_MB_COUNT                       (volatile unsigned int *)((0x3e16  << 2) + 0xff620000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant
+//   bit 11:6 -- h264_quant_c
+//   bit  5:0 -- h264_quant_c
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode
+//   bit 11:6  -- AltPQuant
+//   bit  5:0  -- PQuant
+//
+#define   HEVC_IQ_QUANT                            (0x3e17)
+#define P_HEVC_IQ_QUANT                            (volatile unsigned int *)((0x3e17  << 2) + 0xff620000)
+// bit 31:24  -- bitplane_width
+// bit 23:16  -- bitplane_height
+// bit 15:14  -- bitplane_start_x
+// bit 13:12  -- bitplane_start_y
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define   HEVC_VC1_BITPLANE_CTL                    (0x3e18)
+#define P_HEVC_VC1_BITPLANE_CTL                    (volatile unsigned int *)((0x3e18  << 2) + 0xff620000)
+// bit 24:16  -- wq_param1
+// bit  8: 0  -- wq_param0
+#define   HEVC_AVSP_IQ_WQ_PARAM_01                 (0x3e19)
+#define P_HEVC_AVSP_IQ_WQ_PARAM_01                 (volatile unsigned int *)((0x3e19  << 2) + 0xff620000)
+// bit 24:16  -- wq_param3
+// bit  8: 0  -- wq_param2
+#define   HEVC_AVSP_IQ_WQ_PARAM_23                 (0x3e1a)
+#define P_HEVC_AVSP_IQ_WQ_PARAM_23                 (volatile unsigned int *)((0x3e1a  << 2) + 0xff620000)
+// bit 24:16  -- wq_param5
+// bit  8: 0  -- wq_param4
+#define   HEVC_AVSP_IQ_WQ_PARAM_45                 (0x3e1b)
+#define P_HEVC_AVSP_IQ_WQ_PARAM_45                 (volatile unsigned int *)((0x3e1b  << 2) + 0xff620000)
+// bit    31  -- weight_quant_en
+// bit 17:16  -- current_scene_model
+// bit 12: 8  -- chroma_qp_delta_cr
+// bit  4: 0  -- chroma_qp_delta_cb
+#define   HEVC_AVSP_IQ_CTL                         (0x3e1c)
+#define P_HEVC_AVSP_IQ_CTL                         (volatile unsigned int *)((0x3e1c  << 2) + 0xff620000)
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define   HCODEC_MSP                               (0x1300)
+#define P_HCODEC_MSP                               (volatile unsigned int *)((0x1300  << 2) + 0xff620000)
+#define   HCODEC_MPSR                              (0x1301)
+#define P_HCODEC_MPSR                              (volatile unsigned int *)((0x1301  << 2) + 0xff620000)
+#define   HCODEC_MINT_VEC_BASE                     (0x1302)
+#define P_HCODEC_MINT_VEC_BASE                     (volatile unsigned int *)((0x1302  << 2) + 0xff620000)
+#define   HCODEC_MCPU_INTR_GRP                     (0x1303)
+#define P_HCODEC_MCPU_INTR_GRP                     (volatile unsigned int *)((0x1303  << 2) + 0xff620000)
+#define   HCODEC_MCPU_INTR_MSK                     (0x1304)
+#define P_HCODEC_MCPU_INTR_MSK                     (volatile unsigned int *)((0x1304  << 2) + 0xff620000)
+#define   HCODEC_MCPU_INTR_REQ                     (0x1305)
+#define P_HCODEC_MCPU_INTR_REQ                     (volatile unsigned int *)((0x1305  << 2) + 0xff620000)
+#define   HCODEC_MPC_P                             (0x1306)
+#define P_HCODEC_MPC_P                             (volatile unsigned int *)((0x1306  << 2) + 0xff620000)
+#define   HCODEC_MPC_D                             (0x1307)
+#define P_HCODEC_MPC_D                             (volatile unsigned int *)((0x1307  << 2) + 0xff620000)
+#define   HCODEC_MPC_E                             (0x1308)
+#define P_HCODEC_MPC_E                             (volatile unsigned int *)((0x1308  << 2) + 0xff620000)
+#define   HCODEC_MPC_W                             (0x1309)
+#define P_HCODEC_MPC_W                             (volatile unsigned int *)((0x1309  << 2) + 0xff620000)
+#define   HCODEC_MINDEX0_REG                       (0x130a)
+#define P_HCODEC_MINDEX0_REG                       (volatile unsigned int *)((0x130a  << 2) + 0xff620000)
+#define   HCODEC_MINDEX1_REG                       (0x130b)
+#define P_HCODEC_MINDEX1_REG                       (volatile unsigned int *)((0x130b  << 2) + 0xff620000)
+#define   HCODEC_MINDEX2_REG                       (0x130c)
+#define P_HCODEC_MINDEX2_REG                       (volatile unsigned int *)((0x130c  << 2) + 0xff620000)
+#define   HCODEC_MINDEX3_REG                       (0x130d)
+#define P_HCODEC_MINDEX3_REG                       (volatile unsigned int *)((0x130d  << 2) + 0xff620000)
+#define   HCODEC_MINDEX4_REG                       (0x130e)
+#define P_HCODEC_MINDEX4_REG                       (volatile unsigned int *)((0x130e  << 2) + 0xff620000)
+#define   HCODEC_MINDEX5_REG                       (0x130f)
+#define P_HCODEC_MINDEX5_REG                       (volatile unsigned int *)((0x130f  << 2) + 0xff620000)
+#define   HCODEC_MINDEX6_REG                       (0x1310)
+#define P_HCODEC_MINDEX6_REG                       (volatile unsigned int *)((0x1310  << 2) + 0xff620000)
+#define   HCODEC_MINDEX7_REG                       (0x1311)
+#define P_HCODEC_MINDEX7_REG                       (volatile unsigned int *)((0x1311  << 2) + 0xff620000)
+#define   HCODEC_MMIN_REG                          (0x1312)
+#define P_HCODEC_MMIN_REG                          (volatile unsigned int *)((0x1312  << 2) + 0xff620000)
+#define   HCODEC_MMAX_REG                          (0x1313)
+#define P_HCODEC_MMAX_REG                          (volatile unsigned int *)((0x1313  << 2) + 0xff620000)
+#define   HCODEC_MBREAK0_REG                       (0x1314)
+#define P_HCODEC_MBREAK0_REG                       (volatile unsigned int *)((0x1314  << 2) + 0xff620000)
+#define   HCODEC_MBREAK1_REG                       (0x1315)
+#define P_HCODEC_MBREAK1_REG                       (volatile unsigned int *)((0x1315  << 2) + 0xff620000)
+#define   HCODEC_MBREAK2_REG                       (0x1316)
+#define P_HCODEC_MBREAK2_REG                       (volatile unsigned int *)((0x1316  << 2) + 0xff620000)
+#define   HCODEC_MBREAK3_REG                       (0x1317)
+#define P_HCODEC_MBREAK3_REG                       (volatile unsigned int *)((0x1317  << 2) + 0xff620000)
+#define   HCODEC_MBREAK_TYPE                       (0x1318)
+#define P_HCODEC_MBREAK_TYPE                       (volatile unsigned int *)((0x1318  << 2) + 0xff620000)
+#define   HCODEC_MBREAK_CTRL                       (0x1319)
+#define P_HCODEC_MBREAK_CTRL                       (volatile unsigned int *)((0x1319  << 2) + 0xff620000)
+#define   HCODEC_MBREAK_STAUTS                     (0x131a)
+#define P_HCODEC_MBREAK_STAUTS                     (volatile unsigned int *)((0x131a  << 2) + 0xff620000)
+#define   HCODEC_MDB_ADDR_REG                      (0x131b)
+#define P_HCODEC_MDB_ADDR_REG                      (volatile unsigned int *)((0x131b  << 2) + 0xff620000)
+#define   HCODEC_MDB_DATA_REG                      (0x131c)
+#define P_HCODEC_MDB_DATA_REG                      (volatile unsigned int *)((0x131c  << 2) + 0xff620000)
+#define   HCODEC_MDB_CTRL                          (0x131d)
+#define P_HCODEC_MDB_CTRL                          (volatile unsigned int *)((0x131d  << 2) + 0xff620000)
+#define   HCODEC_MSFTINT0                          (0x131e)
+#define P_HCODEC_MSFTINT0                          (volatile unsigned int *)((0x131e  << 2) + 0xff620000)
+#define   HCODEC_MSFTINT1                          (0x131f)
+#define P_HCODEC_MSFTINT1                          (volatile unsigned int *)((0x131f  << 2) + 0xff620000)
+#define   HCODEC_CSP                               (0x1320)
+#define P_HCODEC_CSP                               (volatile unsigned int *)((0x1320  << 2) + 0xff620000)
+#define   HCODEC_CPSR                              (0x1321)
+#define P_HCODEC_CPSR                              (volatile unsigned int *)((0x1321  << 2) + 0xff620000)
+#define   HCODEC_CINT_VEC_BASE                     (0x1322)
+#define P_HCODEC_CINT_VEC_BASE                     (volatile unsigned int *)((0x1322  << 2) + 0xff620000)
+#define   HCODEC_CCPU_INTR_GRP                     (0x1323)
+#define P_HCODEC_CCPU_INTR_GRP                     (volatile unsigned int *)((0x1323  << 2) + 0xff620000)
+#define   HCODEC_CCPU_INTR_MSK                     (0x1324)
+#define P_HCODEC_CCPU_INTR_MSK                     (volatile unsigned int *)((0x1324  << 2) + 0xff620000)
+#define   HCODEC_CCPU_INTR_REQ                     (0x1325)
+#define P_HCODEC_CCPU_INTR_REQ                     (volatile unsigned int *)((0x1325  << 2) + 0xff620000)
+#define   HCODEC_CPC_P                             (0x1326)
+#define P_HCODEC_CPC_P                             (volatile unsigned int *)((0x1326  << 2) + 0xff620000)
+#define   HCODEC_CPC_D                             (0x1327)
+#define P_HCODEC_CPC_D                             (volatile unsigned int *)((0x1327  << 2) + 0xff620000)
+#define   HCODEC_CPC_E                             (0x1328)
+#define P_HCODEC_CPC_E                             (volatile unsigned int *)((0x1328  << 2) + 0xff620000)
+#define   HCODEC_CPC_W                             (0x1329)
+#define P_HCODEC_CPC_W                             (volatile unsigned int *)((0x1329  << 2) + 0xff620000)
+#define   HCODEC_CINDEX0_REG                       (0x132a)
+#define P_HCODEC_CINDEX0_REG                       (volatile unsigned int *)((0x132a  << 2) + 0xff620000)
+#define   HCODEC_CINDEX1_REG                       (0x132b)
+#define P_HCODEC_CINDEX1_REG                       (volatile unsigned int *)((0x132b  << 2) + 0xff620000)
+#define   HCODEC_CINDEX2_REG                       (0x132c)
+#define P_HCODEC_CINDEX2_REG                       (volatile unsigned int *)((0x132c  << 2) + 0xff620000)
+#define   HCODEC_CINDEX3_REG                       (0x132d)
+#define P_HCODEC_CINDEX3_REG                       (volatile unsigned int *)((0x132d  << 2) + 0xff620000)
+#define   HCODEC_CINDEX4_REG                       (0x132e)
+#define P_HCODEC_CINDEX4_REG                       (volatile unsigned int *)((0x132e  << 2) + 0xff620000)
+#define   HCODEC_CINDEX5_REG                       (0x132f)
+#define P_HCODEC_CINDEX5_REG                       (volatile unsigned int *)((0x132f  << 2) + 0xff620000)
+#define   HCODEC_CINDEX6_REG                       (0x1330)
+#define P_HCODEC_CINDEX6_REG                       (volatile unsigned int *)((0x1330  << 2) + 0xff620000)
+#define   HCODEC_CINDEX7_REG                       (0x1331)
+#define P_HCODEC_CINDEX7_REG                       (volatile unsigned int *)((0x1331  << 2) + 0xff620000)
+#define   HCODEC_CMIN_REG                          (0x1332)
+#define P_HCODEC_CMIN_REG                          (volatile unsigned int *)((0x1332  << 2) + 0xff620000)
+#define   HCODEC_CMAX_REG                          (0x1333)
+#define P_HCODEC_CMAX_REG                          (volatile unsigned int *)((0x1333  << 2) + 0xff620000)
+#define   HCODEC_CBREAK0_REG                       (0x1334)
+#define P_HCODEC_CBREAK0_REG                       (volatile unsigned int *)((0x1334  << 2) + 0xff620000)
+#define   HCODEC_CBREAK1_REG                       (0x1335)
+#define P_HCODEC_CBREAK1_REG                       (volatile unsigned int *)((0x1335  << 2) + 0xff620000)
+#define   HCODEC_CBREAK2_REG                       (0x1336)
+#define P_HCODEC_CBREAK2_REG                       (volatile unsigned int *)((0x1336  << 2) + 0xff620000)
+#define   HCODEC_CBREAK3_REG                       (0x1337)
+#define P_HCODEC_CBREAK3_REG                       (volatile unsigned int *)((0x1337  << 2) + 0xff620000)
+#define   HCODEC_CBREAK_TYPE                       (0x1338)
+#define P_HCODEC_CBREAK_TYPE                       (volatile unsigned int *)((0x1338  << 2) + 0xff620000)
+#define   HCODEC_CBREAK_CTRL                       (0x1339)
+#define P_HCODEC_CBREAK_CTRL                       (volatile unsigned int *)((0x1339  << 2) + 0xff620000)
+#define   HCODEC_CBREAK_STAUTS                     (0x133a)
+#define P_HCODEC_CBREAK_STAUTS                     (volatile unsigned int *)((0x133a  << 2) + 0xff620000)
+#define   HCODEC_CDB_ADDR_REG                      (0x133b)
+#define P_HCODEC_CDB_ADDR_REG                      (volatile unsigned int *)((0x133b  << 2) + 0xff620000)
+#define   HCODEC_CDB_DATA_REG                      (0x133c)
+#define P_HCODEC_CDB_DATA_REG                      (volatile unsigned int *)((0x133c  << 2) + 0xff620000)
+#define   HCODEC_CDB_CTRL                          (0x133d)
+#define P_HCODEC_CDB_CTRL                          (volatile unsigned int *)((0x133d  << 2) + 0xff620000)
+#define   HCODEC_CSFTINT0                          (0x133e)
+#define P_HCODEC_CSFTINT0                          (volatile unsigned int *)((0x133e  << 2) + 0xff620000)
+#define   HCODEC_CSFTINT1                          (0x133f)
+#define P_HCODEC_CSFTINT1                          (volatile unsigned int *)((0x133f  << 2) + 0xff620000)
+#define   HCODEC_IMEM_DMA_CTRL                     (0x1340)
+#define P_HCODEC_IMEM_DMA_CTRL                     (volatile unsigned int *)((0x1340  << 2) + 0xff620000)
+#define   HCODEC_IMEM_DMA_ADR                      (0x1341)
+#define P_HCODEC_IMEM_DMA_ADR                      (volatile unsigned int *)((0x1341  << 2) + 0xff620000)
+#define   HCODEC_IMEM_DMA_COUNT                    (0x1342)
+#define P_HCODEC_IMEM_DMA_COUNT                    (volatile unsigned int *)((0x1342  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define   HCODEC_WRRSP_IMEM                        (0x1343)
+#define P_HCODEC_WRRSP_IMEM                        (volatile unsigned int *)((0x1343  << 2) + 0xff620000)
+#define   HCODEC_LMEM_DMA_CTRL                     (0x1350)
+#define P_HCODEC_LMEM_DMA_CTRL                     (volatile unsigned int *)((0x1350  << 2) + 0xff620000)
+#define   HCODEC_LMEM_DMA_ADR                      (0x1351)
+#define P_HCODEC_LMEM_DMA_ADR                      (volatile unsigned int *)((0x1351  << 2) + 0xff620000)
+#define   HCODEC_LMEM_DMA_COUNT                    (0x1352)
+#define P_HCODEC_LMEM_DMA_COUNT                    (volatile unsigned int *)((0x1352  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem
+#define   HCODEC_WRRSP_LMEM                        (0x1353)
+#define P_HCODEC_WRRSP_LMEM                        (volatile unsigned int *)((0x1353  << 2) + 0xff620000)
+#define   HCODEC_MAC_CTRL1                         (0x1360)
+#define P_HCODEC_MAC_CTRL1                         (volatile unsigned int *)((0x1360  << 2) + 0xff620000)
+#define   HCODEC_ACC0REG1                          (0x1361)
+#define P_HCODEC_ACC0REG1                          (volatile unsigned int *)((0x1361  << 2) + 0xff620000)
+#define   HCODEC_ACC1REG1                          (0x1362)
+#define P_HCODEC_ACC1REG1                          (volatile unsigned int *)((0x1362  << 2) + 0xff620000)
+#define   HCODEC_MAC_CTRL2                         (0x1370)
+#define P_HCODEC_MAC_CTRL2                         (volatile unsigned int *)((0x1370  << 2) + 0xff620000)
+#define   HCODEC_ACC0REG2                          (0x1371)
+#define P_HCODEC_ACC0REG2                          (volatile unsigned int *)((0x1371  << 2) + 0xff620000)
+#define   HCODEC_ACC1REG2                          (0x1372)
+#define P_HCODEC_ACC1REG2                          (volatile unsigned int *)((0x1372  << 2) + 0xff620000)
+#define   HCODEC_CPU_TRACE                         (0x1380)
+#define P_HCODEC_CPU_TRACE                         (volatile unsigned int *)((0x1380  << 2) + 0xff620000)
+//
+// Closing file:  vcpu_regs.h
+//
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define   VDEC2_MSP                                (0x2300)
+#define P_VDEC2_MSP                                (volatile unsigned int *)((0x2300  << 2) + 0xff620000)
+#define   VDEC2_MPSR                               (0x2301)
+#define P_VDEC2_MPSR                               (volatile unsigned int *)((0x2301  << 2) + 0xff620000)
+#define   VDEC2_MINT_VEC_BASE                      (0x2302)
+#define P_VDEC2_MINT_VEC_BASE                      (volatile unsigned int *)((0x2302  << 2) + 0xff620000)
+#define   VDEC2_MCPU_INTR_GRP                      (0x2303)
+#define P_VDEC2_MCPU_INTR_GRP                      (volatile unsigned int *)((0x2303  << 2) + 0xff620000)
+#define   VDEC2_MCPU_INTR_MSK                      (0x2304)
+#define P_VDEC2_MCPU_INTR_MSK                      (volatile unsigned int *)((0x2304  << 2) + 0xff620000)
+#define   VDEC2_MCPU_INTR_REQ                      (0x2305)
+#define P_VDEC2_MCPU_INTR_REQ                      (volatile unsigned int *)((0x2305  << 2) + 0xff620000)
+#define   VDEC2_MPC_P                              (0x2306)
+#define P_VDEC2_MPC_P                              (volatile unsigned int *)((0x2306  << 2) + 0xff620000)
+#define   VDEC2_MPC_D                              (0x2307)
+#define P_VDEC2_MPC_D                              (volatile unsigned int *)((0x2307  << 2) + 0xff620000)
+#define   VDEC2_MPC_E                              (0x2308)
+#define P_VDEC2_MPC_E                              (volatile unsigned int *)((0x2308  << 2) + 0xff620000)
+#define   VDEC2_MPC_W                              (0x2309)
+#define P_VDEC2_MPC_W                              (volatile unsigned int *)((0x2309  << 2) + 0xff620000)
+#define   VDEC2_MINDEX0_REG                        (0x230a)
+#define P_VDEC2_MINDEX0_REG                        (volatile unsigned int *)((0x230a  << 2) + 0xff620000)
+#define   VDEC2_MINDEX1_REG                        (0x230b)
+#define P_VDEC2_MINDEX1_REG                        (volatile unsigned int *)((0x230b  << 2) + 0xff620000)
+#define   VDEC2_MINDEX2_REG                        (0x230c)
+#define P_VDEC2_MINDEX2_REG                        (volatile unsigned int *)((0x230c  << 2) + 0xff620000)
+#define   VDEC2_MINDEX3_REG                        (0x230d)
+#define P_VDEC2_MINDEX3_REG                        (volatile unsigned int *)((0x230d  << 2) + 0xff620000)
+#define   VDEC2_MINDEX4_REG                        (0x230e)
+#define P_VDEC2_MINDEX4_REG                        (volatile unsigned int *)((0x230e  << 2) + 0xff620000)
+#define   VDEC2_MINDEX5_REG                        (0x230f)
+#define P_VDEC2_MINDEX5_REG                        (volatile unsigned int *)((0x230f  << 2) + 0xff620000)
+#define   VDEC2_MINDEX6_REG                        (0x2310)
+#define P_VDEC2_MINDEX6_REG                        (volatile unsigned int *)((0x2310  << 2) + 0xff620000)
+#define   VDEC2_MINDEX7_REG                        (0x2311)
+#define P_VDEC2_MINDEX7_REG                        (volatile unsigned int *)((0x2311  << 2) + 0xff620000)
+#define   VDEC2_MMIN_REG                           (0x2312)
+#define P_VDEC2_MMIN_REG                           (volatile unsigned int *)((0x2312  << 2) + 0xff620000)
+#define   VDEC2_MMAX_REG                           (0x2313)
+#define P_VDEC2_MMAX_REG                           (volatile unsigned int *)((0x2313  << 2) + 0xff620000)
+#define   VDEC2_MBREAK0_REG                        (0x2314)
+#define P_VDEC2_MBREAK0_REG                        (volatile unsigned int *)((0x2314  << 2) + 0xff620000)
+#define   VDEC2_MBREAK1_REG                        (0x2315)
+#define P_VDEC2_MBREAK1_REG                        (volatile unsigned int *)((0x2315  << 2) + 0xff620000)
+#define   VDEC2_MBREAK2_REG                        (0x2316)
+#define P_VDEC2_MBREAK2_REG                        (volatile unsigned int *)((0x2316  << 2) + 0xff620000)
+#define   VDEC2_MBREAK3_REG                        (0x2317)
+#define P_VDEC2_MBREAK3_REG                        (volatile unsigned int *)((0x2317  << 2) + 0xff620000)
+#define   VDEC2_MBREAK_TYPE                        (0x2318)
+#define P_VDEC2_MBREAK_TYPE                        (volatile unsigned int *)((0x2318  << 2) + 0xff620000)
+#define   VDEC2_MBREAK_CTRL                        (0x2319)
+#define P_VDEC2_MBREAK_CTRL                        (volatile unsigned int *)((0x2319  << 2) + 0xff620000)
+#define   VDEC2_MBREAK_STAUTS                      (0x231a)
+#define P_VDEC2_MBREAK_STAUTS                      (volatile unsigned int *)((0x231a  << 2) + 0xff620000)
+#define   VDEC2_MDB_ADDR_REG                       (0x231b)
+#define P_VDEC2_MDB_ADDR_REG                       (volatile unsigned int *)((0x231b  << 2) + 0xff620000)
+#define   VDEC2_MDB_DATA_REG                       (0x231c)
+#define P_VDEC2_MDB_DATA_REG                       (volatile unsigned int *)((0x231c  << 2) + 0xff620000)
+#define   VDEC2_MDB_CTRL                           (0x231d)
+#define P_VDEC2_MDB_CTRL                           (volatile unsigned int *)((0x231d  << 2) + 0xff620000)
+#define   VDEC2_MSFTINT0                           (0x231e)
+#define P_VDEC2_MSFTINT0                           (volatile unsigned int *)((0x231e  << 2) + 0xff620000)
+#define   VDEC2_MSFTINT1                           (0x231f)
+#define P_VDEC2_MSFTINT1                           (volatile unsigned int *)((0x231f  << 2) + 0xff620000)
+#define   VDEC2_CSP                                (0x2320)
+#define P_VDEC2_CSP                                (volatile unsigned int *)((0x2320  << 2) + 0xff620000)
+#define   VDEC2_CPSR                               (0x2321)
+#define P_VDEC2_CPSR                               (volatile unsigned int *)((0x2321  << 2) + 0xff620000)
+#define   VDEC2_CINT_VEC_BASE                      (0x2322)
+#define P_VDEC2_CINT_VEC_BASE                      (volatile unsigned int *)((0x2322  << 2) + 0xff620000)
+#define   VDEC2_CCPU_INTR_GRP                      (0x2323)
+#define P_VDEC2_CCPU_INTR_GRP                      (volatile unsigned int *)((0x2323  << 2) + 0xff620000)
+#define   VDEC2_CCPU_INTR_MSK                      (0x2324)
+#define P_VDEC2_CCPU_INTR_MSK                      (volatile unsigned int *)((0x2324  << 2) + 0xff620000)
+#define   VDEC2_CCPU_INTR_REQ                      (0x2325)
+#define P_VDEC2_CCPU_INTR_REQ                      (volatile unsigned int *)((0x2325  << 2) + 0xff620000)
+#define   VDEC2_CPC_P                              (0x2326)
+#define P_VDEC2_CPC_P                              (volatile unsigned int *)((0x2326  << 2) + 0xff620000)
+#define   VDEC2_CPC_D                              (0x2327)
+#define P_VDEC2_CPC_D                              (volatile unsigned int *)((0x2327  << 2) + 0xff620000)
+#define   VDEC2_CPC_E                              (0x2328)
+#define P_VDEC2_CPC_E                              (volatile unsigned int *)((0x2328  << 2) + 0xff620000)
+#define   VDEC2_CPC_W                              (0x2329)
+#define P_VDEC2_CPC_W                              (volatile unsigned int *)((0x2329  << 2) + 0xff620000)
+#define   VDEC2_CINDEX0_REG                        (0x232a)
+#define P_VDEC2_CINDEX0_REG                        (volatile unsigned int *)((0x232a  << 2) + 0xff620000)
+#define   VDEC2_CINDEX1_REG                        (0x232b)
+#define P_VDEC2_CINDEX1_REG                        (volatile unsigned int *)((0x232b  << 2) + 0xff620000)
+#define   VDEC2_CINDEX2_REG                        (0x232c)
+#define P_VDEC2_CINDEX2_REG                        (volatile unsigned int *)((0x232c  << 2) + 0xff620000)
+#define   VDEC2_CINDEX3_REG                        (0x232d)
+#define P_VDEC2_CINDEX3_REG                        (volatile unsigned int *)((0x232d  << 2) + 0xff620000)
+#define   VDEC2_CINDEX4_REG                        (0x232e)
+#define P_VDEC2_CINDEX4_REG                        (volatile unsigned int *)((0x232e  << 2) + 0xff620000)
+#define   VDEC2_CINDEX5_REG                        (0x232f)
+#define P_VDEC2_CINDEX5_REG                        (volatile unsigned int *)((0x232f  << 2) + 0xff620000)
+#define   VDEC2_CINDEX6_REG                        (0x2330)
+#define P_VDEC2_CINDEX6_REG                        (volatile unsigned int *)((0x2330  << 2) + 0xff620000)
+#define   VDEC2_CINDEX7_REG                        (0x2331)
+#define P_VDEC2_CINDEX7_REG                        (volatile unsigned int *)((0x2331  << 2) + 0xff620000)
+#define   VDEC2_CMIN_REG                           (0x2332)
+#define P_VDEC2_CMIN_REG                           (volatile unsigned int *)((0x2332  << 2) + 0xff620000)
+#define   VDEC2_CMAX_REG                           (0x2333)
+#define P_VDEC2_CMAX_REG                           (volatile unsigned int *)((0x2333  << 2) + 0xff620000)
+#define   VDEC2_CBREAK0_REG                        (0x2334)
+#define P_VDEC2_CBREAK0_REG                        (volatile unsigned int *)((0x2334  << 2) + 0xff620000)
+#define   VDEC2_CBREAK1_REG                        (0x2335)
+#define P_VDEC2_CBREAK1_REG                        (volatile unsigned int *)((0x2335  << 2) + 0xff620000)
+#define   VDEC2_CBREAK2_REG                        (0x2336)
+#define P_VDEC2_CBREAK2_REG                        (volatile unsigned int *)((0x2336  << 2) + 0xff620000)
+#define   VDEC2_CBREAK3_REG                        (0x2337)
+#define P_VDEC2_CBREAK3_REG                        (volatile unsigned int *)((0x2337  << 2) + 0xff620000)
+#define   VDEC2_CBREAK_TYPE                        (0x2338)
+#define P_VDEC2_CBREAK_TYPE                        (volatile unsigned int *)((0x2338  << 2) + 0xff620000)
+#define   VDEC2_CBREAK_CTRL                        (0x2339)
+#define P_VDEC2_CBREAK_CTRL                        (volatile unsigned int *)((0x2339  << 2) + 0xff620000)
+#define   VDEC2_CBREAK_STAUTS                      (0x233a)
+#define P_VDEC2_CBREAK_STAUTS                      (volatile unsigned int *)((0x233a  << 2) + 0xff620000)
+#define   VDEC2_CDB_ADDR_REG                       (0x233b)
+#define P_VDEC2_CDB_ADDR_REG                       (volatile unsigned int *)((0x233b  << 2) + 0xff620000)
+#define   VDEC2_CDB_DATA_REG                       (0x233c)
+#define P_VDEC2_CDB_DATA_REG                       (volatile unsigned int *)((0x233c  << 2) + 0xff620000)
+#define   VDEC2_CDB_CTRL                           (0x233d)
+#define P_VDEC2_CDB_CTRL                           (volatile unsigned int *)((0x233d  << 2) + 0xff620000)
+#define   VDEC2_CSFTINT0                           (0x233e)
+#define P_VDEC2_CSFTINT0                           (volatile unsigned int *)((0x233e  << 2) + 0xff620000)
+#define   VDEC2_CSFTINT1                           (0x233f)
+#define P_VDEC2_CSFTINT1                           (volatile unsigned int *)((0x233f  << 2) + 0xff620000)
+#define   VDEC2_IMEM_DMA_CTRL                      (0x2340)
+#define P_VDEC2_IMEM_DMA_CTRL                      (volatile unsigned int *)((0x2340  << 2) + 0xff620000)
+#define   VDEC2_IMEM_DMA_ADR                       (0x2341)
+#define P_VDEC2_IMEM_DMA_ADR                       (volatile unsigned int *)((0x2341  << 2) + 0xff620000)
+#define   VDEC2_IMEM_DMA_COUNT                     (0x2342)
+#define P_VDEC2_IMEM_DMA_COUNT                     (volatile unsigned int *)((0x2342  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define   VDEC2_WRRSP_IMEM                         (0x2343)
+#define P_VDEC2_WRRSP_IMEM                         (volatile unsigned int *)((0x2343  << 2) + 0xff620000)
+#define   VDEC2_LMEM_DMA_CTRL                      (0x2350)
+#define P_VDEC2_LMEM_DMA_CTRL                      (volatile unsigned int *)((0x2350  << 2) + 0xff620000)
+#define   VDEC2_LMEM_DMA_ADR                       (0x2351)
+#define P_VDEC2_LMEM_DMA_ADR                       (volatile unsigned int *)((0x2351  << 2) + 0xff620000)
+#define   VDEC2_LMEM_DMA_COUNT                     (0x2352)
+#define P_VDEC2_LMEM_DMA_COUNT                     (volatile unsigned int *)((0x2352  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem
+#define   VDEC2_WRRSP_LMEM                         (0x2353)
+#define P_VDEC2_WRRSP_LMEM                         (volatile unsigned int *)((0x2353  << 2) + 0xff620000)
+#define   VDEC2_MAC_CTRL1                          (0x2360)
+#define P_VDEC2_MAC_CTRL1                          (volatile unsigned int *)((0x2360  << 2) + 0xff620000)
+#define   VDEC2_ACC0REG1                           (0x2361)
+#define P_VDEC2_ACC0REG1                           (volatile unsigned int *)((0x2361  << 2) + 0xff620000)
+#define   VDEC2_ACC1REG1                           (0x2362)
+#define P_VDEC2_ACC1REG1                           (volatile unsigned int *)((0x2362  << 2) + 0xff620000)
+#define   VDEC2_MAC_CTRL2                          (0x2370)
+#define P_VDEC2_MAC_CTRL2                          (volatile unsigned int *)((0x2370  << 2) + 0xff620000)
+#define   VDEC2_ACC0REG2                           (0x2371)
+#define P_VDEC2_ACC0REG2                           (volatile unsigned int *)((0x2371  << 2) + 0xff620000)
+#define   VDEC2_ACC1REG2                           (0x2372)
+#define P_VDEC2_ACC1REG2                           (volatile unsigned int *)((0x2372  << 2) + 0xff620000)
+#define   VDEC2_CPU_TRACE                          (0x2380)
+#define P_VDEC2_CPU_TRACE                          (volatile unsigned int *)((0x2380  << 2) + 0xff620000)
+//
+// Closing file:  vcpu_regs.h
+//
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define   HEVC_MSP                                 (0x3300)
+#define P_HEVC_MSP                                 (volatile unsigned int *)((0x3300  << 2) + 0xff620000)
+#define   HEVC_MPSR                                (0x3301)
+#define P_HEVC_MPSR                                (volatile unsigned int *)((0x3301  << 2) + 0xff620000)
+#define   HEVC_MINT_VEC_BASE                       (0x3302)
+#define P_HEVC_MINT_VEC_BASE                       (volatile unsigned int *)((0x3302  << 2) + 0xff620000)
+#define   HEVC_MCPU_INTR_GRP                       (0x3303)
+#define P_HEVC_MCPU_INTR_GRP                       (volatile unsigned int *)((0x3303  << 2) + 0xff620000)
+#define   HEVC_MCPU_INTR_MSK                       (0x3304)
+#define P_HEVC_MCPU_INTR_MSK                       (volatile unsigned int *)((0x3304  << 2) + 0xff620000)
+#define   HEVC_MCPU_INTR_REQ                       (0x3305)
+#define P_HEVC_MCPU_INTR_REQ                       (volatile unsigned int *)((0x3305  << 2) + 0xff620000)
+#define   HEVC_MPC_P                               (0x3306)
+#define P_HEVC_MPC_P                               (volatile unsigned int *)((0x3306  << 2) + 0xff620000)
+#define   HEVC_MPC_D                               (0x3307)
+#define P_HEVC_MPC_D                               (volatile unsigned int *)((0x3307  << 2) + 0xff620000)
+#define   HEVC_MPC_E                               (0x3308)
+#define P_HEVC_MPC_E                               (volatile unsigned int *)((0x3308  << 2) + 0xff620000)
+#define   HEVC_MPC_W                               (0x3309)
+#define P_HEVC_MPC_W                               (volatile unsigned int *)((0x3309  << 2) + 0xff620000)
+#define   HEVC_MINDEX0_REG                         (0x330a)
+#define P_HEVC_MINDEX0_REG                         (volatile unsigned int *)((0x330a  << 2) + 0xff620000)
+#define   HEVC_MINDEX1_REG                         (0x330b)
+#define P_HEVC_MINDEX1_REG                         (volatile unsigned int *)((0x330b  << 2) + 0xff620000)
+#define   HEVC_MINDEX2_REG                         (0x330c)
+#define P_HEVC_MINDEX2_REG                         (volatile unsigned int *)((0x330c  << 2) + 0xff620000)
+#define   HEVC_MINDEX3_REG                         (0x330d)
+#define P_HEVC_MINDEX3_REG                         (volatile unsigned int *)((0x330d  << 2) + 0xff620000)
+#define   HEVC_MINDEX4_REG                         (0x330e)
+#define P_HEVC_MINDEX4_REG                         (volatile unsigned int *)((0x330e  << 2) + 0xff620000)
+#define   HEVC_MINDEX5_REG                         (0x330f)
+#define P_HEVC_MINDEX5_REG                         (volatile unsigned int *)((0x330f  << 2) + 0xff620000)
+#define   HEVC_MINDEX6_REG                         (0x3310)
+#define P_HEVC_MINDEX6_REG                         (volatile unsigned int *)((0x3310  << 2) + 0xff620000)
+#define   HEVC_MINDEX7_REG                         (0x3311)
+#define P_HEVC_MINDEX7_REG                         (volatile unsigned int *)((0x3311  << 2) + 0xff620000)
+#define   HEVC_MMIN_REG                            (0x3312)
+#define P_HEVC_MMIN_REG                            (volatile unsigned int *)((0x3312  << 2) + 0xff620000)
+#define   HEVC_MMAX_REG                            (0x3313)
+#define P_HEVC_MMAX_REG                            (volatile unsigned int *)((0x3313  << 2) + 0xff620000)
+#define   HEVC_MBREAK0_REG                         (0x3314)
+#define P_HEVC_MBREAK0_REG                         (volatile unsigned int *)((0x3314  << 2) + 0xff620000)
+#define   HEVC_MBREAK1_REG                         (0x3315)
+#define P_HEVC_MBREAK1_REG                         (volatile unsigned int *)((0x3315  << 2) + 0xff620000)
+#define   HEVC_MBREAK2_REG                         (0x3316)
+#define P_HEVC_MBREAK2_REG                         (volatile unsigned int *)((0x3316  << 2) + 0xff620000)
+#define   HEVC_MBREAK3_REG                         (0x3317)
+#define P_HEVC_MBREAK3_REG                         (volatile unsigned int *)((0x3317  << 2) + 0xff620000)
+#define   HEVC_MBREAK_TYPE                         (0x3318)
+#define P_HEVC_MBREAK_TYPE                         (volatile unsigned int *)((0x3318  << 2) + 0xff620000)
+#define   HEVC_MBREAK_CTRL                         (0x3319)
+#define P_HEVC_MBREAK_CTRL                         (volatile unsigned int *)((0x3319  << 2) + 0xff620000)
+#define   HEVC_MBREAK_STAUTS                       (0x331a)
+#define P_HEVC_MBREAK_STAUTS                       (volatile unsigned int *)((0x331a  << 2) + 0xff620000)
+#define   HEVC_MDB_ADDR_REG                        (0x331b)
+#define P_HEVC_MDB_ADDR_REG                        (volatile unsigned int *)((0x331b  << 2) + 0xff620000)
+#define   HEVC_MDB_DATA_REG                        (0x331c)
+#define P_HEVC_MDB_DATA_REG                        (volatile unsigned int *)((0x331c  << 2) + 0xff620000)
+#define   HEVC_MDB_CTRL                            (0x331d)
+#define P_HEVC_MDB_CTRL                            (volatile unsigned int *)((0x331d  << 2) + 0xff620000)
+#define   HEVC_MSFTINT0                            (0x331e)
+#define P_HEVC_MSFTINT0                            (volatile unsigned int *)((0x331e  << 2) + 0xff620000)
+#define   HEVC_MSFTINT1                            (0x331f)
+#define P_HEVC_MSFTINT1                            (volatile unsigned int *)((0x331f  << 2) + 0xff620000)
+#define   HEVC_CSP                                 (0x3320)
+#define P_HEVC_CSP                                 (volatile unsigned int *)((0x3320  << 2) + 0xff620000)
+#define   HEVC_CPSR                                (0x3321)
+#define P_HEVC_CPSR                                (volatile unsigned int *)((0x3321  << 2) + 0xff620000)
+#define   HEVC_CINT_VEC_BASE                       (0x3322)
+#define P_HEVC_CINT_VEC_BASE                       (volatile unsigned int *)((0x3322  << 2) + 0xff620000)
+#define   HEVC_CCPU_INTR_GRP                       (0x3323)
+#define P_HEVC_CCPU_INTR_GRP                       (volatile unsigned int *)((0x3323  << 2) + 0xff620000)
+#define   HEVC_CCPU_INTR_MSK                       (0x3324)
+#define P_HEVC_CCPU_INTR_MSK                       (volatile unsigned int *)((0x3324  << 2) + 0xff620000)
+#define   HEVC_CCPU_INTR_REQ                       (0x3325)
+#define P_HEVC_CCPU_INTR_REQ                       (volatile unsigned int *)((0x3325  << 2) + 0xff620000)
+#define   HEVC_CPC_P                               (0x3326)
+#define P_HEVC_CPC_P                               (volatile unsigned int *)((0x3326  << 2) + 0xff620000)
+#define   HEVC_CPC_D                               (0x3327)
+#define P_HEVC_CPC_D                               (volatile unsigned int *)((0x3327  << 2) + 0xff620000)
+#define   HEVC_CPC_E                               (0x3328)
+#define P_HEVC_CPC_E                               (volatile unsigned int *)((0x3328  << 2) + 0xff620000)
+#define   HEVC_CPC_W                               (0x3329)
+#define P_HEVC_CPC_W                               (volatile unsigned int *)((0x3329  << 2) + 0xff620000)
+#define   HEVC_CINDEX0_REG                         (0x332a)
+#define P_HEVC_CINDEX0_REG                         (volatile unsigned int *)((0x332a  << 2) + 0xff620000)
+#define   HEVC_CINDEX1_REG                         (0x332b)
+#define P_HEVC_CINDEX1_REG                         (volatile unsigned int *)((0x332b  << 2) + 0xff620000)
+#define   HEVC_CINDEX2_REG                         (0x332c)
+#define P_HEVC_CINDEX2_REG                         (volatile unsigned int *)((0x332c  << 2) + 0xff620000)
+#define   HEVC_CINDEX3_REG                         (0x332d)
+#define P_HEVC_CINDEX3_REG                         (volatile unsigned int *)((0x332d  << 2) + 0xff620000)
+#define   HEVC_CINDEX4_REG                         (0x332e)
+#define P_HEVC_CINDEX4_REG                         (volatile unsigned int *)((0x332e  << 2) + 0xff620000)
+#define   HEVC_CINDEX5_REG                         (0x332f)
+#define P_HEVC_CINDEX5_REG                         (volatile unsigned int *)((0x332f  << 2) + 0xff620000)
+#define   HEVC_CINDEX6_REG                         (0x3330)
+#define P_HEVC_CINDEX6_REG                         (volatile unsigned int *)((0x3330  << 2) + 0xff620000)
+#define   HEVC_CINDEX7_REG                         (0x3331)
+#define P_HEVC_CINDEX7_REG                         (volatile unsigned int *)((0x3331  << 2) + 0xff620000)
+#define   HEVC_CMIN_REG                            (0x3332)
+#define P_HEVC_CMIN_REG                            (volatile unsigned int *)((0x3332  << 2) + 0xff620000)
+#define   HEVC_CMAX_REG                            (0x3333)
+#define P_HEVC_CMAX_REG                            (volatile unsigned int *)((0x3333  << 2) + 0xff620000)
+#define   HEVC_CBREAK0_REG                         (0x3334)
+#define P_HEVC_CBREAK0_REG                         (volatile unsigned int *)((0x3334  << 2) + 0xff620000)
+#define   HEVC_CBREAK1_REG                         (0x3335)
+#define P_HEVC_CBREAK1_REG                         (volatile unsigned int *)((0x3335  << 2) + 0xff620000)
+#define   HEVC_CBREAK2_REG                         (0x3336)
+#define P_HEVC_CBREAK2_REG                         (volatile unsigned int *)((0x3336  << 2) + 0xff620000)
+#define   HEVC_CBREAK3_REG                         (0x3337)
+#define P_HEVC_CBREAK3_REG                         (volatile unsigned int *)((0x3337  << 2) + 0xff620000)
+#define   HEVC_CBREAK_TYPE                         (0x3338)
+#define P_HEVC_CBREAK_TYPE                         (volatile unsigned int *)((0x3338  << 2) + 0xff620000)
+#define   HEVC_CBREAK_CTRL                         (0x3339)
+#define P_HEVC_CBREAK_CTRL                         (volatile unsigned int *)((0x3339  << 2) + 0xff620000)
+#define   HEVC_CBREAK_STAUTS                       (0x333a)
+#define P_HEVC_CBREAK_STAUTS                       (volatile unsigned int *)((0x333a  << 2) + 0xff620000)
+#define   HEVC_CDB_ADDR_REG                        (0x333b)
+#define P_HEVC_CDB_ADDR_REG                        (volatile unsigned int *)((0x333b  << 2) + 0xff620000)
+#define   HEVC_CDB_DATA_REG                        (0x333c)
+#define P_HEVC_CDB_DATA_REG                        (volatile unsigned int *)((0x333c  << 2) + 0xff620000)
+#define   HEVC_CDB_CTRL                            (0x333d)
+#define P_HEVC_CDB_CTRL                            (volatile unsigned int *)((0x333d  << 2) + 0xff620000)
+#define   HEVC_CSFTINT0                            (0x333e)
+#define P_HEVC_CSFTINT0                            (volatile unsigned int *)((0x333e  << 2) + 0xff620000)
+#define   HEVC_CSFTINT1                            (0x333f)
+#define P_HEVC_CSFTINT1                            (volatile unsigned int *)((0x333f  << 2) + 0xff620000)
+#define   HEVC_IMEM_DMA_CTRL                       (0x3340)
+#define P_HEVC_IMEM_DMA_CTRL                       (volatile unsigned int *)((0x3340  << 2) + 0xff620000)
+#define   HEVC_IMEM_DMA_ADR                        (0x3341)
+#define P_HEVC_IMEM_DMA_ADR                        (volatile unsigned int *)((0x3341  << 2) + 0xff620000)
+#define   HEVC_IMEM_DMA_COUNT                      (0x3342)
+#define P_HEVC_IMEM_DMA_COUNT                      (volatile unsigned int *)((0x3342  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define   HEVC_WRRSP_IMEM                          (0x3343)
+#define P_HEVC_WRRSP_IMEM                          (volatile unsigned int *)((0x3343  << 2) + 0xff620000)
+#define   HEVC_LMEM_DMA_CTRL                       (0x3350)
+#define P_HEVC_LMEM_DMA_CTRL                       (volatile unsigned int *)((0x3350  << 2) + 0xff620000)
+#define   HEVC_LMEM_DMA_ADR                        (0x3351)
+#define P_HEVC_LMEM_DMA_ADR                        (volatile unsigned int *)((0x3351  << 2) + 0xff620000)
+#define   HEVC_LMEM_DMA_COUNT                      (0x3352)
+#define P_HEVC_LMEM_DMA_COUNT                      (volatile unsigned int *)((0x3352  << 2) + 0xff620000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem
+#define   HEVC_WRRSP_LMEM                          (0x3353)
+#define P_HEVC_WRRSP_LMEM                          (volatile unsigned int *)((0x3353  << 2) + 0xff620000)
+#define   HEVC_MAC_CTRL1                           (0x3360)
+#define P_HEVC_MAC_CTRL1                           (volatile unsigned int *)((0x3360  << 2) + 0xff620000)
+#define   HEVC_ACC0REG1                            (0x3361)
+#define P_HEVC_ACC0REG1                            (volatile unsigned int *)((0x3361  << 2) + 0xff620000)
+#define   HEVC_ACC1REG1                            (0x3362)
+#define P_HEVC_ACC1REG1                            (volatile unsigned int *)((0x3362  << 2) + 0xff620000)
+#define   HEVC_MAC_CTRL2                           (0x3370)
+#define P_HEVC_MAC_CTRL2                           (volatile unsigned int *)((0x3370  << 2) + 0xff620000)
+#define   HEVC_ACC0REG2                            (0x3371)
+#define P_HEVC_ACC0REG2                            (volatile unsigned int *)((0x3371  << 2) + 0xff620000)
+#define   HEVC_ACC1REG2                            (0x3372)
+#define P_HEVC_ACC1REG2                            (volatile unsigned int *)((0x3372  << 2) + 0xff620000)
+#define   HEVC_CPU_TRACE                           (0x3380)
+#define P_HEVC_CPU_TRACE                           (volatile unsigned int *)((0x3380  << 2) + 0xff620000)
+//
+// Closing file:  vcpu_regs.h
+//
+//
+// Reading file:  henc_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_HENC_CBUS_BASE = 0x0a
+// -----------------------------------------------
+#define   HCODEC_HENC_SCRATCH_0                    (0x1ac0)
+#define P_HCODEC_HENC_SCRATCH_0                    (volatile unsigned int *)((0x1ac0  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_1                    (0x1ac1)
+#define P_HCODEC_HENC_SCRATCH_1                    (volatile unsigned int *)((0x1ac1  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_2                    (0x1ac2)
+#define P_HCODEC_HENC_SCRATCH_2                    (volatile unsigned int *)((0x1ac2  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_3                    (0x1ac3)
+#define P_HCODEC_HENC_SCRATCH_3                    (volatile unsigned int *)((0x1ac3  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_4                    (0x1ac4)
+#define P_HCODEC_HENC_SCRATCH_4                    (volatile unsigned int *)((0x1ac4  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_5                    (0x1ac5)
+#define P_HCODEC_HENC_SCRATCH_5                    (volatile unsigned int *)((0x1ac5  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_6                    (0x1ac6)
+#define P_HCODEC_HENC_SCRATCH_6                    (volatile unsigned int *)((0x1ac6  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_7                    (0x1ac7)
+#define P_HCODEC_HENC_SCRATCH_7                    (volatile unsigned int *)((0x1ac7  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_8                    (0x1ac8)
+#define P_HCODEC_HENC_SCRATCH_8                    (volatile unsigned int *)((0x1ac8  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_9                    (0x1ac9)
+#define P_HCODEC_HENC_SCRATCH_9                    (volatile unsigned int *)((0x1ac9  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_A                    (0x1aca)
+#define P_HCODEC_HENC_SCRATCH_A                    (volatile unsigned int *)((0x1aca  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_B                    (0x1acb)
+#define P_HCODEC_HENC_SCRATCH_B                    (volatile unsigned int *)((0x1acb  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_C                    (0x1acc)
+#define P_HCODEC_HENC_SCRATCH_C                    (volatile unsigned int *)((0x1acc  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_D                    (0x1acd)
+#define P_HCODEC_HENC_SCRATCH_D                    (volatile unsigned int *)((0x1acd  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_E                    (0x1ace)
+#define P_HCODEC_HENC_SCRATCH_E                    (volatile unsigned int *)((0x1ace  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_F                    (0x1acf)
+#define P_HCODEC_HENC_SCRATCH_F                    (volatile unsigned int *)((0x1acf  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_G                    (0x1ad0)
+#define P_HCODEC_HENC_SCRATCH_G                    (volatile unsigned int *)((0x1ad0  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_H                    (0x1ad1)
+#define P_HCODEC_HENC_SCRATCH_H                    (volatile unsigned int *)((0x1ad1  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_I                    (0x1ad2)
+#define P_HCODEC_HENC_SCRATCH_I                    (volatile unsigned int *)((0x1ad2  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_J                    (0x1ad3)
+#define P_HCODEC_HENC_SCRATCH_J                    (volatile unsigned int *)((0x1ad3  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_K                    (0x1ad4)
+#define P_HCODEC_HENC_SCRATCH_K                    (volatile unsigned int *)((0x1ad4  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_L                    (0x1ad5)
+#define P_HCODEC_HENC_SCRATCH_L                    (volatile unsigned int *)((0x1ad5  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_M                    (0x1ad6)
+#define P_HCODEC_HENC_SCRATCH_M                    (volatile unsigned int *)((0x1ad6  << 2) + 0xff620000)
+#define   HCODEC_HENC_SCRATCH_N                    (0x1ad7)
+#define P_HCODEC_HENC_SCRATCH_N                    (volatile unsigned int *)((0x1ad7  << 2) + 0xff620000)
+// bit [7:0] data_feed_buff_id
+#define   HCODEC_IE_DATA_FEED_BUFF_INFO            (0x1ad8)
+#define P_HCODEC_IE_DATA_FEED_BUFF_INFO            (volatile unsigned int *)((0x1ad8  << 2) + 0xff620000)
+//
+// Closing file:  henc_regs.h
+//
+//
+// Reading file:  vlc_regs.h
+//
+//========================================================================
+//  VLC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VLC_CBUS_BASE = 0x0d
+// -----------------------------------------------
+// Bit[31:28] - henc_status
+// Bit[27:8] - reserved
+// Bit[7]    mc_hcmd_buff_enable
+// Bit[6]    mc_hcmd_use_mc_hcmd_buff
+// Bit[5]    mc_hcmd_use_mc_hcmd_hw_start
+// Bit[4]    no_mc_out_null_non_skipped_mb
+// Bit[3]    mc_out_even_skipped_mb
+// Bit[2] - hcmd_enable
+// Bit[1] - vlc_control_enable (0 will treat as soft_reset)
+// Bit[0] - vlc_input_enable (enable input interface)
+#define   HCODEC_VLC_STATUS_CTRL                   (0x1d00)
+#define P_HCODEC_VLC_STATUS_CTRL                   (volatile unsigned int *)((0x1d00  << 2) + 0xff620000)
+// Bit [31]  - small_luma_ignore_chroma
+// Bit[30:16] - Reserved
+// Bit [15]  - enable_free_clk_mc_hcmd_buff
+// Bit [14]  - enable_free_clk_reg
+// Bit [13]  - enable_free_clk_stream
+// Bit [12]  - enable_free_clk_pre_buff
+// Bit [11]  - enable_free_clk_vb_buff
+// Bit [10]  - enable_free_clk_dc_input
+// Bit [9]   - enable_free_clk_input
+// Bit [8]   - enable_free_clk_mv_cal
+// Bit [7]   - enable_free_clk_status
+// Bit [6]   - enable_free_clk_mc_dblk_cmd_if
+// Bit [5]   - disable_mvd_enc_finished
+// Bit [4]   - I16MB_share_ipred_mode_with_I4MB
+// Bit [3]   - fixed_picture_qp
+// Bit [2]   - use_set_b8_mode ( not used now)
+// Bit [1]   - use_set_mb_skip_run
+// Bit [0]   - pop_coeff_even_all_zero
+#define   HCODEC_VLC_CONFIG                        (0x1d01)
+#define P_HCODEC_VLC_CONFIG                        (volatile unsigned int *)((0x1d01  << 2) + 0xff620000)
+// --------------------------------------------
+// Bitstream DDR Interface
+// --------------------------------------------
+#define   HCODEC_VLC_VB_START_PTR                  (0x1d10)
+#define P_HCODEC_VLC_VB_START_PTR                  (volatile unsigned int *)((0x1d10  << 2) + 0xff620000)
+#define   HCODEC_VLC_VB_END_PTR                    (0x1d11)
+#define P_HCODEC_VLC_VB_END_PTR                    (volatile unsigned int *)((0x1d11  << 2) + 0xff620000)
+#define   HCODEC_VLC_VB_WR_PTR                     (0x1d12)
+#define P_HCODEC_VLC_VB_WR_PTR                     (volatile unsigned int *)((0x1d12  << 2) + 0xff620000)
+// Read Only, VLC_VB_SW_RD_PTR or VLC_VB_HW_RD_PTR
+#define   HCODEC_VLC_VB_RD_PTR                     (0x1d13)
+#define P_HCODEC_VLC_VB_RD_PTR                     (volatile unsigned int *)((0x1d13  << 2) + 0xff620000)
+#define   HCODEC_VLC_VB_SW_RD_PTR                  (0x1d14)
+#define P_HCODEC_VLC_VB_SW_RD_PTR                  (volatile unsigned int *)((0x1d14  << 2) + 0xff620000)
+// Read Only
+#define   HCODEC_VLC_VB_LEFT                       (0x1d15)
+#define P_HCODEC_VLC_VB_LEFT                       (volatile unsigned int *)((0x1d15  << 2) + 0xff620000)
+// VB FIFO Control
+// bit  [31:24] vb_full_int_enable_cpu[7:0]
+// bit  [23:16] vb_full_int_enable_amrisc[7:0]
+//   -bit 23 Video BUFFER LEFT < 0x400 Bytes
+//   -bit 22 Video BUFFER LEFT < 0x200 Bytes
+//   -bit 21 Video BUFFER LEFT < 0x100 Bytes
+//   -bit 20 Video BUFFER LEFT < 0x80 Bytes
+//   -bit 19 Video BUFFER LEFT < 0x40 Bytes
+//   -bit 18 Video BUFFER LEFT < 0x20 Bytes
+//   -bit 17 vbfifo left  < 16 double words (8x64bits)
+//   -bit 16 vbfifo left  < 8 double words (4x64bits)
+// bit  [15]    wr_ptr_int_enable_cpu
+// bit  [14]    wr_ptr_int_enable_amrisc
+// bit  [13]    wr_ptr_int (Read Only, write 1 will clear)
+// bit  [12]    vb_full_int_enable_cpu(Read Only)
+// bit  [11]    vb_full_int_enable_amrisc(Read Only)
+// bit  [10]    reserved
+// bit  [9]     use_vb_hw_rd_ptr
+// bit  [8]     vb_always_ready Set to 1 to ignore vb_level blocking DDR write
+// bit  [7]     vb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   vb_endian       Set VB Endian inside DDR memory
+// bit  [2]     vb_write_busy   Read Only - indicate DDR write busy
+// bit  [1]     vb_write_en     Set to 1 to enable writing data to DDR memory
+// bit  [0]     vb_soft_reset   Soft reset
+#define   HCODEC_VLC_VB_CONTROL                    (0x1d16)
+#define P_HCODEC_VLC_VB_CONTROL                    (volatile unsigned int *)((0x1d16  << 2) + 0xff620000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23:22 reserved
+// bit 21:16 A_id  // default : 0x20
+// bit 15:0  vb_left_hold // default : 0
+#define   HCODEC_VLC_VB_MEM_CTL                    (0x1d17)
+#define P_HCODEC_VLC_VB_MEM_CTL                    (volatile unsigned int *)((0x1d17  << 2) + 0xff620000)
+// vb_wr_ptr address to generate interrupt
+#define   HCODEC_VLC_VB_INT_PTR                    (0x1d18)
+#define P_HCODEC_VLC_VB_INT_PTR                    (volatile unsigned int *)((0x1d18  << 2) + 0xff620000)
+// bit[31:12] reserved
+// bit[11:0] vlc_wrrsp_count
+#define   HCODEC_VLC_WRRSP                         (0x1d19)
+#define P_HCODEC_VLC_WRRSP                         (volatile unsigned int *)((0x1d19  << 2) + 0xff620000)
+#define   HCODEC_VLC_TOTAL_BYTES                   (0x1d1a)
+#define P_HCODEC_VLC_TOTAL_BYTES                   (volatile unsigned int *)((0x1d1a  << 2) + 0xff620000)
+// bit  [31:26] reserved
+// bit  [25]    vb_flush
+// bit  [24]    vb_reg_ready
+// bit  [23:16] vb_buff_left     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define   HCODEC_VLC_VB_BUFF                       (0x1d1b)
+#define P_HCODEC_VLC_VB_BUFF                       (volatile unsigned int *)((0x1d1b  << 2) + 0xff620000)
+// bit[31]    flush_vlc_pre_buff
+// bit[30:27] reserved
+// bit[26:24] vb_pre_buff_level
+// bit[23:0]  vb_pre_buff_data[55:32]
+#define   HCODEC_VLC_VB_PRE_BUFF_HI                (0x1d1c)
+#define P_HCODEC_VLC_VB_PRE_BUFF_HI                (volatile unsigned int *)((0x1d1c  << 2) + 0xff620000)
+// bit[31:0] vb_pre_buff_data[31:0]
+#define   HCODEC_VLC_VB_PRE_BUFF_LOW               (0x1d1d)
+#define P_HCODEC_VLC_VB_PRE_BUFF_LOW               (volatile unsigned int *)((0x1d1d  << 2) + 0xff620000)
+// bit[31]    stream_encap_enable  // 0x0000(00-03) will be changed to 0x000003(00-03) if enabled
+// bit[30:29] stream_encap_delay   // delay bytes for encap used
+// bit[28:24] stream_buff_point
+// bit[23:0]  stream_buff_data
+#define   HCODEC_VLC_STREAM_BUFF                   (0x1d1e)
+#define P_HCODEC_VLC_STREAM_BUFF                   (volatile unsigned int *)((0x1d1e  << 2) + 0xff620000)
+// bit[31]    push_stream_block - Read Only (Will set if vb_buff full)
+// bit[30]    push_stream_busy  - Read Only (busy when output one byte from stream_buf (max 2 clocks for 8 bits push)
+// bit[29:28] stream_encap_status - Read Only
+// bit[27:21] reserved
+// Long Mode : (Amrisc need movilo and mvihi high to set stream_info)
+//   bit[20:16] push_stream_long_length (0 or 31 : Mid or Short mode)
+//   bit[15:0]  push_stream_data
+// Mid Mode : (Amrisc need movi to set stream_info)
+//   bit[15:12]] push_stream_mid_length (1-12 : mid mode active, 0-short mode, 15 - byte align)
+//   bit[11:0]  push_stream_data
+// Short Mode : (Amrisc can use mtspi to push stream directely)
+//   bit[7:5] push_stream_short_length (0-5 : short length, else - invalid)
+//   bit[4:0]  push_stream_data
+#define   HCODEC_VLC_PUSH_STREAM                   (0x1d1f)
+#define P_HCODEC_VLC_PUSH_STREAM                   (volatile unsigned int *)((0x1d1f  << 2) + 0xff620000)
+// bit[15:8] ELEMENT_LENGTH
+// bit[7:1]  reserved
+// bit[0]  Write - push start, Read - Push Busy
+#define   HCODEC_VLC_PUSH_ELEMENT                  (0x1d20)
+#define P_HCODEC_VLC_PUSH_ELEMENT                  (volatile unsigned int *)((0x1d20  << 2) + 0xff620000)
+#define   HCODEC_VLC_ELEMENT_DATA                  (0x1d21)
+#define P_HCODEC_VLC_ELEMENT_DATA                  (volatile unsigned int *)((0x1d21  << 2) + 0xff620000)
+// bit[7] hcmd_intra_use_sw_info
+// bit[6] hcmd_use_sw_info
+// bit[5] always_use_info_0_cbp_blk
+// bit[4] always_update_info_0_cbp_blk
+// bit[3] reset_left_mb_wr
+// bit[2] reset_top_mb_wr
+// bit[1] set_left_mb_wr
+// bit[0] set_top_mb_wr
+#define   HCODEC_VLC_SPECIAL_CTL                   (0x1d22)
+#define P_HCODEC_VLC_SPECIAL_CTL                   (volatile unsigned int *)((0x1d22  << 2) + 0xff620000)
+// bit[28]    left_intra
+// bit[27:22] left_quant
+// bit[21:16] left_quant_c
+// bit[12]    top_intra
+// bit[11:6]  top_quant
+// bit[5:0]   top_quant_c
+#define   HCODEC_VLC_HCMD_T_L_INFO                 (0x1d23)
+#define P_HCODEC_VLC_HCMD_T_L_INFO                 (volatile unsigned int *)((0x1d23  << 2) + 0xff620000)
+// bit[12]    cur_intra
+// bit[11:6]  cur_quant
+// bit[5:0]   cur_quant_c
+#define   HCODEC_VLC_HCMD_CUR_INFO                 (0x1d24)
+#define P_HCODEC_VLC_HCMD_CUR_INFO                 (volatile unsigned int *)((0x1d24  << 2) + 0xff620000)
+// bit[13]    top_left_info_in_data_mv_cal
+// bit[12]    only_use_info_0_top_left_in_I
+// bit[11]    top_left_info_in_data
+// bit[10]    early_mix_mc_hcmd
+// bit[9]     update_top_left_mix
+// bit[8]     p_top_left_mix
+// bit[7]     mv_cal_mixed_type
+// bit[6]     mc_hcmd_mixed_type
+// bit[5]     use_seperate_int_control
+// bit[4]     hcmd_intra_use_q_info
+// bit[3]     hcmd_left_use_prev_info
+// bit[2]     hcmd_use_q_info
+// bit[1]     use_q_delta_quant
+// bit[0]     detect_I16_from_I4
+#define   HCODEC_VLC_ADV_CONFIG                    (0x1d25)
+#define P_HCODEC_VLC_ADV_CONFIG                    (volatile unsigned int *)((0x1d25  << 2) + 0xff620000)
+//   31 - use_hcmd_mb_xy_auto
+//23:16 - hcmd_max_mb_x
+//15:8  - hcmd_mb_y_auto
+// 7:0  - hcmd_mb_x_auto
+#define   HCODEC_VLC_HCMD_MBXY_AUTO                (0x1d26)
+#define P_HCODEC_VLC_HCMD_MBXY_AUTO                (volatile unsigned int *)((0x1d26  << 2) + 0xff620000)
+// bit[31:0] vlc_int_control_inter -- will be used when use_seperate_int_control is set
+#define   HCODEC_VLC_INT_CONTROL_INTER             (0x1d2f)
+#define P_HCODEC_VLC_INT_CONTROL_INTER             (volatile unsigned int *)((0x1d2f  << 2) + 0xff620000)
+// --------------------------------------------
+// Picture VLC
+// --------------------------------------------
+// (&(int|(~AND_enable))|(|(int&OR_enable)))
+// bit[31]    OR interrupt Enable Reserved
+// bit[30]    OR interrupt Enable for mv_busy
+// bit[29]    OR interrupt Enable for b8_mode_busy
+// bit[28]    OR interrupt Enable for mb_skip_run_busy
+// bit[27]    OR interrupt Enable for cbp_busy
+// bit[26]    OR interrupt Enable for Reserved
+// bit[25]    OR interrupt Enable for Reserved
+// bit[24]    OR interrupt Enable for mb_info_busy
+// bit[23]    AND interrupt Enable Reserved
+// bit[22]    AND interrupt Enable for mv_busy
+// bit[21]    AND interrupt Enable for b8_mode_busy
+// bit[20]    AND interrupt Enable for mb_skip_run_busy
+// bit[19]    AND interrupt Enable for cbp_busy
+// bit[18]    AND interrupt Enable for Reserved
+// bit[17]    AND interrupt Enable for Reserved
+// bit[16]    AND interrupt Enable for mb_info_busy
+// bit[15]    OR interrupt Enable Reserved
+// bit[14]    OR interrupt Enable for mvd
+// bit[13]    OR interrupt Enable for b8_mode
+// bit[12]    OR interrupt Enable for mb_skip_run
+// bit[11]    OR interrupt Enable for cbp_ready
+// bit[10]    OR interrupt Enable for c_ipred_mode_ready
+// bit[9]     OR interrupt Enable for ipred_mode_ready
+// bit[8]     OR interrupt Enable for mb_info_ready
+// bit[7]     AND interrupt Enable Reserved
+// bit[6]     AND interrupt Enable for mvd
+// bit[5]     AND interrupt Enable for b8_mode
+// bit[4]     AND interrupt Enable for mb_skip_run
+// bit[3]     AND interrupt Enable for cbp_ready
+// bit[2]     AND interrupt Enable for c_ipred_mode_ready
+// bit[1]     AND interrupt Enable for ipred_mode_ready
+// bit[0]     AND interrupt Enable for mb_info_ready
+#define   HCODEC_VLC_INT_CONTROL                   (0x1d30)
+#define P_HCODEC_VLC_INT_CONTROL                   (volatile unsigned int *)((0x1d30  << 2) + 0xff620000)
+// Bit[31:16] picture_height
+// Bit[15:0]  picture_width
+#define   HCODEC_VLC_PIC_SIZE                      (0x1d31)
+#define P_HCODEC_VLC_PIC_SIZE                      (volatile unsigned int *)((0x1d31  << 2) + 0xff620000)
+// [31:16] Reserved
+// [15:3] pic_width_in_mbs_minus1
+// [2:0]  picture_type
+#define   HCODEC_VLC_PIC_INFO                      (0x1d32)
+#define P_HCODEC_VLC_PIC_INFO                      (volatile unsigned int *)((0x1d32  << 2) + 0xff620000)
+// Bit[31:16] MB_NR
+// Bit[15:8] MBY
+// Bit[7:0] MBX
+#define   HCODEC_VLC_PIC_POSITION                  (0x1d33)
+#define P_HCODEC_VLC_PIC_POSITION                  (volatile unsigned int *)((0x1d33  << 2) + 0xff620000)
+// Bit[31] MV_busy
+// Bit[30:6] Reserved
+// Bit[15] Reserved
+// Bit[14] vlc_input_MV_busy
+// Bit[13] vlc_input_b8_mode_busy
+// Bit[12] vlc_input_mb_skip_run_busy
+// Bit[11] vlc_input_cbp_busy
+// Bit[10] Reserved
+// Bit[9]  Reserved
+// Bit[8] vlc_input_mb_info_busy
+// Bit[7] Reserved
+// Bit[6] mvd
+// Bit[5] b8_mode
+// Bit[4] mb_skip_run
+// Bit[3] cbp
+// Bit[2] c_ipred_mode
+// Bit[1] ipred_mode
+// Bit[0] mb_info ( mb_type, mb_x, mb_y)
+#define   HCODEC_VLC_INPUT_STATUS                  (0x1d34)
+#define P_HCODEC_VLC_INPUT_STATUS                  (volatile unsigned int *)((0x1d34  << 2) + 0xff620000)
+// Bit[31:28] detected_mb_type
+// Bit[27:16] mb_y
+// Bit[15:4]  mb_x
+// Bit[3:0]   mb_type
+#define   HCODEC_VLC_MB_INFO                       (0x1d35)
+#define P_HCODEC_VLC_MB_INFO                       (volatile unsigned int *)((0x1d35  << 2) + 0xff620000)
+// commnad 0 -- no pending
+// normal command + 1 is pending command
+//
+// bit 31:28 -- pending command 7
+// bit 27:24 -- pending command 6
+// bit 23:20 -- pending command 5
+// bit 19:16 -- pending command 4
+// bit 15:12 -- pending command 3
+// bit 11:8  -- pending command 2
+// bit  7:4  -- pending command 1
+// bit  3:0  -- pending command 0
+#define   HCODEC_VLC_ENC_PEND_CMD                  (0x1d36)
+#define P_HCODEC_VLC_ENC_PEND_CMD                  (volatile unsigned int *)((0x1d36  << 2) + 0xff620000)
+// For I Slice
+// Bit[31:16] Reserved
+// Bit[15:0] IntraType
+#define   HCODEC_HENC_TOP_INFO_0                   (0x1d37)
+#define P_HCODEC_HENC_TOP_INFO_0                   (volatile unsigned int *)((0x1d37  << 2) + 0xff620000)
+#define   HCODEC_HENC_LEFT_INFO_0                  (0x1d38)
+#define P_HCODEC_HENC_LEFT_INFO_0                  (volatile unsigned int *)((0x1d38  << 2) + 0xff620000)
+// For I Slice
+// Bit[31:24] V_nnz
+// Bit[23:16] U_nnz
+// Bit[15:0]  Y_nnz
+#define   HCODEC_HENC_TOP_INFO_1                   (0x1d39)
+#define P_HCODEC_HENC_TOP_INFO_1                   (volatile unsigned int *)((0x1d39  << 2) + 0xff620000)
+#define   HCODEC_HENC_LEFT_INFO_1                  (0x1d3a)
+#define P_HCODEC_HENC_LEFT_INFO_1                  (volatile unsigned int *)((0x1d3a  << 2) + 0xff620000)
+// bit[63:0] ipred_mode
+#define   HCODEC_VLC_IPRED_MODE_HI                 (0x1d3b)
+#define P_HCODEC_VLC_IPRED_MODE_HI                 (volatile unsigned int *)((0x1d3b  << 2) + 0xff620000)
+#define   HCODEC_VLC_IPRED_MODE_LO                 (0x1d3c)
+#define P_HCODEC_VLC_IPRED_MODE_LO                 (volatile unsigned int *)((0x1d3c  << 2) + 0xff620000)
+// bit[15:8] SE delta quant
+// bit[7:0]  UE delta quant
+#define   HCODEC_VLC_DELTA_QP                      (0x1d3d)
+#define P_HCODEC_VLC_DELTA_QP                      (volatile unsigned int *)((0x1d3d  << 2) + 0xff620000)
+// bit[31:16] Reserved
+// bit[15:12] Reserved
+// bit[11:8] c_ipred_mode
+// bit[7:0] cbp
+#define   HCODEC_VLC_MB_HEADER_INFO                (0x1d3e)
+#define P_HCODEC_VLC_MB_HEADER_INFO                (volatile unsigned int *)((0x1d3e  << 2) + 0xff620000)
+// bit[31:16] mb_skip_run
+// bit[15:0]  b8_mode
+#define   HCODEC_VLC_P_MB_HEADER_INFO              (0x1d3f)
+#define P_HCODEC_VLC_P_MB_HEADER_INFO              (volatile unsigned int *)((0x1d3f  << 2) + 0xff620000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:20] coeff_buf_level
+// bit[19:10] coeff_buf_write_ptr
+// bit[9:0]   coeff_buf_read_ptr
+#define   HCODEC_VLC_COEFF_BUF_STATUS              (0x1d40)
+#define P_HCODEC_VLC_COEFF_BUF_STATUS              (volatile unsigned int *)((0x1d40  << 2) + 0xff620000)
+// bit[31:10] Reserved
+// bit[9:0] read_req_addr
+#define   HCODEC_VLC_COEFF_RD_REQ                  (0x1d41)
+#define P_HCODEC_VLC_COEFF_RD_REQ                  (volatile unsigned int *)((0x1d41  << 2) + 0xff620000)
+// bit[20]   - coeff_buf_read_finished
+// bit[19]   - coeff_first
+// bit[18:4] - coeff_level
+// bit[3:0]  - coeff_run
+#define   HCODEC_VLC_COEFF                         (0x1d42)
+#define P_HCODEC_VLC_COEFF                         (volatile unsigned int *)((0x1d42  << 2) + 0xff620000)
+// bit[31]    - coeff_info_ready
+// bit[30:25] - Reserved
+// bit[24:15] - block_begin_addr
+// bit[14:11] - trailing_one_sign
+// bit[10:6]  - total_coeff
+// bit[5:4]   - trailing_ones
+// bit[3:0]   - total_zeros
+#define   HCODEC_VLC_COEFF_INFO                    (0x1d43)
+#define P_HCODEC_VLC_COEFF_INFO                    (volatile unsigned int *)((0x1d43  << 2) + 0xff620000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:25] Reserved
+// bit[24:20] dc_buf_level -- 0-16
+// bit[19:15] Reserved
+// bit[14:10] dc_buf_write_ptr
+// bit[9:5]   Reserved
+// bit[4:0]   dc_buf_read_ptr
+#define   HCODEC_VLC_DC_BUF_STATUS                 (0x1d44)
+#define P_HCODEC_VLC_DC_BUF_STATUS                 (volatile unsigned int *)((0x1d44  << 2) + 0xff620000)
+// bit[31:10] Reserved
+// bit[9:4]   Reserved
+// bit[3:0]   read_req_addr
+#define   HCODEC_VLC_DC_RD_REQ                     (0x1d45)
+#define P_HCODEC_VLC_DC_RD_REQ                     (volatile unsigned int *)((0x1d45  << 2) + 0xff620000)
+// bit[31:17] - Reserved
+// bit[16]   - dc_first
+// bit[15:1] - dc_level
+// bit[0]    - dc_type  0 - CDC, 1 - LDC
+#define   HCODEC_VLC_DC                            (0x1d46)
+#define P_HCODEC_VLC_DC                            (volatile unsigned int *)((0x1d46  << 2) + 0xff620000)
+// bit[31]    - dc_info_ready
+// bit[30:25] - Reserved
+// bit[24:20] - Reserved
+// bit[19:15] - dc_idx_begin_addr
+// bit[14:11] - dc_trailing_one_sign
+// bit[10:6]  - dc_total_coeff
+// bit[5:4]   - dc_trailing_ones
+// bit[3:0]   - dc_total_zeros
+#define   HCODEC_VLC_DC_INFO                       (0x1d47)
+#define P_HCODEC_VLC_DC_INFO                       (volatile unsigned int *)((0x1d47  << 2) + 0xff620000)
+// bit[31:4]  - Reserved
+// bit[3:0]   - mv_rw_idx  (auto increment when read/write VLC_MV)
+#define   HCODEC_VLC_MV_INDEX                      (0x1d48)
+#define P_HCODEC_VLC_MV_INDEX                      (volatile unsigned int *)((0x1d48  << 2) + 0xff620000)
+// bit[31:16] - MVY
+// bit[15:0]  - MVX
+#define   HCODEC_VLC_MV                            (0x1d49)
+#define P_HCODEC_VLC_MV                            (volatile unsigned int *)((0x1d49  << 2) + 0xff620000)
+// bit[31:16] - MVY
+// bitp15:0]  - MVX
+// Write to HENC_TOP_MV_0 will cause previous U->UL, UR->U, and UR write
+// Read will read U MV only
+#define   HCODEC_HENC_TOP_MV_0                     (0x1d4a)
+#define P_HCODEC_HENC_TOP_MV_0                     (volatile unsigned int *)((0x1d4a  << 2) + 0xff620000)
+#define   HCODEC_HENC_TOP_MV_1                     (0x1d4b)
+#define P_HCODEC_HENC_TOP_MV_1                     (volatile unsigned int *)((0x1d4b  << 2) + 0xff620000)
+#define   HCODEC_HENC_TOP_MV_2                     (0x1d4c)
+#define P_HCODEC_HENC_TOP_MV_2                     (volatile unsigned int *)((0x1d4c  << 2) + 0xff620000)
+#define   HCODEC_HENC_TOP_MV_3                     (0x1d4d)
+#define P_HCODEC_HENC_TOP_MV_3                     (volatile unsigned int *)((0x1d4d  << 2) + 0xff620000)
+#define   HCODEC_HENC_LEFT_MV_0                    (0x1d4e)
+#define P_HCODEC_HENC_LEFT_MV_0                    (volatile unsigned int *)((0x1d4e  << 2) + 0xff620000)
+#define   HCODEC_HENC_LEFT_MV_1                    (0x1d4f)
+#define P_HCODEC_HENC_LEFT_MV_1                    (volatile unsigned int *)((0x1d4f  << 2) + 0xff620000)
+#define   HCODEC_HENC_LEFT_MV_2                    (0x1d50)
+#define P_HCODEC_HENC_LEFT_MV_2                    (volatile unsigned int *)((0x1d50  << 2) + 0xff620000)
+#define   HCODEC_HENC_LEFT_MV_3                    (0x1d51)
+#define P_HCODEC_HENC_LEFT_MV_3                    (volatile unsigned int *)((0x1d51  << 2) + 0xff620000)
+// Bit[31:1] Reserved
+// Bit[0] top_left_mv_ready
+#define   HCODEC_TOP_LEFT_READY                    (0x1d52)
+#define P_HCODEC_TOP_LEFT_READY                    (volatile unsigned int *)((0x1d52  << 2) + 0xff620000)
+// Bit[31:16] Reserved
+// Bit[15:0] mb_skip_run
+#define   HCODEC_MB_SKIP_RUN                       (0x1d53)
+#define P_HCODEC_MB_SKIP_RUN                       (volatile unsigned int *)((0x1d53  << 2) + 0xff620000)
+// Bit[31:16] Reserved
+// Bit[15]    Reserved
+// Bit[14:13] rd_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[12:11] wr_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[10:5]  mv_buff_id
+// Bit[4:0]   mv_ref
+#define   HCODEC_VLC_HCMD_CONFIG                   (0x1d54)
+#define P_HCODEC_VLC_HCMD_CONFIG                   (volatile unsigned int *)((0x1d54  << 2) + 0xff620000)
+// Bit[9:0] h264_dblk_info
+#define   HCODEC_VLC_HCMD_DBLK_INFO                (0x1d55)
+#define P_HCODEC_VLC_HCMD_DBLK_INFO                (volatile unsigned int *)((0x1d55  << 2) + 0xff620000)
+// Bit[3:0] vlc_dbg_idx
+#define   HCODEC_VLC_DBG_IDX                       (0x1d56)
+#define P_HCODEC_VLC_DBG_IDX                       (volatile unsigned int *)((0x1d56  << 2) + 0xff620000)
+// Read Only
+#define   HCODEC_VLC_DBG_READ                      (0x1d57)
+#define P_HCODEC_VLC_DBG_READ                      (volatile unsigned int *)((0x1d57  << 2) + 0xff620000)
+// [   29] RW jpeg_comp2_ac_table_sel.                                                      Default 0.
+// [   28] RW jpeg_comp2_dc_table_sel.                                                      Default 0.
+// [26:25] RW jpeg_comp2_cnt_max.                                                           Default 0.
+// [   24] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   21] RW jpeg_comp1_ac_table_sel.                                                      Default 0.
+// [   20] RW jpeg_comp1_dc_table_sel.                                                      Default 0.
+// [18:17] RW jpeg_comp1_cnt_max.                                                           Default 0.
+// [   16] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [   13] RW jpeg_comp0_ac_table_sel.                                                      Default 0.
+// [   12] RW jpeg_comp0_dc_table_sel.                                                      Default 0.
+// [10: 9] RW jpeg_comp0_cnt_max.                                                           Default 0.
+// [    8] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [    1] W  jpeg_coeff_init. Write 1 to this bit to initialize JPEG run length encoder.
+// [    0] RW jpeg_en. 0=Disable JPEG encoder; 1=Enable JPEG encoder.                       Default 0.
+#define   HCODEC_VLC_JPEG_CTRL                     (0x1d58)
+#define P_HCODEC_VLC_JPEG_CTRL                     (volatile unsigned int *)((0x1d58  << 2) + 0xff620000)
+// [   13] RW jpeg_coeff_buf_overfl. Write this bit to 1 to clear overfl.
+// [   12] RW jpeg_coeff_buf_undrfl. Write this bit to 1 to clear undrfl.
+// [   11] R  jpeg_coeff_buf_full.
+// [   10] R  jpeg_coeff_buf_empty.
+// [ 8: 0] R  jpeg_coeff_buf_level.
+#define   HCODEC_VLC_JPEG_COEFF_BUF_STAT           (0x1d59)
+#define P_HCODEC_VLC_JPEG_COEFF_BUF_STAT           (volatile unsigned int *)((0x1d59  << 2) + 0xff620000)
+// [   16] RW JPEG HUFFMAN table access mode. 0=Write; 1=Read.  Default 1.
+// [ 8: 0] RW JPEG HUFFMAN table addr.                          Default 0.
+#define   HCODEC_VLC_HUFFMAN_ADDR                  (0x1d5a)
+#define P_HCODEC_VLC_HUFFMAN_ADDR                  (volatile unsigned int *)((0x1d5a  << 2) + 0xff620000)
+// [19: 0] RW JPEG HUFFMAN table data.
+#define   HCODEC_VLC_HUFFMAN_DATA                  (0x1d5b)
+#define P_HCODEC_VLC_HUFFMAN_DATA                  (volatile unsigned int *)((0x1d5b  << 2) + 0xff620000)
+// bit[31:0] enc_mv_bits - including b8_mode and mvd
+#define   HCODEC_VLC_ENC_MV_BITS                   (0x1d5c)
+#define P_HCODEC_VLC_ENC_MV_BITS                   (volatile unsigned int *)((0x1d5c  << 2) + 0xff620000)
+// bit[31:0] enc_coeff_bits - including cbp, token, trailing_sign, coeff_enc, h264_totzeros, h264_run
+#define   HCODEC_VLC_ENC_COEFF_BITS                (0x1d5d)
+#define P_HCODEC_VLC_ENC_COEFF_BITS                (volatile unsigned int *)((0x1d5d  << 2) + 0xff620000)
+//
+// Closing file:  vlc_regs.h
+//
+//
+// Reading file:  qdct_regs.h
+//
+//========================================================================
+//  QDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_QDCT_CBUS_BASE = 0x0f
+// -----------------------------------------------
+// bit[31:28] - mb_info_state
+#define   HCODEC_QDCT_STATUS_CTRL                  (0x1f00)
+#define P_HCODEC_QDCT_STATUS_CTRL                  (volatile unsigned int *)((0x1f00  << 2) + 0xff620000)
+// bit[18]    - enable_free_clk_sad_top
+// bit[17]    - enable_free_clk_ie_top
+// bit[16]    - enable_free_clk_ie_sub
+// bit[15]    - enable_free_clk_mc_out
+// bit[14]    - enable_free_clk_i_pred_top
+// bit[13]    - enable_free_clk_idct_top
+// bit[12]    - enable_free_clk_iq_top
+// bit[11]    - enable_free_clk_q_top
+// bit[10]    - enable_free_clk_dc_buff_8
+// bit[9]     - enable_free_clk_dct_top
+// bit[8]     - enable_free_clk_mb_info
+// bit[7]     - enable_free_clk_mb_buff
+// bit[6]     - enable_free_clk_reg
+// bit[5]     - ignore_1_include_2nd_half_c
+// bit[4]     - ignore_1_include_2nd_half
+// bit[3]     - ignore_t_p8x8
+// bit[2]     - not_ignore_dc
+// bit[1]     - ignore_small_lac_intra
+// bit[0]     - disable_fast_zero_block
+#define   HCODEC_QDCT_CONFIG                       (0x1f01)
+#define P_HCODEC_QDCT_CONFIG                       (volatile unsigned int *)((0x1f01  << 2) + 0xff620000)
+// bit[31]    - ignore_lac_coeff_en
+// bit[30:26] - ignore_lac_coeff_else
+// bit[25:21] - ignore_lac_coeff_2
+// bit[20:16] - ignore_lac_coeff_1
+// bit[15]    - ignore_cac_coeff_en
+// bit[14:10] - ignore_cac_coeff_else
+// bit[9:5]   - ignore_cac_coeff_2
+// bit[4:0]   - ignore_cac_coeff_1
+#define   HCODEC_IGNORE_CONFIG                     (0x1f02)
+#define P_HCODEC_IGNORE_CONFIG                     (volatile unsigned int *)((0x1f02  << 2) + 0xff620000)
+// bit[31]    - ignore_t_lac_coeff_en
+// bit[30:26] - ignore_t_lac_coeff_else
+// bit[25:21] - ignore_t_lac_coeff_2
+// bit[20:16] - ignore_t_lac_coeff_1
+// bit[15]    - ignore_cdc_coeff_en
+// bit[14]    - ignore_t_lac_coeff_else_le_3
+// bit[13]    - ignore_t_lac_coeff_else_le_4
+// bit[12]    - ignore_cdc_only_when_empty_cac_inter
+// bit[11]    - ignore_cdc_only_when_one_empty_inter
+// bit[10:9]  - ignore_cdc_range_max_inter // 0-0, 1-1, 2,-2, 3-3
+// bit[8:7]   - ignore_cdc_abs_max_inter // 0-1, 1-2, 2,-3, 3-4
+// bit[6]     - reserved
+// bit[5]     - ignore_cdc_only_when_empty_cac_intra
+// bit[4]     - ignore_cdc_only_when_one_empty_intra
+// bit[3:2]   - ignore_cdc_range_max_intra // 0-0, 1-1, 2,-2, 3-3
+// bit[1:0]   - ignore_cdc_abs_max_intra // 0-1, 1-2, 2,-3, 3-4
+#define   HCODEC_IGNORE_CONFIG_2                   (0x1f03)
+#define P_HCODEC_IGNORE_CONFIG_2                   (volatile unsigned int *)((0x1f03  << 2) + 0xff620000)
+// --------------------------------------------
+// MB DATA DDR Interface
+// --------------------------------------------
+#define   HCODEC_QDCT_MB_START_PTR                 (0x1f10)
+#define P_HCODEC_QDCT_MB_START_PTR                 (volatile unsigned int *)((0x1f10  << 2) + 0xff620000)
+#define   HCODEC_QDCT_MB_END_PTR                   (0x1f11)
+#define P_HCODEC_QDCT_MB_END_PTR                   (volatile unsigned int *)((0x1f11  << 2) + 0xff620000)
+#define   HCODEC_QDCT_MB_WR_PTR                    (0x1f12)
+#define P_HCODEC_QDCT_MB_WR_PTR                    (volatile unsigned int *)((0x1f12  << 2) + 0xff620000)
+#define   HCODEC_QDCT_MB_RD_PTR                    (0x1f13)
+#define P_HCODEC_QDCT_MB_RD_PTR                    (volatile unsigned int *)((0x1f13  << 2) + 0xff620000)
+#define   HCODEC_QDCT_MB_LEVEL                     (0x1f14)
+#define P_HCODEC_QDCT_MB_LEVEL                     (volatile unsigned int *)((0x1f14  << 2) + 0xff620000)
+// bit  [31]    disable_mbxy_ie_save
+// bit  [30]    no_wait_after_q_cdc
+// bit  [29]    ie_start_int_enable
+// bit  [28]    ignore_t_p8x8
+// bit  [27]    zero_mc_out_null_non_skipped_mb
+// bit  [26]    no_mc_out_null_non_skipped_mb
+// bit  [25]    mc_out_even_skipped_mb
+// bit  [24]    mc_out_wait_cbp_ready
+// bit  [23]    mc_out_wait_mb_type_ready
+// bit  [22]    i_pred_int_enable
+// bit  [21]    intra_sat8_enable
+// bit  [20]    ie_sub_enable
+// bit  [19]    i_pred_enable
+// bit  [18]    iq_enable
+// bit  [17]    idct_enable
+// bit  [16]    no_zero_coeff_mb
+// bit  [15]    add_zero_coeff_block
+// bit  [14]    mb_pause_enable
+// bit  [13]    q_enable
+// bit  [12]    dct_enable
+// bit  [11]    ignore_magic_word
+// bit  [10]    mb_info_en
+// bit  [9]     mb_info_soft_reset
+// bit  [8]     mb_always_ready Set to 1 to ignore mb_level blocking DDR read
+// bit  [7]     mb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   mb_endian       Set MB Endian inside DDR memory
+// bit  [2]     mb_read_busy   Read Only - indicate DDR read busy
+// bit  [1]     mb_read_en     Set to 1 to enable reading data from DDR memory
+// bit  [0]     mb_soft_reset   Soft reset
+#define   HCODEC_QDCT_MB_CONTROL                   (0x1f15)
+#define P_HCODEC_QDCT_MB_CONTROL                   (volatile unsigned int *)((0x1f15  << 2) + 0xff620000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23    reserved
+// bit 22    read_till_zero
+// bit 21:16 A_id  // default : 0x21
+// bit 15:0  mb_level_hold // default : 0
+#define   HCODEC_QDCT_MB_MEM_CTL                   (0x1f16)
+#define P_HCODEC_QDCT_MB_MEM_CTL                   (volatile unsigned int *)((0x1f16  << 2) + 0xff620000)
+// bit  [31:24] reserved
+// bit  [23:16] vb_buff_level     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define   HCODEC_QDCT_MB_BUFF                      (0x1f17)
+#define P_HCODEC_QDCT_MB_BUFF                      (volatile unsigned int *)((0x1f17  << 2) + 0xff620000)
+// bit [31:0] mb infor data begin magic word - default : 0xa55aaa55
+#define   HCODEC_QDCT_MB_MAGIC_WORD                (0x1f18)
+#define P_HCODEC_QDCT_MB_MAGIC_WORD                (volatile unsigned int *)((0x1f18  << 2) + 0xff620000)
+// Read Only Register
+// bit[19]   dct_ready_1
+// bit[18]   dct_ready_0
+// bit[17]   dct_rd_idx
+// bit[16]   dct_wr_idx
+// bit[15]   dct_srdy
+// bit[14]   dct_rrdy
+// bit[13]   Reserved
+// bit[12:8] dct_block_number
+// bit[7:4]  dct_rw_addr
+// bit[3:0]  dct_status
+#define   HCODEC_QDCT_DCT_STATUS                   (0x1f19)
+#define P_HCODEC_QDCT_DCT_STATUS                   (volatile unsigned int *)((0x1f19  << 2) + 0xff620000)
+// bit[24:23]  vlc_quant_count
+// bit[22:16]  vlc_delta_quant_data
+// bit[15:10]  vlc_quant_data
+// bit[9:4]    vlc_prev_quant_data
+// bit[3:0]    q_status
+#define   HCODEC_QDCT_Q_STATUS                     (0x1f1a)
+#define P_HCODEC_QDCT_Q_STATUS                     (volatile unsigned int *)((0x1f1a  << 2) + 0xff620000)
+// bit[31:3] Reserved
+// bit[2:0]  picture_type
+#define   HCODEC_QDCT_PIC_INFO                     (0x1f1b)
+#define P_HCODEC_QDCT_PIC_INFO                     (volatile unsigned int *)((0x1f1b  << 2) + 0xff620000)
+// bit[31:28] Reserved
+// bit[27:22] I_pic_quant_c
+// bit[21:16] I_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define   HCODEC_QDCT_Q_QUANT_I                    (0x1f1c)
+#define P_HCODEC_QDCT_Q_QUANT_I                    (volatile unsigned int *)((0x1f1c  << 2) + 0xff620000)
+// bit[31:28] Reserved
+// bit[27:22] P_pic_quant_c
+// bit[21:16] P_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define   HCODEC_QDCT_Q_QUANT_P                    (0x1f1d)
+#define P_HCODEC_QDCT_Q_QUANT_P                    (volatile unsigned int *)((0x1f1d  << 2) + 0xff620000)
+// bit[31]    mb_info_pause
+// bit[30:16] pause_mby
+// bit[15:0]  pause_mbx
+#define   HCODEC_QDCT_MB_PAUSE_CTL                 (0x1f1e)
+#define P_HCODEC_QDCT_MB_PAUSE_CTL                 (volatile unsigned int *)((0x1f1e  << 2) + 0xff620000)
+// bit[31]   top_control_ready_i_pred
+// bit[30:28]top_dma_status
+// bit[27]   top_control_ready_ie
+// bit[26:24]Reserved
+// bit[23]   ul_mb
+// bit[22]   right_mb
+// bit[21]   top_mb
+// bit[20]   left_mb
+// bit[19:8] mb_x
+// bit[7:6]  i_pred_ref_idx_L
+// bit[5:4]  i_pred_ref_idx_UL
+// bit[3:2]  i_pred_ref_idx_U
+// bit[1:0]  i_pred_ref_idx_UR
+#define   HCODEC_QDCT_TOP_CONTROL                  (0x1f1f)
+#define P_HCODEC_QDCT_TOP_CONTROL                  (volatile unsigned int *)((0x1f1f  << 2) + 0xff620000)
+// bit[31:0] top_base_addr - DDR Memory start address for save top Pixel
+#define   HCODEC_QDCT_TOP_BASE_MEM                 (0x1f20)
+#define P_HCODEC_QDCT_TOP_BASE_MEM                 (volatile unsigned int *)((0x1f20  << 2) + 0xff620000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x22
+#define   HCODEC_QDCT_TOP_MEM_CTL                  (0x1f21)
+#define P_HCODEC_QDCT_TOP_MEM_CTL                  (volatile unsigned int *)((0x1f21  << 2) + 0xff620000)
+// bit [11:0] top_wrrsp_count
+#define   HCODEC_QDCT_TOP_WRRSP                    (0x1f22)
+#define P_HCODEC_QDCT_TOP_WRRSP                    (volatile unsigned int *)((0x1f22  << 2) + 0xff620000)
+// Bit[3:0] qdct_dbg_idx
+#define   HCODEC_QDCT_DBG_IDX                      (0x1f23)
+#define P_HCODEC_QDCT_DBG_IDX                      (volatile unsigned int *)((0x1f23  << 2) + 0xff620000)
+// Read Only
+#define   HCODEC_QDCT_DBG_READ                     (0x1f24)
+#define P_HCODEC_QDCT_DBG_READ                     (volatile unsigned int *)((0x1f24  << 2) + 0xff620000)
+// [19:18] RW jdct_inflow_ctrl. JPEG DCT input flow control.                                Default 0.
+//            0=No halt;
+//            1=DCT halts request at end of each 8x8 block;
+//            2=DCT halts request at end of each MCU.
+// [17:16] RW jpeg_coeff_last_sel.                                                          Default 0.
+//            Select at which point to finish processing, give update to AmRISC so it can control the next step.
+//            0=Mark last coeff at the end of an 8x8 block;
+//            1=Mark at the end of an MCU;
+//            2=Mark at the end of a scan.
+// [   15] RW jpeg_quant_sel_comp2. 0=Comp2 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   14] RW jpeg_v_factor_comp2. Component 2's vertical sampling factor.                  Default 0.
+// [   13] RW jpeg_h_factor_comp2. Component 2's horizontal sampling factor.                Default 0.
+// [   12] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   11] RW jpeg_quant_sel_comp1. 0=Comp1 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   10] RW jpeg_v_factor_comp1. Component 1's vertical sampling factor.                  Default 0.
+// [    9] RW jpeg_h_factor_comp1. Component 1's horizontal sampling factor.                Default 0.
+// [    8] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [    7] RW jpeg_quant_sel_comp0. 0=Comp0 select Quantization table 0; 1=Select table 1.  Default 0.
+// [    6] RW jpeg_v_factor_comp0. Component 0's vertical sampling factor.                  Default 0.
+// [    5] RW jpeg_h_factor_comp0. Component 0's horizontal sampling factor.                Default 0.
+// [    4] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [ 3: 1] RW jdct_intr_sel. JPEG DCT interrupt select.                                     Default 0.
+//            0=Disable intr;
+//            1=Intr at end of each 8x8 block of DCT input;
+//            2=Intr at end of each MCU of DCT input;
+//            3=Intr at end of a scan of DCT input;
+//            4=Intr at end of each 8x8 block of DCT output;
+//            5=Intr at end of each MCU of DCT output;
+//            6=Intr at end of a scan of DCT output.
+// [    0] RW jpeg_en. 0=Disable JPEG QDCT; 1=Enable JPEG QDCT.                             Default 0.
+#define   HCODEC_QDCT_JPEG_CTRL                    (0x1f25)
+#define P_HCODEC_QDCT_JPEG_CTRL                    (volatile unsigned int *)((0x1f25  << 2) + 0xff620000)
+// [29:16] RW jpeg_x_end.   Picture X end.      Default 0.
+// [13: 0] RW jpeg_x_start. Picture X start.    Default 0.
+#define   HCODEC_QDCT_JPEG_X_START_END             (0x1f26)
+#define P_HCODEC_QDCT_JPEG_X_START_END             (volatile unsigned int *)((0x1f26  << 2) + 0xff620000)
+// [29:16] RW jpeg_y_end.   Picture Y end.      Default 0.
+// [13: 0] RW jpeg_y_start. Picture Y start.    Default 0.
+#define   HCODEC_QDCT_JPEG_Y_START_END             (0x1f27)
+#define P_HCODEC_QDCT_JPEG_Y_START_END             (volatile unsigned int *)((0x1f27  << 2) + 0xff620000)
+// [    8] RW JPEG QUANT table access mode. 0=Write; 1=Read.    Default 1.
+// [ 5: 0] RW JPEG QUANT table addr.                            Default 0.
+#define   HCODEC_QDCT_JPEG_QUANT_ADDR              (0x1f28)
+#define P_HCODEC_QDCT_JPEG_QUANT_ADDR              (volatile unsigned int *)((0x1f28  << 2) + 0xff620000)
+// [31: 0] RW JPEG QUANT table data.
+#define   HCODEC_QDCT_JPEG_QUANT_DATA              (0x1f29)
+#define P_HCODEC_QDCT_JPEG_QUANT_DATA              (volatile unsigned int *)((0x1f29  << 2) + 0xff620000)
+// [    1] W  resume_jdct.
+//            Write 1 to this bit will resume JPEG input engine when previously
+//            it is halted by QDCT_JPEG_CTRL.jdct_inflow_ctrl.
+// [    0] W  jpeg_sof.
+//            Write 1 to this bit will start JPEG input engine.
+#define   HCODEC_QDCT_JPEG_SOF_RESUME              (0x1f2a)
+#define P_HCODEC_QDCT_JPEG_SOF_RESUME              (volatile unsigned int *)((0x1f2a  << 2) + 0xff620000)
+// [31:30] R  dct_st.       jdct_ctrl state. 0=IDLE; 1=WAIT; 2=DCT_REQ.
+// [29:28] R  mfdin_comp.   Current component at pixel request to MFDIN.
+// [27:14] R  mfdin_y.      Current Y at pixel request to MFDIN.
+// [13: 0] R  mfdin_x.      Current X at pixel request to MFDIN.
+#define   HCODEC_QDCT_JPEG_DCT_STATUS0             (0x1f2b)
+#define P_HCODEC_QDCT_JPEG_DCT_STATUS0             (volatile unsigned int *)((0x1f2b  << 2) + 0xff620000)
+// [15:12] R  JPEG Quant read MEM select.
+// [11: 8] R  JPEG DCT2 write MEM select.
+// [ 7: 4] R  JPEG DCT2 read MEM select.
+// [ 3: 0] R  JPEG DCT1 write MEM select.
+#define   HCODEC_QDCT_JPEG_DCT_STATUS1             (0x1f2c)
+#define P_HCODEC_QDCT_JPEG_DCT_STATUS1             (volatile unsigned int *)((0x1f2c  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff1.  Default 13'h1D90; // 7568 = 4096 * sqrt(2) * (cos(Pi/8) + sin(Pi/8)) // 7569
+// [12: 0] RW jdct_coeff0.  Default 13'h16A1; // 5793 = 4096 * sqrt(2)
+#define   HCODEC_QDCT_JPEG_DCT_COEFF01             (0x1f2d)
+#define P_HCODEC_QDCT_JPEG_DCT_COEFF01             (volatile unsigned int *)((0x1f2d  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff3.  Default 13'h0C3F; // 3135 = 4096 * sqrt(2) * (cos(Pi/8) - sin(Pi/8))
+// [12: 0] RW jdct_coeff2.  Default 13'h08A9; // 2217 = 4096 * sqrt(2) * sin(Pi/8) // 2215
+#define   HCODEC_QDCT_JPEG_DCT_COEFF23             (0x1f2e)
+#define P_HCODEC_QDCT_JPEG_DCT_COEFF23             (volatile unsigned int *)((0x1f2e  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff5.  Default 13'h046A; // 1130 = 4096 * (cos(3Pi/16) - sin(3Pi/16))
+// [12: 0] RW jdct_coeff4.  Default 13'h1631; // 5681 = 4096 * (cos(3Pi/16) + sin(3Pi/16)) // 5682
+#define   HCODEC_QDCT_JPEG_DCT_COEFF45             (0x1f2f)
+#define P_HCODEC_QDCT_JPEG_DCT_COEFF45             (volatile unsigned int *)((0x1f2f  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff7.  Default 13'h0C92; // 3218 = 4096 * (cos(Pi/16) - sin(Pi/16))
+// [12: 0] RW jdct_coeff6.  Default 13'h12D0; // 4816 = 4096 * (cos(Pi/16) + sin(Pi/16))
+#define   HCODEC_QDCT_JPEG_DCT_COEFF67             (0x1f30)
+#define P_HCODEC_QDCT_JPEG_DCT_COEFF67             (volatile unsigned int *)((0x1f30  << 2) + 0xff620000)
+// [28:16] RW jdct_coeff9.  Default 13'h0FB1; // 4017 = 4096 * cos(Pi/16)
+// [12: 0] RW jdct_coeff8.  Default 13'h0D4E; // 3406 = 4096 * cos(3Pi/16)
+#define   HCODEC_QDCT_JPEG_DCT_COEFF89             (0x1f31)
+#define P_HCODEC_QDCT_JPEG_DCT_COEFF89             (volatile unsigned int *)((0x1f31  << 2) + 0xff620000)
+#define   HCODEC_QDCT_I_PRED_REF_WR_IDX            (0x1f32)
+#define P_HCODEC_QDCT_I_PRED_REF_WR_IDX            (volatile unsigned int *)((0x1f32  << 2) + 0xff620000)
+#define   HCODEC_QDCT_I_PRED_REF_WR_DATA           (0x1f33)
+#define P_HCODEC_QDCT_I_PRED_REF_WR_DATA           (volatile unsigned int *)((0x1f33  << 2) + 0xff620000)
+// bit[29]  mb_info_latch_no_I16_pred_mode
+// bit[28]  ie_dma_mbxy_use_i_pred
+// bit[27]  ie_dma_read_write_use_ip_idx
+// bit[26]  ie_start_use_top_dma_count
+// bit[25]  i_pred_top_dma_rd_mbbot
+// bit[24]  i_pred_top_dma_wr_disable
+// bit[23]  i_pred_mix
+// bit[22]  me_ab_rd_when_intra_in_p
+// bit[21]  force_mb_skip_run_when_intra
+// bit[20]  mc_out_mixed_type
+// bit[19]  ie_start_when_quant_not_full
+// bit[18]  mb_info_state_mix
+// bit[17]  mb_type_use_mix_result
+// bit[16]  me_cb_ie_read_enable
+// bit[15]  ie_cur_data_from_me
+// bit[14]  rem_per_use_table
+// bit[13]  q_latch_int_enable
+// bit[12]  q_use_table
+// bit[11]  q_start_wait
+// bit[10]  LUMA_16_LEFT_use_cur
+// bit[9]   DC_16_LEFT_SUM_use_cur
+// bit[8]   c_ref_ie_sel_cur
+// bit[7]   c_ipred_perfect_mode
+// bit[6]   ref_ie_ul_sel 0-old, 1-use next_set
+// bit[5]   mb_type_use_ie_result
+// bit[4]   detect_I16_from_I4
+// bit[3]   ie_not_wait_ref_busy
+// bit[2]   ie_I16_enable
+// bit[1:0] ie_done_sel (0, 1, 2, -1)
+#define   HCODEC_QDCT_ADV_CONFIG                   (0x1f34)
+#define P_HCODEC_QDCT_ADV_CONFIG                   (volatile unsigned int *)((0x1f34  << 2) + 0xff620000)
+// bit [31:16] I16x16_weight
+// bit [15:0]  I4x4_weight
+#define   HCODEC_IE_WEIGHT                         (0x1f35)
+#define P_HCODEC_IE_WEIGHT                         (volatile unsigned int *)((0x1f35  << 2) + 0xff620000)
+// bit [31]  reserved
+// bit [30] q_I16MB
+// bit [29]  reserved
+// bit [28]  reserved
+// bit [27:23] quant_table_addr I4MB:[0,7], I16MB:[8:15], INTER:[16:23], Reserved:[24:31]
+// bit [22]    quant_table_addr_update(when notupdate_rem_per) (read is arb_result : q_intra)
+// bit [21:19] quant_rem_c
+// bit [18:16] quant_rem_y
+// bit [15:12] quant_per_c
+// bit [11:8]  quant_per_y
+// bit [7:2] quant
+// bit [1] update_rem_per
+// bit [0] clear_wait_status
+#define   HCODEC_Q_QUANT_CONTROL                   (0x1f36)
+#define P_HCODEC_Q_QUANT_CONTROL                   (volatile unsigned int *)((0x1f36  << 2) + 0xff620000)
+#define   HCODEC_MBBOT_EVEN_ADDR                   (0x1f37)
+#define P_HCODEC_MBBOT_EVEN_ADDR                   (volatile unsigned int *)((0x1f37  << 2) + 0xff620000)
+#define   HCODEC_MBBOT_ODD_ADDR                    (0x1f38)
+#define P_HCODEC_MBBOT_ODD_ADDR                    (volatile unsigned int *)((0x1f38  << 2) + 0xff620000)
+// bit [29:24] quant_table_data_3
+// bit [21:16] quant_table_data_2
+// bit [13:8]  quant_table_data_1
+// bit [5:0]   quant_table_data_0
+#define   HCODEC_QUANT_TABLE_DATA                  (0x1f39)
+#define P_HCODEC_QUANT_TABLE_DATA                  (volatile unsigned int *)((0x1f39  << 2) + 0xff620000)
+// bit [31:16] ie_sad_offset_I16
+// bit [15:0] ie_sad_offset_I4
+#define   HCODEC_SAD_CONTROL_0                     (0x1f3a)
+#define P_HCODEC_SAD_CONTROL_0                     (volatile unsigned int *)((0x1f3a  << 2) + 0xff620000)
+// bit [31]     sad_soft_reset
+// bit [30:27]  reserved
+// bit [26:24]  ie_sad_shift_I16
+// bit [22:20]  ie_sad_shift_I4
+// bit [18:16]  me_sad_shift_INTER
+// bit [15:0]   me_sad_offset_INTER
+#define   HCODEC_SAD_CONTROL_1                     (0x1f3b)
+#define P_HCODEC_SAD_CONTROL_1                     (volatile unsigned int *)((0x1f3b  << 2) + 0xff620000)
+// bit [31]     vlc_quant_rd_ptr
+// bit [30]     vlc_quant_rd_ptr_update
+// bit [29]     vlc_quant_wr_ptr
+// bit [28]     vlc_quant_wr_ptr_update
+// bit [27:26]  reserved
+// bit [25:19]  vlc_delta_quant_1
+// bit [18:13]  vlc_quant_1
+// bit [12:6]   vlc_delta_quant_0
+// bit [5:0]    vlc_quant_0
+#define   HCODEC_QDCT_VLC_QUANT_CTL_0              (0x1f3c)
+#define P_HCODEC_QDCT_VLC_QUANT_CTL_0              (volatile unsigned int *)((0x1f3c  << 2) + 0xff620000)
+// bit [31:30]  me_sad_rd_idx
+// bit [29]     me_sad_rd_idx_update
+// bit [28:27]  me_sad_wr_idx
+// bit [26]     me_sad_wr_idx_update
+// bit [25:24]  ie_sad_rd_idx
+// bit [23]     ie_sad_rd_idx_update
+// bit [22:21]  ie_sad_wr_idx
+// bit [20]     ie_sad_wr_idx_update
+// bit [19:12]  Reserved
+// bit [11:6]   vlc_max_delta_q_neg
+// bit [5:0]    vlc_max_delta_q_pos
+#define   HCODEC_QDCT_VLC_QUANT_CTL_1              (0x1f3d)
+#define P_HCODEC_QDCT_VLC_QUANT_CTL_1              (volatile unsigned int *)((0x1f3d  << 2) + 0xff620000)
+// bit[4] jdct_int
+// bit[3] quant_latch
+// bit[2] me_done
+// bit[1] ie_start
+// bit[0] i_pred_start
+#define   HCODEC_QDCT_INT_STATUS                   (0x1f3e)
+#define P_HCODEC_QDCT_INT_STATUS                   (volatile unsigned int *)((0x1f3e  << 2) + 0xff620000)
+// bit[3]   mix_i_pred_wait_left_en
+// bit[2:0] mc_pending_mb_count
+#define   HCODEC_QDCT_MIX_I_PRED_STATUS            (0x1f3f)
+#define P_HCODEC_QDCT_MIX_I_PRED_STATUS            (volatile unsigned int *)((0x1f3f  << 2) + 0xff620000)
+// IE/ME share same cbus_base as QDCT
+//
+// bit[31]  active_ur_block
+// bit[30]  active_ul_block
+// bit[21]  disable_HENC_V_PRED_16
+// bit[20]  disable_HENC_H_PRED_16
+// bit[19]  disable_HENC_DC_PRED_16
+// bit[18]  disable_HENC_HENC_HOR_UP_PRED
+// bit[17]  disable_HENC_VERT_LEFT_PRED
+// bit[16]  disable_HENC_HENC_HOR_DOWN_PRED
+// bit[15]  disable_HENC_VERT_RIGHT_PRED
+// bit[14]  disable_HENC_DIAG_DOWN_RIGHT_PRED
+// bit[13]  disable_HENC_DIAG_DOWN_LEFT_PRED
+// bit[12]  disable_HENC_DC_PRED
+// bit[11]  disable_HENC_HOR_PRED
+// bit[10]  disable_HENC_VERT_PRED
+// bit[9]   ie_c_wait_ie_pause
+// bit[8:4] max_ie_result_buff_count
+// bit[3]   ie_wait_for_ie_result  // use for (max_ie_result_buff_count == 0) to wait every block
+// bit[2]   reserved
+// bit[1]   ie_enable
+// bit[0]   ie_soft_reset
+#define   HCODEC_IE_CONTROL                        (0x1f40)
+#define P_HCODEC_IE_CONTROL                        (volatile unsigned int *)((0x1f40  << 2) + 0xff620000)
+// bit[31:12] Reserved
+// bit[11:0]  mb_y
+#define   HCODEC_IE_MB_POSITION                    (0x1f41)
+#define P_HCODEC_IE_MB_POSITION                    (volatile unsigned int *)((0x1f41  << 2) + 0xff620000)
+// bit[31:16] me_skip_run
+// bit[15:8]  reserved
+// bit [7:4]  me_b8_mode
+// bit [3:0]  ie_me_mb_type
+#define   HCODEC_IE_ME_MB_INFO                     (0x1f42)
+#define P_HCODEC_IE_ME_MB_INFO                     (volatile unsigned int *)((0x1f42  << 2) + 0xff620000)
+// bit[3]   ie_result_buff_enable
+// bit[2]   ie_result_buff_soft_reset
+// bit[1]   sad_enable
+// bit[0]   ie_sad_soft_reset
+#define   HCODEC_SAD_CONTROL                       (0x1f43)
+#define P_HCODEC_SAD_CONTROL                       (volatile unsigned int *)((0x1f43  << 2) + 0xff620000)
+// bit[31:16] - ie_result_buff_count - read only
+// bit[14:12] -current_ie_result (pred_mode) - read only
+// bit[11]  top_control_data_buff_wr_ptr - rd/wr
+// bit[10]  top_control_data_buff_rd_ptr - rd/wr
+// bit[9:5] ie_result_buff_wr_ptr        - rd/wr
+// bit[4:0] ie_result_buff_rd_ptr        - rd/wr
+#define   HCODEC_IE_RESULT_BUFFER                  (0x1f44)
+#define P_HCODEC_IE_RESULT_BUFFER                  (volatile unsigned int *)((0x1f44  << 2) + 0xff620000)
+// bit[63:0] ie_i4_pred_mode
+#define   HCODEC_IE_I4_PRED_MODE_HI                (0x1f45)
+#define P_HCODEC_IE_I4_PRED_MODE_HI                (volatile unsigned int *)((0x1f45  << 2) + 0xff620000)
+#define   HCODEC_IE_I4_PRED_MODE_LO                (0x1f46)
+#define P_HCODEC_IE_I4_PRED_MODE_LO                (volatile unsigned int *)((0x1f46  << 2) + 0xff620000)
+// bit [31:9] reserved
+// bit [8:4] i_pred_block_number
+// bit [3:0] ie_c_pred_mode
+#define   HCODEC_IE_C_PRED_MODE                    (0x1f47)
+#define P_HCODEC_IE_C_PRED_MODE                    (volatile unsigned int *)((0x1f47  << 2) + 0xff620000)
+// 31:16 - Left, 0-select ie_pixel, 1-select mc_data_out
+// 15:0  - Top,  0-select ie_pixel, 1-select mc_data_out
+#define   HCODEC_IE_CUR_REF_SEL                    (0x1f48)
+#define P_HCODEC_IE_CUR_REF_SEL                    (volatile unsigned int *)((0x1f48  << 2) + 0xff620000)
+// bit[31]  enable_f_skip_1_step_3
+// bit[30]  enable_f_skip_1_step_2
+// bit[29]  enable_f_skip_1_step_1
+// bit[28]  step_3_enable
+// bit[27]  step_2_sub_pixel
+// bit[26]  always_f_skip_step_3
+// bit[25]  always_f_skip_step_2
+// bit[24]  always_f_skip_step_1
+// bit[23]  half_pixel_only
+// bit[22:13] reserved
+// bit[12]  adv_mv_enable
+// bit[11]  sad_short_valid
+// bit[10:9] mv_flexable_ctl 00:0x40, 01:0x80, 10:0xc0, 11 : 0x100
+// bit[8]   no_md_ab_rd
+// bit[7]   use_dct_state
+// bit[6]   enable_free_clk_me_ctl
+// bit[5]   enable_free_clk_me_ab
+// bit[4]   enable_free_clk_me_cb
+// bit[3]   reserved
+// bit[2]   me_done_int_enable
+// bit[1]   me_enable
+// bit[0]   me_soft_reset
+#define   HCODEC_ME_CONTROL                        (0x1f49)
+#define P_HCODEC_ME_CONTROL                        (volatile unsigned int *)((0x1f49  << 2) + 0xff620000)
+// bit[31:28] Reserved
+// bit[27:16] me_start_mby
+// bit[15:12] Reserved
+// bit[11:0]  me_start_mbx
+#define   HCODEC_ME_START_POSITION                 (0x1f4a)
+#define P_HCODEC_ME_START_POSITION                 (volatile unsigned int *)((0x1f4a  << 2) + 0xff620000)
+// bit [31:28] me_status - Read only
+// bit [27:24] me_cb_status  // current buffer
+// bit [23:20] me_ab_status  // anc buffer
+// bit [19]    Reserved
+// bit [18:16] me_ab_wr_ptr  // read only
+// bit [15:4]  me_last_mbx
+// bit [3:1]   me_ab_rd_ptr  // read only
+// bit [0]     me_action
+#define   HCODEC_ME_STATUS                         (0x1f4b)
+#define P_HCODEC_ME_STATUS                         (volatile unsigned int *)((0x1f4b  << 2) + 0xff620000)
+// all Read-only
+// bit [31:28] Reserved
+// bit [27:16] me_ab_mbx
+// bit [15:14] me_cb_wr_ptr
+// bit [13:12] me_cb_rd_ptr
+// bit [11:0]  me_cb_mbx
+#define   HCODEC_ME_DEBUG                          (0x1f4c)
+#define P_HCODEC_ME_DEBUG                          (volatile unsigned int *)((0x1f4c  << 2) + 0xff620000)
+// bit[29:24] step_3_skip_line
+// bit[23:18] step_2_skip_line
+// bit[17:12] step_1_skip_line
+// bit[11:6]  step_0_skip_line
+// bit[5:0]   read_skip_line
+#define   HCODEC_ME_SKIP_LINE                      (0x1f4d)
+#define P_HCODEC_ME_SKIP_LINE                      (volatile unsigned int *)((0x1f4d  << 2) + 0xff620000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x23
+#define   HCODEC_ME_AB_MEM_CTL                     (0x1f4e)
+#define P_HCODEC_ME_AB_MEM_CTL                     (volatile unsigned int *)((0x1f4e  << 2) + 0xff620000)
+// bit[31:24] anc_pic_canvas
+// bit[23:12] max_me_mby_num
+// bit[11:0]  max_me_mbx_num
+#define   HCODEC_ME_PIC_INFO                       (0x1f4f)
+#define P_HCODEC_ME_PIC_INFO                       (volatile unsigned int *)((0x1f4f  << 2) + 0xff620000)
+// bit [23:12] me_sad_enough_1
+// bit [11:0]  me_sad_enough_0
+#define   HCODEC_ME_SAD_ENOUGH_01                  (0x1f50)
+#define P_HCODEC_ME_SAD_ENOUGH_01                  (volatile unsigned int *)((0x1f50  << 2) + 0xff620000)
+// bit [25:12] adv_mv_8x8_enough
+// bit [11:0]  me_sad_enough_2
+#define   HCODEC_ME_SAD_ENOUGH_23                  (0x1f51)
+#define P_HCODEC_ME_SAD_ENOUGH_23                  (volatile unsigned int *)((0x1f51  << 2) + 0xff620000)
+// bit [21:10] me_step0_big_sad
+// bit [9:5] me_step0_close_mv_y
+// bit [4:0] me_step0_close_mv_x
+#define   HCODEC_ME_STEP0_CLOSE_MV                 (0x1f52)
+#define P_HCODEC_ME_STEP0_CLOSE_MV                 (volatile unsigned int *)((0x1f52  << 2) + 0xff620000)
+// bit[31:24] force_skip_sad_3
+// bit[23:16] force_skip_sad_2
+// bit[15:08] force_skip_sad_1
+// bit[07:00] force_skip_sad_0
+#define   HCODEC_ME_F_SKIP_SAD                     (0x1f53)
+#define P_HCODEC_ME_F_SKIP_SAD                     (volatile unsigned int *)((0x1f53  << 2) + 0xff620000)
+// bit[31:24] force_skip_weight_3
+// bit[23:16] force_skip_weight_2
+// bit[15:08] force_skip_weight_1
+// bit[07:00] force_skip_weight_0
+#define   HCODEC_ME_F_SKIP_WEIGHT                  (0x1f54)
+#define P_HCODEC_ME_F_SKIP_WEIGHT                  (volatile unsigned int *)((0x1f54  << 2) + 0xff620000)
+// Merge when (
+//              (flex & me_merge_flex_en) |
+//              (big_sad & me_merge_sad_en)|
+//              ((~me_merge_flex_en)&(~me_merge_sad_en))
+//            ) &
+//            ( small_mv_diff |(~me_merge_small_mv_en))
+//            & (me_merge_flex_en | me_merge_sad_en | me_merge_small_mv_en)
+// bit[31]   me_merge_mv_en_16
+// bit[30]   me_merge_small_mv_en_16
+// bit[29]   me_merge_flex_en_16
+// bit[28]   me_merge_sad_en_16
+// bit[27]   me_merge_mv_en_8
+// bit[26]   me_merge_small_mv_en_8
+// bit[25]   me_merge_flex_en_8
+// bit[24]   me_merge_sad_en_8
+// bit[23:18] me_merge_mv_diff_16
+// bit[17:12] me_merge_mv_diff_8
+// bit[11:0] me_merge_min_sad
+#define   HCODEC_ME_MV_MERGE_CTL                   (0x1f55)
+#define P_HCODEC_ME_MV_MERGE_CTL                   (volatile unsigned int *)((0x1f55  << 2) + 0xff620000)
+// bit[31:24] mv_step_weight_1
+// bit[23:16] mv_pre_weight_1
+// bit [15:0] mv_step_weight_0
+// bit[7:0]   mv_pre_weight_0
+#define   HCODEC_ME_MV_WEIGHT_01                   (0x1f56)
+#define P_HCODEC_ME_MV_WEIGHT_01                   (volatile unsigned int *)((0x1f56  << 2) + 0xff620000)
+// bit[31:24] mv_step_weight_3 (mv_step_weight_1_2nd)
+// bit[23:16] mv_pre_weight_3 (mv_pre_weight_1_2nd)
+// bit[15:8]  mv_step_weight_2
+// bit[7:0]   mv_pre_weight_2
+#define   HCODEC_ME_MV_WEIGHT_23                   (0x1f57)
+#define P_HCODEC_ME_MV_WEIGHT_23                   (volatile unsigned int *)((0x1f57  << 2) + 0xff620000)
+// bit[31:24] me_sad_range_inc_3
+// bit[23:16] me_sad_range_inc_2
+// bit[15:8] me_sad_range_inc_1
+// bit[7:0] me_sad_range_inc_0
+#define   HCODEC_ME_SAD_RANGE_INC                  (0x1f58)
+#define P_HCODEC_ME_SAD_RANGE_INC                  (volatile unsigned int *)((0x1f58  << 2) + 0xff620000)
+// bit[31:19]  reserved
+// bit[18]     sub_relative_any_1_en
+// bit[17]     sub_relative_any_2_en
+// bit[16]     sub_relative_any_3_en
+// bit[15]     sub_relative_any_4_en
+// bit[14]     sub_relative_any_h_en
+// bit[13]     sub_make_non_flex_fix
+// bit[12]     sub_make_big_non_flex_fix
+// bit[11:8]   sub_normal_mv_diff_16
+// bit[7:4]    sub_normal_mv_diff_8
+// bit[3:2]    Reserved
+// bit[1]      sub_merge_enable_16
+// bit[0]      sub_merge_enable_8
+#define   HCODEC_ME_SUB_MERGE_CTL                  (0x1f59)
+#define P_HCODEC_ME_SUB_MERGE_CTL                  (volatile unsigned int *)((0x1f59  << 2) + 0xff620000)
+// bit[31:28]  sub_ref_mv_diff_near
+// bit[27:24]  sub_ref_mv_diff_near_flex
+// bit[23:20]  sub_ref_mv_diff
+// bit[19:16]  sub_ref_mv_diff_flex
+// bit[15:8]   sub_ref_mv_near_weight
+// bit[7:0]    sub_ref_mv_weight
+#define   HCODEC_ME_SUB_REF_MV_CTL                 (0x1f5a)
+#define P_HCODEC_ME_SUB_REF_MV_CTL                 (volatile unsigned int *)((0x1f5a  << 2) + 0xff620000)
+// bit[31:24]  sub_weight_max_sad
+// bit[23:16]  sub_any_range_sad
+// bit[15:8]   sub_any_min_sad
+// bit[7:0]    sub_any_max_sad
+#define   HCODEC_ME_SUB_ANY_WEIGHT_SAD             (0x1f5b)
+#define P_HCODEC_ME_SUB_ANY_WEIGHT_SAD             (volatile unsigned int *)((0x1f5b  << 2) + 0xff620000)
+// bit[31:24]  sub_fix_sad
+// bit[23:16]  sub_fix_diff_sad
+// bit[15:8]   sub_sad_flex_adj
+// bit[7:0]    sub_big_non_flex_fix_sad
+#define   HCODEC_ME_SUB_FIX_SAD                    (0x1f5c)
+#define P_HCODEC_ME_SUB_FIX_SAD                    (volatile unsigned int *)((0x1f5c  << 2) + 0xff620000)
+// bit[31:24]  sub_fix_min_sad
+// bit[23:16]  sub_fix_min_diff_sad
+// bit[15:8]   sub_fix_min_sad_2
+// bit[7:0]    sub_fix_min_diff_sad_2
+#define   HCODEC_ME_SUB_FIX_MIN_SAD                (0x1f5d)
+#define P_HCODEC_ME_SUB_FIX_MIN_SAD                (volatile unsigned int *)((0x1f5d  << 2) + 0xff620000)
+// bit[31:24]  sub_snap_to_ref_max_sad
+// bit[23]     sub_snap_to_ref_non_flex
+// bit[22:16]  sub_snap_to_ref_mv_diff
+// bit[15:4]   sub_glitch_mv_sad
+// bit[3:0]    sub_glitch_mv_diff
+#define   HCODEC_ME_SUB_SNAP_GLITCH                (0x1f5e)
+#define P_HCODEC_ME_SUB_SNAP_GLITCH                (volatile unsigned int *)((0x1f5e  << 2) + 0xff620000)
+// bit[31:20]  sad_act_limit
+// bit[19:8]   s_a_any_sad
+// bit[7]      Reserved
+// bit[6:5]    sub_merge_method
+// bit[4]      use_sub_act_result
+// bit[3]      s_a_rnd
+// bit[2]      Reserved
+// bit[1]      sub_act_en_16
+// bit[0]      sub_act_en
+#define   HCODEC_ME_SUB_ACT_CTL                    (0x1f5f)
+#define P_HCODEC_ME_SUB_ACT_CTL                    (volatile unsigned int *)((0x1f5f  << 2) + 0xff620000)
+// bit[31:16]  reserved
+// bit[15:0]   me_weight
+#define   HCODEC_ME_WEIGHT                         (0x1f60)
+#define P_HCODEC_ME_WEIGHT                         (volatile unsigned int *)((0x1f60  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_0
+// bit[21]  ie_sad_ready_0
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_0
+// bit[15:0] me_sad_0
+#define   HCODEC_ME_SAD_0                          (0x1f61)
+#define P_HCODEC_ME_SAD_0                          (volatile unsigned int *)((0x1f61  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_1
+// bit[21]  me_sad_ready_1
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_1
+// bit[15:0] me_sad_1
+#define   HCODEC_ME_SAD_1                          (0x1f62)
+#define P_HCODEC_ME_SAD_1                          (volatile unsigned int *)((0x1f62  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_2
+// bit[21]  me_sad_ready_2
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_2
+// bit[15:0] me_sad_2
+#define   HCODEC_ME_SAD_2                          (0x1f63)
+#define P_HCODEC_ME_SAD_2                          (volatile unsigned int *)((0x1f63  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] me_quant_3
+// bit[21]  me_sad_ready_3
+// bit[20:18]  Reserved
+// bit[17:16]  me_sad_mv_type_3
+// bit[15:0] me_sad_3
+#define   HCODEC_ME_SAD_3                          (0x1f64)
+#define P_HCODEC_ME_SAD_3                          (volatile unsigned int *)((0x1f64  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_0
+// bit[21]  ie_sad_ready_0
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_0
+#define   HCODEC_IE_SAD_0                          (0x1f65)
+#define P_HCODEC_IE_SAD_0                          (volatile unsigned int *)((0x1f65  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_1
+// bit[21]  ie_sad_ready_1
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_1
+#define   HCODEC_IE_SAD_1                          (0x1f66)
+#define P_HCODEC_IE_SAD_1                          (volatile unsigned int *)((0x1f66  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_2
+// bit[21]  ie_sad_ready_2
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_2
+#define   HCODEC_IE_SAD_2                          (0x1f67)
+#define P_HCODEC_IE_SAD_2                          (volatile unsigned int *)((0x1f67  << 2) + 0xff620000)
+// bit[31]  ready_update
+// bit[30]  data_update
+// bit[29:28] reserved
+// bit[27:22] ie_quant_3
+// bit[21]  ie_sad_ready_3
+// bit[20]   I4/I16 (0-I4MB, 1-I16MB)
+// bit[19:0] ie_sad_3
+#define   HCODEC_IE_SAD_3                          (0x1f68)
+#define P_HCODEC_IE_SAD_3                          (volatile unsigned int *)((0x1f68  << 2) + 0xff620000)
+// bit[31]   enable_large_diff_16x8
+// bit[30]   enable_large_diff_8x16
+// bit[29:16] adv_mv_8x8_weight
+// bit[15:14] reserved
+// bit[13:0] adv_mv_4x4x4_weight
+#define   HCODEC_ADV_MV_CTL0                       (0x1f69)
+#define P_HCODEC_ADV_MV_CTL0                       (volatile unsigned int *)((0x1f69  << 2) + 0xff620000)
+// bit[31:16] adv_mv_16x16_weight
+// bit[15]   enable_large_diff_16x16
+// bit[14:0] adv_mv_16_8_weight
+#define   HCODEC_ADV_MV_CTL1                       (0x1f6a)
+#define P_HCODEC_ADV_MV_CTL1                       (volatile unsigned int *)((0x1f6a  << 2) + 0xff620000)
+#define   HCODEC_ADV_MV_CTL2                       (0x1f6b)
+#define P_HCODEC_ADV_MV_CTL2                       (volatile unsigned int *)((0x1f6b  << 2) + 0xff620000)
+// bit[31]    v3_skip_enable
+// bit[30]    v3_step_1_weight_enable // for step1, will only use pre_weight for block0, only step_weight for block 1,2,3
+// bit[29]    v3_l2_skip_only_use_l2_sad // set to 1 may allow l1 maybe not skip
+// bit[28]    v3_mv_sad_weight_enable
+// bit[27]    v3_ipred_type_enable
+// bit[25:12] force_skip_sad_1
+// bit[11:0]  force_skip_sad_0
+#define   HCODEC_V3_SKIP_CONTROL                   (0x1f6c)
+#define P_HCODEC_V3_SKIP_CONTROL                   (volatile unsigned int *)((0x1f6c  << 2) + 0xff620000)
+// bit[18:16] top_ipred_type_count
+// bit[15:14] Reserved
+// bit[13:12] top_ipred_type_rd_idx
+// bit[11:10] top_ipred_type_wr_idx
+// bit[9]   left_ipred_type_ready
+// bit[8]   top_ipred_type_ready
+// bit[7:6] left_mv_idx
+// bit[5:4] top_mv_idx
+// bit[3] - left_mv_ready
+// bit[2:0] top_mv_ready
+#define   HCODEC_V3_TOP_LEFT_CTL                   (0x1f6d)
+#define P_HCODEC_V3_TOP_LEFT_CTL                   (volatile unsigned int *)((0x1f6d  << 2) + 0xff620000)
+#define   HCODEC_V3_TOP_MV                         (0x1f6e)
+#define P_HCODEC_V3_TOP_MV                         (volatile unsigned int *)((0x1f6e  << 2) + 0xff620000)
+#define   HCODEC_V3_LEFT_MV                        (0x1f6f)
+#define P_HCODEC_V3_LEFT_MV                        (volatile unsigned int *)((0x1f6f  << 2) + 0xff620000)
+// bit[31:30] reserved
+// bit[29:16] v3_skip_weight_1
+// bit[15:12] reserved
+// bit[11:0]  v3_skip_weight_0
+#define   HCODEC_V3_SKIP_WEIGHT                    (0x1f70)
+#define P_HCODEC_V3_SKIP_WEIGHT                    (volatile unsigned int *)((0x1f70  << 2) + 0xff620000)
+// bit[31:28] reserved
+// bit[27:16] v3_l1_f_skip_max_sad
+// bit[15:12] reserved
+// bit[11:0]  v3_l1_skip_max_sad
+#define   HCODEC_V3_L1_SKIP_MAX_SAD                (0x1f71)
+#define P_HCODEC_V3_L1_SKIP_MAX_SAD                (volatile unsigned int *)((0x1f71  << 2) + 0xff620000)
+// bit[31:16] force_skip_sad_2
+// bit[15:0]  v3_skip_weight_2
+#define   HCODEC_V3_L2_SKIP_WEIGHT                 (0x1f72)
+#define P_HCODEC_V3_L2_SKIP_WEIGHT                 (volatile unsigned int *)((0x1f72  << 2) + 0xff620000)
+// bit[21:16] v3_mv_sad_table_addr 0-15 table_step_0
+// bit[11:0]  v3_mv_sad
+#define   HCODEC_V3_MV_SAD_TABLE                   (0x1f73)
+#define P_HCODEC_V3_MV_SAD_TABLE                   (volatile unsigned int *)((0x1f73  << 2) + 0xff620000)
+// [31:16] v3_ie_f_zero_sad_i16
+// [15:0]  v3_ie_f_zero_sad_i4
+#define   HCODEC_V3_F_ZERO_CTL_0                   (0x1f74)
+#define P_HCODEC_V3_F_ZERO_CTL_0                   (volatile unsigned int *)((0x1f74  << 2) + 0xff620000)
+// [25]    v3_no_ver_when_top_zero_en
+// [24]    v3_no_hor_when_left_zero_en
+// [23:16] v3_max_I16_H_num    // 0 means no break
+// [15:0]  v3_me_f_zero_sad
+#define   HCODEC_V3_F_ZERO_CTL_1                   (0x1f75)
+#define P_HCODEC_V3_F_ZERO_CTL_1                   (volatile unsigned int *)((0x1f75  << 2) + 0xff620000)
+#define   HCODEC_V3_TOP_INTRA_INFO                 (0x1f76)
+#define P_HCODEC_V3_TOP_INTRA_INFO                 (volatile unsigned int *)((0x1f76  << 2) + 0xff620000)
+#define   HCODEC_V3_LEFT_INTRA_INFO                (0x1f77)
+#define P_HCODEC_V3_LEFT_INTRA_INFO                (volatile unsigned int *)((0x1f77  << 2) + 0xff620000)
+// [31:24]  C_ipred_weight_H
+// [23:16]  C_ipred_weight_V
+// [15:8]   I4_ipred_weight_else
+// [7:0]    I4_ipred_weight_most
+#define   HCODEC_V3_IPRED_TYPE_WEIGHT_0            (0x1f78)
+#define P_HCODEC_V3_IPRED_TYPE_WEIGHT_0            (volatile unsigned int *)((0x1f78  << 2) + 0xff620000)
+// [31:24]  I16_ipred_weight_DC
+// [23:16]  I16_ipred_weight_H
+// [15:8]   I16_ipred_weight_V
+// [7:0]    C_ipred_weight_DC
+#define   HCODEC_V3_IPRED_TYPE_WEIGHT_1            (0x1f79)
+#define P_HCODEC_V3_IPRED_TYPE_WEIGHT_1            (volatile unsigned int *)((0x1f79  << 2) + 0xff620000)
+// [31:16]  v3_left_small_max_me_sad
+// [15:0]   v3_left_small_max_ie_sad
+#define   HCODEC_V3_LEFT_SMALL_MAX_SAD             (0x1f7a)
+#define P_HCODEC_V3_LEFT_SMALL_MAX_SAD             (volatile unsigned int *)((0x1f7a  << 2) + 0xff620000)
+// (qr==7) & (qp==15) means force zero block
+// [31:26]  v4_force_q_r_intra
+// [25:20]  v4_force_q_r_inter
+// [19]     v4_force_q_y_enable
+// [18:16]  v4_force_qr_y
+// [15:12]  v4_force_qp_y
+// [11:0]   v4_force_skip_sad
+#define   HCODEC_V4_FORCE_SKIP_CFG                 (0x1f7b)
+#define P_HCODEC_V4_FORCE_SKIP_CFG                 (volatile unsigned int *)((0x1f7b  << 2) + 0xff620000)
+// v5 Complexity // Y(256 pixel per MB) and C(128 pixel per MB)
+// For every 4x4 block, calculate average and Add abs(pixel-average) together
+// bit[31:16] v5_diff_sum_C
+// bit[15:0]  v5_diff_sum_Y
+#define   HCODEC_V5_MB_DIFF_SUM                    (0x1f7c)
+#define P_HCODEC_V5_MB_DIFF_SUM                    (volatile unsigned int *)((0x1f7c  << 2) + 0xff620000)
+// bit[31:24] v5_small_diff_cnt_C
+// bit[23:16] v5_small_diff_C
+// bit[15:8]  v5_small_diff_cnt_Y
+// bit[7:0]   v5_small_diff_Y
+#define   HCODEC_V5_SMALL_DIFF_CNT                 (0x1f7d)
+#define P_HCODEC_V5_SMALL_DIFF_CNT                 (volatile unsigned int *)((0x1f7d  << 2) + 0xff620000)
+// bit[31:29] Reserved
+// bit[28:24] v5_simple_block_cnt // 0 -15 Y 16-23 C
+// bit[23:20] v5_simple_pixel_cnt
+// bit[19:18] v5_simple_dq_wr_ptr
+// bit[17:16] v5_simple_dq_rd_ptr
+// bit[15:12] v5_simple_dq (Read Only)
+// bit[11:8]  v5_simple_me_weight(Read Only)
+// bit[7] v5_use_small_diff_cnt
+// bit[6] v5_simple_mb_inter_all_en
+// bit[5] v5_simple_mb_inter_8x8_en
+// bit[4] v5_simple_mb_inter_16_8_en
+// bit[3] v5_simple_mb_inter_16x16_en
+// bit[2] v5_simple_mb_intra_en
+// bit[1] v5_simple_mb_C_en
+// bit[0] v5_simple_mb_Y_en
+#define   HCODEC_V5_SIMPLE_MB_CTL                  (0x1f7e)
+#define P_HCODEC_V5_SIMPLE_MB_CTL                  (volatile unsigned int *)((0x1f7e  << 2) + 0xff620000)
+// bit[31:28] v5_simple_dq_shift
+// bit[27:24] v5_simple_dq_6(-7 to +7)
+// bit[23:20] v5_simple_dq_5(-7 to +7)
+// bit[19:16] v5_simple_dq_4(-7 to +7)
+// bit[15:12] v5_simple_dq_3(-7 to +7)
+// bit[11:08] v5_simple_dq_2(-7 to +7)
+// bit[07:04] v5_simple_dq_1(-7 to +7)
+// bit[03:00] v5_simple_dq_0(-7 to +7)
+#define   HCODEC_V5_SIMPLE_MB_DQUANT               (0x1f7f)
+#define P_HCODEC_V5_SIMPLE_MB_DQUANT               (volatile unsigned int *)((0x1f7f  << 2) + 0xff620000)
+// bit[31:28] v5_simple_me_weight_shift
+// bit[27:24] v5_simple_me_weight_6(-7 to +7)
+// bit[23:20] v5_simple_me_weight_5(-7 to +7)
+// bit[19:16] v5_simple_me_weight_4(-7 to +7)
+// bit[15:12] v5_simple_me_weight_3(-7 to +7)
+// bit[11:08] v5_simple_me_weight_2(-7 to +7)
+// bit[07:04] v5_simple_me_weight_1(-7 to +7)
+// bit[03:00] v5_simple_me_weight_0(-7 to +7)
+#define   HCODEC_V5_SIMPLE_MB_ME_WEIGHT            (0x1f80)
+#define P_HCODEC_V5_SIMPLE_MB_ME_WEIGHT            (volatile unsigned int *)((0x1f80  << 2) + 0xff620000)
+//
+// Closing file:  qdct_regs.h
+//
+
+#endif // DOS_REGISTER_H
+
+#if 0
+#define Wr(addr, data) *(volatile uint32_t *)(addr)=(data)
+#define Rd(addr) *(volatile uint32_t *)(addr)
+#define Wr_reg_bits(reg, val, start, len) \
+  Wr(reg, ((Rd(reg) & ~(((1L<<(len))-1)<<(start))) | ((uint32_t)(val) << (start))))
+#endif
+
+//
+// Reading file:  ./register_map.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Reading file:  stb_define.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  STB_CBUS_BASE = 0x18
+// -----------------------------------------------
+// There are two instantiations under one CBUS slave.  Each CBUS slave can support
+// 256 registers.  Each demux is allocated 128 registers so set the offset in
+// the middle
+// Copy this define but don't add a base address
+#define SECOND_DEMUX_OFFSET_0  0x50
+#define THIRD_DEMUX_OFFSET_0   0xa0
+//========================================================================
+//  STB TOP Registers				    (8'hf0 - 8'hf7)
+//========================================================================
+// bit 30:28 -- ciplus_o_sel
+// bit 27:26 -- ciplus_i_sel
+// bit 25 -- use FAIL fro TS2
+// bit 24 -- use FAIL fro TS1
+// bit 23 -- use FAIL fro TS0
+// bit 22 -- invert fec_error for S2P1
+// bit 21 -- invert fec_data for S2P1
+// bit 20 -- invert fec_sync for S2P1
+// bit 19 -- invert fec_valid for S2P1
+// bit 18 -- invert fec_clk for S2P1
+// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+// Bit 15 -- enable_des_pl_clk
+// Bit 14:13 -- reserved
+// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
+// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
+// bit 7 -- enable_des_pl
+// bit 6 -- invert fec_error for S2P0
+// bit 5 -- invert fec_data for S2P0
+// bit 4 -- invert fec_sync for S2P0
+// bit 3 -- invert fec_valid for S2P0
+// bit 2 -- invert fec_clk for S2P0
+// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+#define   STB_TOP_CONFIG                           (0x18f0)
+#define P_STB_TOP_CONFIG                           (volatile unsigned int *)((0x18f0  << 2) + 0xffd00000)
+// 31:28 - s2p1_clk_div
+// 27:24 - s2p0_clk_div
+// 23    - s2p1_disable
+// 22    - s2p0_disable
+// 21    - Reserved
+// 20 -- TS_OUT_error_INVERT
+// 19 -- TS_OUT_data_INVERT
+// 18 -- TS_OUT_sync_INVERT
+// 17 -- TS_OUT_valid_INVERT
+// 16 -- TS_OUT_clk_INVERT
+// 15:8 -- TS_package_length_sub_1 (default : 187)
+//  7:0 -- fec_sync_byte (default : 0x47)
+#define   TS_TOP_CONFIG                            (0x18f1)
+#define P_TS_TOP_CONFIG                            (volatile unsigned int *)((0x18f1  << 2) + 0xffd00000)
+// Bit 25:24 -- transport_scrambling_control_odd_2 // should be 3
+// Bit 23:16 -- file_m2ts_skip_bytes
+// Bit 15:8 -- des_out_dly
+// Bit 7:6 -- transport_scrambling_control_odd // should be 3
+// Bit 5 -- ts_hiu_enable
+// Bit 4:0 -- fec_clk_div
+#define   TS_FILE_CONFIG                           (0x18f2)
+#define P_TS_FILE_CONFIG                           (volatile unsigned int *)((0x18f2  << 2) + 0xffd00000)
+// Bit 19:14 -- des_2 ts pl state   -- Read Only
+// Bit 13:8 -- des ts pl state   -- Read Only
+// Bit 3:0 PID index to 8 PID to get key-set
+// auto increse after TS_PL_PID_DATA read/write
+#define   TS_PL_PID_INDEX                          (0x18f3)
+#define P_TS_PL_PID_INDEX                          (volatile unsigned int *)((0x18f3  << 2) + 0xffd00000)
+// Bit 13 -- PID match disble
+// Bit 12:0 -- PID
+#define   TS_PL_PID_DATA                           (0x18f4)
+#define P_TS_PL_PID_DATA                           (volatile unsigned int *)((0x18f4  << 2) + 0xffd00000)
+#define   COMM_DESC_KEY0                           (0x18f5)
+#define P_COMM_DESC_KEY0                           (volatile unsigned int *)((0x18f5  << 2) + 0xffd00000)
+#define   COMM_DESC_KEY1                           (0x18f6)
+#define P_COMM_DESC_KEY1                           (volatile unsigned int *)((0x18f6  << 2) + 0xffd00000)
+#define   COMM_DESC_KEY_RW                         (0x18f7)
+#define P_COMM_DESC_KEY_RW                         (volatile unsigned int *)((0x18f7  << 2) + 0xffd00000)
+// CI+ Register defines
+// Bits[31:0] of the key
+#define   CIPLUS_KEY0                              (0x18f8)
+#define P_CIPLUS_KEY0                              (volatile unsigned int *)((0x18f8  << 2) + 0xffd00000)
+// Bits[63:32] of the key
+#define   CIPLUS_KEY1                              (0x18f9)
+#define P_CIPLUS_KEY1                              (volatile unsigned int *)((0x18f9  << 2) + 0xffd00000)
+// Bits[95:64] of the key
+#define   CIPLUS_KEY2                              (0x18fa)
+#define P_CIPLUS_KEY2                              (volatile unsigned int *)((0x18fa  << 2) + 0xffd00000)
+// Bits[127:96] of the key
+#define   CIPLUS_KEY3                              (0x18fb)
+#define P_CIPLUS_KEY3                              (volatile unsigned int *)((0x18fb  << 2) + 0xffd00000)
+// bit[5] write AES IV B value
+// bit[4] write AES IV A value
+// bit[3] write AES B key
+// bit[2] write AES A key
+// bit[1] write DES B key
+// bit[0] write DES A key
+#define   CIPLUS_KEY_WR                            (0x18fc)
+#define P_CIPLUS_KEY_WR                            (volatile unsigned int *)((0x18fc  << 2) + 0xffd00000)
+// [15:8]   TS out delay.  This controls the rate at which the CIplus module drives TS out
+// [3]      General enable for the ciplus module
+// [2]      AES CBC disable (default should be 0 to enable AES CBC)
+// [1]      AES Enable
+// [0]      DES Eanble
+#define   CIPLUS_CONFIG                            (0x18fd)
+#define P_CIPLUS_CONFIG                            (volatile unsigned int *)((0x18fd  << 2) + 0xffd00000)
+// bit[31:28] AES IV endian
+// bit[27:24] AES message out endian
+// bit[23:20] AES message in endian
+// bit[19:16] AES key endian
+// bit[15:11]  unused
+// bit[10:8]  DES message out endian
+// bit[6:4]   DES message in endian
+// bit[2:0]   DES key endian
+#define   CIPLUS_ENDIAN                            (0x18fe)
+#define P_CIPLUS_ENDIAN                            (volatile unsigned int *)((0x18fe  << 2) + 0xffd00000)
+// bit 15:8 - des_out_dly_2
+// bit   7 - reserved
+// Bit   6-- enable_des_pl_clk_2
+// bit   5 - enable_des_pl_2
+// bit 4:2 -- use_des_2  bit[2] -- demux0, bit[3] -- demux1, bit[4] -- demux2
+// bit 1:0 -- des_i_sel_2 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
+#define   COMM_DESC_2_CTL                          (0x18ff)
+#define P_COMM_DESC_2_CTL                          (volatile unsigned int *)((0x18ff  << 2) + 0xffd00000)
+//
+// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
+//        Instead, since the demux has multiple instances (and many registers) use a separate
+//        script to create a separate stb_define.h for C-code.
+//========================================================================
+//  STB Registers				    (8'h00 - 8'h4f)
+//
+//========================================================================
+// STB registers are 8'h0x
+// Bit 15:0 -- version number : 0x0002  (v0.01)
+// Bit 15 -- fec_core_select 1 - select descramble output
+// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
+// Bit 11 -- FEC_CLK
+// Bit 10 -- SOP
+// Bit 9 -- D_VALID
+// Bit 8 -- D_FAIL
+// Bit 7:0 -- D_DATA 7:0
+// bit 31 -- enable_free_clk_fec_data_valid
+// bit 30 -- enable_free_clk_stb_reg
+// bit 29 -- always_use_pes_package_length
+// bit 28 -- disable_pre_incomplete_section_fix
+// bit 27 -- pointer_field_multi_pre_en
+// bit 26 -- ignore_pre_incomplete_section
+// bit 25 -- video2_enable
+// bit 24:22 -- video2_type
+// bit 21 -- do_not_trust_pes_package_length
+// bit 20 (bit 4) -- Bypass use recoder path
+// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
+// bit 18 (bit 2) -- Disable Splicing
+// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
+// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
+// Bit 15 - do not trust section length
+// Bit 14 - om cmd push even zero
+// Bit 13 - set_buff_ready_even_not_busy
+// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
+// Bit 11 - discard_av_package -- for ts_recorder use only
+// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
+// Bit 9 - ts_recorder_enable
+// Bit 8 - (table_id == 0xff) means section_end
+// Bit 7 - do not send uncomplete section
+// Bit 6 - do not discard duplicate package
+// Bit 5 - search SOP when trasport_error_indicator
+// Bit 4 - stb demux enable
+// Bit 3 - do not reset state machine on SOP
+// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
+// Bit 1 - do not use SOP input ( check FEC sync byte instead )
+// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
+// bit 15:8 demux package length - 1 ( default : 187 )
+// bit 7:0 default is 0x47
+// bit 31:16 -- filter memory write data hi[31:16]
+// bit 15:0 -- filter memory write data low [15:0]
+// bit 31:24 -- advanced setting hi
+// bit 23:16 -- advanced setting low
+// bit 15 -- filter memory write data request
+// bit 7:0 -- filter memory write addr
+// bit 13:8 demux state  -- read only
+// bit 7:4 -- maxnum section filter compare address
+// bit 3:0 -- maxnum PID filter compare address
+// bit 15 - transport_error_indicator
+// bit 14 - payload_unit_start_indicator
+// bit 13 - transport_priority
+// bit 12:0 - PID
+// bit 7:6 transport_scrambling_control
+// bit 5:4 adaptation_field_control
+// bit 3:0 continuity_counter
+// bit 15:12 -- om_cmd_count (read only)
+// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
+// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
+// bit   5:3 -- type_stb_om_w_rd (read only)
+// bit     2 -- unit_start_stb_om_w_rd (read only)
+// bit     1 -- om_cmd_overflow (read only)
+// bit     0 -- om_cmd_pending (read)
+// bit     0 -- om_cmd_read_finished (write)
+// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
+// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
+// bit 11:0 -- offset for section data
+// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
+// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
+// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
+// bit 7:4 -- section buffer size for group 1
+// bit 11:8 -- section buffer size for group 2
+// bit 15:12 -- section buffer size for group 3
+// section buffer busy status for buff 31:0 ( Read Only )
+// section buffer write status for buff 31:0 -- Read
+// clear buffer status ( buff READY and BUSY ) -- write
+// bit 4:0 -- SEC_BUFFER_INDEX   RW
+// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
+// bit 14 -- output_section_buffer_valid
+// bit 15 -- section_reset_busy (Read Only)
+// bit 9:5 -- BYPASS PID number
+// bit 4:0 -- PCR PID number
+// bit 15:0 -- stream_id filter bit enable
+// bit 7:0 -- stream_id filter target
+// bit 12 -- PCR_EN
+// bit 11:0 -- PCR90K_DIV
+// bit 31:0 -- PCR[31:0] R/W
+// bit 31:0 -- VPTS[31:0] R/W
+// bit 31:0 -- VDTS[31:0] R/W
+// bit 31:0 -- APTS[31:0] R/W
+// bit 31:0 -- SPTS[31:0] R/W
+// read -- status, write 1 clear status
+// bit 15 -- SUB_PTS[32]
+// bit 14 -- AUDIO_PTS[32]
+// bit 13 -- VIDEO_DTS[32]
+// bit 12 -- VIDEO_PTS[32]
+// bit 3 -- sub_pts_ready
+// bit 2 -- audio_pts_ready
+// bit 1 -- video_dts_ready
+// bit 0 -- video_pts_ready
+// bit 3:0 --
+//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]
+//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
+//  2 -- pes_package_bytes_left[15:0]
+//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
+//
+// read only
+// bit[31] -- no_match_record_en
+// bit[30:16] - reserved
+// default : 0x807f
+// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)
+// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
+// 15:0  WRITE 1 CLEAR to clear interrupt source
+//12 -- INPUT_TIME_OUT
+//11 -- PCR_ready
+//10 -- audio_splicing_point
+// 9 -- video_splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN
+// Bit 5:3 - demux om write endian control for bypass
+// Bit 2:0 - demux om write endian control for section
+// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
+// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
+// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
+// Bit 17:15 - demux om write endian control for SUB_PACKET
+// Bit 14:12 - demux om write endian control for AUDIO_PACKET
+// Bit 11:9  - demux om write endian control for VIDEO_PACKET
+//
+// When Bit 31 - 0 write will indicate all type else use Bit 8:6
+// Bit 8:6 - demux om write endian control for else
+// Bit 15:8 -- last_burst_threshold
+// Bit 7 -- use hi_bsf interface
+// Bit 6:2 - fec_clk_div
+// Bit 1 ts_source_sel
+// Bit 0 - Hiu TS generate enable
+// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
+// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
+// bit 10 -- mask bit for SUB_AHB_DMA_EN
+// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
+// bit 8 -- mask bit for SECTION_AHB_DMA_EN
+// bit 7 -- mask bit for recoder stream
+// bit 6:0 -- mask bit for each type
+// bit 31:0 -- vb_wr_ptr for video PDTS
+// bit 31:0 -- ab_wr_ptr for audio PDTS
+// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
+// bit 19:0 -- SB_START (sb_start << 12 == byte address);
+// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)
+// bit 31:0 -- sb_wr_ptr for sub PES
+// bit 31:16 -- ob_wr_ptr for other PES
+// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
+// bit 19:0 -- OB_START (ob_start << 12 == byte address);
+// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)
+// bit 31:0 -- ob_wr_ptr for sub PES
+// 15:0  DEMUX interrupt MASK
+// 9 -- splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN
+// 31:16 VIDEO PID filter data
+//15 -- splicing VIDEO PID change enable
+//14:10 -- VIDEO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only)
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+// 31:16 AUDIO PID filter data
+//15 -- splicing AUDIO PID change enable
+//14:10 -- AUDIO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only)
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+// 23:16 M2TS_SKIP_BYTES
+// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
+// 7:0  PACKAGE BYTE COUNT (Read Only)
+// 15:0 2 bytes strong sync add to PES
+// bit 15 -- stb_om_ren
+// bit 14:11 -- reserved
+// bit  10:0 -- OM_DATA_RD_ADDR
+// bit 15:0 -- OM_DATA_RD
+// AUTO STOP SETTING for 32 channels
+// 4-nbits per channel
+// when write
+// bit 3 -- set section active
+// bit 2:0 -- auto stop after count (0 means never stop)
+// when read
+// bit 3 -- current active status (1 - active, 0 - stopped )
+// bit 2:0 -- count down to auto stop
+// section 31:24
+// section 23:16
+// section 15:8
+// section 7:0
+// bit 31:0 reset channel status - each bit reset each channel
+// read -- 32 channel status
+// bit 4 -- video_stamp_use_dts
+// bit 3 -- audio_stamp_sync_1_en
+// bit 2 -- audio_stamp_insert_en
+// bit 1 -- video_stamp_sync_1_en
+// bit 0 -- video_stamp_insert_en
+// Write : Bit[4:0] secter filter number for reset
+// Read  : select according to output_section_buffer_valid :
+//         per bit per section buffer valid status
+//         or section_buffer_ignore
+// bit[31:0] - channel_reset_timeout_disable
+// bit[31] - no_match_reset_timeout_disable
+// bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count
+// bit[31:0] - channel_packet_count_disable
+// bit[31] - no_match_packet_count_disable
+// bit[30:0] input_packet_count
+// bit[31:0] channel_record_enable
+// bit[31:0] channel_process_enable
+// bit[31:24] small_sec_size ((n+1) * 256 Bytes)
+// bit[23:16] small_sec_rd_ptr
+// bit[15:8]  small_sec_wr_ptr
+// bit[7:2]   reserved
+// bit[1] small_sec_wr_ptr_wr_enable
+// bit[0] small_section_enable
+// bit[31:0] small_sec_start_addr
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  stb_define.h
+//
+//
+// Reading file:  periphs_reg.h
+//
+// $periphs/rtl/periphs_core register defines for the
+// APB bus
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  SC_CBUS_BASE = 0x94
+// -----------------------------------------------
+#define   SMARTCARD_REG0                           (0x9400)
+#define P_SMARTCARD_REG0                           (volatile unsigned int *)((0x9400  << 2) + 0xffd00000)
+#define   SMARTCARD_REG1                           (0x9401)
+#define P_SMARTCARD_REG1                           (volatile unsigned int *)((0x9401  << 2) + 0xffd00000)
+#define   SMARTCARD_REG2                           (0x9402)
+#define P_SMARTCARD_REG2                           (volatile unsigned int *)((0x9402  << 2) + 0xffd00000)
+#define   SMARTCARD_STATUS                         (0x9403)
+#define P_SMARTCARD_STATUS                         (volatile unsigned int *)((0x9403  << 2) + 0xffd00000)
+#define   SMARTCARD_INTR                           (0x9404)
+#define P_SMARTCARD_INTR                           (volatile unsigned int *)((0x9404  << 2) + 0xffd00000)
+#define   SMARTCARD_REG5                           (0x9405)
+#define P_SMARTCARD_REG5                           (volatile unsigned int *)((0x9405  << 2) + 0xffd00000)
+#define   SMARTCARD_REG6                           (0x9406)
+#define P_SMARTCARD_REG6                           (volatile unsigned int *)((0x9406  << 2) + 0xffd00000)
+#define   SMARTCARD_FIFO                           (0x9407)
+#define P_SMARTCARD_FIFO                           (volatile unsigned int *)((0x9407  << 2) + 0xffd00000)
+#define   SMARTCARD_REG8                           (0x9408)
+#define P_SMARTCARD_REG8                           (volatile unsigned int *)((0x9408  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  UART0_CBUS_BASE = 0x90
+// -----------------------------------------------
+#define   UART0_WFIFO                              (0x9000)
+#define P_UART0_WFIFO                              (volatile unsigned int *)((0x9000  << 2) + 0xffd00000)
+#define   UART0_RFIFO                              (0x9001)
+#define P_UART0_RFIFO                              (volatile unsigned int *)((0x9001  << 2) + 0xffd00000)
+#define   UART0_CONTROL                            (0x9002)
+#define P_UART0_CONTROL                            (volatile unsigned int *)((0x9002  << 2) + 0xffd00000)
+#define   UART0_STATUS                             (0x9003)
+#define P_UART0_STATUS                             (volatile unsigned int *)((0x9003  << 2) + 0xffd00000)
+#define   UART0_MISC                               (0x9004)
+#define P_UART0_MISC                               (volatile unsigned int *)((0x9004  << 2) + 0xffd00000)
+#define   UART0_REG5                               (0x9005)
+#define P_UART0_REG5                               (volatile unsigned int *)((0x9005  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  UART1_CBUS_BASE = 0x8c
+// -----------------------------------------------
+#define   UART1_WFIFO                              (0x8c00)
+#define P_UART1_WFIFO                              (volatile unsigned int *)((0x8c00  << 2) + 0xffd00000)
+#define   UART1_RFIFO                              (0x8c01)
+#define P_UART1_RFIFO                              (volatile unsigned int *)((0x8c01  << 2) + 0xffd00000)
+#define   UART1_CONTROL                            (0x8c02)
+#define P_UART1_CONTROL                            (volatile unsigned int *)((0x8c02  << 2) + 0xffd00000)
+#define   UART1_STATUS                             (0x8c03)
+#define P_UART1_STATUS                             (volatile unsigned int *)((0x8c03  << 2) + 0xffd00000)
+#define   UART1_MISC                               (0x8c04)
+#define P_UART1_MISC                               (volatile unsigned int *)((0x8c04  << 2) + 0xffd00000)
+#define   UART1_REG5                               (0x8c05)
+#define P_UART1_REG5                               (volatile unsigned int *)((0x8c05  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  UART2_CBUS_BASE = 0x88
+// -----------------------------------------------
+#define   UART2_WFIFO                              (0x8800)
+#define P_UART2_WFIFO                              (volatile unsigned int *)((0x8800  << 2) + 0xffd00000)
+#define   UART2_RFIFO                              (0x8801)
+#define P_UART2_RFIFO                              (volatile unsigned int *)((0x8801  << 2) + 0xffd00000)
+#define   UART2_CONTROL                            (0x8802)
+#define P_UART2_CONTROL                            (volatile unsigned int *)((0x8802  << 2) + 0xffd00000)
+#define   UART2_STATUS                             (0x8803)
+#define P_UART2_STATUS                             (volatile unsigned int *)((0x8803  << 2) + 0xffd00000)
+#define   UART2_MISC                               (0x8804)
+#define P_UART2_MISC                               (volatile unsigned int *)((0x8804  << 2) + 0xffd00000)
+#define   UART2_REG5                               (0x8805)
+#define P_UART2_REG5                               (volatile unsigned int *)((0x8805  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  UART3_CBUS_BASE = 0x84
+// -----------------------------------------------
+#define   UART3_DF_REG_A73                         (0x8400)
+#define P_UART3_DF_REG_A73                         (volatile unsigned int *)((0x8400  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A74                         (0x8401)
+#define P_UART3_DF_REG_A74                         (volatile unsigned int *)((0x8401  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A75                         (0x8402)
+#define P_UART3_DF_REG_A75                         (volatile unsigned int *)((0x8402  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A76                         (0x8403)
+#define P_UART3_DF_REG_A76                         (volatile unsigned int *)((0x8403  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A77                         (0x8404)
+#define P_UART3_DF_REG_A77                         (volatile unsigned int *)((0x8404  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A78                         (0x8405)
+#define P_UART3_DF_REG_A78                         (volatile unsigned int *)((0x8405  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A79                         (0x8406)
+#define P_UART3_DF_REG_A79                         (volatile unsigned int *)((0x8406  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A80                         (0x8407)
+#define P_UART3_DF_REG_A80                         (volatile unsigned int *)((0x8407  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A81                         (0x8408)
+#define P_UART3_DF_REG_A81                         (volatile unsigned int *)((0x8408  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A82                         (0x8409)
+#define P_UART3_DF_REG_A82                         (volatile unsigned int *)((0x8409  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A83                         (0x8410)
+#define P_UART3_DF_REG_A83                         (volatile unsigned int *)((0x8410  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A84                         (0x8411)
+#define P_UART3_DF_REG_A84                         (volatile unsigned int *)((0x8411  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A85                         (0x8412)
+#define P_UART3_DF_REG_A85                         (volatile unsigned int *)((0x8412  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A86                         (0x8413)
+#define P_UART3_DF_REG_A86                         (volatile unsigned int *)((0x8413  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A87                         (0x8414)
+#define P_UART3_DF_REG_A87                         (volatile unsigned int *)((0x8414  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A88                         (0x8415)
+#define P_UART3_DF_REG_A88                         (volatile unsigned int *)((0x8415  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A89                         (0x8416)
+#define P_UART3_DF_REG_A89                         (volatile unsigned int *)((0x8416  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A96                         (0x8417)
+#define P_UART3_DF_REG_A96                         (volatile unsigned int *)((0x8417  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A97                         (0x8418)
+#define P_UART3_DF_REG_A97                         (volatile unsigned int *)((0x8418  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A128                        (0x8420)
+#define P_UART3_DF_REG_A128                        (volatile unsigned int *)((0x8420  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A129                        (0x8421)
+#define P_UART3_DF_REG_A129                        (volatile unsigned int *)((0x8421  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A130                        (0x8422)
+#define P_UART3_DF_REG_A130                        (volatile unsigned int *)((0x8422  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A131                        (0x8423)
+#define P_UART3_DF_REG_A131                        (volatile unsigned int *)((0x8423  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A132                        (0x8424)
+#define P_UART3_DF_REG_A132                        (volatile unsigned int *)((0x8424  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A133                        (0x8425)
+#define P_UART3_DF_REG_A133                        (volatile unsigned int *)((0x8425  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A134                        (0x8426)
+#define P_UART3_DF_REG_A134                        (volatile unsigned int *)((0x8426  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A135                        (0x8427)
+#define P_UART3_DF_REG_A135                        (volatile unsigned int *)((0x8427  << 2) + 0xffd00000)
+#define   UART3_DF_REG_A136                        (0x8428)
+#define P_UART3_DF_REG_A136                        (volatile unsigned int *)((0x8428  << 2) + 0xffd00000)
+// ----------------------------
+// SANA (Stream Analyzer)
+// ----------------------------
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  SANA_CBUS_BASE = 0x30
+// -----------------------------------------------
+// [31:16] - ddr_setting
+// [15]    - disable_stream_clock_gating
+// [14:13] - mem_pd_ctl_sana
+// [6:4]   - stream_fetch_endian
+// [3]     - use_parser_vbuf_wp
+// [2]     - use_parser_vbuf2_wp
+// [1]     - stream_fetch_busy - Read Only
+// [0]     - stream_fetch_enable
+#define   SANA_STREAM_CONTROL                      (0x3020)
+#define P_SANA_STREAM_CONTROL                      (volatile unsigned int *)((0x3020  << 2) + 0xffd00000)
+#define   SANA_STREAM_START_ADDR                   (0x3021)
+#define P_SANA_STREAM_START_ADDR                   (volatile unsigned int *)((0x3021  << 2) + 0xffd00000)
+#define   SANA_STREAM_END_ADDR                     (0x3022)
+#define P_SANA_STREAM_END_ADDR                     (volatile unsigned int *)((0x3022  << 2) + 0xffd00000)
+// SW stream_buffer_wr_ptr
+#define   SANA_STREAM_WR_PTR                       (0x3023)
+#define P_SANA_STREAM_WR_PTR                       (volatile unsigned int *)((0x3023  << 2) + 0xffd00000)
+#define   SANA_STREAM_RD_PTR                       (0x3024)
+#define P_SANA_STREAM_RD_PTR                       (volatile unsigned int *)((0x3024  << 2) + 0xffd00000)
+//[31:0] stream_buffer_level - read only
+#define   SANA_STREAM_LEVEL                        (0x3025)
+#define P_SANA_STREAM_LEVEL                        (volatile unsigned int *)((0x3025  << 2) + 0xffd00000)
+// [31:29] stream_buffer_hole 256*(4^0) bytes
+// [28:23] stream_fifo_hole
+// [22:16] stream_fifo_level
+// [15]    stream_fifo_wr_ptr_update_en
+// [14:8]  stream_fifo_wr_ptr
+// [7]     stream_fifo_rd_ptr_update_en
+// [6:0]   stream_fifo_rd_ptr
+#define   SANA_STREAM_FIFO_CTL                     (0x3026)
+#define P_SANA_STREAM_FIFO_CTL                     (volatile unsigned int *)((0x3026  << 2) + 0xffd00000)
+// [31:18] - Reserved
+// [17]    - sana_int_enable
+// [16]    - sana_int_level (default : 0(pulse))
+// [15]    - disable_shift_clock_gating
+// [14]    - startcode_protect -- TODO
+// [8:6]   - sft_valid_wr_position (default : 3 (at least 24 bits available))
+// [5:4]   - emulate_code_length_sub_1(Default : 2)
+// [3]     - emulation_auto_on_startcode(Default : 0)
+// [2:1]   - start_code_length_sub_1(Default : 2)
+// [0]     - stream_shift_enable(Default : 0)
+#define   SANA_SHIFT_CONTROL                       (0x3027)
+#define P_SANA_SHIFT_CONTROL                       (volatile unsigned int *)((0x3027  << 2) + 0xffd00000)
+// [31:0]  - max 4-bytes start code (Default : 0x00000100)
+#define   SANA_SHIFT_STARTCODE                     (0x3028)
+#define P_SANA_SHIFT_STARTCODE                     (volatile unsigned int *)((0x3028  << 2) + 0xffd00000)
+// [31:0]  - max 4-bytes emulate code (Default : 0x00000300)
+#define   SANA_SHIFT_EMULATECODE                   (0x3029)
+#define P_SANA_SHIFT_EMULATECODE                   (volatile unsigned int *)((0x3029  << 2) + 0xffd00000)
+// [3]     - sana_int
+// [2]     - startcode_searching
+// [1]     - emulation_check_on
+// [0]     - startcode_check_on
+#define   SANA_SHIFT_STATUS                        (0x302a)
+#define P_SANA_SHIFT_STATUS                        (volatile unsigned int *)((0x302a  << 2) + 0xffd00000)
+// [31:0] sana_shifted_data - read only
+#define   SANA_SHIFTED_DATA                        (0x302b)
+#define P_SANA_SHIFTED_DATA                        (volatile unsigned int *)((0x302b  << 2) + 0xffd00000)
+// [31:0] shift_byte_count[31:0]
+#define   SANA_SHIFT_BYTE_COUNT                    (0x302c)
+#define P_SANA_SHIFT_BYTE_COUNT                    (volatile unsigned int *)((0x302c  << 2) + 0xffd00000)
+// [31:28] - shift_byte_count[35:32]
+// [27:20] - element_read_data[31:24]
+// [10]    - bytealign
+// [9]     - signed_element
+// [8]     - start_element_read
+// [7]     - shift_busy
+// [6:0]   - shift_bits
+#define   SANA_SHIFT_COMMAND                       (0x302d)
+#define P_SANA_SHIFT_COMMAND                       (volatile unsigned int *)((0x302d  << 2) + 0xffd00000)
+// 31:8    - element_read_data[23:0]
+//  7:2    - element_read_length
+//  1:0    - element_read_state
+#define   SANA_ELEMENT_RESULT                      (0x302e)
+#define P_SANA_ELEMENT_RESULT                      (volatile unsigned int *)((0x302e  << 2) + 0xffd00000)
+// support up to 8 masters, one bit per master
+// 23:16   - lock_release (Write 1 to release)
+// 15:8    - lock_req (write 1 to request)
+//  7:0    - lock_result (Read Only)
+#define   ATOM_LOCK                                (0x302f)
+#define P_ATOM_LOCK                                (volatile unsigned int *)((0x302f  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  I2C_M_0_CBUS_BASE = 0x7c
+// -----------------------------------------------
+#define   I2C_M_0_CONTROL_REG                      (0x7c00)
+#define P_I2C_M_0_CONTROL_REG                      (volatile unsigned int *)((0x7c00  << 2) + 0xffd00000)
+    #define     I2C_M_MANUAL_SDA_I        26
+    #define     I2C_M_MANUAL_SCL_I        25
+    #define     I2C_M_MANUAL_SDA_O        24
+    #define     I2C_M_MANUAL_SCL_O        23
+    #define     I2C_M_MANUAL_EN           22
+    #define     I2C_M_DELAY_MSB           21
+    #define     I2C_M_DELAY_LSB           12
+    #define     I2C_M_DATA_CNT_MSB        11
+    #define     I2C_M_DATA_CNT_LSB        8
+    #define     I2C_M_CURR_TOKEN_MSB      7
+    #define     I2C_M_CURR_TOKEN_LSB      4
+    #define     I2C_M_ERROR               3
+    #define     I2C_M_STATUS              2
+    #define     I2C_M_ACK_IGNORE          1
+    #define     I2C_M_START               0
+#define   I2C_M_0_SLAVE_ADDR                       (0x7c01)
+#define P_I2C_M_0_SLAVE_ADDR                       (volatile unsigned int *)((0x7c01  << 2) + 0xffd00000)
+#define   I2C_M_0_TOKEN_LIST0                      (0x7c02)
+#define P_I2C_M_0_TOKEN_LIST0                      (volatile unsigned int *)((0x7c02  << 2) + 0xffd00000)
+#define   I2C_M_0_TOKEN_LIST1                      (0x7c03)
+#define P_I2C_M_0_TOKEN_LIST1                      (volatile unsigned int *)((0x7c03  << 2) + 0xffd00000)
+#define   I2C_M_0_WDATA_REG0                       (0x7c04)
+#define P_I2C_M_0_WDATA_REG0                       (volatile unsigned int *)((0x7c04  << 2) + 0xffd00000)
+#define   I2C_M_0_WDATA_REG1                       (0x7c05)
+#define P_I2C_M_0_WDATA_REG1                       (volatile unsigned int *)((0x7c05  << 2) + 0xffd00000)
+#define   I2C_M_0_RDATA_REG0                       (0x7c06)
+#define P_I2C_M_0_RDATA_REG0                       (volatile unsigned int *)((0x7c06  << 2) + 0xffd00000)
+#define   I2C_M_0_RDATA_REG1                       (0x7c07)
+#define P_I2C_M_0_RDATA_REG1                       (volatile unsigned int *)((0x7c07  << 2) + 0xffd00000)
+// -----------------------------------------------
+// CBUS_BASE:  I2C_M_1_CBUS_BASE = 0x78
+// -----------------------------------------------
+#define   I2C_M_1_CONTROL_REG                      (0x7800)
+#define P_I2C_M_1_CONTROL_REG                      (volatile unsigned int *)((0x7800  << 2) + 0xffd00000)
+#define   I2C_M_1_SLAVE_ADDR                       (0x7801)
+#define P_I2C_M_1_SLAVE_ADDR                       (volatile unsigned int *)((0x7801  << 2) + 0xffd00000)
+#define   I2C_M_1_TOKEN_LIST0                      (0x7802)
+#define P_I2C_M_1_TOKEN_LIST0                      (volatile unsigned int *)((0x7802  << 2) + 0xffd00000)
+#define   I2C_M_1_TOKEN_LIST1                      (0x7803)
+#define P_I2C_M_1_TOKEN_LIST1                      (volatile unsigned int *)((0x7803  << 2) + 0xffd00000)
+#define   I2C_M_1_WDATA_REG0                       (0x7804)
+#define P_I2C_M_1_WDATA_REG0                       (volatile unsigned int *)((0x7804  << 2) + 0xffd00000)
+#define   I2C_M_1_WDATA_REG1                       (0x7805)
+#define P_I2C_M_1_WDATA_REG1                       (volatile unsigned int *)((0x7805  << 2) + 0xffd00000)
+#define   I2C_M_1_RDATA_REG0                       (0x7806)
+#define P_I2C_M_1_RDATA_REG0                       (volatile unsigned int *)((0x7806  << 2) + 0xffd00000)
+#define   I2C_M_1_RDATA_REG1                       (0x7807)
+#define P_I2C_M_1_RDATA_REG1                       (volatile unsigned int *)((0x7807  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  I2C_M_2_CBUS_BASE = 0x74
+// -----------------------------------------------
+#define   I2C_M_2_CONTROL_REG                      (0x7400)
+#define P_I2C_M_2_CONTROL_REG                      (volatile unsigned int *)((0x7400  << 2) + 0xffd00000)
+#define   I2C_M_2_SLAVE_ADDR                       (0x7401)
+#define P_I2C_M_2_SLAVE_ADDR                       (volatile unsigned int *)((0x7401  << 2) + 0xffd00000)
+#define   I2C_M_2_TOKEN_LIST0                      (0x7402)
+#define P_I2C_M_2_TOKEN_LIST0                      (volatile unsigned int *)((0x7402  << 2) + 0xffd00000)
+#define   I2C_M_2_TOKEN_LIST1                      (0x7403)
+#define P_I2C_M_2_TOKEN_LIST1                      (volatile unsigned int *)((0x7403  << 2) + 0xffd00000)
+#define   I2C_M_2_WDATA_REG0                       (0x7404)
+#define P_I2C_M_2_WDATA_REG0                       (volatile unsigned int *)((0x7404  << 2) + 0xffd00000)
+#define   I2C_M_2_WDATA_REG1                       (0x7405)
+#define P_I2C_M_2_WDATA_REG1                       (volatile unsigned int *)((0x7405  << 2) + 0xffd00000)
+#define   I2C_M_2_RDATA_REG0                       (0x7406)
+#define P_I2C_M_2_RDATA_REG0                       (volatile unsigned int *)((0x7406  << 2) + 0xffd00000)
+#define   I2C_M_2_RDATA_REG1                       (0x7407)
+#define P_I2C_M_2_RDATA_REG1                       (volatile unsigned int *)((0x7407  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  I2C_M_3_CBUS_BASE = 0x70
+// -----------------------------------------------
+#define   I2C_M_3_CONTROL_REG                      (0x7000)
+#define P_I2C_M_3_CONTROL_REG                      (volatile unsigned int *)((0x7000  << 2) + 0xffd00000)
+#define   I2C_M_3_SLAVE_ADDR                       (0x7001)
+#define P_I2C_M_3_SLAVE_ADDR                       (volatile unsigned int *)((0x7001  << 2) + 0xffd00000)
+#define   I2C_M_3_TOKEN_LIST0                      (0x7002)
+#define P_I2C_M_3_TOKEN_LIST0                      (volatile unsigned int *)((0x7002  << 2) + 0xffd00000)
+#define   I2C_M_3_TOKEN_LIST1                      (0x7003)
+#define P_I2C_M_3_TOKEN_LIST1                      (volatile unsigned int *)((0x7003  << 2) + 0xffd00000)
+#define   I2C_M_3_WDATA_REG0                       (0x7004)
+#define P_I2C_M_3_WDATA_REG0                       (volatile unsigned int *)((0x7004  << 2) + 0xffd00000)
+#define   I2C_M_3_WDATA_REG1                       (0x7005)
+#define P_I2C_M_3_WDATA_REG1                       (volatile unsigned int *)((0x7005  << 2) + 0xffd00000)
+#define   I2C_M_3_RDATA_REG0                       (0x7006)
+#define P_I2C_M_3_RDATA_REG0                       (volatile unsigned int *)((0x7006  << 2) + 0xffd00000)
+#define   I2C_M_3_RDATA_REG1                       (0x7007)
+#define P_I2C_M_3_RDATA_REG1                       (volatile unsigned int *)((0x7007  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PWM_AB_CBUS_BASE = 0x6c
+// -----------------------------------------------
+#define   PWM_PWM_A                                (0x6c00)
+#define P_PWM_PWM_A                                (volatile unsigned int *)((0x6c00  << 2) + 0xffd00000)
+#define   PWM_PWM_B                                (0x6c01)
+#define P_PWM_PWM_B                                (volatile unsigned int *)((0x6c01  << 2) + 0xffd00000)
+#define   PWM_MISC_REG_AB                          (0x6c02)
+#define P_PWM_MISC_REG_AB                          (volatile unsigned int *)((0x6c02  << 2) + 0xffd00000)
+#define   PWM_DELTA_SIGMA_AB                       (0x6c03)
+#define P_PWM_DELTA_SIGMA_AB                       (volatile unsigned int *)((0x6c03  << 2) + 0xffd00000)
+#define   PWM_TIME_AB                              (0x6c04)
+#define P_PWM_TIME_AB                              (volatile unsigned int *)((0x6c04  << 2) + 0xffd00000)
+#define   PWM_A2                                   (0x6c05)
+#define P_PWM_A2                                   (volatile unsigned int *)((0x6c05  << 2) + 0xffd00000)
+#define   PWM_B2                                   (0x6c06)
+#define P_PWM_B2                                   (volatile unsigned int *)((0x6c06  << 2) + 0xffd00000)
+#define   PWM_BLINK_AB                             (0x6c07)
+#define P_PWM_BLINK_AB                             (volatile unsigned int *)((0x6c07  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PWM_CD_CBUS_BASE = 0x68
+// -----------------------------------------------
+#define   PWM_PWM_C                                (0x6800)
+#define P_PWM_PWM_C                                (volatile unsigned int *)((0x6800  << 2) + 0xffd00000)
+#define   PWM_PWM_D                                (0x6801)
+#define P_PWM_PWM_D                                (volatile unsigned int *)((0x6801  << 2) + 0xffd00000)
+#define   PWM_MISC_REG_CD                          (0x6802)
+#define P_PWM_MISC_REG_CD                          (volatile unsigned int *)((0x6802  << 2) + 0xffd00000)
+#define   PWM_DELTA_SIGMA_CD                       (0x6803)
+#define P_PWM_DELTA_SIGMA_CD                       (volatile unsigned int *)((0x6803  << 2) + 0xffd00000)
+#define   PWM_TIME_CD                              (0x6804)
+#define P_PWM_TIME_CD                              (volatile unsigned int *)((0x6804  << 2) + 0xffd00000)
+#define   PWM_C2                                   (0x6805)
+#define P_PWM_C2                                   (volatile unsigned int *)((0x6805  << 2) + 0xffd00000)
+#define   PWM_D2                                   (0x6806)
+#define P_PWM_D2                                   (volatile unsigned int *)((0x6806  << 2) + 0xffd00000)
+#define   PWM_BLINK_CD                             (0x6807)
+#define P_PWM_BLINK_CD                             (volatile unsigned int *)((0x6807  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PWM_EF_CBUS_BASE = 0x64
+// -----------------------------------------------
+#define   PWM_PWM_E                                (0x6400)
+#define P_PWM_PWM_E                                (volatile unsigned int *)((0x6400  << 2) + 0xffd00000)
+#define   PWM_PWM_F                                (0x6401)
+#define P_PWM_PWM_F                                (volatile unsigned int *)((0x6401  << 2) + 0xffd00000)
+#define   PWM_MISC_REG_EF                          (0x6402)
+#define P_PWM_MISC_REG_EF                          (volatile unsigned int *)((0x6402  << 2) + 0xffd00000)
+#define   PWM_DELTA_SIGMA_EF                       (0x6403)
+#define P_PWM_DELTA_SIGMA_EF                       (volatile unsigned int *)((0x6403  << 2) + 0xffd00000)
+#define   PWM_TIME_EF                              (0x6404)
+#define P_PWM_TIME_EF                              (volatile unsigned int *)((0x6404  << 2) + 0xffd00000)
+#define   PWM_E2                                   (0x6405)
+#define P_PWM_E2                                   (volatile unsigned int *)((0x6405  << 2) + 0xffd00000)
+#define   PWM_F2                                   (0x6406)
+#define P_PWM_F2                                   (volatile unsigned int *)((0x6406  << 2) + 0xffd00000)
+#define   PWM_BLINK_EF                             (0x6407)
+#define P_PWM_BLINK_EF                             (volatile unsigned int *)((0x6407  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  MSR_CLK_CBUS_BASE = 0x60
+// -----------------------------------------------
+#define   MSR_CLK_DUTY                             (0x6000)
+#define P_MSR_CLK_DUTY                             (volatile unsigned int *)((0x6000  << 2) + 0xffd00000)
+#define   MSR_CLK_REG0                             (0x6001)
+#define P_MSR_CLK_REG0                             (volatile unsigned int *)((0x6001  << 2) + 0xffd00000)
+#define   MSR_CLK_REG1                             (0x6002)
+#define P_MSR_CLK_REG1                             (volatile unsigned int *)((0x6002  << 2) + 0xffd00000)
+#define   MSR_CLK_REG2                             (0x6003)
+#define P_MSR_CLK_REG2                             (volatile unsigned int *)((0x6003  << 2) + 0xffd00000)
+#define   MSR_CLK_REG3                             (0x6004)
+#define P_MSR_CLK_REG3                             (volatile unsigned int *)((0x6004  << 2) + 0xffd00000)
+#define   MSR_CLK_REG4                             (0x6005)
+#define P_MSR_CLK_REG4                             (volatile unsigned int *)((0x6005  << 2) + 0xffd00000)
+#define   MSR_CLK_REG5                             (0x6006)
+#define P_MSR_CLK_REG5                             (volatile unsigned int *)((0x6006  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  STEAM_CBUS_BASE = 0x2c
+// -----------------------------------------------
+// bit 31:24 -- event_length
+// bit 23:22 -- bus_1st_sel_1  //00-gpio, 01-reserved, 10-addr, 11-data
+// bit 21:20 -- bus_2nd_sel_1
+// bit 19:18 -- bus_1st_sel_0
+// bit 17:16 -- bus_2nd_sel_0
+// bit 15:0 -- set output value (output 1 will read according to external input)
+#define   STREAM_EVENT_INFO                        (0x2c00)
+#define P_STREAM_EVENT_INFO                        (volatile unsigned int *)((0x2c00  << 2) + 0xffd00000)
+// bit 31    -- force_parity_1
+// bit 30    -- LSB_first
+// bit 31:20 -- reserved
+// bit 19:16 -- toggle point index
+// bit 15:8  -- output togle point1
+// bit 7:0   -- output togle point0 (0xff means input)
+#define   STREAM_OUTPUT_CONFIG                     (0x2c01)
+#define P_STREAM_OUTPUT_CONFIG                     (volatile unsigned int *)((0x2c01  << 2) + 0xffd00000)
+// bit 31:24 -- clock_divide_ext
+// bit 23:20 -- s_bus_start ( sclk, sdataout, sdatain)  // 0 means no s_bus used
+// bit 19    -- no_sclk_on_pin // will use internal write clock and read clock (like RS232)
+// bit 18    -- invert_sclk_in
+// bit 17    -- sdata_send_busy  // indicate one data is sending -- read only
+// bit 16    -- one_sdata_received // set when one sdata is received, can write 0 to clear
+// bit 15    -- sdata_parity  // (write -- 0-even, 1-odd) (read -- received parity check)
+// bit 14    -- sdata_send_type  // 0 -- 8 bits  1 -- 32 bits ( for fujitsu only )
+// bit 13    -- sdata_receive_type // 0 -- 8 bits only  1 -- 8/32 bits
+// bit 12    -- invert_request_out
+// bit 11:8  -- request_out_sel  // 0 means disable output
+// bit 7:0   --  stop_request_count
+#define   C_D_BUS_CONTROL                          (0x2c02)
+#define P_C_D_BUS_CONTROL                          (volatile unsigned int *)((0x2c02  << 2) + 0xffd00000)
+// bit 31:0  -- serial data (write: output one data, read: input data)
+#define   C_DATA                                   (0x2c03)
+#define P_C_DATA                                   (volatile unsigned int *)((0x2c03  << 2) + 0xffd00000)
+// bit 31:28 bus_width_1
+// bit 27:24 bus_start_pin_1
+// bit 23:16 bus_sel_chang_point_1
+// bit 15:12 bus_width_0
+// bit 11:08 bus_start_pin_0
+// bit 07:00 bus_sel_chang_point_0
+#define   STREAM_BUS_CONFIG                        (0x2c04)
+#define P_STREAM_BUS_CONFIG                        (volatile unsigned int *)((0x2c04  << 2) + 0xffd00000)
+// bit 31:24 clock_divide
+// bit 23:20 clock_output_sel  -- 0 means disable clock output
+// bit 19 -- inc_event_addr
+// bit 18 -- async_fifo_endian
+// bit 17 -- send_to_async_fifo
+// bit 16 -- data_in_serial_lsb
+// bit 15 -- invert_no_wait_condition_0
+// bit 14 -- invert_no_wait_condition_1
+// bit 13 -- invert_no_wait_condition_2
+// bit 12 -- invert_data_bus
+// bit 11 -- invert_clock_in
+// bit 10 -- event_wait_clk_en
+// bit 9 -- data_in_serial
+// bit 8 -- invert_data_in_clk
+// bit 7:4  -- data_in_begin
+// bit 3:0  -- data_in_clk_sel
+#define   STREAM_DATA_IN_CONFIG                    (0x2c05)
+#define P_STREAM_DATA_IN_CONFIG                    (volatile unsigned int *)((0x2c05  << 2) + 0xffd00000)
+// wait condition and irq should not be connected to 0, 0 means disable)
+// bit 31:28 -- no_wait_condition_0   (0 means disable this condition)
+// bit 27:24 -- no_wait_condition_1   (0 means disable this condition)
+// bit 23:20 -- no_wait_condition_2   (0 means disable this condition)
+// bit 19:16 -- irq_input_sel         (0 means disable this interrupt)
+// bit 15:13 -- interrupt_status (read) clear status (write) (ext 0, ext 1, transfer end)
+// bit 12 -- enable_sdata_irq
+// bit 11 -- invert_irq_0
+// bit 10 -- invert_irq_1
+// bit  9 -- enable_transfer_end_irq
+// bit  8 -- enable_second_ext_irq
+// bit 7:0 -- no_wait_condition_check_point (0xff means no check)
+#define   STREAM_WAIT_IRQ_CONFIG                   (0x2c06)
+#define P_STREAM_WAIT_IRQ_CONFIG                   (volatile unsigned int *)((0x2c06  << 2) + 0xffd00000)
+// bit 31:24 -- event address
+// bit 23:16 -- event data
+// bit 15:1 -- event repeat times  (0 means one time event)
+// bit 0  -- Start Event (write) event_busy (read)
+#define   STREAM_EVENT_CTL                         (0x2c07)
+#define P_STREAM_EVENT_CTL                         (volatile unsigned int *)((0x2c07  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  SYNC_FIFO_CBUS_BASE = 0x28
+// -----------------------------------------------
+#define   ASYNC_FIFO_REG0                          (0x2800)
+#define P_ASYNC_FIFO_REG0                          (volatile unsigned int *)((0x2800  << 2) + 0xffd00000)
+#define   ASYNC_FIFO_REG1                          (0x2801)
+#define P_ASYNC_FIFO_REG1                          (volatile unsigned int *)((0x2801  << 2) + 0xffd00000)
+    #define ASYNC_FIFO_FLUSH_STATUS     31
+    #define ASYNC_FIFO_ERR              30
+    #define ASYNC_FIFO_FIFO_EMPTY       29
+    #define ASYNC_FIFO_TO_HIU           24
+    #define ASYNC_FIFO_FLUSH            23
+    #define ASYNC_FIFO_RESET            22
+    #define ASYNC_FIFO_WRAP_EN          21
+    #define ASYNC_FIFO_FLUSH_EN         20
+    #define ASYNC_FIFO_RESIDUAL_MSB     19
+    #define ASYNC_FIFO_RESIDUAL_LSB     15
+    #define ASYNC_FIFO_FLUSH_CNT_MSB    14
+    #define ASYNC_FIFO_FLUSH_CNT_LSB    0
+#define   ASYNC_FIFO_REG2                          (0x2802)
+#define P_ASYNC_FIFO_REG2                          (volatile unsigned int *)((0x2802  << 2) + 0xffd00000)
+    #define ASYNC_FIFO_FIFO_FULL        26
+    #define ASYNC_FIFO_FILL_STATUS      25
+    #define ASYNC_FIFO_SOURCE_MSB       24
+    #define ASYNC_FIFO_SOURCE_LSB       23
+    #define ASYNC_FIFO_ENDIAN_MSB       22
+    #define ASYNC_FIFO_ENDIAN_LSB       21
+    #define ASYNC_FIFO_FILL_EN          20
+    #define ASYNC_FIFO_FILL_CNT_MSB     19
+    #define ASYNC_FIFO_FILL_CNT_LSB     0
+#define   ASYNC_FIFO_REG3                          (0x2803)
+#define P_ASYNC_FIFO_REG3                          (volatile unsigned int *)((0x2803  << 2) + 0xffd00000)
+    #define ASYNC_FLUSH_SIZE_IRQ_MSB    15
+    #define ASYNC_FLUSH_SIZE_IRQ_LSB    0
+#define   ASYNC_FIFO_REG4                          (0x2804)
+#define P_ASYNC_FIFO_REG4                          (volatile unsigned int *)((0x2804  << 2) + 0xffd00000)
+#define   ASYNC_FIFO_REG5                          (0x2805)
+#define P_ASYNC_FIFO_REG5                          (volatile unsigned int *)((0x2805  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  SYNC_FIFO2_CBUS_BASE = 0x24
+// -----------------------------------------------
+#define   ASYNC_FIFO2_REG0                         (0x2400)
+#define P_ASYNC_FIFO2_REG0                         (volatile unsigned int *)((0x2400  << 2) + 0xffd00000)
+#define   ASYNC_FIFO2_REG1                         (0x2401)
+#define P_ASYNC_FIFO2_REG1                         (volatile unsigned int *)((0x2401  << 2) + 0xffd00000)
+#define   ASYNC_FIFO2_REG2                         (0x2402)
+#define P_ASYNC_FIFO2_REG2                         (volatile unsigned int *)((0x2402  << 2) + 0xffd00000)
+#define   ASYNC_FIFO2_REG3                         (0x2403)
+#define P_ASYNC_FIFO2_REG3                         (volatile unsigned int *)((0x2403  << 2) + 0xffd00000)
+#define   ASYNC_FIFO2_REG4                         (0x2404)
+#define P_ASYNC_FIFO2_REG4                         (volatile unsigned int *)((0x2404  << 2) + 0xffd00000)
+#define   ASYNC_FIFO2_REG5                         (0x2405)
+#define P_ASYNC_FIFO2_REG5                         (volatile unsigned int *)((0x2405  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  SPIFC_CBUS_BASE = 0x50
+// -----------------------------------------------
+#define   SPI_FLASH_CMD                            (0x5000)
+#define P_SPI_FLASH_CMD                            (volatile unsigned int *)((0x5000  << 2) + 0xffd00000)
+    #define SPI_FLASH_READ    31
+    #define SPI_FLASH_WREN    30
+    #define SPI_FLASH_WRDI    29
+    #define SPI_FLASH_RDID    28
+    #define SPI_FLASH_RDSR    27
+    #define SPI_FLASH_WRSR    26
+    #define SPI_FLASH_PP      25
+    #define SPI_FLASH_SE      24
+    #define SPI_FLASH_BE      23
+    #define SPI_FLASH_CE      22
+    #define SPI_FLASH_DP      21
+    #define SPI_FLASH_RES     20
+    #define SPI_HPM           19
+    #define SPI_FLASH_USR     18
+    #define SPI_FLASH_USR_ADDR 15
+    #define SPI_FLASH_USR_DUMMY 14
+    #define SPI_FLASH_USR_DIN   13
+    #define SPI_FLASH_USR_DOUT   12
+    #define SPI_FLASH_USR_DUMMY_BLEN   10
+    #define SPI_FLASH_USR_CMD     0
+#define   SPI_FLASH_ADDR                           (0x5001)
+#define P_SPI_FLASH_ADDR                           (volatile unsigned int *)((0x5001  << 2) + 0xffd00000)
+    #define SPI_FLASH_BYTES_LEN 24
+    #define SPI_FLASH_ADDR_START 0
+#define   SPI_FLASH_CTRL                           (0x5002)
+#define P_SPI_FLASH_CTRL                           (volatile unsigned int *)((0x5002  << 2) + 0xffd00000)
+    #define SPI_ENABLE_AHB    17
+    #define SPI_SST_AAI       16
+    #define SPI_RES_RID       15
+    #define SPI_FREAD_DUAL    14
+    #define SPI_READ_READ_EN  13
+    #define SPI_CLK_DIV0      12
+    #define SPI_CLKCNT_N      8
+    #define SPI_CLKCNT_H      4
+    #define SPI_CLKCNT_L      0
+#define   SPI_FLASH_CTRL1                          (0x5003)
+#define P_SPI_FLASH_CTRL1                          (volatile unsigned int *)((0x5003  << 2) + 0xffd00000)
+#define   SPI_FLASH_STATUS                         (0x5004)
+#define P_SPI_FLASH_STATUS                         (volatile unsigned int *)((0x5004  << 2) + 0xffd00000)
+#define   SPI_FLASH_CTRL2                          (0x5005)
+#define P_SPI_FLASH_CTRL2                          (volatile unsigned int *)((0x5005  << 2) + 0xffd00000)
+#define   SPI_FLASH_CLOCK                          (0x5006)
+#define P_SPI_FLASH_CLOCK                          (volatile unsigned int *)((0x5006  << 2) + 0xffd00000)
+#define   SPI_FLASH_USER                           (0x5007)
+#define P_SPI_FLASH_USER                           (volatile unsigned int *)((0x5007  << 2) + 0xffd00000)
+#define   SPI_FLASH_USER1                          (0x5008)
+#define P_SPI_FLASH_USER1                          (volatile unsigned int *)((0x5008  << 2) + 0xffd00000)
+#define   SPI_FLASH_USER2                          (0x5009)
+#define P_SPI_FLASH_USER2                          (volatile unsigned int *)((0x5009  << 2) + 0xffd00000)
+#define   SPI_FLASH_USER3                          (0x500a)
+#define P_SPI_FLASH_USER3                          (volatile unsigned int *)((0x500a  << 2) + 0xffd00000)
+#define   SPI_FLASH_USER4                          (0x500b)
+#define P_SPI_FLASH_USER4                          (volatile unsigned int *)((0x500b  << 2) + 0xffd00000)
+#define   SPI_FLASH_SLAVE                          (0x500c)
+#define P_SPI_FLASH_SLAVE                          (volatile unsigned int *)((0x500c  << 2) + 0xffd00000)
+#define   SPI_FLASH_SLAVE1                         (0x500d)
+#define P_SPI_FLASH_SLAVE1                         (volatile unsigned int *)((0x500d  << 2) + 0xffd00000)
+#define   SPI_FLASH_SLAVE2                         (0x500e)
+#define P_SPI_FLASH_SLAVE2                         (volatile unsigned int *)((0x500e  << 2) + 0xffd00000)
+#define   SPI_FLASH_SLAVE3                         (0x500f)
+#define P_SPI_FLASH_SLAVE3                         (volatile unsigned int *)((0x500f  << 2) + 0xffd00000)
+#define   SPI_FLASH_C0                             (0x5010)
+#define P_SPI_FLASH_C0                             (volatile unsigned int *)((0x5010  << 2) + 0xffd00000)
+#define   SPI_FLASH_C1                             (0x5011)
+#define P_SPI_FLASH_C1                             (volatile unsigned int *)((0x5011  << 2) + 0xffd00000)
+#define   SPI_FLASH_C2                             (0x5012)
+#define P_SPI_FLASH_C2                             (volatile unsigned int *)((0x5012  << 2) + 0xffd00000)
+#define   SPI_FLASH_C3                             (0x5013)
+#define P_SPI_FLASH_C3                             (volatile unsigned int *)((0x5013  << 2) + 0xffd00000)
+#define   SPI_FLASH_C4                             (0x5014)
+#define P_SPI_FLASH_C4                             (volatile unsigned int *)((0x5014  << 2) + 0xffd00000)
+#define   SPI_FLASH_C5                             (0x5015)
+#define P_SPI_FLASH_C5                             (volatile unsigned int *)((0x5015  << 2) + 0xffd00000)
+#define   SPI_FLASH_C6                             (0x5016)
+#define P_SPI_FLASH_C6                             (volatile unsigned int *)((0x5016  << 2) + 0xffd00000)
+#define   SPI_FLASH_C7                             (0x5017)
+#define P_SPI_FLASH_C7                             (volatile unsigned int *)((0x5017  << 2) + 0xffd00000)
+#define   SPI_FLASH_B8                             (0x5018)
+#define P_SPI_FLASH_B8                             (volatile unsigned int *)((0x5018  << 2) + 0xffd00000)
+#define   SPI_FLASH_B9                             (0x5019)
+#define P_SPI_FLASH_B9                             (volatile unsigned int *)((0x5019  << 2) + 0xffd00000)
+#define   SPI_FLASH_B10                            (0x501a)
+#define P_SPI_FLASH_B10                            (volatile unsigned int *)((0x501a  << 2) + 0xffd00000)
+#define   SPI_FLASH_B11                            (0x501b)
+#define P_SPI_FLASH_B11                            (volatile unsigned int *)((0x501b  << 2) + 0xffd00000)
+#define   SPI_FLASH_B12                            (0x501c)
+#define P_SPI_FLASH_B12                            (volatile unsigned int *)((0x501c  << 2) + 0xffd00000)
+#define   SPI_FLASH_B13                            (0x501d)
+#define P_SPI_FLASH_B13                            (volatile unsigned int *)((0x501d  << 2) + 0xffd00000)
+#define   SPI_FLASH_B14                            (0x501e)
+#define P_SPI_FLASH_B14                            (volatile unsigned int *)((0x501e  << 2) + 0xffd00000)
+#define   SPI_FLASH_B15                            (0x501f)
+#define P_SPI_FLASH_B15                            (volatile unsigned int *)((0x501f  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+//spicc 0
+// -----------------------------------------------
+// CBUS_BASE:  SPICC0_CBUS_BASE = 0x4c
+// -----------------------------------------------
+#define   SPICC0_RXDATA                            (0x4c00)
+#define P_SPICC0_RXDATA                            (volatile unsigned int *)((0x4c00  << 2) + 0xffd00000)
+#define   SPICC0_TXDATA                            (0x4c01)
+#define P_SPICC0_TXDATA                            (volatile unsigned int *)((0x4c01  << 2) + 0xffd00000)
+#define   SPICC0_CONREG                            (0x4c02)
+#define P_SPICC0_CONREG                            (volatile unsigned int *)((0x4c02  << 2) + 0xffd00000)
+#define   SPICC0_INTREG                            (0x4c03)
+#define P_SPICC0_INTREG                            (volatile unsigned int *)((0x4c03  << 2) + 0xffd00000)
+#define   SPICC0_DMAREG                            (0x4c04)
+#define P_SPICC0_DMAREG                            (volatile unsigned int *)((0x4c04  << 2) + 0xffd00000)
+#define   SPICC0_STATREG                           (0x4c05)
+#define P_SPICC0_STATREG                           (volatile unsigned int *)((0x4c05  << 2) + 0xffd00000)
+#define   SPICC0_PERIODREG                         (0x4c06)
+#define P_SPICC0_PERIODREG                         (volatile unsigned int *)((0x4c06  << 2) + 0xffd00000)
+#define   SPICC0_TESTREG                           (0x4c07)
+#define P_SPICC0_TESTREG                           (volatile unsigned int *)((0x4c07  << 2) + 0xffd00000)
+#define   SPICC0_DRADDR                            (0x4c08)
+#define P_SPICC0_DRADDR                            (volatile unsigned int *)((0x4c08  << 2) + 0xffd00000)
+#define   SPICC0_DWADDR                            (0x4c09)
+#define P_SPICC0_DWADDR                            (volatile unsigned int *)((0x4c09  << 2) + 0xffd00000)
+#define   SPICC0_LD_CNTL0                          (0x4c0a)
+#define P_SPICC0_LD_CNTL0                          (volatile unsigned int *)((0x4c0a  << 2) + 0xffd00000)
+#define   SPICC0_LD_CNTL1                          (0x4c0b)
+#define P_SPICC0_LD_CNTL1                          (volatile unsigned int *)((0x4c0b  << 2) + 0xffd00000)
+#define   SPICC0_LD_RADDR                          (0x4c0c)
+#define P_SPICC0_LD_RADDR                          (volatile unsigned int *)((0x4c0c  << 2) + 0xffd00000)
+#define   SPICC0_LD_WADDR                          (0x4c0d)
+#define P_SPICC0_LD_WADDR                          (volatile unsigned int *)((0x4c0d  << 2) + 0xffd00000)
+#define   SPICC0_ENHANCE_CNTL                      (0x4c0e)
+#define P_SPICC0_ENHANCE_CNTL                      (volatile unsigned int *)((0x4c0e  << 2) + 0xffd00000)
+// ------------------------------------------------------------------------------------
+//spicc 1
+// -----------------------------------------------
+// CBUS_BASE:  SPICC1_CBUS_BASE = 0x54
+// -----------------------------------------------
+#define   SPICC1_RXDATA                            (0x5400)
+#define P_SPICC1_RXDATA                            (volatile unsigned int *)((0x5400  << 2) + 0xffd00000)
+#define   SPICC1_TXDATA                            (0x5401)
+#define P_SPICC1_TXDATA                            (volatile unsigned int *)((0x5401  << 2) + 0xffd00000)
+#define   SPICC1_CONREG                            (0x5402)
+#define P_SPICC1_CONREG                            (volatile unsigned int *)((0x5402  << 2) + 0xffd00000)
+#define   SPICC1_INTREG                            (0x5403)
+#define P_SPICC1_INTREG                            (volatile unsigned int *)((0x5403  << 2) + 0xffd00000)
+#define   SPICC1_DMAREG                            (0x5404)
+#define P_SPICC1_DMAREG                            (volatile unsigned int *)((0x5404  << 2) + 0xffd00000)
+#define   SPICC1_STATREG                           (0x5405)
+#define P_SPICC1_STATREG                           (volatile unsigned int *)((0x5405  << 2) + 0xffd00000)
+#define   SPICC1_PERIODREG                         (0x5406)
+#define P_SPICC1_PERIODREG                         (volatile unsigned int *)((0x5406  << 2) + 0xffd00000)
+#define   SPICC1_TESTREG                           (0x5407)
+#define P_SPICC1_TESTREG                           (volatile unsigned int *)((0x5407  << 2) + 0xffd00000)
+#define   SPICC1_DRADDR                            (0x5408)
+#define P_SPICC1_DRADDR                            (volatile unsigned int *)((0x5408  << 2) + 0xffd00000)
+#define   SPICC1_DWADDR                            (0x5409)
+#define P_SPICC1_DWADDR                            (volatile unsigned int *)((0x5409  << 2) + 0xffd00000)
+#define   SPICC1_LD_CNTL0                          (0x540a)
+#define P_SPICC1_LD_CNTL0                          (volatile unsigned int *)((0x540a  << 2) + 0xffd00000)
+#define   SPICC1_LD_CNTL1                          (0x540b)
+#define P_SPICC1_LD_CNTL1                          (volatile unsigned int *)((0x540b  << 2) + 0xffd00000)
+#define   SPICC1_LD_RADDR                          (0x540c)
+#define P_SPICC1_LD_RADDR                          (volatile unsigned int *)((0x540c  << 2) + 0xffd00000)
+#define   SPICC1_LD_WADDR                          (0x540d)
+#define P_SPICC1_LD_WADDR                          (volatile unsigned int *)((0x540d  << 2) + 0xffd00000)
+#define   SPICC1_ENHANCE_CNTL                      (0x540e)
+#define P_SPICC1_ENHANCE_CNTL                      (volatile unsigned int *)((0x540e  << 2) + 0xffd00000)
+//
+//// -------------------------------------------------------------------
+//// PSEL Group #1:  0x400 ~ 0x7FF
+//// -------------------------------------------------------------------
+//`define  PERIPHS1_CBUS_BASE   8'h28
+//
+//
+//
+//// ----------------------------
+//// IR Remote (8)
+//// ----------------------------
+//`define IR_DEC_LDR_ACTIVE               8'h20
+//`define IR_DEC_LDR_IDLE                 8'h21
+//`define IR_DEC_LDR_REPEAT               8'h22
+//`define IR_DEC_BIT_0                    8'h23
+//`define IR_DEC_REG0                     8'h24
+//`define IR_DEC_FRAME                    8'h25
+//`define IR_DEC_STATUS                   8'h26
+//`define IR_DEC_REG1                     8'h27
+//
+//// ----------------------------
+//// Demod Sampling
+//// ----------------------------
+//`define DEMOD_ADC_SAMPLING               8'h2d
+//// ----------------------------
+//// WIFI
+//// ----------------------------
+//// `define WIFI_ADC_SAMPLING               8'h2e
+//// `define WIFI_ADC_READBACK               8'h2f
+//
+//
+//// ---------------------------
+//// EFUSE (4)
+//// ----------------------------
+//// Moved to the Secure APB3 bus
+//// `define EFUSE_CNTL0                     8'h58
+//// `define EFUSE_CNTL1                     8'h59
+//// `define EFUSE_CNTL2                     8'h5a
+//// `define EFUSE_CNTL3                     8'h5b
+//// `define EFUSE_CNTL4                     8'h5c
+//
+//// ---------------------------------------------
+//// Separate APB slave that shares the CBUS/APB
+//// register space of the static registers
+//// ---------------------------------------------
+//
+//`define ATAPI_IDEREG0                   8'h60
+//   `define IDE_UDMA_PIO_STATE         15
+//   `define IDE_BUSY                   14
+//   `define IDE_ERROR_BIT              13
+//   `define IDE_DMARQ_BIT              12
+//   `define IDE_IORDY_BIT              11
+//   `define IDE_IORDY_EN_BIT           10
+//   `define IDE_DIS_CSEL_BIT            9
+//   `define IDE_CSEL_BIT                8
+//   `define IDE_IRQ14                   2
+//   `define IDE_ATAPI_GPIO_EN           3
+//   `define IDE_DMARQ_FULL              1
+//   `define IDE_ENABLE                  0
+//`define ATAPI_IDEREG1                   8'h61
+//`define ATAPI_IDEREG2                   8'h62
+//    `define IDE_XFER_CNT_MSB_BIT      18
+//    `define IDE_XFER_CNT_LSB_BIT       0
+//`define ATAPI_CYCTIME                   8'h63
+//`define ATAPI_IDETIME                   8'h64
+//`define ATAPI_PIO_TIMING                8'h65
+//`define ATAPI_TABLE_ADD_REG             8'h66
+//`define ATAPI_IDEREG3                   8'h67
+//`define ATAPI_UDMA_REG0                 8'h68
+//`define ATAPI_UDMA_REG1                 8'h69
+//
+//// Room for registers here
+//
+//`define TRANS_PWMA_REG0                 8'h70
+//`define TRANS_PWMA_REG1                 8'h71
+//`define TRANS_PWMA_MUX0                 8'h72
+//`define TRANS_PWMA_MUX1                 8'h73
+//`define TRANS_PWMA_MUX2                 8'h74
+//`define TRANS_PWMA_MUX3                 8'h75
+//`define TRANS_PWMA_MUX4                 8'h76
+//`define TRANS_PWMA_MUX5                 8'h77
+//
+//`define TRANS_PWMB_REG0                 8'h78
+//`define TRANS_PWMB_REG1                 8'h79
+//`define TRANS_PWMB_MUX0                 8'h7a
+//`define TRANS_PWMB_MUX1                 8'h7b
+//`define TRANS_PWMB_MUX2                 8'h7c
+//`define TRANS_PWMB_MUX3                 8'h7d
+//`define TRANS_PWMB_MUX4                 8'h7e
+//`define TRANS_PWMB_MUX5                 8'h7f
+//
+//
+//
+//// ----------------------------
+//// NAND (21)
+//// ----------------------------
+//`define NAND_START                      8'h80
+//`define NAND_ADR_CMD                    8'h8a
+//`define NAND_ADR_STS                    8'h8b
+//`define NAND_END                        8'h8f
+//
+//// ----------------------------
+//// ISP_FLASH_LED_CTRL
+//// ----------------------------
+////bit 31, reg_led_en //rising pulse start, falling pulse stop for torch mode
+////bit 30, reg_inc_i_st_lat //for as3685, dynamic increase current during st_latch
+////bit 29:28, reg_inv_en_pol //bit[29], invert en1, bit [28], invert en2
+////bit 27, reg_switch_en1en2  //switch output en1 and en2. For IS3231: en1 is EN, en2 is mode.
+////bit 26, reg_force_off_mode //1: reset state machine at the falling edge no matter which state it is in
+////bit 25, reg_hold_nonstd_off_mode //hold the non-std led_off signal input before state "OFF"
+////bit 24, reg_flash_mode_timeout_en  //force to exit the Tlat state when time out, for flash mode protection
+////bit 23, reg_en1_st_ini_level //en1 level during state ST_INI
+////bit 22, reg_en2_st_set_mp_level //en2 level during state ST_SET_MP_HI, ST_SET_MP_LO
+////bit 21, reg_en1_st_off_level //en1 level during state ST_OFF
+////bit 20, reg_en2_st_off_level //en2 level during state ST_OFF
+////bit 19:12, reg_en1_mp_num  //en1 multi pulse number, up to 256 step current control
+////bit 10:0, reg_t_st_ini //Max: 85.2 us under 24M clock input
+//`define ISP_LED_CTRL                    8'h98
+//
+////bit 31:21, reg_t_en1_inc_i_st_lat_cnt //Max: 85.2us under 24M. for as3685, dynamic increase current during st_latch
+////bit 20:10, reg_t_en2_lo_st_ini //Max: 85.2 us under 24M clock input
+////bit 9:0, reg_t_en2_hi1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
+//`define ISP_LED_TIMING1                 8'h99
+//
+////bit 31:21, reg_t_en1_mp_hi_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
+////bit 20:10, reg_t_en1_mp_lo_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
+////bit 9:0, reg_t_en2_lo1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
+//`define ISP_LED_TIMING2                 8'h9a
+//
+////bit 30:28, RO state
+////bit 25:0, reg_flash_mode_timeout_cnt //up to 2.79s at 24Mhz clk input
+//`define ISP_LED_TIMING3                 8'h9b
+//
+////bit 25:0, reg_t_st_lat_cnt //up to 2.79s, keep the led on if it's 26'h3ffffff under torch mode
+//`define ISP_LED_TIMING4                 8'h9c
+//
+////bit 31:26, reg_t_st_off_cnt[5:0] //up to 85.2us OFF state.
+////bit 25:0, reg_t_en2_hi2_st_lat_cnt //EN2 can output hi-lo-hi during ST_LATCH, this is the second hi -duration
+//`define ISP_LED_TIMING5                 8'h9d
+//
+////bit 30:26, reg_t_st_off_cnt[10:6] //up to 85.2us OFF state.
+////bit 25:0, reg_t_en1_st_lat_hold_cnt //to make sure Tlat to meat it's minimum request 500us (since non-std led_off signal may comes in anytime)
+//`define ISP_LED_TIMING6                 8'h9e
+//// ----------------------------
+//// SAR ADC (16)
+//// ----------------------------
+////`define SAR_ADC_REG0                    8'ha0
+////`define SAR_ADC_CHAN_LIST               8'ha1
+////`define SAR_ADC_AVG_CNTL                8'ha2
+////`define SAR_ADC_REG3                    8'ha3
+////`define SAR_ADC_DELAY                   8'ha4
+////`define SAR_ADC_LAST_RD                 8'ha5
+////`define SAR_ADC_FIFO_RD                 8'ha6
+////`define SAR_ADC_AUX_SW                  8'ha7
+////`define SAR_ADC_CHAN_10_SW              8'ha8
+////`define SAR_ADC_DETECT_IDLE_SW          8'ha9
+////`define SAR_ADC_DELTA_10                8'haa
+////`define SAR_ADC_REG11                   8'hab
+////`define SAR_ADC_REG12                   8'hac
+////`define SAR_ADC_REG13                   8'had
+//
+//// ----------------------------
+//// CTouch (16)
+//// ----------------------------
+//
+//
+//// ---------------------------
+//// RTC (4)
+//// ---------------------------
+//`define RTC_ADDR0                      8'hd0
+//`define RTC_ADDR1                      8'hd1
+//`define RTC_ADDR2                      8'hd2
+//`define RTC_ADDR3                      8'hd3
+//`define RTC_ADDR4                      8'hd4
+//// ----------------------------
+//// clock measure (4)
+//// ----------------------------
+//
+//
+//
+//// -------------------------------------------------------------------
+//// PSEL Group #2:  0x800 ~ 0xbFF
+//// -------------------------------------------------------------------
+//`define  PERIPHS2_CBUS_BASE   8'h2c
+//
+//`define USB_ADDR0                      8'h00
+//`define USB_ADDR1                      8'h01
+//`define USB_ADDR2                      8'h02
+//`define USB_ADDR3                      8'h03
+//`define USB_ADDR4                      8'h04
+//`define USB_ADDR5                      8'h05
+//`define USB_ADDR6                      8'h06
+//`define USB_ADDR7                      8'h07
+//`define USB_ADDR8                      8'h08
+//`define USB_ADDR9                      8'h09
+//`define USB_ADDR10                     8'h0a
+//`define USB_ADDR11                     8'h0b
+//`define USB_ADDR12                     8'h0c
+//`define USB_ADDR13                     8'h0d
+//`define USB_ADDR14                     8'h0e
+//`define USB_ADDR15                     8'h0f
+//
+//`define USB_ADDR16                     8'h10
+//`define USB_ADDR17                     8'h11
+//`define USB_ADDR18                     8'h12
+//`define USB_ADDR19                     8'h13
+//`define USB_ADDR20                     8'h14
+//`define USB_ADDR21                     8'h15
+//`define USB_ADDR22                     8'h16
+//`define USB_ADDR23                     8'h17
+//`define USB_ADDR24                     8'h18
+//`define USB_ADDR25                     8'h19
+//`define USB_ADDR26                     8'h1a
+//`define USB_ADDR27                     8'h1b
+//`define USB_ADDR28                     8'h1c
+//`define USB_ADDR29                     8'h1d
+//`define USB_ADDR30                     8'h1e
+//`define USB_ADDR31                     8'h1f
+//
+//
+//
+//
+//
+//// -------------------------------------------------------------------
+//// PSEL Group #3:  0xc00 ~ 0xFFF
+//// -------------------------------------------------------------------
+//`define  PERIPHS3_CBUS_BASE   8'h30
+//
+//// ---------------------------
+//// SDIO (8)
+//// ---------------------------
+//// `define C_SDIO_HIGH16                   8'h00
+//// bit 31:0 -- cmd_argument/MS_SHORT_DATA_WRITE
+//`define CMD_ARGUMENT                    8'h08
+//// bit 31:24 -- repeat_package_times/MS_SHORT_DATA_WRITE_NUMBER
+//// bit 21   -- use_int_window
+//// bit 20   -- cmd_send_data/MS_HAVE_LONG_DATA_WRITE
+//// bit 19   -- check_busy_on_dat0 (used for R1b response)
+//// bit 18   -- response_crc7_from_8
+//// bit 17   -- response_have_data/MS_HAVE_LONG_DATA_READ
+//// bit 16   -- response_do_not_have_crc7/MS_SHORT_DATA_DO_NOT_HAVE_CRC16
+//// bit 15:8 -- cmd_response_bits (00 means no response) /MS_SHORT_DATA_READ_NUMBER
+//// bit 7:0 -- cmd_command/MS_TPC
+//`define CMD_SEND                        8'h09
+//// bit 31:29 -- sdio_write_CRC_ok_status
+//// bit 28:23 -- sdio_write_Nwr
+//// bit 22:21 -- m_endian
+//// bit 20    -- bus_width
+//// bit 19    -- data_latch_at_negedge (normally at posedge)
+//// bit 18    -- do_not_delay_data (normally delay one clock)
+//// bit 17:12 -- cmd_argument_bits (before CRC, normally : 39)
+//// bit 11 -- cmd_out_at_posedge (normally at negedge)
+//// bit 10 -- cmd_disable_CRC
+//// bit 9:0 -- cmd_clk_divide
+//`define SDIO_CONFIG                     8'h0a
+//// bit 31:19 -- sdio_timing_out_count
+//// bit 18 -- arc_timing_out_int_en
+//// bit 17 -- amrisc_timing_out_int_en
+//// bit 16 -- sdio_timig_out_int   -- write 1 clear this int bit
+//// bit 15:12 -- sdio_status_info  -- used for change infor between ARC and Amrisc
+//// bit 11 -- sdio_set_soft_int -- write 1 to this bit will set sdio_soft_int , read out is m_req_sdio
+//// bit 10 -- sdio_soft_int   -- write 1 clear this int bit
+//// bit 9 -- sdio_cmd_int   -- write 1 clear this int bit
+//// bit 8 -- sdio_if_int   -- write 1 clear this int bit
+//// bit 7 -- sdio_data_write_crc16_ok -- Read-Only
+//// bit 6 -- sdio_data_read_crc16_ok  -- Read-Only
+//// bit 5 -- sdio_response_crc7_ok    -- Read-Only
+//// bit 4 -- sdio_cmd_busy            -- Read-Only
+//// bit 3:0 -- sdio_status            -- Read-Only
+//`define SDIO_STATUS_IRQ                 8'h0b
+//// bit 31 -- halt_hole 0 -- 8 bits 1 -- 16 bits
+//// bit 30 -- force_halt
+//// bit 29:24 -- sdio_force_data_read (read_only)
+//// bit 23:22 -- disable_mem_halt (write and read)
+//// bit 21:16 -- sdio_force_output_en
+//// bit 15 -- soft_reset
+//// bit 14 -- sdio_force_enable
+//// bit 13:8 -- sdio_force_data/sdio_read_data
+//// bit 7:6 -- sdio_if_int_config
+//// bit 5 -- arc_soft_int_en
+//// bit 4 -- arc_cmd_int_en
+//// bit 3 -- arc_if_int_en
+//// bit 2 -- amrisc_soft_int_en
+//// bit 1 -- amrisc_cmd_int_en
+//// bit 0 -- amrisc_if_int_en
+//`define SDIO_IRQ_CONFIG                 8'h0c
+//// bit 27:16 -- data_catch_finish_point
+//// (
+//// bit 15:12 -- response_read_index
+//// bit 9 -- data_catch_readout_en
+//// bit 8 -- write_read_out_index
+//// ) this bits only write when write_read_out_index = 1
+//// bit 11 -- sdio_1_data_swap01
+//// bit 10 -- sdio_0_data_on_1
+//// bit 7:6 -- data_catch_level
+//// bit 5 -- stream_8_bits_mode
+//// bit 4 -- stream_enable
+//// bit 3 -- ms_sclk_always
+//// bit 2 -- ms_enable
+//// bit 1:0 -- SDIO_port_sel //00-sdio1, 01-sdio2, 02-sdio3
+//`define SDIO_MULT_CONFIG                8'h0d
+//// bit 31:0 -- m_addr_sdio
+//`define SDIO_M_ADDR                     8'h0e
+//// bit 31    -- CRC_status_4line
+//// bit 30    -- data_rw_do_not_have_crc16/MS_LONG_DATA_DO_NOT_HAVE_CRC16
+//// bit 29:16 -- data_rw_number/MS_LONG_DATA_NUMBER
+//// bit 15:0 -- cmd_argument_ext/MS_SHORT_DATA_EXTENSION
+//`define SDIO_EXTENSION                  8'h0f
+//// ----------------------------
+//// SDIO_AHB_CBUS (2)
+//// ----------------------------
+//// bit   17    -- arc_ahb_cbus_int_en
+//// bit   16    -- amrisc_ahb_cbus_int_en
+//// bit 15:8    -- SDIO_FIFO_count
+//// bit  7:4    -- m_req_count
+//// bit    3    -- reserved
+//// bit    2    -- m_write_cbus
+//// bit    1    -- m_req_cbus
+//// bit    0    -- sdio_ahb_cbus_enable
+//`define SDIO_AHB_CBUS_CTRL             8'h18
+//// m_rd_data[31:0] when (m_write_cbus == 0)  CBUS write
+//// m_wr_data[31:0] when (m_write_cbus == 1)  CBUS read
+//`define SDIO_AHB_CBUS_M_DATA           8'h19
+//
+//
+//// ----------------------------
+//// SDHC (SDIO #2)
+//// ----------------------------
+//`define SD_REG0_ARGU    8'h80
+//`define SD_REG1_SEND    8'h81
+//`define SD_REG2_CNTL    8'h82
+//`define SD_REG3_STAT    8'h83
+//`define SD_REG4_CLKC    8'h84
+//`define SD_REG5_ADDR    8'h85
+//`define SD_REG6_PDMA    8'h86
+//`define SD_REG7_MISC    8'h87
+//`define SD_REG8_DATA    8'h88
+//`define SD_REG9_ICTL    8'h89
+//`define SD_REGA_ISTA    8'h8a
+//`define SD_REGB_SRST    8'h8b
+//`define SD_REGC_ESTA    8'h8c
+//`define SD_REGD_ENHC    8'h8d
+//`define SD_REGE_CLK2    8'h8e
+//
+//
+// Closing file:  periphs_reg.h
+//
+//
+// Reading file:  isa_reg.h
+//
+// $isa/rtl/isa_core register defines for the APB bus
+// CBUS base slave address
+// -----------------------------------------------
+// CBUS_BASE:  ISA_CBUS_BASE = 0x3c
+// -----------------------------------------------
+// Up to 256 registers for this base
+#define   ISA_DEBUG_REG0                           (0x3c00)
+#define P_ISA_DEBUG_REG0                           (volatile unsigned int *)((0x3c00  << 2) + 0xffd00000)
+#define   ISA_DEBUG_REG1                           (0x3c01)
+#define P_ISA_DEBUG_REG1                           (volatile unsigned int *)((0x3c01  << 2) + 0xffd00000)
+#define   ISA_DEBUG_REG2                           (0x3c02)
+#define P_ISA_DEBUG_REG2                           (volatile unsigned int *)((0x3c02  << 2) + 0xffd00000)
+#define   ISA_DEBUG_REG3                           (0x3c03)
+#define P_ISA_DEBUG_REG3                           (volatile unsigned int *)((0x3c03  << 2) + 0xffd00000)
+#define   ISA_PLL_CLK_SIM0                         (0x3c08)
+#define P_ISA_PLL_CLK_SIM0                         (volatile unsigned int *)((0x3c08  << 2) + 0xffd00000)
+#define   ISA_CNTL_REG0                            (0x3c09)
+#define P_ISA_CNTL_REG0                            (volatile unsigned int *)((0x3c09  << 2) + 0xffd00000)
+// -----------------------------------------------------------
+#define   AO_CPU_IRQ_IN0_INTR_STAT                 (0x3c10)
+#define P_AO_CPU_IRQ_IN0_INTR_STAT                 (volatile unsigned int *)((0x3c10  << 2) + 0xffd00000)
+#define   AO_CPU_IRQ_IN0_INTR_STAT_CLR             (0x3c11)
+#define P_AO_CPU_IRQ_IN0_INTR_STAT_CLR             (volatile unsigned int *)((0x3c11  << 2) + 0xffd00000)
+#define   AO_CPU_IRQ_IN0_INTR_MASK                 (0x3c12)
+#define P_AO_CPU_IRQ_IN0_INTR_MASK                 (volatile unsigned int *)((0x3c12  << 2) + 0xffd00000)
+#define   AO_CPU_IRQ_IN0_INTR_FIRQ_SEL             (0x3c13)
+#define P_AO_CPU_IRQ_IN0_INTR_FIRQ_SEL             (volatile unsigned int *)((0x3c13  << 2) + 0xffd00000)
+// define MEDIA_CPU_IRQ_IN1_INTR_STAT           8'h14
+// define MEDIA_CPU_IRQ_IN1_INTR_STAT_CLR       8'h15
+// define MEDIA_CPU_IRQ_IN1_INTR_MASK           8'h16
+// define MEDIA_CPU_IRQ_IN1_INTR_FIRQ_SEL       8'h17
+//
+// define MEDIA_CPU_IRQ_IN2_INTR_STAT              8'h18
+// define MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR          8'h19
+// define MEDIA_CPU_IRQ_IN2_INTR_MASK              8'h1a
+// define MEDIA_CPU_IRQ_IN2_INTR_FIRQ_SEL          8'h1b
+//
+// define MEDIA_CPU_IRQ_IN3_INTR_STAT            8'h1c
+// define MEDIA_CPU_IRQ_IN3_INTR_STAT_CLR        8'h1d
+// define MEDIA_CPU_IRQ_IN3_INTR_MASK            8'h1e
+// define MEDIA_CPU_IRQ_IN3_INTR_FIRQ_SEL        8'h1f
+#define   GPIO_INTR_EDGE_POL                       (0x3c20)
+#define P_GPIO_INTR_EDGE_POL                       (volatile unsigned int *)((0x3c20  << 2) + 0xffd00000)
+#define   GPIO_INTR_GPIO_SEL0                      (0x3c21)
+#define P_GPIO_INTR_GPIO_SEL0                      (volatile unsigned int *)((0x3c21  << 2) + 0xffd00000)
+#define   GPIO_INTR_GPIO_SEL1                      (0x3c22)
+#define P_GPIO_INTR_GPIO_SEL1                      (volatile unsigned int *)((0x3c22  << 2) + 0xffd00000)
+#define   GPIO_INTR_FILTER_SEL0                    (0x3c23)
+#define P_GPIO_INTR_FILTER_SEL0                    (volatile unsigned int *)((0x3c23  << 2) + 0xffd00000)
+// `define GLOBAL_INTR_DISABLE                 8'h24    never used
+#define   CVBS_IRQ0_CNTL                           (0x3c24)
+#define P_CVBS_IRQ0_CNTL                           (volatile unsigned int *)((0x3c24  << 2) + 0xffd00000)
+#define   CVBS_IRQ1_CNTL                           (0x3c25)
+#define P_CVBS_IRQ1_CNTL                           (volatile unsigned int *)((0x3c25  << 2) + 0xffd00000)
+#define   CVBS_IRQ0_COUNTER                        (0x3c26)
+#define P_CVBS_IRQ0_COUNTER                        (volatile unsigned int *)((0x3c26  << 2) + 0xffd00000)
+#define   CVBS_IRQ1_COUNTER                        (0x3c27)
+#define P_CVBS_IRQ1_COUNTER                        (volatile unsigned int *)((0x3c27  << 2) + 0xffd00000)
+#define   MEDIA_CPU_INTR_STAT                      (0x3c28)
+#define P_MEDIA_CPU_INTR_STAT                      (volatile unsigned int *)((0x3c28  << 2) + 0xffd00000)
+#define   MEDIA_CPU_INTR_STAT_CLR                  (0x3c29)
+#define P_MEDIA_CPU_INTR_STAT_CLR                  (volatile unsigned int *)((0x3c29  << 2) + 0xffd00000)
+#define   MEDIA_CPU_INTR_MASK                      (0x3c2a)
+#define P_MEDIA_CPU_INTR_MASK                      (volatile unsigned int *)((0x3c2a  << 2) + 0xffd00000)
+#define   MEDIA_CPU_INTR_FIRQ_SEL                  (0x3c2b)
+#define P_MEDIA_CPU_INTR_FIRQ_SEL                  (volatile unsigned int *)((0x3c2b  << 2) + 0xffd00000)
+// -----------------------------------------------------------
+#define   ISA_BIST_REG0                            (0x3c30)
+#define P_ISA_BIST_REG0                            (volatile unsigned int *)((0x3c30  << 2) + 0xffd00000)
+#define   ISA_BIST_REG1                            (0x3c31)
+#define P_ISA_BIST_REG1                            (volatile unsigned int *)((0x3c31  << 2) + 0xffd00000)
+// -----------------------------------------------------------
+#define   WATCHDOG_CNTL                            (0x3c34)
+#define P_WATCHDOG_CNTL                            (volatile unsigned int *)((0x3c34  << 2) + 0xffd00000)
+#define   WATCHDOG_CNTL1                           (0x3c35)
+#define P_WATCHDOG_CNTL1                           (volatile unsigned int *)((0x3c35  << 2) + 0xffd00000)
+#define   WATCHDOG_TCNT                            (0x3c36)
+#define P_WATCHDOG_TCNT                            (volatile unsigned int *)((0x3c36  << 2) + 0xffd00000)
+#define   WATCHDOG_RST                             (0x3c37)
+#define P_WATCHDOG_RST                             (volatile unsigned int *)((0x3c37  << 2) + 0xffd00000)
+// -----------------------------------------------------------
+#define   AHB_ARBITER_REG                          (0x3c42)
+#define P_AHB_ARBITER_REG                          (volatile unsigned int *)((0x3c42  << 2) + 0xffd00000)
+#define   AHB_ARBDEC_REG                           (0x3c43)
+#define P_AHB_ARBDEC_REG                           (volatile unsigned int *)((0x3c43  << 2) + 0xffd00000)
+#define   AHB_ARBITER2_REG                         (0x3c4a)
+#define P_AHB_ARBITER2_REG                         (volatile unsigned int *)((0x3c4a  << 2) + 0xffd00000)
+#define   DEVICE_MMCP_CNTL                         (0x3c4b)
+#define P_DEVICE_MMCP_CNTL                         (volatile unsigned int *)((0x3c4b  << 2) + 0xffd00000)
+#define   AUDIO_MMCP_CNTL                          (0x3c4c)
+#define P_AUDIO_MMCP_CNTL                          (volatile unsigned int *)((0x3c4c  << 2) + 0xffd00000)
+// -----------------------------------------------------------
+#define   ISA_TIMER_MUX                            (0x3c50)
+#define P_ISA_TIMER_MUX                            (volatile unsigned int *)((0x3c50  << 2) + 0xffd00000)
+#define   ISA_TIMERA                               (0x3c51)
+#define P_ISA_TIMERA                               (volatile unsigned int *)((0x3c51  << 2) + 0xffd00000)
+#define   ISA_TIMERB                               (0x3c52)
+#define P_ISA_TIMERB                               (volatile unsigned int *)((0x3c52  << 2) + 0xffd00000)
+#define   ISA_TIMERC                               (0x3c53)
+#define P_ISA_TIMERC                               (volatile unsigned int *)((0x3c53  << 2) + 0xffd00000)
+#define   ISA_TIMERD                               (0x3c54)
+#define P_ISA_TIMERD                               (volatile unsigned int *)((0x3c54  << 2) + 0xffd00000)
+#define   FBUF_ADDR                                (0x3c56)
+#define P_FBUF_ADDR                                (volatile unsigned int *)((0x3c56  << 2) + 0xffd00000)
+    #define VIDEO_FRM_BUF_MSB_BIT      23
+    #define VIDEO_FRM_BUF_LSB_BIT       2
+#define   SDRAM_CTL0                               (0x3c57)
+#define P_SDRAM_CTL0                               (volatile unsigned int *)((0x3c57  << 2) + 0xffd00000)
+#define   SDRAM_CTL2                               (0x3c58)
+#define P_SDRAM_CTL2                               (volatile unsigned int *)((0x3c58  << 2) + 0xffd00000)
+//`define AO_CPU_CTL                          8'h59
+#define   SDRAM_CTL4                               (0x3c5a)
+#define P_SDRAM_CTL4                               (volatile unsigned int *)((0x3c5a  << 2) + 0xffd00000)
+#define   SDRAM_CTL5                               (0x3c5b)
+#define P_SDRAM_CTL5                               (volatile unsigned int *)((0x3c5b  << 2) + 0xffd00000)
+#define   SDRAM_CTL6                               (0x3c5c)
+#define P_SDRAM_CTL6                               (volatile unsigned int *)((0x3c5c  << 2) + 0xffd00000)
+#define   SDRAM_CTL7                               (0x3c5d)
+#define P_SDRAM_CTL7                               (volatile unsigned int *)((0x3c5d  << 2) + 0xffd00000)
+#define   SDRAM_CTL8                               (0x3c5e)
+#define P_SDRAM_CTL8                               (volatile unsigned int *)((0x3c5e  << 2) + 0xffd00000)
+#define   AHB_MP4_MC_CTL                           (0x3c5f)
+#define P_AHB_MP4_MC_CTL                           (volatile unsigned int *)((0x3c5f  << 2) + 0xffd00000)
+#define   MEDIA_CPU_PCR                            (0x3c60)
+#define P_MEDIA_CPU_PCR                            (volatile unsigned int *)((0x3c60  << 2) + 0xffd00000)
+#define   MEDIA_CPU_CTL                            (0x3c61)
+#define P_MEDIA_CPU_CTL                            (volatile unsigned int *)((0x3c61  << 2) + 0xffd00000)
+#define   ISA_TIMERE                               (0x3c62)
+#define P_ISA_TIMERE                               (volatile unsigned int *)((0x3c62  << 2) + 0xffd00000)
+#define   ISA_TIMERE_HI                            (0x3c63)
+#define P_ISA_TIMERE_HI                            (volatile unsigned int *)((0x3c63  << 2) + 0xffd00000)
+#define   ISA_TIMER_MUX1                           (0x3c64)
+#define P_ISA_TIMER_MUX1                           (volatile unsigned int *)((0x3c64  << 2) + 0xffd00000)
+#define   ISA_TIMERF                               (0x3c65)
+#define P_ISA_TIMERF                               (volatile unsigned int *)((0x3c65  << 2) + 0xffd00000)
+#define   ISA_TIMERG                               (0x3c66)
+#define P_ISA_TIMERG                               (volatile unsigned int *)((0x3c66  << 2) + 0xffd00000)
+#define   ISA_TIMERH                               (0x3c67)
+#define P_ISA_TIMERH                               (volatile unsigned int *)((0x3c67  << 2) + 0xffd00000)
+#define   ISA_TIMERI                               (0x3c68)
+#define P_ISA_TIMERI                               (volatile unsigned int *)((0x3c68  << 2) + 0xffd00000)
+// ---------------------------------------------
+#define   ABUF_WR_CTL0                             (0x3c70)
+#define P_ABUF_WR_CTL0                             (volatile unsigned int *)((0x3c70  << 2) + 0xffd00000)
+    #define ABUF_WR_INT_EN	    31
+    #define ABUF_WR_INT_POS_MSB      30
+    #define ABUF_WR_INT_POS_LSB      16
+    #define ABUF_WR_BLK_SIZE_MSB     14
+    #define ABUF_WR_BLK_SIZE_LSB      0
+#define   ABUF_WR_CTL1                             (0x3c71)
+#define P_ABUF_WR_CTL1                             (volatile unsigned int *)((0x3c71  << 2) + 0xffd00000)
+    #define ABUF_WR_INT_EN	    31
+    #define ABUF_WR_INT_POS_MSB      30
+    #define ABUF_WR_INT_POS_LSB      16
+    #define ABUF_WR_BLK_SIZE_MSB     14
+    #define ABUF_WR_BLK_SIZE_LSB      0
+#define   ABUF_WR_CTL2                             (0x3c72)
+#define P_ABUF_WR_CTL2                             (volatile unsigned int *)((0x3c72  << 2) + 0xffd00000)
+    #define ABUF_WR_CUR_FF_CNT_MSB   21
+    #define ABUF_WR_CUR_FF_CNT_LSB   16
+    #define ABUF_WR_CUR_BLK_MSB      14
+    #define ABUF_WR_CUR_BLK_LSB       0
+#define   ABUF_WR_CTL3                             (0x3c73)
+#define P_ABUF_WR_CTL3                             (volatile unsigned int *)((0x3c73  << 2) + 0xffd00000)
+    #define ABUF_WR_AHB_RST_PLS       3
+    #define ABUF_WR_FF_CLR_PLS        2
+    #define ABUF_WR_PLY_RPT_LVL	     1
+    #define ABUF_WR_FF_PAUSE_LVL      0
+#define   ABUF_RD_CTL0                             (0x3c74)
+#define P_ABUF_RD_CTL0                             (volatile unsigned int *)((0x3c74  << 2) + 0xffd00000)
+#define   ABUF_RD_CTL1                             (0x3c75)
+#define P_ABUF_RD_CTL1                             (volatile unsigned int *)((0x3c75  << 2) + 0xffd00000)
+    #define ABUF_RD_INT_EN	    31
+    #define ABUF_RD_INT_POS_MSB      30
+    #define ABUF_RD_INT_POS_LSB      16
+    #define ABUF_RD_BLK_SIZE_MSB     14
+    #define ABUF_RD_BLK_SIZE_LSB      0
+#define   ABUF_RD_CTL2                             (0x3c76)
+#define P_ABUF_RD_CTL2                             (volatile unsigned int *)((0x3c76  << 2) + 0xffd00000)
+    #define ABUF_RD_CUR_FF_CNT_MSB   21
+    #define ABUF_RD_CUR_FF_CNT_LSB   16
+    #define ABUF_RD_CUR_BLK_MSB      14
+    #define ABUF_RD_CUR_BLK_LSB       0
+#define   ABUF_RD_CTL3                             (0x3c77)
+#define P_ABUF_RD_CTL3                             (volatile unsigned int *)((0x3c77  << 2) + 0xffd00000)
+    #define ABUF_RD_PLY_ONCE_PLS      4
+    #define ABUF_RD_AHB_RST_PLS       3
+    #define ABUF_RD_FF_CLR_PLS        2
+    #define ABUF_RD_PLY_RPT_LVL	     1
+    #define ABUF_RD_FF_PAUSE_LVL      0
+#define   ABUF_ARB_CTL0                            (0x3c78)
+#define P_ABUF_ARB_CTL0                            (volatile unsigned int *)((0x3c78  << 2) + 0xffd00000)
+#define   ABUF_FIFO_CTL0                           (0x3c79)
+#define P_ABUF_FIFO_CTL0                           (volatile unsigned int *)((0x3c79  << 2) + 0xffd00000)
+    #define AIUout_FIFO_THRESHOLD_MSB 11
+    #define AIUout_FIFO_THRESHOLD_LSB 6
+    #define AIUin_FIFO_THRESHOLD_MSB  5
+    #define AIUin_FIFO_THRESHOLD_LSB  0
+// ---------------------------------------------
+#define   AHB_BRIDGE_CNTL_WR                       (0x3c80)
+#define P_AHB_BRIDGE_CNTL_WR                       (volatile unsigned int *)((0x3c80  << 2) + 0xffd00000)
+#define   AHB_BRIDGE_REMAP0                        (0x3c81)
+#define P_AHB_BRIDGE_REMAP0                        (volatile unsigned int *)((0x3c81  << 2) + 0xffd00000)
+#define   AHB_BRIDGE_REMAP1                        (0x3c82)
+#define P_AHB_BRIDGE_REMAP1                        (volatile unsigned int *)((0x3c82  << 2) + 0xffd00000)
+#define   AHB_BRIDGE_REMAP2                        (0x3c83)
+#define P_AHB_BRIDGE_REMAP2                        (volatile unsigned int *)((0x3c83  << 2) + 0xffd00000)
+#define   AHB_BRIDGE_REMAP3                        (0x3c84)
+#define P_AHB_BRIDGE_REMAP3                        (volatile unsigned int *)((0x3c84  << 2) + 0xffd00000)
+#define   AHB_BRIDGE_CNTL_REG1                     (0x3c85)
+#define P_AHB_BRIDGE_CNTL_REG1                     (volatile unsigned int *)((0x3c85  << 2) + 0xffd00000)
+#define   AHB_BRIDGE_CNTL_REG2                     (0x3c86)
+#define P_AHB_BRIDGE_CNTL_REG2                     (volatile unsigned int *)((0x3c86  << 2) + 0xffd00000)
+// ---------------------------------------------
+// ----------------------------------------------
+// `define SYS_CPU_0_IRQ_IN0_INTR_STAT         8'h90
+// `define SYS_CPU_0_IRQ_IN0_INTR_STAT_CLR     8'h91
+// `define SYS_CPU_0_IRQ_IN0_INTR_MASK         8'h92
+// `define SYS_CPU_0_IRQ_IN0_INTR_FIRQ_SEL     8'h93
+// `define SYS_CPU_0_IRQ_IN1_INTR_STAT         8'h94
+// `define SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR     8'h95
+// `define SYS_CPU_0_IRQ_IN1_INTR_MASK         8'h96
+// `define SYS_CPU_0_IRQ_IN1_INTR_FIRQ_SEL     8'h97
+// `define SYS_CPU_0_IRQ_IN2_INTR_STAT         8'h98
+// `define SYS_CPU_0_IRQ_IN2_INTR_STAT_CLR     8'h99
+// `define SYS_CPU_0_IRQ_IN2_INTR_MASK         8'h9a
+// `define SYS_CPU_0_IRQ_IN2_INTR_FIRQ_SEL     8'h9b
+// `define SYS_CPU_0_IRQ_IN3_INTR_STAT         8'h9c
+// `define SYS_CPU_0_IRQ_IN3_INTR_STAT_CLR     8'h9d
+// `define SYS_CPU_0_IRQ_IN3_INTR_MASK         8'h9e
+// `define SYS_CPU_0_IRQ_IN3_INTR_FIRQ_SEL     8'h9f
+// ----------------------------------------------
+// `define SYS_CPU_1_IRQ_IN0_INTR_STAT         8'ha0
+// `define SYS_CPU_1_IRQ_IN0_INTR_STAT_CLR     8'ha1
+// `define SYS_CPU_1_IRQ_IN0_INTR_MASK         8'ha2
+// `define SYS_CPU_1_IRQ_IN0_INTR_FIRQ_SEL     8'ha3
+//
+// `define SYS_CPU_1_IRQ_IN1_INTR_STAT         8'ha4
+// `define SYS_CPU_1_IRQ_IN1_INTR_STAT_CLR     8'ha5
+// `define SYS_CPU_1_IRQ_IN1_INTR_MASK         8'ha6
+// `define SYS_CPU_1_IRQ_IN1_INTR_FIRQ_SEL     8'ha7
+//
+// `define SYS_CPU_1_IRQ_IN2_INTR_STAT         8'ha8
+// `define SYS_CPU_1_IRQ_IN2_INTR_STAT_CLR     8'ha9
+// `define SYS_CPU_1_IRQ_IN2_INTR_MASK         8'haa
+// `define SYS_CPU_1_IRQ_IN2_INTR_FIRQ_SEL     8'hab
+//
+// `define SYS_CPU_1_IRQ_IN3_INTR_STAT         8'hac
+// `define SYS_CPU_1_IRQ_IN3_INTR_STAT_CLR     8'had
+// `define SYS_CPU_1_IRQ_IN3_INTR_MASK         8'hae
+// `define SYS_CPU_1_IRQ_IN3_INTR_FIRQ_SEL     8'haf
+// ----------------------------------------------
+// `define MEDIA_CPU_IRQ_IN4_INTR_STAT         8'hb0
+// `define MEDIA_CPU_IRQ_IN4_INTR_STAT_CLR     8'hb1
+// `define MEDIA_CPU_IRQ_IN4_INTR_MASK         8'hb2
+// `define MEDIA_CPU_IRQ_IN4_INTR_FIRQ_SEL     8'hb3
+// `define SYS_CPU_0_IRQ_IN4_INTR_STAT         8'hb4
+// `define SYS_CPU_0_IRQ_IN4_INTR_STAT_CLR     8'hb5
+// `define SYS_CPU_0_IRQ_IN4_INTR_MASK         8'hb6
+// `define SYS_CPU_0_IRQ_IN4_INTR_FIRQ_SEL     8'hb7
+// `define SYS_CPU_1_IRQ_IN4_INTR_STAT         8'hb8
+// `define SYS_CPU_1_IRQ_IN4_INTR_STAT_CLR     8'hb9
+// `define SYS_CPU_1_IRQ_IN4_INTR_MASK         8'hba
+// `define SYS_CPU_1_IRQ_IN4_INTR_FIRQ_SEL     8'hbb
+// `define SYS_CPU_2_IRQ_IN4_INTR_STAT         8'hbc
+// `define SYS_CPU_2_IRQ_IN4_INTR_STAT_CLR     8'hbd
+// `define SYS_CPU_2_IRQ_IN4_INTR_MASK         8'hbe
+// `define SYS_CPU_2_IRQ_IN4_INTR_FIRQ_SEL     8'hbf
+// ----------------------------------------------
+// `define SYS_CPU_2_IRQ_IN0_INTR_STAT         8'hc0
+// `define SYS_CPU_2_IRQ_IN0_INTR_STAT_CLR     8'hc1
+// `define SYS_CPU_2_IRQ_IN0_INTR_MASK         8'hc2
+// `define SYS_CPU_2_IRQ_IN0_INTR_FIRQ_SEL     8'hc3
+// `define SYS_CPU_2_IRQ_IN1_INTR_STAT         8'hc4
+// `define SYS_CPU_2_IRQ_IN1_INTR_STAT_CLR     8'hc5
+// `define SYS_CPU_2_IRQ_IN1_INTR_MASK         8'hc6
+// `define SYS_CPU_2_IRQ_IN1_INTR_FIRQ_SEL     8'hc7
+// `define SYS_CPU_2_IRQ_IN2_INTR_STAT         8'hc8
+// `define SYS_CPU_2_IRQ_IN2_INTR_STAT_CLR     8'hc9
+// `define SYS_CPU_2_IRQ_IN2_INTR_MASK         8'hca
+// `define SYS_CPU_2_IRQ_IN2_INTR_FIRQ_SEL     8'hcb
+// `define SYS_CPU_2_IRQ_IN3_INTR_STAT         8'hcc
+// `define SYS_CPU_2_IRQ_IN3_INTR_STAT_CLR     8'hcd
+// `define SYS_CPU_2_IRQ_IN3_INTR_MASK         8'hce
+// `define SYS_CPU_2_IRQ_IN3_INTR_FIRQ_SEL     8'hcf
+// ----------------------------------------------
+// `define SYS_CPU_3_IRQ_IN0_INTR_STAT         8'hd0
+// `define SYS_CPU_3_IRQ_IN0_INTR_STAT_CLR     8'hd1
+// `define SYS_CPU_3_IRQ_IN0_INTR_MASK         8'hd2
+// `define SYS_CPU_3_IRQ_IN0_INTR_FIRQ_SEL     8'hd3
+// `define SYS_CPU_3_IRQ_IN1_INTR_STAT         8'hd4
+// `define SYS_CPU_3_IRQ_IN1_INTR_STAT_CLR     8'hd5
+// `define SYS_CPU_3_IRQ_IN1_INTR_MASK         8'hd6
+// `define SYS_CPU_3_IRQ_IN1_INTR_FIRQ_SEL     8'hd7
+// `define SYS_CPU_3_IRQ_IN2_INTR_STAT         8'hd8
+// `define SYS_CPU_3_IRQ_IN2_INTR_STAT_CLR     8'hd9
+// `define SYS_CPU_3_IRQ_IN2_INTR_MASK         8'hda
+// `define SYS_CPU_3_IRQ_IN2_INTR_FIRQ_SEL     8'hdb
+// `define SYS_CPU_3_IRQ_IN3_INTR_STAT         8'hdc
+// `define SYS_CPU_3_IRQ_IN3_INTR_STAT_CLR     8'hdd
+// `define SYS_CPU_3_IRQ_IN3_INTR_MASK         8'hde
+// `define SYS_CPU_3_IRQ_IN3_INTR_FIRQ_SEL     8'hdf
+// ----------------------------------------------
+// `define SYS_CPU_3_IRQ_IN4_INTR_STAT         8'he0
+// `define SYS_CPU_3_IRQ_IN4_INTR_STAT_CLR     8'he1
+// `define SYS_CPU_3_IRQ_IN4_INTR_MASK         8'he2
+// `define SYS_CPU_3_IRQ_IN4_INTR_FIRQ_SEL     8'he3
+// `define MEDIA_CPU_IRQ_IN5_INTR_STAT         8'he4
+// `define MEDIA_CPU_IRQ_IN5_INTR_STAT_CLR     8'he5
+// `define MEDIA_CPU_IRQ_IN5_INTR_MASK         8'he6
+// `define MEDIA_CPU_IRQ_IN5_INTR_FIRQ_SEL     8'he7
+// `define SYS_CPU_0_IRQ_IN5_INTR_STAT         8'he8
+// `define SYS_CPU_0_IRQ_IN5_INTR_STAT_CLR     8'he9
+// `define SYS_CPU_0_IRQ_IN5_INTR_MASK         8'hea
+// `define SYS_CPU_0_IRQ_IN5_INTR_FIRQ_SEL     8'heb
+//
+// Closing file:  isa_reg.h
+//
+//`include "bt656_reg.h"
+//`include "pdm_reg.h"
+//========================================================================
+//  Global Control Registers			    (12'h000 - 12'h0ff)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  RESET_CBUS_BASE = 0x04
+// -----------------------------------------------
+#define   VERSION_CTRL                             (0x0400)
+#define P_VERSION_CTRL                             (volatile unsigned int *)((0x0400  << 2) + 0xffd00000)
+#define   RESET0_REGISTER                          (0x0401)
+#define P_RESET0_REGISTER                          (volatile unsigned int *)((0x0401  << 2) + 0xffd00000)
+#define   RESET1_REGISTER                          (0x0402)
+#define P_RESET1_REGISTER                          (volatile unsigned int *)((0x0402  << 2) + 0xffd00000)
+#define   RESET2_REGISTER                          (0x0403)
+#define P_RESET2_REGISTER                          (volatile unsigned int *)((0x0403  << 2) + 0xffd00000)
+#define   RESET3_REGISTER                          (0x0404)
+#define P_RESET3_REGISTER                          (volatile unsigned int *)((0x0404  << 2) + 0xffd00000)
+#define   RESET4_REGISTER                          (0x0405)
+#define P_RESET4_REGISTER                          (volatile unsigned int *)((0x0405  << 2) + 0xffd00000)
+#define   RESET5_REGISTER                          (0x0406)
+#define P_RESET5_REGISTER                          (volatile unsigned int *)((0x0406  << 2) + 0xffd00000)
+#define   RESET6_REGISTER                          (0x0407)
+#define P_RESET6_REGISTER                          (volatile unsigned int *)((0x0407  << 2) + 0xffd00000)
+#define   RESET7_REGISTER                          (0x0408)
+#define P_RESET7_REGISTER                          (volatile unsigned int *)((0x0408  << 2) + 0xffd00000)
+#define   RESET0_MASK                              (0x0410)
+#define P_RESET0_MASK                              (volatile unsigned int *)((0x0410  << 2) + 0xffd00000)
+#define   RESET1_MASK                              (0x0411)
+#define P_RESET1_MASK                              (volatile unsigned int *)((0x0411  << 2) + 0xffd00000)
+#define   RESET2_MASK                              (0x0412)
+#define P_RESET2_MASK                              (volatile unsigned int *)((0x0412  << 2) + 0xffd00000)
+#define   RESET3_MASK                              (0x0413)
+#define P_RESET3_MASK                              (volatile unsigned int *)((0x0413  << 2) + 0xffd00000)
+#define   RESET4_MASK                              (0x0414)
+#define P_RESET4_MASK                              (volatile unsigned int *)((0x0414  << 2) + 0xffd00000)
+#define   RESET5_MASK                              (0x0415)
+#define P_RESET5_MASK                              (volatile unsigned int *)((0x0415  << 2) + 0xffd00000)
+#define   RESET6_MASK                              (0x0416)
+#define P_RESET6_MASK                              (volatile unsigned int *)((0x0416  << 2) + 0xffd00000)
+#define   CRT_MASK                                 (0x0417)
+#define P_CRT_MASK                                 (volatile unsigned int *)((0x0417  << 2) + 0xffd00000)
+#define   RESET7_MASK                              (0x0418)
+#define P_RESET7_MASK                              (volatile unsigned int *)((0x0418  << 2) + 0xffd00000)
+#define   RESET0_LEVEL                             (0x0420)
+#define P_RESET0_LEVEL                             (volatile unsigned int *)((0x0420  << 2) + 0xffd00000)
+#define   RESET1_LEVEL                             (0x0421)
+#define P_RESET1_LEVEL                             (volatile unsigned int *)((0x0421  << 2) + 0xffd00000)
+#define   RESET2_LEVEL                             (0x0422)
+#define P_RESET2_LEVEL                             (volatile unsigned int *)((0x0422  << 2) + 0xffd00000)
+#define   RESET3_LEVEL                             (0x0423)
+#define P_RESET3_LEVEL                             (volatile unsigned int *)((0x0423  << 2) + 0xffd00000)
+#define   RESET4_LEVEL                             (0x0424)
+#define P_RESET4_LEVEL                             (volatile unsigned int *)((0x0424  << 2) + 0xffd00000)
+#define   RESET5_LEVEL                             (0x0425)
+#define P_RESET5_LEVEL                             (volatile unsigned int *)((0x0425  << 2) + 0xffd00000)
+#define   RESET6_LEVEL                             (0x0426)
+#define P_RESET6_LEVEL                             (volatile unsigned int *)((0x0426  << 2) + 0xffd00000)
+#define   RESET7_LEVEL                             (0x0427)
+#define P_RESET7_LEVEL                             (volatile unsigned int *)((0x0427  << 2) + 0xffd00000)
+//======================================
+//  Reset Register Bits
+//
+//======================================
+    #define HIU_RESET	    0x0001
+    #define VLD_RESET	    0x0002
+    #define IQIDCT_RESET	0x0004
+    #define MC_RESET	    0x0008
+    #define DCU_RESET	    0x0010
+    #define VIU_RESET	    0x0020
+    #define AIU_RESET	    0x0040
+    #define CPU_RESET	    0x0080
+    #define AC3_RESET	    0x0100
+    #define MPEG_RESET	    0x0200
+//-----------------------------------------------------------
+// PARSER
+//-----------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PARSER_CBUS_BASE = 0x38
+// -----------------------------------------------
+// bit 31:8 -- es_pack_size
+// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
+// bit 5 -- es_write
+// bit 4 -- es_passthrough
+// bit 3 -- insert_before_es_write
+// bit 2 -- discard_cmd
+// bit 1 -- search_cmd
+// bit 0 -- Parser Busy
+#define   PARSER_CONTROL                           (0x3860)
+#define P_PARSER_CONTROL                           (volatile unsigned int *)((0x3860  << 2) + 0xffd00000)
+// Write
+//   bit 31:0 begin address for parser fetch
+// Read
+//   32 bit current fetch address
+#define   PARSER_FETCH_ADDR                        (0x3861)
+#define P_PARSER_FETCH_ADDR                        (volatile unsigned int *)((0x3861  << 2) + 0xffd00000)
+// Write
+//   bit 31 circle buffer indicator
+//   bit 30 check_buffer_stop_addr
+//   bit 29:27 fetch endian
+//   bit 26:0 buffer size ( Bytes )
+// Special command:
+//   when bit 26:0 == 27'h0
+//     then bit 29    -- stream_passthrough_enable
+//          bit 28:27 -- stream_passthrough_type
+// Read
+//   6:5 cmd_rd_ptr
+//   4:3 cmd_wr_ptr
+//   2:0 cmd_number
+#define   PARSER_FETCH_CMD                         (0x3862)
+#define P_PARSER_FETCH_CMD                         (volatile unsigned int *)((0x3862  << 2) + 0xffd00000)
+// 31:0 stop_fetch_addr
+#define   PARSER_FETCH_STOP_ADDR                   (0x3863)
+#define P_PARSER_FETCH_STOP_ADDR                   (volatile unsigned int *)((0x3863  << 2) + 0xffd00000)
+// 31:0 stop_fetch_addr - current_write_addr  // read only
+#define   PARSER_FETCH_LEVEL                       (0x3864)
+#define P_PARSER_FETCH_LEVEL                       (volatile unsigned int *)((0x3864  << 2) + 0xffd00000)
+// bit 31 - fetch_dma_urgent
+// bit 30 - stream_dma_urgent
+// bit 29 - force_pfifo_ren
+// bit 28 - pfifo_peak_enable
+// bit 27 - enable_free_clk_parser_reg
+// bit 26 -
+// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
+// bit 23:16 - pfifo_empty_count
+// bit 15:12 - max_es_write_cycle (x16x64bits)
+// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
+// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
+// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
+#define   PARSER_CONFIG                            (0x3865)
+#define P_PARSER_CONFIG                            (volatile unsigned int *)((0x3865  << 2) + 0xffd00000)
+// bit 24:16 -- pfifo_level
+// bit 9:0 -- point to byte address
+#define   PFIFO_WR_PTR                             (0x3866)
+#define P_PFIFO_WR_PTR                             (volatile unsigned int *)((0x3866  << 2) + 0xffd00000)
+// bit 9:0 -- point to byte address
+#define   PFIFO_RD_PTR                             (0x3867)
+#define P_PFIFO_RD_PTR                             (volatile unsigned int *)((0x3867  << 2) + 0xffd00000)
+// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
+#define   PFIFO_DATA                               (0x3868)
+#define P_PFIFO_DATA                               (volatile unsigned int *)((0x3868  << 2) + 0xffd00000)
+// bit 31:0 -- parser search pattern
+#define   PARSER_SEARCH_PATTERN                    (0x3869)
+#define P_PARSER_SEARCH_PATTERN                    (volatile unsigned int *)((0x3869  << 2) + 0xffd00000)
+// bit 31:0 -- parser search mask ( 0 - disable bit match test )
+#define   PARSER_SEARCH_MASK                       (0x386a)
+#define P_PARSER_SEARCH_MASK                       (volatile unsigned int *)((0x386a  << 2) + 0xffd00000)
+// bit 31:16 -- parser_int_disable_count
+// bit 15:8 -- Parser interrupt enable for host cpu
+// bit 7:0 -- Parser interrupt enable for Amrisc
+#define   PARSER_INT_ENABLE                        (0x386b)
+#define P_PARSER_INT_ENABLE                        (volatile unsigned int *)((0x386b  << 2) + 0xffd00000)
+// Bit 7 -- fetch_cmd_finished
+// Bit 6:5 -- reserved
+// Bit 4 -- parse finished
+// Bit 3 -- discard finished
+// Bit 2 -- insert zero finished
+// Bit 1 -- Action Finished Except Search Start Code
+// Bit 0 -- Search match interrupt (StartCode found)
+// Read 7:0 int status
+// Write will clear (bit based)
+#define   PARSER_INT_STATUS                        (0x386c)
+#define P_PARSER_INT_STATUS                        (volatile unsigned int *)((0x386c  << 2) + 0xffd00000)
+// 15    - SCR_32_READ_OUT (Read Only)
+// 14    - SCR_32_data_valid
+// 13    - SCR_32_data
+// 12    - SCR_count_en
+// 11:0  - SCR90K_DIV
+#define   PARSER_SCR_CTL                           (0x386d)
+#define P_PARSER_SCR_CTL                           (volatile unsigned int *)((0x386d  << 2) + 0xffd00000)
+// bit 31:0 SCR value
+#define   PARSER_SCR                               (0x386e)
+#define P_PARSER_SCR                               (volatile unsigned int *)((0x386e  << 2) + 0xffd00000)
+// bit 31:24 -- insert_loop_number
+// bit 23:21 --
+// bit 20:16 -- insert_byte_number
+// bit 15:0 -- discard number
+#define   PARSER_PARAMETER                         (0x386f)
+#define P_PARSER_PARAMETER                         (volatile unsigned int *)((0x386f  << 2) + 0xffd00000)
+// bit 31:0 -- insert data // write only
+// write to PARSER_CONTROL will reset the write position
+// continous write to this address can write upto 16 bytes
+#define   PARSER_INSERT_DATA                       (0x3870)
+#define P_PARSER_INSERT_DATA                       (volatile unsigned int *)((0x3870  << 2) + 0xffd00000)
+// Bit 31:24 -- Reserved Stream_ID
+// Bit 23:16 -- Sub Stream_ID
+// Bit 15:8  -- Audio Stream_ID
+// Bit 7:0   -- Video Stream_ID
+#define   VAS_STREAM_ID                            (0x3871)
+#define P_VAS_STREAM_ID                            (volatile unsigned int *)((0x3871  << 2) + 0xffd00000)
+// Bit 31:0 -- VIDEO_DTS
+#define   VIDEO_DTS                                (0x3872)
+#define P_VIDEO_DTS                                (volatile unsigned int *)((0x3872  << 2) + 0xffd00000)
+// Bit 31:0 -- VIDEO_PTS
+#define   VIDEO_PTS                                (0x3873)
+#define P_VIDEO_PTS                                (volatile unsigned int *)((0x3873  << 2) + 0xffd00000)
+// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
+#define   VIDEO_PTS_DTS_WR_PTR                     (0x3874)
+#define P_VIDEO_PTS_DTS_WR_PTR                     (volatile unsigned int *)((0x3874  << 2) + 0xffd00000)
+// Bit 31:0 -- AUDIO_PTS
+#define   AUDIO_PTS                                (0x3875)
+#define P_AUDIO_PTS                                (volatile unsigned int *)((0x3875  << 2) + 0xffd00000)
+// Bit 31:0 -- AUDIO_PTS_WR_PTR
+#define   AUDIO_PTS_WR_PTR                         (0x3876)
+#define P_AUDIO_PTS_WR_PTR                         (volatile unsigned int *)((0x3876  << 2) + 0xffd00000)
+// bit 31:20 -- stream_es_count ( Read Only)
+// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
+// bit 18 -- stream_es_passthrough_enable
+// bit 17:16 -- stream_es_passthrough_type
+// bit 15:13 -- VIDEO2 Ees_write Endian
+// bit 12 -- VIDEO2 using manual read point
+// bit 11:9 -- SUB Ees_write Endian
+// bit 8 -- SUB using manual read point
+// bit 7:5 -- AUDIO Ees_write Endian
+// bit 4 -- AUDIO using manual read point
+// bit 3:1 -- VIDEO Ees_write Endian
+// bit 0 -- VIDEO using manual read point
+#define   PARSER_ES_CONTROL                        (0x3877)
+#define P_PARSER_ES_CONTROL                        (volatile unsigned int *)((0x3877  << 2) + 0xffd00000)
+// Bit 31:0 PFIFO_MONITOR
+#define   PFIFO_MONITOR                            (0x3878)
+#define P_PFIFO_MONITOR                            (volatile unsigned int *)((0x3878  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_VIDEO DDR Interface
+// --------------------------------------------
+// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   PARSER_VIDEO_START_PTR                   (0x3880)
+#define P_PARSER_VIDEO_START_PTR                   (volatile unsigned int *)((0x3880  << 2) + 0xffd00000)
+#define   PARSER_VIDEO_END_PTR                     (0x3881)
+#define P_PARSER_VIDEO_END_PTR                     (volatile unsigned int *)((0x3881  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_VIDEO Buffer Level Manager
+// --------------------------------------------
+#define   PARSER_VIDEO_WP                          (0x3882)
+#define P_PARSER_VIDEO_WP                          (volatile unsigned int *)((0x3882  << 2) + 0xffd00000)
+#define   PARSER_VIDEO_RP                          (0x3883)
+#define P_PARSER_VIDEO_RP                          (volatile unsigned int *)((0x3883  << 2) + 0xffd00000)
+#define   PARSER_VIDEO_HOLE                        (0x3884)
+#define P_PARSER_VIDEO_HOLE                        (volatile unsigned int *)((0x3884  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_AUDIO DDR Interface
+// --------------------------------------------
+// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   PARSER_AUDIO_START_PTR                   (0x3885)
+#define P_PARSER_AUDIO_START_PTR                   (volatile unsigned int *)((0x3885  << 2) + 0xffd00000)
+#define   PARSER_AUDIO_END_PTR                     (0x3886)
+#define P_PARSER_AUDIO_END_PTR                     (volatile unsigned int *)((0x3886  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_AUDIO Buffer Level Manager
+// --------------------------------------------
+#define   PARSER_AUDIO_WP                          (0x3887)
+#define P_PARSER_AUDIO_WP                          (volatile unsigned int *)((0x3887  << 2) + 0xffd00000)
+#define   PARSER_AUDIO_RP                          (0x3888)
+#define P_PARSER_AUDIO_RP                          (volatile unsigned int *)((0x3888  << 2) + 0xffd00000)
+#define   PARSER_AUDIO_HOLE                        (0x3889)
+#define P_PARSER_AUDIO_HOLE                        (volatile unsigned int *)((0x3889  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_SUB DDR Interface
+// --------------------------------------------
+// The PARSER_SUB start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   PARSER_SUB_START_PTR                     (0x388a)
+#define P_PARSER_SUB_START_PTR                     (volatile unsigned int *)((0x388a  << 2) + 0xffd00000)
+#define   PARSER_SUB_END_PTR                       (0x388b)
+#define P_PARSER_SUB_END_PTR                       (volatile unsigned int *)((0x388b  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_SUB Buffer Level Manager
+// --------------------------------------------
+#define   PARSER_SUB_WP                            (0x388c)
+#define P_PARSER_SUB_WP                            (volatile unsigned int *)((0x388c  << 2) + 0xffd00000)
+#define   PARSER_SUB_RP                            (0x388d)
+#define P_PARSER_SUB_RP                            (volatile unsigned int *)((0x388d  << 2) + 0xffd00000)
+#define   PARSER_SUB_HOLE                          (0x388e)
+#define P_PARSER_SUB_HOLE                          (volatile unsigned int *)((0x388e  << 2) + 0xffd00000)
+// Bit[31] dma_busy
+// Bit[30] cur_fetch_or_es_write
+// Bit[29:28] reserved
+// Bit[27:24] fetch_status
+// Bit[23:0] buffer_cycles_left
+#define   PARSER_FETCH_INFO                        (0x388f)
+#define P_PARSER_FETCH_INFO                        (volatile unsigned int *)((0x388f  << 2) + 0xffd00000)
+// Bit[31:28] ctl_status
+// Bit[27:24] insert_byte_offset
+// Bit[23:0] es_pack_left_cycle
+#define   PARSER_STATUS                            (0x3890)
+#define P_PARSER_STATUS                            (volatile unsigned int *)((0x3890  << 2) + 0xffd00000)
+// Bit [31:16] AUDIO_wrap_count
+// Bit  [15:0] VIDEO_wrap_count
+#define   PARSER_AV_WRAP_COUNT                     (0x3891)
+#define P_PARSER_AV_WRAP_COUNT                     (volatile unsigned int *)((0x3891  << 2) + 0xffd00000)
+// bit[29:24] A_brst_num_parser
+// bit[21:16] A_id_parser
+// bit[11:0] wrrsp_count_parser
+#define   WRRSP_PARSER                             (0x3892)
+#define P_WRRSP_PARSER                             (volatile unsigned int *)((0x3892  << 2) + 0xffd00000)
+// `define CSS_cmd             12'h200   // address of css command and indirect register
+// `define CSS_cntl            12'h201   // css control register
+// `define CSS_data            12'h202   // indirect register
+// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
+// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
+//CPPM registers
+// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
+// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
+// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
+// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
+// `define CPPM_CMD			12'h214   //CPPM command and control register
+// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug
+// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug
+// --------------------------------------------
+// PARSER_VIDEO2 DDR Interface
+// --------------------------------------------
+// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   PARSER_VIDEO2_START_PTR                  (0x3893)
+#define P_PARSER_VIDEO2_START_PTR                  (volatile unsigned int *)((0x3893  << 2) + 0xffd00000)
+#define   PARSER_VIDEO2_END_PTR                    (0x3894)
+#define P_PARSER_VIDEO2_END_PTR                    (volatile unsigned int *)((0x3894  << 2) + 0xffd00000)
+// --------------------------------------------
+// PARSER_VIDEO2 Buffer Level Manager
+// --------------------------------------------
+#define   PARSER_VIDEO2_WP                         (0x3895)
+#define P_PARSER_VIDEO2_WP                         (volatile unsigned int *)((0x3895  << 2) + 0xffd00000)
+#define   PARSER_VIDEO2_RP                         (0x3896)
+#define P_PARSER_VIDEO2_RP                         (volatile unsigned int *)((0x3896  << 2) + 0xffd00000)
+#define   PARSER_VIDEO2_HOLE                       (0x3897)
+#define P_PARSER_VIDEO2_HOLE                       (volatile unsigned int *)((0x3897  << 2) + 0xffd00000)
+// Bit [31:16] AUDIO_wrap_count
+// Bit  [15:0] VIDEO2_wrap_count
+#define   PARSER_AV2_WRAP_COUNT                    (0x3898)
+#define P_PARSER_AV2_WRAP_COUNT                    (volatile unsigned int *)((0x3898  << 2) + 0xffd00000)
+// DDR registers
+//`define USE_DDR2
+//========================================================================
+//  DVIN Registers				    (12'h2e0 - 12'h2ef)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DVIN_CBUS_BASE = 0x08
+// -----------------------------------------------
+// Bit 31:12 Rsrv
+// Bit 11:10 RW, vs_hs_tim_ctrl: Controls which edge of HS/VS the active pixel/line is related:
+//                               bit[0]=0: start of active pixel is counted from the rising edge of HS;
+//                               bit[0]=1: start of active pixel is counted from the falling edge of HS;
+//                               bit[1]=0: start of active line is counted from the rising edge of VS;
+//                               bit[1]=1: start of active line is counted from the falling edge of VS.
+// Bit     9 RW, sample_clk_neg: 1=invert input dvin_clk
+// Bit  8: 7 RW, mode_422to444: 0=No convertion; 1=Rsrv; 2=Convert 422 to 444, use previous C value; 3=Convert 422 to 444, use average C value.
+// Bit  6: 5 RW, de_mode: 0x=ignore input DE signal, use internal detection to to determine active pixel;
+//                        10=during active pixel, if DE is low, replace input data with the last good data before DE goes low;
+//                        11=Active pixel is determined by DE, no internal detection.
+// Bit     4 RW, ext_field_sel: 1=Select external input Field, 0=Use internal detected Field.
+// Bit     3 RW, field_pol_inv: set to 1 if input Field is low active and ext_field_sel=1
+// Bit     2 RW, de_pol_inv: set to 1 if input DE is low active
+// Bit     1 RW, vs_pol_inv: set to 1 if input VS is low active
+// Bit     0 RW, hs_pol_inv: set to 1 if input HS is low active
+#define   DVIN_FRONT_END_CTRL                      (0x08e0)
+#define P_DVIN_FRONT_END_CTRL                      (volatile unsigned int *)((0x08e0  << 2) + 0xffd00000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, hs_lead_vs_odd_max: Criteria for HW detecting odd/even Field internally: max clock cycles allowed for HS
+//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, hs_lead_vs_odd_min: Criteria for HW detecting odd/even Field internally -- min clock cycles allowed for HS
+//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
+#define   DVIN_HS_LEAD_VS_ODD                      (0x08e1)
+#define P_DVIN_HS_LEAD_VS_ODD                      (volatile unsigned int *)((0x08e1  << 2) + 0xffd00000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, active_start_pix_fo
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, active_start_pix_fe
+#define   DVIN_ACTIVE_START_PIX                    (0x08e2)
+#define P_DVIN_ACTIVE_START_PIX                    (volatile unsigned int *)((0x08e2  << 2) + 0xffd00000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, active_start_line_fo
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, active_start_line_fe
+#define   DVIN_ACTIVE_START_LINE                   (0x08e3)
+#define P_DVIN_ACTIVE_START_LINE                   (volatile unsigned int *)((0x08e3  << 2) + 0xffd00000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, field_height_m1
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, line_width_m1
+#define   DVIN_DISPLAY_SIZE                        (0x08e4)
+#define P_DVIN_DISPLAY_SIZE                        (volatile unsigned int *)((0x08e4  << 2) + 0xffd00000)
+// Bit    31 Rsrv
+// Bit    30 R,  vs_in_polarity: 0=active high; 1=active low.
+// Bit    29 R,  hs_in_polarity: 0=active high; 1=active low.
+// Bit    28 R,  field_odd
+// Bit 27:16 R,  hs_lead_vs_cnt
+// Bit 15: 4 Rsrv
+// Bit  3: 1 RW, data_comp_map: Re-map input data to form YCbCr.
+//                              0=YCbCr is {[29:20], [19:10], [ 9: 0]};
+//                              1=YCbCr is {[29:20], [ 9: 0], [19:10]};
+//                              2=YCbCr is {[ 9: 0], [29:20], [19:10]};
+//                              3=YCbCr is {[19:10], [29:20], [ 9: 0]};
+//                              4=YCbCr is {[19:10], [ 9: 0], [29:20]};
+//                              5=YCbCr is {[ 9: 0], [19:10], [29:20]};
+//                              6,7=Rsrv
+// Bit     0 RW, dvin_enable
+#define   DVIN_CTRL_STAT                           (0x08e5)
+#define P_DVIN_CTRL_STAT                           (volatile unsigned int *)((0x08e5  << 2) + 0xffd00000)
+//========================================================================
+//  DOS registers				    APB allocation from 32'hd0050000
+//
+//========================================================================
+//=======================================================================
+// XIF module
+// `include "xregs.h"
+    #define X_INT_ADR           0x400
+    #define GPIO_ADR            0x401
+    #define GPIO_ADR_H8         0x402
+    #define WFIFO_DEPTH         8
+    #define WFIFO_PointerWidth  3
+    #define WFIFO_WORDSIZE      32
+// MAC module
+// move them to cpu domain.
+//`define CLR_ACC_MAC         12'h410
+//`define CLR_ACC_MAC2        12'h411
+//`define ACC_0               12'h412
+//`define ACC_1               12'h413
+//`define ACC_2               12'h414
+//`define ACC_3               12'h415
+//========================================================================
+//  Audio EQ DRC Interface				    (15'h1400 - 15'h14ff)
+//
+//========================================================================
+//
+// Reading file:  audio_eq_drc.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  AED_CBUS_BASE = 0x10
+// -----------------------------------------------
+
+/* defined in g12a secure_apb.h */
+#if 0
+#define   AED_EQ_CH1_COEF00                        (0x1000)
+#define P_AED_EQ_CH1_COEF00                        (volatile unsigned int *)((0x1000  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF01                        (0x1001)
+#define P_AED_EQ_CH1_COEF01                        (volatile unsigned int *)((0x1001  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF02                        (0x1002)
+#define P_AED_EQ_CH1_COEF02                        (volatile unsigned int *)((0x1002  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF03                        (0x1003)
+#define P_AED_EQ_CH1_COEF03                        (volatile unsigned int *)((0x1003  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF04                        (0x1004)
+#define P_AED_EQ_CH1_COEF04                        (volatile unsigned int *)((0x1004  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF10                        (0x1005)
+#define P_AED_EQ_CH1_COEF10                        (volatile unsigned int *)((0x1005  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF11                        (0x1006)
+#define P_AED_EQ_CH1_COEF11                        (volatile unsigned int *)((0x1006  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF12                        (0x1007)
+#define P_AED_EQ_CH1_COEF12                        (volatile unsigned int *)((0x1007  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF13                        (0x1008)
+#define P_AED_EQ_CH1_COEF13                        (volatile unsigned int *)((0x1008  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF14                        (0x1009)
+#define P_AED_EQ_CH1_COEF14                        (volatile unsigned int *)((0x1009  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF20                        (0x100a)
+#define P_AED_EQ_CH1_COEF20                        (volatile unsigned int *)((0x100a  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF21                        (0x100b)
+#define P_AED_EQ_CH1_COEF21                        (volatile unsigned int *)((0x100b  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF22                        (0x100c)
+#define P_AED_EQ_CH1_COEF22                        (volatile unsigned int *)((0x100c  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF23                        (0x100d)
+#define P_AED_EQ_CH1_COEF23                        (volatile unsigned int *)((0x100d  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF24                        (0x100e)
+#define P_AED_EQ_CH1_COEF24                        (volatile unsigned int *)((0x100e  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF30                        (0x100f)
+#define P_AED_EQ_CH1_COEF30                        (volatile unsigned int *)((0x100f  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF31                        (0x1010)
+#define P_AED_EQ_CH1_COEF31                        (volatile unsigned int *)((0x1010  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF32                        (0x1011)
+#define P_AED_EQ_CH1_COEF32                        (volatile unsigned int *)((0x1011  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF33                        (0x1012)
+#define P_AED_EQ_CH1_COEF33                        (volatile unsigned int *)((0x1012  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF34                        (0x1013)
+#define P_AED_EQ_CH1_COEF34                        (volatile unsigned int *)((0x1013  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF40                        (0x1014)
+#define P_AED_EQ_CH1_COEF40                        (volatile unsigned int *)((0x1014  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF41                        (0x1015)
+#define P_AED_EQ_CH1_COEF41                        (volatile unsigned int *)((0x1015  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF42                        (0x1016)
+#define P_AED_EQ_CH1_COEF42                        (volatile unsigned int *)((0x1016  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF43                        (0x1017)
+#define P_AED_EQ_CH1_COEF43                        (volatile unsigned int *)((0x1017  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF44                        (0x1018)
+#define P_AED_EQ_CH1_COEF44                        (volatile unsigned int *)((0x1018  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF50                        (0x1019)
+#define P_AED_EQ_CH1_COEF50                        (volatile unsigned int *)((0x1019  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF51                        (0x101a)
+#define P_AED_EQ_CH1_COEF51                        (volatile unsigned int *)((0x101a  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF52                        (0x101b)
+#define P_AED_EQ_CH1_COEF52                        (volatile unsigned int *)((0x101b  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF53                        (0x101c)
+#define P_AED_EQ_CH1_COEF53                        (volatile unsigned int *)((0x101c  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF54                        (0x101d)
+#define P_AED_EQ_CH1_COEF54                        (volatile unsigned int *)((0x101d  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF60                        (0x101e)
+#define P_AED_EQ_CH1_COEF60                        (volatile unsigned int *)((0x101e  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF61                        (0x101f)
+#define P_AED_EQ_CH1_COEF61                        (volatile unsigned int *)((0x101f  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF62                        (0x1020)
+#define P_AED_EQ_CH1_COEF62                        (volatile unsigned int *)((0x1020  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF63                        (0x1021)
+#define P_AED_EQ_CH1_COEF63                        (volatile unsigned int *)((0x1021  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF64                        (0x1022)
+#define P_AED_EQ_CH1_COEF64                        (volatile unsigned int *)((0x1022  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF70                        (0x1023)
+#define P_AED_EQ_CH1_COEF70                        (volatile unsigned int *)((0x1023  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF71                        (0x1024)
+#define P_AED_EQ_CH1_COEF71                        (volatile unsigned int *)((0x1024  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF72                        (0x1025)
+#define P_AED_EQ_CH1_COEF72                        (volatile unsigned int *)((0x1025  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF73                        (0x1026)
+#define P_AED_EQ_CH1_COEF73                        (volatile unsigned int *)((0x1026  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF74                        (0x1027)
+#define P_AED_EQ_CH1_COEF74                        (volatile unsigned int *)((0x1027  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF80                        (0x1028)
+#define P_AED_EQ_CH1_COEF80                        (volatile unsigned int *)((0x1028  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF81                        (0x1029)
+#define P_AED_EQ_CH1_COEF81                        (volatile unsigned int *)((0x1029  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF82                        (0x102a)
+#define P_AED_EQ_CH1_COEF82                        (volatile unsigned int *)((0x102a  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF83                        (0x102b)
+#define P_AED_EQ_CH1_COEF83                        (volatile unsigned int *)((0x102b  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF84                        (0x102c)
+#define P_AED_EQ_CH1_COEF84                        (volatile unsigned int *)((0x102c  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF90                        (0x102d)
+#define P_AED_EQ_CH1_COEF90                        (volatile unsigned int *)((0x102d  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF91                        (0x102e)
+#define P_AED_EQ_CH1_COEF91                        (volatile unsigned int *)((0x102e  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF92                        (0x102f)
+#define P_AED_EQ_CH1_COEF92                        (volatile unsigned int *)((0x102f  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF93                        (0x1030)
+#define P_AED_EQ_CH1_COEF93                        (volatile unsigned int *)((0x1030  << 2) + 0xffd00000)
+#define   AED_EQ_CH1_COEF94                        (0x1031)
+#define P_AED_EQ_CH1_COEF94                        (volatile unsigned int *)((0x1031  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF00                        (0x1032)
+#define P_AED_EQ_CH2_COEF00                        (volatile unsigned int *)((0x1032  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF01                        (0x1033)
+#define P_AED_EQ_CH2_COEF01                        (volatile unsigned int *)((0x1033  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF02                        (0x1034)
+#define P_AED_EQ_CH2_COEF02                        (volatile unsigned int *)((0x1034  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF03                        (0x1035)
+#define P_AED_EQ_CH2_COEF03                        (volatile unsigned int *)((0x1035  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF04                        (0x1036)
+#define P_AED_EQ_CH2_COEF04                        (volatile unsigned int *)((0x1036  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF10                        (0x1037)
+#define P_AED_EQ_CH2_COEF10                        (volatile unsigned int *)((0x1037  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF11                        (0x1038)
+#define P_AED_EQ_CH2_COEF11                        (volatile unsigned int *)((0x1038  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF12                        (0x1039)
+#define P_AED_EQ_CH2_COEF12                        (volatile unsigned int *)((0x1039  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF13                        (0x103a)
+#define P_AED_EQ_CH2_COEF13                        (volatile unsigned int *)((0x103a  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF14                        (0x103b)
+#define P_AED_EQ_CH2_COEF14                        (volatile unsigned int *)((0x103b  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF20                        (0x103c)
+#define P_AED_EQ_CH2_COEF20                        (volatile unsigned int *)((0x103c  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF21                        (0x103d)
+#define P_AED_EQ_CH2_COEF21                        (volatile unsigned int *)((0x103d  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF22                        (0x103e)
+#define P_AED_EQ_CH2_COEF22                        (volatile unsigned int *)((0x103e  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF23                        (0x103f)
+#define P_AED_EQ_CH2_COEF23                        (volatile unsigned int *)((0x103f  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF24                        (0x1040)
+#define P_AED_EQ_CH2_COEF24                        (volatile unsigned int *)((0x1040  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF30                        (0x1041)
+#define P_AED_EQ_CH2_COEF30                        (volatile unsigned int *)((0x1041  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF31                        (0x1042)
+#define P_AED_EQ_CH2_COEF31                        (volatile unsigned int *)((0x1042  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF32                        (0x1043)
+#define P_AED_EQ_CH2_COEF32                        (volatile unsigned int *)((0x1043  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF33                        (0x1044)
+#define P_AED_EQ_CH2_COEF33                        (volatile unsigned int *)((0x1044  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF34                        (0x1045)
+#define P_AED_EQ_CH2_COEF34                        (volatile unsigned int *)((0x1045  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF40                        (0x1046)
+#define P_AED_EQ_CH2_COEF40                        (volatile unsigned int *)((0x1046  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF41                        (0x1047)
+#define P_AED_EQ_CH2_COEF41                        (volatile unsigned int *)((0x1047  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF42                        (0x1048)
+#define P_AED_EQ_CH2_COEF42                        (volatile unsigned int *)((0x1048  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF43                        (0x1049)
+#define P_AED_EQ_CH2_COEF43                        (volatile unsigned int *)((0x1049  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF44                        (0x104a)
+#define P_AED_EQ_CH2_COEF44                        (volatile unsigned int *)((0x104a  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF50                        (0x104b)
+#define P_AED_EQ_CH2_COEF50                        (volatile unsigned int *)((0x104b  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF51                        (0x104c)
+#define P_AED_EQ_CH2_COEF51                        (volatile unsigned int *)((0x104c  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF52                        (0x104d)
+#define P_AED_EQ_CH2_COEF52                        (volatile unsigned int *)((0x104d  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF53                        (0x104e)
+#define P_AED_EQ_CH2_COEF53                        (volatile unsigned int *)((0x104e  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF54                        (0x104f)
+#define P_AED_EQ_CH2_COEF54                        (volatile unsigned int *)((0x104f  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF60                        (0x1050)
+#define P_AED_EQ_CH2_COEF60                        (volatile unsigned int *)((0x1050  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF61                        (0x1051)
+#define P_AED_EQ_CH2_COEF61                        (volatile unsigned int *)((0x1051  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF62                        (0x1052)
+#define P_AED_EQ_CH2_COEF62                        (volatile unsigned int *)((0x1052  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF63                        (0x1053)
+#define P_AED_EQ_CH2_COEF63                        (volatile unsigned int *)((0x1053  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF64                        (0x1054)
+#define P_AED_EQ_CH2_COEF64                        (volatile unsigned int *)((0x1054  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF70                        (0x1055)
+#define P_AED_EQ_CH2_COEF70                        (volatile unsigned int *)((0x1055  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF71                        (0x1056)
+#define P_AED_EQ_CH2_COEF71                        (volatile unsigned int *)((0x1056  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF72                        (0x1057)
+#define P_AED_EQ_CH2_COEF72                        (volatile unsigned int *)((0x1057  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF73                        (0x1058)
+#define P_AED_EQ_CH2_COEF73                        (volatile unsigned int *)((0x1058  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF74                        (0x1059)
+#define P_AED_EQ_CH2_COEF74                        (volatile unsigned int *)((0x1059  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF80                        (0x105a)
+#define P_AED_EQ_CH2_COEF80                        (volatile unsigned int *)((0x105a  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF81                        (0x105b)
+#define P_AED_EQ_CH2_COEF81                        (volatile unsigned int *)((0x105b  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF82                        (0x105c)
+#define P_AED_EQ_CH2_COEF82                        (volatile unsigned int *)((0x105c  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF83                        (0x105d)
+#define P_AED_EQ_CH2_COEF83                        (volatile unsigned int *)((0x105d  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF84                        (0x105e)
+#define P_AED_EQ_CH2_COEF84                        (volatile unsigned int *)((0x105e  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF90                        (0x105f)
+#define P_AED_EQ_CH2_COEF90                        (volatile unsigned int *)((0x105f  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF91                        (0x1060)
+#define P_AED_EQ_CH2_COEF91                        (volatile unsigned int *)((0x1060  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF92                        (0x1061)
+#define P_AED_EQ_CH2_COEF92                        (volatile unsigned int *)((0x1061  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF93                        (0x1062)
+#define P_AED_EQ_CH2_COEF93                        (volatile unsigned int *)((0x1062  << 2) + 0xffd00000)
+#define   AED_EQ_CH2_COEF94                        (0x1063)
+#define P_AED_EQ_CH2_COEF94                        (volatile unsigned int *)((0x1063  << 2) + 0xffd00000)
+#define   AED_EQ_EN                                (0x1064)
+#define P_AED_EQ_EN                                (volatile unsigned int *)((0x1064  << 2) + 0xffd00000)
+#define   AED_EQ_VOLUME                            (0x1065)
+#define P_AED_EQ_VOLUME                            (volatile unsigned int *)((0x1065  << 2) + 0xffd00000)
+#define   AED_EQ_VOLUME_SLEW_CNT                   (0x1066)
+#define P_AED_EQ_VOLUME_SLEW_CNT                   (volatile unsigned int *)((0x1066  << 2) + 0xffd00000)
+#define   AED_MUTE                                 (0x1067)
+#define P_AED_MUTE                                 (volatile unsigned int *)((0x1067  << 2) + 0xffd00000)
+#define   AED_DRC_EN                               (0x1070)
+#define P_AED_DRC_EN                               (volatile unsigned int *)((0x1070  << 2) + 0xffd00000)
+#define   AED_DRC_AE                               (0x1071)
+#define P_AED_DRC_AE                               (volatile unsigned int *)((0x1071  << 2) + 0xffd00000)
+#define   AED_DRC_AA                               (0x1072)
+#define P_AED_DRC_AA                               (volatile unsigned int *)((0x1072  << 2) + 0xffd00000)
+#define   AED_DRC_AD                               (0x1073)
+#define P_AED_DRC_AD                               (volatile unsigned int *)((0x1073  << 2) + 0xffd00000)
+#define   AED_DRC_AE_1M                            (0x1074)
+#define P_AED_DRC_AE_1M                            (volatile unsigned int *)((0x1074  << 2) + 0xffd00000)
+#define   AED_DRC_AA_1M                            (0x1075)
+#define P_AED_DRC_AA_1M                            (volatile unsigned int *)((0x1075  << 2) + 0xffd00000)
+#define   AED_DRC_AD_1M                            (0x1076)
+#define P_AED_DRC_AD_1M                            (volatile unsigned int *)((0x1076  << 2) + 0xffd00000)
+#define   AED_DRC_OFFSET0                          (0x1077)
+#define P_AED_DRC_OFFSET0                          (volatile unsigned int *)((0x1077  << 2) + 0xffd00000)
+#define   AED_DRC_OFFSET1                          (0x1078)
+#define P_AED_DRC_OFFSET1                          (volatile unsigned int *)((0x1078  << 2) + 0xffd00000)
+#define   AED_DRC_THD0                             (0x1079)
+#define P_AED_DRC_THD0                             (volatile unsigned int *)((0x1079  << 2) + 0xffd00000)
+#define   AED_DRC_THD1                             (0x107a)
+#define P_AED_DRC_THD1                             (volatile unsigned int *)((0x107a  << 2) + 0xffd00000)
+#define   AED_DRC_K0                               (0x107b)
+#define P_AED_DRC_K0                               (volatile unsigned int *)((0x107b  << 2) + 0xffd00000)
+#define   AED_DRC_K1                               (0x107c)
+#define P_AED_DRC_K1                               (volatile unsigned int *)((0x107c  << 2) + 0xffd00000)
+#define   AED_CLIP_THD                             (0x107d)
+#define P_AED_CLIP_THD                             (volatile unsigned int *)((0x107d  << 2) + 0xffd00000)
+#define   AED_NG_THD0                              (0x107e)
+#define P_AED_NG_THD0                              (volatile unsigned int *)((0x107e  << 2) + 0xffd00000)
+#define   AED_NG_THD1                              (0x107f)
+#define P_AED_NG_THD1                              (volatile unsigned int *)((0x107f  << 2) + 0xffd00000)
+#define   AED_NG_CNT_THD                           (0x1080)
+#define P_AED_NG_CNT_THD                           (volatile unsigned int *)((0x1080  << 2) + 0xffd00000)
+#define   AED_NG_CTL                               (0x1081)
+#define P_AED_NG_CTL                               (volatile unsigned int *)((0x1081  << 2) + 0xffd00000)
+#define   AED_ED_CTL                               (0x1082)
+#define P_AED_ED_CTL                               (volatile unsigned int *)((0x1082  << 2) + 0xffd00000)
+#define   AED_DEBUG0                               (0x1083)
+#define P_AED_DEBUG0                               (volatile unsigned int *)((0x1083  << 2) + 0xffd00000)
+#define   AED_DEBUG1                               (0x1084)
+#define P_AED_DEBUG1                               (volatile unsigned int *)((0x1084  << 2) + 0xffd00000)
+#define   AED_DEBUG2                               (0x1085)
+#define P_AED_DEBUG2                               (volatile unsigned int *)((0x1085  << 2) + 0xffd00000)
+#define   AED_DEBUG3                               (0x1086)
+#define P_AED_DEBUG3                               (volatile unsigned int *)((0x1086  << 2) + 0xffd00000)
+#define   AED_DEBUG4                               (0x1087)
+#define P_AED_DEBUG4                               (volatile unsigned int *)((0x1087  << 2) + 0xffd00000)
+#define   AED_DEBUG5                               (0x1088)
+#define P_AED_DEBUG5                               (volatile unsigned int *)((0x1088  << 2) + 0xffd00000)
+#define   AED_DEBUG6                               (0x1089)
+#define P_AED_DEBUG6                               (volatile unsigned int *)((0x1089  << 2) + 0xffd00000)
+#define   AED_TOP_CTL                              (0x1090)
+#define P_AED_TOP_CTL                              (volatile unsigned int *)((0x1090  << 2) + 0xffd00000)
+#endif
+
+//
+// Closing file:  audio_eq_drc.h
+//
+//========================================================================
+//  Audio Interface				    (12'h500 - 12'h5ff)
+//
+//========================================================================
+//
+// Reading file:  aregs.h
+//
+//========================================================================
+//  Audio Interface                                 (8'h00 - 8'hff)
+//  Modified : Xuyun Chen Jan 2001
+//========================================================================
+// Number of bytes expected per NON-PCM frame, including the header.
+// 16 bits.
+// -----------------------------------------------
+// CBUS_BASE:  AIU_CBUS_BASE = 0x14
+// -----------------------------------------------
+#define   AIU_958_BPF                              (0x1400)
+#define P_AIU_958_BPF                              (volatile unsigned int *)((0x1400  << 2) + 0xffd00000)
+// Value of burst_info used in IEC958 preamble for a NON-PCM frame. See
+// ATSC AC-3 spec Annex B. 16 bits.
+#define   AIU_958_BRST                             (0x1401)
+#define P_AIU_958_BRST                             (volatile unsigned int *)((0x1401  << 2) + 0xffd00000)
+// Value of length_code used in IEC958 preamble for an NON-PCM frame. See
+// ATSC AC-3 spec Annex B. 16 bits.
+#define   AIU_958_LENGTH                           (0x1402)
+#define P_AIU_958_LENGTH                           (volatile unsigned int *)((0x1402  << 2) + 0xffd00000)
+// How many subframes to padd around the NON-PCM frame. This will
+// be set to 'd3072 if it is a AC-3 audio stream.
+// 16 bits
+#define   AIU_958_PADDSIZE                         (0x1403)
+#define P_AIU_958_PADDSIZE                         (volatile unsigned int *)((0x1403  << 2) + 0xffd00000)
+// 16'd3072
+// Misc. control settings for IEC958 interface
+// Bit 15:14 pcm_sample_ctl, 00-pcm_no_sample, 01-pcm_sample_up, 10-pcm_sample_down, 11-pcm_sample_down_drop
+// Bit 13: if true, force each audio data to left or right according to the bit attached with the audio data
+//         This bit should be used with Register AIU_958_force_left(0x505) together
+// Bit 12: if true, the U(user data) is from the stream otherwise it is filled by
+//                   zero while encoding iec958 frame
+// Bit 11   : if true big endian(highword,lowword) otherwise little endian(lowword,highword)
+//            for 32bit mode
+// Bit 10:8 : shift number for 32 bit mode
+// Bit 7  : 32 bit mode turn on while This bit is true and Bit 1 is true
+// Bit 6:5 : Specifies output alignment for 16 bit pcm data.
+//          00 : dout = {8'b0, din};
+//          01 : dout = {4'b0, din, 4'b0};
+//          10 : dout = {      din, 8'b0};
+// Bit 4  : True if data should be sent out MSB first. LSB first is the
+//          default in the spec.
+// Bit 3  : True if msb should be extended (only used with 16 bit pcm data.)
+// Bit 2  : True if msb of PCM data should be inverted.
+// Bit 1  : True if PCM data is 16 bits wide. False if 24 bit or 32bit mode.
+// Bit 0  : True if source data is non-PCM data. False if it is PCM data.
+#define   AIU_958_MISC                             (0x1404)
+#define P_AIU_958_MISC                             (volatile unsigned int *)((0x1404  << 2) + 0xffd00000)
+// 14'b0_0_0_000_0_0000001
+// A write to this register specifies that the next pcm sample sent out
+// of the iec958 interface should go into the _left_ channel.
+#define   AIU_958_FORCE_LEFT                       (0x1405)
+#define P_AIU_958_FORCE_LEFT                       (volatile unsigned int *)((0x1405  << 2) + 0xffd00000)
+//Read Only
+//bit 6:0  how many data discarded in the last dma after one frame data finish transfering to AIU
+// should used together with register AIU_958_dcu_ff_ctrl
+#define   AIU_958_DISCARD_NUM                      (0x1406)
+#define P_AIU_958_DISCARD_NUM                      (volatile unsigned int *)((0x1406  << 2) + 0xffd00000)
+//bit 15:8  : A read from this register indicates the IEC958 FIFO count value
+//bit 7 :  ai_958_req_size if ture, set to 8 bits interface, used to handle odd frame continous read
+//bit 6 :  continue seeking and dont discard the rest data in one dma after frame end
+//bit 5 :  if true, byte by byte seeking, otherwise word by word seeking
+//bit 4 :  if true, the function for sync head seeking is enabled
+//bit 3:2 :	IEC958 interrupt mode
+// There are two conditions to generate interrupt. The First condition is that one frame data
+// have been finished writing into FIFO. The second condition is at least some data of the current
+// frame have been read out(refer to Register AIU_958_ffrdout_thd)
+//			00: interrupt is not generated
+//			10:	interrupt is generated if the first condition is true
+//			01:	interrupt is generated if the second condition is true
+//			11:	interrupt is generated if both of the conditions are true
+//bit 1: fifo auto disable, High means after one frame data put into the FIFO, the FIFO
+//					will automatically disabled
+//bit 0: fifo enable
+#define   AIU_958_DCU_FF_CTRL                      (0x1407)
+#define P_AIU_958_DCU_FF_CTRL                      (volatile unsigned int *)((0x1407  << 2) + 0xffd00000)
+// 'b0_0_1_11_1_0
+// channel status registers for Left channel
+// chstat_l0[15:0] contains bits 15:0 of the channel status word. Note
+// that bit zero of the channel status word is sent out first.
+// chstat_l1[15:0] contains bits 31:16 of the channel status word.
+#define   AIU_958_CHSTAT_L0                        (0x1408)
+#define P_AIU_958_CHSTAT_L0                        (volatile unsigned int *)((0x1408  << 2) + 0xffd00000)
+#define   AIU_958_CHSTAT_L1                        (0x1409)
+#define P_AIU_958_CHSTAT_L1                        (volatile unsigned int *)((0x1409  << 2) + 0xffd00000)
+// Control register for IEC958 interface
+// Bit 9:8 what to do if there is a fifo underrun
+//         00 => insert 24'h000000
+//         01 => insert mute constant as defined below
+//         10 => repeat last l/r samples
+// Bit 7:5 mute constant
+//         000 => 24'h000000
+//         001 => 24'h800000
+//         010 => 24'h080000
+//         011 => 24'h008000
+//         100 => 24'h000001
+//         101 => 24'h000010
+//         110 => 24'h000100
+// Bit 4   mute left speaker
+// Bit 3   mute right speaker
+// Bit 2:1 swap channels
+//         00 : L R => L R
+//         01 : L R => L L
+//         10 : L R => R R
+//         11 : L R => R L
+// Bit 0   Set this bit to hold iec958 interface after the current
+//         subframe has been completely transmitted.
+#define   AIU_958_CTRL                             (0x140a)
+#define P_AIU_958_CTRL                             (volatile unsigned int *)((0x140a  << 2) + 0xffd00000)
+// 10'b00_000_00_00_0
+// A write operation to this register will cause one of the output samples
+// to be repeated. This can be used to switch the left and the right
+// channels.
+#define   AIU_958_RPT                              (0x140b)
+#define P_AIU_958_RPT                              (volatile unsigned int *)((0x140b  << 2) + 0xffd00000)
+// Channel swap and mute control register.
+// Bit 15: Mute extra left channel
+// Bit 14: Mute extra right channel
+// Bit 13: Mute center
+// Bit 12: Mute subwoofer
+// Bit 11: Mute surround left
+// Bit 10: Mute surround right
+// Bit  9: Mute left
+// Bit  8: Mute right
+// Bit 7:6 Channel swap for xtra dac
+// Bit 5:4 Channel swap for sub/center dac
+// Bit 3:2 Channel swap for surround dac
+// Bit 1:0 Channel swap for main l/r dac
+// Channel swap possibilities:
+// 00 : L R => L R
+// 01 : L R => L L
+// 10 : L R => R R
+// 11 : L R => R L
+#define   AIU_I2S_MUTE_SWAP                        (0x140c)
+#define P_AIU_I2S_MUTE_SWAP                        (volatile unsigned int *)((0x140c  << 2) + 0xffd00000)
+// 16'b0
+// Bit 0 : 0=> single two channel stream
+//         1=> four two channel streams
+#define   AIU_I2S_SOURCE_DESC                      (0x140d)
+#define P_AIU_I2S_SOURCE_DESC                      (volatile unsigned int *)((0x140d  << 2) + 0xffd00000)
+// Median filter control register
+// Bit 1:  0=> data is offset binary
+//         1=> data is signed
+// Bit 0:  enable median filter
+#define   AIU_I2S_MED_CTRL                         (0x140e)
+#define P_AIU_I2S_MED_CTRL                         (volatile unsigned int *)((0x140e  << 2) + 0xffd00000)
+// 2'b10
+// Median filter threshold constant
+// 16 bits
+#define   AIU_I2S_MED_THRESH                       (0x140f)
+#define P_AIU_I2S_MED_THRESH                       (volatile unsigned int *)((0x140f  << 2) + 0xffd00000)
+// 16'h8000
+// Describes dac's connected to I2S interface
+// Bit 7:  sign extend sample before downshift.
+// Bit 6:4 payload downshift constant
+// Bit 3:  mute constant
+//         0 => 'h0000000
+//         1 => 'h800000
+// Bit 2:  send msb first
+// Bit 1:0 Size of payload
+//         Note that this parameter used to be called "size of dacs"
+//         It is now called the payload size since a 24 bit payload can
+//         actually be connected to any size of dac. The dac will simply
+//         disregard the extra bits.
+//         00 => 16 bit, alrclk = aoclk/32
+//         01 => 20 bit, alrclk = aoclk/40
+//         10 => 24 bit, alrclk = aoclk/48
+//		   11 => 24 bit, but alrclk = aoclk/64
+#define   AIU_I2S_DAC_CFG                          (0x1410)
+#define P_AIU_I2S_DAC_CFG                          (volatile unsigned int *)((0x1410  << 2) + 0xffd00000)
+// 8'b0_000_1_1_10
+// A write to this register will cause the interface to repeat the current
+// sample. Can be used to regain synchronization.
+// A read from this register indicates that the next sample to be sent
+// out of the interface should go into the _left_ channel of the dac.
+#define   AIU_I2S_SYNC                             (0x1411)
+#define P_AIU_I2S_SYNC                             (volatile unsigned int *)((0x1411  << 2) + 0xffd00000)
+// Misc regs
+// Bit 4 if true, force each audio data to left or right according to the bit attached with the audio data
+//         This bit should be used with Register AIU_i2s_sync(0x511) together
+// Bit 3:  Same Audio source for IEC958 and I2s stream 0, both from i2s buffer
+// Bit 2:  Set this bit to put i2s interface in hold mode
+// Bit 1:0 How to handle underruns
+//         00 => send zeros
+//         01 => send 'h800000
+//         10 => repeat last samples
+#define   AIU_I2S_MISC                             (0x1412)
+#define P_AIU_I2S_MISC                             (volatile unsigned int *)((0x1412  << 2) + 0xffd00000)
+// 5'b0
+// Bit 7:0 Audio output config.
+//			2 bits for each dac, 7:6 for dac3, 5:4 for dac2,
+//								 3:2 for dac1, 1:0 for dac0
+//			For each 2bits: 00: connect channel0-1 to the dac
+//							01: connect channel2-3 to the dac
+//							10: connect channel4-5 to the dac
+//							11: connect channel6-7 to the dac
+#define   AIU_I2S_OUT_CFG                          (0x1413)
+#define P_AIU_I2S_OUT_CFG                          (volatile unsigned int *)((0x1413  << 2) + 0xffd00000)
+// 8'b0_000000_0
+#define   AIU_I2S_FF_CTRL                          (0x1414)
+#define P_AIU_I2S_FF_CTRL                          (volatile unsigned int *)((0x1414  << 2) + 0xffd00000)
+// A write to this register resets the AIU
+//Bit 3 reset slow domain iec958
+//Bit 2 soft reset iec958 fast domain
+//Bit 1 reset slow domain i2s
+//Bit 0 soft reset i2s fast domain
+#define   AIU_RST_SOFT                             (0x1415)
+#define P_AIU_RST_SOFT                             (volatile unsigned int *)((0x1415  << 2) + 0xffd00000)
+// Clock generation control register
+// Bit 15: enable_ddr_arb, set low to reset
+// Bit 14:13 parser_A_addr_sel  00-A_addr_aififo2, 01-A_addr_iec958, 10-A_addr_aififo, 11-A_addr_i2s
+// Bit 12: 958 divisor more, if true, divided by 2, 4, 6, 8
+// Bit 11: amclk output divisor
+//			0 => dont divide
+//			1 => divide by 2
+// Bit 10: clock source selection
+//        0 => aiclk from pin
+//        1 => ai_pll_clk from pll
+// Bit 9:8 alrclk skew
+//         00 => alrclk transitions at the same time msb is sent
+//         01 => alrclk transitions on the cycle before msb is sent
+//         10 => alrclk transitions on the cycle after msb is sent
+// Bit 7: invert alrclk
+// Bit 6: invert aoclk
+// Bit 5:4 958 divisor
+//        00 => divide by 1
+//        01 => divide by 2
+//		  10 => divide by 3
+//		  11 => divide by 4
+// Bit 3:2 i2s divisor. NOTE: this value is ignored if AIU_clk_ctrl_more[5:0] != 0
+//         00 => divide by 1
+//         01 => divide by 2
+//         10 => divide by 4
+//         11 => divide by 8
+// Bit 1: enable 958 divider
+// Bit 0: enable i2s divider
+#define   AIU_CLK_CTRL                             (0x1416)
+#define P_AIU_CLK_CTRL                             (volatile unsigned int *)((0x1416  << 2) + 0xffd00000)
+// 13'b0_0_1_01_1_1_10_11_0_0
+// Misc settings that determine the type of adc that is
+// connected to the AIU. Reverb mode is deleted.
+// Bit 12:  selects adc input
+// Bit 11:10 adc size
+//           00 => 16 bits
+//           01 => 18 bits
+//           10 => 20 bits
+//           11 => 24 bits
+// Bit 9:8   adc l/r swap mode
+//           00 => stereo
+//           01 => send the right adc input to both l and r speakers
+//           01 => send the left adc input to both l and r speakers
+//           11 => sum the left and right inputs and forward to
+//                both speakers
+// Bit 7:5 adata/lrclk skew mode
+// Bit 4   1=>invert the adc's lrclk (This is the lrclk going _out_
+//         of the chip.
+// Bit 3   1=>Latch the data on the positive edge of the _internal_
+//         aoclk.
+// Bit 2   1=>adc data is in signed 2's complement mode
+#define   AIU_MIX_ADCCFG                           (0x1417)
+#define P_AIU_MIX_ADCCFG                           (volatile unsigned int *)((0x1417  << 2) + 0xffd00000)
+// 12'b01_00_001_1_0_1_00
+// Control register that can be changed dynamically. These control
+// signals are synchronized internally.
+// Bit 12:  if true, toggle each mixed audio data to left or right channel
+// Bit 11:  abuf din left selection, if true, select bit 24 of the data from abuf
+//		    otherwise select bit 25 of the data from abuf
+// Bit 10:9  mix sync select, when music, mic and abuf are mixed togather, the main
+//			 sync source can be selected
+//     00: not sync source
+//	   01: music data is the main sync source
+//	   10: abuf input data is the main sync source
+//	   11: music and abuf togather as the sync source
+// Bit 8:  0=> data from abuf is offset binary
+//         1=> data from abuf is signed
+// Bit 7:6 the source for data from aiu to abuf
+//           00 => mic
+//           01 => mic saled + abuf scaled
+//           10 => mic scaled + abuf scaled + music scaled
+//			 11 => music
+// Bit 5   channel from aiu to abuf is on
+// Bit 4   channel from abuf to aiu is on
+// Bit 3   mic is on
+// Bit 2   music is on
+// Bit 1   if true the mixed data are outputed to i2s dac channel,
+//			otherwise the mixed data are outputed to IEC958 output
+// Bit 0   if true music source for mixing is from i2s buffer,
+//			otherwise music source is from iec958 buffer
+#define   AIU_MIX_CTRL                             (0x1418)
+#define P_AIU_MIX_CTRL                             (volatile unsigned int *)((0x1418  << 2) + 0xffd00000)
+// 11'b01_1_01_0_0_0_1_1_1
+// Bit    15 invert_audin_sclk.
+// Bit    14 enable_adc_sclk.
+// Bit 13: 8 divisor_adc_sclk.
+// Bit     7 invert_acodec_adc_sclk.
+// Bit     6 hdmitx_sel_aoclkx2: 0=Select cts_clk_i958 as AIU clk to hdmi_tx_audio_master_clk; 1=Select cts_aoclkx2_int as AIU clk to hdmi_tx_audio_master_clk;
+// Bit  5: 0 More control on i2s divisor. For backward compatiblity, this value is ignored if is 0,
+//           if non-zero, it takes effect over AIU_clk_ctrl[3:2].
+//           0=i2s divisor will use the old value in AIU_clk_ctrl[3:2] (divide by 1/2/4/8)
+//           1=divide by 2;
+//           2=divide by 3;
+//           3=divide by 4;
+//           ... and so on ...
+//           63=divide by 64.
+#define   AIU_CLK_CTRL_MORE                        (0x1419)
+#define P_AIU_CLK_CTRL_MORE                        (volatile unsigned int *)((0x1419  << 2) + 0xffd00000)
+// A read from this register pops 16 bits of data off the 958
+// fifo. A write has no effect.
+#define   AIU_958_POP                              (0x141a)
+#define P_AIU_958_POP                              (volatile unsigned int *)((0x141a  << 2) + 0xffd00000)
+//gain register for mixing
+// for each gain,
+//			 00000: x 0
+//			 00001: x 1
+//			 00010: x 2
+//           00011: x 3
+//			 00100: x 4
+//			 00101: x 5
+//			 00110: x 6
+//			......
+//           01110: x14
+//           01111: x15
+//           10000: x 0
+//           10001: x 1/16
+//           10010: x 2/16
+//           10011: x 3/16
+//           10100: x 4/16
+//			......
+//           11110: x 14/16
+//           11111: x 15/16
+//Bit 14:10 mic gain
+//Bit 9:5 	abuf gain
+//Bit 4:0 music gain
+#define   AIU_MIX_GAIN                             (0x141b)
+#define P_AIU_MIX_GAIN                             (volatile unsigned int *)((0x141b  << 2) + 0xffd00000)
+// 15'b00001_00001_00001
+//sync head seeking is supported. The  maxinium length of sync head is
+//48-bit-wide.(in byte by byte seeking mode, the maximium is 44-bit-wide).
+//It is consisted of 3 words (synword1_synword2_syncword3).
+//You can configure the sync head pattern by using sync mask(mask1_mask2_mask3).
+//For example. AC-3 sync head is a 16-bit word(0b77), so syncword1 is set as 0b77,
+//mask1 is 0000(not set), mask2 and mask3 is all masked.
+#define   AIU_958_SYNWORD1                         (0x141c)
+#define P_AIU_958_SYNWORD1                         (volatile unsigned int *)((0x141c  << 2) + 0xffd00000)
+//16'h0b77  //ac-3 sync head
+#define   AIU_958_SYNWORD2                         (0x141d)
+#define P_AIU_958_SYNWORD2                         (volatile unsigned int *)((0x141d  << 2) + 0xffd00000)
+//16'h0000
+#define   AIU_958_SYNWORD3                         (0x141e)
+#define P_AIU_958_SYNWORD3                         (volatile unsigned int *)((0x141e  << 2) + 0xffd00000)
+//16'h0000
+#define   AIU_958_SYNWORD1_MASK                    (0x141f)
+#define P_AIU_958_SYNWORD1_MASK                    (volatile unsigned int *)((0x141f  << 2) + 0xffd00000)
+//16'h0000 //16-bit ac-3 sync_head
+#define   AIU_958_SYNWORD2_MASK                    (0x1420)
+#define P_AIU_958_SYNWORD2_MASK                    (volatile unsigned int *)((0x1420  << 2) + 0xffd00000)
+//16'hffff
+#define   AIU_958_SYNWORD3_MASK                    (0x1421)
+#define P_AIU_958_SYNWORD3_MASK                    (volatile unsigned int *)((0x1421  << 2) + 0xffd00000)
+//16'hffff
+//fifo read-out threshold, one condition to generate interrupt is met after fifo readout counter
+//reach this value in a frame, please refer to register AIU_958_dcu_ff_ctrl
+#define   AIU_958_FFRDOUT_THD                      (0x1422)
+#define P_AIU_958_FFRDOUT_THD                      (volatile unsigned int *)((0x1422  << 2) + 0xffd00000)
+//'h0004
+//For pause burst sequence adding, one pause burst sequence is consist of a serious
+// pause burst.
+//This register defines the length of each pause burst in a pause burst sequence. The size of the
+//preamble(Pa, Pb, Pc, Pd) is not counted, but the size of stuff data is counted.
+#define   AIU_958_LENGTH_PER_PAUSE                 (0x1423)
+#define P_AIU_958_LENGTH_PER_PAUSE                 (volatile unsigned int *)((0x1423  << 2) + 0xffd00000)
+//'h0000
+//This reigster defines the number of pause burst in a pause burst sequence.
+//Bit 15  if true, one pause burst sequence will be added
+//Bit 14:0 the number of pause burst in a pause burst sequence
+#define   AIU_958_PAUSE_NUM                        (0x1424)
+#define P_AIU_958_PAUSE_NUM                        (volatile unsigned int *)((0x1424  << 2) + 0xffd00000)
+//'h0000
+//The first 16-bit in the payload of pause burst sequence (gap_length)
+#define   AIU_958_PAUSE_PAYLOAD                    (0x1425)
+#define P_AIU_958_PAUSE_PAYLOAD                    (volatile unsigned int *)((0x1425  << 2) + 0xffd00000)
+//'h0000
+//For auto pause function, when enabled, pause burst sequence will be automatically added if the data in
+// 958 fifo is less than auto_pause threshold and if fifo is disabled.
+//Bit 15   if true, auto pause function enable
+//Bit 14   pause pack option, just for debugging and adding one option
+//Bit 7:0  auto_pause threshold
+#define   AIU_958_AUTO_PAUSE                       (0x1426)
+#define P_AIU_958_AUTO_PAUSE                       (volatile unsigned int *)((0x1426  << 2) + 0xffd00000)
+//'h0000
+//pause burst sequence payload length( = AIU_958_pause_num * AIU_958_length_per_pause)
+#define   AIU_958_PAUSE_PD_LENGTH                  (0x1427)
+#define P_AIU_958_PAUSE_PD_LENGTH                  (volatile unsigned int *)((0x1427  << 2) + 0xffd00000)
+//'h0000
+// Bit 15:12 Rsrv.
+// Bit 11: 0 dac_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
+#define   AIU_CODEC_DAC_LRCLK_CTRL                 (0x1428)
+#define P_AIU_CODEC_DAC_LRCLK_CTRL                 (volatile unsigned int *)((0x1428  << 2) + 0xffd00000)
+//'h002f
+// Bit 15:14 Rsrv.
+// Bit    13 inv_audin_lrclk: whether to invert lrclk before output to Audin
+// Bit    12 inv_acodec_adc_lrclk: whether to invert lrclk before output to Audio Codec
+// Bit 11: 0 adc_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
+#define   AIU_CODEC_ADC_LRCLK_CTRL                 (0x1429)
+#define P_AIU_CODEC_ADC_LRCLK_CTRL                 (volatile unsigned int *)((0x1429  << 2) + 0xffd00000)
+//'h002f
+// Bit 15:6 Rsrv.
+// Bit  5: 4 hdmi_data_sel: 00=output 0, disable hdmi data; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+// Bit  3: 2 Rsrv.
+// Bit  1: 0 hdmi_clk_sel: 00=Disable output hdmi clock; 01=Select pcm clock; 10=Select AIU clk; 11=Not allowed.
+#define   AIU_HDMI_CLK_DATA_CTRL                   (0x142a)
+#define P_AIU_HDMI_CLK_DATA_CTRL                   (volatile unsigned int *)((0x142a  << 2) + 0xffd00000)
+//'h0000
+// Bit 15:6 Rsrv.
+// Bit  5: 4 acodec_data_sel: 00=output 0, disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+// Bit  3: 2 Rsrv.
+// Bit  1: 0 acodec_clk_sel: 00=Disable output acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+#define   AIU_CODEC_CLK_DATA_CTRL                  (0x142b)
+#define P_AIU_CODEC_CLK_DATA_CTRL                  (volatile unsigned int *)((0x142b  << 2) + 0xffd00000)
+//'h0000
+#define   AIU_ACODEC_CTRL                          (0x142c)
+#define P_AIU_ACODEC_CTRL                          (volatile unsigned int *)((0x142c  << 2) + 0xffd00000)
+// channel status registers for right channel
+// chstat_r0[15:0] contains bits 15:0 of the channel status word. Note
+// that bit zero of the channel status word is sent out first.
+// chstat_r1[15:0] contains bits 31:16 of the channel status word.
+#define   AIU_958_CHSTAT_R0                        (0x1430)
+#define P_AIU_958_CHSTAT_R0                        (volatile unsigned int *)((0x1430  << 2) + 0xffd00000)
+#define   AIU_958_CHSTAT_R1                        (0x1431)
+#define P_AIU_958_CHSTAT_R1                        (volatile unsigned int *)((0x1431  << 2) + 0xffd00000)
+//Bit 1 	if true, turn on Digital output Valid control
+//Bit 0		0: output 0, 1: output 1 to the valid bit in audio digital output when Bit 1 is true
+#define   AIU_958_VALID_CTRL                       (0x1432)
+#define P_AIU_958_VALID_CTRL                       (volatile unsigned int *)((0x1432  << 2) + 0xffd00000)
+//-----------------------------------------------------------------------------
+// Audio Amplifier controls
+//-----------------------------------------------------------------------------
+#define   AIU_AUDIO_AMP_REG0                       (0x143c)
+#define P_AIU_AUDIO_AMP_REG0                       (volatile unsigned int *)((0x143c  << 2) + 0xffd00000)
+#define   AIU_AUDIO_AMP_REG1                       (0x143d)
+#define P_AIU_AUDIO_AMP_REG1                       (volatile unsigned int *)((0x143d  << 2) + 0xffd00000)
+#define   AIU_AUDIO_AMP_REG2                       (0x143e)
+#define P_AIU_AUDIO_AMP_REG2                       (volatile unsigned int *)((0x143e  << 2) + 0xffd00000)
+#define   AIU_AUDIO_AMP_REG3                       (0x143f)
+#define P_AIU_AUDIO_AMP_REG3                       (volatile unsigned int *)((0x143f  << 2) + 0xffd00000)
+//-----------------------------------------------------------------------------
+//add for AIFIFO2 channel
+//-----------------------------------------------------------------------------
+//Bit 3 	CRC pop aififo2 enable
+//Bit 2		writing to this bit to 1 causes CRC module reset
+//Bit 1		unused
+//Bit 0		writing to this bit to 1 causes AIFIFO2 soft reset
+#define   AIU_AIFIFO2_CTRL                         (0x1440)
+#define P_AIU_AIFIFO2_CTRL                         (volatile unsigned int *)((0x1440  << 2) + 0xffd00000)
+//'h0000
+//AIFIFO2 status register
+//Bit 4:0		//how many bits left in the first pop register
+#define   AIU_AIFIFO2_STATUS                       (0x1441)
+#define P_AIU_AIFIFO2_STATUS                       (volatile unsigned int *)((0x1441  << 2) + 0xffd00000)
+//Same fucntion as the AIGBIT of AIFIFO in CDROM module
+//write to this register how many bits wanna pop,
+//and reading this register gets the corresponding bits data
+#define   AIU_AIFIFO2_GBIT                         (0x1442)
+#define P_AIU_AIFIFO2_GBIT                         (volatile unsigned int *)((0x1442  << 2) + 0xffd00000)
+//Same function as the AICLB of AIFIFO in CDROM module
+//return the leading zeros by reading this registers
+#define   AIU_AIFIFO2_CLB                          (0x1443)
+#define P_AIU_AIFIFO2_CLB                          (volatile unsigned int *)((0x1443  << 2) + 0xffd00000)
+//CRC control register, read/write
+//Bit 0		CRC caculation start
+//Bit 1		CRC core soft reset
+//Bit 2		CRC input register clear
+//Bit 3		CRC pop data from FIFO enable
+//Bit 13:8	CRC polynomial equation order, between 1 to 32
+#define   AIU_CRC_CTRL                             (0x1444)
+#define P_AIU_CRC_CTRL                             (volatile unsigned int *)((0x1444  << 2) + 0xffd00000)
+//16'h1000
+//CRC status register, read only
+//Bit 7:4	CRC internal shift register bit select, just for debug purpose
+//Bit 3		CRC internal shift register data valid, just for debug purpose
+//Bit 2		CRC input register data valid
+//Bit 1		CRC result, 1: CRC not correct, 0: CRC correct
+//Bit 0		CRC state,  1: CRC busy, 0: CRC idle
+#define   AIU_CRC_STATUS                           (0x1445)
+#define P_AIU_CRC_STATUS                           (volatile unsigned int *)((0x1445  << 2) + 0xffd00000)
+//CRC internal shift register, read only, for debug purpose
+#define   AIU_CRC_SHIFT_REG                        (0x1446)
+#define P_AIU_CRC_SHIFT_REG                        (volatile unsigned int *)((0x1446  << 2) + 0xffd00000)
+//CRC data input register, read/write
+#define   AIU_CRC_IREG                             (0x1447)
+#define P_AIU_CRC_IREG                             (volatile unsigned int *)((0x1447  << 2) + 0xffd00000)
+//16'h0000
+//CRC calculation register high-bit part [31:16], read/write
+#define   AIU_CRC_CAL_REG1                         (0x1448)
+#define P_AIU_CRC_CAL_REG1                         (volatile unsigned int *)((0x1448  << 2) + 0xffd00000)
+//CRC calculation register low-bit part [15:0], read/write
+#define   AIU_CRC_CAL_REG0                         (0x1449)
+#define P_AIU_CRC_CAL_REG0                         (volatile unsigned int *)((0x1449  << 2) + 0xffd00000)
+//32'h00000000
+//CRC polynomial coefficient high-bit part [31:16], read/write
+#define   AIU_CRC_POLY_COEF1                       (0x144a)
+#define P_AIU_CRC_POLY_COEF1                       (volatile unsigned int *)((0x144a  << 2) + 0xffd00000)
+//CRC polynomial coefficient low-bit part [15:0], read/write
+#define   AIU_CRC_POLY_COEF0                       (0x144b)
+#define P_AIU_CRC_POLY_COEF0                       (volatile unsigned int *)((0x144b  << 2) + 0xffd00000)
+//32'h80050000			default CRC-16
+//CRC frame size, high-bit part [19:16], read/write
+#define   AIU_CRC_BIT_SIZE1                        (0x144c)
+#define P_AIU_CRC_BIT_SIZE1                        (volatile unsigned int *)((0x144c  << 2) + 0xffd00000)
+//CRC frame size, low-bit part [15:0],	 read/write
+#define   AIU_CRC_BIT_SIZE0                        (0x144d)
+#define P_AIU_CRC_BIT_SIZE0                        (volatile unsigned int *)((0x144d  << 2) + 0xffd00000)
+//20'hfffff
+//how many bits have been processed right now in the current frame, read only
+//high-bit part [19:16]
+#define   AIU_CRC_BIT_CNT1                         (0x144e)
+#define P_AIU_CRC_BIT_CNT1                         (volatile unsigned int *)((0x144e  << 2) + 0xffd00000)
+//low-bit part [15:0]
+#define   AIU_CRC_BIT_CNT0                         (0x144f)
+#define P_AIU_CRC_BIT_CNT0                         (volatile unsigned int *)((0x144f  << 2) + 0xffd00000)
+// -------------------------------------
+// AMCLK Measurement
+// -------------------------------------
+// Used to measure the amclk frequency
+#define   AIU_AMCLK_GATE_HI                        (0x1450)
+#define P_AIU_AMCLK_GATE_HI                        (volatile unsigned int *)((0x1450  << 2) + 0xffd00000)
+#define   AIU_AMCLK_GATE_LO                        (0x1451)
+#define P_AIU_AMCLK_GATE_LO                        (volatile unsigned int *)((0x1451  << 2) + 0xffd00000)
+#define   AIU_AMCLK_MSR                            (0x1452)
+#define P_AIU_AMCLK_MSR                            (volatile unsigned int *)((0x1452  << 2) + 0xffd00000)
+#define   AIU_AUDAC_CTRL0                          (0x1453)
+#define P_AIU_AUDAC_CTRL0                          (volatile unsigned int *)((0x1453  << 2) + 0xffd00000)
+// -------------------------------------
+// Super Simple Delta Sigma DAC
+// -------------------------------------
+// bit 15   1 = invert the clock to the analog filter
+// bit 14   1 = digital mute
+// bit 13   1 = enable analog mute (in the analog block)
+// bit 12   1 = enable Right channel 3 in the analog block
+// bit 11   1 = enable Left  channel 3 in the analog block
+// bit 10   1 = enable Right channel 2 in the analog block
+// bit  9   1 = enable Left  channel 2 in the analog block
+// bit  8   1 = enable Right channel 1 in the analog block
+// bit  7   1 = enable Left  channel 1 in the analog block
+// bit  6   1 = enable Right channel 0 in the analog block
+// bit  5   1 = enable Left  channel 0 in the analog block
+// bit  4:  bit select for serial input data
+// bit  3:  invert alrclk used by the delta-sigma DAC
+// bit  2:  1 = use serial I2S data.  0 = use parallel audio data
+// bits 1:0 Which data to send to the delta-sigma DAC
+//              11 = use channel 3 data
+//              10 = use channel 2 data
+//              01 = use channel 1 data
+//              00 = use channel 0 data
+#define   AIU_DELTA_SIGMA0                         (0x1455)
+#define P_AIU_DELTA_SIGMA0                         (volatile unsigned int *)((0x1455  << 2) + 0xffd00000)
+// Delta Sigma MUTE Value
+#define   AIU_DELTA_SIGMA1                         (0x1456)
+#define P_AIU_DELTA_SIGMA1                         (volatile unsigned int *)((0x1456  << 2) + 0xffd00000)
+// Additional Audio filter controls
+#define   AIU_DELTA_SIGMA2                         (0x1457)
+#define P_AIU_DELTA_SIGMA2                         (volatile unsigned int *)((0x1457  << 2) + 0xffd00000)
+//Bit 14, left channel Delta Sigma modulator soft reset
+//Bit 13, right channel Delta Sigma modulator soft reset
+//Bit 12, left channel Delta Sigma modulator internal state clear enable when it is unstable
+//Bit 11, right channel Delta Sigma modulator internal state clear enable when it is unstable
+//Bit 10, left channel Delta Sigma detect unstable state enable
+//Bit  9, right channel Delta Sigma detect unstable state enable
+//Bit  8, dither high pass filter enable in the Delta Sigma loop
+//Bit 7:6, reserved
+//Bit 5:0, Delta Sigma input data gain  0/32 ~ 63/32
+//default: 16'h3
+#define   AIU_DELTA_SIGMA3                         (0x1458)
+#define P_AIU_DELTA_SIGMA3                         (volatile unsigned int *)((0x1458  << 2) + 0xffd00000)
+//15:8, Added Delta Sigma DC level, range:+-1/2, minimium: +-1/128 (assume max is -1 ~ +1)
+//7:0, max same sequence number, used for unstable detection
+//default: 16'h0
+#define   AIU_DELTA_SIGMA4                         (0x1459)
+#define P_AIU_DELTA_SIGMA4                         (volatile unsigned int *)((0x1459  << 2) + 0xffd00000)
+//Bit 15:8, square wave divide num
+//Bit 7:0, square wave amplitude, -1/4 ~ 1/4, minimium: +-1/1024
+//default: 16'h0
+#define   AIU_DELTA_SIGMA5                         (0x145a)
+#define P_AIU_DELTA_SIGMA5                         (volatile unsigned int *)((0x145a  << 2) + 0xffd00000)
+//Bit 11:8, loop dither amplitude2, 0/32 ~ 15/32
+//Bit 7:4,  loop dither amplitude1, 0/32 ~ 15/32
+//Bit 3:0,  loop dither amplitude0, 0/32 ~ 15/32
+//default: 16'h0
+#define   AIU_DELTA_SIGMA6                         (0x145b)
+#define P_AIU_DELTA_SIGMA6                         (volatile unsigned int *)((0x145b  << 2) + 0xffd00000)
+//Bit 15:8, loop dithering threshold1   0, 1/512, 2/512 ... 1/2
+//Bit 7:0,  loop dithering threshold0   0, 1/512, 2/512 ... 1/2
+//default: 16'h0
+#define   AIU_DELTA_SIGMA7                         (0x145c)
+#define P_AIU_DELTA_SIGMA7                         (volatile unsigned int *)((0x145c  << 2) + 0xffd00000)
+//read only
+//Bit 15:8  left channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
+//          It will saturate to 255, if more than 255 time
+//Bit 7:0   left channel max same sequence number
+#define   AIU_DELTA_SIGMA_LCNTS                    (0x145d)
+#define P_AIU_DELTA_SIGMA_LCNTS                    (volatile unsigned int *)((0x145d  << 2) + 0xffd00000)
+//read only
+//Bit 15:8  right channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
+//          It will saturate to 255, if more than 255 time
+//Bit 7:0   right channel max same sequence number
+#define   AIU_DELTA_SIGMA_RCNTS                    (0x145e)
+#define P_AIU_DELTA_SIGMA_RCNTS                    (volatile unsigned int *)((0x145e  << 2) + 0xffd00000)
+// --------------------------------------------
+// I2S DDR Interface
+// --------------------------------------------
+// The I2S start pointer into DDR memory is a 32-bit number
+#define   AIU_MEM_I2S_START_PTR                    (0x1460)
+#define P_AIU_MEM_I2S_START_PTR                    (volatile unsigned int *)((0x1460  << 2) + 0xffd00000)
+#define   AIU_MEM_I2S_RD_PTR                       (0x1461)
+#define P_AIU_MEM_I2S_RD_PTR                       (volatile unsigned int *)((0x1461  << 2) + 0xffd00000)
+#define   AIU_MEM_I2S_END_PTR                      (0x1462)
+#define P_AIU_MEM_I2S_END_PTR                      (volatile unsigned int *)((0x1462  << 2) + 0xffd00000)
+// There are two masks that control how data is read:
+// [31:16] IRQ block.
+// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
+// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
+#define   AIU_MEM_I2S_MASKS                        (0x1463)
+#define P_AIU_MEM_I2S_MASKS                        (volatile unsigned int *)((0x1463  << 2) + 0xffd00000)
+// I2S FIFO Control
+// bits [11:10] Select which hardware pointer to use to control the buffer
+//              level:
+//                  00 = parser
+//                  01 = audin_fifo0_wrpt
+//                  1x = audin_fifo1_wrpt
+// bit  [9]     Use level control: 1 = use buffer level control
+// bit  [8]     Read Only.  This bit is 1 when there is data available for reading
+// bit  [7]     Read only.  This bit will be high when we're fetching data from the DDR memory
+//              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//              After that you can pulse cntl_init to start over
+// bit  [6]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR
+// bits [5:3]   endian:  see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading data from the FIFO
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+#define   AIU_MEM_I2S_CONTROL                      (0x1464)
+#define P_AIU_MEM_I2S_CONTROL                      (volatile unsigned int *)((0x1464  << 2) + 0xffd00000)
+// --------------------------------------------
+// IEC958 DDR Interface
+// --------------------------------------------
+// The IEC958 start pointer into DDR memory is a 32-bit number
+#define   AIU_MEM_IEC958_START_PTR                 (0x1465)
+#define P_AIU_MEM_IEC958_START_PTR                 (volatile unsigned int *)((0x1465  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_RD_PTR                    (0x1466)
+#define P_AIU_MEM_IEC958_RD_PTR                    (volatile unsigned int *)((0x1466  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_END_PTR                   (0x1467)
+#define P_AIU_MEM_IEC958_END_PTR                   (volatile unsigned int *)((0x1467  << 2) + 0xffd00000)
+// There are two masks that control how data is read:
+// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
+// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
+#define   AIU_MEM_IEC958_MASKS                     (0x1468)
+#define P_AIU_MEM_IEC958_MASKS                     (volatile unsigned int *)((0x1468  << 2) + 0xffd00000)
+// IEC958 FIFO Control
+// bit  [31]    A_urgent
+// bit  [30]    ch_always_8
+// bit  [29:24] rdata_rd_base_begin ( used for select from different channel )
+// bit  [23:14] reserved
+// bit  [13]    cntl_sim_en
+// bit  [12]    cntl_use_level
+// bit  [11]    Read only.      This bit will be set to 1 when there is data in the FIFO to process
+// bit  [10]    Read only.  This bit will be high when we're fetching data from the DDR memory
+//              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//              After that you can pulse cntl_init to start over
+// bit  [9]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
+//                              the FIFO to the rest of the IEC958 logic
+// bit  [8]     mode_raw:       Set this bit to 1 to tell the IEC958 FIFO to read
+//                              and process data linearly for raw data.
+// bit  [7]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR.  Only valid when mode_raw = 0
+// bit  [6]     cntl_rd_ddr     Set this bit to read if you want AIU_MEM_IEC958_RD_PTR and
+//                              AIU_MEM_IEC958_RD_PTR_HIGH to refer to the pointer into DDR memory.
+//                              Otherwise, the curr_ptr registers refer to the byte address of the data
+//                              at the output of the FIFO to the rest of the IEC958 logic
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+#define   AIU_MEM_IEC958_CONTROL                   (0x1469)
+#define P_AIU_MEM_IEC958_CONTROL                   (volatile unsigned int *)((0x1469  << 2) + 0xffd00000)
+// --------------------------------------------
+// AIFIFO2 DDR Interface
+// --------------------------------------------
+// The AIFIFO2 start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   AIU_MEM_AIFIFO2_START_PTR                (0x146a)
+#define P_AIU_MEM_AIFIFO2_START_PTR                (volatile unsigned int *)((0x146a  << 2) + 0xffd00000)
+// The current pointer points so some location between the START and END
+// pointers.  The current pointer is a BYTE pointer.  That is, you can
+// point to any BYTE address within the START/END range
+#define   AIU_MEM_AIFIFO2_CURR_PTR                 (0x146b)
+#define P_AIU_MEM_AIFIFO2_CURR_PTR                 (volatile unsigned int *)((0x146b  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO2_END_PTR                  (0x146c)
+#define P_AIU_MEM_AIFIFO2_END_PTR                  (volatile unsigned int *)((0x146c  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO2_BYTES_AVAIL              (0x146d)
+#define P_AIU_MEM_AIFIFO2_BYTES_AVAIL              (volatile unsigned int *)((0x146d  << 2) + 0xffd00000)
+// AIFIFO2 FIFO Control
+// bit  [15:11] unused
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
+//                              the FIFO to getbit
+// bit  [6]     unused
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define   AIU_MEM_AIFIFO2_CONTROL                  (0x146e)
+#define P_AIU_MEM_AIFIFO2_CONTROL                  (volatile unsigned int *)((0x146e  << 2) + 0xffd00000)
+// --------------------------------------------
+// AIFIFO2 Buffer Level Manager
+// --------------------------------------------
+#define   AIU_MEM_AIFIFO2_MAN_WP                   (0x146f)
+#define P_AIU_MEM_AIFIFO2_MAN_WP                   (volatile unsigned int *)((0x146f  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO2_MAN_RP                   (0x1470)
+#define P_AIU_MEM_AIFIFO2_MAN_RP                   (volatile unsigned int *)((0x1470  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO2_LEVEL                    (0x1471)
+#define P_AIU_MEM_AIFIFO2_LEVEL                    (volatile unsigned int *)((0x1471  << 2) + 0xffd00000)
+//
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   AIU_MEM_AIFIFO2_BUF_CNTL                 (0x1472)
+#define P_AIU_MEM_AIFIFO2_BUF_CNTL                 (volatile unsigned int *)((0x1472  << 2) + 0xffd00000)
+// --------------------------------------------
+// I2S Buffer Level Manager
+// --------------------------------------------
+#define   AIU_MEM_I2S_MAN_WP                       (0x1473)
+#define P_AIU_MEM_I2S_MAN_WP                       (volatile unsigned int *)((0x1473  << 2) + 0xffd00000)
+#define   AIU_MEM_I2S_MAN_RP                       (0x1474)
+#define P_AIU_MEM_I2S_MAN_RP                       (volatile unsigned int *)((0x1474  << 2) + 0xffd00000)
+#define   AIU_MEM_I2S_LEVEL                        (0x1475)
+#define P_AIU_MEM_I2S_LEVEL                        (volatile unsigned int *)((0x1475  << 2) + 0xffd00000)
+//
+// bit  [1]     mode            0 = parser (or audin_fifo0 or audin_fifo1),
+//                              1 for manual write pointer
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   AIU_MEM_I2S_BUF_CNTL                     (0x1476)
+#define P_AIU_MEM_I2S_BUF_CNTL                     (volatile unsigned int *)((0x1476  << 2) + 0xffd00000)
+#define   AIU_MEM_I2S_BUF_WRAP_COUNT               (0x1477)
+#define P_AIU_MEM_I2S_BUF_WRAP_COUNT               (volatile unsigned int *)((0x1477  << 2) + 0xffd00000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   AIU_MEM_I2S_MEM_CTL                      (0x1478)
+#define P_AIU_MEM_I2S_MEM_CTL                      (volatile unsigned int *)((0x1478  << 2) + 0xffd00000)
+//-----------------------------------------------------------------------------
+// Additional IEC958 registers (new feature)
+//-----------------------------------------------------------------------------
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   AIU_MEM_IEC958_MEM_CTL                   (0x1479)
+#define P_AIU_MEM_IEC958_MEM_CTL                   (volatile unsigned int *)((0x1479  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_WRAP_COUNT                (0x147a)
+#define P_AIU_MEM_IEC958_WRAP_COUNT                (volatile unsigned int *)((0x147a  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_IRQ_LEVEL                 (0x147b)
+#define P_AIU_MEM_IEC958_IRQ_LEVEL                 (volatile unsigned int *)((0x147b  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_MAN_WP                    (0x147c)
+#define P_AIU_MEM_IEC958_MAN_WP                    (volatile unsigned int *)((0x147c  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_MAN_RP                    (0x147d)
+#define P_AIU_MEM_IEC958_MAN_RP                    (volatile unsigned int *)((0x147d  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_LEVEL                     (0x147e)
+#define P_AIU_MEM_IEC958_LEVEL                     (volatile unsigned int *)((0x147e  << 2) + 0xffd00000)
+#define   AIU_MEM_IEC958_BUF_CNTL                  (0x147f)
+#define P_AIU_MEM_IEC958_BUF_CNTL                  (volatile unsigned int *)((0x147f  << 2) + 0xffd00000)
+//-----------------------------------------------------------------------------
+// add for AIFIFO channel (old $cdrom/rtl/cdr_top/getbit)
+//-----------------------------------------------------------------------------
+// Bit 3 	CRC pop aififo enable
+// Bit 2		writing to this bit to 1 causes CRC module reset
+// Bit 1		enable aififo
+// Bit 0		writing to this bit to 1 causes aififo soft reset
+#define   AIU_AIFIFO_CTRL                          (0x1480)
+#define P_AIU_AIFIFO_CTRL                          (volatile unsigned int *)((0x1480  << 2) + 0xffd00000)
+//'h0000
+// AIFIFO status register
+// Bit 13		//aififo request to dcu status
+// Bit 12		//dcu select status
+// Bit 11:5		//aififo word counter number
+// Bit 4:0		//how many bits left in the first pop register
+#define   AIU_AIFIFO_STATUS                        (0x1481)
+#define P_AIU_AIFIFO_STATUS                        (volatile unsigned int *)((0x1481  << 2) + 0xffd00000)
+// Same fucntion as the AIGBIT of AIFIFO in CDROM module
+// write to this register how many bits wanna pop,
+// and reading this register gets the corresponding bits data
+#define   AIU_AIFIFO_GBIT                          (0x1482)
+#define P_AIU_AIFIFO_GBIT                          (volatile unsigned int *)((0x1482  << 2) + 0xffd00000)
+// Same function as the AICLB of AIFIFO in CDROM module
+// return the leading zeros by reading this registers
+#define   AIU_AIFIFO_CLB                           (0x1483)
+#define P_AIU_AIFIFO_CLB                           (volatile unsigned int *)((0x1483  << 2) + 0xffd00000)
+// --------------------------------------------
+// AIFIFO DDR Interface
+// --------------------------------------------
+// The AIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define   AIU_MEM_AIFIFO_START_PTR                 (0x1484)
+#define P_AIU_MEM_AIFIFO_START_PTR                 (volatile unsigned int *)((0x1484  << 2) + 0xffd00000)
+// The current pointer points so some location between the START and END
+// pointers.  The current pointer is a BYTE pointer.  That is, you can
+// point to any BYTE address within the START/END range
+#define   AIU_MEM_AIFIFO_CURR_PTR                  (0x1485)
+#define P_AIU_MEM_AIFIFO_CURR_PTR                  (volatile unsigned int *)((0x1485  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO_END_PTR                   (0x1486)
+#define P_AIU_MEM_AIFIFO_END_PTR                   (volatile unsigned int *)((0x1486  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO_BYTES_AVAIL               (0x1487)
+#define P_AIU_MEM_AIFIFO_BYTES_AVAIL               (volatile unsigned int *)((0x1487  << 2) + 0xffd00000)
+// AIFIFO FIFO Control
+// bit  [15:11] unused
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0.
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
+//                              the FIFO to getbit
+// bit  [6]     unused
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define   AIU_MEM_AIFIFO_CONTROL                   (0x1488)
+#define P_AIU_MEM_AIFIFO_CONTROL                   (volatile unsigned int *)((0x1488  << 2) + 0xffd00000)
+// --------------------------------------------
+// AIFIFO Buffer Level Manager
+// --------------------------------------------
+#define   AIU_MEM_AIFIFO_MAN_WP                    (0x1489)
+#define P_AIU_MEM_AIFIFO_MAN_WP                    (volatile unsigned int *)((0x1489  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO_MAN_RP                    (0x148a)
+#define P_AIU_MEM_AIFIFO_MAN_RP                    (volatile unsigned int *)((0x148a  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO_LEVEL                     (0x148b)
+#define P_AIU_MEM_AIFIFO_LEVEL                     (volatile unsigned int *)((0x148b  << 2) + 0xffd00000)
+//
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define   AIU_MEM_AIFIFO_BUF_CNTL                  (0x148c)
+#define P_AIU_MEM_AIFIFO_BUF_CNTL                  (volatile unsigned int *)((0x148c  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO_BUF_WRAP_COUNT            (0x148d)
+#define P_AIU_MEM_AIFIFO_BUF_WRAP_COUNT            (volatile unsigned int *)((0x148d  << 2) + 0xffd00000)
+#define   AIU_MEM_AIFIFO2_BUF_WRAP_COUNT           (0x148e)
+#define P_AIU_MEM_AIFIFO2_BUF_WRAP_COUNT           (volatile unsigned int *)((0x148e  << 2) + 0xffd00000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   AIU_MEM_AIFIFO_MEM_CTL                   (0x148f)
+#define P_AIU_MEM_AIFIFO_MEM_CTL                   (volatile unsigned int *)((0x148f  << 2) + 0xffd00000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   AIFIFO_TIME_STAMP_CNTL                   (0x1490)
+#define P_AIFIFO_TIME_STAMP_CNTL                   (volatile unsigned int *)((0x1490  << 2) + 0xffd00000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   AIFIFO_TIME_STAMP_SYNC_0                 (0x1491)
+#define P_AIFIFO_TIME_STAMP_SYNC_0                 (volatile unsigned int *)((0x1491  << 2) + 0xffd00000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   AIFIFO_TIME_STAMP_SYNC_1                 (0x1492)
+#define P_AIFIFO_TIME_STAMP_SYNC_1                 (volatile unsigned int *)((0x1492  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_0
+#define   AIFIFO_TIME_STAMP_0                      (0x1493)
+#define P_AIFIFO_TIME_STAMP_0                      (volatile unsigned int *)((0x1493  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_1
+#define   AIFIFO_TIME_STAMP_1                      (0x1494)
+#define P_AIFIFO_TIME_STAMP_1                      (volatile unsigned int *)((0x1494  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_2
+#define   AIFIFO_TIME_STAMP_2                      (0x1495)
+#define P_AIFIFO_TIME_STAMP_2                      (volatile unsigned int *)((0x1495  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_3
+#define   AIFIFO_TIME_STAMP_3                      (0x1496)
+#define P_AIFIFO_TIME_STAMP_3                      (volatile unsigned int *)((0x1496  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   AIFIFO_TIME_STAMP_LENGTH                 (0x1497)
+#define P_AIFIFO_TIME_STAMP_LENGTH                 (volatile unsigned int *)((0x1497  << 2) + 0xffd00000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   AIFIFO2_TIME_STAMP_CNTL                  (0x1498)
+#define P_AIFIFO2_TIME_STAMP_CNTL                  (volatile unsigned int *)((0x1498  << 2) + 0xffd00000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   AIFIFO2_TIME_STAMP_SYNC_0                (0x1499)
+#define P_AIFIFO2_TIME_STAMP_SYNC_0                (volatile unsigned int *)((0x1499  << 2) + 0xffd00000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   AIFIFO2_TIME_STAMP_SYNC_1                (0x149a)
+#define P_AIFIFO2_TIME_STAMP_SYNC_1                (volatile unsigned int *)((0x149a  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_0
+#define   AIFIFO2_TIME_STAMP_0                     (0x149b)
+#define P_AIFIFO2_TIME_STAMP_0                     (volatile unsigned int *)((0x149b  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_1
+#define   AIFIFO2_TIME_STAMP_1                     (0x149c)
+#define P_AIFIFO2_TIME_STAMP_1                     (volatile unsigned int *)((0x149c  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_2
+#define   AIFIFO2_TIME_STAMP_2                     (0x149d)
+#define P_AIFIFO2_TIME_STAMP_2                     (volatile unsigned int *)((0x149d  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_3
+#define   AIFIFO2_TIME_STAMP_3                     (0x149e)
+#define P_AIFIFO2_TIME_STAMP_3                     (volatile unsigned int *)((0x149e  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   AIFIFO2_TIME_STAMP_LENGTH                (0x149f)
+#define P_AIFIFO2_TIME_STAMP_LENGTH                (volatile unsigned int *)((0x149f  << 2) + 0xffd00000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define   IEC958_TIME_STAMP_CNTL                   (0x14a0)
+#define P_IEC958_TIME_STAMP_CNTL                   (volatile unsigned int *)((0x14a0  << 2) + 0xffd00000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define   IEC958_TIME_STAMP_SYNC_0                 (0x14a1)
+#define P_IEC958_TIME_STAMP_SYNC_0                 (volatile unsigned int *)((0x14a1  << 2) + 0xffd00000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1
+#define   IEC958_TIME_STAMP_SYNC_1                 (0x14a2)
+#define P_IEC958_TIME_STAMP_SYNC_1                 (volatile unsigned int *)((0x14a2  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_0
+#define   IEC958_TIME_STAMP_0                      (0x14a3)
+#define P_IEC958_TIME_STAMP_0                      (volatile unsigned int *)((0x14a3  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_1
+#define   IEC958_TIME_STAMP_1                      (0x14a4)
+#define P_IEC958_TIME_STAMP_1                      (volatile unsigned int *)((0x14a4  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_2
+#define   IEC958_TIME_STAMP_2                      (0x14a5)
+#define P_IEC958_TIME_STAMP_2                      (volatile unsigned int *)((0x14a5  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_3
+#define   IEC958_TIME_STAMP_3                      (0x14a6)
+#define P_IEC958_TIME_STAMP_3                      (volatile unsigned int *)((0x14a6  << 2) + 0xffd00000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define   IEC958_TIME_STAMP_LENGTH                 (0x14a7)
+#define P_IEC958_TIME_STAMP_LENGTH                 (volatile unsigned int *)((0x14a7  << 2) + 0xffd00000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold
+#define   AIU_MEM_AIFIFO2_MEM_CTL                  (0x14a8)
+#define P_AIU_MEM_AIFIFO2_MEM_CTL                  (volatile unsigned int *)((0x14a8  << 2) + 0xffd00000)
+// --------------------------------------------
+// CBUS_DDR interface for I2S_FAST
+// --------------------------------------------
+// bit[31:26] unused
+// bit[25]      A_req       level
+// bit[24]      data_req    If this bit is 1, then (a_req_cnt != 'h0)
+// bit[23:16]   a_req_cnt   This value corresponds to the number of 32-bit words
+//                          requested by the i2s_fast() module
+// bit[15:7]    unused
+// bit[6]                   Set this bit to mux in the cbus_ddr_interface
+// bit[5]                   Set this bit to allow back to back A_req's to be serviced
+// bit[4]                   Set this bit to generate an IRQ on the first A_req
+//                          If this bit is 0, then an IRQ is generated after all requests
+//                          are completed and how many 32-bit words to send is calculated.
+// bit[3:1]                 Endian
+// bit[0]                   Set this bit enable the cbus_ddr_interface
+#define   AIU_I2S_CBUS_DDR_CNTL                    (0x14a9)
+#define P_AIU_I2S_CBUS_DDR_CNTL                    (volatile unsigned int *)((0x14a9  << 2) + 0xffd00000)
+// 32-bit data to write to the cbus_ddr interface
+#define   AIU_I2S_CBUS_DDR_WDATA                   (0x14aa)
+#define P_AIU_I2S_CBUS_DDR_WDATA                   (volatile unsigned int *)((0x14aa  << 2) + 0xffd00000)
+// First address associated with the first request by the i2s_fast() to read DDR data
+#define   AIU_I2S_CBUS_DDR_ADDR                    (0x14ab)
+#define P_AIU_I2S_CBUS_DDR_ADDR                    (volatile unsigned int *)((0x14ab  << 2) + 0xffd00000)
+//
+// Closing file:  aregs.h
+//
+//========================================================================
+//  CDROM Interface                                 (12'h600 - 12'h6ff)
+//
+//========================================================================
+//========================================================================
+//	registers for ge2d (12'h8a0 - 12'h8ff)
+//========================================================================
+////`include "ge2d_regs.h" //  not in cbus domain any more, it is located in vapb3 bus now
+//========================================================================
+//  DSP Co-Processor Registers			    ( 8'he00 - 12'hfff)
+//
+//========================================================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define AUDIO_COP_CTL1      12'hf00  // r & w; r-> 6'h00,bsmod[2:0],acmod[2:0],lfeon,nfchans[2:0]
+//
+// Incorrect format....should be 8'bits only
+//
+// Removed by Chris Maslyar       `define AUDIO_COP_CTL2      12'hf01  // r & w; r-> frame_size[12:0],dsurmod[1:0]
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar       //  f02 -f0d are special regs , not in ac3_reg.h, but used by CPU for AC3 operations
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar       `define OPERAND_M_CTL       12'hf02
+// Removed by Chris Maslyar       `define OPERAND1_ADDR       12'hf03
+// Removed by Chris Maslyar       `define OPERAND2_ADDR       12'hf04
+// Removed by Chris Maslyar       `define RESULT_M_CTL        12'hf05
+// Removed by Chris Maslyar       `define RESULT1_ADDR        12'hf06
+// Removed by Chris Maslyar       `define RESULT2_ADDR        12'hf07
+// Removed by Chris Maslyar       `define ADD_SHFT_CTL        12'hf08
+// Removed by Chris Maslyar       `define OPERAND_ONE_H       12'hf09
+// Removed by Chris Maslyar       `define OPERAND_ONE_L       12'hf0a
+// Removed by Chris Maslyar       `define OPERAND_TWO_H       12'hf0b
+// Removed by Chris Maslyar       `define OPERAND_TWO_L       12'hf0c
+// Removed by Chris Maslyar       `define RESULT_H            12'hf0d
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar       `define RESULT_M            12'hf0e   // r & w; ac3_reg_14
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar       // special reg
+// Removed by Chris Maslyar       `define RESULT_L            12'hf0f
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar       //
+// Removed by Chris Maslyar       `define WMEM_R_PTR          12'hf10   // r & w ; endmant0 &1
+// Removed by Chris Maslyar
+// Removed by Chris Maslyar       `define WMEM_W_PTR          12'hf11
+// Removed by Chris Maslyar       `define AUDIO_LAYER         12'hf20
+// Removed by Chris Maslyar       `define AC3_DECODING        12'hf21
+// Removed by Chris Maslyar       `define AC3_DYNAMIC         12'hf22
+// Removed by Chris Maslyar       `define AC3_MELODY          12'hf23
+// Removed by Chris Maslyar       `define AC3_VOCAL           12'hf24
+//======================================
+//  CPU Assist module
+//
+//======================================
+// -----------------------------------------------
+// CBUS_BASE:  ASSIST_CBUS_BASE = 0x20
+// -----------------------------------------------
+//`define ASSIST_AMR_MBOX1_INT          8'h4d
+//`define ASSIST_AMR_MBOX2_INT          8'h4e
+#define   ASSIST_AMR_SCRATCH0                      (0x204f)
+#define P_ASSIST_AMR_SCRATCH0                      (volatile unsigned int *)((0x204f  << 2) + 0xffd00000)
+#define   ASSIST_AMR_SCRATCH1                      (0x2050)
+#define P_ASSIST_AMR_SCRATCH1                      (volatile unsigned int *)((0x2050  << 2) + 0xffd00000)
+#define   ASSIST_AMR_SCRATCH2                      (0x2051)
+#define P_ASSIST_AMR_SCRATCH2                      (volatile unsigned int *)((0x2051  << 2) + 0xffd00000)
+#define   ASSIST_AMR_SCRATCH3                      (0x2052)
+#define P_ASSIST_AMR_SCRATCH3                      (volatile unsigned int *)((0x2052  << 2) + 0xffd00000)
+#define   ASSIST_HW_REV                            (0x2053)
+#define P_ASSIST_HW_REV                            (volatile unsigned int *)((0x2053  << 2) + 0xffd00000)
+//`define ASSIST_CBUS_ARB               8'h54
+#define   ASSIST_POR_CONFIG                        (0x2055)
+#define P_ASSIST_POR_CONFIG                        (volatile unsigned int *)((0x2055  << 2) + 0xffd00000)
+#define   ASSIST_SPARE16_REG1                      (0x2056)
+#define P_ASSIST_SPARE16_REG1                      (volatile unsigned int *)((0x2056  << 2) + 0xffd00000)
+#define   ASSIST_SPARE16_REG2                      (0x2057)
+#define P_ASSIST_SPARE16_REG2                      (volatile unsigned int *)((0x2057  << 2) + 0xffd00000)
+#define   ASSIST_SPARE8_REG1                       (0x2058)
+#define P_ASSIST_SPARE8_REG1                       (volatile unsigned int *)((0x2058  << 2) + 0xffd00000)
+#define   ASSIST_SPARE8_REG2                       (0x2059)
+#define P_ASSIST_SPARE8_REG2                       (volatile unsigned int *)((0x2059  << 2) + 0xffd00000)
+// Duplicate Address...when used please move to a new address
+// `define TO_AMRISC_REG                 8'h59 // for amrisc
+#define   ASSIST_SPARE8_REG3                       (0x205a)
+#define P_ASSIST_SPARE8_REG3                       (volatile unsigned int *)((0x205a  << 2) + 0xffd00000)
+// Duplicate Address...when used please move to a new address
+// `define FROM_AMRISC_REG               8'h5a // for amrisc
+// Duplicate Address...when used please move to a new address
+// `define MPEG2_DECODER_CONTROL         8'h5b // for amrisc
+#define   AC3_CTRL_REG1                            (0x205b)
+#define P_AC3_CTRL_REG1                            (volatile unsigned int *)((0x205b  << 2) + 0xffd00000)
+#define   AC3_CTRL_REG2                            (0x205c)
+#define P_AC3_CTRL_REG2                            (volatile unsigned int *)((0x205c  << 2) + 0xffd00000)
+#define   AC3_CTRL_REG3                            (0x205d)
+#define P_AC3_CTRL_REG3                            (volatile unsigned int *)((0x205d  << 2) + 0xffd00000)
+#define   AC3_CTRL_REG4                            (0x205e)
+#define P_AC3_CTRL_REG4                            (volatile unsigned int *)((0x205e  << 2) + 0xffd00000)
+//`define ASSIST_PMEM_SPLIT             8'h5f
+#define   ASSIST_GEN_CNTL                          (0x2068)
+#define P_ASSIST_GEN_CNTL                          (volatile unsigned int *)((0x2068  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX0_IRQ_REG                  (0x2070)
+#define P_EE_ASSIST_MBOX0_IRQ_REG                  (volatile unsigned int *)((0x2070  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX0_CLR_REG                  (0x2071)
+#define P_EE_ASSIST_MBOX0_CLR_REG                  (volatile unsigned int *)((0x2071  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX0_MASK                     (0x2072)
+#define P_EE_ASSIST_MBOX0_MASK                     (volatile unsigned int *)((0x2072  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX0_FIQ_SEL                  (0x2073)
+#define P_EE_ASSIST_MBOX0_FIQ_SEL                  (volatile unsigned int *)((0x2073  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX1_IRQ_REG                  (0x2074)
+#define P_EE_ASSIST_MBOX1_IRQ_REG                  (volatile unsigned int *)((0x2074  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX1_CLR_REG                  (0x2075)
+#define P_EE_ASSIST_MBOX1_CLR_REG                  (volatile unsigned int *)((0x2075  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX1_MASK                     (0x2076)
+#define P_EE_ASSIST_MBOX1_MASK                     (volatile unsigned int *)((0x2076  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX1_FIQ_SEL                  (0x2077)
+#define P_EE_ASSIST_MBOX1_FIQ_SEL                  (volatile unsigned int *)((0x2077  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX2_IRQ_REG                  (0x2078)
+#define P_EE_ASSIST_MBOX2_IRQ_REG                  (volatile unsigned int *)((0x2078  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX2_CLR_REG                  (0x2079)
+#define P_EE_ASSIST_MBOX2_CLR_REG                  (volatile unsigned int *)((0x2079  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX2_MASK                     (0x207a)
+#define P_EE_ASSIST_MBOX2_MASK                     (volatile unsigned int *)((0x207a  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX2_FIQ_SEL                  (0x207b)
+#define P_EE_ASSIST_MBOX2_FIQ_SEL                  (volatile unsigned int *)((0x207b  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX3_IRQ_REG                  (0x207c)
+#define P_EE_ASSIST_MBOX3_IRQ_REG                  (volatile unsigned int *)((0x207c  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX3_CLR_REG                  (0x207d)
+#define P_EE_ASSIST_MBOX3_CLR_REG                  (volatile unsigned int *)((0x207d  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX3_MASK                     (0x207e)
+#define P_EE_ASSIST_MBOX3_MASK                     (volatile unsigned int *)((0x207e  << 2) + 0xffd00000)
+#define   EE_ASSIST_MBOX3_FIQ_SEL                  (0x207f)
+#define P_EE_ASSIST_MBOX3_FIQ_SEL                  (volatile unsigned int *)((0x207f  << 2) + 0xffd00000)
+// -----------------------------------------------
+// CBUS_BASE:  AUD_CBUS_BASE = 0x34
+// -----------------------------------------------
+// ----------------------------
+// AUDIN (64)
+// ----------------------------
+#define   AUDIN_SPDIF_MODE                         (0x3400)
+#define P_AUDIN_SPDIF_MODE                         (volatile unsigned int *)((0x3400  << 2) + 0xffd00000)
+    #define SPDIF_EN                31
+    #define SPDIF_INT_EN            30
+    #define SPDIF_BURST_PRE_INT_EN  29
+    #define SPDIF_TIE_0             24
+    #define SPDIF_SAMPLE_SEL        23
+    #define SPDIF_REVERSE_EN        22
+    #define SPDIF_BIT_ORDER         20
+    #define SPDIF_CHNL_ORDER        19
+    #define SPDIF_DATA_TYPE_SEL     18
+    #define SPDIF_XTDCLK_UPD_ITVL   14   //16:14
+    #define SPDIF_CLKNUM_54U        0     //13:0
+#define   AUDIN_SPDIF_FS_CLK_RLTN                  (0x3401)
+#define P_AUDIN_SPDIF_FS_CLK_RLTN                  (volatile unsigned int *)((0x3401  << 2) + 0xffd00000)
+    #define SPDIF_CLKNUM_192K  24     //29:24
+    #define SPDIF_CLKNUM_96K   18     //23:18
+    #define SPDIF_CLKNUM_48K   12     //17:12
+    #define SPDIF_CLKNUM_44K   6     // 11:6
+    #define SPDIF_CLKNUM_32K   0     // 5:0
+#define   AUDIN_SPDIF_CHNL_STS_A                   (0x3402)
+#define P_AUDIN_SPDIF_CHNL_STS_A                   (volatile unsigned int *)((0x3402  << 2) + 0xffd00000)
+#define   AUDIN_SPDIF_CHNL_STS_B                   (0x3403)
+#define P_AUDIN_SPDIF_CHNL_STS_B                   (volatile unsigned int *)((0x3403  << 2) + 0xffd00000)
+#define   AUDIN_SPDIF_MISC                         (0x3404)
+#define P_AUDIN_SPDIF_MISC                         (volatile unsigned int *)((0x3404  << 2) + 0xffd00000)
+#define   AUDIN_SPDIF_NPCM_PCPD                    (0x3405)
+#define P_AUDIN_SPDIF_NPCM_PCPD                    (volatile unsigned int *)((0x3405  << 2) + 0xffd00000)
+#define   AUDIN_SPDIF_END                          (0x340f)
+#define P_AUDIN_SPDIF_END                          (volatile unsigned int *)((0x340f  << 2) + 0xffd00000)
+#define   AUDIN_I2SIN_CTRL                         (0x3410)
+#define P_AUDIN_I2SIN_CTRL                         (volatile unsigned int *)((0x3410  << 2) + 0xffd00000)
+    #define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
+    #define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
+    #define I2SIN_LRCLK_SEL 2
+    #define I2SIN_POS_SYNC  3
+    #define I2SIN_LRCLK_SKEW 4    // 6:4
+    #define I2SIN_LRCLK_INVT 7
+    #define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
+    #define I2SIN_CHAN_EN   10    //13:10.
+    #define I2SIN_EN        15
+// Bit 31:15    Rsrv.
+// Bit 14:12 RW HDMI-RX SPDIF channel status select to report on AUDIN_DECODE_CHANNEL_STATUS_A_*: 0=select channel 1; 1=channel 2; ...; 7=channel 8.
+// Bit 11: 8 RW HDMI-RX SPDIF channel status extraction enable, 1-bit per channel pair. To enable, SPDIF input source also must select 1.
+// Bit  7: 6    Rsrv.
+// Bit  5: 4 RW SPDIF input source select. 0=Default, select chip external; 1=select HDMI RX output; 2/3=Rsrv.
+// Bit  3: 2    Rsrv.
+// Bit  1: 0 RW I2S input source select. 0=Default, select chip external; 1=select audio codec output; 2=select HDMI RX output; 3=Rsrv.
+#define   AUDIN_SOURCE_SEL                         (0x3411)
+#define P_AUDIN_SOURCE_SEL                         (volatile unsigned int *)((0x3411  << 2) + 0xffd00000)
+// The following registers control the new alternative decoder -- hdmi_tx_audio_decoder, in audin module
+// Bit 31:25    Rsrv.
+// Bit    24 RW SPDIF enable.
+// Bit 23:22    Rsrv.
+// Bit 21:20 RW i2s_block_start_src: 0=left channel 0 is approved as block start generator, ..., 3=left channel 3 is the block start generator.
+// Bit 19:17    Rsrv.
+// Bit    16 RW I2S enable.
+// Bit 15: 8 RW audio_channel_alloc: Usage indication of up to 8 channels. If the correspoinding bit is 1, then this channel is used.
+//                                   E.g.: In 2-channel audio, it is 00000011
+// Bit     7 RW hdmi_tx_audio_decoder input sel: 0=SPDIF; 1=I2S.
+// Bit     6 RW i2s_channel_config: 0=2-channel; 1=8-channel.
+// Bit  5: 4 RW i2s_format_select: 0=left-justify; 1=right-justify; 2=I2S format; 3=DSP format.
+// Bit  3: 2 RW i2s_bit_width: 0=16-bit; 1=18-bit; 2=20-bit; 3=24-bit.
+// Bit     1 RW ws polarity: 0=0 is left, 1 is right; 1=1 is left, 0 is right.
+// Bit     0 RW For SPDIF mode, 0=use channel status from input data; 1=use channel status from registers;
+//              For I2S mode, 0=one-bit audio; 1=I2S.
+#define   AUDIN_DECODE_FORMAT                      (0x3412)
+#define P_AUDIN_DECODE_FORMAT                      (volatile unsigned int *)((0x3412  << 2) + 0xffd00000)
+// Bit 31:25    Rsrv.
+// Bit    24 R  channel_status stablility indicator.
+// Bit 23:16 RW Valid bits for audio sample packet. [7] for valid_sp3_right, [6] for valid_sp3_left, ..., [1] for valid_sp0_right, [0] for valid_sp0_left.
+// Bit 15: 8 RW User bits for audio sample packet. [7] for user_sp3_right, [6] for user_sp3_left, ..., [1] for user_sp0_right, [0] for user_sp0_left.
+// Bit  7: 4 RW cntl_init_discard: Number of initial hdmi_tx_audio_decoder samples to discard from reset.
+// Bit     3 RW cntl_invert_i2s_lrclk: Invert WS before input to hdmi_tx_audio_decoder.
+// Bit     2 RW audio_valid_overwrite: Valid bit selection in audio packet. 0=use input data; 1=use
+// Bit     1 RW audio_user_overwrite: User bit selection in audio packet. 0=use input data; 1=use
+// Bit     0 RW audio_sample_valid: sample non-flat indication. 0=flat, non-valid; 1=non-flat, valid.
+#define   AUDIN_DECODE_CONTROL_STATUS              (0x3413)
+#define P_AUDIN_DECODE_CONTROL_STATUS              (volatile unsigned int *)((0x3413  << 2) + 0xffd00000)
+// IEC958 192-bit channel status: muxed between 8 channels, channel selection by AUDIN_SOURCE_SEL[14:12]
+#define   AUDIN_DECODE_CHANNEL_STATUS_A_0          (0x3414)
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_0          (volatile unsigned int *)((0x3414  << 2) + 0xffd00000)
+#define   AUDIN_DECODE_CHANNEL_STATUS_A_1          (0x3415)
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_1          (volatile unsigned int *)((0x3415  << 2) + 0xffd00000)
+#define   AUDIN_DECODE_CHANNEL_STATUS_A_2          (0x3416)
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_2          (volatile unsigned int *)((0x3416  << 2) + 0xffd00000)
+#define   AUDIN_DECODE_CHANNEL_STATUS_A_3          (0x3417)
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_3          (volatile unsigned int *)((0x3417  << 2) + 0xffd00000)
+#define   AUDIN_DECODE_CHANNEL_STATUS_A_4          (0x3418)
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_4          (volatile unsigned int *)((0x3418  << 2) + 0xffd00000)
+#define   AUDIN_DECODE_CHANNEL_STATUS_A_5          (0x3419)
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_5          (volatile unsigned int *)((0x3419  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_START                        (0x3420)
+#define P_AUDIN_FIFO0_START                        (volatile unsigned int *)((0x3420  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_END                          (0x3421)
+#define P_AUDIN_FIFO0_END                          (volatile unsigned int *)((0x3421  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_PTR                          (0x3422)
+#define P_AUDIN_FIFO0_PTR                          (volatile unsigned int *)((0x3422  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_INTR                         (0x3423)
+#define P_AUDIN_FIFO0_INTR                         (volatile unsigned int *)((0x3423  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_RDPTR                        (0x3424)
+#define P_AUDIN_FIFO0_RDPTR                        (volatile unsigned int *)((0x3424  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_CTRL                         (0x3425)
+#define P_AUDIN_FIFO0_CTRL                         (volatile unsigned int *)((0x3425  << 2) + 0xffd00000)
+    #define AUDIN_FIFO0_EN       0
+    #define AUDIN_FIFO0_RST      1
+    #define AUDIN_FIFO0_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
+
+    #define AUDIN_FIFO0_DIN_SEL  3
+            // 0     spdifIN
+            // 1     i2Sin
+            // 2     PCMIN
+            // 3     HDMI in
+            // 4     DEMODULATOR IN
+    #define AUDIN_FIFO0_ENDIAN   8    //10:8   data endian control.
+    #define AUDIN_FIFO0_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
+    #define AUDIN_FIFO0_UG       15    // urgent request enable.
+    #define AUDIN_FIFO0_HOLD0_EN  19
+    #define AUDIN_FIFO0_HOLD1_EN  20
+    #define AUDIN_FIFO0_HOLD2_EN  21
+    #define AUDIN_FIFO0_HOLD0_SEL 22   // 23:22
+    #define AUDIN_FIFO0_HOLD1_SEL 24   // 25:24
+    #define AUDIN_FIFO0_HOLD2_SEL 26   // 27:26
+    #define AUDIN_FIFO0_HOLD_LVL  28   // 27:26
+
+
+#define   AUDIN_FIFO0_CTRL1                        (0x3426)
+#define P_AUDIN_FIFO0_CTRL1                        (volatile unsigned int *)((0x3426  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_LVL0                         (0x3427)
+#define P_AUDIN_FIFO0_LVL0                         (volatile unsigned int *)((0x3427  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_LVL1                         (0x3428)
+#define P_AUDIN_FIFO0_LVL1                         (volatile unsigned int *)((0x3428  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_LVL2                         (0x3429)
+#define P_AUDIN_FIFO0_LVL2                         (volatile unsigned int *)((0x3429  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_REQID                        (0x3430)
+#define P_AUDIN_FIFO0_REQID                        (volatile unsigned int *)((0x3430  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_WRAP                         (0x3431)
+#define P_AUDIN_FIFO0_WRAP                         (volatile unsigned int *)((0x3431  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_START                        (0x3433)
+#define P_AUDIN_FIFO1_START                        (volatile unsigned int *)((0x3433  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_END                          (0x3434)
+#define P_AUDIN_FIFO1_END                          (volatile unsigned int *)((0x3434  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_PTR                          (0x3435)
+#define P_AUDIN_FIFO1_PTR                          (volatile unsigned int *)((0x3435  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_INTR                         (0x3436)
+#define P_AUDIN_FIFO1_INTR                         (volatile unsigned int *)((0x3436  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_RDPTR                        (0x3437)
+#define P_AUDIN_FIFO1_RDPTR                        (volatile unsigned int *)((0x3437  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_CTRL                         (0x3438)
+#define P_AUDIN_FIFO1_CTRL                         (volatile unsigned int *)((0x3438  << 2) + 0xffd00000)
+    #define AUDIN_FIFO1_EN       0
+    #define AUDIN_FIFO1_RST      1
+    #define AUDIN_FIFO1_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
+
+    #define AUDIN_FIFO1_DIN_SEL  3
+            // 0     spdifIN
+            // 1     i2Sin
+            // 2     PCMIN
+            // 3     HDMI in
+            // 4     DEMODULATOR IN
+    #define AUDIN_FIFO1_ENDIAN   8    //10:8   data endian control.
+    #define AUDIN_FIFO1_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
+    #define AUDIN_FIFO1_UG       15    // urgent request enable.
+    #define AUDIN_FIFO1_HOLD0_EN  19
+    #define AUDIN_FIFO1_HOLD1_EN  20
+    #define AUDIN_FIFO1_HOLD2_EN  21
+    #define AUDIN_FIFO1_HOLD0_SEL 22   // 23:22
+    #define AUDIN_FIFO1_HOLD1_SEL 24   // 25:24
+    #define AUDIN_FIFO1_HOLD2_SEL 26   // 27:26
+    #define AUDIN_FIFO1_HOLD_LVL  28   // 27:26
+#define   AUDIN_FIFO1_CTRL1                        (0x3439)
+#define P_AUDIN_FIFO1_CTRL1                        (volatile unsigned int *)((0x3439  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_LVL0                         (0x3440)
+#define P_AUDIN_FIFO1_LVL0                         (volatile unsigned int *)((0x3440  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_LVL1                         (0x3441)
+#define P_AUDIN_FIFO1_LVL1                         (volatile unsigned int *)((0x3441  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_LVL2                         (0x3442)
+#define P_AUDIN_FIFO1_LVL2                         (volatile unsigned int *)((0x3442  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_REQID                        (0x3443)
+#define P_AUDIN_FIFO1_REQID                        (volatile unsigned int *)((0x3443  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_WRAP                         (0x3444)
+#define P_AUDIN_FIFO1_WRAP                         (volatile unsigned int *)((0x3444  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_START                        (0x3445)
+#define P_AUDIN_FIFO2_START                        (volatile unsigned int *)((0x3445  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_END                          (0x3446)
+#define P_AUDIN_FIFO2_END                          (volatile unsigned int *)((0x3446  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_PTR                          (0x3447)
+#define P_AUDIN_FIFO2_PTR                          (volatile unsigned int *)((0x3447  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_INTR                         (0x3448)
+#define P_AUDIN_FIFO2_INTR                         (volatile unsigned int *)((0x3448  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_RDPTR                        (0x3449)
+#define P_AUDIN_FIFO2_RDPTR                        (volatile unsigned int *)((0x3449  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_CTRL                         (0x344a)
+#define P_AUDIN_FIFO2_CTRL                         (volatile unsigned int *)((0x344a  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_CTRL1                        (0x344b)
+#define P_AUDIN_FIFO2_CTRL1                        (volatile unsigned int *)((0x344b  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_LVL0                         (0x344c)
+#define P_AUDIN_FIFO2_LVL0                         (volatile unsigned int *)((0x344c  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_LVL1                         (0x344d)
+#define P_AUDIN_FIFO2_LVL1                         (volatile unsigned int *)((0x344d  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_LVL2                         (0x344e)
+#define P_AUDIN_FIFO2_LVL2                         (volatile unsigned int *)((0x344e  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_REQID                        (0x344f)
+#define P_AUDIN_FIFO2_REQID                        (volatile unsigned int *)((0x344f  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_WRAP                         (0x3450)
+#define P_AUDIN_FIFO2_WRAP                         (volatile unsigned int *)((0x3450  << 2) + 0xffd00000)
+#define   AUDIN_INT_CTRL                           (0x3451)
+#define P_AUDIN_INT_CTRL                           (volatile unsigned int *)((0x3451  << 2) + 0xffd00000)
+#define   AUDIN_FIFO_INT                           (0x3452)
+#define P_AUDIN_FIFO_INT                           (volatile unsigned int *)((0x3452  << 2) + 0xffd00000)
+#define   PCMIN_CTRL0                              (0x3460)
+#define P_PCMIN_CTRL0                              (volatile unsigned int *)((0x3460  << 2) + 0xffd00000)
+#define   PCMIN_CTRL1                              (0x3461)
+#define P_PCMIN_CTRL1                              (volatile unsigned int *)((0x3461  << 2) + 0xffd00000)
+#define   PCMIN_CTRL2                              (0x3462)
+#define P_PCMIN_CTRL2                              (volatile unsigned int *)((0x3462  << 2) + 0xffd00000)
+//`define PCMIN1_CTRL0                     8'h62
+//`define PCMIN1_CTRL1                     8'h63
+#define   PCMOUT_CTRL0                             (0x3470)
+#define P_PCMOUT_CTRL0                             (volatile unsigned int *)((0x3470  << 2) + 0xffd00000)
+#define   PCMOUT_CTRL1                             (0x3471)
+#define P_PCMOUT_CTRL1                             (volatile unsigned int *)((0x3471  << 2) + 0xffd00000)
+#define   PCMOUT_CTRL2                             (0x3472)
+#define P_PCMOUT_CTRL2                             (volatile unsigned int *)((0x3472  << 2) + 0xffd00000)
+#define   PCMOUT_CTRL3                             (0x3473)
+#define P_PCMOUT_CTRL3                             (volatile unsigned int *)((0x3473  << 2) + 0xffd00000)
+#define   PCMOUT_CTRL4                             (0x3474)
+#define P_PCMOUT_CTRL4                             (volatile unsigned int *)((0x3474  << 2) + 0xffd00000)
+//`define PCMOUT1_CTRL0                    8'h74
+//`define PCMOUT1_CTRL1                    8'h75
+//`define PCMOUT1_CTRL2                    8'h76
+//`define PCMOUT1_CTRL3                    8'h77
+#define   AUDOUT_CTRL                              (0x3480)
+#define P_AUDOUT_CTRL                              (volatile unsigned int *)((0x3480  << 2) + 0xffd00000)
+#define   AUDOUT_CTRL1                             (0x3481)
+#define P_AUDOUT_CTRL1                             (volatile unsigned int *)((0x3481  << 2) + 0xffd00000)
+#define   AUDOUT_BUF0_STA                          (0x3482)
+#define P_AUDOUT_BUF0_STA                          (volatile unsigned int *)((0x3482  << 2) + 0xffd00000)
+#define   AUDOUT_BUF0_EDA                          (0x3483)
+#define P_AUDOUT_BUF0_EDA                          (volatile unsigned int *)((0x3483  << 2) + 0xffd00000)
+#define   AUDOUT_BUF0_WPTR                         (0x3484)
+#define P_AUDOUT_BUF0_WPTR                         (volatile unsigned int *)((0x3484  << 2) + 0xffd00000)
+#define   AUDOUT_BUF1_STA                          (0x3485)
+#define P_AUDOUT_BUF1_STA                          (volatile unsigned int *)((0x3485  << 2) + 0xffd00000)
+#define   AUDOUT_BUF1_EDA                          (0x3486)
+#define P_AUDOUT_BUF1_EDA                          (volatile unsigned int *)((0x3486  << 2) + 0xffd00000)
+#define   AUDOUT_BUF1_WPTR                         (0x3487)
+#define P_AUDOUT_BUF1_WPTR                         (volatile unsigned int *)((0x3487  << 2) + 0xffd00000)
+#define   AUDOUT_FIFO_RPTR                         (0x3488)
+#define P_AUDOUT_FIFO_RPTR                         (volatile unsigned int *)((0x3488  << 2) + 0xffd00000)
+#define   AUDOUT_INTR_PTR                          (0x3489)
+#define P_AUDOUT_INTR_PTR                          (volatile unsigned int *)((0x3489  << 2) + 0xffd00000)
+#define   AUDOUT_FIFO_STS                          (0x348a)
+#define P_AUDOUT_FIFO_STS                          (volatile unsigned int *)((0x348a  << 2) + 0xffd00000)
+//`define AUDOUT1_CTRL                     8'h90
+//`define AUDOUT1_CTRL1                    8'h91
+//`define AUDOUT1_BUF0_STA                 8'h92
+//`define AUDOUT1_BUF0_EDA                 8'h93
+//`define AUDOUT1_BUF0_WPTR                8'h94
+//`define AUDOUT1_BUF1_STA                 8'h95
+//`define AUDOUT1_BUF1_EDA                 8'h96
+//`define AUDOUT1_BUF1_WPTR                8'h97
+//`define AUDOUT1_FIFO_RPTR                8'h98
+//`define AUDOUT1_INTR_PTR                 8'h99
+//`define AUDOUT1_FIFO_STS                 8'h9a
+//// Bit 31: 0 RW cntl_mute_val: Use this value during mute, if cntl_mute_mode=2.
+//`define AUDIN_MUTE_VAL                 8'h35
+#define   AUDIN_HDMI_MEAS_CTRL                     (0x34a0)
+#define P_AUDIN_HDMI_MEAS_CTRL                     (volatile unsigned int *)((0x34a0  << 2) + 0xffd00000)
+#define   AUDIN_HDMI_MEAS_CYCLES_M1                (0x34a1)
+#define P_AUDIN_HDMI_MEAS_CYCLES_M1                (volatile unsigned int *)((0x34a1  << 2) + 0xffd00000)
+#define   AUDIN_HDMI_MEAS_INTR_MASKN               (0x34a2)
+#define P_AUDIN_HDMI_MEAS_INTR_MASKN               (volatile unsigned int *)((0x34a2  << 2) + 0xffd00000)
+#define   AUDIN_HDMI_MEAS_INTR_STAT                (0x34a3)
+#define P_AUDIN_HDMI_MEAS_INTR_STAT                (volatile unsigned int *)((0x34a3  << 2) + 0xffd00000)
+#define   AUDIN_HDMI_REF_CYCLES_STAT_0             (0x34a4)
+#define P_AUDIN_HDMI_REF_CYCLES_STAT_0             (volatile unsigned int *)((0x34a4  << 2) + 0xffd00000)
+#define   AUDIN_HDMI_REF_CYCLES_STAT_1             (0x34a5)
+#define P_AUDIN_HDMI_REF_CYCLES_STAT_1             (volatile unsigned int *)((0x34a5  << 2) + 0xffd00000)
+#define   AUDIN_HDMIRX_AFIFO_STAT                  (0x34a6)
+#define P_AUDIN_HDMIRX_AFIFO_STAT                  (volatile unsigned int *)((0x34a6  << 2) + 0xffd00000)
+#define   AUDIN_MEM_PD                             (0x34aa)
+#define P_AUDIN_MEM_PD                             (volatile unsigned int *)((0x34aa  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_PIO_STS                      (0x34b0)
+#define P_AUDIN_FIFO0_PIO_STS                      (volatile unsigned int *)((0x34b0  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_PIO_RDL                      (0x34b1)
+#define P_AUDIN_FIFO0_PIO_RDL                      (volatile unsigned int *)((0x34b1  << 2) + 0xffd00000)
+#define   AUDIN_FIFO0_PIO_RDH                      (0x34b2)
+#define P_AUDIN_FIFO0_PIO_RDH                      (volatile unsigned int *)((0x34b2  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_PIO_STS                      (0x34b3)
+#define P_AUDIN_FIFO1_PIO_STS                      (volatile unsigned int *)((0x34b3  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_PIO_RDL                      (0x34b4)
+#define P_AUDIN_FIFO1_PIO_RDL                      (volatile unsigned int *)((0x34b4  << 2) + 0xffd00000)
+#define   AUDIN_FIFO1_PIO_RDH                      (0x34b5)
+#define P_AUDIN_FIFO1_PIO_RDH                      (volatile unsigned int *)((0x34b5  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_PIO_STS                      (0x34b6)
+#define P_AUDIN_FIFO2_PIO_STS                      (volatile unsigned int *)((0x34b6  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_PIO_RDL                      (0x34b7)
+#define P_AUDIN_FIFO2_PIO_RDL                      (volatile unsigned int *)((0x34b7  << 2) + 0xffd00000)
+#define   AUDIN_FIFO2_PIO_RDH                      (0x34b8)
+#define P_AUDIN_FIFO2_PIO_RDH                      (volatile unsigned int *)((0x34b8  << 2) + 0xffd00000)
+#define   AUDOUT_FIFO_PIO_STS                      (0x34b9)
+#define P_AUDOUT_FIFO_PIO_STS                      (volatile unsigned int *)((0x34b9  << 2) + 0xffd00000)
+#define   AUDOUT_FIFO_PIO_WRL                      (0x34ba)
+#define P_AUDOUT_FIFO_PIO_WRL                      (volatile unsigned int *)((0x34ba  << 2) + 0xffd00000)
+#define   AUDOUT_FIFO_PIO_WRH                      (0x34bb)
+#define P_AUDOUT_FIFO_PIO_WRH                      (volatile unsigned int *)((0x34bb  << 2) + 0xffd00000)
+//`define AUDOUT1_FIFO_PIO_STS		8'hbc
+//`define AUDOUT1_FIFO_PIO_WRL        	8'hbd
+//`define AUDOUT1_FIFO_PIO_WRH        	8'hbe
+#define   AUD_RESAMPLE_CTRL0                       (0x34bf)
+#define P_AUD_RESAMPLE_CTRL0                       (volatile unsigned int *)((0x34bf  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_CTRL1                       (0x34c0)
+#define P_AUD_RESAMPLE_CTRL1                       (volatile unsigned int *)((0x34c0  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_STATUS                      (0x34c1)
+#define P_AUD_RESAMPLE_STATUS                      (volatile unsigned int *)((0x34c1  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_CTRL2                       (0x34c2)
+#define P_AUD_RESAMPLE_CTRL2                       (volatile unsigned int *)((0x34c2  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_COEF0                       (0x34c3)
+#define P_AUD_RESAMPLE_COEF0                       (volatile unsigned int *)((0x34c3  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_COEF1                       (0x34c4)
+#define P_AUD_RESAMPLE_COEF1                       (volatile unsigned int *)((0x34c4  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_COEF2                       (0x34c5)
+#define P_AUD_RESAMPLE_COEF2                       (volatile unsigned int *)((0x34c5  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_COEF3                       (0x34c6)
+#define P_AUD_RESAMPLE_COEF3                       (volatile unsigned int *)((0x34c6  << 2) + 0xffd00000)
+#define   AUD_RESAMPLE_COEF4                       (0x34c7)
+#define P_AUD_RESAMPLE_COEF4                       (volatile unsigned int *)((0x34c7  << 2) + 0xffd00000)
+#define   AUDIN_ADDR_END                           (0x34c8)
+#define P_AUDIN_ADDR_END                           (volatile unsigned int *)((0x34c8  << 2) + 0xffd00000)
+#define   AUDIN_ATV_DEMOD_CTRL                     (0x34d0)
+#define P_AUDIN_ATV_DEMOD_CTRL                     (volatile unsigned int *)((0x34d0  << 2) + 0xffd00000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./register_map.h
+//
+//
+// Reading file:  ./vcbus_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+//`define RDMA_VCBUS_BASE       8'h11
+//===========================================================================
+//
+// Reading file:  rdma_regs.h
+//
+//===========================================================================
+// RDMA registers 0x00 - 0xff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  RDMA_VCBUS_BASE = 0x11
+// -----------------------------------------------
+// Bit 31: 0 RW AHB start address for manual start DMA
+#define   RDMA_AHB_START_ADDR_MAN                  (0x1100)
+#define P_RDMA_AHB_START_ADDR_MAN                  (volatile unsigned int *)((0x1100  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for manual start DMA
+#define   RDMA_AHB_END_ADDR_MAN                    (0x1101)
+#define P_RDMA_AHB_END_ADDR_MAN                    (volatile unsigned int *)((0x1101  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 1
+#define   RDMA_AHB_START_ADDR_1                    (0x1102)
+#define P_RDMA_AHB_START_ADDR_1                    (volatile unsigned int *)((0x1102  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 1
+#define   RDMA_AHB_END_ADDR_1                      (0x1103)
+#define P_RDMA_AHB_END_ADDR_1                      (volatile unsigned int *)((0x1103  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 2
+#define   RDMA_AHB_START_ADDR_2                    (0x1104)
+#define P_RDMA_AHB_START_ADDR_2                    (volatile unsigned int *)((0x1104  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 2
+#define   RDMA_AHB_END_ADDR_2                      (0x1105)
+#define P_RDMA_AHB_END_ADDR_2                      (volatile unsigned int *)((0x1105  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 3
+#define   RDMA_AHB_START_ADDR_3                    (0x1106)
+#define P_RDMA_AHB_START_ADDR_3                    (volatile unsigned int *)((0x1106  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 3
+#define   RDMA_AHB_END_ADDR_3                      (0x1107)
+#define P_RDMA_AHB_END_ADDR_3                      (volatile unsigned int *)((0x1107  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 4
+#define   RDMA_AHB_START_ADDR_4                    (0x1108)
+#define P_RDMA_AHB_START_ADDR_4                    (volatile unsigned int *)((0x1108  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 4
+#define   RDMA_AHB_END_ADDR_4                      (0x1109)
+#define P_RDMA_AHB_END_ADDR_4                      (volatile unsigned int *)((0x1109  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 5
+#define   RDMA_AHB_START_ADDR_5                    (0x110a)
+#define P_RDMA_AHB_START_ADDR_5                    (volatile unsigned int *)((0x110a  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 5
+#define   RDMA_AHB_END_ADDR_5                      (0x110b)
+#define P_RDMA_AHB_END_ADDR_5                      (volatile unsigned int *)((0x110b  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 6
+#define   RDMA_AHB_START_ADDR_6                    (0x110c)
+#define P_RDMA_AHB_START_ADDR_6                    (volatile unsigned int *)((0x110c  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 6
+#define   RDMA_AHB_END_ADDR_6                      (0x110d)
+#define P_RDMA_AHB_END_ADDR_6                      (volatile unsigned int *)((0x110d  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB start address for auto start source 7
+#define   RDMA_AHB_START_ADDR_7                    (0x110e)
+#define P_RDMA_AHB_START_ADDR_7                    (volatile unsigned int *)((0x110e  << 2) + 0xff900000)
+// Bit 31: 0 RW AHB end address for auto start source 7
+#define   RDMA_AHB_END_ADDR_7                      (0x110f)
+#define P_RDMA_AHB_END_ADDR_7                      (volatile unsigned int *)((0x110f  << 2) + 0xff900000)
+// Auto start DMA control:
+// Bit 31:24 RW ctrl_enable_int_3. Interrupt inputs enable mask for source 3.
+// Bit 23:16 RW ctrl_enable_int_2. Interrupt inputs enable mask for source 2.
+// Bit 15: 8 RW ctrl_enable_int_1. Interrupt inputs enable mask for source 1.
+// Bit     7 RW ctrl_cbus_write_3. Register read/write mode for auto-start 3. 1=Register write; 0=Register read.
+// Bit     6 RW ctrl_cbus_write_3. Register read/write mode for auto-start 2. 1=Register write; 0=Register read.
+// Bit     5 RW ctrl_cbus_write_3. Register read/write mode for auto-start 1. 1=Register write; 0=Register read.
+// Bit     4 R  Rsrv.
+// Bit     3 RW ctrl_cbus_addr_incr_3. 1=Incremental register access for auto-start 3; 0=Non-incremental (individual) register access.
+// Bit     2 RW ctrl_cbus_addr_incr_2. 1=Incremental register access for auto-start 2; 0=Non-incremental (individual) register access.
+// Bit     1 RW ctrl_cbus_addr_incr_1. 1=Incremental register access for auto-start 1; 0=Non-incremental (individual) register access.
+// Bit     0 R  Rsrv.
+#define   RDMA_ACCESS_AUTO                         (0x1110)
+#define P_RDMA_ACCESS_AUTO                         (volatile unsigned int *)((0x1110  << 2) + 0xff900000)
+#define   RDMA_ACCESS_AUTO2                        (0x1111)
+#define P_RDMA_ACCESS_AUTO2                        (volatile unsigned int *)((0x1111  << 2) + 0xff900000)
+#define   RDMA_ACCESS_AUTO3                        (0x1112)
+#define P_RDMA_ACCESS_AUTO3                        (volatile unsigned int *)((0x1112  << 2) + 0xff900000)
+// Manual start DMA control:
+// Bit 31: 3 R  Rsrv.
+// Bit     2 RW ctrl_cbus_write_man. Register read/write mode for manual-start. 1=Register write; 0=Register read.
+// Bit     1 RW ctrl_cbus_addr_incr_man. 1=Incremental register access for manual-start; 0=Non-incremental (individual) register access.
+// Bit     0 W  ctrl_start_man. Write 1 to this bit to manual-start DMA. This bit always read back 0.
+#define   RDMA_ACCESS_MAN                          (0x1113)
+#define P_RDMA_ACCESS_MAN                          (volatile unsigned int *)((0x1113  << 2) + 0xff900000)
+// RDMA general control:
+// Bit 31:25 R  Rsrv.
+// Bit    24 W  ctrl_clr_rdma_done_int. Write 1 to reset rdma_int level to 0. No need to clear this bit.
+// Bit 23:19 R  Rsrv.
+// Bit 18:13 R  Rsrv.
+// Bit 12: 7 R  Rsrv.
+// Bit     6 RW ctrl_ddr_urgent.
+// Bit  5: 4 RW ctrl_ahb_wr_burst_size. 0=ABH write request burst size 16;
+//                                      1=ABH write request burst size 24;
+//                                      2=ABH write request burst size 32;
+//                                      3=ABH write request burst size 48.
+// Bit  3: 2 RW ctrl_ahb_rd_burst_size. 0=ABH read request burst size 16;
+//                                      1=ABH read request burst size 24;
+//                                      2=ABH read request burst size 32;
+//                                      3=ABH read request burst size 48.
+// Bit     1 RW ctrl_sw_reset. 1=Reset RDMA logics except register.
+// Bit     0 RW ctrl_free_clk_enable. 0=Default, Enable clock gating. 1=No clock gating, enable free clock.
+#define   RDMA_CTRL                                (0x1114)
+#define P_RDMA_CTRL                                (volatile unsigned int *)((0x1114  << 2) + 0xff900000)
+// Read only.
+// Bit 31:29 R  Rsrv.
+// Bit    28 R  rdma_done_int.
+// Bit 27:25 R  Rsrv.
+// Bit 24:18 R  ahb_wrfifo_cnt. FIFO for buffering CBus read data to be sent to AHB
+// Bit 17:11 R  ahb_rdfifo_cnt. FIFO for buffering data read from AHB.
+// Bit 10: 8 R  ddr_req_st. =0 -- Idle; !=0 -- AHB interfacing ongoing.
+// Bit  7: 4 R  curr_req. Latest requests that is being/been serviced. E.g. 0000=Idle; 0010=Latest serviced request is Req 1.
+// Bit  3: 0 R  req_latch. Requests that are yet to be serviced. E.g. 0000=No request; 0001=Req 0 waiting; 1100=Req 2 and 3 waiting.
+#define   RDMA_STATUS                              (0x1115)
+#define P_RDMA_STATUS                              (volatile unsigned int *)((0x1115  << 2) + 0xff900000)
+#define   RDMA_STATUS2                             (0x1116)
+#define P_RDMA_STATUS2                             (volatile unsigned int *)((0x1116  << 2) + 0xff900000)
+#define   RDMA_STATUS3                             (0x1117)
+#define P_RDMA_STATUS3                             (volatile unsigned int *)((0x1117  << 2) + 0xff900000)
+#define   RDMA_ACCESS_AUTO4                        (0x1118)
+#define P_RDMA_ACCESS_AUTO4                        (volatile unsigned int *)((0x1118  << 2) + 0xff900000)
+#define   RDMA_SRAM_CNTL                           (0x1120)
+#define P_RDMA_SRAM_CNTL                           (volatile unsigned int *)((0x1120  << 2) + 0xff900000)
+#define   RDMA_SRAM_REGADDR                        (0x1121)
+#define P_RDMA_SRAM_REGADDR                        (volatile unsigned int *)((0x1121  << 2) + 0xff900000)
+#define   RDMA_SRAM_REGDATA                        (0x1122)
+#define P_RDMA_SRAM_REGDATA                        (volatile unsigned int *)((0x1122  << 2) + 0xff900000)
+//
+// Closing file:  rdma_regs.h
+//
+//===========================================================================
+// VDIN
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VDIN_VCBUS_BASE = 0x12
+// -----------------------------------------------
+//VDIN0        8'h00 - 8'h7f
+//VDIN1        8'h80 - 8'hef
+#define VDIN0_OFFSET            0x00
+#define VDIN1_OFFSET            0x80
+
+#define   VDIN_SCALE_COEF_IDX                      (0x1200)
+#define P_VDIN_SCALE_COEF_IDX                      (volatile unsigned int *)((0x1200  << 2) + 0xff900000)
+#define   VDIN_SCALE_COEF                          (0x1201)
+#define P_VDIN_SCALE_COEF                          (volatile unsigned int *)((0x1201  << 2) + 0xff900000)
+//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
+//bit 30,   mpeg_field info which can be written by software
+//Bit 29,   force go_field, pulse signal
+//Bit 28,   force go_line, pulse signal
+//Bit 27,   enable mpeg_go_field input signal
+//Bit 26:20, hold lines
+//Bit 19,   delay go_field function enable
+//Bit 18:12, delay go_field line number
+//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
+//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
+//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
+//Bit 5,   input window selection function enable
+//Bit 4, enable VDIN common data input, otherwise there will be no video data input
+//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: bt656 input, 3: component input, 4: tvdecoder input, 5: hdmi rx input, 6: digtial video input, 7: loopback from Viu1, 8: MIPI.
+#define   VDIN_COM_CTRL0                           (0x1202)
+#define P_VDIN_COM_CTRL0                           (volatile unsigned int *)((0x1202  << 2) + 0xff900000)
+//Bit 28:16 active_max_pix_cnt, readonly
+//Bit 12:0  active_max_pix_cnt_shadow, readonly
+#define   VDIN_ACTIVE_MAX_PIX_CNT_STATUS           (0x1203)
+#define P_VDIN_ACTIVE_MAX_PIX_CNT_STATUS           (volatile unsigned int *)((0x1203  << 2) + 0xff900000)
+//Bit 28:16 go_line_cnt, readonly
+//Bit 12:0  active_line_cnt, readonly
+#define   VDIN_LCNT_STATUS                         (0x1204)
+#define P_VDIN_LCNT_STATUS                         (volatile unsigned int *)((0x1204  << 2) + 0xff900000)
+//Readonly
+//Bit [14:3] lfifo_buf_cnt
+//Bit 2, vdin_direct_done status
+//Bit 1, vdin_nr_done status
+//Bit 0, field
+#define   VDIN_COM_STATUS0                         (0x1205)
+#define P_VDIN_COM_STATUS0                         (volatile unsigned int *)((0x1205  << 2) + 0xff900000)
+//Readonly
+//Bit 31, vdi4 fifo overflow
+//Bit 29:24, vdi3_asfifo_cnt
+//Bit 23, vdi3 fifo overflow
+//Bit 21:16, vdi3_asfifo_cnt
+//Bit 15, vdi2 fifo overflow
+//Bit 13:8, vdi2_asfifo_cnt
+//Bit 7, vdi1 fifo overflow
+//Bit 5:0, vdi1_asfifo_cnt
+#define   VDIN_COM_STATUS1                         (0x1206)
+#define P_VDIN_COM_STATUS1                         (volatile unsigned int *)((0x1206  << 2) + 0xff900000)
+//Bit 28:16 go_line_cnt_shadow, readonly
+//Bit 12:0  active_line_cnt_shadow, readonly
+#define   VDIN_LCNT_SHADOW_STATUS                  (0x1207)
+#define P_VDIN_LCNT_SHADOW_STATUS                  (volatile unsigned int *)((0x1207  << 2) + 0xff900000)
+//each 8bit asfifo_ctrl is following:
+//Bit 7, DE  enable
+//Bit 6, go field enable
+//Bit 5, go line enable
+//Bit 4, if true, negative active input vsync
+//Bit 3, if true, negative active input hsync
+//Bit 2, vsync soft reset fifo enable
+//Bit 1, overflow status clear
+//Bit 0 asfifo soft reset, level signal
+//Bit 7:0 vdi1 asfifo_ctrl
+//Bit 23:16 vdi2 asfifo_ctrl
+#define   VDIN_ASFIFO_CTRL0                        (0x1208)
+#define P_VDIN_ASFIFO_CTRL0                        (volatile unsigned int *)((0x1208  << 2) + 0xff900000)
+//Bit 7:0 vdi3 asfifo_ctrl
+//Bit 23:16 vdi4 asfifo_ctrl
+#define   VDIN_ASFIFO_CTRL1                        (0x1209)
+#define P_VDIN_ASFIFO_CTRL1                        (volatile unsigned int *)((0x1209  << 2) + 0xff900000)
+//Bit 28:16 input width minus 1, after the window function
+//Bit 12:0  output width minus 1
+#define   VDIN_WIDTHM1I_WIDTHM1O                   (0x120a)
+#define P_VDIN_WIDTHM1I_WIDTHM1O                   (volatile unsigned int *)((0x120a  << 2) + 0xff900000)
+//Bit 20:17 prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
+//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
+//Bit 16:15 sp422_mode, special mode for the component1 and component2, 00: normal case, 01: 32 64 32, 10: 0 64 64 0, 11: 16 96 16
+//Bit 14:8, hsc_ini_pixi_ptr, signed data, only useful when short_lineo_en is true
+//Bit 7, prehsc_en
+//Bit 6, hsc_en,
+//Bit 5, hsc_short_lineo_en, short line output enable
+//Bit 4, hsc_nearest_en
+//Bit 3, hsc_phase0_always_en
+//Bit 2:0, hsc_bank_length
+#define   VDIN_SC_MISC_CTRL                        (0x120b)
+#define P_VDIN_SC_MISC_CTRL                        (volatile unsigned int *)((0x120b  << 2) + 0xff900000)
+//Bit 28:24, integer portion
+//Bit 23:0, fraction portion
+#define   VDIN_HSC_PHASE_STEP                      (0x120c)
+#define P_VDIN_HSC_PHASE_STEP                      (volatile unsigned int *)((0x120c  << 2) + 0xff900000)
+//Bit 30:29    hscale rpt_p0_num
+//Bit 28:24    hscale ini_rcv_num
+//Bit 23:0     hscale ini_phase
+#define   VDIN_HSC_INI_CTRL                        (0x120d)
+#define P_VDIN_HSC_INI_CTRL                        (volatile unsigned int *)((0x120d  << 2) + 0xff900000)
+//Read only
+//Bit 23, vdi7 fifo overflow
+//Bit 21:16, vdi7_asfifo_cnt
+//Bit 15, vdi6 fifo overflow
+//Bit 13:8, vdi6_asfifo_cnt
+//Bit 7, vdi5 fifo overflow
+//Bit 5:0, vdi5_asfifo_cnt
+#define   VDIN_COM_STATUS2                         (0x120e)
+#define P_VDIN_COM_STATUS2                         (volatile unsigned int *)((0x120e  << 2) + 0xff900000)
+//Bit 25:16 asfifo decimate control
+//Bit 25, if true, decimation counter sync with first valid DE in the field,
+//otherwise the decimation counter is not sync with external signal
+//Bit 24, decimation de enable
+//Bit 23:20, decimation phase, which counter value use to decimate,
+//Bit 19:16, decimation number, 0: not decimation, 1: decimation 2, 2: decimation 3 ....
+//Bit 7:0 vdi5 asfifo_ctrl
+#define   VDIN_ASFIFO_CTRL2                        (0x120f)
+#define P_VDIN_ASFIFO_CTRL2                        (volatile unsigned int *)((0x120f  << 2) + 0xff900000)
+//Bit 7,  highlight_en
+//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
+//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
+//Bit 1   mat1 conversion matrix enable
+//Bit 0   mat0 conversion matrix enable
+#define   VDIN_MATRIX_CTRL                         (0x1210)
+#define P_VDIN_MATRIX_CTRL                         (volatile unsigned int *)((0x1210  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VDIN_MATRIX_COEF00_01                    (0x1211)
+#define P_VDIN_MATRIX_COEF00_01                    (volatile unsigned int *)((0x1211  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VDIN_MATRIX_COEF02_10                    (0x1212)
+#define P_VDIN_MATRIX_COEF02_10                    (volatile unsigned int *)((0x1212  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VDIN_MATRIX_COEF11_12                    (0x1213)
+#define P_VDIN_MATRIX_COEF11_12                    (volatile unsigned int *)((0x1213  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VDIN_MATRIX_COEF20_21                    (0x1214)
+#define P_VDIN_MATRIX_COEF20_21                    (volatile unsigned int *)((0x1214  << 2) + 0xff900000)
+//BIt 18:16 conv_rs
+//Bit 12:0  coef22
+#define   VDIN_MATRIX_COEF22                       (0x1215)
+#define P_VDIN_MATRIX_COEF22                       (volatile unsigned int *)((0x1215  << 2) + 0xff900000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define   VDIN_MATRIX_OFFSET0_1                    (0x1216)
+#define P_VDIN_MATRIX_OFFSET0_1                    (volatile unsigned int *)((0x1216  << 2) + 0xff900000)
+//Bit 10:0  offset2
+#define   VDIN_MATRIX_OFFSET2                      (0x1217)
+#define P_VDIN_MATRIX_OFFSET2                      (volatile unsigned int *)((0x1217  << 2) + 0xff900000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define   VDIN_MATRIX_PRE_OFFSET0_1                (0x1218)
+#define P_VDIN_MATRIX_PRE_OFFSET0_1                (volatile unsigned int *)((0x1218  << 2) + 0xff900000)
+//Bit 10:0  pre_offset2
+#define   VDIN_MATRIX_PRE_OFFSET2                  (0x1219)
+#define P_VDIN_MATRIX_PRE_OFFSET2                  (volatile unsigned int *)((0x1219  << 2) + 0xff900000)
+//12:0 lfifo_buf_size
+#define   VDIN_LFIFO_CTRL                          (0x121a)
+#define P_VDIN_LFIFO_CTRL                          (volatile unsigned int *)((0x121a  << 2) + 0xff900000)
+#define   VDIN_COM_GCLK_CTRL                       (0x121b)
+#define P_VDIN_COM_GCLK_CTRL                       (volatile unsigned int *)((0x121b  << 2) + 0xff900000)
+//12:0 VDIN input interface width minus 1, before the window function, after the de decimation
+#define   VDIN_INTF_WIDTHM1                        (0x121c)
+#define P_VDIN_INTF_WIDTHM1                        (volatile unsigned int *)((0x121c  << 2) + 0xff900000)
+//Bit 15          //default== 0, urgent_ctrl_en
+//Bit 14          //default== 0, urgent_wr, if true for write buffer
+//Bit 13          //default== 0, out_inv_en
+//Bit 12          //default == 0, urgent_ini_value
+//Bit 11:6        //default == 0, up_th  up threshold
+//Bit 5:0         //default == 0, dn_th  dn threshold
+#define   VDIN_LFIFO_URG_CTRL                      (0x121e)
+#define P_VDIN_LFIFO_URG_CTRL                      (volatile unsigned int *)((0x121e  << 2) + 0xff900000)
+//Bit 8, 1: discard data before line fifo, 0: normal mode
+//Bit 7:0 Write chroma canvas address
+#define   VDIN_WR_CTRL2                            (0x121f)
+#define P_VDIN_WR_CTRL2                            (volatile unsigned int *)((0x121f  << 2) + 0xff900000)
+//Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2. 0: Output every even pixels' CbCr;
+//                                                            1: Output every odd pixels' CbCr;
+//                                                            2: Output an average value per even&odd pair of pixels;
+//                                                            3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
+//Bit 29 no_clk_gate: disable vid_wr_mif clock gating function.
+//Bit 28 clear write response counter in the vdin write memory interface
+//Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line end indication in the vdin write memory interface
+//Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1.
+//Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1.
+//Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1.
+//Bit 23 vdin frame reset enble, if true, it will provide frame reset during go_field(vsync) to the modules after that
+//Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will reset during go_field (vsync)
+//Bit 21 vdin direct write done status clear bit
+//Bit 20 vdin NR write done status clear bit
+//Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12); 1: Output CrCb (NV21).
+//Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even lines' CbCr;
+//                                                       1: Output every odd lines' CbCr;
+//                                                       2: Reserved;
+//                                                       3: Output all CbCr.
+//Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4 to luma canvas,
+//                             2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit 31:30, 17:16, and bit 18.
+//Bit 11 vdin write canvas double buffer enable, means the canvas address will be latched by vsync before using
+//Bit 10 1: disable ctrl_reg write pulse which will reset internal counter. when bit 11 is 1, this bit should be 1.
+//Bit 9 vdin write request urgent
+//Bit 8 vdin write request enable
+//Bit 7:0 Write luma canvas address
+#define   VDIN_WR_CTRL                             (0x1220)
+#define P_VDIN_WR_CTRL                             (volatile unsigned int *)((0x1220  << 2) + 0xff900000)
+//Bit 29, if true, horizontal reverse
+//Bit 28:16 start
+//Bit 12:0  end
+#define   VDIN_WR_H_START_END                      (0x1221)
+#define P_VDIN_WR_H_START_END                      (volatile unsigned int *)((0x1221  << 2) + 0xff900000)
+//Bit 29, if true, vertical reverse
+//Bit 28:16 start
+//Bit 12:0  end
+#define   VDIN_WR_V_START_END                      (0x1222)
+#define P_VDIN_WR_V_START_END                      (volatile unsigned int *)((0x1222  << 2) + 0xff900000)
+//Bit 24:20, integer portion
+//Bit 19:0, fraction portion
+#define   VDIN_VSC_PHASE_STEP                      (0x1223)
+#define P_VDIN_VSC_PHASE_STEP                      (volatile unsigned int *)((0x1223  << 2) + 0xff900000)
+//Bit 23, vsc_en, vertical scaler enable
+//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
+//Bit 20:16 ini skip_line_num
+//Bit 15:0 vscaler ini_phase
+#define   VDIN_VSC_INI_CTRL                        (0x1224)
+#define P_VDIN_VSC_INI_CTRL                        (volatile unsigned int *)((0x1224  << 2) + 0xff900000)
+//Bit 28:16, vshrink input height minus 1
+//Bit 12:0, scaler input height minus 1
+#define   VDIN_SCIN_HEIGHTM1                       (0x1225)
+#define P_VDIN_SCIN_HEIGHTM1                       (volatile unsigned int *)((0x1225  << 2) + 0xff900000)
+//Bit 23:16, dummy component 0
+//Bit 15:8, dummy component 1
+//Bit 7:0, dummy component 2
+#define   VDIN_DUMMY_DATA                          (0x1226)
+#define P_VDIN_DUMMY_DATA                          (volatile unsigned int *)((0x1226  << 2) + 0xff900000)
+//Read only
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define   VDIN_MATRIX_PROBE_COLOR                  (0x1228)
+#define P_VDIN_MATRIX_PROBE_COLOR                  (volatile unsigned int *)((0x1228  << 2) + 0xff900000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define   VDIN_MATRIX_HL_COLOR                     (0x1229)
+#define P_VDIN_MATRIX_HL_COLOR                     (volatile unsigned int *)((0x1229  << 2) + 0xff900000)
+//28:16 probe x, postion
+//12:0  probe y, position
+#define   VDIN_MATRIX_PROBE_POS                    (0x122a)
+#define P_VDIN_MATRIX_PROBE_POS                    (volatile unsigned int *)((0x122a  << 2) + 0xff900000)
+#define   VDIN_CHROMA_ADDR_PORT                    (0x122b)
+#define P_VDIN_CHROMA_ADDR_PORT                    (volatile unsigned int *)((0x122b  << 2) + 0xff900000)
+#define   VDIN_CHROMA_DATA_PORT                    (0x122c)
+#define P_VDIN_CHROMA_DATA_PORT                    (volatile unsigned int *)((0x122c  << 2) + 0xff900000)
+//
+#define   VDIN_CM_BRI_CON_CTRL                     (0x122d)
+#define P_VDIN_CM_BRI_CON_CTRL                     (volatile unsigned int *)((0x122d  << 2) + 0xff900000)
+//Bit 17  clk_cyc_cnt_clr, if true, clear this register
+//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt
+//Bit 15:0   line width using vpu clk
+#define   VDIN_GO_LINE_CTRL                        (0x122f)
+#define P_VDIN_GO_LINE_CTRL                        (volatile unsigned int *)((0x122f  << 2) + 0xff900000)
+//Bit 31:24 hist_pix_white_th, larger than this th is counted as white pixel
+//Bit 23:16 hist_pix_black_th, less than this th is counted as black pixel
+//Bit 11    hist_34bin_only,   34 bin only mode, including white/black
+//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
+//Bit 8     ldim_stts_en
+//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
+//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
+//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
+//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
+#define   VDIN_HIST_CTRL                           (0x1230)
+#define P_VDIN_HIST_CTRL                           (volatile unsigned int *)((0x1230  << 2) + 0xff900000)
+//Bit 28:16 hist_hstart  horizontal start value to define hist window
+//Bit 12:0  hist_hend    horizontal end value to define hist window
+#define   VDIN_HIST_H_START_END                    (0x1231)
+#define P_VDIN_HIST_H_START_END                    (volatile unsigned int *)((0x1231  << 2) + 0xff900000)
+//Bit 28:16 hist_vstart  vertical start value to define hist window
+//Bit 12:0  hist_vend    vertical end value to define hist window
+#define   VDIN_HIST_V_START_END                    (0x1232)
+#define P_VDIN_HIST_V_START_END                    (volatile unsigned int *)((0x1232  << 2) + 0xff900000)
+//Bit 15:8  hist_max    maximum value
+//Bit 7:0   hist_min    minimum value
+//read only
+#define   VDIN_HIST_MAX_MIN                        (0x1233)
+#define P_VDIN_HIST_MAX_MIN                        (volatile unsigned int *)((0x1233  << 2) + 0xff900000)
+//Bit 31:0  hist_spl_rd
+//counts for the total luma value
+//read only
+#define   VDIN_HIST_SPL_VAL                        (0x1234)
+#define P_VDIN_HIST_SPL_VAL                        (volatile unsigned int *)((0x1234  << 2) + 0xff900000)
+//Bit 21:0  hist_spl_pixel_count
+//counts for the total calculated pixels
+//read only
+#define   VDIN_HIST_SPL_PIX_CNT                    (0x1235)
+#define P_VDIN_HIST_SPL_PIX_CNT                    (volatile unsigned int *)((0x1235  << 2) + 0xff900000)
+//Bit 31:0  hist_chroma_sum
+//counts for the total chroma value
+//read only
+#define   VDIN_HIST_CHROMA_SUM                     (0x1236)
+#define P_VDIN_HIST_CHROMA_SUM                     (volatile unsigned int *)((0x1236  << 2) + 0xff900000)
+//Bit 31:16 higher hist bin
+//Bit 15:0  lower hist bin
+//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
+//are the statistic number of pixels that within each bin.
+//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
+//VDIN_DNLP_HIST00[31:16] counts for the second bin
+//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
+//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
+//etc...
+//read only
+#define   VDIN_DNLP_HIST00                         (0x1237)
+#define P_VDIN_DNLP_HIST00                         (volatile unsigned int *)((0x1237  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST01                         (0x1238)
+#define P_VDIN_DNLP_HIST01                         (volatile unsigned int *)((0x1238  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST02                         (0x1239)
+#define P_VDIN_DNLP_HIST02                         (volatile unsigned int *)((0x1239  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST03                         (0x123a)
+#define P_VDIN_DNLP_HIST03                         (volatile unsigned int *)((0x123a  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST04                         (0x123b)
+#define P_VDIN_DNLP_HIST04                         (volatile unsigned int *)((0x123b  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST05                         (0x123c)
+#define P_VDIN_DNLP_HIST05                         (volatile unsigned int *)((0x123c  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST06                         (0x123d)
+#define P_VDIN_DNLP_HIST06                         (volatile unsigned int *)((0x123d  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST07                         (0x123e)
+#define P_VDIN_DNLP_HIST07                         (volatile unsigned int *)((0x123e  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST08                         (0x123f)
+#define P_VDIN_DNLP_HIST08                         (volatile unsigned int *)((0x123f  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST09                         (0x1240)
+#define P_VDIN_DNLP_HIST09                         (volatile unsigned int *)((0x1240  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST10                         (0x1241)
+#define P_VDIN_DNLP_HIST10                         (volatile unsigned int *)((0x1241  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST11                         (0x1242)
+#define P_VDIN_DNLP_HIST11                         (volatile unsigned int *)((0x1242  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST12                         (0x1243)
+#define P_VDIN_DNLP_HIST12                         (volatile unsigned int *)((0x1243  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST13                         (0x1244)
+#define P_VDIN_DNLP_HIST13                         (volatile unsigned int *)((0x1244  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST14                         (0x1245)
+#define P_VDIN_DNLP_HIST14                         (volatile unsigned int *)((0x1245  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST15                         (0x1246)
+#define P_VDIN_DNLP_HIST15                         (volatile unsigned int *)((0x1246  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST16                         (0x1247)
+#define P_VDIN_DNLP_HIST16                         (volatile unsigned int *)((0x1247  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST17                         (0x1248)
+#define P_VDIN_DNLP_HIST17                         (volatile unsigned int *)((0x1248  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST18                         (0x1249)
+#define P_VDIN_DNLP_HIST18                         (volatile unsigned int *)((0x1249  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST19                         (0x124a)
+#define P_VDIN_DNLP_HIST19                         (volatile unsigned int *)((0x124a  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST20                         (0x124b)
+#define P_VDIN_DNLP_HIST20                         (volatile unsigned int *)((0x124b  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST21                         (0x124c)
+#define P_VDIN_DNLP_HIST21                         (volatile unsigned int *)((0x124c  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST22                         (0x124d)
+#define P_VDIN_DNLP_HIST22                         (volatile unsigned int *)((0x124d  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST23                         (0x124e)
+#define P_VDIN_DNLP_HIST23                         (volatile unsigned int *)((0x124e  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST24                         (0x124f)
+#define P_VDIN_DNLP_HIST24                         (volatile unsigned int *)((0x124f  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST25                         (0x1250)
+#define P_VDIN_DNLP_HIST25                         (volatile unsigned int *)((0x1250  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST26                         (0x1251)
+#define P_VDIN_DNLP_HIST26                         (volatile unsigned int *)((0x1251  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST27                         (0x1252)
+#define P_VDIN_DNLP_HIST27                         (volatile unsigned int *)((0x1252  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST28                         (0x1253)
+#define P_VDIN_DNLP_HIST28                         (volatile unsigned int *)((0x1253  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST29                         (0x1254)
+#define P_VDIN_DNLP_HIST29                         (volatile unsigned int *)((0x1254  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST30                         (0x1255)
+#define P_VDIN_DNLP_HIST30                         (volatile unsigned int *)((0x1255  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST31                         (0x1256)
+#define P_VDIN_DNLP_HIST31                         (volatile unsigned int *)((0x1256  << 2) + 0xff900000)
+//Bit 31, local dimming statistic enable
+//Bit 28, eol enable
+//Bit 27:25, vertical line overlap number for max finding
+//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
+//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
+//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
+//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION
+//Bit 6:0, region read index
+#define   VDIN_LDIM_STTS_HIST_REGION_IDX           (0x1257)
+#define P_VDIN_LDIM_STTS_HIST_REGION_IDX           (volatile unsigned int *)((0x1257  << 2) + 0xff900000)
+//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
+//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
+//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
+//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
+//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
+//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
+//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
+//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
+//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
+//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
+//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
+//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
+#define   VDIN_LDIM_STTS_HIST_SET_REGION           (0x1258)
+#define P_VDIN_LDIM_STTS_HIST_SET_REGION           (volatile unsigned int *)((0x1258  << 2) + 0xff900000)
+//REGION STATISTIC DATA READ OUT PORT, bit 29:20 max_comp2, bit 19:10 max_comp1, bit 9:0 max_comp0
+#define   VDIN_LDIM_STTS_HIST_READ_REGION          (0x1259)
+#define P_VDIN_LDIM_STTS_HIST_READ_REGION          (volatile unsigned int *)((0x1259  << 2) + 0xff900000)
+//Bit 18, reset bit, high active
+//Bit 17, if true, widen hs/vs pulse
+//Bit 16  vsync total counter always accumulating enable
+//Bit 14:12, select hs/vs of video input channel to measure, 0: no selection, 1: vdi1, 2: vid2, 3: vid3, 4:vid4, 5:vdi5, 6:vid6, 7:vdi7, 8: vdi8
+//Bit 11:4, vsync_span, define how many vsync span need to measure
+//Bit 2:0  meas_hs_index, index to select which HS counter/range
+#define   VDIN_MEAS_CTRL0                          (0x125a)
+#define P_VDIN_MEAS_CTRL0                          (volatile unsigned int *)((0x125a  << 2) + 0xff900000)
+//Read only
+//19:16     meas_ind_total_count_n, every number of sync_span vsyncs, this count add 1
+//15:0      high bit portion of vsync total counter
+#define   VDIN_MEAS_VS_COUNT_HI                    (0x125b)
+#define P_VDIN_MEAS_VS_COUNT_HI                    (volatile unsigned int *)((0x125b  << 2) + 0xff900000)
+//Read only
+//31:0, low bit portion of vsync total counter
+#define   VDIN_MEAS_VS_COUNT_LO                    (0x125c)
+#define P_VDIN_MEAS_VS_COUNT_LO                    (volatile unsigned int *)((0x125c  << 2) + 0xff900000)
+//according to the meas_hs_index in register VDIN_MEAS_CTRL0
+//meas_hs_index == 0, first hs range
+//meas_hs_index == 1, second hs range
+//meas_hs_index == 2, third hs range
+//meas_hs_index == 3, fourth hs range
+//bit 28:16 count_start
+//bit 12:0 count_end
+#define   VDIN_MEAS_HS_RANGE                       (0x125d)
+#define P_VDIN_MEAS_HS_RANGE                       (volatile unsigned int *)((0x125d  << 2) + 0xff900000)
+//Read only
+//according to the meas_hs_index in register VDIN_MEAS_CTRL0,
+//meas_hs_index == 0, first range hs counter,
+//meas_hs_index == 1, second range hs coutner
+//meas_hs_index == 2, third range hs coutner
+//meas_hs_index == 3, fourth range hs coutner
+//23:0
+#define   VDIN_MEAS_HS_COUNT                       (0x125e)
+#define P_VDIN_MEAS_HS_COUNT                       (volatile unsigned int *)((0x125e  << 2) + 0xff900000)
+//Bit 8      white_enable
+//Bit 7:0    blkbar_white_level
+#define   VDIN_BLKBAR_CTRL1                        (0x125f)
+#define P_VDIN_BLKBAR_CTRL1                        (volatile unsigned int *)((0x125f  << 2) + 0xff900000)
+// Bit 31:24 blkbar_black_level    threshold to judge a black point
+// Bit 23:21 Reserved
+// Bit 20:8  blkbar_hwidth         left and right region width
+// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
+// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
+// Bit 3     blkbar_det_en
+// Bit 2:1   blkbar_din_sel
+// bit blkbar_det_top_en
+#define   VDIN_BLKBAR_CTRL0                        (0x1260)
+#define P_VDIN_BLKBAR_CTRL0                        (volatile unsigned int *)((0x1260  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_hstart.        Left region start
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_hend.          Right region end
+#define   VDIN_BLKBAR_H_START_END                  (0x1261)
+#define P_VDIN_BLKBAR_H_START_END                  (volatile unsigned int *)((0x1261  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_vstart
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_vend
+#define   VDIN_BLKBAR_V_START_END                  (0x1262)
+#define P_VDIN_BLKBAR_V_START_END                  (volatile unsigned int *)((0x1262  << 2) + 0xff900000)
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black
+#define   VDIN_BLKBAR_CNT_THRESHOLD                (0x1263)
+#define P_VDIN_BLKBAR_CNT_THRESHOLD                (volatile unsigned int *)((0x1263  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
+// Bit 15:13 Reserved
+// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
+#define   VDIN_BLKBAR_ROW_TH1_TH2                  (0x1264)
+#define P_VDIN_BLKBAR_ROW_TH1_TH2                  (volatile unsigned int *)((0x1264  << 2) + 0xff900000)
+//Readonly
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
+#define   VDIN_BLKBAR_IND_LEFT_START_END           (0x1265)
+#define P_VDIN_BLKBAR_IND_LEFT_START_END           (volatile unsigned int *)((0x1265  << 2) + 0xff900000)
+//Readonly
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
+#define   VDIN_BLKBAR_IND_RIGHT_START_END          (0x1266)
+#define P_VDIN_BLKBAR_IND_RIGHT_START_END          (volatile unsigned int *)((0x1266  << 2) + 0xff900000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
+#define   VDIN_BLKBAR_IND_LEFT1_CNT                (0x1267)
+#define P_VDIN_BLKBAR_IND_LEFT1_CNT                (volatile unsigned int *)((0x1267  << 2) + 0xff900000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. right part of the left region
+#define   VDIN_BLKBAR_IND_LEFT2_CNT                (0x1268)
+#define P_VDIN_BLKBAR_IND_LEFT2_CNT                (volatile unsigned int *)((0x1268  << 2) + 0xff900000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
+#define   VDIN_BLKBAR_IND_RIGHT1_CNT               (0x1269)
+#define P_VDIN_BLKBAR_IND_RIGHT1_CNT               (volatile unsigned int *)((0x1269  << 2) + 0xff900000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
+#define   VDIN_BLKBAR_IND_RIGHT2_CNT               (0x126a)
+#define P_VDIN_BLKBAR_IND_RIGHT2_CNT               (volatile unsigned int *)((0x126a  << 2) + 0xff900000)
+//Readonly
+// Bit 31:30 Resersed
+// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
+// Bit 28:16 blkbar_top_pos.            Top black bar position
+// Bit 15:13 Reserved.
+// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
+#define   VDIN_BLKBAR_STATUS0                      (0x126b)
+#define P_VDIN_BLKBAR_STATUS0                      (volatile unsigned int *)((0x126b  << 2) + 0xff900000)
+//Readonly
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_left_pos.       Left black bar posiont
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_right_pos.      Right black bar position
+#define   VDIN_BLKBAR_STATUS1                      (0x126c)
+#define P_VDIN_BLKBAR_STATUS1                      (volatile unsigned int *)((0x126c  << 2) + 0xff900000)
+//Bit 28:16 input window H start
+//Bit 12:0  input window H end
+#define   VDIN_WIN_H_START_END                     (0x126d)
+#define P_VDIN_WIN_H_START_END                     (volatile unsigned int *)((0x126d  << 2) + 0xff900000)
+//Bit 28:16 input window H start
+//Bit 12:0  input window V start
+#define   VDIN_WIN_V_START_END                     (0x126e)
+#define P_VDIN_WIN_V_START_END                     (volatile unsigned int *)((0x126e  << 2) + 0xff900000)
+//Bit 23:16 vdi8 asfifo_ctrl
+//Bit 15:8 vdi7 asfifo_ctrl
+//Bit 7:0 vdi6 asfifo_ctrl
+#define   VDIN_ASFIFO_CTRL3                        (0x126f)
+#define P_VDIN_ASFIFO_CTRL3                        (volatile unsigned int *)((0x126f  << 2) + 0xff900000)
+//Bit 3:2 vshrk_clk2_ctrl
+//Bit 1:0 vshrk_clk1_ctrl
+#define   VDIN_COM_GCLK_CTRL2                      (0x1270)
+#define P_VDIN_COM_GCLK_CTRL2                      (volatile unsigned int *)((0x1270  << 2) + 0xff900000)
+//Bit 27 vshrk_en
+//Bit 26:25 vshrk_mode
+//Bit 24 vshrk_lpf_mode
+//Bit 23:0 vshrk_dummy
+#define   VDIN_VSHRK_CTRL                          (0x1271)
+#define P_VDIN_VSHRK_CTRL                          (volatile unsigned int *)((0x1271  << 2) + 0xff900000)
+#define   VDIN_DNLP_HIST32                         (0x1272)
+#define P_VDIN_DNLP_HIST32                         (volatile unsigned int *)((0x1272  << 2) + 0xff900000)
+//Read only
+//Bit 7, vdi9 fifo overflow
+//Bit 5:0, vdi9_asfifo_cnt
+#define   VDIN_COM_STATUS3                         (0x1273)
+#define P_VDIN_COM_STATUS3                         (volatile unsigned int *)((0x1273  << 2) + 0xff900000)
+#define   VDIN_SYNC_MASK                           (0x1274)
+#define P_VDIN_SYNC_MASK                           (volatile unsigned int *)((0x1274  << 2) + 0xff900000)
+//Bit 7:0,  hsync_mask_num
+//Bit 15:8, vsync_mask_num
+//Bit 16,   hsync_mask_enable
+//Bit 17,   vsync_mask_num
+//dolby vdin
+#define   VDIN_DOLBY_DSC_CTRL0                     (0x1275)
+#define P_VDIN_DOLBY_DSC_CTRL0                     (volatile unsigned int *)((0x1275  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_CTRL1                     (0x1276)
+#define P_VDIN_DOLBY_DSC_CTRL1                     (volatile unsigned int *)((0x1276  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_CTRL2                     (0x1277)
+#define P_VDIN_DOLBY_DSC_CTRL2                     (volatile unsigned int *)((0x1277  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_CTRL3                     (0x1278)
+#define P_VDIN_DOLBY_DSC_CTRL3                     (volatile unsigned int *)((0x1278  << 2) + 0xff900000)
+#define   VDIN_DOLBY_AXI_CTRL0                     (0x1279)
+#define P_VDIN_DOLBY_AXI_CTRL0                     (volatile unsigned int *)((0x1279  << 2) + 0xff900000)
+#define   VDIN_DOLBY_AXI_CTRL1                     (0x127a)
+#define P_VDIN_DOLBY_AXI_CTRL1                     (volatile unsigned int *)((0x127a  << 2) + 0xff900000)
+#define   VDIN_DOLBY_AXI_CTRL2                     (0x127b)
+#define P_VDIN_DOLBY_AXI_CTRL2                     (volatile unsigned int *)((0x127b  << 2) + 0xff900000)
+#define   VDIN_DOLBY_AXI_CTRL3                     (0x127c)
+#define P_VDIN_DOLBY_AXI_CTRL3                     (volatile unsigned int *)((0x127c  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_STATUS0                   (0x127d)
+#define P_VDIN_DOLBY_DSC_STATUS0                   (volatile unsigned int *)((0x127d  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_STATUS1                   (0x127e)
+#define P_VDIN_DOLBY_DSC_STATUS1                   (volatile unsigned int *)((0x127e  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_STATUS2                   (0x127f)
+#define P_VDIN_DOLBY_DSC_STATUS2                   (volatile unsigned int *)((0x127f  << 2) + 0xff900000)
+#define   VDIN_DOLBY_DSC_STATUS3                   (0x121d)
+#define P_VDIN_DOLBY_DSC_STATUS3                   (volatile unsigned int *)((0x121d  << 2) + 0xff900000)
+
+//8'h72 occupied by histogram 32
+//VDIN0        8'h00 - 8'h7f
+#define VDIN0_SCALE_COEF_IDX                    ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
+#define VDIN0_SCALE_COEF                        ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF                   )
+#define VDIN0_COM_CTRL0                         ((VDIN0_OFFSET << 2) + VDIN_COM_CTRL0                    )
+#define VDIN0_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN0_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
+#define VDIN0_LCNT_STATUS                       ((VDIN0_OFFSET << 2) + VDIN_LCNT_STATUS                  )
+#define VDIN0_COM_STATUS0                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS0                  )
+#define VDIN0_COM_STATUS1                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS1                  )
+#define VDIN0_LCNT_SHADOW_STATUS                ((VDIN0_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
+#define VDIN0_ASFIFO_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
+#define VDIN0_ASFIFO_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
+#define VDIN0_WIDTHM1I_WIDTHM1O                 ((VDIN0_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
+#define VDIN0_SC_MISC_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
+#define VDIN0_HSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
+#define VDIN0_HSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
+#define VDIN0_COM_STATUS2                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS2                  )
+#define VDIN0_COM_STATUS3                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS3                  )
+#define VDIN0_ASFIFO_CTRL2                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
+#define VDIN0_MATRIX_CTRL                       ((VDIN0_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
+#define VDIN0_MATRIX_COEF00_01                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
+#define VDIN0_MATRIX_COEF02_10                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
+#define VDIN0_MATRIX_COEF11_12                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
+#define VDIN0_MATRIX_COEF20_21                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
+#define VDIN0_MATRIX_COEF22                     ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF22                )
+#define VDIN0_MATRIX_OFFSET0_1                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
+#define VDIN0_MATRIX_OFFSET2                    ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
+#define VDIN0_MATRIX_PRE_OFFSET0_1              ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
+#define VDIN0_MATRIX_PRE_OFFSET2                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
+#define VDIN0_LFIFO_CTRL                        ((VDIN0_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
+#define VDIN0_COM_GCLK_CTRL                     ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
+#define VDIN0_INTF_WIDTHM1                      ((VDIN0_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
+#define VDIN0_WR_CTRL2                          ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL2                     )
+#define VDIN0_WR_CTRL                           ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL                      )
+#define VDIN0_WR_H_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_H_START_END               )
+#define VDIN0_WR_V_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_V_START_END               )
+#define VDIN0_VSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
+#define VDIN0_VSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
+#define VDIN0_SCIN_HEIGHTM1                     ((VDIN0_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
+#define VDIN0_DUMMY_DATA                        ((VDIN0_OFFSET << 2) + VDIN_DUMMY_DATA                   )
+#define VDIN0_MATRIX_PROBE_COLOR                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
+#define VDIN0_MATRIX_HL_COLOR                   ((VDIN0_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
+#define VDIN0_MATRIX_PROBE_POS                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
+#define VDIN0_CHROMA_ADDR_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
+#define VDIN0_CHROMA_DATA_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
+#define VDIN0_CM_BRI_CON_CTRL                   ((VDIN0_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
+#define VDIN0_HIST_CTRL                         ((VDIN0_OFFSET << 2) + VDIN_HIST_CTRL                    )
+#define VDIN0_HIST_H_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_H_START_END             )
+#define VDIN0_HIST_V_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_V_START_END             )
+#define VDIN0_HIST_MAX_MIN                      ((VDIN0_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
+#define VDIN0_HIST_SPL_VAL                      ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
+#define VDIN0_HIST_SPL_PIX_CNT                  ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
+#define VDIN0_HIST_CHROMA_SUM                   ((VDIN0_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
+#define VDIN0_DNLP_HIST00                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST00                  )
+#define VDIN0_DNLP_HIST01                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST01                  )
+#define VDIN0_DNLP_HIST02                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST02                  )
+#define VDIN0_DNLP_HIST03                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST03                  )
+#define VDIN0_DNLP_HIST04                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST04                  )
+#define VDIN0_DNLP_HIST05                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST05                  )
+#define VDIN0_DNLP_HIST06                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST06                  )
+#define VDIN0_DNLP_HIST07                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST07                  )
+#define VDIN0_DNLP_HIST08                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST08                  )
+#define VDIN0_DNLP_HIST09                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST09                  )
+#define VDIN0_DNLP_HIST10                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST10                  )
+#define VDIN0_DNLP_HIST11                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST11                  )
+#define VDIN0_DNLP_HIST12                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST12                  )
+#define VDIN0_DNLP_HIST13                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST13                  )
+#define VDIN0_DNLP_HIST14                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST14                  )
+#define VDIN0_DNLP_HIST15                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST15                  )
+#define VDIN0_DNLP_HIST16                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST16                  )
+#define VDIN0_DNLP_HIST17                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST17                  )
+#define VDIN0_DNLP_HIST18                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST18                  )
+#define VDIN0_DNLP_HIST19                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST19                  )
+#define VDIN0_DNLP_HIST20                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST20                  )
+#define VDIN0_DNLP_HIST21                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST21                  )
+#define VDIN0_DNLP_HIST22                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST22                  )
+#define VDIN0_DNLP_HIST23                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST23                  )
+#define VDIN0_DNLP_HIST24                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST24                  )
+#define VDIN0_DNLP_HIST25                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST25                  )
+#define VDIN0_DNLP_HIST26                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST26                  )
+#define VDIN0_DNLP_HIST27                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST27                  )
+#define VDIN0_DNLP_HIST28                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST28                  )
+#define VDIN0_DNLP_HIST29                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST29                  )
+#define VDIN0_DNLP_HIST30                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST30                  )
+#define VDIN0_DNLP_HIST31                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST31                  )
+#define VDIN0_DNLP_HIST32                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST32                  )
+#define VDIN0_LDIM_STTS_HIST_REGION_IDX         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
+#define VDIN0_LDIM_STTS_HIST_SET_REGION         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
+#define VDIN0_LDIM_STTS_HIST_READ_REGION        ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
+#define VDIN0_MEAS_CTRL0                        ((VDIN0_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
+#define VDIN0_MEAS_VS_COUNT_HI                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
+#define VDIN0_MEAS_VS_COUNT_LO                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
+#define VDIN0_MEAS_HS_RANGE                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
+#define VDIN0_MEAS_HS_COUNT                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
+#define VDIN0_BLKBAR_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
+#define VDIN0_BLKBAR_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
+#define VDIN0_BLKBAR_H_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
+#define VDIN0_BLKBAR_V_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
+#define VDIN0_BLKBAR_CNT_THRESHOLD              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
+#define VDIN0_BLKBAR_ROW_TH1_TH2                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
+#define VDIN0_BLKBAR_IND_LEFT_START_END         ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
+#define VDIN0_BLKBAR_IND_RIGHT_START_END        ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
+#define VDIN0_BLKBAR_IND_LEFT1_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
+#define VDIN0_BLKBAR_IND_LEFT2_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
+#define VDIN0_BLKBAR_IND_RIGHT1_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
+#define VDIN0_BLKBAR_IND_RIGHT2_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
+#define VDIN0_BLKBAR_STATUS0                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
+#define VDIN0_BLKBAR_STATUS1                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
+#define VDIN0_WIN_H_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_H_START_END              )
+#define VDIN0_WIN_V_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_V_START_END              )
+#define VDIN0_ASFIFO_CTRL3                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )
+#define VDIN0_COM_GCLK_CTRL2                    ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL2               )
+#define VDIN0_VSHRK_CTRL                        ((VDIN0_OFFSET << 2) + VDIN_VSHRK_CTRL                   )
+#define VDIN0_SYNC_MASK                         ((VDIN0_OFFSET << 2) + VDIN_SYNC_MASK                    )
+#define VDIN0_DOLBY_DSC_CTRL0                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL0  )
+#define VDIN0_DOLBY_DSC_CTRL1                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL1  )
+#define VDIN0_DOLBY_DSC_CTRL2                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL2  )
+#define VDIN0_DOLBY_DSC_CTRL3                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL3  )
+#define VDIN0_DOLBY_AXI_CTRL0                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL0  )
+#define VDIN0_DOLBY_AXI_CTRL1                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL1  )
+#define VDIN0_DOLBY_AXI_CTRL2                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL2  )
+#define VDIN0_DOLBY_AXI_CTRL3                    ((VDIN0_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL3  )
+#define VDIN0_DOLBY_DSC_STATUS0                  ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS0)
+#define VDIN0_DOLBY_DSC_STATUS1                  ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS1)
+#define VDIN0_DOLBY_DSC_STATUS2                  ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS2)
+#define VDIN0_DOLBY_DSC_STATUS3                  ((VDIN0_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS3)
+
+
+//VDIN1        8'h80 - 8'hef
+#define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
+#define VDIN1_SCALE_COEF                        ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF                   )
+#define VDIN1_COM_CTRL0                         ((VDIN1_OFFSET << 2) + VDIN_COM_CTRL0                    )
+#define VDIN1_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN1_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
+#define VDIN1_LCNT_STATUS                       ((VDIN1_OFFSET << 2) + VDIN_LCNT_STATUS                  )
+#define VDIN1_COM_STATUS0                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS0                  )
+#define VDIN1_COM_STATUS1                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS1                  )
+#define VDIN1_LCNT_SHADOW_STATUS                ((VDIN1_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
+#define VDIN1_ASFIFO_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
+#define VDIN1_ASFIFO_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
+#define VDIN1_WIDTHM1I_WIDTHM1O                 ((VDIN1_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
+#define VDIN1_SC_MISC_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
+#define VDIN1_HSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
+#define VDIN1_HSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
+#define VDIN1_COM_STATUS2                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS2                  )
+#define VDIN1_COM_STATUS3                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS3                  )
+#define VDIN1_ASFIFO_CTRL2                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
+#define VDIN1_MATRIX_CTRL                       ((VDIN1_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
+#define VDIN1_MATRIX_COEF00_01                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
+#define VDIN1_MATRIX_COEF02_10                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
+#define VDIN1_MATRIX_COEF11_12                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
+#define VDIN1_MATRIX_COEF20_21                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
+#define VDIN1_MATRIX_COEF22                     ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF22                )
+#define VDIN1_MATRIX_OFFSET0_1                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
+#define VDIN1_MATRIX_OFFSET2                    ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
+#define VDIN1_MATRIX_PRE_OFFSET0_1              ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
+#define VDIN1_MATRIX_PRE_OFFSET2                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
+#define VDIN1_LFIFO_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
+#define VDIN1_COM_GCLK_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
+#define VDIN1_INTF_WIDTHM1                      ((VDIN1_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
+#define VDIN1_WR_CTRL2                          ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL2                     )
+#define VDIN1_WR_CTRL                           ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL                      )
+#define VDIN1_WR_H_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_H_START_END               )
+#define VDIN1_WR_V_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_V_START_END               )
+#define VDIN1_VSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
+#define VDIN1_VSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
+#define VDIN1_SCIN_HEIGHTM1                     ((VDIN1_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
+#define VDIN1_DUMMY_DATA                        ((VDIN1_OFFSET << 2) + VDIN_DUMMY_DATA                   )
+#define VDIN1_MATRIX_PROBE_COLOR                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
+#define VDIN1_MATRIX_HL_COLOR                   ((VDIN1_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
+#define VDIN1_MATRIX_PROBE_POS                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
+#define VDIN1_CHROMA_ADDR_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
+#define VDIN1_CHROMA_DATA_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
+#define VDIN1_CM_BRI_CON_CTRL                   ((VDIN1_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
+#define VDIN1_HIST_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HIST_CTRL                    )
+#define VDIN1_HIST_H_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_H_START_END             )
+#define VDIN1_HIST_V_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_V_START_END             )
+#define VDIN1_HIST_MAX_MIN                      ((VDIN1_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
+#define VDIN1_HIST_SPL_VAL                      ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
+#define VDIN1_HIST_SPL_PIX_CNT                  ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
+#define VDIN1_HIST_CHROMA_SUM                   ((VDIN1_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
+#define VDIN1_DNLP_HIST00                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST00                  )
+#define VDIN1_DNLP_HIST01                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST01                  )
+#define VDIN1_DNLP_HIST02                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST02                  )
+#define VDIN1_DNLP_HIST03                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST03                  )
+#define VDIN1_DNLP_HIST04                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST04                  )
+#define VDIN1_DNLP_HIST05                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST05                  )
+#define VDIN1_DNLP_HIST06                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST06                  )
+#define VDIN1_DNLP_HIST07                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST07                  )
+#define VDIN1_DNLP_HIST08                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST08                  )
+#define VDIN1_DNLP_HIST09                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST09                  )
+#define VDIN1_DNLP_HIST10                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST10                  )
+#define VDIN1_DNLP_HIST11                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST11                  )
+#define VDIN1_DNLP_HIST12                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST12                  )
+#define VDIN1_DNLP_HIST13                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST13                  )
+#define VDIN1_DNLP_HIST14                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST14                  )
+#define VDIN1_DNLP_HIST15                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST15                  )
+#define VDIN1_DNLP_HIST16                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST16                  )
+#define VDIN1_DNLP_HIST17                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST17                  )
+#define VDIN1_DNLP_HIST18                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST18                  )
+#define VDIN1_DNLP_HIST19                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST19                  )
+#define VDIN1_DNLP_HIST20                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST20                  )
+#define VDIN1_DNLP_HIST21                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST21                  )
+#define VDIN1_DNLP_HIST22                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST22                  )
+#define VDIN1_DNLP_HIST23                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST23                  )
+#define VDIN1_DNLP_HIST24                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST24                  )
+#define VDIN1_DNLP_HIST25                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST25                  )
+#define VDIN1_DNLP_HIST26                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST26                  )
+#define VDIN1_DNLP_HIST27                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST27                  )
+#define VDIN1_DNLP_HIST28                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST28                  )
+#define VDIN1_DNLP_HIST29                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST29                  )
+#define VDIN1_DNLP_HIST30                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST30                  )
+#define VDIN1_DNLP_HIST31                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST31                  )
+#define VDIN1_DNLP_HIST32                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST32                  )
+#define VDIN1_LDIM_STTS_HIST_REGION_IDX         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
+#define VDIN1_LDIM_STTS_HIST_SET_REGION         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
+#define VDIN1_LDIM_STTS_HIST_READ_REGION        ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
+#define VDIN1_MEAS_CTRL0                        ((VDIN1_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
+#define VDIN1_MEAS_VS_COUNT_HI                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
+#define VDIN1_MEAS_VS_COUNT_LO                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
+#define VDIN1_MEAS_HS_RANGE                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
+#define VDIN1_MEAS_HS_COUNT                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
+#define VDIN1_BLKBAR_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
+#define VDIN1_BLKBAR_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
+#define VDIN1_BLKBAR_H_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
+#define VDIN1_BLKBAR_V_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
+#define VDIN1_BLKBAR_CNT_THRESHOLD              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
+#define VDIN1_BLKBAR_ROW_TH1_TH2                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
+#define VDIN1_BLKBAR_IND_LEFT_START_END         ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
+#define VDIN1_BLKBAR_IND_RIGHT_START_END        ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
+#define VDIN1_BLKBAR_IND_LEFT1_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
+#define VDIN1_BLKBAR_IND_LEFT2_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
+#define VDIN1_BLKBAR_IND_RIGHT1_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
+#define VDIN1_BLKBAR_IND_RIGHT2_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
+#define VDIN1_BLKBAR_STATUS0                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
+#define VDIN1_BLKBAR_STATUS1                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
+#define VDIN1_WIN_H_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_H_START_END              )
+#define VDIN1_WIN_V_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_V_START_END              )
+#define VDIN1_ASFIFO_CTRL3                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )
+#define VDIN1_COM_GCLK_CTRL2                    ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL2               )
+#define VDIN1_VSHRK_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_VSHRK_CTRL                   )
+#define VDIN1_SYNC_MASK                         ((VDIN1_OFFSET << 2) + VDIN_SYNC_MASK                    )
+#define VDIN1_DOLBY_DSC_CTRL0                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL0  )
+#define VDIN1_DOLBY_DSC_CTRL1                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL1  )
+#define VDIN1_DOLBY_DSC_CTRL2                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL2  )
+#define VDIN1_DOLBY_DSC_CTRL3                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL3  )
+#define VDIN1_DOLBY_AXI_CTRL0                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL0  )
+#define VDIN1_DOLBY_AXI_CTRL1                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL1  )
+#define VDIN1_DOLBY_AXI_CTRL2                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL2  )
+#define VDIN1_DOLBY_AXI_CTRL3                    ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL3  )
+#define VDIN1_DOLBY_DSC_STATUS0                  ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS0)
+#define VDIN1_DOLBY_DSC_STATUS1                  ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS1)
+#define VDIN1_DOLBY_DSC_STATUS2                  ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS2)
+#define VDIN1_DOLBY_DSC_STATUS3                  ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS3)
+
+//`define LCD_VCBUS_BASE               8'h14
+//
+// Reading file:  lcd_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  LCD_VCBUS_BASE = 0x14
+// -----------------------------------------------
+//========================================================================
+//LCD DRV     12'h480~12'h4ef
+//=======================================================================
+#define   L_GAMMA_CNTL_PORT                        (0x1400)
+#define P_L_GAMMA_CNTL_PORT                        (volatile unsigned int *)((0x1400  << 2) + 0xff900000)
+#define   L_GAMMA_DATA_PORT                        (0x1401)
+#define P_L_GAMMA_DATA_PORT                        (volatile unsigned int *)((0x1401  << 2) + 0xff900000)
+#define   L_GAMMA_ADDR_PORT                        (0x1402)
+#define P_L_GAMMA_ADDR_PORT                        (volatile unsigned int *)((0x1402  << 2) + 0xff900000)
+#define   L_GAMMA_VCOM_HSWITCH_ADDR                (0x1403)
+#define P_L_GAMMA_VCOM_HSWITCH_ADDR                (volatile unsigned int *)((0x1403  << 2) + 0xff900000)
+#define   L_RGB_BASE_ADDR                          (0x1405)
+#define P_L_RGB_BASE_ADDR                          (volatile unsigned int *)((0x1405  << 2) + 0xff900000)
+#define   L_RGB_COEFF_ADDR                         (0x1406)
+#define P_L_RGB_COEFF_ADDR                         (volatile unsigned int *)((0x1406  << 2) + 0xff900000)
+#define   L_POL_CNTL_ADDR                          (0x1407)
+#define P_L_POL_CNTL_ADDR                          (volatile unsigned int *)((0x1407  << 2) + 0xff900000)
+#define   L_DITH_CNTL_ADDR                         (0x1408)
+#define P_L_DITH_CNTL_ADDR                         (volatile unsigned int *)((0x1408  << 2) + 0xff900000)
+#define   L_GAMMA_PROBE_CTRL                       (0x1409)
+#define P_L_GAMMA_PROBE_CTRL                       (volatile unsigned int *)((0x1409  << 2) + 0xff900000)
+//read only
+#define   L_GAMMA_PROBE_COLOR_L                    (0x140a)
+#define P_L_GAMMA_PROBE_COLOR_L                    (volatile unsigned int *)((0x140a  << 2) + 0xff900000)
+#define   L_GAMMA_PROBE_COLOR_H                    (0x140b)
+#define P_L_GAMMA_PROBE_COLOR_H                    (volatile unsigned int *)((0x140b  << 2) + 0xff900000)
+#define   L_GAMMA_PROBE_HL_COLOR                   (0x140c)
+#define P_L_GAMMA_PROBE_HL_COLOR                   (volatile unsigned int *)((0x140c  << 2) + 0xff900000)
+#define   L_GAMMA_PROBE_POS_X                      (0x140d)
+#define P_L_GAMMA_PROBE_POS_X                      (volatile unsigned int *)((0x140d  << 2) + 0xff900000)
+#define   L_GAMMA_PROBE_POS_Y                      (0x140e)
+#define P_L_GAMMA_PROBE_POS_Y                      (volatile unsigned int *)((0x140e  << 2) + 0xff900000)
+#define   L_STH1_HS_ADDR                           (0x1410)
+#define P_L_STH1_HS_ADDR                           (volatile unsigned int *)((0x1410  << 2) + 0xff900000)
+#define   L_STH1_HE_ADDR                           (0x1411)
+#define P_L_STH1_HE_ADDR                           (volatile unsigned int *)((0x1411  << 2) + 0xff900000)
+#define   L_STH1_VS_ADDR                           (0x1412)
+#define P_L_STH1_VS_ADDR                           (volatile unsigned int *)((0x1412  << 2) + 0xff900000)
+#define   L_STH1_VE_ADDR                           (0x1413)
+#define P_L_STH1_VE_ADDR                           (volatile unsigned int *)((0x1413  << 2) + 0xff900000)
+#define   L_STH2_HS_ADDR                           (0x1414)
+#define P_L_STH2_HS_ADDR                           (volatile unsigned int *)((0x1414  << 2) + 0xff900000)
+#define   L_STH2_HE_ADDR                           (0x1415)
+#define P_L_STH2_HE_ADDR                           (volatile unsigned int *)((0x1415  << 2) + 0xff900000)
+#define   L_STH2_VS_ADDR                           (0x1416)
+#define P_L_STH2_VS_ADDR                           (volatile unsigned int *)((0x1416  << 2) + 0xff900000)
+#define   L_STH2_VE_ADDR                           (0x1417)
+#define P_L_STH2_VE_ADDR                           (volatile unsigned int *)((0x1417  << 2) + 0xff900000)
+#define   L_OEH_HS_ADDR                            (0x1418)
+#define P_L_OEH_HS_ADDR                            (volatile unsigned int *)((0x1418  << 2) + 0xff900000)
+#define   L_OEH_HE_ADDR                            (0x1419)
+#define P_L_OEH_HE_ADDR                            (volatile unsigned int *)((0x1419  << 2) + 0xff900000)
+#define   L_OEH_VS_ADDR                            (0x141a)
+#define P_L_OEH_VS_ADDR                            (volatile unsigned int *)((0x141a  << 2) + 0xff900000)
+#define   L_OEH_VE_ADDR                            (0x141b)
+#define P_L_OEH_VE_ADDR                            (volatile unsigned int *)((0x141b  << 2) + 0xff900000)
+#define   L_VCOM_HSWITCH_ADDR                      (0x141c)
+#define P_L_VCOM_HSWITCH_ADDR                      (volatile unsigned int *)((0x141c  << 2) + 0xff900000)
+#define   L_VCOM_VS_ADDR                           (0x141d)
+#define P_L_VCOM_VS_ADDR                           (volatile unsigned int *)((0x141d  << 2) + 0xff900000)
+#define   L_VCOM_VE_ADDR                           (0x141e)
+#define P_L_VCOM_VE_ADDR                           (volatile unsigned int *)((0x141e  << 2) + 0xff900000)
+#define   L_CPV1_HS_ADDR                           (0x141f)
+#define P_L_CPV1_HS_ADDR                           (volatile unsigned int *)((0x141f  << 2) + 0xff900000)
+#define   L_CPV1_HE_ADDR                           (0x1420)
+#define P_L_CPV1_HE_ADDR                           (volatile unsigned int *)((0x1420  << 2) + 0xff900000)
+#define   L_CPV1_VS_ADDR                           (0x1421)
+#define P_L_CPV1_VS_ADDR                           (volatile unsigned int *)((0x1421  << 2) + 0xff900000)
+#define   L_CPV1_VE_ADDR                           (0x1422)
+#define P_L_CPV1_VE_ADDR                           (volatile unsigned int *)((0x1422  << 2) + 0xff900000)
+#define   L_CPV2_HS_ADDR                           (0x1423)
+#define P_L_CPV2_HS_ADDR                           (volatile unsigned int *)((0x1423  << 2) + 0xff900000)
+#define   L_CPV2_HE_ADDR                           (0x1424)
+#define P_L_CPV2_HE_ADDR                           (volatile unsigned int *)((0x1424  << 2) + 0xff900000)
+#define   L_CPV2_VS_ADDR                           (0x1425)
+#define P_L_CPV2_VS_ADDR                           (volatile unsigned int *)((0x1425  << 2) + 0xff900000)
+#define   L_CPV2_VE_ADDR                           (0x1426)
+#define P_L_CPV2_VE_ADDR                           (volatile unsigned int *)((0x1426  << 2) + 0xff900000)
+#define   L_STV1_HS_ADDR                           (0x1427)
+#define P_L_STV1_HS_ADDR                           (volatile unsigned int *)((0x1427  << 2) + 0xff900000)
+#define   L_STV1_HE_ADDR                           (0x1428)
+#define P_L_STV1_HE_ADDR                           (volatile unsigned int *)((0x1428  << 2) + 0xff900000)
+#define   L_STV1_VS_ADDR                           (0x1429)
+#define P_L_STV1_VS_ADDR                           (volatile unsigned int *)((0x1429  << 2) + 0xff900000)
+#define   L_STV1_VE_ADDR                           (0x142a)
+#define P_L_STV1_VE_ADDR                           (volatile unsigned int *)((0x142a  << 2) + 0xff900000)
+#define   L_STV2_HS_ADDR                           (0x142b)
+#define P_L_STV2_HS_ADDR                           (volatile unsigned int *)((0x142b  << 2) + 0xff900000)
+#define   L_STV2_HE_ADDR                           (0x142c)
+#define P_L_STV2_HE_ADDR                           (volatile unsigned int *)((0x142c  << 2) + 0xff900000)
+#define   L_STV2_VS_ADDR                           (0x142d)
+#define P_L_STV2_VS_ADDR                           (volatile unsigned int *)((0x142d  << 2) + 0xff900000)
+#define   L_STV2_VE_ADDR                           (0x142e)
+#define P_L_STV2_VE_ADDR                           (volatile unsigned int *)((0x142e  << 2) + 0xff900000)
+#define   L_OEV1_HS_ADDR                           (0x142f)
+#define P_L_OEV1_HS_ADDR                           (volatile unsigned int *)((0x142f  << 2) + 0xff900000)
+#define   L_OEV1_HE_ADDR                           (0x1430)
+#define P_L_OEV1_HE_ADDR                           (volatile unsigned int *)((0x1430  << 2) + 0xff900000)
+#define   L_OEV1_VS_ADDR                           (0x1431)
+#define P_L_OEV1_VS_ADDR                           (volatile unsigned int *)((0x1431  << 2) + 0xff900000)
+#define   L_OEV1_VE_ADDR                           (0x1432)
+#define P_L_OEV1_VE_ADDR                           (volatile unsigned int *)((0x1432  << 2) + 0xff900000)
+#define   L_OEV2_HS_ADDR                           (0x1433)
+#define P_L_OEV2_HS_ADDR                           (volatile unsigned int *)((0x1433  << 2) + 0xff900000)
+#define   L_OEV2_HE_ADDR                           (0x1434)
+#define P_L_OEV2_HE_ADDR                           (volatile unsigned int *)((0x1434  << 2) + 0xff900000)
+#define   L_OEV2_VS_ADDR                           (0x1435)
+#define P_L_OEV2_VS_ADDR                           (volatile unsigned int *)((0x1435  << 2) + 0xff900000)
+#define   L_OEV2_VE_ADDR                           (0x1436)
+#define P_L_OEV2_VE_ADDR                           (volatile unsigned int *)((0x1436  << 2) + 0xff900000)
+#define   L_OEV3_HS_ADDR                           (0x1437)
+#define P_L_OEV3_HS_ADDR                           (volatile unsigned int *)((0x1437  << 2) + 0xff900000)
+#define   L_OEV3_HE_ADDR                           (0x1438)
+#define P_L_OEV3_HE_ADDR                           (volatile unsigned int *)((0x1438  << 2) + 0xff900000)
+#define   L_OEV3_VS_ADDR                           (0x1439)
+#define P_L_OEV3_VS_ADDR                           (volatile unsigned int *)((0x1439  << 2) + 0xff900000)
+#define   L_OEV3_VE_ADDR                           (0x143a)
+#define P_L_OEV3_VE_ADDR                           (volatile unsigned int *)((0x143a  << 2) + 0xff900000)
+#define   L_LCD_PWR_ADDR                           (0x143b)
+#define P_L_LCD_PWR_ADDR                           (volatile unsigned int *)((0x143b  << 2) + 0xff900000)
+#define   L_LCD_PWM0_LO_ADDR                       (0x143c)
+#define P_L_LCD_PWM0_LO_ADDR                       (volatile unsigned int *)((0x143c  << 2) + 0xff900000)
+#define   L_LCD_PWM0_HI_ADDR                       (0x143d)
+#define P_L_LCD_PWM0_HI_ADDR                       (volatile unsigned int *)((0x143d  << 2) + 0xff900000)
+#define   L_LCD_PWM1_LO_ADDR                       (0x143e)
+#define P_L_LCD_PWM1_LO_ADDR                       (volatile unsigned int *)((0x143e  << 2) + 0xff900000)
+#define   L_LCD_PWM1_HI_ADDR                       (0x143f)
+#define P_L_LCD_PWM1_HI_ADDR                       (volatile unsigned int *)((0x143f  << 2) + 0xff900000)
+#define   L_INV_CNT_ADDR                           (0x1440)
+#define P_L_INV_CNT_ADDR                           (volatile unsigned int *)((0x1440  << 2) + 0xff900000)
+#define   L_TCON_MISC_SEL_ADDR                     (0x1441)
+#define P_L_TCON_MISC_SEL_ADDR                     (volatile unsigned int *)((0x1441  << 2) + 0xff900000)
+#define   L_DUAL_PORT_CNTL_ADDR                    (0x1442)
+#define P_L_DUAL_PORT_CNTL_ADDR                    (volatile unsigned int *)((0x1442  << 2) + 0xff900000)
+#define   MLVDS_CLK_CTL1_HI                        (0x1443)
+#define P_MLVDS_CLK_CTL1_HI                        (volatile unsigned int *)((0x1443  << 2) + 0xff900000)
+#define   MLVDS_CLK_CTL1_LO                        (0x1444)
+#define P_MLVDS_CLK_CTL1_LO                        (volatile unsigned int *)((0x1444  << 2) + 0xff900000)
+//  [31:30] enable mlvds clocks
+//  [24]    mlvds_clk_half_delay       24 // Bit 0
+//  [23:0]  mlvds_clk_pattern           0 // Bit 23:0
+#define   L_TCON_DOUBLE_CTL                        (0x1449)
+#define P_L_TCON_DOUBLE_CTL                        (volatile unsigned int *)((0x1449  << 2) + 0xff900000)
+#define   L_TCON_PATTERN_HI                        (0x144a)
+#define P_L_TCON_PATTERN_HI                        (volatile unsigned int *)((0x144a  << 2) + 0xff900000)
+#define   L_TCON_PATTERN_LO                        (0x144b)
+#define P_L_TCON_PATTERN_LO                        (volatile unsigned int *)((0x144b  << 2) + 0xff900000)
+#define   LDIM_BL_ADDR_PORT                        (0x144e)
+#define P_LDIM_BL_ADDR_PORT                        (volatile unsigned int *)((0x144e  << 2) + 0xff900000)
+#define   LDIM_BL_DATA_PORT                        (0x144f)
+#define P_LDIM_BL_DATA_PORT                        (volatile unsigned int *)((0x144f  << 2) + 0xff900000)
+#define   L_DE_HS_ADDR                             (0x1451)
+#define P_L_DE_HS_ADDR                             (volatile unsigned int *)((0x1451  << 2) + 0xff900000)
+#define   L_DE_HE_ADDR                             (0x1452)
+#define P_L_DE_HE_ADDR                             (volatile unsigned int *)((0x1452  << 2) + 0xff900000)
+#define   L_DE_VS_ADDR                             (0x1453)
+#define P_L_DE_VS_ADDR                             (volatile unsigned int *)((0x1453  << 2) + 0xff900000)
+#define   L_DE_VE_ADDR                             (0x1454)
+#define P_L_DE_VE_ADDR                             (volatile unsigned int *)((0x1454  << 2) + 0xff900000)
+#define   L_HSYNC_HS_ADDR                          (0x1455)
+#define P_L_HSYNC_HS_ADDR                          (volatile unsigned int *)((0x1455  << 2) + 0xff900000)
+#define   L_HSYNC_HE_ADDR                          (0x1456)
+#define P_L_HSYNC_HE_ADDR                          (volatile unsigned int *)((0x1456  << 2) + 0xff900000)
+#define   L_HSYNC_VS_ADDR                          (0x1457)
+#define P_L_HSYNC_VS_ADDR                          (volatile unsigned int *)((0x1457  << 2) + 0xff900000)
+#define   L_HSYNC_VE_ADDR                          (0x1458)
+#define P_L_HSYNC_VE_ADDR                          (volatile unsigned int *)((0x1458  << 2) + 0xff900000)
+#define   L_VSYNC_HS_ADDR                          (0x1459)
+#define P_L_VSYNC_HS_ADDR                          (volatile unsigned int *)((0x1459  << 2) + 0xff900000)
+#define   L_VSYNC_HE_ADDR                          (0x145a)
+#define P_L_VSYNC_HE_ADDR                          (volatile unsigned int *)((0x145a  << 2) + 0xff900000)
+#define   L_VSYNC_VS_ADDR                          (0x145b)
+#define P_L_VSYNC_VS_ADDR                          (volatile unsigned int *)((0x145b  << 2) + 0xff900000)
+#define   L_VSYNC_VE_ADDR                          (0x145c)
+#define P_L_VSYNC_VE_ADDR                          (volatile unsigned int *)((0x145c  << 2) + 0xff900000)
+// bit 8 -- vfifo_mcu_enable
+// bit 7 -- halt_vs_de
+// bit 6 -- R8G8B8_format
+// bit 5 -- R6G6B6_format (round to 6 bits)
+// bit 4 -- R5G6B5_format
+// bit 3 -- dac_dith_sel
+// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
+// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
+// bit 0 -- lcd_mcu_enable
+#define   L_LCD_MCU_CTL                            (0x145d)
+#define P_L_LCD_MCU_CTL                            (volatile unsigned int *)((0x145d  << 2) + 0xff900000)
+//**************************************************************************
+//*  Dual port mLVDS registers
+//**************************************************************************
+// bit 3 - enable_u_dual_mlvds_dp_clk
+// bit 2 - enable_u_map_mlvds_r_clk
+// bit 1 - enable_u_map_mlvds_l_clk
+// bit 0 - dual_mlvds_en
+//`define DUAL_MLVDS_CTL                8'h60
+// bit[12:0] - dual_mlvds_line_start
+//`define DUAL_MLVDS_LINE_START         8'h61
+// bit[12:0] - dual_mlvds_line_end
+//`define DUAL_MLVDS_LINE_END           8'h62
+// bit[12:0] - dual_mlvds_w_pixel_start_l
+//`define DUAL_MLVDS_PIXEL_W_START_L    8'h63
+// bit[12:0] - dual_mlvds_w_pixel_end_l
+//`define DUAL_MLVDS_PIXEL_W_END_L      8'h64
+// bit[12:0] - dual_mlvds_w_pixel_start_r
+//`define DUAL_MLVDS_PIXEL_W_START_R    8'h65
+// bit[12:0] - dual_mlvds_w_pixel_end_r
+//`define DUAL_MLVDS_PIXEL_W_END_R      8'h66
+// bit[12:0] - dual_mlvds_r_pixel_start_l
+//`define DUAL_MLVDS_PIXEL_R_START_L    8'h67
+// bit[12:0] - dual_mlvds_r_pixel_cnt_l
+//`define DUAL_MLVDS_PIXEL_R_CNT_L      8'h68
+// bit[12:0] - dual_mlvds_r_pixel_start_r
+//`define DUAL_MLVDS_PIXEL_R_START_R    8'h69
+// bit[12:0] - dual_mlvds_r_pixel_cnt_r
+//`define DUAL_MLVDS_PIXEL_R_CNT_R      8'h6a
+// bit[15]   - v_inversion_en
+// bit[12:0] - v_inversion_pixel
+//`define V_INVERSION_PIXEL             8'h70
+// bit[15]   - v_inversion_sync_en
+// bit[12:0] - v_inversion_line
+//`define V_INVERSION_LINE              8'h71
+// bit[15:12]  - v_loop_r
+// bit[11:10]  - v_pattern_1_r
+// bit[9:8]    - v_pattern_0_r
+// bit[7:4]    - v_loop_l
+// bit[3:2]    - v_pattern_1_l
+// bit[1:0]    - v_pattern_0_l
+//`define V_INVERSION_CONTROL           8'h72
+//`define MLVDS2_CONTROL           8'h74
+   #define     mLVDS2_RESERVED  15    // 15
+   #define     mLVDS2_double_pattern  14    // 14
+   #define     mLVDS2_ins_reset  8    // 13:8  // each channel has one bit
+   #define     mLVDS2_dual_gate  7
+   #define     mLVDS2_bit_num    6    // 0-6Bits, 1-8Bits
+   #define     mLVDS2_pair_num   5    // 0-3Pairs, 1-6Pairs
+   #define     mLVDS2_msb_first  4
+   #define     mLVDS2_PORT_SWAP  3
+   #define     mLVDS2_MLSB_SWAP  2
+   #define     mLVDS2_PN_SWAP    1
+   #define     mLVDS2_en         0
+//`define MLVDS2_CONFIG_HI         8'h75
+//`define MLVDS2_CONFIG_LO         8'h76
+   #define     mLVDS2_reset_offset         29 // Bit 31:29
+   #define     mLVDS2_reset_length         23 // Bit 28:23
+   #define     mLVDS2_config_reserved      20 // Bit 22:20
+   #define     mLVDS2_reset_start_bit12    19 // Bit 19
+   #define     mLVDS2_data_write_toggle    18
+   #define     mLVDS2_data_write_ini       17
+   #define     mLVDS2_data_latch_1_toggle  16
+   #define     mLVDS2_data_latch_1_ini     15
+   #define     mLVDS2_data_latch_0_toggle  14
+   #define     mLVDS2_data_latch_0_ini     13
+   #define     mLVDS2_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
+   #define     mLVDS2_reset_start           0 // Bit 11:0
+//`define MLVDS2_DUAL_GATE_WR_START        8'h77
+//   `define     mlvds2_dual_gate_wr_start    0 // Bit 12:0
+//`define MLVDS2_DUAL_GATE_WR_END          8'h78
+//   `define     mlvds2_dual_gate_wr_end      0 // Bit 12:0
+//
+//`define MLVDS2_DUAL_GATE_RD_START        8'h79
+//   `define     mlvds2_dual_gate_rd_start    0 // Bit 12:0
+//`define MLVDS2_DUAL_GATE_RD_END          8'h7a
+//   `define     mlvds2_dual_gate_rd_end      0 // Bit 12:0
+//`define MLVDS2_SECOND_RESET_CTL          8'h7b
+//   `define     mLVDS2_2nd_reset_start       0 // Bit 12:0
+//
+//`define MLVDS2_DUAL_GATE_CTL_HI        8'h7c
+//`define MLVDS2_DUAL_GATE_CTL_LO        8'h7d
+//   `define     mlvds2_tcon_field_en        24 // Bit 7:0
+//   `define     mlvds2_dual_gate_reserved   21 // Bit 2:0
+//   `define     mlvds2_scan_mode_start_line_bit12 20 // Bit 0
+//   `define     mlvds2_scan_mode_odd        16 // Bit 3:0
+//   `define     mlvds2_scan_mode_even       12 // Bit 3:0
+//   `define     mlvds2_scan_mode_start_line  0 // Bit 11:0
+//
+//`define MLVDS2_RESET_CONFIG_HI         8'h7e
+//`define MLVDS2_RESET_CONFIG_LO         8'h7f
+//   `define     mLVDS2_reset_range_enable   31 // Bit 0
+//   `define     mLVDS2_reset_range_inv      30 // Bit 0
+//   `define     mLVDS2_reset_config_res1    29 // Bit 0
+//   `define     mLVDS2_reset_range_line_0   16 // Bit 11:0
+//   `define     mLVDS2_reset_config_res3    13 // Bit 2:0
+//   `define     mLVDS2_reset_range_line_1    0 // Bit 11:0
+//
+//**************************************************************************
+//*  Vbyone registers  (Note: no MinLVDS in G9tv, share the register)
+//**************************************************************************
+#define   VBO_CTRL_L                               (0x1460)
+#define P_VBO_CTRL_L                               (volatile unsigned int *)((0x1460  << 2) + 0xff900000)
+#define   VBO_CTRL_H                               (0x1461)
+#define P_VBO_CTRL_H                               (volatile unsigned int *)((0x1461  << 2) + 0xff900000)
+#define   VBO_SOFT_RST                             (0x1462)
+#define P_VBO_SOFT_RST                             (volatile unsigned int *)((0x1462  << 2) + 0xff900000)
+#define   VBO_LANES                                (0x1463)
+#define P_VBO_LANES                                (volatile unsigned int *)((0x1463  << 2) + 0xff900000)
+#define   VBO_VIN_CTRL                             (0x1464)
+#define P_VBO_VIN_CTRL                             (volatile unsigned int *)((0x1464  << 2) + 0xff900000)
+#define   VBO_ACT_VSIZE                            (0x1465)
+#define P_VBO_ACT_VSIZE                            (volatile unsigned int *)((0x1465  << 2) + 0xff900000)
+#define   VBO_REGION_00                            (0x1466)
+#define P_VBO_REGION_00                            (volatile unsigned int *)((0x1466  << 2) + 0xff900000)
+#define   VBO_REGION_01                            (0x1467)
+#define P_VBO_REGION_01                            (volatile unsigned int *)((0x1467  << 2) + 0xff900000)
+#define   VBO_REGION_02                            (0x1468)
+#define P_VBO_REGION_02                            (volatile unsigned int *)((0x1468  << 2) + 0xff900000)
+#define   VBO_REGION_03                            (0x1469)
+#define P_VBO_REGION_03                            (volatile unsigned int *)((0x1469  << 2) + 0xff900000)
+#define   VBO_VBK_CTRL_0                           (0x146a)
+#define P_VBO_VBK_CTRL_0                           (volatile unsigned int *)((0x146a  << 2) + 0xff900000)
+#define   VBO_VBK_CTRL_1                           (0x146b)
+#define P_VBO_VBK_CTRL_1                           (volatile unsigned int *)((0x146b  << 2) + 0xff900000)
+#define   VBO_HBK_CTRL                             (0x146c)
+#define P_VBO_HBK_CTRL                             (volatile unsigned int *)((0x146c  << 2) + 0xff900000)
+#define   VBO_PXL_CTRL                             (0x146d)
+#define P_VBO_PXL_CTRL                             (volatile unsigned int *)((0x146d  << 2) + 0xff900000)
+#define   VBO_LANE_SKEW_L                          (0x146e)
+#define P_VBO_LANE_SKEW_L                          (volatile unsigned int *)((0x146e  << 2) + 0xff900000)
+#define   VBO_LANE_SKEW_H                          (0x146f)
+#define P_VBO_LANE_SKEW_H                          (volatile unsigned int *)((0x146f  << 2) + 0xff900000)
+#define   VBO_GCLK_LANE_L                          (0x1470)
+#define P_VBO_GCLK_LANE_L                          (volatile unsigned int *)((0x1470  << 2) + 0xff900000)
+#define   VBO_GCLK_LANE_H                          (0x1471)
+#define P_VBO_GCLK_LANE_H                          (volatile unsigned int *)((0x1471  << 2) + 0xff900000)
+#define   VBO_GCLK_MAIN                            (0x1472)
+#define P_VBO_GCLK_MAIN                            (volatile unsigned int *)((0x1472  << 2) + 0xff900000)
+#define   VBO_STATUS_L                             (0x1473)
+#define P_VBO_STATUS_L                             (volatile unsigned int *)((0x1473  << 2) + 0xff900000)
+#define   VBO_STATUS_H                             (0x1474)
+#define P_VBO_STATUS_H                             (volatile unsigned int *)((0x1474  << 2) + 0xff900000)
+#define   VBO_LANE_OUTPUT                          (0x1475)
+#define P_VBO_LANE_OUTPUT                          (volatile unsigned int *)((0x1475  << 2) + 0xff900000)
+#define   LCD_PORT_SWAP                            (0x1476)
+#define P_LCD_PORT_SWAP                            (volatile unsigned int *)((0x1476  << 2) + 0xff900000)
+#define   VBO_TMCHK_THRD_L                         (0x1478)
+#define P_VBO_TMCHK_THRD_L                         (volatile unsigned int *)((0x1478  << 2) + 0xff900000)
+#define   VBO_TMCHK_THRD_H                         (0x1479)
+#define P_VBO_TMCHK_THRD_H                         (volatile unsigned int *)((0x1479  << 2) + 0xff900000)
+#define   VBO_FSM_HOLDER_L                         (0x147a)
+#define P_VBO_FSM_HOLDER_L                         (volatile unsigned int *)((0x147a  << 2) + 0xff900000)
+#define   VBO_FSM_HOLDER_H                         (0x147b)
+#define P_VBO_FSM_HOLDER_H                         (volatile unsigned int *)((0x147b  << 2) + 0xff900000)
+#define   VBO_INTR_STATE_CTRL                      (0x147c)
+#define P_VBO_INTR_STATE_CTRL                      (volatile unsigned int *)((0x147c  << 2) + 0xff900000)
+#define   VBO_INTR_UNMASK                          (0x147d)
+#define P_VBO_INTR_UNMASK                          (volatile unsigned int *)((0x147d  << 2) + 0xff900000)
+#define   VBO_TMCHK_HSYNC_STATE_L                  (0x147e)
+#define P_VBO_TMCHK_HSYNC_STATE_L                  (volatile unsigned int *)((0x147e  << 2) + 0xff900000)
+#define   VBO_TMCHK_HSYNC_STATE_H                  (0x147f)
+#define P_VBO_TMCHK_HSYNC_STATE_H                  (volatile unsigned int *)((0x147f  << 2) + 0xff900000)
+#define   VBO_TMCHK_VSYNC_STATE_L                  (0x14f4)
+#define P_VBO_TMCHK_VSYNC_STATE_L                  (volatile unsigned int *)((0x14f4  << 2) + 0xff900000)
+#define   VBO_TMCHK_VSYNC_STATE_H                  (0x14f5)
+#define P_VBO_TMCHK_VSYNC_STATE_H                  (volatile unsigned int *)((0x14f5  << 2) + 0xff900000)
+#define   VBO_TMCHK_VDE_STATE_L                    (0x14f6)
+#define P_VBO_TMCHK_VDE_STATE_L                    (volatile unsigned int *)((0x14f6  << 2) + 0xff900000)
+#define   VBO_TMCHK_VDE_STATE_H                    (0x14f7)
+#define P_VBO_TMCHK_VDE_STATE_H                    (volatile unsigned int *)((0x14f7  << 2) + 0xff900000)
+#define   VBO_INTR_STATE                           (0x14f8)
+#define P_VBO_INTR_STATE                           (volatile unsigned int *)((0x14f8  << 2) + 0xff900000)
+#define   VBO_INFILTER_CTRL                        (0x14f9)
+#define P_VBO_INFILTER_CTRL                        (volatile unsigned int *)((0x14f9  << 2) + 0xff900000)
+#define   VBO_INSGN_CTRL                           (0x14fa)
+#define P_VBO_INSGN_CTRL                           (volatile unsigned int *)((0x14fa  << 2) + 0xff900000)
+//**************************************************************************
+//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
+//**************************************************************************
+#define   GAMMA_CNTL_PORT                          (0x1480)
+#define P_GAMMA_CNTL_PORT                          (volatile unsigned int *)((0x1480  << 2) + 0xff900000)
+   #define  GAMMA_VCOM_POL    7     //RW
+   #define  GAMMA_RVS_OUT     6     //RW
+   #define  ADR_RDY           5     //Read Only
+   #define  WR_RDY            4     //Read Only
+   #define  RD_RDY            3     //Read Only
+   #define  GAMMA_TR          2     //RW
+   #define  GAMMA_SET         1     //RW
+   #define  GAMMA_EN          0     //RW
+#define   GAMMA_DATA_PORT                          (0x1481)
+#define P_GAMMA_DATA_PORT                          (volatile unsigned int *)((0x1481  << 2) + 0xff900000)
+#define   GAMMA_ADDR_PORT                          (0x1482)
+#define P_GAMMA_ADDR_PORT                          (volatile unsigned int *)((0x1482  << 2) + 0xff900000)
+   #define  H_RD              12
+   #define  H_AUTO_INC        11
+   #define  H_SEL_R           10
+   #define  H_SEL_G           9
+   #define  H_SEL_B           8
+   #define  HADR_MSB          7            //7:0
+   #define  HADR              0            //7:0
+#define   GAMMA_VCOM_HSWITCH_ADDR                  (0x1483)
+#define P_GAMMA_VCOM_HSWITCH_ADDR                  (volatile unsigned int *)((0x1483  << 2) + 0xff900000)
+#define   RGB_BASE_ADDR                            (0x1485)
+#define P_RGB_BASE_ADDR                            (volatile unsigned int *)((0x1485  << 2) + 0xff900000)
+#define   RGB_COEFF_ADDR                           (0x1486)
+#define P_RGB_COEFF_ADDR                           (volatile unsigned int *)((0x1486  << 2) + 0xff900000)
+#define   POL_CNTL_ADDR                            (0x1487)
+#define P_POL_CNTL_ADDR                            (volatile unsigned int *)((0x1487  << 2) + 0xff900000)
+   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
+   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
+   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
+   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
+   #define   CPH3_POL         8
+   #define   CPH2_POL         7
+   #define   CPH1_POL         6
+   #define   TCON_DE_SEL      5
+   #define   TCON_VS_SEL      4
+   #define   TCON_HS_SEL      3
+   #define   DE_POL           2
+   #define   VS_POL           1
+   #define   HS_POL           0
+#define   DITH_CNTL_ADDR                           (0x1488)
+#define P_DITH_CNTL_ADDR                           (volatile unsigned int *)((0x1488  << 2) + 0xff900000)
+   #define  DITH10_EN         10
+   #define  DITH8_EN          9
+   #define  DITH_MD           8
+   #define  DITH10_CNTL_MSB   7          //7:4
+   #define  DITH10_CNTL       4          //7:4
+   #define  DITH8_CNTL_MSB    3          //3:0
+   #define  DITH8_CNTL        0          //3:0
+//Bit 1 highlight_en
+//Bit 0 probe_en
+#define   GAMMA_PROBE_CTRL                         (0x1489)
+#define P_GAMMA_PROBE_CTRL                         (volatile unsigned int *)((0x1489  << 2) + 0xff900000)
+//read only
+//Bit [15:0]  probe_color[15:0]
+#define   GAMMA_PROBE_COLOR_L                      (0x148a)
+#define P_GAMMA_PROBE_COLOR_L                      (volatile unsigned int *)((0x148a  << 2) + 0xff900000)
+//Read only
+//Bit 15: if true valid probed color
+//Bit [13:0]  probe_color[29:16]
+#define   GAMMA_PROBE_COLOR_H                      (0x148b)
+#define P_GAMMA_PROBE_COLOR_H                      (volatile unsigned int *)((0x148b  << 2) + 0xff900000)
+//bit 15:0, 5:6:5 color
+#define   GAMMA_PROBE_HL_COLOR                     (0x148c)
+#define P_GAMMA_PROBE_HL_COLOR                     (volatile unsigned int *)((0x148c  << 2) + 0xff900000)
+//12:0 pos_x
+#define   GAMMA_PROBE_POS_X                        (0x148d)
+#define P_GAMMA_PROBE_POS_X                        (volatile unsigned int *)((0x148d  << 2) + 0xff900000)
+//12:0 pos_y
+#define   GAMMA_PROBE_POS_Y                        (0x148e)
+#define P_GAMMA_PROBE_POS_Y                        (volatile unsigned int *)((0x148e  << 2) + 0xff900000)
+#define   STH1_HS_ADDR                             (0x1490)
+#define P_STH1_HS_ADDR                             (volatile unsigned int *)((0x1490  << 2) + 0xff900000)
+#define   STH1_HE_ADDR                             (0x1491)
+#define P_STH1_HE_ADDR                             (volatile unsigned int *)((0x1491  << 2) + 0xff900000)
+#define   STH1_VS_ADDR                             (0x1492)
+#define P_STH1_VS_ADDR                             (volatile unsigned int *)((0x1492  << 2) + 0xff900000)
+#define   STH1_VE_ADDR                             (0x1493)
+#define P_STH1_VE_ADDR                             (volatile unsigned int *)((0x1493  << 2) + 0xff900000)
+#define   STH2_HS_ADDR                             (0x1494)
+#define P_STH2_HS_ADDR                             (volatile unsigned int *)((0x1494  << 2) + 0xff900000)
+#define   STH2_HE_ADDR                             (0x1495)
+#define P_STH2_HE_ADDR                             (volatile unsigned int *)((0x1495  << 2) + 0xff900000)
+#define   STH2_VS_ADDR                             (0x1496)
+#define P_STH2_VS_ADDR                             (volatile unsigned int *)((0x1496  << 2) + 0xff900000)
+#define   STH2_VE_ADDR                             (0x1497)
+#define P_STH2_VE_ADDR                             (volatile unsigned int *)((0x1497  << 2) + 0xff900000)
+#define   OEH_HS_ADDR                              (0x1498)
+#define P_OEH_HS_ADDR                              (volatile unsigned int *)((0x1498  << 2) + 0xff900000)
+#define   OEH_HE_ADDR                              (0x1499)
+#define P_OEH_HE_ADDR                              (volatile unsigned int *)((0x1499  << 2) + 0xff900000)
+#define   OEH_VS_ADDR                              (0x149a)
+#define P_OEH_VS_ADDR                              (volatile unsigned int *)((0x149a  << 2) + 0xff900000)
+#define   OEH_VE_ADDR                              (0x149b)
+#define P_OEH_VE_ADDR                              (volatile unsigned int *)((0x149b  << 2) + 0xff900000)
+#define   VCOM_HSWITCH_ADDR                        (0x149c)
+#define P_VCOM_HSWITCH_ADDR                        (volatile unsigned int *)((0x149c  << 2) + 0xff900000)
+#define   VCOM_VS_ADDR                             (0x149d)
+#define P_VCOM_VS_ADDR                             (volatile unsigned int *)((0x149d  << 2) + 0xff900000)
+#define   VCOM_VE_ADDR                             (0x149e)
+#define P_VCOM_VE_ADDR                             (volatile unsigned int *)((0x149e  << 2) + 0xff900000)
+#define   CPV1_HS_ADDR                             (0x149f)
+#define P_CPV1_HS_ADDR                             (volatile unsigned int *)((0x149f  << 2) + 0xff900000)
+#define   CPV1_HE_ADDR                             (0x14a0)
+#define P_CPV1_HE_ADDR                             (volatile unsigned int *)((0x14a0  << 2) + 0xff900000)
+#define   CPV1_VS_ADDR                             (0x14a1)
+#define P_CPV1_VS_ADDR                             (volatile unsigned int *)((0x14a1  << 2) + 0xff900000)
+#define   CPV1_VE_ADDR                             (0x14a2)
+#define P_CPV1_VE_ADDR                             (volatile unsigned int *)((0x14a2  << 2) + 0xff900000)
+#define   CPV2_HS_ADDR                             (0x14a3)
+#define P_CPV2_HS_ADDR                             (volatile unsigned int *)((0x14a3  << 2) + 0xff900000)
+#define   CPV2_HE_ADDR                             (0x14a4)
+#define P_CPV2_HE_ADDR                             (volatile unsigned int *)((0x14a4  << 2) + 0xff900000)
+#define   CPV2_VS_ADDR                             (0x14a5)
+#define P_CPV2_VS_ADDR                             (volatile unsigned int *)((0x14a5  << 2) + 0xff900000)
+#define   CPV2_VE_ADDR                             (0x14a6)
+#define P_CPV2_VE_ADDR                             (volatile unsigned int *)((0x14a6  << 2) + 0xff900000)
+#define   STV1_HS_ADDR                             (0x14a7)
+#define P_STV1_HS_ADDR                             (volatile unsigned int *)((0x14a7  << 2) + 0xff900000)
+#define   STV1_HE_ADDR                             (0x14a8)
+#define P_STV1_HE_ADDR                             (volatile unsigned int *)((0x14a8  << 2) + 0xff900000)
+#define   STV1_VS_ADDR                             (0x14a9)
+#define P_STV1_VS_ADDR                             (volatile unsigned int *)((0x14a9  << 2) + 0xff900000)
+#define   STV1_VE_ADDR                             (0x14aa)
+#define P_STV1_VE_ADDR                             (volatile unsigned int *)((0x14aa  << 2) + 0xff900000)
+#define   STV2_HS_ADDR                             (0x14ab)
+#define P_STV2_HS_ADDR                             (volatile unsigned int *)((0x14ab  << 2) + 0xff900000)
+#define   STV2_HE_ADDR                             (0x14ac)
+#define P_STV2_HE_ADDR                             (volatile unsigned int *)((0x14ac  << 2) + 0xff900000)
+#define   STV2_VS_ADDR                             (0x14ad)
+#define P_STV2_VS_ADDR                             (volatile unsigned int *)((0x14ad  << 2) + 0xff900000)
+#define   STV2_VE_ADDR                             (0x14ae)
+#define P_STV2_VE_ADDR                             (volatile unsigned int *)((0x14ae  << 2) + 0xff900000)
+#define   OEV1_HS_ADDR                             (0x14af)
+#define P_OEV1_HS_ADDR                             (volatile unsigned int *)((0x14af  << 2) + 0xff900000)
+#define   OEV1_HE_ADDR                             (0x14b0)
+#define P_OEV1_HE_ADDR                             (volatile unsigned int *)((0x14b0  << 2) + 0xff900000)
+#define   OEV1_VS_ADDR                             (0x14b1)
+#define P_OEV1_VS_ADDR                             (volatile unsigned int *)((0x14b1  << 2) + 0xff900000)
+#define   OEV1_VE_ADDR                             (0x14b2)
+#define P_OEV1_VE_ADDR                             (volatile unsigned int *)((0x14b2  << 2) + 0xff900000)
+#define   OEV2_HS_ADDR                             (0x14b3)
+#define P_OEV2_HS_ADDR                             (volatile unsigned int *)((0x14b3  << 2) + 0xff900000)
+#define   OEV2_HE_ADDR                             (0x14b4)
+#define P_OEV2_HE_ADDR                             (volatile unsigned int *)((0x14b4  << 2) + 0xff900000)
+#define   OEV2_VS_ADDR                             (0x14b5)
+#define P_OEV2_VS_ADDR                             (volatile unsigned int *)((0x14b5  << 2) + 0xff900000)
+#define   OEV2_VE_ADDR                             (0x14b6)
+#define P_OEV2_VE_ADDR                             (volatile unsigned int *)((0x14b6  << 2) + 0xff900000)
+#define   OEV3_HS_ADDR                             (0x14b7)
+#define P_OEV3_HS_ADDR                             (volatile unsigned int *)((0x14b7  << 2) + 0xff900000)
+#define   OEV3_HE_ADDR                             (0x14b8)
+#define P_OEV3_HE_ADDR                             (volatile unsigned int *)((0x14b8  << 2) + 0xff900000)
+#define   OEV3_VS_ADDR                             (0x14b9)
+#define P_OEV3_VS_ADDR                             (volatile unsigned int *)((0x14b9  << 2) + 0xff900000)
+#define   OEV3_VE_ADDR                             (0x14ba)
+#define P_OEV3_VE_ADDR                             (volatile unsigned int *)((0x14ba  << 2) + 0xff900000)
+#define   LCD_PWR_ADDR                             (0x14bb)
+#define P_LCD_PWR_ADDR                             (volatile unsigned int *)((0x14bb  << 2) + 0xff900000)
+   #define      LCD_VDD        5
+   #define      LCD_VBL        4
+   #define      LCD_GPI_MSB    3
+   #define      LCD_GPIO       0
+#define   LCD_PWM0_LO_ADDR                         (0x14bc)
+#define P_LCD_PWM0_LO_ADDR                         (volatile unsigned int *)((0x14bc  << 2) + 0xff900000)
+#define   LCD_PWM0_HI_ADDR                         (0x14bd)
+#define P_LCD_PWM0_HI_ADDR                         (volatile unsigned int *)((0x14bd  << 2) + 0xff900000)
+#define   LCD_PWM1_LO_ADDR                         (0x14be)
+#define P_LCD_PWM1_LO_ADDR                         (volatile unsigned int *)((0x14be  << 2) + 0xff900000)
+#define   LCD_PWM1_HI_ADDR                         (0x14bf)
+#define P_LCD_PWM1_HI_ADDR                         (volatile unsigned int *)((0x14bf  << 2) + 0xff900000)
+#define   INV_CNT_ADDR                             (0x14c0)
+#define P_INV_CNT_ADDR                             (volatile unsigned int *)((0x14c0  << 2) + 0xff900000)
+   #define     INV_EN          4
+   #define     INV_CNT_MSB     3
+   #define     INV_CNT         0
+#define   TCON_MISC_SEL_ADDR                       (0x14c1)
+#define P_TCON_MISC_SEL_ADDR                       (volatile unsigned int *)((0x14c1  << 2) + 0xff900000)
+   #define     STH2_SEL        12
+   #define     STH1_SEL        11
+   #define     OEH_SEL         10
+   #define     VCOM_SEL         9
+   #define     DB_LINE_SW       8
+   #define     CPV2_SEL         7
+   #define     CPV1_SEL         6
+   #define     STV2_SEL         5
+   #define     STV1_SEL         4
+   #define     OEV_UNITE        3
+   #define     OEV3_SEL         2
+   #define     OEV2_SEL         1
+   #define     OEV1_SEL         0
+#define   DUAL_PORT_CNTL_ADDR                      (0x14c2)
+#define P_DUAL_PORT_CNTL_ADDR                      (volatile unsigned int *)((0x14c2  << 2) + 0xff900000)
+   #define     OUTPUT_YUV       15
+   #define     DUAL_IDF         12   // 14:12
+   #define     DUAL_ISF         9    // 11:9
+   #define     LCD_ANALOG_SEL_CPH3   8
+   #define     LCD_ANALOG_3PHI_CLK_SEL   7
+   #define     LCD_LVDS_SEL54   6
+   #define     LCD_LVDS_SEL27   5
+   #define     LCD_TTL_SEL      4
+   #define     DUAL_LVDC_EN     3
+   #define     PORT_SWP         2
+   #define     RGB_SWP          1
+   #define     BIT_SWP          0
+#define   MLVDS_CONTROL                            (0x14c3)
+#define P_MLVDS_CONTROL                            (volatile unsigned int *)((0x14c3  << 2) + 0xff900000)
+   #define     mLVDS_RESERVED  15    // 15
+   #define     mLVDS_double_pattern  14    // 14
+   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
+   #define     mLVDS_dual_gate  7
+   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
+   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
+   #define     mLVDS_msb_first  4
+   #define     mLVDS_PORT_SWAP  3
+   #define     mLVDS_MLSB_SWAP  2
+   #define     mLVDS_PN_SWAP    1
+   #define     mLVDS_en         0
+#define   MLVDS_RESET_PATTERN_HI                   (0x14c4)
+#define P_MLVDS_RESET_PATTERN_HI                   (volatile unsigned int *)((0x14c4  << 2) + 0xff900000)
+#define   MLVDS_RESET_PATTERN_LO                   (0x14c5)
+#define P_MLVDS_RESET_PATTERN_LO                   (volatile unsigned int *)((0x14c5  << 2) + 0xff900000)
+   #define     mLVDS_reset_pattern  0 // Bit 47:16
+#define   MLVDS_RESET_PATTERN_EXT                  (0x14c6)
+#define P_MLVDS_RESET_PATTERN_EXT                  (volatile unsigned int *)((0x14c6  << 2) + 0xff900000)
+   #define     mLVDS_reset_pattern_ext  0 // Bit 15:0
+#define   MLVDS_CONFIG_HI                          (0x14c7)
+#define P_MLVDS_CONFIG_HI                          (volatile unsigned int *)((0x14c7  << 2) + 0xff900000)
+#define   MLVDS_CONFIG_LO                          (0x14c8)
+#define P_MLVDS_CONFIG_LO                          (volatile unsigned int *)((0x14c8  << 2) + 0xff900000)
+   #define     mLVDS_reset_offset         29 // Bit 31:29
+   #define     mLVDS_reset_length         23 // Bit 28:23
+   #define     mLVDS_config_reserved      20 // Bit 22:20
+   #define     mLVDS_reset_start_bit12    19 // Bit 19
+   #define     mLVDS_data_write_toggle    18
+   #define     mLVDS_data_write_ini       17
+   #define     mLVDS_data_latch_1_toggle  16
+   #define     mLVDS_data_latch_1_ini     15
+   #define     mLVDS_data_latch_0_toggle  14
+   #define     mLVDS_data_latch_0_ini     13
+   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
+   #define     mLVDS_reset_start           0 // Bit 11:0
+#define   TCON_DOUBLE_CTL                          (0x14c9)
+#define P_TCON_DOUBLE_CTL                          (volatile unsigned int *)((0x14c9  << 2) + 0xff900000)
+   #define     tcon_double_ini          8 // Bit 7:0
+   #define     tcon_double_inv          0 // Bit 7:0
+#define   TCON_PATTERN_HI                          (0x14ca)
+#define P_TCON_PATTERN_HI                          (volatile unsigned int *)((0x14ca  << 2) + 0xff900000)
+#define   TCON_PATTERN_LO                          (0x14cb)
+#define P_TCON_PATTERN_LO                          (volatile unsigned int *)((0x14cb  << 2) + 0xff900000)
+   #define     tcon_pattern_loop_data     16 // Bit 15:0
+   #define     tcon_pattern_loop_start    12 // Bit 3:0
+   #define     tcon_pattern_loop_end       8 // Bit 3:0
+   #define     tcon_pattern_enable         0 // Bit 7:0
+#define   TCON_CONTROL_HI                          (0x14cc)
+#define P_TCON_CONTROL_HI                          (volatile unsigned int *)((0x14cc  << 2) + 0xff900000)
+#define   TCON_CONTROL_LO                          (0x14cd)
+#define P_TCON_CONTROL_LO                          (volatile unsigned int *)((0x14cd  << 2) + 0xff900000)
+   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
+   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
+   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
+#define   LVDS_BLANK_DATA_HI                       (0x14ce)
+#define P_LVDS_BLANK_DATA_HI                       (volatile unsigned int *)((0x14ce  << 2) + 0xff900000)
+#define   LVDS_BLANK_DATA_LO                       (0x14cf)
+#define P_LVDS_BLANK_DATA_LO                       (volatile unsigned int *)((0x14cf  << 2) + 0xff900000)
+   #define     LVDS_blank_data_reserved 30  // 31:30
+   #define     LVDS_blank_data_r        20  // 29:20
+   #define     LVDS_blank_data_g        10  // 19:10
+   #define     LVDS_blank_data_b         0  //  9:0
+#define   LVDS_PACK_CNTL_ADDR                      (0x14d0)
+#define P_LVDS_PACK_CNTL_ADDR                      (volatile unsigned int *)((0x14d0  << 2) + 0xff900000)
+   #define     LVDS_USE_TCON    7
+   #define     LVDS_DUAL        6
+   #define     PN_SWP           5
+   #define     LSB_FIRST        4
+   #define     LVDS_RESV        3
+   #define     ODD_EVEN_SWP     2
+   #define     LVDS_REPACK      0
+// New from M3 :
+// Bit 15:12 -- Enable OFFSET Double Generate(TOCN7-TCON4)
+// Bit 11:0 -- de_hs(old tcon) second offset_hs (new tcon)
+#define   DE_HS_ADDR                               (0x14d1)
+#define P_DE_HS_ADDR                               (volatile unsigned int *)((0x14d1  << 2) + 0xff900000)
+// New from M3 :
+// Bit 15:12 -- Enable OFFSET Double Generate(TOCN3-TCON0)
+#define   DE_HE_ADDR                               (0x14d2)
+#define P_DE_HE_ADDR                               (volatile unsigned int *)((0x14d2  << 2) + 0xff900000)
+#define   DE_VS_ADDR                               (0x14d3)
+#define P_DE_VS_ADDR                               (volatile unsigned int *)((0x14d3  << 2) + 0xff900000)
+#define   DE_VE_ADDR                               (0x14d4)
+#define P_DE_VE_ADDR                               (volatile unsigned int *)((0x14d4  << 2) + 0xff900000)
+#define   HSYNC_HS_ADDR                            (0x14d5)
+#define P_HSYNC_HS_ADDR                            (volatile unsigned int *)((0x14d5  << 2) + 0xff900000)
+#define   HSYNC_HE_ADDR                            (0x14d6)
+#define P_HSYNC_HE_ADDR                            (volatile unsigned int *)((0x14d6  << 2) + 0xff900000)
+#define   HSYNC_VS_ADDR                            (0x14d7)
+#define P_HSYNC_VS_ADDR                            (volatile unsigned int *)((0x14d7  << 2) + 0xff900000)
+#define   HSYNC_VE_ADDR                            (0x14d8)
+#define P_HSYNC_VE_ADDR                            (volatile unsigned int *)((0x14d8  << 2) + 0xff900000)
+#define   VSYNC_HS_ADDR                            (0x14d9)
+#define P_VSYNC_HS_ADDR                            (volatile unsigned int *)((0x14d9  << 2) + 0xff900000)
+#define   VSYNC_HE_ADDR                            (0x14da)
+#define P_VSYNC_HE_ADDR                            (volatile unsigned int *)((0x14da  << 2) + 0xff900000)
+#define   VSYNC_VS_ADDR                            (0x14db)
+#define P_VSYNC_VS_ADDR                            (volatile unsigned int *)((0x14db  << 2) + 0xff900000)
+#define   VSYNC_VE_ADDR                            (0x14dc)
+#define P_VSYNC_VE_ADDR                            (volatile unsigned int *)((0x14dc  << 2) + 0xff900000)
+// bit 8 -- vfifo_mcu_enable
+// bit 7 -- halt_vs_de
+// bit 6 -- R8G8B8_format
+// bit 5 -- R6G6B6_format (round to 6 bits)
+// bit 4 -- R5G6B5_format
+// bit 3 -- dac_dith_sel
+// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
+// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
+// bit 0 -- lcd_mcu_enable
+#define   LCD_MCU_CTL                              (0x14dd)
+#define P_LCD_MCU_CTL                              (volatile unsigned int *)((0x14dd  << 2) + 0xff900000)
+// ReadOnly
+//   R5G6B5 when R5G6B5_format
+//   G8R8   when R8G8B8_format
+//   G5R10  Other
+#define   LCD_MCU_DATA_0                           (0x14de)
+#define P_LCD_MCU_DATA_0                           (volatile unsigned int *)((0x14de  << 2) + 0xff900000)
+// ReadOnly
+//   G8B8   when R8G8B8_format
+//   G5B10  Other
+#define   LCD_MCU_DATA_1                           (0x14df)
+#define P_LCD_MCU_DATA_1                           (volatile unsigned int *)((0x14df  << 2) + 0xff900000)
+// LVDS
+#define   LVDS_GEN_CNTL                            (0x14e0)
+#define P_LVDS_GEN_CNTL                            (volatile unsigned int *)((0x14e0  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL0                           (0x14e1)
+#define P_LVDS_PHY_CNTL0                           (volatile unsigned int *)((0x14e1  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL1                           (0x14e2)
+#define P_LVDS_PHY_CNTL1                           (volatile unsigned int *)((0x14e2  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL2                           (0x14e3)
+#define P_LVDS_PHY_CNTL2                           (volatile unsigned int *)((0x14e3  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL3                           (0x14e4)
+#define P_LVDS_PHY_CNTL3                           (volatile unsigned int *)((0x14e4  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL4                           (0x14e5)
+#define P_LVDS_PHY_CNTL4                           (volatile unsigned int *)((0x14e5  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL5                           (0x14e6)
+#define P_LVDS_PHY_CNTL5                           (volatile unsigned int *)((0x14e6  << 2) + 0xff900000)
+#define   LVDS_SRG_TEST                            (0x14e8)
+#define P_LVDS_SRG_TEST                            (volatile unsigned int *)((0x14e8  << 2) + 0xff900000)
+#define   LVDS_BIST_MUX0                           (0x14e9)
+#define P_LVDS_BIST_MUX0                           (volatile unsigned int *)((0x14e9  << 2) + 0xff900000)
+#define   LVDS_BIST_MUX1                           (0x14ea)
+#define P_LVDS_BIST_MUX1                           (volatile unsigned int *)((0x14ea  << 2) + 0xff900000)
+#define   LVDS_BIST_FIXED0                         (0x14eb)
+#define P_LVDS_BIST_FIXED0                         (volatile unsigned int *)((0x14eb  << 2) + 0xff900000)
+#define   LVDS_BIST_FIXED1                         (0x14ec)
+#define P_LVDS_BIST_FIXED1                         (volatile unsigned int *)((0x14ec  << 2) + 0xff900000)
+#define   LVDS_BIST_CNTL0                          (0x14ed)
+#define P_LVDS_BIST_CNTL0                          (volatile unsigned int *)((0x14ed  << 2) + 0xff900000)
+#define   LVDS_CLKB_CLKA                           (0x14ee)
+#define P_LVDS_CLKB_CLKA                           (volatile unsigned int *)((0x14ee  << 2) + 0xff900000)
+#define   LVDS_PHY_CLK_CNTL                        (0x14ef)
+#define P_LVDS_PHY_CLK_CNTL                        (volatile unsigned int *)((0x14ef  << 2) + 0xff900000)
+#define   LVDS_SER_EN                              (0x14f0)
+#define P_LVDS_SER_EN                              (volatile unsigned int *)((0x14f0  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL6                           (0x14f1)
+#define P_LVDS_PHY_CNTL6                           (volatile unsigned int *)((0x14f1  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL7                           (0x14f2)
+#define P_LVDS_PHY_CNTL7                           (volatile unsigned int *)((0x14f2  << 2) + 0xff900000)
+#define   LVDS_PHY_CNTL8                           (0x14f3)
+#define P_LVDS_PHY_CNTL8                           (volatile unsigned int *)((0x14f3  << 2) + 0xff900000)
+//`define MLVDS_CLK_CTL0_HI        8'hf4
+//`define MLVDS_CLK_CTL0_LO        8'hf5
+//   `define     mlvds_clk_pattern_reserved 31 // Bit 31
+//   `define     mpclk_dly                  28 // Bit 2:0
+//   `define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
+//   `define     use_mpclk                  25 // Bit 0
+//   `define     mlvds_clk_half_delay       24 // Bit 0
+//   `define     mlvds_clk_pattern           0 // Bit 23:0
+//`define MLVDS_DUAL_GATE_WR_START        8'hf6
+//   `define     mlvds_dual_gate_wr_start    0 // Bit 12:0
+//`define MLVDS_DUAL_GATE_WR_END          8'hf7
+//   `define     mlvds_dual_gate_wr_end      0 // Bit 12:0
+//
+//`define MLVDS_DUAL_GATE_RD_START        8'hf8
+//   `define     mlvds_dual_gate_rd_start    0 // Bit 12:0
+//`define MLVDS_DUAL_GATE_RD_END          8'hf9
+//   `define     mlvds_dual_gate_rd_end      0 // Bit 12:0
+//`define MLVDS_SECOND_RESET_CTL          8'hfa
+//   `define     mLVDS_2nd_reset_start       0 // Bit 12:0
+//
+#define   MLVDS_DUAL_GATE_CTL_HI                   (0x14fb)
+#define P_MLVDS_DUAL_GATE_CTL_HI                   (volatile unsigned int *)((0x14fb  << 2) + 0xff900000)
+#define   MLVDS_DUAL_GATE_CTL_LO                   (0x14fc)
+#define P_MLVDS_DUAL_GATE_CTL_LO                   (volatile unsigned int *)((0x14fc  << 2) + 0xff900000)
+//   `define     mlvds_tcon_field_en        24 // Bit 7:0
+//   `define     mlvds_dual_gate_reserved   21 // Bit 2:0
+//   `define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
+//   `define     mlvds_scan_mode_odd        16 // Bit 3:0
+//   `define     mlvds_scan_mode_even       12 // Bit 3:0
+//   `define     mlvds_scan_mode_start_line  0 // Bit 11:0
+//
+//`define MLVDS_RESET_CONFIG_HI         8'hfd
+//`define MLVDS_RESET_CONFIG_LO         8'hfe
+//   `define     mLVDS_reset_range_enable   31 // Bit 0
+//   `define     mLVDS_reset_range_inv      30 // Bit 0
+//   `define     mLVDS_reset_config_res1    29 // Bit 0
+//   `define     mLVDS_reset_range_line_0   16 // Bit 11:0
+//   `define     mLVDS_reset_config_res3    13 // Bit 2:0
+//   `define     mLVDS_reset_range_line_1    0 // Bit 11:0
+//===============================================================
+//LCD DRIVER BASE   END
+//===============================================================
+//
+// Closing file:  lcd_regs.h
+//
+//`define MAD_VCBUS_BASE               8'h17
+//
+// Reading file:  mad_regs.h
+//
+//DEINTERLACE module start from 8'h90 end to 8'hff
+// -----------------------------------------------
+// CBUS_BASE:  MAD_VCBUS_BASE = 0x17
+// -----------------------------------------------
+#define   DI_PRE_CTRL                              (0x1700)
+#define P_DI_PRE_CTRL                              (volatile unsigned int *)((0x1700  << 2) + 0xff900000)
+// bit 31,      cbus_pre_frame_rst
+// bit 30,      cbus_pre_soft_rst
+// bit 29,      pre_field_num
+// bit 27:26,   mode_444c422
+// bit 25,      di_cont_read_en
+// bit 24:23,   mode_422c444
+// bit 22,      mtn_after_nr
+// bit 21:16,   pre_hold_fifo_lines
+// bit 15,      nr_wr_by
+// bit 14,      use_vdin_go_line
+// bit 13,      di_prevdin_en
+// bit 12,      di_pre_viu_link
+// bit 11,      di_pre_repeat
+// bit 10,      di_pre_drop_1st
+// bit  9,      di_buf2_en
+// bit  8,      di_chan2_en
+// bit  7,      prenr_hist_en
+// bit  6,      chan2_hist_en
+// bit  5,      hist_check_en
+// bit  4,      check_after_nr
+// bit  3,      check222p_en
+// bit  2,      check322p_en
+// bit  1,      mtn_en
+// bit  0,      nr_en
+#define   DI_POST_CTRL                             (0x1701)
+#define P_DI_POST_CTRL                             (volatile unsigned int *)((0x1701  << 2) + 0xff900000)
+// bit 31,      cbus_post_frame_rst
+// bit 30,      cbus_post_soft_rst
+// bit 29,      post_field_num
+// bit 21:16,   post_hold_fifo_lines
+// bit 13,      prepost_link
+// bit 12,      di_post_viu_link
+// bit 11,      di_post_repeat
+// bit 10,      di_post_drop_1st
+// bit  9,      mif0_to_vpp_en
+// bit  8,      di_vpp_out_en
+// bit  7,      di_wr_bk_en
+// bit  6,      di_mux_en
+// bit  5,      di_blend_en
+// bit  4,      di_mtnp_read_en
+// bit  3,      di_mtn_buf_en
+// bit  2,      di_ei_en
+// bit  1,      di_buf1_en
+// bit  0,      di_buf0_en
+#define   DI_POST_SIZE                             (0x1702)
+#define P_DI_POST_SIZE                             (volatile unsigned int *)((0x1702  << 2) + 0xff900000)
+//bit 28:16,    vsize1post
+//bit 12:0,     hsize1post
+#define   DI_PRE_SIZE                              (0x1703)
+#define P_DI_PRE_SIZE                              (volatile unsigned int *)((0x1703  << 2) + 0xff900000)
+//bit 28:16,    vsize1pre
+//bit 12:0,     hsize1pre
+#define   DI_EI_CTRL0                              (0x1704)
+#define P_DI_EI_CTRL0                              (volatile unsigned int *)((0x1704  << 2) + 0xff900000)
+//bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter && ...right>filter && ...top>filter && ...bot>filter -> filter
+//bit 15:8,     ei0_threshold[2:+]
+//bit 3,        ei0_vertical
+//bit 2,        ei0_bpscf2
+//bit 1,        ei0_bpsfar1
+#define   DI_EI_CTRL1                              (0x1705)
+#define P_DI_EI_CTRL1                              (volatile unsigned int *)((0x1705  << 2) + 0xff900000)
+//bit 31:24,    ei0_diff
+//bit 23:16,    ei0_angle45
+//bit 15:8,     ei0_peak
+//bit 7:0,      ei0_cross
+#define   DI_EI_CTRL2                              (0x1706)
+#define P_DI_EI_CTRL2                              (volatile unsigned int *)((0x1706  << 2) + 0xff900000)
+//bit 31:24,    ei0_close2
+//bit 23:16,    ei0_close1
+//bit 15:8,     ei0_far2
+//bit 7:0,      ei0_far1
+#define   DI_NR_CTRL0                              (0x1707)
+#define P_DI_NR_CTRL0                              (volatile unsigned int *)((0x1707  << 2) + 0xff900000)
+//bit 26,       nr_cue_en
+//bit 25,       nr2_en
+#define   DI_NR_CTRL1                              (0x1708)
+#define P_DI_NR_CTRL1                              (volatile unsigned int *)((0x1708  << 2) + 0xff900000)
+//bit 31:30,    mot_p1txtcore_mode
+//bit 29:24,    mot_p1txtcore_clmt
+//bit 21:16,    mot_p1txtcore_ylmt
+//bit 15:8,     mot_p1txtcore_crate
+//bit 7:0,      mot_p1txtcore_yrate
+#define   DI_NR_CTRL2                              (0x1709)
+#define P_DI_NR_CTRL2                              (volatile unsigned int *)((0x1709  << 2) + 0xff900000)
+//bit 29:24,    mot_curtxtcore_clmt
+//bit 21:16,    mot_curtxtcore_ylmt
+//bit 15:8,     mot_curtxtcore_crate
+//bit 7:0,      mot_curtxtcore_yrate
+//`define DI_NR_CTRL3               8'h0a
+//no use
+//`define DI_MTN_CTRL               8'h0b
+//no use
+#define   DI_CANVAS_URGENT0                        (0x170a)
+#define P_DI_CANVAS_URGENT0                        (volatile unsigned int *)((0x170a  << 2) + 0xff900000)
+#define   DI_CANVAS_URGENT1                        (0x170b)
+#define P_DI_CANVAS_URGENT1                        (volatile unsigned int *)((0x170b  << 2) + 0xff900000)
+#define   DI_MTN_CTRL1                             (0x170c)
+#define P_DI_MTN_CTRL1                             (volatile unsigned int *)((0x170c  << 2) + 0xff900000)
+//bit 13 ,      me enable
+//bit 12 ,      me autoenable
+//bit 11:8,		mtn_paramtnthd
+//bit 7:0,      mtn_parafltthd
+#define   DI_BLEND_CTRL                            (0x170d)
+#define P_DI_BLEND_CTRL                            (volatile unsigned int *)((0x170d  << 2) + 0xff900000)
+//bit 31,      blend_1_en
+//bit 30,      blend_mtn_lpf
+//bit 28,      post_mb_en
+//bit 27,      blend_mtn3p_max
+//bit 26,      blend_mtn3p_min
+//bit 25,      blend_mtn3p_ave
+//bit 24,      blend_mtn3p_maxtb
+//bit 23,      blend_mtn_flt_en
+//bit 22,      blend_data_flt_en
+//bit 21:20,   blend_top_mode
+//bit 19,      blend_reg3_enable
+//bit 18,      blend_reg2_enable
+//bit 17,      blend_reg1_enable
+//bit 16,      blend_reg0_enable
+//bit 15:14,   blend_reg3_mode
+//bit 13:12,   blend_reg2_mode
+//bit 11:10,   blend_reg1_mode
+//bit 9:8,     blend_reg0_mode
+//bit 7:0,     kdeint
+//`define DI_BLEND_CTRL1            8'h0e
+//no use
+#define   DI_CANVAS_URGENT2                        (0x170e)
+#define P_DI_CANVAS_URGENT2                        (volatile unsigned int *)((0x170e  << 2) + 0xff900000)
+//`define DI_BLEND_CTRL2            8'h0f
+//no use
+#define   DI_ARB_CTRL                              (0x170f)
+#define P_DI_ARB_CTRL                              (volatile unsigned int *)((0x170f  << 2) + 0xff900000)
+//bit 31:26,			di_arb_thd1
+//bit 25:20,			di_arb_thd0
+//bit 19,			di_arb_tid_mode
+//bit 18,			di_arb_arb_mode
+//bit 17,			di_arb_acq_en
+//bit 16,			di_arb_disable_clk
+//bit 15:0,			di_arb_req_en
+#define   DI_BLEND_REG0_X                          (0x1710)
+#define P_DI_BLEND_REG0_X                          (volatile unsigned int *)((0x1710  << 2) + 0xff900000)
+//bit 27:16,   blend_reg0_startx
+//bit 11:0,    blend_reg0_endx
+#define   DI_BLEND_REG0_Y                          (0x1711)
+#define P_DI_BLEND_REG0_Y                          (volatile unsigned int *)((0x1711  << 2) + 0xff900000)
+#define   DI_BLEND_REG1_X                          (0x1712)
+#define P_DI_BLEND_REG1_X                          (volatile unsigned int *)((0x1712  << 2) + 0xff900000)
+#define   DI_BLEND_REG1_Y                          (0x1713)
+#define P_DI_BLEND_REG1_Y                          (volatile unsigned int *)((0x1713  << 2) + 0xff900000)
+#define   DI_BLEND_REG2_X                          (0x1714)
+#define P_DI_BLEND_REG2_X                          (volatile unsigned int *)((0x1714  << 2) + 0xff900000)
+#define   DI_BLEND_REG2_Y                          (0x1715)
+#define P_DI_BLEND_REG2_Y                          (volatile unsigned int *)((0x1715  << 2) + 0xff900000)
+#define   DI_BLEND_REG3_X                          (0x1716)
+#define P_DI_BLEND_REG3_X                          (volatile unsigned int *)((0x1716  << 2) + 0xff900000)
+#define   DI_BLEND_REG3_Y                          (0x1717)
+#define P_DI_BLEND_REG3_Y                          (volatile unsigned int *)((0x1717  << 2) + 0xff900000)
+#define   DI_CLKG_CTRL                             (0x1718)
+#define P_DI_CLKG_CTRL                             (volatile unsigned int *)((0x1718  << 2) + 0xff900000)
+//bit 31:24,   pre_gclk_ctrl     no clk gate control. if ==1, module clk is not gated (always on). [3] for pulldown,[2] for mtn_1,[1] for mtn_0,[0] for nr
+//bit 23:16,   post_gclk_ctrl    no clk gate control. [4] for ei_1, [3] for ei_0,[2] for ei_top, [1] for blend_1, [0] for blend_0
+//bit 1,       di_gate_all       clk shut down. if ==1 , all di clock shut down
+//bit 0,       di_no_clk_gate    no clk gate control.     if di_gated_all==0 and di_no_clk_gate ==1, all di clock is always working.
+#define   DI_EI_CTRL3                              (0x1719)
+#define P_DI_EI_CTRL3                              (volatile unsigned int *)((0x1719  << 2) + 0xff900000)
+//bit 31,      reg_ei_1
+//bit 30,      reg_demon_en
+//bit 26:24,   reg_demon_mux
+//bit 23:20,   reg_right_win
+//bit 19:16,   reg_left_win
+//bit 7:4,     reg_ei_sadm_quatize_margin
+//bit 1:0,     reg_ei_sad_relative_mode
+#define   DI_EI_CTRL4                              (0x171a)
+#define P_DI_EI_CTRL4                              (volatile unsigned int *)((0x171a  << 2) + 0xff900000)
+//bit 29,      reg_ei_caldrt_ambliike2_biasvertical
+//bit 28:24,   reg_ei_caldrt_addxla2list_drtmax
+//bit 22:20,   reg_ei_caldrt_addxla2list_signm0th
+//bit 19,      reg_ei_caldrt_addxla2list_mode
+//bit 18:16,   reg_ei_signm_sad_cor_rate
+//bit 15:12,   reg_ei_signm_sadi_cor_rate
+//bit 11:6,    reg_ei_signm_sadi_cor_ofst
+//bit 5:0,     reg_ei_signm_sad_ofst
+#define   DI_EI_CTRL5                              (0x171b)
+#define P_DI_EI_CTRL5                              (volatile unsigned int *)((0x171b  << 2) + 0xff900000)
+//bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd
+//bit 26:24,   reg_ei_caldrt_cnflctchk_mg
+//bit 23:22,   reg_ei_caldrt_cnflctchk_ws
+//bit 21,      reg_ei_caldrt_cnflctchk_en
+//bit 20,      reg_ei_caldrt_verfrc_final_en
+//bit 19,      reg_ei_caldrt_verfrc_retimflt_en
+//bit 18:16,   reg_ei_caldrt_verftc_eithratemth
+//bit 15,      reg_ei_caldrt_verfrc_retiming_en
+//bit 14:12,   reg_ei_caldrt_verfrc_bothratemth
+//bit 11:9,    reg_ei_caldrt_ver_thrd
+//bit 8:4,     reg_ei_caldrt_addxla2list_drtmin
+//bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit
+#define   DI_EI_CTRL6                              (0x171c)
+#define P_DI_EI_CTRL6                              (volatile unsigned int *)((0x171c  << 2) + 0xff900000)
+//bit 31:24,   reg_ei_caldrt_abext_sad12thhig
+//bit 23:16,   reg_ei_caldrt_abext_sad00thlow
+//bit 15:8,    reg_ei_caldrt_abext_sad12thlow
+//bit 6:4,     reg_ei_caldrt_abext_ratemth
+//bit 2:0,     reg_ei_caldrt_abext_drtthrd
+#define   DI_EI_CTRL7                              (0x171d)
+#define P_DI_EI_CTRL7                              (volatile unsigned int *)((0x171d  << 2) + 0xff900000)
+//bit 29,      reg_ei_caldrt_xlanopeak_codien
+//bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax
+//bit 23,      reg_ei_caldrt_xlanopeak_en
+//bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha
+//bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd
+//bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd
+//bit 28:24,   reg_ei_caldrt_abext_sad00rate
+//bit 28:24,   reg_ei_caldrt_abext_sad12rate
+//bit 28:24,   reg_ei_caldrt_abext_sad00thhig
+#define   DI_EI_CTRL8                              (0x171e)
+#define P_DI_EI_CTRL8                              (volatile unsigned int *)((0x171e  << 2) + 0xff900000)
+//bit 30:28,   reg_ei_assign_headtail_magin
+//bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode
+//bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth
+//bit 20,      reg_ei_caldrt_histchk_cnfid
+//bit 19:16,   reg_ei_caldrt_histchk_thrd
+//bit 15,      reg_ei_caldrt_histchk_abext
+//bit 14,      reg_ei_caldrt_histchk_npen
+//bit 13:11,   reg_ei_caldrt_amblike2_drtmg
+//bit 10:8,    reg_ei_caldrt_amblike2_valmg
+//bit 7:4,     reg_ei_caldrt_amblike2_alpha
+//bit 3:0,     reg_ei_caldrt_amblike2_drtth
+#define   DI_EI_CTRL9                              (0x171f)
+#define P_DI_EI_CTRL9                              (volatile unsigned int *)((0x171f  << 2) + 0xff900000)
+//bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3
+//bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en
+//bit 26:24,   reg_ei_caldrt_conf_drtth
+//bit 23:20,   reg_ei_caldrt_conf_absdrtth
+//bit 19:18,   reg_ei_caldrt_abcheck_mode1
+//bit 17:16,   reg_ei_caldrt_abcheck_mode0
+//bit 15:12,   reg_ei_caldrt_abcheck_drth1
+//bit 11:8,    reg_ei_caldrt_abcheck_drth0
+//bit 6:4,     reg_ei_caldrt_abpnchk1_th
+//bit 1,       reg_ei_caldrt_abpnchk1_en
+//bit 0,       reg_ei_caldrt_abpnchk0_en
+// DEINTERLACE mode check.
+#define   DI_MC_REG0_X                             (0x1720)
+#define P_DI_MC_REG0_X                             (volatile unsigned int *)((0x1720  << 2) + 0xff900000)
+//bit 27:16,   mc_reg0_start_x
+//bit 11:0,    mc_reg0_end_x
+#define   DI_MC_REG0_Y                             (0x1721)
+#define P_DI_MC_REG0_Y                             (volatile unsigned int *)((0x1721  << 2) + 0xff900000)
+#define   DI_MC_REG1_X                             (0x1722)
+#define P_DI_MC_REG1_X                             (volatile unsigned int *)((0x1722  << 2) + 0xff900000)
+#define   DI_MC_REG1_Y                             (0x1723)
+#define P_DI_MC_REG1_Y                             (volatile unsigned int *)((0x1723  << 2) + 0xff900000)
+#define   DI_MC_REG2_X                             (0x1724)
+#define P_DI_MC_REG2_X                             (volatile unsigned int *)((0x1724  << 2) + 0xff900000)
+#define   DI_MC_REG2_Y                             (0x1725)
+#define P_DI_MC_REG2_Y                             (volatile unsigned int *)((0x1725  << 2) + 0xff900000)
+#define   DI_MC_REG3_X                             (0x1726)
+#define P_DI_MC_REG3_X                             (volatile unsigned int *)((0x1726  << 2) + 0xff900000)
+#define   DI_MC_REG3_Y                             (0x1727)
+#define P_DI_MC_REG3_Y                             (volatile unsigned int *)((0x1727  << 2) + 0xff900000)
+#define   DI_MC_REG4_X                             (0x1728)
+#define P_DI_MC_REG4_X                             (volatile unsigned int *)((0x1728  << 2) + 0xff900000)
+#define   DI_MC_REG4_Y                             (0x1729)
+#define P_DI_MC_REG4_Y                             (volatile unsigned int *)((0x1729  << 2) + 0xff900000)
+#define   DI_MC_32LVL0                             (0x172a)
+#define P_DI_MC_32LVL0                             (volatile unsigned int *)((0x172a  << 2) + 0xff900000)
+//bit 31:24,   mc_reg2_32lvl
+//bit 23:16,   mc_reg1_32lvl
+//bit 15:8,    mc_reg0_32lvl
+//bit 7:0,     field_32lvl
+#define   DI_MC_32LVL1                             (0x172b)
+#define P_DI_MC_32LVL1                             (volatile unsigned int *)((0x172b  << 2) + 0xff900000)
+//bit 15:8,    mc_reg3_32lvl
+//bit 7:0,     mc_reg4_32lvl
+#define   DI_MC_22LVL0                             (0x172c)
+#define P_DI_MC_22LVL0                             (volatile unsigned int *)((0x172c  << 2) + 0xff900000)
+//bit 31:16,   mc_reg0_22lvl
+//bit 15:0,    field_22lvl
+#define   DI_MC_22LVL1                             (0x172d)
+#define P_DI_MC_22LVL1                             (volatile unsigned int *)((0x172d  << 2) + 0xff900000)
+//bit 31:16,   mc_reg2_22lvl
+//bit 15:0,    mc_reg1_22lvl
+#define   DI_MC_22LVL2                             (0x172e)
+#define P_DI_MC_22LVL2                             (volatile unsigned int *)((0x172e  << 2) + 0xff900000)
+//bit 31:16,   mc_reg4_22lvl
+//bit 15:0,    mc_reg3_22lvl
+#define   DI_MC_CTRL                               (0x172f)
+#define P_DI_MC_CTRL                               (volatile unsigned int *)((0x172f  << 2) + 0xff900000)
+//bit 4,       mc_reg4_en
+//bit 3,       mc_reg3_en
+//bit 2,       mc_reg2_en
+//bit 1,       mc_reg1_en
+//bit 0,       mc_reg0_en
+#define   DI_INTR_CTRL                             (0x1730)
+#define P_DI_INTR_CTRL                             (volatile unsigned int *)((0x1730  << 2) + 0xff900000)
+#define   DI_INFO_ADDR                             (0x1731)
+#define P_DI_INFO_ADDR                             (volatile unsigned int *)((0x1731  << 2) + 0xff900000)
+#define   DI_INFO_DATA                             (0x1732)
+#define P_DI_INFO_DATA                             (volatile unsigned int *)((0x1732  << 2) + 0xff900000)
+#define   DI_PRE_HOLD                              (0x1733)
+#define P_DI_PRE_HOLD                              (volatile unsigned int *)((0x1733  << 2) + 0xff900000)
+//// DET 3D REG DEFINE BEGIN ////
+//// 8'h34~8'h3f
+//     `define DET3D_MOTN_CFG                8'h34
+//     //Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
+//     //Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma:
+//     //                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
+//     //Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
+//     //Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
+//
+//     `define DET3D_CB_CFG                  8'h35
+//     //Bit 7:4,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizotnal or vertical combing detection.
+//     //Bit 3:0,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizotnal or vertical combing detection.
+//
+//     `define DET3D_SPLT_CFG                8'h36
+//     //Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection.
+//     //                                      The smaller of this value, the easier of the split line detected.
+//     //Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation.
+//     //                                      The smaller of this value, the more samples will be added to the estimation.
+//
+//     `define DET3D_HV_MUTE                 8'h37
+//     //Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part.
+//     //Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part.
+//     //Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
+//     //Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
+//     //Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block.
+//     //Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block.
+//
+//     `define DET3D_MAT_STA_P1M1            8'h38
+//     //Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
+//     //Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
+//     //Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
+//     //Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
+//
+//     `define DET3D_MAT_STA_P1TH            8'h39
+//     //Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)
+//     //Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
+//     //Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
+//
+//     `define DET3D_MAT_STA_M1TH            8'h3a
+//     //Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
+//     //Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
+//     //Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
+//
+//     `define DET3D_MAT_STA_RSFT            8'h3b
+//     //Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
+//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//     //Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
+//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//     //Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
+//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//
+//     `define DET3D_MAT_SYMTC_TH            8'h3c
+//     //Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric.
+//     //Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric.
+//     //Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric.
+//     //Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric.
+//
+//     `define DET3D_RO_DET_CB_HOR           8'h3d
+//     //Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
+//     //Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
+//
+//     `define DET3D_RO_DET_CB_VER           8'h3e
+//     //Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
+//     //Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
+//
+//     `define DET3D_RO_SPLT_HT              8'h3f
+//     //Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
+//     //Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
+//     //Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+//
+//     //// DET 3D REG DEFINE END ////
+#define   DI_MTN_1_CTRL1                           (0x1740)
+#define P_DI_MTN_1_CTRL1                           (volatile unsigned int *)((0x1740  << 2) + 0xff900000)
+//bit 31,      mtn_1_en
+//bit 30,      mtn_init
+//bit 29,      di2nr_txt_en
+//bit 28,      reserved
+//bit 27:24,   mtn_def
+//bit 23:16,   mtn_adp_yc
+//bit 15:8,    mtn_adp_2c
+//bit 7:0,     mtn_adp_2y
+#define   DI_MTN_1_CTRL2                           (0x1741)
+#define P_DI_MTN_1_CTRL2                           (volatile unsigned int *)((0x1741  << 2) + 0xff900000)
+//bit 31:24,   mtn_ykinter
+//bit 23:16,   mtn_ckinter
+//bit 15:8,    mtn_ykintra
+//bit  7:0,    mtn_ckintra
+#define   DI_MTN_1_CTRL3                           (0x1742)
+#define P_DI_MTN_1_CTRL3                           (volatile unsigned int *)((0x1742  << 2) + 0xff900000)
+//bit 31:24,   mtn_tyrate
+//bit 23:16,   mtn_tcrate
+//bit 15: 8,   mtn_mxcmby
+//bit  7: 0,   mtn_mxcmbc
+#define   DI_MTN_1_CTRL4                           (0x1743)
+#define P_DI_MTN_1_CTRL4                           (volatile unsigned int *)((0x1743  << 2) + 0xff900000)
+//bit 31:24,   mtn_tcorey
+//bit 23:16,   mtn_tcorec
+//bit 15: 8,   mtn_minth
+//bit  7: 0,   mtn_maxth
+#define   DI_MTN_1_CTRL5                           (0x1744)
+#define P_DI_MTN_1_CTRL5                           (volatile unsigned int *)((0x1744  << 2) + 0xff900000)
+//bit 31:28,   mtn_m1b_extnd
+//bit 27:24,   mtn_m1b_errod
+//bit 21:20,   mtn_mot_txt_mode
+//bit 19:18,   mtn_replace_cbyy
+//bit 17:16,   mtn_replace_ybyc
+//bit 15: 8,   mtn_core_ykinter
+//bit  7: 0,   mtn_core_ckinter
+//// NR2 REG DEFINE BEGIN////
+#define   NR2_MET_NM_CTRL                          (0x1745)
+#define P_NR2_MET_NM_CTRL                          (volatile unsigned int *)((0x1745  << 2) + 0xff900000)
+//Bit 28,	   reg_NM_reset	          Reset to the status of the Loop filter.
+//Bit 27:24,   reg_NM_calc_length	  Length mode of the Noise measurement sample number for statistics.
+//                                    0:  256 samples;    1: 512 samples;    2: 1024 samples;   X: 2^(8+x) samples
+//Bit 23:20,   reg_NM_inc_step	      Loop filter input gain increase step.
+//Bit 19:16,   reg_NM_dec_step	      Loop filter input gain decrease step.
+//Bit 15:8,	   reg_NM_YHPmot_thrd	  Luma channel HP portion motion for condition of pixels included in Luma Noise measurement.
+//Bit 7:0,	   reg_NM_CHPmot_thrd	  Chroma channel HP portion motion for condition of pixels included in Chroma Noise measurement.
+#define   NR2_MET_NM_YCTRL                         (0x1746)
+#define P_NR2_MET_NM_YCTRL                         (volatile unsigned int *)((0x1746  << 2) + 0xff900000)
+//Bit 31:28,   reg_NM_YPLL_target	      Target rate of NM_Ynoise_thrd to mean of the Luma Noise
+//Bit 27:24,   reg_NM_YLPmot_thrd	      Luma channel LP portion motion for condition of pixels included in Luma Noise measurement.
+//Bit 23:16,   reg_NM_YHPmot_thrd_min	  Minimum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement.
+//Bit 15:8,	   reg_NM_YHPmot_thrd_max	  Maximum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement.
+//Bit 7:0,	   reg_NM_Ylock_rate	      Rate to decide whether the Luma noise measurement is lock or not.
+#define   NR2_MET_NM_CCTRL                         (0x1747)
+#define P_NR2_MET_NM_CCTRL                         (volatile unsigned int *)((0x1747  << 2) + 0xff900000)
+//Bit 31:28,	reg_NM_CPLL_target	     Target rate of NM_Cnoise_thrd to mean of the Chroma Noise
+//Bit 27:24,	reg_NM_CLPmot_thrd	     Chroma channel LP portion motion for condition of pixels included in Chroma Noise measurement.
+//Bit 23:16,	reg_NM_CHPmot_thrd_min	 Minimum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement.
+//Bit 15:8,	    reg_NM_CHPmot_thrd_max	 Maximum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement.
+//Bit 7:0,	    reg_NM_Clock_rate	     Rate to decide whether the Chroma noise measurement is lock or not;
+#define   NR2_MET_NM_TNR                           (0x1748)
+#define P_NR2_MET_NM_TNR                           (volatile unsigned int *)((0x1748  << 2) + 0xff900000)
+//Bit 25,	    ro_NM_TNR_Ylock	         Read-only register to tell ifLuma channel noise measurement is locked or not.
+//Bit 24,	    ro_NM_TNR_Clock	         Read-only register to tell if Chroma channel noise measurement is locked or not.
+//Bit 23:12,	ro_NM_TNR_Ylevel	     Read-only register to give Luma channel noise level. It was 16x of pixel difference in 8 bits of YHPmot.
+//Bit 11:0,	ro_NM_TNR_Clevel	         Read-only register to give Chroma channel noise level. It was 16x of pixel difference in 8 bits of CHPmot.
+#define   NR2_MET_NMFRM_TNR_YLEV                   (0x1749)
+#define P_NR2_MET_NMFRM_TNR_YLEV                   (volatile unsigned int *)((0x1749  << 2) + 0xff900000)
+//Bit 28:0,	ro_NMFrm_TNR_Ylevel	         Frame based Read-only register to give Luma channel noise level within one frame/field.
+#define   NR2_MET_NMFRM_TNR_YCNT                   (0x174a)
+#define P_NR2_MET_NMFRM_TNR_YCNT                   (volatile unsigned int *)((0x174a  << 2) + 0xff900000)
+//Bit 23:0,	ro_NMFrm_TNR_Ycount	         Number ofLuma channel pixels included in Frame/Field based noise level measurement.
+#define   NR2_MET_NMFRM_TNR_CLEV                   (0x174b)
+#define P_NR2_MET_NMFRM_TNR_CLEV                   (volatile unsigned int *)((0x174b  << 2) + 0xff900000)
+//Bit 28:0,	ro_NMFrm_TNR_Clevel	         Frame based Read-only register to give Chroma channel noise level within one frame/field.
+#define   NR2_MET_NMFRM_TNR_CCNT                   (0x174c)
+#define P_NR2_MET_NMFRM_TNR_CCNT                   (volatile unsigned int *)((0x174c  << 2) + 0xff900000)
+//Bit 23:0,	ro_NMFrm_TNR_Ccount	         Number of Chroma channel pixels included in Frame/Field based noise level measurement.
+#define   NR2_3DEN_MODE                            (0x174d)
+#define P_NR2_3DEN_MODE                            (volatile unsigned int *)((0x174d  << 2) + 0xff900000)
+//Bit 6:4,	Blend_3dnr_en_r
+//Bit 2:0,	Blend_3dnr_en_l
+//   `define NR2_IIR_CTRL                8'h4e
+//   //Bit 15:14, reg_LP_IIR_8bit_mode	LP IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
+//   //                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
+//   //Bit 13:12, reg_LP_IIR_mute_mode	Mode for the LP IIR mute,
+//   //Bit 11:8,	 reg_LP_IIR_mute_thrd	Threshold of LP IIR mute to avoid ghost:
+//   //Bit 7:6,	 reg_HP_IIR_8bit_mode	IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
+//   //                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
+//   //Bit 5:4,	reg_HP_IIR_mute_mode	Mode for theLP IIR mute
+//   //Bit 3:0,	reg_HP_IIR_mute_thrd	Threshold of HP IIR mute to avoid ghost
+//   //
+#define   NR2_SW_EN                                (0x174f)
+#define P_NR2_SW_EN                                (volatile unsigned int *)((0x174f  << 2) + 0xff900000)
+//Bit 17:8,	Clk_gate_ctrl
+//Bit 7,	Cfr_enable
+//Bit 5,	Det3d_en
+//Bit 4,	Nr2_proc_en
+//Bit 0,	Nr2_sw_en
+#define   NR2_FRM_SIZE                             (0x1750)
+#define P_NR2_FRM_SIZE                             (volatile unsigned int *)((0x1750  << 2) + 0xff900000)
+//Bit 27:16,  Frm_heigh	Frame/field height
+//Bit 11: 0,  Frm_width	Frame/field width
+//   `define NR2_SNR_SAD_CFG             8'h51
+//   //Bit 12,	reg_MATNR_SNR_SAD_CenRPL	U1, Enable signal for Current pixel position SAD to be replaced by SAD_min.0: do not replace Current pixel position SAD by SAD_min;1: do replacements
+//   //Bit 11:8,	reg_MATNR_SNR_SAD_coring	Coring value of the intra-frame SAD. sum = (sum - reg_MATNR_SNR_SAD_coring);sum = (sum<0) ? 0: (sum>255)? 255: sum;
+//   //Bit 6:5,	reg_MATNR_SNR_SAD_WinMod	Unsigned, Intra-frame SAD matching window mode:0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
+//   //Bit 4:0,	Sad_coef_num	            Sad coeffient
+//
+//   `define NR2_MATNR_SNR_OS            8'h52
+//   //Bit 7:4,	reg_MATNR_SNR_COS	    SNR Filter overshoot control margin for UV channel (X2 to u10 scale)
+//   //Bit 3:0,	reg_MATNR_SNR_YOS	    SNR Filter overshoot control margin for luma channel (X2 to u10 scale)
+//
+//   `define NR2_MATNR_SNR_NRM_CFG       8'h53
+//   //Bit 23:16,	reg_MATNR_SNR_NRM_ofst	Edge based SNR boosting normalization offset to SAD_max ;
+//   //Bit 15:8,	    reg_MATNR_SNR_NRM_max	Edge based SNR boosting normalization Max value
+//   //Bit 7:0,	    reg_MATNR_SNR_NRM_min	Edge based SNR boosting normalization Min value
+//
+//   `define NR2_MATNR_SNR_NRM_GAIN      8'h54
+//   //Bit 15:8,	reg_MATNR_SNR_NRM_Cgain	Edge based SNR boosting normalization Gain for Chrm channel (norm 32 as 1)
+//   //Bit 7:0,	reg_MATNR_SNR_NRM_Ygain	Edge based SNR boosting normalization Gain for Luma channel (norm 32 as 1)
+//
+//   `define NR2_MATNR_SNR_LPF_CFG       8'h55
+//   //Bit 23:16,reg_MATNR_SNRLPF_SADmaxTH	U8,  Threshold to SADmax to use TNRLPF to replace SNRLPF. i.e.if (SAD_max<reg_MATNR_SNRLPF_SADmaxTH) SNRLPF_yuv[k] = TNRLPF_yuv[k];
+//   //Bit 13:11,reg_MATNR_SNRLPF_Cmode	    LPF based SNR filtering mode on CHRM channel:
+//   //                                      0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 4 4 3]/16;
+//   //                                      4: TNRLPF;  5 : CurLPF3x3_yuv[];  6: CurLPF3o3_yuv[]  7: CurLPF3x5_yuv[]
+//   //Bit 10:8,	reg_MATNR_SNRLPF_Ymode	    LPF based SNR filtering mode on LUMA channel:
+//   //                                      0: gradient LPF //Bit [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8;3: gradient LPF [5 4 4 3]/16;
+//   //                                      4: TNRLPF;               5 : CurLPF3x3_yuv[];       6: CurLPF3o3_yuv[]         7: CurLPF3x5_yuv[]
+//   //Bit 7:4,	reg_MATNR_SNRLPF_SADmin3TH	Offset threshold to SAD_min to Discard SAD_min3 corresponding pixel in LPF SNR filtering. (X8 to u8 scale)
+//   //Bit 3:0,	reg_MATNR_SNRLPF_SADmin2TH	Offset threshold to SAD_min to Discard SAD_min2 corresponding pixel in LPF SNR filtering. (X8 to u8 scale)
+//
+//   `define NR2_MATNR_SNR_USF_GAIN      8'h56
+//   //Bit 15:8,	reg_MATNR_SNR_USF_Cgain	    Un-sharp (HP) compensate back Chrm portion gain, (norm 64 as 1)
+//   //Bit 7:0,	reg_MATNR_SNR_USF_Ygain	    Un-sharp (HP) compensate back Luma portion gain, (norm 64 as 1)
+//
+//   `define NR2_MATNR_SNR_EDGE2B        8'h57
+//   //Bit 15:8,	reg_MATNR_SNR_Edge2Beta_ofst	U8,  Offset for Beta based on Edge.
+//   //Bit 7:0,	reg_MATNR_SNR_Edge2Beta_gain	U8.  Gain to SAD_min for Beta based on Edge. (norm 16 as 1)
+//
+//   `define NR2_MATNR_BETA_EGAIN        8'h58
+//   //Bit 15:8,	reg_MATNR_CBeta_Egain	U8,  Gain to Edge based Beta for Chrm channel. (normalized to 32 as 1)
+//   //Bit 7:0,	reg_MATNR_YBeta_Egain	U8,  Gain to Edge based Beta for Luma channel. (normalized to 32 as 1)
+//
+//   `define NR2_MATNR_BETA_BRT          8'h59
+//   //Bit 31:28,	reg_MATNR_beta_BRT_limt_hi	U4,  Beta adjustment based on Brightness high side Limit. (X16 to u8 scale)
+//   //Bit 27:24,	reg_MATNR_beta_BRT_slop_hi	U4,  Beta adjustment based on Brightness high side slope. Normalized to 16 as 1
+//   //Bit 23:16,	reg_MATNR_beta_BRT_thrd_hi	U8,  Beta adjustment based on Brightness high threshold.(u8 scale)
+//   //Bit 15:12,	reg_MATNR_beta_BRT_limt_lo	U4,  Beta adjustment based on Brightness low side Limit. (X16 to u8 scale)
+//   //Bit 11:8,	    reg_MATNR_beta_BRT_slop_lo	U4,  Beta adjustment based on Brightness low side slope. Normalized to 16 as 1
+//   //Bit 7:0,	    reg_MATNR_beta_BRT_thrd_lo	U8,  Beta adjustment based on Brightness low threshold.(u8 scale)
+//   `define NR2_MATNR_XBETA_CFG         8'h5a
+//   //Bit 19:18,	reg_MATNR_CBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Chrm channel;
+//   //Bit 17:16,	reg_MATNR_YBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Luma channel;
+//   //Bit 15: 8,	reg_MATNR_CBeta_Ofst	    U8,  Offset to Beta for Chrm channel.(after beta_edge and beta_motion mux)
+//   //Bit  7: 0,	reg_MATNR_YBeta_Ofst	    U8,  Offset to Beta for Luma channel.(after beta_edge and beta_motion mux)
+//   `define NR2_MATNR_YBETA_SCL         8'h5b
+//   //Bit 31:24,	reg_MATNR_YBeta_scale_min	U8,  Final step Beta scale low limit for Luma channel;
+//   //Bit 23:16,	reg_MATNR_YBeta_scale_max	U8,  Final step Beta scale high limit for Luma channe;
+//   //Bit 15: 8,	reg_MATNR_YBeta_scale_gain	U8,  Final step Beta scale Gain for Luma channel (normalized 32 to 1);
+//   //Bit 7 : 0,	reg_MATNR_YBeta_scale_ofst	S8,  Final step Beta scale offset for Luma channel ;
+//   `define NR2_MATNR_CBETA_SCL         8'h5c
+//   //Bit 31:24,	reg_MATNR_CBeta_scale_min	Final step Beta scale low limit for Chrm channel.Similar to Y
+//   //Bit 23:16,	reg_MATNR_CBeta_scale_max	U8,  Final step Beta scale high limit for Chrm channel.Similar to Y
+//   //Bit 15: 8,	reg_MATNR_CBeta_scale_gain	U8,  Final step Beta scale Gain for Chrm channel Similar to Y
+//   //Bit  7: 0,	reg_MATNR_CBeta_scale_ofst	S8,  Final step Beta scale offset for Chrm channel Similar to Y
+//   `define NR2_SNR_MASK                8'h5d
+//   //Bit 20:0, 	SAD_MSK	                    Valid signal in the 3x7 SAD surface
+//   `define NR2_SAD2NORM_LUT0           8'h5e
+//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_3	SAD convert normal LUT node 3
+//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_2	SAD convert normal LUT node 2
+//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_1	SAD convert normal LUT node 1
+//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_0	SAD convert normal LUT node 0
+//   `define NR2_SAD2NORM_LUT1           8'h5f
+//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_7	SAD convert normal LUT node 7
+//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_6	SAD convert normal LUT node 6
+//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_5	SAD convert normal LUT node 5
+//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_4	SAD convert normal LUT node 4
+//   `define NR2_SAD2NORM_LUT2           8'h60
+//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_11	SAD convert normal LUT node 11
+//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_10	SAD convert normal LUT node 10
+//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_9	SAD convert normal LUT node 9
+//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_8	SAD convert normal LUT node 8
+//   `define NR2_SAD2NORM_LUT3           8'h61
+//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_15	SAD convert normal LUT node 15
+//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_14	SAD convert normal LUT node 14
+//   //Bit 15:8,	reg_MATNR_SAD2Norm_LUT_13	SAD convert normal LUT node 13
+//   //Bit 7:0,	reg_MATNR_SAD2Norm_LUT_12	SAD convert normal LUT node 12
+//   `define NR2_EDGE2BETA_LUT0          8'h62
+//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_3	Edge convert beta LUT node 3
+//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_2	Edge convert beta LUT node 2
+//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_1	Edge convert beta LUT node 1
+//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_0	Edge convert beta LUT node 0
+//   `define NR2_EDGE2BETA_LUT1          8'h63
+//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_7	Edge convert beta LUT node 7
+//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_6	Edge convert beta LUT node 6
+//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_5	Edge convert beta LUT node 5
+//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_4	Edge convert beta LUT node 4
+//   `define NR2_EDGE2BETA_LUT2          8'h64
+//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_11	Edge convert beta LUT node 11
+//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_10	Edge convert beta LUT node 10
+//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_9	Edge convert beta LUT node 9
+//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_8	Edge convert beta LUT node 8
+//   `define NR2_EDGE2BETA_LUT3          8'h65
+//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_15	Edge convert beta LUT node 15
+//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_14	Edge convert beta LUT node 14
+//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_13	Edge convert beta LUT node 13
+//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_12	Edge convert beta LUT node 12
+//   `define NR2_MOTION2BETA_LUT0        8'h66
+//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_3	Motion convert beta LUT node 3
+//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_2	Motion convert beta LUT node 2
+//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_1	Motion convert beta LUT node 1
+//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_0	Motion convert beta LUT node 0
+//   `define NR2_MOTION2BETA_LUT1        8'h67
+//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_7	Motion convert beta LUT node 7
+//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_6	Motion convert beta LUT node 6
+//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_5	Motion convert beta LUT node 5
+//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_4	Motion convert beta LUT node 4
+//   `define NR2_MOTION2BETA_LUT2        8'h68
+//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_11	Motion convert beta LUT node 11
+//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_10	Motion convert beta LUT node 10
+//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_9	Motion convert beta LUT node 9
+//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_8	Motion convert beta LUT node 8
+//   `define NR2_MOTION2BETA_LUT3        8'h69
+//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_15	Motion convert beta LUT node 15
+//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_14	Motion convert beta LUT node 14
+//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_13	Motion convert beta LUT node 13
+//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_12	Motion convert beta LUT node 12
+//    `define NR2_MATNR_MTN_CRTL          8'h6a
+//    //Bit 25:24,	reg_MATNR_Vmtn_use_mode	    Motion_yuvV channel motion selection mode:0: Vmot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)
+//    //Bit 21:20,	reg_MATNR_Umtn_use_mode	    Motion_yuvU channel motion selection mode:0:Umot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)
+//    //Bit 17:16,	reg_MATNR_Ymtn_use_mode	    Motion_yuvLuma channel motion selection mode:0:  Ymot, 1: Ymot/2 + (Umot+Vmot)/4; 2: Ymot/2 + max(Umot,Vmot)/2; 3:  max(Ymot,Umot, Vmot)
+//    //Bit 13:12,	reg_MATNR_mtn_txt_mode	    Texture detection mode for adaptive coring of HP motion
+//    //Bit  9: 8,	reg_MATNR_mtn_cor_mode	    Coring selection mode based on texture detection;
+//    //Bit  6: 4,	reg_MATNR_mtn_hpf_mode	    video mode of current and previous frame/field for MotHPF_yuv[k] calculation:
+//    //Bit  2: 0,	reg_MATNR_mtn_lpf_mode	    LPF video mode of current and previous frame/field for MotLPF_yuv[k] calculation:
+//    `define NR2_MATNR_MTN_CRTL2         8'h6b
+//    //Bit 18:16,	reg_MATNR_iir_BS_Ymode	    IIR TNR filter Band split filter mode for Luma LPF result generation (Cur and Prev);
+//    //Bit 15: 8,	reg_MATNR_mtnb_alpLP_Cgain	Scale of motion_brthp_uv to motion_brtlp_uv, normalized to 32 as 1
+//    //Bit  7: 0,	reg_MATNR_mtnb_alpLP_Ygain	Scale of motion_brthp_y to motion_brtlp_y, normalized to 32 as 1
+//    `define NR2_MATNR_MTN_COR           8'h6c
+//    //Bit 15:12,	reg_MATNR_mtn_cor_Cofst	    Coring Offset for Chroma Motion.
+//    //Bit 11: 8,	reg_MATNR_mtn_cor_Cgain	    Gain to texture based coring for Chroma Motion. Normalized to 16 as 1
+//    //Bit  7: 4,	reg_MATNR_mtn_cor_Yofst	    Coring Offset for Luma Motion.
+//    //Bit  3: 0,	reg_MATNR_mtn_cor_Ygain	    Gain to texture based coring for Luma Motion. Normalized to 16 as 1
+//    `define NR2_MATNR_MTN_GAIN          8'h6d
+//    //Bit 31:24,	reg_MATNR_mtn_hp_Cgain	Gain to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
+//    //Bit 23:16,	reg_MATNR_mtn_hp_Ygain	Gain to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
+//    //Bit 15: 8,	reg_MATNR_mtn_lp_Cgain	Gain to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
+//    //Bit  7: 0,	reg_MATNR_mtn_lp_Ygain	Gain to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
+//    `define NR2_MATNR_DEGHOST           8'h6e
+//    //Bit 8,	reg_MATNR_DeGhost_En	Enable signal for DeGhost function:0: disable; 1: enable
+//    //Bit 7:4,	reg_MATNR_DeGhost_COS	DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
+//    //Bit 3:0,	reg_MATNR_DeGhost_YOS	DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
+//
+//    `define NR2_MATNR_ALPHALP_LUT0      8'h6f
+//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_3	    Matnr low-pass filter alpha LUT node 3
+//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_2	    Matnr low-pass filter alpha LUT node 2
+//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_1	    Matnr low-pass filter alpha LUT node 1
+//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_0	    Matnr low-pass filter alpha LUT node 0
+//    `define NR2_MATNR_ALPHALP_LUT1      8'h70
+//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_7	    Matnr low-pass filter alpha LUT node 7
+//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_6	    Matnr low-pass filter alpha LUT node 6
+//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_5	    Matnr low-pass filter alpha LUT node 5
+//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_4	    Matnr low-pass filter alpha LUT node 4
+//    `define NR2_MATNR_ALPHALP_LUT2      8'h71
+//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_11	Matnr low-pass filter alpha LUT node 11
+//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_10	Matnr low-pass filter alpha LUT node 10
+//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_9	    Matnr low-pass filter alpha LUT node 9
+//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_8	    Matnr low-pass filter alpha LUT node 8
+//    `define NR2_MATNR_ALPHALP_LUT3      8'h72
+//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_15	Matnr low-pass filter alpha LUT node 15
+//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_14	Matnr low-pass filter alpha LUT node 14
+//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_13	Matnr low-pass filter alpha LUT node 13
+//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_12	Matnr low-pass filter alpha LUT node 12
+//    `define NR2_MATNR_ALPHAHP_LUT0      8'h73
+//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_3	    Matnr high-pass filter alpha LUT node 3
+//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_2	    Matnr high-pass filter alpha LUT node 2
+//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_1	    Matnr high-pass filter alpha LUT node 1
+//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_0	    Matnr high-pass filter alpha LUT node 0
+//    `define NR2_MATNR_ALPHAHP_LUT1      8'h74
+//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_7	    Matnr high-pass filter alpha LUT node 7
+//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_6	    Matnr high-pass filter alpha LUT node 6
+//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_5	    Matnr high-pass filter alpha LUT node 5
+//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_4	    Matnr high-pass filter alpha LUT node 4
+//    `define NR2_MATNR_ALPHAHP_LUT2      8'h75
+//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_11	Matnr high-pass filter alpha LUT node 11
+//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_10	Matnr high-pass filter alpha LUT node 10
+//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_9	    Matnr high-pass filter alpha LUT node 9
+//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_8	    Matnr high-pass filter alpha LUT node 8
+//    `define NR2_MATNR_ALPHAHP_LUT3      8'h76
+//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_15	Matnr high-pass filter alpha LUT node 15
+//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_14	Matnr high-pass filter alpha LUT node 14
+//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_13	Matnr high-pass filter alpha LUT node 13
+//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_12	Matnr high-pass filter alpha LUT node 12
+//
+//    `define NR2_MATNR_MTNB_BRT          8'h77
+//    //Bit 31:28,	reg_MATNR_mtnb_BRT_limt_hi	Motion adjustment based on Brightness high side Limit. (X16 to u8 scale)
+//    //Bit 27:24,	reg_MATNR_mtnb_BRT_slop_hi	Motion adjustment based on Brightness high side slope. Normalized to 16 as 1
+//    //Bit 23:16,	reg_MATNR_mtnb_BRT_thrd_hi	Motion adjustment based on Brightness high threshold.(u8 scale)
+//    //Bit 15:12,	reg_MATNR_mtnb_BRT_limt_lo	Motion adjustment based on Brightness low side Limit. (X16 to u8 scale)
+//    //Bit 11: 8,	reg_MATNR_mtnb_BRT_slop_lo	Motion adjustment based on Brightness low side slope. Normalized to 16 as 1
+//    //Bit  7: 0,	reg_MATNR_mtnb_BRT_thrd_lo	Motion adjustment based on Brightness low threshold.(u8 scale)
+// 0x51 - 0x69 | 0x4e | 0x6a - 0x77
+//
+// Reading file:  nr2_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//========== nr2_snr_regs register begin ==========//
+#define   NR2_SNR_SAD_CFG                          (0x1751)
+#define P_NR2_SNR_SAD_CFG                          (volatile unsigned int *)((0x1751  << 2) + 0xff900000)
+//Bit 31:13        reserved
+//Bit 12           reg_matnr_snr_sad_cenrpl       // unsigned , default = 1
+//Bit 11: 8        reg_matnr_snr_sad_coring       // unsigned , default = 3
+//Bit  7            reserved
+//Bit  6: 5        reg_matnr_snr_sad_winmod       // unsigned , default = 1     0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
+//Bit  4: 0        sad_coef_num                      // unsigned , default = 1     0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
+#define   NR2_MATNR_SNR_OS                         (0x1752)
+#define P_NR2_MATNR_SNR_OS                         (volatile unsigned int *)((0x1752  << 2) + 0xff900000)
+//Bit 31: 8        reserved
+//Bit  7: 4        reg_matnr_snr_cos              // unsigned , default = 8
+//Bit  3: 0        reg_matnr_snr_yos              // unsigned , default = 13
+#define   NR2_MATNR_SNR_NRM_CFG                    (0x1753)
+#define P_NR2_MATNR_SNR_NRM_CFG                    (volatile unsigned int *)((0x1753  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_matnr_snr_nrm_ofst         // signed , default = 64
+//Bit 15: 8        reg_matnr_snr_nrm_max          // unsigned , default = 255
+//Bit  7: 0        reg_matnr_snr_nrm_min          // unsigned , default = 0
+#define   NR2_MATNR_SNR_NRM_GAIN                   (0x1754)
+#define P_NR2_MATNR_SNR_NRM_GAIN                   (volatile unsigned int *)((0x1754  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15: 8        reg_matnr_snr_nrm_cgain        // unsigned , default = 0     norm 32
+//Bit  7: 0        reg_matnr_snr_nrm_ygain        // unsigned , default = 32    norm 32
+#define   NR2_MATNR_SNR_LPF_CFG                    (0x1755)
+#define P_NR2_MATNR_SNR_LPF_CFG                    (volatile unsigned int *)((0x1755  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_matnr_snrlpf_sadmaxth      // unsigned , default = 12
+//Bit 15:14        reserved
+//Bit 13:11        reg_matnr_snrlpf_cmode         // unsigned , default = 2     0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 5 4 3]/16;
+//Bit 10: 8        reg_matnr_snrlpf_ymode         // unsigned , default = 2     0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 5 4 3]/16;
+//Bit  7: 4        reg_matnr_snrlpf_sadmin3th     // unsigned , default = 6     X8
+//Bit  3: 0        reg_matnr_snrlpf_sadmin2th     // unsigned , default = 4     X8
+#define   NR2_MATNR_SNR_USF_GAIN                   (0x1756)
+#define P_NR2_MATNR_SNR_USF_GAIN                   (volatile unsigned int *)((0x1756  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15: 8        reg_matnr_snr_usf_cgain        // unsigned , default = 0     norm 64
+//Bit  7: 0        reg_matnr_snr_usf_ygain        // unsigned , default = 0     norm 64
+#define   NR2_MATNR_SNR_EDGE2B                     (0x1757)
+#define P_NR2_MATNR_SNR_EDGE2B                     (volatile unsigned int *)((0x1757  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15: 8        reg_matnr_snr_edge2beta_ofst   // unsigned , default = 128
+//Bit  7: 0        reg_matnr_snr_edge2beta_gain   // unsigned , default = 16
+#define   NR2_MATNR_BETA_EGAIN                     (0x1758)
+#define P_NR2_MATNR_BETA_EGAIN                     (volatile unsigned int *)((0x1758  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15: 8        reg_matnr_cbeta_egain          // unsigned , default = 32    normalized to 32
+//Bit  7: 0        reg_matnr_ybeta_egain          // unsigned , default = 32    normalized to 32
+#define   NR2_MATNR_BETA_BRT                       (0x1759)
+#define P_NR2_MATNR_BETA_BRT                       (volatile unsigned int *)((0x1759  << 2) + 0xff900000)
+//Bit 31:28        reg_matnr_beta_brt_limt_hi     // unsigned , default = 0
+//Bit 27:24        reg_matnr_beta_brt_slop_hi     // unsigned , default = 0
+//Bit 23:16        reg_matnr_beta_brt_thrd_hi     // unsigned , default = 160
+//Bit 15:12        reg_matnr_beta_brt_limt_lo     // unsigned , default = 6
+//Bit 11: 8        reg_matnr_beta_brt_slop_lo     // unsigned , default = 6
+//Bit  7: 0        reg_matnr_beta_brt_thrd_lo     // unsigned , default = 100
+#define   NR2_MATNR_XBETA_CFG                      (0x175a)
+#define P_NR2_MATNR_XBETA_CFG                      (volatile unsigned int *)((0x175a  << 2) + 0xff900000)
+//Bit 31:20        reserved
+//Bit 19:18        reg_matnr_cbeta_use_mode       // unsigned , default = 0     0: beta_motion; 1: beta_edge; 2: min(beta_mot,beta_edge); 3: (beta_mot + beta_edge)/2
+//Bit 17:16        reg_matnr_ybeta_use_mode       // unsigned , default = 0     0: beta_motion; 1: beta_edge; 2: min(beta_mot,beta_edge); 3: (beta_mot + beta_edge)/2;
+//Bit 15: 8        reg_matnr_cbeta_ofst           // unsigned , default = 0
+//Bit  7: 0        reg_matnr_ybeta_ofst           // unsigned , default = 0
+#define   NR2_MATNR_YBETA_SCL                      (0x175b)
+#define P_NR2_MATNR_YBETA_SCL                      (volatile unsigned int *)((0x175b  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_ybeta_scale_min      // unsigned , default = 60
+//Bit 23:16        reg_matnr_ybeta_scale_max      // unsigned , default = 255
+//Bit 15: 8        reg_matnr_ybeta_scale_gain     // unsigned , default = 32    normalized 32 to 1.0
+//Bit  7: 0        reg_matnr_ybeta_scale_ofst     // signed , default = 0
+#define   NR2_MATNR_CBETA_SCL                      (0x175c)
+#define P_NR2_MATNR_CBETA_SCL                      (volatile unsigned int *)((0x175c  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_cbeta_scale_min      // unsigned , default = 0
+//Bit 23:16        reg_matnr_cbeta_scale_max      // unsigned , default = 255
+//Bit 15: 8        reg_matnr_cbeta_scale_gain     // unsigned , default = 32    normalized 32 to 1.0
+//Bit  7: 0        reg_matnr_cbeta_scale_ofst     // signed , default = 0
+#define   NR2_SNR_MASK                             (0x175d)
+#define P_NR2_SNR_MASK                             (volatile unsigned int *)((0x175d  << 2) + 0xff900000)
+//Bit 31:21        reserved
+//Bit 20: 0        sad_msk                        // unsigned , default = 0x0f9f3e
+#define   NR2_SAD2NORM_LUT0                        (0x175e)
+#define P_NR2_SAD2NORM_LUT0                        (volatile unsigned int *)((0x175e  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_sad2norm_lut3      // unsigned , default = 114
+//Bit 23:16        reg_matnr_sad2norm_lut2      // unsigned , default = 146
+//Bit 15: 8        reg_matnr_sad2norm_lut1      // unsigned , default = 171
+//Bit  7: 0        reg_matnr_sad2norm_lut0      // unsigned , default = 205
+#define   NR2_SAD2NORM_LUT1                        (0x175f)
+#define P_NR2_SAD2NORM_LUT1                        (volatile unsigned int *)((0x175f  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_sad2norm_lut7      // unsigned , default = 28
+//Bit 23:16        reg_matnr_sad2norm_lut6      // unsigned , default = 35
+//Bit 15: 8        reg_matnr_sad2norm_lut5      // unsigned , default = 49
+//Bit  7: 0        reg_matnr_sad2norm_lut4      // unsigned , default = 79
+#define   NR2_SAD2NORM_LUT2                        (0x1760)
+#define P_NR2_SAD2NORM_LUT2                        (volatile unsigned int *)((0x1760  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_sad2norm_lut11     // unsigned , default = 15
+//Bit 23:16        reg_matnr_sad2norm_lut10     // unsigned , default = 17
+//Bit 15: 8        reg_matnr_sad2norm_lut9      // unsigned , default = 19
+//Bit  7: 0        reg_matnr_sad2norm_lut8      // unsigned , default = 23
+#define   NR2_SAD2NORM_LUT3                        (0x1761)
+#define P_NR2_SAD2NORM_LUT3                        (volatile unsigned int *)((0x1761  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_sad2norm_lut15     // unsigned , default = 8
+//Bit 23:16        reg_matnr_sad2norm_lut14     // unsigned , default = 9
+//Bit 15: 8        reg_matnr_sad2norm_lut13     // unsigned , default = 10
+//Bit  7: 0        reg_matnr_sad2norm_lut12     // unsigned , default = 12
+#define   NR2_EDGE2BETA_LUT0                       (0x1762)
+#define P_NR2_EDGE2BETA_LUT0                       (volatile unsigned int *)((0x1762  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_edge2beta_lut3    // unsigned , default = 128
+//Bit 23:16        reg_matnr_edge2beta_lut2    // unsigned , default = 160
+//Bit 15: 8        reg_matnr_edge2beta_lut1    // unsigned , default = 224
+//Bit  7: 0        reg_matnr_edge2beta_lut0    // unsigned , default = 255
+#define   NR2_EDGE2BETA_LUT1                       (0x1763)
+#define P_NR2_EDGE2BETA_LUT1                       (volatile unsigned int *)((0x1763  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_edge2beta_lut7    // unsigned , default = 4
+//Bit 23:16        reg_matnr_edge2beta_lut6    // unsigned , default = 16
+//Bit 15: 8        reg_matnr_edge2beta_lut5    // unsigned , default = 32
+//Bit  7: 0        reg_matnr_edge2beta_lut4    // unsigned , default = 80
+#define   NR2_EDGE2BETA_LUT2                       (0x1764)
+#define P_NR2_EDGE2BETA_LUT2                       (volatile unsigned int *)((0x1764  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_edge2beta_lut11    // unsigned , default = 0
+//Bit 23:16        reg_matnr_edge2beta_lut10    // unsigned , default = 0
+//Bit 15: 8        reg_matnr_edge2beta_lut9    // unsigned , default = 0
+//Bit  7: 0        reg_matnr_edge2beta_lut8    // unsigned , default = 2
+#define   NR2_EDGE2BETA_LUT3                       (0x1765)
+#define P_NR2_EDGE2BETA_LUT3                       (volatile unsigned int *)((0x1765  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_edge2beta_lut15    // unsigned , default = 0
+//Bit 23:16        reg_matnr_edge2beta_lut14    // unsigned , default = 0
+//Bit 15: 8        reg_matnr_edge2beta_lut13    // unsigned , default = 0
+//Bit  7: 0        reg_matnr_edge2beta_lut12    // unsigned , default = 0
+#define   NR2_MOTION2BETA_LUT0                     (0x1766)
+#define P_NR2_MOTION2BETA_LUT0                     (volatile unsigned int *)((0x1766  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_mot2beta_lut3     // unsigned , default = 32
+//Bit 23:16        reg_matnr_mot2beta_lut2     // unsigned , default = 16
+//Bit 15: 8        reg_matnr_mot2beta_lut1     // unsigned , default = 4
+//Bit  7: 0        reg_matnr_mot2beta_lut0     // unsigned , default = 0
+#define   NR2_MOTION2BETA_LUT1                     (0x1767)
+#define P_NR2_MOTION2BETA_LUT1                     (volatile unsigned int *)((0x1767  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_mot2beta_lut7     // unsigned , default = 196
+//Bit 23:16        reg_matnr_mot2beta_lut6     // unsigned , default = 128
+//Bit 15: 8        reg_matnr_mot2beta_lut5     // unsigned , default = 64
+//Bit  7: 0        reg_matnr_mot2beta_lut4     // unsigned , default = 48
+#define   NR2_MOTION2BETA_LUT2                     (0x1768)
+#define P_NR2_MOTION2BETA_LUT2                     (volatile unsigned int *)((0x1768  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_mot2beta_lut11     // unsigned , default = 255
+//Bit 23:16        reg_matnr_mot2beta_lut10     // unsigned , default = 255
+//Bit 15: 8        reg_matnr_mot2beta_lut9     // unsigned , default = 240
+//Bit  7: 0        reg_matnr_mot2beta_lut8     // unsigned , default = 224
+#define   NR2_MOTION2BETA_LUT3                     (0x1769)
+#define P_NR2_MOTION2BETA_LUT3                     (volatile unsigned int *)((0x1769  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_mot2beta_lut15     // unsigned , default = 255
+//Bit 23:16        reg_matnr_mot2beta_lut14     // unsigned , default = 255
+//Bit 15: 8        reg_matnr_mot2beta_lut13     // unsigned , default = 255
+//Bit  7: 0        reg_matnr_mot2beta_lut12     // unsigned , default = 255
+//========== nr2_snr_regs register end ==========//
+//========== nr2_tnr_regs register begin ==========//
+#define   NR2_IIR_CTRL                             (0x174e)
+#define P_NR2_IIR_CTRL                             (volatile unsigned int *)((0x174e  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15:14        reg_lp_iir_8bit_mode      // unsigned , default = 0  10bits; 1: 9bits; 2: 8bits 3: 7bits
+//Bit 13:12        reg_hp_iir_mute_mode      // unsigned , default = 0
+//Bit 11: 8        reg_hp_iir_mute_thrd      // unsigned , default = 0
+//Bit  7: 6        reg_hp_iir_8bit_mode      // unsigned , default = 0
+//Bit  5: 4        reg_lp_iir_mute_mode      // unsigned , default = 0
+//Bit  3: 0        reg_lp_iir_mute_thrd      // unsigned , default = 0
+#define   NR2_MATNR_MTN_CRTL                       (0x176a)
+#define P_NR2_MATNR_MTN_CRTL                       (volatile unsigned int *)((0x176a  << 2) + 0xff900000)
+//Bit 31:20        reserved
+//Bit 19:18        reg_matnr_vmtn_use_mode   // unsigned , default = 0  0- Vmot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
+//Bit 17:16        reg_matnr_umtn_use_mode   // unsigned , default = 0  0- Umot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
+//Bit 15:14        reg_matnr_ymtn_use_mode   // unsigned , default = 0  0- Ymot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
+//Bit 13:12        reg_matnr_mtn_txt_mode    // unsigned , default = 1
+//Bit 11            reserved
+//Bit 10: 8        reg_matnr_mtn_cor_mode    // unsigned , default = 1  changes)
+//Bit  7: 4        reg_matnr_mtn_hpf_mode    // unsigned , default = 8  extend to u4 for nr4, 0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5, 6:3x3 SAD, 7: 5x3 SAD, 8-15: drt adaptive
+//Bit  3            reserved
+//Bit  2: 0        reg_matnr_mtn_lpf_mode    // unsigned , default = 6  0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5, 6,7: drt adaptive
+#define   NR2_MATNR_MTN_CRTL2                      (0x176b)
+#define P_NR2_MATNR_MTN_CRTL2                      (volatile unsigned int *)((0x176b  << 2) + 0xff900000)
+//Bit 31:19        reserved
+//Bit 18:16        reg_matnr_iir_bs_ymode      // unsigned , default = 6  LPF~~ 0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5; 6/7: 0
+//Bit 15: 8        reg_matnr_mtnb_alplp_cgain  // unsigned , default = 64  to 32
+//Bit  7: 0        reg_matnr_mtnb_alplp_ygain  // unsigned , default = 64  to 32
+#define   NR2_MATNR_MTN_COR                        (0x176c)
+#define P_NR2_MATNR_MTN_COR                        (volatile unsigned int *)((0x176c  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15:12        reg_matnr_mtn_cor_cofst   // unsigned , default = 3  Offset for Chroma Motion.
+//Bit 11: 8        reg_matnr_mtn_cor_cgain   // unsigned , default = 3  to texture based coring for Chroma Motion. Normalized to 16 as 1
+//Bit  7: 4        reg_matnr_mtn_cor_yofst   // unsigned , default = 3  Offset for Luma Motion.
+//Bit  3: 0        reg_matnr_mtn_cor_ygain   // unsigned , default = 3  to texture based coring for Luma Motion. Normalized to 16 as 1
+#define   NR2_MATNR_MTN_GAIN                       (0x176d)
+#define P_NR2_MATNR_MTN_GAIN                       (volatile unsigned int *)((0x176d  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_mtn_hp_cgain    // unsigned , default = 64  to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
+//Bit 23:16        reg_matnr_mtn_hp_ygain    // unsigned , default = 64  to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
+//Bit 15: 8        reg_matnr_mtn_lp_cgain    // unsigned , default = 64  to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
+//Bit  7: 0        reg_matnr_mtn_lp_ygain    // unsigned , default = 64  to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
+#define   NR2_MATNR_DEGHOST                        (0x176e)
+#define P_NR2_MATNR_DEGHOST                        (volatile unsigned int *)((0x176e  << 2) + 0xff900000)
+//Bit 31            reserved
+//Bit 30:28        reg_matnr_deghost_mode    // unsigned , default = 0  0:old_deghost; 1:soft_denoise & strong_deghost; 2:strong_denoise & soft_deghost; 3:strong_denoise & strong_deghost
+//Bit 27:25        reserved
+//Bit 24:20        reg_matnr_deghost_ygain   // unsigned , default = 4
+//Bit 19:17        reserved
+//Bit 16:12        reg_matnr_deghost_cgain   // unsigned , default = 4
+//Bit 11: 9        reserved
+//Bit  8           reg_matnr_deghost_en      // unsigned , default = 1  0: disable; 1: enable Enable signal for DeGhost function:0: disable; 1: enable
+//Bit  7: 4        reg_matnr_deghost_cos     // unsigned , default = 3  DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
+//Bit  3: 0        reg_matnr_deghost_yos     // unsigned , default = 3  DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
+#define   NR2_MATNR_ALPHALP_LUT0                   (0x176f)
+#define P_NR2_MATNR_ALPHALP_LUT0                   (volatile unsigned int *)((0x176f  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphalp_lut3    // unsigned , default = 64  low-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphalp_lut2    // unsigned , default = 128  low-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphalp_lut1    // unsigned , default = 128  low-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphalp_lut0    // unsigned , default = 128  low-pass filter alpha LUT
+#define   NR2_MATNR_ALPHALP_LUT1                   (0x1770)
+#define P_NR2_MATNR_ALPHALP_LUT1                   (volatile unsigned int *)((0x1770  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphalp_lut7    // unsigned , default = 255  low-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphalp_lut6    // unsigned , default = 128  low-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphalp_lut5    // unsigned , default = 80  low-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphalp_lut4    // unsigned , default = 64  low-pass filter alpha LUT
+#define   NR2_MATNR_ALPHALP_LUT2                   (0x1771)
+#define P_NR2_MATNR_ALPHALP_LUT2                   (volatile unsigned int *)((0x1771  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphalp_lut11   // unsigned , default = 255  low-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphalp_lut10   // unsigned , default = 255  low-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphalp_lut9    // unsigned , default = 255  low-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphalp_lut8    // unsigned , default = 255  low-pass filter alpha LUT
+#define   NR2_MATNR_ALPHALP_LUT3                   (0x1772)
+#define P_NR2_MATNR_ALPHALP_LUT3                   (volatile unsigned int *)((0x1772  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphalp_lut15   // unsigned , default = 255  low-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphalp_lut14   // unsigned , default = 255  low-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphalp_lut13   // unsigned , default = 255  low-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphalp_lut12   // unsigned , default = 255  low-pass filter alpha LUT
+#define   NR2_MATNR_ALPHAHP_LUT0                   (0x1773)
+#define P_NR2_MATNR_ALPHAHP_LUT0                   (volatile unsigned int *)((0x1773  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphahp_lut3    // unsigned , default = 64  high-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphahp_lut2    // unsigned , default = 128  high-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphahp_lut1    // unsigned , default = 128  high-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphahp_lut0    // unsigned , default = 128  high-pass filter alpha LUT
+#define   NR2_MATNR_ALPHAHP_LUT1                   (0x1774)
+#define P_NR2_MATNR_ALPHAHP_LUT1                   (volatile unsigned int *)((0x1774  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphahp_lut7    // unsigned , default = 255  high-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphahp_lut6    // unsigned , default = 128  high-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphahp_lut5    // unsigned , default = 80  high-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphahp_lut4    // unsigned , default = 64  high-pass filter alpha LUT
+#define   NR2_MATNR_ALPHAHP_LUT2                   (0x1775)
+#define P_NR2_MATNR_ALPHAHP_LUT2                   (volatile unsigned int *)((0x1775  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphahp_lut11   // unsigned , default = 255  high-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphahp_lut10   // unsigned , default = 255  high-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphahp_lut9    // unsigned , default = 255  high-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphahp_lut8    // unsigned , default = 255  high-pass filter alpha LUT
+#define   NR2_MATNR_ALPHAHP_LUT3                   (0x1776)
+#define P_NR2_MATNR_ALPHAHP_LUT3                   (volatile unsigned int *)((0x1776  << 2) + 0xff900000)
+//Bit 31:24        reg_matnr_alphahp_lut15   // unsigned , default = 255  high-pass filter alpha LUT
+//Bit 23:16        reg_matnr_alphahp_lut14   // unsigned , default = 255  high-pass filter alpha LUT
+//Bit 15: 8        reg_matnr_alphahp_lut13   // unsigned , default = 255  high-pass filter alpha LUT
+//Bit  7: 0        reg_matnr_alphahp_lut12   // unsigned , default = 255  high-pass filter alpha LUT
+#define   NR2_MATNR_MTNB_BRT                       (0x1777)
+#define P_NR2_MATNR_MTNB_BRT                       (volatile unsigned int *)((0x1777  << 2) + 0xff900000)
+//Bit 31:28        reg_matnr_mtnb_brt_limt_hi  // unsigned , default = 0
+//Bit 27:24        reg_matnr_mtnb_brt_slop_hi  // unsigned , default = 0
+//Bit 23:16        reg_matnr_mtnb_brt_thrd_hi  // unsigned , default = 160
+//Bit 15:12        reg_matnr_mtnb_brt_limt_lo  // unsigned , default = 6
+//Bit 11: 8        reg_matnr_mtnb_brt_slop_lo  // unsigned , default = 6
+//Bit  7: 0        reg_matnr_mtnb_brt_thrd_lo  // unsigned , default = 100
+//========== nr2_tnr_regs register end ==========//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr2_regs.h
+//
+#define   DI_EI_DRT_CTRL                           (0x1778)
+#define P_DI_EI_DRT_CTRL                           (volatile unsigned int *)((0x1778  << 2) + 0xff900000)
+//Bit 31,     reg_rectg_en      ;u1
+//Bit 30,     reg_recbld_en     ;u1
+//Bit 29:28,  reg_rectg_ws      ;u2
+//Bit 27,     reserved
+//Bit 26:24,  reg_abq_margin    ;u3
+//Bit 23,     reserved
+//Bit 22:20,  reg_trend_mg      ;u3
+//Bit 19:16,  reg_int_d16xc1    ;u4
+//Bit 15:14,  reserved
+//Bit 13: 8,  reg_int_chlmt1    ;u6
+//Bit  7,     reserved
+//Bit  6: 4,  reg_nscheck_thrd  ;u3
+//Bit  3,     reserved
+//Bit  2: 0,  reg_horsl_ws      ;u3
+#define   DI_EI_DRT_PIXTH                          (0x1779)
+#define P_DI_EI_DRT_PIXTH                          (volatile unsigned int *)((0x1779  << 2) + 0xff900000)
+//Bit 31:24,  reg_min_pix        ;u8
+//Bit 23:16,  reg_max_pix        ;u8
+//Bit 15: 8,  reg_dmaxmin_thrdma ;u8
+//Bit  7: 0,  reg_dmaxmin_thrdmi ;u8
+#define   DI_EI_DRT_CORRPIXTH                      (0x177a)
+#define P_DI_EI_DRT_CORRPIXTH                      (volatile unsigned int *)((0x177a  << 2) + 0xff900000)
+//Bit 31:24,  reg_newcorrpix_maxthrd ;u8
+//Bit 23:16,  reg_corrpix_diffthrd   ;u8
+//Bit 15: 8,  reg_corrpix_minthrd    ;u8
+//Bit  7: 0,  reg_corrpix_maxthrd    ;u8
+#define   DI_EI_DRT_RECTG_WAVE                     (0x177b)
+#define P_DI_EI_DRT_RECTG_WAVE                     (volatile unsigned int *)((0x177b  << 2) + 0xff900000)
+//Bit 31:29,  reserved
+//Bit 28:24,  reg_max_pixwave  ;u5
+//Bit 23:21,  reserved
+//Bit 20:16,  reg_pix_wave     ;u5
+//Bit 15:14,  reserved
+//Bit 13: 8,  reg_maxdrt_thrd  ;u6
+//Bit  7: 0,  reg_wave_thrd    ;u8
+#define   DI_EI_DRT_PIX_DIFFTH                     (0x177c)
+#define P_DI_EI_DRT_PIX_DIFFTH                     (volatile unsigned int *)((0x177c  << 2) + 0xff900000)
+//Bit 31:24,  reg_newraw_thrd    ;u8
+//Bit 23:16,  reg_tb_max_thrd    ;u8
+//Bit 15: 8,  reg_diffpix_thrd   ;u8
+//Bit  7: 6,  reserved
+//Bit  5: 0,  reg_bilt_trendnumt ;u8
+#define   DI_EI_DRT_UNBITREND_TH                   (0x177d)
+#define P_DI_EI_DRT_UNBITREND_TH                   (volatile unsigned int *)((0x177d  << 2) + 0xff900000)
+//Bit 31:29,  reserved
+//Bit 28:24,  reg_trend_numb     ;u5
+//Bit 23:21,  reserved
+//Bit 20:16,  reg_bilt_trendnum  ;u5
+//Bit 15:13,  reserved
+//Bit 12: 8,  reg_unil_trendnumt ;u5
+//Bit  7: 5,  reserved
+//Bit  4: 0,  reg_trend_num      ;u5
+#define   NR2_CONV_MODE                            (0x177f)
+#define P_NR2_CONV_MODE                            (volatile unsigned int *)((0x177f  << 2) + 0xff900000)
+//Bit 3:2,	Conv_c444_mode	The format convert mode about 422 to 444 when data read out line buffer
+//Bit 1:0,	Conv_c422_mode	the format convert mode about 444 to 422 when data write to line buffer
+//// NR2 REG DEFINE END ////
+//// DET 3D REG DEFINE BEGIN ////
+//// 8'h34~8'h3f | 8'h80~8'h8f | 0x9a-0x9b
+//
+// Reading file:  det3d_regs.h
+//
+//// DET 3D REG DEFINE BEGIN ////
+//// 8'h34~8'h3f
+//// DET 3D REG DEFINE END ////
+#define   DET3D_MOTN_CFG                           (0x1734)
+#define P_DET3D_MOTN_CFG                           (volatile unsigned int *)((0x1734  << 2) + 0xff900000)
+//Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
+//Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma:
+//                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
+//Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
+//Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
+#define   DET3D_CB_CFG                             (0x1735)
+#define P_DET3D_CB_CFG                             (volatile unsigned int *)((0x1735  << 2) + 0xff900000)
+//Bit 7:4,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizotnal or vertical combing detection.
+//Bit 3:0,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizotnal or vertical combing detection.
+#define   DET3D_SPLT_CFG                           (0x1736)
+#define P_DET3D_SPLT_CFG                           (volatile unsigned int *)((0x1736  << 2) + 0xff900000)
+//Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection.
+//                                      The smaller of this value, the easier of the split line detected.
+//Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation.
+//                                      The smaller of this value, the more samples will be added to the estimation.
+#define   DET3D_HV_MUTE                            (0x1737)
+#define P_DET3D_HV_MUTE                            (volatile unsigned int *)((0x1737  << 2) + 0xff900000)
+//Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part.
+//Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part.
+//Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
+//Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
+//Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block.
+//Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block.
+#define   DET3D_MAT_STA_P1M1                       (0x1738)
+#define P_DET3D_MAT_STA_P1M1                       (volatile unsigned int *)((0x1738  << 2) + 0xff900000)
+//Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
+//Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
+//Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
+//Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
+#define   DET3D_MAT_STA_P1TH                       (0x1739)
+#define P_DET3D_MAT_STA_P1TH                       (volatile unsigned int *)((0x1739  << 2) + 0xff900000)
+//Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)
+//Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
+//Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
+#define   DET3D_MAT_STA_M1TH                       (0x173a)
+#define P_DET3D_MAT_STA_M1TH                       (volatile unsigned int *)((0x173a  << 2) + 0xff900000)
+//Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
+//Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
+//Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
+#define   DET3D_MAT_STA_RSFT                       (0x173b)
+#define P_DET3D_MAT_STA_RSFT                       (volatile unsigned int *)((0x173b  << 2) + 0xff900000)
+//Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
+//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
+//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
+//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+#define   DET3D_MAT_SYMTC_TH                       (0x173c)
+#define P_DET3D_MAT_SYMTC_TH                       (volatile unsigned int *)((0x173c  << 2) + 0xff900000)
+//Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric.
+//Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric.
+//Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric.
+//Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric.
+#define   DET3D_RO_DET_CB_HOR                      (0x173d)
+#define P_DET3D_RO_DET_CB_HOR                      (volatile unsigned int *)((0x173d  << 2) + 0xff900000)
+//Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
+//Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
+#define   DET3D_RO_DET_CB_VER                      (0x173e)
+#define P_DET3D_RO_DET_CB_VER                      (volatile unsigned int *)((0x173e  << 2) + 0xff900000)
+//Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
+//Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
+#define   DET3D_RO_SPLT_HT                         (0x173f)
+#define P_DET3D_RO_SPLT_HT                         (volatile unsigned int *)((0x173f  << 2) + 0xff900000)
+//Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
+//Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
+//Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+//// DET 3D REG DEFINE BEGIN ////
+////  8'h80~8'h8f
+#define   DET3D_RO_SPLT_HB                         (0x1780)
+#define P_DET3D_RO_SPLT_HB                         (volatile unsigned int *)((0x1780  << 2) + 0xff900000)
+//Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+#define   DET3D_RO_SPLT_VL                         (0x1781)
+#define P_DET3D_RO_SPLT_VL                         (volatile unsigned int *)((0x1781  << 2) + 0xff900000)
+//Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+#define   DET3D_RO_SPLT_VR                         (0x1782)
+#define P_DET3D_RO_SPLT_VR                         (volatile unsigned int *)((0x1782  << 2) + 0xff900000)
+//Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+#define   DET3D_RO_MAT_LUMA_LR                     (0x1783)
+#define P_DET3D_RO_MAT_LUMA_LR                     (volatile unsigned int *)((0x1783  << 2) + 0xff900000)
+//Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically),
+//                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
+//Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically),
+//                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
+//Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision,
+//                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
+#define   DET3D_RO_MAT_LUMA_TB                     (0x1784)
+#define P_DET3D_RO_MAT_LUMA_TB                     (volatile unsigned int *)((0x1784  << 2) + 0xff900000)
+//Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally),
+//Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally),
+//Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision,
+#define   DET3D_RO_MAT_CHRU_LR                     (0x1785)
+#define P_DET3D_RO_MAT_CHRU_LR                     (volatile unsigned int *)((0x1785  << 2) + 0xff900000)
+//Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically),
+//Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically),
+//Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision,
+#define   DET3D_RO_MAT_CHRU_TB                     (0x1786)
+#define P_DET3D_RO_MAT_CHRU_TB                     (volatile unsigned int *)((0x1786  << 2) + 0xff900000)
+//Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
+#define   DET3D_RO_MAT_CHRV_LR                     (0x1787)
+#define P_DET3D_RO_MAT_CHRV_LR                     (volatile unsigned int *)((0x1787  << 2) + 0xff900000)
+//Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
+#define   DET3D_RO_MAT_CHRV_TB                     (0x1788)
+#define P_DET3D_RO_MAT_CHRV_TB                     (volatile unsigned int *)((0x1788  << 2) + 0xff900000)
+//Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
+#define   DET3D_RO_MAT_HEDG_LR                     (0x1789)
+#define P_DET3D_RO_MAT_HEDG_LR                     (volatile unsigned int *)((0x1789  << 2) + 0xff900000)
+//Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
+#define   DET3D_RO_MAT_HEDG_TB                     (0x178a)
+#define P_DET3D_RO_MAT_HEDG_TB                     (volatile unsigned int *)((0x178a  << 2) + 0xff900000)
+//Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
+#define   DET3D_RO_MAT_VEDG_LR                     (0x178b)
+#define P_DET3D_RO_MAT_VEDG_LR                     (volatile unsigned int *)((0x178b  << 2) + 0xff900000)
+//Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
+#define   DET3D_RO_MAT_VEDG_TB                     (0x178c)
+#define P_DET3D_RO_MAT_VEDG_TB                     (volatile unsigned int *)((0x178c  << 2) + 0xff900000)
+//Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
+#define   DET3D_RO_MAT_MOTN_LR                     (0x178d)
+#define P_DET3D_RO_MAT_MOTN_LR                     (volatile unsigned int *)((0x178d  << 2) + 0xff900000)
+//Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
+#define   DET3D_RO_MAT_MOTN_TB                     (0x178e)
+#define P_DET3D_RO_MAT_MOTN_TB                     (volatile unsigned int *)((0x178e  << 2) + 0xff900000)
+//Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
+#define   DET3D_RO_FRM_MOTN                        (0x178f)
+#define P_DET3D_RO_FRM_MOTN                        (volatile unsigned int *)((0x178f  << 2) + 0xff900000)
+//Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
+/// mat ram read enter addr
+#define   DET3D_RAMRD_ADDR_PORT                    (0x179a)
+#define P_DET3D_RAMRD_ADDR_PORT                    (volatile unsigned int *)((0x179a  << 2) + 0xff900000)
+#define   DET3D_RAMRD_DATA_PORT                    (0x179b)
+#define P_DET3D_RAMRD_DATA_PORT                    (volatile unsigned int *)((0x179b  << 2) + 0xff900000)
+//
+// Closing file:  det3d_regs.h
+//
+//   `define DET3D_RO_SPLT_HB            8'h80
+//   //Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//   //Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//   //Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+//   `define DET3D_RO_SPLT_VL            8'h81
+//   //Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//   //Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//   //Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+//   `define DET3D_RO_SPLT_VR            8'h82
+//   //Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//   //Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//   //Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+//   `define DET3D_RO_MAT_LUMA_LR        8'h83
+//   //Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically),
+//   //                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
+//   //Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically),
+//   //                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
+//   //Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision,
+//   //                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
+//   `define DET3D_RO_MAT_LUMA_TB        8'h84
+//   //Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally),
+//   //Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally),
+//   //Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision,
+//   `define DET3D_RO_MAT_CHRU_LR        8'h85
+//   //Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically),
+//   //Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically),
+//   //Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision,
+//   `define DET3D_RO_MAT_CHRU_TB        8'h86
+//   //Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
+//   //Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//   //Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
+//   `define DET3D_RO_MAT_CHRV_LR        8'h87
+//   //Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
+//   //Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
+//   //Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
+//   `define DET3D_RO_MAT_CHRV_TB        8'h88
+//   //Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
+//   //Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//   //Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
+//   `define DET3D_RO_MAT_HEDG_LR        8'h89
+//   //Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
+//   //Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
+//   //Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
+//   `define DET3D_RO_MAT_HEDG_TB        8'h8a
+//   //Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
+//   //Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//   //Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
+//   `define DET3D_RO_MAT_VEDG_LR        8'h8b
+//   //Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
+//   //Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
+//   //Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
+//   `define DET3D_RO_MAT_VEDG_TB        8'h8c
+//   //Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
+//   //Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//   //Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
+//   `define DET3D_RO_MAT_MOTN_LR        8'h8d
+//   //Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
+//   //Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
+//   //Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
+//   `define DET3D_RO_MAT_MOTN_TB        8'h8e
+//   //Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
+//   //Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//   //Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
+//   `define DET3D_RO_FRM_MOTN           8'h8f
+//   //Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
+#define   DI_EI_CTRL10                             (0x1793)
+#define P_DI_EI_CTRL10                             (volatile unsigned int *)((0x1793  << 2) + 0xff900000)
+//bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth
+//bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd
+//bit 23:20,   reg_ei_caldrt_hstrrgchk_mg
+//bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul
+//bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf
+//bit 17:16,   reg_ei_caldrt_hstrrgchk_ws
+//bit 15,      reg_ei_caldrt_hstrrgchk_en
+//bit 14:13,   reg_ei_caldrt_hpncheck_mode
+//bit 12,      reg_ei_caldrt_hpncheck_mute
+//bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2
+//bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1
+//bit 5:4,     reg_ei_caldrt_hcnfcheck_mode
+//bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2
+#define   DI_NR_1_CTRL0                            (0x1794)
+#define P_DI_NR_1_CTRL0                            (volatile unsigned int *)((0x1794  << 2) + 0xff900000)
+#define   DI_NR_1_CTRL1                            (0x1795)
+#define P_DI_NR_1_CTRL1                            (volatile unsigned int *)((0x1795  << 2) + 0xff900000)
+#define   DI_NR_1_CTRL2                            (0x1796)
+#define P_DI_NR_1_CTRL2                            (volatile unsigned int *)((0x1796  << 2) + 0xff900000)
+#define   DI_NR_1_CTRL3                            (0x1797)
+#define P_DI_NR_1_CTRL3                            (volatile unsigned int *)((0x1797  << 2) + 0xff900000)
+#define   DI_EI_XWIN0                              (0x1798)
+#define P_DI_EI_XWIN0                              (volatile unsigned int *)((0x1798  << 2) + 0xff900000)
+//bit 27:16,   ei_xend0
+//bit 11:0,    ei_xstart0
+#define   DI_EI_XWIN1                              (0x1799)
+#define P_DI_EI_XWIN1                              (volatile unsigned int *)((0x1799  << 2) + 0xff900000)
+/// mat ram read enter addr
+//   `define DET3D_RAMRD_ADDR_PORT       8'h9a
+//   `define DET3D_RAMRD_DATA_PORT       8'h9b
+#define   NR2_CFR_PARA_CFG0                        (0x179c)
+#define P_NR2_CFR_PARA_CFG0                        (volatile unsigned int *)((0x179c  << 2) + 0xff900000)
+//Bit 8,	reg_CFR_CurDif_luma_mode	Current Field Top/Bot line Luma difference calculation mode
+//Bit 7:6,	reg_MACFR_frm_phase	        U2  This will be a field based phase register that need to be set by FW phase to phase:
+//                                      this will be calculated based on dbdr_phase of the specific line of this frame.
+//                                      u1: dbdr_phase=1, center line is DB in current line;  dbdr_phase=2, center line is Dr in current line;
+//Bit 5:4,	reg_CFR_CurDif_tran_mode	U2  Current Field Top/Bot line Luma/Chroma transition level calculation mode,
+//Bit 3:2,	reg_CFR_alpha_mode	        U2  Alpha selection mode for CFR block from curAlp and motAlp i.e. 0: motAlp; 1: (motAlp+curAlp)/2; 2: min(motAlp,curAlp); 3: max(motAlp,curAlp);
+//Bit 1:0,	reg_CFR_Motion_Luma_mode	U2  LumaMotion Calculation mode for MA-CFR. 0: top/bot Lumma motion;   1: middle Luma Motion 2: top/bot + middle motion; 3: max(top/tot motion, middle motion)
+#define   NR2_CFR_PARA_CFG1                        (0x179d)
+#define P_NR2_CFR_PARA_CFG1                        (volatile unsigned int *)((0x179d  << 2) + 0xff900000)
+//Bit 23:16,	reg_CFR_alpha_gain	    gain to map muxed curAlp and motAlp to alpha that will be used for final blending.
+//Bit 15: 8,	reg_CFR_Motion_ofst	    Offset to Motion to calculate the motAlp, e,g:motAlp= reg_CFR_Motion_ofst- Motion;This register can be seen as the level of motion that we consider it at moving.
+//Bit  7: 0,	reg_CFR_CurDif_gain	    gain to CurDif to map to alpha, normalized to 32;
+//// DET 3D REG DEFINE END ////
+#define   DI_EI_CTRL11                             (0x179e)
+#define P_DI_EI_CTRL11                             (volatile unsigned int *)((0x179e  << 2) + 0xff900000)
+//bit 30:29,   reg_ei_amb_detect_mode
+//bit 28:24,   reg_ei_amb_detect_winth
+//bit 23:21,   reg_ei_amb_decide_rppth
+//bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth
+//bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode
+//bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode
+//bit 13:12,   reg_ei_retime_lastvertfrcchk_mode
+//bit 11:8,    reg_ei_retime_lastpnchk_drtth
+//bit 6,       reg_ei_retime_lastpnchk_en
+//bit 5:4,     reg_ei_retime_mode
+//bit 3,       reg_ei_retime_last_en
+//bit 2,       reg_ei_retime_ab_en
+//bit 1,       reg_ei_caldrt_hstrvertfrcchk_en
+//bit 0,       reg_ei_caldrt_hstrrgchk_mode
+#define   DI_EI_CTRL12                             (0x179f)
+#define P_DI_EI_CTRL12                             (volatile unsigned int *)((0x179f  << 2) + 0xff900000)
+//bit 31:28,   reg_ei_drtdelay2_lmt
+//bit 27:26,   reg_ei_drtdelay2_notver_lrwin
+//bit 25:24,   reg_ei_drtdelay_mode
+//bit 23,      reg_ei_drtdelay2_mode
+//bit 22:20,   reg_ei_assign_xla_signm0th
+//bit 19,      reg_ei_assign_pkbiasvert_en
+//bit 18,      reg_ei_assign_xla_en
+//bit 17:16,   reg_ei_assign_xla_mode
+//bit 15:12,   reg_ei_assign_nlfilter_magin
+//bit 11:8,    reg_ei_localsearch_maxrange
+//bit 7:4,     reg_ei_xla_drtth
+//bit 3:0,     reg_ei_flatmsad_thrd
+#define   DI_CONTWR_X                              (0x17a0)
+#define P_DI_CONTWR_X                              (volatile unsigned int *)((0x17a0  << 2) + 0xff900000)
+#define   DI_CONTWR_Y                              (0x17a1)
+#define P_DI_CONTWR_Y                              (volatile unsigned int *)((0x17a1  << 2) + 0xff900000)
+#define   DI_CONTWR_CTRL                           (0x17a2)
+#define P_DI_CONTWR_CTRL                           (volatile unsigned int *)((0x17a2  << 2) + 0xff900000)
+#define   DI_CONTPRD_X                             (0x17a3)
+#define P_DI_CONTPRD_X                             (volatile unsigned int *)((0x17a3  << 2) + 0xff900000)
+#define   DI_CONTPRD_Y                             (0x17a4)
+#define P_DI_CONTPRD_Y                             (volatile unsigned int *)((0x17a4  << 2) + 0xff900000)
+#define   DI_CONTP2RD_X                            (0x17a5)
+#define P_DI_CONTP2RD_X                            (volatile unsigned int *)((0x17a5  << 2) + 0xff900000)
+#define   DI_CONTP2RD_Y                            (0x17a6)
+#define P_DI_CONTP2RD_Y                            (volatile unsigned int *)((0x17a6  << 2) + 0xff900000)
+#define   DI_CONTRD_CTRL                           (0x17a7)
+#define P_DI_CONTRD_CTRL                           (volatile unsigned int *)((0x17a7  << 2) + 0xff900000)
+#define   DI_EI_CTRL13                             (0x17a8)
+#define P_DI_EI_CTRL13                             (volatile unsigned int *)((0x17a8  << 2) + 0xff900000)
+//bit 27:24,   reg_ei_int_drt2x_chrdrt_limit
+//bit 23:20,   reg_ei_int_drt16x_core
+//bit 19:16,   reg_ei_int_drtdelay2_notver_cancv
+//bit 15:8,    reg_ei_int_drtdelay2_notver_sadth
+//bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth
+#define   DI_MTN_1_CTRL6                           (0x17a9)
+#define P_DI_MTN_1_CTRL6                           (volatile unsigned int *)((0x17a9  << 2) + 0xff900000)
+//bit 31:24,   mtn_m1b_extnd
+//bit 23:16,   mtn_m1b_errod
+//bit 15: 8,   mtn_core_ykinter
+//bit  7: 0,   mtn_core_ckinter
+#define   DI_MTN_1_CTRL7                           (0x17aa)
+#define P_DI_MTN_1_CTRL7                           (volatile unsigned int *)((0x17aa  << 2) + 0xff900000)
+//bit 31:24,   mtn_core_mxcmby
+//bit 23:16,   mtn_core_mxcmbc
+//bit 15: 8,   mtn_core_y
+//bit  7: 0,   mtn_core_c
+#define   DI_MTN_1_CTRL8                           (0x17ab)
+#define P_DI_MTN_1_CTRL8                           (volatile unsigned int *)((0x17ab  << 2) + 0xff900000)
+//bit 31:24,   mtn_fcore_ykinter
+//bit 23:16,   mtn_fcore_ckinter
+//bit 15: 8,   mtn_fcore_ykintra
+//bit  7: 0,   mtn_fcore_ckintra
+#define   DI_MTN_1_CTRL9                           (0x17ac)
+#define P_DI_MTN_1_CTRL9                           (volatile unsigned int *)((0x17ac  << 2) + 0xff900000)
+//bit 31:24,   mtn_fcore_2yrate
+//bit 23:16,   mtn_fcore_2crate
+//bit 15: 8,   mtn_fcore_y
+//bit  7: 0,   mtn_fcore_c
+#define   DI_MTN_1_CTRL10                          (0x17ad)
+#define P_DI_MTN_1_CTRL10                          (volatile unsigned int *)((0x17ad  << 2) + 0xff900000)
+//bit 27:24,   mtn_motfld0
+//bit 19:16,   mtn_stlfld0
+//bit 11: 8,   mtn_motfld1
+//bit  3: 0,   mtn_stlfld1
+#define   DI_MTN_1_CTRL11                          (0x17ae)
+#define P_DI_MTN_1_CTRL11                          (volatile unsigned int *)((0x17ae  << 2) + 0xff900000)
+//bit 27:24,   mtn_smotevn
+//bit 20:16,   mtn_smotodd
+//bit 11: 8,   mtn_sstlevn
+//bit  4: 0,   mtn_sstlodd
+#define   DI_MTN_1_CTRL12                          (0x17af)
+#define P_DI_MTN_1_CTRL12                          (volatile unsigned int *)((0x17af  << 2) + 0xff900000)
+//bit 31:24,   mtn_mgain
+//bit 17:16,   mtn_mmode
+//bit 15: 8,   mtn_sthrd
+//bit  4: 0,   mtn_sgain
+#define   DI_NRWR_X                                (0x17c0)
+#define P_DI_NRWR_X                                (volatile unsigned int *)((0x17c0  << 2) + 0xff900000)
+#define   DI_NRWR_Y                                (0x17c1)
+#define P_DI_NRWR_Y                                (volatile unsigned int *)((0x17c1  << 2) + 0xff900000)
+//bit 31:30				nrwr_words_lim
+//bit 29				nrwr_rev_y
+//bit 28:16				nrwr_start_y
+//bit 15				nrwr_ext_en
+//bit 12:0				nrwr_end_y
+#define   DI_NRWR_CTRL                             (0x17c2)
+#define P_DI_NRWR_CTRL                             (volatile unsigned int *)((0x17c2  << 2) + 0xff900000)
+//bit 31				pending_ddr_wrrsp_diwr
+//bit 30				nrwr_reg_swap
+//bit 29:26				nrwr_burst_lim
+//bit 25				nrwr_canvas_syncen
+//bit 24				nrwr_no_clk_gate
+//bit 23:22				nrwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas;
+//bit 21:20				nrwr_hconv_mode
+//bit 19:18				nrwr_vconv_mode
+//bit 17				nrwr_swap_cbcr
+//bit 16				nrwr_urgent
+//bit 15:8				nrwr_canvas_index_chroma
+//bit 7:0				nrwr_canvas_index_luma
+#define   DI_MTNWR_X                               (0x17c3)
+#define P_DI_MTNWR_X                               (volatile unsigned int *)((0x17c3  << 2) + 0xff900000)
+#define   DI_MTNWR_Y                               (0x17c4)
+#define P_DI_MTNWR_Y                               (volatile unsigned int *)((0x17c4  << 2) + 0xff900000)
+#define   DI_MTNWR_CTRL                            (0x17c5)
+#define P_DI_MTNWR_CTRL                            (volatile unsigned int *)((0x17c5  << 2) + 0xff900000)
+#define   DI_DIWR_X                                (0x17c6)
+#define P_DI_DIWR_X                                (volatile unsigned int *)((0x17c6  << 2) + 0xff900000)
+#define   DI_DIWR_Y                                (0x17c7)
+#define P_DI_DIWR_Y                                (volatile unsigned int *)((0x17c7  << 2) + 0xff900000)
+//bit 31:30				diwr_words_lim
+//bit 29				diwr_rev_y
+//bit 28:16				diwr_start_y
+//bit 15				diwr_ext_en
+//bit 12:0				diwr_end_y
+#define   DI_DIWR_CTRL                             (0x17c8)
+#define P_DI_DIWR_CTRL                             (volatile unsigned int *)((0x17c8  << 2) + 0xff900000)
+//bit 31				pending_ddr_wrrsp_diwr
+//bit 30				diwr_reg_swap
+//bit 29:26				diwr_burst_lim
+//bit 25				diwr_canvas_syncen
+//bit 24				diwr_no_clk_gate
+//bit 23:22				diwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas;
+//bit 21:20				diwr_hconv_mode
+//bit 19:18				diwr_vconv_mode
+//bit 17				diwr_swap_cbcr
+//bit 16				diwr_urgent
+//bit 15:8				diwr_canvas_index_chroma
+//bit 7:0				diwr_canvas_index_luma
+//`define DI_MTNCRD_X               8'hc9
+//`define DI_MTNCRD_Y               8'hca
+#define   DI_MTNPRD_X                              (0x17cb)
+#define P_DI_MTNPRD_X                              (volatile unsigned int *)((0x17cb  << 2) + 0xff900000)
+#define   DI_MTNPRD_Y                              (0x17cc)
+#define P_DI_MTNPRD_Y                              (volatile unsigned int *)((0x17cc  << 2) + 0xff900000)
+#define   DI_MTNRD_CTRL                            (0x17cd)
+#define P_DI_MTNRD_CTRL                            (volatile unsigned int *)((0x17cd  << 2) + 0xff900000)
+#define   DI_INP_GEN_REG                           (0x17ce)
+#define P_DI_INP_GEN_REG                           (volatile unsigned int *)((0x17ce  << 2) + 0xff900000)
+#define   DI_INP_CANVAS0                           (0x17cf)
+#define P_DI_INP_CANVAS0                           (volatile unsigned int *)((0x17cf  << 2) + 0xff900000)
+#define   DI_INP_LUMA_X0                           (0x17d0)
+#define P_DI_INP_LUMA_X0                           (volatile unsigned int *)((0x17d0  << 2) + 0xff900000)
+#define   DI_INP_LUMA_Y0                           (0x17d1)
+#define P_DI_INP_LUMA_Y0                           (volatile unsigned int *)((0x17d1  << 2) + 0xff900000)
+#define   DI_INP_CHROMA_X0                         (0x17d2)
+#define P_DI_INP_CHROMA_X0                         (volatile unsigned int *)((0x17d2  << 2) + 0xff900000)
+#define   DI_INP_CHROMA_Y0                         (0x17d3)
+#define P_DI_INP_CHROMA_Y0                         (volatile unsigned int *)((0x17d3  << 2) + 0xff900000)
+#define   DI_INP_RPT_LOOP                          (0x17d4)
+#define P_DI_INP_RPT_LOOP                          (volatile unsigned int *)((0x17d4  << 2) + 0xff900000)
+#define   DI_INP_LUMA0_RPT_PAT                     (0x17d5)
+#define P_DI_INP_LUMA0_RPT_PAT                     (volatile unsigned int *)((0x17d5  << 2) + 0xff900000)
+#define   DI_INP_CHROMA0_RPT_PAT                   (0x17d6)
+#define P_DI_INP_CHROMA0_RPT_PAT                   (volatile unsigned int *)((0x17d6  << 2) + 0xff900000)
+#define   DI_INP_DUMMY_PIXEL                       (0x17d7)
+#define P_DI_INP_DUMMY_PIXEL                       (volatile unsigned int *)((0x17d7  << 2) + 0xff900000)
+#define   DI_INP_LUMA_FIFO_SIZE                    (0x17d8)
+#define P_DI_INP_LUMA_FIFO_SIZE                    (volatile unsigned int *)((0x17d8  << 2) + 0xff900000)
+#define   DI_INP_RANGE_MAP_Y                       (0x17ba)
+#define P_DI_INP_RANGE_MAP_Y                       (volatile unsigned int *)((0x17ba  << 2) + 0xff900000)
+#define   DI_INP_RANGE_MAP_CB                      (0x17bb)
+#define P_DI_INP_RANGE_MAP_CB                      (volatile unsigned int *)((0x17bb  << 2) + 0xff900000)
+#define   DI_INP_RANGE_MAP_CR                      (0x17bc)
+#define P_DI_INP_RANGE_MAP_CR                      (volatile unsigned int *)((0x17bc  << 2) + 0xff900000)
+#define   DI_INP_GEN_REG2                          (0x1791)
+#define P_DI_INP_GEN_REG2                          (volatile unsigned int *)((0x1791  << 2) + 0xff900000)
+#define   DI_INP_FMT_CTRL                          (0x17d9)
+#define P_DI_INP_FMT_CTRL                          (volatile unsigned int *)((0x17d9  << 2) + 0xff900000)
+#define   DI_INP_FMT_W                             (0x17da)
+#define P_DI_INP_FMT_W                             (volatile unsigned int *)((0x17da  << 2) + 0xff900000)
+#define   DI_MEM_GEN_REG                           (0x17db)
+#define P_DI_MEM_GEN_REG                           (volatile unsigned int *)((0x17db  << 2) + 0xff900000)
+#define   DI_MEM_CANVAS0                           (0x17dc)
+#define P_DI_MEM_CANVAS0                           (volatile unsigned int *)((0x17dc  << 2) + 0xff900000)
+#define   DI_MEM_LUMA_X0                           (0x17dd)
+#define P_DI_MEM_LUMA_X0                           (volatile unsigned int *)((0x17dd  << 2) + 0xff900000)
+#define   DI_MEM_LUMA_Y0                           (0x17de)
+#define P_DI_MEM_LUMA_Y0                           (volatile unsigned int *)((0x17de  << 2) + 0xff900000)
+#define   DI_MEM_CHROMA_X0                         (0x17df)
+#define P_DI_MEM_CHROMA_X0                         (volatile unsigned int *)((0x17df  << 2) + 0xff900000)
+#define   DI_MEM_CHROMA_Y0                         (0x17e0)
+#define P_DI_MEM_CHROMA_Y0                         (volatile unsigned int *)((0x17e0  << 2) + 0xff900000)
+#define   DI_MEM_RPT_LOOP                          (0x17e1)
+#define P_DI_MEM_RPT_LOOP                          (volatile unsigned int *)((0x17e1  << 2) + 0xff900000)
+#define   DI_MEM_LUMA0_RPT_PAT                     (0x17e2)
+#define P_DI_MEM_LUMA0_RPT_PAT                     (volatile unsigned int *)((0x17e2  << 2) + 0xff900000)
+#define   DI_MEM_CHROMA0_RPT_PAT                   (0x17e3)
+#define P_DI_MEM_CHROMA0_RPT_PAT                   (volatile unsigned int *)((0x17e3  << 2) + 0xff900000)
+#define   DI_MEM_DUMMY_PIXEL                       (0x17e4)
+#define P_DI_MEM_DUMMY_PIXEL                       (volatile unsigned int *)((0x17e4  << 2) + 0xff900000)
+#define   DI_MEM_LUMA_FIFO_SIZE                    (0x17e5)
+#define P_DI_MEM_LUMA_FIFO_SIZE                    (volatile unsigned int *)((0x17e5  << 2) + 0xff900000)
+#define   DI_MEM_RANGE_MAP_Y                       (0x17bd)
+#define P_DI_MEM_RANGE_MAP_Y                       (volatile unsigned int *)((0x17bd  << 2) + 0xff900000)
+#define   DI_MEM_RANGE_MAP_CB                      (0x17be)
+#define P_DI_MEM_RANGE_MAP_CB                      (volatile unsigned int *)((0x17be  << 2) + 0xff900000)
+#define   DI_MEM_RANGE_MAP_CR                      (0x17bf)
+#define P_DI_MEM_RANGE_MAP_CR                      (volatile unsigned int *)((0x17bf  << 2) + 0xff900000)
+#define   DI_MEM_GEN_REG2                          (0x1792)
+#define P_DI_MEM_GEN_REG2                          (volatile unsigned int *)((0x1792  << 2) + 0xff900000)
+#define   DI_MEM_FMT_CTRL                          (0x17e6)
+#define P_DI_MEM_FMT_CTRL                          (volatile unsigned int *)((0x17e6  << 2) + 0xff900000)
+#define   DI_MEM_FMT_W                             (0x17e7)
+#define P_DI_MEM_FMT_W                             (volatile unsigned int *)((0x17e7  << 2) + 0xff900000)
+#define   DI_IF1_GEN_REG                           (0x17e8)
+#define P_DI_IF1_GEN_REG                           (volatile unsigned int *)((0x17e8  << 2) + 0xff900000)
+#define   DI_IF1_CANVAS0                           (0x17e9)
+#define P_DI_IF1_CANVAS0                           (volatile unsigned int *)((0x17e9  << 2) + 0xff900000)
+#define   DI_IF1_LUMA_X0                           (0x17ea)
+#define P_DI_IF1_LUMA_X0                           (volatile unsigned int *)((0x17ea  << 2) + 0xff900000)
+#define   DI_IF1_LUMA_Y0                           (0x17eb)
+#define P_DI_IF1_LUMA_Y0                           (volatile unsigned int *)((0x17eb  << 2) + 0xff900000)
+#define   DI_IF1_CHROMA_X0                         (0x17ec)
+#define P_DI_IF1_CHROMA_X0                         (volatile unsigned int *)((0x17ec  << 2) + 0xff900000)
+#define   DI_IF1_CHROMA_Y0                         (0x17ed)
+#define P_DI_IF1_CHROMA_Y0                         (volatile unsigned int *)((0x17ed  << 2) + 0xff900000)
+#define   DI_IF1_RPT_LOOP                          (0x17ee)
+#define P_DI_IF1_RPT_LOOP                          (volatile unsigned int *)((0x17ee  << 2) + 0xff900000)
+#define   DI_IF1_LUMA0_RPT_PAT                     (0x17ef)
+#define P_DI_IF1_LUMA0_RPT_PAT                     (volatile unsigned int *)((0x17ef  << 2) + 0xff900000)
+#define   DI_IF1_CHROMA0_RPT_PAT                   (0x17f0)
+#define P_DI_IF1_CHROMA0_RPT_PAT                   (volatile unsigned int *)((0x17f0  << 2) + 0xff900000)
+#define   DI_IF1_DUMMY_PIXEL                       (0x17f1)
+#define P_DI_IF1_DUMMY_PIXEL                       (volatile unsigned int *)((0x17f1  << 2) + 0xff900000)
+#define   DI_IF1_LUMA_FIFO_SIZE                    (0x17f2)
+#define P_DI_IF1_LUMA_FIFO_SIZE                    (volatile unsigned int *)((0x17f2  << 2) + 0xff900000)
+#define   DI_IF1_RANGE_MAP_Y                       (0x17fc)
+#define P_DI_IF1_RANGE_MAP_Y                       (volatile unsigned int *)((0x17fc  << 2) + 0xff900000)
+#define   DI_IF1_RANGE_MAP_CB                      (0x17fd)
+#define P_DI_IF1_RANGE_MAP_CB                      (volatile unsigned int *)((0x17fd  << 2) + 0xff900000)
+#define   DI_IF1_RANGE_MAP_CR                      (0x17fe)
+#define P_DI_IF1_RANGE_MAP_CR                      (volatile unsigned int *)((0x17fe  << 2) + 0xff900000)
+#define   DI_IF1_GEN_REG2                          (0x1790)
+#define P_DI_IF1_GEN_REG2                          (volatile unsigned int *)((0x1790  << 2) + 0xff900000)
+#define   DI_IF1_FMT_CTRL                          (0x17f3)
+#define P_DI_IF1_FMT_CTRL                          (volatile unsigned int *)((0x17f3  << 2) + 0xff900000)
+#define   DI_IF1_FMT_W                             (0x17f4)
+#define P_DI_IF1_FMT_W                             (volatile unsigned int *)((0x17f4  << 2) + 0xff900000)
+#define   DI_CHAN2_GEN_REG                         (0x17f5)
+#define P_DI_CHAN2_GEN_REG                         (volatile unsigned int *)((0x17f5  << 2) + 0xff900000)
+#define   DI_CHAN2_CANVAS0                         (0x17f6)
+#define P_DI_CHAN2_CANVAS0                         (volatile unsigned int *)((0x17f6  << 2) + 0xff900000)
+#define   DI_CHAN2_LUMA_X0                         (0x17f7)
+#define P_DI_CHAN2_LUMA_X0                         (volatile unsigned int *)((0x17f7  << 2) + 0xff900000)
+#define   DI_CHAN2_LUMA_Y0                         (0x17f8)
+#define P_DI_CHAN2_LUMA_Y0                         (volatile unsigned int *)((0x17f8  << 2) + 0xff900000)
+#define   DI_CHAN2_CHROMA_X0                       (0x17f9)
+#define P_DI_CHAN2_CHROMA_X0                       (volatile unsigned int *)((0x17f9  << 2) + 0xff900000)
+#define   DI_CHAN2_CHROMA_Y0                       (0x17fa)
+#define P_DI_CHAN2_CHROMA_Y0                       (volatile unsigned int *)((0x17fa  << 2) + 0xff900000)
+#define   DI_CHAN2_RPT_LOOP                        (0x17fb)
+#define P_DI_CHAN2_RPT_LOOP                        (volatile unsigned int *)((0x17fb  << 2) + 0xff900000)
+#define   DI_CHAN2_LUMA0_RPT_PAT                   (0x17b0)
+#define P_DI_CHAN2_LUMA0_RPT_PAT                   (volatile unsigned int *)((0x17b0  << 2) + 0xff900000)
+#define   DI_CHAN2_CHROMA0_RPT_PAT                 (0x17b1)
+#define P_DI_CHAN2_CHROMA0_RPT_PAT                 (volatile unsigned int *)((0x17b1  << 2) + 0xff900000)
+#define   DI_CHAN2_DUMMY_PIXEL                     (0x17b2)
+#define P_DI_CHAN2_DUMMY_PIXEL                     (volatile unsigned int *)((0x17b2  << 2) + 0xff900000)
+#define   DI_CHAN2_LUMA_FIFO_SIZE                  (0x17b3)
+#define P_DI_CHAN2_LUMA_FIFO_SIZE                  (volatile unsigned int *)((0x17b3  << 2) + 0xff900000)
+#define   DI_CHAN2_RANGE_MAP_Y                     (0x17b4)
+#define P_DI_CHAN2_RANGE_MAP_Y                     (volatile unsigned int *)((0x17b4  << 2) + 0xff900000)
+#define   DI_CHAN2_RANGE_MAP_CB                    (0x17b5)
+#define P_DI_CHAN2_RANGE_MAP_CB                    (volatile unsigned int *)((0x17b5  << 2) + 0xff900000)
+#define   DI_CHAN2_RANGE_MAP_CR                    (0x17b6)
+#define P_DI_CHAN2_RANGE_MAP_CR                    (volatile unsigned int *)((0x17b6  << 2) + 0xff900000)
+#define   DI_CHAN2_GEN_REG2                        (0x17b7)
+#define P_DI_CHAN2_GEN_REG2                        (volatile unsigned int *)((0x17b7  << 2) + 0xff900000)
+#define   DI_CHAN2_FMT_CTRL                        (0x17b8)
+#define P_DI_CHAN2_FMT_CTRL                        (volatile unsigned int *)((0x17b8  << 2) + 0xff900000)
+#define   DI_CHAN2_FMT_W                           (0x17b9)
+#define P_DI_CHAN2_FMT_W                           (volatile unsigned int *)((0x17b9  << 2) + 0xff900000)
+//
+#define DOLBY_PATH_CTRL                            0x1a0c
+#define OSD_PATH_MISC_CTRL                         0x1a0e
+#define MALI_AFBCD_TOP_CTRL                        0x1a0f
+
+#define VPP_VD2_HDR_IN_SIZE                        0x1df0
+#define VPP_OSD1_IN_SIZE                           0x1df1
+#define VPP_GCLK_CTRL2                             0x1df2
+#define VD2_PPS_DUMMY_DATA                         0x1df4
+#define VPP_OSD1_BLD_H_SCOPE                       0x1df5
+#define VPP_OSD1_BLD_V_SCOPE                       0x1df6
+#define VPP_OSD2_BLD_H_SCOPE                       0x1df7
+#define VPP_OSD2_BLD_V_SCOPE                       0x1df8
+#define VPP_WRBAK_CTRL                             0x1df9
+#define VPP_SLEEP_CTRL                             0x1dfa
+#define VD1_BLEND_SRC_CTRL                         0x1dfb
+#define VD2_BLEND_SRC_CTRL                         0x1dfc
+#define OSD1_BLEND_SRC_CTRL                        0x1dfd
+#define OSD2_BLEND_SRC_CTRL                        0x1dfe
+
+#define VIU_OSD_BLEND_CTRL                         0x39b0
+#define VIU_OSD_BLEND_CTRL1                        0x39c0
+#define VIU_OSD_BLEND_DIN0_SCOPE_H                 0x39b1
+#define VIU_OSD_BLEND_DIN0_SCOPE_V                 0x39b2
+#define VIU_OSD_BLEND_DIN1_SCOPE_H                 0x39b3
+#define VIU_OSD_BLEND_DIN1_SCOPE_V                 0x39b4
+#define VIU_OSD_BLEND_DIN2_SCOPE_H                 0x39b5
+#define VIU_OSD_BLEND_DIN2_SCOPE_V                 0x39b6
+#define VIU_OSD_BLEND_DIN3_SCOPE_H                 0x39b7
+#define VIU_OSD_BLEND_DIN3_SCOPE_V                 0x39b8
+#define VIU_OSD_BLEND_DUMMY_DATA0                  0x39b9
+#define VIU_OSD_BLEND_DUMMY_ALPHA                  0x39ba
+#define VIU_OSD_BLEND_BLEND0_SIZE                  0x39bb
+#define VIU_OSD_BLEND_BLEND1_SIZE                  0x39bc
+#define VIU_OSD_BLEND_RO_CURRENT_XY                0x39bf
+#define VPP_POST_BLEND_BLEND_DUMMY_DATA            0x3968
+#define VPP_POST_BLEND_DUMMY_ALPHA                 0x3969
+
+
+#define VPP_POST2_MATRIX_COEF00_01                 0x39a0
+#define VPP_POST2_MATRIX_COEF02_10                 0x39a1
+#define VPP_POST2_MATRIX_COEF11_12                 0x39a2
+#define VPP_POST2_MATRIX_COEF20_21                 0x39a3
+#define VPP_POST2_MATRIX_COEF22                    0x39a4
+#define VPP_POST2_MATRIX_COEF13_14                 0x39a5
+#define VPP_POST2_MATRIX_COEF23_24                 0x39a6
+#define VPP_POST2_MATRIX_COEF15_25                 0x39a7
+#define VPP_POST2_MATRIX_CLIP                      0x39a8
+#define VPP_POST2_MATRIX_OFFSET0_1                 0x39a9
+#define VPP_POST2_MATRIX_OFFSET2                   0x39aa
+#define VPP_POST2_MATRIX_PRE_OFFSET0_1             0x39ab
+#define VPP_POST2_MATRIX_PRE_OFFSET2               0x39ac
+#define VPP_POST2_MATRIX_EN_CTRL                   0x39ad
+
+#define VPP_WRAP_OSD1_MATRIX_COEF00_01             0x3d60
+#define VPP_WRAP_OSD1_MATRIX_COEF02_10             0x3d61
+#define VPP_WRAP_OSD1_MATRIX_COEF11_12             0x3d62
+#define VPP_WRAP_OSD1_MATRIX_COEF20_21             0x3d63
+#define VPP_WRAP_OSD1_MATRIX_COEF22                0x3d64
+#define VPP_WRAP_OSD1_MATRIX_COEF13_14             0x3d65
+#define VPP_WRAP_OSD1_MATRIX_COEF23_24             0x3d66
+#define VPP_WRAP_OSD1_MATRIX_COEF15_25             0x3d67
+#define VPP_WRAP_OSD1_MATRIX_CLIP                  0x3d68
+#define VPP_WRAP_OSD1_MATRIX_OFFSET0_1             0x3d69
+#define VPP_WRAP_OSD1_MATRIX_OFFSET2               0x3d6a
+#define VPP_WRAP_OSD1_MATRIX_PRE_OFFSET0_1         0x3d6b
+#define VPP_WRAP_OSD1_MATRIX_PRE_OFFSET2           0x3d6c
+#define VPP_WRAP_OSD1_MATRIX_EN_CTRL               0x3d6d
+
+#define VPP_WRAP_OSD2_MATRIX_COEF00_01             0x3d70
+#define VPP_WRAP_OSD2_MATRIX_COEF02_10             0x3d71
+#define VPP_WRAP_OSD2_MATRIX_COEF11_12             0x3d72
+#define VPP_WRAP_OSD2_MATRIX_COEF20_21             0x3d73
+#define VPP_WRAP_OSD2_MATRIX_COEF22                0x3d74
+#define VPP_WRAP_OSD2_MATRIX_COEF13_14             0x3d75
+#define VPP_WRAP_OSD2_MATRIX_COEF23_24             0x3d76
+#define VPP_WRAP_OSD2_MATRIX_COEF15_25             0x3d77
+#define VPP_WRAP_OSD2_MATRIX_CLIP                  0x3d78
+#define VPP_WRAP_OSD2_MATRIX_OFFSET0_1             0x3d79
+#define VPP_WRAP_OSD2_MATRIX_OFFSET2               0x3d7a
+#define VPP_WRAP_OSD2_MATRIX_PRE_OFFSET0_1         0x3d7b
+#define VPP_WRAP_OSD2_MATRIX_PRE_OFFSET2           0x3d7c
+#define VPP_WRAP_OSD2_MATRIX_EN_CTRL               0x3d7d
+
+#define VPP_WRAP_OSD3_MATRIX_COEF00_01             0x3db0
+#define VPP_WRAP_OSD3_MATRIX_COEF02_10             0x3db1
+#define VPP_WRAP_OSD3_MATRIX_COEF11_12             0x3db2
+#define VPP_WRAP_OSD3_MATRIX_COEF20_21             0x3db3
+#define VPP_WRAP_OSD3_MATRIX_COEF22                0x3db4
+#define VPP_WRAP_OSD3_MATRIX_COEF13_14             0x3db5
+#define VPP_WRAP_OSD3_MATRIX_COEF23_24             0x3db6
+#define VPP_WRAP_OSD3_MATRIX_COEF15_25             0x3db7
+#define VPP_WRAP_OSD3_MATRIX_CLIP                  0x3db8
+#define VPP_WRAP_OSD3_MATRIX_OFFSET0_1             0x3db9
+#define VPP_WRAP_OSD3_MATRIX_OFFSET2               0x3dba
+#define VPP_WRAP_OSD3_MATRIX_PRE_OFFSET0_1         0x3dbb
+#define VPP_WRAP_OSD3_MATRIX_PRE_OFFSET2           0x3dbc
+#define VPP_WRAP_OSD3_MATRIX_EN_CTRL               0x3dbd
+
+// Closing file:  mad_regs.h
+//
+//`define VPP2_VCBUS_BASE              8'h19
+//
+// Reading file:  vpp2_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPP2_VCBUS_BASE = 0x19
+// -----------------------------------------------
+//===========================================================================
+// Video postprocesing Registers
+//===========================================================================
+// dummy data used in the VPP preblend and scaler
+// Bit 23:16
+// Bit 15:8     CB
+// Bit 7:0      CR
+#define   VPP2_DUMMY_DATA                          (0x1900)
+#define P_VPP2_DUMMY_DATA                          (volatile unsigned int *)((0x1900  << 2) + 0xff900000)
+//input line length used in VPP
+#define   VPP2_LINE_IN_LENGTH                      (0x1901)
+#define P_VPP2_LINE_IN_LENGTH                      (volatile unsigned int *)((0x1901  << 2) + 0xff900000)
+//input Picture height used in VPP
+#define   VPP2_PIC_IN_HEIGHT                       (0x1902)
+#define P_VPP2_PIC_IN_HEIGHT                       (volatile unsigned int *)((0x1902  << 2) + 0xff900000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15    index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
+//Bit 14    1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 13    if true, vertical separated coef enable
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered
+//Bit 6:0   coef index
+#define   VPP2_SCALE_COEF_IDX                      (0x1903)
+#define P_VPP2_SCALE_COEF_IDX                      (volatile unsigned int *)((0x1903  << 2) + 0xff900000)
+//coefficients for vertical filter and horizontal filter
+#define   VPP2_SCALE_COEF                          (0x1904)
+#define P_VPP2_SCALE_COEF                          (volatile unsigned int *)((0x1904  << 2) + 0xff900000)
+//these following registers are the absolute line address pointer for output divided screen
+//The output divided screen is shown in the following:
+//
+//  --------------------------   <------ line zero
+//      .
+//      .
+//      .           region0        <---------- nonlinear region or nonscaling region
+//      .
+//  ---------------------------
+//  ---------------------------  <------ region1_startp
+//      .
+//      .           region1         <---------- nonlinear region
+//      .
+//      .
+//  ---------------------------
+//  ---------------------------  <------ region2_startp
+//      .
+//      .           region2         <---------- linear region
+//      .
+//      .
+//  ---------------------------
+//  ---------------------------  <------ region3_startp
+//      .
+//      .           region3         <---------- nonlinear region
+//      .
+//      .
+//  ---------------------------
+//  ---------------------------  <------ region4_startp
+//      .
+//      .           region4         <---------- nonlinear region or nonoscaling region
+//      .
+//      .
+//  ---------------------------  <------ region4_endp
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define   VPP2_VSC_REGION12_STARTP                 (0x1905)
+#define P_VPP2_VSC_REGION12_STARTP                 (volatile unsigned int *)((0x1905  << 2) + 0xff900000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define   VPP2_VSC_REGION34_STARTP                 (0x1906)
+#define P_VPP2_VSC_REGION34_STARTP                 (volatile unsigned int *)((0x1906  << 2) + 0xff900000)
+#define   VPP2_VSC_REGION4_ENDP                    (0x1907)
+#define P_VPP2_VSC_REGION4_ENDP                    (volatile unsigned int *)((0x1907  << 2) + 0xff900000)
+//vertical start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part
+//Bit 23:0  fraction part
+#define   VPP2_VSC_START_PHASE_STEP                (0x1908)
+#define P_VPP2_VSC_START_PHASE_STEP                (volatile unsigned int *)((0x1908  << 2) + 0xff900000)
+//vertical scaler region0 phase slope, Bit24 signed bit
+#define   VPP2_VSC_REGION0_PHASE_SLOPE             (0x1909)
+#define P_VPP2_VSC_REGION0_PHASE_SLOPE             (volatile unsigned int *)((0x1909  << 2) + 0xff900000)
+//vertical scaler region1 phase slope, Bit24 signed bit
+#define   VPP2_VSC_REGION1_PHASE_SLOPE             (0x190a)
+#define P_VPP2_VSC_REGION1_PHASE_SLOPE             (volatile unsigned int *)((0x190a  << 2) + 0xff900000)
+//vertical scaler region3 phase slope, Bit24 signed bit
+#define   VPP2_VSC_REGION3_PHASE_SLOPE             (0x190b)
+#define P_VPP2_VSC_REGION3_PHASE_SLOPE             (volatile unsigned int *)((0x190b  << 2) + 0xff900000)
+//vertical scaler region4 phase slope, Bit24 signed bit
+#define   VPP2_VSC_REGION4_PHASE_SLOPE             (0x190c)
+#define P_VPP2_VSC_REGION4_PHASE_SLOPE             (volatile unsigned int *)((0x190c  << 2) + 0xff900000)
+//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X,
+//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
+//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
+//Bit 16     0: progressive output, 1: interlace output
+//Bit 15     vertical scaler output line0 in advance or not for bottom field
+//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
+//Bit 11:8   vertical scaler initial receiving  number for bottom field
+//Bit 7      vertical scaler output line0 in advance or not for top field
+//Bit 6:5    vertical scaler initial repeat line0 number for top field
+//Bit 3:0    vertical scaler initial receiving  number for top field
+#define   VPP2_VSC_PHASE_CTRL                      (0x190d)
+#define P_VPP2_VSC_PHASE_CTRL                      (volatile unsigned int *)((0x190d  << 2) + 0xff900000)
+//Bit 31:16  vertical scaler field initial phase for bottom field
+//Bit 15:0  vertical scaler field initial phase for top field
+#define   VPP2_VSC_INI_PHASE                       (0x190e)
+#define P_VPP2_VSC_INI_PHASE                       (volatile unsigned int *)((0x190e  << 2) + 0xff900000)
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define   VPP2_HSC_REGION12_STARTP                 (0x1910)
+#define P_VPP2_HSC_REGION12_STARTP                 (volatile unsigned int *)((0x1910  << 2) + 0xff900000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define   VPP2_HSC_REGION34_STARTP                 (0x1911)
+#define P_VPP2_HSC_REGION34_STARTP                 (volatile unsigned int *)((0x1911  << 2) + 0xff900000)
+#define   VPP2_HSC_REGION4_ENDP                    (0x1912)
+#define P_VPP2_HSC_REGION4_ENDP                    (volatile unsigned int *)((0x1912  << 2) + 0xff900000)
+//horizontal start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part
+//Bit 23:0  fraction part
+#define   VPP2_HSC_START_PHASE_STEP                (0x1913)
+#define P_VPP2_HSC_START_PHASE_STEP                (volatile unsigned int *)((0x1913  << 2) + 0xff900000)
+//horizontal scaler region0 phase slope, Bit24 signed bit
+#define   VPP2_HSC_REGION0_PHASE_SLOPE             (0x1914)
+#define P_VPP2_HSC_REGION0_PHASE_SLOPE             (volatile unsigned int *)((0x1914  << 2) + 0xff900000)
+//horizontal scaler region1 phase slope, Bit24 signed bit
+#define   VPP2_HSC_REGION1_PHASE_SLOPE             (0x1915)
+#define P_VPP2_HSC_REGION1_PHASE_SLOPE             (volatile unsigned int *)((0x1915  << 2) + 0xff900000)
+//horizontal scaler region3 phase slope, Bit24 signed bit
+#define   VPP2_HSC_REGION3_PHASE_SLOPE             (0x1916)
+#define P_VPP2_HSC_REGION3_PHASE_SLOPE             (volatile unsigned int *)((0x1916  << 2) + 0xff900000)
+//horizontal scaler region4 phase slope, Bit24 signed bit
+#define   VPP2_HSC_REGION4_PHASE_SLOPE             (0x1917)
+#define P_VPP2_HSC_REGION4_PHASE_SLOPE             (volatile unsigned int *)((0x1917  << 2) + 0xff900000)
+//Bit 22:21   horizontal scaler initial repeat pixel0 number
+//Bit 19:16   horizontal scaler initial receiving number
+//Bit 15:0    horizontal scaler top field initial phase
+#define   VPP2_HSC_PHASE_CTRL                      (0x1918)
+#define P_VPP2_HSC_PHASE_CTRL                      (volatile unsigned int *)((0x1918  << 2) + 0xff900000)
+// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
+//                 just for special usage, more flexibility
+// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
+// Bit 20 prehsc_en
+// Bit 19 prevsc_en
+// Bit 18 vsc_en
+// Bit 17 hsc_en
+// Bit 16 scale_top_en
+// Bit 15 video1 scale out enable
+// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler
+// Bit 10:8 horizontal scaler bank length
+// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
+// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler
+// Bit 2:0 vertical scaler bank length
+#define   VPP2_SC_MISC                             (0x1919)
+#define P_VPP2_SC_MISC                             (volatile unsigned int *)((0x1919  << 2) + 0xff900000)
+// preblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_PREBLEND_VD1_H_START_END            (0x191a)
+#define P_VPP2_PREBLEND_VD1_H_START_END            (volatile unsigned int *)((0x191a  << 2) + 0xff900000)
+// preblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_PREBLEND_VD1_V_START_END            (0x191b)
+#define P_VPP2_PREBLEND_VD1_V_START_END            (volatile unsigned int *)((0x191b  << 2) + 0xff900000)
+// postblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_POSTBLEND_VD1_H_START_END           (0x191c)
+#define P_VPP2_POSTBLEND_VD1_H_START_END           (volatile unsigned int *)((0x191c  << 2) + 0xff900000)
+// postblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_POSTBLEND_VD1_V_START_END           (0x191d)
+#define P_VPP2_POSTBLEND_VD1_V_START_END           (volatile unsigned int *)((0x191d  << 2) + 0xff900000)
+// preblend horizontal size
+#define   VPP2_PREBLEND_H_SIZE                     (0x1920)
+#define P_VPP2_PREBLEND_H_SIZE                     (volatile unsigned int *)((0x1920  << 2) + 0xff900000)
+// postblend horizontal size
+#define   VPP2_POSTBLEND_H_SIZE                    (0x1921)
+#define P_VPP2_POSTBLEND_H_SIZE                    (volatile unsigned int *)((0x1921  << 2) + 0xff900000)
+//VPP hold lines
+//Bit 29:24
+//Bit 21:16
+//Bit 15:8     preblend hold lines
+//Bit 7:0      postblend hold lines
+#define   VPP2_HOLD_LINES                          (0x1922)
+#define P_VPP2_HOLD_LINES                          (volatile unsigned int *)((0x1922  << 2) + 0xff900000)
+//Bit 25   if true, change screen to one color value for preblender
+//Bit 24   if true, change screen to one color value for postblender
+// Bit 23:16 one color Y
+// Bit 15:8 one color Cb
+// Bit  7:0 one color  Cr
+#define   VPP2_BLEND_ONECOLOR_CTRL                 (0x1923)
+#define P_VPP2_BLEND_ONECOLOR_CTRL                 (volatile unsigned int *)((0x1923  << 2) + 0xff900000)
+//Read Only, VPP preblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define   VPP2_PREBLEND_CURRENT_XY                 (0x1924)
+#define P_VPP2_PREBLEND_CURRENT_XY                 (volatile unsigned int *)((0x1924  << 2) + 0xff900000)
+//Read Only, VPP postblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define   VPP2_POSTBLEND_CURRENT_XY                (0x1925)
+#define P_VPP2_POSTBLEND_CURRENT_XY                (volatile unsigned int *)((0x1925  << 2) + 0xff900000)
+// Bit 31  vd1_bgosd_exchange_en for preblend
+// Bit 30  vd1_bgosd_exchange_en for postblend
+// bit 28   color management enable
+// Bit 27,  reserved
+// Bit 26:18, reserved
+// Bit 17, osd2 enable for preblend
+// Bit 16, osd1 enable for preblend
+// Bit 15, reserved
+// Bit 14, vd1 enable for preblend
+// Bit 13, osd2 enable for postblend
+// Bit 12, osd1 enable for postblend
+// Bit 11, reserved
+// Bit 10, vd1 enable for postblend
+// Bit 9,  if true, osd1 is alpha premultipiled
+// Bit 8,  if true, osd2 is alpha premultipiled
+// Bit 7,  postblend module enable
+// Bit 6,  preblend module enable
+// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
+// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
+// Bit 3,
+// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
+//           the aync fifo will be reseted.
+// Bit 1,
+// Bit 0    if true, the output result of VPP is saturated
+#define   VPP2_MISC                                (0x1926)
+#define P_VPP2_MISC                                (volatile unsigned int *)((0x1926  << 2) + 0xff900000)
+//Bit 31:20 ofifo line length minus 1
+//Bit 19  if true invert input vs
+//Bit 18  if true invert input hs
+//Bit 17  force top/bottom field, enable
+//Bit 16  force top/bottom field, 0: top, 1: bottom
+//Bit 15  force one go_field, one pluse, write only
+//Bit 14  force one go_line, one pluse, write only
+//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
+#define   VPP2_OFIFO_SIZE                          (0x1927)
+#define P_VPP2_OFIFO_SIZE                          (volatile unsigned int *)((0x1927  << 2) + 0xff900000)
+//Read only
+//Bit 28:17 current scale out fifo counter
+//Bit 16:12 current afifo counter
+//Bit 11:0 current ofifo counter
+#define   VPP2_FIFO_STATUS                         (0x1928)
+#define P_VPP2_FIFO_STATUS                         (volatile unsigned int *)((0x1928  << 2) + 0xff900000)
+// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable
+// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable
+// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable
+// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable
+#define   VPP2_SMOKE_CTRL                          (0x1929)
+#define P_VPP2_SMOKE_CTRL                          (volatile unsigned int *)((0x1929  << 2) + 0xff900000)
+//smoke can be used only when that blending is disable and then be used as smoke function
+//smoke1 for OSD1 chanel
+//smoke2 for OSD2 chanel
+//31:24 Y
+//23:16 Cb
+//15:8 Cr
+//7:0 Alpha
+#define   VPP2_SMOKE1_VAL                          (0x192a)
+#define P_VPP2_SMOKE1_VAL                          (volatile unsigned int *)((0x192a  << 2) + 0xff900000)
+#define   VPP2_SMOKE2_VAL                          (0x192b)
+#define P_VPP2_SMOKE2_VAL                          (volatile unsigned int *)((0x192b  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_SMOKE1_H_START_END                  (0x192d)
+#define P_VPP2_SMOKE1_H_START_END                  (volatile unsigned int *)((0x192d  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_SMOKE1_V_START_END                  (0x192e)
+#define P_VPP2_SMOKE1_V_START_END                  (volatile unsigned int *)((0x192e  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_SMOKE2_H_START_END                  (0x192f)
+#define P_VPP2_SMOKE2_H_START_END                  (volatile unsigned int *)((0x192f  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP2_SMOKE2_V_START_END                  (0x1930)
+#define P_VPP2_SMOKE2_V_START_END                  (volatile unsigned int *)((0x1930  << 2) + 0xff900000)
+//Bit 27:16 scale out fifo line length minus 1
+//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
+#define   VPP2_SCO_FIFO_CTRL                       (0x1933)
+#define P_VPP2_SCO_FIFO_CTRL                       (volatile unsigned int *)((0x1933  << 2) + 0xff900000)
+//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
+//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
+//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
+//Bit 23 horizontal scaler double pixel mode
+//Bit 22:21   horizontal scaler initial repeat pixel0 number1
+//Bit 19:16   horizontal scaler initial receiving number1
+//Bit 15:0    horizontal scaler top field initial phase1
+#define   VPP2_HSC_PHASE_CTRL1                     (0x1934)
+#define P_VPP2_HSC_PHASE_CTRL1                     (volatile unsigned int *)((0x1934  << 2) + 0xff900000)
+//for 3D quincunx sub-sampling
+//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
+//22:20  prehsc pattern start
+//18:16 prehsc pattern end
+//15:8 pattern, each patten 1 bit, from lsb -> msb
+//6:4  pattern start
+//2:0  pattern end
+#define   VPP2_HSC_INI_PAT_CTRL                    (0x1935)
+#define P_VPP2_HSC_INI_PAT_CTRL                    (volatile unsigned int *)((0x1935  << 2) + 0xff900000)
+//Bit 3         minus black level enable for vadj2
+//Bit 2         Video adjustment enable for vadj2
+//Bit 1         minus black level enable for vadj1
+//Bit 0         Video adjustment enable for vadj1
+#define   VPP2_VADJ_CTRL                           (0x1940)
+#define P_VPP2_VADJ_CTRL                           (volatile unsigned int *)((0x1940  << 2) + 0xff900000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
+#define   VPP2_VADJ1_Y                             (0x1941)
+#define P_VPP2_VADJ1_Y                             (volatile unsigned int *)((0x1941  << 2) + 0xff900000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define   VPP2_VADJ1_MA_MB                         (0x1942)
+#define P_VPP2_VADJ1_MA_MB                         (volatile unsigned int *)((0x1942  << 2) + 0xff900000)
+#define   VPP2_VADJ1_MC_MD                         (0x1943)
+#define P_VPP2_VADJ1_MC_MD                         (volatile unsigned int *)((0x1943  << 2) + 0xff900000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
+#define   VPP2_VADJ2_Y                             (0x1944)
+#define P_VPP2_VADJ2_Y                             (volatile unsigned int *)((0x1944  << 2) + 0xff900000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define   VPP2_VADJ2_MA_MB                         (0x1945)
+#define P_VPP2_VADJ2_MA_MB                         (volatile unsigned int *)((0x1945  << 2) + 0xff900000)
+#define   VPP2_VADJ2_MC_MD                         (0x1946)
+#define P_VPP2_VADJ2_MC_MD                         (volatile unsigned int *)((0x1946  << 2) + 0xff900000)
+//Read only
+//Bit 31, if it is true, it means this probe is valid in the last field/frame
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define   VPP2_MATRIX_PROBE_COLOR                  (0x195c)
+#define P_VPP2_MATRIX_PROBE_COLOR                  (volatile unsigned int *)((0x195c  << 2) + 0xff900000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define   VPP2_MATRIX_HL_COLOR                     (0x195d)
+#define P_VPP2_MATRIX_HL_COLOR                     (volatile unsigned int *)((0x195d  << 2) + 0xff900000)
+//28:16 probe x, postion
+//12:0  probe y, position
+#define   VPP2_MATRIX_PROBE_POS                    (0x195e)
+#define P_VPP2_MATRIX_PROBE_POS                    (volatile unsigned int *)((0x195e  << 2) + 0xff900000)
+//Bit 16,  highlight_en
+//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix,
+//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix
+//Bit 5    vd1 conversion matrix enable
+//Bit 4    reserved
+//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 0    post conversion matrix enable
+#define   VPP2_MATRIX_CTRL                         (0x195f)
+#define P_VPP2_MATRIX_CTRL                         (volatile unsigned int *)((0x195f  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VPP2_MATRIX_COEF00_01                    (0x1960)
+#define P_VPP2_MATRIX_COEF00_01                    (volatile unsigned int *)((0x1960  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VPP2_MATRIX_COEF02_10                    (0x1961)
+#define P_VPP2_MATRIX_COEF02_10                    (volatile unsigned int *)((0x1961  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VPP2_MATRIX_COEF11_12                    (0x1962)
+#define P_VPP2_MATRIX_COEF11_12                    (volatile unsigned int *)((0x1962  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VPP2_MATRIX_COEF20_21                    (0x1963)
+#define P_VPP2_MATRIX_COEF20_21                    (volatile unsigned int *)((0x1963  << 2) + 0xff900000)
+#define   VPP2_MATRIX_COEF22                       (0x1964)
+#define P_VPP2_MATRIX_COEF22                       (volatile unsigned int *)((0x1964  << 2) + 0xff900000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define   VPP2_MATRIX_OFFSET0_1                    (0x1965)
+#define P_VPP2_MATRIX_OFFSET0_1                    (volatile unsigned int *)((0x1965  << 2) + 0xff900000)
+//Bit 10:0  offset2
+#define   VPP2_MATRIX_OFFSET2                      (0x1966)
+#define P_VPP2_MATRIX_OFFSET2                      (volatile unsigned int *)((0x1966  << 2) + 0xff900000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define   VPP2_MATRIX_PRE_OFFSET0_1                (0x1967)
+#define P_VPP2_MATRIX_PRE_OFFSET0_1                (volatile unsigned int *)((0x1967  << 2) + 0xff900000)
+//Bit 10:0  pre_offset2
+#define   VPP2_MATRIX_PRE_OFFSET2                  (0x1968)
+#define P_VPP2_MATRIX_PRE_OFFSET2                  (volatile unsigned int *)((0x1968  << 2) + 0xff900000)
+// dummy data used in the VPP postblend
+// Bit 23:16    Y
+// Bit 15:8     CB
+// Bit 7:0      CR
+#define   VPP2_DUMMY_DATA1                         (0x1969)
+#define P_VPP2_DUMMY_DATA1                         (volatile unsigned int *)((0x1969  << 2) + 0xff900000)
+//Bit 31 gainoff module enable
+//Bit 26:16 gain0, 1.10 unsigned data
+//Bit 10:0  gain1, 1.10 unsigned dat
+#define   VPP2_GAINOFF_CTRL0                       (0x196a)
+#define P_VPP2_GAINOFF_CTRL0                       (volatile unsigned int *)((0x196a  << 2) + 0xff900000)
+//Bit 26:16 gain2, 1.10 unsigned data
+//Bit 10:0, offset0, signed data
+#define   VPP2_GAINOFF_CTRL1                       (0x196b)
+#define P_VPP2_GAINOFF_CTRL1                       (volatile unsigned int *)((0x196b  << 2) + 0xff900000)
+//Bit 26:16, offset1, signed data
+//Bit 10:0, offset2, signed data
+#define   VPP2_GAINOFF_CTRL2                       (0x196c)
+#define P_VPP2_GAINOFF_CTRL2                       (volatile unsigned int *)((0x196c  << 2) + 0xff900000)
+//Bit 26:16, pre_offset0, signed data
+//Bit 10:0, pre_offset1, signed data
+#define   VPP2_GAINOFF_CTRL3                       (0x196d)
+#define P_VPP2_GAINOFF_CTRL3                       (volatile unsigned int *)((0x196d  << 2) + 0xff900000)
+//Bit 10:0, pre_offset2, signed data
+#define   VPP2_GAINOFF_CTRL4                       (0x196e)
+#define P_VPP2_GAINOFF_CTRL4                       (volatile unsigned int *)((0x196e  << 2) + 0xff900000)
+//only two registers used in the color management, which are defined in the chroma_reg.h
+#define   VPP2_CHROMA_ADDR_PORT                    (0x1970)
+#define P_VPP2_CHROMA_ADDR_PORT                    (volatile unsigned int *)((0x1970  << 2) + 0xff900000)
+#define   VPP2_CHROMA_DATA_PORT                    (0x1971)
+#define P_VPP2_CHROMA_DATA_PORT                    (volatile unsigned int *)((0x1971  << 2) + 0xff900000)
+//`include "chroma_reg.h"       //defined inside is the indirect addressed registers
+//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
+//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock
+//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again
+//because the register itself canot be set again without clk
+//Bit 31:0
+#define   VPP2_GCLK_CTRL0                          (0x1972)
+#define P_VPP2_GCLK_CTRL0                          (volatile unsigned int *)((0x1972  << 2) + 0xff900000)
+//Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
+//Bit 9:0
+#define   VPP2_GCLK_CTRL1                          (0x1973)
+#define P_VPP2_GCLK_CTRL1                          (volatile unsigned int *)((0x1973  << 2) + 0xff900000)
+//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
+//Bit 11:0
+#define   VPP2_SC_GCLK_CTRL                        (0x1974)
+#define P_VPP2_SC_GCLK_CTRL                        (volatile unsigned int *)((0x1974  << 2) + 0xff900000)
+//Bit 17:9 VD1 alpha for preblend
+//Bit 8:0 VD1 alpha for postblend
+#define   VPP2_MISC1                               (0x1976)
+#define P_VPP2_MISC1                               (volatile unsigned int *)((0x1976  << 2) + 0xff900000)
+//Bit 31:24     bottom of region03 output value
+//Bit 23:16     bottom of region02 output value
+//Bit 15:8      bottom of region01 output value
+//Bit 7:0       bottom of region00 output value
+#define   VPP2_DNLP_CTRL_00                        (0x1981)
+#define P_VPP2_DNLP_CTRL_00                        (volatile unsigned int *)((0x1981  << 2) + 0xff900000)
+//Bit 31:24     bottom of region07 output value
+//Bit 23:16     bottom of region06 output value
+//Bit 15:8      bottom of region05 output value
+//Bit 7:0       bottom of region04 output value
+#define   VPP2_DNLP_CTRL_01                        (0x1982)
+#define P_VPP2_DNLP_CTRL_01                        (volatile unsigned int *)((0x1982  << 2) + 0xff900000)
+//Bit 31:24     bottom of region11 output value
+//Bit 23:16     bottom of region10 output value
+//Bit 15:8      bottom of region09 output value
+//Bit 7:0       bottom of region08 output value
+#define   VPP2_DNLP_CTRL_02                        (0x1983)
+#define P_VPP2_DNLP_CTRL_02                        (volatile unsigned int *)((0x1983  << 2) + 0xff900000)
+//Bit 31:24     bottom of region15 output value
+//Bit 23:16     bottom of region14 output value
+//Bit 15:8      bottom of region13 output value
+//Bit 7:0       bottom of region12 output value
+#define   VPP2_DNLP_CTRL_03                        (0x1984)
+#define P_VPP2_DNLP_CTRL_03                        (volatile unsigned int *)((0x1984  << 2) + 0xff900000)
+//Bit 31:24     bottom of region19 output value
+//Bit 23:16     bottom of region18 output value
+//Bit 15:8      bottom of region17 output value
+//Bit 7:0       bottom of region16 output value
+#define   VPP2_DNLP_CTRL_04                        (0x1985)
+#define P_VPP2_DNLP_CTRL_04                        (volatile unsigned int *)((0x1985  << 2) + 0xff900000)
+//Bit 31:24     bottom of region23 output value
+//Bit 23:16     bottom of region22 output value
+//Bit 15:8      bottom of region21 output value
+//Bit 7:0       bottom of region20 output value
+#define   VPP2_DNLP_CTRL_05                        (0x1986)
+#define P_VPP2_DNLP_CTRL_05                        (volatile unsigned int *)((0x1986  << 2) + 0xff900000)
+//Bit 31:24     bottom of region27 output value
+//Bit 23:16     bottom of region26 output value
+//Bit 15:8      bottom of region25 output value
+//Bit 7:0       bottom of region24 output value
+#define   VPP2_DNLP_CTRL_06                        (0x1987)
+#define P_VPP2_DNLP_CTRL_06                        (volatile unsigned int *)((0x1987  << 2) + 0xff900000)
+//Bit 31:24     bottom of region31 output value
+//Bit 23:16     bottom of region30 output value
+//Bit 15:8      bottom of region29 output value
+//Bit 7:0       bottom of region28 output value
+#define   VPP2_DNLP_CTRL_07                        (0x1988)
+#define P_VPP2_DNLP_CTRL_07                        (volatile unsigned int *)((0x1988  << 2) + 0xff900000)
+//Bit 31:24     bottom of region35 output value
+//Bit 23:16     bottom of region34 output value
+//Bit 15:8      bottom of region33 output value
+//Bit 7:0       bottom of region32 output value
+#define   VPP2_DNLP_CTRL_08                        (0x1989)
+#define P_VPP2_DNLP_CTRL_08                        (volatile unsigned int *)((0x1989  << 2) + 0xff900000)
+//Bit 31:24     bottom of region39 output value
+//Bit 23:16     bottom of region38 output value
+//Bit 15:8      bottom of region37 output value
+//Bit 7:0       bottom of region36 output value
+#define   VPP2_DNLP_CTRL_09                        (0x198a)
+#define P_VPP2_DNLP_CTRL_09                        (volatile unsigned int *)((0x198a  << 2) + 0xff900000)
+//Bit 31:24     bottom of region43 output value
+//Bit 23:16     bottom of region42 output value
+//Bit 15:8      bottom of region41 output value
+//Bit 7:0       bottom of region40 output value
+#define   VPP2_DNLP_CTRL_10                        (0x198b)
+#define P_VPP2_DNLP_CTRL_10                        (volatile unsigned int *)((0x198b  << 2) + 0xff900000)
+//Bit 31:24     bottom of region47 output value
+//Bit 23:16     bottom of region46 output value
+//Bit 15:8      bottom of region45 output value
+//Bit 7:0       bottom of region44 output value
+#define   VPP2_DNLP_CTRL_11                        (0x198c)
+#define P_VPP2_DNLP_CTRL_11                        (volatile unsigned int *)((0x198c  << 2) + 0xff900000)
+//Bit 31:24     bottom of region51 output value
+//Bit 23:16     bottom of region50 output value
+//Bit 15:8      bottom of region49 output value
+//Bit 7:0       bottom of region48 output value
+#define   VPP2_DNLP_CTRL_12                        (0x198d)
+#define P_VPP2_DNLP_CTRL_12                        (volatile unsigned int *)((0x198d  << 2) + 0xff900000)
+//Bit 31:24     bottom of region55 output value
+//Bit 23:16     bottom of region54 output value
+//Bit 15:8      bottom of region53 output value
+//Bit 7:0       bottom of region52 output value
+#define   VPP2_DNLP_CTRL_13                        (0x198e)
+#define P_VPP2_DNLP_CTRL_13                        (volatile unsigned int *)((0x198e  << 2) + 0xff900000)
+//Bit 31:24     bottom of region59 output value
+//Bit 23:16     bottom of region58 output value
+//Bit 15:8      bottom of region57 output value
+//Bit 7:0       bottom of region56 output value
+#define   VPP2_DNLP_CTRL_14                        (0x198f)
+#define P_VPP2_DNLP_CTRL_14                        (volatile unsigned int *)((0x198f  << 2) + 0xff900000)
+//Bit 31:24     bottom of region63 output value
+//Bit 23:16     bottom of region62 output value
+//Bit 15:8      bottom of region61 output value
+//Bit 7:0       bottom of region60 output value
+#define   VPP2_DNLP_CTRL_15                        (0x1990)
+#define P_VPP2_DNLP_CTRL_15                        (volatile unsigned int *)((0x1990  << 2) + 0xff900000)
+//Bit 20 reserved
+//Bit 19 reserved
+//Bit 18 demo dynamic nonlinear luma processing enable
+//Bit 17 reserved
+//Bit 16 reserved
+//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
+//Bit 4 reserved
+//Bit 3 reserved
+//Bit 2 dynamic nonlinear luma processing enable
+//Bit 1 reserved
+//Bit 0 reserved
+#define   VPP2_VE_ENABLE_CTRL                      (0x19a1)
+#define P_VPP2_VE_ENABLE_CTRL                      (volatile unsigned int *)((0x19a1  << 2) + 0xff900000)
+//Bit 12:0, demo left or top screen width
+#define   VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH       (0x19a2)
+#define P_VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH       (volatile unsigned int *)((0x19a2  << 2) + 0xff900000)
+#define   VPP2_VE_DEMO_CENTER_BAR                  (0x19a3)
+#define P_VPP2_VE_DEMO_CENTER_BAR                  (volatile unsigned int *)((0x19a3  << 2) + 0xff900000)
+//28:16  ve_line_length
+//12:0   ve_pic_height
+#define   VPP2_VE_H_V_SIZE                         (0x19a4)
+#define P_VPP2_VE_H_V_SIZE                         (volatile unsigned int *)((0x19a4  << 2) + 0xff900000)
+//Bit 10   reset bit, high active
+//Bit 9    0: measuring rising edge, 1: measuring falling edge
+//Bit 8    if true, accumulate the counter number, otherwise not
+//Bit 7:0  vsync_span, define how many vsync span need to measure
+#define   VPP2_VDO_MEAS_CTRL                       (0x19a8)
+#define P_VPP2_VDO_MEAS_CTRL                       (volatile unsigned int *)((0x19a8  << 2) + 0xff900000)
+//Read only
+//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
+//15:0, high bit portion of counter
+#define   VPP2_VDO_MEAS_VS_COUNT_HI                (0x19a9)
+#define P_VPP2_VDO_MEAS_VS_COUNT_HI                (volatile unsigned int *)((0x19a9  << 2) + 0xff900000)
+//Read only
+//31:0, low bit portion of counter
+#define   VPP2_VDO_MEAS_VS_COUNT_LO                (0x19aa)
+#define P_VPP2_VDO_MEAS_VS_COUNT_LO                (volatile unsigned int *)((0x19aa  << 2) + 0xff900000)
+//vertical scaler phase step
+//Bit 27:0,  4.24 format
+#define   VPP2_OSD_VSC_PHASE_STEP                  (0x19c0)
+#define P_VPP2_OSD_VSC_PHASE_STEP                  (volatile unsigned int *)((0x19c0  << 2) + 0xff900000)
+//Bit 31:16, botttom vertical scaler initial phase
+//Bit 15:0, top vertical scaler initial phase
+#define   VPP2_OSD_VSC_INI_PHASE                   (0x19c1)
+#define P_VPP2_OSD_VSC_INI_PHASE                   (volatile unsigned int *)((0x19c1  << 2) + 0xff900000)
+//Bit 24    osd vertical Scaler enable
+//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
+//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
+//Bit 20    osd_vsc_phase0_always_en
+//Bit 19    osd_vsc_nearest_en
+//Bit 17:16 osd_vsc_bot_rpt_l0_num
+//Bit 14:11 osd_vsc_bot_ini_rcv_num
+//Bit 9:8   osd_vsc_top_rpt_l0_num
+//Bit 6:3   osd_vsc_top_ini_rcv_num
+//Bit 2:0   osd_vsc_bank_length
+#define   VPP2_OSD_VSC_CTRL0                       (0x19c2)
+#define P_VPP2_OSD_VSC_CTRL0                       (volatile unsigned int *)((0x19c2  << 2) + 0xff900000)
+//horizontal scaler phase step
+//Bit 27:0,  4.24 format
+#define   VPP2_OSD_HSC_PHASE_STEP                  (0x19c3)
+#define P_VPP2_OSD_HSC_PHASE_STEP                  (volatile unsigned int *)((0x19c3  << 2) + 0xff900000)
+//Bit 31:16, horizontal scaler initial phase1
+//Bit 15:0, horizontal scaler initial phase0
+#define   VPP2_OSD_HSC_INI_PHASE                   (0x19c4)
+#define P_VPP2_OSD_HSC_INI_PHASE                   (volatile unsigned int *)((0x19c4  << 2) + 0xff900000)
+//Bit 22   osd horizontal scaler enable
+//Bit 21   osd_hsc_double_pix_mode
+//Bit 20   osd_hsc_phase0_always_en
+//Bit 19   osd_hsc_nearest_en
+//Bit 17:16 osd_hsc_rpt_p0_num1
+//Bit 14:11 osd_hsc_ini_rcv_num1
+//Bit 9:8   osd_hsc_rpt_p0_num0
+//Bit 6:3   osd_hsc_ini_rcv_num0
+//Bit 2:0   osd_hsc_bank_length
+#define   VPP2_OSD_HSC_CTRL0                       (0x19c5)
+#define P_VPP2_OSD_HSC_CTRL0                       (volatile unsigned int *)((0x19c5  << 2) + 0xff900000)
+//for 3D quincunx sub-sampling
+//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
+//bit 6:4  pattern start
+//bit 2:0  pattern end
+#define   VPP2_OSD_HSC_INI_PAT_CTRL                (0x19c6)
+#define P_VPP2_OSD_HSC_INI_PAT_CTRL                (volatile unsigned int *)((0x19c6  << 2) + 0xff900000)
+//bit 31:24, componet 0
+//bit 23:16, component 1
+//bit 15:8, component 2
+//bit 7:0 component 3, alpha
+#define   VPP2_OSD_SC_DUMMY_DATA                   (0x19c7)
+#define P_VPP2_OSD_SC_DUMMY_DATA                   (volatile unsigned int *)((0x19c7  << 2) + 0xff900000)
+//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
+//Bit 3 osd scaler path enable
+//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
+#define   VPP2_OSD_SC_CTRL0                        (0x19c8)
+#define P_VPP2_OSD_SC_CTRL0                        (volatile unsigned int *)((0x19c8  << 2) + 0xff900000)
+//Bit 28:16 OSD scaler input width minus 1
+//Bit 12:0 OSD scaler input height minus 1
+#define   VPP2_OSD_SCI_WH_M1                       (0x19c9)
+#define P_VPP2_OSD_SCI_WH_M1                       (volatile unsigned int *)((0x19c9  << 2) + 0xff900000)
+//Bit 28:16 OSD scaler output horizontal start
+//Bit 12:0 OSD scaler output horizontal end
+#define   VPP2_OSD_SCO_H_START_END                 (0x19ca)
+#define P_VPP2_OSD_SCO_H_START_END                 (volatile unsigned int *)((0x19ca  << 2) + 0xff900000)
+//Bit 28:16 OSD scaler output vertical start
+//Bit 12:0 OSD scaler output vertical end
+#define   VPP2_OSD_SCO_V_START_END                 (0x19cb)
+#define P_VPP2_OSD_SCO_V_START_END                 (volatile unsigned int *)((0x19cb  << 2) + 0xff900000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
+//Bit 6:0 	coef index
+#define   VPP2_OSD_SCALE_COEF_IDX                  (0x19cc)
+#define P_VPP2_OSD_SCALE_COEF_IDX                  (volatile unsigned int *)((0x19cc  << 2) + 0xff900000)
+//coefficients for vertical filter and horizontal filter
+#define   VPP2_OSD_SCALE_COEF                      (0x19cd)
+#define P_VPP2_OSD_SCALE_COEF                      (volatile unsigned int *)((0x19cd  << 2) + 0xff900000)
+//Bit 12:0 line number use to generate interrupt when line == this number
+#define   VPP2_INT_LINE_NUM                        (0x19ce)
+#define P_VPP2_INT_LINE_NUM                        (volatile unsigned int *)((0x19ce  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpp2_regs.h
+//
+//`define VIU_VCBUS_BASE                8'h1a
+//
+// Reading file:  vregs_clk2.h
+//
+//===========================================================================
+// Video Interface Registers    0xa00 - 0xaff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VIU_VCBUS_BASE = 0x1a
+// -----------------------------------------------
+#define   VIU_ADDR_START                           (0x1a00)
+#define P_VIU_ADDR_START                           (volatile unsigned int *)((0x1a00  << 2) + 0xff900000)
+#define   VIU_ADDR_END                             (0x1aff)
+#define P_VIU_ADDR_END                             (volatile unsigned int *)((0x1aff  << 2) + 0xff900000)
+//`define TRACE_REG 8'ff
+//------------------------------------------------------------------------------
+// VIU top-level registers
+//------------------------------------------------------------------------------
+// Bit  0 RW, osd1_reset
+// Bit  1 RW, osd2_reset
+// Bit  2 RW, vd1_reset
+// Bit  3 RW, vd1_fmt_reset
+// Bit  4 RW, vd2_reset
+// Bit  5 RW, vd2_fmt_reset
+// Bit  6 RW, di_dsr1to2_reset
+// Bit  7 RW, vpp_reset
+// Bit  8 RW, di_if1_reset
+// Bit  9 RW, di_if1_fmt_reset
+// Bit 10 RW, di_inp_reset
+// Bit 11 RW, di_inp_fmt_reset
+// Bit 12 RW, di_mem_reset
+// Bit 13 RW, di_mem_fmt_reset
+// Bit 14 RW, di_nr_wr_mif_reset
+// Bit 15 RW, dein_wr_mif_reset
+// Bit 16 RW, di_chan2_mif_reset
+// Bit 17 RW, di_mtn_wr_mif_reset
+// Bit 18 RW, di_mtn_rd_mif_reset
+// Bit 19 RW, di_mad_reset
+// Bit 20 RW, vdin0_reset
+// Bit 21 RW, vdin1_reset
+// Bit 22 RW, nrin_mux_reset
+// Bit 23 RW, vdin0_wr_reset
+// Bit 24 RW, vdin1_wr_reset
+// Bit 25 RW, reserved
+// Bit 26 RW, d2d3_reset
+// Bit 27 RW, di_cont_wr_mif_reset
+// Bit 28 RW, di_cont_rd_mif_reset
+#define   VIU_SW_RESET                             (0x1a01)
+#define P_VIU_SW_RESET                             (volatile unsigned int *)((0x1a01  << 2) + 0xff900000)
+#define   VIU_SW_RESET0                            (0x1a02)
+#define P_VIU_SW_RESET0                            (volatile unsigned int *)((0x1a02  << 2) + 0xff900000)
+// Bit 0 RW, software reset for mcvecrd_mif
+// Bit 1 RW, software reset for mcinfowr_mif
+// Bit 2 RW, software reset for mcinford_mif
+#define   VIU_SECURE_REG                           (0x1a04)
+#define P_VIU_SECURE_REG                           (volatile unsigned int *)((0x1a04  << 2) + 0xff900000)
+// Bit 0 RW, dolby core1_tv secure w and r
+// Bit 1 RW, dolby core2 secure w and r
+// Bit 2 RW, dolby core3 secure w and r
+// Bit 3 RW, for osd1 secure read
+// Bit 4 RW, for osd2 secure read
+#define   DOLBY_INT_STAT                           (0x1a05)
+#define P_DOLBY_INT_STAT                           (volatile unsigned int *)((0x1a05  << 2) + 0xff900000)
+// todo
+//bit 15:12 osdbld_gclk_ctrl 3:2 regclk ctrl 1:0 blending clk control
+//bit 8 if true, vsync interrup is generate only field == 0
+//bit 7:0 fix_disable
+#define   VIU_MISC_CTRL0                           (0x1a06)
+#define P_VIU_MISC_CTRL0                           (volatile unsigned int *)((0x1a06  << 2) + 0xff900000)
+#define   VIU_MISC_CTRL1                           (0x1a07)
+#define P_VIU_MISC_CTRL1                           (volatile unsigned int *)((0x1a07  << 2) + 0xff900000)
+// Bit 15:14  mali_afbcd_gclk_ctrl      mali_afbcd clock gate control[5:4]
+// Bit 12     osd1_afbcd_axi_mux        0 : use the osd mif as input; 1 : use afbcd as input
+// Bit 11:8   mali_afbcd_gclk_ctrl      mali_afbcd clock gate control[3:0]
+// Bit  7:2   vd2_afbcd_gclk_ctrl       vd2_afbcd clock gate control
+// Bit  1     vpp_vd2_din_sel           0: vpp vd2 sel the mif input; 1: vpp vd2 sel the dos afbcd
+// Bit  0     vd2_afbcd_out_sel         0: vd2_afbcd output to vpp; 1 : vd2_afbcd output to di inp
+#define   D2D3_INTF_LENGTH                         (0x1a08)
+#define P_D2D3_INTF_LENGTH                         (volatile unsigned int *)((0x1a08  << 2) + 0xff900000)
+// Bit 31:30 vdin0 dout splitter, bit 0 turns on vdin0 to old path, bit 1 turns on vdin0 to d2d3_intf vdin0 input path
+// Bit 29:28 vdin1 dout splitter, bit 0 turns on vdin1 to old path, bit 1 turns on vdin1 to d2d3_intf vdin1 input path
+// Bit 27:26 NR write dout splitter, bit 0 turns on NR write to old path, bit 1 turns on NR WR to d2d3_intf NR WR input path
+// Bit 23 if true, turn on clk_d2d3_reg (register clock)
+// Bit 22 if true, turn on clk_d2d3
+// Bit 21 reg_v1_go_line
+// Bit 20 reg_v1_go_field
+// Bit 19 reg_v0_go_field
+// Bit 18:16 v1_gofld_sel, 000: display go_field/go_line, 001: DI pre_frame_rst/go_line, 010: vdin0 go_field/go_line,
+//011: vdin1 go_field/go_line, otherwise: force go_field by reg_v1_go_field(bit20), force go_line by reg_v1_go_line(bit21)
+// Bit 15:13 v0_gofld_sel, 000: display go_field, 001: DI pre_frame_rst, 010: vdin0 go_field, 011: vdin1 go_field, otherwise: force go_field by
+// reg_v0_go_field(bit19)
+// Bit 12:6 hole_lines for d2d3 depth read interface
+// Bit 5:4 d2d3_v1_sel, 2'b01: video display read interface(DI or vd1 fomart output), 2'b10: scale output, otherwise nothing as v1
+// Bit 3 use_vdin_eol, if true, use vdin eol as the v0_eol, otherwise using length to get the v0_eol
+// Bit 2:0  d2d3_v0_sel  001: vdin0, 010: vdin1, 011: NRW, 100: video display read interface(DI or vd1 fomart output), 101: vpp scale output
+//
+#define   D2D3_INTF_CTRL0                          (0x1a09)
+#define P_D2D3_INTF_CTRL0                          (volatile unsigned int *)((0x1a09  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// OSD1 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit 10: 9 Reserved for control signals
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define   VIU_OSD1_CTRL_STAT                       (0x1a10)
+#define P_VIU_OSD1_CTRL_STAT                       (volatile unsigned int *)((0x1a10  << 2) + 0xff900000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15    RW, osd_dpath_sel   0-osd1 mif 1-vpu mali afbcd
+// Bit 14    RW, replaced_alpha_en
+// Bit 13: 6 RW, replaced_alpha
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define   VIU_OSD1_CTRL_STAT2                      (0x1a2d)
+#define P_VIU_OSD1_CTRL_STAT2                      (volatile unsigned int *)((0x1a2d  << 2) + 0xff900000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define   VIU_OSD1_COLOR_ADDR                      (0x1a11)
+#define P_VIU_OSD1_COLOR_ADDR                      (volatile unsigned int *)((0x1a11  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU_OSD1_COLOR                           (0x1a12)
+#define P_VIU_OSD1_COLOR                           (volatile unsigned int *)((0x1a12  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU_OSD1_TCOLOR_AG0                      (0x1a17)
+#define P_VIU_OSD1_TCOLOR_AG0                      (volatile unsigned int *)((0x1a17  << 2) + 0xff900000)
+#define   VIU_OSD1_TCOLOR_AG1                      (0x1a18)
+#define P_VIU_OSD1_TCOLOR_AG1                      (volatile unsigned int *)((0x1a18  << 2) + 0xff900000)
+#define   VIU_OSD1_TCOLOR_AG2                      (0x1a19)
+#define P_VIU_OSD1_TCOLOR_AG2                      (volatile unsigned int *)((0x1a19  << 2) + 0xff900000)
+#define   VIU_OSD1_TCOLOR_AG3                      (0x1a1a)
+#define P_VIU_OSD1_TCOLOR_AG3                      (volatile unsigned int *)((0x1a1a  << 2) + 0xff900000)
+// Bit 31:30 Reserved
+// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
+// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
+// Bit 27:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define   VIU_OSD1_BLK0_CFG_W0                     (0x1a1b)
+#define P_VIU_OSD1_BLK0_CFG_W0                     (volatile unsigned int *)((0x1a1b  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK1_CFG_W0                     (0x1a1f)
+#define P_VIU_OSD1_BLK1_CFG_W0                     (volatile unsigned int *)((0x1a1f  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK2_CFG_W0                     (0x1a23)
+#define P_VIU_OSD1_BLK2_CFG_W0                     (volatile unsigned int *)((0x1a23  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK3_CFG_W0                     (0x1a27)
+#define P_VIU_OSD1_BLK3_CFG_W0                     (volatile unsigned int *)((0x1a27  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define   VIU_OSD1_BLK0_CFG_W1                     (0x1a1c)
+#define P_VIU_OSD1_BLK0_CFG_W1                     (volatile unsigned int *)((0x1a1c  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK1_CFG_W1                     (0x1a20)
+#define P_VIU_OSD1_BLK1_CFG_W1                     (volatile unsigned int *)((0x1a20  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK2_CFG_W1                     (0x1a24)
+#define P_VIU_OSD1_BLK2_CFG_W1                     (volatile unsigned int *)((0x1a24  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK3_CFG_W1                     (0x1a28)
+#define P_VIU_OSD1_BLK3_CFG_W1                     (volatile unsigned int *)((0x1a28  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define   VIU_OSD1_BLK0_CFG_W2                     (0x1a1d)
+#define P_VIU_OSD1_BLK0_CFG_W2                     (volatile unsigned int *)((0x1a1d  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK1_CFG_W2                     (0x1a21)
+#define P_VIU_OSD1_BLK1_CFG_W2                     (volatile unsigned int *)((0x1a21  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK2_CFG_W2                     (0x1a25)
+#define P_VIU_OSD1_BLK2_CFG_W2                     (volatile unsigned int *)((0x1a25  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK3_CFG_W2                     (0x1a29)
+#define P_VIU_OSD1_BLK3_CFG_W2                     (volatile unsigned int *)((0x1a29  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define   VIU_OSD1_BLK0_CFG_W3                     (0x1a1e)
+#define P_VIU_OSD1_BLK0_CFG_W3                     (volatile unsigned int *)((0x1a1e  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK1_CFG_W3                     (0x1a22)
+#define P_VIU_OSD1_BLK1_CFG_W3                     (volatile unsigned int *)((0x1a22  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK2_CFG_W3                     (0x1a26)
+#define P_VIU_OSD1_BLK2_CFG_W3                     (volatile unsigned int *)((0x1a26  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK3_CFG_W3                     (0x1a2a)
+#define P_VIU_OSD1_BLK3_CFG_W3                     (volatile unsigned int *)((0x1a2a  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define   VIU_OSD1_BLK0_CFG_W4                     (0x1a13)
+#define P_VIU_OSD1_BLK0_CFG_W4                     (volatile unsigned int *)((0x1a13  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK1_CFG_W4                     (0x1a14)
+#define P_VIU_OSD1_BLK1_CFG_W4                     (volatile unsigned int *)((0x1a14  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK2_CFG_W4                     (0x1a15)
+#define P_VIU_OSD1_BLK2_CFG_W4                     (volatile unsigned int *)((0x1a15  << 2) + 0xff900000)
+#define   VIU_OSD1_BLK3_CFG_W4                     (0x1a16)
+#define P_VIU_OSD1_BLK3_CFG_W4                     (volatile unsigned int *)((0x1a16  << 2) + 0xff900000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
+// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
+// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
+// Bit    19 R,  fifo_overflow
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define   VIU_OSD1_FIFO_CTRL_STAT                  (0x1a2b)
+#define P_VIU_OSD1_FIFO_CTRL_STAT                  (volatile unsigned int *)((0x1a2b  << 2) + 0xff900000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define   VIU_OSD1_TEST_RDDATA                     (0x1a2c)
+#define P_VIU_OSD1_TEST_RDDATA                     (volatile unsigned int *)((0x1a2c  << 2) + 0xff900000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define   VIU_OSD1_PROT_CTRL                       (0x1a2e)
+#define P_VIU_OSD1_PROT_CTRL                       (volatile unsigned int *)((0x1a2e  << 2) + 0xff900000)
+//Bit 7,  highlight_en
+//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
+//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
+//Bit 1   mat1 conversion matrix enable
+//Bit 0   mat0 conversion matrix enable
+#define   VIU_OSD1_MATRIX_CTRL                     (0x1a90)
+#define P_VIU_OSD1_MATRIX_CTRL                     (volatile unsigned int *)((0x1a90  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VIU_OSD1_MATRIX_COEF00_01                (0x1a91)
+#define P_VIU_OSD1_MATRIX_COEF00_01                (volatile unsigned int *)((0x1a91  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VIU_OSD1_MATRIX_COEF02_10                (0x1a92)
+#define P_VIU_OSD1_MATRIX_COEF02_10                (volatile unsigned int *)((0x1a92  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VIU_OSD1_MATRIX_COEF11_12                (0x1a93)
+#define P_VIU_OSD1_MATRIX_COEF11_12                (volatile unsigned int *)((0x1a93  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VIU_OSD1_MATRIX_COEF20_21                (0x1a94)
+#define P_VIU_OSD1_MATRIX_COEF20_21                (volatile unsigned int *)((0x1a94  << 2) + 0xff900000)
+//Bit 31:30    mat_clmod
+//Bit 18:16    mat_convrs
+//Bit 12:0     mat_coef42
+#define   VIU_OSD1_MATRIX_COLMOD_COEF42            (0x1a95)
+#define P_VIU_OSD1_MATRIX_COLMOD_COEF42            (volatile unsigned int *)((0x1a95  << 2) + 0xff900000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define   VIU_OSD1_MATRIX_OFFSET0_1                (0x1a96)
+#define P_VIU_OSD1_MATRIX_OFFSET0_1                (volatile unsigned int *)((0x1a96  << 2) + 0xff900000)
+//Bit 10:0  offset2
+#define   VIU_OSD1_MATRIX_OFFSET2                  (0x1a97)
+#define P_VIU_OSD1_MATRIX_OFFSET2                  (volatile unsigned int *)((0x1a97  << 2) + 0xff900000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define   VIU_OSD1_MATRIX_PRE_OFFSET0_1            (0x1a98)
+#define P_VIU_OSD1_MATRIX_PRE_OFFSET0_1            (volatile unsigned int *)((0x1a98  << 2) + 0xff900000)
+//Bit 10:0  pre_offset2
+#define   VIU_OSD1_MATRIX_PRE_OFFSET2              (0x1a99)
+#define P_VIU_OSD1_MATRIX_PRE_OFFSET2              (volatile unsigned int *)((0x1a99  << 2) + 0xff900000)
+//Read only
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define   VIU_OSD1_MATRIX_PROBE_COLOR              (0x1a9a)
+#define P_VIU_OSD1_MATRIX_PROBE_COLOR              (volatile unsigned int *)((0x1a9a  << 2) + 0xff900000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define   VIU_OSD1_MATRIX_HL_COLOR                 (0x1a9b)
+#define P_VIU_OSD1_MATRIX_HL_COLOR                 (volatile unsigned int *)((0x1a9b  << 2) + 0xff900000)
+//28:16 probe x, postion
+//12:0  probe y, position
+#define   VIU_OSD1_MATRIX_PROBE_POS                (0x1a9c)
+#define P_VIU_OSD1_MATRIX_PROBE_POS                (volatile unsigned int *)((0x1a9c  << 2) + 0xff900000)
+//Bit 28:16 coef22
+//Bit 12:0  coef30
+#define   VIU_OSD1_MATRIX_COEF22_30                (0x1a9d)
+#define P_VIU_OSD1_MATRIX_COEF22_30                (volatile unsigned int *)((0x1a9d  << 2) + 0xff900000)
+//Bit 28:16 coef31
+//Bit 12:0  coef32
+#define   VIU_OSD1_MATRIX_COEF31_32                (0x1a9e)
+#define P_VIU_OSD1_MATRIX_COEF31_32                (volatile unsigned int *)((0x1a9e  << 2) + 0xff900000)
+//Bit 28:16 coef40
+//Bit 12:0  coef41
+#define   VIU_OSD1_MATRIX_COEF40_41                (0x1a9f)
+#define P_VIU_OSD1_MATRIX_COEF40_41                (volatile unsigned int *)((0x1a9f  << 2) + 0xff900000)
+//Bit 31:27 for all [31] for all eotf enable,[30] for matrix3x3 enable, [29:27] for eotf_ch0~3
+//Bit 17:6  for clock gating
+//Bit 5:4   pscale_mode ch2
+//Bit 3:2   pscale_mode ch1
+//Bit 1:0   pscale_mode ch0
+#define   VIU_OSD1_EOTF_CTL                        (0x1ad4)
+#define P_VIU_OSD1_EOTF_CTL                        (volatile unsigned int *)((0x1ad4  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VIU_OSD1_EOTF_COEF00_01                  (0x1ad5)
+#define P_VIU_OSD1_EOTF_COEF00_01                  (volatile unsigned int *)((0x1ad5  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VIU_OSD1_EOTF_COEF02_10                  (0x1ad6)
+#define P_VIU_OSD1_EOTF_COEF02_10                  (volatile unsigned int *)((0x1ad6  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VIU_OSD1_EOTF_COEF11_12                  (0x1ad7)
+#define P_VIU_OSD1_EOTF_COEF11_12                  (volatile unsigned int *)((0x1ad7  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VIU_OSD1_EOTF_COEF20_21                  (0x1ad8)
+#define P_VIU_OSD1_EOTF_COEF20_21                  (volatile unsigned int *)((0x1ad8  << 2) + 0xff900000)
+//Bit 28:16 coef22
+//Bit   2:0 coef_rs
+#define   VIU_OSD1_EOTF_COEF22_RS                  (0x1ad9)
+#define P_VIU_OSD1_EOTF_COEF22_RS                  (volatile unsigned int *)((0x1ad9  << 2) + 0xff900000)
+#define   VIU_OSD1_EOTF_LUT_ADDR_PORT              (0x1ada)
+#define P_VIU_OSD1_EOTF_LUT_ADDR_PORT              (volatile unsigned int *)((0x1ada  << 2) + 0xff900000)
+#define   VIU_OSD1_EOTF_LUT_DATA_PORT              (0x1adb)
+#define P_VIU_OSD1_EOTF_LUT_DATA_PORT              (volatile unsigned int *)((0x1adb  << 2) + 0xff900000)
+//Bit 31:29  for OETF ch0~ch2
+//Bit 21:12  for clock gating
+//Bit 11:8   for oetf_scl_ch2
+//Bit  7:4   for oetf_scl_ch1
+//Bit  3:0   for oetf_scl_ch0
+#define   VIU_OSD1_OETF_CTL                        (0x1adc)
+#define P_VIU_OSD1_OETF_CTL                        (volatile unsigned int *)((0x1adc  << 2) + 0xff900000)
+#define   VIU_OSD1_OETF_LUT_ADDR_PORT              (0x1add)
+#define P_VIU_OSD1_OETF_LUT_ADDR_PORT              (volatile unsigned int *)((0x1add  << 2) + 0xff900000)
+#define   VIU_OSD1_OETF_LUT_DATA_PORT              (0x1ade)
+#define P_VIU_OSD1_OETF_LUT_DATA_PORT              (volatile unsigned int *)((0x1ade  << 2) + 0xff900000)
+#define   VIU_OSD1_OETF_3X3_OFST_0                 (0x1aa0)
+#define P_VIU_OSD1_OETF_3X3_OFST_0                 (volatile unsigned int *)((0x1aa0  << 2) + 0xff900000)
+#define   VIU_OSD1_OETF_3X3_OFST_1                 (0x1aa1)
+#define P_VIU_OSD1_OETF_3X3_OFST_1                 (volatile unsigned int *)((0x1aa1  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// OSD2 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit    10 RW, hl2_en
+// Bit     9 RW, hl1_en
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define   VIU_OSD2_CTRL_STAT                       (0x1a30)
+#define P_VIU_OSD2_CTRL_STAT                       (volatile unsigned int *)((0x1a30  << 2) + 0xff900000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15    Reserved
+// Bit 14    RW, replaced_alpha_en
+// Bit 13: 6 RW, replaced_alpha
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define   VIU_OSD2_CTRL_STAT2                      (0x1a4d)
+#define P_VIU_OSD2_CTRL_STAT2                      (volatile unsigned int *)((0x1a4d  << 2) + 0xff900000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define   VIU_OSD2_COLOR_ADDR                      (0x1a31)
+#define P_VIU_OSD2_COLOR_ADDR                      (volatile unsigned int *)((0x1a31  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU_OSD2_COLOR                           (0x1a32)
+#define P_VIU_OSD2_COLOR                           (volatile unsigned int *)((0x1a32  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, hl[1-2]_h/v_start
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, hl[1-2]_h/v_end
+#define   VIU_OSD2_HL1_H_START_END                 (0x1a33)
+#define P_VIU_OSD2_HL1_H_START_END                 (volatile unsigned int *)((0x1a33  << 2) + 0xff900000)
+#define   VIU_OSD2_HL1_V_START_END                 (0x1a34)
+#define P_VIU_OSD2_HL1_V_START_END                 (volatile unsigned int *)((0x1a34  << 2) + 0xff900000)
+#define   VIU_OSD2_HL2_H_START_END                 (0x1a35)
+#define P_VIU_OSD2_HL2_H_START_END                 (volatile unsigned int *)((0x1a35  << 2) + 0xff900000)
+#define   VIU_OSD2_HL2_V_START_END                 (0x1a36)
+#define P_VIU_OSD2_HL2_V_START_END                 (volatile unsigned int *)((0x1a36  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU_OSD2_TCOLOR_AG0                      (0x1a37)
+#define P_VIU_OSD2_TCOLOR_AG0                      (volatile unsigned int *)((0x1a37  << 2) + 0xff900000)
+#define   VIU_OSD2_TCOLOR_AG1                      (0x1a38)
+#define P_VIU_OSD2_TCOLOR_AG1                      (volatile unsigned int *)((0x1a38  << 2) + 0xff900000)
+#define   VIU_OSD2_TCOLOR_AG2                      (0x1a39)
+#define P_VIU_OSD2_TCOLOR_AG2                      (volatile unsigned int *)((0x1a39  << 2) + 0xff900000)
+#define   VIU_OSD2_TCOLOR_AG3                      (0x1a3a)
+#define P_VIU_OSD2_TCOLOR_AG3                      (volatile unsigned int *)((0x1a3a  << 2) + 0xff900000)
+// Bit 31:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define   VIU_OSD2_BLK0_CFG_W0                     (0x1a3b)
+#define P_VIU_OSD2_BLK0_CFG_W0                     (volatile unsigned int *)((0x1a3b  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK1_CFG_W0                     (0x1a3f)
+#define P_VIU_OSD2_BLK1_CFG_W0                     (volatile unsigned int *)((0x1a3f  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK2_CFG_W0                     (0x1a43)
+#define P_VIU_OSD2_BLK2_CFG_W0                     (volatile unsigned int *)((0x1a43  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK3_CFG_W0                     (0x1a47)
+#define P_VIU_OSD2_BLK3_CFG_W0                     (volatile unsigned int *)((0x1a47  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define   VIU_OSD2_BLK0_CFG_W1                     (0x1a3c)
+#define P_VIU_OSD2_BLK0_CFG_W1                     (volatile unsigned int *)((0x1a3c  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK1_CFG_W1                     (0x1a40)
+#define P_VIU_OSD2_BLK1_CFG_W1                     (volatile unsigned int *)((0x1a40  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK2_CFG_W1                     (0x1a44)
+#define P_VIU_OSD2_BLK2_CFG_W1                     (volatile unsigned int *)((0x1a44  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK3_CFG_W1                     (0x1a48)
+#define P_VIU_OSD2_BLK3_CFG_W1                     (volatile unsigned int *)((0x1a48  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define   VIU_OSD2_BLK0_CFG_W2                     (0x1a3d)
+#define P_VIU_OSD2_BLK0_CFG_W2                     (volatile unsigned int *)((0x1a3d  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK1_CFG_W2                     (0x1a41)
+#define P_VIU_OSD2_BLK1_CFG_W2                     (volatile unsigned int *)((0x1a41  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK2_CFG_W2                     (0x1a45)
+#define P_VIU_OSD2_BLK2_CFG_W2                     (volatile unsigned int *)((0x1a45  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK3_CFG_W2                     (0x1a49)
+#define P_VIU_OSD2_BLK3_CFG_W2                     (volatile unsigned int *)((0x1a49  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define   VIU_OSD2_BLK0_CFG_W3                     (0x1a3e)
+#define P_VIU_OSD2_BLK0_CFG_W3                     (volatile unsigned int *)((0x1a3e  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK1_CFG_W3                     (0x1a42)
+#define P_VIU_OSD2_BLK1_CFG_W3                     (volatile unsigned int *)((0x1a42  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK2_CFG_W3                     (0x1a46)
+#define P_VIU_OSD2_BLK2_CFG_W3                     (volatile unsigned int *)((0x1a46  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK3_CFG_W3                     (0x1a4a)
+#define P_VIU_OSD2_BLK3_CFG_W3                     (volatile unsigned int *)((0x1a4a  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define   VIU_OSD2_BLK0_CFG_W4                     (0x1a64)
+#define P_VIU_OSD2_BLK0_CFG_W4                     (volatile unsigned int *)((0x1a64  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK1_CFG_W4                     (0x1a65)
+#define P_VIU_OSD2_BLK1_CFG_W4                     (volatile unsigned int *)((0x1a65  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK2_CFG_W4                     (0x1a66)
+#define P_VIU_OSD2_BLK2_CFG_W4                     (volatile unsigned int *)((0x1a66  << 2) + 0xff900000)
+#define   VIU_OSD2_BLK3_CFG_W4                     (0x1a67)
+#define P_VIU_OSD2_BLK3_CFG_W4                     (volatile unsigned int *)((0x1a67  << 2) + 0xff900000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
+// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
+// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
+// Bit    19 R,  fifo_overflow
+//
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define   VIU_OSD2_FIFO_CTRL_STAT                  (0x1a4b)
+#define P_VIU_OSD2_FIFO_CTRL_STAT                  (volatile unsigned int *)((0x1a4b  << 2) + 0xff900000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define   VIU_OSD2_TEST_RDDATA                     (0x1a4c)
+#define P_VIU_OSD2_TEST_RDDATA                     (volatile unsigned int *)((0x1a4c  << 2) + 0xff900000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define   VIU_OSD2_PROT_CTRL                       (0x1a4e)
+#define P_VIU_OSD2_PROT_CTRL                       (volatile unsigned int *)((0x1a4e  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// VD1 path
+//------------------------------------------------------------------------------
+#define   VD1_IF0_GEN_REG                          (0x1a50)
+#define P_VD1_IF0_GEN_REG                          (volatile unsigned int *)((0x1a50  << 2) + 0xff900000)
+#define   VD1_IF0_CANVAS0                          (0x1a51)
+#define P_VD1_IF0_CANVAS0                          (volatile unsigned int *)((0x1a51  << 2) + 0xff900000)
+#define   VD1_IF0_CANVAS1                          (0x1a52)
+#define P_VD1_IF0_CANVAS1                          (volatile unsigned int *)((0x1a52  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA_X0                          (0x1a53)
+#define P_VD1_IF0_LUMA_X0                          (volatile unsigned int *)((0x1a53  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA_Y0                          (0x1a54)
+#define P_VD1_IF0_LUMA_Y0                          (volatile unsigned int *)((0x1a54  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA_X0                        (0x1a55)
+#define P_VD1_IF0_CHROMA_X0                        (volatile unsigned int *)((0x1a55  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA_Y0                        (0x1a56)
+#define P_VD1_IF0_CHROMA_Y0                        (volatile unsigned int *)((0x1a56  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA_X1                          (0x1a57)
+#define P_VD1_IF0_LUMA_X1                          (volatile unsigned int *)((0x1a57  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA_Y1                          (0x1a58)
+#define P_VD1_IF0_LUMA_Y1                          (volatile unsigned int *)((0x1a58  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA_X1                        (0x1a59)
+#define P_VD1_IF0_CHROMA_X1                        (volatile unsigned int *)((0x1a59  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA_Y1                        (0x1a5a)
+#define P_VD1_IF0_CHROMA_Y1                        (volatile unsigned int *)((0x1a5a  << 2) + 0xff900000)
+#define   VD1_IF0_RPT_LOOP                         (0x1a5b)
+#define P_VD1_IF0_RPT_LOOP                         (volatile unsigned int *)((0x1a5b  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA0_RPT_PAT                    (0x1a5c)
+#define P_VD1_IF0_LUMA0_RPT_PAT                    (volatile unsigned int *)((0x1a5c  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA0_RPT_PAT                  (0x1a5d)
+#define P_VD1_IF0_CHROMA0_RPT_PAT                  (volatile unsigned int *)((0x1a5d  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA1_RPT_PAT                    (0x1a5e)
+#define P_VD1_IF0_LUMA1_RPT_PAT                    (volatile unsigned int *)((0x1a5e  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA1_RPT_PAT                  (0x1a5f)
+#define P_VD1_IF0_CHROMA1_RPT_PAT                  (volatile unsigned int *)((0x1a5f  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA_PSEL                        (0x1a60)
+#define P_VD1_IF0_LUMA_PSEL                        (volatile unsigned int *)((0x1a60  << 2) + 0xff900000)
+#define   VD1_IF0_CHROMA_PSEL                      (0x1a61)
+#define P_VD1_IF0_CHROMA_PSEL                      (volatile unsigned int *)((0x1a61  << 2) + 0xff900000)
+#define   VD1_IF0_DUMMY_PIXEL                      (0x1a62)
+#define P_VD1_IF0_DUMMY_PIXEL                      (volatile unsigned int *)((0x1a62  << 2) + 0xff900000)
+#define   VD1_IF0_LUMA_FIFO_SIZE                   (0x1a63)
+#define P_VD1_IF0_LUMA_FIFO_SIZE                   (volatile unsigned int *)((0x1a63  << 2) + 0xff900000)
+#define   VD1_IF0_RANGE_MAP_Y                      (0x1a6a)
+#define P_VD1_IF0_RANGE_MAP_Y                      (volatile unsigned int *)((0x1a6a  << 2) + 0xff900000)
+#define   VD1_IF0_RANGE_MAP_CB                     (0x1a6b)
+#define P_VD1_IF0_RANGE_MAP_CB                     (volatile unsigned int *)((0x1a6b  << 2) + 0xff900000)
+#define   VD1_IF0_RANGE_MAP_CR                     (0x1a6c)
+#define P_VD1_IF0_RANGE_MAP_CR                     (volatile unsigned int *)((0x1a6c  << 2) + 0xff900000)
+#define   VD1_IF0_GEN_REG2                         (0x1a6d)
+#define P_VD1_IF0_GEN_REG2                         (volatile unsigned int *)((0x1a6d  << 2) + 0xff900000)
+#define   VD1_IF0_PROT_CNTL                        (0x1a6e)
+#define P_VD1_IF0_PROT_CNTL                        (volatile unsigned int *)((0x1a6e  << 2) + 0xff900000)
+#define   VD1_IF0_URGENT_CTRL                      (0x1a6f)
+#define P_VD1_IF0_URGENT_CTRL                      (volatile unsigned int *)((0x1a6f  << 2) + 0xff900000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 19    if true, always use phase0 while vertical formater, meaning always
+//          repeat data, no interpolation
+//Bit 18    if true, disable vertical formatter chroma repeat last line
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)
+//Bit 0     vertical formatter enable
+#define   VIU_VD1_FMT_CTRL                         (0x1a68)
+#define P_VIU_VD1_FMT_CTRL                         (volatile unsigned int *)((0x1a68  << 2) + 0xff900000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define   VIU_VD1_FMT_W                            (0x1a69)
+#define P_VIU_VD1_FMT_W                            (volatile unsigned int *)((0x1a69  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// VD2 path
+//------------------------------------------------------------------------------
+#define   VD2_IF0_GEN_REG                          (0x1a70)
+#define P_VD2_IF0_GEN_REG                          (volatile unsigned int *)((0x1a70  << 2) + 0xff900000)
+#define   VD2_IF0_CANVAS0                          (0x1a71)
+#define P_VD2_IF0_CANVAS0                          (volatile unsigned int *)((0x1a71  << 2) + 0xff900000)
+#define   VD2_IF0_CANVAS1                          (0x1a72)
+#define P_VD2_IF0_CANVAS1                          (volatile unsigned int *)((0x1a72  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA_X0                          (0x1a73)
+#define P_VD2_IF0_LUMA_X0                          (volatile unsigned int *)((0x1a73  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA_Y0                          (0x1a74)
+#define P_VD2_IF0_LUMA_Y0                          (volatile unsigned int *)((0x1a74  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA_X0                        (0x1a75)
+#define P_VD2_IF0_CHROMA_X0                        (volatile unsigned int *)((0x1a75  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA_Y0                        (0x1a76)
+#define P_VD2_IF0_CHROMA_Y0                        (volatile unsigned int *)((0x1a76  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA_X1                          (0x1a77)
+#define P_VD2_IF0_LUMA_X1                          (volatile unsigned int *)((0x1a77  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA_Y1                          (0x1a78)
+#define P_VD2_IF0_LUMA_Y1                          (volatile unsigned int *)((0x1a78  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA_X1                        (0x1a79)
+#define P_VD2_IF0_CHROMA_X1                        (volatile unsigned int *)((0x1a79  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA_Y1                        (0x1a7a)
+#define P_VD2_IF0_CHROMA_Y1                        (volatile unsigned int *)((0x1a7a  << 2) + 0xff900000)
+#define   VD2_IF0_RPT_LOOP                         (0x1a7b)
+#define P_VD2_IF0_RPT_LOOP                         (volatile unsigned int *)((0x1a7b  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA0_RPT_PAT                    (0x1a7c)
+#define P_VD2_IF0_LUMA0_RPT_PAT                    (volatile unsigned int *)((0x1a7c  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA0_RPT_PAT                  (0x1a7d)
+#define P_VD2_IF0_CHROMA0_RPT_PAT                  (volatile unsigned int *)((0x1a7d  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA1_RPT_PAT                    (0x1a7e)
+#define P_VD2_IF0_LUMA1_RPT_PAT                    (volatile unsigned int *)((0x1a7e  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA1_RPT_PAT                  (0x1a7f)
+#define P_VD2_IF0_CHROMA1_RPT_PAT                  (volatile unsigned int *)((0x1a7f  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA_PSEL                        (0x1a80)
+#define P_VD2_IF0_LUMA_PSEL                        (volatile unsigned int *)((0x1a80  << 2) + 0xff900000)
+#define   VD2_IF0_CHROMA_PSEL                      (0x1a81)
+#define P_VD2_IF0_CHROMA_PSEL                      (volatile unsigned int *)((0x1a81  << 2) + 0xff900000)
+#define   VD2_IF0_DUMMY_PIXEL                      (0x1a82)
+#define P_VD2_IF0_DUMMY_PIXEL                      (volatile unsigned int *)((0x1a82  << 2) + 0xff900000)
+#define   VD2_IF0_LUMA_FIFO_SIZE                   (0x1a83)
+#define P_VD2_IF0_LUMA_FIFO_SIZE                   (volatile unsigned int *)((0x1a83  << 2) + 0xff900000)
+#define   VD2_IF0_RANGE_MAP_Y                      (0x1a8a)
+#define P_VD2_IF0_RANGE_MAP_Y                      (volatile unsigned int *)((0x1a8a  << 2) + 0xff900000)
+#define   VD2_IF0_RANGE_MAP_CB                     (0x1a8b)
+#define P_VD2_IF0_RANGE_MAP_CB                     (volatile unsigned int *)((0x1a8b  << 2) + 0xff900000)
+#define   VD2_IF0_RANGE_MAP_CR                     (0x1a8c)
+#define P_VD2_IF0_RANGE_MAP_CR                     (volatile unsigned int *)((0x1a8c  << 2) + 0xff900000)
+#define   VD2_IF0_GEN_REG2                         (0x1a8d)
+#define P_VD2_IF0_GEN_REG2                         (volatile unsigned int *)((0x1a8d  << 2) + 0xff900000)
+#define   VD2_IF0_PROT_CNTL                        (0x1a8e)
+#define P_VD2_IF0_PROT_CNTL                        (volatile unsigned int *)((0x1a8e  << 2) + 0xff900000)
+#define   VD2_IF0_URGENT_CTRL                      (0x1a8f)
+#define P_VD2_IF0_URGENT_CTRL                      (volatile unsigned int *)((0x1a8f  << 2) + 0xff900000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)
+//Bit 0     vertical formatter enable
+#define   VIU_VD2_FMT_CTRL                         (0x1a88)
+#define P_VIU_VD2_FMT_CTRL                         (volatile unsigned int *)((0x1a88  << 2) + 0xff900000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define   VIU_VD2_FMT_W                            (0x1a89)
+#define P_VIU_VD2_FMT_W                            (volatile unsigned int *)((0x1a89  << 2) + 0xff900000)
+//     //todo add comment
+#define   LDIM_STTS_GCLK_CTRL0                     (0x1ac0)
+#define P_LDIM_STTS_GCLK_CTRL0                     (volatile unsigned int *)((0x1ac0  << 2) + 0xff900000)
+#define   LDIM_STTS_CTRL0                          (0x1ac1)
+#define P_LDIM_STTS_CTRL0                          (volatile unsigned int *)((0x1ac1  << 2) + 0xff900000)
+#define   LDIM_STTS_WIDTHM1_HEIGHTM1               (0x1ac2)
+#define P_LDIM_STTS_WIDTHM1_HEIGHTM1               (volatile unsigned int *)((0x1ac2  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_COEF00_01               (0x1ac3)
+#define P_LDIM_STTS_MATRIX_COEF00_01               (volatile unsigned int *)((0x1ac3  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_COEF02_10               (0x1ac4)
+#define P_LDIM_STTS_MATRIX_COEF02_10               (volatile unsigned int *)((0x1ac4  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_COEF11_12               (0x1ac5)
+#define P_LDIM_STTS_MATRIX_COEF11_12               (volatile unsigned int *)((0x1ac5  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_COEF20_21               (0x1ac6)
+#define P_LDIM_STTS_MATRIX_COEF20_21               (volatile unsigned int *)((0x1ac6  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_COEF22                  (0x1ac7)
+#define P_LDIM_STTS_MATRIX_COEF22                  (volatile unsigned int *)((0x1ac7  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_OFFSET0_1               (0x1ac8)
+#define P_LDIM_STTS_MATRIX_OFFSET0_1               (volatile unsigned int *)((0x1ac8  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_OFFSET2                 (0x1ac9)
+#define P_LDIM_STTS_MATRIX_OFFSET2                 (volatile unsigned int *)((0x1ac9  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_PRE_OFFSET0_1           (0x1aca)
+#define P_LDIM_STTS_MATRIX_PRE_OFFSET0_1           (volatile unsigned int *)((0x1aca  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_PRE_OFFSET2             (0x1acb)
+#define P_LDIM_STTS_MATRIX_PRE_OFFSET2             (volatile unsigned int *)((0x1acb  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_HL_COLOR                (0x1acc)
+#define P_LDIM_STTS_MATRIX_HL_COLOR                (volatile unsigned int *)((0x1acc  << 2) + 0xff900000)
+#define   LDIM_STTS_MATRIX_PROBE_POS               (0x1acd)
+#define P_LDIM_STTS_MATRIX_PROBE_POS               (volatile unsigned int *)((0x1acd  << 2) + 0xff900000)
+//
+//     //read only
+#define   LDIM_STTS_MATRIX_PROBE_COLOR             (0x1ace)
+#define P_LDIM_STTS_MATRIX_PROBE_COLOR             (volatile unsigned int *)((0x1ace  << 2) + 0xff900000)
+//
+//     //Bit 31, local dimming statistic enable
+//     //Bit 29, 1: output region histogram 16bit 0:output region histogram 20bit
+//     //Bit 28, eol enable
+//     //Bit 27:25, vertical line overlap number for max finding
+//     //Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
+//     //Bit 20, 1,2,1 low pass filter enable before max/hist statistic
+//     //Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
+//     //Bit 15:14, 1: region read index auto increase per block read finished to VDIN_LDIM_STTS_HIST_READ_REGION
+//     //			 2: region read index auto increase per read finished to VDIN_LDIM_STTS_HIST_READ_REGION
+//     //			 0/3: disable read index self increase
+//     //Bit 13:8, region read sub index, which mux the hist & max-finding result to cbus port, refer to LDIM_STTS_HIST_READ_REGION
+//     //Bit 6:0, region read index
+#define   LDIM_STTS_HIST_REGION_IDX                (0x1ad0)
+#define P_LDIM_STTS_HIST_REGION_IDX                (volatile unsigned int *)((0x1ad0  << 2) + 0xff900000)
+//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
+//     //hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
+//     //hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
+//     //vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
+//     //hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
+//     //vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
+//     //hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
+//     //vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
+//     //hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
+//     //vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
+//     //hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
+//     //vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
+#define   LDIM_STTS_HIST_SET_REGION                (0x1ad1)
+#define P_LDIM_STTS_HIST_SET_REGION                (volatile unsigned int *)((0x1ad1  << 2) + 0xff900000)
+//
+//     //if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data.
+//     //if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0.
+//     //output sequence as rd_sub_idx from 0~47: {max_comp2, comp0_hist0}, {max_comp1, comp0_hist1}, {max_comp0, comp0_hist2},
+//     //										   comp0_hist3 ... comp2_hist16
+//     //if LDIM_STTS_HIST_REGION_IDX[29] == 1, that is output hist with 16bit data.
+//     //if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0.
+//     //output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
+//     //										   comp0_hist3 ... comp2_hist16
+//     //if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data.
+//     //if LDIM_STTS_HIST_REGION_IDX[21] == 1, that is output 32hist bins in comp 0.
+//     //output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
+//     //										   comp0_hist3 ...comp0_hist31 ... comp1_hist16
+//
+#define   LDIM_STTS_HIST_READ_REGION               (0x1ad2)
+#define P_LDIM_STTS_HIST_READ_REGION               (volatile unsigned int *)((0x1ad2  << 2) + 0xff900000)
+#define   LDIM_STTS_HIST_START_RD_REGION           (0x1ad3)
+#define P_LDIM_STTS_HIST_START_RD_REGION           (volatile unsigned int *)((0x1ad3  << 2) + 0xff900000)
+//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di if1 chroma path
+//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di if1 luma path
+//     `define DI_IF1_URGENT_CTRL						8'ha3
+//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
+//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
+//     `define DI_INP_URGENT_CTRL						8'ha4
+//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di mem chroma path
+//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di mem luma path
+//     `define DI_MEM_URGENT_CTRL						8'ha5
+//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di chan2 chroma path
+//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di chan2 luma path
+//     `define DI_CHAN2_URGENT_CTRL					8'ha6
+#define   VD1_IF0_GEN_REG3                         (0x1aa7)
+#define P_VD1_IF0_GEN_REG3                         (volatile unsigned int *)((0x1aa7  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+#define   VD2_IF0_GEN_REG3                         (0x1aa8)
+#define P_VD2_IF0_GEN_REG3                         (volatile unsigned int *)((0x1aa8  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+#define   OSD_BLENDO_H_START_END                   (0x1aa9)
+#define P_OSD_BLENDO_H_START_END                   (volatile unsigned int *)((0x1aa9  << 2) + 0xff900000)
+//OSD blending output horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   OSD_BLENDO_V_START_END                   (0x1aaa)
+#define P_OSD_BLENDO_V_START_END                   (volatile unsigned int *)((0x1aaa  << 2) + 0xff900000)
+//OSD blending output vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   OSD_BLEND_GEN_CTRL0                      (0x1aab)
+#define P_OSD_BLEND_GEN_CTRL0                      (volatile unsigned int *)((0x1aab  << 2) + 0xff900000)
+//Bit 31:23 const_out_alpha
+//Bit 22:14 const_op_alpha
+//Bit 13 if true, OSD2 foreground otherwise OSD1 foreground
+//Bit 12  OSD BLENDing enable
+//Bit 9:8 alpha_op_sel 00: output alpha use osd1_alpha, 01: use osd2_alpha, else use const_out_alpha
+//Bit 5:4 color_op_sel 00: use osd1_alpha, 01: use osd2_alpha, else use const_op_alpha
+//Bit 1  OSD2 enable
+//Bit 0  OSD1 enable
+#define   OSD_BLEND_GEN_CTRL1                      (0x1aac)
+#define P_OSD_BLEND_GEN_CTRL1                      (volatile unsigned int *)((0x1aac  << 2) + 0xff900000)
+//Bit 31    osd1_alpha_premult, if true, osd1 alpha is premultipiled
+//Bit 30    osd2_alpha_premult, if true, osd2 alpha is premultipiled
+//Bit 23:16 osd blending hold lines
+//Bit 13:0  osd blending h_size
+#define   OSD_BLEND_DUMMY_DATA                     (0x1aad)
+#define P_OSD_BLEND_DUMMY_DATA                     (volatile unsigned int *)((0x1aad  << 2) + 0xff900000)
+//Bit 29:20   Y/R
+//Bit 19:10   CB/G
+//Bit 9:0     Cr/B
+#define   OSD_BLEND_CURRENT_XY                     (0x1aae)
+#define P_OSD_BLEND_CURRENT_XY                     (volatile unsigned int *)((0x1aae  << 2) + 0xff900000)
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+//Bit 7,  highlight_en
+//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
+//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
+//Bit 1   mat1 conversion matrix enable
+//Bit 0   mat0 conversion matrix enable
+#define   VIU_OSD2_MATRIX_CTRL                     (0x1ab0)
+#define P_VIU_OSD2_MATRIX_CTRL                     (volatile unsigned int *)((0x1ab0  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VIU_OSD2_MATRIX_COEF00_01                (0x1ab1)
+#define P_VIU_OSD2_MATRIX_COEF00_01                (volatile unsigned int *)((0x1ab1  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VIU_OSD2_MATRIX_COEF02_10                (0x1ab2)
+#define P_VIU_OSD2_MATRIX_COEF02_10                (volatile unsigned int *)((0x1ab2  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VIU_OSD2_MATRIX_COEF11_12                (0x1ab3)
+#define P_VIU_OSD2_MATRIX_COEF11_12                (volatile unsigned int *)((0x1ab3  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VIU_OSD2_MATRIX_COEF20_21                (0x1ab4)
+#define P_VIU_OSD2_MATRIX_COEF20_21                (volatile unsigned int *)((0x1ab4  << 2) + 0xff900000)
+#define   VIU_OSD2_MATRIX_COEF22                   (0x1ab5)
+#define P_VIU_OSD2_MATRIX_COEF22                   (volatile unsigned int *)((0x1ab5  << 2) + 0xff900000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define   VIU_OSD2_MATRIX_OFFSET0_1                (0x1ab6)
+#define P_VIU_OSD2_MATRIX_OFFSET0_1                (volatile unsigned int *)((0x1ab6  << 2) + 0xff900000)
+//Bit 10:0  offset2
+#define   VIU_OSD2_MATRIX_OFFSET2                  (0x1ab7)
+#define P_VIU_OSD2_MATRIX_OFFSET2                  (volatile unsigned int *)((0x1ab7  << 2) + 0xff900000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define   VIU_OSD2_MATRIX_PRE_OFFSET0_1            (0x1ab8)
+#define P_VIU_OSD2_MATRIX_PRE_OFFSET0_1            (volatile unsigned int *)((0x1ab8  << 2) + 0xff900000)
+//Bit 10:0  pre_offset2
+#define   VIU_OSD2_MATRIX_PRE_OFFSET2              (0x1ab9)
+#define P_VIU_OSD2_MATRIX_PRE_OFFSET2              (volatile unsigned int *)((0x1ab9  << 2) + 0xff900000)
+//Read only
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define   VIU_OSD2_MATRIX_PROBE_COLOR              (0x1aba)
+#define P_VIU_OSD2_MATRIX_PROBE_COLOR              (volatile unsigned int *)((0x1aba  << 2) + 0xff900000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define   VIU_OSD2_MATRIX_HL_COLOR                 (0x1abb)
+#define P_VIU_OSD2_MATRIX_HL_COLOR                 (volatile unsigned int *)((0x1abb  << 2) + 0xff900000)
+//28:16 probe x, postion
+//12:0  probe y, position
+#define   VIU_OSD2_MATRIX_PROBE_POS                (0x1abc)
+#define P_VIU_OSD2_MATRIX_PROBE_POS                (volatile unsigned int *)((0x1abc  << 2) + 0xff900000)
+//the segment of afbc dec is 8'he0-8'hfe
+//`define AFBC_DEC_OFFSET   8'he0
+//
+// Reading file:  afbc_dec_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+////===============================////
+//// reg
+////===============================////
+#define   AFBC_ENABLE                              (0x1ae0)
+#define P_AFBC_ENABLE                              (volatile unsigned int *)((0x1ae0  << 2) + 0xff900000)
+//Bit   31:1,     reserved
+//Bit   8,        dec_enable        unsigned  , default = 0
+//Bit   7:1,      reserved
+//Bit   0,        frm_start         unsigned  , default = 0
+#define   AFBC_MODE                                (0x1ae1)
+#define P_AFBC_MODE                                (volatile unsigned int *)((0x1ae1  << 2) + 0xff900000)
+//Bit   31,       soft_reset        the use as go_field
+//Bit   30,       reserved
+//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
+//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
+//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
+//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
+//Bit   22:16,    hold_line_num
+//Bit   15:14,    burst_len         uns, default = 1, 0: burst1 1:burst2 2:burst4
+//Bit   13:8,     compbits_yuv      uns, default = 0 ,
+//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit
+//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit
+//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit
+//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+#define   AFBC_SIZE_IN                             (0x1ae2)
+#define P_AFBC_SIZE_IN                             (volatile unsigned int *)((0x1ae2  << 2) + 0xff900000)
+//Bit   31:29,    reserved
+//Bit   28:16     hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
+//Bit   15:13,    reserved
+//Bit   12:0,     vsize_in          uns, default = 1080 , pic vert size in  unit: pixel
+#define   AFBC_DEC_DEF_COLOR                       (0x1ae3)
+#define P_AFBC_DEC_DEF_COLOR                       (volatile unsigned int *)((0x1ae3  << 2) + 0xff900000)
+//Bit   31:29,    reserved
+//Bit   29:20,   def_color_y        uns, default = 0, afbc dec y default setting value
+//Bit   19:10,   def_color_u        uns, default = 0, afbc dec u default setting value
+//Bit    9: 0,   def_color_v        uns, default = 0, afbc dec v default setting value
+#define   AFBC_CONV_CTRL                           (0x1ae4)
+#define P_AFBC_CONV_CTRL                           (volatile unsigned int *)((0x1ae4  << 2) + 0xff900000)
+//Bit   31:12,   reserved
+//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
+#define   AFBC_LBUF_DEPTH                          (0x1ae5)
+#define P_AFBC_LBUF_DEPTH                          (volatile unsigned int *)((0x1ae5  << 2) + 0xff900000)
+//Bit   31:28,   reserved
+//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
+//Bit   15:12,   reserved
+//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
+#define   AFBC_HEAD_BADDR                          (0x1ae6)
+#define P_AFBC_HEAD_BADDR                          (volatile unsigned int *)((0x1ae6  << 2) + 0xff900000)
+//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
+#define   AFBC_BODY_BADDR                          (0x1ae7)
+#define P_AFBC_BODY_BADDR                          (volatile unsigned int *)((0x1ae7  << 2) + 0xff900000)
+//Bit   31:0,   mif_data_baddr      uns, default = 32'h0001_0000;
+#define   AFBC_SIZE_OUT                            (0x1ae8)
+#define P_AFBC_SIZE_OUT                            (volatile unsigned int *)((0x1ae8  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   hsize_out           uns, default = 1920    ; // unit: 1 pixel
+//Bit   15:13,   reserved
+//Bit    12:0,   vsize_out           uns, default = 1080 ; // unit: 1 pixel
+#define   AFBC_OUT_YSCOPE                          (0x1ae9)
+#define P_AFBC_OUT_YSCOPE                          (volatile unsigned int *)((0x1ae9  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
+//Bit   15:13,   reserved
+//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
+#define   AFBC_STAT                                (0x1aea)
+#define P_AFBC_STAT                                (volatile unsigned int *)((0x1aea  << 2) + 0xff900000)
+//Bit   31:1,   reserved
+//Bit      0,   frm_end_stat         uns, frame end status
+#define   AFBC_VD_CFMT_CTRL                        (0x1aeb)
+#define P_AFBC_VD_CFMT_CTRL                        (volatile unsigned int *)((0x1aeb  << 2) + 0xff900000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 19    if true, always use phase0 while vertical formater, meaning always
+//          repeat data, no interpolation
+//Bit 18    if true, disable vertical formatter chroma repeat last line
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)
+//Bit 0     vertical formatter enable
+#define   AFBC_VD_CFMT_W                           (0x1aec)
+#define P_AFBC_VD_CFMT_W                           (volatile unsigned int *)((0x1aec  << 2) + 0xff900000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define   AFBC_MIF_HOR_SCOPE                       (0x1aed)
+#define P_AFBC_MIF_HOR_SCOPE                       (volatile unsigned int *)((0x1aed  << 2) + 0xff900000)
+//Bit   31:26,   reserved
+//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
+//Bit   15:10,   reserved
+//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
+#define   AFBC_MIF_VER_SCOPE                       (0x1aee)
+#define P_AFBC_MIF_VER_SCOPE                       (volatile unsigned int *)((0x1aee  << 2) + 0xff900000)
+//Bit   31:28,   reserved
+//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
+//Bit   15:12,   reserved
+//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
+#define   AFBC_PIXEL_HOR_SCOPE                     (0x1aef)
+#define P_AFBC_PIXEL_HOR_SCOPE                     (volatile unsigned int *)((0x1aef  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
+//Bit   15:13,   reserved
+//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
+#define   AFBC_PIXEL_VER_SCOPE                     (0x1af0)
+#define P_AFBC_PIXEL_VER_SCOPE                     (volatile unsigned int *)((0x1af0  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
+//Bit   15:13,   reserved
+//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
+#define   AFBC_VD_CFMT_H                           (0x1af1)
+#define P_AFBC_VD_CFMT_H                           (volatile unsigned int *)((0x1af1  << 2) + 0xff900000)
+//Bit 12:0   vertical formatter height
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  afbc_dec_regs.h
+//
+//
+// Closing file:  vregs_clk2.h
+//
+//`define  VENC_VCBUS_BASE              8'h1b
+//
+// Reading file:  venc_regs.h
+//
+//===========================================================================
+// Video Interface Registers    0xa00 - 0xbff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VENC_VCBUS_BASE = 0x1b
+// -----------------------------------------------
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 0 -- vfifo2vd_en
+#define   ENCP_VFIFO2VD_CTL                        (0x1b58)
+#define P_ENCP_VFIFO2VD_CTL                        (volatile unsigned int *)((0x1b58  << 2) + 0xff900000)
+// bit 12:0 -- vfifo2vd_pixel_start
+#define   ENCP_VFIFO2VD_PIXEL_START                (0x1b59)
+#define P_ENCP_VFIFO2VD_PIXEL_START                (volatile unsigned int *)((0x1b59  << 2) + 0xff900000)
+// bit 12:00 -- vfifo2vd_pixel_end
+#define   ENCP_VFIFO2VD_PIXEL_END                  (0x1b5a)
+#define P_ENCP_VFIFO2VD_PIXEL_END                  (volatile unsigned int *)((0x1b5a  << 2) + 0xff900000)
+// bit 10:0 -- vfifo2vd_line_top_start
+#define   ENCP_VFIFO2VD_LINE_TOP_START             (0x1b5b)
+#define P_ENCP_VFIFO2VD_LINE_TOP_START             (volatile unsigned int *)((0x1b5b  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_top_end
+#define   ENCP_VFIFO2VD_LINE_TOP_END               (0x1b5c)
+#define P_ENCP_VFIFO2VD_LINE_TOP_END               (volatile unsigned int *)((0x1b5c  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_start
+#define   ENCP_VFIFO2VD_LINE_BOT_START             (0x1b5d)
+#define P_ENCP_VFIFO2VD_LINE_BOT_START             (volatile unsigned int *)((0x1b5d  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_end
+#define   ENCP_VFIFO2VD_LINE_BOT_END               (0x1b5e)
+#define P_ENCP_VFIFO2VD_LINE_BOT_END               (volatile unsigned int *)((0x1b5e  << 2) + 0xff900000)
+// Route the hsync and vsync signals round the chip. There are three
+// sources and users of these signals: VIU, internal video encoder, and
+// the pins on the chip. Some muxing is still being done in the VIU. It
+// was not moved to the venc module so that the same exact VIU code could
+// be used both in Twister and Twister2000.
+// Bit 2: venc_sync_source (1=>pins, 0=>viu)
+// Bit 1: viu_sync_source (1=>pins, 0=>venc)
+// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
+#define   VENC_SYNC_ROUTE                          (0x1b60)
+#define P_VENC_SYNC_ROUTE                          (volatile unsigned int *)((0x1b60  << 2) + 0xff900000)
+#define   VENC_VIDEO_EXSRC                         (0x1b61)
+#define P_VENC_VIDEO_EXSRC                         (volatile unsigned int *)((0x1b61  << 2) + 0xff900000)
+#define   VENC_DVI_SETTING                         (0x1b62)
+#define P_VENC_DVI_SETTING                         (volatile unsigned int *)((0x1b62  << 2) + 0xff900000)
+#define   VENC_C656_CTRL                           (0x1b63)
+#define P_VENC_C656_CTRL                           (volatile unsigned int *)((0x1b63  << 2) + 0xff900000)
+#define   VENC_UPSAMPLE_CTRL0                      (0x1b64)
+#define P_VENC_UPSAMPLE_CTRL0                      (volatile unsigned int *)((0x1b64  << 2) + 0xff900000)
+#define   VENC_UPSAMPLE_CTRL1                      (0x1b65)
+#define P_VENC_UPSAMPLE_CTRL1                      (volatile unsigned int *)((0x1b65  << 2) + 0xff900000)
+#define   VENC_UPSAMPLE_CTRL2                      (0x1b66)
+#define P_VENC_UPSAMPLE_CTRL2                      (volatile unsigned int *)((0x1b66  << 2) + 0xff900000)
+// Invert control for tcon output
+// bit[15:14] -- vsync, hsync,
+// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
+#define   TCON_INVERT_CTL                          (0x1b67)
+#define P_TCON_INVERT_CTL                          (volatile unsigned int *)((0x1b67  << 2) + 0xff900000)
+#define   VENC_VIDEO_PROG_MODE                     (0x1b68)
+#define P_VENC_VIDEO_PROG_MODE                     (volatile unsigned int *)((0x1b68  << 2) + 0xff900000)
+//---- Venc pixel/line info
+#define   VENC_ENCI_LINE                           (0x1b69)
+#define P_VENC_ENCI_LINE                           (volatile unsigned int *)((0x1b69  << 2) + 0xff900000)
+#define   VENC_ENCI_PIXEL                          (0x1b6a)
+#define P_VENC_ENCI_PIXEL                          (volatile unsigned int *)((0x1b6a  << 2) + 0xff900000)
+#define   VENC_ENCP_LINE                           (0x1b6b)
+#define P_VENC_ENCP_LINE                           (volatile unsigned int *)((0x1b6b  << 2) + 0xff900000)
+#define   VENC_ENCP_PIXEL                          (0x1b6c)
+#define P_VENC_ENCP_PIXEL                          (volatile unsigned int *)((0x1b6c  << 2) + 0xff900000)
+//---- Status
+#define   VENC_STATA                               (0x1b6d)
+#define P_VENC_STATA                               (volatile unsigned int *)((0x1b6d  << 2) + 0xff900000)
+//---- Interrupt setting
+#define   VENC_INTCTRL                             (0x1b6e)
+#define P_VENC_INTCTRL                             (volatile unsigned int *)((0x1b6e  << 2) + 0xff900000)
+#define   VENC_INTFLAG                             (0x1b6f)
+#define P_VENC_INTFLAG                             (volatile unsigned int *)((0x1b6f  << 2) + 0xff900000)
+//--------- Video test configuration
+#define   VENC_VIDEO_TST_EN                        (0x1b70)
+#define P_VENC_VIDEO_TST_EN                        (volatile unsigned int *)((0x1b70  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_MDSEL                     (0x1b71)
+#define P_VENC_VIDEO_TST_MDSEL                     (volatile unsigned int *)((0x1b71  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_Y                         (0x1b72)
+#define P_VENC_VIDEO_TST_Y                         (volatile unsigned int *)((0x1b72  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_CB                        (0x1b73)
+#define P_VENC_VIDEO_TST_CB                        (volatile unsigned int *)((0x1b73  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_CR                        (0x1b74)
+#define P_VENC_VIDEO_TST_CR                        (volatile unsigned int *)((0x1b74  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_CLRBAR_STRT               (0x1b75)
+#define P_VENC_VIDEO_TST_CLRBAR_STRT               (volatile unsigned int *)((0x1b75  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_CLRBAR_WIDTH              (0x1b76)
+#define P_VENC_VIDEO_TST_CLRBAR_WIDTH              (volatile unsigned int *)((0x1b76  << 2) + 0xff900000)
+#define   VENC_VIDEO_TST_VDCNT_STSET               (0x1b77)
+#define P_VENC_VIDEO_TST_VDCNT_STSET               (volatile unsigned int *)((0x1b77  << 2) + 0xff900000)
+//----- Video dac setting
+#define   VENC_VDAC_DACSEL0                        (0x1b78)
+#define P_VENC_VDAC_DACSEL0                        (volatile unsigned int *)((0x1b78  << 2) + 0xff900000)
+#define   VENC_VDAC_DACSEL1                        (0x1b79)
+#define P_VENC_VDAC_DACSEL1                        (volatile unsigned int *)((0x1b79  << 2) + 0xff900000)
+#define   VENC_VDAC_DACSEL2                        (0x1b7a)
+#define P_VENC_VDAC_DACSEL2                        (volatile unsigned int *)((0x1b7a  << 2) + 0xff900000)
+#define   VENC_VDAC_DACSEL3                        (0x1b7b)
+#define P_VENC_VDAC_DACSEL3                        (volatile unsigned int *)((0x1b7b  << 2) + 0xff900000)
+#define   VENC_VDAC_DACSEL4                        (0x1b7c)
+#define P_VENC_VDAC_DACSEL4                        (volatile unsigned int *)((0x1b7c  << 2) + 0xff900000)
+#define   VENC_VDAC_DACSEL5                        (0x1b7d)
+#define P_VENC_VDAC_DACSEL5                        (volatile unsigned int *)((0x1b7d  << 2) + 0xff900000)
+#define   VENC_VDAC_SETTING                        (0x1b7e)
+#define P_VENC_VDAC_SETTING                        (volatile unsigned int *)((0x1b7e  << 2) + 0xff900000)
+#define   VENC_VDAC_TST_VAL                        (0x1b7f)
+#define P_VENC_VDAC_TST_VAL                        (volatile unsigned int *)((0x1b7f  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC0_GAINCTRL                  (0x1bf0)
+#define P_VENC_VDAC_DAC0_GAINCTRL                  (volatile unsigned int *)((0x1bf0  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC0_OFFSET                    (0x1bf1)
+#define P_VENC_VDAC_DAC0_OFFSET                    (volatile unsigned int *)((0x1bf1  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC1_GAINCTRL                  (0x1bf2)
+#define P_VENC_VDAC_DAC1_GAINCTRL                  (volatile unsigned int *)((0x1bf2  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC1_OFFSET                    (0x1bf3)
+#define P_VENC_VDAC_DAC1_OFFSET                    (volatile unsigned int *)((0x1bf3  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC2_GAINCTRL                  (0x1bf4)
+#define P_VENC_VDAC_DAC2_GAINCTRL                  (volatile unsigned int *)((0x1bf4  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC2_OFFSET                    (0x1bf5)
+#define P_VENC_VDAC_DAC2_OFFSET                    (volatile unsigned int *)((0x1bf5  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC3_GAINCTRL                  (0x1bf6)
+#define P_VENC_VDAC_DAC3_GAINCTRL                  (volatile unsigned int *)((0x1bf6  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC3_OFFSET                    (0x1bf7)
+#define P_VENC_VDAC_DAC3_OFFSET                    (volatile unsigned int *)((0x1bf7  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC4_GAINCTRL                  (0x1bf8)
+#define P_VENC_VDAC_DAC4_GAINCTRL                  (volatile unsigned int *)((0x1bf8  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC4_OFFSET                    (0x1bf9)
+#define P_VENC_VDAC_DAC4_OFFSET                    (volatile unsigned int *)((0x1bf9  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC5_GAINCTRL                  (0x1bfa)
+#define P_VENC_VDAC_DAC5_GAINCTRL                  (volatile unsigned int *)((0x1bfa  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC5_OFFSET                    (0x1bfb)
+#define P_VENC_VDAC_DAC5_OFFSET                    (volatile unsigned int *)((0x1bfb  << 2) + 0xff900000)
+#define   VENC_VDAC_FIFO_CTRL                      (0x1bfc)
+#define P_VENC_VDAC_FIFO_CTRL                      (volatile unsigned int *)((0x1bfc  << 2) + 0xff900000)
+#define   ENCL_TCON_INVERT_CTL                     (0x1bfd)
+#define P_ENCL_TCON_INVERT_CTL                     (volatile unsigned int *)((0x1bfd  << 2) + 0xff900000)
+//
+// Closing file:  venc_regs.h
+//
+//
+// Reading file:  enc480p_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// Video Encoder 480p Registers    0xb80 - 0xbef
+//===========================================================================
+//-------- Video basic setting
+#define   ENCP_VIDEO_EN                            (0x1b80)
+#define P_ENCP_VIDEO_EN                            (volatile unsigned int *)((0x1b80  << 2) + 0xff900000)
+#define   ENCP_VIDEO_SYNC_MODE                     (0x1b81)
+#define P_ENCP_VIDEO_SYNC_MODE                     (volatile unsigned int *)((0x1b81  << 2) + 0xff900000)
+#define   ENCP_MACV_EN                             (0x1b82)
+#define P_ENCP_MACV_EN                             (volatile unsigned int *)((0x1b82  << 2) + 0xff900000)
+#define   ENCP_VIDEO_Y_SCL                         (0x1b83)
+#define P_ENCP_VIDEO_Y_SCL                         (volatile unsigned int *)((0x1b83  << 2) + 0xff900000)
+#define   ENCP_VIDEO_PB_SCL                        (0x1b84)
+#define P_ENCP_VIDEO_PB_SCL                        (volatile unsigned int *)((0x1b84  << 2) + 0xff900000)
+#define   ENCP_VIDEO_PR_SCL                        (0x1b85)
+#define P_ENCP_VIDEO_PR_SCL                        (volatile unsigned int *)((0x1b85  << 2) + 0xff900000)
+#define   ENCP_VIDEO_SYNC_SCL                      (0x1b86)
+#define P_ENCP_VIDEO_SYNC_SCL                      (volatile unsigned int *)((0x1b86  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MACV_SCL                      (0x1b87)
+#define P_ENCP_VIDEO_MACV_SCL                      (volatile unsigned int *)((0x1b87  << 2) + 0xff900000)
+#define   ENCP_VIDEO_Y_OFFST                       (0x1b88)
+#define P_ENCP_VIDEO_Y_OFFST                       (volatile unsigned int *)((0x1b88  << 2) + 0xff900000)
+#define   ENCP_VIDEO_PB_OFFST                      (0x1b89)
+#define P_ENCP_VIDEO_PB_OFFST                      (volatile unsigned int *)((0x1b89  << 2) + 0xff900000)
+#define   ENCP_VIDEO_PR_OFFST                      (0x1b8a)
+#define P_ENCP_VIDEO_PR_OFFST                      (volatile unsigned int *)((0x1b8a  << 2) + 0xff900000)
+#define   ENCP_VIDEO_SYNC_OFFST                    (0x1b8b)
+#define P_ENCP_VIDEO_SYNC_OFFST                    (volatile unsigned int *)((0x1b8b  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MACV_OFFST                    (0x1b8c)
+#define P_ENCP_VIDEO_MACV_OFFST                    (volatile unsigned int *)((0x1b8c  << 2) + 0xff900000)
+//----- Video mode
+#define   ENCP_VIDEO_MODE                          (0x1b8d)
+#define P_ENCP_VIDEO_MODE                          (volatile unsigned int *)((0x1b8d  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MODE_ADV                      (0x1b8e)
+#define P_ENCP_VIDEO_MODE_ADV                      (volatile unsigned int *)((0x1b8e  << 2) + 0xff900000)
+//--------------- Debug pins
+#define   ENCP_DBG_PX_RST                          (0x1b90)
+#define P_ENCP_DBG_PX_RST                          (volatile unsigned int *)((0x1b90  << 2) + 0xff900000)
+#define   ENCP_DBG_LN_RST                          (0x1b91)
+#define P_ENCP_DBG_LN_RST                          (volatile unsigned int *)((0x1b91  << 2) + 0xff900000)
+#define   ENCP_DBG_PX_INT                          (0x1b92)
+#define P_ENCP_DBG_PX_INT                          (volatile unsigned int *)((0x1b92  << 2) + 0xff900000)
+#define   ENCP_DBG_LN_INT                          (0x1b93)
+#define P_ENCP_DBG_LN_INT                          (volatile unsigned int *)((0x1b93  << 2) + 0xff900000)
+//----------- Video Advanced setting
+#define   ENCP_VIDEO_YFP1_HTIME                    (0x1b94)
+#define P_ENCP_VIDEO_YFP1_HTIME                    (volatile unsigned int *)((0x1b94  << 2) + 0xff900000)
+#define   ENCP_VIDEO_YFP2_HTIME                    (0x1b95)
+#define P_ENCP_VIDEO_YFP2_HTIME                    (volatile unsigned int *)((0x1b95  << 2) + 0xff900000)
+#define   ENCP_VIDEO_YC_DLY                        (0x1b96)
+#define P_ENCP_VIDEO_YC_DLY                        (volatile unsigned int *)((0x1b96  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MAX_PXCNT                     (0x1b97)
+#define P_ENCP_VIDEO_MAX_PXCNT                     (volatile unsigned int *)((0x1b97  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HSPULS_BEGIN                  (0x1b98)
+#define P_ENCP_VIDEO_HSPULS_BEGIN                  (volatile unsigned int *)((0x1b98  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HSPULS_END                    (0x1b99)
+#define P_ENCP_VIDEO_HSPULS_END                    (volatile unsigned int *)((0x1b99  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HSPULS_SWITCH                 (0x1b9a)
+#define P_ENCP_VIDEO_HSPULS_SWITCH                 (volatile unsigned int *)((0x1b9a  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSPULS_BEGIN                  (0x1b9b)
+#define P_ENCP_VIDEO_VSPULS_BEGIN                  (volatile unsigned int *)((0x1b9b  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSPULS_END                    (0x1b9c)
+#define P_ENCP_VIDEO_VSPULS_END                    (volatile unsigned int *)((0x1b9c  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSPULS_BLINE                  (0x1b9d)
+#define P_ENCP_VIDEO_VSPULS_BLINE                  (volatile unsigned int *)((0x1b9d  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSPULS_ELINE                  (0x1b9e)
+#define P_ENCP_VIDEO_VSPULS_ELINE                  (volatile unsigned int *)((0x1b9e  << 2) + 0xff900000)
+#define   ENCP_VIDEO_EQPULS_BEGIN                  (0x1b9f)
+#define P_ENCP_VIDEO_EQPULS_BEGIN                  (volatile unsigned int *)((0x1b9f  << 2) + 0xff900000)
+#define   ENCP_VIDEO_EQPULS_END                    (0x1ba0)
+#define P_ENCP_VIDEO_EQPULS_END                    (volatile unsigned int *)((0x1ba0  << 2) + 0xff900000)
+#define   ENCP_VIDEO_EQPULS_BLINE                  (0x1ba1)
+#define P_ENCP_VIDEO_EQPULS_BLINE                  (volatile unsigned int *)((0x1ba1  << 2) + 0xff900000)
+#define   ENCP_VIDEO_EQPULS_ELINE                  (0x1ba2)
+#define P_ENCP_VIDEO_EQPULS_ELINE                  (volatile unsigned int *)((0x1ba2  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HAVON_END                     (0x1ba3)
+#define P_ENCP_VIDEO_HAVON_END                     (volatile unsigned int *)((0x1ba3  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HAVON_BEGIN                   (0x1ba4)
+#define P_ENCP_VIDEO_HAVON_BEGIN                   (volatile unsigned int *)((0x1ba4  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VAVON_ELINE                   (0x1baf)
+#define P_ENCP_VIDEO_VAVON_ELINE                   (volatile unsigned int *)((0x1baf  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VAVON_BLINE                   (0x1ba6)
+#define P_ENCP_VIDEO_VAVON_BLINE                   (volatile unsigned int *)((0x1ba6  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HSO_BEGIN                     (0x1ba7)
+#define P_ENCP_VIDEO_HSO_BEGIN                     (volatile unsigned int *)((0x1ba7  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HSO_END                       (0x1ba8)
+#define P_ENCP_VIDEO_HSO_END                       (volatile unsigned int *)((0x1ba8  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSO_BEGIN                     (0x1ba9)
+#define P_ENCP_VIDEO_VSO_BEGIN                     (volatile unsigned int *)((0x1ba9  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSO_END                       (0x1baa)
+#define P_ENCP_VIDEO_VSO_END                       (volatile unsigned int *)((0x1baa  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSO_BLINE                     (0x1bab)
+#define P_ENCP_VIDEO_VSO_BLINE                     (volatile unsigned int *)((0x1bab  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VSO_ELINE                     (0x1bac)
+#define P_ENCP_VIDEO_VSO_ELINE                     (volatile unsigned int *)((0x1bac  << 2) + 0xff900000)
+#define   ENCP_VIDEO_SYNC_WAVE_CURVE               (0x1bad)
+#define P_ENCP_VIDEO_SYNC_WAVE_CURVE               (volatile unsigned int *)((0x1bad  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MAX_LNCNT                     (0x1bae)
+#define P_ENCP_VIDEO_MAX_LNCNT                     (volatile unsigned int *)((0x1bae  << 2) + 0xff900000)
+#define   ENCP_VIDEO_SY_VAL                        (0x1bb0)
+#define P_ENCP_VIDEO_SY_VAL                        (volatile unsigned int *)((0x1bb0  << 2) + 0xff900000)
+#define   ENCP_VIDEO_SY2_VAL                       (0x1bb1)
+#define P_ENCP_VIDEO_SY2_VAL                       (volatile unsigned int *)((0x1bb1  << 2) + 0xff900000)
+#define   ENCP_VIDEO_BLANKY_VAL                    (0x1bb2)
+#define P_ENCP_VIDEO_BLANKY_VAL                    (volatile unsigned int *)((0x1bb2  << 2) + 0xff900000)
+#define   ENCP_VIDEO_BLANKPB_VAL                   (0x1bb3)
+#define P_ENCP_VIDEO_BLANKPB_VAL                   (volatile unsigned int *)((0x1bb3  << 2) + 0xff900000)
+#define   ENCP_VIDEO_BLANKPR_VAL                   (0x1bb4)
+#define P_ENCP_VIDEO_BLANKPR_VAL                   (volatile unsigned int *)((0x1bb4  << 2) + 0xff900000)
+#define   ENCP_VIDEO_HOFFST                        (0x1bb5)
+#define P_ENCP_VIDEO_HOFFST                        (volatile unsigned int *)((0x1bb5  << 2) + 0xff900000)
+#define   ENCP_VIDEO_VOFFST                        (0x1bb6)
+#define P_ENCP_VIDEO_VOFFST                        (volatile unsigned int *)((0x1bb6  << 2) + 0xff900000)
+#define   ENCP_VIDEO_RGB_CTRL                      (0x1bb7)
+#define P_ENCP_VIDEO_RGB_CTRL                      (volatile unsigned int *)((0x1bb7  << 2) + 0xff900000)
+#define   ENCP_VIDEO_FILT_CTRL                     (0x1bb8)
+#define P_ENCP_VIDEO_FILT_CTRL                     (volatile unsigned int *)((0x1bb8  << 2) + 0xff900000)
+#define   ENCP_VIDEO_OFLD_VPEQ_OFST                (0x1bb9)
+#define P_ENCP_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned int *)((0x1bb9  << 2) + 0xff900000)
+#define   ENCP_VIDEO_OFLD_VOAV_OFST                (0x1bba)
+#define P_ENCP_VIDEO_OFLD_VOAV_OFST                (volatile unsigned int *)((0x1bba  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MATRIX_CB                     (0x1bbb)
+#define P_ENCP_VIDEO_MATRIX_CB                     (volatile unsigned int *)((0x1bbb  << 2) + 0xff900000)
+#define   ENCP_VIDEO_MATRIX_CR                     (0x1bbc)
+#define P_ENCP_VIDEO_MATRIX_CR                     (volatile unsigned int *)((0x1bbc  << 2) + 0xff900000)
+#define   ENCP_VIDEO_RGBIN_CTRL                    (0x1bbd)
+#define P_ENCP_VIDEO_RGBIN_CTRL                    (volatile unsigned int *)((0x1bbd  << 2) + 0xff900000)
+//------------------Macrovision advanced setting
+#define   ENCP_MACV_BLANKY_VAL                     (0x1bc0)
+#define P_ENCP_MACV_BLANKY_VAL                     (volatile unsigned int *)((0x1bc0  << 2) + 0xff900000)
+#define   ENCP_MACV_MAXY_VAL                       (0x1bc1)
+#define P_ENCP_MACV_MAXY_VAL                       (volatile unsigned int *)((0x1bc1  << 2) + 0xff900000)
+#define   ENCP_MACV_1ST_PSSYNC_STRT                (0x1bc2)
+#define P_ENCP_MACV_1ST_PSSYNC_STRT                (volatile unsigned int *)((0x1bc2  << 2) + 0xff900000)
+#define   ENCP_MACV_PSSYNC_STRT                    (0x1bc3)
+#define P_ENCP_MACV_PSSYNC_STRT                    (volatile unsigned int *)((0x1bc3  << 2) + 0xff900000)
+#define   ENCP_MACV_AGC_STRT                       (0x1bc4)
+#define P_ENCP_MACV_AGC_STRT                       (volatile unsigned int *)((0x1bc4  << 2) + 0xff900000)
+#define   ENCP_MACV_AGC_END                        (0x1bc5)
+#define P_ENCP_MACV_AGC_END                        (volatile unsigned int *)((0x1bc5  << 2) + 0xff900000)
+#define   ENCP_MACV_WAVE_END                       (0x1bc6)
+#define P_ENCP_MACV_WAVE_END                       (volatile unsigned int *)((0x1bc6  << 2) + 0xff900000)
+#define   ENCP_MACV_STRTLINE                       (0x1bc7)
+#define P_ENCP_MACV_STRTLINE                       (volatile unsigned int *)((0x1bc7  << 2) + 0xff900000)
+#define   ENCP_MACV_ENDLINE                        (0x1bc8)
+#define P_ENCP_MACV_ENDLINE                        (volatile unsigned int *)((0x1bc8  << 2) + 0xff900000)
+#define   ENCP_MACV_TS_CNT_MAX_L                   (0x1bc9)
+#define P_ENCP_MACV_TS_CNT_MAX_L                   (volatile unsigned int *)((0x1bc9  << 2) + 0xff900000)
+#define   ENCP_MACV_TS_CNT_MAX_H                   (0x1bca)
+#define P_ENCP_MACV_TS_CNT_MAX_H                   (volatile unsigned int *)((0x1bca  << 2) + 0xff900000)
+#define   ENCP_MACV_TIME_DOWN                      (0x1bcb)
+#define P_ENCP_MACV_TIME_DOWN                      (volatile unsigned int *)((0x1bcb  << 2) + 0xff900000)
+#define   ENCP_MACV_TIME_LO                        (0x1bcc)
+#define P_ENCP_MACV_TIME_LO                        (volatile unsigned int *)((0x1bcc  << 2) + 0xff900000)
+#define   ENCP_MACV_TIME_UP                        (0x1bcd)
+#define P_ENCP_MACV_TIME_UP                        (volatile unsigned int *)((0x1bcd  << 2) + 0xff900000)
+#define   ENCP_MACV_TIME_RST                       (0x1bce)
+#define P_ENCP_MACV_TIME_RST                       (volatile unsigned int *)((0x1bce  << 2) + 0xff900000)
+//---------------- VBI control -------------------
+#define   ENCP_VBI_CTRL                            (0x1bd0)
+#define P_ENCP_VBI_CTRL                            (volatile unsigned int *)((0x1bd0  << 2) + 0xff900000)
+#define   ENCP_VBI_SETTING                         (0x1bd1)
+#define P_ENCP_VBI_SETTING                         (volatile unsigned int *)((0x1bd1  << 2) + 0xff900000)
+#define   ENCP_VBI_BEGIN                           (0x1bd2)
+#define P_ENCP_VBI_BEGIN                           (volatile unsigned int *)((0x1bd2  << 2) + 0xff900000)
+#define   ENCP_VBI_WIDTH                           (0x1bd3)
+#define P_ENCP_VBI_WIDTH                           (volatile unsigned int *)((0x1bd3  << 2) + 0xff900000)
+#define   ENCP_VBI_HVAL                            (0x1bd4)
+#define P_ENCP_VBI_HVAL                            (volatile unsigned int *)((0x1bd4  << 2) + 0xff900000)
+#define   ENCP_VBI_DATA0                           (0x1bd5)
+#define P_ENCP_VBI_DATA0                           (volatile unsigned int *)((0x1bd5  << 2) + 0xff900000)
+#define   ENCP_VBI_DATA1                           (0x1bd6)
+#define P_ENCP_VBI_DATA1                           (volatile unsigned int *)((0x1bd6  << 2) + 0xff900000)
+//----------------C656 OUT Control------------- Grant
+#define   C656_HS_ST                               (0x1be0)
+#define P_C656_HS_ST                               (volatile unsigned int *)((0x1be0  << 2) + 0xff900000)
+#define   C656_HS_ED                               (0x1be1)
+#define P_C656_HS_ED                               (volatile unsigned int *)((0x1be1  << 2) + 0xff900000)
+#define   C656_VS_LNST_E                           (0x1be2)
+#define P_C656_VS_LNST_E                           (volatile unsigned int *)((0x1be2  << 2) + 0xff900000)
+#define   C656_VS_LNST_O                           (0x1be3)
+#define P_C656_VS_LNST_O                           (volatile unsigned int *)((0x1be3  << 2) + 0xff900000)
+#define   C656_VS_LNED_E                           (0x1be4)
+#define P_C656_VS_LNED_E                           (volatile unsigned int *)((0x1be4  << 2) + 0xff900000)
+#define   C656_VS_LNED_O                           (0x1be5)
+#define P_C656_VS_LNED_O                           (volatile unsigned int *)((0x1be5  << 2) + 0xff900000)
+#define   C656_FS_LNST                             (0x1be6)
+#define P_C656_FS_LNST                             (volatile unsigned int *)((0x1be6  << 2) + 0xff900000)
+#define   C656_FS_LNED                             (0x1be7)
+#define P_C656_FS_LNED                             (volatile unsigned int *)((0x1be7  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  enc480p_regs.h
+//
+//
+// Reading file:  enci_regs.h
+//
+//===========================================================================
+// Video Interface Registers    0xb00 - 0xb57
+//===========================================================================
+#define   ENCI_VIDEO_MODE                          (0x1b00)
+#define P_ENCI_VIDEO_MODE                          (volatile unsigned int *)((0x1b00  << 2) + 0xff900000)
+#define   ENCI_VIDEO_MODE_ADV                      (0x1b01)
+#define P_ENCI_VIDEO_MODE_ADV                      (volatile unsigned int *)((0x1b01  << 2) + 0xff900000)
+#define   ENCI_VIDEO_FSC_ADJ                       (0x1b02)
+#define P_ENCI_VIDEO_FSC_ADJ                       (volatile unsigned int *)((0x1b02  << 2) + 0xff900000)
+#define   ENCI_VIDEO_BRIGHT                        (0x1b03)
+#define P_ENCI_VIDEO_BRIGHT                        (volatile unsigned int *)((0x1b03  << 2) + 0xff900000)
+#define   ENCI_VIDEO_CONT                          (0x1b04)
+#define P_ENCI_VIDEO_CONT                          (volatile unsigned int *)((0x1b04  << 2) + 0xff900000)
+#define   ENCI_VIDEO_SAT                           (0x1b05)
+#define P_ENCI_VIDEO_SAT                           (volatile unsigned int *)((0x1b05  << 2) + 0xff900000)
+#define   ENCI_VIDEO_HUE                           (0x1b06)
+#define P_ENCI_VIDEO_HUE                           (volatile unsigned int *)((0x1b06  << 2) + 0xff900000)
+#define   ENCI_VIDEO_SCH                           (0x1b07)
+#define P_ENCI_VIDEO_SCH                           (volatile unsigned int *)((0x1b07  << 2) + 0xff900000)
+#define   ENCI_SYNC_MODE                           (0x1b08)
+#define P_ENCI_SYNC_MODE                           (volatile unsigned int *)((0x1b08  << 2) + 0xff900000)
+#define   ENCI_SYNC_CTRL                           (0x1b09)
+#define P_ENCI_SYNC_CTRL                           (volatile unsigned int *)((0x1b09  << 2) + 0xff900000)
+#define   ENCI_SYNC_HSO_BEGIN                      (0x1b0a)
+#define P_ENCI_SYNC_HSO_BEGIN                      (volatile unsigned int *)((0x1b0a  << 2) + 0xff900000)
+#define   ENCI_SYNC_HSO_END                        (0x1b0b)
+#define P_ENCI_SYNC_HSO_END                        (volatile unsigned int *)((0x1b0b  << 2) + 0xff900000)
+#define   ENCI_SYNC_VSO_EVN                        (0x1b0c)
+#define P_ENCI_SYNC_VSO_EVN                        (volatile unsigned int *)((0x1b0c  << 2) + 0xff900000)
+#define   ENCI_SYNC_VSO_ODD                        (0x1b0d)
+#define P_ENCI_SYNC_VSO_ODD                        (volatile unsigned int *)((0x1b0d  << 2) + 0xff900000)
+#define   ENCI_SYNC_VSO_EVNLN                      (0x1b0e)
+#define P_ENCI_SYNC_VSO_EVNLN                      (volatile unsigned int *)((0x1b0e  << 2) + 0xff900000)
+#define   ENCI_SYNC_VSO_ODDLN                      (0x1b0f)
+#define P_ENCI_SYNC_VSO_ODDLN                      (volatile unsigned int *)((0x1b0f  << 2) + 0xff900000)
+#define   ENCI_SYNC_HOFFST                         (0x1b10)
+#define P_ENCI_SYNC_HOFFST                         (volatile unsigned int *)((0x1b10  << 2) + 0xff900000)
+#define   ENCI_SYNC_VOFFST                         (0x1b11)
+#define P_ENCI_SYNC_VOFFST                         (volatile unsigned int *)((0x1b11  << 2) + 0xff900000)
+#define   ENCI_SYNC_ADJ                            (0x1b12)
+#define P_ENCI_SYNC_ADJ                            (volatile unsigned int *)((0x1b12  << 2) + 0xff900000)
+#define   ENCI_RGB_SETTING                         (0x1b13)
+#define P_ENCI_RGB_SETTING                         (volatile unsigned int *)((0x1b13  << 2) + 0xff900000)
+//`define	ENCI_CMPN_MATRIX_CB		8'h14
+//`define	ENCI_CMPN_MATRIX_CR		8'h15
+#define   ENCI_DE_H_BEGIN                          (0x1b16)
+#define P_ENCI_DE_H_BEGIN                          (volatile unsigned int *)((0x1b16  << 2) + 0xff900000)
+#define   ENCI_DE_H_END                            (0x1b17)
+#define P_ENCI_DE_H_END                            (volatile unsigned int *)((0x1b17  << 2) + 0xff900000)
+#define   ENCI_DE_V_BEGIN_EVEN                     (0x1b18)
+#define P_ENCI_DE_V_BEGIN_EVEN                     (volatile unsigned int *)((0x1b18  << 2) + 0xff900000)
+#define   ENCI_DE_V_END_EVEN                       (0x1b19)
+#define P_ENCI_DE_V_END_EVEN                       (volatile unsigned int *)((0x1b19  << 2) + 0xff900000)
+#define   ENCI_DE_V_BEGIN_ODD                      (0x1b1a)
+#define P_ENCI_DE_V_BEGIN_ODD                      (volatile unsigned int *)((0x1b1a  << 2) + 0xff900000)
+#define   ENCI_DE_V_END_ODD                        (0x1b1b)
+#define P_ENCI_DE_V_END_ODD                        (volatile unsigned int *)((0x1b1b  << 2) + 0xff900000)
+#define   ENCI_VBI_SETTING                         (0x1b20)
+#define P_ENCI_VBI_SETTING                         (volatile unsigned int *)((0x1b20  << 2) + 0xff900000)
+#define   ENCI_VBI_CCDT_EVN                        (0x1b21)
+#define P_ENCI_VBI_CCDT_EVN                        (volatile unsigned int *)((0x1b21  << 2) + 0xff900000)
+#define   ENCI_VBI_CCDT_ODD                        (0x1b22)
+#define P_ENCI_VBI_CCDT_ODD                        (volatile unsigned int *)((0x1b22  << 2) + 0xff900000)
+#define   ENCI_VBI_CC525_LN                        (0x1b23)
+#define P_ENCI_VBI_CC525_LN                        (volatile unsigned int *)((0x1b23  << 2) + 0xff900000)
+#define   ENCI_VBI_CC625_LN                        (0x1b24)
+#define P_ENCI_VBI_CC625_LN                        (volatile unsigned int *)((0x1b24  << 2) + 0xff900000)
+#define   ENCI_VBI_WSSDT                           (0x1b25)
+#define P_ENCI_VBI_WSSDT                           (volatile unsigned int *)((0x1b25  << 2) + 0xff900000)
+#define   ENCI_VBI_WSS_LN                          (0x1b26)
+#define P_ENCI_VBI_WSS_LN                          (volatile unsigned int *)((0x1b26  << 2) + 0xff900000)
+#define   ENCI_VBI_CGMSDT_L                        (0x1b27)
+#define P_ENCI_VBI_CGMSDT_L                        (volatile unsigned int *)((0x1b27  << 2) + 0xff900000)
+#define   ENCI_VBI_CGMSDT_H                        (0x1b28)
+#define P_ENCI_VBI_CGMSDT_H                        (volatile unsigned int *)((0x1b28  << 2) + 0xff900000)
+#define   ENCI_VBI_CGMS_LN                         (0x1b29)
+#define P_ENCI_VBI_CGMS_LN                         (volatile unsigned int *)((0x1b29  << 2) + 0xff900000)
+#define   ENCI_VBI_TTX_HTIME                       (0x1b2a)
+#define P_ENCI_VBI_TTX_HTIME                       (volatile unsigned int *)((0x1b2a  << 2) + 0xff900000)
+#define   ENCI_VBI_TTX_LN                          (0x1b2b)
+#define P_ENCI_VBI_TTX_LN                          (volatile unsigned int *)((0x1b2b  << 2) + 0xff900000)
+#define   ENCI_VBI_TTXDT0                          (0x1b2c)
+#define P_ENCI_VBI_TTXDT0                          (volatile unsigned int *)((0x1b2c  << 2) + 0xff900000)
+#define   ENCI_VBI_TTXDT1                          (0x1b2d)
+#define P_ENCI_VBI_TTXDT1                          (volatile unsigned int *)((0x1b2d  << 2) + 0xff900000)
+#define   ENCI_VBI_TTXDT2                          (0x1b2e)
+#define P_ENCI_VBI_TTXDT2                          (volatile unsigned int *)((0x1b2e  << 2) + 0xff900000)
+#define   ENCI_VBI_TTXDT3                          (0x1b2f)
+#define P_ENCI_VBI_TTXDT3                          (volatile unsigned int *)((0x1b2f  << 2) + 0xff900000)
+#define   ENCI_MACV_N0                             (0x1b30)
+#define P_ENCI_MACV_N0                             (volatile unsigned int *)((0x1b30  << 2) + 0xff900000)
+#define   ENCI_MACV_N1                             (0x1b31)
+#define P_ENCI_MACV_N1                             (volatile unsigned int *)((0x1b31  << 2) + 0xff900000)
+#define   ENCI_MACV_N2                             (0x1b32)
+#define P_ENCI_MACV_N2                             (volatile unsigned int *)((0x1b32  << 2) + 0xff900000)
+#define   ENCI_MACV_N3                             (0x1b33)
+#define P_ENCI_MACV_N3                             (volatile unsigned int *)((0x1b33  << 2) + 0xff900000)
+#define   ENCI_MACV_N4                             (0x1b34)
+#define P_ENCI_MACV_N4                             (volatile unsigned int *)((0x1b34  << 2) + 0xff900000)
+#define   ENCI_MACV_N5                             (0x1b35)
+#define P_ENCI_MACV_N5                             (volatile unsigned int *)((0x1b35  << 2) + 0xff900000)
+#define   ENCI_MACV_N6                             (0x1b36)
+#define P_ENCI_MACV_N6                             (volatile unsigned int *)((0x1b36  << 2) + 0xff900000)
+#define   ENCI_MACV_N7                             (0x1b37)
+#define P_ENCI_MACV_N7                             (volatile unsigned int *)((0x1b37  << 2) + 0xff900000)
+#define   ENCI_MACV_N8                             (0x1b38)
+#define P_ENCI_MACV_N8                             (volatile unsigned int *)((0x1b38  << 2) + 0xff900000)
+#define   ENCI_MACV_N9                             (0x1b39)
+#define P_ENCI_MACV_N9                             (volatile unsigned int *)((0x1b39  << 2) + 0xff900000)
+#define   ENCI_MACV_N10                            (0x1b3a)
+#define P_ENCI_MACV_N10                            (volatile unsigned int *)((0x1b3a  << 2) + 0xff900000)
+#define   ENCI_MACV_N11                            (0x1b3b)
+#define P_ENCI_MACV_N11                            (volatile unsigned int *)((0x1b3b  << 2) + 0xff900000)
+#define   ENCI_MACV_N12                            (0x1b3c)
+#define P_ENCI_MACV_N12                            (volatile unsigned int *)((0x1b3c  << 2) + 0xff900000)
+#define   ENCI_MACV_N13                            (0x1b3d)
+#define P_ENCI_MACV_N13                            (volatile unsigned int *)((0x1b3d  << 2) + 0xff900000)
+#define   ENCI_MACV_N14                            (0x1b3e)
+#define P_ENCI_MACV_N14                            (volatile unsigned int *)((0x1b3e  << 2) + 0xff900000)
+#define   ENCI_MACV_N15                            (0x1b3f)
+#define P_ENCI_MACV_N15                            (volatile unsigned int *)((0x1b3f  << 2) + 0xff900000)
+#define   ENCI_MACV_N16                            (0x1b40)
+#define P_ENCI_MACV_N16                            (volatile unsigned int *)((0x1b40  << 2) + 0xff900000)
+#define   ENCI_MACV_N17                            (0x1b41)
+#define P_ENCI_MACV_N17                            (volatile unsigned int *)((0x1b41  << 2) + 0xff900000)
+#define   ENCI_MACV_N18                            (0x1b42)
+#define P_ENCI_MACV_N18                            (volatile unsigned int *)((0x1b42  << 2) + 0xff900000)
+#define   ENCI_MACV_N19                            (0x1b43)
+#define P_ENCI_MACV_N19                            (volatile unsigned int *)((0x1b43  << 2) + 0xff900000)
+#define   ENCI_MACV_N20                            (0x1b44)
+#define P_ENCI_MACV_N20                            (volatile unsigned int *)((0x1b44  << 2) + 0xff900000)
+#define   ENCI_MACV_N21                            (0x1b45)
+#define P_ENCI_MACV_N21                            (volatile unsigned int *)((0x1b45  << 2) + 0xff900000)
+#define   ENCI_MACV_N22                            (0x1b46)
+#define P_ENCI_MACV_N22                            (volatile unsigned int *)((0x1b46  << 2) + 0xff900000)
+//`define	ENCI_MACV_P_AGC			8'h47
+#define   ENCI_DBG_PX_RST                          (0x1b48)
+#define P_ENCI_DBG_PX_RST                          (volatile unsigned int *)((0x1b48  << 2) + 0xff900000)
+#define   ENCI_DBG_FLDLN_RST                       (0x1b49)
+#define P_ENCI_DBG_FLDLN_RST                       (volatile unsigned int *)((0x1b49  << 2) + 0xff900000)
+#define   ENCI_DBG_PX_INT                          (0x1b4a)
+#define P_ENCI_DBG_PX_INT                          (volatile unsigned int *)((0x1b4a  << 2) + 0xff900000)
+#define   ENCI_DBG_FLDLN_INT                       (0x1b4b)
+#define P_ENCI_DBG_FLDLN_INT                       (volatile unsigned int *)((0x1b4b  << 2) + 0xff900000)
+#define   ENCI_DBG_MAXPX                           (0x1b4c)
+#define P_ENCI_DBG_MAXPX                           (volatile unsigned int *)((0x1b4c  << 2) + 0xff900000)
+#define   ENCI_DBG_MAXLN                           (0x1b4d)
+#define P_ENCI_DBG_MAXLN                           (volatile unsigned int *)((0x1b4d  << 2) + 0xff900000)
+#define   ENCI_MACV_MAX_AMP                        (0x1b50)
+#define P_ENCI_MACV_MAX_AMP                        (volatile unsigned int *)((0x1b50  << 2) + 0xff900000)
+#define   ENCI_MACV_PULSE_LO                       (0x1b51)
+#define P_ENCI_MACV_PULSE_LO                       (volatile unsigned int *)((0x1b51  << 2) + 0xff900000)
+#define   ENCI_MACV_PULSE_HI                       (0x1b52)
+#define P_ENCI_MACV_PULSE_HI                       (volatile unsigned int *)((0x1b52  << 2) + 0xff900000)
+#define   ENCI_MACV_BKP_MAX                        (0x1b53)
+#define P_ENCI_MACV_BKP_MAX                        (volatile unsigned int *)((0x1b53  << 2) + 0xff900000)
+#define   ENCI_CFILT_CTRL                          (0x1b54)
+#define P_ENCI_CFILT_CTRL                          (volatile unsigned int *)((0x1b54  << 2) + 0xff900000)
+#define   ENCI_CFILT7                              (0x1b55)
+#define P_ENCI_CFILT7                              (volatile unsigned int *)((0x1b55  << 2) + 0xff900000)
+#define   ENCI_YC_DELAY                            (0x1b56)
+#define P_ENCI_YC_DELAY                            (volatile unsigned int *)((0x1b56  << 2) + 0xff900000)
+#define   ENCI_VIDEO_EN                            (0x1b57)
+#define P_ENCI_VIDEO_EN                            (volatile unsigned int *)((0x1b57  << 2) + 0xff900000)
+//
+// Closing file:  enci_regs.h
+//
+//`define  VENC2_VCBUS_BASE             8'h1c
+//
+// Reading file:  venc2_regs.h
+//
+//===========================================================================
+// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef)
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VENC2_VCBUS_BASE = 0x1c
+// -----------------------------------------------
+// Program video control signals from ENCI core to DVI/HDMI interface
+#define   ENCI_DVI_HSO_BEGIN                       (0x1c00)
+#define P_ENCI_DVI_HSO_BEGIN                       (volatile unsigned int *)((0x1c00  << 2) + 0xff900000)
+#define   ENCI_DVI_HSO_END                         (0x1c01)
+#define P_ENCI_DVI_HSO_END                         (volatile unsigned int *)((0x1c01  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_BLINE_EVN                   (0x1c02)
+#define P_ENCI_DVI_VSO_BLINE_EVN                   (volatile unsigned int *)((0x1c02  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_BLINE_ODD                   (0x1c03)
+#define P_ENCI_DVI_VSO_BLINE_ODD                   (volatile unsigned int *)((0x1c03  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_ELINE_EVN                   (0x1c04)
+#define P_ENCI_DVI_VSO_ELINE_EVN                   (volatile unsigned int *)((0x1c04  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_ELINE_ODD                   (0x1c05)
+#define P_ENCI_DVI_VSO_ELINE_ODD                   (volatile unsigned int *)((0x1c05  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_BEGIN_EVN                   (0x1c06)
+#define P_ENCI_DVI_VSO_BEGIN_EVN                   (volatile unsigned int *)((0x1c06  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_BEGIN_ODD                   (0x1c07)
+#define P_ENCI_DVI_VSO_BEGIN_ODD                   (volatile unsigned int *)((0x1c07  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_END_EVN                     (0x1c08)
+#define P_ENCI_DVI_VSO_END_EVN                     (volatile unsigned int *)((0x1c08  << 2) + 0xff900000)
+#define   ENCI_DVI_VSO_END_ODD                     (0x1c09)
+#define P_ENCI_DVI_VSO_END_ODD                     (volatile unsigned int *)((0x1c09  << 2) + 0xff900000)
+// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
+// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+#define   ENCI_CFILT_CTRL2                         (0x1c0a)
+#define P_ENCI_CFILT_CTRL2                         (volatile unsigned int *)((0x1c0a  << 2) + 0xff900000)
+#define   ENCI_DACSEL_0                            (0x1c0b)
+#define P_ENCI_DACSEL_0                            (volatile unsigned int *)((0x1c0b  << 2) + 0xff900000)
+#define   ENCI_DACSEL_1                            (0x1c0c)
+#define P_ENCI_DACSEL_1                            (volatile unsigned int *)((0x1c0c  << 2) + 0xff900000)
+#define   ENCP_DACSEL_0                            (0x1c0d)
+#define P_ENCP_DACSEL_0                            (volatile unsigned int *)((0x1c0d  << 2) + 0xff900000)
+#define   ENCP_DACSEL_1                            (0x1c0e)
+#define P_ENCP_DACSEL_1                            (volatile unsigned int *)((0x1c0e  << 2) + 0xff900000)
+#define   ENCP_MAX_LINE_SWITCH_POINT               (0x1c0f)
+#define P_ENCP_MAX_LINE_SWITCH_POINT               (volatile unsigned int *)((0x1c0f  << 2) + 0xff900000)
+#define   ENCI_TST_EN                              (0x1c10)
+#define P_ENCI_TST_EN                              (volatile unsigned int *)((0x1c10  << 2) + 0xff900000)
+#define   ENCI_TST_MDSEL                           (0x1c11)
+#define P_ENCI_TST_MDSEL                           (volatile unsigned int *)((0x1c11  << 2) + 0xff900000)
+#define   ENCI_TST_Y                               (0x1c12)
+#define P_ENCI_TST_Y                               (volatile unsigned int *)((0x1c12  << 2) + 0xff900000)
+#define   ENCI_TST_CB                              (0x1c13)
+#define P_ENCI_TST_CB                              (volatile unsigned int *)((0x1c13  << 2) + 0xff900000)
+#define   ENCI_TST_CR                              (0x1c14)
+#define P_ENCI_TST_CR                              (volatile unsigned int *)((0x1c14  << 2) + 0xff900000)
+#define   ENCI_TST_CLRBAR_STRT                     (0x1c15)
+#define P_ENCI_TST_CLRBAR_STRT                     (volatile unsigned int *)((0x1c15  << 2) + 0xff900000)
+#define   ENCI_TST_CLRBAR_WIDTH                    (0x1c16)
+#define P_ENCI_TST_CLRBAR_WIDTH                    (volatile unsigned int *)((0x1c16  << 2) + 0xff900000)
+#define   ENCI_TST_VDCNT_STSET                     (0x1c17)
+#define P_ENCI_TST_VDCNT_STSET                     (volatile unsigned int *)((0x1c17  << 2) + 0xff900000)
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 7 -- vfifo2vd_drop
+// bit 6:1 -- vfifo2vd_delay
+// bit 0 -- vfifo2vd_en
+#define   ENCI_VFIFO2VD_CTL                        (0x1c18)
+#define P_ENCI_VFIFO2VD_CTL                        (volatile unsigned int *)((0x1c18  << 2) + 0xff900000)
+// bit 12:0 -- vfifo2vd_pixel_start
+#define   ENCI_VFIFO2VD_PIXEL_START                (0x1c19)
+#define P_ENCI_VFIFO2VD_PIXEL_START                (volatile unsigned int *)((0x1c19  << 2) + 0xff900000)
+// bit 12:00 -- vfifo2vd_pixel_end
+#define   ENCI_VFIFO2VD_PIXEL_END                  (0x1c1a)
+#define P_ENCI_VFIFO2VD_PIXEL_END                  (volatile unsigned int *)((0x1c1a  << 2) + 0xff900000)
+// bit 10:0 -- vfifo2vd_line_top_start
+#define   ENCI_VFIFO2VD_LINE_TOP_START             (0x1c1b)
+#define P_ENCI_VFIFO2VD_LINE_TOP_START             (volatile unsigned int *)((0x1c1b  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_top_end
+#define   ENCI_VFIFO2VD_LINE_TOP_END               (0x1c1c)
+#define P_ENCI_VFIFO2VD_LINE_TOP_END               (volatile unsigned int *)((0x1c1c  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_start
+#define   ENCI_VFIFO2VD_LINE_BOT_START             (0x1c1d)
+#define P_ENCI_VFIFO2VD_LINE_BOT_START             (volatile unsigned int *)((0x1c1d  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_end
+#define   ENCI_VFIFO2VD_LINE_BOT_END               (0x1c1e)
+#define P_ENCI_VFIFO2VD_LINE_BOT_END               (volatile unsigned int *)((0x1c1e  << 2) + 0xff900000)
+#define   ENCI_VFIFO2VD_CTL2                       (0x1c1f)
+#define P_ENCI_VFIFO2VD_CTL2                       (volatile unsigned int *)((0x1c1f  << 2) + 0xff900000)
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 7 -- vfifo2vd_drop
+// bit 6:1 -- vfifo2vd_delay
+// bit 0 -- vfifo2vd_en
+#define   ENCT_VFIFO2VD_CTL                        (0x1c20)
+#define P_ENCT_VFIFO2VD_CTL                        (volatile unsigned int *)((0x1c20  << 2) + 0xff900000)
+// bit 12:0 -- vfifo2vd_pixel_start
+#define   ENCT_VFIFO2VD_PIXEL_START                (0x1c21)
+#define P_ENCT_VFIFO2VD_PIXEL_START                (volatile unsigned int *)((0x1c21  << 2) + 0xff900000)
+// bit 12:00 -- vfifo2vd_pixel_end
+#define   ENCT_VFIFO2VD_PIXEL_END                  (0x1c22)
+#define P_ENCT_VFIFO2VD_PIXEL_END                  (volatile unsigned int *)((0x1c22  << 2) + 0xff900000)
+// bit 10:0 -- vfifo2vd_line_top_start
+#define   ENCT_VFIFO2VD_LINE_TOP_START             (0x1c23)
+#define P_ENCT_VFIFO2VD_LINE_TOP_START             (volatile unsigned int *)((0x1c23  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_top_end
+#define   ENCT_VFIFO2VD_LINE_TOP_END               (0x1c24)
+#define P_ENCT_VFIFO2VD_LINE_TOP_END               (volatile unsigned int *)((0x1c24  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_start
+#define   ENCT_VFIFO2VD_LINE_BOT_START             (0x1c25)
+#define P_ENCT_VFIFO2VD_LINE_BOT_START             (volatile unsigned int *)((0x1c25  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_end
+#define   ENCT_VFIFO2VD_LINE_BOT_END               (0x1c26)
+#define P_ENCT_VFIFO2VD_LINE_BOT_END               (volatile unsigned int *)((0x1c26  << 2) + 0xff900000)
+#define   ENCT_VFIFO2VD_CTL2                       (0x1c27)
+#define P_ENCT_VFIFO2VD_CTL2                       (volatile unsigned int *)((0x1c27  << 2) + 0xff900000)
+#define   ENCT_TST_EN                              (0x1c28)
+#define P_ENCT_TST_EN                              (volatile unsigned int *)((0x1c28  << 2) + 0xff900000)
+#define   ENCT_TST_MDSEL                           (0x1c29)
+#define P_ENCT_TST_MDSEL                           (volatile unsigned int *)((0x1c29  << 2) + 0xff900000)
+#define   ENCT_TST_Y                               (0x1c2a)
+#define P_ENCT_TST_Y                               (volatile unsigned int *)((0x1c2a  << 2) + 0xff900000)
+#define   ENCT_TST_CB                              (0x1c2b)
+#define P_ENCT_TST_CB                              (volatile unsigned int *)((0x1c2b  << 2) + 0xff900000)
+#define   ENCT_TST_CR                              (0x1c2c)
+#define P_ENCT_TST_CR                              (volatile unsigned int *)((0x1c2c  << 2) + 0xff900000)
+#define   ENCT_TST_CLRBAR_STRT                     (0x1c2d)
+#define P_ENCT_TST_CLRBAR_STRT                     (volatile unsigned int *)((0x1c2d  << 2) + 0xff900000)
+#define   ENCT_TST_CLRBAR_WIDTH                    (0x1c2e)
+#define P_ENCT_TST_CLRBAR_WIDTH                    (volatile unsigned int *)((0x1c2e  << 2) + 0xff900000)
+#define   ENCT_TST_VDCNT_STSET                     (0x1c2f)
+#define P_ENCT_TST_VDCNT_STSET                     (volatile unsigned int *)((0x1c2f  << 2) + 0xff900000)
+// Program video control signals from ENCP core to DVI/HDMI interface
+#define   ENCP_DVI_HSO_BEGIN                       (0x1c30)
+#define P_ENCP_DVI_HSO_BEGIN                       (volatile unsigned int *)((0x1c30  << 2) + 0xff900000)
+#define   ENCP_DVI_HSO_END                         (0x1c31)
+#define P_ENCP_DVI_HSO_END                         (volatile unsigned int *)((0x1c31  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_BLINE_EVN                   (0x1c32)
+#define P_ENCP_DVI_VSO_BLINE_EVN                   (volatile unsigned int *)((0x1c32  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_BLINE_ODD                   (0x1c33)
+#define P_ENCP_DVI_VSO_BLINE_ODD                   (volatile unsigned int *)((0x1c33  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_ELINE_EVN                   (0x1c34)
+#define P_ENCP_DVI_VSO_ELINE_EVN                   (volatile unsigned int *)((0x1c34  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_ELINE_ODD                   (0x1c35)
+#define P_ENCP_DVI_VSO_ELINE_ODD                   (volatile unsigned int *)((0x1c35  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_BEGIN_EVN                   (0x1c36)
+#define P_ENCP_DVI_VSO_BEGIN_EVN                   (volatile unsigned int *)((0x1c36  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_BEGIN_ODD                   (0x1c37)
+#define P_ENCP_DVI_VSO_BEGIN_ODD                   (volatile unsigned int *)((0x1c37  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_END_EVN                     (0x1c38)
+#define P_ENCP_DVI_VSO_END_EVN                     (volatile unsigned int *)((0x1c38  << 2) + 0xff900000)
+#define   ENCP_DVI_VSO_END_ODD                     (0x1c39)
+#define P_ENCP_DVI_VSO_END_ODD                     (volatile unsigned int *)((0x1c39  << 2) + 0xff900000)
+#define   ENCP_DE_H_BEGIN                          (0x1c3a)
+#define P_ENCP_DE_H_BEGIN                          (volatile unsigned int *)((0x1c3a  << 2) + 0xff900000)
+#define   ENCP_DE_H_END                            (0x1c3b)
+#define P_ENCP_DE_H_END                            (volatile unsigned int *)((0x1c3b  << 2) + 0xff900000)
+#define   ENCP_DE_V_BEGIN_EVEN                     (0x1c3c)
+#define P_ENCP_DE_V_BEGIN_EVEN                     (volatile unsigned int *)((0x1c3c  << 2) + 0xff900000)
+#define   ENCP_DE_V_END_EVEN                       (0x1c3d)
+#define P_ENCP_DE_V_END_EVEN                       (volatile unsigned int *)((0x1c3d  << 2) + 0xff900000)
+#define   ENCP_DE_V_BEGIN_ODD                      (0x1c3e)
+#define P_ENCP_DE_V_BEGIN_ODD                      (volatile unsigned int *)((0x1c3e  << 2) + 0xff900000)
+#define   ENCP_DE_V_END_ODD                        (0x1c3f)
+#define P_ENCP_DE_V_END_ODD                        (volatile unsigned int *)((0x1c3f  << 2) + 0xff900000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define   ENCI_SYNC_LINE_LENGTH                    (0x1c40)
+#define P_ENCI_SYNC_LINE_LENGTH                    (volatile unsigned int *)((0x1c40  << 2) + 0xff900000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define   ENCI_SYNC_PIXEL_EN                       (0x1c41)
+#define P_ENCI_SYNC_PIXEL_EN                       (volatile unsigned int *)((0x1c41  << 2) + 0xff900000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define   ENCI_SYNC_TO_LINE_EN                     (0x1c42)
+#define P_ENCI_SYNC_TO_LINE_EN                     (volatile unsigned int *)((0x1c42  << 2) + 0xff900000)
+// Bit 12:0 - sync target pixel
+#define   ENCI_SYNC_TO_PIXEL                       (0x1c43)
+#define P_ENCI_SYNC_TO_PIXEL                       (volatile unsigned int *)((0x1c43  << 2) + 0xff900000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define   ENCP_SYNC_LINE_LENGTH                    (0x1c44)
+#define P_ENCP_SYNC_LINE_LENGTH                    (volatile unsigned int *)((0x1c44  << 2) + 0xff900000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define   ENCP_SYNC_PIXEL_EN                       (0x1c45)
+#define P_ENCP_SYNC_PIXEL_EN                       (volatile unsigned int *)((0x1c45  << 2) + 0xff900000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define   ENCP_SYNC_TO_LINE_EN                     (0x1c46)
+#define P_ENCP_SYNC_TO_LINE_EN                     (volatile unsigned int *)((0x1c46  << 2) + 0xff900000)
+// Bit 12:0 - sync target pixel
+#define   ENCP_SYNC_TO_PIXEL                       (0x1c47)
+#define P_ENCP_SYNC_TO_PIXEL                       (volatile unsigned int *)((0x1c47  << 2) + 0xff900000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define   ENCT_SYNC_LINE_LENGTH                    (0x1c48)
+#define P_ENCT_SYNC_LINE_LENGTH                    (volatile unsigned int *)((0x1c48  << 2) + 0xff900000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define   ENCT_SYNC_PIXEL_EN                       (0x1c49)
+#define P_ENCT_SYNC_PIXEL_EN                       (volatile unsigned int *)((0x1c49  << 2) + 0xff900000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define   ENCT_SYNC_TO_LINE_EN                     (0x1c4a)
+#define P_ENCT_SYNC_TO_LINE_EN                     (volatile unsigned int *)((0x1c4a  << 2) + 0xff900000)
+// Bit 12:0 - sync target pixel
+#define   ENCT_SYNC_TO_PIXEL                       (0x1c4b)
+#define P_ENCT_SYNC_TO_PIXEL                       (volatile unsigned int *)((0x1c4b  << 2) + 0xff900000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define   ENCL_SYNC_LINE_LENGTH                    (0x1c4c)
+#define P_ENCL_SYNC_LINE_LENGTH                    (volatile unsigned int *)((0x1c4c  << 2) + 0xff900000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define   ENCL_SYNC_PIXEL_EN                       (0x1c4d)
+#define P_ENCL_SYNC_PIXEL_EN                       (volatile unsigned int *)((0x1c4d  << 2) + 0xff900000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define   ENCL_SYNC_TO_LINE_EN                     (0x1c4e)
+#define P_ENCL_SYNC_TO_LINE_EN                     (volatile unsigned int *)((0x1c4e  << 2) + 0xff900000)
+// Bit 12:0 - sync target pixel
+#define   ENCL_SYNC_TO_PIXEL                       (0x1c4f)
+#define P_ENCL_SYNC_TO_PIXEL                       (volatile unsigned int *)((0x1c4f  << 2) + 0xff900000)
+// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
+//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
+// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
+//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
+// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
+//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
+// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
+//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
+#define   ENCP_VFIFO2VD_CTL2                       (0x1c50)
+#define P_ENCP_VFIFO2VD_CTL2                       (volatile unsigned int *)((0x1c50  << 2) + 0xff900000)
+// bit 15:1 Reserved.
+// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
+//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
+//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
+//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
+#define   VENC_DVI_SETTING_MORE                    (0x1c51)
+#define P_VENC_DVI_SETTING_MORE                    (volatile unsigned int *)((0x1c51  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC4_FILT_CTRL0                (0x1c54)
+#define P_VENC_VDAC_DAC4_FILT_CTRL0                (volatile unsigned int *)((0x1c54  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC4_FILT_CTRL1                (0x1c55)
+#define P_VENC_VDAC_DAC4_FILT_CTRL1                (volatile unsigned int *)((0x1c55  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC5_FILT_CTRL0                (0x1c56)
+#define P_VENC_VDAC_DAC5_FILT_CTRL0                (volatile unsigned int *)((0x1c56  << 2) + 0xff900000)
+#define   VENC_VDAC_DAC5_FILT_CTRL1                (0x1c57)
+#define P_VENC_VDAC_DAC5_FILT_CTRL1                (volatile unsigned int *)((0x1c57  << 2) + 0xff900000)
+//Bit 0   filter_en
+#define   VENC_VDAC_DAC0_FILT_CTRL0                (0x1c58)
+#define P_VENC_VDAC_DAC0_FILT_CTRL0                (volatile unsigned int *)((0x1c58  << 2) + 0xff900000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0,
+#define   VENC_VDAC_DAC0_FILT_CTRL1                (0x1c59)
+#define P_VENC_VDAC_DAC0_FILT_CTRL1                (volatile unsigned int *)((0x1c59  << 2) + 0xff900000)
+//Bit 0   filter_en
+#define   VENC_VDAC_DAC1_FILT_CTRL0                (0x1c5a)
+#define P_VENC_VDAC_DAC1_FILT_CTRL0                (volatile unsigned int *)((0x1c5a  << 2) + 0xff900000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0,
+#define   VENC_VDAC_DAC1_FILT_CTRL1                (0x1c5b)
+#define P_VENC_VDAC_DAC1_FILT_CTRL1                (volatile unsigned int *)((0x1c5b  << 2) + 0xff900000)
+//Bit 0   filter_en
+#define   VENC_VDAC_DAC2_FILT_CTRL0                (0x1c5c)
+#define P_VENC_VDAC_DAC2_FILT_CTRL0                (volatile unsigned int *)((0x1c5c  << 2) + 0xff900000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0,
+#define   VENC_VDAC_DAC2_FILT_CTRL1                (0x1c5d)
+#define P_VENC_VDAC_DAC2_FILT_CTRL1                (volatile unsigned int *)((0x1c5d  << 2) + 0xff900000)
+//Bit 0   filter_en
+#define   VENC_VDAC_DAC3_FILT_CTRL0                (0x1c5e)
+#define P_VENC_VDAC_DAC3_FILT_CTRL0                (volatile unsigned int *)((0x1c5e  << 2) + 0xff900000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0,
+#define   VENC_VDAC_DAC3_FILT_CTRL1                (0x1c5f)
+#define P_VENC_VDAC_DAC3_FILT_CTRL1                (volatile unsigned int *)((0x1c5f  << 2) + 0xff900000)
+//===========================================================================
+// ENCT registers
+#define   ENCT_VIDEO_EN                            (0x1c60)
+#define P_ENCT_VIDEO_EN                            (volatile unsigned int *)((0x1c60  << 2) + 0xff900000)
+#define   ENCT_VIDEO_Y_SCL                         (0x1c61)
+#define P_ENCT_VIDEO_Y_SCL                         (volatile unsigned int *)((0x1c61  << 2) + 0xff900000)
+#define   ENCT_VIDEO_PB_SCL                        (0x1c62)
+#define P_ENCT_VIDEO_PB_SCL                        (volatile unsigned int *)((0x1c62  << 2) + 0xff900000)
+#define   ENCT_VIDEO_PR_SCL                        (0x1c63)
+#define P_ENCT_VIDEO_PR_SCL                        (volatile unsigned int *)((0x1c63  << 2) + 0xff900000)
+#define   ENCT_VIDEO_Y_OFFST                       (0x1c64)
+#define P_ENCT_VIDEO_Y_OFFST                       (volatile unsigned int *)((0x1c64  << 2) + 0xff900000)
+#define   ENCT_VIDEO_PB_OFFST                      (0x1c65)
+#define P_ENCT_VIDEO_PB_OFFST                      (volatile unsigned int *)((0x1c65  << 2) + 0xff900000)
+#define   ENCT_VIDEO_PR_OFFST                      (0x1c66)
+#define P_ENCT_VIDEO_PR_OFFST                      (volatile unsigned int *)((0x1c66  << 2) + 0xff900000)
+//----- Video mode
+#define   ENCT_VIDEO_MODE                          (0x1c67)
+#define P_ENCT_VIDEO_MODE                          (volatile unsigned int *)((0x1c67  << 2) + 0xff900000)
+#define   ENCT_VIDEO_MODE_ADV                      (0x1c68)
+#define P_ENCT_VIDEO_MODE_ADV                      (volatile unsigned int *)((0x1c68  << 2) + 0xff900000)
+//--------------- Debug pins
+#define   ENCT_DBG_PX_RST                          (0x1c69)
+#define P_ENCT_DBG_PX_RST                          (volatile unsigned int *)((0x1c69  << 2) + 0xff900000)
+#define   ENCT_DBG_LN_RST                          (0x1c6a)
+#define P_ENCT_DBG_LN_RST                          (volatile unsigned int *)((0x1c6a  << 2) + 0xff900000)
+#define   ENCT_DBG_PX_INT                          (0x1c6b)
+#define P_ENCT_DBG_PX_INT                          (volatile unsigned int *)((0x1c6b  << 2) + 0xff900000)
+#define   ENCT_DBG_LN_INT                          (0x1c6c)
+#define P_ENCT_DBG_LN_INT                          (volatile unsigned int *)((0x1c6c  << 2) + 0xff900000)
+//----------- Video Advanced setting
+#define   ENCT_VIDEO_YFP1_HTIME                    (0x1c6d)
+#define P_ENCT_VIDEO_YFP1_HTIME                    (volatile unsigned int *)((0x1c6d  << 2) + 0xff900000)
+#define   ENCT_VIDEO_YFP2_HTIME                    (0x1c6e)
+#define P_ENCT_VIDEO_YFP2_HTIME                    (volatile unsigned int *)((0x1c6e  << 2) + 0xff900000)
+#define   ENCT_VIDEO_YC_DLY                        (0x1c6f)
+#define P_ENCT_VIDEO_YC_DLY                        (volatile unsigned int *)((0x1c6f  << 2) + 0xff900000)
+#define   ENCT_VIDEO_MAX_PXCNT                     (0x1c70)
+#define P_ENCT_VIDEO_MAX_PXCNT                     (volatile unsigned int *)((0x1c70  << 2) + 0xff900000)
+#define   ENCT_VIDEO_HAVON_END                     (0x1c71)
+#define P_ENCT_VIDEO_HAVON_END                     (volatile unsigned int *)((0x1c71  << 2) + 0xff900000)
+#define   ENCT_VIDEO_HAVON_BEGIN                   (0x1c72)
+#define P_ENCT_VIDEO_HAVON_BEGIN                   (volatile unsigned int *)((0x1c72  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VAVON_ELINE                   (0x1c73)
+#define P_ENCT_VIDEO_VAVON_ELINE                   (volatile unsigned int *)((0x1c73  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VAVON_BLINE                   (0x1c74)
+#define P_ENCT_VIDEO_VAVON_BLINE                   (volatile unsigned int *)((0x1c74  << 2) + 0xff900000)
+#define   ENCT_VIDEO_HSO_BEGIN                     (0x1c75)
+#define P_ENCT_VIDEO_HSO_BEGIN                     (volatile unsigned int *)((0x1c75  << 2) + 0xff900000)
+#define   ENCT_VIDEO_HSO_END                       (0x1c76)
+#define P_ENCT_VIDEO_HSO_END                       (volatile unsigned int *)((0x1c76  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VSO_BEGIN                     (0x1c77)
+#define P_ENCT_VIDEO_VSO_BEGIN                     (volatile unsigned int *)((0x1c77  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VSO_END                       (0x1c78)
+#define P_ENCT_VIDEO_VSO_END                       (volatile unsigned int *)((0x1c78  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VSO_BLINE                     (0x1c79)
+#define P_ENCT_VIDEO_VSO_BLINE                     (volatile unsigned int *)((0x1c79  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VSO_ELINE                     (0x1c7a)
+#define P_ENCT_VIDEO_VSO_ELINE                     (volatile unsigned int *)((0x1c7a  << 2) + 0xff900000)
+#define   ENCT_VIDEO_MAX_LNCNT                     (0x1c7b)
+#define P_ENCT_VIDEO_MAX_LNCNT                     (volatile unsigned int *)((0x1c7b  << 2) + 0xff900000)
+#define   ENCT_VIDEO_BLANKY_VAL                    (0x1c7c)
+#define P_ENCT_VIDEO_BLANKY_VAL                    (volatile unsigned int *)((0x1c7c  << 2) + 0xff900000)
+#define   ENCT_VIDEO_BLANKPB_VAL                   (0x1c7d)
+#define P_ENCT_VIDEO_BLANKPB_VAL                   (volatile unsigned int *)((0x1c7d  << 2) + 0xff900000)
+#define   ENCT_VIDEO_BLANKPR_VAL                   (0x1c7e)
+#define P_ENCT_VIDEO_BLANKPR_VAL                   (volatile unsigned int *)((0x1c7e  << 2) + 0xff900000)
+#define   ENCT_VIDEO_HOFFST                        (0x1c7f)
+#define P_ENCT_VIDEO_HOFFST                        (volatile unsigned int *)((0x1c7f  << 2) + 0xff900000)
+#define   ENCT_VIDEO_VOFFST                        (0x1c80)
+#define P_ENCT_VIDEO_VOFFST                        (volatile unsigned int *)((0x1c80  << 2) + 0xff900000)
+#define   ENCT_VIDEO_RGB_CTRL                      (0x1c81)
+#define P_ENCT_VIDEO_RGB_CTRL                      (volatile unsigned int *)((0x1c81  << 2) + 0xff900000)
+#define   ENCT_VIDEO_FILT_CTRL                     (0x1c82)
+#define P_ENCT_VIDEO_FILT_CTRL                     (volatile unsigned int *)((0x1c82  << 2) + 0xff900000)
+#define   ENCT_VIDEO_OFLD_VPEQ_OFST                (0x1c83)
+#define P_ENCT_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned int *)((0x1c83  << 2) + 0xff900000)
+#define   ENCT_VIDEO_OFLD_VOAV_OFST                (0x1c84)
+#define P_ENCT_VIDEO_OFLD_VOAV_OFST                (volatile unsigned int *)((0x1c84  << 2) + 0xff900000)
+#define   ENCT_VIDEO_MATRIX_CB                     (0x1c85)
+#define P_ENCT_VIDEO_MATRIX_CB                     (volatile unsigned int *)((0x1c85  << 2) + 0xff900000)
+#define   ENCT_VIDEO_MATRIX_CR                     (0x1c86)
+#define P_ENCT_VIDEO_MATRIX_CR                     (volatile unsigned int *)((0x1c86  << 2) + 0xff900000)
+#define   ENCT_VIDEO_RGBIN_CTRL                    (0x1c87)
+#define P_ENCT_VIDEO_RGBIN_CTRL                    (volatile unsigned int *)((0x1c87  << 2) + 0xff900000)
+#define   ENCT_MAX_LINE_SWITCH_POINT               (0x1c88)
+#define P_ENCT_MAX_LINE_SWITCH_POINT               (volatile unsigned int *)((0x1c88  << 2) + 0xff900000)
+#define   ENCT_DACSEL_0                            (0x1c89)
+#define P_ENCT_DACSEL_0                            (volatile unsigned int *)((0x1c89  << 2) + 0xff900000)
+#define   ENCT_DACSEL_1                            (0x1c8a)
+#define P_ENCT_DACSEL_1                            (volatile unsigned int *)((0x1c8a  << 2) + 0xff900000)
+//===========================================================================
+// For ENCL
+//===========================================================================
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 7 -- vfifo2vd_drop
+// bit 6:1 -- vfifo2vd_delay
+// bit 0 -- vfifo2vd_en
+#define   ENCL_VFIFO2VD_CTL                        (0x1c90)
+#define P_ENCL_VFIFO2VD_CTL                        (volatile unsigned int *)((0x1c90  << 2) + 0xff900000)
+// bit 12:0 -- vfifo2vd_pixel_start
+#define   ENCL_VFIFO2VD_PIXEL_START                (0x1c91)
+#define P_ENCL_VFIFO2VD_PIXEL_START                (volatile unsigned int *)((0x1c91  << 2) + 0xff900000)
+// bit 12:00 -- vfifo2vd_pixel_end
+#define   ENCL_VFIFO2VD_PIXEL_END                  (0x1c92)
+#define P_ENCL_VFIFO2VD_PIXEL_END                  (volatile unsigned int *)((0x1c92  << 2) + 0xff900000)
+// bit 10:0 -- vfifo2vd_line_top_start
+#define   ENCL_VFIFO2VD_LINE_TOP_START             (0x1c93)
+#define P_ENCL_VFIFO2VD_LINE_TOP_START             (volatile unsigned int *)((0x1c93  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_top_end
+#define   ENCL_VFIFO2VD_LINE_TOP_END               (0x1c94)
+#define P_ENCL_VFIFO2VD_LINE_TOP_END               (volatile unsigned int *)((0x1c94  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_start
+#define   ENCL_VFIFO2VD_LINE_BOT_START             (0x1c95)
+#define P_ENCL_VFIFO2VD_LINE_BOT_START             (volatile unsigned int *)((0x1c95  << 2) + 0xff900000)
+// bit 10:00 -- vfifo2vd_line_bot_end
+#define   ENCL_VFIFO2VD_LINE_BOT_END               (0x1c96)
+#define P_ENCL_VFIFO2VD_LINE_BOT_END               (volatile unsigned int *)((0x1c96  << 2) + 0xff900000)
+#define   ENCL_VFIFO2VD_CTL2                       (0x1c97)
+#define P_ENCL_VFIFO2VD_CTL2                       (volatile unsigned int *)((0x1c97  << 2) + 0xff900000)
+#define   ENCL_TST_EN                              (0x1c98)
+#define P_ENCL_TST_EN                              (volatile unsigned int *)((0x1c98  << 2) + 0xff900000)
+#define   ENCL_TST_MDSEL                           (0x1c99)
+#define P_ENCL_TST_MDSEL                           (volatile unsigned int *)((0x1c99  << 2) + 0xff900000)
+#define   ENCL_TST_Y                               (0x1c9a)
+#define P_ENCL_TST_Y                               (volatile unsigned int *)((0x1c9a  << 2) + 0xff900000)
+#define   ENCL_TST_CB                              (0x1c9b)
+#define P_ENCL_TST_CB                              (volatile unsigned int *)((0x1c9b  << 2) + 0xff900000)
+#define   ENCL_TST_CR                              (0x1c9c)
+#define P_ENCL_TST_CR                              (volatile unsigned int *)((0x1c9c  << 2) + 0xff900000)
+#define   ENCL_TST_CLRBAR_STRT                     (0x1c9d)
+#define P_ENCL_TST_CLRBAR_STRT                     (volatile unsigned int *)((0x1c9d  << 2) + 0xff900000)
+#define   ENCL_TST_CLRBAR_WIDTH                    (0x1c9e)
+#define P_ENCL_TST_CLRBAR_WIDTH                    (volatile unsigned int *)((0x1c9e  << 2) + 0xff900000)
+#define   ENCL_TST_VDCNT_STSET                     (0x1c9f)
+#define P_ENCL_TST_VDCNT_STSET                     (volatile unsigned int *)((0x1c9f  << 2) + 0xff900000)
+//===========================================================================
+// ENCL registers
+#define   ENCL_VIDEO_EN                            (0x1ca0)
+#define P_ENCL_VIDEO_EN                            (volatile unsigned int *)((0x1ca0  << 2) + 0xff900000)
+#define   ENCL_VIDEO_Y_SCL                         (0x1ca1)
+#define P_ENCL_VIDEO_Y_SCL                         (volatile unsigned int *)((0x1ca1  << 2) + 0xff900000)
+#define   ENCL_VIDEO_PB_SCL                        (0x1ca2)
+#define P_ENCL_VIDEO_PB_SCL                        (volatile unsigned int *)((0x1ca2  << 2) + 0xff900000)
+#define   ENCL_VIDEO_PR_SCL                        (0x1ca3)
+#define P_ENCL_VIDEO_PR_SCL                        (volatile unsigned int *)((0x1ca3  << 2) + 0xff900000)
+#define   ENCL_VIDEO_Y_OFFST                       (0x1ca4)
+#define P_ENCL_VIDEO_Y_OFFST                       (volatile unsigned int *)((0x1ca4  << 2) + 0xff900000)
+#define   ENCL_VIDEO_PB_OFFST                      (0x1ca5)
+#define P_ENCL_VIDEO_PB_OFFST                      (volatile unsigned int *)((0x1ca5  << 2) + 0xff900000)
+#define   ENCL_VIDEO_PR_OFFST                      (0x1ca6)
+#define P_ENCL_VIDEO_PR_OFFST                      (volatile unsigned int *)((0x1ca6  << 2) + 0xff900000)
+//----- Video mode
+#define   ENCL_VIDEO_MODE                          (0x1ca7)
+#define P_ENCL_VIDEO_MODE                          (volatile unsigned int *)((0x1ca7  << 2) + 0xff900000)
+#define   ENCL_VIDEO_MODE_ADV                      (0x1ca8)
+#define P_ENCL_VIDEO_MODE_ADV                      (volatile unsigned int *)((0x1ca8  << 2) + 0xff900000)
+//--------------- Debug pins
+#define   ENCL_DBG_PX_RST                          (0x1ca9)
+#define P_ENCL_DBG_PX_RST                          (volatile unsigned int *)((0x1ca9  << 2) + 0xff900000)
+#define   ENCL_DBG_LN_RST                          (0x1caa)
+#define P_ENCL_DBG_LN_RST                          (volatile unsigned int *)((0x1caa  << 2) + 0xff900000)
+#define   ENCL_DBG_PX_INT                          (0x1cab)
+#define P_ENCL_DBG_PX_INT                          (volatile unsigned int *)((0x1cab  << 2) + 0xff900000)
+#define   ENCL_DBG_LN_INT                          (0x1cac)
+#define P_ENCL_DBG_LN_INT                          (volatile unsigned int *)((0x1cac  << 2) + 0xff900000)
+//----------- Video Advanced setting
+#define   ENCL_VIDEO_YFP1_HTIME                    (0x1cad)
+#define P_ENCL_VIDEO_YFP1_HTIME                    (volatile unsigned int *)((0x1cad  << 2) + 0xff900000)
+#define   ENCL_VIDEO_YFP2_HTIME                    (0x1cae)
+#define P_ENCL_VIDEO_YFP2_HTIME                    (volatile unsigned int *)((0x1cae  << 2) + 0xff900000)
+#define   ENCL_VIDEO_YC_DLY                        (0x1caf)
+#define P_ENCL_VIDEO_YC_DLY                        (volatile unsigned int *)((0x1caf  << 2) + 0xff900000)
+#define   ENCL_VIDEO_MAX_PXCNT                     (0x1cb0)
+#define P_ENCL_VIDEO_MAX_PXCNT                     (volatile unsigned int *)((0x1cb0  << 2) + 0xff900000)
+#define   ENCL_VIDEO_HAVON_END                     (0x1cb1)
+#define P_ENCL_VIDEO_HAVON_END                     (volatile unsigned int *)((0x1cb1  << 2) + 0xff900000)
+#define   ENCL_VIDEO_HAVON_BEGIN                   (0x1cb2)
+#define P_ENCL_VIDEO_HAVON_BEGIN                   (volatile unsigned int *)((0x1cb2  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VAVON_ELINE                   (0x1cb3)
+#define P_ENCL_VIDEO_VAVON_ELINE                   (volatile unsigned int *)((0x1cb3  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VAVON_BLINE                   (0x1cb4)
+#define P_ENCL_VIDEO_VAVON_BLINE                   (volatile unsigned int *)((0x1cb4  << 2) + 0xff900000)
+#define   ENCL_VIDEO_HSO_BEGIN                     (0x1cb5)
+#define P_ENCL_VIDEO_HSO_BEGIN                     (volatile unsigned int *)((0x1cb5  << 2) + 0xff900000)
+#define   ENCL_VIDEO_HSO_END                       (0x1cb6)
+#define P_ENCL_VIDEO_HSO_END                       (volatile unsigned int *)((0x1cb6  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VSO_BEGIN                     (0x1cb7)
+#define P_ENCL_VIDEO_VSO_BEGIN                     (volatile unsigned int *)((0x1cb7  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VSO_END                       (0x1cb8)
+#define P_ENCL_VIDEO_VSO_END                       (volatile unsigned int *)((0x1cb8  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VSO_BLINE                     (0x1cb9)
+#define P_ENCL_VIDEO_VSO_BLINE                     (volatile unsigned int *)((0x1cb9  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VSO_ELINE                     (0x1cba)
+#define P_ENCL_VIDEO_VSO_ELINE                     (volatile unsigned int *)((0x1cba  << 2) + 0xff900000)
+#define   ENCL_VIDEO_MAX_LNCNT                     (0x1cbb)
+#define P_ENCL_VIDEO_MAX_LNCNT                     (volatile unsigned int *)((0x1cbb  << 2) + 0xff900000)
+#define   ENCL_VIDEO_BLANKY_VAL                    (0x1cbc)
+#define P_ENCL_VIDEO_BLANKY_VAL                    (volatile unsigned int *)((0x1cbc  << 2) + 0xff900000)
+#define   ENCL_VIDEO_BLANKPB_VAL                   (0x1cbd)
+#define P_ENCL_VIDEO_BLANKPB_VAL                   (volatile unsigned int *)((0x1cbd  << 2) + 0xff900000)
+#define   ENCL_VIDEO_BLANKPR_VAL                   (0x1cbe)
+#define P_ENCL_VIDEO_BLANKPR_VAL                   (volatile unsigned int *)((0x1cbe  << 2) + 0xff900000)
+#define   ENCL_VIDEO_HOFFST                        (0x1cbf)
+#define P_ENCL_VIDEO_HOFFST                        (volatile unsigned int *)((0x1cbf  << 2) + 0xff900000)
+#define   ENCL_VIDEO_VOFFST                        (0x1cc0)
+#define P_ENCL_VIDEO_VOFFST                        (volatile unsigned int *)((0x1cc0  << 2) + 0xff900000)
+#define   ENCL_VIDEO_RGB_CTRL                      (0x1cc1)
+#define P_ENCL_VIDEO_RGB_CTRL                      (volatile unsigned int *)((0x1cc1  << 2) + 0xff900000)
+#define   ENCL_VIDEO_FILT_CTRL                     (0x1cc2)
+#define P_ENCL_VIDEO_FILT_CTRL                     (volatile unsigned int *)((0x1cc2  << 2) + 0xff900000)
+#define   ENCL_VIDEO_OFLD_VPEQ_OFST                (0x1cc3)
+#define P_ENCL_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned int *)((0x1cc3  << 2) + 0xff900000)
+#define   ENCL_VIDEO_OFLD_VOAV_OFST                (0x1cc4)
+#define P_ENCL_VIDEO_OFLD_VOAV_OFST                (volatile unsigned int *)((0x1cc4  << 2) + 0xff900000)
+#define   ENCL_VIDEO_MATRIX_CB                     (0x1cc5)
+#define P_ENCL_VIDEO_MATRIX_CB                     (volatile unsigned int *)((0x1cc5  << 2) + 0xff900000)
+#define   ENCL_VIDEO_MATRIX_CR                     (0x1cc6)
+#define P_ENCL_VIDEO_MATRIX_CR                     (volatile unsigned int *)((0x1cc6  << 2) + 0xff900000)
+#define   ENCL_VIDEO_RGBIN_CTRL                    (0x1cc7)
+#define P_ENCL_VIDEO_RGBIN_CTRL                    (volatile unsigned int *)((0x1cc7  << 2) + 0xff900000)
+#define   ENCL_MAX_LINE_SWITCH_POINT               (0x1cc8)
+#define P_ENCL_MAX_LINE_SWITCH_POINT               (volatile unsigned int *)((0x1cc8  << 2) + 0xff900000)
+#define   ENCL_DACSEL_0                            (0x1cc9)
+#define P_ENCL_DACSEL_0                            (volatile unsigned int *)((0x1cc9  << 2) + 0xff900000)
+#define   ENCL_DACSEL_1                            (0x1cca)
+#define P_ENCL_DACSEL_1                            (volatile unsigned int *)((0x1cca  << 2) + 0xff900000)
+//
+// Closing file:  venc2_regs.h
+//
+//`define VPP_VCBUS_BASE			     8'h1d
+//
+// Reading file:  vpp_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPP_VCBUS_BASE = 0x1d
+// -----------------------------------------------
+//===========================================================================
+// Video postprocesing Registers
+//===========================================================================
+// dummy data used in the VPP preblend and scaler
+// Bit 23:16    Y
+// Bit 15:8     CB
+// Bit 7:0      CR
+#define   VPP_DUMMY_DATA                           (0x1d00)
+#define P_VPP_DUMMY_DATA                           (volatile unsigned int *)((0x1d00  << 2) + 0xff900000)
+//input line length used in VPP
+#define   VPP_LINE_IN_LENGTH                       (0x1d01)
+#define P_VPP_LINE_IN_LENGTH                       (volatile unsigned int *)((0x1d01  << 2) + 0xff900000)
+//input Picture height used in VPP
+#define   VPP_PIC_IN_HEIGHT                        (0x1d02)
+#define P_VPP_PIC_IN_HEIGHT                        (volatile unsigned int *)((0x1d02  << 2) + 0xff900000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 13    if true, vertical separated coef enable
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered
+//Bit 6:0 	coef index
+#define   VPP_SCALE_COEF_IDX                       (0x1d03)
+#define P_VPP_SCALE_COEF_IDX                       (volatile unsigned int *)((0x1d03  << 2) + 0xff900000)
+//coefficients for vertical filter and horizontal filter
+#define   VPP_SCALE_COEF                           (0x1d04)
+#define P_VPP_SCALE_COEF                           (volatile unsigned int *)((0x1d04  << 2) + 0xff900000)
+//these following registers are the absolute line address pointer for output divided screen
+//The output divided screen is shown in the following:
+//
+//  --------------------------   <------ line zero
+//		.
+//		.
+//		.		    region0        <---------- nonlinear region or nonscaling region
+//		.
+//  ---------------------------
+//  ---------------------------  <------ region1_startp
+//		.
+//		.           region1         <---------- nonlinear region
+//		.
+//		.
+//  ---------------------------
+//  ---------------------------  <------ region2_startp
+//		.
+//		.           region2         <---------- linear region
+//		.
+//		.
+//  ---------------------------
+//  ---------------------------  <------ region3_startp
+//		.
+//		.           region3         <---------- nonlinear region
+//		.
+//		.
+//  ---------------------------
+//  ---------------------------  <------ region4_startp
+//		.
+//		.           region4         <---------- nonlinear region or nonoscaling region
+//		.
+//		.
+//  ---------------------------  <------ region4_endp
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define   VPP_VSC_REGION12_STARTP                  (0x1d05)
+#define P_VPP_VSC_REGION12_STARTP                  (volatile unsigned int *)((0x1d05  << 2) + 0xff900000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define   VPP_VSC_REGION34_STARTP                  (0x1d06)
+#define P_VPP_VSC_REGION34_STARTP                  (volatile unsigned int *)((0x1d06  << 2) + 0xff900000)
+#define   VPP_VSC_REGION4_ENDP                     (0x1d07)
+#define P_VPP_VSC_REGION4_ENDP                     (volatile unsigned int *)((0x1d07  << 2) + 0xff900000)
+//vertical start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part
+//Bit 23:0	fraction part
+#define   VPP_VSC_START_PHASE_STEP                 (0x1d08)
+#define P_VPP_VSC_START_PHASE_STEP                 (volatile unsigned int *)((0x1d08  << 2) + 0xff900000)
+//vertical scaler region0 phase slope, Bit24 signed bit
+#define   VPP_VSC_REGION0_PHASE_SLOPE              (0x1d09)
+#define P_VPP_VSC_REGION0_PHASE_SLOPE              (volatile unsigned int *)((0x1d09  << 2) + 0xff900000)
+//vertical scaler region1 phase slope, Bit24 signed bit
+#define   VPP_VSC_REGION1_PHASE_SLOPE              (0x1d0a)
+#define P_VPP_VSC_REGION1_PHASE_SLOPE              (volatile unsigned int *)((0x1d0a  << 2) + 0xff900000)
+//vertical scaler region3 phase slope, Bit24 signed bit
+#define   VPP_VSC_REGION3_PHASE_SLOPE              (0x1d0b)
+#define P_VPP_VSC_REGION3_PHASE_SLOPE              (volatile unsigned int *)((0x1d0b  << 2) + 0xff900000)
+//vertical scaler region4 phase slope, Bit24 signed bit
+#define   VPP_VSC_REGION4_PHASE_SLOPE              (0x1d0c)
+#define P_VPP_VSC_REGION4_PHASE_SLOPE              (volatile unsigned int *)((0x1d0c  << 2) + 0xff900000)
+//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X,
+//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
+//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
+//Bit 16     0: progressive output, 1: interlace output
+//Bit 15     vertical scaler output line0 in advance or not for bottom field
+//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
+//Bit 11:8   vertical scaler initial receiving  number for bottom field
+//Bit 7      vertical scaler output line0 in advance or not for top field
+//Bit 6:5    vertical scaler initial repeat line0 number for top field
+//Bit 3:0    vertical scaler initial receiving  number for top field
+#define   VPP_VSC_PHASE_CTRL                       (0x1d0d)
+#define P_VPP_VSC_PHASE_CTRL                       (volatile unsigned int *)((0x1d0d  << 2) + 0xff900000)
+//Bit 31:16  vertical scaler field initial phase for bottom field
+//Bit 15:0  vertical scaler field initial phase for top field
+#define   VPP_VSC_INI_PHASE                        (0x1d0e)
+#define P_VPP_VSC_INI_PHASE                        (volatile unsigned int *)((0x1d0e  << 2) + 0xff900000)
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define   VPP_HSC_REGION12_STARTP                  (0x1d10)
+#define P_VPP_HSC_REGION12_STARTP                  (volatile unsigned int *)((0x1d10  << 2) + 0xff900000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define   VPP_HSC_REGION34_STARTP                  (0x1d11)
+#define P_VPP_HSC_REGION34_STARTP                  (volatile unsigned int *)((0x1d11  << 2) + 0xff900000)
+#define   VPP_HSC_REGION4_ENDP                     (0x1d12)
+#define P_VPP_HSC_REGION4_ENDP                     (volatile unsigned int *)((0x1d12  << 2) + 0xff900000)
+//horizontal start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part
+//Bit 23:0	fraction part
+#define   VPP_HSC_START_PHASE_STEP                 (0x1d13)
+#define P_VPP_HSC_START_PHASE_STEP                 (volatile unsigned int *)((0x1d13  << 2) + 0xff900000)
+//horizontal scaler region0 phase slope, Bit24 signed bit
+#define   VPP_HSC_REGION0_PHASE_SLOPE              (0x1d14)
+#define P_VPP_HSC_REGION0_PHASE_SLOPE              (volatile unsigned int *)((0x1d14  << 2) + 0xff900000)
+//horizontal scaler region1 phase slope, Bit24 signed bit
+#define   VPP_HSC_REGION1_PHASE_SLOPE              (0x1d15)
+#define P_VPP_HSC_REGION1_PHASE_SLOPE              (volatile unsigned int *)((0x1d15  << 2) + 0xff900000)
+//horizontal scaler region3 phase slope, Bit24 signed bit
+#define   VPP_HSC_REGION3_PHASE_SLOPE              (0x1d16)
+#define P_VPP_HSC_REGION3_PHASE_SLOPE              (volatile unsigned int *)((0x1d16  << 2) + 0xff900000)
+//horizontal scaler region4 phase slope, Bit24 signed bit
+#define   VPP_HSC_REGION4_PHASE_SLOPE              (0x1d17)
+#define P_VPP_HSC_REGION4_PHASE_SLOPE              (volatile unsigned int *)((0x1d17  << 2) + 0xff900000)
+//Bit 22:21   horizontal scaler initial repeat pixel0 number0
+//Bit 19:16   horizontal scaler initial receiving number0
+//Bit 15:0    horizontal scaler top field initial phase0
+#define   VPP_HSC_PHASE_CTRL                       (0x1d18)
+#define P_VPP_HSC_PHASE_CTRL                       (volatile unsigned int *)((0x1d18  << 2) + 0xff900000)
+// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
+//                 just for special usage, more flexibility
+// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
+// Bit 20 prehsc_en
+// Bit 19 prevsc_en
+// Bit 18 vsc_en
+// Bit 17 hsc_en
+// Bit 16 scale_top_en
+// Bit 15 video1 scale out enable
+// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler
+// Bit 10:8 horizontal scaler bank length
+// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
+// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler
+// Bit 2:0 vertical scaler bank length
+#define   VPP_SC_MISC                              (0x1d19)
+#define P_VPP_SC_MISC                              (volatile unsigned int *)((0x1d19  << 2) + 0xff900000)
+// preblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_PREBLEND_VD1_H_START_END             (0x1d1a)
+#define P_VPP_PREBLEND_VD1_H_START_END             (volatile unsigned int *)((0x1d1a  << 2) + 0xff900000)
+// preblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_PREBLEND_VD1_V_START_END             (0x1d1b)
+#define P_VPP_PREBLEND_VD1_V_START_END             (volatile unsigned int *)((0x1d1b  << 2) + 0xff900000)
+// postblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_POSTBLEND_VD1_H_START_END            (0x1d1c)
+#define P_VPP_POSTBLEND_VD1_H_START_END            (volatile unsigned int *)((0x1d1c  << 2) + 0xff900000)
+// postblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_POSTBLEND_VD1_V_START_END            (0x1d1d)
+#define P_VPP_POSTBLEND_VD1_V_START_END            (volatile unsigned int *)((0x1d1d  << 2) + 0xff900000)
+// preblend/postblend video2 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_BLEND_VD2_H_START_END                (0x1d1e)
+#define P_VPP_BLEND_VD2_H_START_END                (volatile unsigned int *)((0x1d1e  << 2) + 0xff900000)
+// preblend/postblend video2 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_BLEND_VD2_V_START_END                (0x1d1f)
+#define P_VPP_BLEND_VD2_V_START_END                (volatile unsigned int *)((0x1d1f  << 2) + 0xff900000)
+// preblend horizontal size
+#define   VPP_PREBLEND_H_SIZE                      (0x1d20)
+#define P_VPP_PREBLEND_H_SIZE                      (volatile unsigned int *)((0x1d20  << 2) + 0xff900000)
+// postblend horizontal size
+#define   VPP_POSTBLEND_H_SIZE                     (0x1d21)
+#define P_VPP_POSTBLEND_H_SIZE                     (volatile unsigned int *)((0x1d21  << 2) + 0xff900000)
+//VPP hold lines
+//Bit 29:24
+//Bit 21:16
+//Bit 15:8     preblend hold lines
+//Bit 7:0      postblend hold lines
+#define   VPP_HOLD_LINES                           (0x1d22)
+#define P_VPP_HOLD_LINES                           (volatile unsigned int *)((0x1d22  << 2) + 0xff900000)
+//Bit 26   if true, automatic change post blend output to one color if field ==1
+//Bit 25   if true, change screen to one color value for preblender
+//Bit 24   if true, change screen to one color value for postblender
+// Bit 23:16 one color Y
+// Bit 15:8 one color Cb
+// Bit  7:0 one color  Cr
+#define   VPP_BLEND_ONECOLOR_CTRL                  (0x1d23)
+#define P_VPP_BLEND_ONECOLOR_CTRL                  (volatile unsigned int *)((0x1d23  << 2) + 0xff900000)
+//Read Only, VPP preblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define   VPP_PREBLEND_CURRENT_XY                  (0x1d24)
+#define P_VPP_PREBLEND_CURRENT_XY                  (volatile unsigned int *)((0x1d24  << 2) + 0xff900000)
+//Read Only, VPP postblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define   VPP_POSTBLEND_CURRENT_XY                 (0x1d25)
+#define P_VPP_POSTBLEND_CURRENT_XY                 (volatile unsigned int *)((0x1d25  << 2) + 0xff900000)
+// Bit 31  vd1_bgosd_exchange_en for preblend
+// Bit 30  vd1_bgosd_exchange_en for postblend
+// Bit 28   color management enable
+// Bit 27,  if true, vd2 use viu2 output as the input, otherwise use normal vd2 from memory
+// Bit 26:18, vd2 alpha
+// Bit 17, osd2 enable for preblend
+// Bit 16, osd1 enable for preblend
+// Bit 15, vd2 enable for preblend
+// Bit 14, vd1 enable for preblend
+// Bit 13, osd2 enable for postblend
+// Bit 12, osd1 enable for postblend
+// Bit 11, vd2 enable for postblend
+// Bit 10, vd1 enable for postblend
+// Bit 9,  if true, osd1 is alpha premultipiled
+// Bit 8,  if true, osd2 is alpha premultipiled
+// Bit 7,  postblend module enable
+// Bit 6,  preblend module enable
+// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
+// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
+// Bit 3,
+// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
+//			 the aync fifo will be reseted.
+// Bit 1,
+// Bit 0	if true, the output result of VPP is saturated
+#define   VPP_MISC                                 (0x1d26)
+#define P_VPP_MISC                                 (volatile unsigned int *)((0x1d26  << 2) + 0xff900000)
+//Bit 31:20 ofifo line length minus 1
+//Bit 19  if true invert input vs
+//Bit 18  if true invert input hs
+//Bit 17  force top/bottom field, enable
+//Bit 16  force top/bottom field, 0: top, 1: bottom
+//Bit 15  force one go_field, one pluse, write only
+//Bit 14  force one go_line, one pluse, write only
+//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
+#define   VPP_OFIFO_SIZE                           (0x1d27)
+#define P_VPP_OFIFO_SIZE                           (volatile unsigned int *)((0x1d27  << 2) + 0xff900000)
+//Read only
+//Bit 28:18 current scale out fifo counter
+//Bit 17:13 current afifo counter
+//Bit 12:0 current ofifo counter
+#define   VPP_FIFO_STATUS                          (0x1d28)
+#define P_VPP_FIFO_STATUS                          (volatile unsigned int *)((0x1d28  << 2) + 0xff900000)
+// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable
+// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable
+// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable
+// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable
+// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable
+// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable
+#define   VPP_SMOKE_CTRL                           (0x1d29)
+#define P_VPP_SMOKE_CTRL                           (volatile unsigned int *)((0x1d29  << 2) + 0xff900000)
+//smoke can be used only when that blending is disable and then be used as smoke function
+//smoke1 for OSD1 chanel
+//smoke2 for OSD2 chanel
+//smoke3 for VD2 chanel
+//31:24 Y
+//23:16 Cb
+//15:8 Cr
+//7:0 Alpha
+#define   VPP_SMOKE1_VAL                           (0x1d2a)
+#define P_VPP_SMOKE1_VAL                           (volatile unsigned int *)((0x1d2a  << 2) + 0xff900000)
+#define   VPP_SMOKE2_VAL                           (0x1d2b)
+#define P_VPP_SMOKE2_VAL                           (volatile unsigned int *)((0x1d2b  << 2) + 0xff900000)
+#define   VPP_SMOKE3_VAL                           (0x1d2c)
+#define P_VPP_SMOKE3_VAL                           (volatile unsigned int *)((0x1d2c  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_SMOKE1_H_START_END                   (0x1d2d)
+#define P_VPP_SMOKE1_H_START_END                   (volatile unsigned int *)((0x1d2d  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_SMOKE1_V_START_END                   (0x1d2e)
+#define P_VPP_SMOKE1_V_START_END                   (volatile unsigned int *)((0x1d2e  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_SMOKE2_H_START_END                   (0x1d2f)
+#define P_VPP_SMOKE2_H_START_END                   (volatile unsigned int *)((0x1d2f  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_SMOKE2_V_START_END                   (0x1d30)
+#define P_VPP_SMOKE2_V_START_END                   (volatile unsigned int *)((0x1d30  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_SMOKE3_H_START_END                   (0x1d31)
+#define P_VPP_SMOKE3_H_START_END                   (volatile unsigned int *)((0x1d31  << 2) + 0xff900000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define   VPP_SMOKE3_V_START_END                   (0x1d32)
+#define P_VPP_SMOKE3_V_START_END                   (volatile unsigned int *)((0x1d32  << 2) + 0xff900000)
+//Bit 27:16 scale out fifo line length minus 1
+//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
+#define   VPP_SCO_FIFO_CTRL                        (0x1d33)
+#define P_VPP_SCO_FIFO_CTRL                        (volatile unsigned int *)((0x1d33  << 2) + 0xff900000)
+//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
+//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
+//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
+//Bit 23 horizontal scaler double pixel mode
+//Bit 22:21   horizontal scaler initial repeat pixel0 number1
+//Bit 19:16   horizontal scaler initial receiving number1
+//Bit 15:0    horizontal scaler top field initial phase1
+#define   VPP_HSC_PHASE_CTRL1                      (0x1d34)
+#define P_VPP_HSC_PHASE_CTRL1                      (volatile unsigned int *)((0x1d34  << 2) + 0xff900000)
+//for 3D quincunx sub-sampling
+//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
+//22:20  prehsc pattern start
+//18:16 prehsc pattern end
+//15:8 hsc pattern, each patten 1 bit, from lsb -> msb
+//6:4  hsc pattern start
+//2:0  hsc pattern end
+#define   VPP_HSC_INI_PAT_CTRL                     (0x1d35)
+#define P_VPP_HSC_INI_PAT_CTRL                     (volatile unsigned int *)((0x1d35  << 2) + 0xff900000)
+//Bit 3			minus black level enable for vadj2
+//Bit 2			Video adjustment enable for vadj2
+//Bit 1			minus black level enable for vadj1
+//Bit 0			Video adjustment enable for vadj1
+#define   VPP_VADJ_CTRL                            (0x1d40)
+#define P_VPP_VADJ_CTRL                            (volatile unsigned int *)((0x1d40  << 2) + 0xff900000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
+#define   VPP_VADJ1_Y                              (0x1d41)
+#define P_VPP_VADJ1_Y                              (volatile unsigned int *)((0x1d41  << 2) + 0xff900000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define   VPP_VADJ1_MA_MB                          (0x1d42)
+#define P_VPP_VADJ1_MA_MB                          (volatile unsigned int *)((0x1d42  << 2) + 0xff900000)
+#define   VPP_VADJ1_MC_MD                          (0x1d43)
+#define P_VPP_VADJ1_MC_MD                          (volatile unsigned int *)((0x1d43  << 2) + 0xff900000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
+#define   VPP_VADJ2_Y                              (0x1d44)
+#define P_VPP_VADJ2_Y                              (volatile unsigned int *)((0x1d44  << 2) + 0xff900000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define   VPP_VADJ2_MA_MB                          (0x1d45)
+#define P_VPP_VADJ2_MA_MB                          (volatile unsigned int *)((0x1d45  << 2) + 0xff900000)
+#define   VPP_VADJ2_MC_MD                          (0x1d46)
+#define P_VPP_VADJ2_MC_MD                          (volatile unsigned int *)((0x1d46  << 2) + 0xff900000)
+//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur
+//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur
+//Bit 0 horizontal sharpness enable
+#define   VPP_HSHARP_CTRL                          (0x1d50)
+#define P_VPP_HSHARP_CTRL                          (volatile unsigned int *)((0x1d50  << 2) + 0xff900000)
+//{1'b0,threhsold} < diff
+//Bit 26:16  luma threshold0
+//Bit 10:0   luma threshold1
+#define   VPP_HSHARP_LUMA_THRESH01                 (0x1d51)
+#define P_VPP_HSHARP_LUMA_THRESH01                 (volatile unsigned int *)((0x1d51  << 2) + 0xff900000)
+//
+//Bit 26:16  luma threshold2
+//Bit 10:0   luma threshold3
+#define   VPP_HSHARP_LUMA_THRESH23                 (0x1d52)
+#define P_VPP_HSHARP_LUMA_THRESH23                 (volatile unsigned int *)((0x1d52  << 2) + 0xff900000)
+//Bit 26:16  chroma threshold0
+//Bit 10:0   chroma threshold1
+#define   VPP_HSHARP_CHROMA_THRESH01               (0x1d53)
+#define P_VPP_HSHARP_CHROMA_THRESH01               (volatile unsigned int *)((0x1d53  << 2) + 0xff900000)
+//Bit 26:16  chroma threshold2
+//Bit 10:0   chroma threshold3
+#define   VPP_HSHARP_CHROMA_THRESH23               (0x1d54)
+#define P_VPP_HSHARP_CHROMA_THRESH23               (volatile unsigned int *)((0x1d54  << 2) + 0xff900000)
+//Bit 23:16 luma gain2
+//Bit 15:8  luma gain1
+//Bit 7:0   luma gain0
+#define   VPP_HSHARP_LUMA_GAIN                     (0x1d55)
+#define P_VPP_HSHARP_LUMA_GAIN                     (volatile unsigned int *)((0x1d55  << 2) + 0xff900000)
+//
+//Bit 23:16 chroma gain2
+//Bit 15:8  chroma gain1
+//Bit 7:0   chroma gain0
+#define   VPP_HSHARP_CHROMA_GAIN                   (0x1d56)
+#define P_VPP_HSHARP_CHROMA_GAIN                   (volatile unsigned int *)((0x1d56  << 2) + 0xff900000)
+//Read only
+//Bit 31, if it is true, it means this probe is valid in the last field/frame
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define   VPP_MATRIX_PROBE_COLOR                   (0x1d5c)
+#define P_VPP_MATRIX_PROBE_COLOR                   (volatile unsigned int *)((0x1d5c  << 2) + 0xff900000)
+#define   VPP_MATRIX_PROBE_COLOR1                  (0x1dd7)
+#define P_VPP_MATRIX_PROBE_COLOR1                  (volatile unsigned int *)((0x1dd7  << 2) + 0xff900000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define   VPP_MATRIX_HL_COLOR                      (0x1d5d)
+#define P_VPP_MATRIX_HL_COLOR                      (volatile unsigned int *)((0x1d5d  << 2) + 0xff900000)
+//28:16 probe x, postion
+//12:0  probe y, position
+#define   VPP_MATRIX_PROBE_POS                     (0x1d5e)
+#define P_VPP_MATRIX_PROBE_POS                     (volatile unsigned int *)((0x1d5e  << 2) + 0xff900000)
+//Bit 16,  highlight_en
+//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix, 010: select vd2 matrix
+//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
+//Bit 5    vd1 conversion matrix enable
+//Bit 4    vd2 conversion matrix enable
+//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 0    post conversion matrix enable
+#define   VPP_MATRIX_CTRL                          (0x1d5f)
+#define P_VPP_MATRIX_CTRL                          (volatile unsigned int *)((0x1d5f  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VPP_MATRIX_COEF00_01                     (0x1d60)
+#define P_VPP_MATRIX_COEF00_01                     (volatile unsigned int *)((0x1d60  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VPP_MATRIX_COEF02_10                     (0x1d61)
+#define P_VPP_MATRIX_COEF02_10                     (volatile unsigned int *)((0x1d61  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VPP_MATRIX_COEF11_12                     (0x1d62)
+#define P_VPP_MATRIX_COEF11_12                     (volatile unsigned int *)((0x1d62  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VPP_MATRIX_COEF20_21                     (0x1d63)
+#define P_VPP_MATRIX_COEF20_21                     (volatile unsigned int *)((0x1d63  << 2) + 0xff900000)
+#define   VPP_MATRIX_COEF22                        (0x1d64)
+#define P_VPP_MATRIX_COEF22                        (volatile unsigned int *)((0x1d64  << 2) + 0xff900000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define   VPP_MATRIX_OFFSET0_1                     (0x1d65)
+#define P_VPP_MATRIX_OFFSET0_1                     (volatile unsigned int *)((0x1d65  << 2) + 0xff900000)
+//Bit 10:0  offset2
+#define   VPP_MATRIX_OFFSET2                       (0x1d66)
+#define P_VPP_MATRIX_OFFSET2                       (volatile unsigned int *)((0x1d66  << 2) + 0xff900000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define   VPP_MATRIX_PRE_OFFSET0_1                 (0x1d67)
+#define P_VPP_MATRIX_PRE_OFFSET0_1                 (volatile unsigned int *)((0x1d67  << 2) + 0xff900000)
+//Bit 10:0  pre_offset2
+#define   VPP_MATRIX_PRE_OFFSET2                   (0x1d68)
+#define P_VPP_MATRIX_PRE_OFFSET2                   (volatile unsigned int *)((0x1d68  << 2) + 0xff900000)
+// dummy data used in the VPP postblend
+// Bit 23:16    Y
+// Bit 15:8     CB
+// Bit 7:0      CR
+#define   VPP_DUMMY_DATA1                          (0x1d69)
+#define P_VPP_DUMMY_DATA1                          (volatile unsigned int *)((0x1d69  << 2) + 0xff900000)
+//Bit 31 gainoff module enable
+//Bit 26:16 gain0, 1.10 unsigned data
+//Bit 10:0  gain1, 1.10 unsigned dat
+#define   VPP_GAINOFF_CTRL0                        (0x1d6a)
+#define P_VPP_GAINOFF_CTRL0                        (volatile unsigned int *)((0x1d6a  << 2) + 0xff900000)
+//Bit 26:16 gain2, 1.10 unsigned data
+//Bit 10:0, offset0, signed data
+#define   VPP_GAINOFF_CTRL1                        (0x1d6b)
+#define P_VPP_GAINOFF_CTRL1                        (volatile unsigned int *)((0x1d6b  << 2) + 0xff900000)
+//Bit 26:16, offset1, signed data
+//Bit 10:0, offset2, signed data
+#define   VPP_GAINOFF_CTRL2                        (0x1d6c)
+#define P_VPP_GAINOFF_CTRL2                        (volatile unsigned int *)((0x1d6c  << 2) + 0xff900000)
+//Bit 26:16, pre_offset0, signed data
+//Bit 10:0, pre_offset1, signed data
+#define   VPP_GAINOFF_CTRL3                        (0x1d6d)
+#define P_VPP_GAINOFF_CTRL3                        (volatile unsigned int *)((0x1d6d  << 2) + 0xff900000)
+//Bit 10:0, pre_offset2, signed data
+#define   VPP_GAINOFF_CTRL4                        (0x1d6e)
+#define P_VPP_GAINOFF_CTRL4                        (volatile unsigned int *)((0x1d6e  << 2) + 0xff900000)
+//only two registers used in the color management, which are defined in the chroma_reg.h
+//`define VPP_CHROMA_ADDR_PORT    8'h70
+//`define VPP_CHROMA_DATA_PORT    8'h71
+//
+// Reading file:  chroma_reg.h
+//
+//**********************************************************************************
+//* Copyright (c) 2008, AMLOGIC Inc.
+//* All rights reserved
+//**********************************************************************************
+//* File :  chroma_reg.v
+//* Author : Terrence Wang
+//* Date : Dec 2008
+//* Description :
+//*
+//**********************************************************************************
+//* Modification History:
+//* Date    Modified By         Reason
+//**********************************************************************************
+// synopsys translate_off
+// synopsys translate_on
+#define   VPP_CHROMA_ADDR_PORT                     (0x1d70)
+#define P_VPP_CHROMA_ADDR_PORT                     (volatile unsigned int *)((0x1d70  << 2) + 0xff900000)
+#define   VPP_CHROMA_DATA_PORT                     (0x1d71)
+#define P_VPP_CHROMA_DATA_PORT                     (volatile unsigned int *)((0x1d71  << 2) + 0xff900000)
+//`define CHROMA_ADDR_PORT        8'h67
+//`define CHROMA_DATA_PORT        8'h68
+
+//  CHROMA_GAIN_REG_XX(00-07)
+//  hue gain, sat gain function control
+//  Bit 31      reg_sat_en                  enable sat adjustment in current region
+//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
+//                                          1'b1: increase  1'b0: decrease
+//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
+//                                          2'b01 central biggest   2'b00 one side biggest
+//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
+//                                          1'b1: left side biggest 1'b0 right side biggest
+//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
+//                                          0x00-0xff
+//  Bit 15      reg_hue_en                  enable hue adjustment in current region
+//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
+//                                          1'b1: clockwise 1'b0: anti-clockwise
+//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
+//                                          1'b1: parabola curve    1'b0: non-symmetry curve
+//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
+//                                          1'b1: right side change more    1'b0: left side change more
+//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
+//                                          0x00-0x80, note: should be no bigger than 0x80
+
+    #define CHROMA_GAIN_REG00       0x00
+
+
+//  HUE_HUE_RANGE_REG_XX(00-07)
+//  hue range select
+//  Bit 31:24   no use now
+//  Bit 23:16   reg_hue_shift_range         define the angle of target region
+//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
+//                                          must be greater or equal than 8'd8
+//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
+//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
+//                                          the symmetry region hue_shift_range = reg_hue_shift_range
+//                                          in symmetry region, all the sat and hue setting will be same with original region,
+//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
+//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
+//                                          0x6000 means 360 degree
+//                                          only region 0 and 1 can exceed 360 degrees.
+
+    #define HUE_HUE_RANGE_REG00     0x01
+
+
+//  HUE_RANGE_INV_REG_XX
+//  Calculation should be follow
+//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
+//  HUE_RANGE_INV_REG_XX is to used to save divider
+
+    #define HUE_RANGE_INV_REG00     0x02
+
+
+
+//  for belowing each low, high, low_slope, high_slope group:
+//            a_____________b
+//            /             \               a = low  + 2^low_slope
+//           /               \              b = high - 2^high_slope
+//          /                 \             low_slope <= 7; high_slope <= 7
+//         /                   \            b >= a
+//  ______/_____________________\________
+//       low                    high
+//
+//
+//  HUE_LUM_RANGE_REG_XX(00-07)
+//  luma range selection for hue adjustment
+//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
+//                                          0x00-0xff
+//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
+//                                          0x00-0x07
+//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
+//                                          0x00-0x07
+//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
+//                                          0x00-0xff
+//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
+//                                          0x00-0xff
+
+    #define HUE_LUM_RANGE_REG00     0x03
+
+//  HUE_SAT_RANGE_REG_XX(00-07)
+//  sat range selection for hue adjustment
+//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
+//                                          0x00-0xff
+//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
+//                                          0x00-0x07
+//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
+//                                          0x00-0x07
+//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
+//                                          0x00-0xff
+//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
+//                                          0x00-0xff
+
+    #define HUE_SAT_RANGE_REG00     0x04
+
+//  SAT_SAT_RANGE_REG_XX(00-07)
+//  sat range selection for hue adjustment
+//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
+//                                          0x00-0x07
+//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
+//                                          0x00-0x07
+//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
+//                                          0x00-0x07
+//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
+//                                          0x00-0x07
+//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
+//                                          0x00-0xff
+//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
+//                                          0x00-0xff
+
+    #define SAT_SAT_RANGE_REG00     0x05
+
+
+    #define CHROMA_GAIN_REG01       0x06
+    #define HUE_HUE_RANGE_REG01     0x07
+    #define HUE_RANGE_INV_REG01     0x08
+    #define HUE_LUM_RANGE_REG01     0x09
+    #define HUE_SAT_RANGE_REG01     0x0a
+    #define SAT_SAT_RANGE_REG01     0x0b
+
+    #define CHROMA_GAIN_REG02       0x0c
+    #define HUE_HUE_RANGE_REG02     0x0d
+    #define HUE_RANGE_INV_REG02     0x0e
+    #define HUE_LUM_RANGE_REG02     0x0f
+    #define HUE_SAT_RANGE_REG02     0x10
+    #define SAT_SAT_RANGE_REG02     0x11
+
+
+    #define CHROMA_GAIN_REG03       0x12
+    #define HUE_HUE_RANGE_REG03     0x13
+    #define HUE_RANGE_INV_REG03     0x14
+    #define HUE_LUM_RANGE_REG03     0x15
+    #define HUE_SAT_RANGE_REG03     0x16
+    #define SAT_SAT_RANGE_REG03     0x17
+
+    #define CHROMA_GAIN_REG04       0x18
+    #define HUE_HUE_RANGE_REG04     0x19
+    #define HUE_RANGE_INV_REG04     0x1a
+    #define HUE_LUM_RANGE_REG04     0x1b
+    #define HUE_SAT_RANGE_REG04     0x1c
+    #define SAT_SAT_RANGE_REG04     0x1d
+
+    #define CHROMA_GAIN_REG05       0x1e
+    #define HUE_HUE_RANGE_REG05     0x1f
+    #define HUE_RANGE_INV_REG05     0x20
+    #define HUE_LUM_RANGE_REG05     0x21
+    #define HUE_SAT_RANGE_REG05     0x22
+    #define SAT_SAT_RANGE_REG05     0x23
+
+    #define CHROMA_GAIN_REG06       0x24
+    #define HUE_HUE_RANGE_REG06     0x25
+    #define HUE_RANGE_INV_REG06     0x26
+    #define HUE_LUM_RANGE_REG06     0x27
+    #define HUE_SAT_RANGE_REG06     0x28
+    #define SAT_SAT_RANGE_REG06     0x29
+
+    #define CHROMA_GAIN_REG07       0x2a
+    #define HUE_HUE_RANGE_REG07     0x2b
+    #define HUE_RANGE_INV_REG07     0x2c
+    #define HUE_LUM_RANGE_REG07     0x2d
+    #define HUE_SAT_RANGE_REG07     0x2e
+    #define SAT_SAT_RANGE_REG07     0x2f
+
+//  REG_CHROMA_CONTROL
+//  Bit 31      reg_chroma_en               enable color manage function
+//                                          1'b1: enable    1'b0: bypass
+//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
+//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
+//  Bit 5       uv_adj_en                   final uv_adjust enable
+//                                          1'b1: enable    1'b0: bypass
+//  Bit 2       hue_en                      rgb to hue enable
+//                                          1'b1: enable(default)   1'b0: bypass
+//  Bit 1:0     csc_sel                     define input YUV with different color type
+//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
+//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
+    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024
+    #define REG_DEMO_CENTER_BAR     0x31   // default 32h'0
+    #define REG_DEMO_HLIGHT_MODE    0x32   // default 32h'0
+    #define REG_DEMO_OWR_DATA       0x33   // default 32h'0
+
+
+////===========================================////
+//// CM2 ADDR
+////===========================================////
+
+    #define SAT_BYYB_NODE_REG0          0x200   // default 32'h0
+//Bit 31:24, sat_byyb_node3    the 4th node
+//Bit 23:16, sat_byyb_node2    the 3th node
+//Bit 15: 8, sat_byyb_node1    signed, the 2th node about saturation
+//Bit  7: 0, sat_byyb_node0    signed, the 1th node about saturation
+//gain offset along y coordinate,the gain normalized to 128 as "1"
+
+	#define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
+//Bit 31:24, sat_byyb_node7     the 8th node
+//Bit 23:16, sat_byyb_node6     the 7th node
+//Bit 15: 8, sat_byyb_node5     signed, the 6th node about saturation
+//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
+//gain offset along y coordinate,the gain normalized to 128 as "1"
+
+    #define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
+//Bit 31: 8, reserved
+//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
+
+
+    #define SAT_SRC_NODE_REG            0x203   // default 32'h0
+//Bit 31:28, reserved
+//Bit 27:16, sat_src_node1
+//Bit 15:12, reserved
+//Bit 11: 0, sat_src_node0     usigned, threshold of input saturation for  first and second piece
+
+    #define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
+//Bit 31: 9, reserved
+//Bit  8: 6, hue_lsft_mode        hue offset adjustments scale
+//Bit  5: 4, luma_lsft_mode       luma offset adjustments scale for reg_cm2_adj_luma_via_hue
+//Bit  3: 2, sat_byy_rsft_mode    saturation gain adjustments scale for reg_cm2_adj_sat_via_y
+//Bit  1: 0, sat_byhs_rsft_mode   saturation gain adjustments scale for reg_cm2_adj_sat_via_hs[:][:] 0:no scale up/down 1:dnscale by 2(-128,127)/2
+
+    #define FRM_SIZE_REG                0x205   // default 32'h0
+//Bit 31:29, reserved
+//Bit 28:16, reg_frm_height       the frame height size
+//Bit 15:13, reserved
+//Bit 12: 0, reg_frm_width        the frame width size
+
+    #define FITLER_CFG_REG              0x206   // default 32'h0
+//Bit 31: 5, reserved
+//Bit  4: 4, inteleav_mod         horizontal interleave filter(zero-padding) for 3D considerations 0:using non-zero padding lpf 1:using zero-padding lpf
+//Bit  3: 2, lpf_slt_uv           apply cm on lp portion or original video pixels options
+//Bit  1: 0, lpf_slt_y            apply cm on lp portion or original video pixels options
+
+    #define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
+//Bit 31:28, reserved
+//Bit 27:16, cm2_global_sat     global saturation gain for general color adjustments(0~4095 <=> 0~8),512 normalized to "1"
+//Bit 15:12, reserved
+//Bit 11: 0, cm2_global_hue     global hue offsets for general color adjustments(0~4095 <=> 0~360 degree)
+
+    #define CM_ENH_CTL_REG              0x208   // default 32'h0
+//Bit  31:7, reserved
+//Bit     6, hue_adj_en        cm2 hue adjustments
+//Bit     5, sat_adj_en        cm2 saturation adjustments
+//Bit     4, luma_adj_en       enable siganl for cm2 luma adjustments
+//Bit     3, reserved
+//Bit     2, cm2_filt_en       apply cm on lp portion enable
+//Bit     1, cm2_en            cm2 enable siganl
+//Bit     0, cm1_en
+
+    #define ROI_X_SCOPE_REG             0x209   // default 32'h0
+//Bit 31:29, reserved
+//Bit 28:16, roi_x_end      ending col index of the region of interest
+//Bit 15:13, reserved
+//Bit 12: 0, roi_x_beg      start col index of the region of interest
+
+   #define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
+//Bit 31:29, reserved
+//Bit 28:16, roi_y_end      ending row index of the region of interest
+//Bit 15:13, reserved
+//Bit 12: 0, roi_y_beg      start row index of the region of interest
+
+    #define POI_XY_DIR_REG              0x20b   // default 32'h0
+//Bit 31:29, reserved
+//Bit 28:16, poi_y_dir      ending row index of the region of interest
+//Bit 15:13, reserved
+//Bit 12: 0, poi_x_dir      start row index of the region of interest
+
+    #define COI_Y_SCOPE_REG             0x20c   // default 32'h0
+//Bit 31:16, reserved
+//Bit 15: 8, coi_y_end
+//Bit  7: 0, coi_y_beg
+
+    #define COI_H_SCOPE_REG             0x20d   // default 32'h0
+//Bit 31:28, reserved
+//Bit 27:16, coi_h_end
+//Bit 15:12, reserved
+//Bit 11: 0, coi_h_beg        lower bound of hue value for color of interest ,12 bits precision
+
+    #define COI_S_SCOPE_REG             0x20e   // default 32'h0
+//Bit 31:28, reserved
+//Bit 27:16, coi_s_end
+//Bit 15:12, reserved
+//Bit 11: 0, coi_s_beg        lower bound of sat value for color of interest ,12 bits precision
+    #define IFO_MODE_REG                0x20f   // default 32'h0
+//Bit 31:8, reserved
+//Bit  7:6, ifo_mode3
+//Bit  5:4, ifo_mode2
+//Bit  3:2, ifo_mode1
+//Bit  1:0, ifo_mode0
+    #define POI_RPL_MODE_REG            0x210   // default 32'h0
+//Bit 31:4, reserved
+//Bit  3:0, poi_rpl_mode          enhance mode control of pixels inside and outside region of interest bit[3:2]control roi
+    #define DEMO_OWR_YHS_REG            0x211   // default 32'h0
+//Bit 31: 0, demo_owr_yhs
+
+    #define DEMO_POI_Y_REG              0x212   // default 32'h0
+//Bit 31: 8, reserved
+//Bit  7: 0, luma_data_poi_r       only get locked higher 8bits
+    #define DEMO_POI_H_REG              0x213   // default 32'h0
+//Bit 31: 12, reserved
+//Bit 11: 0, hue_data_poi_r        only get locked higher 12bits
+    #define DEMO_POI_S_REG              0x214   // default 32'h0
+//Bit 31: 12, reserved
+//Bit 11: 0, sat_data_poi_r         only get locked higher 12bits
+    //#define LUMA_BYH_LIMT_REG           0x215   // default 32'h0
+    #define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
+//Bit 31:24, reserved
+//Bit 23:16, luma_lmt_satslp         slope to do the luma adjustment degrade
+//Bit 15:12, reserved
+//Bit 11:0, luma_lmt_satth           threshold to saturation
+    #define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
+//Bit 31:24, reserved
+//Bit 23:16, sat_lmt_satslp        slope to do the adjustment degrade
+//Bit 15:12, reserved
+//Bit 11:0, sat_lmt_satth          threshold to saturation
+    #define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
+//Bit 31: 24, reserved
+//Bit 23: 16, hue_lmt_satslp        slope to do the adjustment degrade
+//Bit 15: 12, reserved
+//Bit 11: 0,  hue_lmt_satth          threshold to saturation
+    #define UVHS_OFST_REG               0x218   // default 32'h0
+//Bit 31: 24, hs2uv_v_ofst
+//Bit 23: 16, hs2uv_u_ofst
+//Bit 15: 8,  uv2hs_v_ofst
+//Bit  7: 0,  uv2hs_u_ofst
+    #define HUE_CFG_PARA_REG            0x219   // default 32'h0
+//Bit 31: 17, reserved
+//Bit     16, hue_protect_en
+//Bit 15: 13, cm2_hue_byhs_mode
+//Bit     12, cm2_hue_div_mode
+//Bit 11: 0, cm2_before_hue_ofst
+    #define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
+//Bit 31: 22, reserved
+//Bit 21: 20, demo_split_mode
+//Bit 19: 16, demo_split_width        slope to do the adjustment degrade
+//Bit 15: 13, reserved
+//Bit 12: 0,  demo_split_post           threshold to saturation
+    #define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0
+//Bit 31: 0,  demo_splt_yhs             threshold to saturation
+
+    #define XVYCC_YSCP_REG              0x21c   // default 32'h0
+//Bit 31: 28, reserved
+//Bit 27: 16, xvycc_y_max
+//Bit 15: 12, reserved
+//Bit 11: 0, xvycc_y_min
+    #define XVYCC_USCP_REG              0x21d   // default 32'h0
+//Bit 31: 28, reserved
+//Bit 27: 16, xvycc_u_max
+//Bit 15: 12, reserved
+//Bit 11: 0, xvycc_u_min
+    #define XVYCC_VSCP_REG              0x21e   // default 32'h0
+//Bit 31: 28, reserved
+//Bit 27: 16, xvycc_v_max
+//Bit 15: 12, reserved
+//Bit 11: 0, xvycc_v_min
+
+////========= NODE 0 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
+//Bit 31: 24, reg_cm2_adj_sat_via_hs_2
+//Bit 23: 16, reg_cm2_adj_sat_via_hs_1
+//Bit 15: 8,  reg_cm2_adj_sat_via_hs_0
+//Bit  7: 0, reg_cm2_adj_luma_via_h
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 1 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 2 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 3 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 4 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 5 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 6 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 7 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 8 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 9 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 10 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 11 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 12 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 13 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+
+/* Constraints
+0)
+  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
+  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
+  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
+  the 8 regions for hue adjustment are defined by: (example are for region 0)
+    a) hue:
+        start: reg_hue_hue_shift_start_00[14:0]
+        end:
+        if reg_symmetry_en_00 == 0
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
+        if reg_symmetry_en_00 == 1
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
+    b) sat:
+        start: reg_hue_sat_low_00
+        end:   reg_hue_sat_high_00
+
+  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
+  the 8 regions for sat adjustment are defined by: (example are for region 0)
+    a) hue: same as that for hue adjustment.
+        start: reg_hue_hue_shift_start_00[14:0]
+        end:
+        if reg_symmetry_en_00 == 0
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
+        if reg_symmetry_en_00 == 1
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
+    b) sat:
+        start: reg_sat_sat_low_00
+        end:   reg_sat_sat_high_00
+
+1)
+  reg_hue_hue_shift_range_00[7:0]:
+  reg_hue_hue_shift_range_01[7:0]:
+  reg_hue_hue_shift_range_02[7:0]:
+  reg_hue_hue_shift_range_03[7:0]:
+  reg_hue_hue_shift_range_04[7:0]:
+  reg_hue_hue_shift_range_05[7:0]:
+  reg_hue_hue_shift_range_06[7:0]:
+  reg_hue_hue_shift_range_07[7:0]:
+  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx
+
+2)
+  all regions of 0-7 should meet below requirement. below is just an example for region 7.
+  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >=
+        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)
+
+  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
+        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)
+
+  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
+        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)
+
+  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
+        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)
+
+3)
+  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
+  only region 0 and 1 can exceed 360 degrees. ie:
+    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
+    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
+  but below should be met:
+    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
+    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
+    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
+    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
+
+  others could not exceed 360 degrees. ie:
+    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
+    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.
+
+4)
+  reg_hue_gain_00[7:0] <= 0x80.
+  reg_hue_gain_01[7:0] <= 0x80.
+  reg_hue_gain_02[7:0] <= 0x80.
+  reg_hue_gain_03[7:0] <= 0x80.
+  reg_hue_gain_04[7:0] <= 0x80.
+  reg_hue_gain_05[7:0] <= 0x80.
+  reg_hue_gain_06[7:0] <= 0x80.
+  reg_hue_gain_07[7:0] <= 0x80.
+
+5)
+  below registers can only have two setting: 00 and 01.
+    reg_hue_central_en_00[1:0]  .. _07[1:0]
+    reg_sat_central_en_00[1:0]  .. _07[1:0]
+
+6)
+  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
+   for example: below is for region 0:
+   reg_hue_lum_low_slope_00[3:0]  <= 7
+   reg_hue_lum_high_slope_00[3:0] <= 7
+   reg_hue_sat_low_slope_00[3:0]  <= 7
+   reg_hue_sat_high_slope_00[3:0] <= 7
+   reg_sat_lum_low_slope_00[3:0]  <= 7
+   reg_sat_lum_high_slope_00[3:0] <= 7
+   reg_sat_sat_low_slope_00[3:0]  <= 7
+   reg_sat_sat_high_slope_00[3:0] <= 7
+*/
+
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  chroma_reg.h
+//
+//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
+//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock
+//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again
+//because the register itself canot be set again without clk
+//Bit 31:0
+#define   VPP_GCLK_CTRL0                           (0x1d72)
+#define P_VPP_GCLK_CTRL0                           (volatile unsigned int *)((0x1d72  << 2) + 0xff900000)
+//(front_lti), (front_cti), Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
+//Bit 13:0
+#define   VPP_GCLK_CTRL1                           (0x1d73)
+#define P_VPP_GCLK_CTRL1                           (volatile unsigned int *)((0x1d73  << 2) + 0xff900000)
+//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
+//Bit 11:0
+#define   VPP_SC_GCLK_CTRL                         (0x1d74)
+#define P_VPP_SC_GCLK_CTRL                         (volatile unsigned int *)((0x1d74  << 2) + 0xff900000)
+//Bit 17:9 VD1 alpha for preblend
+//Bit 8:0 VD1 alpha for postblend
+#define   VPP_MISC1                                (0x1d76)
+#define P_VPP_MISC1                                (volatile unsigned int *)((0x1d76  << 2) + 0xff900000)
+//Bit 31:0 super scalar clock control
+#define   VPP_SRSCL_GCLK_CTRL                      (0x1d77)
+#define P_VPP_SRSCL_GCLK_CTRL                      (volatile unsigned int *)((0x1d77  << 2) + 0xff900000)
+//Bit 31:0 OSD super scalar clock control
+#define   VPP_OSDSR_GCLK_CTRL                      (0x1d78)
+#define P_VPP_OSDSR_GCLK_CTRL                      (volatile unsigned int *)((0x1d78  << 2) + 0xff900000)
+//Bit 31:0 vvycc clock control
+#define   VPP_XVYCC_GCLK_CTRL                      (0x1d79)
+#define P_VPP_XVYCC_GCLK_CTRL                      (volatile unsigned int *)((0x1d79  << 2) + 0xff900000)
+//Bit 31:24     blackext_start
+//Bit 23:16     blackext_slope1
+//Bit 15:8      blackext_midpt
+//Bit 7:0       blackext_slope2
+#define   VPP_BLACKEXT_CTRL                        (0x1d80)
+#define P_VPP_BLACKEXT_CTRL                        (volatile unsigned int *)((0x1d80  << 2) + 0xff900000)
+//Bit 31:24     bottom of region03 output value
+//Bit 23:16     bottom of region02 output value
+//Bit 15:8      bottom of region01 output value
+//Bit 7:0       bottom of region00 output value
+#define   VPP_DNLP_CTRL_00                         (0x1d81)
+#define P_VPP_DNLP_CTRL_00                         (volatile unsigned int *)((0x1d81  << 2) + 0xff900000)
+//Bit 31:24     bottom of region07 output value
+//Bit 23:16     bottom of region06 output value
+//Bit 15:8      bottom of region05 output value
+//Bit 7:0       bottom of region04 output value
+#define   VPP_DNLP_CTRL_01                         (0x1d82)
+#define P_VPP_DNLP_CTRL_01                         (volatile unsigned int *)((0x1d82  << 2) + 0xff900000)
+//Bit 31:24     bottom of region11 output value
+//Bit 23:16     bottom of region10 output value
+//Bit 15:8      bottom of region09 output value
+//Bit 7:0       bottom of region08 output value
+#define   VPP_DNLP_CTRL_02                         (0x1d83)
+#define P_VPP_DNLP_CTRL_02                         (volatile unsigned int *)((0x1d83  << 2) + 0xff900000)
+//Bit 31:24     bottom of region15 output value
+//Bit 23:16     bottom of region14 output value
+//Bit 15:8      bottom of region13 output value
+//Bit 7:0       bottom of region12 output value
+#define   VPP_DNLP_CTRL_03                         (0x1d84)
+#define P_VPP_DNLP_CTRL_03                         (volatile unsigned int *)((0x1d84  << 2) + 0xff900000)
+//Bit 31:24     bottom of region19 output value
+//Bit 23:16     bottom of region18 output value
+//Bit 15:8      bottom of region17 output value
+//Bit 7:0       bottom of region16 output value
+#define   VPP_DNLP_CTRL_04                         (0x1d85)
+#define P_VPP_DNLP_CTRL_04                         (volatile unsigned int *)((0x1d85  << 2) + 0xff900000)
+//Bit 31:24     bottom of region23 output value
+//Bit 23:16     bottom of region22 output value
+//Bit 15:8      bottom of region21 output value
+//Bit 7:0       bottom of region20 output value
+#define   VPP_DNLP_CTRL_05                         (0x1d86)
+#define P_VPP_DNLP_CTRL_05                         (volatile unsigned int *)((0x1d86  << 2) + 0xff900000)
+//Bit 31:24     bottom of region27 output value
+//Bit 23:16     bottom of region26 output value
+//Bit 15:8      bottom of region25 output value
+//Bit 7:0       bottom of region24 output value
+#define   VPP_DNLP_CTRL_06                         (0x1d87)
+#define P_VPP_DNLP_CTRL_06                         (volatile unsigned int *)((0x1d87  << 2) + 0xff900000)
+//Bit 31:24     bottom of region31 output value
+//Bit 23:16     bottom of region30 output value
+//Bit 15:8      bottom of region29 output value
+//Bit 7:0       bottom of region28 output value
+#define   VPP_DNLP_CTRL_07                         (0x1d88)
+#define P_VPP_DNLP_CTRL_07                         (volatile unsigned int *)((0x1d88  << 2) + 0xff900000)
+//Bit 31:24     bottom of region35 output value
+//Bit 23:16     bottom of region34 output value
+//Bit 15:8      bottom of region33 output value
+//Bit 7:0       bottom of region32 output value
+#define   VPP_DNLP_CTRL_08                         (0x1d89)
+#define P_VPP_DNLP_CTRL_08                         (volatile unsigned int *)((0x1d89  << 2) + 0xff900000)
+//Bit 31:24     bottom of region39 output value
+//Bit 23:16     bottom of region38 output value
+//Bit 15:8      bottom of region37 output value
+//Bit 7:0       bottom of region36 output value
+#define   VPP_DNLP_CTRL_09                         (0x1d8a)
+#define P_VPP_DNLP_CTRL_09                         (volatile unsigned int *)((0x1d8a  << 2) + 0xff900000)
+//Bit 31:24     bottom of region43 output value
+//Bit 23:16     bottom of region42 output value
+//Bit 15:8      bottom of region41 output value
+//Bit 7:0       bottom of region40 output value
+#define   VPP_DNLP_CTRL_10                         (0x1d8b)
+#define P_VPP_DNLP_CTRL_10                         (volatile unsigned int *)((0x1d8b  << 2) + 0xff900000)
+//Bit 31:24     bottom of region47 output value
+//Bit 23:16     bottom of region46 output value
+//Bit 15:8      bottom of region45 output value
+//Bit 7:0       bottom of region44 output value
+#define   VPP_DNLP_CTRL_11                         (0x1d8c)
+#define P_VPP_DNLP_CTRL_11                         (volatile unsigned int *)((0x1d8c  << 2) + 0xff900000)
+//Bit 31:24     bottom of region51 output value
+//Bit 23:16     bottom of region50 output value
+//Bit 15:8      bottom of region49 output value
+//Bit 7:0       bottom of region48 output value
+#define   VPP_DNLP_CTRL_12                         (0x1d8d)
+#define P_VPP_DNLP_CTRL_12                         (volatile unsigned int *)((0x1d8d  << 2) + 0xff900000)
+//Bit 31:24     bottom of region55 output value
+//Bit 23:16     bottom of region54 output value
+//Bit 15:8      bottom of region53 output value
+//Bit 7:0       bottom of region52 output value
+#define   VPP_DNLP_CTRL_13                         (0x1d8e)
+#define P_VPP_DNLP_CTRL_13                         (volatile unsigned int *)((0x1d8e  << 2) + 0xff900000)
+//Bit 31:24     bottom of region59 output value
+//Bit 23:16     bottom of region58 output value
+//Bit 15:8      bottom of region57 output value
+//Bit 7:0       bottom of region56 output value
+#define   VPP_DNLP_CTRL_14                         (0x1d8f)
+#define P_VPP_DNLP_CTRL_14                         (volatile unsigned int *)((0x1d8f  << 2) + 0xff900000)
+//Bit 31:24     bottom of region63 output value
+//Bit 23:16     bottom of region62 output value
+//Bit 15:8      bottom of region61 output value
+//Bit 7:0       bottom of region60 output value
+#define   VPP_DNLP_CTRL_15                         (0x1d90)
+#define P_VPP_DNLP_CTRL_15                         (volatile unsigned int *)((0x1d90  << 2) + 0xff900000)
+// `define VPP_PEAKING_HGAIN       8'h91   //32'h0
+// `define VPP_PEAKING_VGAIN       8'h92   //32'h0
+// `define VPP_PEAKING_NLP_1       8'h93   //32'h0
+// `define VPP_PEAKING_NLP_2       8'h94   //32'h0
+// `define VPP_PEAKING_NLP_3       8'h95   //32'h0
+// `define VPP_PEAKING_NLP_4       8'h96   //32'h0
+// `define VPP_PEAKING_NLP_5       8'h97   //32'h0
+// `define VPP_SHARP_LIMIT         8'h98   //32'h0
+// `define VPP_VLTI_CTRL           8'h99   //32'h0
+// `define VPP_HLTI_CTRL           8'h9a   //32'h0
+// `define VPP_CTI_CTRL            8'h9b   //32'h0
+#define   VPP_SRSHARP0_CTRL                        (0x1d91)
+#define P_VPP_SRSHARP0_CTRL                        (volatile unsigned int *)((0x1d91  << 2) + 0xff900000)
+//Bit 31:29  reserved
+//Bit 28:16  srsharp_demo_split_sz   srsharp demo top/bot left/right width
+//Bit 15:6   reserved
+//Bit 5:4    srsharp_demo_disp_post  srsharp demo display postion
+//Bit 3      srsharp_demo_en         srsharp demo enable
+//Bit 2      srsharp_c444to422_en    srsharp format444 convert 422 enable
+//Bit 1,     srsharp_buf_en          srsharp buffer enable
+//Bit 0,     srsharp_en              srsharp enable
+#define   VPP_SRSHARP1_CTRL                        (0x1d92)
+#define P_VPP_SRSHARP1_CTRL                        (volatile unsigned int *)((0x1d92  << 2) + 0xff900000)
+//Bit 31:29  reserved
+//Bit 28:16  srsharp_demo_split_sz   srsharp demo top/bot left/right width
+//Bit 15:6   reserved
+//Bit 5:4    srsharp_demo_disp_post  srsharp demo display postion
+//Bit 3      srsharp_demo_en         srsharp demo enable
+//Bit 2      srsharp_c444to422_en    srsharp format444 convert 422 enable
+//Bit 1,     srsharp_buf_en          srsharp buffer enable
+//Bit 0,     srsharp_en              srsharp enable
+#define   VPP_DOLBY_CTRL                           (0x1d93)
+#define P_VPP_DOLBY_CTRL                           (volatile unsigned int *)((0x1d93  << 2) + 0xff900000)
+//todo
+#define   VPP_DAT_CONV_PARA0                       (0x1d94)
+#define P_VPP_DAT_CONV_PARA0                       (volatile unsigned int *)((0x1d94  << 2) + 0xff900000)
+#define   VPP_DAT_CONV_PARA1                       (0x1d95)
+#define P_VPP_DAT_CONV_PARA1                       (volatile unsigned int *)((0x1d95  << 2) + 0xff900000)
+//todo
+#define   VPP_SYNC_SEL0                            (0x1d96)
+#define P_VPP_SYNC_SEL0                            (volatile unsigned int *)((0x1d96  << 2) + 0xff900000)
+#define   VPP_VADJ1_BLACK_VAL                      (0x1d97)
+#define P_VPP_VADJ1_BLACK_VAL                      (volatile unsigned int *)((0x1d97  << 2) + 0xff900000)
+#define   VPP_VADJ2_BLACK_VAL                      (0x1d98)
+#define P_VPP_VADJ2_BLACK_VAL                      (volatile unsigned int *)((0x1d98  << 2) + 0xff900000)
+//Bit 29        blue_stretch_cb_inc
+//Bit 28        blue_stretch_cr_inc
+//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
+//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
+//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
+//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
+//Bit 23:16     blue_stretch_gain
+//Bit 15:8      blue_stretch_gain_cb4cr
+//Bit 7:0       blue_stretch_luma_high
+#define   VPP_BLUE_STRETCH_1                       (0x1d9c)
+#define P_VPP_BLUE_STRETCH_1                       (volatile unsigned int *)((0x1d9c  << 2) + 0xff900000)
+//Bit 31:27     blue_stretch_error_crp
+//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
+//Bit 15:11     blue_stretch_error_crn
+//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
+#define   VPP_BLUE_STRETCH_2                       (0x1d9d)
+#define P_VPP_BLUE_STRETCH_2                       (volatile unsigned int *)((0x1d9d  << 2) + 0xff900000)
+//Bit 31:27     blue_stretch_error_cbp
+//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
+//Bit 15:11     blue_stretch_error_cbn
+//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
+#define   VPP_BLUE_STRETCH_3                       (0x1d9e)
+#define P_VPP_BLUE_STRETCH_3                       (volatile unsigned int *)((0x1d9e  << 2) + 0xff900000)
+//Bit 25:16 bypass_ccoring_ythd
+//Bit 15:8, Chroma coring threshold
+//Bit 3:0, Chroma coring slope
+#define   VPP_CCORING_CTRL                         (0x1da0)
+#define P_VPP_CCORING_CTRL                         (volatile unsigned int *)((0x1da0  << 2) + 0xff900000)
+//Bit 20 demo chroma coring enable
+//Bit 19 demo black enxtension enable
+//Bit 18 demo dynamic nonlinear luma processing enable
+//Bit 17 demo hsvsharp enable
+//Bit 16 demo bluestretch enable
+//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
+//Bit 4 chroma coring enable
+//Bit 3 black enxtension enable
+//Bit 2 dynamic nonlinear luma processing enable
+//Bit 1 hsvsharp enable
+//Bit 0 bluestretch enable
+#define   VPP_VE_ENABLE_CTRL                       (0x1da1)
+#define P_VPP_VE_ENABLE_CTRL                       (volatile unsigned int *)((0x1da1  << 2) + 0xff900000)
+//Bit 12:0, demo left or top screen width
+#define   VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH        (0x1da2)
+#define P_VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH        (volatile unsigned int *)((0x1da2  << 2) + 0xff900000)
+#define   VPP_VE_DEMO_CENTER_BAR                   (0x1da3)
+#define P_VPP_VE_DEMO_CENTER_BAR                   (volatile unsigned int *)((0x1da3  << 2) + 0xff900000)
+//28:16  ve_line_length
+//12:0   ve_pic_height
+#define   VPP_VE_H_V_SIZE                          (0x1da4)
+#define P_VPP_VE_H_V_SIZE                          (volatile unsigned int *)((0x1da4  << 2) + 0xff900000)
+//28:16  vppout_line_length
+//12:0   vppout_pic_height
+#define   VPP_OUT_H_V_SIZE                         (0x1da5)
+#define P_VPP_OUT_H_V_SIZE                         (volatile unsigned int *)((0x1da5  << 2) + 0xff900000)
+//28:16  vppin_line_length
+//12:0   vppin_pic_height
+#define   VPP_IN_H_V_SIZE                          (0x1da6)
+#define P_VPP_IN_H_V_SIZE                          (volatile unsigned int *)((0x1da6  << 2) + 0xff900000)
+//Bit 10   reset bit, high active
+//Bit 9    0: measuring rising edge, 1: measuring falling edge
+//Bit 8    if true, accumulate the counter number, otherwise not
+//Bit 7:0  vsync_span, define how many vsync span need to measure
+#define   VPP_VDO_MEAS_CTRL                        (0x1da8)
+#define P_VPP_VDO_MEAS_CTRL                        (volatile unsigned int *)((0x1da8  << 2) + 0xff900000)
+//Read only
+//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
+//15:0, high bit portion of counter
+#define   VPP_VDO_MEAS_VS_COUNT_HI                 (0x1da9)
+#define P_VPP_VDO_MEAS_VS_COUNT_HI                 (volatile unsigned int *)((0x1da9  << 2) + 0xff900000)
+//Read only
+//31:0, low bit portion of counter
+#define   VPP_VDO_MEAS_VS_COUNT_LO                 (0x1daa)
+#define P_VPP_VDO_MEAS_VS_COUNT_LO                 (volatile unsigned int *)((0x1daa  << 2) + 0xff900000)
+//bit 11:9 vd2_sel,  001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
+//bit 8:6 vd1_l_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
+//bit 5:3 vd1_r_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
+//note: the source vd1_l_sel selected cannot be used as the source of vd1_r_sel or vd2_sel
+// vd1_r_sel is useful only vd1_interleave_mode is not 00. And the source vd1_r_sel used can not used for the vd2_sel any more.
+//bit 2:0 vd1_interleave_mode, 000: no interleave, 001: pixel interleaving, 010: line interleaving, 011: 2 pixel interleaving,
+// 100: 2 line interleaving
+#define   VPP_INPUT_CTRL                           (0x1dab)
+#define P_VPP_INPUT_CTRL                           (volatile unsigned int *)((0x1dab  << 2) + 0xff900000)
+//bit 25:24 cti_bpf_sel
+//bit 20:16 cti_blend_factor_gama
+//bit 12:8 cti_blend_factor_beta
+//bit 4:0 cti_blend_factor_alpha
+#define   VPP_CTI_CTRL2                            (0x1dac)
+#define P_VPP_CTI_CTRL2                            (volatile unsigned int *)((0x1dac  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD1                     (0x1dad)
+#define P_VPP_PEAKING_SAT_THD1                     (volatile unsigned int *)((0x1dad  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD2                     (0x1dae)
+#define P_VPP_PEAKING_SAT_THD2                     (volatile unsigned int *)((0x1dae  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD3                     (0x1daf)
+#define P_VPP_PEAKING_SAT_THD3                     (volatile unsigned int *)((0x1daf  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD4                     (0x1db0)
+#define P_VPP_PEAKING_SAT_THD4                     (volatile unsigned int *)((0x1db0  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD5                     (0x1db1)
+#define P_VPP_PEAKING_SAT_THD5                     (volatile unsigned int *)((0x1db1  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD6                     (0x1db2)
+#define P_VPP_PEAKING_SAT_THD6                     (volatile unsigned int *)((0x1db2  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD7                     (0x1db3)
+#define P_VPP_PEAKING_SAT_THD7                     (volatile unsigned int *)((0x1db3  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD8                     (0x1db4)
+#define P_VPP_PEAKING_SAT_THD8                     (volatile unsigned int *)((0x1db4  << 2) + 0xff900000)
+#define   VPP_PEAKING_SAT_THD9                     (0x1db5)
+#define P_VPP_PEAKING_SAT_THD9                     (volatile unsigned int *)((0x1db5  << 2) + 0xff900000)
+#define   VPP_PEAKING_GAIN_ADD1                    (0x1db6)
+#define P_VPP_PEAKING_GAIN_ADD1                    (volatile unsigned int *)((0x1db6  << 2) + 0xff900000)
+#define   VPP_PEAKING_GAIN_ADD2                    (0x1db7)
+#define P_VPP_PEAKING_GAIN_ADD2                    (volatile unsigned int *)((0x1db7  << 2) + 0xff900000)
+//bit 23:16 peaking_dnlp_gain, u5.3, DNLP effect
+//bit 15:8  peaking_factor
+//bit 5     peaking_dnlp_demo_en
+//bit 4     peaking_dnlp_en
+//bit 3:0   peaking_filter_sel
+#define   VPP_PEAKING_DNLP                         (0x1db8)
+#define P_VPP_PEAKING_DNLP                         (volatile unsigned int *)((0x1db8  << 2) + 0xff900000)
+//bit 24    sharp_demo_win_en
+//bit 23:12 sharp_demo_win_vend
+//bit 11:0  sharp_demo_win_vstart
+#define   VPP_SHARP_DEMO_WIN_CTRL1                 (0x1db9)
+#define P_VPP_SHARP_DEMO_WIN_CTRL1                 (volatile unsigned int *)((0x1db9  << 2) + 0xff900000)
+//bit 23:12 sharp_demo_win_hend
+//bit 11:0  sharp_demo_win_hstart
+#define   VPP_SHARP_DEMO_WIN_CTRL2                 (0x1dba)
+#define P_VPP_SHARP_DEMO_WIN_CTRL2                 (volatile unsigned int *)((0x1dba  << 2) + 0xff900000)
+//Bit 31:24     front_hlti_neg_gain
+//Bit 23:16     front_hlti_pos_gain
+//Bit 15:8      front_hlti_threshold
+//Bit 7:0       front_hlti_blend_factor
+#define   VPP_FRONT_HLTI_CTRL                      (0x1dbb)
+#define P_VPP_FRONT_HLTI_CTRL                      (volatile unsigned int *)((0x1dbb  << 2) + 0xff900000)
+//Bit 31        front_enable, enable the front LTI&CTI before scaler
+//Bit 26:24     front_cti_step2
+//Bit 23:21     front_cti_step
+//Bit 20:16     front_cti_blend_factor
+//Bit 15        front_cti_median_mode
+//Bit 14:8      front_cti_threshold
+//Bit 7:0       front_cti_gain
+#define   VPP_FRONT_CTI_CTRL                       (0x1dbc)
+#define P_VPP_FRONT_CTI_CTRL                       (volatile unsigned int *)((0x1dbc  << 2) + 0xff900000)
+//bit 29:28 front_hlti_step
+//bit 25:24 front_cti_bpf_sel
+//bit 20:16 front_cti_blend_factor_gama
+//bit 12:8  front_cti_blend_factor_beta
+//bit 4:0   front_cti_blend_factor_alpha
+#define   VPP_FRONT_CTI_CTRL2                      (0x1dbd)
+#define P_VPP_FRONT_CTI_CTRL2                      (volatile unsigned int *)((0x1dbd  << 2) + 0xff900000)
+//vertical scaler phase step
+//Bit 27:0,  4.24 format
+#define   VPP_OSD_VSC_PHASE_STEP                   (0x1dc0)
+#define P_VPP_OSD_VSC_PHASE_STEP                   (volatile unsigned int *)((0x1dc0  << 2) + 0xff900000)
+//Bit 31:16, botttom vertical scaler initial phase
+//Bit 15:0, top vertical scaler initial phase
+#define   VPP_OSD_VSC_INI_PHASE                    (0x1dc1)
+#define P_VPP_OSD_VSC_INI_PHASE                    (volatile unsigned int *)((0x1dc1  << 2) + 0xff900000)
+//Bit 24    osd vertical Scaler enable
+//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
+//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
+//Bit 20    osd_vsc_phase0_always_en
+//Bit 19    osd_vsc_nearest_en
+//Bit 17:16 osd_vsc_bot_rpt_l0_num
+//Bit 14:11 osd_vsc_bot_ini_rcv_num
+//Bit 9:8   osd_vsc_top_rpt_l0_num
+//Bit 6:3   osd_vsc_top_ini_rcv_num
+//Bit 2:0   osd_vsc_bank_length
+#define   VPP_OSD_VSC_CTRL0                        (0x1dc2)
+#define P_VPP_OSD_VSC_CTRL0                        (volatile unsigned int *)((0x1dc2  << 2) + 0xff900000)
+//horizontal scaler phase step
+//Bit 27:0,  4.24 format
+#define   VPP_OSD_HSC_PHASE_STEP                   (0x1dc3)
+#define P_VPP_OSD_HSC_PHASE_STEP                   (volatile unsigned int *)((0x1dc3  << 2) + 0xff900000)
+//Bit 31:16, horizontal scaler initial phase1
+//Bit 15:0, horizontal scaler initial phase0
+#define   VPP_OSD_HSC_INI_PHASE                    (0x1dc4)
+#define P_VPP_OSD_HSC_INI_PHASE                    (volatile unsigned int *)((0x1dc4  << 2) + 0xff900000)
+//Bit 22   osd horizontal scaler enable
+//Bit 21   osd_hsc_double_pix_mode
+//Bit 20   osd_hsc_phase0_always_en
+//Bit 19   osd_hsc_nearest_en
+//Bit 17:16 osd_hsc_rpt_p0_num1
+//Bit 14:11 osd_hsc_ini_rcv_num1
+//Bit 9:8   osd_hsc_rpt_p0_num0
+//Bit 6:3   osd_hsc_ini_rcv_num0
+//Bit 2:0   osd_hsc_bank_length
+#define   VPP_OSD_HSC_CTRL0                        (0x1dc5)
+#define P_VPP_OSD_HSC_CTRL0                        (volatile unsigned int *)((0x1dc5  << 2) + 0xff900000)
+//for 3D quincunx sub-sampling
+//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
+//bit 6:4  pattern start
+//bit 2:0  pattern end
+#define   VPP_OSD_HSC_INI_PAT_CTRL                 (0x1dc6)
+#define P_VPP_OSD_HSC_INI_PAT_CTRL                 (volatile unsigned int *)((0x1dc6  << 2) + 0xff900000)
+//bit 31:24, componet 0
+//bit 23:16, component 1
+//bit 15:8, component 2
+//bit 7:0 component 3, alpha
+#define   VPP_OSD_SC_DUMMY_DATA                    (0x1dc7)
+#define P_VPP_OSD_SC_DUMMY_DATA                    (volatile unsigned int *)((0x1dc7  << 2) + 0xff900000)
+//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
+//Bit 3 osd scaler path enable
+//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
+#define   VPP_OSD_SC_CTRL0                         (0x1dc8)
+#define P_VPP_OSD_SC_CTRL0                         (volatile unsigned int *)((0x1dc8  << 2) + 0xff900000)
+//Bit 28:16 OSD scaler input width minus 1
+//Bit 12:0 OSD scaler input height minus 1
+#define   VPP_OSD_SCI_WH_M1                        (0x1dc9)
+#define P_VPP_OSD_SCI_WH_M1                        (volatile unsigned int *)((0x1dc9  << 2) + 0xff900000)
+//Bit 28:16 OSD scaler output horizontal start
+//Bit 12:0 OSD scaler output horizontal end
+#define   VPP_OSD_SCO_H_START_END                  (0x1dca)
+#define P_VPP_OSD_SCO_H_START_END                  (volatile unsigned int *)((0x1dca  << 2) + 0xff900000)
+//Bit 28:16 OSD scaler output vertical start
+//Bit 12:0 OSD scaler output vertical end
+#define   VPP_OSD_SCO_V_START_END                  (0x1dcb)
+#define P_VPP_OSD_SCO_V_START_END                  (volatile unsigned int *)((0x1dcb  << 2) + 0xff900000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
+//Bit 6:0 	coef index
+#define   VPP_OSD_SCALE_COEF_IDX                   (0x1dcc)
+#define P_VPP_OSD_SCALE_COEF_IDX                   (volatile unsigned int *)((0x1dcc  << 2) + 0xff900000)
+//coefficients for vertical filter and horizontal filter
+#define   VPP_OSD_SCALE_COEF                       (0x1dcd)
+#define P_VPP_OSD_SCALE_COEF                       (volatile unsigned int *)((0x1dcd  << 2) + 0xff900000)
+//Bit 12:0 line number use to generate interrupt when line == this number
+#define   VPP_INT_LINE_NUM                         (0x1dce)
+#define P_VPP_INT_LINE_NUM                         (volatile unsigned int *)((0x1dce  << 2) + 0xff900000)
+#define   VPP_XVYCC_MISC                           (0x1dcf)
+#define P_VPP_XVYCC_MISC                           (volatile unsigned int *)((0x1dcf  << 2) + 0xff900000)
+// new add lti/cti in 120924
+//Bit  3: 0        //default== 0  reg_hlti_dn_flt_coe[0]
+//Bit  7: 4        //default== 0  reg_hlti_dn_flt_coe[1]
+//Bit 11: 8        //default== 0  reg_hlti_dn_flt_coe[2]
+//Bit 15:12        //default== 2  reg_hlti_dn_flt_coe[3]
+//Bit 19:16        //default== 4  reg_hlti_dn_flt_coe[4]
+//Bit 22:20        //default== 3  reg_hlti_dn_flt_nrm  u3: 3~7
+#define   VPP_HLTI_DN_FLT                          (0x1dd0)
+#define P_VPP_HLTI_DN_FLT                          (volatile unsigned int *)((0x1dd0  << 2) + 0xff900000)
+//Bit  7: 0        //default== 8  reg_hlti_bst_gain  u8, norm 16 as "1"
+//Bit 15: 8        //default== 20 reg_hlti_bst_core  u8, norm 32 as "1"
+//Bit 23:16        //default== 32 reg_hlti_oob_gain  u8, norm 32 as "1"
+//Bit 28:24        //default== 0  reg_hlti_oob_core  u5
+#define   VPP_HLTI_GAIN                            (0x1dd1)
+#define P_VPP_HLTI_GAIN                            (volatile unsigned int *)((0x1dd1  << 2) + 0xff900000)
+//Bit  7: 0        //default== 2  reg_hlti_clp_ofst  u8,
+//Bit     8        //default== 0  reg_hlti_clp_mode  u1,
+//Bit 11: 9        //default== 1  reg_hlti_clp_wind  u3,
+//Bit 14:12        //default== 1  reg_hlti_bst_fltr  u3,
+//Bit    15        //default== 1  reg_hlti_enable    u1,
+#define   VPP_HLTI_PARA                            (0x1dd2)
+#define P_VPP_HLTI_PARA                            (volatile unsigned int *)((0x1dd2  << 2) + 0xff900000)
+//Bit  3: 0        //default== 0  reg_hcti_dn_flt_coe[0]
+//Bit  7: 4        //default== 0  reg_hcti_dn_flt_coe[1]
+//Bit 11: 8        //default== 1  reg_hcti_dn_flt_coe[2]
+//Bit 15:12        //default== 2  reg_hcti_dn_flt_coe[3]
+//Bit 19:16        //default== 2  reg_hcti_dn_flt_coe[4]
+//Bit 22:20        //default== 3  reg_hcti_dn_flt_nrm   u3: 3~7
+#define   VPP_HCTI_DN_FLT                          (0x1dd3)
+#define P_VPP_HCTI_DN_FLT                          (volatile unsigned int *)((0x1dd3  << 2) + 0xff900000)
+//Bit 7: 0        //default== 48 reg_hcti_bst_gain  u8, norm 16 as "1"
+//Bit15: 8        //default== 17 reg_hcti_bst_core  u8, norm 32 as "1"
+//Bit23:16        //default== 16 reg_hcti_oob_gain  u8, norm 32 as "1"
+//Bit28:24        //default==  0 reg_hcti_oob_core  u5
+#define   VPP_HCTI_GAIN                            (0x1dd4)
+#define P_VPP_HCTI_GAIN                            (volatile unsigned int *)((0x1dd4  << 2) + 0xff900000)
+//Bit  7: 0        //default==  0 reg_hcti_clp_ofst  u8,
+//Bit     8        //default==  1 reg_hcti_clp_mode  u1,
+//Bit 11: 9        //default==  3 reg_hcti_clp_wind  u3,
+//Bit 14:12        //default==  6 reg_hcti_bst_fltr  u3,
+//Bit    15        //default==  1 reg_hcti_enable    u1,
+#define   VPP_HCTI_PARA                            (0x1dd5)
+#define P_VPP_HCTI_PARA                            (volatile unsigned int *)((0x1dd5  << 2) + 0xff900000)
+//Bit  7: 0        //default== 48 reg_vcti_bst_gain  u8, normalize 16 as "1"
+//Bit 15: 8        //default== 10 reg_vcti_bst_core  u8
+//Bit 19:16        //default== 10 reg_vcti_clp_ofst  u4
+//Bit    20        //default==  1 reg_vcti_clp_wind  u1, 0: wind 3, 1: wind5
+#define   VPP_VCTI_PARA                            (0x1dd6)
+#define P_VPP_VCTI_PARA                            (volatile unsigned int *)((0x1dd6  << 2) + 0xff900000)
+//`define VPP_MATRIX_PROBE_COLOR1 8'hd7  //defined before
+//Bit 31          //default== 0, urgent fifo hold enable
+//Bit 28:12       //default== 0, urgent fifo hold line threshold
+//Bit 15          //default== 0, urgent_ctrl_en
+//Bit 14          //default== 0, urgent_wr, if true for write buffer
+//Bit 13          //default== 0, out_inv_en
+//Bit 12          //default == 0, urgent_ini_value
+//Bit 11:6        //default == 0, up_th  up threshold
+//Bit 5:0         //default == 0, dn_th  dn threshold
+#define   VPP_OFIFO_URG_CTRL                       (0x1dd8)
+#define P_VPP_OFIFO_URG_CTRL                       (volatile unsigned int *)((0x1dd8  << 2) + 0xff900000)
+#define   VPP_CLIP_MISC0                           (0x1dd9)
+#define P_VPP_CLIP_MISC0                           (volatile unsigned int *)((0x1dd9  << 2) + 0xff900000)
+//Bit 29:20       // default == 1023, final clip r channel top
+//Bit 19:10       // default == 1023, final clip g channel top
+//Bit  9: 0       // default == 1023, final clip b channel top
+#define   VPP_CLIP_MISC1                           (0x1dda)
+#define P_VPP_CLIP_MISC1                           (volatile unsigned int *)((0x1dda  << 2) + 0xff900000)
+//Bit 29:20       // default ==    0, final clip r channel bottom
+//Bit 19:10       // default ==    0, final clip g channel bottom
+//Bit  9: 0       // default ==    0, final clip b channel bottom
+#define   VPP_MATRIX_COEF13_14                     (0x1ddb)
+#define P_VPP_MATRIX_COEF13_14                     (volatile unsigned int *)((0x1ddb  << 2) + 0xff900000)
+//Bit 28:16       // default == 0, matrix coef13
+//Bit 12:0        // default == 0, matrix coef14
+#define   VPP_MATRIX_COEF23_24                     (0x1ddc)
+#define P_VPP_MATRIX_COEF23_24                     (volatile unsigned int *)((0x1ddc  << 2) + 0xff900000)
+//Bit 28:16       // default == 0, matrix coef23
+//Bit 12:0        // default == 0, matrix coef24
+#define   VPP_MATRIX_COEF15_25                     (0x1ddd)
+#define P_VPP_MATRIX_COEF15_25                     (volatile unsigned int *)((0x1ddd  << 2) + 0xff900000)
+//Bit 28:16       // default == 0, matrix coef15
+//Bit 12:0        // default == 0, matrix coef25
+#define   VPP_MATRIX_CLIP                          (0x1dde)
+#define P_VPP_MATRIX_CLIP                          (volatile unsigned int *)((0x1dde  << 2) + 0xff900000)
+//Bit 7:5         //  default == 0,   mat rs
+//Bit 4:3         //  default == 0,   mat clmod
+//Bit 2:0         //  default == 0,   mat clip enable
+#define   VPP_XVYCC_MISC0                          (0x1ddf)
+#define P_VPP_XVYCC_MISC0                          (volatile unsigned int *)((0x1ddf  << 2) + 0xff900000)
+//Bit 29:20       // default == 1023, xvycc clip r channel top
+//Bit 19:10       // default == 1023, xvycc clip g channel top
+//Bit  9: 0       // default == 1023, xvycc clip b channel top
+#define   VPP_XVYCC_MISC1                          (0x1de0)
+#define P_VPP_XVYCC_MISC1                          (volatile unsigned int *)((0x1de0  << 2) + 0xff900000)
+//Bit 29:20       // default ==    0, xvycc clip r channel bottom
+//Bit 19:10       // default ==    0, xvycc clip g channel bottom
+//Bit  9: 0       // default ==    0, xvycc clip b channel bottom
+#define   VPP_VD1_CLIP_MISC0                       (0x1de1)
+#define P_VPP_VD1_CLIP_MISC0                       (volatile unsigned int *)((0x1de1  << 2) + 0xff900000)
+//Bit 29:20       // default == 1023, vd1 clip r channel top
+//Bit 19:10       // default == 1023, vd1 clip g channel top
+//Bit  9: 0       // default == 1023, vd1 clip b channel top
+#define   VPP_VD1_CLIP_MISC1                       (0x1de2)
+#define P_VPP_VD1_CLIP_MISC1                       (volatile unsigned int *)((0x1de2  << 2) + 0xff900000)
+//Bit 29:20       // default ==    0, vd1 clip r channel bottom
+//Bit 19:10       // default ==    0, vd1 clip g channel bottom
+//Bit  9: 0       // default ==    0, vd1 clip b channel bottom
+#define   VPP_VD2_CLIP_MISC0                       (0x1de3)
+#define P_VPP_VD2_CLIP_MISC0                       (volatile unsigned int *)((0x1de3  << 2) + 0xff900000)
+//Bit 29:20       // default == 1023, vd2 clip r channel top
+//Bit 19:10       // default == 1023, vd2 clip g channel top
+//Bit  9: 0       // default == 1023, vd2 clip b channel top
+#define   VPP_VD2_CLIP_MISC1                       (0x1de4)
+#define P_VPP_VD2_CLIP_MISC1                       (volatile unsigned int *)((0x1de4  << 2) + 0xff900000)
+//Bit 29:20       // default ==    0, vd2 clip r channel bottom
+//Bit 19:10       // default ==    0, vd2 clip g channel bottom
+//Bit  9: 0       // default ==    0, vd2 clip b channel bottom
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpp_regs.h
+//
+//`define VIU2_VCBUS_BASE                8'h1e
+//
+// Reading file:  v2regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// Video Interface 2 Registers    0xe00 - 0xeff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VIU2_VCBUS_BASE = 0x1e
+// -----------------------------------------------
+#define   VIU2_ADDR_START                          (0x1e00)
+#define P_VIU2_ADDR_START                          (volatile unsigned int *)((0x1e00  << 2) + 0xff900000)
+#define   VIU2_ADDR_END                            (0x1eff)
+#define P_VIU2_ADDR_END                            (volatile unsigned int *)((0x1eff  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// VIU2 top-level registers
+//------------------------------------------------------------------------------
+// Bit  0 RW, osd1_reset
+// Bit  1 RW, osd2_reset
+// Bit  2 RW, vd1_reset
+// Bit  3 RW, vd1_fmt_reset
+// Bit  7 RW, vpp_reset
+#define   VIU2_SW_RESET                            (0x1e01)
+#define P_VIU2_SW_RESET                            (volatile unsigned int *)((0x1e01  << 2) + 0xff900000)
+#define   VIU2_SW_RESET0                           (0x1e02)
+#define P_VIU2_SW_RESET0                           (volatile unsigned int *)((0x1e02  << 2) + 0xff900000)
+// Bit 0 RW, software reset for mcvecrd_mif
+// Bit 1 RW, software reset for mcinfowr_mif
+// Bit 2 RW, software reset for mcinford_mif
+//bit 8 if true, vsync interrup is generate only field == 0
+//bit 7:0 fix_disable
+#define   VIU2_MISC_CTRL0                          (0x1e06)
+#define P_VIU2_MISC_CTRL0                          (volatile unsigned int *)((0x1e06  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// OSD1 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit 10: 9 Reserved for control signals
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define   VIU2_OSD1_CTRL_STAT                      (0x1e10)
+#define P_VIU2_OSD1_CTRL_STAT                      (volatile unsigned int *)((0x1e10  << 2) + 0xff900000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15: 6 Reserved
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define   VIU2_OSD1_CTRL_STAT2                     (0x1e2d)
+#define P_VIU2_OSD1_CTRL_STAT2                     (volatile unsigned int *)((0x1e2d  << 2) + 0xff900000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define   VIU2_OSD1_COLOR_ADDR                     (0x1e11)
+#define P_VIU2_OSD1_COLOR_ADDR                     (volatile unsigned int *)((0x1e11  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU2_OSD1_COLOR                          (0x1e12)
+#define P_VIU2_OSD1_COLOR                          (volatile unsigned int *)((0x1e12  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU2_OSD1_TCOLOR_AG0                     (0x1e17)
+#define P_VIU2_OSD1_TCOLOR_AG0                     (volatile unsigned int *)((0x1e17  << 2) + 0xff900000)
+#define   VIU2_OSD1_TCOLOR_AG1                     (0x1e18)
+#define P_VIU2_OSD1_TCOLOR_AG1                     (volatile unsigned int *)((0x1e18  << 2) + 0xff900000)
+#define   VIU2_OSD1_TCOLOR_AG2                     (0x1e19)
+#define P_VIU2_OSD1_TCOLOR_AG2                     (volatile unsigned int *)((0x1e19  << 2) + 0xff900000)
+#define   VIU2_OSD1_TCOLOR_AG3                     (0x1e1a)
+#define P_VIU2_OSD1_TCOLOR_AG3                     (volatile unsigned int *)((0x1e1a  << 2) + 0xff900000)
+// Bit 31:30 Reserved
+// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
+// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
+// Bit 27:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define   VIU2_OSD1_BLK0_CFG_W0                    (0x1e1b)
+#define P_VIU2_OSD1_BLK0_CFG_W0                    (volatile unsigned int *)((0x1e1b  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK1_CFG_W0                    (0x1e1f)
+#define P_VIU2_OSD1_BLK1_CFG_W0                    (volatile unsigned int *)((0x1e1f  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK2_CFG_W0                    (0x1e23)
+#define P_VIU2_OSD1_BLK2_CFG_W0                    (volatile unsigned int *)((0x1e23  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK3_CFG_W0                    (0x1e27)
+#define P_VIU2_OSD1_BLK3_CFG_W0                    (volatile unsigned int *)((0x1e27  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define   VIU2_OSD1_BLK0_CFG_W1                    (0x1e1c)
+#define P_VIU2_OSD1_BLK0_CFG_W1                    (volatile unsigned int *)((0x1e1c  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK1_CFG_W1                    (0x1e20)
+#define P_VIU2_OSD1_BLK1_CFG_W1                    (volatile unsigned int *)((0x1e20  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK2_CFG_W1                    (0x1e24)
+#define P_VIU2_OSD1_BLK2_CFG_W1                    (volatile unsigned int *)((0x1e24  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK3_CFG_W1                    (0x1e28)
+#define P_VIU2_OSD1_BLK3_CFG_W1                    (volatile unsigned int *)((0x1e28  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define   VIU2_OSD1_BLK0_CFG_W2                    (0x1e1d)
+#define P_VIU2_OSD1_BLK0_CFG_W2                    (volatile unsigned int *)((0x1e1d  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK1_CFG_W2                    (0x1e21)
+#define P_VIU2_OSD1_BLK1_CFG_W2                    (volatile unsigned int *)((0x1e21  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK2_CFG_W2                    (0x1e25)
+#define P_VIU2_OSD1_BLK2_CFG_W2                    (volatile unsigned int *)((0x1e25  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK3_CFG_W2                    (0x1e29)
+#define P_VIU2_OSD1_BLK3_CFG_W2                    (volatile unsigned int *)((0x1e29  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define   VIU2_OSD1_BLK0_CFG_W3                    (0x1e1e)
+#define P_VIU2_OSD1_BLK0_CFG_W3                    (volatile unsigned int *)((0x1e1e  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK1_CFG_W3                    (0x1e22)
+#define P_VIU2_OSD1_BLK1_CFG_W3                    (volatile unsigned int *)((0x1e22  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK2_CFG_W3                    (0x1e26)
+#define P_VIU2_OSD1_BLK2_CFG_W3                    (volatile unsigned int *)((0x1e26  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK3_CFG_W3                    (0x1e2a)
+#define P_VIU2_OSD1_BLK3_CFG_W3                    (volatile unsigned int *)((0x1e2a  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define   VIU2_OSD1_BLK0_CFG_W4                    (0x1e13)
+#define P_VIU2_OSD1_BLK0_CFG_W4                    (volatile unsigned int *)((0x1e13  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK1_CFG_W4                    (0x1e14)
+#define P_VIU2_OSD1_BLK1_CFG_W4                    (volatile unsigned int *)((0x1e14  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK2_CFG_W4                    (0x1e15)
+#define P_VIU2_OSD1_BLK2_CFG_W4                    (volatile unsigned int *)((0x1e15  << 2) + 0xff900000)
+#define   VIU2_OSD1_BLK3_CFG_W4                    (0x1e16)
+#define P_VIU2_OSD1_BLK3_CFG_W4                    (volatile unsigned int *)((0x1e16  << 2) + 0xff900000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
+// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
+// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
+// Bit    19 R,  fifo_overflow
+//
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define   VIU2_OSD1_FIFO_CTRL_STAT                 (0x1e2b)
+#define P_VIU2_OSD1_FIFO_CTRL_STAT                 (volatile unsigned int *)((0x1e2b  << 2) + 0xff900000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define   VIU2_OSD1_TEST_RDDATA                    (0x1e2c)
+#define P_VIU2_OSD1_TEST_RDDATA                    (volatile unsigned int *)((0x1e2c  << 2) + 0xff900000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define   VIU2_OSD1_PROT_CTRL                      (0x1e2e)
+#define P_VIU2_OSD1_PROT_CTRL                      (volatile unsigned int *)((0x1e2e  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// OSD2 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit    10 RW, hl2_en
+// Bit     9 RW, hl1_en
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define   VIU2_OSD2_CTRL_STAT                      (0x1e30)
+#define P_VIU2_OSD2_CTRL_STAT                      (volatile unsigned int *)((0x1e30  << 2) + 0xff900000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15: 6 Reserved
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define   VIU2_OSD2_CTRL_STAT2                     (0x1e4d)
+#define P_VIU2_OSD2_CTRL_STAT2                     (volatile unsigned int *)((0x1e4d  << 2) + 0xff900000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define   VIU2_OSD2_COLOR_ADDR                     (0x1e31)
+#define P_VIU2_OSD2_COLOR_ADDR                     (volatile unsigned int *)((0x1e31  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU2_OSD2_COLOR                          (0x1e32)
+#define P_VIU2_OSD2_COLOR                          (volatile unsigned int *)((0x1e32  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, hl[1-2]_h/v_start
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, hl[1-2]_h/v_end
+#define   VIU2_OSD2_HL1_H_START_END                (0x1e33)
+#define P_VIU2_OSD2_HL1_H_START_END                (volatile unsigned int *)((0x1e33  << 2) + 0xff900000)
+#define   VIU2_OSD2_HL1_V_START_END                (0x1e34)
+#define P_VIU2_OSD2_HL1_V_START_END                (volatile unsigned int *)((0x1e34  << 2) + 0xff900000)
+#define   VIU2_OSD2_HL2_H_START_END                (0x1e35)
+#define P_VIU2_OSD2_HL2_H_START_END                (volatile unsigned int *)((0x1e35  << 2) + 0xff900000)
+#define   VIU2_OSD2_HL2_V_START_END                (0x1e36)
+#define P_VIU2_OSD2_HL2_V_START_END                (volatile unsigned int *)((0x1e36  << 2) + 0xff900000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   VIU2_OSD2_TCOLOR_AG0                     (0x1e37)
+#define P_VIU2_OSD2_TCOLOR_AG0                     (volatile unsigned int *)((0x1e37  << 2) + 0xff900000)
+#define   VIU2_OSD2_TCOLOR_AG1                     (0x1e38)
+#define P_VIU2_OSD2_TCOLOR_AG1                     (volatile unsigned int *)((0x1e38  << 2) + 0xff900000)
+#define   VIU2_OSD2_TCOLOR_AG2                     (0x1e39)
+#define P_VIU2_OSD2_TCOLOR_AG2                     (volatile unsigned int *)((0x1e39  << 2) + 0xff900000)
+#define   VIU2_OSD2_TCOLOR_AG3                     (0x1e3a)
+#define P_VIU2_OSD2_TCOLOR_AG3                     (volatile unsigned int *)((0x1e3a  << 2) + 0xff900000)
+// Bit 31:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define   VIU2_OSD2_BLK0_CFG_W0                    (0x1e3b)
+#define P_VIU2_OSD2_BLK0_CFG_W0                    (volatile unsigned int *)((0x1e3b  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK1_CFG_W0                    (0x1e3f)
+#define P_VIU2_OSD2_BLK1_CFG_W0                    (volatile unsigned int *)((0x1e3f  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK2_CFG_W0                    (0x1e43)
+#define P_VIU2_OSD2_BLK2_CFG_W0                    (volatile unsigned int *)((0x1e43  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK3_CFG_W0                    (0x1e47)
+#define P_VIU2_OSD2_BLK3_CFG_W0                    (volatile unsigned int *)((0x1e47  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define   VIU2_OSD2_BLK0_CFG_W1                    (0x1e3c)
+#define P_VIU2_OSD2_BLK0_CFG_W1                    (volatile unsigned int *)((0x1e3c  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK1_CFG_W1                    (0x1e40)
+#define P_VIU2_OSD2_BLK1_CFG_W1                    (volatile unsigned int *)((0x1e40  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK2_CFG_W1                    (0x1e44)
+#define P_VIU2_OSD2_BLK2_CFG_W1                    (volatile unsigned int *)((0x1e44  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK3_CFG_W1                    (0x1e48)
+#define P_VIU2_OSD2_BLK3_CFG_W1                    (volatile unsigned int *)((0x1e48  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define   VIU2_OSD2_BLK0_CFG_W2                    (0x1e3d)
+#define P_VIU2_OSD2_BLK0_CFG_W2                    (volatile unsigned int *)((0x1e3d  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK1_CFG_W2                    (0x1e41)
+#define P_VIU2_OSD2_BLK1_CFG_W2                    (volatile unsigned int *)((0x1e41  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK2_CFG_W2                    (0x1e45)
+#define P_VIU2_OSD2_BLK2_CFG_W2                    (volatile unsigned int *)((0x1e45  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK3_CFG_W2                    (0x1e49)
+#define P_VIU2_OSD2_BLK3_CFG_W2                    (volatile unsigned int *)((0x1e49  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define   VIU2_OSD2_BLK0_CFG_W3                    (0x1e3e)
+#define P_VIU2_OSD2_BLK0_CFG_W3                    (volatile unsigned int *)((0x1e3e  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK1_CFG_W3                    (0x1e42)
+#define P_VIU2_OSD2_BLK1_CFG_W3                    (volatile unsigned int *)((0x1e42  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK2_CFG_W3                    (0x1e46)
+#define P_VIU2_OSD2_BLK2_CFG_W3                    (volatile unsigned int *)((0x1e46  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK3_CFG_W3                    (0x1e4a)
+#define P_VIU2_OSD2_BLK3_CFG_W3                    (volatile unsigned int *)((0x1e4a  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define   VIU2_OSD2_BLK0_CFG_W4                    (0x1e64)
+#define P_VIU2_OSD2_BLK0_CFG_W4                    (volatile unsigned int *)((0x1e64  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK1_CFG_W4                    (0x1e65)
+#define P_VIU2_OSD2_BLK1_CFG_W4                    (volatile unsigned int *)((0x1e65  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK2_CFG_W4                    (0x1e66)
+#define P_VIU2_OSD2_BLK2_CFG_W4                    (volatile unsigned int *)((0x1e66  << 2) + 0xff900000)
+#define   VIU2_OSD2_BLK3_CFG_W4                    (0x1e67)
+#define P_VIU2_OSD2_BLK3_CFG_W4                    (volatile unsigned int *)((0x1e67  << 2) + 0xff900000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
+// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
+// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
+// Bit    19 R,  fifo_overflow
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define   VIU2_OSD2_FIFO_CTRL_STAT                 (0x1e4b)
+#define P_VIU2_OSD2_FIFO_CTRL_STAT                 (volatile unsigned int *)((0x1e4b  << 2) + 0xff900000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define   VIU2_OSD2_TEST_RDDATA                    (0x1e4c)
+#define P_VIU2_OSD2_TEST_RDDATA                    (volatile unsigned int *)((0x1e4c  << 2) + 0xff900000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define   VIU2_OSD2_PROT_CTRL                      (0x1e4e)
+#define P_VIU2_OSD2_PROT_CTRL                      (volatile unsigned int *)((0x1e4e  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// VD1 path
+//------------------------------------------------------------------------------
+#define   VIU2_VD1_IF0_GEN_REG                     (0x1e50)
+#define P_VIU2_VD1_IF0_GEN_REG                     (volatile unsigned int *)((0x1e50  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CANVAS0                     (0x1e51)
+#define P_VIU2_VD1_IF0_CANVAS0                     (volatile unsigned int *)((0x1e51  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CANVAS1                     (0x1e52)
+#define P_VIU2_VD1_IF0_CANVAS1                     (volatile unsigned int *)((0x1e52  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA_X0                     (0x1e53)
+#define P_VIU2_VD1_IF0_LUMA_X0                     (volatile unsigned int *)((0x1e53  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA_Y0                     (0x1e54)
+#define P_VIU2_VD1_IF0_LUMA_Y0                     (volatile unsigned int *)((0x1e54  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA_X0                   (0x1e55)
+#define P_VIU2_VD1_IF0_CHROMA_X0                   (volatile unsigned int *)((0x1e55  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA_Y0                   (0x1e56)
+#define P_VIU2_VD1_IF0_CHROMA_Y0                   (volatile unsigned int *)((0x1e56  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA_X1                     (0x1e57)
+#define P_VIU2_VD1_IF0_LUMA_X1                     (volatile unsigned int *)((0x1e57  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA_Y1                     (0x1e58)
+#define P_VIU2_VD1_IF0_LUMA_Y1                     (volatile unsigned int *)((0x1e58  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA_X1                   (0x1e59)
+#define P_VIU2_VD1_IF0_CHROMA_X1                   (volatile unsigned int *)((0x1e59  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA_Y1                   (0x1e5a)
+#define P_VIU2_VD1_IF0_CHROMA_Y1                   (volatile unsigned int *)((0x1e5a  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_RPT_LOOP                    (0x1e5b)
+#define P_VIU2_VD1_IF0_RPT_LOOP                    (volatile unsigned int *)((0x1e5b  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA0_RPT_PAT               (0x1e5c)
+#define P_VIU2_VD1_IF0_LUMA0_RPT_PAT               (volatile unsigned int *)((0x1e5c  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA0_RPT_PAT             (0x1e5d)
+#define P_VIU2_VD1_IF0_CHROMA0_RPT_PAT             (volatile unsigned int *)((0x1e5d  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA1_RPT_PAT               (0x1e5e)
+#define P_VIU2_VD1_IF0_LUMA1_RPT_PAT               (volatile unsigned int *)((0x1e5e  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA1_RPT_PAT             (0x1e5f)
+#define P_VIU2_VD1_IF0_CHROMA1_RPT_PAT             (volatile unsigned int *)((0x1e5f  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA_PSEL                   (0x1e60)
+#define P_VIU2_VD1_IF0_LUMA_PSEL                   (volatile unsigned int *)((0x1e60  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_CHROMA_PSEL                 (0x1e61)
+#define P_VIU2_VD1_IF0_CHROMA_PSEL                 (volatile unsigned int *)((0x1e61  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_DUMMY_PIXEL                 (0x1e62)
+#define P_VIU2_VD1_IF0_DUMMY_PIXEL                 (volatile unsigned int *)((0x1e62  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_LUMA_FIFO_SIZE              (0x1e63)
+#define P_VIU2_VD1_IF0_LUMA_FIFO_SIZE              (volatile unsigned int *)((0x1e63  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_RANGE_MAP_Y                 (0x1e6a)
+#define P_VIU2_VD1_IF0_RANGE_MAP_Y                 (volatile unsigned int *)((0x1e6a  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_RANGE_MAP_CB                (0x1e6b)
+#define P_VIU2_VD1_IF0_RANGE_MAP_CB                (volatile unsigned int *)((0x1e6b  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_RANGE_MAP_CR                (0x1e6c)
+#define P_VIU2_VD1_IF0_RANGE_MAP_CR                (volatile unsigned int *)((0x1e6c  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_GEN_REG2                    (0x1e6d)
+#define P_VIU2_VD1_IF0_GEN_REG2                    (volatile unsigned int *)((0x1e6d  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_PROT_CNTL                   (0x1e6e)
+#define P_VIU2_VD1_IF0_PROT_CNTL                   (volatile unsigned int *)((0x1e6e  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_URGENT_CTRL                 (0x1e6f)
+#define P_VIU2_VD1_IF0_URGENT_CTRL                 (volatile unsigned int *)((0x1e6f  << 2) + 0xff900000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 19    if true, always use phase0 while vertical formater, meaning always
+//          repeat data, no interpolation
+//Bit 18    if true, disable vertical formatter chroma repeat last line
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)
+//Bit 0     vertical formatter enable
+#define   VIU2_VD1_FMT_CTRL                        (0x1e68)
+#define P_VIU2_VD1_FMT_CTRL                        (volatile unsigned int *)((0x1e68  << 2) + 0xff900000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define   VIU2_VD1_FMT_W                           (0x1e69)
+#define P_VIU2_VD1_FMT_W                           (volatile unsigned int *)((0x1e69  << 2) + 0xff900000)
+#define   VIU2_VD1_IF0_GEN_REG3                    (0x1e70)
+#define P_VIU2_VD1_IF0_GEN_REG3                    (volatile unsigned int *)((0x1e70  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  v2regs.h
+//
+//`define VIUB_VCBUS_BASE                8'h20
+//
+// Reading file:  vregs_clk1.h
+//
+//===========================================================================
+// Video Interface Registers    0xa00 - 0xaff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VIUB_VCBUS_BASE = 0x20
+// -----------------------------------------------
+#define   VIUB_ADDR_START                          (0x2000)
+#define P_VIUB_ADDR_START                          (volatile unsigned int *)((0x2000  << 2) + 0xff900000)
+#define   VIUB_ADDR_END                            (0x20ff)
+#define P_VIUB_ADDR_END                            (volatile unsigned int *)((0x20ff  << 2) + 0xff900000)
+//`define TRACE_REG 8'ff
+//------------------------------------------------------------------------------
+// VIU top-level registers
+//------------------------------------------------------------------------------
+// Bit  0 RW, osd1_reset
+// Bit  1 RW, osd2_reset
+// Bit  2 RW, vd1_reset
+// Bit  3 RW, vd1_fmt_reset
+// Bit  4 RW, vd2_reset
+// Bit  5 RW, vd2_fmt_reset
+// Bit  6 RW, di_dsr1to2_reset
+// Bit  7 RW, vpp_reset
+// Bit  8 RW, di_if1_reset
+// Bit  9 RW, di_if1_fmt_reset
+// Bit 10 RW, di_inp_reset
+// Bit 11 RW, di_inp_fmt_reset
+// Bit 12 RW, di_mem_reset
+// Bit 13 RW, di_mem_fmt_reset
+// Bit 14 RW, di_nr_wr_mif_reset
+// Bit 15 RW, dein_wr_mif_reset
+// Bit 16 RW, di_chan2_mif_reset
+// Bit 17 RW, di_mtn_wr_mif_reset
+// Bit 18 RW, di_mtn_rd_mif_reset
+// Bit 19 RW, di_mad_reset
+// Bit 20 RW, vdin0_reset
+// Bit 21 RW, vdin1_reset
+// Bit 22 RW, nrin_mux_reset
+// Bit 23 RW, vdin0_wr_reset
+// Bit 24 RW, vdin1_wr_reset
+// Bit 25 RW, reserved
+// Bit 26 RW, d2d3_reset
+// Bit 27 RW, di_cont_wr_mif_reset
+// Bit 28 RW, di_cont_rd_mif_reset
+#define   VIUB_SW_RESET                            (0x2001)
+#define P_VIUB_SW_RESET                            (volatile unsigned int *)((0x2001  << 2) + 0xff900000)
+#define   VIUB_SW_RESET0                           (0x2002)
+#define P_VIUB_SW_RESET0                           (volatile unsigned int *)((0x2002  << 2) + 0xff900000)
+// Bit 0 RW, software reset for mcvecrd_mif
+// Bit 1 RW, software reset for mcinfowr_mif
+// Bit 2 RW, software reset for mcinford_mif
+//bit 8 if true, vsync interrup is generate only field == 0
+//bit 7:0 fix_disable
+#define   VIUB_MISC_CTRL0                          (0x2006)
+#define P_VIUB_MISC_CTRL0                          (volatile unsigned int *)((0x2006  << 2) + 0xff900000)
+#define   VIUB_GCLK_CTRL0                          (0x2007)
+#define P_VIUB_GCLK_CTRL0                          (volatile unsigned int *)((0x2007  << 2) + 0xff900000)
+//// gclk_ctrl0_gl[ 0] : def=1 di_top_wrap clk enable
+////
+//// gclk_ctrl0_gl[ 8] : def=0 mad pre clock enable, from mad clock
+//// gclk_ctrl0_gl[ 9] : def=0 mad post clock enable, from mad clock
+//// gclk_ctrl0_gl[10] : def=0 div clock enable, di slow clock including di&mcdi
+//// gclk_ctrl0_gl[11] : def=0 mcdi clock enable, from div clock
+//// gclk_ctrl0_gl[12] : def=0 di post clock enable, from div clock
+//// gclk_ctrl0_gl[13] : def=0 reserved
+//// gclk_ctrl0_gl[14] : def=1 di_no_clk_gate, for old di
+//// gclk_ctrl0_gl[15] : def=0 di_gate_all, for old di
+#define   VIUB_GCLK_CTRL1                          (0x2008)
+#define P_VIUB_GCLK_CTRL1                          (volatile unsigned int *)((0x2008  << 2) + 0xff900000)
+//// gclk_ctrl1_gl[ 1: 0] : def=2'b00 mif-sub-arb clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[ 3: 2] : def=2'b00 if1 rdmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[ 5: 4] : def=2'b00 if2 rdmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[ 7: 6] : def=2'b00 de wrmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[ 9: 8] : def=2'b00 mtnrd post mif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[11:10] : def=2'b00 mcdi post mif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[17:16] : def=2'b00 inp rdmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[19:18] : def=2'b00 mem rdmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[21:20] : def=2'b00 chan rdmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[23:22] : def=2'b00 nr wrmif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[25:24] : def=2'b00 mtn mif clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl1_gl[27:26] : def=2'b00 mcdi pre mif clock gate ctrl [1]: clock valid, [0]: clock close
+////
+#define   VIUB_GCLK_CTRL2                          (0x2009)
+#define P_VIUB_GCLK_CTRL2                          (volatile unsigned int *)((0x2009  << 2) + 0xff900000)
+//// gclk_ctrl_pre[ 1: 0] : def=2'b00 nr clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_pre[ 3: 2] : def=2'b00 pd clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_pre[ 5: 4] : def=2'b00 mtn det clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_pre[ 7: 6] : def=2'b00 debanding clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_pre[ 9: 8] : def=2'b00 dnr clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_pre[11:10] : def=2'b00 nr&dnr blend clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_pre[13:12] : def=2'b00 mcdi clock gate ctrl [1]: clock valid, [0]: clock close
+#define   VIUB_GCLK_CTRL3                          (0x200a)
+#define P_VIUB_GCLK_CTRL3                          (volatile unsigned int *)((0x200a  << 2) + 0xff900000)
+//// gclk_ctrl_post[ 1: 0] : def=2'b00 di blend clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_post[ 3: 2] : def=2'b00 ei clock gate ctrl [1]: clock valid, [0]: clock close
+//// gclk_ctrl_post[ 5: 4] : def=2'b00 ei_0 clock gate ctrl [1]: clock valid, [0]: clock close
+#define   DI_IF2_GEN_REG                           (0x2010)
+#define P_DI_IF2_GEN_REG                           (volatile unsigned int *)((0x2010  << 2) + 0xff900000)
+#define   DI_IF2_CANVAS0                           (0x2011)
+#define P_DI_IF2_CANVAS0                           (volatile unsigned int *)((0x2011  << 2) + 0xff900000)
+#define   DI_IF2_LUMA_X0                           (0x2012)
+#define P_DI_IF2_LUMA_X0                           (volatile unsigned int *)((0x2012  << 2) + 0xff900000)
+#define   DI_IF2_LUMA_Y0                           (0x2013)
+#define P_DI_IF2_LUMA_Y0                           (volatile unsigned int *)((0x2013  << 2) + 0xff900000)
+#define   DI_IF2_CHROMA_X0                         (0x2014)
+#define P_DI_IF2_CHROMA_X0                         (volatile unsigned int *)((0x2014  << 2) + 0xff900000)
+#define   DI_IF2_CHROMA_Y0                         (0x2015)
+#define P_DI_IF2_CHROMA_Y0                         (volatile unsigned int *)((0x2015  << 2) + 0xff900000)
+#define   DI_IF2_RPT_LOOP                          (0x2016)
+#define P_DI_IF2_RPT_LOOP                          (volatile unsigned int *)((0x2016  << 2) + 0xff900000)
+#define   DI_IF2_LUMA0_RPT_PAT                     (0x2017)
+#define P_DI_IF2_LUMA0_RPT_PAT                     (volatile unsigned int *)((0x2017  << 2) + 0xff900000)
+#define   DI_IF2_CHROMA0_RPT_PAT                   (0x2018)
+#define P_DI_IF2_CHROMA0_RPT_PAT                   (volatile unsigned int *)((0x2018  << 2) + 0xff900000)
+#define   DI_IF2_DUMMY_PIXEL                       (0x2019)
+#define P_DI_IF2_DUMMY_PIXEL                       (volatile unsigned int *)((0x2019  << 2) + 0xff900000)
+#define   DI_IF2_LUMA_FIFO_SIZE                    (0x201a)
+#define P_DI_IF2_LUMA_FIFO_SIZE                    (volatile unsigned int *)((0x201a  << 2) + 0xff900000)
+#define   DI_IF2_RANGE_MAP_Y                       (0x201b)
+#define P_DI_IF2_RANGE_MAP_Y                       (volatile unsigned int *)((0x201b  << 2) + 0xff900000)
+#define   DI_IF2_RANGE_MAP_CB                      (0x201c)
+#define P_DI_IF2_RANGE_MAP_CB                      (volatile unsigned int *)((0x201c  << 2) + 0xff900000)
+#define   DI_IF2_RANGE_MAP_CR                      (0x201d)
+#define P_DI_IF2_RANGE_MAP_CR                      (volatile unsigned int *)((0x201d  << 2) + 0xff900000)
+#define   DI_IF2_GEN_REG2                          (0x201e)
+#define P_DI_IF2_GEN_REG2                          (volatile unsigned int *)((0x201e  << 2) + 0xff900000)
+#define   DI_IF2_FMT_CTRL                          (0x201f)
+#define P_DI_IF2_FMT_CTRL                          (volatile unsigned int *)((0x201f  << 2) + 0xff900000)
+#define   DI_IF2_FMT_W                             (0x2020)
+#define P_DI_IF2_FMT_W                             (volatile unsigned int *)((0x2020  << 2) + 0xff900000)
+#define   DI_IF2_URGENT_CTRL                       (0x2021)
+#define P_DI_IF2_URGENT_CTRL                       (volatile unsigned int *)((0x2021  << 2) + 0xff900000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
+#define   DI_IF2_GEN_REG3                          (0x2022)
+#define P_DI_IF2_GEN_REG3                          (volatile unsigned int *)((0x2022  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+#define   DI_IF1_URGENT_CTRL                       (0x20a3)
+#define P_DI_IF1_URGENT_CTRL                       (volatile unsigned int *)((0x20a3  << 2) + 0xff900000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
+#define   DI_INP_URGENT_CTRL                       (0x20a4)
+#define P_DI_INP_URGENT_CTRL                       (volatile unsigned int *)((0x20a4  << 2) + 0xff900000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di mem chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di mem luma path
+#define   DI_MEM_URGENT_CTRL                       (0x20a5)
+#define P_DI_MEM_URGENT_CTRL                       (volatile unsigned int *)((0x20a5  << 2) + 0xff900000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di chan2 chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di chan2 luma path
+#define   DI_CHAN2_URGENT_CTRL                     (0x20a6)
+#define P_DI_CHAN2_URGENT_CTRL                     (volatile unsigned int *)((0x20a6  << 2) + 0xff900000)
+#define   DI_IF1_GEN_REG3                          (0x20a7)
+#define P_DI_IF1_GEN_REG3                          (volatile unsigned int *)((0x20a7  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+#define   DI_INP_GEN_REG3                          (0x20a8)
+#define P_DI_INP_GEN_REG3                          (volatile unsigned int *)((0x20a8  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+#define   DI_MEM_GEN_REG3                          (0x20a9)
+#define P_DI_MEM_GEN_REG3                          (volatile unsigned int *)((0x20a9  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+#define   DI_CHAN2_GEN_REG3                        (0x20aa)
+#define P_DI_CHAN2_GEN_REG3                        (volatile unsigned int *)((0x20aa  << 2) + 0xff900000)
+//bit 31:1,  reversed
+//bit 0,     cntl_64bit_rev
+//
+// Closing file:  vregs_clk1.h
+//
+//======================================================================
+//   vpu  register.
+//======================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VPU_VCBUS_BASE = 0x27
+// -----------------------------------------------
+#define   VPU_OSD1_MMC_CTRL                        (0x2701)
+#define P_VPU_OSD1_MMC_CTRL                        (volatile unsigned int *)((0x2701  << 2) + 0xff900000)
+#define   VPU_OSD2_MMC_CTRL                        (0x2702)
+#define P_VPU_OSD2_MMC_CTRL                        (volatile unsigned int *)((0x2702  << 2) + 0xff900000)
+#define   VPU_VD1_MMC_CTRL                         (0x2703)
+#define P_VPU_VD1_MMC_CTRL                         (volatile unsigned int *)((0x2703  << 2) + 0xff900000)
+#define   VPU_VD2_MMC_CTRL                         (0x2704)
+#define P_VPU_VD2_MMC_CTRL                         (volatile unsigned int *)((0x2704  << 2) + 0xff900000)
+#define   VPU_DI_IF1_MMC_CTRL                      (0x2705)
+#define P_VPU_DI_IF1_MMC_CTRL                      (volatile unsigned int *)((0x2705  << 2) + 0xff900000)
+#define   VPU_DI_MEM_MMC_CTRL                      (0x2706)
+#define P_VPU_DI_MEM_MMC_CTRL                      (volatile unsigned int *)((0x2706  << 2) + 0xff900000)
+#define   VPU_DI_INP_MMC_CTRL                      (0x2707)
+#define P_VPU_DI_INP_MMC_CTRL                      (volatile unsigned int *)((0x2707  << 2) + 0xff900000)
+#define   VPU_DI_MTNRD_MMC_CTRL                    (0x2708)
+#define P_VPU_DI_MTNRD_MMC_CTRL                    (volatile unsigned int *)((0x2708  << 2) + 0xff900000)
+#define   VPU_DI_CHAN2_MMC_CTRL                    (0x2709)
+#define P_VPU_DI_CHAN2_MMC_CTRL                    (volatile unsigned int *)((0x2709  << 2) + 0xff900000)
+#define   VPU_DI_MTNWR_MMC_CTRL                    (0x270a)
+#define P_VPU_DI_MTNWR_MMC_CTRL                    (volatile unsigned int *)((0x270a  << 2) + 0xff900000)
+#define   VPU_DI_NRWR_MMC_CTRL                     (0x270b)
+#define P_VPU_DI_NRWR_MMC_CTRL                     (volatile unsigned int *)((0x270b  << 2) + 0xff900000)
+#define   VPU_DI_DIWR_MMC_CTRL                     (0x270c)
+#define P_VPU_DI_DIWR_MMC_CTRL                     (volatile unsigned int *)((0x270c  << 2) + 0xff900000)
+#define   VPU_VDIN0_MMC_CTRL                       (0x270d)
+#define P_VPU_VDIN0_MMC_CTRL                       (volatile unsigned int *)((0x270d  << 2) + 0xff900000)
+#define   VPU_VDIN1_MMC_CTRL                       (0x270e)
+#define P_VPU_VDIN1_MMC_CTRL                       (volatile unsigned int *)((0x270e  << 2) + 0xff900000)
+#define   VPU_BT656_MMC_CTRL                       (0x270f)
+#define P_VPU_BT656_MMC_CTRL                       (volatile unsigned int *)((0x270f  << 2) + 0xff900000)
+#define   VPU_TVD3D_MMC_CTRL                       (0x2710)
+#define P_VPU_TVD3D_MMC_CTRL                       (volatile unsigned int *)((0x2710  << 2) + 0xff900000)
+#define   VPU_TVDVBI_MMC_CTRL                      (0x2711)
+#define P_VPU_TVDVBI_MMC_CTRL                      (volatile unsigned int *)((0x2711  << 2) + 0xff900000)
+//Read only
+//`define     VPU_TVDVBI_VSLATCH_ADDR   8'h12
+//Read only
+//`define     VPU_TVDVBI_WRRSP_ADDR 8'h13
+#define   VPU_VDIN_PRE_ARB_CTRL                    (0x2714)
+#define P_VPU_VDIN_PRE_ARB_CTRL                    (volatile unsigned int *)((0x2714  << 2) + 0xff900000)
+#define   VPU_VDISP_PRE_ARB_CTRL                   (0x2715)
+#define P_VPU_VDISP_PRE_ARB_CTRL                   (volatile unsigned int *)((0x2715  << 2) + 0xff900000)
+#define   VPU_VPUARB2_PRE_ARB_CTRL                 (0x2716)
+#define P_VPU_VPUARB2_PRE_ARB_CTRL                 (volatile unsigned int *)((0x2716  << 2) + 0xff900000)
+#define   VPU_OSD3_MMC_CTRL                        (0x2717)
+#define P_VPU_OSD3_MMC_CTRL                        (volatile unsigned int *)((0x2717  << 2) + 0xff900000)
+#define   VPU_OSD4_MMC_CTRL                        (0x2718)
+#define P_VPU_OSD4_MMC_CTRL                        (volatile unsigned int *)((0x2718  << 2) + 0xff900000)
+#define   VPU_VD3_MMC_CTRL                         (0x2719)
+#define P_VPU_VD3_MMC_CTRL                         (volatile unsigned int *)((0x2719  << 2) + 0xff900000)
+// [31:11] Reserved.
+// [10: 8] cntl_viu_vdin_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
+//          3'b000=Disable VIU to VDIN path;
+//          3'b001=Enable VIU of ENC_I domain to VDIN;
+//          3'b010=Enable VIU of ENC_P domain to VDIN;
+//          3'b100=Enable VIU of ENC_T domain to VDIN;
+// [ 6: 4] cntl_viu_vdin_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
+//          3'b000=Disable VIU to VDIN clock;
+//          3'b001=Select encI clock to VDIN;
+//          3'b010=Select encP clock to VDIN;
+//          3'b100=Select encT clock to VDIN;
+// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+#define   VPU_VIU_VENC_MUX_CTRL                    (0x271a)
+#define P_VPU_VIU_VENC_MUX_CTRL                    (volatile unsigned int *)((0x271a  << 2) + 0xff900000)
+// [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+// [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+// [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+//                          0=output CrYCb(BRG);
+//                          1=output YCbCr(RGB);
+//                          2=output YCrCb(RBG);
+//                          3=output CbCrY(GBR);
+//                          4=output CbYCr(GRB);
+//                          5=output CrCbY(BGR);
+//                          6,7=Rsrv.
+// [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+// [    3] inv_vsync. 1=Invert Vsync polarity.
+// [    2] inv_hsync. 1=Invert Hsync polarity.
+// [ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
+#define   VPU_HDMI_SETTING                         (0x271b)
+#define P_VPU_HDMI_SETTING                         (volatile unsigned int *)((0x271b  << 2) + 0xff900000)
+#define   ENCI_INFO_READ                           (0x271c)
+#define P_ENCI_INFO_READ                           (volatile unsigned int *)((0x271c  << 2) + 0xff900000)
+#define   ENCP_INFO_READ                           (0x271d)
+#define P_ENCP_INFO_READ                           (volatile unsigned int *)((0x271d  << 2) + 0xff900000)
+#define   ENCT_INFO_READ                           (0x271e)
+#define P_ENCT_INFO_READ                           (volatile unsigned int *)((0x271e  << 2) + 0xff900000)
+#define   ENCL_INFO_READ                           (0x271f)
+#define P_ENCL_INFO_READ                           (volatile unsigned int *)((0x271f  << 2) + 0xff900000)
+// Bit  0 RW, viu_rst_n
+// Bit  1 RW, vdin_mmc_arb_rst_n
+// Bit  2 RW, vdisp_mmc_arb_rst_n
+// Bit  3 RW, vpuarb2_mmc_arb_rst_n
+#define   VPU_SW_RESET                             (0x2720)
+#define P_VPU_SW_RESET                             (volatile unsigned int *)((0x2720  << 2) + 0xff900000)
+//Bit 30     d2d3_depr_req_sel,  0:vdisp_pre_arb, 1: vpuarb2_pre_arb
+//Bit 27:22  d2d3_depr_brst_num
+//Bit 21:16  d2d3_depr_id
+//Bit 14     d2d3_depw_req_sel, 0: vdin_pre_arb, 1: vdisp_pre_arb
+//Bit 11:6   d2d3_depw_brst_num
+//Bit 5:0    d2d3_depw_id
+#define   VPU_D2D3_MMC_CTRL                        (0x2721)
+#define P_VPU_D2D3_MMC_CTRL                        (volatile unsigned int *)((0x2721  << 2) + 0xff900000)
+//Bit 30     mtn_contrd_req_pre,  0:disp1_arb, 1: vdin_pre_arb
+//Bit 27:22  mtn_contrd_brst_num
+//Bit 21:16  mtn_contrd_id
+//Bit 14     mtn_contwr_req_pre, 0: vdisp1_arb, 1: vdin_pre_arb
+//Bit 11:6   mtn_contwr_brst_num
+//Bit 5:0    mtn_contwr_id
+#define   VPU_CONT_MMC_CTRL                        (0x2722)
+#define P_VPU_CONT_MMC_CTRL                        (volatile unsigned int *)((0x2722  << 2) + 0xff900000)
+// Bit  6 RW, gclk_mpeg_vpu_misc
+// Bit  5 RW, gclk_mpeg_venc_l_top
+// Bit  4 RW, gclk_mpeg_vencl_int
+// Bit  3 RW, gclk_mpeg_vencp_int
+// Bit  2 RW, gclk_mpeg_vi2_top
+// Bit  1 RW, gclk_mpeg_vi_top
+// Bit  0 RW, gclk_mpeg_venc_p_top
+#define   VPU_CLK_GATE                             (0x2723)
+#define P_VPU_CLK_GATE                             (volatile unsigned int *)((0x2723  << 2) + 0xff900000)
+//Bit    12 RW, rdma_pre
+//Bit 11: 6 RW, rdma_num
+//Bit  5: 0 RW, rdma_id
+#define   VPU_RDMA_MMC_CTRL                        (0x2724)
+#define P_VPU_RDMA_MMC_CTRL                        (volatile unsigned int *)((0x2724  << 2) + 0xff900000)
+#define   VPU_MEM_PD_REG0                          (0x2725)
+#define P_VPU_MEM_PD_REG0                          (volatile unsigned int *)((0x2725  << 2) + 0xff900000)
+#define   VPU_MEM_PD_REG1                          (0x2726)
+#define P_VPU_MEM_PD_REG1                          (volatile unsigned int *)((0x2726  << 2) + 0xff900000)
+// [   31] hdmi_data_ovr_en: 1=Enable overriding data input to HDMI TX with hdmi_data_ovr[29:0]. 0=No override. Default 0.
+// [   30] Reserved.                                                                                            Default 0
+// [29: 0] hdmi_data_ovr.                                                                                       Default 0.
+#define   VPU_HDMI_DATA_OVR                        (0x2727)
+#define P_VPU_HDMI_DATA_OVR                        (volatile unsigned int *)((0x2727  << 2) + 0xff900000)
+//Bit    15 RW, prot1_sel_osd4
+//Bit    14 RW, prot1_sel_osd3
+//Bit    13 RW, prot1_sel_osd2
+//Bit    12 RW, prot1_sel_osd1
+//Bit 11: 6 RW, prot1_brst_num
+//Bit  5: 0 RW, prot1_id
+#define   VPU_PROT1_MMC_CTRL                       (0x2728)
+#define P_VPU_PROT1_MMC_CTRL                       (volatile unsigned int *)((0x2728  << 2) + 0xff900000)
+//Bit    14 RW, prot2_sel_vd3
+//Bit    13 RW, prot2_sel_vd2
+//Bit    12 RW, prot2_sel_vd1
+//Bit 11: 6 RW, prot2_brst_num
+//Bit  5: 0 RW, prot2_id
+#define   VPU_PROT2_MMC_CTRL                       (0x2729)
+#define P_VPU_PROT2_MMC_CTRL                       (volatile unsigned int *)((0x2729  << 2) + 0xff900000)
+//Bit    14 RW, prot3_sel_vd3
+//Bit    13 RW, prot3_sel_vd2
+//Bit    12 RW, prot3_sel_vd1
+//Bit 11: 6 RW, prot3_brst_num
+//Bit  5: 0 RW, prot3_id
+#define   VPU_PROT3_MMC_CTRL                       (0x272a)
+#define P_VPU_PROT3_MMC_CTRL                       (volatile unsigned int *)((0x272a  << 2) + 0xff900000)
+//Bit 29:24 RW, s3_brst_num
+//Bit 21:16 RW, s2_brst_num
+//Bit 13: 8 RW, s1_brst_num
+//Bit  5: 0 RW, s0_brst_num
+#define   VPU_ARB4_V1_MMC_CTRL                     (0x272b)
+#define P_VPU_ARB4_V1_MMC_CTRL                     (volatile unsigned int *)((0x272b  << 2) + 0xff900000)
+//Bit 29:24 RW, s3_brst_num
+//Bit 21:16 RW, s2_brst_num
+//Bit 13: 8 RW, s1_brst_num
+//Bit  5: 0 RW, s0_brst_num
+#define   VPU_ARB4_V2_MMC_CTRL                     (0x272c)
+#define P_VPU_ARB4_V2_MMC_CTRL                     (volatile unsigned int *)((0x272c  << 2) + 0xff900000)
+//Bit 27:22 RW, mcvecwr_num
+//Bit 21:16 RW, mcvecwr_id
+//Bit 11:6  RW, mcvecrd_num
+//Bit 5:0   RW, mcvecrd_id
+#define   VPU_MCVEC_MMC_CTRL                       (0x272d)
+#define P_VPU_MCVEC_MMC_CTRL                       (volatile unsigned int *)((0x272d  << 2) + 0xff900000)
+//Bit 27:22 RW, mcinfwr_num
+//Bit 21:16 RW, mcinfwr_id
+//Bit 11:6  RW, mcinfrd_num
+//Bit 5:0   RW, mcinfrd_id
+#define   VPU_MCINF_MMC_CTRL                       (0x272e)
+#define P_VPU_MCINF_MMC_CTRL                       (volatile unsigned int *)((0x272e  << 2) + 0xff900000)
+//Bit 31    reg_vpu_pwm_inv, 1: invert the pwm signal, active low
+//Bit 30:29 reg_vpu_pwm_src_sel, 00: encl, enct, encp
+//Bit 28:16 reg_vpu_pwm_v_end0
+//Bit 12:0  reg_vpu_pwm_v_start0
+#define   VPU_VPU_PWM_V0                           (0x2730)
+#define P_VPU_VPU_PWM_V0                           (volatile unsigned int *)((0x2730  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_v_end1
+//Bit 12:0  reg_vpu_pwm_v_start1
+#define   VPU_VPU_PWM_V1                           (0x2731)
+#define P_VPU_VPU_PWM_V1                           (volatile unsigned int *)((0x2731  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_v_end2
+//Bit 12:0  reg_vpu_pwm_v_start2
+#define   VPU_VPU_PWM_V2                           (0x2732)
+#define P_VPU_VPU_PWM_V2                           (volatile unsigned int *)((0x2732  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_v_end3
+//Bit 12:0  reg_vpu_pwm_v_start3
+#define   VPU_VPU_PWM_V3                           (0x2733)
+#define P_VPU_VPU_PWM_V3                           (volatile unsigned int *)((0x2733  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_h_end0
+//Bit 12:0  reg_vpu_pwm_h_start0
+#define   VPU_VPU_PWM_H0                           (0x2734)
+#define P_VPU_VPU_PWM_H0                           (volatile unsigned int *)((0x2734  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_h_end1
+//Bit 12:0  reg_vpu_pwm_h_start1
+#define   VPU_VPU_PWM_H1                           (0x2735)
+#define P_VPU_VPU_PWM_H1                           (volatile unsigned int *)((0x2735  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_h_end2
+//Bit 12:0  reg_vpu_pwm_h_start2
+#define   VPU_VPU_PWM_H2                           (0x2736)
+#define P_VPU_VPU_PWM_H2                           (volatile unsigned int *)((0x2736  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_pwm_h_end3
+//Bit 12:0  reg_vpu_pwm_h_start3
+#define   VPU_VPU_PWM_H3                           (0x2737)
+#define P_VPU_VPU_PWM_H3                           (volatile unsigned int *)((0x2737  << 2) + 0xff900000)
+//Bit 18   reg_vpu_3d_go_high_fld_pol: 0: go high at field 0, 1: go high at field 1
+//Bit 17   reg_vpu_3d_sync_setting_vsync_latch
+//Bit 16   reg_vpu_3d_sync_enable
+//Bit 14:8 reg_vpu_3d_sync_v_end
+//Bit 6:0  reg_vpu_3d_sync_v_start
+#define   VPU_VPU_3D_SYNC1                         (0x2738)
+#define P_VPU_VPU_3D_SYNC1                         (volatile unsigned int *)((0x2738  << 2) + 0xff900000)
+//Bit 28:16 reg_vpu_3d_sync_h_end
+//Bit 12:0  reg_vpu_3d_sync_h_start
+#define   VPU_VPU_3D_SYNC2                         (0x2739)
+#define P_VPU_VPU_3D_SYNC2                         (volatile unsigned int *)((0x2739  << 2) + 0xff900000)
+//Bit 4    csi2_pre, 1: using vpu pre arbiter0, 0: using vpu pre arbiter2
+//Bit 2:1  isp_in_sel, 01: select bt656, 10: select Mipi CSI2, otherwise select nothing
+//Bit 0,   if true, force vencl clk enable, otherwise, it might auto turn off by mipi DSI
+#define   VPU_MISC_CTRL                            (0x2740)
+#define P_VPU_MISC_CTRL                            (volatile unsigned int *)((0x2740  << 2) + 0xff900000)
+#define   VPU_ISP_GCLK_CTRL0                       (0x2741)
+#define P_VPU_ISP_GCLK_CTRL0                       (volatile unsigned int *)((0x2741  << 2) + 0xff900000)
+#define   VPU_ISP_GCLK_CTRL1                       (0x2742)
+#define P_VPU_ISP_GCLK_CTRL1                       (volatile unsigned int *)((0x2742  << 2) + 0xff900000)
+#define   VPU_HDMI_FMT_CTRL                        (0x2743)
+#define P_VPU_HDMI_FMT_CTRL                        (volatile unsigned int *)((0x2743  << 2) + 0xff900000)
+#define   VPU_VDIN_ASYNC_HOLD_CTRL                 (0x2744)
+#define P_VPU_VDIN_ASYNC_HOLD_CTRL                 (volatile unsigned int *)((0x2744  << 2) + 0xff900000)
+#define   VPU_VDISP_ASYNC_HOLD_CTRL                (0x2745)
+#define P_VPU_VDISP_ASYNC_HOLD_CTRL                (volatile unsigned int *)((0x2745  << 2) + 0xff900000)
+#define   VPU_VPUARB2_ASYNC_HOLD_CTRL              (0x2746)
+#define P_VPU_VPUARB2_ASYNC_HOLD_CTRL              (volatile unsigned int *)((0x2746  << 2) + 0xff900000)
+//    arb0_rd_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[0] |
+//                        rdma_ddr_req_busy_sync_d1 & vpu_arb_urg_ctrl[1]
+//                        ;
+//
+//    arb1_rd_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[2] |
+//                        rdma_ddr_req_busy_sync_d1 & vpu_arb_urg_ctrl[3]
+//                        ;
+//
+//    arb2_rd_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[4] |
+//                        rdma_ddr_req_busy_sync_d1 & vpu_arb_urg_ctrl[5]
+//                        ;
+//
+//    arb0_wr_urg_ctrl_o <=  vdin0_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[6] |
+//                        vdin1_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[7]
+//                        ;
+//
+//    arb1_wr_urg_ctrl_o <=  vdin0_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[8] |
+//                        vdin1_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[9]
+//
+#define   VPU_ARB_URG_CTRL                         (0x2747)
+#define P_VPU_ARB_URG_CTRL                         (volatile unsigned int *)((0x2747  << 2) + 0xff900000)
+#define   VPU_SECURE_DUMMY                         (0x2748)
+#define P_VPU_SECURE_DUMMY                         (volatile unsigned int *)((0x2748  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_EN                        (0x2749)
+#define P_VPU_VENCL_DITH_EN                        (volatile unsigned int *)((0x2749  << 2) + 0xff900000)
+// todo :
+#define   VPU_422TO444_RST                         (0x274a)
+#define P_VPU_422TO444_RST                         (volatile unsigned int *)((0x274a  << 2) + 0xff900000)
+// todo :
+#define   VPU_422TO444_CTRL0                       (0x274b)
+#define P_VPU_422TO444_CTRL0                       (volatile unsigned int *)((0x274b  << 2) + 0xff900000)
+// todo :
+#define   VPU_422TO444_CTRL1                       (0x274c)
+#define P_VPU_422TO444_CTRL1                       (volatile unsigned int *)((0x274c  << 2) + 0xff900000)
+// todo :
+// Picture Rotate (PROT) module 1 (for OSD) registers:
+#define   VPU_PROT1_CLK_GATE                       (0x2750)
+#define P_VPU_PROT1_CLK_GATE                       (volatile unsigned int *)((0x2750  << 2) + 0xff900000)
+#define   VPU_PROT1_GEN_CNTL                       (0x2751)
+#define P_VPU_PROT1_GEN_CNTL                       (volatile unsigned int *)((0x2751  << 2) + 0xff900000)
+#define   VPU_PROT1_X_START_END                    (0x2752)
+#define P_VPU_PROT1_X_START_END                    (volatile unsigned int *)((0x2752  << 2) + 0xff900000)
+#define   VPU_PROT1_Y_START_END                    (0x2753)
+#define P_VPU_PROT1_Y_START_END                    (volatile unsigned int *)((0x2753  << 2) + 0xff900000)
+#define   VPU_PROT1_Y_LEN_STEP                     (0x2754)
+#define P_VPU_PROT1_Y_LEN_STEP                     (volatile unsigned int *)((0x2754  << 2) + 0xff900000)
+#define   VPU_PROT1_RPT_LOOP                       (0x2755)
+#define P_VPU_PROT1_RPT_LOOP                       (volatile unsigned int *)((0x2755  << 2) + 0xff900000)
+#define   VPU_PROT1_RPT_PAT                        (0x2756)
+#define P_VPU_PROT1_RPT_PAT                        (volatile unsigned int *)((0x2756  << 2) + 0xff900000)
+#define   VPU_PROT1_DDR                            (0x2757)
+#define P_VPU_PROT1_DDR                            (volatile unsigned int *)((0x2757  << 2) + 0xff900000)
+#define   VPU_PROT1_RBUF_ROOM                      (0x2758)
+#define P_VPU_PROT1_RBUF_ROOM                      (volatile unsigned int *)((0x2758  << 2) + 0xff900000)
+#define   VPU_PROT1_STAT_0                         (0x2759)
+#define P_VPU_PROT1_STAT_0                         (volatile unsigned int *)((0x2759  << 2) + 0xff900000)
+#define   VPU_PROT1_STAT_1                         (0x275a)
+#define P_VPU_PROT1_STAT_1                         (volatile unsigned int *)((0x275a  << 2) + 0xff900000)
+#define   VPU_PROT1_STAT_2                         (0x275b)
+#define P_VPU_PROT1_STAT_2                         (volatile unsigned int *)((0x275b  << 2) + 0xff900000)
+#define   VPU_PROT1_REQ_ONOFF                      (0x275c)
+#define P_VPU_PROT1_REQ_ONOFF                      (volatile unsigned int *)((0x275c  << 2) + 0xff900000)
+// Picture Rotate (PROT) module 2 (for VD) registers:
+#define   VPU_PROT2_CLK_GATE                       (0x2760)
+#define P_VPU_PROT2_CLK_GATE                       (volatile unsigned int *)((0x2760  << 2) + 0xff900000)
+#define   VPU_PROT2_GEN_CNTL                       (0x2761)
+#define P_VPU_PROT2_GEN_CNTL                       (volatile unsigned int *)((0x2761  << 2) + 0xff900000)
+#define   VPU_PROT2_X_START_END                    (0x2762)
+#define P_VPU_PROT2_X_START_END                    (volatile unsigned int *)((0x2762  << 2) + 0xff900000)
+#define   VPU_PROT2_Y_START_END                    (0x2763)
+#define P_VPU_PROT2_Y_START_END                    (volatile unsigned int *)((0x2763  << 2) + 0xff900000)
+#define   VPU_PROT2_Y_LEN_STEP                     (0x2764)
+#define P_VPU_PROT2_Y_LEN_STEP                     (volatile unsigned int *)((0x2764  << 2) + 0xff900000)
+#define   VPU_PROT2_RPT_LOOP                       (0x2765)
+#define P_VPU_PROT2_RPT_LOOP                       (volatile unsigned int *)((0x2765  << 2) + 0xff900000)
+#define   VPU_PROT2_RPT_PAT                        (0x2766)
+#define P_VPU_PROT2_RPT_PAT                        (volatile unsigned int *)((0x2766  << 2) + 0xff900000)
+#define   VPU_PROT2_DDR                            (0x2767)
+#define P_VPU_PROT2_DDR                            (volatile unsigned int *)((0x2767  << 2) + 0xff900000)
+#define   VPU_PROT2_RBUF_ROOM                      (0x2768)
+#define P_VPU_PROT2_RBUF_ROOM                      (volatile unsigned int *)((0x2768  << 2) + 0xff900000)
+#define   VPU_PROT2_STAT_0                         (0x2769)
+#define P_VPU_PROT2_STAT_0                         (volatile unsigned int *)((0x2769  << 2) + 0xff900000)
+#define   VPU_PROT2_STAT_1                         (0x276a)
+#define P_VPU_PROT2_STAT_1                         (volatile unsigned int *)((0x276a  << 2) + 0xff900000)
+#define   VPU_PROT2_STAT_2                         (0x276b)
+#define P_VPU_PROT2_STAT_2                         (volatile unsigned int *)((0x276b  << 2) + 0xff900000)
+#define   VPU_PROT2_REQ_ONOFF                      (0x276c)
+#define P_VPU_PROT2_REQ_ONOFF                      (volatile unsigned int *)((0x276c  << 2) + 0xff900000)
+// Picture Rotate (PROT) module 3 (for VD) registers:
+#define   VPU_PROT3_CLK_GATE                       (0x2770)
+#define P_VPU_PROT3_CLK_GATE                       (volatile unsigned int *)((0x2770  << 2) + 0xff900000)
+#define   VPU_PROT3_GEN_CNTL                       (0x2771)
+#define P_VPU_PROT3_GEN_CNTL                       (volatile unsigned int *)((0x2771  << 2) + 0xff900000)
+#define   VPU_PROT3_X_START_END                    (0x2772)
+#define P_VPU_PROT3_X_START_END                    (volatile unsigned int *)((0x2772  << 2) + 0xff900000)
+#define   VPU_PROT3_Y_START_END                    (0x2773)
+#define P_VPU_PROT3_Y_START_END                    (volatile unsigned int *)((0x2773  << 2) + 0xff900000)
+#define   VPU_PROT3_Y_LEN_STEP                     (0x2774)
+#define P_VPU_PROT3_Y_LEN_STEP                     (volatile unsigned int *)((0x2774  << 2) + 0xff900000)
+#define   VPU_PROT3_RPT_LOOP                       (0x2775)
+#define P_VPU_PROT3_RPT_LOOP                       (volatile unsigned int *)((0x2775  << 2) + 0xff900000)
+#define   VPU_PROT3_RPT_PAT                        (0x2776)
+#define P_VPU_PROT3_RPT_PAT                        (volatile unsigned int *)((0x2776  << 2) + 0xff900000)
+#define   VPU_PROT3_DDR                            (0x2777)
+#define P_VPU_PROT3_DDR                            (volatile unsigned int *)((0x2777  << 2) + 0xff900000)
+#define   VPU_PROT3_RBUF_ROOM                      (0x2778)
+#define P_VPU_PROT3_RBUF_ROOM                      (volatile unsigned int *)((0x2778  << 2) + 0xff900000)
+#define   VPU_PROT3_STAT_0                         (0x2779)
+#define P_VPU_PROT3_STAT_0                         (volatile unsigned int *)((0x2779  << 2) + 0xff900000)
+#define   VPU_PROT3_STAT_1                         (0x277a)
+#define P_VPU_PROT3_STAT_1                         (volatile unsigned int *)((0x277a  << 2) + 0xff900000)
+#define   VPU_PROT3_STAT_2                         (0x277b)
+#define P_VPU_PROT3_STAT_2                         (volatile unsigned int *)((0x277b  << 2) + 0xff900000)
+#define   VPU_PROT3_REQ_ONOFF                      (0x277c)
+#define P_VPU_PROT3_REQ_ONOFF                      (volatile unsigned int *)((0x277c  << 2) + 0xff900000)
+//Bit 20    reg_viu2vdin_sw_reset:   software reset
+//Bit 19:18 reg_viu2vdin_dn_ratio:   down-scale ratio; 0: no scale; 1: 1/2;  2:1/4; 3: reserved
+//Bit 17:16 reg_viu2vdin_flt_mode:   filter mode; 0: no filter; 1:[0 2 2 0]/4; 2:[1 1 1 1]/4; 3:[1 3 3 1]/8
+//Bit 15:14 reversed
+//Bit 13:0  reg_viu2vdin_hsize:      source horizontal size
+#define   VPU_VIU2VDIN_HDN_CTRL                    (0x2780)
+#define P_VPU_VIU2VDIN_HDN_CTRL                    (volatile unsigned int *)((0x2780  << 2) + 0xff900000)
+#define   VPU_VIU_ASYNC_MASK                       (0x2781)
+#define P_VPU_VIU_ASYNC_MASK                       (volatile unsigned int *)((0x2781  << 2) + 0xff900000)
+#define   VDIN_MISC_CTRL                           (0x2782)
+#define P_VDIN_MISC_CTRL                           (volatile unsigned int *)((0x2782  << 2) + 0xff900000)
+// vpu arbtration :
+// the segment is 8'h90-8'hc8
+//
+// Reading file:  vpu_arb_axi_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+////===============================////
+//// reg
+////===============================////
+#define   VPU_RDARB_MODE_L1C1                      (0x2790)
+#define P_VPU_RDARB_MODE_L1C1                      (volatile unsigned int *)((0x2790  << 2) + 0xff900000)
+//Bit   31:22,    reserved
+//Bit   21:16,    rdarb_sel           uns, default = 0 ,
+//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
+//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
+//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
+//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
+//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
+//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
+//Bit   15:10,    reserved
+//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
+//                                    rdarb_arb_mode[0] master port0 arb way,
+//                                    rdarb_arb_mode[1] master port1 arb way,
+//Bit   7:4,      reserved
+//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
+//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
+//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
+#define   VPU_RDARB_REQEN_SLV_L1C1                 (0x2791)
+#define P_VPU_RDARB_REQEN_SLV_L1C1                 (volatile unsigned int *)((0x2791  << 2) + 0xff900000)
+//Bit   31:12,     reserved
+//Bit   11:0,     rdarb_dc_req_en     unsigned  , default = 12'hfff
+//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
+//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
+//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
+//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
+//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
+//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
+//                                    rdarb_dc_req_en[6]: the slv0 req to mst port1 enable,
+//                                    rdarb_dc_req_en[7]: the slv1 req to mst port1 enable,
+//                                    rdarb_dc_req_en[8]: the slv2 req to mst port1 enable,
+//                                    rdarb_dc_req_en[9]: the slv3 req to mst port1 enable,
+//                                    rdarb_dc_req_en[10]: the slv4 req to mst port1 enable,
+//                                    rdarb_dc_req_en[11]: the slv5 req to mst port1 enable,
+#define   VPU_RDARB_WEIGH0_SLV_L1C1                (0x2792)
+#define P_VPU_RDARB_WEIGH0_SLV_L1C1                (volatile unsigned int *)((0x2792  << 2) + 0xff900000)
+//Bit   31:30,    reserved
+//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
+//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
+//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
+//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
+//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
+//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
+#define   VPU_RDARB_WEIGH1_SLV_L1C1                (0x2793)
+#define P_VPU_RDARB_WEIGH1_SLV_L1C1                (volatile unsigned int *)((0x2793  << 2) + 0xff900000)
+//Bit   31:6,    reserved
+//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
+//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
+#define   VPU_WRARB_MODE_L1C1                      (0x2794)
+#define P_VPU_WRARB_MODE_L1C1                      (volatile unsigned int *)((0x2794  << 2) + 0xff900000)
+//Bit   31:22,    reserved
+//Bit   21:16,    wrarb_sel           uns, default = 0 ,
+//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
+//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
+//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
+//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
+//                                    wrarb_sel[4]==0 slave dc4 connect master port0 wrarb_sel[4]==1 slave dc4 connect master port1
+//                                    wrarb_sel[5]==0 slave dc5 connect master port0 wrarb_sel[5]==1 slave dc5 connect master port1
+//Bit   15:10,    reserved
+//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
+//                                    wrarb_arb_mode[0] master port0 arb way,
+//                                    wrarb_arb_mode[1] master port1 arb way,
+//Bit   7:4,      reserved
+//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
+//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
+//                                    wrarb_gate_clk_ctrl[3:2] master port1 clk gate control
+#define   VPU_WRARB_REQEN_SLV_L1C1                 (0x2795)
+#define P_VPU_WRARB_REQEN_SLV_L1C1                 (volatile unsigned int *)((0x2795  << 2) + 0xff900000)
+//Bit   31:12,     reserved
+//Bit   11:0,     wrarb_dc_req_en     unsigned  , default = 0
+//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
+//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
+//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
+//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
+//                                    wrarb_dc_req_en[4]: the slv4 req to mst port0 enable,
+//                                    wrarb_dc_req_en[5]: the slv5 req to mst port0 enable,
+//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
+//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
+//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
+//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
+//                                    wrarb_dc_req_en[4]: the slv4 req to mst port1 enable,
+//                                    wrarb_dc_req_en[5]: the slv5 req to mst port1 enable,
+#define   VPU_WRARB_WEIGH0_SLV_L1C1                (0x2796)
+#define P_VPU_WRARB_WEIGH0_SLV_L1C1                (volatile unsigned int *)((0x2796  << 2) + 0xff900000)
+//Bit   31:30,    reserved
+//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
+//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
+//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
+//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
+//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
+//                                    wrdc_weigh_sxn[4*6+:6]: the slv4 req weigh number
+#define   VPU_WRARB_WEIGH1_SLV_L1C1                (0x2797)
+#define P_VPU_WRARB_WEIGH1_SLV_L1C1                (volatile unsigned int *)((0x2797  << 2) + 0xff900000)
+//Bit   31:6,    reserved
+//Bit   5:0,     wrdc_weigh_sxn     unsigned  , default = 0
+//                                    wrdc_weigh_sxn[5*6+:6]: the slv5 req weigh number
+#define   VPU_RDWR_ARB_STATUS_L1C1                 (0x2798)
+#define P_VPU_RDWR_ARB_STATUS_L1C1                 (volatile unsigned int *)((0x2798  << 2) + 0xff900000)
+//Bit   31:4,    reserved
+//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
+//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
+#define   VPU_RDARB_MODE_L1C2                      (0x2799)
+#define P_VPU_RDARB_MODE_L1C2                      (volatile unsigned int *)((0x2799  << 2) + 0xff900000)
+//Bit   31:21,    reserved
+//Bit   20:16,    rdarb_sel           uns, default = 0 ,
+//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
+//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
+//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
+//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
+//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
+//Bit   15:10,    reserved
+//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
+//                                    rdarb_arb_mode[0] master port0 arb way,
+//                                    rdarb_arb_mode[1] master port1 arb way,
+//Bit   7:4,      reserved
+//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
+//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
+//                                    rdarb_gate_clk_ctrl[3:2] master port0 clk gate control
+#define   VPU_RDARB_REQEN_SLV_L1C2                 (0x279a)
+#define P_VPU_RDARB_REQEN_SLV_L1C2                 (volatile unsigned int *)((0x279a  << 2) + 0xff900000)
+//Bit   31:10,     reserved
+//Bit    9:0,     rdarb_dc_req_en     unsigned  , default = 0
+//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
+//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
+//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
+//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
+//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
+//                                    rdarb_dc_req_en[5]: the slv0 req to mst port1 enable,
+//                                    rdarb_dc_req_en[6]: the slv1 req to mst port1 enable,
+//                                    rdarb_dc_req_en[7]: the slv2 req to mst port1 enable,
+//                                    rdarb_dc_req_en[8]: the slv3 req to mst port1 enable,
+//                                    rdarb_dc_req_en[9]: the slv4 req to mst port1 enable,
+#define   VPU_RDARB_WEIGH0_SLV_L1C2                (0x279b)
+#define P_VPU_RDARB_WEIGH0_SLV_L1C2                (volatile unsigned int *)((0x279b  << 2) + 0xff900000)
+//Bit   31:30,    reserved
+//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
+//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
+//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
+//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
+//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
+//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
+#define   VPU_RDWR_ARB_STATUS_L1C2                 (0x279c)
+#define P_VPU_RDWR_ARB_STATUS_L1C2                 (volatile unsigned int *)((0x279c  << 2) + 0xff900000)
+//Bit   31:3,    reserved
+//Bit      2,    wrarb_arb_busy     unsigned  , default = 0
+//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
+#define   VPU_RDARB_MODE_L2C1                      (0x279d)
+#define P_VPU_RDARB_MODE_L2C1                      (volatile unsigned int *)((0x279d  << 2) + 0xff900000)
+//Bit   31:28,    reserved
+//Bit   27:16,    rdarb_sel           uns, default = 0 ,
+//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
+//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
+//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
+//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
+//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
+//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
+//Bit   15:11,    reserved
+//Bit   10:8,      rdarb_arb_mode      uns, default = 0 ,
+//                                    rdarb_arb_mode[0] master port0 arb way,
+//                                    rdarb_arb_mode[1] master port1 arb way,
+//Bit   7:6,      reserved
+//Bit   5:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
+//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
+//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
+//                                    rdarb_gate_clk_ctrl[5:4] master port2 clk gate control
+#define   VPU_RDARB_REQEN_SLV_L2C1                 (0x279e)
+#define P_VPU_RDARB_REQEN_SLV_L2C1                 (volatile unsigned int *)((0x279e  << 2) + 0xff900000)
+//Bit   31:18,     reserved
+//Bit   17:0,     rdarb_dc_req_en     unsigned  , default = 0
+//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
+//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
+//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
+//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
+//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
+//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
+//                                    rdarb_dc_req_en[0]: the slv0 req to mst port1 enable,
+//                                    rdarb_dc_req_en[1]: the slv1 req to mst port1 enable,
+//                                    rdarb_dc_req_en[2]: the slv2 req to mst port1 enable,
+//                                    rdarb_dc_req_en[3]: the slv3 req to mst port1 enable,
+//                                    rdarb_dc_req_en[4]: the slv4 req to mst port1 enable,
+//                                    rdarb_dc_req_en[5]: the slv5 req to mst port1 enable,
+#define   VPU_RDARB_WEIGH0_SLV_L2C1                (0x279f)
+#define P_VPU_RDARB_WEIGH0_SLV_L2C1                (volatile unsigned int *)((0x279f  << 2) + 0xff900000)
+//Bit   31:30,    reserved
+//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
+//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
+//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
+//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
+//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
+//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
+#define   VPU_RDARB_WEIGH1_SLV_L2C1                (0x27a0)
+#define P_VPU_RDARB_WEIGH1_SLV_L2C1                (volatile unsigned int *)((0x27a0  << 2) + 0xff900000)
+//Bit   31:6,    reserved
+//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
+//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
+#define   VPU_RDWR_ARB_STATUS_L2C1                 (0x27a1)
+#define P_VPU_RDWR_ARB_STATUS_L2C1                 (volatile unsigned int *)((0x27a1  << 2) + 0xff900000)
+//Bit   31:4,    reserved
+//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
+//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
+#define   VPU_WRARB_MODE_L2C1                      (0x27a2)
+#define P_VPU_WRARB_MODE_L2C1                      (volatile unsigned int *)((0x27a2  << 2) + 0xff900000)
+//Bit   31:20,    reserved
+//Bit   19:16,    wrarb_sel           uns, default = 0 ,
+//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
+//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
+//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
+//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
+//Bit   15:10,    reserved
+//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
+//                                    wrarb_arb_mode[0] master port0 arb way,
+//                                    wrarb_arb_mode[1] master port1 arb way,
+//Bit   7:4,      reserved
+//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
+//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
+//                                    wrarb_gate_clk_ctrl[3:2] master port0 clk gate control
+#define   VPU_WRARB_REQEN_SLV_L2C1                 (0x27a3)
+#define P_VPU_WRARB_REQEN_SLV_L2C1                 (volatile unsigned int *)((0x27a3  << 2) + 0xff900000)
+//Bit   31:8,     reserved
+//Bit    7:0,     wrarb_dc_req_en     unsigned  , default = 0
+//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
+//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
+//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
+//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
+//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
+//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
+//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
+//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
+#define   VPU_WRARB_WEIGH0_SLV_L2C1                (0x27a4)
+#define P_VPU_WRARB_WEIGH0_SLV_L2C1                (volatile unsigned int *)((0x27a4  << 2) + 0xff900000)
+//Bit   31:24,    reserved
+//Bit   23:0,     wrdc_weigh_sxn     unsigned  , default = 0
+//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
+//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
+//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
+//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
+#define   VPU_ASYNC_RD_MODE0                       (0x27a5)
+#define P_VPU_ASYNC_RD_MODE0                       (volatile unsigned int *)((0x27a5  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
+#define   VPU_ASYNC_RD_MODE1                       (0x27a6)
+#define P_VPU_ASYNC_RD_MODE1                       (volatile unsigned int *)((0x27a6  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
+#define   VPU_ASYNC_RD_MODE2                       (0x27a7)
+#define P_VPU_ASYNC_RD_MODE2                       (volatile unsigned int *)((0x27a7  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
+#define   VPU_ASYNC_RD_MODE3                       (0x27a8)
+#define P_VPU_ASYNC_RD_MODE3                       (volatile unsigned int *)((0x27a8  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
+#define   VPU_ASYNC_RD_MODE4                       (0x27a9)
+#define P_VPU_ASYNC_RD_MODE4                       (volatile unsigned int *)((0x27a9  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
+#define   VPU_ASYNC_WR_MODE0                       (0x27aa)
+#define P_VPU_ASYNC_WR_MODE0                       (volatile unsigned int *)((0x27aa  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
+#define   VPU_ASYNC_WR_MODE1                       (0x27ab)
+#define P_VPU_ASYNC_WR_MODE1                       (volatile unsigned int *)((0x27ab  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
+#define   VPU_ASYNC_WR_MODE2                       (0x27ac)
+#define P_VPU_ASYNC_WR_MODE2                       (volatile unsigned int *)((0x27ac  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       req_en            unsigned  , default = 0  async enable
+//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
+//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
+//Bit   11,       reserved
+//Bit   10:9,     arugt_sel         unsigned  , default = 0
+//                                  00 : use auto fifo arugt generate the output arugt.
+//                                  01 : use the register bit control
+//                                  00 : use the input arguent
+//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
+//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
+//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
+#define   VPU_ASYNC_STAT                           (0x27ad)
+#define P_VPU_ASYNC_STAT                           (volatile unsigned int *)((0x27ad  << 2) + 0xff900000)
+//Bit   31:19,    reserved
+//Bit   18,       axiwr2_chan_idle  unsigned  , RO, axi write channel2 idle state
+//Bit   17,       axiwr1_chan_idle  unsigned  , RO, axi write channel1 idle state
+//Bit   16,       axiwr0_chan_idle  unsigned  , RO, axi write channel0 idle state
+//Bit   15:5,     reserved
+//Bit   4,        axird4_chan_idle  unsigned  , RO, axi read channel4 idle state
+//Bit   3,        axird3_chan_idle  unsigned  , RO, axi read channel3 idle state
+//Bit   2,        axird2_chan_idle  unsigned  , RO, axi read channel2 idle state
+//Bit   1,        axird1_chan_idle  unsigned  , RO, axi read channel1 idle state
+//Bit   0,        axird0_chan_idle  unsigned  , RO, axi read channel0 idle state
+#define   VPU_WRARB_MODE_L1C2                      (0x27ae)
+#define P_VPU_WRARB_MODE_L1C2                      (volatile unsigned int *)((0x27ae  << 2) + 0xff900000)
+//Bit   31:18,    reserved
+//Bit   17:16,    wrarb_sel           uns, default = 0 ,
+//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
+//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
+//Bit   15:9,     reserved
+//Bit   8,        wrarb_arb_mode      uns, default = 0 ,
+//                                    wrarb_arb_mode[0] master port0 arb way,
+//Bit   7:2,      reserved
+//Bit   1:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
+//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
+#define   VPU_WRARB_REQEN_SLV_L1C2                 (0x27af)
+#define P_VPU_WRARB_REQEN_SLV_L1C2                 (volatile unsigned int *)((0x27af  << 2) + 0xff900000)
+//Bit   31:2,     reserved
+//Bit    1:0,     wrarb_dc_req_en     unsigned  , default = 0
+//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
+//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
+#define   VPU_WRARB_WEIGH0_SLV_L1C2                (0x27b0)
+#define P_VPU_WRARB_WEIGH0_SLV_L1C2                (volatile unsigned int *)((0x27b0  << 2) + 0xff900000)
+//Bit   31:30,    reserved
+//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
+//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
+//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
+//                                    wrdc_weigh_sxn[2*6+:6]: the slv1 req weigh number
+//                                    wrdc_weigh_sxn[3*6+:6]: the slv1 req weigh number
+//                                    wrdc_weigh_sxn[4*6+:6]: the slv1 req weigh number
+#define   VPU_WRARB_WEIGH1_SLV_L1C2                (0x27b1)
+#define P_VPU_WRARB_WEIGH1_SLV_L1C2                (volatile unsigned int *)((0x27b1  << 2) + 0xff900000)
+//Bit   31:18,    reserved
+//Bit   17:0,     wrdc_weigh_sxn     unsigned  , default = 0
+//                                    wrdc_weigh_sxn[5*6+:6]: the slv0 req weigh number
+//                                    wrdc_weigh_sxn[6*6+:6]: the slv1 req weigh number
+//                                    wrdc_weigh_sxn[7*6+:6]: the slv1 req weigh number
+#define   VPU_RDARB_WEIGH1_SLV_L1C2                (0x27b2)
+#define P_VPU_RDARB_WEIGH1_SLV_L1C2                (volatile unsigned int *)((0x27b2  << 2) + 0xff900000)
+//Bit   31:18,    reserved
+//Bit   17:0,     rddc_weigh_sxn     unsigned  , default = 0
+//                                    rddc_weigh_sxn[5*6+:6]: the slv0 req weigh number
+//                                    rddc_weigh_sxn[6*6+:6]: the slv1 req weigh number
+//                                    rddc_weigh_sxn[7*6+:6]: the slv2 req weigh number
+#define   VPU_ARB_DBG_CTRL_L1C1                    (0x27b3)
+#define P_VPU_ARB_DBG_CTRL_L1C1                    (volatile unsigned int *)((0x27b3  << 2) + 0xff900000)
+#define   VPU_ARB_DBG_STAT_L1C1                    (0x27b4)
+#define P_VPU_ARB_DBG_STAT_L1C1                    (volatile unsigned int *)((0x27b4  << 2) + 0xff900000)
+#define   VPU_ARB_DBG_CTRL_L1C2                    (0x27b5)
+#define P_VPU_ARB_DBG_CTRL_L1C2                    (volatile unsigned int *)((0x27b5  << 2) + 0xff900000)
+#define   VPU_ARB_DBG_STAT_L1C2                    (0x27b6)
+#define P_VPU_ARB_DBG_STAT_L1C2                    (volatile unsigned int *)((0x27b6  << 2) + 0xff900000)
+#define   VPU_ARB_DBG_CTRL_L2C1                    (0x27b7)
+#define P_VPU_ARB_DBG_CTRL_L2C1                    (volatile unsigned int *)((0x27b7  << 2) + 0xff900000)
+#define   VPU_ARB_DBG_STAT_L2C1                    (0x27b8)
+#define P_VPU_ARB_DBG_STAT_L2C1                    (volatile unsigned int *)((0x27b8  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_CTRL                        (0x27b9)
+#define P_VPU_ARB_PATH_CTRL                        (volatile unsigned int *)((0x27b9  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP00                       (0x27ba)
+#define P_VPU_ARB_PATH_MAP00                       (volatile unsigned int *)((0x27ba  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP01                       (0x27bb)
+#define P_VPU_ARB_PATH_MAP01                       (volatile unsigned int *)((0x27bb  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP02                       (0x27bc)
+#define P_VPU_ARB_PATH_MAP02                       (volatile unsigned int *)((0x27bc  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP03                       (0x27bd)
+#define P_VPU_ARB_PATH_MAP03                       (volatile unsigned int *)((0x27bd  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP10                       (0x27be)
+#define P_VPU_ARB_PATH_MAP10                       (volatile unsigned int *)((0x27be  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP11                       (0x27bf)
+#define P_VPU_ARB_PATH_MAP11                       (volatile unsigned int *)((0x27bf  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP12                       (0x27c0)
+#define P_VPU_ARB_PATH_MAP12                       (volatile unsigned int *)((0x27c0  << 2) + 0xff900000)
+#define   VPU_ARB_PATH_MAP13                       (0x27c1)
+#define P_VPU_ARB_PATH_MAP13                       (volatile unsigned int *)((0x27c1  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpu_arb_axi_regs.h
+//
+// the segment is 8'he0-8'hef
+#define   VPU_VENCL_DITH_CTRL                      (0x27e0)
+#define P_VPU_VENCL_DITH_CTRL                      (volatile unsigned int *)((0x27e0  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_1                     (0x27e1)
+#define P_VPU_VENCL_DITH_LUT_1                     (volatile unsigned int *)((0x27e1  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_2                     (0x27e2)
+#define P_VPU_VENCL_DITH_LUT_2                     (volatile unsigned int *)((0x27e2  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_3                     (0x27e3)
+#define P_VPU_VENCL_DITH_LUT_3                     (volatile unsigned int *)((0x27e3  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_4                     (0x27e4)
+#define P_VPU_VENCL_DITH_LUT_4                     (volatile unsigned int *)((0x27e4  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_5                     (0x27e5)
+#define P_VPU_VENCL_DITH_LUT_5                     (volatile unsigned int *)((0x27e5  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_6                     (0x27e6)
+#define P_VPU_VENCL_DITH_LUT_6                     (volatile unsigned int *)((0x27e6  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_7                     (0x27e7)
+#define P_VPU_VENCL_DITH_LUT_7                     (volatile unsigned int *)((0x27e7  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_8                     (0x27e8)
+#define P_VPU_VENCL_DITH_LUT_8                     (volatile unsigned int *)((0x27e8  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_9                     (0x27e9)
+#define P_VPU_VENCL_DITH_LUT_9                     (volatile unsigned int *)((0x27e9  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_10                    (0x27ea)
+#define P_VPU_VENCL_DITH_LUT_10                    (volatile unsigned int *)((0x27ea  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_11                    (0x27eb)
+#define P_VPU_VENCL_DITH_LUT_11                    (volatile unsigned int *)((0x27eb  << 2) + 0xff900000)
+#define   VPU_VENCL_DITH_LUT_12                    (0x27ec)
+#define P_VPU_VENCL_DITH_LUT_12                    (volatile unsigned int *)((0x27ec  << 2) + 0xff900000)
+//new added 4x4 dither
+// the segment is 8'hf0
+#define   VPU_HDMI_DITH_01_04                      (0x27f0)
+#define P_VPU_HDMI_DITH_01_04                      (volatile unsigned int *)((0x27f0  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_01_15                      (0x27f1)
+#define P_VPU_HDMI_DITH_01_15                      (volatile unsigned int *)((0x27f1  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_01_26                      (0x27f2)
+#define P_VPU_HDMI_DITH_01_26                      (volatile unsigned int *)((0x27f2  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_01_37                      (0x27f3)
+#define P_VPU_HDMI_DITH_01_37                      (volatile unsigned int *)((0x27f3  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_10_04                      (0x27f4)
+#define P_VPU_HDMI_DITH_10_04                      (volatile unsigned int *)((0x27f4  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_10_15                      (0x27f5)
+#define P_VPU_HDMI_DITH_10_15                      (volatile unsigned int *)((0x27f5  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_10_26                      (0x27f6)
+#define P_VPU_HDMI_DITH_10_26                      (volatile unsigned int *)((0x27f6  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_10_37                      (0x27f7)
+#define P_VPU_HDMI_DITH_10_37                      (volatile unsigned int *)((0x27f7  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_11_04                      (0x27f8)
+#define P_VPU_HDMI_DITH_11_04                      (volatile unsigned int *)((0x27f8  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_11_15                      (0x27f9)
+#define P_VPU_HDMI_DITH_11_15                      (volatile unsigned int *)((0x27f9  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_11_26                      (0x27fa)
+#define P_VPU_HDMI_DITH_11_26                      (volatile unsigned int *)((0x27fa  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_11_37                      (0x27fb)
+#define P_VPU_HDMI_DITH_11_37                      (volatile unsigned int *)((0x27fb  << 2) + 0xff900000)
+#define   VPU_HDMI_DITH_CNTL                       (0x27fc)
+#define P_VPU_HDMI_DITH_CNTL                       (volatile unsigned int *)((0x27fc  << 2) + 0xff900000)
+//========================================================================
+//  MIPI CSI2 Controller Adaptor    (16'h2a00 - 16'h2aff)
+//
+//========================================================================
+//`define  CSI2_VCBUS_BASE            8'h2a
+//`include "csi2_regs.h"
+//======================================================================
+// D2D3 registers
+//======================================================================
+//`define     D2D3_VCBUS_BASE         8'h2b
+//
+// Reading file:  d2d3_regs.h
+//
+//===========================================================================
+// D2D3 Registers    0x - 0x
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  D2D3_VCBUS_BASE = 0x2b
+// -----------------------------------------------
+//------------------------------------------------------------------------------
+// D2D3 top-level registers
+//------------------------------------------------------------------------------
+// Bit 31    RW, rd_lock_en,     1 to allow update some read-only registers based on filed
+// Bit 30    RW, sw_rst_nobuf,   1 to reset the whole d2d3 unit
+// Bit 29:28 RW, clk_auto_dis,   [29] DBR clock disable
+//                               [28] DPG clock disable
+// Bit 27:16 RW, clk_ctrl,       [27:26] gated clock control for register unit
+//                               [25:24] gated clock control for DBR unit
+//                               [23:22] gated clock control for LBDG unit
+//                               [21:20] gated clock control for MBDG unit
+//                               [19:18] gated clock control for CBDG unit
+//                               [17:16] gated clock control for DBLD unit and SCD81 unit
+// Bit 15:12 Reserved
+// Bit 11    RW, lo_chroma_sign, 0: negate the u/v component of DBR left channel video output, 1: bypass
+// Bit 10    RW, ro_chroma_sign, 0: negate the u/v component of DBR right channel video output, 1: bypass
+// Bit 9     RW, vi0_chroma_sign, 0: negate the u/v component of DPG video input, 1: bypass
+// Bit 8     RW, vi1_chroma_sign, 0: negate the u/v component of DBR video input, 1: bypass
+// Bit 7:5   Reserved
+// Bit 4     RW, lg_en,          Enable the LBDG unit and LBDG clock
+// Bit 3     RW, mg_en,          Enable the MBDG unit and MBDG clock
+// Bit 2     RW, cg_en,          Enable the CBDG unit and CBDG clock
+// Bit 1     RW, dbr_en,         Enable the DBR unit and DBR clock
+// Bit 0     RW, dpg_en,         Enable the DPG unit and clock except sub-unit CBDG, MBDG and LBDG
+#define   D2D3_GLB_CTRL                            (0x2b00)
+#define P_D2D3_GLB_CTRL                            (volatile unsigned int *)((0x2b00  << 2) + 0xff900000)
+// Indicate the input picture size in DPG unit
+// Bit 31:16 RW, szx_vi_m1,      The horizontal size minus 1
+// Bit 15:0  RW, szy_vi_m1,      The vertical size minus 1
+#define   D2D3_DPG_INPIC_SIZE                      (0x2b01)
+#define P_D2D3_DPG_INPIC_SIZE                      (volatile unsigned int *)((0x2b01  << 2) + 0xff900000)
+// Indicate the output picture size in DBR unit
+// Bit 31:16 RW, szx_vo_m1,      The horizontal size minus 1
+// Bit 15:0  RW, szy_vo_m1,      The vertical size minus 1
+#define   D2D3_DBR_OUTPIC_SIZE                     (0x2b02)
+#define P_D2D3_DBR_OUTPIC_SIZE                     (volatile unsigned int *)((0x2b02  << 2) + 0xff900000)
+// Indicate the rectangular window to generate the "depth" in DPG unit
+// Bit 31:16 RW, dg_win_x_start, Horizontal start position, count from 0
+// Bit 15:0  RW, dg_win_x_end,   Horizontal end position, count from 0
+#define   D2D3_DGEN_WIN_HOR                        (0x2b03)
+#define P_D2D3_DGEN_WIN_HOR                        (volatile unsigned int *)((0x2b03  << 2) + 0xff900000)
+// Indicate the rectangular window to generate the "depth" in DPG unit
+// Bit 31:16 RW, dg_win_y_start, Vertical start position, count from 0
+// Bit 15:0  RW, dg_win_y_end,   Vertical end position, count from 0
+#define   D2D3_DGEN_WIN_VER                        (0x2b04)
+#define P_D2D3_DGEN_WIN_VER                        (volatile unsigned int *)((0x2b04  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// CBDG SCU18 SCD81 SCD81_PRE registers
+// cg: color based depth generate module
+// scu18: scale up module
+// scd81: scale down module
+// scd81_pre: scd81 pre-scale-down module
+//------------------------------------------------------------------------------
+// Indicate parameters of pre-scale-down unit
+// Bit 31:16 RW, scd81_hphs_step, horizontal step
+// Bit 15:0  RW, scd81_hphs_ini, horizontal initial phase
+#define   D2D3_PRE_SCD_H                           (0x2b05)
+#define P_D2D3_PRE_SCD_H                           (volatile unsigned int *)((0x2b05  << 2) + 0xff900000)
+// Bit 31:16 RW, scu18_iniph,    initial phase in SCU18,
+//                               [23:16] indicate the horizontal phase offset from the first data of every line
+//                               [31:24] indicate the vertical phase offset from the first line of every frame
+// Bit 15:12 Reserved
+// Bit 11    RW, scd81_predrop_en, 1 to enable scd81 pre-scale-down function
+// Bit 10:9  RW, cg_csc_sel,     Color Space Conversion(CSC) matrix mode selector in CBDG
+//                               0: BT.601 (16-235/240)
+//                               1: BT.709 (16-235/240)
+//                               2: BT.601 (0-255)
+//                               3: BT.709 (0-255)
+// Bit 8     RW, scu18_rep_en,   1 to double each line of the SCU18 output
+// Bit 7:4   RW, scu18_factor,   up-scale factor in SCU18 on DBR input depth data
+//                               [7:6] for vertical, 0->1:1, 1->1:2, 2->1:4, 3->1:8
+//                               [5:4] for horizontal, 0->1:1, 1->1:2, 2->1:4, 3->1:8
+// Bit 3:0   RW, scd81_factor,   down-scale factor in SCD81 on DPG source video
+//                               [3:2] for vertical, 0->1:1, 1->2:1, 2->4:1, 3->8:1
+//                               [1:0] for horizontal, 0->1:1, 1->2:1, 2->4:1, 3->8:1
+#define   D2D3_SCALER_CTRL                         (0x2b06)
+#define P_D2D3_SCALER_CTRL                         (volatile unsigned int *)((0x2b06  << 2) + 0xff900000)
+// Bit 31:24 RW, cg_rpg_dth,     the down |r-g| threshold for sky detect
+// Bit 23:16 RW, cg_rpg_uth,     the up |r-g| threshold for sky detect
+// Bit 15:8  RW, cg_lum_dth,     the down Y threshold for sky detect
+// Bit 7:0   RW, cg_lum_uth,     the up Y threshold for sky detect
+#define   D2D3_CG_THRESHOLD_1                      (0x2b07)
+#define P_D2D3_CG_THRESHOLD_1                      (volatile unsigned int *)((0x2b07  << 2) + 0xff900000)
+// Bit 31:24 RW, cg_rpb_dth,     the down |r-b| threshold for sky detect
+// Bit 23:16 RW, cg_rpb_uth,     the up |r-b| threshold for sky detect
+// Bit 15:8  RW, cg_bpg_dth,     the down |b-g| threshold for sky detect
+// Bit 7:0   RW, cg_bpg_uth,     the up |b-g| threshold for sky detect
+#define   D2D3_CG_THRESHOLD_2                      (0x2b08)
+#define P_D2D3_CG_THRESHOLD_2                      (volatile unsigned int *)((0x2b08  << 2) + 0xff900000)
+// Bit 31:24 RW, cg_vp_rel_k,    parameter to calculate vanish point reliability
+// Bit 23:16 RW, cg_vp_y_thr,    the max limitation to calculate the vanish-point's vertical position
+// Bit 15:8  RW, cg_meet_dval,   signed depth value in the sky-bitmap
+// Bit 7:0   RW, cg_unmt_dval,   signed depth value not in the sky-bitmap
+#define   D2D3_CG_PARAM_1                          (0x2b09)
+#define P_D2D3_CG_PARAM_1                          (volatile unsigned int *)((0x2b09  << 2) + 0xff900000)
+// Bit 31:16 RW, cg_vpos_thr,    Maximal vertical limitation for sky-bit map when cg_vpos_en=1 and cg_vpos_adpt_en=0
+// Bit 15:8  Reserved
+// Bit 7     RW, cg_vpos_en,     1 to enable the max vertical limitation for sky-bitmap
+// Bit 6     RW, cg_vpos_adpt_en, 1 to enable the adaptive max vertical limitation for sky-bitmap.
+//                               It is only valid when cg_vpos_en=1.
+//                               The max vertical limitation is the previous field's vanish-point (vertical position) if cg_vpos_adpt_en=1.
+// Bit 5:4   RW, cg_lpf_bypass,  bypass of low pass filter
+//                               [5]:Vertical bypass, 1: bypass the vertical LPF on the CBDG depth
+//                               [4]:Horizontal bypass, 1: bypass the horizontal LPF on the CBDG depth
+// Bit 3:0   RW, cg_vp_rel_s,    parameter to calculate vanish point reliability
+#define   D2D3_CG_PARAM_2                          (0x2b0a)
+#define P_D2D3_CG_PARAM_2                          (volatile unsigned int *)((0x2b0a  << 2) + 0xff900000)
+// Indicate parameters of pre-scale-down unit
+// Bit 31:16 RW, scd81_vphs_step, vertical step
+// Bit 15:0  RW, scd81_vphs_ini, vertical initial phase
+#define   D2D3_PRE_SCD_V                           (0x2b0b)
+#define P_D2D3_PRE_SCD_V                           (volatile unsigned int *)((0x2b0b  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// D2P registers
+// d2p: depth to parallax transform module
+//------------------------------------------------------------------------------
+// Bit 31:24 RW, d2p_brdwid,     Horizontal boundary width for parallax, the parallax value would be forced to 0 in boundary,
+//                               the d2p_brdwid should not 0 when D2P_WRAP is enabled
+// Bit 23:22 Reserved
+// Bit 21:20 RW, d2p_lomode,     line output mode,
+//                               0:whole line is left or right;  1:whole line is left or right;
+//                               2:left/right pixel interleaved;  3:left/right half-line interleaved
+// Bit 19    RW, d2p_neg,        1 to exchange the left and right parallax value
+// Bit 18    Reserved
+// Bit 17    RW, d2p_wrap_en,    1 to enable D2P_WRAP unit
+// Bit 16    RW, d2p_lar,        Indicate the first output for left or right, 0: left; 1: right
+// Bit 15    RW, d2p_lr_switch,  enable left/right flag filed switch automatically, only valid when parallax output mode is field interleaved
+// Bit 14    RW, d2p_1dtolr,     enable to generate 2 parallax data (left and right) from one depth
+// Bit 13:12 RW, d2p_out_mode,   Parallax output mode
+//                               0:left/right pixel interleaved; 1:line or half line interleaved; 2:field interleaved
+// Bit 11:8  RW, d2p_smode,      Shift mode,
+//                               0: no shift; 1: enable left shift;
+//                               2: enable right shift; 3: both left and right shift are enabled
+// Bit 7:0   RW, d2p_offset,     depth offset, signed,
+#define   D2D3_D2P_PARAM_1                         (0x2b0c)
+#define P_D2D3_D2P_PARAM_1                         (volatile unsigned int *)((0x2b0c  << 2) + 0xff900000)
+// Bit 31:24 RW, d2p_pg0,        positive parallax gain when Parallax value < pt
+// Bit 23:16 RW, d2p_pg1,        positive parallax gain when Parallax value >= pt
+// Bit 15:8  RW, d2p_pt,         unsigned value used to separate the positive parallax range
+// Bit 7:0   RW, d2p_plimit,     The limitation for positive parallax
+#define   D2D3_D2P_PARAM_2                         (0x2b0d)
+#define P_D2D3_D2P_PARAM_2                         (volatile unsigned int *)((0x2b0d  << 2) + 0xff900000)
+// Bit 31:24 RW, d2p_ng0,        negative parallax gain when Parallax value > -nt
+// Bit 23:16 RW, d2p_ng1,        negative parallax gain when Parallax value <= -nt
+// Bit 15:8  RW, d2p_nt,         unsigned value used to separate the negative parallax range
+// Bit 7:0   RW, d2p_nlimit,     The limitation for negative parallax
+#define   D2D3_D2P_PARAM_3                         (0x2b0e)
+#define P_D2D3_D2P_PARAM_3                         (volatile unsigned int *)((0x2b0e  << 2) + 0xff900000)
+// Indicate step parameters of SCU18 unit
+// Bit 31:17 Reserved
+// Bit 16    RW, scu18_step_en,   step set enable in SCU18
+// Bit 15:8  RW, scu18_hphs_step, horizontal step in SCU18
+// Bit 7:0   RW, scu18_vphs_step, vertical step in SCU18
+#define   D2D3_SCU18_STEP                          (0x2b0f)
+#define P_D2D3_SCU18_STEP                          (volatile unsigned int *)((0x2b0f  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// LBDG and DBLD registers
+// lg: luma based depth generate module
+// db: depth blending module
+//------------------------------------------------------------------------------
+// Bit 31:22 Reserved
+// Bit 21:20 RW, db_lpf_bpcoeff, [21]:Vertical factor of low pass filter,
+//                               1: Vfactor = 0/0/64/0/0, 0: Vfactor = {db_vf_a,db_vf_b,db_vf_c,db_vf_b,db_vf_a}, see D2D3_CTRL_15
+//                               [20]:Horizontal factor of low pass filter,
+//                               1: Hfactor = 0/0/64/0/0, 0: Hfactor = {db_hf_a,db_hf_b,db_hf_c,db_hf_b,db_hf_a}, see D2D3_CTRL_14
+// Bit 19:18 RW, lg_lpf_bpcoeff, [19]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
+//                               [18]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
+// Bit 17:16 RW, cg_lpf_bpcoeff, [17]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
+//                               [16]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
+// Bit 15:10 Reserved
+// Bit 9:8   RW, db_lpf_bypass,  [9] 1 to bypass the vertical LPF on the DBLD depth
+//                               [8] 1 to bypass the horizontal LPF on the DBLD depth
+// Bit 7:6   RW, lg_lpf_bypass,  [7] 1 to bypass the vertical LPF on the LBDG depth
+//                               [6] 1 to bypass the horizontal LPF on the LBDG depth
+// Bit 5:0   RW, lg_kc,          gain of CPL(v-u+256-y) to calculate the depth in LBDG
+#define   D2D3_DPF_LPF_CTRL                        (0x2b10)
+#define P_D2D3_DPF_LPF_CTRL                        (volatile unsigned int *)((0x2b10  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// DBLD registers
+// db: depth blending module
+//------------------------------------------------------------------------------
+// Bit 31:24 RW, db_g2_cg,       gain of CBDG depth in DBLD
+// Bit 23:16 RW, db_o2_cg,       offset of CBDG depth in DBLD
+// Bit 15:8  RW, db_g1_cg,       gain of CBDG depth using for summary in DBLD
+// Bit 7:0   RW, db_o1_cg,       offset of CBDG depth using for summary in DBLD
+#define   D2D3_DBLD_CG_PARAM                       (0x2b11)
+#define P_D2D3_DBLD_CG_PARAM                       (volatile unsigned int *)((0x2b11  << 2) + 0xff900000)
+// Bit 31:24 RW, db_g2_mg,       gain of MBDG depth in DBLD
+// Bit 23:16 RW, db_o2_mg,       offset of MBDG depth in DBLD
+// Bit 15:8  RW, db_g1_mg,       gain of MBDG depth using for summary in DBLD
+// Bit 7:0   RW, db_o1_mg,       offset of MBDG depth using for summary in DBLD
+#define   D2D3_DBLD_MG_PARAM                       (0x2b12)
+#define P_D2D3_DBLD_MG_PARAM                       (volatile unsigned int *)((0x2b12  << 2) + 0xff900000)
+// Bit 31:24 RW, db_g2_lg,       gain of LBDG depth in DBLD
+// Bit 23:16 RW, db_o2_lg,       offset of LBDG depth in DBLD
+// Bit 15:8  RW, db_g1_lg,       gain of LBDG depth using for summary in DBLD
+// Bit 7:0   RW, db_o1_lg,       offset of LBDG depth using for summary in DBLD
+#define   D2D3_DBLD_LG_PARAM                       (0x2b13)
+#define P_D2D3_DBLD_LG_PARAM                       (volatile unsigned int *)((0x2b13  << 2) + 0xff900000)
+// Bit 31:24 RW, db_factor,      unsigned gain of difference in DBLD
+// Bit 23:16 RW, db_hf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 15:8  RW, db_hf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 7:0   RW, db_hf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+#define   D2D3_DBLD_LPF_HCOEFF                     (0x2b14)
+#define P_D2D3_DBLD_LPF_HCOEFF                     (volatile unsigned int *)((0x2b14  << 2) + 0xff900000)
+// Bit 31:24 RW, db_owin_fill,   signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
+// Bit 23:16 RW, db_vf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 15:8  RW, db_vf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 7:0   RW, db_vf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+#define   D2D3_DBLD_LPF_VCOEFF                     (0x2b15)
+#define P_D2D3_DBLD_LPF_VCOEFF                     (volatile unsigned int *)((0x2b15  << 2) + 0xff900000)
+// Bit 31:28 RW, hist_depth_idx,
+// Bit 27:26 Reserved
+// Bit 25    RW, mbdg_dep_neg,   1 to negate the output data of MBDG
+// Bit 24    RW, lbdg_dep_neg,   1 to negate the output data of LBDG
+// Bit 23:16 RW, db_f1_ctrl,     MUX1 selector
+//                               [1:0] MUX1 path1 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [3:2] MUX1 path2 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [6:4] MUX1 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX1out0, others:summary
+//                               [7] MUX1OUT0 selector, 0:MIN (MUX1PATH1,MUX1Path2), 1:MAX (MUX1Path1,MUX1Path2)
+// Bit 15:8  RW, db_f2_ctrl,     MUX2 selector
+//                               [1:0] MUX2 path1 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [3:2] MUX2 path2 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [6:4] MUX2 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX2out0, others:MUX2out0
+//                               [7] MUX2OUT0 selector, 0:MIN (MUX2PATH1,MUX2Path2), 1:MAX (MUX2Path1,MUX2Path2)
+// Bit 7:4   RW, db_fifo0_sel,   the source input of FIFO0
+//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG others:reserved
+// Bit 3:0   RW, db_fifo1_sel,   the source input of FIFO1
+//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG 4: from FIFO0; others:reserved
+#define   D2D3_DBLD_PATH_CTRL                      (0x2b16)
+#define P_D2D3_DBLD_PATH_CTRL                      (volatile unsigned int *)((0x2b16  << 2) + 0xff900000)
+// Indicate the input picture size in SCU18 unit
+// Bit 31:16 RW, szy_scui,       The vertical size
+// Bit 15:0  RW, szx_scui,       The horizontal size
+#define   D2D3_SCU18_INPIC_SIZE                    (0x2b17)
+#define P_D2D3_SCU18_INPIC_SIZE                    (volatile unsigned int *)((0x2b17  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// MBDG registers
+// mg: model based depth generate module
+//------------------------------------------------------------------------------
+// Bit 31:18 Reserved
+// Bit 17    RW, mg_vp_en,       mdg vanish point enable, not used
+// Bit 16    RW, mg_sw_en,       1 to use the software forced parameter for the point D, U and C in MBDG
+// Bit 15:8  RW, mg_owin_fill,   Signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
+// Bit 7     RW, mg_iir_en,      1 to enable the 2-taps IIR filter in MBDG
+// Bit 6:0   RW, mg_iir,         [6]: 1 to bypass the 2-taps IIR filter in MBDG
+//                               [5:0]:Unsigned coefficient of the 2-taps IIR filter in MBDG
+//                               [6]:bypass, 1:bypass, 0:not bypass
+#define   D2D3_MBDG_CTRL                           (0x2b18)
+#define P_D2D3_MBDG_CTRL                           (volatile unsigned int *)((0x2b18  << 2) + 0xff900000)
+// Bit 31:28 RW, mg_dtl_pxl_left, Max pixel number (1<< mg_dtl_pxl_left) using in the left window for activities in MBDG
+// Bit 27:24 RW, mg_dtl_pxl_right, Max pixel number (1<< mg_dtl_pxl_right) using in the right window for activities in MBDG
+// Bit 23:16 RW, mg_cx_sw,       Depth of point C in horizontal curve in MBDG for software forced
+// Bit 15:8  RW, mg_ux_sw,       Depth of point U in horizontal curve in MBDG for software forced
+// Bit 7:0   RW, mg_dx_sw,       Depth of point D in horizontal curve in MBDG for software forced
+#define   D2D3_MBDG_PARAM_0                        (0x2b19)
+#define P_D2D3_MBDG_PARAM_0                        (volatile unsigned int *)((0x2b19  << 2) + 0xff900000)
+// Bit 31:28 RW, mg_dtl_pxl_up,  Max pixel number (1<< mg_dtl_pxl_up) using in the top window for activities in MBDG
+// Bit 27:24 RW, mg_dtl_pxl_dn,  Max pixel number (1<< mg_dtl_pxl_dn) using in the bottom window for activities in MBDG
+// Bit 23:16 RW, mg_cy_sw,       Depth of point C in vertical curve in MBDG for software forced
+// Bit 15:8  RW, mg_uy_sw,       Depth of point U in vertical curve in MBDG for software forced
+// Bit 7:0   RW, mg_dy_sw,       Depth of point D in vertical curve in MBDG for software forced
+#define   D2D3_MBDG_PARAM_1                        (0x2b1a)
+#define P_D2D3_MBDG_PARAM_1                        (volatile unsigned int *)((0x2b1a  << 2) + 0xff900000)
+// Bit 31:24 RW, mg_dtl_ln_up,   Line number in the top window for activities in MBDG
+// Bit 23:16 RW, mg_dtl_ln_dn,   Line number in the bottom window for activities in MBDG
+// Bit 15:8  RW, mg_dtl_ln_left, Column number in the left window for activities in MBDG
+// Bit 7:0   RW, mg_dtl_ln_right,Column number in the right window for activities in MBDG
+#define   D2D3_MBDG_PARAM_2                        (0x2b1b)
+#define P_D2D3_MBDG_PARAM_2                        (volatile unsigned int *)((0x2b1b  << 2) + 0xff900000)
+// Bit 31:24 RW, mg_y_max,       Software initial depth of point D and U in vertical curve
+// Bit 23:16 RW, mg_y_min,       Software initial depth of point C in vertical curve
+// Bit 15:8  RW, mg_x_max,       Software initial depth of point D and U in horizontal curve
+// Bit 7:0   RW, mg_x_min,       Software initial depth of point C in horizontal curve
+#define   D2D3_MBDG_PARAM_3                        (0x2b1c)
+#define P_D2D3_MBDG_PARAM_3                        (volatile unsigned int *)((0x2b1c  << 2) + 0xff900000)
+// Bit 31:27 Reserved
+// Bit 26    RW, mg_y_adapt_en,  1 to enable the adaptive mode for point U/D in vertical curve calculation
+// Bit 25    RW, mg_xmm_adapt_en, 1 to enable the XMM adaptive mode for point U/D in horizontal curve calculation
+// Bit 24    RW, mg_x_adapt_en,  1 to enable the adaptive mode for point U/D in horizontal curve calculation
+// Bit 23:20 RW, mg_ytrans_1,    Shifter controller in vertical curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
+// Bit 19:16 RW, mg_xtrans_1,    Shifter controller in horizontal curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
+// Bit 15:8  RW, mg_yk_0,        The based activities value of the ACT for vertical curve
+// Bit 7:0   RW, mg_xk_0,        The based activities value of the ACT for horizontal curve
+#define   D2D3_MBDG_PARAM_4                        (0x2b1d)
+#define P_D2D3_MBDG_PARAM_4                        (volatile unsigned int *)((0x2b1d  << 2) + 0xff900000)
+// Bit 31:24 RW, mg_ysu3,        Quantized value 3 in vertical curve adaptive calculation
+// Bit 23:16 RW, mg_ysu2,        Quantized value 2 in vertical curve adaptive calculation
+// Bit 15:8  RW, mg_ysu1,        Quantized value 1 in vertical curve adaptive calculation
+// Bit 7:0   RW, mg_ysu0,        Quantized value 0 in vertical curve adaptive calculation
+#define   D2D3_MBDG_PARAM_5                        (0x2b1e)
+#define P_D2D3_MBDG_PARAM_5                        (volatile unsigned int *)((0x2b1e  << 2) + 0xff900000)
+// Bit 31:24 RW, mg_xsu3,        Quantized value 3 in horizontal curve adaptive calculation
+// Bit 23:16 RW, mg_xsu2,        Quantized value 2 in horizontal curve adaptive calculation
+// Bit 15:8  RW, mg_xsu1,        Quantized value 1 in horizontal curve adaptive calculation
+// Bit 7:0   RW, mg_xsu0,        Quantized value 0 in horizontal curve adaptive calculation
+#define   D2D3_MBDG_PARAM_6                        (0x2b1f)
+#define P_D2D3_MBDG_PARAM_6                        (volatile unsigned int *)((0x2b1f  << 2) + 0xff900000)
+// Bit 31:16 Reserved
+// Bit 15:8  RW, mg_xsu4,        Quantized value 4 in horizontal curve adaptive calculation
+// Bit 7:0   RW, mg_ysu4,        Quantized value 4 in vertical curve adaptive calculation
+#define   D2D3_MBDG_PARAM_7                        (0x2b20)
+#define P_D2D3_MBDG_PARAM_7                        (volatile unsigned int *)((0x2b20  << 2) + 0xff900000)
+// Bit 31:28 RW, dbg_hscnt_sel   see DBG_STATUS_2
+// Bit 27:25 Reserved
+// Bit 24    RW, dbg_dbr_en,     1 to enable debug mode in DBR
+// Bit 23:16 RW, dbg_force_data, Forced data in debug mode
+// Bit 15:12 RW, dbg_bld_ctrl,   debug controller for DBLD
+//                               [12]:enable;  [13]: 0 for passive mode, 0 for handshake mode
+//                               [15:14]: 0 for constant mode, 1 for step1 mode
+// Bit 11:8  RW, dbg_mg_ctrl,    debug controller for MBDG
+//                               [8]:enable;  [9]: 0 for passive mode, 0 for handshake mode
+//                               [11:10]: 0 for constant mode, 1 for step1 mode
+// Bit 7:4   RW, dbg_cg_ctrl,    debug controller for CBDG
+//                               [4]:enable;  [5]: 0 for passive mode, 0 for handshake mode
+//                               [7:6]: 0 for constant mode, 1 for step1 mode
+// Bit 3:0   RW, dbg_lg_ctrl,    debug controller for LBDG
+//                               [0]:enable;  [1]: 0 for passive mode, 0 for handshake mode
+//                               [3:2]: 0 for constant mode, 1 for step1 mode
+#define   D2D3_DBG_CTRL                            (0x2b23)
+#define P_D2D3_DBG_CTRL                            (volatile unsigned int *)((0x2b23  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// DWMIF registers
+//------------------------------------------------------------------------------
+// Bit 31:18 Reserved
+// Bit 17    RW, dw_x_rev        0: Normal write data from left to right in horizontal
+//                               1: Reversed write data from left to right in horizontal
+// Bit 16    RW, dw_y_rev        0: Normal write data from top to bottom in horizontal
+//                               1: Reversed write data from bottom to top in horizontal
+// Bit 15    RW, dw_done_clr     1 to clear register depw_done (DWMIF_STATUS)
+// Bit 14    RW, dw_little_endian, 0: data is ordered in big-endian, 1: little endian
+// Bit 13:12 RW, dw_pic_struct,  0:read every line, 1:reserved, 2:read even line, 3:read odd line
+// Bit 11    RW, dw_urgent,      urgent index
+// Bit 10    RW, dw_clr_wrrsp,   1:clear the write fifo counter
+// Bit 9     RW, dw_canvas_wr,   canvas write initialization again
+// Bit 8     RW, dw_req_en,      1 to enable write request
+// Bit 7:0   RW, dw_canvas_index,Canvas index for the MSB of memory address for memory write
+#define   D2D3_DWMIF_CTRL                          (0x2b24)
+#define P_D2D3_DWMIF_CTRL                          (volatile unsigned int *)((0x2b24  << 2) + 0xff900000)
+// Bit 31    Reserved
+// Bit 30:16 RW, dw_end_x,       Horizontal end position for memory write, count by BYTE
+// Bit 15    Reserved
+// Bit 14:0  RW, dw_start_x,     Horizontal start position for memory write, count by BYTE
+#define   D2D3_DWMIF_HPOS                          (0x2b25)
+#define P_D2D3_DWMIF_HPOS                          (volatile unsigned int *)((0x2b25  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, dw_end_y,       Vertical end position for memory write, count by BYTE
+// Bit 15:13 Reserved
+// Bit 12:0  RW, dw_start_y,     Vertical start position for memory write, count by BYTE
+#define   D2D3_DWMIF_VPOS                          (0x2b26)
+#define P_D2D3_DWMIF_VPOS                          (volatile unsigned int *)((0x2b26  << 2) + 0xff900000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, dw_vsizem1,     Vertical size for memory write, equal the size minus 1
+// Bit 15:12 Reserved
+// Bit 11:0  RW, dw_hsizem1,     Horizontal size for memory write, equal the size minus 1
+#define   D2D3_DWMIF_SIZE                          (0x2b27)
+#define P_D2D3_DWMIF_SIZE                          (volatile unsigned int *)((0x2b27  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// DRMIF registers
+//------------------------------------------------------------------------------
+// Bit 31:18 Reserved
+// Bit 17    RW, dr_y_rev,       0: Normal Read data from top to bottom in horizontal
+//                               1: Reversed read data from bottom to top in horizontal
+// Bit 16    RW, dr_x_rev,       0: Normal Read data from left to right in horizontal
+//                               1: Reversed read data from right to left in horizontal
+// Bit 15    RW, dr_clr_fifo_error, 1 to clear the overflow flag of the sticky FIFO
+// Bit 14    RW, dr_little_endian, 0: data is ordered in big-endian; 1: little-endian
+// Bit 13:12 RW, dr_pic_struct,  0: progressive;  1: Reserved;
+//                               2: interlaced, even line;  3: interlaced, odd line
+// Bit 11    RW, dr_urgent,      urgent index, no use in this system
+// Bit 10:9  RW, dr_burst_size,  Burst read length for each request; 0=24,1=32,2=48,3=64
+// Bit 8     RW, dr_req_en,      1 to enable read request
+// Bit 7:0   RW, dr_canvas_index, Canvas index for the MSB of memory address for memory read
+#define   D2D3_DRMIF_CTRL                          (0x2b28)
+#define P_D2D3_DRMIF_CTRL                          (volatile unsigned int *)((0x2b28  << 2) + 0xff900000)
+// Bit 31    Reserved
+// Bit 30:16 RW, dr_end_x,       Horizontal end position for memory read, count by BYTE
+// Bit 15    Reserved
+// Bit 14:0  RW, dr_start_x,     Horizontal start position for memory read, count by BYTE
+#define   D2D3_DRMIF_HPOS                          (0x2b29)
+#define P_D2D3_DRMIF_HPOS                          (volatile unsigned int *)((0x2b29  << 2) + 0xff900000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, dr_end_y,       Vertical end position for memory read, count by BYTE
+// Bit 15:13 Reserved
+// Bit 12:0  RW, dr_start_y,     Vertical start position for memory read, count by BYTE
+#define   D2D3_DRMIF_VPOS                          (0x2b2a)
+#define P_D2D3_DRMIF_VPOS                          (volatile unsigned int *)((0x2b2a  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// PDR registers
+// ddd: parallax based render
+//------------------------------------------------------------------------------
+// Bit 31:8  Reserved
+// Bit 7     RW, ddd_brdlpf_en,  1 to enable the smooth filter on the depth around the boundary
+// Bit 6     RW, ddd_extn_black, 1 to enable the function to fill black colour when interpolated pixels is outside the picture in DBR
+// Bit 5     RW, ddd_wrap_en,    Reserved
+// Bit 4     RW, ddd_hhalf,      1 to indicate the left/right line length is a half of original line.
+// Bit 3:2   RW, ddd_out_mode,   Reserved
+// Bit 1:0   RW, ddd_lomode,     wrap & pbr interleave mode:
+//                               2'b0x: whole line is left or right;
+//                               2'b10: d2p_lar=1(D2P_PARAM_1), rlrlrlrl inteleave in one line,
+//                                      d2p_lar=0(D2P_PARAM_1), lrlrlrlr inteleave in one line,
+//                               2'b11: d2p_lar=1(D2P_PARAM_1), rrrrr?lllll, half line is right, another half is left,
+//                                      d2p_lar=0(D2P_PARAM_1), lllll?rrrrr, half line is left, another half is right,
+#define   D2D3_DBR_DDD_CTRL                        (0x2b2c)
+#define P_D2D3_DBR_DDD_CTRL                        (volatile unsigned int *)((0x2b2c  << 2) + 0xff900000)
+// Bit 31:0  RW, ddd_dbg_ctrl,   no use
+#define   D2D3_DBR_DDD_DBG                         (0x2b2d)
+#define P_D2D3_DBR_DDD_DBG                         (volatile unsigned int *)((0x2b2d  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// LRDMX registers
+//------------------------------------------------------------------------------
+// Bit 31:9  Reserved
+// Bit 8     RW, lr_merge,       1: all the left/right input go to the left channel output
+// Bit 7:6   RW, lrd_ff0_sel,    FF0 source selector
+//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
+// Bit 5:4   RW, lrd_ff1_sel,    FF1 source selector
+//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
+// Bit 3:2   RW, lrd_lout_sel,   left channel DEMUX
+//                               00: ff0  01:ff1   10: left input  11:right input
+// Bit 1:0   RW, lrd_rout_sel,   right channel DEMUX
+//                               00: ff1  01:ff0   10: left input  11:right input
+#define   D2D3_DBR_LRDMX_CTRL                      (0x2b2f)
+#define P_D2D3_DBR_LRDMX_CTRL                      (volatile unsigned int *)((0x2b2f  << 2) + 0xff900000)
+//------------------------------------------------------------------------------
+// Read Only registers
+//------------------------------------------------------------------------------
+// Bit 31:24 RO, ro_cg_vprel,    vanish point's reliability in CBDG
+// Bit 23:12 RO, ro_cg_vpx,      vanish point's X-Axis in CBDG
+// Bit 11:0  RO, ro_cg_vpy,      vanish point's Y-Axis in CBDG
+#define   D2D3_CBDG_STATUS_1                       (0x2b30)
+#define P_D2D3_CBDG_STATUS_1                       (volatile unsigned int *)((0x2b30  << 2) + 0xff900000)
+// Bit 31:24 RO, ro_mg_cx[7:0],  X-Axis of point C in horizontal curve in MBDG
+// Bit 23:16 RO, ro_mg_ux,       Depth value of point U in horizontal curve in MBDG
+// Bit 15:8  RO, ro_mg_dx,       Depth value of point D in horizontal curve in MBDG
+// Bit 7:0   RO, ro_mg_minx,     Depth value of point C in horizontal curve in MBDG
+#define   D2D3_MBDG_STATUS_1                       (0x2b31)
+#define P_D2D3_MBDG_STATUS_1                       (volatile unsigned int *)((0x2b31  << 2) + 0xff900000)
+// Bit 31:24 RO, ro_mg_cy[7:0],  X-Axis of point C in vertical curve in MBDG
+// Bit 23:16 RO, ro_mg_uy,       Depth value of point U in vertical curve in MBDG
+// Bit 15:8  RO, ro_mg_dy,       Depth value of point D in vertical curve in MBDG
+// Bit 7:0   RO, ro_mg_miny,     Depth value of point C in vertical curve in MBDG
+#define   D2D3_MBDG_STATUS_2                       (0x2b32)
+#define P_D2D3_MBDG_STATUS_2                       (volatile unsigned int *)((0x2b32  << 2) + 0xff900000)
+// Bit 31    RO, ro_wrap_status, 1 indicate the D2P_WRAP is busy to perform the initialization
+// Bit 30:8  Reserved
+// Bit 7:4   RO, ro_mg_cy[11:8], X-Axis of point C in vertical curve in MBDG
+// Bit 3:0   RO, ro_mg_cx[11:8], X-Axis of point C in horizontal curve in MBDG
+#define   D2D3_MBDG_STATUS_3                       (0x2b33)
+#define P_D2D3_MBDG_STATUS_3                       (volatile unsigned int *)((0x2b33  << 2) + 0xff900000)
+// Bit 31:21 Reserved
+// Bit 20:0  RO, ro_mg_sum_u,    ACT(top): activities of the top part
+#define   D2D3_MBDG_STATUS_4                       (0x2b34)
+#define P_D2D3_MBDG_STATUS_4                       (volatile unsigned int *)((0x2b34  << 2) + 0xff900000)
+// Bit 31:21 Reserved
+// Bit 20:0  RO, ro_mg_sum_d,    ACT(bottom): activities of the bottom part
+#define   D2D3_MBDG_STATUS_5                       (0x2b35)
+#define P_D2D3_MBDG_STATUS_5                       (volatile unsigned int *)((0x2b35  << 2) + 0xff900000)
+// Bit 31:21 Reserved
+// Bit 20:0  RO, ro_mg_sum_l,    ACT(left): activities of the left part
+#define   D2D3_MBDG_STATUS_6                       (0x2b36)
+#define P_D2D3_MBDG_STATUS_6                       (volatile unsigned int *)((0x2b36  << 2) + 0xff900000)
+// Bit 31:21 Reserved
+// Bit 20:0  RO, ro_mg_sum_r,    ACT(right): activities of the right part
+#define   D2D3_MBDG_STATUS_7                       (0x2b37)
+#define P_D2D3_MBDG_STATUS_7                       (volatile unsigned int *)((0x2b37  << 2) + 0xff900000)
+// Bit 31:0 dbg_handshake_ro0,   handshake signal for debug, internal srdy and rrdy
+#define   D2D3_DBG_STATUS_1                        (0x2b38)
+#define P_D2D3_DBG_STATUS_1                        (volatile unsigned int *)((0x2b38  << 2) + 0xff900000)
+// Bit 31:0 dbg_hscnt,           dbg_hscnt_sel == 4'h0, output lg hscnt
+//                               dbg_hscnt_sel == 4'h1, output cg hscnt
+//                               dbg_hscnt_sel == 4'h2, output mg hscnt
+//                               dbg_hscnt_sel == 4'h3, output bld hscnt
+//                               dbg_hscnt_sel == other value, output 32'h0
+#define   D2D3_DBG_STATUS_2                        (0x2b39)
+#define P_D2D3_DBG_STATUS_2                        (volatile unsigned int *)((0x2b39  << 2) + 0xff900000)
+// Bit 31:0 RO, drmif_status,    drmif module internal status
+#define   D2D3_DRMIF_STATUS                        (0x2b3a)
+#define P_D2D3_DRMIF_STATUS                        (volatile unsigned int *)((0x2b3a  << 2) + 0xff900000)
+// Bit 31:2 RO, Reserved
+// Bit 1:0  RO, d2d3_status0,    [1]: depw_done, one field depth write to ddr has done
+//                               [0]: dwmif_pending_ddr_wrrsp, 1 to indicate write response from ddr
+#define   D2D3_DWMIF_STATUS                        (0x2b3b)
+#define P_D2D3_DWMIF_STATUS                        (volatile unsigned int *)((0x2b3b  << 2) + 0xff900000)
+// Bit 31:24 Reserved
+// Bit 23:0  RO, ro_meet_sum,    register sumxy_sum_dbg in CBDG
+#define   D2D3_CBDG_STATUS_2                       (0x2b3c)
+#define P_D2D3_CBDG_STATUS_2                       (volatile unsigned int *)((0x2b3c  << 2) + 0xff900000)
+// Bit 31:20 Reserved
+// Bit 19:0  RO, ro_hist_depth,
+#define   D2D3_DBLD_STATUS                         (0x2b3d)
+#define P_D2D3_DBLD_STATUS                         (volatile unsigned int *)((0x2b3d  << 2) + 0xff900000)
+// Bit 31:0 Reserved
+#define   D2D3_RESEV_STATUS1                       (0x2b3e)
+#define P_D2D3_RESEV_STATUS1                       (volatile unsigned int *)((0x2b3e  << 2) + 0xff900000)
+// Bit 31:0  Reserved
+#define   D2D3_RESEV_STATUS2                       (0x2b3f)
+#define P_D2D3_RESEV_STATUS2                       (volatile unsigned int *)((0x2b3f  << 2) + 0xff900000)
+//
+// Closing file:  d2d3_regs.h
+//
+//========================================================================
+//  MIPI DSI Host Controller        (16'h2c00 - 16'h2cff)
+//
+//========================================================================
+//`define  DSI_VCBUS_BASE             8'h2c
+//`include "dsi_regs.h"
+//========================================================================
+//  ISP register    (16'h2d00 - 16'h2dff)
+//========================================================================
+//`define ISP_VCBUS_BASE                   8'h2d
+//`include "isp_reg.h"
+//`define MADB_VCBUS_BASE                8'h2d
+//
+// Reading file:  dnr_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  MADB_VCBUS_BASE = 0x2d
+// -----------------------------------------------
+#define   DNR_CTRL                                 (0x2d00)
+#define P_DNR_CTRL                                 (volatile unsigned int *)((0x2d00  << 2) + 0xff900000)
+//Bit 31:17,        reserved
+//Bit 16,            reg_dnr_en		                                , dnr enable                  . unsigned  , default = 1
+//Bit 15,            reg_dnr_db_vdbstep                          , vdb step, 0: 4, 1: 8        . unsigned  , default = 1
+//Bit 14,            reg_dnr_db_vdbprten                         , vdb protectoin enable       . unsigned  , default = 1
+//Bit 13,            reg_dnr_gbs_difen                           , enable dif (between LR and LL/RR) condition for gbs stat.. unsigned  , default = 0
+//Bit 12,            reg_dnr_luma_en                             , enable ycbcr2luma module    . unsigned  , default = 1
+//Bit 11:10,        reg_dnr_db_mod                              , deblocking mode, 0: disable, 1: horizontal deblocking, 2: vertical deblocking, 3: horizontal & vertical deblocking. unsigned  , default = 3
+//Bit  9,            reg_dnr_db_chrmen                           , enable chroma deblocking    . unsigned  , default = 1
+//Bit  8,            reg_dnr_hvdif_mod                           , 0: calc. difs by original Y, 1: by new luma. unsigned  , default = 1
+//Bit  7,            reserved
+//Bit  6: 4,        reg_dnr_demo_lften                          , b0: Y b1:U b2:V             . unsigned  , default = 7
+//Bit  3,            reserved
+//Bit  2: 0,        reg_dnr_demo_rgten                          , b0: Y b1:U b2:V             . unsigned  , default = 7
+#define   DNR_HVSIZE                               (0x2d01)
+#define P_DNR_HVSIZE                               (volatile unsigned int *)((0x2d01  << 2) + 0xff900000)
+//Bit 31:29,        reserved
+//Bit 28:16,        reg_dnr_hsize                               , hsize                       . unsigned  , default = 0
+//Bit 15:13,        reserved
+//Bit 12: 0,        reg_dnr_vsize                               , vsize                       . unsigned  , default = 0
+#define   DNR_DBLK_BLANK_NUM                       (0x2d02)
+#define P_DNR_DBLK_BLANK_NUM                       (volatile unsigned int *)((0x2d02  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_dblk_hblank_num                         , deblock hor blank num       . unsigned  , default = 16
+//Bit  7: 0,        reg_dblk_vblank_num                         , deblock ver blank num       . unsigned  , default = 45
+#define   DNR_BLK_OFFST                            (0x2d03)
+#define P_DNR_BLK_OFFST                            (volatile unsigned int *)((0x2d03  << 2) + 0xff900000)
+//Bit 31: 7,        reserved
+//Bit  6: 4,        reg_dnr_hbofst                              , horizontal block offset may provide by software calc.. unsigned  , default = 0
+//Bit  3,            reserved
+//Bit  2: 0,        reg_dnr_vbofst                              , vertical block offset may provide by software calc.. unsigned  , default = 0
+#define   DNR_GBS                                  (0x2d04)
+#define P_DNR_GBS                                  (volatile unsigned int *)((0x2d04  << 2) + 0xff900000)
+//Bit 31: 2,        reserved
+//Bit  1: 0,        reg_dnr_gbs                                 , global block strength may update by software calc.. unsigned  , default = 0
+#define   DNR_HBOFFST_STAT                         (0x2d05)
+#define P_DNR_HBOFFST_STAT                         (volatile unsigned int *)((0x2d05  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_hbof_difthd                         , dif threshold (>=) between LR and LL/RR. unsigned  , default = 2
+//Bit 23:16,        reg_dnr_hbof_edgethd                        , edge threshold (<=) for LR  . unsigned  , default = 32
+//Bit 15: 8,        reg_dnr_hbof_flatthd                        , flat threshold (>=) for LR  . unsigned  , default = 0
+//Bit  7,            reserved
+//Bit  6: 4,        reg_dnr_hbof_delta                          , delta for weighted bin accumulator. unsigned  , default = 1
+//Bit  3,            reserved
+//Bit  2: 0,        reg_dnr_hbof_statmod                        , statistic mode for horizontal block offset, 0: count flags for 8-bin, 1: count LRs for 8-bin, 2: count difs for 8-bin, 3: count weighted flags for 8-bin, 4: count flags for first 32-bin, 5: count LRs for first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2
+#define   DNR_VBOFFST_STAT                         (0x2d06)
+#define P_DNR_VBOFFST_STAT                         (volatile unsigned int *)((0x2d06  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_vbof_difthd                         , dif threshold (>=) between Up and Dw. unsigned  , default = 1
+//Bit 23:16,        reg_dnr_vbof_edgethd                        , edge threshold (<=) for Up/Dw. unsigned  , default = 16
+//Bit 15: 8,        reg_dnr_vbof_flatthd                        , flat threshold (>=) for Up/Dw. unsigned  , default = 0
+//Bit  7,            reserved
+//Bit  6: 4,        reg_dnr_vbof_delta                          , delta for weighted bin accumulator. unsigned  , default = 1
+//Bit  3,            reserved
+//Bit  2: 0,        reg_dnr_vbof_statmod                        , statistic mode for vertical block offset, 0: count flags for 8-bin, 1: count Ups for 8-bin, 2: count difs for 8-bin, 3: count weighted flags for 8-bin, 4: count flags for first 32-bin, 5: count Ups for first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2
+#define   DNR_GBS_STAT                             (0x2d07)
+#define P_DNR_GBS_STAT                             (volatile unsigned int *)((0x2d07  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_gbs_edgethd                         , edge threshold (<=) for LR  . unsigned  , default = 32
+//Bit 23:16,        reg_dnr_gbs_flatthd                         , flat threshold (>=) for LR  . unsigned  , default = 0
+//Bit 15: 8,        reg_dnr_gbs_varthd                          , variation threshold (<=) for Lvar/Rvar. unsigned  , default = 16
+//Bit  7: 0,        reg_dnr_gbs_difthd                          , dif threshold (>=) between LR and LL/RR. unsigned  , default = 2
+#define   DNR_STAT_X_START_END                     (0x2d08)
+#define P_DNR_STAT_X_START_END                     (volatile unsigned int *)((0x2d08  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:16,        reg_dnr_stat_xst                                                          . unsigned  , default = 24
+//Bit 15:14,        reserved
+//Bit 13: 0,        reg_dnr_stat_xed                                                          . unsigned  , default = HSIZE - 25
+#define   DNR_STAT_Y_START_END                     (0x2d09)
+#define P_DNR_STAT_Y_START_END                     (volatile unsigned int *)((0x2d09  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:16,        reg_dnr_stat_yst                                                          . unsigned  , default = 24
+//Bit 15:14,        reserved
+//Bit 13: 0,        reg_dnr_stat_yed                                                          . unsigned  , default = VSIZE - 25
+#define   DNR_LUMA                                 (0x2d0a)
+#define P_DNR_LUMA                                 (volatile unsigned int *)((0x2d0a  << 2) + 0xff900000)
+//Bit 31:27,        reserved
+//Bit 26:24,        reg_dnr_luma_sqrtshft                       , left shift for fast squart of chroma, [0, 4]. unsigned  , default = 2
+//Bit 23:21,        reserved
+//Bit 20:16,        reg_dnr_luma_sqrtoffst                      , offset for fast squart of chroma. signed    , default = 0
+//Bit 15,            reserved
+//Bit 14:12,        reg_dnr_luma_wcmod                          , theta related to warm/cool segment line, 0: 0, 1: 45, 2: 90, 3: 135, 4: 180, 5: 225, 6: 270, 7: 315. . unsigned  , default = 3
+//Bit 11: 8,        reg_dnr_luma_cshft                          , shift for calc. delta part, 0~8,  . unsigned  , default = 8
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_dnr_luma_cgain                          , final gain for delta part, 32 normalized to "1". unsigned  , default = 4
+#define   DNR_DB_YEDGE_THD                         (0x2d0b)
+#define P_DNR_DB_YEDGE_THD                         (volatile unsigned int *)((0x2d0b  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_db_yedgethd0                        , edge threshold0 for luma    . unsigned  , default = 12
+//Bit 23:16,        reg_dnr_db_yedgethd1                        , edge threshold1 for luma    . unsigned  , default = 15
+//Bit 15: 8,        reg_dnr_db_yedgethd2                        , edge threshold2 for luma    . unsigned  , default = 18
+//Bit  7: 0,        reg_dnr_db_yedgethd3                        , edge threshold3 for luma    . unsigned  , default = 25
+#define   DNR_DB_CEDGE_THD                         (0x2d0c)
+#define P_DNR_DB_CEDGE_THD                         (volatile unsigned int *)((0x2d0c  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_db_cedgethd0                        , edge threshold0 for chroma  . unsigned  , default = 12
+//Bit 23:16,        reg_dnr_db_cedgethd1                        , edge threshold1 for chroma  . unsigned  , default = 15
+//Bit 15: 8,        reg_dnr_db_cedgethd2                        , edge threshold2 for chroma  . unsigned  , default = 18
+//Bit  7: 0,        reg_dnr_db_cedgethd3                        , edge threshold3 for chroma  . unsigned  , default = 25
+#define   DNR_DB_HGAP                              (0x2d0d)
+#define P_DNR_DB_HGAP                              (volatile unsigned int *)((0x2d0d  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_dnr_db_hgapthd                          , horizontal gap thd (<=) for very sure blockiness . unsigned  , default = 8
+//Bit 15: 8,        reg_dnr_db_hgapdifthd                       , dif thd between hgap and lft/rgt hdifs. unsigned  , default = 1
+//Bit  7: 1,        reserved
+//Bit  0,            reg_dnr_db_hgapmod                          , horizontal gap calc. mode, 0: just use current col x, 1: find max between (x-1, x, x+1) . unsigned  , default = 0
+#define   DNR_DB_HBS                               (0x2d0e)
+#define P_DNR_DB_HBS                               (volatile unsigned int *)((0x2d0e  << 2) + 0xff900000)
+//Bit 31: 6,        reserved
+//Bit  5: 4,        reg_dnr_db_hbsup                            , horizontal bs up value      . unsigned  , default = 1
+//Bit  3: 2,        reg_dnr_db_hbsmax                           , max value of hbs for global control. unsigned  , default = 3
+//Bit  1: 0,        reg_dnr_db_hgbsthd                          , gbs thd (>=) for hbs calc.  . unsigned  , default = 1
+#define   DNR_DB_HACT                              (0x2d0f)
+#define P_DNR_DB_HACT                              (volatile unsigned int *)((0x2d0f  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_dnr_db_hactthd0                         , thd0 of hact, for block classification. unsigned  , default = 10
+//Bit  7: 0,        reg_dnr_db_hactthd1                         , thd1 of hact, for block classification. unsigned  , default = 32
+#define   DNR_DB_YHDELTA_GAIN                      (0x2d10)
+#define P_DNR_DB_YHDELTA_GAIN                      (volatile unsigned int *)((0x2d10  << 2) + 0xff900000)
+//Bit 31:27,        reserved
+//Bit 26:24,        reg_dnr_db_yhdeltagain1                     , (p1-q1) gain for Y's delta calc. when bs=1, normalized 8 as "1" . unsigned  , default = 2
+//Bit 23,            reserved
+//Bit 22:20,        reg_dnr_db_yhdeltagain2                     , (p1-q1) gain for Y's delta calc. when bs=2, normalized 8 as "1" . unsigned  , default = 0
+//Bit 19,            reserved
+//Bit 18:16,        reg_dnr_db_yhdeltagain3                     , (p1-q1) gain for Y's delta calc. when bs=3, normalized 8 as "1" . unsigned  , default = 0
+//Bit 15,            reserved
+//Bit 14: 8,        reg_dnr_db_yhdeltaadjoffst                  , offset for adjust Y's hdelta (-64, 63). signed    , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_dnr_db_yhdeltaadjgain                   , gain for adjust Y's hdelta, normalized 32 as "1" . unsigned  , default = 32
+#define   DNR_DB_YHDELTA2_GAIN                     (0x2d11)
+#define P_DNR_DB_YHDELTA2_GAIN                     (volatile unsigned int *)((0x2d11  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_dnr_db_yhdelta2gain2                    , gain for bs=2's adjust Y's hdelta2, normalized 64 as "1" . unsigned  , default = 8
+//Bit 23:21,        reserved
+//Bit 20:16,        reg_dnr_db_yhdelta2offst2                   , offset for bs=2's adjust Y's hdelta2 (-16, 15). signed    , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_dnr_db_yhdelta2gain3                    , gain for bs=3's adjust Y's hdelta2, normalized 64 as "1" . unsigned  , default = 4
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_db_yhdelta2offst3                   , offset for bs=3's adjust Y's hdelta2 (-16, 15). signed    , default = 0
+#define   DNR_DB_CHDELTA_GAIN                      (0x2d12)
+#define P_DNR_DB_CHDELTA_GAIN                      (volatile unsigned int *)((0x2d12  << 2) + 0xff900000)
+//Bit 31:27,        reserved
+//Bit 26:24,        reg_dnr_db_chdeltagain1                     , (p1-q1) gain for UV's delta calc. when bs=1, normalized 8 as "1". unsigned  , default = 2
+//Bit 23,            reserved
+//Bit 22:20,        reg_dnr_db_chdeltagain2                     , (p1-q1) gain for UV's delta calc. when bs=2, normalized 8 as "1". unsigned  , default = 0
+//Bit 19,            reserved
+//Bit 18:16,        reg_dnr_db_chdeltagain3                     , (p1-q1) gain for UV's delta calc. when bs=3, normalized 8 as "1". unsigned  , default = 0
+//Bit 15,            reserved
+//Bit 14: 8,        reg_dnr_db_chdeltaadjoffst                  , offset for adjust UV's hdelta (-64, 63). signed    , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_dnr_db_chdeltaadjgain                   , gain for adjust UV's hdelta, normalized 32 as "1". unsigned  , default = 32
+#define   DNR_DB_CHDELTA2_GAIN                     (0x2d13)
+#define P_DNR_DB_CHDELTA2_GAIN                     (volatile unsigned int *)((0x2d13  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_dnr_db_chdelta2gain2                    , gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" . unsigned  , default = 8
+//Bit 23:21,        reserved
+//Bit 20:16,        reg_dnr_db_chdelta2offst2                   , offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_dnr_db_chdelta2gain3                    , gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" . unsigned  , default = 4
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_db_chdelta2offst3                   , offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0
+#define   DNR_DB_YC_VEDGE_THD                      (0x2d14)
+#define P_DNR_DB_YC_VEDGE_THD                      (volatile unsigned int *)((0x2d14  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_dnr_db_yvedgethd                        , special Y's edge thd for vdb. unsigned  , default = 12
+//Bit  7: 0,        reg_dnr_db_cvedgethd                        , special UV's edge thd for vdb. unsigned  , default = 12
+#define   DNR_DB_VBS_MISC                          (0x2d15)
+#define P_DNR_DB_VBS_MISC                          (volatile unsigned int *)((0x2d15  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_db_vgapthd                          , vertical gap thd (<=) for very sure blockiness . unsigned  , default = 8
+//Bit 23:16,        reg_dnr_db_vactthd                          , thd of vact, for block classification . unsigned  , default = 10
+//Bit 15: 8,        reg_dnr_db_vgapdifthd                       , dif thd between vgap and vact. unsigned  , default = 4
+//Bit  7: 4,        reserved
+//Bit  3: 2,        reg_dnr_db_vbsmax                           , max value of vbs for global control. unsigned  , default = 2
+//Bit  1: 0,        reg_dnr_db_vgbsthd                          , gbs thd (>=) for vbs calc.  . unsigned  , default = 1
+#define   DNR_DB_YVDELTA_GAIN                      (0x2d16)
+#define P_DNR_DB_YVDELTA_GAIN                      (volatile unsigned int *)((0x2d16  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_dnr_db_yvdeltaadjgain                   , gain for adjust Y's vdelta, normalized 32 as "1". unsigned  , default = 32
+//Bit 23,            reserved
+//Bit 22:16,        reg_dnr_db_yvdeltaadjoffst                  , offset for adjust Y's vdelta (-64, 63). signed    , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_dnr_db_yvdelta2gain                     , gain for adjust Y's vdelta2, normalized 64 as "1". unsigned  , default = 8
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_db_yvdelta2offst                    , offset for adjust Y's vdelta2 (-16, 15). signed    , default = 0
+#define   DNR_DB_CVDELTA_GAIN                      (0x2d17)
+#define P_DNR_DB_CVDELTA_GAIN                      (volatile unsigned int *)((0x2d17  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_dnr_db_cvdeltaadjgain                   , gain for adjust UV's vdelta, normalized 32 as "1". unsigned  , default = 32
+//Bit 23,            reserved
+//Bit 22:16,        reg_dnr_db_cvdeltaadjoffst                  , offset for adjust UV's vdelta (-64, 63). signed    , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_dnr_db_cvdelta2gain                     , gain for adjust UV's vdelta2, normalized 64 as "1". unsigned  , default = 8
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_db_cvdelta2offst                    , offset for adjust UV's vdelta2 (-16, 15). signed    , default = 0
+#define   DNR_RO_GBS_STAT_LR                       (0x2d18)
+#define P_DNR_RO_GBS_STAT_LR                       (volatile unsigned int *)((0x2d18  << 2) + 0xff900000)
+//Bit 31: 0,        ro_gbs_stat_lr                                                            . unsigned  , default = 0
+#define   DNR_RO_GBS_STAT_LL                       (0x2d19)
+#define P_DNR_RO_GBS_STAT_LL                       (volatile unsigned int *)((0x2d19  << 2) + 0xff900000)
+//Bit 31: 0,        ro_gbs_stat_ll                                                            . unsigned  , default = 0
+#define   DNR_RO_GBS_STAT_RR                       (0x2d1a)
+#define P_DNR_RO_GBS_STAT_RR                       (volatile unsigned int *)((0x2d1a  << 2) + 0xff900000)
+//Bit 31: 0,        ro_gbs_stat_rr                                                            . unsigned  , default = 0
+#define   DNR_RO_GBS_STAT_DIF                      (0x2d1b)
+#define P_DNR_RO_GBS_STAT_DIF                      (volatile unsigned int *)((0x2d1b  << 2) + 0xff900000)
+//Bit 31: 0,        ro_gbs_stat_dif                                                           . unsigned  , default = 0
+#define   DNR_RO_GBS_STAT_CNT                      (0x2d1c)
+#define P_DNR_RO_GBS_STAT_CNT                      (volatile unsigned int *)((0x2d1c  << 2) + 0xff900000)
+//Bit 31: 0,        ro_gbs_stat_cnt                                                           . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_0                   (0x2d1d)
+#define P_DNR_RO_HBOF_STAT_CNT_0                   (volatile unsigned int *)((0x2d1d  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt0                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_1                   (0x2d1e)
+#define P_DNR_RO_HBOF_STAT_CNT_1                   (volatile unsigned int *)((0x2d1e  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt1                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_2                   (0x2d1f)
+#define P_DNR_RO_HBOF_STAT_CNT_2                   (volatile unsigned int *)((0x2d1f  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt2                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_3                   (0x2d20)
+#define P_DNR_RO_HBOF_STAT_CNT_3                   (volatile unsigned int *)((0x2d20  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt3                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_4                   (0x2d21)
+#define P_DNR_RO_HBOF_STAT_CNT_4                   (volatile unsigned int *)((0x2d21  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt4                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_5                   (0x2d22)
+#define P_DNR_RO_HBOF_STAT_CNT_5                   (volatile unsigned int *)((0x2d22  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt5                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_6                   (0x2d23)
+#define P_DNR_RO_HBOF_STAT_CNT_6                   (volatile unsigned int *)((0x2d23  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt6                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_7                   (0x2d24)
+#define P_DNR_RO_HBOF_STAT_CNT_7                   (volatile unsigned int *)((0x2d24  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt7                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_8                   (0x2d25)
+#define P_DNR_RO_HBOF_STAT_CNT_8                   (volatile unsigned int *)((0x2d25  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt8                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_9                   (0x2d26)
+#define P_DNR_RO_HBOF_STAT_CNT_9                   (volatile unsigned int *)((0x2d26  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt9                                                         . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_10                  (0x2d27)
+#define P_DNR_RO_HBOF_STAT_CNT_10                  (volatile unsigned int *)((0x2d27  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt10                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_11                  (0x2d28)
+#define P_DNR_RO_HBOF_STAT_CNT_11                  (volatile unsigned int *)((0x2d28  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt11                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_12                  (0x2d29)
+#define P_DNR_RO_HBOF_STAT_CNT_12                  (volatile unsigned int *)((0x2d29  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt12                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_13                  (0x2d2a)
+#define P_DNR_RO_HBOF_STAT_CNT_13                  (volatile unsigned int *)((0x2d2a  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt13                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_14                  (0x2d2b)
+#define P_DNR_RO_HBOF_STAT_CNT_14                  (volatile unsigned int *)((0x2d2b  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt14                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_15                  (0x2d2c)
+#define P_DNR_RO_HBOF_STAT_CNT_15                  (volatile unsigned int *)((0x2d2c  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt15                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_16                  (0x2d2d)
+#define P_DNR_RO_HBOF_STAT_CNT_16                  (volatile unsigned int *)((0x2d2d  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt16                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_17                  (0x2d2e)
+#define P_DNR_RO_HBOF_STAT_CNT_17                  (volatile unsigned int *)((0x2d2e  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt17                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_18                  (0x2d2f)
+#define P_DNR_RO_HBOF_STAT_CNT_18                  (volatile unsigned int *)((0x2d2f  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt18                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_19                  (0x2d30)
+#define P_DNR_RO_HBOF_STAT_CNT_19                  (volatile unsigned int *)((0x2d30  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt19                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_20                  (0x2d31)
+#define P_DNR_RO_HBOF_STAT_CNT_20                  (volatile unsigned int *)((0x2d31  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt20                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_21                  (0x2d32)
+#define P_DNR_RO_HBOF_STAT_CNT_21                  (volatile unsigned int *)((0x2d32  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt21                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_22                  (0x2d33)
+#define P_DNR_RO_HBOF_STAT_CNT_22                  (volatile unsigned int *)((0x2d33  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt22                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_23                  (0x2d34)
+#define P_DNR_RO_HBOF_STAT_CNT_23                  (volatile unsigned int *)((0x2d34  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt23                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_24                  (0x2d35)
+#define P_DNR_RO_HBOF_STAT_CNT_24                  (volatile unsigned int *)((0x2d35  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt24                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_25                  (0x2d36)
+#define P_DNR_RO_HBOF_STAT_CNT_25                  (volatile unsigned int *)((0x2d36  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt25                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_26                  (0x2d37)
+#define P_DNR_RO_HBOF_STAT_CNT_26                  (volatile unsigned int *)((0x2d37  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt26                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_27                  (0x2d38)
+#define P_DNR_RO_HBOF_STAT_CNT_27                  (volatile unsigned int *)((0x2d38  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt27                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_28                  (0x2d39)
+#define P_DNR_RO_HBOF_STAT_CNT_28                  (volatile unsigned int *)((0x2d39  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt28                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_29                  (0x2d3a)
+#define P_DNR_RO_HBOF_STAT_CNT_29                  (volatile unsigned int *)((0x2d3a  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt29                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_30                  (0x2d3b)
+#define P_DNR_RO_HBOF_STAT_CNT_30                  (volatile unsigned int *)((0x2d3b  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt30                                                        . unsigned  , default = 0
+#define   DNR_RO_HBOF_STAT_CNT_31                  (0x2d3c)
+#define P_DNR_RO_HBOF_STAT_CNT_31                  (volatile unsigned int *)((0x2d3c  << 2) + 0xff900000)
+//Bit 31: 0,        ro_hbof_stat_cnt31                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_0                   (0x2d3d)
+#define P_DNR_RO_VBOF_STAT_CNT_0                   (volatile unsigned int *)((0x2d3d  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt0                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_1                   (0x2d3e)
+#define P_DNR_RO_VBOF_STAT_CNT_1                   (volatile unsigned int *)((0x2d3e  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt1                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_2                   (0x2d3f)
+#define P_DNR_RO_VBOF_STAT_CNT_2                   (volatile unsigned int *)((0x2d3f  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt2                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_3                   (0x2d40)
+#define P_DNR_RO_VBOF_STAT_CNT_3                   (volatile unsigned int *)((0x2d40  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt3                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_4                   (0x2d41)
+#define P_DNR_RO_VBOF_STAT_CNT_4                   (volatile unsigned int *)((0x2d41  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt4                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_5                   (0x2d42)
+#define P_DNR_RO_VBOF_STAT_CNT_5                   (volatile unsigned int *)((0x2d42  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt5                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_6                   (0x2d43)
+#define P_DNR_RO_VBOF_STAT_CNT_6                   (volatile unsigned int *)((0x2d43  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt6                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_7                   (0x2d44)
+#define P_DNR_RO_VBOF_STAT_CNT_7                   (volatile unsigned int *)((0x2d44  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt7                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_8                   (0x2d45)
+#define P_DNR_RO_VBOF_STAT_CNT_8                   (volatile unsigned int *)((0x2d45  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt8                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_9                   (0x2d46)
+#define P_DNR_RO_VBOF_STAT_CNT_9                   (volatile unsigned int *)((0x2d46  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt9                                                         . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_10                  (0x2d47)
+#define P_DNR_RO_VBOF_STAT_CNT_10                  (volatile unsigned int *)((0x2d47  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt10                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_11                  (0x2d48)
+#define P_DNR_RO_VBOF_STAT_CNT_11                  (volatile unsigned int *)((0x2d48  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt11                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_12                  (0x2d49)
+#define P_DNR_RO_VBOF_STAT_CNT_12                  (volatile unsigned int *)((0x2d49  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt12                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_13                  (0x2d4a)
+#define P_DNR_RO_VBOF_STAT_CNT_13                  (volatile unsigned int *)((0x2d4a  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt13                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_14                  (0x2d4b)
+#define P_DNR_RO_VBOF_STAT_CNT_14                  (volatile unsigned int *)((0x2d4b  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt14                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_15                  (0x2d4c)
+#define P_DNR_RO_VBOF_STAT_CNT_15                  (volatile unsigned int *)((0x2d4c  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt15                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_16                  (0x2d4d)
+#define P_DNR_RO_VBOF_STAT_CNT_16                  (volatile unsigned int *)((0x2d4d  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt16                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_17                  (0x2d4e)
+#define P_DNR_RO_VBOF_STAT_CNT_17                  (volatile unsigned int *)((0x2d4e  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt17                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_18                  (0x2d4f)
+#define P_DNR_RO_VBOF_STAT_CNT_18                  (volatile unsigned int *)((0x2d4f  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt18                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_19                  (0x2d50)
+#define P_DNR_RO_VBOF_STAT_CNT_19                  (volatile unsigned int *)((0x2d50  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt19                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_20                  (0x2d51)
+#define P_DNR_RO_VBOF_STAT_CNT_20                  (volatile unsigned int *)((0x2d51  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt20                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_21                  (0x2d52)
+#define P_DNR_RO_VBOF_STAT_CNT_21                  (volatile unsigned int *)((0x2d52  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt21                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_22                  (0x2d53)
+#define P_DNR_RO_VBOF_STAT_CNT_22                  (volatile unsigned int *)((0x2d53  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt22                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_23                  (0x2d54)
+#define P_DNR_RO_VBOF_STAT_CNT_23                  (volatile unsigned int *)((0x2d54  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt23                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_24                  (0x2d55)
+#define P_DNR_RO_VBOF_STAT_CNT_24                  (volatile unsigned int *)((0x2d55  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt24                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_25                  (0x2d56)
+#define P_DNR_RO_VBOF_STAT_CNT_25                  (volatile unsigned int *)((0x2d56  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt25                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_26                  (0x2d57)
+#define P_DNR_RO_VBOF_STAT_CNT_26                  (volatile unsigned int *)((0x2d57  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt26                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_27                  (0x2d58)
+#define P_DNR_RO_VBOF_STAT_CNT_27                  (volatile unsigned int *)((0x2d58  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt27                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_28                  (0x2d59)
+#define P_DNR_RO_VBOF_STAT_CNT_28                  (volatile unsigned int *)((0x2d59  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt28                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_29                  (0x2d5a)
+#define P_DNR_RO_VBOF_STAT_CNT_29                  (volatile unsigned int *)((0x2d5a  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt29                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_30                  (0x2d5b)
+#define P_DNR_RO_VBOF_STAT_CNT_30                  (volatile unsigned int *)((0x2d5b  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt30                                                        . unsigned  , default = 0
+#define   DNR_RO_VBOF_STAT_CNT_31                  (0x2d5c)
+#define P_DNR_RO_VBOF_STAT_CNT_31                  (volatile unsigned int *)((0x2d5c  << 2) + 0xff900000)
+//Bit 31: 0,        ro_vbof_stat_cnt31                                                        . unsigned  , default = 0
+#define   DNR_DM_CTRL                              (0x2d60)
+#define P_DNR_DM_CTRL                              (volatile unsigned int *)((0x2d60  << 2) + 0xff900000)
+//Bit 31:13,        reserved
+//Bit 12,            reg_dnr_dm_fedgeflg_en                      , enable edge flag calc. of each frame. unsigned  , default = 1
+//Bit 11,            reg_dnr_dm_fedgeflg_cl                      , clear frame edge flag if needed. unsigned  , default = 1
+//Bit 10,            reg_dnr_dm_fedgeflg_df                      , user defined edge when reg_dnr_dm_fedgeflg_en=0, default = 1
+//Bit  9,            reg_dnr_dm_en                               , enable demosquito function  . unsigned  , default = 1
+//Bit  8,            reg_dnr_dm_chrmen                           , enable chrome processing for demosquito. unsigned  , default = 1
+//Bit  7: 6,        reg_dnr_dm_level                            , demosquito level            . unsigned  , default = 3
+//Bit  5: 4,        reg_dnr_dm_leveldw0                         , level down when gbs is small. unsigned  , default = 1
+//Bit  3: 2,        reg_dnr_dm_leveldw1                         , level down for no edge/flat blocks. unsigned  , default = 1
+//Bit  1: 0,        reg_dnr_dm_gbsthd                           , small/large threshold for gbs (<=). unsigned  , default = 0
+#define   DNR_DM_NR_BLND                           (0x2d61)
+#define P_DNR_DM_NR_BLND                           (volatile unsigned int *)((0x2d61  << 2) + 0xff900000)
+//Bit 31:25,        reserved
+//Bit 24,            reg_dnr_dm_defalpen                         , enable user define alpha for dm & nr blend. unsigned  , default = 0
+//Bit 23:16,        reg_dnr_dm_defalp                           , user define alpha for dm & nr blend if enable. unsigned  , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_dnr_dm_alpgain                          , gain for nr/dm alpha, normalized 32 as "1". unsigned  , default = 32
+//Bit  7: 0,        reg_dnr_dm_alpoffst                         , (-128, 127), offset for nr/dm alpha. signed    , default = 0
+#define   DNR_DM_RNG_THD                           (0x2d62)
+#define P_DNR_DM_RNG_THD                           (volatile unsigned int *)((0x2d62  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_dnr_dm_rngminthd                                                      . unsigned  , default = 2
+//Bit 15: 8,        reg_dnr_dm_rngmaxthd                                                      . unsigned  , default = 64
+//Bit  7: 0,        reg_dnr_dm_rngdifthd                                                      . unsigned  , default = 4
+#define   DNR_DM_RNG_GAIN_OFST                     (0x2d63)
+#define P_DNR_DM_RNG_GAIN_OFST                     (volatile unsigned int *)((0x2d63  << 2) + 0xff900000)
+//Bit 31:14,        reserved
+//Bit 13: 8,        reg_dnr_dm_rnggain                          , normalized 16 as "1"        . unsigned  , default = 16
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_dnr_dm_rngofst                                                        . unsigned  , default = 0
+#define   DNR_DM_DIR_MISC                          (0x2d64)
+#define P_DNR_DM_DIR_MISC                          (volatile unsigned int *)((0x2d64  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29,            reg_dnr_dm_diralpen                                                       . unsigned  , default = 1
+//Bit 28:24,        reg_dnr_dm_diralpgain                                                     . unsigned  , default = 0
+//Bit 23:22,        reserved
+//Bit 21:16,        reg_dnr_dm_diralpofst                                                     . unsigned  , default = 0
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_diralpmin                                                      . unsigned  , default = 0
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_diralpmax                                                      . unsigned  , default = 31
+#define   DNR_DM_COR_DIF                           (0x2d65)
+#define P_DNR_DM_COR_DIF                           (volatile unsigned int *)((0x2d65  << 2) + 0xff900000)
+//Bit 31: 4,        reserved
+//Bit  3: 1,        reg_dnr_dm_cordifshft                                                     . unsigned  , default = 3
+//Bit  0,            reg_dnr_dm_cordifmod                        , 0:use max dir dif as cordif, 1: use max3x3 - min3x3 as cordif. unsigned  , default = 1
+#define   DNR_DM_FLT_THD                           (0x2d66)
+#define P_DNR_DM_FLT_THD                           (volatile unsigned int *)((0x2d66  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_dm_fltthd00                         , block flat threshold0 for block average difference when gbs is small, for flat block detection. unsigned  , default = 4
+//Bit 23:16,        reg_dnr_dm_fltthd01                         , block flat threshold1 for block average difference when gbs is small, for flat block detection. unsigned  , default = 6
+//Bit 15: 8,        reg_dnr_dm_fltthd10                         , block flat threshold0 for block average difference when gbs is large, for flat block detection. unsigned  , default = 9
+//Bit  7: 0,        reg_dnr_dm_fltthd11                         , block flat threshold1 for block average difference when gbs is large, for flat block detection. unsigned  , default = 12
+#define   DNR_DM_VAR_THD                           (0x2d67)
+#define P_DNR_DM_VAR_THD                           (volatile unsigned int *)((0x2d67  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_dm_varthd00                         , block variance threshold0 (>=) when gbs is small, for flat block detection. unsigned  , default = 2
+//Bit 23:16,        reg_dnr_dm_varthd01                         , block variance threshold1 (<=) when gbs is small, for flat block detection. unsigned  , default = 15
+//Bit 15: 8,        reg_dnr_dm_varthd10                         , block variance threshold0 (>=) when gbs is large, for flat block detection. unsigned  , default = 3
+//Bit  7: 0,        reg_dnr_dm_varthd11                         , block variance threshold1 (<=) when gbs is large, for flat block detection. unsigned  , default = 24
+#define   DNR_DM_EDGE_DIF_THD                      (0x2d68)
+#define P_DNR_DM_EDGE_DIF_THD                      (volatile unsigned int *)((0x2d68  << 2) + 0xff900000)
+//Bit 31:24,        reg_dnr_dm_edgethd0                         , block edge threshold (<=) when gbs is small, for flat block detection. unsigned  , default = 32
+//Bit 23:16,        reg_dnr_dm_edgethd1                         , block edge threshold (<=) when gbs is large, for flat block detection. unsigned  , default = 48
+//Bit 15: 8,        reg_dnr_dm_difthd0                          , block dif threshold (<=) when gbs is small, for flat block detection. unsigned  , default = 48
+//Bit  7: 0,        reg_dnr_dm_difthd1                          , block dif threshold (<=) when gbs is large, for flat block detection. unsigned  , default = 64
+#define   DNR_DM_AVG_THD                           (0x2d69)
+#define P_DNR_DM_AVG_THD                           (volatile unsigned int *)((0x2d69  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_dnr_dm_avgthd0                          , block average threshold (>=), for flat block detection. unsigned  , default = 160
+//Bit  7: 0,        reg_dnr_dm_avgthd1                          , block average threshold (<=), for flat block detection. unsigned  , default = 128
+#define   DNR_DM_AVG_VAR_DIF_THD                   (0x2d6a)
+#define P_DNR_DM_AVG_VAR_DIF_THD                   (volatile unsigned int *)((0x2d6a  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_dnr_dm_avgdifthd                        , block average dif threshold (<) between cur and up block, for flat block detection. unsigned  , default = 12
+//Bit  7: 0,        reg_dnr_dm_vardifthd                        , block variance dif threshold (>=) between cur and up block, for flat block detection. unsigned  , default = 1
+#define   DNR_DM_VAR_EDGE_DIF_THD2                 (0x2d6b)
+#define P_DNR_DM_VAR_EDGE_DIF_THD2                 (volatile unsigned int *)((0x2d6b  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_dnr_dm_varthd2                          , block variance threshold (>=), for edge block detection. unsigned  , default = 24
+//Bit 15: 8,        reg_dnr_dm_edgethd2                         , block edge threshold (>=), for edge block detection. unsigned  , default = 40
+//Bit  7: 0,        reg_dnr_dm_difthd2                          , block dif threshold (>=), for edge block detection. unsigned  , default = 80
+#define   DNR_DM_DIF_FLT_MISC                      (0x2d6c)
+#define P_DNR_DM_DIF_FLT_MISC                      (volatile unsigned int *)((0x2d6c  << 2) + 0xff900000)
+//Bit 31:28,        reg_dnr_dm_ldifoob                          , pre-defined large dif when pixel out of blocks. unsigned  , default = 0
+//Bit 27:24,        reg_dnr_dm_bdifoob                          , pre-defined block dif when pixel out of blocks;. unsigned  , default = 0
+//Bit 23:16,        reg_dnr_dm_fltalp                           , pre-defined alpha for dm and nr blending, when block is flat with mos.. unsigned  , default = 200
+//Bit 15:12,        reserved
+//Bit 11: 8,        reg_dnr_dm_fltminbdif                       , pre-defined min block dif for dm filter, when block is flat with mos.. unsigned  , default = 12
+//Bit  7,            reserved
+//Bit  6: 2,        reg_dnr_dm_difnormgain                      , gain for pixel dif normalization for dm filter, normalized 16 as "1". unsigned  , default = 16
+//Bit  1,            reg_dnr_dm_difnormen                        , enable pixel dif normalization for dm filter. unsigned  , default = 1
+//Bit  0,            reg_dnr_dm_difupden                         , enable block dif update using max of left, cur, right difs. unsigned  , default = 0
+#define   DNR_DM_SDIF_LUT0_2                       (0x2d6d)
+#define P_DNR_DM_SDIF_LUT0_2                       (volatile unsigned int *)((0x2d6d  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_sdiflut0                         , normally 0-16               . unsigned  , default = 16
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_sdiflut1                         , normally 0-16               . unsigned  , default = 14
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_sdiflut2                         , normally 0-16               . unsigned  , default = 13
+#define   DNR_DM_SDIF_LUT3_5                       (0x2d6e)
+#define P_DNR_DM_SDIF_LUT3_5                       (volatile unsigned int *)((0x2d6e  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_sdiflut3                         , normally 0-16               . unsigned  , default = 10
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_sdiflut4                         , normally 0-16               . unsigned  , default = 7
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_sdiflut5                         , normally 0-16               . unsigned  , default = 5
+#define   DNR_DM_SDIF_LUT6_8                       (0x2d6f)
+#define P_DNR_DM_SDIF_LUT6_8                       (volatile unsigned int *)((0x2d6f  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_sdiflut6                         , normally 0-16               . unsigned  , default = 3
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_sdiflut7                         , normally 0-16               . unsigned  , default = 1
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_sdiflut8                         , normally 0-16               . unsigned  , default = 0
+#define   DNR_DM_LDIF_LUT0_2                       (0x2d70)
+#define P_DNR_DM_LDIF_LUT0_2                       (volatile unsigned int *)((0x2d70  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_ldiflut0                         , normally 0-16               . unsigned  , default = 0
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_ldiflut1                         , normally 0-16               . unsigned  , default = 4
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_ldiflut2                         , normally 0-16               . unsigned  , default = 12
+#define   DNR_DM_LDIF_LUT3_5                       (0x2d71)
+#define P_DNR_DM_LDIF_LUT3_5                       (volatile unsigned int *)((0x2d71  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_ldiflut3                         , normally 0-16               . unsigned  , default = 14
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_ldiflut4                         , normally 0-16               . unsigned  , default = 15
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_ldiflut5                         , normally 0-16               . unsigned  , default = 16
+#define   DNR_DM_LDIF_LUT6_8                       (0x2d72)
+#define P_DNR_DM_LDIF_LUT6_8                       (volatile unsigned int *)((0x2d72  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_ldiflut6                         , normally 0-16               . unsigned  , default = 16
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_ldiflut7                         , normally 0-16               . unsigned  , default = 16
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_ldiflut8                         , normally 0-16               . unsigned  , default = 16
+#define   DNR_DM_DIF2NORM_LUT0_2                   (0x2d73)
+#define P_DNR_DM_DIF2NORM_LUT0_2                   (volatile unsigned int *)((0x2d73  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_dif2normlut0                     , normally 0-16               . unsigned  , default = 16
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_dif2normlut1                     , normally 0-16               . unsigned  , default = 5
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_dif2normlut2                     , normally 0-16               . unsigned  , default = 3
+#define   DNR_DM_DIF2NORM_LUT3_5                   (0x2d74)
+#define P_DNR_DM_DIF2NORM_LUT3_5                   (volatile unsigned int *)((0x2d74  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_dif2normlut3                     , normally 0-16               . unsigned  , default = 2
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_dif2normlut4                     , normally 0-16               . unsigned  , default = 2
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_dif2normlut5                     , normally 0-16               . unsigned  , default = 1
+#define   DNR_DM_DIF2NORM_LUT6_8                   (0x2d75)
+#define P_DNR_DM_DIF2NORM_LUT6_8                   (volatile unsigned int *)((0x2d75  << 2) + 0xff900000)
+//Bit 31:21,        reserved
+//Bit 20:16,        reg_dnr_dm_dif2normlut6                     , normally 0-16               . unsigned  , default = 1
+//Bit 15:13,        reserved
+//Bit 12: 8,        reg_dnr_dm_dif2normlut7                     , normally 0-16               . unsigned  , default = 1
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_dnr_dm_dif2normlut8                     , normally 0-16               . unsigned  , default = 1
+#define   DNR_DM_GMS_THD                           (0x2d76)
+#define P_DNR_DM_GMS_THD                           (volatile unsigned int *)((0x2d76  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_gms_stat_thd0                                                         . unsigned  , default = 0
+//Bit  7: 0,        reg_gms_stat_thd1                                                         . unsigned  , default = 128
+#define   DNR_RO_DM_GMS_STAT_CNT                   (0x2d77)
+#define P_DNR_RO_DM_GMS_STAT_CNT                   (volatile unsigned int *)((0x2d77  << 2) + 0xff900000)
+//Bit 31: 0,        ro_dm_gms_stat_cnt                                                        . unsigned  , default = 0
+#define   DNR_RO_DM_GMS_STAT_MS                    (0x2d78)
+#define P_DNR_RO_DM_GMS_STAT_MS                    (volatile unsigned int *)((0x2d78  << 2) + 0xff900000)
+//Bit 31: 0,        ro_dm_gms_stat_ms                                                        . unsigned  , default = 0
+// 0x80-0x90
+//
+// Reading file:  decomb_regs.h
+//
+#define   DECOMB_DET_VERT_CON0                     (0x2d80)
+#define P_DECOMB_DET_VERT_CON0                     (volatile unsigned int *)((0x2d80  << 2) + 0xff900000)
+//Bit  31:24   reg_di_dcmb_det_vcon_thd0      default = 60  // u8
+//Bit  23:16   reg_di_dcmb_det_vcon_thd1      default = 80  // u8
+//Bit  15: 8   reg_di_dcmb_det_valp_lmt0      default = 63  // u8
+//Bit   7: 0   reg_di_dcmb_det_valp_lmt1      default = 4   // u8
+#define   DECOMB_DET_VERT_CON1                     (0x2d81)
+#define P_DECOMB_DET_VERT_CON1                     (volatile unsigned int *)((0x2d81  << 2) + 0xff900000)
+//Bit  23:16   reg_di_dcmb_det_valp_lmt2      default = 0   // u8
+//Bit  15: 8   reg_di_dcmb_det_vrate0         default = 32  // u8
+//Bit   7: 0   reg_di_dcmb_det_vrate1         default = 4   // u8
+#define   DECOMB_DET_EDGE_CON0                     (0x2d82)
+#define P_DECOMB_DET_EDGE_CON0                     (volatile unsigned int *)((0x2d82  << 2) + 0xff900000)
+//Bit  31:24   reg_di_dcmb_det_econ_thd0      default = 60  // u8
+//Bit  23:16   reg_di_dcmb_det_econ_thd1      default = 80  // u8
+//Bit  15: 8   reg_di_dcmb_det_ealp_lmt0      default = 63  // u8
+//Bit   7: 0   reg_di_dcmb_det_ealp_lmt1      default = 4   // u8
+#define   DECOMB_DET_EDGE_CON1                     (0x2d83)
+#define P_DECOMB_DET_EDGE_CON1                     (volatile unsigned int *)((0x2d83  << 2) + 0xff900000)
+//Bit  23:16   reg_di_dcmb_det_ealp_lmt2      default = 0   // u8
+//Bit  15: 8   reg_di_dcmb_det_erate0         default = 32  // u8
+//Bit   7: 0   reg_di_dcmb_det_erate1         default = 4  // u8
+#define   DECOMB_PARA                              (0x2d84)
+#define P_DECOMB_PARA                              (volatile unsigned int *)((0x2d84  << 2) + 0xff900000)
+//Bit  31:30   reserved
+//Bit  29:28   reg_di_dcmb_cmb_lpf            default = 1  // u2, 0:no lpf, 1:[1 2 1], 2,3: [1 2 2 2 1]
+//Bit  27:26   reg_di_dcmb_vedge_chk          default = 0  // u2, vertical edge check, 0: no check, 1: vrt!=0, 2: vrt==3
+//Bit  25:24   reg_di_dcmb_nedge_chk          default = 0  // u2, no idea edge check, 0, no check, 1, check
+//Bit  23:20   reg_di_dcmb_edge_min           default = 0   // u4, min edge for edge cmb
+//Bit  19:16   reg_di_dcmb_edge_max           default = 15  // u4, min edge for edge cmb
+//Bit   15:8   reg_di_dcmb_bld_alp            default = 255  // u8, user defined alpha for di & decmb blend
+//Bit    7:0   reg_di_dcmb_bld_alp_beta       default = 40  // u8, beta for mtn & cmb blend, for bld alpha calc.
+#define   DECOMB_BLND_CON0                         (0x2d85)
+#define P_DECOMB_BLND_CON0                         (volatile unsigned int *)((0x2d85  << 2) + 0xff900000)
+//Bit  31:24   reg_di_dcmb_bld_con_thd0       default = 100  // u8
+//Bit  23:16   reg_di_dcmb_bld_con_thd1       default = 120  // u8
+//Bit  15: 8   reg_di_dcmb_bld_alp_lmt0       default = 0  // u8
+//Bit   7: 0   reg_di_dcmb_bld_alp_lmt1       default = 128   // u8
+#define   DECOMB_BLND_CON1                         (0x2d86)
+#define P_DECOMB_BLND_CON1                         (volatile unsigned int *)((0x2d86  << 2) + 0xff900000)
+//Bit  23:16   reg_di_dcmb_bld_alp_lmt2       default = 255   // u8
+//Bit  15: 8   reg_di_dcmb_bld_rate0          default = 32 // u8
+//Bit   7: 0   reg_di_dcmb_bld_rate1          default = 32  // u8
+#define   DECOMB_YC_THRD                           (0x2d87)
+#define P_DECOMB_YC_THRD                           (volatile unsigned int *)((0x2d87  << 2) + 0xff900000)
+//Bit  31:16   reserved
+//Bit  15: 8   reg_di_dcmb_ythd               default = 2 // u8, default = 2
+//Bit   7: 0   reg_di_dcmb_cthd               default = 2 // u8, default = 2
+#define   DECOMB_MTN_GAIN_OFST                     (0x2d88)
+#define P_DECOMB_MTN_GAIN_OFST                     (volatile unsigned int *)((0x2d88  << 2) + 0xff900000)
+//Bit  31:22   reserved
+//Bit  21:16   reg_di_dcmb_mtn_alp_gain       default = 16  // u6, 16 is normalized to '1'
+//Bit   15:9   reserved
+//Bit    8:0   reg_di_dcmb_mtn_alp_ofst       default = 0  // s9, [-256, 255]
+#define   DECOMB_CMB_SEL_GAIN_OFST                 (0x2d89)
+#define P_DECOMB_CMB_SEL_GAIN_OFST                 (volatile unsigned int *)((0x2d89  << 2) + 0xff900000)
+//Bit  31:22   reserved
+//Bit  21:16   reg_di_dcmb_cmb_sel_gain       default = 48  // u6, 16 is normalized to '1'
+//Bit   15:9   reserved
+//Bit    8:0   reg_di_dcmb_cmb_sel_ofst       default = 0  // s9, [-256, 255]
+#define   DECOMB_WIND00                            (0x2d8a)
+#define P_DECOMB_WIND00                            (volatile unsigned int *)((0x2d8a  << 2) + 0xff900000)
+//Bit  31:29   reserved
+//Bit  28:16   reg_di_dcmb_wnd00              default = 0 // u13, x0 for window 0, software control
+//Bit  15:13   reserved
+//Bit   12:0   reg_di_dcmb_wnd01              default = 719 // u13, x1 for window 0, HSIZE-1, software control
+#define   DECOMB_WIND01                            (0x2d8b)
+#define P_DECOMB_WIND01                            (volatile unsigned int *)((0x2d8b  << 2) + 0xff900000)
+//Bit  31:29   reserved
+//Bit  28:16   reg_di_dcmb_wnd02              default = 0 // u13, y0 for window 0, software control
+//Bit  15:13   reserved
+//Bit   12:0   reg_di_dcmb_wnd03              default = 39 // u13, y1 for window 0, software control
+#define   DECOMB_WIND10                            (0x2d8c)
+#define P_DECOMB_WIND10                            (volatile unsigned int *)((0x2d8c  << 2) + 0xff900000)
+//Bit  31:29   reserved
+//Bit  28:16   reg_di_dcmb_wnd10              default = 0 // u13, x0 for window 1, software control
+//Bit  15:13   reserved
+//Bit   12:0   reg_di_dcmb_wnd11              default = 719 // u13, x1 for window 1, HSIZE-1, software control
+#define   DECOMB_WIND11                            (0x2d8d)
+#define P_DECOMB_WIND11                            (volatile unsigned int *)((0x2d8d  << 2) + 0xff900000)
+//Bit  31:29   reserved
+//Bit  28:16   reg_di_dcmb_wnd12              default = 40 // u13, y0 for window 1, software control
+//Bit  15:13   reserved
+//Bit   12:0   reg_di_dcmb_wnd13              default = 239 // u13, y1 for window 1, VSIZE-1-40, software control
+#define   DECOMB_MODE                              (0x2d8e)
+#define P_DECOMB_MODE                              (volatile unsigned int *)((0x2d8e  << 2) + 0xff900000)
+//Bit  31:16   reserved
+//Bit     15   reg_di_dcmb_is_cmb_bef         default = 1  // u1, 1: decide is_cmb before cmbing refine, 0: decide is_cmb after cmbing refine
+//Bit     14   reg_di_dcmb_en0                default = 1 // u1, enable decmobing for wind0
+//Bit     13   reg_di_dcmb_en1                default = 1 // u1, enable decmobing for wind1
+//Bit     12   reg_di_dcmb_en2                default = 1 // u1, enable decmobing for wind2
+//Bit  11:10   reg_di_dcmb_lpf_mod0           default = 2  // u2, get combing free pixels of wind0 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
+//Bit    9:8   reg_di_dcmb_lpf_mod1           default = 2  // u2, get combing free pixels of wind1 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
+//Bit    7:6   reg_di_dcmb_lpf_mod2           default = 0  // u2, get combing free pixels of wind2 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
+//Bit      5   reg_di_dcmb_cmb_sel0           default = 1  // u1, wind0 decmb based on: 0, vert cmb, 1, edge cmb
+//Bit      4   reg_di_dcmb_cmb_sel1           default = 1  // u1, wind1 decmb based on: 0, vert cmb, 1, edge cmb
+//Bit      3   reg_di_dcmb_cmb_sel2           default = 0  // u1, wind2 decmb based on: 0, vert cmb, 1, edge cmb
+//Bit      2   reg_di_dcmb_alp_mod0           default = 1  // u1, wind0 decmb alpha based on: 0, user-defined, 1, motion adaptive
+//Bit      1   reg_di_dcmb_alp_mod1           default = 1  // u1, wind1 decmb alpha based on: 0, user-defined, 1, motion adaptive
+//Bit      0   reg_di_dcmb_alp_mod2           default = 1  // u1, wind2 decmb alpha based on: 0, user-defined, 1, motion adaptive
+#define   DECOMB_FRM_SIZE                          (0x2d8f)
+#define P_DECOMB_FRM_SIZE                          (volatile unsigned int *)((0x2d8f  << 2) + 0xff900000)
+//Bit  31:29   reserved
+//Bit  28:16   hsize_in                       default = 1920  // u13, pic horz size in  unit: pixel
+//Bit  15:13   reserved
+//Bit   12:0   vsize_in                       default = 1080  // u13, pic vert size in  unit: pixel
+#define   DECOMB_HV_BLANK                          (0x2d90)
+#define P_DECOMB_HV_BLANK                          (volatile unsigned int *)((0x2d90  << 2) + 0xff900000)
+//Bit  31:16   reserved
+//Bit   15:8   hblank_num                     default = 20  // u8, hor blank time
+//Bit    7:0   vblank_num                     default = 50  // u8, ver blank time
+//
+// Closing file:  decomb_regs.h
+//
+// 0x98-0xa3
+//
+// Reading file:  nr2_det_polar_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   NR2_POLAR3_MODE                          (0x2d98)
+#define P_NR2_POLAR3_MODE                          (volatile unsigned int *)((0x2d98  << 2) + 0xff900000)
+//Bit 31:20        reserved
+//Bit 19:18        reg_polar3_f02lpf_mod0    // unsigned , default = 3  low pass filter mode for field 0 and field2 before polar3 detection; 0 for no lpf, 1: [1 2 1]/4 vert lpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 no hlpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 [1 2 1]/4 hlpf
+//Bit 17:16        reg_polar3_f02lpf_mod1    // unsigned , default = 3  low pass filter mode for field 0 and field2 before polar3 detection; 0 for no lpf, 1: [1 2 1]/4 vert lpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 no hlpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 [1 2 1]/4 hlpf
+//Bit 15: 8        reg_polar3_dif02_thrd0    // unsigned , default = 5  threshold of dif for polar3 detection except for 32 detection, only do polar3 detection on obvious motion, [0] for luma, 1[1] for chroma
+//Bit  7: 0        reg_polar3_dif02_thrd1    // unsigned , default = 5  threshold of dif for polar3 detection except for 32 detection, only do polar3 detection on obvious motion, [0] for luma, 1[1] for chroma
+#define   NR2_POLAR3_THRD                          (0x2d99)
+#define P_NR2_POLAR3_THRD                          (volatile unsigned int *)((0x2d99  << 2) + 0xff900000)
+//Bit 31:24        reg_polar3_txtf02_thrd0   // unsigned , default = 30  threshold to vertical f0f2 texture, if texture larger than this threshold, will not do the polar3 decision.
+//Bit 23:16        reg_polar3_txtf02_thrd1   // unsigned , default = 30  threshold to vertical f0f2 texture, if texture larger than this threshold, will not do the polar3 decision.
+//Bit 15: 8        reg_polar3_txtf1_thrd0    // unsigned , default = 20  threshold to vertical f1 texture, if texture larger than this threshold, will not do the polar3 decision.
+//Bit  7: 0        reg_polar3_txtf1_thrd1    // unsigned , default = 20  threshold to vertical f1 texture, if texture larger than this threshold, will not do the polar3 decision.
+#define   NR2_POLAR3_PARA0                         (0x2d9a)
+#define P_NR2_POLAR3_PARA0                         (volatile unsigned int *)((0x2d9a  << 2) + 0xff900000)
+//Bit 31:28        reg_polar3_rate00         // unsigned , default = 6  delt = rate*dif02/32, e.g. f2<f0, if f1 within((f0+f2)/2 - delt), ((f0+f2)/2 + delt), then polar3_smoothmv++;
+//Bit 27:24        reg_polar3_rate01         // unsigned , default = 6  delt = rate*dif02/32, e.g. f2<f0, if f1 within((f0+f2)/2 - delt), ((f0+f2)/2 + delt), then polar3_smoothmv++;
+//Bit 23:20        reg_polar3_rate10         // unsigned , default = 8  delt = rate*dif02/32, e.g. f2-ofst1<f0, if f1<((f0+f2)/2 - delt), then polar3_m1++; if f1>((f0+f2)/2 + delt), then polar3_p1++;
+//Bit 19:16        reg_polar3_rate11         // unsigned , default = 8  delt = rate*dif02/32, e.g. f2-ofst1<f0, if f1<((f0+f2)/2 - delt), then polar3_m1++; if f1>((f0+f2)/2 + delt), then polar3_p1++;
+//Bit 15:12        reg_polar3_rate20         // unsigned , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
+//Bit 11: 8        reg_polar3_rate21         // unsigned , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
+//Bit  7: 1        reserved
+//Bit  0           reg_polar3_ro_reset       // unsigned , default = 0  reset signal of the polar3 read only registers
+#define   NR2_POLAR3_PARA1                         (0x2d9b)
+#define P_NR2_POLAR3_PARA1                         (volatile unsigned int *)((0x2d9b  << 2) + 0xff900000)
+//Bit 31:24        reg_polar3_rate30         // unsigned , default = 48  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset3) or f1>((f0 + delt+ofst3), then polar3_32++;
+//Bit 23:16        reg_polar3_rate31         // unsigned , default = 48  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset3) or f1>((f0 + delt+ofst3), then polar3_32++;
+//Bit 15:12        reg_polar3_ofst30         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt-ofst3) or f1>((f0 + delt+ofst3), then polar3_32++;
+//Bit 11: 8        reg_polar3_ofst31         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt-ofst3) or f1>((f0 + delt+ofst3), then polar3_32++;
+//Bit  7: 4        reg_polar3_ofst20         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
+//Bit  3: 0        reg_polar3_ofst21         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
+#define   NR2_POLAR3_CTRL                          (0x2d9c)
+#define P_NR2_POLAR3_CTRL                          (volatile unsigned int *)((0x2d9c  << 2) + 0xff900000)
+//Bit 31:24        reg_polar3_ofst10         // signed , default = 1
+//Bit 23:16        reg_polar3_ofst11         // signed , default = 1
+//Bit 15: 8        reg_polar3_h_mute         // unsigned , default = 10  horizontal pixels to mute for left right sides for polar3 detection;
+//Bit  7: 0        reg_polar3_v_mute         // unsigned , default = 10  vertical pixels to mute for top and bottom sides for polar3 detection;
+#define   NR2_RO_POLAR3_NUMOFPIX                   (0x2d9d)
+#define P_NR2_RO_POLAR3_NUMOFPIX                   (volatile unsigned int *)((0x2d9d  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_numofpix        // unsigned , default = 0  number of pixels detected as polar3
+#define   NR2_RO_POLAR3_SMOOTHMV                   (0x2d9e)
+#define P_NR2_RO_POLAR3_SMOOTHMV                   (volatile unsigned int *)((0x2d9e  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_smoothmv        // unsigned , default = 0  number of pixels with smooth mv, F(t) is close between avg of f(t-1) and f(t+1);
+#define   NR2_RO_POLAR3_M1                         (0x2d9f)
+#define P_NR2_RO_POLAR3_M1                         (volatile unsigned int *)((0x2d9f  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_m1              // unsigned , default = 0  number of pixels with F(t) is close to f(t-1) instead of f(t+1), but in between [f(t-1), f(t+1)];
+#define   NR2_RO_POLAR3_P1                         (0x2da0)
+#define P_NR2_RO_POLAR3_P1                         (volatile unsigned int *)((0x2da0  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_p1              // unsigned , default = 0  number of pixels with F(t) is close to f(t+1) instead of f(t-1), but in between [f(t-1), f(t+1)];
+#define   NR2_RO_POLAR3_M2                         (0x2da1)
+#define P_NR2_RO_POLAR3_M2                         (volatile unsigned int *)((0x2da1  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_m2              // unsigned , default = 0  number of pixels with F(t) is close to f(t-1) instead of f(t+1), but out side of (f(t-1), f(t+1));
+#define   NR2_RO_POLAR3_P2                         (0x2da2)
+#define P_NR2_RO_POLAR3_P2                         (volatile unsigned int *)((0x2da2  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_p2              // unsigned , default = 0  number of pixels with F(t) is close to f(t+1) instead of f(t-1), but out side of (f(t-1), f(t+1));
+#define   NR2_RO_POLAR3_32                         (0x2da3)
+#define P_NR2_RO_POLAR3_32                         (volatile unsigned int *)((0x2da3  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23: 0        ro_polar3_32              // unsigned , default = 0  number of pixels with F(t) far from [f(t-1),f(t+1)] and f(t-1) is close to f(t+1);
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr2_det_polar_regs.h
+//
+// 0xa4-0xf7 / 0xff
+//
+// Reading file:  nr4_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//========== nr4_drt_regs register begin ==========//
+#define   NR4_DRT_CTRL                             (0x2da4)
+#define P_NR4_DRT_CTRL                             (volatile unsigned int *)((0x2da4  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_ydrt_3line_ssd_gain    // unsigned , default = 16  gain to max ssd normalized 16 as '1'
+//Bit 23:16        reg_nr4_ydrt_5line_ssd_gain    // unsigned , default = 16  gain to max ssd normalized 16 as '1'
+//Bit 15            reserved
+//Bit 14:13        reg_nr4_drt_yhsad_mode         // unsigned , default = 1  mode for luma horiztonal sad calc., 0: no vertical lpf, 1: vertical [1 2 1], 2 or 3: vertical [ 1 2 2 2 1] if 5 lines
+//Bit 12:11        reg_nr4_drt_chsad_mode         // unsigned , default = 1  mode for chroma horiztonal sad calc., 0: no vertical lpf, 1: vertical [1 2 1], 2 or 3: vertical [ 1 2 2 2 1] if 5 lines
+//Bit 10           reg_nr4_drt_yhsad_hlpf         // unsigned , default = 1  hlpf for luma hsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
+//Bit  9           reg_nr4_drt_yvsad_hlpf         // unsigned , default = 1  hlpf for luma vsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
+//Bit  8           reg_nr4_drt_ydsad_hlpf         // unsigned , default = 1  hlpf for luma dsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
+//Bit  7           reg_nr4_drt_chsad_hlpf         // unsigned , default = 1  hlpf for chrome hsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
+//Bit  6           reg_nr4_drt_cvsad_hlpf         // unsigned , default = 1  hlpf for chroma vsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
+//Bit  5           reg_nr4_drt_cdsad_hlpf         // unsigned , default = 1  hlpf for chroma dsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
+//Bit  4           reg_nr4_ydrt_dif_mode          // unsigned , default = 1  0:y_dif, 1: y_dif + (u_dif + v_dif)/2
+//Bit  3: 2        reg_nr4_cdrt_dif_mode          // unsigned , default = 2  0:(u_dif + v_dif), 1: y_dif/4 + (u_dif + v_dif)*3/4, 2:y_dif/2 + (u_dif + v_dif)/2, 3: y_dif (not recommended)
+//Bit  1: 0        reserved
+#define   NR4_DRT_YSAD_GAIN                        (0x2da5)
+#define P_NR4_DRT_YSAD_GAIN                        (volatile unsigned int *)((0x2da5  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_ysad_hrz_gain           // unsigned , default = 16  gain for horizontal sad, 16 normalized to "1"
+//Bit 23:16        reg_nr4_ysad_diag_gain          // unsigned , default = 20  gain for diagonal sad, 16 normalized to "1"
+//Bit 15: 8        reg_nr4_ysad_vrt_gain           // unsigned , default = 16  gain for vertical sad, 16 normalized to "1"
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_drt_ysad_core_rate      // unsigned , default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
+#define   NR4_DRT_CSAD_GAIN                        (0x2da6)
+#define P_NR4_DRT_CSAD_GAIN                        (volatile unsigned int *)((0x2da6  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_csad_hrz_gain           // unsigned , default = 16  gain for horizontal sad, 16 normalized to "1"
+//Bit 23:16        reg_nr4_csad_diag_gain          // unsigned , default = 20  gain for diagonal sad, 16 normalized to "1"
+//Bit 15: 8        reg_nr4_csad_vrt_gain           // unsigned , default = 16  gain for vertical sad, 16 normalized to "1"
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_drt_csad_core_rate      // unsigned , default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
+#define   NR4_DRT_SAD_ALP_CORE                     (0x2da7)
+#define P_NR4_DRT_SAD_ALP_CORE                     (volatile unsigned int *)((0x2da7  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:20        reg_nr4_ydrt_alp_core_rate     // unsigned , default = 0  luma ratio to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 0/32
+//Bit 19:16        reg_nr4_cdrt_alp_core_rate     // unsigned , default = 0  chroma ratio to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 0/32
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_ydrt_alp_core_ofst     // unsigned , default = 10  luma offset to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 10
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_cdrt_alp_core_ofst     // unsigned , default = 10  chroma offset to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 10
+#define   NR4_DRT_ALP_MINMAX                       (0x2da8)
+#define P_NR4_DRT_ALP_MINMAX                       (volatile unsigned int *)((0x2da8  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_ydrt_alp_min           // unsigned , default = 0  luma min value of alpha, dft = 0
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_ydrt_alp_max           // unsigned , default = 63  luma max value of alpha, dft = 63
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_cdrt_alp_min           // unsigned , default = 0  chroma min value of alpha, dft = 0
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_cdrt_alp_max           // unsigned , default = 63  chroma max value of alpha, dft = 63
+//========== nr4_drt_regs register end ==========//
+//========== nr4_snr_regs register begin ==========//
+#define   NR4_SNR_CTRL_REG                         (0x2da9)
+#define P_NR4_SNR_CTRL_REG                         (volatile unsigned int *)((0x2da9  << 2) + 0xff900000)
+//Bit 31:13        reserved
+//Bit 12           reg_nr4_bet2_sel              // unsigned , default = 1
+//Bit 11: 9        reg_nr4_snr2_sel_mode         // unsigned , default = 0  0: no filter, 1: adpgau, adp_drt_lpf blend; 2: adpgau, drt4_lpf blend; 3: adp_drt_lpf method, 4: drt4_lpf method, 5: adp_drt_                                                             //original image blend, 6: drt4_lpf, original image blend, 7: adpgau method; dft=1
+//Bit  8           reg_nr4_snr2_gaulpf_mode      // unsigned , default = 1    0: 3*5 or 5*5 gaussian lpf;  1: 3*3 (window size) gaussian lpf;   dft=1
+//Bit  7: 6        reg_nr4_snr2_alpha0_sad_mode  // unsigned , default = 3  0: max_sad*max_ssd;  1: max_sad*max_sad; 2: adp_max_sad*max_ssd; 3: adp_max_sad*adp_max_sad  dft=3
+//Bit  5: 4        reg_nr4_snr2_alpha1_sad_mode  // unsigned , default = 2  0: max_sad;  1: cross_max_sad; 2 or 3: adp_sad  dft=2
+//Bit  3: 2        reserved
+//Bit  1: 0        reg_nr4_snr2_adp_drtlpf_mode  // unsigned , default = 3  0: adp_drtlpf [2 1 1]/4, 1: adp_drtlpf [4 2 1 1]/8; 2: adp_drtlpf [2 2 2 1 1]/8; 3: adp_drtlpf [7 7 7 6 5]/32;  dft=3;
+#define   NR4_SNR_ALPHA0_MAX_MIN                   (0x2daa)
+#define P_NR4_SNR_ALPHA0_MAX_MIN                   (volatile unsigned int *)((0x2daa  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:23        reg_nr4_snr2_alp0_ymin    // unsigned , default = 127  normalized to 128 as '1'
+//Bit 22:16        reg_nr4_snr2_alp0_ymax    // unsigned , default = 127  normalized to 128 as '1'
+//Bit 15:14        reserved
+//Bit 13: 7        reg_nr4_snr2_alp0_cmin    // unsigned , default = 127  normalized to 128 as '1'
+//Bit  6: 0        reg_nr4_snr2_alp0_cmax    // unsigned , default = 127  normalized to 128 as '1'
+#define   NR4_ALP0C_ERR2CURV_LIMIT0                (0x2dab)
+#define P_NR4_ALP0C_ERR2CURV_LIMIT0                (volatile unsigned int *)((0x2dab  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_snr2_alp0_minerr_cpar0  // unsigned , default = 0  threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.
+//Bit 23:16        reg_nr4_snr2_alp0_minerr_cpar1  // unsigned , default = 25  threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.
+//Bit 15: 8        reg_nr4_snr2_alp0_minerr_cpar5  // unsigned , default = 40  rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.
+//Bit  7: 0        reg_nr4_snr2_alp0_minerr_cpar6  // unsigned , default = 40  rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.
+#define   NR4_ALP0C_ERR2CURV_LIMIT1                (0x2dac)
+#define P_NR4_ALP0C_ERR2CURV_LIMIT1                (volatile unsigned int *)((0x2dac  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_snr2_alp0_minerr_cpar2  // unsigned , default = 127  level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, that we can do for flat region. 0~255.
+//Bit 15: 8        reg_nr4_snr2_alp0_minerr_cpar3  // unsigned , default = 0  level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, that we can do for misc region. 0~255.
+//Bit  7: 0        reg_nr4_snr2_alp0_minerr_cpar4  // unsigned , default = 127  level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel,   that we can do for texture region. 0~255.
+#define   NR4_ALP0Y_ERR2CURV_LIMIT0                (0x2dad)
+#define P_NR4_ALP0Y_ERR2CURV_LIMIT0                (volatile unsigned int *)((0x2dad  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_snr2_alp0_minerr_ypar0  // unsigned , default = 0  threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.
+//Bit 23:16        reg_nr4_snr2_alp0_minerr_ypar1  // unsigned , default = 25  threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.
+//Bit 15: 8        reg_nr4_snr2_alp0_minerr_ypar5  // unsigned , default = 40  rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.
+//Bit  7: 0        reg_nr4_snr2_alp0_minerr_ypar6  // unsigned , default = 40  rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.
+#define   NR4_ALP0Y_ERR2CURV_LIMIT1                (0x2dae)
+#define P_NR4_ALP0Y_ERR2CURV_LIMIT1                (volatile unsigned int *)((0x2dae  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_snr2_alp0_minerr_ypar2  // unsigned , default = 127  level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel,  set to alp0 that we can do for flat region. 0~255.
+//Bit 15: 8        reg_nr4_snr2_alp0_minerr_ypar3  // unsigned , default = 0  level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, alp0 that we can do for misc region. 0~255.
+//Bit  7: 0        reg_nr4_snr2_alp0_minerr_ypar4  // unsigned , default = 127  level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, alp0 that we can do for texture region. 0~255.
+#define   NR4_SNR_ALPA1_RATE_AND_OFST              (0x2daf)
+#define P_NR4_SNR_ALPA1_RATE_AND_OFST              (volatile unsigned int *)((0x2daf  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:18        reg_nr4_snr2_alp1_ycore_rate      // unsigned , default = 0    normalized 64 as "1"
+//Bit 17:12        reg_nr4_snr2_alp1_ccore_rate      // unsigned , default = 0    normalized 64 as "1"
+//Bit 11: 6        reg_nr4_snr2_alp1_ycore_ofst      // signed , default = 3    normalized 64 as "1"
+//Bit  5: 0        reg_nr4_snr2_alp1_ccore_ofst      // signed , default = 3    normalized 64 as "1"
+#define   NR4_SNR_ALPHA1_MAX_MIN                   (0x2db0)
+#define P_NR4_SNR_ALPHA1_MAX_MIN                   (volatile unsigned int *)((0x2db0  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:18        reg_nr4_snr2_alp1_ymin            // unsigned , default = 0    normalized to 64 as '1'
+//Bit 17:12        reg_nr4_snr2_alp1_ymax            // unsigned , default = 63   normalized to 64 as '1'
+//Bit 11: 6        reg_nr4_snr2_alp1_cmin            // unsigned , default = 0    normalized to 64 as '1'
+//Bit  5: 0        reg_nr4_snr2_alp1_cmax            // unsigned , default = 63   normalized to 64 as '1'
+#define   NR4_ALP1C_ERR2CURV_LIMIT0                (0x2db1)
+#define P_NR4_ALP1C_ERR2CURV_LIMIT0                (volatile unsigned int *)((0x2db1  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_snr2_alp1_minerr_cpar0  // unsigned , default = 0    annel, this will be set value of flat region mierr that no need directional NR. 0~255.
+//Bit 23:16        reg_nr4_snr2_alp1_minerr_cpar1  // unsigned , default = 24   hannel,this will be set value of texture region mierr that can not do directional NR. 0~255.
+//Bit 15: 8        reg_nr4_snr2_alp1_minerr_cpar5  // unsigned , default = 0    a/chroma  channel. the larger of the value, the deep of the slope.
+//Bit  7: 0        reg_nr4_snr2_alp1_minerr_cpar6  // unsigned , default = 20   a/chroma  channel. the larger of the value, the deep of the slope. 0~255
+#define   NR4_ALP1C_ERR2CURV_LIMIT1                (0x2db2)
+#define P_NR4_ALP1C_ERR2CURV_LIMIT1                (volatile unsigned int *)((0x2db2  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_snr2_alp1_minerr_cpar2  // unsigned , default = 0    will be set to alp1 that we can do for flat region. 0~255.
+//Bit 15: 8        reg_nr4_snr2_alp1_minerr_cpar3  // unsigned , default = 16   this will be set to alp1 that we can do for misc region. 0~255.
+//Bit  7: 0        reg_nr4_snr2_alp1_minerr_cpar4  // unsigned , default = 63   will be set to alp1 that we can do for texture region. 0~255.255 before
+#define   NR4_ALP1Y_ERR2CURV_LIMIT0                (0x2db3)
+#define P_NR4_ALP1Y_ERR2CURV_LIMIT0                (volatile unsigned int *)((0x2db3  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_snr2_alp1_minerr_ypar0  // unsigned , default = 0    thra/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.
+//Bit 23:16        reg_nr4_snr2_alp1_minerr_ypar1  // unsigned , default = 24   thra/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.
+//Bit 15: 8        reg_nr4_snr2_alp1_minerr_ypar5  // unsigned , default = 0    ratlp1 for luma/chroma  channel. the larger of the value, the deep of the slope.
+//Bit  7: 0        reg_nr4_snr2_alp1_minerr_ypar6  // unsigned , default = 20   ratlp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255
+#define   NR4_ALP1Y_ERR2CURV_LIMIT1                (0x2db4)
+#define P_NR4_ALP1Y_ERR2CURV_LIMIT1                (volatile unsigned int *)((0x2db4  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_snr2_alp1_minerr_ypar2  // unsigned , default = 0    lev to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.
+//Bit 15: 8        reg_nr4_snr2_alp1_minerr_ypar3  // unsigned , default = 16   levierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.
+//Bit  7: 0        reg_nr4_snr2_alp1_minerr_ypar4  // unsigned , default = 63   lev to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before
+//========== nr4_snr_regs register end ==========//
+//========== nr4_tnr_regs register begin ==========//
+#define   NR4_MTN_CTRL                             (0x2db5)
+#define P_NR4_MTN_CTRL                             (volatile unsigned int *)((0x2db5  << 2) + 0xff900000)
+//Bit 31: 2        reserved
+//Bit  1           reg_nr4_mtn_ref_en        // unsigned , default = 1  enable motion refinement, dft = 1
+//Bit  0           reg_nr4_mtn_ref_bet_sel   // unsigned , default = 0  beta selection mode for motion refinement, 0: beta1, 1: beta2, dft = 0
+#define   NR4_MTN_REF_PAR0                         (0x2db6)
+#define P_NR4_MTN_REF_PAR0                         (volatile unsigned int *)((0x2db6  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_mtn_ref_par0      // unsigned , default = 24  par0 for beta to gain, dft =
+//Bit 23:16        reg_nr4_mtn_ref_par1      // unsigned , default = 60  par1 for beta to gain, dft =
+//Bit 15: 8        reg_nr4_mtn_ref_par2      // unsigned , default = 4  par2 for beta to gain, dft =
+//Bit  7: 0        reg_nr4_mtn_ref_par3      // unsigned , default = 32  par3 for beta to gain, dft =
+#define   NR4_MTN_REF_PAR1                         (0x2db7)
+#define P_NR4_MTN_REF_PAR1                         (volatile unsigned int *)((0x2db7  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_mtn_ref_par4      // unsigned , default = 128  par4 for beta to gain, dft =
+//Bit 15: 8        reg_nr4_mtn_ref_par5      // unsigned , default = 40  par5 for beta to gain, dft =
+//Bit  7: 0        reg_nr4_mtn_ref_par6      // unsigned , default = 20  par6 for beta to gain, dft =
+//========== nr4_tnr_regs register end ==========//
+//========== nr4_mcnr_regs register begin ==========//
+#define   NR4_MCNR_LUMA_ENH_CTRL                   (0x2db8)
+#define P_NR4_MCNR_LUMA_ENH_CTRL                   (volatile unsigned int *)((0x2db8  << 2) + 0xff900000)
+//Bit 31: 4        reserved
+//Bit  3           reg_nr4_luma_plus_en           // unsigned , default = 1  enable luma enhancement, dft = 1
+//Bit  2           reg_nr4_luma_plus_wt_mode      // unsigned , default = 1  luma weight calc mode, 0:sqrt(1+x^2), 1: 1+abs(x), dft = 0
+//Bit  1: 0        reg_nr4_luma_plus_orient_mode  // unsigned , default = 1  0: only use previous orient for pre and cur luma plus, 1: 0: only use current orient for pre and cur luma plus
+#define   NR4_MCNR_LUMA_STAT_LIMTX                 (0x2db9)
+#define P_NR4_MCNR_LUMA_STAT_LIMTX                 (volatile unsigned int *)((0x2db9  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_nr4_luma_plus_xst        // unsigned , default = 8    start for luma plus statistic, dft = 8
+//Bit 15:14        reserved
+//Bit 13: 0        reg_nr4_luma_plus_xed        // unsigned , default = 711  end for luma plus statistic, dft = HSIZE-8-1;
+#define   NR4_MCNR_LUMA_STAT_LIMTY                 (0x2dba)
+#define P_NR4_MCNR_LUMA_STAT_LIMTY                 (volatile unsigned int *)((0x2dba  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_nr4_luma_plus_yst          // unsigned , default = 8  start for luma plus statistic, dft = 8
+//Bit 15:14        reserved
+//Bit 13: 0        reg_nr4_luma_plus_yed          // unsigned , default = 231  end for luma plus statistic, dft = VSIZE-8-1
+#define   NR4_MCNR_LUMA_DIF_CALC                   (0x2dbb)
+#define P_NR4_MCNR_LUMA_DIF_CALC                   (volatile unsigned int *)((0x2dbb  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_luma_plus_ugain        // unsigned , default = 8  U's gain for luma enhancement, 16 normalized as '1'
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_luma_plus_vgain        // unsigned , default = 8  V's gain for luma enhancement, 16 normalized as '1'
+//Bit 15: 8        reg_nr4_luma_plus_ycor_thd     // unsigned , default = 2  Y coring threshold for difference calc., dft = 0
+//Bit  7: 0        reg_nr4_luma_plus_ccor_thd     // unsigned , default = 0  C coring threshold for difference calc., dft = 0
+#define   NR4_MCNR_LUMAPRE_CAL_PRAM                (0x2dbc)
+#define P_NR4_MCNR_LUMAPRE_CAL_PRAM                (volatile unsigned int *)((0x2dbc  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:24        reg_nr4_pre_u_orient           // signed , default = 0  orientation of previous U, initial to 0, and will be updated by software
+//Bit 23:18        reserved
+//Bit 17:16        reg_nr4_pre_v_orient           // signed , default = 0  orientation of previous V, initial to 0, and will be updated by software
+//Bit 15: 8        reg_nr4_pre_u_mean             // unsigned , default = 0  mean of previous U, initial to 0, and will be updated by software
+//Bit  7: 0        reg_nr4_pre_v_mean             // unsigned , default = 0  mean of previousV, initial to 0, and will be updated by software
+#define   NR4_MCNR_LUMACUR_CAL_PRAM                (0x2dbd)
+#define P_NR4_MCNR_LUMACUR_CAL_PRAM                (volatile unsigned int *)((0x2dbd  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:24        reg_nr4_cur_u_orient           // signed , default = 0  orientation of current U, initial to 0, and will be updated by software
+//Bit 23:18        reserved
+//Bit 17:16        reg_nr4_cur_v_orient           // signed , default = 0  orientation of current V, initial to 0, and will be updated by software
+//Bit 15: 8        reg_nr4_cur_u_mean             // unsigned , default = 0  mean of current U, initial to 0, and will be updated by software
+//Bit  7: 0        reg_nr4_cur_v_mean             // unsigned , default = 0  mean of current, initial to 0, and will be updated by software
+#define   NR4_MCNR_MV_CTRL_REG                     (0x2dbe)
+#define P_NR4_MCNR_MV_CTRL_REG                     (volatile unsigned int *)((0x2dbe  << 2) + 0xff900000)
+//Bit 31:14        reserved
+//Bit 13:12        reg_nr4_sad_bitw          // unsigned , default = 2  sad bit width (8 + x) before clip to u8, dft = 1
+//Bit 11: 4        reg_nr4_glb_gain          // unsigned , default = 64  global gain calc. by software, 64 is normalized as '1'
+//Bit  3: 0        reg_nr4_mv_err_rsft       // unsigned , default = 8  right shift for mv err calc., dft = 9
+#define   NR4_MCNR_MV_GAIN0                        (0x2dbf)
+#define P_NR4_MCNR_MV_GAIN0                        (volatile unsigned int *)((0x2dbf  << 2) + 0xff900000)
+//Bit 31:28        reg_nr4_lftmvx_gain       // unsigned , default = 1  left mvx gain for err calc., dft = 1
+//Bit 27:24        reg_nr4_lftmvy_gain       // unsigned , default = 1  left mvy gain for err calc., dft = 1
+//Bit 23:20        reg_nr4_zmvx_gain         // unsigned , default = 5  zero mvx gain for err calc., dft = 2
+//Bit 19:16        reg_nr4_zmvy_gain         // unsigned , default = 5  zero mvy gain for err calc., dft = 4
+//Bit 15:12        reg_nr4_lmvx0_gain        // unsigned , default = 2  line mvx0 gain for err calc., dft = 1
+//Bit 11: 8        reg_nr4_lmvx1_gain        // unsigned , default = 2  line mvx1 gain for err calc., dft = 1
+//Bit  7: 4        reg_nr4_lmvy0_gain        // unsigned , default = 2  line mvy0 gain for err calc., dft = 1
+//Bit  3: 0        reg_nr4_lmvy1_gain        // unsigned , default = 2  line mvy1 gain for err calc., dft = 1
+#define   NR4_MCNR_LMV_PARM                        (0x2dc0)
+#define P_NR4_MCNR_LMV_PARM                        (volatile unsigned int *)((0x2dc0  << 2) + 0xff900000)
+//Bit 31:28        reg_nr4_lmv_rt0		         // unsigned , default = 3  ratio of max lmv
+//Bit 27:24        reg_nr4_lmv_rt1		         // unsigned , default = 3  ratio of second max lmv
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_lmv_num_lmt0	     // unsigned , default = 16  lmv0 least/limit number of (total number - zero_bin)
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_lmv_num_lmt1	     // unsigned , default = 8  lmv1 least/limit number of (total number - zero_bin - max0)
+//Bit  7: 2        reserved
+//Bit  1: 0        reg_nr4_max_sad_rng       // unsigned , default = 1  search range of max2 sad in small region, dft = 1
+#define   NR4_MCNR_ALP0_REG                        (0x2dc1)
+#define P_NR4_MCNR_ALP0_REG                        (volatile unsigned int *)((0x2dc1  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25           reg_nr4_alp0_fail_chk     // unsigned , default = 1  enable check for alp0 fail status
+//Bit 24           reg_nr4_bet0_coef_ref_en  // unsigned , default = 1  bet1 refinement by coef_blt
+//Bit 23:16        reg_nr4_alp0_posad_gain   // unsigned , default = 255  the sad (norm) gain for pixel pointed by MV;
+//Bit 15:10        reserved
+//Bit  9: 8        reg_nr4_alp0_norm_mode    // unsigned , default = 0  alp0 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_alp0_norm_gain    // unsigned , default = 16  alp0 gain for sad norm, '32' as '1', dft = 1
+#define   NR4_MCNR_ALP1_AND_BET0_REG               (0x2dc2)
+#define P_NR4_MCNR_ALP1_AND_BET0_REG               (volatile unsigned int *)((0x2dc2  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:24        reg_nr4_alp1_norm_mode    // unsigned , default = 3  alp1 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_alp1_norm_gain    // unsigned , default = 3  alp1 gain for sad norm, '32' as '1', dft = 1
+//Bit 15:10        reserved
+//Bit  9: 8        reg_nr4_bet0_norm_mode    // unsigned , default = 3  bet0 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bet0_norm_gain    // unsigned , default = 8  bet0 gain for sad norm, '32' as '1', dft = 1
+#define   NR4_MCNR_BET1_AND_BET2_REG               (0x2dc3)
+#define P_NR4_MCNR_BET1_AND_BET2_REG               (volatile unsigned int *)((0x2dc3  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:24        reg_nr4_bet1_norm_mode    // unsigned , default = 3  bet1 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_bet1_norm_gain    // unsigned , default = 8  bet1 gain for sad norm, '32' as '1', dft = 1
+//Bit 15:10        reserved
+//Bit  9: 8        reg_nr4_bet2_norm_mode    // unsigned , default = 0  bet2 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bet2_norm_gain    // unsigned , default = 16  bet2 gain for sad norm, '32' as '1', dft = 1
+#define   NR4_MCNR_AC_DC_CRTL                      (0x2dc4)
+#define P_NR4_MCNR_AC_DC_CRTL                      (volatile unsigned int *)((0x2dc4  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15:12        reserved
+//Bit 11           reg_nr4_dc_mode           // unsigned , default = 1  mode for dc selection,0: Y_lpf, 1: Y_lpf + (U_Lpf+V_lpf)/2,
+//Bit 10           reg_nr4_ac_mode           // unsigned , default = 1  mode for ac selection, 0: Y_abs_dif, 1: Y_abs_dif + (U_abs_dif + V_abs_dif)/2
+//Bit  9           reg_nr4_dc_sel            // unsigned , default = 0  selection mode for dc value, 0: 3x5, 1: 5x5, dft = 1
+//Bit  8           reg_nr4_ac_sel            // unsigned , default = 0  selection mode for ac value, 0: 3x5, 1: 5x5, dft = 1
+//Bit  7            reserved
+//Bit  6: 4        reg_nr4_dc_shft           // unsigned , default = 2  right shift for dc value, dft = 2
+//Bit  3            reserved
+//Bit  2: 0        reg_nr4_ac_shft           // unsigned , default = 0  right shift for ac value, dft = 2
+#define   NR4_MCNR_CM_CTRL0                        (0x2dc5)
+#define P_NR4_MCNR_CM_CTRL0                        (volatile unsigned int *)((0x2dc5  << 2) + 0xff900000)
+//Bit 31:29        reserved
+//Bit 28           reg_nr4_cm_skin_prc_bet0      // unsigned , default = 0  enable skin tone processing for mcnr bet0 calc., dft = 1
+//Bit 27:26        reg_nr4_cm_chrm_sel           // unsigned , default = 1  chrome selection for color match, 0: 1x1, 1: 3X3LPF, 2: 3x5LPF, 3: 5x5LPF for 5lines, 3x5LPF for 3lines, dft = 3
+//Bit 25:24        reg_nr4_cm_luma_sel           // unsigned , default = 1  luma selection for color match, 0: 1x1, 1: 3X3LPF, 2: 3x5LPF, 3: 5x5LPF for 5lines, 3x5LPF for 3lines, dft = 3
+//Bit 23:21        reg_nr4_cm_skin_rshft_bet0    // unsigned , default = 3  right shift for bet0's skin color gains, dft = 3
+//Bit 20           reg_nr4_cm_var_sel            // unsigned , default = 1  variation selection for color match, 0: 3x5, 1: 5x5 for 5lines, 3x5 for 3lines, dft = 1
+//Bit 19           reg_nr4_cm_green_prc_bet0     // unsigned , default = 1  enable green processing for mcnr bet0 calc., dft = 1
+//Bit 18:16        reg_nr4_cm_green_rshft_bet0   // unsigned , default = 4  right shift for bet0's green color gains, dft = 4
+//Bit 15:14        reg_nr4_preflt_mod            // unsigned , default = 2  pre filter mode in mcnr, 0: mv pointed pixel, 1: bilater filter
+//Bit 13:12        reg_nr4_alp1_mode             // unsigned , default = 1  mode for alpha1's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad
+//Bit 11:10        reserved
+//Bit  9: 8        reg_nr4_bet0_mode             // unsigned , default = 0  mode for bet0's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
+//Bit  7: 6        reserved
+//Bit  5: 4        reg_nr4_bet1_mode             // unsigned , default = 2  mode for bet1's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
+//Bit  3: 2        reserved
+//Bit  1: 0        reg_nr4_bet2_mode             // unsigned , default = 1  mode for bet2's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
+#define   NR4_MCNR_CM_PRAM                         (0x2dc6)
+#define P_NR4_MCNR_CM_PRAM                         (volatile unsigned int *)((0x2dc6  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29           reg_nr4_cm_blue_prc_alp0      // unsigned , default = 1  enable blue processing for mcnr alpha0 calc., dft = 1
+//Bit 28           reg_nr4_cm_blue_prc_alp1      // unsigned , default = 1  enable blue processing for mcnr alpha1 calc., dft = 1
+//Bit 27           reg_nr4_cm_skin_prc_alp0      // unsigned , default = 1  enable skin tone processing for mcnr alpha0 calc., dft = 1
+//Bit 26           reg_nr4_cm_green_prc_alp0     // unsigned , default = 1  enable green processing for mcnr alpha0 clac., dft = 1
+//Bit 25           reg_nr4_cm_skin_prc_alp1      // unsigned , default = 1  enable skin tone processing for mcnr alpha0 calc., dft = 1
+//Bit 24           reg_nr4_cm_green_prc_alp1     // unsigned , default = 1  enable green processing for mcnr alpha1 clac., dft = 1
+//Bit 23:20        reg_nr4_cm_blue_hue_st        // unsigned , default = 13  hue start of blue, dft =
+//Bit 19:16        reg_nr4_cm_blue_hue_ed        // unsigned , default = 15  hue end  of blue, dft =
+//Bit 15:12        reg_nr4_cm_green_hue_st       // unsigned , default = 7  hue start of green, dft =
+//Bit 11: 8        reg_nr4_cm_green_hue_ed       // unsigned , default = 10  hue end  of green, dft =
+//Bit  7: 4        reg_nr4_cm_skin_hue_st        // unsigned , default = 5  hue start of skin, dft =
+//Bit  3: 0        reg_nr4_cm_skin_hue_ed        // unsigned , default = 6  hue end  of skin, dft =
+#define   NR4_MCNR_CM_RSHFT_ALP0                   (0x2dc7)
+#define P_NR4_MCNR_CM_RSHFT_ALP0                   (volatile unsigned int *)((0x2dc7  << 2) + 0xff900000)
+//Bit 31:28        reserved
+//Bit 27:25        reg_nr4_cm_blue_rshft_bet0    // unsigned , default = 5  right shift for bet0's blue color gains, dft = 5
+//Bit 24           reg_nr4_cm_blue_prc_bet0      // unsigned , default = 1  enable blue processing for mcnr bet0 calc., dft = 1
+//Bit 23            reserved
+//Bit 22:20        reg_nr4_cm_blue_rshft_alp0    // unsigned , default = 5  right shift for alpha0/1's blue color gains, dft = 5
+//Bit 19            reserved
+//Bit 18:16        reg_nr4_cm_blue_rshft_alp1    // unsigned , default = 5  right shift for alpha0/1's blue color gains, dft = 5
+//Bit 15            reserved
+//Bit 14:12        reg_nr4_cm_green_rshft_alp0   // unsigned , default = 4  right shift for alpha0/1's green color gains, dft = 4
+//Bit 11            reserved
+//Bit 10: 8        reg_nr4_cm_green_rshft_alp1   // unsigned , default = 4  right shift for alpha0/1's green color gains, dft = 4
+//Bit  7            reserved
+//Bit  6: 4        reg_nr4_cm_skin_rshft_alp0    // unsigned , default = 3  right shift for alpha0/1's skin color gains, dft = 3
+//Bit  3            reserved
+//Bit  2: 0        reg_nr4_cm_skin_rshft_alp1    // unsigned , default = 3  right shift for alpha0/1's skin color gains, dft = 3
+#define   NR4_MCNR_BLUE_CENT                       (0x2dc8)
+#define P_NR4_MCNR_BLUE_CENT                       (volatile unsigned int *)((0x2dc8  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_blue_centx         // unsigned , default = 157  x coordinate of center of blue, dft =
+//Bit 15: 8        reserved
+//Bit  7: 0        reg_nr4_cm_blue_centy         // unsigned , default = 110  y coordinate of center of blue, dft =
+#define   NR4_MCNR_BLUE_GAIN_PAR0                  (0x2dc9)
+#define P_NR4_MCNR_BLUE_GAIN_PAR0                  (volatile unsigned int *)((0x2dc9  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_cm_blue_gain_par0   // unsigned , default = 32  par0 for blue gain, dft =
+//Bit 23:16        reg_nr4_cm_blue_gain_par1   // unsigned , default = 255  par1 for blue gain, dft =
+//Bit 15: 8        reg_nr4_cm_blue_gain_par2   // unsigned , default = 4  par2 for blue gain, dft =
+//Bit  7: 0        reg_nr4_cm_blue_gain_par3   // unsigned , default = 32  par3 for blue gain, dft =
+#define   NR4_MCNR_BLUE_GAIN_PAR1                  (0x2dca)
+#define P_NR4_MCNR_BLUE_GAIN_PAR1                  (volatile unsigned int *)((0x2dca  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_blue_gain_par4   // unsigned , default = 32  par4 for blue gain, dft =
+//Bit 15: 8        reg_nr4_cm_blue_gain_par5   // unsigned , default = 32  par5 for blue gain, dft =
+//Bit  7: 0        reg_nr4_cm_blue_gain_par6   // unsigned , default = 0  par6 for blue gain, dft =
+#define   NR4_MCNR_CM_BLUE_CLIP0                   (0x2dcb)
+#define P_NR4_MCNR_CM_BLUE_CLIP0                   (volatile unsigned int *)((0x2dcb  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_blue_luma_min      // unsigned , default = 40  luma min for blue color matching, dft =
+//Bit 15: 8        reserved
+//Bit  7: 0        reg_nr4_cm_blue_luma_max      // unsigned , default = 180  luma max for blue color matching, dft =
+#define   NR4_MCNR_CM_BLUE_CLIP1                   (0x2dcc)
+#define P_NR4_MCNR_CM_BLUE_CLIP1                   (volatile unsigned int *)((0x2dcc  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_cm_blue_sat_min       // unsigned , default = 5  saturation min for blue color matching, dft =
+//Bit 23:16        reg_nr4_cm_blue_sat_max       // unsigned , default = 255  saturation max for blue color matching, dft =
+//Bit 15: 8        reg_nr4_cm_blue_var_min       // unsigned , default = 0  variation min for blue color matching, dft =
+//Bit  7: 0        reg_nr4_cm_blue_var_max       // unsigned , default = 12  variation max for blue color matching, dft =
+#define   NR4_MCNR_GREEN_CENT                      (0x2dcd)
+#define P_NR4_MCNR_GREEN_CENT                      (volatile unsigned int *)((0x2dcd  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_green_centx         // unsigned , default = 114  x coordinate of center of green, dft =
+//Bit 15: 8        reserved
+//Bit  7: 0        reg_nr4_cm_green_centy         // unsigned , default = 126  y coordinate of center of green, dft =
+#define   NR4_MCNR_GREEN_GAIN_PAR0                 (0x2dce)
+#define P_NR4_MCNR_GREEN_GAIN_PAR0                 (volatile unsigned int *)((0x2dce  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_cm_green_gain_par0   // unsigned , default = 16  par0 for green gain, dft =
+//Bit 23:16        reg_nr4_cm_green_gain_par1   // unsigned , default = 255  par1 for green gain, dft =
+//Bit 15: 8        reg_nr4_cm_green_gain_par2   // unsigned , default = 255  par2 for green gain, dft =
+//Bit  7: 0        reg_nr4_cm_green_gain_par3   // unsigned , default = 16  par3 for green gain, dft =
+#define   NR4_MCNR_GREEN_GAIN_PAR1                 (0x2dcf)
+#define P_NR4_MCNR_GREEN_GAIN_PAR1                 (volatile unsigned int *)((0x2dcf  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_green_gain_par4   // unsigned , default = 16  par4 for green gain, dft =
+//Bit 15: 8        reg_nr4_cm_green_gain_par5   // unsigned , default = 128  par5 for green gain, dft =
+//Bit  7: 0        reg_nr4_cm_green_gain_par6   // unsigned , default = 0  par6 for green gain, dft =
+#define   NR4_MCNR_GREEN_CLIP0                     (0x2dd0)
+#define P_NR4_MCNR_GREEN_CLIP0                     (volatile unsigned int *)((0x2dd0  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_green_luma_min      // unsigned , default = 40  luma min for green color matching, dft =
+//Bit 15: 8        reserved
+//Bit  7: 0        reg_nr4_cm_green_luma_max      // unsigned , default = 160  luma max for green color matching, dft =
+#define   NR4_MCNR_GREEN_CLIP2                     (0x2dd1)
+#define P_NR4_MCNR_GREEN_CLIP2                     (volatile unsigned int *)((0x2dd1  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_cm_green_sat_min       // unsigned , default = 4  saturation min for green color matching, dft =
+//Bit 23:16        reg_nr4_cm_green_sat_max       // unsigned , default = 255  saturation max for green color matching, dft =
+//Bit 15: 8        reg_nr4_cm_green_var_min       // unsigned , default = 0  variation min for green color matching, dft =
+//Bit  7: 0        reg_nr4_cm_green_var_max       // unsigned , default = 12  variation max for green color matching, dft =
+#define   NR4_MCNR_SKIN_CENT                       (0x2dd2)
+#define P_NR4_MCNR_SKIN_CENT                       (volatile unsigned int *)((0x2dd2  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_skin_centx         // unsigned , default = 112  x coordinate of center of skin tone, dft =
+//Bit 15: 8        reserved
+//Bit  7: 0        reg_nr4_cm_skin_centy         // unsigned , default = 149  y coordinate of center of skin tone, dft =
+#define   NR4_MCNR_SKIN_GAIN_PAR0                  (0x2dd3)
+#define P_NR4_MCNR_SKIN_GAIN_PAR0                  (volatile unsigned int *)((0x2dd3  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_cm_skin_gain_par0   // unsigned , default = 20  par0 for skin gain, dft =
+//Bit 23:16        reg_nr4_cm_skin_gain_par1   // unsigned , default = 255  par1 for skin gain, dft =
+//Bit 15: 8        reg_nr4_cm_skin_gain_par2   // unsigned , default = 255  par2 for skin gain, dft =
+//Bit  7: 0        reg_nr4_cm_skin_gain_par3   // unsigned , default = 8  par3 for skin gain, dft =
+#define   NR4_MCNR_SKIN_GAIN_PAR1                  (0x2dd4)
+#define P_NR4_MCNR_SKIN_GAIN_PAR1                  (volatile unsigned int *)((0x2dd4  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_skin_gain_par4   // unsigned , default = 8  par4 for skin gain, dft =
+//Bit 15: 8        reg_nr4_cm_skin_gain_par5   // unsigned , default = 128  par5 for skin gain, dft =
+//Bit  7: 0        reg_nr4_cm_skin_gain_par6   // unsigned , default = 0  par6 for skin gain, dft =
+#define   NR4_MCNR_SKIN_CLIP0                      (0x2dd5)
+#define P_NR4_MCNR_SKIN_CLIP0                      (volatile unsigned int *)((0x2dd5  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_cm_skin_luma_min      // unsigned , default = 40  luma min for skin color matching, dft =
+//Bit 15: 8        reserved
+//Bit  7: 0        reg_nr4_cm_skin_luma_max      // unsigned , default = 180  luma max for skin color matching, dft =
+#define   NR4_MCNR_SKIN_CLIP1                      (0x2dd6)
+#define P_NR4_MCNR_SKIN_CLIP1                      (volatile unsigned int *)((0x2dd6  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_cm_skin_sat_min       // unsigned , default = 5  saturation min for skin color matching, dft =
+//Bit 23:16        reg_nr4_cm_skin_sat_max       // unsigned , default = 255  saturation max for skin color matching, dft =
+//Bit 15: 8        reg_nr4_cm_skin_var_min       // unsigned , default = 0  variation min for skin color matching, dft =
+//Bit  7: 0        reg_nr4_cm_skin_var_max       // unsigned , default = 12  variation max for skin color matching, dft =
+#define   NR4_MCNR_ALP1_GLB_CTRL                   (0x2dd7)
+#define P_NR4_MCNR_ALP1_GLB_CTRL                   (volatile unsigned int *)((0x2dd7  << 2) + 0xff900000)
+//Bit 31           reg_nr4_alp1_glb_gain_en     // unsigned , default = 0  alp1 adjust by global gain, dft = 1
+//Bit 30:28        reg_nr4_alp1_glb_gain_lsft   // unsigned , default = 6  alp1 left shift before combine with global gain
+//Bit 27           reg_nr4_bet0_glb_gain_en     // unsigned , default = 1  bet0 adjust by global gain, dft = 1
+//Bit 26:24        reg_nr4_bet0_glb_gain_lsft   // unsigned , default = 6  bet1 left shift before combine with global gain
+//Bit 23           reg_nr4_bet1_glb_gain_en     // unsigned , default = 0  bet1 adjust by global gain, dft = 0
+//Bit 22:20        reg_nr4_bet1_glb_gain_lsft   // unsigned , default = 6  bet1 left shift before combine with global gain
+//Bit 19           reg_nr4_bet2_glb_gain_en     // unsigned , default = 1  bet2 adjust by global gain, dft = 1
+//Bit 18:16        reg_nr4_bet2_glb_gain_lsft   // unsigned , default = 6  bet2 left shift before combine with global gain
+//Bit 15           reg_nr4_alp1_ac_en           // unsigned , default = 1  alp1 adjust by ac, dft = 1
+//Bit 14:12        reg_nr4_alp1_ac_lsft         // unsigned , default = 5  alp1 left shift before combine with ac
+//Bit 11           reg_nr4_bet0_ac_en           // unsigned , default = 0  bet0 adjust by ac, dft = 1
+//Bit 10: 8        reg_nr4_bet0_ac_lsft         // unsigned , default = 5  bet0 left shift before combine with ac
+//Bit  7           reg_nr4_bet1_ac_en           // unsigned , default = 0  bet1 adjust by ac, dft = 1
+//Bit  6: 4        reg_nr4_bet1_ac_lsft         // unsigned , default = 5  bet1 left shift before combine with ac
+//Bit  3           reg_nr4_bet2_ac_en           // unsigned , default = 0  bet2 adjust by ac, dft = 1
+//Bit  2: 0        reg_nr4_bet2_ac_lsft         // unsigned , default = 5  bet2 left shift before combine with ac
+#define   NR4_MCNR_DC2NORM_LUT0                    (0x2dd8)
+#define P_NR4_MCNR_DC2NORM_LUT0                    (volatile unsigned int *)((0x2dd8  << 2) + 0xff900000)
+//Bit 31:29        reserved
+//Bit 28:24        reg_nr4_dc2norm_lut0         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+//Bit 23:21        reserved
+//Bit 20:16        reg_nr4_dc2norm_lut1         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+//Bit 15:13        reserved
+//Bit 12: 8        reg_nr4_dc2norm_lut2         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+//Bit  7: 5        reserved
+//Bit  4: 0        reg_nr4_dc2norm_lut3         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+#define   NR4_MCNR_DC2NORM_LUT1                    (0x2dd9)
+#define P_NR4_MCNR_DC2NORM_LUT1                    (volatile unsigned int *)((0x2dd9  << 2) + 0xff900000)
+//Bit 31:29        reserved
+//Bit 28:24        reg_nr4_dc2norm_lut4         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+//Bit 23:21        reserved
+//Bit 20:16        reg_nr4_dc2norm_lut5         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+//Bit 15:13        reserved
+//Bit 12: 8        reg_nr4_dc2norm_lut6         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
+//Bit  7: 5        reserved
+//Bit  4: 0        reg_nr4_dc2norm_lut7         // unsigned , default = 12  normal 0~16, dc to norm for alpha adjust, dft =
+#define   NR4_MCNR_DC2NORM_LUT2                    (0x2dda)
+#define P_NR4_MCNR_DC2NORM_LUT2                    (volatile unsigned int *)((0x2dda  << 2) + 0xff900000)
+//Bit 31: 5        reserved
+//Bit  4: 0        reg_nr4_dc2norm_lut8        // unsigned , default = 8   normal 0~16, dc to norm for alpha adjust, dft =
+#define   NR4_MCNR_AC2NORM_LUT0                    (0x2ddb)
+#define P_NR4_MCNR_AC2NORM_LUT0                    (volatile unsigned int *)((0x2ddb  << 2) + 0xff900000)
+//Bit 31:29        reserved
+//Bit 28:24        reg_nr4_ac2norm_lut0         // unsigned , default = 2  normal 0~16, ac to norm for alpha adjust, dft =
+//Bit 23:21        reserved
+//Bit 20:16        reg_nr4_ac2norm_lut1         // unsigned , default = 16  normal 0~16, ac to norm for alpha adjust, dft =
+//Bit 15:13        reserved
+//Bit 12: 8        reg_nr4_ac2norm_lut2         // unsigned , default = 16  normal 0~16, ac to norm for alpha adjust, dft =
+//Bit  7: 5        reserved
+//Bit  4: 0        reg_nr4_ac2norm_lut3         // unsigned , default = 12  normal 0~16, ac to norm for alpha adjust, dft =
+#define   NR4_MCNR_AC2NORM_LUT1                    (0x2ddc)
+#define P_NR4_MCNR_AC2NORM_LUT1                    (volatile unsigned int *)((0x2ddc  << 2) + 0xff900000)
+//Bit 31:29        reserved
+//Bit 28:24        reg_nr4_ac2norm_lut4         // unsigned , default = 4  normal 0~16, ac to norm for alpha adjust, dft =
+//Bit 23:21        reserved
+//Bit 20:16        reg_nr4_ac2norm_lut5         // unsigned , default = 2  normal 0~16, ac to norm for alpha adjust, dft =
+//Bit 15:13        reserved
+//Bit 12: 8        reg_nr4_ac2norm_lut6         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
+//Bit  7: 5        reserved
+//Bit  4: 0        reg_nr4_ac2norm_lut7         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
+#define   NR4_MCNR_AC2NORM_LUT2                    (0x2ddd)
+#define P_NR4_MCNR_AC2NORM_LUT2                    (volatile unsigned int *)((0x2ddd  << 2) + 0xff900000)
+//Bit 31: 5        reserved
+//Bit  4: 0        reg_nr4_ac2norm_lut8         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
+#define   NR4_MCNR_SAD2ALP0_LUT0                   (0x2dde)
+#define P_NR4_MCNR_SAD2ALP0_LUT0                   (volatile unsigned int *)((0x2dde  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp0_lut0        // unsigned , default = 255  sad to alpha0 for temporal pixel value, dft = 255
+//Bit 23:16        reg_nr4_sad2alp0_lut1        // unsigned , default = 252  sad to alpha0 for temporal pixel value, dft = 252
+//Bit 15: 8        reg_nr4_sad2alp0_lut2        // unsigned , default = 249  sad to alpha0 for temporal pixel value, dft = 249
+//Bit  7: 0        reg_nr4_sad2alp0_lut3        // unsigned , default = 235  sad to alpha0 for temporal pixel value, dft = 70
+#define   NR4_MCNR_SAD2ALP0_LUT1                   (0x2ddf)
+#define P_NR4_MCNR_SAD2ALP0_LUT1                   (volatile unsigned int *)((0x2ddf  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp0_lut4        // unsigned , default = 185  sad to alpha0 for temporal pixel value, dft = 12
+//Bit 23:16        reg_nr4_sad2alp0_lut5        // unsigned , default = 70  sad to alpha0 for temporal pixel value, dft = 1
+//Bit 15: 8        reg_nr4_sad2alp0_lut6        // unsigned , default = 14  sad to alpha0 for temporal pixel value, dft = 0
+//Bit  7: 0        reg_nr4_sad2alp0_lut7        // unsigned , default = 1  sad to alpha0 for temporal pixel value, dft = 0
+#define   NR4_MCNR_SAD2ALP0_LUT2                   (0x2de0)
+#define P_NR4_MCNR_SAD2ALP0_LUT2                   (volatile unsigned int *)((0x2de0  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp0_lut8        // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+//Bit 23:16        reg_nr4_sad2alp0_lut9        // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+//Bit 15: 8        reg_nr4_sad2alp0_lut10       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+//Bit  7: 0        reg_nr4_sad2alp0_lut11       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+#define   NR4_MCNR_SAD2ALP0_LUT3                   (0x2de1)
+#define P_NR4_MCNR_SAD2ALP0_LUT3                   (volatile unsigned int *)((0x2de1  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp0_lut12       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+//Bit 23:16        reg_nr4_sad2alp0_lut13       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+//Bit 15: 8        reg_nr4_sad2alp0_lut14       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+//Bit  7: 0        reg_nr4_sad2alp0_lut15       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
+#define   NR4_MCNR_SAD2ALP1_LUT0                   (0x2de2)
+#define P_NR4_MCNR_SAD2ALP1_LUT0                   (volatile unsigned int *)((0x2de2  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp1_lut0        // unsigned , default = 192  sad to alpha1 for temporal blending, dft = 128
+//Bit 23:16        reg_nr4_sad2alp1_lut1        // unsigned , default = 160  sad to alpha1 for temporal blending, dft = 128
+//Bit 15: 8        reg_nr4_sad2alp1_lut2        // unsigned , default = 128  sad to alpha1 for temporal blending, dft = 128
+//Bit  7: 0        reg_nr4_sad2alp1_lut3        // unsigned , default = 96  sad to alpha1 for temporal blending, dft = 64
+#define   NR4_MCNR_SAD2ALP1_LUT1                   (0x2de3)
+#define P_NR4_MCNR_SAD2ALP1_LUT1                   (volatile unsigned int *)((0x2de3  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp1_lut4        // unsigned , default = 64  sad to alpha1 for temporal blending, dft = 64
+//Bit 23:16        reg_nr4_sad2alp1_lut5        // unsigned , default = 32  sad to alpha1 for temporal blending, dft = 128
+//Bit 15: 8        reg_nr4_sad2alp1_lut6        // unsigned , default = 16  sad to alpha1 for temporal blending, dft = 255
+//Bit  7: 0        reg_nr4_sad2alp1_lut7        // unsigned , default = 8  sad to alpha1 for temporal blending, dft = 255
+#define   NR4_MCNR_SAD2ALP1_LUT2                   (0x2de4)
+#define P_NR4_MCNR_SAD2ALP1_LUT2                   (volatile unsigned int *)((0x2de4  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp1_lut8        // unsigned , default = 4  sad to alpha1 for temporal blending, dft = 255
+//Bit 23:16        reg_nr4_sad2alp1_lut9        // unsigned , default = 0  sad to alpha1 for temporal blending, dft = 255
+//Bit 15: 8        reg_nr4_sad2alp1_lut10       // unsigned , default = 16  sad to alpha1 for temporal blending, dft = 255
+//Bit  7: 0        reg_nr4_sad2alp1_lut11       // unsigned , default = 64  sad to alpha1 for temporal blending, dft = 255
+#define   NR4_MCNR_SAD2ALP1_LUT3                   (0x2de5)
+#define P_NR4_MCNR_SAD2ALP1_LUT3                   (volatile unsigned int *)((0x2de5  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2alp1_lut12       // unsigned , default = 96  sad to alpha1 for temporal blending, dft = 255
+//Bit 23:16        reg_nr4_sad2alp1_lut13       // unsigned , default = 224  sad to alpha1 for temporal blending, dft = 255
+//Bit 15: 8        reg_nr4_sad2alp1_lut14       // unsigned , default = 255  sad to alpha1 for temporal blending, dft = 255
+//Bit  7: 0        reg_nr4_sad2alp1_lut15       // unsigned , default = 255  sad to alpha1 for temporal blending, dft = 255
+#define   NR4_MCNR_SAD2BET0_LUT0                   (0x2de6)
+#define P_NR4_MCNR_SAD2BET0_LUT0                   (volatile unsigned int *)((0x2de6  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet0_lut0        // unsigned , default = 0  sad to beta0 for tnr and mcnr blending, dft = 0
+//Bit 23:16        reg_nr4_sad2bet0_lut1        // unsigned , default = 2  sad to beta0 for tnr and mcnr blending, dft = 2
+//Bit 15: 8        reg_nr4_sad2bet0_lut2        // unsigned , default = 4  sad to beta0 for tnr and mcnr blending, dft = 4
+//Bit  7: 0        reg_nr4_sad2bet0_lut3        // unsigned , default = 8  sad to beta0 for tnr and mcnr blending, dft = 8
+#define   NR4_MCNR_SAD2BET0_LUT1                   (0x2de7)
+#define P_NR4_MCNR_SAD2BET0_LUT1                   (volatile unsigned int *)((0x2de7  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet0_lut4        // unsigned , default = 16  sad to beta0 for tnr and mcnr blending, dft = 16
+//Bit 23:16        reg_nr4_sad2bet0_lut5        // unsigned , default = 32  sad to beta0 for tnr and mcnr blending, dft = 32
+//Bit 15: 8        reg_nr4_sad2bet0_lut6        // unsigned , default = 48  sad to beta0 for tnr and mcnr blending, dft = 48
+//Bit  7: 0        reg_nr4_sad2bet0_lut7        // unsigned , default = 64  sad to beta0 for tnr and mcnr blending, dft = 64
+#define   NR4_MCNR_SAD2BET0_LUT2                   (0x2de8)
+#define P_NR4_MCNR_SAD2BET0_LUT2                   (volatile unsigned int *)((0x2de8  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet0_lut8        // unsigned , default = 80  sad to beta0 for tnr and mcnr blending, dft = 80
+//Bit 23:16        reg_nr4_sad2bet0_lut9        // unsigned , default = 96  sad to beta0 for tnr and mcnr blending, dft = 96
+//Bit 15: 8        reg_nr4_sad2bet0_lut10       // unsigned , default = 112  sad to beta0 for tnr and mcnr blending, dft = 112
+//Bit  7: 0        reg_nr4_sad2bet0_lut11       // unsigned , default = 128  sad to beta0 for tnr and mcnr blending, dft = 128
+#define   NR4_MCNR_SAD2BET0_LUT3                   (0x2de9)
+#define P_NR4_MCNR_SAD2BET0_LUT3                   (volatile unsigned int *)((0x2de9  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet0_lut12       // unsigned , default = 196  sad to beta0 for tnr and mcnr blending, dft = 160
+//Bit 23:16        reg_nr4_sad2bet0_lut13       // unsigned , default = 224  sad to beta0 for tnr and mcnr blending, dft = 192
+//Bit 15: 8        reg_nr4_sad2bet0_lut14       // unsigned , default = 255  sad to beta0 for tnr and mcnr blending, dft = 224
+//Bit  7: 0        reg_nr4_sad2bet0_lut15       // unsigned , default = 255  sad to beta0 for tnr and mcnr blending, dft = 255
+#define   NR4_MCNR_SAD2BET1_LUT0                   (0x2dea)
+#define P_NR4_MCNR_SAD2BET1_LUT0                   (volatile unsigned int *)((0x2dea  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet1_lut0        // unsigned , default = 0  sad to beta1 for deghost blending, dft = 0
+//Bit 23:16        reg_nr4_sad2bet1_lut1        // unsigned , default = 2  sad to beta1 for deghost blending, dft = 2
+//Bit 15: 8        reg_nr4_sad2bet1_lut2        // unsigned , default = 4  sad to beta1 for deghost blending, dft = 4
+//Bit  7: 0        reg_nr4_sad2bet1_lut3        // unsigned , default = 8  sad to beta1 for deghost blending, dft = 8
+#define   NR4_MCNR_SAD2BET1_LUT1                   (0x2deb)
+#define P_NR4_MCNR_SAD2BET1_LUT1                   (volatile unsigned int *)((0x2deb  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet1_lut4        // unsigned , default = 16  sad to beta1 for deghost blending, dft = 16
+//Bit 23:16        reg_nr4_sad2bet1_lut5        // unsigned , default = 32  sad to beta1 for deghost blending, dft = 32
+//Bit 15: 8        reg_nr4_sad2bet1_lut6        // unsigned , default = 48  sad to beta1 for deghost blending, dft = 48
+//Bit  7: 0        reg_nr4_sad2bet1_lut7        // unsigned , default = 64  sad to beta1 for deghost blending, dft = 64
+#define   NR4_MCNR_SAD2BET1_LUT2                   (0x2dec)
+#define P_NR4_MCNR_SAD2BET1_LUT2                   (volatile unsigned int *)((0x2dec  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet1_lut8        // unsigned , default = 80  sad to beta1 for deghost blending, dft = 80
+//Bit 23:16        reg_nr4_sad2bet1_lut9        // unsigned , default = 96  sad to beta1 for deghost blending, dft = 96
+//Bit 15: 8        reg_nr4_sad2bet1_lut10       // unsigned , default = 112  sad to beta1 for deghost blending, dft = 112
+//Bit  7: 0        reg_nr4_sad2bet1_lut11       // unsigned , default = 128  sad to beta1 for deghost blending, dft = 128
+#define   NR4_MCNR_SAD2BET1_LUT3                   (0x2ded)
+#define P_NR4_MCNR_SAD2BET1_LUT3                   (volatile unsigned int *)((0x2ded  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet1_lut12       // unsigned , default = 160  sad to beta1 for deghost blending, dft = 160
+//Bit 23:16        reg_nr4_sad2bet1_lut13       // unsigned , default = 192  sad to beta1 for deghost blending, dft = 192
+//Bit 15: 8        reg_nr4_sad2bet1_lut14       // unsigned , default = 224  sad to beta1 for deghost blending, dft = 224
+//Bit  7: 0        reg_nr4_sad2bet1_lut15       // unsigned , default = 255  sad to beta1 for deghost blending, dft = 255
+#define   NR4_MCNR_SAD2BET2_LUT0                   (0x2dee)
+#define P_NR4_MCNR_SAD2BET2_LUT0                   (volatile unsigned int *)((0x2dee  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet2_lut0        // unsigned , default = 0  sad to beta2 for snr and mcnr blending, dft = 0
+//Bit 23:16        reg_nr4_sad2bet2_lut1        // unsigned , default = 1  sad to beta2 for snr and mcnr blending, dft = 2
+//Bit 15: 8        reg_nr4_sad2bet2_lut2        // unsigned , default = 2  sad to beta2 for snr and mcnr blending, dft  = 4
+//Bit  7: 0        reg_nr4_sad2bet2_lut3        // unsigned , default = 4  sad to beta2 for snr and mcnr blending, dft = 8
+#define   NR4_MCNR_SAD2BET2_LUT1                   (0x2def)
+#define P_NR4_MCNR_SAD2BET2_LUT1                   (volatile unsigned int *)((0x2def  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet2_lut4        // unsigned , default = 8  sad to beta2 for snr and mcnr blending, dft = 16
+//Bit 23:16        reg_nr4_sad2bet2_lut5        // unsigned , default = 16  sad to beta2 for snr and mcnr blending, dft = 32
+//Bit 15: 8        reg_nr4_sad2bet2_lut6        // unsigned , default = 32  sad to beta2 for snr and mcnr blending, dft = 48
+//Bit  7: 0        reg_nr4_sad2bet2_lut7        // unsigned , default = 48  sad to beta2 for snr and mcnr blending, dft = 64
+#define   NR4_MCNR_SAD2BET2_LUT2                   (0x2df0)
+#define P_NR4_MCNR_SAD2BET2_LUT2                   (volatile unsigned int *)((0x2df0  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet2_lut8        // unsigned , default = 64  sad to beta2 for snr and mcnr blending, dft = 80
+//Bit 23:16        reg_nr4_sad2bet2_lut9        // unsigned , default = 80  sad to beta2 for snr and mcnr blending, dft = 96
+//Bit 15: 8        reg_nr4_sad2bet2_lut10       // unsigned , default = 96  sad to beta2 for snr and mcnr blending, dft = 112
+//Bit  7: 0        reg_nr4_sad2bet2_lut11       // unsigned , default = 112  sad to beta2 for snr and mcnr blending, dft = 128
+#define   NR4_MCNR_SAD2BET2_LUT3                   (0x2df1)
+#define P_NR4_MCNR_SAD2BET2_LUT3                   (volatile unsigned int *)((0x2df1  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_sad2bet2_lut12       // unsigned , default = 128  sad to beta2 for snr and mcnr blending, dft = 160
+//Bit 23:16        reg_nr4_sad2bet2_lut13       // unsigned , default = 160  sad to beta2 for snr and mcnr blending, dft = 192
+//Bit 15: 8        reg_nr4_sad2bet2_lut14       // unsigned , default = 224  sad to beta2 for snr and mcnr blending, dft = 224
+//Bit  7: 0        reg_nr4_sad2bet2_lut15       // unsigned , default = 255  sad to beta2 for snr and mcnr blending, dft = 255
+#define   NR4_MCNR_RO_U_SUM                        (0x2df2)
+#define P_NR4_MCNR_RO_U_SUM                        (volatile unsigned int *)((0x2df2  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_u_sum                // unsigned , default = 0  sum of U of current field/frame
+#define   NR4_MCNR_RO_V_SUM                        (0x2df3)
+#define P_NR4_MCNR_RO_V_SUM                        (volatile unsigned int *)((0x2df3  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_v_sum                // unsigned , default = 0  sum of V of current field/frame
+#define   NR4_MCNR_RO_GRDU_SUM                     (0x2df4)
+#define P_NR4_MCNR_RO_GRDU_SUM                     (volatile unsigned int *)((0x2df4  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_grdu_sum             // unsigned , default = 0  sum of gradient U of current field/frame
+#define   NR4_MCNR_RO_GRDV_SUM                     (0x2df5)
+#define P_NR4_MCNR_RO_GRDV_SUM                     (volatile unsigned int *)((0x2df5  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_grdv_sum             // unsigned , default = 0  sum of gradient V of current field/frame
+#define   NR4_TOP_CTRL                             (0x2dff)
+#define P_NR4_TOP_CTRL                             (volatile unsigned int *)((0x2dff  << 2) + 0xff900000)
+//Bit 31:20        reg_gclk_ctrl                 // unsigned , default = 0
+//Bit 19           reserved
+//Bit 18           reg_nr4_mcnr_en              // unsigned , default = 1  ncnr enable or bypass, dft = 1
+//Bit 17           reg_nr2_en                 // unsigned , default = 1  nr2 enable, dft = 1
+//Bit 16           reg_nr4_en                   // unsigned , default = 1  nr4 enable, dft = 1
+//Bit 15           reg_nr2_proc_en            // unsigned , default = 1
+//Bit 14           reg_det3d_en               // unsigned , default = 1
+//Bit 13           di_polar_en                   // unsigned , default = 1  do does not have in C
+//Bit 12           reg_cfr_enable             // unsigned , default = 0  0-disable;  1:enable
+//Bit 11: 9        reg_3dnr_enable_l          // unsigned , default = 7  b0: Y b1:U b2:V
+//Bit  8: 6        reg_3dnr_enable_r          // unsigned , default = 7  b0: Y b1:U b2:V
+//Bit  5           reg_nr4_lnbuf_ctrl           // unsigned , default = 1  line buf ctrl for nr4: 0, 3lines, 1, 5lines, dft = 1
+//Bit  4           reg_nr4_snr2_en              // unsigned , default = 0  snr2 enable, 0: use old snr, 1: use new snr2,   dft = 1
+//Bit  3           reg_nr4_scene_change_en      // unsigned , default = 1  enable scene change proc. dft = 1
+//Bit  2           nr2_sw_en                     // unsigned , default = 1  do does not have in C
+//Bit  1            reserved
+//Bit  0           reg_nr4_scene_change_flg     // unsigned , default = 0  flags for scene change, dft = 0
+//========== nr4_mcnr_regs register end ==========//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr4_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dnr_regs.h
+//
+//========================================================================
+//  VI_HIST_SPL register    (16'h2e00 - 16'h2eff)
+//========================================================================
+//`define VI_HIST_SPL_VCBUS_BASE                   8'h2e
+//
+// Reading file:  vi_hist_spl_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// ----------------------------
+// VI_HIST_SPL 0x2e
+// ----------------------------
+// -----------------------------------------------
+// CBUS_BASE:  VI_HIST_SPL_VCBUS_BASE = 0x2e
+// -----------------------------------------------
+//BIT 14: 34bin only, 0&255 and other 32bins
+//Bit 13:11 hist_din_sel, 00: from vdin0 dout,  1: from vdin1, 2: from nr dout, 3: di output, 4: vpp output, 5: vd1_din, 6: vd2_din, 7:osd1_dout
+//Bit 10:8   hist_din_comp_mux, mux of [29:22], [19:12], [9:2] for hist detect
+//Bit 7:5   hist_dnlp_low   the real pixels in each bins got by VI_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
+//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
+//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
+//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
+#define   VI_HIST_CTRL                             (0x2e00)
+#define P_VI_HIST_CTRL                             (volatile unsigned int *)((0x2e00  << 2) + 0xff900000)
+//Bit 28:16 hist_hstart  horizontal start value to define hist window
+//Bit 12:0  hist_hend    horizontal end value to define hist window
+#define   VI_HIST_H_START_END                      (0x2e01)
+#define P_VI_HIST_H_START_END                      (volatile unsigned int *)((0x2e01  << 2) + 0xff900000)
+//Bit 28:16 hist_vstart  vertical start value to define hist window
+//Bit 12:0  hist_vend    vertical end value to define hist window
+#define   VI_HIST_V_START_END                      (0x2e02)
+#define P_VI_HIST_V_START_END                      (volatile unsigned int *)((0x2e02  << 2) + 0xff900000)
+//Bit 15:8  hist_max    maximum value
+//Bit 7:0   hist_min    minimum value
+//read only
+#define   VI_HIST_MAX_MIN                          (0x2e03)
+#define P_VI_HIST_MAX_MIN                          (volatile unsigned int *)((0x2e03  << 2) + 0xff900000)
+//Bit 31:0  hist_spl_rd
+//counts for the total luma value
+//read only
+#define   VI_HIST_SPL_VAL                          (0x2e04)
+#define P_VI_HIST_SPL_VAL                          (volatile unsigned int *)((0x2e04  << 2) + 0xff900000)
+//Bit 21:0  hist_spl_pixel_count
+//counts for the total calculated pixels
+//read only
+#define   VI_HIST_SPL_PIX_CNT                      (0x2e05)
+#define P_VI_HIST_SPL_PIX_CNT                      (volatile unsigned int *)((0x2e05  << 2) + 0xff900000)
+//Bit 31:0  hist_chroma_sum
+//counts for the total chroma value
+//read only
+#define   VI_HIST_CHROMA_SUM                       (0x2e06)
+#define P_VI_HIST_CHROMA_SUM                       (volatile unsigned int *)((0x2e06  << 2) + 0xff900000)
+//Bit 31:16 higher hist bin
+//Bit 15:0  lower hist bin
+//0-255 are splited to 64 bins evenly, and VI_DNLP_HISTXX
+//are the statistic number of pixels that within each bin.
+//VI_DNLP_HIST00[15:0]  counts for the first  bin
+//VI_DNLP_HIST00[31:16] counts for the second bin
+//VI_DNLP_HIST01[15:0]  counts for the third  bin
+//VI_DNLP_HIST01[31:16] counts for the fourth bin
+//etc...
+//read only
+#define   VI_DNLP_HIST00                           (0x2e07)
+#define P_VI_DNLP_HIST00                           (volatile unsigned int *)((0x2e07  << 2) + 0xff900000)
+#define   VI_DNLP_HIST01                           (0x2e08)
+#define P_VI_DNLP_HIST01                           (volatile unsigned int *)((0x2e08  << 2) + 0xff900000)
+#define   VI_DNLP_HIST02                           (0x2e09)
+#define P_VI_DNLP_HIST02                           (volatile unsigned int *)((0x2e09  << 2) + 0xff900000)
+#define   VI_DNLP_HIST03                           (0x2e0a)
+#define P_VI_DNLP_HIST03                           (volatile unsigned int *)((0x2e0a  << 2) + 0xff900000)
+#define   VI_DNLP_HIST04                           (0x2e0b)
+#define P_VI_DNLP_HIST04                           (volatile unsigned int *)((0x2e0b  << 2) + 0xff900000)
+#define   VI_DNLP_HIST05                           (0x2e0c)
+#define P_VI_DNLP_HIST05                           (volatile unsigned int *)((0x2e0c  << 2) + 0xff900000)
+#define   VI_DNLP_HIST06                           (0x2e0d)
+#define P_VI_DNLP_HIST06                           (volatile unsigned int *)((0x2e0d  << 2) + 0xff900000)
+#define   VI_DNLP_HIST07                           (0x2e0e)
+#define P_VI_DNLP_HIST07                           (volatile unsigned int *)((0x2e0e  << 2) + 0xff900000)
+#define   VI_DNLP_HIST08                           (0x2e0f)
+#define P_VI_DNLP_HIST08                           (volatile unsigned int *)((0x2e0f  << 2) + 0xff900000)
+#define   VI_DNLP_HIST09                           (0x2e10)
+#define P_VI_DNLP_HIST09                           (volatile unsigned int *)((0x2e10  << 2) + 0xff900000)
+#define   VI_DNLP_HIST10                           (0x2e11)
+#define P_VI_DNLP_HIST10                           (volatile unsigned int *)((0x2e11  << 2) + 0xff900000)
+#define   VI_DNLP_HIST11                           (0x2e12)
+#define P_VI_DNLP_HIST11                           (volatile unsigned int *)((0x2e12  << 2) + 0xff900000)
+#define   VI_DNLP_HIST12                           (0x2e13)
+#define P_VI_DNLP_HIST12                           (volatile unsigned int *)((0x2e13  << 2) + 0xff900000)
+#define   VI_DNLP_HIST13                           (0x2e14)
+#define P_VI_DNLP_HIST13                           (volatile unsigned int *)((0x2e14  << 2) + 0xff900000)
+#define   VI_DNLP_HIST14                           (0x2e15)
+#define P_VI_DNLP_HIST14                           (volatile unsigned int *)((0x2e15  << 2) + 0xff900000)
+#define   VI_DNLP_HIST15                           (0x2e16)
+#define P_VI_DNLP_HIST15                           (volatile unsigned int *)((0x2e16  << 2) + 0xff900000)
+#define   VI_DNLP_HIST16                           (0x2e17)
+#define P_VI_DNLP_HIST16                           (volatile unsigned int *)((0x2e17  << 2) + 0xff900000)
+#define   VI_DNLP_HIST17                           (0x2e18)
+#define P_VI_DNLP_HIST17                           (volatile unsigned int *)((0x2e18  << 2) + 0xff900000)
+#define   VI_DNLP_HIST18                           (0x2e19)
+#define P_VI_DNLP_HIST18                           (volatile unsigned int *)((0x2e19  << 2) + 0xff900000)
+#define   VI_DNLP_HIST19                           (0x2e1a)
+#define P_VI_DNLP_HIST19                           (volatile unsigned int *)((0x2e1a  << 2) + 0xff900000)
+#define   VI_DNLP_HIST20                           (0x2e1b)
+#define P_VI_DNLP_HIST20                           (volatile unsigned int *)((0x2e1b  << 2) + 0xff900000)
+#define   VI_DNLP_HIST21                           (0x2e1c)
+#define P_VI_DNLP_HIST21                           (volatile unsigned int *)((0x2e1c  << 2) + 0xff900000)
+#define   VI_DNLP_HIST22                           (0x2e1d)
+#define P_VI_DNLP_HIST22                           (volatile unsigned int *)((0x2e1d  << 2) + 0xff900000)
+#define   VI_DNLP_HIST23                           (0x2e1e)
+#define P_VI_DNLP_HIST23                           (volatile unsigned int *)((0x2e1e  << 2) + 0xff900000)
+#define   VI_DNLP_HIST24                           (0x2e1f)
+#define P_VI_DNLP_HIST24                           (volatile unsigned int *)((0x2e1f  << 2) + 0xff900000)
+#define   VI_DNLP_HIST25                           (0x2e20)
+#define P_VI_DNLP_HIST25                           (volatile unsigned int *)((0x2e20  << 2) + 0xff900000)
+#define   VI_DNLP_HIST26                           (0x2e21)
+#define P_VI_DNLP_HIST26                           (volatile unsigned int *)((0x2e21  << 2) + 0xff900000)
+#define   VI_DNLP_HIST27                           (0x2e22)
+#define P_VI_DNLP_HIST27                           (volatile unsigned int *)((0x2e22  << 2) + 0xff900000)
+#define   VI_DNLP_HIST28                           (0x2e23)
+#define P_VI_DNLP_HIST28                           (volatile unsigned int *)((0x2e23  << 2) + 0xff900000)
+#define   VI_DNLP_HIST29                           (0x2e24)
+#define P_VI_DNLP_HIST29                           (volatile unsigned int *)((0x2e24  << 2) + 0xff900000)
+#define   VI_DNLP_HIST30                           (0x2e25)
+#define P_VI_DNLP_HIST30                           (volatile unsigned int *)((0x2e25  << 2) + 0xff900000)
+#define   VI_DNLP_HIST31                           (0x2e26)
+#define P_VI_DNLP_HIST31                           (volatile unsigned int *)((0x2e26  << 2) + 0xff900000)
+#define   VI_DNLP_HIST32                           (0x2e27)
+#define P_VI_DNLP_HIST32                           (volatile unsigned int *)((0x2e27  << 2) + 0xff900000)
+//Bit 28:16 hist_pic_height  active input data window height
+//Bit 12:0  hist_pic_width   active input data window width
+#define   VI_HIST_PIC_SIZE                         (0x2e28)
+#define P_VI_HIST_PIC_SIZE                         (volatile unsigned int *)((0x2e28  << 2) + 0xff900000)
+//Bit 15:8 hist_pix_white_value: >= this value will be white pixel
+//Bit 7:0 hist_pix_black_value: <= this value will be black pixel
+#define   VI_HIST_BLACK_WHITE_VALUE                (0x2e29)
+#define P_VI_HIST_BLACK_WHITE_VALUE                (volatile unsigned int *)((0x2e29  << 2) + 0xff900000)
+#define   VI_HIST_GCLK_CTRL                        (0x2e2a)
+#define P_VI_HIST_GCLK_CTRL                        (volatile unsigned int *)((0x2e2a  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vi_hist_spl_reg.h
+//
+//`define MCDI_VCBUS_BASE                8'h2f
+//
+// Reading file:  mcdi_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  MCDI_VCBUS_BASE = 0x2f
+// -----------------------------------------------
+////=================================================================////
+//// memc di core 0
+////=================================================================////
+#define   MCDI_HV_SIZEIN                           (0x2f00)
+#define P_MCDI_HV_SIZEIN                           (volatile unsigned int *)((0x2f00  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:16, reg_mcdi_hsize               image horizontal size (number of cols)   default=1024
+//Bit 15:13, reserved
+//Bit 12: 0, reg_mcdi_vsize               image vertical size   (number of rows)   default=1024
+#define   MCDI_HV_BLKSIZEIN                        (0x2f01)
+#define P_MCDI_HV_BLKSIZEIN                        (volatile unsigned int *)((0x2f01  << 2) + 0xff900000)
+//Bit    31, reg_mcdi_vrev					 default = 0
+//Bit    30, reg_mcdi_hrev					 default = 0
+//Bit 29:28, reserved
+//Bit 27:16, reg_mcdi_blkhsize               image horizontal blk size (number of cols)   default=1024
+//Bit 15:13, reserved
+//Bit 11: 0, reg_mcdi_blkvsize               image vertical blk size   (number of rows)   default=1024
+#define   MCDI_BLKTOTAL                            (0x2f02)
+#define P_MCDI_BLKTOTAL                            (volatile unsigned int *)((0x2f02  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23: 0, reg_mcdi_blktotal
+#define   MCDI_MOTINEN                             (0x2f03)
+#define P_MCDI_MOTINEN                             (volatile unsigned int *)((0x2f03  << 2) + 0xff900000)
+//Bit 31: 2, reserved
+//Bit     1, reg_mcdi_motionrefen.           enable motion refinement of MA, default = 1
+//Bit     0, reg_mcdi_motionparadoxen.       enable motion paradox detection, default = 1
+#define   MCDI_CTRL_MODE                           (0x2f04)
+#define P_MCDI_CTRL_MODE                           (volatile unsigned int *)((0x2f04  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:26, reg_mcdi_lmvlocken	             0:disable, 1: use max Lmv, 2: use no-zero Lmv, lmv lock enable mode, default = 2
+//Bit 25,    reg_mcdi_reldetrptchken
+//                                           0: unable; 1: enable, enable repeat pattern check (not repeat mv detection) in rel det part, default = 1
+//Bit 24,    reg_mcdi_reldetgmvpd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check in gmv lock mode for rel det, default = 1
+//Bit 23,    reg_mcdi_pd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check (lock) function, default = 1
+//Bit 22,    reg_mcdi_reldetlpfen
+//                                           0: unable; 1: enable, enable det value lpf, default = 1
+//Bit 21,    reg_mcdi_reldetlmvpd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check in lmv lock mode for rel det, default = 1
+//Bit 20,    reg_mcdi_reldetlmvdifchken
+//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1
+//Bit 19,    reg_mcdi_reldetgmvdifchken
+//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1
+//Bit 18,    reg_mcdi_reldetpd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check for rel det refinement, default = 1
+//Bit 17,    reg_mcdi_reldetfrqchken
+//                                           0: unable; 1: enable, enable mv frequency check in rel det, default = 1
+//Bit 16,    reg_mcdi_qmeen
+//                                           0: unable; 1: enable, enable quarter motion estimation, defautl = 1
+//Bit 15,    reg_mcdi_refrptmven
+//                                           0: unable; 1: enable, use repeat mv in refinement, default = 1
+//Bit 14,    reg_mcdi_refgmven
+//                                           0: unable; 1: enable, use gmv in refinement, default = 1
+//Bit 13,    reg_mcdi_reflmven
+//                                           0: unable; 1: enable, use lmvs in refinement, default = 1
+//Bit 12,    reg_mcdi_refnmven
+//                                           0: unable; 1: enable, use neighoring mvs in refinement, default = 1
+//Bit 11,    reserved
+//Bit 10,    reg_mcdi_referrfrqchken
+//                                           0: unable; 1: enable, enable mv frquency check while finding min err in ref, default = 1
+//Bit 9,     reg_mcdi_refen
+//                                           0: unable; 1: enable, enable mv refinement, default = 1
+//Bit 8,     reg_mcdi_horlineen
+//                                           0: unable; 1: enable,enable horizontal lines detection by sad map, default = 1
+//Bit 7,     reg_mcdi_highvertfrqdeten
+//                                           0: unable; 1: enable, enable high vertical frequency pattern detection, default = 1
+//Bit 6,     reg_mcdi_gmvlocken
+//                                           0: unable; 1: enable, enable gmv lock mode, default = 1
+//Bit 5,     reg_mcdi_rptmven
+//                                           0: unable; 1: enable, enable repeat pattern detection, default = 1
+//Bit 4,     reg_mcdi_gmven
+//                                           0: unable; 1: enable, enable global motion estimation, default = 1
+//Bit 3,     reg_mcdi_lmven
+//                                           0: unable; 1: enable, enable line mv estimation for hme, default = 1
+//Bit 2,     reg_mcdi_chkedgeen
+//                                           0: unable; 1: enable, enable check edge function, default = 1
+//Bit 1,     reg_mcdi_txtdeten
+//                                           0: unable; 1: enable, enable texture detection, default = 1
+//Bit 0,     reg_mcdi_memcen
+//                                           0: unable; 1: enable, enable of memc di, default = 1
+#define   MCDI_UNI_MVDST                           (0x2f05)
+#define P_MCDI_UNI_MVDST                           (volatile unsigned int *)((0x2f05  << 2) + 0xff900000)
+//Bit 31:20, reserved
+//Bit 19:17, reg_mcdi_unimvdstabsseg0                     segment0 for uni-mv abs, default = 1
+//Bit 16:12, reg_mcdi_unimvdstabsseg1                     segment1 for uni-mv abs, default = 15
+//Bit 11: 8, reg_mcdi_unimvdstabsdifgain0	          2/2, gain0 of uni-mv abs dif for segment0, normalized 2 to '1', default = 2
+//Bit  7: 5, reg_mcdi_unimvdstabsdifgain1                 2/2, gain1 of uni-mv abs dif for segment1, normalized 2 to '1', default = 2
+//Bit  4: 2, reg_mcdi_unimvdstabsdifgain2                 2/2, gain2 of uni-mv abs dif beyond segment1, normalized 2 to '1', default = 2
+//Bit  1: 0, reg_mcdi_unimvdstsgnshft		          shift for neighboring distance of uni-mv, default = 0
+#define   MCDI_BI_MVDST                            (0x2f06)
+#define P_MCDI_BI_MVDST                            (volatile unsigned int *)((0x2f06  << 2) + 0xff900000)
+//Bit 31:20, reserved
+//Bit 19:17, reg_mcdi_bimvdstabsseg0                      segment0 for bi-mv abs, default = 1
+//Bit 16:12, reg_mcdi_bimvdstabsseg1                      segment1 for bi-mv abs, default = 9
+//Bit 11: 8, reg_mcdi_bimvdstabsdifgain0	          6/2, gain0 of bi-mv abs dif for segment0, normalized 2 to '1', default = 6
+//Bit  7: 5, reg_mcdi_bimvdstabsdifgain1                  3/2, gain1 of bi-mvabs dif for segment1, normalized 2 to '1', default = 3
+//Bit  4: 2, reg_mcdi_bimvdstabsdifgain2                  2/2, gain2 of bi-mvabs dif beyond segment1, normalized 2 to '1', default = 2
+//Bit  1: 0, reg_mcdi_bimvdstsgnshft	                  shift for neighboring distance of bi-mv, default = 0
+#define   MCDI_SAD_GAIN                            (0x2f07)
+#define P_MCDI_SAD_GAIN                            (volatile unsigned int *)((0x2f07  << 2) + 0xff900000)
+//Bit 31:19, reserved
+//Bit 18:17, reg_mcdi_unisadcorepxlgain                   uni-sad core pixels gain, default = 3
+//Bit 16,    reg_mcdi_unisadcorepxlnormen                 enable uni-sad core pixels normalization, default = 0
+//Bit 15:11, reserved
+//Bit 10: 9, reg_mcdi_bisadcorepxlgain                    bi-sad core pixels gain, default = 3
+//Bit  8,    reg_mcdi_bisadcorepxlnormen                  enable bi-sad core pixels normalization, default = 1
+//Bit  7: 3, reserved
+//Bit  2: 1, reg_mcdi_biqsadcorepxlgain                   bi-qsad core pixels gain, default = 3
+//Bit  0,    reg_mcdi_biqsadcorepxlnormen                 enable bi-qsad core pixels normalization, default = 1
+#define   MCDI_TXT_THD                             (0x2f08)
+#define P_MCDI_TXT_THD                             (volatile unsigned int *)((0x2f08  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_txtminmaxdifthd,                    min max dif threshold (>=) for texture detection, default = 24
+//Bit 15: 8, reg_mcdi_txtmeandifthd,                      mean dif threshold (<) for texture detection, default = 9
+//Bit  7: 3, reserved
+//Bit  2: 0, reg_mcdi_txtdetthd,                          texture detecting threshold, 0~4, default = 2
+#define   MCDI_FLT_MODESEL                         (0x2f09)
+#define P_MCDI_FLT_MODESEL                         (volatile unsigned int *)((0x2f09  << 2) + 0xff900000)
+//Bit 31	 reserved
+//Bit 30:28, reg_mcdi_flthorlineselmode                   mode for horizontal line detecting flat calculation, default = 1, same as below
+//Bit 27	 reserved
+//Bit 26:24, reg_mcdi_fltgmvselmode                       mode for gmv flat calculation, default = 4, same as below
+//Bit 23,	 reserved
+//Bit 22:20, reg_mcdi_fltsadselmode                       mode for sad flat calculation, default = 2, same as below
+//Bit 19,	 reserved
+//Bit 18:16, reg_mcdi_fltbadwselmode                      mode for badw flat calculation, default = 3, same as below
+//Bit 15,	 reserved
+//Bit 14:12, reg_mcdi_fltrptmvselmode                     mode for repeat mv flat calculation, default = 4, same as below
+//Bit 11,	 reserved
+//Bit 10: 8, reg_mcdi_fltbadrelselmode                    mode for bad rel flat calculation, default = 4, same as below
+//Bit  7,	 reserved
+//Bit  6: 4, reg_mcdi_fltcolcfdselmode                    mode for col cfd flat calculation, default = 2, same as below
+//Bit  3,	 reserved
+//Bit  2: 0, reg_mcdi_fltpd22chkselmode                   mode for pd22 check flat calculation, default = 2, # 0:cur dif h, 1: cur dif v, 2: pre dif h, 3: pre dif v, 4: cur flt, 5: pre flt, 6: cur+pre, 7: max all(cur,pre)
+#define   MCDI_CHK_EDGE_THD                        (0x2f0a)
+#define P_MCDI_CHK_EDGE_THD                        (volatile unsigned int *)((0x2f0a  << 2) + 0xff900000)
+//Bit 23:28, reserved.
+//Bit 27:24, reg_mcdi_chkedgedifsadthd.                   thd (<=) for sad dif check, 0~8, default = 1
+//Bit 23:16, reserved.
+//Bit 15:12, reg_mcdi_chkedgemaxedgethd.                  max drt of edge, default = 15
+//Bit 11: 8, reg_mcdi_chkedgeminedgethd.                  min drt of edge, default = 2
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_chkedgevdifthd.                     thd for vertical dif in check edge, default = 14
+#define   MCDI_CHK_EDGE_GAIN_OFFST                 (0x2f0b)
+#define P_MCDI_CHK_EDGE_GAIN_OFFST                 (volatile unsigned int *)((0x2f0b  << 2) + 0xff900000)
+//Bit 31:24, reserved.
+//Bit 23:20, reg_mcdi_chkedgedifthd1.                     thd1 for edge dif check (<=), default = 4
+//Bit 19:16, reg_mcdi_chkedgedifthd0.                     thd0 for edge dif check (>=), default = 15
+//Bit   :15, reserved.
+//Bit 14:10, reg_mcdi_chkedgechklen.                      total check length for edge check, 1~24 (>0), default = 24
+//Bit  9: 8, reg_mcdi_chkedgeedgesel.                     final edge select mode, 0: original start edge, 1: lpf start edge, 2: orignal start+end edge, 3: lpf start+end edge, default = 1
+//Bit  7: 3, reg_mcdi_chkedgesaddstgain.                  distance gain for sad calc while getting edges, default = 4
+//Bit     2, reg_mcdi_chkedgechkmode.                     edge used in check mode, 0: original edge, 1: lpf edge, defautl = 1
+//Bit     1, reg_mcdi_chkedgestartedge.                   edge mode for start edge, 0: original edge, 1: lpf edge, defautl = 0
+//Bit     0, reg_mcdi_chkedgeedgelpf.                     edge lpf mode, 0:[0,2,4,2,0], 1:[1,2,2,2,1], default = 0
+#define   MCDI_LMV_RT                              (0x2f0c)
+#define P_MCDI_LMV_RT                              (volatile unsigned int *)((0x2f0c  << 2) + 0xff900000)
+//BIt 31:15, reserved
+//Bit 14:12, reg_mcdi_lmvvalidmode                        valid mode for lmv calc., 100b: use char det, 010b: use flt, 001b: use hori flg
+//Bit 11:10, reg_mcdi_lmvgainmvmode                       four modes of mv selection for lmv weight calucluation, default = 1
+//                                                        0: cur(x-3), lst(x-1,x,x+1); 1: cur(x-4,x-3), lst(x,x+1); 2: cur(x-5,x-4,x-3), lst(x-1,x,x+1,x+2,x+3); 3: cur(x-6,x-5,x-4,x-3), lst(x-1,x,x+1,x+2);
+//Bit  9,    reg_mcdi_lmvinitmode                         initial lmvs at first row of input field, 0: intial value = 0; 1: inital = 32 (invalid), default = 0
+//Bit  8,    reserved
+//Bit  7: 4, reg_mcdi_lmvrt0                              ratio of max mv, default = 5
+//Bit  3: 0, reg_mcdi_lmvrt1                              ratio of second max mv, default = 5
+#define   MCDI_LMV_GAINTHD                         (0x2f0d)
+#define P_MCDI_LMV_GAINTHD                         (volatile unsigned int *)((0x2f0d  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_lmvvxmaxgain                        max gain of lmv weight, default = 96
+//Bit 23,    reserved
+//Bit 22:20, reg_mcdi_lmvdifthd0                          dif threshold 0 (<) for small lmv, default = 1
+//Bit 19:17, reg_mcdi_lmvdifthd1                          dif threshold 1 (<) for median lmv, default = 2
+//Bit 16:14, reg_mcdi_lmvdifthd2                          dif threshold 2 (<) for large lmv, default = 3
+//Bit 13: 8, reg_mcdi_lmvnumlmt                           least/limit number of (total number - max0), default = 20
+//Bit  7: 0, reg_mcdi_lmvfltthd                           flt cnt thd (<) for lmv, default = 9
+#define   MCDI_RPTMV_THD0                          (0x2f0e)
+#define P_MCDI_RPTMV_THD0                          (volatile unsigned int *)((0x2f0e  << 2) + 0xff900000)
+//Bit 31:25, reg_mcdi_rptmvslpthd2			  slope thd (>=) between i and i+3/i-3 (i+4/i-4), default = 64
+//Bit 24:20, reg_mcdi_rptmvslpthd1                        slope thd (>=) between i and i+2/i-2, default = 4
+//Bit 19:10, reg_mcdi_rptmvampthd2                        amplitude thd (>=) between max and min, when count cycles, default = 300
+//Bit  9: 0, reg_mcdi_rptmvampthd1                        amplitude thd (>=) between average of max and min, default = 400
+#define   MCDI_RPTMV_THD1                          (0x2f0f)
+#define P_MCDI_RPTMV_THD1                          (volatile unsigned int *)((0x2f0f  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:25, reg_mcdi_rptmvcyccntthd                      thd (>=) of total cycles count, default = 2
+//Bit 24:21, reg_mcdi_rptmvcycdifthd                      dif thd (<) of cycles length, default = 3
+//Bit 20:18, reg_mcdi_rptmvcycvldthd                      thd (>) of valid cycles number, default = 1
+//Bit 17:15, reg_mcdi_rptmvhalfcycminthd                  min length thd (>=) of half cycle, default = 2
+//Bit 14:11, reg_mcdi_rptmvhalfcycdifthd                  neighboring half cycle length dif thd (<), default = 5
+//Bit 10: 8, reg_mcdi_rptmvminmaxcntthd                   least number of valid max and min, default = 2
+//Bit  7: 5, reg_mcdi_rptmvcycminthd                      min length thd (>=) of cycles, default = 2
+//Bit  4: 0, reg_mcdi_rptmvcycmaxthd                      max length thd (<) of cycles, default = 17
+#define   MCDI_RPTMV_THD2                          (0x2f10)
+#define P_MCDI_RPTMV_THD2                          (volatile unsigned int *)((0x2f10  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_rptmvhdifthd0                       higher hdif thd (>=) (vertical edge) for rpt detection, default = 8
+//Bit 15: 8, reg_mcdi_rptmvhdifthd1                       hdif thd (>=) (slope edge) for rpt detection, default = 4
+//Bit  7: 0, reg_mcdi_rptmvvdifthd                        vdif thd (>=) (slope edge) for rpt detection, default = 1
+#define   MCDI_RPTMV_SAD                           (0x2f11)
+#define P_MCDI_RPTMV_SAD                           (volatile unsigned int *)((0x2f11  << 2) + 0xff900000)
+//Bit 31:26, reserved
+//Bit 25:16, reg_mcdi_rptmvsaddifthdgain                  7x3x(16/16), gain for sad dif thd in rpt mv detection, 0~672, normalized 16 as '1', default = 336
+//Bit 15:10, reserved
+//Bit  9: 0, reg_mcdi_rptmvsaddifthdoffst                 offset for sad dif thd in rpt mv detection, -512~511, default = 16
+#define   MCDI_RPTMV_FLG                           (0x2f12)
+#define P_MCDI_RPTMV_FLG                           (volatile unsigned int *)((0x2f12  << 2) + 0xff900000)
+//Bit 31:18,  reserved
+//Bit 17:16,  reg_mcdi_rptmvmode                          select mode of mvs for repeat motion estimation, 0: hmv, 1: qmv/2, 2 or 3: qmv/4, default = 2
+//Bit 15: 8,  reg_mcdi_rptmvflgcntthd                     thd (>=) of min count number for rptmv of whole field, for rptmv estimation, default = 64
+//Bit  7: 5,  reserved
+//Bit  4: 0,  reg_mcdi_rptmvflgcntrt                      4/32, ratio for repeat mv flag count, normalized 32 as '1', set 31 to 32,
+#define   MCDI_RPTMV_GAIN                          (0x2f13)
+#define P_MCDI_RPTMV_GAIN                          (volatile unsigned int *)((0x2f13  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_rptmvlftgain                        up repeat mv gain for hme, default = 96
+//Bit 23:16, reg_mcdi_rptmvuplftgain                      up left repeat mv gain for hme, default = 32
+//Bit 15: 8, reg_mcdi_rptmvupgain                         up repeat mv gain for hme, default = 64
+//Bit  7: 0, reg_mcdi_rptmvuprightgain                    up right repeat mv gain for hme, default = 32
+#define   MCDI_GMV_RT                              (0x2f14)
+#define P_MCDI_GMV_RT                              (volatile unsigned int *)((0x2f14  << 2) + 0xff900000)
+//Bit 31,    reserved
+//Bit 30:24, reg_mcdi_gmvmtnrt0                           ratio 0 for motion senario, set 127 to 128, normalized 128 as '1', default =32
+//Bit 23,    reserved
+//Bit 22:16, reg_mcdi_gmvmtnrt1                           ratio 1 for motion senario, set 127 to 128, normalized 128 as '1', default = 56
+//Bit 15,    reserved
+//Bit 14: 8, reg_mcdi_gmvstlrt0                           ratio 0 for still senario, set 127 to 128, normalized 128 as '1', default = 56
+//Bit  7,    reserved
+//Bit  6: 0, reg_mcdi_gmvstlrt1                           ratio 1 for still senario, set 127 to 128, normalized 128 as '1', default = 80
+#define   MCDI_GMV_GAIN                            (0x2f15)
+#define P_MCDI_GMV_GAIN                            (volatile unsigned int *)((0x2f15  << 2) + 0xff900000)
+//Bit 31:25, reg_mcdi_gmvzeromvlockrt0                    ratio 0 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 100
+//Bit 24:18, reg_mcdi_gmvzeromvlockrt1                    ratio 1 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 112
+//Bit 17:16, reg_mcdi_gmvvalidmode                        valid mode for gmv calc., 10b: use flt, 01b: use hori flg, default = 3
+//Bit 15: 8, reg_mcdi_gmvvxgain                           gmv's vx gain when gmv locked for hme, default = 0
+//Bit  7: 0, reg_mcdi_gmvfltthd                           flat thd (<) for gmv calc. default = 3
+#define   MCDI_HOR_SADOFST                         (0x2f16)
+#define P_MCDI_HOR_SADOFST                         (volatile unsigned int *)((0x2f16  << 2) + 0xff900000)
+//Bit 31:25, reserved
+//Bit 24:16, reg_mcdi_horsaddifthdgain                    21*1/8, gain/divisor for sad dif threshold in hor line detection, normalized 8 as '1', default = 21
+//Bit 15: 8, reg_mcdi_horsaddifthdoffst                   offset for sad dif threshold in hor line detection, -128~127, default = 0
+//Bit  7: 0, reg_mcdi_horvdifthd                          threshold (>=) of vertical dif of next block for horizontal line detection, default = 24
+#define   MCDI_REF_MV_NUM                          (0x2f17)
+#define P_MCDI_REF_MV_NUM                          (volatile unsigned int *)((0x2f17  << 2) + 0xff900000)
+//Bit 31: 2, reserved
+//Bit  1: 0, reg_mcdi_refmcmode.         motion compensated mode used in refinement, 0: pre, 1: next, 2: (pre+next)/2, default = 0
+#define   MCDI_REF_BADW_THD_GAIN                   (0x2f18)
+#define P_MCDI_REF_BADW_THD_GAIN                   (volatile unsigned int *)((0x2f18  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:24, reg_mcdi_refbadwcnt2gain.   gain for badwv count num==3, default = 6
+//Bit 23:20, reg_mcdi_refbadwcnt1gain.   gain for badwv count num==2, default = 3
+//Bit 19:16, reg_mcdi_refbadwcnt0gain.   gain for badwv count num==1, default = 1
+//Bit 15:12, reg_mcdi_refbadwthd3.       threshold 3 for detect badweave with largest average luma, default = 4
+//Bit 11: 8, reg_mcdi_refbadwthd2.       threshold 2 for detect badweave with third smallest average luma, default = 3
+//Bit  7: 4, reg_mcdi_refbadwthd1.       threshold 1 for detect badweave with second smallest average luma, default = 2
+//Bit  3: 0, reg_mcdi_refbadwthd0.       threshold 0 for detect badweave with smallest average luma, default = 1
+#define   MCDI_REF_BADW_SUM_GAIN                   (0x2f19)
+#define P_MCDI_REF_BADW_SUM_GAIN                   (volatile unsigned int *)((0x2f19  << 2) + 0xff900000)
+//Bit 31:13, reserved
+//Bit 12: 8, reg_mcdi_refbadwsumgain0.   sum gain for r channel, 0~16, default = 8
+//Bit  7: 5, reserved
+//Bit     4, reg_mcdi_refbadwcalcmode.   mode for badw calculation, 0:sum, 1:max, default = 0
+//Bit  3: 0, reserved
+#define   MCDI_REF_BS_THD_GAIN                     (0x2f1a)
+#define P_MCDI_REF_BS_THD_GAIN                     (volatile unsigned int *)((0x2f1a  << 2) + 0xff900000)
+//Bit 31:28, reg_mcdi_refbsudgain1.      up & down block stregth gain1, normalized to 8 as '1', default = 2
+//Bit 27:24, reg_mcdi_refbsudgain0.      up & down block stregth gain0, normalized to 8 as '1', default = 4
+//Bit 23:19, reserved
+//Bit 18:16, reg_mcdi_refbslftgain.      left block strength gain, default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_refbsthd1.         threshold 1 for detect block stregth in refinment, default = 16
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_refbsthd0.         threshold 0 for detect block stregth in refinment, default = 8
+#define   MCDI_REF_ERR_GAIN0                       (0x2f1b)
+#define P_MCDI_REF_ERR_GAIN0                       (volatile unsigned int *)((0x2f1b  << 2) + 0xff900000)
+//Bit    31, reserved
+//Bit 30:24, reg_mcdi_referrnbrdstgain.            neighoring mv distances gain for err calc. in ref, normalized to 8 as '1', default = 48
+//Bit 23:20, reserved
+//Bit 19:16, reg_mcdi_referrbsgain.                bs gain for err calc. in ref, normalized to 8 as '1', default = 4
+//Bit    15, reserved
+//Bit 14: 8, reg_mcdi_referrbadwgain.              badw gain for err calc. in ref, normalized to 8 as '1', default = 64
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_referrsadgain.               sad gain for err calc. in ref, normalized to 8 as '1', default = 4
+#define   MCDI_REF_ERR_GAIN1                       (0x2f1c)
+#define P_MCDI_REF_ERR_GAIN1                       (volatile unsigned int *)((0x2f1c  << 2) + 0xff900000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_referrchkedgegain.           check edge gain for err calc. in ref, normalized to 8 as '1', default = 4
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_referrlmvgain.               (locked) lmv gain for err calc. in ref, normalized to 8 as '1', default = 0
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_referrgmvgain.               (locked) gmv gain for err calc. in ref, normalized to 8 as '1', default = 0
+#define   MCDI_REF_ERR_FRQ_CHK                     (0x2f1d)
+#define P_MCDI_REF_ERR_FRQ_CHK                     (volatile unsigned int *)((0x2f1d  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:24, reg_mcdi_referrfrqgain.               gain for mv frquency, normalized to 4 as '1', default = 10
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_referrfrqmax.                max gain for mv frquency check, default = 31
+//Bit    15, reserved
+//Bit 14:12, reg_mcdi_ref_errfrqmvdifthd2.         mv dif threshold 2 (<) for mv frquency check, default = 3
+//Bit    11, reserved
+//Bit 10: 8, reg_mcdi_ref_errfrqmvdifthd1.         mv dif threshold 1 (<) for mv frquency check, default = 2
+//Bit     7, reserved
+//Bit  6: 4, reg_mcdi_ref_errfrqmvdifthd0.         mv dif threshold 0 (<) for mv frquency check, default = 1
+//Bit  3: 0, reserved
+#define   MCDI_QME_LPF_MSK                         (0x2f1e)
+#define P_MCDI_QME_LPF_MSK                         (volatile unsigned int *)((0x2f1e  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:24, reg_mcdi_qmechkedgelpfmsk0.           lpf mask0 for chk edge in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+//Bit 23:20, reserved
+//Bit 19:16, reg_mcdi_qmebslpfmsk0.                lpf mask0 for bs in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_qmebadwlpfmsk0.              lpf mask0 for badw in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_qmesadlpfmsk0.               lpf mask0 for sad in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+#define   MCDI_REL_DIF_THD_02                      (0x2f1f)
+#define P_MCDI_REL_DIF_THD_02                      (volatile unsigned int *)((0x2f1f  << 2) + 0xff900000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_reldifthd2.                  thd (<) for (hdif+vdif), default = 9
+//Bit 15: 8, reg_mcdi_reldifthd1.                  thd (<) for (vdif), default = 5
+//Bit  7: 0, reg_mcdi_reldifthd0.                  thd (>=) for (hdif-vdif), default = 48
+#define   MCDI_REL_DIF_THD_34                      (0x2f20)
+#define P_MCDI_REL_DIF_THD_34                      (volatile unsigned int *)((0x2f20  << 2) + 0xff900000)
+//Bit 31:16, reserved.
+//Bit 15: 8, reg_mcdi_reldifthd4.                  thd (<) for (hdif), default = 255
+//Bit  7: 0, reg_mcdi_reldifthd3.                  thd (>=) for (vdif-hdif), default = 48
+#define   MCDI_REL_BADW_GAIN_OFFST_01              (0x2f21)
+#define P_MCDI_REL_BADW_GAIN_OFFST_01              (volatile unsigned int *)((0x2f21  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_relbadwoffst1.               offset for badw adj, for flat block, -128~127, default = 0
+//Bit 23:16, reg_mcdi_relbadwgain1.                gain for badw adj, for flat block, default = 128
+//Bit 15: 8, reg_mcdi_relbadwoffst0.               offset for badw adj, for vertical block, -128~127, default = 0
+//Bit  7: 0, reg_mcdi_relbadwgain0.                gain for badw adj, for vertical block, default = 160
+#define   MCDI_REL_BADW_GAIN_OFFST_23              (0x2f22)
+#define P_MCDI_REL_BADW_GAIN_OFFST_23              (volatile unsigned int *)((0x2f22  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_relbadwoffst3.               offset for badw adj, for other block, -128~127, default = 0
+//Bit 23:16, reg_mcdi_relbadwgain3.                gain for badw adj, for other block, default = 48
+//Bit 15: 8, reg_mcdi_relbadwoffst2.               offset for badw adj, for horizontal block, -128~127, default = 0
+//Bit  7: 0, reg_mcdi_relbadwgain2.                gain for badw adj, for horizontal block, default = 48
+#define   MCDI_REL_BADW_THD_GAIN_OFFST             (0x2f23)
+#define P_MCDI_REL_BADW_THD_GAIN_OFFST             (volatile unsigned int *)((0x2f23  << 2) + 0xff900000)
+//Bit 31:23, reserved.
+//Bit 22:16, reg_mcdi_relbadwoffst.                offset for badw thd adj, -64~63, default = 0
+//Bit 15: 8, reserved.
+//Bit  7: 0, reg_mcdi_relbadwthdgain.              gain0 for badw thd adj, normalized to 16 as '1', default = 16
+#define   MCDI_REL_BADW_THD_MIN_MAX                (0x2f24)
+#define P_MCDI_REL_BADW_THD_MIN_MAX                (volatile unsigned int *)((0x2f24  << 2) + 0xff900000)
+//Bit 31:18, reserved.
+//Bit 17: 8, reg_mcdi_relbadwthdmax.               max for badw thd adj, default = 256
+//Bit  7: 0, reg_mcdi_relbadwthdmin.               min for badw thd adj, default = 16
+#define   MCDI_REL_SAD_GAIN_OFFST_01               (0x2f25)
+#define P_MCDI_REL_SAD_GAIN_OFFST_01               (volatile unsigned int *)((0x2f25  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_relsadoffst1.                offset for sad adj, for flat block, -128~127, default = 0
+//Bit 23:20, reserved.
+//Bit 19:16, reg_mcdi_relsadgain1.                 gain for sad adj, for flat block, normalized to 8 as '1', default = 8
+//Bit 15: 8, reg_mcdi_relsadoffst0.                offset for sad adj, for vertical block, -128~127, default = 0
+//Bit  7: 4, reserved.
+//Bit  3: 0, reg_mcdi_relsadgain0.                 gain for sad adj, for vertical block, normalized to 8 as '1', default = 6
+#define   MCDI_REL_SAD_GAIN_OFFST_23               (0x2f26)
+#define P_MCDI_REL_SAD_GAIN_OFFST_23               (volatile unsigned int *)((0x2f26  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_relsadoffst3.                offset for sad adj, for other block, -128~127, default = 0
+//Bit 23:20, reserved.
+//Bit 19:16, reg_mcdi_relsadgain3.                 gain for sad adj, for other block, normalized to 8 as '1', default = 8
+//Bit 15: 8, reg_mcdi_relsadoffst2.                offset for sad adj, for horizontal block, -128~127, default = 0
+//Bit  7: 4, reserved.
+//Bit  3: 0, reg_mcdi_relsadgain2.                 gain for sad adj, for horizontal block, normalized to 8 as '1', default = 12
+#define   MCDI_REL_SAD_THD_GAIN_OFFST              (0x2f27)
+#define P_MCDI_REL_SAD_THD_GAIN_OFFST              (volatile unsigned int *)((0x2f27  << 2) + 0xff900000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_relsadoffst.                 offset for sad thd adj, -128~127, default = 0
+//Bit 15:10, reserved.
+//Bit  9: 0, reg_mcdi_relsadthdgain.               gain for sad thd adj, 21*2/16, normalized to 16 as '1', default = 42
+#define   MCDI_REL_SAD_THD_MIN_MAX                 (0x2f28)
+#define P_MCDI_REL_SAD_THD_MIN_MAX                 (volatile unsigned int *)((0x2f28  << 2) + 0xff900000)
+//Bit 31:27, reserved.
+//Bit 26:16, reg_mcdi_relsadthdmax.                max for sad thd adj, 21*32, default = 672
+//Bit 15: 9, reserved.
+//Bit  8: 0, reg_mcdi_relsadthdmin.                min for sad thd adj, 21*2, default = 42
+#define   MCDI_REL_DET_GAIN_00                     (0x2f29)
+#define P_MCDI_REL_DET_GAIN_00                     (volatile unsigned int *)((0x2f29  << 2) + 0xff900000)
+//Bit 31:21, reserved.
+//Bit 20:16, reg_mcdi_reldetbsgain0.               gain0 (gmv locked) for bs, for det. calc. normalized to 16 as '1', default = 8
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetbadwgain0.             gain0 (gmv locked) for badw, for det. calc. normalized to 16 as '1', default = 12
+//Bit  7: 5, reserved.
+//Bit  4: 0, reg_mcdi_reldetsadgain0.              gain0 (gmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
+#define   MCDI_REL_DET_GAIN_01                     (0x2f2a)
+#define P_MCDI_REL_DET_GAIN_01                     (volatile unsigned int *)((0x2f2a  << 2) + 0xff900000)
+//Bit 31:14, reserved.
+//Bit 12: 8, reg_mcdi_reldetchkedgegain0.          gain0 (gmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 2
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_reldetnbrdstgain0.           gain0 (gmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
+#define   MCDI_REL_DET_GAIN_10                     (0x2f2b)
+#define P_MCDI_REL_DET_GAIN_10                     (volatile unsigned int *)((0x2f2b  << 2) + 0xff900000)
+//Bit 31:21, reserved.
+//Bit 20:16, reg_mcdi_reldetbsgain1.               gain1 (lmv locked) for bs, for det. calc. normalized to 16 as '1', default = 0
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetbadwgain1.             gain1 (lmv locked) for badw, for det. calc. normalized to 16 as '1', default = 8
+//Bit  7: 5, reserved.
+//Bit  4: 0, reg_mcdi_reldetsadgain1.              gain1 (lmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
+#define   MCDI_REL_DET_GAIN_11                     (0x2f2c)
+#define P_MCDI_REL_DET_GAIN_11                     (volatile unsigned int *)((0x2f2c  << 2) + 0xff900000)
+//Bit 31:14, reserved.
+//Bit 12: 8, reg_mcdi_reldetchkedgegain1.          gain1 (lmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 0
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_reldetnbrdstgain1.           gain1 (lmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
+#define   MCDI_REL_DET_GAIN_20                     (0x2f2d)
+#define P_MCDI_REL_DET_GAIN_20                     (volatile unsigned int *)((0x2f2d  << 2) + 0xff900000)
+//Bit 31:21, reserved.
+//Bit 20:16, reg_mcdi_reldetbsgain2.               gain2 (no locked) for bs, for det. calc. normalized to 16 as '1', default = 12
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetbadwgain2.             gain2 (no locked) for badw, for det. calc. normalized to 16 as '1', default = 32
+//Bit  7: 5, reserved.
+//Bit  4: 0, reg_mcdi_reldetsadgain2.              gain2 (no locked) for qsad, for det. calc. normalized to 16 as '1', default = 16
+#define   MCDI_REL_DET_GAIN_21                     (0x2f2e)
+#define P_MCDI_REL_DET_GAIN_21                     (volatile unsigned int *)((0x2f2e  << 2) + 0xff900000)
+//Bit 31:26, reserved
+//Bit 25:16, reg_mcdi_reldetoffst.                 offset for rel calculation, for det. calc. -512~511,  default = 0
+//Bit 15:14, reserved.
+//Bit 12: 8, reg_mcdi_reldetchkedgegain2.          gain2 (no locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 10
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_reldetnbrdstgain2.           gain2 (no locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 32
+#define   MCDI_REL_DET_GMV_DIF_CHK                 (0x2f2f)
+#define P_MCDI_REL_DET_GMV_DIF_CHK                 (volatile unsigned int *)((0x2f2f  << 2) + 0xff900000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_reldetgmvfltthd.             flat thd (>=) for gmv lock decision, default = 0
+//Bit    15, reserved.
+//Bit 14:12, reg_mcdi_reldetgmvdifthd.             dif thd (>=) for current mv different from gmv for gmv dif check, actually used in Lmv lock check, default = 3
+//Bit    11, reserved.
+//Bit 10: 8, reg_mcdi_reldetgmvdifmin.             min mv dif for gmv dif check, default = 1, note: dif between reg_mcdi_rel_det_gmv_dif_max and reg_mcdi_rel_det_gmv_dif_min should be; 0,1,3,7, not work for others
+//Bit  7: 4, reg_mcdi_reldetgmvdifmax.             max mv dif for gmv dif check, default = 4
+//Bit  3: 1, reserved
+//Bit     0, reg_mcdi_reldetgmvdifmvmode.          mv mode used for gmv dif check, 0: use refmv, 1: use qmv, default = 0
+#define   MCDI_REL_DET_LMV_DIF_CHK                 (0x2f30)
+#define P_MCDI_REL_DET_LMV_DIF_CHK                 (volatile unsigned int *)((0x2f30  << 2) + 0xff900000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_reldetlmvfltthd.             flat thd (>=) for lmv lock decision, default = 12
+//Bit 15:14, reserved.
+//Bit 13:12, reg_mcdi_reldetlmvlockchkmode.        lmv lock check mode, 0:cur Lmv, 1: cur & (last | next), 2: last & cur & next Lmv, default = 1
+//Bit    11, reserved.
+//Bit 10: 8, reg_mcdi_reldetlmvdifmin.             min mv dif for lmv dif check, default = 1, note: dif between reg_mcdi_rel_det_lmv_dif_max and reg_mcdi_rel_det_lmv_dif_min should be; 0,1,3,7, not work for others
+//Bit  7: 4, reg_mcdi_reldetlmvdifmax.             max mv dif for lmv dif check, default = 4
+//Bit  3: 1, reserved
+//Bit     0, reg_mcdi_reldetlmvdifmvmode.          mv mode used for lmv dif check, 0: use refmv, 1: use qmv, default = 0
+#define   MCDI_REL_DET_FRQ_CHK                     (0x2f31)
+#define P_MCDI_REL_DET_FRQ_CHK                     (volatile unsigned int *)((0x2f31  << 2) + 0xff900000)
+//Bit 31:12, reserved.
+//Bit 11: 8, reg_mcdi_reldetfrqgain.               gain for frequency check, normalized to 4 as '1', default = 10
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetfrqmax.                max value for frequency check, default = 31
+#define   MCDI_REL_DET_PD22_CHK                    (0x2f32)
+#define P_MCDI_REL_DET_PD22_CHK                    (volatile unsigned int *)((0x2f32  << 2) + 0xff900000)
+//Bit 31:18, reserved.
+//Bit 17: 8, reg_mcdi_reldetpd22chkoffst.          offset for pd22 check happened, default = 512
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetpd22chkgain.           gain for pd22 check happened, normalized to 8 as '1', default = 12
+#define   MCDI_REL_DET_RPT_CHK_ROW                 (0x2f33)
+#define P_MCDI_REL_DET_RPT_CHK_ROW                 (volatile unsigned int *)((0x2f33  << 2) + 0xff900000)
+//Bit 31:27, reserved
+//Bit 26:16, reg_mcdi_reldetrptchkendrow.          end row (<) number for repeat check, default = 2047
+//Bit 15:11, reserved
+//Bit 10: 0, reg_mcdi_reldetrptchkstartrow.        start row (>=) number for repeat check, default = 0
+#define   MCDI_REL_DET_RPT_CHK_GAIN_QMV            (0x2f34)
+#define P_MCDI_REL_DET_RPT_CHK_GAIN_QMV            (volatile unsigned int *)((0x2f34  << 2) + 0xff900000)
+//Bit 31:30, reserved
+//Bit 29:24, reg_mcdi_reldetrptchkqmvmax.          max thd (<) of abs qmv for repeat check, default = 15, note that quarter mv's range is -63~63
+//Bit 23:22, reserved
+//Bit 21:16, reg_mcdi_reldetrptchkqmvmin.          min thd (>=) of abs qmv for repeat check, default = 10, note that quarter mv's range is -63~63
+//Bit    15, reserved/
+//Bit 14: 4, reg_mcdi_reldetrptchkoffst.           offset for repeat check, default = 512
+//Bit  3: 0, reg_mcdi_reldetrptchkgain.            gain for repeat check, normalized to 8 as '1', default = 4
+#define   MCDI_REL_DET_RPT_CHK_THD_0               (0x2f35)
+#define P_MCDI_REL_DET_RPT_CHK_THD_0               (volatile unsigned int *)((0x2f35  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_reldetrptchkzerosadthd.      zero sad thd (<) for repeat check, default = 255
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetrptchkzerobadwthd.     zero badw thd (>=) for repeat check, default = 16
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_reldetrptchkfrqdifthd.       frequency dif thd (<) for repeat check, 0~10, default = 5
+#define   MCDI_REL_DET_RPT_CHK_THD_1               (0x2f36)
+#define P_MCDI_REL_DET_RPT_CHK_THD_1               (volatile unsigned int *)((0x2f36  << 2) + 0xff900000)
+//Bit 31:16, reserved
+//Bit 15: 8, reg_mcdi_reldetrptchkvdifthd.         vertical dif thd (<) for repeat check, default = 16
+//Bit  7: 0, reg_mcdi_reldetrptchkhdifthd.         horizontal dif thd (>=) for repeat check, default = 16
+#define   MCDI_REL_DET_LPF_DIF_THD                 (0x2f37)
+#define P_MCDI_REL_DET_LPF_DIF_THD                 (volatile unsigned int *)((0x2f37  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetlpfdifthd3.            hdif thd (<) for lpf selection of horizontal block, default = 9
+//Bit 23:16, reg_mcdi_reldetlpfdifthd2.            vdif-hdif thd (>=) for lpf selection of horizontal block, default = 48
+//Bit 15: 8, reg_mcdi_reldetlpfdifthd1.            vdif thd (<) for lpf selection of vertical block, default = 9
+//Bit  7: 0, reg_mcdi_reldetlpfdifthd0.            hdif-vdif thd (>=) for lpf selection of vertical block, default = 48
+#define   MCDI_REL_DET_LPF_MSK_00_03               (0x2f38)
+#define P_MCDI_REL_DET_LPF_MSK_00_03               (volatile unsigned int *)((0x2f38  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk03.              det lpf mask03 for gmv/lmv locked mode, 0~16, default = 1
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk02.              det lpf mask02 for gmv/lmv locked mode, 0~16, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk01.              det lpf mask01 for gmv/lmv locked mode, 0~16, default = 5
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk00.              det lpf mask00 for gmv/lmv locked mode, 0~16, default = 8
+#define   MCDI_REL_DET_LPF_MSK_04_12               (0x2f39)
+#define P_MCDI_REL_DET_LPF_MSK_04_12               (volatile unsigned int *)((0x2f39  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk12.              det lpf mask12 for vertical blocks, 0~16, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk11.              det lpf mask11 for vertical blocks, 0~16, default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk10.              det lpf mask10 for vertical blocks, 0~16, default = 16
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk04.              det lpf mask04 for gmv/lmv locked mode, 0~16, default = 1
+#define   MCDI_REL_DET_LPF_MSK_13_21               (0x2f3a)
+#define P_MCDI_REL_DET_LPF_MSK_13_21               (volatile unsigned int *)((0x2f3a  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk21.              det lpf mask21 for horizontal blocks, 0~16, default = 6
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk20.              det lpf mask20 for horizontal blocks, 0~16, default = 8
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk14.              det lpf mask14 for vertical blocks, 0~16, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk13.              det lpf mask13 for vertical blocks, 0~16, default = 0
+#define   MCDI_REL_DET_LPF_MSK_22_30               (0x2f3b)
+#define P_MCDI_REL_DET_LPF_MSK_22_30               (volatile unsigned int *)((0x2f3b  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk30.              det lpf mask30 for other blocks, 0~16, default = 16
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk24.              det lpf mask24 for horizontal blocks, 0~16, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk23.              det lpf mask23 for horizontal blocks, 0~16, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk22.              det lpf mask22 for horizontal blocks, 0~16, default = 1
+#define   MCDI_REL_DET_LPF_MSK_31_34               (0x2f3c)
+#define P_MCDI_REL_DET_LPF_MSK_31_34               (volatile unsigned int *)((0x2f3c  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk34.              det lpf mask34 for other blocks, 0~16, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk33.              det lpf mask33 for other blocks, 0~16, default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk32.              det lpf mask32 for other blocks, 0~16, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk31.              det lpf mask31 for other blocks, 0~16, default = 0
+//Note: there are four group lpf masks from addr 37~3b, each group sum equal to 16.
+#define   MCDI_REL_DET_MIN                         (0x2f3d)
+#define P_MCDI_REL_DET_MIN                         (volatile unsigned int *)((0x2f3d  << 2) + 0xff900000)
+//Bit 31: 7, reserved
+//Bit  6: 0, reg_mcdi_reldetmin.                   min of detected value, default = 16
+#define   MCDI_REL_DET_LUT_0_3                     (0x2f3e)
+#define P_MCDI_REL_DET_LUT_0_3                     (volatile unsigned int *)((0x2f3e  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetmaplut3.               default = 8
+//Bit 23:16, reg_mcdi_reldetmaplut2.               default = 4
+//Bit 15: 8, reg_mcdi_reldetmaplut1.               default = 2
+//Bit  7: 0, reg_mcdi_reldetmaplut0.               default = 0
+#define   MCDI_REL_DET_LUT_4_7                     (0x2f3f)
+#define P_MCDI_REL_DET_LUT_4_7                     (volatile unsigned int *)((0x2f3f  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetmaplut7.               default = 64
+//Bit 23:16, reg_mcdi_reldetmaplut6.               default = 48
+//Bit 15: 8, reg_mcdi_reldetmaplut5.               default = 32
+//Bit  7: 0, reg_mcdi_reldetmaplut4.               default = 16
+#define   MCDI_REL_DET_LUT_8_11                    (0x2f40)
+#define P_MCDI_REL_DET_LUT_8_11                    (volatile unsigned int *)((0x2f40  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetmaplut11.              default = 160
+//Bit 23:16, reg_mcdi_reldetmaplut10.              default = 128
+//Bit 15: 8, reg_mcdi_reldetmaplut9.               default = 96
+//Bit  7: 0, reg_mcdi_reldetmaplut8.               default = 80
+#define   MCDI_REL_DET_LUT_12_15                   (0x2f41)
+#define P_MCDI_REL_DET_LUT_12_15                   (volatile unsigned int *)((0x2f41  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetmaplut15.              default = 255
+//Bit 23:16, reg_mcdi_reldetmaplut14.              default = 240
+//Bit 15: 8, reg_mcdi_reldetmaplut13.              default = 224
+//Bit  7: 0, reg_mcdi_reldetmaplut12.              default = 192
+#define   MCDI_REL_DET_COL_CFD_THD                 (0x2f42)
+#define P_MCDI_REL_DET_COL_CFD_THD                 (volatile unsigned int *)((0x2f42  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetcolcfdfltthd.          thd for flat smaller than (<) of column cofidence, default = 5
+//Bit 23:16, reg_mcdi_reldetcolcfdthd1.            thd for rel larger than (>=) in rel calc. mode col confidence without gmv locking, default = 160
+//Bit 15: 8, reg_mcdi_reldetcolcfdthd0.            thd for rel larger than (>=) in rel calc. mode col confidence when gmv locked, default = 100
+//Bit  7: 2, reg_mcdi_reldetcolcfdbadwthd.         thd for badw larger than (>=) in qbadw calc. mode of column cofidence, default = 16
+//Bit     1, reserved
+//Bit     0, reg_mcdi_reldetcolcfdcalcmode.        calc. mode for column cofidence, 0: use rel, 1: use qbadw, default = 0
+#define   MCDI_REL_DET_COL_CFD_AVG_LUMA            (0x2f43)
+#define P_MCDI_REL_DET_COL_CFD_AVG_LUMA            (volatile unsigned int *)((0x2f43  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_reldetcolcfdavgmin1.         avg luma min1 (>=) for column cofidence, valid between 16~235, default = 235
+//Bit 23:16, reg_mcdi_reldetcolcfdavgmax1.         avg luma max1 (<)  for column cofidence, valid between 16~235, default = 235
+//Bit 15: 8, reg_mcdi_reldetcolcfdavgmin0.         avg luma min0 (>=) for column cofidence, valid between 16~235, default = 16
+//Bit  7: 0, reg_mcdi_reldetcolcfdavgmax0.         avg luma max0 (<)  for column cofidence, valid between 16~235, default = 21
+#define   MCDI_REL_DET_BAD_THD_0                   (0x2f44)
+#define P_MCDI_REL_DET_BAD_THD_0                   (volatile unsigned int *)((0x2f44  << 2) + 0xff900000)
+//Bit 31:16, reserved
+//Bit 15: 8, reg_mcdi_reldetbadsadthd.             thd (>=) for bad sad, default = 120 (480/4)
+//Bit  7: 6, reserved
+//Bit  5: 0, reg_mcdi_reldetbadbadwthd.            thd (>=) for bad badw, 0~42, default = 12
+#define   MCDI_REL_DET_BAD_THD_1                   (0x2f45)
+#define P_MCDI_REL_DET_BAD_THD_1                   (volatile unsigned int *)((0x2f45  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_reldetbadrelfltthd.          thd (>=) of flat for bad rel detection, default = 4
+//Bit 15: 8, reg_mcdi_reldetbadrelthd1.            thd (>=) for bad rel without gmv/lmv locked, default = 160
+//Bit  7: 0, reg_mcdi_reldetbadrelthd0.            thd (>=) for bad rel with gmv/lmv locked, default = 120
+#define   MCDI_PD22_CHK_THD                        (0x2f46)
+#define P_MCDI_PD22_CHK_THD                        (volatile unsigned int *)((0x2f46  << 2) + 0xff900000)
+//Bit 31:25, reserved
+//Bit 24:16, reg_mcdi_pd22chksaddifthd.            sad dif thd (>=) for (pd22chksad - qsad) for pd22 check, default = 64
+//Bit 15:14, reserved
+//Bit 13: 8, reg_mcdi_pd22chkqmvthd.               thd (>=) of abs qmv for pd22 check, default = 2
+//Bit  7: 0, reg_mcdi_pd22chkfltthd.               thd (>=) of flat for pd22 check, default = 4
+#define   MCDI_PD22_CHK_GAIN_OFFST_0               (0x2f47)
+#define P_MCDI_PD22_CHK_GAIN_OFFST_0               (volatile unsigned int *)((0x2f47  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_pd22chkedgeoffst0.           offset0 of pd22chkedge from right film22 phase, -128~127, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_pd22chkedgegain0.            gain0 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_pd22chkbadwoffst0.           offset0 of pd22chkbadw from right film22 phase, -8~7, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_pd22chkbadwgain0.            gain0 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 8
+#define   MCDI_PD22_CHK_GAIN_OFFST_1               (0x2f48)
+#define P_MCDI_PD22_CHK_GAIN_OFFST_1               (volatile unsigned int *)((0x2f48  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_pd22chkedgeoffst1.           offset1 of pd22chkedge from right film22 phase, -128~127, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_pd22chkedgegain1.            gain1 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_pd22chkbadwoffst1.           offset1 of pd22chkbadw from right film22 phase, -8~7, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_pd22chkbadwgain1.            gain1 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 12
+#define   MCDI_LMV_LOCK_CNT_THD_GAIN               (0x2f49)
+#define P_MCDI_LMV_LOCK_CNT_THD_GAIN               (volatile unsigned int *)((0x2f49  << 2) + 0xff900000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_lmvlockcntmax.               max lmv lock count number, default = 6
+//Bit 15:12, reg_mcdi_lmvlockcntoffst.             offset for lmv lock count, -8~7, default =  0
+//Bit 11: 8, reg_mcdi_lmvlockcntgain.              gain for lmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_lmvlockcntthd.               lmv count thd (>=) before be locked, 1~31, default = 4
+#define   MCDI_LMV_LOCK_ABS_DIF_THD                (0x2f4a)
+#define P_MCDI_LMV_LOCK_ABS_DIF_THD                (volatile unsigned int *)((0x2f4a  << 2) + 0xff900000)
+//Bit 31:27, reserved
+//Bit 26:24, reg_mcdi_lmvlockdifthd2.              lmv dif thd for third part, before locked, default = 1
+//Bit    23, reserved
+//Bit 22:20, reg_mcdi_lmvlockdifthd1.              lmv dif thd for second part, before locked, default = 1
+//Bit    19, reserved
+//Bit 18:16, reg_mcdi_lmvlockdifthd0.              lmv dif thd for first part, before locked, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_lmvlockabsmax.               max abs (<) of lmv to be locked, default = 24
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_lmvlockabsmin.               min abs (>=) of lmv to be locked, default = 1
+#define   MCDI_LMV_LOCK_ROW                        (0x2f4b)
+#define P_MCDI_LMV_LOCK_ROW                        (volatile unsigned int *)((0x2f4b  << 2) + 0xff900000)
+//Bit 31:27, reserved
+//Bit 26:16, reg_mcdi_lmvlockendrow.               end row (<) for lmv lock, default = 2047
+//Bit 15:11, reserved
+//Bit 10: 0, reg_mcdi_lmvlockstartrow.             start row (>=) for lmv lock, default = 0
+#define   MCDI_LMV_LOCK_RT_MODE                    (0x2f4c)
+#define P_MCDI_LMV_LOCK_RT_MODE                    (volatile unsigned int *)((0x2f4c  << 2) + 0xff900000)
+//Bit 31:27, reserved
+//Bit 26:24, reg_mcdi_lmvlockextmode.              extend lines for lmv lock check, check how many lines for lmv locking, default = 2
+//Bit 23:16, reg_mcdi_lmvlockfltcntrt.             ratio of flt cnt for lock check, normalized 256 as '1', 255 is set to 256, default = 32
+//Bit 15: 8, reg_mcdi_lmvlocklmvcntrt1.            ratio when use non-zero lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 48
+//Bit  7: 0, reg_mcdi_lmvlocklmvcntrt0.            ratio when use max lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 106
+#define   MCDI_GMV_LOCK_CNT_THD_GAIN               (0x2f4d)
+#define P_MCDI_GMV_LOCK_CNT_THD_GAIN               (volatile unsigned int *)((0x2f4d  << 2) + 0xff900000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_gmvlockcntmax.               max gmv lock count number, default = 6
+//Bit 15:12, reg_mcdi_gmvlockcntoffst.             offset for gmv lock count, -8~7, default =  0
+//Bit 11: 8, reg_mcdi_gmvlockcntgain.              gain for gmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_gmvlockcntthd.               gmv count thd (>=) before be locked, 1~31, default = 4
+#define   MCDI_GMV_LOCK_ABS_DIF_THD                (0x2f4e)
+#define P_MCDI_GMV_LOCK_ABS_DIF_THD                (volatile unsigned int *)((0x2f4e  << 2) + 0xff900000)
+//Bit 31:27, reserved
+//Bit 26:24, reg_mcdi_gmvlockdifthd2.              gmv dif thd for third part, before locked, default = 3
+//Bit    23, reserved
+//Bit 22:20, reg_mcdi_gmvlockdifthd1.              gmv dif thd for second part, before locked, default = 2
+//Bit    19, reserved
+//Bit 18:16, reg_mcdi_gmvlockdifthd0.              gmv dif thd for first part, before locked, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_gmvlockabsmax.               max abs of gmv to be locked, default = 15
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_gmvlockabsmin.               min abs of gmv to be locked, default = 1
+#define   MCDI_HIGH_VERT_FRQ_DIF_THD               (0x2f4f)
+#define P_MCDI_HIGH_VERT_FRQ_DIF_THD               (volatile unsigned int *)((0x2f4f  << 2) + 0xff900000)
+//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifthd.     high_vert_frq field average luma dif thd (>=), 3*Blk_Width*Blk_Height, set by software, default = 103680
+#define   MCDI_HIGH_VERT_FRQ_DIF_DIF_THD           (0x2f50)
+#define P_MCDI_HIGH_VERT_FRQ_DIF_DIF_THD           (volatile unsigned int *)((0x2f50  << 2) + 0xff900000)
+//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifdifthd.  high_vert_frq field average luma dif's dif thd (<), 3*Blk_Width*Blk_Height, set by software, default = 103680
+#define   MCDI_HIGH_VERT_FRQ_RT_GAIN               (0x2f51)
+#define P_MCDI_HIGH_VERT_FRQ_RT_GAIN               (volatile unsigned int *)((0x2f51  << 2) + 0xff900000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_highvertfrqcntthd.           high_vert_frq count thd (>=) before locked, 1~31, default = 4
+//Bit 15: 8, reg_mcdi_highvertfrqbadsadrt.         ratio for high_vert_frq bad sad count, normalized 256 as '1', 255 is set to 256, default = 24
+//Bit  7: 0, reg_mcdi_highvertfrqbadbadwrt.        ratio for high_vert_frq badw count, normalized 256 as '1', 255 is set to 256, default = 130
+#define   MCDI_MOTION_PARADOX_THD                  (0x2f52)
+#define P_MCDI_MOTION_PARADOX_THD                  (volatile unsigned int *)((0x2f52  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_motionparadoxcntthd.         motion paradox count thd (>=) before locked, 1~31, default = 4
+//Bit 23:22, reserved
+//Bit 21:16, reg_mcdi_motionparadoxgmvthd.         abs gmv thd (<) of motion paradox, 0~32, note that 32 means invalid gmv, be careful, default = 32
+//Bit 15: 0, reserved
+#define   MCDI_MOTION_PARADOX_RT                   (0x2f53)
+#define P_MCDI_MOTION_PARADOX_RT                   (volatile unsigned int *)((0x2f53  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_motionparadoxbadsadrt.       ratio for field bad sad count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 24
+//Bit 15: 8, reg_mcdi_motionparadoxbadrelrt.       ratio for field bad reliabilty count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 120
+//Bit  7: 0, reg_mcdi_motionparadoxmtnrt.          ratio for field motion count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 218
+#define   MCDI_MOTION_REF_THD                      (0x2f54)
+#define P_MCDI_MOTION_REF_THD                      (volatile unsigned int *)((0x2f54  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:20, reg_mcdi_motionrefoffst.              motion ref additive offset, default = 15
+//Bit 19:16, reg_mcdi_motionrefgain.               motion ref gain, normalized 8 as '1', default = 8
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_motionrefrptmvthd.           abs thd (>=) of rpt mv (0~31, 32 means invalid) for motion ref, default = 1
+//Bit  7: 2, reg_mcdi_motionrefqmvthd.             min thd (>=) of abs qmv for motion ref, note that quarter mv's range is -63~63, default = 2
+//Bit  1: 0, reg_mcdi_motionreflpfmode.            Mv and (8 x repeat flg) 's lpf mode of motion refinement, 0: no lpf, 1: [1 2 1], 2: [1 2 2 2 1], default = 1
+#define   MCDI_REL_COL_REF_RT                      (0x2f55)
+#define P_MCDI_REL_COL_REF_RT                      (volatile unsigned int *)((0x2f55  << 2) + 0xff900000)
+//Bit 31: 8, reserved
+//Bit  7: 0, reg_mcdi_relcolrefrt.                 ratio for column cofidence level against column number, for refinement, default = 135
+#define   MCDI_PD22_CHK_THD_RT                     (0x2f56)
+#define P_MCDI_PD22_CHK_THD_RT                     (volatile unsigned int *)((0x2f56  << 2) + 0xff900000)
+//Bit 31:27, reserved
+//Bit 26:16, reg_mcdi_pd22chkfltcntrt.             ratio for flat count of field pulldown 22 check, normalized 2048 as '1', 2047 is set to 2048, default = 1
+//Bit 15: 8, reg_mcdi_pd22chkcntrt.                ratio of pulldown 22 check count, normalized 256 as '1', 255 is set to 256, default = 100
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_pd22chkcntthd.               thd (>=) for pd22 count before locked, 1~31, default = 4
+#define   MCDI_CHAR_DET_DIF_THD                    (0x2f57)
+#define P_MCDI_CHAR_DET_DIF_THD                    (volatile unsigned int *)((0x2f57  << 2) + 0xff900000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_chardetminmaxdifthd.         thd (>=) for dif between min and max value, default = 64
+//Bit 15: 8, reg_mcdi_chardetmaxdifthd.            thd (<) for dif between max value, default = 17
+//Bit  7: 0, reg_mcdi_chardetmindifthd.            thd (<) for dif between min value, default = 17
+#define   MCDI_CHAR_DET_CNT_THD                    (0x2f58)
+#define P_MCDI_CHAR_DET_CNT_THD                    (volatile unsigned int *)((0x2f58  << 2) + 0xff900000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_chardettotcntthd.            thd (>=) for total count, 0~21, default = 18
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_chardetmaxcntthd.            thd (>=) for max count, 0~21, default = 1
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_chardetmincntthd.            thd (>=) for min count, 0~21, default = 1
+//new add
+#define   MCDI_PD_22_CHK_WND0_X                    (0x2f59)
+#define P_MCDI_PD_22_CHK_WND0_X                    (volatile unsigned int *)((0x2f59  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:16, reg_mcdi_pd22chkwnd0_x1                 u13, x1 for window 0, HSIZE-1, software control, default = 719
+//Bit 15:13, reserved
+//Bit 12: 0, reg_mcdi_pd22chkwnd0_x0                 u13, x0 for window 0, software control, default = 0
+#define   MCDI_PD_22_CHK_WND0_Y                    (0x2f5a)
+#define P_MCDI_PD_22_CHK_WND0_Y                    (volatile unsigned int *)((0x2f5a  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:16, reg_mcdi_pd22chkwnd0_y1                 u13, y1 for window 0  software control, default = 39
+//Bit 15:13, reserved
+//Bit 12: 0, reg_mcdi_pd22chkwnd0_y0                 u13, y0 for window 0, software control, default = 0
+#define   MCDI_PD_22_CHK_WND1_X                    (0x2f5b)
+#define P_MCDI_PD_22_CHK_WND1_X                    (volatile unsigned int *)((0x2f5b  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:16, reg_mcdi_pd22chkwnd1_x1                 u13, x1 for window 1, HSIZE-1, software control, default = 719
+//Bit 15:13, reserved
+//Bit 12: 0, reg_mcdi_pd22chkwnd1_x0                 u13, x0 for window 1, software control, default = 0
+#define   MCDI_PD_22_CHK_WND1_Y                    (0x2f5c)
+#define P_MCDI_PD_22_CHK_WND1_Y                    (volatile unsigned int *)((0x2f5c  << 2) + 0xff900000)
+//Bit 31:29, reserved
+//Bit 28:16, reg_mcdi_pd22chkwnd1_y1                 u13, y1 for window 1  software control, default = 199
+//Bit 15:13, reserved
+//Bit 12: 0, reg_mcdi_pd22chkwnd1_y0                 u13, y0 for window 1, software control, default = 40
+#define   MCDI_PD_22_CHK_FRC_LMV                   (0x2f5d)
+#define P_MCDI_PD_22_CHK_FRC_LMV                   (volatile unsigned int *)((0x2f5d  << 2) + 0xff900000)
+//Bit 31:11, reserved
+//Bit    10, reg_mcdi_pd22chklmvchk2               u1, lmv lock check while force vof for each windows, default = 1
+//Bit     9, reg_mcdi_pd22chklmvchk1               u1, lmv lock check while force vof for each windows, default = 0
+//Bit     8, reg_mcdi_pd22chklmvchk0               u1, lmv lock check while force vof for each windows, default = 0
+//Bit     7, reserved
+//Bit     6, reg_mcdi_pd22chkfrcpd2                u1, force pd flags for each windows, default = 0
+//Bit     5, reg_mcdi_pd22chkfrcpd1                u1, force pd flags for each windows, default = 0
+//Bit     4, reg_mcdi_pd22chkfrcpd0                u1, force pd flags for each windows, default = 0
+//Bit     3, reserved
+//Bit     2, reg_mcdi_pd22chkfrcvof2               u1, force vof flags for each windows, default = 1
+//Bit     1, reg_mcdi_pd22chkfrcvof1               u1, force vof flags for each windows, default = 0
+//Bit     0, reg_mcdi_pd22chkfrcvof0               u1, force vof flags for each windows, default = 0
+#define   MCDI_PD_22_CHK_FLG_CNT                   (0x2f5e)
+#define P_MCDI_PD_22_CHK_FLG_CNT                   (volatile unsigned int *)((0x2f5e  << 2) + 0xff900000)
+//Bit 31:27, reserved.
+//Bit    26, reg_mcdi_pd22chkflg2.                     pull down 22 flag of prevoius one field. initial = 0
+//Bit    25, reg_mcdi_pd22chkflg1.                     pull down 22 flag of prevoius one field. initial = 0
+//Bit    24, reg_mcdi_pd22chkflg.                      pull down 22 flag of prevoius one field. initial = 0
+//Bit 23:16, reg_mcdi_pd22chkcnt2.                     pull down 22 count till prevoius one field. initial = 0
+//Bit 15: 8, reg_mcdi_pd22chkcnt1.                     pull down 22 count till prevoius one field. initial = 0
+//Bit  7: 0, reg_mcdi_pd22chkcnt.                      pull down 22 count till prevoius one field. initial = 0
+#define   MCDI_RO_FLD_PD_22_PRE_CNT1               (0x2fca)
+#define P_MCDI_RO_FLD_PD_22_PRE_CNT1               (volatile unsigned int *)((0x2fca  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22precnt1.              prevoius pd22 check count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_FOR_CNT1               (0x2fcb)
+#define P_MCDI_RO_FLD_PD_22_FOR_CNT1               (volatile unsigned int *)((0x2fcb  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22forcnt1.              forward pd22 check count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_FLT_CNT1               (0x2fcc)
+#define P_MCDI_RO_FLD_PD_22_FLT_CNT1               (volatile unsigned int *)((0x2fcc  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22fltcnt1.              flat count (for pd22 check) of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_PRE_CNT2               (0x2fcd)
+#define P_MCDI_RO_FLD_PD_22_PRE_CNT2               (volatile unsigned int *)((0x2fcd  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22precnt2.              prevoius pd22 check count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_FOR_CNT2               (0x2fce)
+#define P_MCDI_RO_FLD_PD_22_FOR_CNT2               (volatile unsigned int *)((0x2fce  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22forcnt2.              forward pd22 check count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_FLT_CNT2               (0x2fcf)
+#define P_MCDI_RO_FLD_PD_22_FLT_CNT2               (volatile unsigned int *)((0x2fcf  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22fltcnt2.              flat count (for pd22 check) of whole pre one field (block based). initial = 0
+#define   MCDI_FIELD_MV                            (0x2f60)
+#define P_MCDI_FIELD_MV                            (volatile unsigned int *)((0x2f60  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_pd22chkcnt
+//Bit 23:16, reg_mcdi_fieldgmvcnt
+//Bit    15, reg_mcdi_pd22chkflg
+//Bit    14, reg_mcdi_fieldgmvlock
+//Bit 13: 8, reg_mcdi_fieldrptmv.    	           last field rpt mv
+//Bit  7: 6, reserved
+//Bit  5: 0, reg_mcdi_fieldgmv.                    last field gmv
+#define   MCDI_FIELD_HVF_PRDX_CNT                  (0x2f61)
+#define P_MCDI_FIELD_HVF_PRDX_CNT                  (volatile unsigned int *)((0x2f61  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_motionparadoxcnt.
+//Bit 23:17, reserved
+//Bit    16, reg_mcdi_motionparadoxflg.
+//Bit 15: 8, reg_mcdi_highvertfrqcnt.
+//Bit  7: 4, reserved
+//Bit  3: 2, reg_mcdi_highvertfrqphase.
+//Bit     1, reserved
+//Bit     0, reg_mcdi_highvertfrqflg.
+#define   MCDI_FIELD_LUMA_AVG_SUM_0                (0x2f62)
+#define P_MCDI_FIELD_LUMA_AVG_SUM_0                (volatile unsigned int *)((0x2f62  << 2) + 0xff900000)
+//Bit 31: 0, reg_mcdi_fld_luma_avg_sum0.
+#define   MCDI_FIELD_LUMA_AVG_SUM_1                (0x2f63)
+#define P_MCDI_FIELD_LUMA_AVG_SUM_1                (volatile unsigned int *)((0x2f63  << 2) + 0xff900000)
+//Bit 31: 0, reg_mcdi_fld_luma_avg_sum1.
+#define   MCDI_YCBCR_BLEND_CRTL                    (0x2f64)
+#define P_MCDI_YCBCR_BLEND_CRTL                    (volatile unsigned int *)((0x2f64  << 2) + 0xff900000)
+//Bit 31:16, reserved
+//Bit 15: 8, reg_mcdi_ycbcrblendgain.              ycbcr blending gain for cbcr in ycbcr. default = 0
+//Bit  7: 2, reserved.
+//Bit  1: 0, reg_mcdi_ycbcrblendmode.              0:y+cmb(cb,cr), 1:med(r,g,b), 2:max(r,g,b), default = 2
+#define   MCDI_MCVECWR_CANVAS_SIZE                 (0x2f65)
+#define P_MCDI_MCVECWR_CANVAS_SIZE                 (volatile unsigned int *)((0x2f65  << 2) + 0xff900000)
+#define   MCDI_MCVECRD_CANVAS_SIZE                 (0x2f66)
+#define P_MCDI_MCVECRD_CANVAS_SIZE                 (volatile unsigned int *)((0x2f66  << 2) + 0xff900000)
+#define   MCDI_MCINFOWR_CANVAS_SIZE                (0x2f67)
+#define P_MCDI_MCINFOWR_CANVAS_SIZE                (volatile unsigned int *)((0x2f67  << 2) + 0xff900000)
+#define   MCDI_MCINFORD_CANVAS_SIZE                (0x2f68)
+#define P_MCDI_MCINFORD_CANVAS_SIZE                (volatile unsigned int *)((0x2f68  << 2) + 0xff900000)
+#define   MCDI_MCVECWR_X                           (0x2f92)
+#define P_MCDI_MCVECWR_X                           (volatile unsigned int *)((0x2f92  << 2) + 0xff900000)
+#define   MCDI_MCVECWR_Y                           (0x2f93)
+#define P_MCDI_MCVECWR_Y                           (volatile unsigned int *)((0x2f93  << 2) + 0xff900000)
+#define   MCDI_MCVECWR_CTRL                        (0x2f94)
+#define P_MCDI_MCVECWR_CTRL                        (volatile unsigned int *)((0x2f94  << 2) + 0xff900000)
+#define   MCDI_MCVECRD_X                           (0x2f95)
+#define P_MCDI_MCVECRD_X                           (volatile unsigned int *)((0x2f95  << 2) + 0xff900000)
+#define   MCDI_MCVECRD_Y                           (0x2f96)
+#define P_MCDI_MCVECRD_Y                           (volatile unsigned int *)((0x2f96  << 2) + 0xff900000)
+#define   MCDI_MCVECRD_CTRL                        (0x2f97)
+#define P_MCDI_MCVECRD_CTRL                        (volatile unsigned int *)((0x2f97  << 2) + 0xff900000)
+#define   MCDI_MCINFOWR_X                          (0x2f98)
+#define P_MCDI_MCINFOWR_X                          (volatile unsigned int *)((0x2f98  << 2) + 0xff900000)
+#define   MCDI_MCINFOWR_Y                          (0x2f99)
+#define P_MCDI_MCINFOWR_Y                          (volatile unsigned int *)((0x2f99  << 2) + 0xff900000)
+#define   MCDI_MCINFOWR_CTRL                       (0x2f9a)
+#define P_MCDI_MCINFOWR_CTRL                       (volatile unsigned int *)((0x2f9a  << 2) + 0xff900000)
+#define   MCDI_MCINFORD_X                          (0x2f9b)
+#define P_MCDI_MCINFORD_X                          (volatile unsigned int *)((0x2f9b  << 2) + 0xff900000)
+#define   MCDI_MCINFORD_Y                          (0x2f9c)
+#define P_MCDI_MCINFORD_Y                          (volatile unsigned int *)((0x2f9c  << 2) + 0xff900000)
+#define   MCDI_MCINFORD_CTRL                       (0x2f9d)
+#define P_MCDI_MCINFORD_CTRL                       (volatile unsigned int *)((0x2f9d  << 2) + 0xff900000)
+// ================================================================== MC registers ========================================================================================================
+#define   MCDI_MC_CRTL                             (0x2f70)
+#define P_MCDI_MC_CRTL                             (volatile unsigned int *)((0x2f70  << 2) + 0xff900000)
+//Bit 31: 9, reserved
+//Bit     8, reg_mcdi_mcpreflg.                    flag to use previous field for MC, 0:forward field, 1: previous field, default = 1
+//Bit     7, reg_mcdi_mcrelrefbycolcfden.          enable rel refinement by column cofidence in mc blending, default = 1
+//Bit  6: 5, reg_mcdi_mclpfen.                     enable mc pixles/rel lpf, 0:disable, 1: lpf rel, 2: lpf mc pxls, 3: lpf both rel and mc pxls, default = 0
+//Bit  4: 2, reg_mcdi_mcdebugmode.                 enable mc debug mode, 0:disable, 1: split left/right, 2: split top/bottom, 3: debug mv, 4: debug rel, default = 0
+//Bit  1: 0, reg_mcdi_mcen.                        mcdi enable mode, 0:disable, 1: blend with ma, 2: full mc, default = 1
+#define   MCDI_MC_LPF_MSK_0                        (0x2f71)
+#define P_MCDI_MC_LPF_MSK_0                        (volatile unsigned int *)((0x2f71  << 2) + 0xff900000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk02.                  mc lpf coef. 2 for pixel 0 of current block, normalized 16 as '1', default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk01.                  mc lpf coef. 1 for pixel 0 of current block, normalized 16 as '1', default = 9
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk00.                  mc lpf coef. 0 for pixel 0 of current block, normalized 16 as '1', default = 7
+#define   MCDI_MC_LPF_MSK_1                        (0x2f72)
+#define P_MCDI_MC_LPF_MSK_1                        (volatile unsigned int *)((0x2f72  << 2) + 0xff900000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk12.                  mc lpf coef. 2 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk11.                  mc lpf coef. 1 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 11
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk10.                  mc lpf coef. 0 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 5
+#define   MCDI_MC_LPF_MSK_2                        (0x2f73)
+#define P_MCDI_MC_LPF_MSK_2                        (volatile unsigned int *)((0x2f73  << 2) + 0xff900000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk22.                  mc lpf coef. 2 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk21.                  mc lpf coef. 1 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 14
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk20.                  mc lpf coef. 0 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
+#define   MCDI_MC_LPF_MSK_3                        (0x2f74)
+#define P_MCDI_MC_LPF_MSK_3                        (volatile unsigned int *)((0x2f74  << 2) + 0xff900000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk32.                  mc lpf coef. 2 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 5
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk31.                  mc lpf coef. 1 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 11
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk30.                  mc lpf coef. 0 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 0
+#define   MCDI_MC_LPF_MSK_4                        (0x2f75)
+#define P_MCDI_MC_LPF_MSK_4                        (volatile unsigned int *)((0x2f75  << 2) + 0xff900000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk42.                  mc lpf coef. 2 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 7
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk41.                  mc lpf coef. 1 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 9
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk40.                  mc lpf coef. 0 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 0
+#define   MCDI_MC_REL_GAIN_OFFST_0                 (0x2f76)
+#define P_MCDI_MC_REL_GAIN_OFFST_0                 (volatile unsigned int *)((0x2f76  << 2) + 0xff900000)
+//Bit 31:26, reserved
+//Bit    25, reg_mcdi_mcmotionparadoxflg.          flag of motion paradox, initial with 0 and read from software, default = 0
+//Bit    24, reg_mcdi_mchighvertfrqflg.            flag of high vert frq, initial with 0 and read from software, default = 0
+//Bit 23:16, reg_mcdi_mcmotionparadoxoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 128
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_mcmotionparadoxgain.         gain for rel (MC blending coef.) refinement if motion paradox detected before MC blending, normalized 8 as '1', set 15 to 16, default = 8
+//Bit  7: 4, reg_mcdi_mchighvertfrqoffst.          minus offset (alpha - offset) for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, default = 15
+//Bit  3: 0, reg_mcdi_mchighvertfrqgain.           gain for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, normalized 8 as '1', set 15 to 16, default = 8
+#define   MCDI_MC_REL_GAIN_OFFST_1                 (0x2f77)
+#define P_MCDI_MC_REL_GAIN_OFFST_1                 (volatile unsigned int *)((0x2f77  << 2) + 0xff900000)
+//Bit 31:24, reg_mcdi_mcoutofboundrayoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending before MC blending, default = 255
+//Bit 23:20, reserved
+//Bit 19:16, reg_mcdi_mcoutofboundraygain.         gain for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending, normalized 8 as '1', set 15 to 16, default = 8
+//Bit 15: 8, reg_mcdi_mcrelrefbycolcfdoffst.       offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 255
+//Bit  7: 4, reserved.
+//Bit  3: 0, reg_mcdi_mcrelrefbycolcfdgain.        gain for rel (MC blending coef.) refinement if column cofidence failed before MC blending, normalized 8 as '1', set 15 to 16, default = 8
+#define   MCDI_MC_COL_CFD_0                        (0x2f78)
+#define P_MCDI_MC_COL_CFD_0                        (volatile unsigned int *)((0x2f78  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_0.                    column cofidence value 0 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_1                        (0x2f79)
+#define P_MCDI_MC_COL_CFD_1                        (volatile unsigned int *)((0x2f79  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_1.                    column cofidence value 1 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_2                        (0x2f7a)
+#define P_MCDI_MC_COL_CFD_2                        (volatile unsigned int *)((0x2f7a  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_2.                    column cofidence value 2 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_3                        (0x2f7b)
+#define P_MCDI_MC_COL_CFD_3                        (volatile unsigned int *)((0x2f7b  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_3.                    column cofidence value 3 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_4                        (0x2f7c)
+#define P_MCDI_MC_COL_CFD_4                        (volatile unsigned int *)((0x2f7c  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_4.                    column cofidence value 4 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_5                        (0x2f7d)
+#define P_MCDI_MC_COL_CFD_5                        (volatile unsigned int *)((0x2f7d  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_5.                    column cofidence value 5 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_6                        (0x2f7e)
+#define P_MCDI_MC_COL_CFD_6                        (volatile unsigned int *)((0x2f7e  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_6.                    column cofidence value 6 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_7                        (0x2f7f)
+#define P_MCDI_MC_COL_CFD_7                        (volatile unsigned int *)((0x2f7f  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_7.                    column cofidence value 7 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_8                        (0x2f80)
+#define P_MCDI_MC_COL_CFD_8                        (volatile unsigned int *)((0x2f80  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_8.                    column cofidence value 8 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_9                        (0x2f81)
+#define P_MCDI_MC_COL_CFD_9                        (volatile unsigned int *)((0x2f81  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_9.                    column cofidence value 9 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_10                       (0x2f82)
+#define P_MCDI_MC_COL_CFD_10                       (volatile unsigned int *)((0x2f82  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_10.                   column cofidence value 10 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_11                       (0x2f83)
+#define P_MCDI_MC_COL_CFD_11                       (volatile unsigned int *)((0x2f83  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_11.                   column cofidence value 11 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_12                       (0x2f84)
+#define P_MCDI_MC_COL_CFD_12                       (volatile unsigned int *)((0x2f84  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_12.                   column cofidence value 12 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_13                       (0x2f85)
+#define P_MCDI_MC_COL_CFD_13                       (volatile unsigned int *)((0x2f85  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_13.                   column cofidence value 13 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_14                       (0x2f86)
+#define P_MCDI_MC_COL_CFD_14                       (volatile unsigned int *)((0x2f86  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_14.                   column cofidence value 14 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_15                       (0x2f87)
+#define P_MCDI_MC_COL_CFD_15                       (volatile unsigned int *)((0x2f87  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_15.                   column cofidence value 15 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_16                       (0x2f88)
+#define P_MCDI_MC_COL_CFD_16                       (volatile unsigned int *)((0x2f88  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_16.                   column cofidence value 16 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_17                       (0x2f89)
+#define P_MCDI_MC_COL_CFD_17                       (volatile unsigned int *)((0x2f89  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_17.                   column cofidence value 17 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_18                       (0x2f8a)
+#define P_MCDI_MC_COL_CFD_18                       (volatile unsigned int *)((0x2f8a  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_18.                   column cofidence value 18 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_19                       (0x2f8b)
+#define P_MCDI_MC_COL_CFD_19                       (volatile unsigned int *)((0x2f8b  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_19.                   column cofidence value 19 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_20                       (0x2f8c)
+#define P_MCDI_MC_COL_CFD_20                       (volatile unsigned int *)((0x2f8c  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_20.                   column cofidence value 20 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_21                       (0x2f8d)
+#define P_MCDI_MC_COL_CFD_21                       (volatile unsigned int *)((0x2f8d  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_21.                   column cofidence value 21 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_22                       (0x2f8e)
+#define P_MCDI_MC_COL_CFD_22                       (volatile unsigned int *)((0x2f8e  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_22.                   column cofidence value 22 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_23                       (0x2f8f)
+#define P_MCDI_MC_COL_CFD_23                       (volatile unsigned int *)((0x2f8f  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_23.                   column cofidence value 23 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_24                       (0x2f90)
+#define P_MCDI_MC_COL_CFD_24                       (volatile unsigned int *)((0x2f90  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_24.                   column cofidence value 24 read from software. initial = 0
+#define   MCDI_MC_COL_CFD_25                       (0x2f91)
+#define P_MCDI_MC_COL_CFD_25                       (volatile unsigned int *)((0x2f91  << 2) + 0xff900000)
+//Bit 31: 0, mcdi_mc_col_cfd_25.                   column cofidence value 25 read from software. initial = 0
+// ===================================================================================== PRE RO Registers ==========================================================================================
+#define   MCDI_RO_FLD_LUMA_AVG_SUM                 (0x2fa0)
+#define P_MCDI_RO_FLD_LUMA_AVG_SUM                 (volatile unsigned int *)((0x2fa0  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldlumaavgsum.                block's luma avg sum of current filed (block based). initial = 0
+#define   MCDI_RO_GMV_VLD_CNT                      (0x2fa1)
+#define P_MCDI_RO_GMV_VLD_CNT                      (volatile unsigned int *)((0x2fa1  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_gmvvldcnt.                    valid gmv's count of pre one filed (block based). initial = 0
+#define   MCDI_RO_RPT_FLG_CNT                      (0x2fa2)
+#define P_MCDI_RO_RPT_FLG_CNT                      (volatile unsigned int *)((0x2fa2  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_rptflgcnt.                    repeat mv's count of pre one filed (block based). initial = 0
+#define   MCDI_RO_FLD_BAD_SAD_CNT                  (0x2fa3)
+#define P_MCDI_RO_FLD_BAD_SAD_CNT                  (volatile unsigned int *)((0x2fa3  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldbadsadcnt.                 bad sad count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_BAD_BADW_CNT                 (0x2fa4)
+#define P_MCDI_RO_FLD_BAD_BADW_CNT                 (volatile unsigned int *)((0x2fa4  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldbadbadwcnt.                bad badw count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_BAD_REL_CNT                  (0x2fa5)
+#define P_MCDI_RO_FLD_BAD_REL_CNT                  (volatile unsigned int *)((0x2fa5  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldbadrelcnt.                 bad rel count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_MTN_CNT                      (0x2fa6)
+#define P_MCDI_RO_FLD_MTN_CNT                      (volatile unsigned int *)((0x2fa6  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldmtncnt.                    motion count of whole pre one field (pixel based). initial = 0
+#define   MCDI_RO_FLD_VLD_CNT                      (0x2fa7)
+#define P_MCDI_RO_FLD_VLD_CNT                      (volatile unsigned int *)((0x2fa7  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldvldcnt.                    valid motion count of whole pre one field (pixel based). initial = 0
+#define   MCDI_RO_FLD_PD_22_PRE_CNT                (0x2fa8)
+#define P_MCDI_RO_FLD_PD_22_PRE_CNT                (volatile unsigned int *)((0x2fa8  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22precnt.                prevoius pd22 check count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_FOR_CNT                (0x2fa9)
+#define P_MCDI_RO_FLD_PD_22_FOR_CNT                (volatile unsigned int *)((0x2fa9  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22forcnt.                forward pd22 check count of whole pre one field (block based). initial = 0
+#define   MCDI_RO_FLD_PD_22_FLT_CNT                (0x2faa)
+#define P_MCDI_RO_FLD_PD_22_FLT_CNT                (volatile unsigned int *)((0x2faa  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_fldpd22fltcnt.                flat count (for pd22 check) of whole pre one field (block based). initial = 0
+#define   MCDI_RO_HIGH_VERT_FRQ_FLG                (0x2fab)
+#define P_MCDI_RO_HIGH_VERT_FRQ_FLG                (volatile unsigned int *)((0x2fab  << 2) + 0xff900000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_highvertfrqcnt.               high vertical frequency count till prevoius one field. initial = 0
+//Bit  7: 3, reserved.
+//Bit  2: 1, ro_mcdi_highvertfrqphase.             high vertical frequency phase of prevoius one field. initial = 2
+//Bit     0, ro_mcdi_highvertfrqflg.               high vertical frequency flag of prevoius one field. initial = 0
+#define   MCDI_RO_GMV_LOCK_FLG                     (0x2fac)
+#define P_MCDI_RO_GMV_LOCK_FLG                     (volatile unsigned int *)((0x2fac  << 2) + 0xff900000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_gmvlckcnt.                    global mv lock count till prevoius one field. initial = 0
+//Bit  7: 2, ro_mcdi_gmv.                          global mv of prevoius one field. -31~31, initial = 32 (invalid value)
+//Bit     1, ro_mcdi_zerogmvlckflg.                zero global mv lock flag of prevoius one field. initial = 0
+//Bit     0, ro_mcdi_gmvlckflg.                    global mv lock flag of prevoius one field. initial = 0
+#define   MCDI_RO_RPT_MV                           (0x2fad)
+#define P_MCDI_RO_RPT_MV                           (volatile unsigned int *)((0x2fad  << 2) + 0xff900000)
+//Bit 5: 0, ro_mcdi_rptmv.                         repeate mv of prevoius one field. -31~31, initial = 32 (invalid value)
+#define   MCDI_RO_MOTION_PARADOX_FLG               (0x2fae)
+#define P_MCDI_RO_MOTION_PARADOX_FLG               (volatile unsigned int *)((0x2fae  << 2) + 0xff900000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_motionparadoxcnt.             motion paradox count till prevoius one field. initial = 0
+//Bit  7: 1, reserved.
+//Bit     0, ro_mcdi_motionparadoxflg.             motion paradox flag of prevoius one field. initial = 0
+#define   MCDI_RO_PD_22_FLG                        (0x2faf)
+#define P_MCDI_RO_PD_22_FLG                        (volatile unsigned int *)((0x2faf  << 2) + 0xff900000)
+//Bit 31:27, reserved.
+//Bit    26, ro_mcdi_pd22flg2.                     pull down 22 flag of prevoius one field. initial = 0
+//Bit    25, ro_mcdi_pd22flg1.                     pull down 22 flag of prevoius one field. initial = 0
+//Bit    24, ro_mcdi_pd22flg.                      pull down 22 flag of prevoius one field. initial = 0
+//Bit 23:16, ro_mcdi_pd22cnt2.                     pull down 22 count till prevoius one field. initial = 0
+//Bit 15: 8, ro_mcdi_pd22cnt1.                     pull down 22 count till prevoius one field. initial = 0
+//Bit  7: 0, ro_mcdi_pd22cnt.                      pull down 22 count till prevoius one field. initial = 0
+#define   MCDI_RO_COL_CFD_0                        (0x2fb0)
+#define P_MCDI_RO_COL_CFD_0                        (volatile unsigned int *)((0x2fb0  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_0.                    column cofidence value 0. initial = 0
+#define   MCDI_RO_COL_CFD_1                        (0x2fb1)
+#define P_MCDI_RO_COL_CFD_1                        (volatile unsigned int *)((0x2fb1  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_1.                    column cofidence value 1. initial = 0
+#define   MCDI_RO_COL_CFD_2                        (0x2fb2)
+#define P_MCDI_RO_COL_CFD_2                        (volatile unsigned int *)((0x2fb2  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_2.                    column cofidence value 2. initial = 0
+#define   MCDI_RO_COL_CFD_3                        (0x2fb3)
+#define P_MCDI_RO_COL_CFD_3                        (volatile unsigned int *)((0x2fb3  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_3.                    column cofidence value 3. initial = 0
+#define   MCDI_RO_COL_CFD_4                        (0x2fb4)
+#define P_MCDI_RO_COL_CFD_4                        (volatile unsigned int *)((0x2fb4  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_4.                    column cofidence value 4. initial = 0
+#define   MCDI_RO_COL_CFD_5                        (0x2fb5)
+#define P_MCDI_RO_COL_CFD_5                        (volatile unsigned int *)((0x2fb5  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_5.                    column cofidence value 5. initial = 0
+#define   MCDI_RO_COL_CFD_6                        (0x2fb6)
+#define P_MCDI_RO_COL_CFD_6                        (volatile unsigned int *)((0x2fb6  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_6.                    column cofidence value 6. initial = 0
+#define   MCDI_RO_COL_CFD_7                        (0x2fb7)
+#define P_MCDI_RO_COL_CFD_7                        (volatile unsigned int *)((0x2fb7  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_7.                    column cofidence value 7. initial = 0
+#define   MCDI_RO_COL_CFD_8                        (0x2fb8)
+#define P_MCDI_RO_COL_CFD_8                        (volatile unsigned int *)((0x2fb8  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_8.                    column cofidence value 8. initial = 0
+#define   MCDI_RO_COL_CFD_9                        (0x2fb9)
+#define P_MCDI_RO_COL_CFD_9                        (volatile unsigned int *)((0x2fb9  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_9.                    column cofidence value 9. initial = 0
+#define   MCDI_RO_COL_CFD_10                       (0x2fba)
+#define P_MCDI_RO_COL_CFD_10                       (volatile unsigned int *)((0x2fba  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_10.                   column cofidence value 10. initial = 0
+#define   MCDI_RO_COL_CFD_11                       (0x2fbb)
+#define P_MCDI_RO_COL_CFD_11                       (volatile unsigned int *)((0x2fbb  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_11.                   column cofidence value 11. initial = 0
+#define   MCDI_RO_COL_CFD_12                       (0x2fbc)
+#define P_MCDI_RO_COL_CFD_12                       (volatile unsigned int *)((0x2fbc  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_12.                   column cofidence value 12. initial = 0
+#define   MCDI_RO_COL_CFD_13                       (0x2fbd)
+#define P_MCDI_RO_COL_CFD_13                       (volatile unsigned int *)((0x2fbd  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_13.                   column cofidence value 13. initial = 0
+#define   MCDI_RO_COL_CFD_14                       (0x2fbe)
+#define P_MCDI_RO_COL_CFD_14                       (volatile unsigned int *)((0x2fbe  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_14.                   column cofidence value 14. initial = 0
+#define   MCDI_RO_COL_CFD_15                       (0x2fbf)
+#define P_MCDI_RO_COL_CFD_15                       (volatile unsigned int *)((0x2fbf  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_15.                   column cofidence value 15. initial = 0
+#define   MCDI_RO_COL_CFD_16                       (0x2fc0)
+#define P_MCDI_RO_COL_CFD_16                       (volatile unsigned int *)((0x2fc0  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_16.                   column cofidence value 16. initial = 0
+#define   MCDI_RO_COL_CFD_17                       (0x2fc1)
+#define P_MCDI_RO_COL_CFD_17                       (volatile unsigned int *)((0x2fc1  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_17.                   column cofidence value 17. initial = 0
+#define   MCDI_RO_COL_CFD_18                       (0x2fc2)
+#define P_MCDI_RO_COL_CFD_18                       (volatile unsigned int *)((0x2fc2  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_18.                   column cofidence value 18. initial = 0
+#define   MCDI_RO_COL_CFD_19                       (0x2fc3)
+#define P_MCDI_RO_COL_CFD_19                       (volatile unsigned int *)((0x2fc3  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_19.                   column cofidence value 19. initial = 0
+#define   MCDI_RO_COL_CFD_20                       (0x2fc4)
+#define P_MCDI_RO_COL_CFD_20                       (volatile unsigned int *)((0x2fc4  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_20.                   column cofidence value 20. initial = 0
+#define   MCDI_RO_COL_CFD_21                       (0x2fc5)
+#define P_MCDI_RO_COL_CFD_21                       (volatile unsigned int *)((0x2fc5  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_21.                   column cofidence value 21. initial = 0
+#define   MCDI_RO_COL_CFD_22                       (0x2fc6)
+#define P_MCDI_RO_COL_CFD_22                       (volatile unsigned int *)((0x2fc6  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_22.                   column cofidence value 22. initial = 0
+#define   MCDI_RO_COL_CFD_23                       (0x2fc7)
+#define P_MCDI_RO_COL_CFD_23                       (volatile unsigned int *)((0x2fc7  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_23.                   column cofidence value 23. initial = 0
+#define   MCDI_RO_COL_CFD_24                       (0x2fc8)
+#define P_MCDI_RO_COL_CFD_24                       (volatile unsigned int *)((0x2fc8  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_24.                   column cofidence value 24. initial = 0
+#define   MCDI_RO_COL_CFD_25                       (0x2fc9)
+#define P_MCDI_RO_COL_CFD_25                       (volatile unsigned int *)((0x2fc9  << 2) + 0xff900000)
+//Bit 31: 0, ro_mcdi_col_cfd_25.                   column cofidence value 25. initial = 0
+// add space 8'hd0-8'hef
+//
+// Reading file:  dipd_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// using 8'he0-8'hef
+#define   DIPD_COMB_CTRL0                          (0x2fd0)
+#define P_DIPD_COMB_CTRL0                          (volatile unsigned int *)((0x2fd0  << 2) + 0xff900000)
+//Bit 31:0,								reg_pd_comb_ctrl0
+#define   DIPD_COMB_CTRL1                          (0x2fd1)
+#define P_DIPD_COMB_CTRL1                          (volatile unsigned int *)((0x2fd1  << 2) + 0xff900000)
+//Bit 31:0,								reg_pd_comb_ctrl1
+#define   DIPD_COMB_CTRL2                          (0x2fd2)
+#define P_DIPD_COMB_CTRL2                          (volatile unsigned int *)((0x2fd2  << 2) + 0xff900000)
+//Bit 31:0,								reg_pd_comb_ctrl2
+#define   DIPD_COMB_CTRL3                          (0x2fd3)
+#define P_DIPD_COMB_CTRL3                          (volatile unsigned int *)((0x2fd3  << 2) + 0xff900000)
+//Bit 31:0,								reg_pd_comb_ctrl3
+#define   DIPD_COMB_CTRL4                          (0x2fd4)
+#define P_DIPD_COMB_CTRL4                          (volatile unsigned int *)((0x2fd4  << 2) + 0xff900000)
+//Bit 31:0,								reg_pd_comb_ctrl4
+#define   DIPD_COMB_CTRL5                          (0x2fd5)
+#define P_DIPD_COMB_CTRL5                          (volatile unsigned int *)((0x2fd5  << 2) + 0xff900000)
+//Bit 31:0,								reg_pd_comb_ctrl5
+#define   DIPD_RO_COMB_0                           (0x2fd6)
+#define P_DIPD_RO_COMB_0                           (volatile unsigned int *)((0x2fd6  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_0
+#define   DIPD_RO_COMB_1                           (0x2fd7)
+#define P_DIPD_RO_COMB_1                           (volatile unsigned int *)((0x2fd7  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_1
+#define   DIPD_RO_COMB_2                           (0x2fd8)
+#define P_DIPD_RO_COMB_2                           (volatile unsigned int *)((0x2fd8  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_2
+#define   DIPD_RO_COMB_3                           (0x2fd9)
+#define P_DIPD_RO_COMB_3                           (volatile unsigned int *)((0x2fd9  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_3
+#define   DIPD_RO_COMB_4                           (0x2fda)
+#define P_DIPD_RO_COMB_4                           (volatile unsigned int *)((0x2fda  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_4
+#define   DIPD_RO_COMB_5                           (0x2fdb)
+#define P_DIPD_RO_COMB_5                           (volatile unsigned int *)((0x2fdb  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_5
+#define   DIPD_RO_COMB_6                           (0x2fdc)
+#define P_DIPD_RO_COMB_6                           (volatile unsigned int *)((0x2fdc  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_6
+#define   DIPD_RO_COMB_7                           (0x2fdd)
+#define P_DIPD_RO_COMB_7                           (volatile unsigned int *)((0x2fdd  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_7
+#define   DIPD_RO_COMB_8                           (0x2fde)
+#define P_DIPD_RO_COMB_8                           (volatile unsigned int *)((0x2fde  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_8
+#define   DIPD_RO_COMB_9                           (0x2fdf)
+#define P_DIPD_RO_COMB_9                           (volatile unsigned int *)((0x2fdf  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_9
+#define   DIPD_RO_COMB_10                          (0x2fe0)
+#define P_DIPD_RO_COMB_10                          (volatile unsigned int *)((0x2fe0  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_10
+#define   DIPD_RO_COMB_11                          (0x2fe1)
+#define P_DIPD_RO_COMB_11                          (volatile unsigned int *)((0x2fe1  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_11
+#define   DIPD_RO_COMB_12                          (0x2fe2)
+#define P_DIPD_RO_COMB_12                          (volatile unsigned int *)((0x2fe2  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_12
+#define   DIPD_RO_COMB_13                          (0x2fe3)
+#define P_DIPD_RO_COMB_13                          (volatile unsigned int *)((0x2fe3  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_13
+#define   DIPD_RO_COMB_14                          (0x2fe4)
+#define P_DIPD_RO_COMB_14                          (volatile unsigned int *)((0x2fe4  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_14
+#define   DIPD_RO_COMB_15                          (0x2fe5)
+#define P_DIPD_RO_COMB_15                          (volatile unsigned int *)((0x2fe5  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_15
+#define   DIPD_RO_COMB_16                          (0x2fe6)
+#define P_DIPD_RO_COMB_16                          (volatile unsigned int *)((0x2fe6  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_16
+#define   DIPD_RO_COMB_17                          (0x2fe7)
+#define P_DIPD_RO_COMB_17                          (volatile unsigned int *)((0x2fe7  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_17
+#define   DIPD_RO_COMB_18                          (0x2fe8)
+#define P_DIPD_RO_COMB_18                          (volatile unsigned int *)((0x2fe8  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_18
+#define   DIPD_RO_COMB_19                          (0x2fe9)
+#define P_DIPD_RO_COMB_19                          (volatile unsigned int *)((0x2fe9  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_19
+#define   DIPD_RO_COMB_20                          (0x2fea)
+#define P_DIPD_RO_COMB_20                          (volatile unsigned int *)((0x2fea  << 2) + 0xff900000)
+//Bit 31:0,								ro_pd_comb_20
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dipd_regs.h
+//
+// addr space 8'hf0-8'hff
+//
+// Reading file:  nr3_tnr_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   NR3_MODE                                 (0x2ff0)
+#define P_NR3_MODE                                 (volatile unsigned int *)((0x2ff0  << 2) + 0xff900000)
+//Bit 31: 6        reserved
+//Bit  5           reg_nr3_vtxt_mode         // unsigned , default = 0  0: avg; 1:MAX
+//Bit  4           reg_3dnr_nr3_cbyy_ignor_coop    // unsigned , default = 0  ignore coop condition for cbyy motion decision
+//Bit  3           reg_3dnr_nr3_ybyc_ignor_cnoop   // unsigned , default = 0  ignore cnoop condition for ybyc motion decision
+//Bit  2: 0        reg_3dnr_nr3_suremot_txt_mode   // unsigned , default = 3  0: cur, 1:p2; 2: (cur+p2)/2; 3/up: min(cur,p2)
+#define   NR3_COOP_PARA                            (0x2ff1)
+#define P_NR3_COOP_PARA                            (volatile unsigned int *)((0x2ff1  << 2) + 0xff900000)
+//Bit 31:22        reserved
+//Bit 21:20        reg_3dnr_nr3_coop_mode    // unsigned , default = 2  0 original pixel 1: [1 2 1]/4 lpf; 2: [1 2 2 2 1]/8; 3: 3x3 lpf
+//Bit 19:16        reg_3dnr_nr3_coop_ratio    // unsigned , default = 8  cur and p2 color oop decision ratio:  (avg1<(dif1*ratio/8 + ofst));
+//Bit 15: 8        reg_3dnr_nr3_coop_ofset    // signed , default = -1  cur and p2 color oop decision ofst:  (avg1<(dif1*ratio/8 + ofst));
+//Bit  7: 0        reg_3dnr_nr3_coop_sat_thrd // unsigned , default = 0  cur and p2 color oop decision min(sat0,sat1) threshold;
+#define   NR3_CNOOP_GAIN                           (0x2ff2)
+#define P_NR3_CNOOP_GAIN                           (volatile unsigned int *)((0x2ff2  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:20        reg_3dnr_nr3_cnoop_ratio0   // unsigned , default = 8  cur and p2 color noop decision ratio0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
+//Bit 19:16        reg_3dnr_nr3_cnoop_ratio1   // unsigned , default = 8  cur and p2 color noop decision ratio1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
+//Bit 15: 8        reg_3dnr_nr3_cnoop_ofset0   // signed , default = 25  cur and p2 color noop decision ofset0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
+//Bit  7: 0        reg_3dnr_nr3_cnoop_ofset1   // signed , default = 0  cur and p2 color noop decision ofset1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
+#define   NR3_YMOT_PARA                            (0x2ff3)
+#define P_NR3_YMOT_PARA                            (volatile unsigned int *)((0x2ff3  << 2) + 0xff900000)
+//Bit 31:20        reserved
+//Bit 19           reg_3dnr_nr3_ymot_only_en  // unsigned , default = 1  enable signal for ignor chroma motion: (ytxt &coop)
+//Bit 18           reg_3dnr_nr3_ymot_only_cmtmode  // unsigned , default = 1  0: cmot=ymot; 1: cmot = MIN(ymot, cmot)
+//Bit 17:16        reg_3dnr_nr3_ymot_only_txtmode  // unsigned , default = 0  0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
+//Bit 15: 8        reg_3dnr_nr3_ymot_only_txtthrd  // unsigned , default = 10  threshold to luma texture to decide use ymot only
+//Bit  7: 0        reg_3dnr_nr3_ymot_only_motthrd  // unsigned , default = 30  threshold to luma motion to decide use ymot only
+#define   NR3_CMOT_PARA                            (0x2ff4)
+#define P_NR3_CMOT_PARA                            (volatile unsigned int *)((0x2ff4  << 2) + 0xff900000)
+//Bit 31:20        reserved
+//Bit 19           reg_3dnr_nr3_cmot_only_en  // unsigned , default = 1  enable signal for ignor luma motion: (ctxt &cnoop)
+//Bit 18           reg_3dnr_nr3_cmot_only_ymtmode  // unsigned , default = 0  0: ymot=cmot+ymot/4; 1: ymot = MIN(ymot, cmot)
+//Bit 17:16        reg_3dnr_nr3_cmot_only_txtmode  // unsigned , default = 0  0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
+//Bit 15: 8        reg_3dnr_nr3_cmot_only_txtthrd  // unsigned , default = 20  threshold to chroma texture to decide use cmot only
+//Bit  7: 0        reg_3dnr_nr3_cmot_only_motthrd  // unsigned , default = 15  threshold to chroma motion to decide use cmot only
+#define   NR3_SUREMOT_YGAIN                        (0x2ff5)
+#define P_NR3_SUREMOT_YGAIN                        (volatile unsigned int *)((0x2ff5  << 2) + 0xff900000)
+//Bit 31:24        reg_3dnr_nr3_suremot_dec_yrate  // unsigned , default = 16  (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 23:16        reg_3dnr_nr3_suremot_dec_yofst  // unsigned , default = 12   lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 15: 8        reg_3dnr_nr3_suremot_frc_ygain  // unsigned , default = 64  (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit  7: 0        reg_3dnr_nr3_suremot_frc_yofst  // unsigned , default = 20  lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+#define   NR3_SUREMOT_CGAIN                        (0x2ff6)
+#define P_NR3_SUREMOT_CGAIN                        (volatile unsigned int *)((0x2ff6  << 2) + 0xff900000)
+//Bit 31:24        reg_3dnr_nr3_suremot_dec_crate  // unsigned , default = 34  (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 23:16        reg_3dnr_nr3_suremot_dec_cofst  // unsigned , default = 38   lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 15: 8        reg_3dnr_nr3_suremot_frc_cgain  // unsigned , default = 64  (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit  7: 0        reg_3dnr_nr3_suremot_frc_cofst  // unsigned , default = 20  lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr3_tnr_regs.h
+//
+#define   LBUF_TOP_CTRL                            (0x2fff)
+#define P_LBUF_TOP_CTRL                            (volatile unsigned int *)((0x2fff  << 2) + 0xff900000)
+//bit 23:22   mode_444c422
+//bit 21:20   mode_422c444
+//bit 17      lbuf_fmt444_mode
+//bit 16      lbuf_line5_mode
+//bit 12:0    pre_lbuf_size
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  mcdi_regs.h
+//
+//  VPU_VLOCK register    (16'h3000 - 16'h30ff)
+//========================================================================
+//`define VPU_VLOCK_VCBUS_BASE                   8'h30
+//
+// Reading file:  vpu_vlock_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// ----------------------------
+// VPU_VLOCK 0x30
+// ----------------------------
+// -----------------------------------------------
+// CBUS_BASE:  VPU_VLOCK_VCBUS_BASE = 0x30
+// -----------------------------------------------
+#define   VPU_VLOCK_CTRL                           (0x3000)
+#define P_VPU_VLOCK_CTRL                           (volatile unsigned int *)((0x3000  << 2) + 0xff900000)
+#define   VPU_VLOCK_MISC_CTRL                      (0x3001)
+#define P_VPU_VLOCK_MISC_CTRL                      (volatile unsigned int *)((0x3001  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP0_ACCUM_LMT                (0x3002)
+#define P_VPU_VLOCK_LOOP0_ACCUM_LMT                (volatile unsigned int *)((0x3002  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP0_CTRL0                    (0x3003)
+#define P_VPU_VLOCK_LOOP0_CTRL0                    (volatile unsigned int *)((0x3003  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP1_CTRL0                    (0x3004)
+#define P_VPU_VLOCK_LOOP1_CTRL0                    (volatile unsigned int *)((0x3004  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP1_IMISSYNC_MAX             (0x3005)
+#define P_VPU_VLOCK_LOOP1_IMISSYNC_MAX             (volatile unsigned int *)((0x3005  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP1_IMISSYNC_MIN             (0x3006)
+#define P_VPU_VLOCK_LOOP1_IMISSYNC_MIN             (volatile unsigned int *)((0x3006  << 2) + 0xff900000)
+#define   VPU_VLOCK_OVWRITE_ACCUM0                 (0x3007)
+#define P_VPU_VLOCK_OVWRITE_ACCUM0                 (volatile unsigned int *)((0x3007  << 2) + 0xff900000)
+#define   VPU_VLOCK_OVWRITE_ACCUM1                 (0x3008)
+#define P_VPU_VLOCK_OVWRITE_ACCUM1                 (volatile unsigned int *)((0x3008  << 2) + 0xff900000)
+#define   VPU_VLOCK_OUTPUT0_CAPT_LMT               (0x3009)
+#define P_VPU_VLOCK_OUTPUT0_CAPT_LMT               (volatile unsigned int *)((0x3009  << 2) + 0xff900000)
+#define   VPU_VLOCK_OUTPUT0_PLL_LMT                (0x300a)
+#define P_VPU_VLOCK_OUTPUT0_PLL_LMT                (volatile unsigned int *)((0x300a  << 2) + 0xff900000)
+#define   VPU_VLOCK_OUTPUT1_CAPT_LMT               (0x300b)
+#define P_VPU_VLOCK_OUTPUT1_CAPT_LMT               (volatile unsigned int *)((0x300b  << 2) + 0xff900000)
+#define   VPU_VLOCK_OUTPUT1_PLL_LMT                (0x300c)
+#define P_VPU_VLOCK_OUTPUT1_PLL_LMT                (volatile unsigned int *)((0x300c  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP1_PHSDIF_TGT               (0x300d)
+#define P_VPU_VLOCK_LOOP1_PHSDIF_TGT               (volatile unsigned int *)((0x300d  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_LOOP0_ACCUM                 (0x300e)
+#define P_VPU_VLOCK_RO_LOOP0_ACCUM                 (volatile unsigned int *)((0x300e  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_LOOP1_ACCUM                 (0x300f)
+#define P_VPU_VLOCK_RO_LOOP1_ACCUM                 (volatile unsigned int *)((0x300f  << 2) + 0xff900000)
+#define   VPU_VLOCK_OROW_OCOL_MAX                  (0x3010)
+#define P_VPU_VLOCK_OROW_OCOL_MAX                  (volatile unsigned int *)((0x3010  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_VS_I_DIST                   (0x3011)
+#define P_VPU_VLOCK_RO_VS_I_DIST                   (volatile unsigned int *)((0x3011  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_VS_O_DIST                   (0x3012)
+#define P_VPU_VLOCK_RO_VS_O_DIST                   (volatile unsigned int *)((0x3012  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_LINE_PIX_ADJ                (0x3013)
+#define P_VPU_VLOCK_RO_LINE_PIX_ADJ                (volatile unsigned int *)((0x3013  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_OUTPUT_00_01                (0x3014)
+#define P_VPU_VLOCK_RO_OUTPUT_00_01                (volatile unsigned int *)((0x3014  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_OUTPUT_10_11                (0x3015)
+#define P_VPU_VLOCK_RO_OUTPUT_10_11                (volatile unsigned int *)((0x3015  << 2) + 0xff900000)
+#define   VPU_VLOCK_MX4096                         (0x3016)
+#define P_VPU_VLOCK_MX4096                         (volatile unsigned int *)((0x3016  << 2) + 0xff900000)
+#define   VPU_VLOCK_STBDET_WIN0_WIN1               (0x3017)
+#define P_VPU_VLOCK_STBDET_WIN0_WIN1               (volatile unsigned int *)((0x3017  << 2) + 0xff900000)
+#define   VPU_VLOCK_STBDET_CLP                     (0x3018)
+#define P_VPU_VLOCK_STBDET_CLP                     (volatile unsigned int *)((0x3018  << 2) + 0xff900000)
+#define   VPU_VLOCK_STBDET_ABS_WIN0                (0x3019)
+#define P_VPU_VLOCK_STBDET_ABS_WIN0                (volatile unsigned int *)((0x3019  << 2) + 0xff900000)
+#define   VPU_VLOCK_STBDET_ABS_WIN1                (0x301a)
+#define P_VPU_VLOCK_STBDET_ABS_WIN1                (volatile unsigned int *)((0x301a  << 2) + 0xff900000)
+#define   VPU_VLOCK_STBDET_SGN_WIN0                (0x301b)
+#define P_VPU_VLOCK_STBDET_SGN_WIN0                (volatile unsigned int *)((0x301b  << 2) + 0xff900000)
+#define   VPU_VLOCK_STBDET_SGN_WIN1                (0x301c)
+#define P_VPU_VLOCK_STBDET_SGN_WIN1                (volatile unsigned int *)((0x301c  << 2) + 0xff900000)
+#define   VPU_VLOCK_ADJ_EN_SYNC_CTRL               (0x301d)
+#define P_VPU_VLOCK_ADJ_EN_SYNC_CTRL               (volatile unsigned int *)((0x301d  << 2) + 0xff900000)
+#define   VPU_VLOCK_GCLK_EN                        (0x301e)
+#define P_VPU_VLOCK_GCLK_EN                        (volatile unsigned int *)((0x301e  << 2) + 0xff900000)
+#define   VPU_VLOCK_LOOP1_ACCUM_LMT                (0x301f)
+#define P_VPU_VLOCK_LOOP1_ACCUM_LMT                (volatile unsigned int *)((0x301f  << 2) + 0xff900000)
+#define   VPU_VLOCK_RO_M_INT_FRAC                  (0x3020)
+#define P_VPU_VLOCK_RO_M_INT_FRAC                  (volatile unsigned int *)((0x3020  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpu_vlock_reg.h
+//
+//`define VPPB_VCBUS_BASE                8'h31
+//
+// Reading file:  srscl_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPPB_VCBUS_BASE = 0x31
+// -----------------------------------------------
+////=================================================================////
+//// vkeystone
+////=================================================================////
+// 8'h00-8'h17
+//
+// Reading file:  vkstone_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   VKS_CTRL                                 (0x3100)
+#define P_VKS_CTRL                                 (volatile unsigned int *)((0x3100  << 2) + 0xff900000)
+//Bit 31           reg_vks_en                // unsigned , default = 1  enable signal of the vks function
+//Bit 30           reg_vks_scl_mode0         // unsigned , default = 1  : b0 mode of vks ofset mode, 0: offset= offset; 1: offset= offset*step= ofset/scale;
+//Bit 29           reg_vks_scl_mode1         // unsigned , default = 1  : b0 mode of vks ofset mode, 0: offset= offset; 1: offset= offset*step= ofset/scale;
+//Bit 28           reg_vks_fill_mode         // unsigned , default = 1  mode of out-of-boundary fill, 0 extension, 1: fill with the fill_value
+//Bit 27:26        reg_vks_row_inp_mode      // unsigned , default = 1  , interpolation mode from 16pieces ofset/step to each line ofset and step; 0: linear interpolation; 1: cubic interpolation (using ccoef)
+//Bit 25           reg_vks_border_ext_mode0  // unsigned , default = 0  , extend mode of the border data of luma and chroma, 0: copy the most border one; 1: extropolate the border one
+//Bit 24           reg_vks_border_ext_mode1  // unsigned , default = 0  , extend mode of the border data of luma and chroma, 0: copy the most border one; 1: extropolate the border one
+//Bit 23           reg_vks_obuf_mode0        // unsigned , default = 1  , mode of output buffer left/right side. 0: no precalculate active pixels during output fill region; 1: precaclc active pixels during output fill regions
+//Bit 22           reg_vks_obuf_mode1        // unsigned , default = 1  , mode of output buffer left/right side. 0: no precalculate active pixels during output fill region; 1: precaclc active pixels during output fill regions
+//Bit 21:20        reg_vks_obuf_mrgn0        // unsigned , default = 3  , margin pixels for left right most active pixel to the fill pixels to avoid jump
+//Bit 19:18        reg_vks_obuf_mrgn1        // unsigned , default = 3  , margin pixels for left right most active pixel to the fill pixels to avoid jump
+//Bit 17:16        reg_vks_phs_qmode         // unsigned , default = 2  , interpolation mode of the phase, 0: floor to 1/64 phase; 1: round to 1/64 phase; 2/3 linear intp
+//Bit 15: 0        reg_vks_row_scl           // unsigned , default = 11651  , scale of row to make it fit to the 16 pieces, scl = (2^23)/RowMax
+#define   VKS_OUT_WIN_SIZE                         (0x3101)
+#define P_VKS_OUT_WIN_SIZE                         (volatile unsigned int *)((0x3101  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_vks_ocolmax           // unsigned , default = 1280  output outer window col number, decided by the projector
+//Bit 15:14        reserved
+//Bit 13: 0        reg_vks_orowmax           // unsigned , default = 720  output outer window row number, decided by the projector
+#define   VKS_PRELPF_YCOEF0                        (0x3102)
+#define P_VKS_PRELPF_YCOEF0                        (volatile unsigned int *)((0x3102  << 2) + 0xff900000)
+//Bit 31:24        reg_vks_prelpf_ycoef0     // signed , default = -128  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
+//Bit 23:16        reg_vks_prelpf_ycoef1     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
+//Bit 15: 8        reg_vks_prelpf_ycoef2     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
+//Bit  7: 0        reg_vks_prelpf_ycoef3     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
+#define   VKS_PRELPF_YCOEF1                        (0x3103)
+#define P_VKS_PRELPF_YCOEF1                        (volatile unsigned int *)((0x3103  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15: 8        reg_vks_prelpf_ycoef4     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
+//Bit  7: 0        reg_vks_prelpf_ycoef5     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
+#define   VKS_PRELPF_CCOEF0                        (0x3104)
+#define P_VKS_PRELPF_CCOEF0                        (volatile unsigned int *)((0x3104  << 2) + 0xff900000)
+//Bit 31:24        reg_vks_prelpf_ccoef0     // signed , default = -128  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
+//Bit 23:16        reg_vks_prelpf_ccoef1     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
+//Bit 15: 8        reg_vks_prelpf_ccoef2     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
+//Bit  7: 0        reg_vks_prelpf_ccoef3     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
+#define   VKS_PRELPF_CCOEF1                        (0x3105)
+#define P_VKS_PRELPF_CCOEF1                        (volatile unsigned int *)((0x3105  << 2) + 0xff900000)
+//Bit 31:16        reserved
+//Bit 15: 8        reg_vks_prelpf_ccoef4     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
+//Bit  7: 0        reg_vks_prelpf_ccoef5     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
+#define   VKS_FILL_VAL                             (0x3106)
+#define P_VKS_FILL_VAL                             (volatile unsigned int *)((0x3106  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_vks_fill_value0       // unsigned , default = 0  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
+//Bit 15: 8        reg_vks_fill_value1       // unsigned , default = 128  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
+//Bit  7: 0        reg_vks_fill_value2       // unsigned , default = 128  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
+#define   VKS_IWIN_HSIZE                           (0x3107)
+#define P_VKS_IWIN_HSIZE                           (volatile unsigned int *)((0x3107  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_vks_iwinx0            // unsigned , default = 160  , input start-col and end-col;
+//Bit 15:14        reserved
+//Bit 13: 0        reg_vks_iwinx1            // unsigned , default = 1279  , input start-col and end-col;
+#define   VKS_IWIN_VSIZE                           (0x3108)
+#define P_VKS_IWIN_VSIZE                           (volatile unsigned int *)((0x3108  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_vks_iwiny0            // unsigned , default = 0  , input start-row and end-row;
+//Bit 15:14        reserved
+//Bit 13: 0        reg_vks_iwiny1            // unsigned , default = 719  , input start-row and end-row;
+#define   VKS_TOP_MISC                             (0x3109)
+#define P_VKS_TOP_MISC                             (volatile unsigned int *)((0x3109  << 2) + 0xff900000)
+//Bit 31:19        reserved
+//Bit 18           reg_flt_en                // unsigned , default = 1
+//Bit 17           reg_frm_rst               // unsigned , default = 0
+//Bit 16           reg_ctrl_sync             // unsigned , default = 0
+//Bit 15: 8        blank_num                 // unsigned , default = 4
+//Bit  7: 0        flt_blank_num             // unsigned , default = 9
+#define   VKS_START_CTRL                           (0x310a)
+#define P_VKS_START_CTRL                           (volatile unsigned int *)((0x310a  << 2) + 0xff900000)
+//Bit 31:17        reserved
+//Bit 16           reg_vks_en_mode           // unsigned , default = 0
+//Bit 15: 0        reg_hold_phnum            // unsigned , default = 5
+#define   VKS_LBUF_SIZE                            (0x310b)
+#define P_VKS_LBUF_SIZE                            (volatile unsigned int *)((0x310b  << 2) + 0xff900000)
+//Bit 31:12        reserved
+//Bit 11: 0        reg_lbuf_depth            // unsigned , default = 1024
+#define   VKS_PARA_ADDR_PORT                       (0x310e)
+#define P_VKS_PARA_ADDR_PORT                       (volatile unsigned int *)((0x310e  << 2) + 0xff900000)
+#define   VKS_PARA_DATA_PORT                       (0x310f)
+#define P_VKS_PARA_DATA_PORT                       (volatile unsigned int *)((0x310f  << 2) + 0xff900000)
+
+    #define VKS_SCL_OFSET00                        0x9  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset0        // unsigned , default = 118534  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET01                        0xa  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset1        // unsigned , default = 111450  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET02                        0xb  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset2        // unsigned , default = 104366  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET03                        0xc  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset3        // unsigned , default = 97283  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET04                        0xd  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset4        // unsigned , default = 90199  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET05                        0xe  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset5        // unsigned , default = 83115  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET06                        0xf  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset6        // unsigned , default = 76031  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET07                       0x10  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset7        // unsigned , default = 68947  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET08                       0x11  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset8        // unsigned , default = 61864  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET09                       0x12  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset9        // unsigned , default = 54780  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET10                       0x13  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset10       // unsigned , default = 47696  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET11                       0x14  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset11       // unsigned , default = 40612  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET12                       0x15  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset12       // unsigned , default = 33528  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET13                       0x16  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset13       // unsigned , default = 26444  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET14                       0x17  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset14       // unsigned , default = 19361  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET15                       0x18  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset15       // unsigned , default = 12277  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_OFSET16                       0x19  //
+//Bit 31:20        reserved
+//Bit 19: 0        reg_vks_scl_ofset16       // unsigned , default = 5193  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
+    #define VKS_SCL_STEP00                        0x1a  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step0         // unsigned , default = 331378  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP01                        0x1b  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step1         // unsigned , default = 383191  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP02                        0x1c  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step2         // unsigned , default = 435004  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP03                        0x1d  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step3         // unsigned , default = 486818  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP04                        0x1e  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step4         // unsigned , default = 538631  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP05                        0x1f  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step5         // unsigned , default = 590444  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP06                        0x20  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step6         // unsigned , default = 642257  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP07                        0x21  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step7         // unsigned , default = 694070  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP08                        0x22  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step8         // unsigned , default = 745884  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP09                        0x23  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step9         // unsigned , default = 797697  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP10                        0x24  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step10        // unsigned , default = 849510  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP11                        0x25  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step11        // unsigned , default = 901323  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP12                        0x26  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step12        // unsigned , default = 953136  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP13                        0x27  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step13        // unsigned , default = 1004949  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP14                        0x28  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step14        // unsigned , default = 1056763  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP15                        0x29  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step15        // unsigned , default = 1108576  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_SCL_STEP16                        0x2a  //
+//Bit 31:24        reserved
+//Bit 23: 0        reg_vks_scl_step16        // unsigned , default = 1160389  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
+    #define VKS_PPS_YCOEF00                       0x2b  //
+//Bit 31:24        reg_vks_ycoef0            // signed , default = 0  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef1            // signed , default = 128  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef2            // signed , default = 0  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef3            // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF01                       0x2c  //
+//Bit 31:24        reg_vks_ycoef4            // signed , default = 0  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef5            // signed , default = 127  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef6            // signed , default = 1  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef7            // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF02                       0x2d  //
+//Bit 31:24        reg_vks_ycoef8            // signed , default = -1  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef9            // signed , default = 127  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef10           // signed , default = 2  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef11           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF03                       0x2e  //
+//Bit 31:24        reg_vks_ycoef12           // signed , default = -2  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef13           // signed , default = 127  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef14           // signed , default = 3  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef15           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF04                       0x2f  //
+//Bit 31:24        reg_vks_ycoef16           // signed , default = -3  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef17           // signed , default = 126  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef18           // signed , default = 5  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef19           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF05                       0x30  //
+//Bit 31:24        reg_vks_ycoef20           // signed , default = -4  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef21           // signed , default = 126  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef22           // signed , default = 6  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef23           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF06                       0x31  //
+//Bit 31:24        reg_vks_ycoef24           // signed , default = -5  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef25           // signed , default = 125  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef26           // signed , default = 8  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef27           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF07                       0x32  //
+//Bit 31:24        reg_vks_ycoef28           // signed , default = -5  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef29           // signed , default = 124  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef30           // signed , default = 9  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef31           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF08                       0x33  //
+//Bit 31:24        reg_vks_ycoef32           // signed , default = -6  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef33           // signed , default = 123  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef34           // signed , default = 11  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef35           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF09                       0x34  //
+//Bit 31:24        reg_vks_ycoef36           // signed , default = -6  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef37           // signed , default = 122  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef38           // signed , default = 13  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef39           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF10                       0x35  //
+//Bit 31:24        reg_vks_ycoef40           // signed , default = -7  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef41           // signed , default = 121  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef42           // signed , default = 15  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef43           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF11                       0x36  //
+//Bit 31:24        reg_vks_ycoef44           // signed , default = -7  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef45           // signed , default = 119  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef46           // signed , default = 17  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef47           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF12                       0x37  //
+//Bit 31:24        reg_vks_ycoef48           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef49           // signed , default = 118  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef50           // signed , default = 19  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef51           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF13                       0x38  //
+//Bit 31:24        reg_vks_ycoef52           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef53           // signed , default = 116  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef54           // signed , default = 22  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef55           // signed , default = -2  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF14                       0x39  //
+//Bit 31:24        reg_vks_ycoef56           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef57           // signed , default = 114  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef58           // signed , default = 24  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef59           // signed , default = -2  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF15                       0x3a  //
+//Bit 31:24        reg_vks_ycoef60           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef61           // signed , default = 112  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef62           // signed , default = 26  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef63           // signed , default = -2  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF16                       0x3b  //
+//Bit 31:24        reg_vks_ycoef64           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef65           // signed , default = 111  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef66           // signed , default = 29  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef67           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF17                       0x3c  //
+//Bit 31:24        reg_vks_ycoef68           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef69           // signed , default = 109  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef70           // signed , default = 31  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef71           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF18                       0x3d  //
+//Bit 31:24        reg_vks_ycoef72           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef73           // signed , default = 107  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef74           // signed , default = 33  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef75           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF19                       0x3e  //
+//Bit 31:24        reg_vks_ycoef76           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef77           // signed , default = 104  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef78           // signed , default = 36  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef79           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF20                       0x3f  //
+//Bit 31:24        reg_vks_ycoef80           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef81           // signed , default = 102  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef82           // signed , default = 39  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef83           // signed , default = -4  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF21                       0x40  //
+//Bit 31:24        reg_vks_ycoef84           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef85           // signed , default = 100  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef86           // signed , default = 41  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef87           // signed , default = -4  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF22                       0x41  //
+//Bit 31:24        reg_vks_ycoef88           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef89           // signed , default = 97  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef90           // signed , default = 44  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef91           // signed , default = -4  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF23                       0x42  //
+//Bit 31:24        reg_vks_ycoef92           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef93           // signed , default = 95  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef94           // signed , default = 47  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef95           // signed , default = -5  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF24                       0x43  //
+//Bit 31:24        reg_vks_ycoef96           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef97           // signed , default = 93  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef98           // signed , default = 49  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef99           // signed , default = -5  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF25                       0x44  //
+//Bit 31:24        reg_vks_ycoef100          // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef101          // signed , default = 90  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef102          // signed , default = 52  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef103          // signed , default = -5  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF26                       0x45  //
+//Bit 31:24        reg_vks_ycoef104          // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef105          // signed , default = 88  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef106          // signed , default = 55  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef107          // signed , default = -6  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF27                       0x46  //
+//Bit 31:24        reg_vks_ycoef108          // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef109          // signed , default = 85  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef110          // signed , default = 58  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef111          // signed , default = -6  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF28                       0x47  //
+//Bit 31:24        reg_vks_ycoef112          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef113          // signed , default = 82  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef114          // signed , default = 60  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef115          // signed , default = -6  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF29                       0x48  //
+//Bit 31:24        reg_vks_ycoef116          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef117          // signed , default = 80  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef118          // signed , default = 63  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef119          // signed , default = -7  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF30                       0x49  //
+//Bit 31:24        reg_vks_ycoef120          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef121          // signed , default = 77  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef122          // signed , default = 66  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef123          // signed , default = -7  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF31                       0x4a  //
+//Bit 31:24        reg_vks_ycoef124          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef125          // signed , default = 74  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef126          // signed , default = 69  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef127          // signed , default = -7  poly-phase scalar coefs
+    #define VKS_PPS_YCOEF32                       0x4b  //
+//Bit 31:24        reg_vks_ycoef128          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ycoef129          // signed , default = 72  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ycoef130          // signed , default = 72  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ycoef131          // signed , default = -8  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF00                       0x4c  //
+//Bit 31:24        reg_vks_ccoef0            // signed , default = 0  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef1            // signed , default = 128  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef2            // signed , default = 0  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef3            // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF01                       0x4d  //
+//Bit 31:24        reg_vks_ccoef4            // signed , default = 0  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef5            // signed , default = 127  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef6            // signed , default = 1  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef7            // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF02                       0x4e  //
+//Bit 31:24        reg_vks_ccoef8            // signed , default = -1  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef9            // signed , default = 127  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef10           // signed , default = 2  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef11           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF03                       0x4f  //
+//Bit 31:24        reg_vks_ccoef12           // signed , default = -2  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef13           // signed , default = 127  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef14           // signed , default = 3  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef15           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF04                       0x50  //
+//Bit 31:24        reg_vks_ccoef16           // signed , default = -3  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef17           // signed , default = 126  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef18           // signed , default = 5  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef19           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF05                       0x51  //
+//Bit 31:24        reg_vks_ccoef20           // signed , default = -4  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef21           // signed , default = 126  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef22           // signed , default = 6  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef23           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF06                       0x52  //
+//Bit 31:24        reg_vks_ccoef24           // signed , default = -5  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef25           // signed , default = 125  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef26           // signed , default = 8  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef27           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF07                       0x53  //
+//Bit 31:24        reg_vks_ccoef28           // signed , default = -5  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef29           // signed , default = 124  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef30           // signed , default = 9  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef31           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF08                       0x54  //
+//Bit 31:24        reg_vks_ccoef32           // signed , default = -6  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef33           // signed , default = 123  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef34           // signed , default = 11  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef35           // signed , default = 0  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF09                       0x55  //
+//Bit 31:24        reg_vks_ccoef36           // signed , default = -6  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef37           // signed , default = 122  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef38           // signed , default = 13  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef39           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF10                       0x56  //
+//Bit 31:24        reg_vks_ccoef40           // signed , default = -7  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef41           // signed , default = 121  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef42           // signed , default = 15  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef43           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF11                       0x57  //
+//Bit 31:24        reg_vks_ccoef44           // signed , default = -7  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef45           // signed , default = 119  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef46           // signed , default = 17  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef47           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF12                       0x58  //
+//Bit 31:24        reg_vks_ccoef48           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef49           // signed , default = 118  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef50           // signed , default = 19  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef51           // signed , default = -1  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF13                       0x59  //
+//Bit 31:24        reg_vks_ccoef52           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef53           // signed , default = 116  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef54           // signed , default = 22  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef55           // signed , default = -2  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF14                       0x5a  //
+//Bit 31:24        reg_vks_ccoef56           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef57           // signed , default = 114  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef58           // signed , default = 24  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef59           // signed , default = -2  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF15                       0x5b  //
+//Bit 31:24        reg_vks_ccoef60           // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef61           // signed , default = 112  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef62           // signed , default = 26  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef63           // signed , default = -2  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF16                       0x5c  //
+//Bit 31:24        reg_vks_ccoef64           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef65           // signed , default = 111  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef66           // signed , default = 29  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef67           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF17                       0x5d  //
+//Bit 31:24        reg_vks_ccoef68           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef69           // signed , default = 109  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef70           // signed , default = 31  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef71           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF18                       0x5e  //
+//Bit 31:24        reg_vks_ccoef72           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef73           // signed , default = 107  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef74           // signed , default = 33  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef75           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF19                       0x5f  //
+//Bit 31:24        reg_vks_ccoef76           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef77           // signed , default = 104  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef78           // signed , default = 36  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef79           // signed , default = -3  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF20                       0x60  //
+//Bit 31:24        reg_vks_ccoef80           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef81           // signed , default = 102  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef82           // signed , default = 39  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef83           // signed , default = -4  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF21                       0x61  //
+//Bit 31:24        reg_vks_ccoef84           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef85           // signed , default = 100  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef86           // signed , default = 41  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef87           // signed , default = -4  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF22                       0x62  //
+//Bit 31:24        reg_vks_ccoef88           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef89           // signed , default = 97  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef90           // signed , default = 44  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef91           // signed , default = -4  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF23                       0x63  //
+//Bit 31:24        reg_vks_ccoef92           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef93           // signed , default = 95  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef94           // signed , default = 47  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef95           // signed , default = -5  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF24                       0x64  //
+//Bit 31:24        reg_vks_ccoef96           // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef97           // signed , default = 93  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef98           // signed , default = 49  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef99           // signed , default = -5  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF25                       0x65  //
+//Bit 31:24        reg_vks_ccoef100          // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef101          // signed , default = 90  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef102          // signed , default = 52  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef103          // signed , default = -5  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF26                       0x66  //
+//Bit 31:24        reg_vks_ccoef104          // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef105          // signed , default = 88  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef106          // signed , default = 55  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef107          // signed , default = -6  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF27                       0x67  //
+//Bit 31:24        reg_vks_ccoef108          // signed , default = -9  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef109          // signed , default = 85  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef110          // signed , default = 58  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef111          // signed , default = -6  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF28                       0x68  //
+//Bit 31:24        reg_vks_ccoef112          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef113          // signed , default = 82  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef114          // signed , default = 60  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef115          // signed , default = -6  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF29                       0x69  //
+//Bit 31:24        reg_vks_ccoef116          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef117          // signed , default = 80  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef118          // signed , default = 63  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef119          // signed , default = -7  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF30                       0x6a  //
+//Bit 31:24        reg_vks_ccoef120          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef121          // signed , default = 77  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef122          // signed , default = 66  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef123          // signed , default = -7  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF31                       0x6b  //
+//Bit 31:24        reg_vks_ccoef124          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef125          // signed , default = 74  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef126          // signed , default = 69  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef127          // signed , default = -7  poly-phase scalar coefs
+    #define VKS_PPS_CCOEF32                       0x6c  //
+//Bit 31:24        reg_vks_ccoef128          // signed , default = -8  poly-phase scalar coefs
+//Bit 23:16        reg_vks_ccoef129          // signed , default = 72  poly-phase scalar coefs
+//Bit 15: 8        reg_vks_ccoef130          // signed , default = 72  poly-phase scalar coefs
+//Bit  7: 0        reg_vks_ccoef131          // signed , default = -8  poly-phase scalar coefs
+
+
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vkstone_regs.h
+//
+////=================================================================////
+//// vpp dither
+////=================================================================////
+// 8'h20-8'h3f
+//
+// Reading file:  vpp_dither_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   VPP_VE_DITHER_CTRL                       (0x3120)
+#define P_VPP_VE_DITHER_CTRL                       (volatile unsigned int *)((0x3120  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_1                      (0x3121)
+#define P_VPP_VE_DITHER_LUT_1                      (volatile unsigned int *)((0x3121  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_2                      (0x3122)
+#define P_VPP_VE_DITHER_LUT_2                      (volatile unsigned int *)((0x3122  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_3                      (0x3123)
+#define P_VPP_VE_DITHER_LUT_3                      (volatile unsigned int *)((0x3123  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_4                      (0x3124)
+#define P_VPP_VE_DITHER_LUT_4                      (volatile unsigned int *)((0x3124  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_5                      (0x3125)
+#define P_VPP_VE_DITHER_LUT_5                      (volatile unsigned int *)((0x3125  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_6                      (0x3126)
+#define P_VPP_VE_DITHER_LUT_6                      (volatile unsigned int *)((0x3126  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_7                      (0x3127)
+#define P_VPP_VE_DITHER_LUT_7                      (volatile unsigned int *)((0x3127  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_8                      (0x3128)
+#define P_VPP_VE_DITHER_LUT_8                      (volatile unsigned int *)((0x3128  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_9                      (0x3129)
+#define P_VPP_VE_DITHER_LUT_9                      (volatile unsigned int *)((0x3129  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_10                     (0x312a)
+#define P_VPP_VE_DITHER_LUT_10                     (volatile unsigned int *)((0x312a  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_11                     (0x312b)
+#define P_VPP_VE_DITHER_LUT_11                     (volatile unsigned int *)((0x312b  << 2) + 0xff900000)
+#define   VPP_VE_DITHER_LUT_12                     (0x312c)
+#define P_VPP_VE_DITHER_LUT_12                     (volatile unsigned int *)((0x312c  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_CTRL                    (0x3130)
+#define P_VPP_OSDSC_DITHER_CTRL                    (volatile unsigned int *)((0x3130  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_1                   (0x3131)
+#define P_VPP_OSDSC_DITHER_LUT_1                   (volatile unsigned int *)((0x3131  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_2                   (0x3132)
+#define P_VPP_OSDSC_DITHER_LUT_2                   (volatile unsigned int *)((0x3132  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_3                   (0x3133)
+#define P_VPP_OSDSC_DITHER_LUT_3                   (volatile unsigned int *)((0x3133  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_4                   (0x3134)
+#define P_VPP_OSDSC_DITHER_LUT_4                   (volatile unsigned int *)((0x3134  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_5                   (0x3135)
+#define P_VPP_OSDSC_DITHER_LUT_5                   (volatile unsigned int *)((0x3135  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_6                   (0x3136)
+#define P_VPP_OSDSC_DITHER_LUT_6                   (volatile unsigned int *)((0x3136  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_7                   (0x3137)
+#define P_VPP_OSDSC_DITHER_LUT_7                   (volatile unsigned int *)((0x3137  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_8                   (0x3138)
+#define P_VPP_OSDSC_DITHER_LUT_8                   (volatile unsigned int *)((0x3138  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_9                   (0x3139)
+#define P_VPP_OSDSC_DITHER_LUT_9                   (volatile unsigned int *)((0x3139  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_10                  (0x313a)
+#define P_VPP_OSDSC_DITHER_LUT_10                  (volatile unsigned int *)((0x313a  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_11                  (0x313b)
+#define P_VPP_OSDSC_DITHER_LUT_11                  (volatile unsigned int *)((0x313b  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_12                  (0x313c)
+#define P_VPP_OSDSC_DITHER_LUT_12                  (volatile unsigned int *)((0x313c  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_13                  (0x313d)
+#define P_VPP_OSDSC_DITHER_LUT_13                  (volatile unsigned int *)((0x313d  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_14                  (0x313e)
+#define P_VPP_OSDSC_DITHER_LUT_14                  (volatile unsigned int *)((0x313e  << 2) + 0xff900000)
+#define   VPP_OSDSC_DITHER_LUT_15                  (0x313f)
+#define P_VPP_OSDSC_DITHER_LUT_15                  (volatile unsigned int *)((0x313f  << 2) + 0xff900000)
+
+
+/* osd super scale */
+#define OSDSR_HV_SIZEIN              VPP_OSDSC_DITHER_CTRL
+#define OSDSR_CTRL_MODE              VPP_OSDSC_DITHER_LUT_1
+#define OSDSR_ABIC_HCOEF             VPP_OSDSC_DITHER_LUT_2
+#define OSDSR_YBIC_HCOEF             VPP_OSDSC_DITHER_LUT_3
+#define OSDSR_CBIC_HCOEF             VPP_OSDSC_DITHER_LUT_4
+#define OSDSR_ABIC_VCOEF             VPP_OSDSC_DITHER_LUT_5
+#define OSDSR_YBIC_VCOEF             VPP_OSDSC_DITHER_LUT_6
+#define OSDSR_CBIC_VCOEF             VPP_OSDSC_DITHER_LUT_7
+#define OSDSR_VAR_PARA               VPP_OSDSC_DITHER_LUT_8
+#define OSDSR_CONST_PARA             VPP_OSDSC_DITHER_LUT_9
+#define OSDSR_RKE_EXTWIN             VPP_OSDSC_DITHER_LUT_10
+#define OSDSR_UK_GRAD2DDIAG_TH_RATE  VPP_OSDSC_DITHER_LUT_11
+#define OSDSR_UK_GRAD2DDIAG_LIMIT    VPP_OSDSC_DITHER_LUT_12
+#define OSDSR_UK_GRAD2DADJA_TH_RATE  VPP_OSDSC_DITHER_LUT_13
+#define OSDSR_UK_GRAD2DADJA_LIMIT    VPP_OSDSC_DITHER_LUT_14
+#define OSDSR_UK_BST_GAIN            VPP_OSDSC_DITHER_LUT_15
+
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpp_dither_regs.h
+//
+// 8'h40-8'h4f
+//
+// Reading file:  osdsc_deband_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   OSD_DB_FLT_CTRL                          (0x3140)
+#define P_OSD_DB_FLT_CTRL                          (volatile unsigned int *)((0x3140  << 2) + 0xff900000)
+//Bit 31:27        reserved
+//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
+//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
+//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
+//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
+//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
+//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
+//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
+//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
+//Bit 16            reserved
+//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
+//Bit 12            reserved
+//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
+//Bit  8            reserved
+//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
+//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
+//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
+//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
+//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
+//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
+#define   OSD_DB_FLT_CTRL1                         (0x3141)
+#define P_OSD_DB_FLT_CTRL1                         (volatile unsigned int *)((0x3141  << 2) + 0xff900000)
+//Bit 31:18        reserved
+//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
+//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
+//Bit 11            reserved
+//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
+//Bit  7            reserved
+//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
+//Bit  3            reserved
+//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
+#define   OSD_DB_FLT_LUMA_THRD                     (0x3142)
+#define P_OSD_DB_FLT_LUMA_THRD                     (volatile unsigned int *)((0x3142  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
+//Bit 23:22        reserved
+//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
+#define   OSD_DB_FLT_CHRM_THRD                     (0x3143)
+#define P_OSD_DB_FLT_CHRM_THRD                     (volatile unsigned int *)((0x3143  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
+//Bit 23:22        reserved
+//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
+#define   OSD_DB_FLT_RANDLUT                       (0x3144)
+#define P_OSD_DB_FLT_RANDLUT                       (volatile unsigned int *)((0x3144  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
+//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
+//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
+//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
+//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
+//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
+//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
+//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
+#define   OSD_DB_FLT_PXI_THRD                      (0x3145)
+#define P_OSD_DB_FLT_PXI_THRD                      (volatile unsigned int *)((0x3145  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
+//Bit 15:10        reserved
+//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
+#define   OSD_DB_FLT_SEED_Y                        (0x3146)
+#define P_OSD_DB_FLT_SEED_Y                        (volatile unsigned int *)((0x3146  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
+#define   OSD_DB_FLT_SEED_U                        (0x3147)
+#define P_OSD_DB_FLT_SEED_U                        (volatile unsigned int *)((0x3147  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
+#define   OSD_DB_FLT_SEED_V                        (0x3148)
+#define P_OSD_DB_FLT_SEED_V                        (volatile unsigned int *)((0x3148  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
+#define   OSD_DB_FLT_SEED3                         (0x3149)
+#define P_OSD_DB_FLT_SEED3                         (volatile unsigned int *)((0x3149  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
+#define   OSD_DB_FLT_SEED4                         (0x314a)
+#define P_OSD_DB_FLT_SEED4                         (volatile unsigned int *)((0x314a  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
+#define   OSD_DB_FLT_SEED5                         (0x314b)
+#define P_OSD_DB_FLT_SEED5                         (volatile unsigned int *)((0x314b  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  osdsc_deband_regs.h
+//
+//register definition for xvycc
+// 8'h50-8'h7f
+//
+// Reading file:  xvycc_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//    `define XVYCC_VCBUS_BASE	   8'hfe
+#define   XVYCC_INV_LUT_Y_ADDR_PORT                (0x3158)
+#define P_XVYCC_INV_LUT_Y_ADDR_PORT                (volatile unsigned int *)((0x3158  << 2) + 0xff900000)
+//Bit 31:7, reserved
+//Bit  6:0,  xvycc_inv_lut_y_addr;
+#define   XVYCC_INV_LUT_Y_DATA_PORT                (0x3159)
+#define P_XVYCC_INV_LUT_Y_DATA_PORT                (volatile unsigned int *)((0x3159  << 2) + 0xff900000)
+//Bit 31:12, reserved
+//Bit  11:0, xvycc_inv_lut_y_data;
+#define   XVYCC_INV_LUT_U_ADDR_PORT                (0x315a)
+#define P_XVYCC_INV_LUT_U_ADDR_PORT                (volatile unsigned int *)((0x315a  << 2) + 0xff900000)
+//Bit 31:6, reserved
+//Bit  5:0,  xvycc_inv_lut_u_addr;
+#define   XVYCC_INV_LUT_U_DATA_PORT                (0x315b)
+#define P_XVYCC_INV_LUT_U_DATA_PORT                (volatile unsigned int *)((0x315b  << 2) + 0xff900000)
+//Bit 31:12, reserved
+//Bit  11:0, xvycc_inv_lut_u_data;
+#define   XVYCC_INV_LUT_V_ADDR_PORT                (0x315c)
+#define P_XVYCC_INV_LUT_V_ADDR_PORT                (volatile unsigned int *)((0x315c  << 2) + 0xff900000)
+//Bit 31:6, reserved
+//Bit  5:0,  xvycc_inv_lut_v_addr;
+#define   XVYCC_INV_LUT_V_DATA_PORT                (0x315d)
+#define P_XVYCC_INV_LUT_V_DATA_PORT                (volatile unsigned int *)((0x315d  << 2) + 0xff900000)
+//Bit 31:12, reserved
+//Bit  11:0, xvycc_inv_lut_v_data;
+#define   XVYCC_LUT_R_ADDR_PORT                    (0x315e)
+#define P_XVYCC_LUT_R_ADDR_PORT                    (volatile unsigned int *)((0x315e  << 2) + 0xff900000)
+//Bit 31:7, reserved
+//Bit  6:0,  xvycc_lut_r_addr;
+#define   XVYCC_LUT_R_DATA_PORT                    (0x315f)
+#define P_XVYCC_LUT_R_DATA_PORT                    (volatile unsigned int *)((0x315f  << 2) + 0xff900000)
+//Bit 31:10, reserved
+//Bit  9:0,  xvycc_lut_r_data;
+#define   XVYCC_LUT_G_ADDR_PORT                    (0x3160)
+#define P_XVYCC_LUT_G_ADDR_PORT                    (volatile unsigned int *)((0x3160  << 2) + 0xff900000)
+//Bit 31:7, reserved
+//Bit  6:0,  xvycc_lut_g_addr;
+#define   XVYCC_LUT_G_DATA_PORT                    (0x3161)
+#define P_XVYCC_LUT_G_DATA_PORT                    (volatile unsigned int *)((0x3161  << 2) + 0xff900000)
+//Bit 31:10, reserved
+//Bit  9:0,  xvycc_lut_g_data;
+#define   XVYCC_LUT_B_ADDR_PORT                    (0x3162)
+#define P_XVYCC_LUT_B_ADDR_PORT                    (volatile unsigned int *)((0x3162  << 2) + 0xff900000)
+//Bit 31:7, reserved
+//Bit  6:0,  xvycc_lut_b_addr;
+#define   XVYCC_LUT_B_DATA_PORT                    (0x3163)
+#define P_XVYCC_LUT_B_DATA_PORT                    (volatile unsigned int *)((0x3163  << 2) + 0xff900000)
+//Bit 31:10, reserved
+//Bit  9:0,  xvycc_lut_b_data;
+#define   XVYCC_INV_LUT_CTL                        (0x3164)
+#define P_XVYCC_INV_LUT_CTL                        (volatile unsigned int *)((0x3164  << 2) + 0xff900000)
+//Bit 31:15, reserved
+//Bit 14:12, reg_xvycc_cmpr_invlut_enable    enable for xvycc compression inverse-lut [2] for Y, [1] for U, [0] for V default=0
+//Bit 11:10, reg_xvycc_cmpr_invlut_vscl_1   v LUT input scale for positive portion   default=0
+//Bit  9: 8, reg_xvycc_cmpr_invlut_vscl_0   v LUT input scale for negative portion   default=0
+//Bit  7: 6, reg_xvycc_cmpr_invlut_uscl_1   u LUT input scale for positive portion   default=0
+//Bit  5: 4, reg_xvycc_cmpr_invlut_uscl_0   u LUT input scale for negative portion   default=0
+//Bit  3: 2, reg_xvycc_cmpr_invlut_yscl_1   y LUT input scale for positive portion   default=0
+//Bit  1: 0, reg_xvycc_cmpr_invlut_yscl_0   y LUT input scale for negative portion   default=0
+#define   XVYCC_LUT_CTL                            (0x3165)
+#define P_XVYCC_LUT_CTL                            (volatile unsigned int *)((0x3165  << 2) + 0xff900000)
+//Bit 31: 7, reserved
+//Bit  6: 4, reg_xvycc_lut_enable  LUT enable [6] for R, [5] for G, [4] for B  default=0
+//Bit  3: 2, reg_xvycc_lut_scl_1   LUT input scale for positive portion   default=0
+//Bit  1: 0, reg_xvycc_lut_scl_0   LUT input scale for negative portion   default=0
+#define   XVYCC_VADJ1_CURV_0                       (0x3166)
+#define P_XVYCC_VADJ1_CURV_0                       (volatile unsigned int *)((0x3166  << 2) + 0xff900000)
+//Bit 31:24, vadj1_softcon_curv0_ci                         default=0
+//Bit 23:12, vadj1_softcon_curv0_b                          default=0
+//Bit 11: 0, vadj1_softcon_curv0_a                          default=0
+#define   XVYCC_VADJ1_CURV_1                       (0x3167)
+#define P_XVYCC_VADJ1_CURV_1                       (volatile unsigned int *)((0x3167  << 2) + 0xff900000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj1_softcon_curv0_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj1_softcon_curv0_cs                         default=0
+#define   XVYCC_VADJ1_CURV_2                       (0x3168)
+#define P_XVYCC_VADJ1_CURV_2                       (volatile unsigned int *)((0x3168  << 2) + 0xff900000)
+//Bit 31:24, vadj1_softcon_curv1_ci                         default=0
+//Bit 23:12, vadj1_softcon_curv1_b                          default=0
+//Bit 11: 0, vadj1_softcon_curv1_a                          default=0
+#define   XVYCC_VADJ1_CURV_3                       (0x3169)
+#define P_XVYCC_VADJ1_CURV_3                       (volatile unsigned int *)((0x3169  << 2) + 0xff900000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj1_softcon_curv1_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj1_softcon_curv1_cs                         default=0
+#define   XVYCC_VADJ2_CURV_0                       (0x316a)
+#define P_XVYCC_VADJ2_CURV_0                       (volatile unsigned int *)((0x316a  << 2) + 0xff900000)
+//Bit 31:24, vadj2_softcon_curv0_ci                         default=0
+//Bit 23:12, vadj2_softcon_curv0_b                          default=0
+//Bit 11: 0, vadj2_softcon_curv0_a                          default=0
+#define   XVYCC_VADJ2_CURV_1                       (0x316b)
+#define P_XVYCC_VADJ2_CURV_1                       (volatile unsigned int *)((0x316b  << 2) + 0xff900000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj2_softcon_curv0_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj2_softcon_curv0_cs                         default=0
+#define   XVYCC_VADJ2_CURV_2                       (0x316c)
+#define P_XVYCC_VADJ2_CURV_2                       (volatile unsigned int *)((0x316c  << 2) + 0xff900000)
+//Bit 31:24, vadj2_softcon_curv1_ci                         default=0
+//Bit 23:12, vadj2_softcon_curv1_b                          default=0
+//Bit 11: 0, vadj2_softcon_curv1_a                          default=0
+#define   XVYCC_VADJ2_CURV_3                       (0x316d)
+#define P_XVYCC_VADJ2_CURV_3                       (volatile unsigned int *)((0x316d  << 2) + 0xff900000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj2_softcon_curv1_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj2_softcon_curv1_cs                         default=0
+#define   XVYCC_VD1_RGB_CTRST                      (0x3170)
+#define P_XVYCC_VD1_RGB_CTRST                      (volatile unsigned int *)((0x3170  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:16, reg_vd1_rgb_ctrst        u12, contrast in rgb.      default=1024
+//Bit 15:14, reserved
+//Bit 13: 4, reg_vd1_rgb_ctrst_blklvl u10, contrast blacklevel   default=64
+//Bit  3: 2, reserved
+//Bit     1, reg_vd1_rgbbst_en         u1, enable rgbbst         default=0
+//Bit     0, reg_vd1_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1
+#define   XVYCC_VD1_RGB_BRGHT                      (0x3171)
+#define P_XVYCC_VD1_RGB_BRGHT                      (volatile unsigned int *)((0x3171  << 2) + 0xff900000)
+//Bit 31:16, reserved
+//Bit 15: 4, reg_vd1_rgb_brght        s12, brightness level in rgb domain                              default=0
+//Bit  3: 2, reserved
+//Bit     1, reg_vd1_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
+//Bit     0, reg_vd1_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
+#define   XVYCC_VD1_RGB_DLUT_0_3                   (0x3172)
+#define P_XVYCC_VD1_RGB_DLUT_0_3                   (volatile unsigned int *)((0x3172  << 2) + 0xff900000)
+//Bit 31:24, reg_vd1_rgbbst_dlut0      u8,   default = 255
+//Bit 23:16, reg_vd1_rgbbst_dlut1      u8,   default = 205
+//Bit 15: 8, reg_vd1_rgbbst_dlut2      u8,   default = 171
+//Bit  7: 0, reg_vd1_rgbbst_dlut3      u8,   default = 147
+#define   XVYCC_VD1_RGB_DLUT_4_7                   (0x3173)
+#define P_XVYCC_VD1_RGB_DLUT_4_7                   (volatile unsigned int *)((0x3173  << 2) + 0xff900000)
+//Bit 31:24, reg_vd1_rgbbst_dlut4      u8,   default = 128
+//Bit 23:16, reg_vd1_rgbbst_dlut5      u8,   default = 113
+//Bit 15: 8, reg_vd1_rgbbst_dlut6      u8,   default = 102
+//Bit  7: 0, reg_vd1_rgbbst_dlut7      u8,   default = 93
+#define   XVYCC_VD1_RGB_DLUT_8_11                  (0x3174)
+#define P_XVYCC_VD1_RGB_DLUT_8_11                  (volatile unsigned int *)((0x3174  << 2) + 0xff900000)
+//Bit 31:24, reg_vd1_rgbbst_dlut8      u8,   default = 85
+//Bit 23:16, reg_vd1_rgbbst_dlut9      u8,   default = 78
+//Bit 15: 8, reg_vd1_rgbbst_dlut10     u8,   default = 73
+//Bit  7: 0, reg_vd1_rgbbst_dlut11     u8,   default = 68
+#define   XVYCC_POST_RGB_CTRST                     (0x3175)
+#define P_XVYCC_POST_RGB_CTRST                     (volatile unsigned int *)((0x3175  << 2) + 0xff900000)
+//Bit 31:28, reserved
+//Bit 27:16, reg_post_rgb_ctrst        u12, contrast in rgb.      default=1024
+//Bit 15:14, reserved
+//Bit 13: 4, reg_post_rgb_ctrst_blklvl u10, contrast blacklevel   default=64
+//Bit  3: 2, reserved
+//Bit     1, reg_post_rgbbst_en         u1, enable rgbbst         default=0
+//Bit     0, reg_post_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1
+#define   XVYCC_POST_RGB_BRGHT                     (0x3176)
+#define P_XVYCC_POST_RGB_BRGHT                     (volatile unsigned int *)((0x3176  << 2) + 0xff900000)
+//Bit 31:16, reserved
+//Bit 15: 4, reg_post_rgb_brght        s12, brightness level in rgb domain                              default=0
+//Bit  3: 2, reserved
+//Bit     1, reg_post_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
+//Bit     0, reg_post_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
+#define   XVYCC_POST_RGB_DLUT_0_3                  (0x3177)
+#define P_XVYCC_POST_RGB_DLUT_0_3                  (volatile unsigned int *)((0x3177  << 2) + 0xff900000)
+//Bit 31:24, reg_post_rgbbst_dlut0      u8,   default = 255
+//Bit 23:16, reg_post_rgbbst_dlut1      u8,   default = 205
+//Bit 15: 8, reg_post_rgbbst_dlut2      u8,   default = 171
+//Bit  7: 0, reg_post_rgbbst_dlut3      u8,   default = 147
+#define   XVYCC_POST_RGB_DLUT_4_7                  (0x3178)
+#define P_XVYCC_POST_RGB_DLUT_4_7                  (volatile unsigned int *)((0x3178  << 2) + 0xff900000)
+//Bit 31:24, reg_post_rgbbst_dlut4      u8,   default = 128
+//Bit 23:16, reg_post_rgbbst_dlut5      u8,   default = 113
+//Bit 15: 8, reg_post_rgbbst_dlut6      u8,   default = 102
+//Bit  7: 0, reg_post_rgbbst_dlut7      u8,   default = 93
+#define   XVYCC_POST_RGB_DLUT_8_11                 (0x3179)
+#define P_XVYCC_POST_RGB_DLUT_8_11                 (volatile unsigned int *)((0x3179  << 2) + 0xff900000)
+//Bit 31:24, reg_post_rgbbst_dlut8      u8,   default = 85
+//Bit 23:16, reg_post_rgbbst_dlut9      u8,   default = 78
+//Bit 15: 8, reg_post_rgbbst_dlut10     u8,   default = 73
+//Bit  7: 0, reg_post_rgbbst_dlut11     u8,   default = 68
+#define   ADAPTIVE_SCALE_REG0                      (0x3150)
+#define P_ADAPTIVE_SCALE_REG0                      (volatile unsigned int *)((0x3150  << 2) + 0xff900000)
+//Bit 31,    reg_adaptive_scale_enable    u1,  default = 1
+//Bit 27:16, reg_adpscl_ys_coef_0        u12,  default = 538
+//Bit 11: 0, reg_adpscl_ys_coef_1        u12,  default = 1389
+#define   ADAPTIVE_SCALE_REG1                      (0x3151)
+#define P_ADAPTIVE_SCALE_REG1                      (volatile unsigned int *)((0x3151  << 2) + 0xff900000)
+//Bit 27:16, reg_adpscl_ys_coef_2        u12,  default = 121
+//Bit 11: 0, reg_adpscl_alpha_0          u12,  default = 1024
+#define   ADAPTIVE_SCALE_REG2                      (0x3152)
+#define P_ADAPTIVE_SCALE_REG2                      (volatile unsigned int *)((0x3152  << 2) + 0xff900000)
+//Bit 27:16, reg_adpscl_alpha_1          u12,  default = 1024
+//Bit 11: 0, reg_adpscl_alpha_2          u12,  default = 1024
+#define   ADAPTIVE_SCALE_REG3                      (0x3153)
+#define P_ADAPTIVE_SCALE_REG3                      (volatile unsigned int *)((0x3153  << 2) + 0xff900000)
+//Bit 31:16, reg_adpscl_beta_0          u16,  default = 0
+//Bit 15: 0, reg_adpscl_beta_1          u16,  default = 0
+#define   ADAPTIVE_SCALE_REG4                      (0x3154)
+#define P_ADAPTIVE_SCALE_REG4                      (volatile unsigned int *)((0x3154  << 2) + 0xff900000)
+//Bit 31:16, reg_adpscl_beta_2          u16,  default = 0
+#define   ADAPTIVE_SCALE_ADDR                      (0x3155)
+#define P_ADAPTIVE_SCALE_ADDR                      (volatile unsigned int *)((0x3155  << 2) + 0xff900000)
+//Bit 6:0,   reg_lut_addr               u7,  default = 0
+#define   ADAPTIVE_SCALE_DATA                      (0x3156)
+#define P_ADAPTIVE_SCALE_DATA                      (volatile unsigned int *)((0x3156  << 2) + 0xff900000)
+//Bit 11:0,  reg_lut_data               u12,  default = 0
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  xvycc_regs.h
+//
+//register definition for vd2 afbc dec
+// 8'h80-8'h9f
+//
+// Reading file:  vd2_afbc_dec_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+////===============================////
+//// reg
+////===============================////
+#define   VD2_AFBC_ENABLE                          (0x3180)
+#define P_VD2_AFBC_ENABLE                          (volatile unsigned int *)((0x3180  << 2) + 0xff900000)
+//Bit   31:1,     reserved
+//Bit   8,        dec_enable        unsigned  , default = 0
+//Bit   7:1,      reserved
+//Bit   0,        frm_start         unsigned  , default = 0
+#define   VD2_AFBC_MODE                            (0x3181)
+#define P_VD2_AFBC_MODE                            (volatile unsigned int *)((0x3181  << 2) + 0xff900000)
+//Bit   31,       soft_reset        the use as go_field
+//Bit   30,       reserved
+//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
+//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
+//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
+//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
+//Bit   22:16,    hold_line_num
+//Bit   15:14,    burst_len         uns, default = 1, 0: burst1 1:burst2 2:burst4
+//Bit   13:8,     compbits_yuv      uns, default = 0 ,
+//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit
+//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit
+//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit
+//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
+#define   VD2_AFBC_SIZE_IN                         (0x3182)
+#define P_VD2_AFBC_SIZE_IN                         (volatile unsigned int *)((0x3182  << 2) + 0xff900000)
+//Bit   31:29,    reserved
+//Bit   28:16     hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
+//Bit   15:13,    reserved
+//Bit   12:0,     vsize_in          uns, default = 1080 , pic vert size in  unit: pixel
+#define   VD2_AFBC_DEC_DEF_COLOR                   (0x3183)
+#define P_VD2_AFBC_DEC_DEF_COLOR                   (volatile unsigned int *)((0x3183  << 2) + 0xff900000)
+//Bit   31:29,    reserved
+//Bit   29:20,   def_color_y        uns, default = 0, afbc dec y default setting value
+//Bit   19:10,   def_color_u        uns, default = 0, afbc dec u default setting value
+//Bit    9: 0,   def_color_v        uns, default = 0, afbc dec v default setting value
+#define   VD2_AFBC_CONV_CTRL                       (0x3184)
+#define P_VD2_AFBC_CONV_CTRL                       (volatile unsigned int *)((0x3184  << 2) + 0xff900000)
+//Bit   31:12,   reserved
+//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
+#define   VD2_AFBC_LBUF_DEPTH                      (0x3185)
+#define P_VD2_AFBC_LBUF_DEPTH                      (volatile unsigned int *)((0x3185  << 2) + 0xff900000)
+//Bit   31:28,   reserved
+//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
+//Bit   15:12,   reserved
+//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
+#define   VD2_AFBC_HEAD_BADDR                      (0x3186)
+#define P_VD2_AFBC_HEAD_BADDR                      (volatile unsigned int *)((0x3186  << 2) + 0xff900000)
+//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
+#define   VD2_AFBC_BODY_BADDR                      (0x3187)
+#define P_VD2_AFBC_BODY_BADDR                      (volatile unsigned int *)((0x3187  << 2) + 0xff900000)
+//Bit   31:0,   mif_data_baddr      uns, default = 32'h0001_0000;
+#define   VD2_AFBC_SIZE_OUT                        (0x3188)
+#define P_VD2_AFBC_SIZE_OUT                        (volatile unsigned int *)((0x3188  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   hsize_out          uns, default = 1920 ; // unit: 1 pixel
+//Bit   15:13,   reserved
+//Bit    12:0,   vsize_out          uns, default = 1080 ; // unit: 1 pixel
+#define   VD2_AFBC_OUT_YSCOPE                      (0x3189)
+#define P_VD2_AFBC_OUT_YSCOPE                      (volatile unsigned int *)((0x3189  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
+//Bit   15:13,   reserved
+//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
+#define   VD2_AFBC_STAT                            (0x318a)
+#define P_VD2_AFBC_STAT                            (volatile unsigned int *)((0x318a  << 2) + 0xff900000)
+//Bit   31:1,   reserved
+//Bit      0,   frm_end_stat         uns, frame end status
+#define   VD2_AFBC_VD_CFMT_CTRL                    (0x318b)
+#define P_VD2_AFBC_VD_CFMT_CTRL                    (volatile unsigned int *)((0x318b  << 2) + 0xff900000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 19    if true, always use phase0 while vertical formater, meaning always
+//          repeat data, no interpolation
+//Bit 18    if true, disable vertical formatter chroma repeat last line
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)
+//Bit 0     vertical formatter enable
+#define   VD2_AFBC_VD_CFMT_W                       (0x318c)
+#define P_VD2_AFBC_VD_CFMT_W                       (volatile unsigned int *)((0x318c  << 2) + 0xff900000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define   VD2_AFBC_MIF_HOR_SCOPE                   (0x318d)
+#define P_VD2_AFBC_MIF_HOR_SCOPE                   (volatile unsigned int *)((0x318d  << 2) + 0xff900000)
+//Bit   31:26,   reserved
+//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
+//Bit   15:10,   reserved
+//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
+#define   VD2_AFBC_MIF_VER_SCOPE                   (0x318e)
+#define P_VD2_AFBC_MIF_VER_SCOPE                   (volatile unsigned int *)((0x318e  << 2) + 0xff900000)
+//Bit   31:28,   reserved
+//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
+//Bit   15:12,   reserved
+//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
+#define   VD2_AFBC_PIXEL_HOR_SCOPE                 (0x318f)
+#define P_VD2_AFBC_PIXEL_HOR_SCOPE                 (volatile unsigned int *)((0x318f  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
+//Bit   15:13,   reserved
+//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
+#define   VD2_AFBC_PIXEL_VER_SCOPE                 (0x3190)
+#define P_VD2_AFBC_PIXEL_VER_SCOPE                 (volatile unsigned int *)((0x3190  << 2) + 0xff900000)
+//Bit   31:29,   reserved
+//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
+//Bit   15:13,   reserved
+//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
+#define   VD2_AFBC_VD_CFMT_H                       (0x3191)
+#define P_VD2_AFBC_VD_CFMT_H                       (volatile unsigned int *)((0x3191  << 2) + 0xff900000)
+//Bit 12:0   vertical formatter height
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vd2_afbc_dec_regs.h
+//
+//register definition for osd1 afbcd dec
+// 8'ha0-8'haf
+//
+// Reading file:  osd1_afbcd_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+////===============================////
+//// reg
+////===============================////
+#define   OSD1_AFBCD_ENABLE                        (0x31a0)
+#define P_OSD1_AFBCD_ENABLE                        (volatile unsigned int *)((0x31a0  << 2) + 0xff900000)
+//Bit   31:16,    reserved
+//Bit   15:9,     id_fifo_thrd      unsigned  , default = 64, axi id fifo threshold
+//Bit   8,        dec_enable        unsigned  , default = 0
+//Bit   7:1,      reserved
+//Bit   0,        frm_start         unsigned  , default = 0
+#define   OSD1_AFBCD_MODE                          (0x31a1)
+#define P_OSD1_AFBCD_MODE                          (volatile unsigned int *)((0x31a1  << 2) + 0xff900000)
+//Bit   31,       soft_reset              the use as go_field
+//Bit   30:29,    reserved
+//Bit   28,       axi_reorder_mode        default=0, the axi reorder mode, note : don't seting
+//Bit   27:26,    reserved
+//Bit   25:24,    mif_urgent              uns, default = 3 , info mif and data mif urgent
+//Bit   22:16,    hold_line_num
+//Bit   15:8,     rgba_exchan_ctrl
+//Bit   7,        reserved
+//Bit   6,        hreg_block_split        uns, default = 1 , Enable/disable block split mode in sparse allocation
+//Bit   5,        hreg_half_block         uns, default = 1 , Enable/disable half block decoding. 1=half block, 0=full block
+//Bit   4:0,      hreg_pixel_packing_fmt  uns, default = 5 , Pixel format
+#define   OSD1_AFBCD_SIZE_IN                       (0x31a2)
+#define P_OSD1_AFBCD_SIZE_IN                       (volatile unsigned int *)((0x31a2  << 2) + 0xff900000)
+//Bit   31:16     hreg_hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
+//Bit   15:0,     hreg_vsize_in          uns, default = 1080 , pic vert size in  unit: pixel
+#define   OSD1_AFBCD_HDR_PTR                       (0x31a3)
+#define P_OSD1_AFBCD_HDR_PTR                       (volatile unsigned int *)((0x31a3  << 2) + 0xff900000)
+//Bit   31:0      hreg_hdr_ptr           uns, default = 0 ,
+#define   OSD1_AFBCD_FRAME_PTR                     (0x31a4)
+#define P_OSD1_AFBCD_FRAME_PTR                     (volatile unsigned int *)((0x31a4  << 2) + 0xff900000)
+//Bit   31:0      hreg_frame_ptr         uns, default = 0 , The start address of the target frame buffer.
+//                                       For YUV format, this pointer specifies the luma buffer.
+#define   OSD1_AFBCD_CHROMA_PTR                    (0x31a5)
+#define P_OSD1_AFBCD_CHROMA_PTR                    (volatile unsigned int *)((0x31a5  << 2) + 0xff900000)
+//Bit   31:0      hreg_chroma_ptr        uns, default = 0 , Only valid in YUV format, to specify the target chroma buffer.
+#define   OSD1_AFBCD_CONV_CTRL                     (0x31a6)
+#define P_OSD1_AFBCD_CONV_CTRL                     (volatile unsigned int *)((0x31a6  << 2) + 0xff900000)
+//Bit   31:15,   reserved
+//Bit   15: 0,   conv_lbuf_len           uns, default = 1024, unit=16 pixel need to set = 2^n
+#define   OSD1_AFBCD_STATUS                        (0x31a8)
+#define P_OSD1_AFBCD_STATUS                        (volatile unsigned int *)((0x31a8  << 2) + 0xff900000)
+//Bit   30:4,     reserved
+//Bit   3,        hreg_dec_resp          uns, default = 0 , Decoder error flage from the dec4x4 core
+//Bit   2,        hreg_axi_bresp         uns, default = 0 , Bus error flag for AXI write error
+//Bit   1,        hreg_axi_rresp         uns, default = 0 , Bus error flag for AXI read error
+//Bit   0,        hreg_idle_n            uns, default = 0 , Idle output, value 0 indicates the standalone decoder is free now and can start the next frame.
+#define   OSD1_AFBCD_PIXEL_HSCOPE                  (0x31a9)
+#define P_OSD1_AFBCD_PIXEL_HSCOPE                  (volatile unsigned int *)((0x31a9  << 2) + 0xff900000)
+//Bit   31:16,   dec_pixel_bgn_h         uns, default = 0  ; // unit: pixel
+//Bit   15: 0,   dec_pixel_end_h         uns, default = 1919 ; // unit: pixel
+#define   OSD1_AFBCD_PIXEL_VSCOPE                  (0x31aa)
+#define P_OSD1_AFBCD_PIXEL_VSCOPE                  (volatile unsigned int *)((0x31aa  << 2) + 0xff900000)
+//Bit   31:16,   dec_pixel_bgn_v         uns, default = 0  ; // unit: pixel
+//Bit   15: 0,   dec_pixel_end_v         uns, default = 1079 ; // unit: pixel
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  osd1_afbcd_regs.h
+//
+//register definition for osd1 afbcd dec
+// 8'hb0-8'hca
+//
+// Reading file:  vpp_wm_regs.h
+//
+//// synopsys translate_off
+//`ifdef VPP_WM_REGS_H
+//`else
+//    `define VPP_WM_REGS_H
+//// synopsys translate_on
+//    `define VPPB_VCBUS_BASE                8'h32
+#define   WM_CTRL                                  (0x31b0)
+#define P_WM_CTRL                                  (volatile unsigned int *)((0x31b0  << 2) + 0xff900000)
+//Bit  31,      int_mask					default = 0
+//Bit  30:16,	reserved
+//Bit  15:8,	strength_multiply			default =1
+//Bit  7:6,		reserved
+//Bit  5,       shift_en                      default = 0
+//Bit  4,		background_embedding_on			default =0
+//Bit  3,		mark_en			default =0
+//Bit  2,		noise_en			default =0
+//Bit  1,		blend_en			default =0
+//Bit  0,		wm_en			default =0
+#define   WM_SPACE_RESOLUTION                      (0x31b1)
+#define P_WM_SPACE_RESOLUTION                      (volatile unsigned int *)((0x31b1  << 2) + 0xff900000)
+//Bit  31:25,	reserved
+//Bit  24:16,	spacing_horz			default =10
+//Bit  15:9,    reserved
+//Bit  8:0,		spacing_vert			default =12
+#define   WM_SYMBOLS_NUM                           (0x31b2)
+#define P_WM_SYMBOLS_NUM                           (volatile unsigned int *)((0x31b2  << 2) + 0xff900000)
+//Bit  31:8, reserved
+//Bit  7:4, symbols_cols		1~10;	default =5
+//Bit  3:0, symbols_rows		1~10;	default =2
+#define   WM_MARK_RESOLUTION                       (0x31b3)
+#define P_WM_MARK_RESOLUTION                       (volatile unsigned int *)((0x31b3  << 2) + 0xff900000)
+//Bit  31:20,  mark_hsize		mark_buffer_width;  	default =1820
+//Bit  19:8,   mark_vsize		mark_buffer_height; 	default =1820             t =780
+//Bit  7:6,		reserved
+//Bit  5:0,		scale			default =13                  // scale up
+#define   WM_FREQ_DIST_LEFT                        (0x31b4)
+#define P_WM_FREQ_DIST_LEFT                        (volatile unsigned int *)((0x31b4  << 2) + 0xff900000)
+//Bit  31:21, reserved
+//Bit  20:0, freq_dist_left			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
+#define   WM_FREQ_DIST_RIGHT                       (0x31b5)
+#define P_WM_FREQ_DIST_RIGHT                       (volatile unsigned int *)((0x31b5  << 2) + 0xff900000)
+//Bit  31:21, reserved
+//Bit  20:0, freq_dist_right			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
+#define   WM_FREQ_DIST_TOP                         (0x31b6)
+#define P_WM_FREQ_DIST_TOP                         (volatile unsigned int *)((0x31b6  << 2) + 0xff900000)
+//Bit  31:21, reserved
+//Bit  20:0, freq_dist_top			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
+#define   WM_SYMBOLS_XPOS                          (0x31b7)
+#define P_WM_SYMBOLS_XPOS                          (volatile unsigned int *)((0x31b7  << 2) + 0xff900000)
+//Bit  31:29, reserved
+//Bit  28:16, symbols_xpos_start			default =1536      // SYMBOLS_XPOS * h_res
+//Bit  15:13, reserved
+//Bit  12:0,  symbols_xpos_end			default =3356        // SYMBOLS_XPOS * h_res + mark_hsize
+#define   WM_SYMBOLS_YPOS                          (0x31b8)
+#define P_WM_SYMBOLS_YPOS                          (volatile unsigned int *)((0x31b8  << 2) + 0xff900000)
+//Bit  31:29, reserved
+//Bit  28:16, symbols_ypos_start			default =756      // SYMBOLS_yPOS * y_res
+//Bit  15:13, reserved
+//Bit  12:0,  symbols_ypos_end			    default =1536        // SYMBOLS_yPOS * y_res + mark_vsize
+#define   WM_STORAGE_SETTING                       (0x31b9)
+#define P_WM_STORAGE_SETTING                       (volatile unsigned int *)((0x31b9  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, direction_max		default = 80
+//Bit	  15, reserved
+//Bit   14:8, storage_s			default =18               // biggest is 72      S
+//Bit      7, reserved
+//Bit    6:0, storage_max_distance			default =36    // biggest is 72      max_distance
+#define   WM_VIDEO_RESOLUTION                      (0x31ba)
+#define P_WM_VIDEO_RESOLUTION                      (volatile unsigned int *)((0x31ba  << 2) + 0xff900000)
+//Bit  31:29, reserved
+//Bit  28:16, h_res			default =3840                   // video hsize
+//Bit  15:13, reserved
+//Bit  12:0,  v_res			default =2160                   // video vsize
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD0         (0x31bb)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD0         (volatile unsigned int *)((0x31bb  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_0		default =48
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_1		default =60
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD1         (0x31bc)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD1         (volatile unsigned int *)((0x31bc  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_2		default = 68
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_3		default = 80
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD2         (0x31bd)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD2         (volatile unsigned int *)((0x31bd  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_4		default = 88
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_5		default = 96
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD3         (0x31be)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD3         (volatile unsigned int *)((0x31be  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_6		default = 100
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_7		default = 108
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD4         (0x31bf)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD4         (volatile unsigned int *)((0x31bf  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_8		default = 112
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_9		default = 116
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD5         (0x31c0)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD5         (volatile unsigned int *)((0x31c0  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_10		default = 120
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_11		default = 124
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD_BG0      (0x31c1)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG0      (volatile unsigned int *)((0x31c1  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_bg_0		default =320
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_bg_1		default = 328
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD_BG1      (0x31c2)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG1      (volatile unsigned int *)((0x31c2  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_bg_2		default = 332
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_bg_3		default = 340
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD_BG2      (0x31c3)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG2      (volatile unsigned int *)((0x31c3  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_bg_4		default = 344
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_bg_5		default = 348
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD_BG3      (0x31c4)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG3      (volatile unsigned int *)((0x31c4  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_bg_6		default = 352
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_bg_7		default = 356
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD_BG4      (0x31c5)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG4      (volatile unsigned int *)((0x31c5  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_bg_8		default = 360
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_bg_9		default = 368
+#define   WM_EMBEDDING_STRENGTH_THRESHOLD_BG5      (0x31c6)
+#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG5      (volatile unsigned int *)((0x31c6  << 2) + 0xff900000)
+//Bit  31:28, reserved
+//Bit  27:16, embedding_strength_threshold_bg_10		default = 372
+//Bit  15:12, reserved
+//Bit  11:0,  embedding_strength_threshold_bg_11		default = 380
+#define   WM_AM_LUT_DATA_PORT                      (0x31c7)
+#define P_WM_AM_LUT_DATA_PORT                      (volatile unsigned int *)((0x31c7  << 2) + 0xff900000)
+#define   WM_AM_LUT_ADDR_PORT                      (0x31c8)
+#define P_WM_AM_LUT_ADDR_PORT                      (volatile unsigned int *)((0x31c8  << 2) + 0xff900000)
+#define   WM_STATUS_RO                             (0x31c9)
+#define P_WM_STATUS_RO                             (volatile unsigned int *)((0x31c9  << 2) + 0xff900000)
+//Bit  31,  ro_resolution_changed
+//Bit  30:29, reserved
+//Bit  30:16, ro_hsize_in
+//Bit  15:13, reserved
+//Bit  8:0,   ro_vsize_in
+#define   WM_STATUS_RAM_RO                         (0x31ca)
+#define P_WM_STATUS_RAM_RO                         (volatile unsigned int *)((0x31ca  << 2) + 0xff900000)
+//Bit  31:9,  reserved
+//Bit  8:0,   ro_ram_addr
+#define   WM_THRES_ADDR_PORT                       (0x31cb)
+#define P_WM_THRES_ADDR_PORT                       (volatile unsigned int *)((0x31cb  << 2) + 0xff900000)
+#define   WM_THRES_DATA_PORT                       (0x31cd)
+#define P_WM_THRES_DATA_PORT                       (volatile unsigned int *)((0x31cd  << 2) + 0xff900000)
+//
+// Closing file:  vpp_wm_regs.h
+//
+// 8'hd0-8hef
+//
+// Reading file:  bt2020_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//    `define XVYCC_VCBUS_BASE	   8'hfe
+//Bit 31:27 for all [31] for all eotf enable,[30] for matrix3x3 enable, [29:27] for eotf_ch0~3
+//Bit 17:6  for clock gating
+//Bit 5:4   pscale_mode ch2
+//Bit 3:2   pscale_mode ch1
+//Bit 1:0   pscale_mode ch0
+#define   VPP_EOTF_CTL                             (0x31d0)
+#define P_VPP_EOTF_CTL                             (volatile unsigned int *)((0x31d0  << 2) + 0xff900000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   VPP_EOTF_COEF00_01                       (0x31d1)
+#define P_VPP_EOTF_COEF00_01                       (volatile unsigned int *)((0x31d1  << 2) + 0xff900000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   VPP_EOTF_COEF02_10                       (0x31d2)
+#define P_VPP_EOTF_COEF02_10                       (volatile unsigned int *)((0x31d2  << 2) + 0xff900000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   VPP_EOTF_COEF11_12                       (0x31d3)
+#define P_VPP_EOTF_COEF11_12                       (volatile unsigned int *)((0x31d3  << 2) + 0xff900000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   VPP_EOTF_COEF20_21                       (0x31d4)
+#define P_VPP_EOTF_COEF20_21                       (volatile unsigned int *)((0x31d4  << 2) + 0xff900000)
+//Bit 28:16 coef22
+//Bit   2:0 coef_rs
+#define   VPP_EOTF_COEF22_RS                       (0x31d5)
+#define P_VPP_EOTF_COEF22_RS                       (volatile unsigned int *)((0x31d5  << 2) + 0xff900000)
+#define   VPP_EOTF_LUT_ADDR_PORT                   (0x31d6)
+#define P_VPP_EOTF_LUT_ADDR_PORT                   (volatile unsigned int *)((0x31d6  << 2) + 0xff900000)
+#define   VPP_EOTF_LUT_DATA_PORT                   (0x31d7)
+#define P_VPP_EOTF_LUT_DATA_PORT                   (volatile unsigned int *)((0x31d7  << 2) + 0xff900000)
+#define   VPP_EOTF_3X3_OFST_0                      (0x31d8)
+#define P_VPP_EOTF_3X3_OFST_0                      (volatile unsigned int *)((0x31d8  << 2) + 0xff900000)
+#define   VPP_EOTF_3X3_OFST_1                      (0x31d9)
+#define P_VPP_EOTF_3X3_OFST_1                      (volatile unsigned int *)((0x31d9  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  bt2020_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  srscl_reg.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  VPPC_VCBUS_BASE = 0x32
+// -----------------------------------------------
+//
+// Reading file:  srsharp_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// `define  VPPB_VCBUS_BASE   8'h31
+//VDIN0        8'h00 - 8'h7f
+//VDIN1        8'h80 - 8'hef
+#define  SRSHARP0_OFFSET   (0x00<<2)
+#define  SRSHARP1_OFFSET   (0x80<<2)
+
+//
+// Reading file:  sharp_regs.h
+//
+#define   SHARP_HVSIZE                             (0x3200)
+#define P_SHARP_HVSIZE                             (volatile unsigned int *)((0x3200  << 2) + 0xff900000)
+//Bit 31:29,        reserved
+//Bit 28:16,        reg_pknr_hsize                                                                                                              . unsigned  , default = 1920
+//Bit 15:13,        reserved
+//Bit 12: 0,        reg_pknr_vsize                                                                                                              . unsigned  , default = 1080
+#define   SHARP_HVBLANK_NUM                        (0x3201)
+#define P_SHARP_HVBLANK_NUM                        (volatile unsigned int *)((0x3201  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_pknr_hblank_num                                                                                                         . unsigned  , default = 20
+//Bit  7: 0,        reg_pknr_vblank_num                                                                                                         . unsigned  , default = 73
+#define   NR_GAUSSIAN_MODE                         (0x3202)
+#define P_NR_GAUSSIAN_MODE                         (volatile unsigned int *)((0x3202  << 2) + 0xff900000)
+//Bit 31: 5,        reserved
+//Bit  4,            reg_nr_gau_ymode                            : 0 3x3 filter; 1: 5x5 filter                                                   . unsigned  , default = 1
+//Bit  3: 1,        reserved
+//Bit  0,            reg_nr_gau_cmode                            : 0 3x3 filter; 1: 5x5 filter                                                   . unsigned  , default = 1
+#define   PK_CON_2CIRHPGAIN_TH_RATE                (0x3205)
+#define P_PK_CON_2CIRHPGAIN_TH_RATE                (volatile unsigned int *)((0x3205  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_cirhpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 25
+//Bit 23:16,        reg_pk_cirhpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 60
+//Bit 15: 8,        reg_pk_cirhpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 80
+//Bit  7: 0,        reg_pk_cirhpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 20
+#define   PK_CON_2CIRHPGAIN_LIMIT                  (0x3206)
+#define P_PK_CON_2CIRHPGAIN_LIMIT                  (volatile unsigned int *)((0x3206  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_cirhpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 155
+//Bit 23:16,        reg_pk_cirhpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 150
+//Bit 15: 8,        reg_pk_cirhpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 5
+//Bit  7: 0,        reserved
+#define   PK_CON_2CIRBPGAIN_TH_RATE                (0x3207)
+#define P_PK_CON_2CIRBPGAIN_TH_RATE                (volatile unsigned int *)((0x3207  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_cirbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 20
+//Bit 23:16,        reg_pk_cirbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).. unsigned  , default = 50
+//Bit 15: 8,        reg_pk_cirbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 50
+//Bit  7: 0,        reg_pk_cirbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 25
+#define   PK_CON_2CIRBPGAIN_LIMIT                  (0x3208)
+#define P_PK_CON_2CIRBPGAIN_LIMIT                  (volatile unsigned int *)((0x3208  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_cirbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 155
+//Bit 23:16,        reg_pk_cirbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 150
+//Bit 15: 8,        reg_pk_cirbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 5
+//Bit  7: 0,        reserved
+#define   PK_CON_2DRTHPGAIN_TH_RATE                (0x3209)
+#define P_PK_CON_2DRTHPGAIN_TH_RATE                (volatile unsigned int *)((0x3209  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_drthpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 25
+//Bit 23:16,        reg_pk_drthpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 60
+//Bit 15: 8,        reg_pk_drthpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 80
+//Bit  7: 0,        reg_pk_drthpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 20
+#define   PK_CON_2DRTHPGAIN_LIMIT                  (0x320a)
+#define P_PK_CON_2DRTHPGAIN_LIMIT                  (volatile unsigned int *)((0x320a  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_drthpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).. unsigned  , default = 105
+//Bit 23:16,        reg_pk_drthpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 96
+//Bit 15: 8,        reg_pk_drthpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 5
+//Bit  7: 0,        reserved
+#define   PK_CON_2DRTBPGAIN_TH_RATE                (0x320b)
+#define P_PK_CON_2DRTBPGAIN_TH_RATE                (volatile unsigned int *)((0x320b  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_drtbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 20
+//Bit 23:16,        reg_pk_drtbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50
+//Bit 15: 8,        reg_pk_drtbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50
+//Bit  7: 0,        reg_pk_drtbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 25
+#define   PK_CON_2DRTBPGAIN_LIMIT                  (0x320c)
+#define P_PK_CON_2DRTBPGAIN_LIMIT                  (volatile unsigned int *)((0x320c  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_drtbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 55
+//Bit 23:16,        reg_pk_drtbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40
+//Bit 15: 8,        reg_pk_drtbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 5
+//Bit  7: 0,        reserved
+#define   PK_CIRFB_LPF_MODE                        (0x320d)
+#define P_PK_CIRFB_LPF_MODE                        (volatile unsigned int *)((0x320d  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:28,        reg_cirhp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
+//Bit 27:26,        reserved
+//Bit 25:24,        reg_cirhp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
+//Bit 23:22,        reserved
+//Bit 21:20,        reg_cirhp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1
+//Bit 19:14,        reserved
+//Bit 13:12,        reg_cirbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
+//Bit 11:10,        reserved
+//Bit  9: 8,        reg_cirbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
+//Bit  7: 6,        reserved
+//Bit  5: 4,        reg_cirbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1
+//Bit  3: 0,        reserved
+#define   PK_DRTFB_LPF_MODE                        (0x320e)
+#define P_PK_DRTFB_LPF_MODE                        (volatile unsigned int *)((0x320e  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:28,        reg_drthp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
+//Bit 27:26,        reserved
+//Bit 25:24,        reg_drthp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
+//Bit 23:22,        reserved
+//Bit 21:20,        reg_drthp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1
+//Bit 19:14,        reserved
+//Bit 13:12,        reg_drtbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
+//Bit 11:10,        reserved
+//Bit  9: 8,        reg_drtbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
+//Bit  7: 6,        reserved
+//Bit  5: 4,        reg_drtbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1
+//Bit  3: 0,        reserved
+#define   PK_CIRFB_HP_CORING                       (0x320f)
+#define P_PK_CIRFB_HP_CORING                       (volatile unsigned int *)((0x320f  << 2) + 0xff900000)
+//Bit 31:22,        reserved
+//Bit 21:16,        reg_cirhp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_cirhp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_cirhp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 0
+#define   PK_CIRFB_BP_CORING                       (0x3210)
+#define P_PK_CIRFB_BP_CORING                       (volatile unsigned int *)((0x3210  << 2) + 0xff900000)
+//Bit 31:22,        reserved
+//Bit 21:16,        reg_cirbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_cirbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_cirbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
+#define   PK_DRTFB_HP_CORING                       (0x3211)
+#define P_PK_DRTFB_HP_CORING                       (volatile unsigned int *)((0x3211  << 2) + 0xff900000)
+//Bit 31:22,        reserved
+//Bit 21:16,        reg_drthp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_drthp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_drthp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
+#define   PK_DRTFB_BP_CORING                       (0x3212)
+#define P_PK_DRTFB_BP_CORING                       (volatile unsigned int *)((0x3212  << 2) + 0xff900000)
+//Bit 31:22,        reserved
+//Bit 21:16,        reg_drtbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_drtbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_drtbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
+#define   PK_CIRFB_BLEND_GAIN                      (0x3213)
+#define P_PK_CIRFB_BLEND_GAIN                      (volatile unsigned int *)((0x3213  << 2) + 0xff900000)
+//Bit 31:28,        reg_hp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
+//Bit 27:24,        reg_hp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
+//Bit 23:20,        reg_hp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
+//Bit 19:16,        reserved
+//Bit 15:12,        reg_bp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
+//Bit 11: 8,        reg_bp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
+//Bit  7: 4,        reg_bp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
+//Bit  3: 0,        reserved
+#define   NR_ALPY_SSD_GAIN_OFST                    (0x3214)
+#define P_NR_ALPY_SSD_GAIN_OFST                    (volatile unsigned int *)((0x3214  << 2) + 0xff900000)
+//Bit 31:16,        reserved
+//Bit 15: 8,        reg_nr_alp0_ssd_gain                        : gain to max ssd normalized 16 as '1'                                          . unsigned  , default = 16
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_nr_alp0_ssd_ofst                        : offset to ssd before dividing to min_err                                      . signed    , default = -2
+#define   NR_ALP0Y_ERR2CURV_TH_RATE                (0x3215)
+#define P_NR_ALP0Y_ERR2CURV_TH_RATE                (volatile unsigned int *)((0x3215  << 2) + 0xff900000)
+//Bit 31:24,        reg_nr_alp0_minerr_ypar0                    : threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.. unsigned  , default = 10
+//Bit 23:16,        reg_nr_alp0_minerr_ypar1                    : threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25
+//Bit 15: 8,        reg_nr_alp0_minerr_ypar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80
+//Bit  7: 0,        reg_nr_alp0_minerr_ypar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64
+#define   NR_ALP0Y_ERR2CURV_LIMIT                  (0x3216)
+#define P_NR_ALP0Y_ERR2CURV_LIMIT                  (volatile unsigned int *)((0x3216  << 2) + 0xff900000)
+//Bit 31:24,        reg_nr_alp0_minerr_ypar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63
+//Bit 23:16,        reg_nr_alp0_minerr_ypar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0
+//Bit 15: 8,        reg_nr_alp0_minerr_ypar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63
+//Bit  7: 0,        reserved
+#define   NR_ALP0C_ERR2CURV_TH_RATE                (0x3217)
+#define P_NR_ALP0C_ERR2CURV_TH_RATE                (volatile unsigned int *)((0x3217  << 2) + 0xff900000)
+//Bit 31:24,        reg_nr_alp0_minerr_cpar0                    : threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.. unsigned  , default = 10
+//Bit 23:16,        reg_nr_alp0_minerr_cpar1                    : threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25
+//Bit 15: 8,        reg_nr_alp0_minerr_cpar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80
+//Bit  7: 0,        reg_nr_alp0_minerr_cpar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64
+#define   NR_ALP0C_ERR2CURV_LIMIT                  (0x3218)
+#define P_NR_ALP0C_ERR2CURV_LIMIT                  (volatile unsigned int *)((0x3218  << 2) + 0xff900000)
+//Bit 31:24,        reg_nr_alp0_minerr_cpar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63
+//Bit 23:16,        reg_nr_alp0_minerr_cpar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0
+//Bit 15: 8,        reg_nr_alp0_minerr_cpar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63
+//Bit  7: 0,        reserved
+#define   NR_ALP0_MIN_MAX                          (0x3219)
+#define P_NR_ALP0_MIN_MAX                          (volatile unsigned int *)((0x3219  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_nr_alp0_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
+//Bit 23:22,        reserved
+//Bit 21:16,        reg_nr_alp0_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_nr_alp0_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_nr_alp0_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
+#define   NR_ALP1_MIERR_CORING                     (0x321a)
+#define P_NR_ALP1_MIERR_CORING                     (volatile unsigned int *)((0x321a  << 2) + 0xff900000)
+//Bit 31:17,        reserved
+//Bit 16,            reg_nr_alp1_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_nr_alp1_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_nr_alp1_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 3
+#define   NR_ALP1_ERR2CURV_TH_RATE                 (0x321b)
+#define P_NR_ALP1_ERR2CURV_TH_RATE                 (volatile unsigned int *)((0x321b  << 2) + 0xff900000)
+//Bit 31:24,        reg_nr_alp1_minerr_par0                     : threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.. unsigned  , default = 0
+//Bit 23:16,        reg_nr_alp1_minerr_par1                     : threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.. unsigned  , default = 24
+//Bit 15: 8,        reg_nr_alp1_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope.. unsigned  , default = 0
+//Bit  7: 0,        reg_nr_alp1_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. unsigned  , default = 20
+#define   NR_ALP1_ERR2CURV_LIMIT                   (0x321c)
+#define P_NR_ALP1_ERR2CURV_LIMIT                   (volatile unsigned int *)((0x321c  << 2) + 0xff900000)
+//Bit 31:24,        reg_nr_alp1_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.. unsigned  , default = 0
+//Bit 23:16,        reg_nr_alp1_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.. unsigned  , default = 16
+//Bit 15: 8,        reg_nr_alp1_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before. unsigned  , default = 63
+//Bit  7: 0,        reserved
+#define   NR_ALP1_MIN_MAX                          (0x321d)
+#define P_NR_ALP1_MIN_MAX                          (volatile unsigned int *)((0x321d  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_nr_alp1_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
+//Bit 23:22,        reserved
+//Bit 21:16,        reg_nr_alp1_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_nr_alp1_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_nr_alp1_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
+#define   PK_ALP2_MIERR_CORING                     (0x321e)
+#define P_PK_ALP2_MIERR_CORING                     (volatile unsigned int *)((0x321e  << 2) + 0xff900000)
+//Bit 31:17,        reserved
+//Bit 16,            reg_pk_alp2_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 1
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_pk_alp2_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_pk_alp2_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 1
+#define   PK_ALP2_ERR2CURV_TH_RATE                 (0x321f)
+#define P_PK_ALP2_ERR2CURV_TH_RATE                 (volatile unsigned int *)((0x321f  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_alp2_minerr_par0                     : threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking.. unsigned  , default = 0
+//Bit 23:16,        reg_pk_alp2_minerr_par1                     : threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255.. unsigned  , default = 24
+//Bit 15: 8,        reg_pk_alp2_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 0
+//Bit  7: 0,        reg_pk_alp2_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 20
+#define   PK_ALP2_ERR2CURV_LIMIT                   (0x3220)
+#define P_PK_ALP2_ERR2CURV_LIMIT                   (volatile unsigned int *)((0x3220  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_alp2_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255.. unsigned  , default = 0
+//Bit 23:16,        reg_pk_alp2_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255.. unsigned  , default = 16
+//Bit 15: 8,        reg_pk_alp2_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 32;. unsigned  , default = 32
+//Bit  7: 0,        reserved
+#define   PK_ALP2_MIN_MAX                          (0x3221)
+#define P_PK_ALP2_MIN_MAX                          (volatile unsigned int *)((0x3221  << 2) + 0xff900000)
+//Bit 31:14,        reserved
+//Bit 13: 8,        reg_pk_alp2_min                             : normalized to 64 as '1'                                                       . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_pk_alp2_max                             : normalized to 64 as '1'                                                       . unsigned  , default = 63
+#define   PK_FINALGAIN_HP_BP                       (0x3222)
+#define P_PK_FINALGAIN_HP_BP                       (volatile unsigned int *)((0x3222  << 2) + 0xff900000)
+//Bit 31:18,        reserved
+//Bit 17:16,        reg_final_gain_rs                           : s2: right shift bits for the gain normalization, 0 normal to 32 as 1; 1 normalize to 64 as 1; -2 normalized to 8 as 1; -1 normalize 16 as 1. default = 0
+//Bit 15: 8,        reg_hp_final_gain                           : gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 40
+//Bit  7: 0,        reg_bp_final_gain                           : gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 30
+#define   PK_OS_HORZ_CORE_GAIN                     (0x3223)
+#define P_PK_OS_HORZ_CORE_GAIN                     (volatile unsigned int *)((0x3223  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_os_hsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8
+//Bit 23:16,        reg_pk_os_hsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
+//Bit 15: 8,        reg_pk_os_hmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2
+//Bit  7: 0,        reg_pk_os_hmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
+#define   PK_OS_VERT_CORE_GAIN                     (0x3224)
+#define P_PK_OS_VERT_CORE_GAIN                     (volatile unsigned int *)((0x3224  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_os_vsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8
+//Bit 23:16,        reg_pk_os_vsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
+//Bit 15: 8,        reg_pk_os_vmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2
+//Bit  7: 0,        reg_pk_os_vmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
+#define   PK_OS_ADPT_MISC                          (0x3225)
+#define P_PK_OS_ADPT_MISC                          (volatile unsigned int *)((0x3225  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_os_minerr_core                       : coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 40
+//Bit 23:16,        reg_pk_os_minerr_gain                       : gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255;. unsigned  , default = 6
+//Bit 15: 8,        reg_pk_os_adpt_max                          : maximum limit adaptive overshoot margin (4x). 0~255;                          . unsigned  , default = 200
+//Bit  7: 0,        reg_pk_os_adpt_min                          : minimun limit adaptive overshoot margin (1x). 0~255;                          . unsigned  , default = 20
+#define   PK_OS_STATIC                             (0x3226)
+#define P_PK_OS_STATIC                             (volatile unsigned int *)((0x3226  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:28,        reg_pk_osh_mode                             : 0~3: (2x+1) window in H direction                                             . unsigned  , default = 2
+//Bit 27:26,        reserved
+//Bit 25:24,        reg_pk_osv_mode                             : 0~3: (2x+1) window in V direction                                             . unsigned  , default = 2
+//Bit 23:22,        reserved
+//Bit 21:12,        reg_pk_os_down                              : static negative overshoot margin. 0~1023;                                     . unsigned  , default = 200
+//Bit 11:10,        reserved
+//Bit  9: 0,        reg_pk_os_up                                : static positive overshoot margin. 0~1023;                                     . unsigned  , default = 200
+#define   PK_NR_ENABLE                             (0x3227)
+#define P_PK_NR_ENABLE                             (volatile unsigned int *)((0x3227  << 2) + 0xff900000)
+//Bit 31: 4,        reserved
+//Bit  3: 2,        reg_3d_mode                                 , 0: no 3D; 1: L/R; 2: T/B; 3: horizontal interleaved, dft = 0                                             //. unsigned  , default = 0
+//Bit  1,            reg_pk_en                                                                                                                   . unsigned  , default = 1
+//Bit  0,            reg_nr_en                                                                                                                   . unsigned  , default = 1
+#define   PK_DRT_SAD_MISC                          (0x3228)
+#define P_PK_DRT_SAD_MISC                          (volatile unsigned int *)((0x3228  << 2) + 0xff900000)
+//Bit 31:24,        reg_pk_sad_ver_gain                         : gain to sad[4], 16 normalized to "1";                                         . unsigned  , default = 32
+//Bit 23:16,        reg_pk_sad_hor_gain                         : gain to sad[0], 16 normalized to "1";                                         . unsigned  , default = 24
+//Bit 15:12,        reserved
+//Bit 11            reserved
+//Bit 10: 9,        reg_pk_bias_diag                            : bias towards diag                                                             . unsigned  , default = 0
+//Bit  8,           reserved
+//Bit  7: 5,        reserved
+//Bit  4: 0,        reg_pk_drt_force                            : force direction of drt peaking filter, h2b: 0:hp drt force, 1: bp drt force; 2: bp+hp drt force, 3: no force;. unsigned  , default = 24
+#define   NR_TI_DNLP_BLEND                         (0x3229)
+#define P_NR_TI_DNLP_BLEND                         (volatile unsigned int *)((0x3229  << 2) + 0xff900000)
+//Bit 31:11,        reserved
+//Bit 10: 8,        reg_dnlp_input_mode                         : dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os). unsigned  , default = 4
+//Bit  7: 4,        reserved
+//Bit  3: 2,        reg_nr_cti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:cti; 2: (nr+cti)/2; 3:cti + dlt_nr  . unsigned  , default = 1
+//Bit  1: 0,        reg_nr_lti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:lti; 2: (nr+lti)/2; 3:lti + dlt_nr  . unsigned  , default = 2
+////////////////////////////////////////////////////////////////////////////////
+// new ti regsters from here
+////////////////////////////////////////////////////////////////////////////////
+#define   LTI_DIR_CORE_ALPHA                       (0x322a)
+#define P_LTI_DIR_CORE_ALPHA                       (volatile unsigned int *)((0x322a  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_adp_lti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 10
+//Bit 23:20,        reserved
+//Bit 19:16,        reg_adp_lti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_adp_lti_dir_alpmin                      : min value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=10              . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_adp_lti_dir_alpmax                      : max value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=63              . unsigned  , default = 63
+#define   CTI_DIR_ALPHA                            (0x322b)
+#define P_CTI_DIR_ALPHA                            (volatile unsigned int *)((0x322b  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_adp_cti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 5
+//Bit 23:20,        reserved
+//Bit 19:16,        reg_adp_cti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_adp_cti_dir_alpmin                      : min value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=10             . unsigned  , default = 0
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_adp_cti_dir_alpmax                      : max value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=63             . unsigned  , default = 63
+#define   LTI_CTI_DF_GAIN                          (0x322c)
+#define P_LTI_CTI_DF_GAIN                          (volatile unsigned int *)((0x322c  << 2) + 0xff900000)
+//Bit 31:30,        reserved
+//Bit 29:24,        reg_adp_lti_hdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
+//Bit 23:22,        reserved
+//Bit 21:16,        reg_adp_lti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
+//Bit 15:14,        reserved
+//Bit 13: 8,        reg_adp_cti_hdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
+//Bit  7: 6,        reserved
+//Bit  5: 0,        reg_adp_cti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
+#define   LTI_CTI_DIR_AC_DBG                       (0x322d)
+#define P_LTI_CTI_DIR_AC_DBG                       (volatile unsigned int *)((0x322d  << 2) + 0xff900000)
+//Bit 31,            reserved
+//Bit 30,            reg_adp_lti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf                                               . unsigned  , default = 1
+//Bit 29,            reserved
+//Bit 28,            reg_adp_lti_dir_difmode                     : 0: y_dif; 1: y_dif + (u_dif+v_dif)/2;                                         . unsigned  , default = 1
+//Bit 27,            reserved
+//Bit 26,            reg_adp_cti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf  dft=1                                        . unsigned  , default = 1
+//Bit 25:24,        reg_adp_cti_dir_difmode                     : 0: (u_dif+v_dif); 1: y_dif/2 + (u_dif+v_dif)*3/4; 2: y_dif + (u_dif+v_dif)/2; 3: y_dif*2 (not recomended). unsigned  , default = 2
+//Bit 23:22,        reg_adp_hvlti_dcblend_mode                  : 0: hlti_dc; 1:vlti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3
+//Bit 21:20,        reg_adp_hvcti_dcblend_mode                  : 0: hcti_dc; 1:vcti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 2
+//Bit 19:18,        reg_adp_hvlti_acblend_mode                  : hlti_ac; 1:vlti_ac; 2: add  3;:adaptive to alpha                              . unsigned  , default = 3
+//Bit 17:16,        reg_adp_hvcti_acblend_mode                  : hcti_ac; 1:vcti_ac; 2: add  3;: adaptive to alpha                             . unsigned  , default = 2
+//Bit 15,            reserved
+//Bit 14:12,        reg_adp_hlti_debug                          , for hlti debug, default = 0                                                   . unsigned  , default = 0
+//Bit 11,            reserved
+//Bit 10: 8,        reg_adp_vlti_debug                          , for vlti debug, default = 0                                                   . unsigned  , default = 0
+//Bit  7,            reserved
+//Bit  6: 4,        reg_adp_hcti_debug                          , for hcti debug, default = 0                                                   . unsigned  , default = 0
+//Bit  3,            reserved
+//Bit  2: 0,        reg_adp_vcti_debug                          , for vcti debug, default = 0                                                   . unsigned  , default = 0
+#define   HCTI_FLT_CLP_DC                          (0x322e)
+#define P_HCTI_FLT_CLP_DC                          (volatile unsigned int *)((0x322e  << 2) + 0xff900000)
+//Bit 31:29,        reserved
+//Bit 28,            reg_adp_hcti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1
+//Bit 27:26,        reg_adp_hcti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8  3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2
+//Bit 25:24,        reg_adp_hcti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2
+//Bit 23:22,        reg_adp_hcti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2     . unsigned  , default = 2
+//Bit 21:20,        reg_adp_hcti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 1        . unsigned  , default = 1
+//Bit 19:18,        reg_adp_hcti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 1        . unsigned  , default = 1
+//Bit 17:16,        reg_adp_hcti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 1       . unsigned  , default = 1
+//Bit 15:12,        reg_adp_hcti_hard_clp_win                   , window size, 0~8, default = 5                                                 . unsigned  , default = 5
+//Bit 11: 8,        reg_adp_hcti_hard_win_min                   , window size, 0~8, default = 3                                                 . unsigned  , default = 3
+//Bit  7: 5,        reserved
+//Bit  4,            reg_adp_hcti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 1                                   . unsigned  , default = 1
+//Bit  3,            reserved
+//Bit  2: 0,        reg_adp_hcti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 0    . unsigned  , default = 0
+#define   HCTI_BST_GAIN                            (0x322f)
+#define P_HCTI_BST_GAIN                            (volatile unsigned int *)((0x322f  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_hcti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 80                         . unsigned  , default = 80
+//Bit 23:16,        reg_adp_hcti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 96                          . unsigned  , default = 96
+//Bit 15: 8,        reg_adp_hcti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 64                          . unsigned  , default = 64
+//Bit  7: 0,        reg_adp_hcti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16
+#define   HCTI_BST_CORE                            (0x3230)
+#define P_HCTI_BST_CORE                            (volatile unsigned int *)((0x3230  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_hcti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5
+//Bit 23:16,        reg_adp_hcti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5
+//Bit 15: 8,        reg_adp_hcti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5
+//Bit  7: 0,        reg_adp_hcti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 5
+#define   HCTI_CON_2_GAIN_0                        (0x3231)
+#define P_HCTI_CON_2_GAIN_0                        (volatile unsigned int *)((0x3231  << 2) + 0xff900000)
+//Bit 31:29,        reg_adp_hcti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: .... default = 1. unsigned  , default = 1
+//Bit 28:26,        reg_adp_hcti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 2                       . unsigned  , default = 2
+//Bit 25:24,        reg_adp_hcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
+//Bit 23:16,        reg_adp_hcti_con_2_gain0                    , default = 25                                                                  . unsigned  , default = 25
+//Bit 15: 8,        reg_adp_hcti_con_2_gain1                    , default = 60                                                                  . unsigned  , default = 60
+//Bit  7: 0,        reg_adp_hcti_con_2_gain2                    0;, default = 5                                                                 . unsigned  , default = 5
+#define   HCTI_CON_2_GAIN_1                        (0x3232)
+#define P_HCTI_CON_2_GAIN_1                        (volatile unsigned int *)((0x3232  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_hcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
+//Bit 23:16,        reg_adp_hcti_con_2_gain4                    5;, default = 5                                                                 . unsigned  , default = 5
+//Bit 15: 8,        reg_adp_hcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
+//Bit  7: 0,        reg_adp_hcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
+#define   HCTI_OS_MARGIN                           (0x3233)
+#define P_HCTI_OS_MARGIN                           (volatile unsigned int *)((0x3233  << 2) + 0xff900000)
+//Bit 31: 8,        reserved
+//Bit  7: 0,        reg_adp_hcti_os_margin                      : margin for hcti overshoot, default = 0                                        . unsigned  , default = 0
+#define   HLTI_FLT_CLP_DC                          (0x3234)
+#define P_HLTI_FLT_CLP_DC                          (volatile unsigned int *)((0x3234  << 2) + 0xff900000)
+//Bit 31:29,        reserved
+//Bit 28,            reg_adp_hlti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1
+//Bit 27:26,        reg_adp_hlti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2
+//Bit 25:24,        reg_adp_hlti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 1. unsigned  , default = 1
+//Bit 23:22,        reg_adp_hlti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 1    . unsigned  , default = 1
+//Bit 21:20,        reg_adp_hlti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 1        . unsigned  , default = 1
+//Bit 19:18,        reg_adp_hlti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 1        . unsigned  , default = 1
+//Bit 17:16,        reg_adp_hlti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 1       . unsigned  , default = 1
+//Bit 15:12,        reg_adp_hlti_hard_clp_win                   , window size, 0~8, default = 2                                                 . unsigned  , default = 2
+//Bit 11: 8,        reg_adp_hlti_hard_win_min                   , window size, 0~8, default = 1                                                 . unsigned  , default = 1
+//Bit  7: 5,        reserved
+//Bit  4,            reg_adp_hlti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 0                                   . unsigned  , default = 0
+//Bit  3,            reserved
+//Bit  2: 0,        reg_adp_hlti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 4    . unsigned  , default = 4
+#define   HLTI_BST_GAIN                            (0x3235)
+#define P_HLTI_BST_GAIN                            (volatile unsigned int *)((0x3235  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_hlti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 32                         . unsigned  , default = 32
+//Bit 23:16,        reg_adp_hlti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 32                          . unsigned  , default = 32
+//Bit 15: 8,        reg_adp_hlti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 28                          . unsigned  , default = 28
+//Bit  7: 0,        reg_adp_hlti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 12                       . unsigned  , default = 12
+#define   HLTI_BST_CORE                            (0x3236)
+#define P_HLTI_BST_CORE                            (volatile unsigned int *)((0x3236  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_hlti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5
+//Bit 23:16,        reg_adp_hlti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5
+//Bit 15: 8,        reg_adp_hlti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5
+//Bit  7: 0,        reg_adp_hlti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 3
+#define   HLTI_CON_2_GAIN_0                        (0x3237)
+#define P_HLTI_CON_2_GAIN_0                        (volatile unsigned int *)((0x3237  << 2) + 0xff900000)
+//Bit 31:29,        reg_adp_hlti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: ....., default = 1. unsigned  , default = 1
+//Bit 28:26,        reg_adp_hlti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 1                       . unsigned  , default = 1
+//Bit 25:24,        reg_adp_hlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
+//Bit 23:16,        reg_adp_hlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
+//Bit 15: 8,        reg_adp_hlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
+//Bit  7: 0,        reg_adp_hlti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
+#define   HLTI_CON_2_GAIN_1                        (0x3238)
+#define P_HLTI_CON_2_GAIN_1                        (volatile unsigned int *)((0x3238  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_hlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
+//Bit 23:16,        reg_adp_hlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
+//Bit 15: 8,        reg_adp_hlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
+//Bit  7: 0,        reg_adp_hlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
+#define   HLTI_OS_MARGIN                           (0x3239)
+#define P_HLTI_OS_MARGIN                           (volatile unsigned int *)((0x3239  << 2) + 0xff900000)
+//Bit 31: 8,        reserved
+//Bit  7: 0,        reg_adp_hlti_os_margin                      : margin for hlti overshoot, default = 0                                        . unsigned  , default = 0
+#define   VLTI_FLT_CON_CLP                         (0x323a)
+#define P_VLTI_FLT_CON_CLP                         (volatile unsigned int *)((0x323a  << 2) + 0xff900000)
+//Bit 31:15,        reserved
+//Bit 14,            reg_adp_vlti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1
+//Bit 13:12,        reg_adp_vlti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit 11:10,        reg_adp_vlti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit  9: 8,        reg_adp_vlti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit  7: 6,        reg_adp_vlti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit  5: 4,        reg_adp_vlti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 1                         . unsigned  , default = 1
+//Bit  3,            reserved
+//Bit  2,            reg_adp_vlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
+//Bit  1,            reserved
+//Bit  0,            reg_adp_vlti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 0                        . unsigned  , default = 0
+#define   VLTI_BST_GAIN                            (0x323b)
+#define P_VLTI_BST_GAIN                            (volatile unsigned int *)((0x323b  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_adp_vlti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 32                                 . unsigned  , default = 32
+//Bit 15: 8,        reg_adp_vlti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 32                             . unsigned  , default = 32
+//Bit  7: 0,        reg_adp_vlti_bst_gain2                      : gain to boost filter usf, default = 32                                        . unsigned  , default = 32
+#define   VLTI_BST_CORE                            (0x323c)
+#define P_VLTI_BST_CORE                            (volatile unsigned int *)((0x323c  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_adp_vlti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5
+//Bit 15: 8,        reg_adp_vlti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5
+//Bit  7: 0,        reg_adp_vlti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3
+#define   VLTI_CON_2_GAIN_0                        (0x323d)
+#define P_VLTI_CON_2_GAIN_0                        (volatile unsigned int *)((0x323d  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_vlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
+//Bit 23:16,        reg_adp_vlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
+//Bit 15: 8,        reg_adp_vlti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
+//Bit  7: 0,        reg_adp_vlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
+#define   VLTI_CON_2_GAIN_1                        (0x323e)
+#define P_VLTI_CON_2_GAIN_1                        (volatile unsigned int *)((0x323e  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_vlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
+//Bit 23:16,        reg_adp_vlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
+//Bit 15: 8,        reg_adp_vlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
+//Bit  7: 0,        reg_adp_vlti_os_margin                      : margin for vlti overshoot, default = 0                                        . unsigned  , default = 0
+#define   VCTI_FLT_CON_CLP                         (0x323f)
+#define P_VCTI_FLT_CON_CLP                         (volatile unsigned int *)((0x323f  << 2) + 0xff900000)
+//Bit 31:15,        reserved
+//Bit 14,            reg_adp_vcti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1
+//Bit 13:12,        reg_adp_vcti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit 11:10,        reg_adp_vcti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit  9: 8,        reg_adp_vcti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit  7: 6,        reg_adp_vcti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
+//Bit  5: 4,        reg_adp_vcti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 1                         . unsigned  , default = 1
+//Bit  3,            reserved
+//Bit  2,            reg_adp_vcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
+//Bit  1,            reserved
+//Bit  0,            reg_adp_vcti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 0                        . unsigned  , default = 0
+#define   VCTI_BST_GAIN                            (0x3240)
+#define P_VCTI_BST_GAIN                            (volatile unsigned int *)((0x3240  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_adp_vcti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 16                                  . unsigned  , default = 16
+//Bit 15: 8,        reg_adp_vcti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 16                              . unsigned  , default = 16
+//Bit  7: 0,        reg_adp_vcti_bst_gain2                      : gain to boost filter usf, default = 16                                         . unsigned  , default = 16
+#define   VCTI_BST_CORE                            (0x3241)
+#define P_VCTI_BST_CORE                            (volatile unsigned int *)((0x3241  << 2) + 0xff900000)
+//Bit 31:24,        reserved
+//Bit 23:16,        reg_adp_vcti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5
+//Bit 15: 8,        reg_adp_vcti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5
+//Bit  7: 0,        reg_adp_vcti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3
+#define   VCTI_CON_2_GAIN_0                        (0x3242)
+#define P_VCTI_CON_2_GAIN_0                        (volatile unsigned int *)((0x3242  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_vcti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
+//Bit 23:16,        reg_adp_vcti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
+//Bit 15: 8,        reg_adp_vcti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
+//Bit  7: 0,        reg_adp_vcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
+#define   VCTI_CON_2_GAIN_1                        (0x3243)
+#define P_VCTI_CON_2_GAIN_1                        (volatile unsigned int *)((0x3243  << 2) + 0xff900000)
+//Bit 31:24,        reg_adp_vcti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
+//Bit 23:16,        reg_adp_vcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
+//Bit 15: 8,        reg_adp_vcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
+//Bit  7: 0,        reg_adp_vcti_os_margin                      : margin for vcti overshoot, default = 0                                        . unsigned  , default = 0
+#define   SHARP_3DLIMIT                            (0x3244)
+#define P_SHARP_3DLIMIT                            (volatile unsigned int *)((0x3244  << 2) + 0xff900000)
+//Bit 31:29,        reserved
+//Bit 28:16,        reg_3d_mid_width                            ,width of left part of 3d input, dft = half size of input width  default = 0    . unsigned  , default = 960
+//Bit 15:13,        reserved
+//Bit 12: 0,        reg_3d_mid_height                           ,height of left part of 3d input, dft = half size of input height  default = 0  . unsigned  , default = 540
+#define   DNLP_EN                                  (0x3245)
+#define P_DNLP_EN                                  (volatile unsigned int *)((0x3245  << 2) + 0xff900000)
+//Bit 31: 1,        reserved
+//Bit  0,            reg_dnlp_en                                                                                                                 . unsigned  , default = 1
+#define   DNLP_00                                  (0x3246)
+#define P_DNLP_00                                  (volatile unsigned int *)((0x3246  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid0                             : dnlp00                                                                        . unsigned  , default = 32'h08060402
+#define   DNLP_01                                  (0x3247)
+#define P_DNLP_01                                  (volatile unsigned int *)((0x3247  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid1                             : dnlp01                                                                        . unsigned  , default = 32'h100e0c0a
+#define   DNLP_02                                  (0x3248)
+#define P_DNLP_02                                  (volatile unsigned int *)((0x3248  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid2                             : dnlp02                                                                        . unsigned  , default = 32'h1a171412
+#define   DNLP_03                                  (0x3249)
+#define P_DNLP_03                                  (volatile unsigned int *)((0x3249  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid3                             : dnlp03                                                                        . unsigned  , default = 32'h2824201d
+#define   DNLP_04                                  (0x324a)
+#define P_DNLP_04                                  (volatile unsigned int *)((0x324a  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid4                             : dnlp04                                                                        . unsigned  , default = 32'h3834302c
+#define   DNLP_05                                  (0x324b)
+#define P_DNLP_05                                  (volatile unsigned int *)((0x324b  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid5                             : dnlp05                                                                        . unsigned  , default = 32'h4b45403c
+#define   DNLP_06                                  (0x324c)
+#define P_DNLP_06                                  (volatile unsigned int *)((0x324c  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid6                             : dnlp06                                                                        . unsigned  , default = 32'h605b5550
+#define   DNLP_07                                  (0x324d)
+#define P_DNLP_07                                  (volatile unsigned int *)((0x324d  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid7                             : dnlp07                                                                        . unsigned  , default = 32'h80787068
+#define   DNLP_08                                  (0x324e)
+#define P_DNLP_08                                  (volatile unsigned int *)((0x324e  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid8                             : dnlp08                                                                        . unsigned  , default = 32'ha0989088
+#define   DNLP_09                                  (0x324f)
+#define P_DNLP_09                                  (volatile unsigned int *)((0x324f  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid9                             : dnlp09                                                                        . unsigned  , default = 32'hb8b2aca6
+#define   DNLP_10                                  (0x3250)
+#define P_DNLP_10                                  (volatile unsigned int *)((0x3250  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid10                            : dnlp10                                                                        . unsigned  , default = 32'hc8c4c0bc
+#define   DNLP_11                                  (0x3251)
+#define P_DNLP_11                                  (volatile unsigned int *)((0x3251  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid11                            : dnlp11                                                                        . unsigned  , default = 32'hd4d2cecb
+#define   DNLP_12                                  (0x3252)
+#define P_DNLP_12                                  (volatile unsigned int *)((0x3252  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid12                            : dnlp12                                                                        . unsigned  , default = 32'hdad8d7d6
+#define   DNLP_13                                  (0x3253)
+#define P_DNLP_13                                  (volatile unsigned int *)((0x3253  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid13                            : dnlp13                                                                        . unsigned  , default = 32'he2e0dedc
+#define   DNLP_14                                  (0x3254)
+#define P_DNLP_14                                  (volatile unsigned int *)((0x3254  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid14                            : dnlp14                                                                        . unsigned  , default = 32'hf0ece8e4
+#define   DNLP_15                                  (0x3255)
+#define P_DNLP_15                                  (volatile unsigned int *)((0x3255  << 2) + 0xff900000)
+//Bit 31: 0,        reg_dnlp_ygrid15                            : dnlp15                                                                        . unsigned  , default = 32'hfffcf8f4
+#define   DEMO_CRTL                                (0x3256)
+#define P_DEMO_CRTL                                (volatile unsigned int *)((0x3256  << 2) + 0xff900000)
+//Bit 31:19,        reserved
+//Bit 18:17,        demo_disp_position                                                                                                          . unsigned  , default = 2
+//Bit 16,            demo_hsvsharp_enable                                                                                                        . unsigned  , default = 0
+//Bit 15:13,        reserved
+//Bit 12: 0,        demo_left_top_screen_width                  :                                                                               . unsigned  , default = 360
+#define   SHARP_SR2_CTRL                           (0x3257)
+#define P_SHARP_SR2_CTRL                           (volatile unsigned int *)((0x3257  << 2) + 0xff900000)
+//Bit 31:22,    reserved
+//Bit 21:16,    reg_sr2_pk_la_err_dis_rate         :     . unsigned  , low angle and high angle error should not be no less than nearby_error*rate/64; default = 24
+//Bit 15:8,     reg_sr2_pk_sad_diag_gain           :     . unsigned  , gain to sad[2] and sad[6], 16 normalized to "1"; default = 16
+//Bit 7,        reg_sr2_vert_outphs                :     . unsigned  , default = 0
+//Bit 6,        reg_sr2_horz_outphs                :     . unsigned  , default = 0
+//Bit 5,        reg_sr2_vert_ratio                 :     . unsigned  , default = 0
+//Bit 4,        reg_sr2_hori_ratio                 :     . unsigned  , default = 0
+//Bit 3,        reg_sr2_bic_norm                   :     . unsigned  , default = 1
+//Bit 2,        reg_sr2_enable                     :     . unsigned  , default = 0
+//Bit 1,        reg_sr2_sharp_prc_lr_hbic          :     . unsigned  , default = 0
+//Bit 0,        reg_sr2_sharp_prc_lr               : lti/cti/nr/peaking processing using LR grid, 0: on HR grid; 1:on LR grid, horizontally no upscale, but using simple bic   . unsigned  , default = 0
+#define   SHARP_SR2_YBIC_HCOEF0                    (0x3258)
+#define P_SHARP_SR2_YBIC_HCOEF0                    (volatile unsigned int *)((0x3258  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_y_bic_hcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel Filter will be normalized to 128 as ?? default=0
+//Bit 23:16, reg_sr2_y_bic_hcoef02            the same as above; default=0
+//Bit 15: 8, reg_sr2_y_bic_hcoef01            the same as above; default=64
+//Bit  7: 0, reg_sr2_y_bic_hcoef00            the same as above; default=0
+#define   SHARP_SR2_YBIC_HCOEF1                    (0x3259)
+#define P_SHARP_SR2_YBIC_HCOEF1                    (volatile unsigned int *)((0x3259  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_y_bic_hcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as ?? default=-4
+//Bit 23:16, reg_sr2_y_bic_hcoef12            the same as above; default=36
+//Bit 15: 8, reg_sr2_y_bic_hcoef11            the same as above; default=36
+//Bit  7: 0, reg_sr2_y_bic_hcoef10            the same as above; default=-4
+#define   SHARP_SR2_CBIC_HCOEF0                    (0x325a)
+#define P_SHARP_SR2_CBIC_HCOEF0                    (volatile unsigned int *)((0x325a  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_c_bic_hcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel ,Filter will be normalized to 128 as ?? default=0
+//Bit 23:16, reg_sr2_c_bic_hcoef02            the same as above; default=21
+//Bit 15: 8, reg_sr2_c_bic_hcoef01            the same as above; default=22
+//Bit  7: 0, reg_sr2_c_bic_hcoef00            the same as above; default=21
+#define   SHARP_SR2_CBIC_HCOEF1                    (0x325b)
+#define P_SHARP_SR2_CBIC_HCOEF1                    (volatile unsigned int *)((0x325b  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_c_bic_hcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as ?? default=-4
+//Bit 23:16, reg_sr2_c_bic_hcoef12            the same as above; default=36
+//Bit 15: 8, reg_sr2_c_bic_hcoef11            the same as above; default=36
+//Bit  7: 0, reg_sr2_c_bic_hcoef10            the same as above; default=-4
+#define   SHARP_SR2_YBIC_VCOEF0                    (0x325c)
+#define P_SHARP_SR2_YBIC_VCOEF0                    (volatile unsigned int *)((0x325c  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_y_bic_vcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel, Filter will be normalized to 128 as ?? default=0
+//Bit 23:16, reg_sr2_y_bic_vcoef02            the same as above; default=0
+//Bit 15: 8, reg_sr2_y_bic_vcoef01            the same as above; default=64
+//Bit  7: 0, reg_sr2_y_bic_vcoef00            the same as above; default=0
+#define   SHARP_SR2_YBIC_VCOEF1                    (0x325d)
+#define P_SHARP_SR2_YBIC_VCOEF1                    (volatile unsigned int *)((0x325d  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_y_bic_vcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channe, lFilter will be normalized to 128 as ?? default=-4
+//Bit 23:16, reg_sr2_y_bic_vcoef12            the same as above; default=36
+//Bit 15: 8, reg_sr2_y_bic_vcoef11            the same as above; default=36
+//Bit  7: 0, reg_sr2_y_bic_vcoef10            the same as above; default=-4
+#define   SHARP_SR2_CBIC_VCOEF0                    (0x325e)
+#define P_SHARP_SR2_CBIC_VCOEF0                    (volatile unsigned int *)((0x325e  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_c_bic_vcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel, Filter will be normalized to 128 as ?? default=0
+//Bit 23:16, reg_sr2_c_bic_vcoef02            the same as above; default=21
+//Bit 15: 8, reg_sr2_c_bic_vcoef01            the same as above; default=22
+//Bit  7: 0, reg_sr2_c_bic_vcoef00            the same as above; default=21
+#define   SHARP_SR2_CBIC_VCOEF1                    (0x325f)
+#define P_SHARP_SR2_CBIC_VCOEF1                    (volatile unsigned int *)((0x325f  << 2) + 0xff900000)
+//Bit 31:24, reg_sr2_c_bic_vcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as ?? default=-4
+//Bit 23:16, reg_sr2_c_bic_vcoef12            the same as above; default=36
+//Bit 15: 8, reg_sr2_c_bic_vcoef11            the same as above; default=36
+//Bit  7: 0, reg_sr2_c_bic_vcoef10            the same as above; default=-4
+#define   SHARP_SR2_MISC                           (0x3260)
+#define P_SHARP_SR2_MISC                           (volatile unsigned int *)((0x3260  << 2) + 0xff900000)
+//Bit 31:2,   reserved
+//Bit 1,      reg_sr2_cmpmux_bef                 :     . unsigned  , default = 0,0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR;
+//Bit 0,      reg_sr2_cmpmux_aft                 :     . unsigned  , default = 0,0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB;
+#define   SHARP_SR3_SAD_CTRL                       (0x3261)
+#define P_SHARP_SR3_SAD_CTRL                       (volatile unsigned int *)((0x3261  << 2) + 0xff900000)
+//Bit 31:30 reserved
+//Bit 29:24 reg_sr3_pk_sad_core_rate         // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
+//Bit 23:22 reserved
+//Bit 21:16 reg_sr3_lti_sad_core_rate        // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64 , default= 6
+//Bit 15:14 reserved
+//Bit 13:8  reg_sr3_cti_sad_core_rate        // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64 , default= 6
+//Bit 7,    reg_sr3_lti_hsad_mode            // u1: mode for hsad of lti caluclation; 0: block based; 1:othor shape; default= 1
+//Bit 6,    reg_sr3_cti_hsad_mode            // u1: mode for hsad of cti caluclation; 0: block based; 1:othor shape; default= 1
+//Bit 5,    reg_sr3_lti_dsad_mode            // u1: mode for dsad of lti caluclation, 0: block based; 1:othor shape; default= 1
+//Bit 4,    reg_sr3_cti_dsad_mode            // u1: mode for dsad of cti caluclation, 0: block based; 1:othor shape; default= 1
+//Bit 3,    reg_sr3_lti_vsad_mode            // u1: mode for vsad of lti caluclation, 0: block based; 1:othor shape; default= 1
+//Bit 2,    reg_sr3_cti_vsad_mode            // u1: mode for vsad of cti caluclation, 0: block based; 1:othor shape; default= 1
+//Bit 1,    reg_sr3_lti_hsad_hlpf            // u1: hlpf for hsad of lti caluclation, 0: no hlpf; 1: with [1 2 1] hlpf; default= 1
+//Bit 0,    reg_sr3_cti_hsad_hlpf            // u1: hlpf for hsad of cti caluclation, 0: no hlpf; 1: with [1 2 1] hlpf; default= 1
+#define   SHARP_SR3_PK_CTRL0                       (0x3262)
+#define P_SHARP_SR3_PK_CTRL0                       (volatile unsigned int *)((0x3262  << 2) + 0xff900000)
+//Bit 31:12 reserved
+//Bit 11,   reg_sr3_pk_sad_mode              // u1: mode for sad of peaking and noise reduction, 0: block based; 1:othor shape; default= 1
+//Bit 10,   reg_sr3_pk_hsad_hlpf             // u1: hlpf for hsad for peaking caluclation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
+//Bit 9,    reg_sr3_pk_vsad_hlpf             // u1: hlpf for vsad for peaking caluclation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
+//Bit 8,    reg_sr3_pk_dsad_hlpf             // u1: hlpf for dsad for peaking caluclation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
+//Bit 7:6,  reg_sr3_pk_hpdrt_mode            // u2: mode for HPdrt filter:  default= 3
+//Bit 5:4,  reg_sr3_pk_bpdrt_mode            // u2: mode for BPdrt filter:  default= 3
+//Bit 3:2,  reg_sr3_pk_drtbld_range          // u2: range of the min2 and min direction distance; default =1
+//Bit 1,    reserved
+//Bit 0,    reg_sr3_pk_ti_blend_mode         // u1: blend mode of the TI and PK results: default = 0;
+#define   SHARP_SR3_PK_CTRL1                       (0x3263)
+#define P_SHARP_SR3_PK_CTRL1                       (volatile unsigned int *)((0x3263  << 2) + 0xff900000)
+//Bit 31,     reserved
+//Bit 30:28,  reg_sr3_pk_hp_hvcon_replace8_maxsad     //u3: replace HP hvcon by maxsad, default =1
+//Bit 27,     reserved
+//Bit 26:24,  reg_sr3_pk_bp_hvcon_replace8_maxsad     //u3: replace HP hvcon by maxsad, default =1
+//Bit 23:16,  reg_sr3_pk_hp_hvcon_replace8lv_gain     //u8: gain to local variant before calculating the hv gain for peaking, normalized to 32 as "1" default = 32;
+//Bit 15:8,   reg_sr3_pk_bp_hvcon_replace8lv_gain     //u8: gain to local variant before calculating the hv gain for peaking, normalized to 32 as "1" default = 32;
+//Bit 7,      reg_sr3_sad_intlev_mode                 //u1: interleave detection xerr mode: 0 max; 1:sum default=1
+//Bit 6,      reg_sr3_sad_intlev_mode1                //u1: mode 1 of using diagonal protection: 0: no digonal protection; 1: with diagonal protection default=1
+//Bit 5:0,    reg_sr3_sad_intlev_gain                 //u6: interleave detection for sad gain applied, normalized to 8 as 1  default=12
+#define   SHARP_DEJ_CTRL                           (0x3264)
+#define P_SHARP_DEJ_CTRL                           (volatile unsigned int *)((0x3264  << 2) + 0xff900000)
+//Bit 31:4    reserved
+//Bit 3:2,    reg_sr3_dejaggy_sameside_prtct   // u2:  enable of sr3 dejaggy same side curve protect from filter, [0] for proc, [1] for ctrl path,  default=3
+//Bit 1,      reg_sr3_dejaggy_sameside_mode    // u1: mode of the sameside flag decision: default =1
+//Bit 0,      reg_sr3_dejaggy_enable           // u1: enable of sr3 dejaggy: default =0
+#define   SHARP_DEJ_ALPHA                          (0x3265)
+#define P_SHARP_DEJ_ALPHA                          (volatile unsigned int *)((0x3265  << 2) + 0xff900000)
+//Bit 31:28,  reg_sr3_dejaggy_ctrlchrm_alpha_1  //u4: alpha for LR video LPF,  default = 0
+//Bit 27:24,  reg_sr3_dejaggy_ctrlchrm_alpha_0  //u4: alpha for LR video LPF,  default = 15
+//Bit 23:20,  reg_sr3_dejaggy_ctrlluma_alpha_1  //u4: alpha for LR video LPF,  default = 0
+//Bit 19:16,  reg_sr3_dejaggy_ctrlluma_alpha_0  //u4: alpha for LR video LPF,  default = 15
+//Bit 15:12,  reg_sr3_dejaggy_procchrm_alpha_1  //u4: alpha for LR video LPF,  default = 4
+//Bit 11:8,   reg_sr3_dejaggy_procchrm_alpha_0  //u4: alpha for LR video LPF,  default = 6
+//Bit 7:4,    reg_sr3_dejaggy_procluma_alpha_1  //u4: alpha for LR video LPF,  default = 4
+//Bit 3:0,    reg_sr3_dejaggy_procluma_alpha_0  //u4: alpha for LR video LPF,  default = 6
+#define   SHARP_SR3_DRTLPF_EN                      (0x3266)
+#define P_SHARP_SR3_DRTLPF_EN                      (volatile unsigned int *)((0x3266  << 2) + 0xff900000)
+//Bit 31:15   reserved
+//Bit 14:8,   reg_pk_debug_edge                . unsigned  , default = 0
+//Bit  7,     reserved
+//Bit  6:4,   reg_sr3_drtlpf_theta_en           //u1x3 theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
+//Bit  3,     reserved
+//Bit  2:0    reg_sr3_drtlpf_enable             //u1x3 directional lpf on luma U and V channels, default = 7
+#define   SHARP_SR3_DRTLPF_ALPHA_0                 (0x3267)
+#define P_SHARP_SR3_DRTLPF_ALPHA_0                 (volatile unsigned int *)((0x3267  << 2) + 0xff900000)
+//Bit 31:30   reserved
+//Bit 29:24   reg_sr3_drtlpf_alpha3             //u6: directional lpf alpha coef for min_sad/max_sad comparied, default = 9
+//Bit 23:22   reserved
+//Bit 21:16   reg_sr3_drtlpf_alpha2             //u6: default =10
+//Bit 15:14   reserved
+//Bit 13:8    reg_sr3_drtlpf_alpha1             //u6: default = 11
+//Bit 7:6     reserved
+//Bit 5:0     reg_sr3_drtlpf_alpha0             //u6: default = 12
+#define   SHARP_SR3_DRTLPF_ALPHA_1                 (0x3268)
+#define P_SHARP_SR3_DRTLPF_ALPHA_1                 (volatile unsigned int *)((0x3268  << 2) + 0xff900000)
+//Bit 31:30   reserved
+//Bit 29:24   reg_sr3_drtlpf_alpha7             //u6: directional lpf alpha coef for min_sad/max_sad comparied, default = 1
+//Bit 23:22   reserved
+//Bit 21:16   reg_sr3_drtlpf_alpha6             //u6: default = 4
+//Bit 15:14   reserved
+//Bit 13:8    reg_sr3_drtlpf_alpha5             //u6: default = 7
+//Bit 7:6     reserved
+//Bit 5:0     reg_sr3_drtlpf_alpha4             //u6: default = 8
+#define   SHARP_SR3_DRTLPF_ALPHA_2                 (0x3269)
+#define P_SHARP_SR3_DRTLPF_ALPHA_2                 (volatile unsigned int *)((0x3269  << 2) + 0xff900000)
+//Bit 31:30   reserved
+//Bit 29:24   reg_sr3_drtlpf_alpha11            //u6: directional lpf alpha coef for min_sad/max_sad comparied, default = 0
+//Bit 23:22   reserved
+//Bit 21:16   reg_sr3_drtlpf_alpha10            //u6: default = 0
+//Bit 15:14   reserved
+//Bit 13:8    reg_sr3_drtlpf_alpha9             //u6: default = 0
+//Bit 7:6     reserved
+//Bit 5:0     reg_sr3_drtlpf_alpha8             //u6: default = 0
+#define   SHARP_SR3_DRTLPF_ALPHA_OFST              (0x326a)
+#define P_SHARP_SR3_DRTLPF_ALPHA_OFST              (volatile unsigned int *)((0x326a  << 2) + 0xff900000)
+//Bit 31:28   reg_sr3_drtlpf_alpha_ofst7        //s4: directional lpf alpha coef ofset of each directions, default = -8
+//Bit 27:24   reg_sr3_drtlpf_alpha_ofst6        //s4: default = -8
+//Bit 23:20   reg_sr3_drtlpf_alpha_ofst5        //s4: default = -8
+//Bit 19:16   reg_sr3_drtlpf_alpha_ofst4        //s4: default = -8
+//Bit 15:12   reg_sr3_drtlpf_alpha_ofst3        //s4: default = -8
+//Bit 11:8    reg_sr3_drtlpf_alpha_ofst2        //s4: default = -8
+//Bit 7:4     reg_sr3_drtlpf_alpha_ofst1        //s4: default = -8
+//Bit 3:0     reg_sr3_drtlpf_alpha_ofst0        //s4: default = -8
+#define   SHARP_SR3_DERING_CTRL                    (0x326b)
+#define P_SHARP_SR3_DERING_CTRL                    (volatile unsigned int *)((0x326b  << 2) + 0xff900000)
+//Bit 31      reserved
+//Bit 30:28   reg_sr3_dering_enable                  // u3: dering enable bits; default = 1
+//Bit 27      reserved
+//Bit 26:24   reg_sr3_dering_varlpf_mode             // u3: local variant LPF mode: 0 no filter, 1, errosion 3x3; 2: 3x3 lpf; 3 and up: 3x3 errosion + lpf default = 3
+//Bit 23:20   reg_sr3_dering_maxrange                // u4: maximum:range of dering in LR resolution, max to 12;  default = 9
+//Bit 19:18   reserved
+//Bit 17:16   reg_sr3_dering_lcvar_blend_mode        // u2: mode for lcvar calculation: 0: HVblend; 1: diagblend; 2: HVblend+V (for hring); 3: HVblend+ DiagBlend default = 2
+//Bit 15:8    reg_sr3_dering_lcvar_gain              // u8: gain to local variant and normalized to 32 as "1"  default = 64
+//Bit 7:0     reg_sr3_dering_lcvar_nearby_maxsad_th  // u8: threshold to use nearer side maxsad if that side sad is larger than this threshold, ortherwise, use the max one default = 28
+#define   SHARP_SR3_DERING_LUMA2PKGAIN_0TO3        (0x326c)
+#define P_SHARP_SR3_DERING_LUMA2PKGAIN_0TO3        (volatile unsigned int *)((0x326c  << 2) + 0xff900000)
+//Bit 31:24   reg_sr3_dering_luma2pkgain3             // u8: level limit(for th0<bpcon<th1) of curve for dering pkgain based on LPF luma level. default=255
+//Bit 23:16   reg_sr3_dering_luma2pkgain2             // u8: level limit(for bpcon<th0) of curve for dering pkgain based on LPF luma level. default=255
+//Bit 15:8    reg_sr3_dering_luma2pkgain1             // u8: threshold1 of curve for dering pkgain based on LPF luma level  default =200
+//Bit 7:0     reg_sr3_dering_luma2pkgain0             // u8: threshold0 of curve for dering pkgain based on LPF luma level. default =30
+#define   SHARP_SR3_DERING_LUMA2PKGAIN_4TO6        (0x326d)
+#define P_SHARP_SR3_DERING_LUMA2PKGAIN_4TO6        (volatile unsigned int *)((0x326d  << 2) + 0xff900000)
+//Bit 31:24   reserved
+//Bit 23:16   reg_sr3_dering_luma2pkgain6             // u8: rate1 (for bpcon>th1) of curve for dering pkgain based on LPF luma level. default =24
+//Bit 15:8    reg_sr3_dering_luma2pkgain5             // u8: rate0 (for bpcon<th0) of curve for dering pkgain based on LPF luma level. dfault =50
+//Bit 7:0     reg_sr3_dering_luma2pkgain4             // u8: level limit(for bpcon>th1) of curve for dering pkgain based on LPF luma level. default =255
+#define   SHARP_SR3_DERING_LUMA2PKOS_0TO3          (0x326e)
+#define P_SHARP_SR3_DERING_LUMA2PKOS_0TO3          (volatile unsigned int *)((0x326e  << 2) + 0xff900000)
+//Bit 31:24   reg_sr3_dering_luma2pkos3             // u8: level limit(for th0<bpcon<th1) of curve for dering pkOS based on LPF luma level. default=255
+//Bit 23:16   reg_sr3_dering_luma2pkos2             // u8: level limit(for bpcon<th0) of curve for dering pkOS based on LPF luma level. default=255
+//Bit 15:8    reg_sr3_dering_luma2pkos1             // u8: threshold1 of curve for dering pkOS based on LPF luma level  default =200
+//Bit 7:0     reg_sr3_dering_luma2pkos0             // u8: threshold0 of curve for dering pkOS based on LPF luma leve. default =30
+#define   SHARP_SR3_DERING_LUMA2PKOS_4TO6          (0x326f)
+#define P_SHARP_SR3_DERING_LUMA2PKOS_4TO6          (volatile unsigned int *)((0x326f  << 2) + 0xff900000)
+//Bit 31:24   reserved
+//Bit 23:16   reg_sr3_dering_luma2pkos6             // u8: rate1 (for bpcon>th1) of curve for dering pkOS based on LPF luma level. default =24
+//Bit 15:8    reg_sr3_dering_luma2pkos5             // u8: rate0 (for bpcon<th0) of curve for dering pkOS based on LPF luma level. dfault =50
+//Bit 7:0     reg_sr3_dering_luma2pkos4             // u8: level limit(for bpcon>th1) of curve for dering pkOS based on LPF luma level. default =255
+#define   SHARP_SR3_DERING_GAINVS_MADSAD           (0x3270)
+#define P_SHARP_SR3_DERING_GAINVS_MADSAD           (volatile unsigned int *)((0x3270  << 2) + 0xff900000)
+//Bit 31:28   reg_sr3_dering_gainvs_maxsad7        //u4: pkgain vs maxsad value, 8 node interpolations, default = 0
+//Bit 27:24   reg_sr3_dering_gainvs_maxsad6        //u4: default = 0
+//Bit 23:20   reg_sr3_dering_gainvs_maxsad5        //u4: default = 0
+//Bit 19:16   reg_sr3_dering_gainvs_maxsad4        //u4: default = 0
+//Bit 15:12   reg_sr3_dering_gainvs_maxsad3        //u4: default = 0
+//Bit 11:8    reg_sr3_dering_gainvs_maxsad2        //u4: default = 0
+//Bit 7:4     reg_sr3_dering_gainvs_maxsad1        //u4: default = 4
+//Bit 3:0     reg_sr3_dering_gainvs_maxsad0        //u4: default = 8
+#define   SHARP_SR3_DERING_GAINVS_VR2MAX           (0x3271)
+#define P_SHARP_SR3_DERING_GAINVS_VR2MAX           (volatile unsigned int *)((0x3271  << 2) + 0xff900000)
+//Bit 31:28   reg_sr3_dering_gainvs_vr2max7        //u4: pkgain vs ratio = max(local_var, floor)/maxsad nearby, default = 15
+//Bit 27:24   reg_sr3_dering_gainvs_vr2max6        //u4: default = 15
+//Bit 23:20   reg_sr3_dering_gainvs_vr2max5        //u4: default = 15
+//Bit 19:16   reg_sr3_dering_gainvs_vr2max4        //u4: default = 15
+//Bit 15:12   reg_sr3_dering_gainvs_vr2max3        //u4: default = 14
+//Bit 11:8    reg_sr3_dering_gainvs_vr2max2        //u4: default = 12
+//Bit 7:4     reg_sr3_dering_gainvs_vr2max1        //u4: default = 2
+//Bit 3:0     reg_sr3_dering_gainvs_vr2max0        //u4: default = 0
+#define   SHARP_SR3_DERING_PARAM0                  (0x3272)
+#define P_SHARP_SR3_DERING_PARAM0                  (volatile unsigned int *)((0x3272  << 2) + 0xff900000)
+//Bit 31:24   reserved
+//Bit 23:16   reg_sr3_dering_lcvar_floor        //u8: local varianet no smaller than this value to calculate dgain max(localvar,x)/maxsad. default = 10
+//Bit 15:8    reg_sr3_dering_vr2max_gain        //u8: gain to max(local_var, floor)/maxsad  before feeding to LUT. default = 32
+//Bit 7:6     reserved
+//Bit 5:0     reg_sr3_dering_vr2max_limt        //u6: limit of maxsad to max(local_var, floor)*(max(maxsad, lmit))/maxsad.  default = 16
+#define   SHARP_SR3_DRTLPF_THETA                   (0x3273)
+#define P_SHARP_SR3_DRTLPF_THETA                   (volatile unsigned int *)((0x3273  << 2) + 0xff900000)
+//Bit 31:0    reg_sr3_drtlpf_theta              //u4x8: directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
+#define   SHARP_SATPRT_CTRL                        (0x3274)
+#define P_SHARP_SATPRT_CTRL                        (volatile unsigned int *)((0x3274  << 2) + 0xff900000)
+//Bit 31:24   reserved
+//Bit 23:16   reg_satprt_sat_core      //u8: 4x will be coring to cor(irgb_max-irgb_min) to calculate the oy_delt, the smaller the more protection to color, the larger only the rich color will be protected;
+//Bit 15:8    reg_satprt_sat_rate      //u8: rate to cor(irgb_max-irgb_min) to calculate the oy_delt, the larger the more protection to rich color; norm 16 as 1
+//Bit 7:4     reserved
+//Bit 3:2     reg_satprt_csc_mode      //u2: csc mode of current yuv input: 0:601, 1:709, 2:BT2020 NCL, 3:reserved
+//Bit 1       reg_satprt_is_lmt        //u1: flag telling the YUV is limited range data or full range data, 0 full range, 1: limited range
+//Bit 0       reg_satprt_enable        //u1: enable of saturation protection for dnlp adjustments
+#define   SHARP_SATPRT_DIVM                        (0x3275)
+#define P_SHARP_SATPRT_DIVM                        (volatile unsigned int *)((0x3275  << 2) + 0xff900000)
+//Bit 31:24   reserved
+//Bit 23:0    reg_satprt_div_m        //u8x3, 1/m, normalized to 128 as 1, default=1
+#define   SHARP_SATPRT_LMT_RGB                     (0x3276)
+#define P_SHARP_SATPRT_LMT_RGB                     (volatile unsigned int *)((0x3276  << 2) + 0xff900000)
+//Bit 31:30   reserved
+//Bit 29:0    reg_satprt_lmt_rgb      //u10x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
+#define   SHARP_DB_FLT_CTRL                        (0x3277)
+#define P_SHARP_DB_FLT_CTRL                        (volatile unsigned int *)((0x3277  << 2) + 0xff900000)
+//Bit 31:27        reserved
+//Bit 26           reg_nrdeband_reset1
+//Bit 25           reg_nrdeband_reset0
+//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  0:yuv 1:RGB
+//Bit 23           reg_nrdeband_en11         // unsigned , default = 1  debanding registers of side lines, [0] for luma,   same for below
+//Bit 22           reg_nrdeband_en10         // unsigned , default = 1  debanding registers of side lines, [1] for chroma, same for below
+//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
+//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
+//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
+//Bit 16            reserved
+//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
+//Bit 12            reserved
+//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
+//Bit  8            reserved
+//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   debanding random hp portion xor, [0] for luma
+//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   debanding random hp portion xor, [1] for chroma
+//Bit  5           reg_nrdeband_en1          // unsigned , default = 1   debanding registers,  for luma
+//Bit  4           reg_nrdeband_en0          // unsigned , default = 1   debanding registers,  for chroma
+//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
+//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
+#define   SHARP_DB_FLT_YC_THRD                     (0x3278)
+#define P_SHARP_DB_FLT_YC_THRD                     (volatile unsigned int *)((0x3278  << 2) + 0xff900000)
+//Bit 31:28        reg_nrdeband_luma_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
+//Bit 27:24        reg_nrdeband_luma_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
+//Bit 23:20        reg_nrdeband_luma_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
+//Bit 19:16        reg_nrdeband_luma_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
+//Bit 15:12        reg_nrdeband_chrm_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
+//Bit 11: 8        reg_nrdeband_chrm_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
+//Bit  7: 4        reg_nrdeband_chrm_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
+//Bit  3: 0        reg_nrdeband_chrm_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif
+#define   SHARP_DB_FLT_RANDLUT                     (0x3279)
+#define P_SHARP_DB_FLT_RANDLUT                     (volatile unsigned int *)((0x3279  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:21        reg_nrdebandslut7         // unsigned , default = 1   lut0
+//Bit 20:18        reg_nrdebandslut6         // unsigned , default = 1   lut0
+//Bit 17:15        reg_nrdebandslut5         // unsigned , default = 1   lut0
+//Bit 14:12        reg_nrdebandslut4         // unsigned , default = 1   lut0
+//Bit 11: 9        reg_nrdebandslut3         // unsigned , default = 1   lut0
+//Bit  8: 6        reg_nrdebandslut2         // unsigned , default = 1   lut0
+//Bit  5: 3        reg_nrdebandslut1         // unsigned , default = 1   lut0
+//Bit  2: 0        reg_nrdebandslut0         // unsigned , default = 1   lut0
+#define   SHARP_DB_FLT_PXI_THRD                    (0x327a)
+#define P_SHARP_DB_FLT_PXI_THRD                    (volatile unsigned int *)((0x327a  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   to luma/|u/v| for using the denoise
+//Bit 15:10        reserved
+//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   to luma/|u/v| for using the denoise
+#define   SHARP_DB_FLT_SEED_Y                      (0x327b)
+#define P_SHARP_DB_FLT_SEED_Y                      (volatile unsigned int *)((0x327b  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  noise adding seed for Y. seed[0]= 0x60a52f20; as default
+#define   SHARP_DB_FLT_SEED_U                      (0x327c)
+#define P_SHARP_DB_FLT_SEED_U                      (volatile unsigned int *)((0x327c  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  noise adding seed for U. seed[0]= 0x60a52f27; as default
+#define   SHARP_DB_FLT_SEED_V                      (0x327d)
+#define P_SHARP_DB_FLT_SEED_V                      (volatile unsigned int *)((0x327d  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
+#define   SHARP_PKGAIN_VSLUMA_LUT_L                (0x327e)
+#define P_SHARP_PKGAIN_VSLUMA_LUT_L                (volatile unsigned int *)((0x327e  << 2) + 0xff900000)
+//Bit 31:28       reg_pkgain_vsluma_lut7;
+//Bit 27:24       reg_pkgain_vsluma_lut6;
+//Bit 23:20       reg_pkgain_vsluma_lut5;
+//Bit 19:16       reg_pkgain_vsluma_lut4;
+//Bit 15:12       reg_pkgain_vsluma_lut3;
+//Bit 11: 8       reg_pkgain_vsluma_lut2;
+//Bit  7: 4       reg_pkgain_vsluma_lut1;
+//Bit  3: 0       reg_pkgain_vsluma_lut0;
+#define   SHARP_PKGAIN_VSLUMA_LUT_H                (0x327f)
+#define P_SHARP_PKGAIN_VSLUMA_LUT_H                (volatile unsigned int *)((0x327f  << 2) + 0xff900000)
+//Bit 31: 4       reserved;
+//Bit  3: 0       reg_pkgain_vsluma_lut8;
+#define   SHARP_PKOSHT_VSLUMA_LUT_L                (0x3203)
+#define P_SHARP_PKOSHT_VSLUMA_LUT_L                (volatile unsigned int *)((0x3203  << 2) + 0xff900000)
+//Bit 31:28       reg_pkosht_vsluma_lut7;
+//Bit 27:24       reg_pkosht_vsluma_lut6;
+//Bit 23:20       reg_pkosht_vsluma_lut5;
+//Bit 19:16       reg_pkosht_vsluma_lut4;
+//Bit 15:12       reg_pkosht_vsluma_lut3;
+//Bit 11: 8       reg_pkosht_vsluma_lut2;
+//Bit  7: 4       reg_pkosht_vsluma_lut1;
+//Bit  3: 0       reg_pkosht_vsluma_lut0;
+#define   SHARP_PKOSHT_VSLUMA_LUT_H                (0x3204)
+#define P_SHARP_PKOSHT_VSLUMA_LUT_H                (volatile unsigned int *)((0x3204  << 2) + 0xff900000)
+//Bit 31: 4       reserved;
+//Bit  3: 0       reg_pkosht_vsluma_lut8;
+//
+// Closing file:  sharp_regs.h
+//
+
+#define SRSHARP0_SHARP_HVSIZE                      (SRSHARP0_OFFSET + SHARP_HVSIZE                 )  //0x00  //
+#define SRSHARP0_SHARP_HVBLANK_NUM                 (SRSHARP0_OFFSET + SHARP_HVBLANK_NUM            )  //0x01  //
+#define SRSHARP0_NR_GAUSSIAN_MODE                  (SRSHARP0_OFFSET + NR_GAUSSIAN_MODE             )  //0x02  //
+//`define SRSHARP0_PK_HVCON_LPF_MODE                 (`SRSHARP0_OFFSET + `PK_HVCON_LPF_MODE            )  //8'h03  //
+//`define SRSHARP0_PK_CON_BLEND_GAIN                 (`SRSHARP0_OFFSET + `PK_CON_BLEND_GAIN            )  //8'h04  //
+#define SRSHARP0_PK_CON_2CIRHPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2CIRHPGAIN_TH_RATE    )  //0x05  //
+#define SRSHARP0_PK_CON_2CIRHPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2CIRHPGAIN_LIMIT      )  //0x06  //
+#define SRSHARP0_PK_CON_2CIRBPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2CIRBPGAIN_TH_RATE    )  //0x07  //
+#define SRSHARP0_PK_CON_2CIRBPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2CIRBPGAIN_LIMIT      )  //0x08  //
+#define SRSHARP0_PK_CON_2DRTHPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2DRTHPGAIN_TH_RATE    )  //0x09  //
+#define SRSHARP0_PK_CON_2DRTHPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2DRTHPGAIN_LIMIT      )  //0x0a  //
+#define SRSHARP0_PK_CON_2DRTBPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2DRTBPGAIN_TH_RATE    )  //0x0b  //
+#define SRSHARP0_PK_CON_2DRTBPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2DRTBPGAIN_LIMIT      )  //0x0c  //
+#define SRSHARP0_PK_CIRFB_LPF_MODE                 (SRSHARP0_OFFSET + PK_CIRFB_LPF_MODE            )  //0x0d  //
+#define SRSHARP0_PK_DRTFB_LPF_MODE                 (SRSHARP0_OFFSET + PK_DRTFB_LPF_MODE            )  //0x0e  //
+#define SRSHARP0_PK_CIRFB_HP_CORING                (SRSHARP0_OFFSET + PK_CIRFB_HP_CORING           )  //0x0f  //
+#define SRSHARP0_PK_CIRFB_BP_CORING                (SRSHARP0_OFFSET + PK_CIRFB_BP_CORING           )  //0x10  //
+#define SRSHARP0_PK_DRTFB_HP_CORING                (SRSHARP0_OFFSET + PK_DRTFB_HP_CORING           )  //0x11  //
+#define SRSHARP0_PK_DRTFB_BP_CORING                (SRSHARP0_OFFSET + PK_DRTFB_BP_CORING           )  //0x12  //
+#define SRSHARP0_PK_CIRFB_BLEND_GAIN               (SRSHARP0_OFFSET + PK_CIRFB_BLEND_GAIN          )  //0x13  //
+#define SRSHARP0_NR_ALPY_SSD_GAIN_OFST             (SRSHARP0_OFFSET + NR_ALPY_SSD_GAIN_OFST        )  //0x14  //
+#define SRSHARP0_NR_ALP0Y_ERR2CURV_TH_RATE         (SRSHARP0_OFFSET + NR_ALP0Y_ERR2CURV_TH_RATE    )  //0x15  //
+#define SRSHARP0_NR_ALP0Y_ERR2CURV_LIMIT           (SRSHARP0_OFFSET + NR_ALP0Y_ERR2CURV_LIMIT      )  //0x16  //
+#define SRSHARP0_NR_ALP0C_ERR2CURV_TH_RATE         (SRSHARP0_OFFSET + NR_ALP0C_ERR2CURV_TH_RATE    )  //0x17  //
+#define SRSHARP0_NR_ALP0C_ERR2CURV_LIMIT           (SRSHARP0_OFFSET + NR_ALP0C_ERR2CURV_LIMIT      )  //0x18  //
+#define SRSHARP0_NR_ALP0_MIN_MAX                   (SRSHARP0_OFFSET + NR_ALP0_MIN_MAX              )  //0x19  //
+#define SRSHARP0_NR_ALP1_MIERR_CORING              (SRSHARP0_OFFSET + NR_ALP1_MIERR_CORING         )  //0x1a  //
+#define SRSHARP0_NR_ALP1_ERR2CURV_TH_RATE          (SRSHARP0_OFFSET + NR_ALP1_ERR2CURV_TH_RATE     )  //0x1b  //
+#define SRSHARP0_NR_ALP1_ERR2CURV_LIMIT            (SRSHARP0_OFFSET + NR_ALP1_ERR2CURV_LIMIT       )  //0x1c  //
+#define SRSHARP0_NR_ALP1_MIN_MAX                   (SRSHARP0_OFFSET + NR_ALP1_MIN_MAX              )  //0x1d  //
+#define SRSHARP0_PK_ALP2_MIERR_CORING              (SRSHARP0_OFFSET + PK_ALP2_MIERR_CORING         )  //0x1e  //
+#define SRSHARP0_PK_ALP2_ERR2CURV_TH_RATE          (SRSHARP0_OFFSET + PK_ALP2_ERR2CURV_TH_RATE     )  //0x1f  //
+#define SRSHARP0_PK_ALP2_ERR2CURV_LIMIT            (SRSHARP0_OFFSET + PK_ALP2_ERR2CURV_LIMIT       )  //0x20  //
+#define SRSHARP0_PK_ALP2_MIN_MAX                   (SRSHARP0_OFFSET + PK_ALP2_MIN_MAX              )  //0x21  //
+#define SRSHARP0_PK_FINALGAIN_HP_BP                (SRSHARP0_OFFSET + PK_FINALGAIN_HP_BP           )  //0x22  //
+#define SRSHARP0_PK_OS_HORZ_CORE_GAIN              (SRSHARP0_OFFSET + PK_OS_HORZ_CORE_GAIN         )  //0x23  //
+#define SRSHARP0_PK_OS_VERT_CORE_GAIN              (SRSHARP0_OFFSET + PK_OS_VERT_CORE_GAIN         )  //0x24  //
+#define SRSHARP0_PK_OS_ADPT_MISC                   (SRSHARP0_OFFSET + PK_OS_ADPT_MISC              )  //0x25  //
+#define SRSHARP0_PK_OS_STATIC                      (SRSHARP0_OFFSET + PK_OS_STATIC                 )  //0x26  //
+#define SRSHARP0_PK_NR_ENABLE                      (SRSHARP0_OFFSET + PK_NR_ENABLE                 )  //0x27  //
+#define SRSHARP0_PK_DRT_SAD_MISC                   (SRSHARP0_OFFSET + PK_DRT_SAD_MISC              )  //0x28  //
+#define SRSHARP0_NR_TI_DNLP_BLEND                  (SRSHARP0_OFFSET + NR_TI_DNLP_BLEND             )  //0x29  //
+
+#define SRSHARP0_LTI_DIR_CORE_ALPHA                (SRSHARP0_OFFSET + LTI_DIR_CORE_ALPHA           )  //0x2a  //
+#define SRSHARP0_CTI_DIR_ALPHA                     (SRSHARP0_OFFSET + CTI_DIR_ALPHA                )  //0x2b  //
+#define SRSHARP0_LTI_CTI_DF_GAIN                   (SRSHARP0_OFFSET + LTI_CTI_DF_GAIN              )  //0x2c  //
+#define SRSHARP0_LTI_CTI_DIR_AC_DBG                (SRSHARP0_OFFSET + LTI_CTI_DIR_AC_DBG           )  //0x2d  //
+#define SRSHARP0_HCTI_FLT_CLP_DC                   (SRSHARP0_OFFSET + HCTI_FLT_CLP_DC              )  //0x2e  //
+#define SRSHARP0_HCTI_BST_GAIN                     (SRSHARP0_OFFSET + HCTI_BST_GAIN                )  //0x2f  //
+#define SRSHARP0_HCTI_BST_CORE                     (SRSHARP0_OFFSET + HCTI_BST_CORE                )  //0x30  //
+#define SRSHARP0_HCTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + HCTI_CON_2_GAIN_0            )  //0x31  //
+#define SRSHARP0_HCTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + HCTI_CON_2_GAIN_1            )  //0x32  //
+#define SRSHARP0_HCTI_OS_MARGIN                    (SRSHARP0_OFFSET + HCTI_OS_MARGIN               )  //0x33  //
+#define SRSHARP0_HLTI_FLT_CLP_DC                   (SRSHARP0_OFFSET + HLTI_FLT_CLP_DC              )  //0x34  //
+#define SRSHARP0_HLTI_BST_GAIN                     (SRSHARP0_OFFSET + HLTI_BST_GAIN                )  //0x35  //
+#define SRSHARP0_HLTI_BST_CORE                     (SRSHARP0_OFFSET + HLTI_BST_CORE                )  //0x36  //
+#define SRSHARP0_HLTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + HLTI_CON_2_GAIN_0            )  //0x37  //
+#define SRSHARP0_HLTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + HLTI_CON_2_GAIN_1            )  //0x38  //
+#define SRSHARP0_HLTI_OS_MARGIN                    (SRSHARP0_OFFSET + HLTI_OS_MARGIN               )  //0x39  //
+#define SRSHARP0_VLTI_FLT_CON_CLP                  (SRSHARP0_OFFSET + VLTI_FLT_CON_CLP             )  //0x3a  //
+#define SRSHARP0_VLTI_BST_GAIN                     (SRSHARP0_OFFSET + VLTI_BST_GAIN                )  //0x3b  //
+#define SRSHARP0_VLTI_BST_CORE                     (SRSHARP0_OFFSET + VLTI_BST_CORE                )  //0x3c  //
+#define SRSHARP0_VLTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + VLTI_CON_2_GAIN_0            )  //0x3d  //
+#define SRSHARP0_VLTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + VLTI_CON_2_GAIN_1            )  //0x3e  //
+#define SRSHARP0_VCTI_FLT_CON_CLP                  (SRSHARP0_OFFSET + VCTI_FLT_CON_CLP             )  //0x3f  //
+#define SRSHARP0_VCTI_BST_GAIN                     (SRSHARP0_OFFSET + VCTI_BST_GAIN                )  //0x40  //
+#define SRSHARP0_VCTI_BST_CORE                     (SRSHARP0_OFFSET + VCTI_BST_CORE                )  //0x41  //
+#define SRSHARP0_VCTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + VCTI_CON_2_GAIN_0            )  //0x42  //
+#define SRSHARP0_VCTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + VCTI_CON_2_GAIN_1            )  //0x43  //
+#define SRSHARP0_SHARP_3DLIMIT                     (SRSHARP0_OFFSET + SHARP_3DLIMIT                )  //0x44  //
+#define SRSHARP0_DNLP_EN                           (SRSHARP0_OFFSET + DNLP_EN                      )  //0x45  //
+#define SRSHARP0_DNLP_00                           (SRSHARP0_OFFSET + DNLP_00                      )  //0x46  //
+#define SRSHARP0_DNLP_01                           (SRSHARP0_OFFSET + DNLP_01                      )  //0x47  //
+#define SRSHARP0_DNLP_02                           (SRSHARP0_OFFSET + DNLP_02                      )  //0x48  //
+#define SRSHARP0_DNLP_03                           (SRSHARP0_OFFSET + DNLP_03                      )  //0x49  //
+#define SRSHARP0_DNLP_04                           (SRSHARP0_OFFSET + DNLP_04                      )  //0x4a  //
+#define SRSHARP0_DNLP_05                           (SRSHARP0_OFFSET + DNLP_05                      )  //0x4b  //
+#define SRSHARP0_DNLP_06                           (SRSHARP0_OFFSET + DNLP_06                      )  //0x4c  //
+#define SRSHARP0_DNLP_07                           (SRSHARP0_OFFSET + DNLP_07                      )  //0x4d  //
+#define SRSHARP0_DNLP_08                           (SRSHARP0_OFFSET + DNLP_08                      )  //0x4e  //
+#define SRSHARP0_DNLP_09                           (SRSHARP0_OFFSET + DNLP_09                      )  //0x4f  //
+#define SRSHARP0_DNLP_10                           (SRSHARP0_OFFSET + DNLP_10                      )  //0x50  //
+#define SRSHARP0_DNLP_11                           (SRSHARP0_OFFSET + DNLP_11                      )  //0x51  //
+#define SRSHARP0_DNLP_12                           (SRSHARP0_OFFSET + DNLP_12                      )  //0x52  //
+#define SRSHARP0_DNLP_13                           (SRSHARP0_OFFSET + DNLP_13                      )  //0x53  //
+#define SRSHARP0_DNLP_14                           (SRSHARP0_OFFSET + DNLP_14                      )  //0x54  //
+#define SRSHARP0_DNLP_15                           (SRSHARP0_OFFSET + DNLP_15                      )  //0x55  //
+#define SRSHARP0_DEMO_CRTL                         (SRSHARP0_OFFSET + DEMO_CRTL                    )  //0x56  //
+#define SRSHARP0_SHARP_SR2_CTRL                    (SRSHARP0_OFFSET + SHARP_SR2_CTRL               )  //0x57  //
+#define SRSHARP0_SHARP_SR2_YBIC_HCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_HCOEF0        )  //0x58
+#define SRSHARP0_SHARP_SR2_YBIC_HCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_HCOEF1        )  //0x59  //
+#define SRSHARP0_SHARP_SR2_CBIC_HCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_HCOEF0        )  //0x5a  //
+#define SRSHARP0_SHARP_SR2_CBIC_HCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_HCOEF1        )  //0x5b  //
+#define SRSHARP0_SHARP_SR2_YBIC_VCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_VCOEF0        )  //0x5c  //
+#define SRSHARP0_SHARP_SR2_YBIC_VCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_VCOEF1        )  //0x5d  //
+#define SRSHARP0_SHARP_SR2_CBIC_VCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_VCOEF0        )  //0x5e  //
+#define SRSHARP0_SHARP_SR2_CBIC_VCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_VCOEF1        )  //0x5f  //
+#define SRSHARP0_SHARP_SR2_MISC                    (SRSHARP0_OFFSET + SHARP_SR2_MISC               )  //0x60  //
+// `define SRSHARP0_SHARP_DEJ2_PRC                    (`SRSHARP0_OFFSET + `SHARP_DEJ2_PRC               )  //8'h61  //
+// `define SRSHARP0_SHARP_DEJ1_PRC                    (`SRSHARP0_OFFSET + `SHARP_DEJ1_PRC               )  //8'h62  //
+// `define SRSHARP0_SHARP_DEJ2_MISC                   (`SRSHARP0_OFFSET + `SHARP_DEJ2_MISC              )  //8'h63  //
+// `define SRSHARP0_SHARP_DEJ1_MISC                   (`SRSHARP0_OFFSET + `SHARP_DEJ1_MISC              )  //8'h64  //
+#define SRSHARP0_SR3_SAD_CTRL                   (SRSHARP0_OFFSET + SHARP_SR3_SAD_CTRL                 ) // 0x61  //
+#define SRSHARP0_SR3_PK_CTRL0                   (SRSHARP0_OFFSET + SHARP_SR3_PK_CTRL0                 ) // 0x62
+#define SRSHARP0_SR3_PK_CTRL1                   (SRSHARP0_OFFSET + SHARP_SR3_PK_CTRL1                 ) // 0x63
+#define SRSHARP0_DEJ_CTRL                       (SRSHARP0_OFFSET + SHARP_DEJ_CTRL                     ) // 0x64
+#define SRSHARP0_DEJ_ALPHA                      (SRSHARP0_OFFSET + SHARP_DEJ_ALPHA                    ) // 0x65
+#define SRSHARP0_SR3_DRTLPF_EN                  (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_EN                ) // 0x66
+#define SRSHARP0_SR3_DRTLPF_ALPHA_0             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_0           ) // 0x67
+#define SRSHARP0_SR3_DRTLPF_ALPHA_1             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_1           ) // 0x68
+#define SRSHARP0_SR3_DRTLPF_ALPHA_2             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_2           ) // 0x69
+#define SRSHARP0_SR3_DRTLPF_ALPHA_OFST          (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_OFST        ) // 0x6a
+#define SRSHARP0_SR3_DERING_CTRL                (SRSHARP0_OFFSET + SHARP_SR3_DERING_CTRL              ) // 0x6b
+#define SRSHARP0_SR3_DERING_LUMA2PKGAIN_0TO3    (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_0TO3  ) // 0x6c
+#define SRSHARP0_SR3_DERING_LUMA2PKGAIN_4TO6    (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_4TO6  ) // 0x6d
+#define SRSHARP0_SR3_DERING_LUMA2PKOS_0TO3      (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_0TO3    ) // 0x6e
+#define SRSHARP0_SR3_DERING_LUMA2PKOS_4TO6      (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_4TO6    ) // 0x6f
+#define SRSHARP0_SR3_DERING_GAINVS_MADSAD       (SRSHARP0_OFFSET + SHARP_SR3_DERING_GAINVS_MADSAD     ) // 0x70
+#define SRSHARP0_SR3_DERING_GAINVS_VR2MAX       (SRSHARP0_OFFSET + SHARP_SR3_DERING_GAINVS_VR2MAX     ) // 0x71
+#define SRSHARP0_SR3_DERING_PARAM0              (SRSHARP0_OFFSET + SHARP_SR3_DERING_PARAM0            ) // 0x72
+#define SRSHARP0_SR3_DRTLPF_THETA               (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_THETA             ) // 0x73
+#define SRSHARP0_SATPRT_CTRL                    (SRSHARP0_OFFSET + SHARP_SATPRT_CTRL                  ) // 0x74
+#define SRSHARP0_SATPRT_DIVM                    (SRSHARP0_OFFSET + SHARP_SATPRT_DIVM                  ) // 0x75
+#define SRSHARP0_SATPRT_LMT_RGB                 (SRSHARP0_OFFSET + SHARP_SATPRT_LMT_RGB               ) // 0x76
+#define SRSHARP0_DB_FLT_CTRL                    (SRSHARP0_OFFSET + SHARP_DB_FLT_CTRL                  ) // 0x77
+#define SRSHARP0_DB_FLT_YC_THRD                 (SRSHARP0_OFFSET + SHARP_DB_FLT_YC_THRD               ) // 0x78
+#define SRSHARP0_DB_FLT_RANDLUT                 (SRSHARP0_OFFSET + SHARP_DB_FLT_RANDLUT               ) // 0x79
+#define SRSHARP0_DB_FLT_PXI_THRD                (SRSHARP0_OFFSET + SHARP_DB_FLT_PXI_THRD              ) // 0x7a
+#define SRSHARP0_DB_FLT_SEED_Y                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_Y                ) // 0x7b
+#define SRSHARP0_DB_FLT_SEED_U                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_U                ) // 0x7c
+#define SRSHARP0_DB_FLT_SEED_V                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_V                ) // 0x7d
+#define SRSHARP0_PKGAIN_VSLUMA_LUT_L            (SRSHARP0_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_L          ) // 0x80
+#define SRSHARP0_PKGAIN_VSLUMA_LUT_H            (SRSHARP0_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_H          ) // 0x81
+#define SRSHARP0_PKOSHT_VSLUMA_LUT_L            (SRSHARP0_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_L          ) // 0x82
+#define SRSHARP0_PKOSHT_VSLUMA_LUT_H            (SRSHARP0_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_H          ) // 0x83
+
+//// srsharp1 reg define
+
+#define SRSHARP1_SHARP_HVSIZE                      (SRSHARP1_OFFSET + SHARP_HVSIZE                 )  //0x00  //
+#define SRSHARP1_SHARP_HVBLANK_NUM                 (SRSHARP1_OFFSET + SHARP_HVBLANK_NUM            )  //0x01  //
+#define SRSHARP1_NR_GAUSSIAN_MODE                  (SRSHARP1_OFFSET + NR_GAUSSIAN_MODE             )  //0x02  //
+//`define SRSHARP1_PK_HVCON_LPF_MODE                 (`SRSHARP1_OFFSET + `PK_HVCON_LPF_MODE            )  //8'h03  //
+//`define SRSHARP1_PK_CON_BLEND_GAIN                 (`SRSHARP1_OFFSET + `PK_CON_BLEND_GAIN            )  //8'h04  //
+#define SRSHARP1_PK_CON_2CIRHPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2CIRHPGAIN_TH_RATE    )  //0x05  //
+#define SRSHARP1_PK_CON_2CIRHPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2CIRHPGAIN_LIMIT      )  //0x06  //
+#define SRSHARP1_PK_CON_2CIRBPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2CIRBPGAIN_TH_RATE    )  //0x07  //
+#define SRSHARP1_PK_CON_2CIRBPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2CIRBPGAIN_LIMIT      )  //0x08  //
+#define SRSHARP1_PK_CON_2DRTHPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2DRTHPGAIN_TH_RATE    )  //0x09  //
+#define SRSHARP1_PK_CON_2DRTHPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2DRTHPGAIN_LIMIT      )  //0x0a  //
+#define SRSHARP1_PK_CON_2DRTBPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2DRTBPGAIN_TH_RATE    )  //0x0b  //
+#define SRSHARP1_PK_CON_2DRTBPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2DRTBPGAIN_LIMIT      )  //0x0c  //
+#define SRSHARP1_PK_CIRFB_LPF_MODE                 (SRSHARP1_OFFSET + PK_CIRFB_LPF_MODE            )  //0x0d  //
+#define SRSHARP1_PK_DRTFB_LPF_MODE                 (SRSHARP1_OFFSET + PK_DRTFB_LPF_MODE            )  //0x0e  //
+#define SRSHARP1_PK_CIRFB_HP_CORING                (SRSHARP1_OFFSET + PK_CIRFB_HP_CORING           )  //0x0f  //
+#define SRSHARP1_PK_CIRFB_BP_CORING                (SRSHARP1_OFFSET + PK_CIRFB_BP_CORING           )  //0x10  //
+#define SRSHARP1_PK_DRTFB_HP_CORING                (SRSHARP1_OFFSET + PK_DRTFB_HP_CORING           )  //0x11  //
+#define SRSHARP1_PK_DRTFB_BP_CORING                (SRSHARP1_OFFSET + PK_DRTFB_BP_CORING           )  //0x12  //
+#define SRSHARP1_PK_CIRFB_BLEND_GAIN               (SRSHARP1_OFFSET + PK_CIRFB_BLEND_GAIN          )  //0x13  //
+#define SRSHARP1_NR_ALPY_SSD_GAIN_OFST             (SRSHARP1_OFFSET + NR_ALPY_SSD_GAIN_OFST        )  //0x14  //
+#define SRSHARP1_NR_ALP0Y_ERR2CURV_TH_RATE         (SRSHARP1_OFFSET + NR_ALP0Y_ERR2CURV_TH_RATE    )  //0x15  //
+#define SRSHARP1_NR_ALP0Y_ERR2CURV_LIMIT           (SRSHARP1_OFFSET + NR_ALP0Y_ERR2CURV_LIMIT      )  //0x16  //
+#define SRSHARP1_NR_ALP0C_ERR2CURV_TH_RATE         (SRSHARP1_OFFSET + NR_ALP0C_ERR2CURV_TH_RATE    )  //0x17  //
+#define SRSHARP1_NR_ALP0C_ERR2CURV_LIMIT           (SRSHARP1_OFFSET + NR_ALP0C_ERR2CURV_LIMIT      )  //0x18  //
+#define SRSHARP1_NR_ALP0_MIN_MAX                   (SRSHARP1_OFFSET + NR_ALP0_MIN_MAX              )  //0x19  //
+#define SRSHARP1_NR_ALP1_MIERR_CORING              (SRSHARP1_OFFSET + NR_ALP1_MIERR_CORING         )  //0x1a  //
+#define SRSHARP1_NR_ALP1_ERR2CURV_TH_RATE          (SRSHARP1_OFFSET + NR_ALP1_ERR2CURV_TH_RATE     )  //0x1b  //
+#define SRSHARP1_NR_ALP1_ERR2CURV_LIMIT            (SRSHARP1_OFFSET + NR_ALP1_ERR2CURV_LIMIT       )  //0x1c  //
+#define SRSHARP1_NR_ALP1_MIN_MAX                   (SRSHARP1_OFFSET + NR_ALP1_MIN_MAX              )  //0x1d  //
+#define SRSHARP1_PK_ALP2_MIERR_CORING              (SRSHARP1_OFFSET + PK_ALP2_MIERR_CORING         )  //0x1e  //
+#define SRSHARP1_PK_ALP2_ERR2CURV_TH_RATE          (SRSHARP1_OFFSET + PK_ALP2_ERR2CURV_TH_RATE     )  //0x1f  //
+#define SRSHARP1_PK_ALP2_ERR2CURV_LIMIT            (SRSHARP1_OFFSET + PK_ALP2_ERR2CURV_LIMIT       )  //0x20  //
+#define SRSHARP1_PK_ALP2_MIN_MAX                   (SRSHARP1_OFFSET + PK_ALP2_MIN_MAX              )  //0x21  //
+#define SRSHARP1_PK_FINALGAIN_HP_BP                (SRSHARP1_OFFSET + PK_FINALGAIN_HP_BP           )  //0x22  //
+#define SRSHARP1_PK_OS_HORZ_CORE_GAIN              (SRSHARP1_OFFSET + PK_OS_HORZ_CORE_GAIN         )  //0x23  //
+#define SRSHARP1_PK_OS_VERT_CORE_GAIN              (SRSHARP1_OFFSET + PK_OS_VERT_CORE_GAIN         )  //0x24  //
+#define SRSHARP1_PK_OS_ADPT_MISC                   (SRSHARP1_OFFSET + PK_OS_ADPT_MISC              )  //0x25  //
+#define SRSHARP1_PK_OS_STATIC                      (SRSHARP1_OFFSET + PK_OS_STATIC                 )  //0x26  //
+#define SRSHARP1_PK_NR_ENABLE                      (SRSHARP1_OFFSET + PK_NR_ENABLE                 )  //0x27  //
+#define SRSHARP1_PK_DRT_SAD_MISC                   (SRSHARP1_OFFSET + PK_DRT_SAD_MISC              )  //0x28  //
+#define SRSHARP1_NR_TI_DNLP_BLEND                  (SRSHARP1_OFFSET + NR_TI_DNLP_BLEND             )  //0x29  //
+#define SRSHARP1_LTI_DIR_CORE_ALPHA                (SRSHARP1_OFFSET + LTI_DIR_CORE_ALPHA           )  //0x2a  //
+#define SRSHARP1_CTI_DIR_ALPHA                     (SRSHARP1_OFFSET + CTI_DIR_ALPHA                )  //0x2b  //
+#define SRSHARP1_LTI_CTI_DF_GAIN                   (SRSHARP1_OFFSET + LTI_CTI_DF_GAIN              )  //0x2c  //
+#define SRSHARP1_LTI_CTI_DIR_AC_DBG                (SRSHARP1_OFFSET + LTI_CTI_DIR_AC_DBG           )  //0x2d  //
+#define SRSHARP1_HCTI_FLT_CLP_DC                   (SRSHARP1_OFFSET + HCTI_FLT_CLP_DC              )  //0x2e  //
+#define SRSHARP1_HCTI_BST_GAIN                     (SRSHARP1_OFFSET + HCTI_BST_GAIN                )  //0x2f  //
+#define SRSHARP1_HCTI_BST_CORE                     (SRSHARP1_OFFSET + HCTI_BST_CORE                )  //0x30  //
+#define SRSHARP1_HCTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + HCTI_CON_2_GAIN_0            )  //0x31  //
+#define SRSHARP1_HCTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + HCTI_CON_2_GAIN_1            )  //0x32  //
+#define SRSHARP1_HCTI_OS_MARGIN                    (SRSHARP1_OFFSET + HCTI_OS_MARGIN               )  //0x33  //
+#define SRSHARP1_HLTI_FLT_CLP_DC                   (SRSHARP1_OFFSET + HLTI_FLT_CLP_DC              )  //0x34  //
+#define SRSHARP1_HLTI_BST_GAIN                     (SRSHARP1_OFFSET + HLTI_BST_GAIN                )  //0x35  //
+#define SRSHARP1_HLTI_BST_CORE                     (SRSHARP1_OFFSET + HLTI_BST_CORE                )  //0x36  //
+#define SRSHARP1_HLTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + HLTI_CON_2_GAIN_0            )  //0x37  //
+#define SRSHARP1_HLTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + HLTI_CON_2_GAIN_1            )  //0x38  //
+#define SRSHARP1_HLTI_OS_MARGIN                    (SRSHARP1_OFFSET + HLTI_OS_MARGIN               )  //0x39  //
+#define SRSHARP1_VLTI_FLT_CON_CLP                  (SRSHARP1_OFFSET + VLTI_FLT_CON_CLP             )  //0x3a  //
+#define SRSHARP1_VLTI_BST_GAIN                     (SRSHARP1_OFFSET + VLTI_BST_GAIN                )  //0x3b  //
+#define SRSHARP1_VLTI_BST_CORE                     (SRSHARP1_OFFSET + VLTI_BST_CORE                )  //0x3c  //
+#define SRSHARP1_VLTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + VLTI_CON_2_GAIN_0            )  //0x3d  //
+#define SRSHARP1_VLTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + VLTI_CON_2_GAIN_1            )  //0x3e  //
+#define SRSHARP1_VCTI_FLT_CON_CLP                  (SRSHARP1_OFFSET + VCTI_FLT_CON_CLP             )  //0x3f  //
+#define SRSHARP1_VCTI_BST_GAIN                     (SRSHARP1_OFFSET + VCTI_BST_GAIN                )  //0x40  //
+#define SRSHARP1_VCTI_BST_CORE                     (SRSHARP1_OFFSET + VCTI_BST_CORE                )  //0x41  //
+#define SRSHARP1_VCTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + VCTI_CON_2_GAIN_0            )  //0x42  //
+#define SRSHARP1_VCTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + VCTI_CON_2_GAIN_1            )  //0x43  //
+#define SRSHARP1_SHARP_3DLIMIT                     (SRSHARP1_OFFSET + SHARP_3DLIMIT                )  //0x44  //
+#define SRSHARP1_DNLP_EN                           (SRSHARP1_OFFSET + DNLP_EN                      )  //0x45  //
+#define SRSHARP1_DNLP_00                           (SRSHARP1_OFFSET + DNLP_00                      )  //0x46  //
+#define SRSHARP1_DNLP_01                           (SRSHARP1_OFFSET + DNLP_01                      )  //0x47  //
+#define SRSHARP1_DNLP_02                           (SRSHARP1_OFFSET + DNLP_02                      )  //0x48  //
+#define SRSHARP1_DNLP_03                           (SRSHARP1_OFFSET + DNLP_03                      )  //0x49  //
+#define SRSHARP1_DNLP_04                           (SRSHARP1_OFFSET + DNLP_04                      )  //0x4a  //
+#define SRSHARP1_DNLP_05                           (SRSHARP1_OFFSET + DNLP_05                      )  //0x4b  //
+#define SRSHARP1_DNLP_06                           (SRSHARP1_OFFSET + DNLP_06                      )  //0x4c  //
+#define SRSHARP1_DNLP_07                           (SRSHARP1_OFFSET + DNLP_07                      )  //0x4d  //
+#define SRSHARP1_DNLP_08                           (SRSHARP1_OFFSET + DNLP_08                      )  //0x4e  //
+#define SRSHARP1_DNLP_09                           (SRSHARP1_OFFSET + DNLP_09                      )  //0x4f  //
+#define SRSHARP1_DNLP_10                           (SRSHARP1_OFFSET + DNLP_10                      )  //0x50  //
+#define SRSHARP1_DNLP_11                           (SRSHARP1_OFFSET + DNLP_11                      )  //0x51  //
+#define SRSHARP1_DNLP_12                           (SRSHARP1_OFFSET + DNLP_12                      )  //0x52  //
+#define SRSHARP1_DNLP_13                           (SRSHARP1_OFFSET + DNLP_13                      )  //0x53  //
+#define SRSHARP1_DNLP_14                           (SRSHARP1_OFFSET + DNLP_14                      )  //0x54  //
+#define SRSHARP1_DNLP_15                           (SRSHARP1_OFFSET + DNLP_15                      )  //0x55  //
+#define SRSHARP1_DEMO_CRTL                         (SRSHARP1_OFFSET + DEMO_CRTL                    )  //0x56  //
+#define SRSHARP1_SHARP_SR2_CTRL                    (SRSHARP1_OFFSET + SHARP_SR2_CTRL               )  //0x57  //
+#define SRSHARP1_SHARP_SR2_YBIC_HCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_HCOEF0        )  //0x58
+#define SRSHARP1_SHARP_SR2_YBIC_HCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_HCOEF1        )  //0x59  //
+#define SRSHARP1_SHARP_SR2_CBIC_HCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_HCOEF0        )  //0x5a  //
+#define SRSHARP1_SHARP_SR2_CBIC_HCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_HCOEF1        )  //0x5b  //
+#define SRSHARP1_SHARP_SR2_YBIC_VCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_VCOEF0        )  //0x5c  //
+#define SRSHARP1_SHARP_SR2_YBIC_VCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_VCOEF1        )  //0x5d  //
+#define SRSHARP1_SHARP_SR2_CBIC_VCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_VCOEF0        )  //0x5e  //
+#define SRSHARP1_SHARP_SR2_CBIC_VCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_VCOEF1        )  //0x5f  //
+#define SRSHARP1_SHARP_SR2_MISC                    (SRSHARP1_OFFSET + SHARP_SR2_MISC               )  //0x60  //
+// `define SRSHARP1_SHARP_DEJ2_PRC                    (`SRSHARP1_OFFSET + `SHARP_DEJ2_PRC               )  //8'h61  //
+// `define SRSHARP1_SHARP_DEJ1_PRC                    (`SRSHARP1_OFFSET + `SHARP_DEJ1_PRC               )  //8'h62  //
+// `define SRSHARP1_SHARP_DEJ2_MISC                   (`SRSHARP1_OFFSET + `SHARP_DEJ2_MISC              )  //8'h63  //
+// `define SRSHARP1_SHARP_DEJ1_MISC                   (`SRSHARP1_OFFSET + `SHARP_DEJ1_MISC              )  //8'h64  //
+
+#define SRSHARP1_SR3_SAD_CTRL                   (SRSHARP1_OFFSET + SHARP_SR3_SAD_CTRL                 ) // 0x61  //
+#define SRSHARP1_SR3_PK_CTRL0                   (SRSHARP1_OFFSET + SHARP_SR3_PK_CTRL0                 ) // 0x62
+#define SRSHARP1_SR3_PK_CTRL1                   (SRSHARP1_OFFSET + SHARP_SR3_PK_CTRL1                 ) // 0x63
+#define SRSHARP1_DEJ_CTRL                       (SRSHARP1_OFFSET + SHARP_DEJ_CTRL                     ) // 0x64
+#define SRSHARP1_DEJ_ALPHA                      (SRSHARP1_OFFSET + SHARP_DEJ_ALPHA                    ) // 0x65
+#define SRSHARP1_SR3_DRTLPF_EN                  (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_EN                ) // 0x66
+#define SRSHARP1_SR3_DRTLPF_ALPHA_0             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_0           ) // 0x67
+#define SRSHARP1_SR3_DRTLPF_ALPHA_1             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_1           ) // 0x68
+#define SRSHARP1_SR3_DRTLPF_ALPHA_2             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_2           ) // 0x69
+#define SRSHARP1_SR3_DRTLPF_ALPHA_OFST          (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_OFST        ) // 0x6a
+#define SRSHARP1_SR3_DERING_CTRL                (SRSHARP1_OFFSET + SHARP_SR3_DERING_CTRL              ) // 0x6b
+#define SRSHARP1_SR3_DERING_LUMA2PKGAIN_0TO3    (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_0TO3  ) // 0x6c
+#define SRSHARP1_SR3_DERING_LUMA2PKGAIN_4TO6    (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_4TO6  ) // 0x6d
+#define SRSHARP1_SR3_DERING_LUMA2PKOS_0TO3      (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_0TO3    ) // 0x6e
+#define SRSHARP1_SR3_DERING_LUMA2PKOS_4TO6      (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_4TO6    ) // 0x6f
+#define SRSHARP1_SR3_DERING_GAINVS_MADSAD       (SRSHARP1_OFFSET + SHARP_SR3_DERING_GAINVS_MADSAD     ) // 0x70
+#define SRSHARP1_SR3_DERING_GAINVS_VR2MAX       (SRSHARP1_OFFSET + SHARP_SR3_DERING_GAINVS_VR2MAX     ) // 0x71
+#define SRSHARP1_SR3_DERING_PARAM0              (SRSHARP1_OFFSET + SHARP_SR3_DERING_PARAM0            ) // 0x72
+#define SRSHARP1_SR3_DRTLPF_THETA               (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_THETA             ) // 0x73
+#define SRSHARP1_SATPRT_CTRL                    (SRSHARP1_OFFSET + SHARP_SATPRT_CTRL                  ) // 0x74
+#define SRSHARP1_SATPRT_DIVM                    (SRSHARP1_OFFSET + SHARP_SATPRT_DIVM                  ) // 0x75
+#define SRSHARP1_SATPRT_LMT_RGB                 (SRSHARP1_OFFSET + SHARP_SATPRT_LMT_RGB               ) // 0x76
+#define SRSHARP1_DB_FLT_CTRL                    (SRSHARP1_OFFSET + SHARP_DB_FLT_CTRL                  ) // 0x77
+#define SRSHARP1_DB_FLT_YC_THRD                 (SRSHARP1_OFFSET + SHARP_DB_FLT_YC_THRD               ) // 0x78
+#define SRSHARP1_DB_FLT_RANDLUT                 (SRSHARP1_OFFSET + SHARP_DB_FLT_RANDLUT               ) // 0x79
+#define SRSHARP1_DB_FLT_PXI_THRD                (SRSHARP1_OFFSET + SHARP_DB_FLT_PXI_THRD              ) // 0x7a
+#define SRSHARP1_DB_FLT_SEED_Y                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_Y                ) // 0x7b
+#define SRSHARP1_DB_FLT_SEED_U                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_U                ) // 0x7c
+#define SRSHARP1_DB_FLT_SEED_V                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_V                ) // 0x7d
+#define SRSHARP1_PKGAIN_VSLUMA_LUT_L            (SRSHARP1_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_L          ) // 0x80
+#define SRSHARP1_PKGAIN_VSLUMA_LUT_H            (SRSHARP1_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_H          ) // 0x81
+#define SRSHARP1_PKOSHT_VSLUMA_LUT_L            (SRSHARP1_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_L          ) // 0x82
+#define SRSHARP1_PKOSHT_VSLUMA_LUT_H            (SRSHARP1_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_H          ) // 0x83
+
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  srsharp_regs.h
+//
+//`define DOLBY0_VCBUS_BASE              8'h33
+//`include "dolby0_regs.h"
+// -----------------------------------------------
+// CBUS_BASE:  DOLBYTV_VCBUS_BASE = 0x33
+// -----------------------------------------------
+//
+// Reading file:  dolby_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   DOLBY_TV_REG_START                       (0x3300)
+#define P_DOLBY_TV_REG_START                       (volatile unsigned int *)((0x3300  << 2) + 0xff900000)
+// dolby register address 0~0xDA
+#define   DOLBY_TV_CLKGATE_CTRL                    (0x33f1)
+#define P_DOLBY_TV_CLKGATE_CTRL                    (volatile unsigned int *)((0x33f1  << 2) + 0xff900000)
+//bit[9:8]  R-RW 0~3 0  dma2axi_clkgate_ctrl         : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
+//bit[7:6]  R-RW 0~3 0  bl_dolby_swaps_clkgate_ctrl  : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
+//bit[5:4]  R-RW 0~3 0  el_swaps_clkgate_ctrl        : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
+//bit[3:2]  R-RW 0~3 0  el_buf_clkgate_ctrl          : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
+//bit[1:0]  R-RW 0~3 0  top_level_reg_clkgate_ctrl   : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
+#define   DOLBY_TV_SWAP_CTRL0                      (0x33f2)
+#define P_DOLBY_TV_SWAP_CTRL0                      (volatile unsigned int *)((0x33f2  << 2) + 0xff900000)
+//bit[2]  R-RW 0~1  0   el_41mode      : 1 "bl resolution : el resolution = 4:1", 0 "bl_res : el_res = 1:1"
+//bit[1]  R-RW 0~1  0   el_enable      : 1 "enhancement layer is supported", 0 "el is not supported"
+//bit[0]  R-RW 0~1  0   source_enable  : 1 "base layer is supported", 0 "bl is not supported"
+#define   DOLBY_TV_SWAP_CTRL1                      (0x33f3)
+#define P_DOLBY_TV_SWAP_CTRL1                      (volatile unsigned int *)((0x33f3  << 2) + 0xff900000)
+//bit[28:16]  R-RW  0~8191 0  htotal  : total pixels number in each line
+//bit[21:0]   R-RW  0~8191 0  vtotal  : total line number in each frame (only support progress frame)
+#define   DOLBY_TV_SWAP_CTRL2                      (0x33f4)
+#define P_DOLBY_TV_SWAP_CTRL2                      (volatile unsigned int *)((0x33f4  << 2) + 0xff900000)
+//bit[28:16]  R-RW  0~4096 0 hsize  : active pixels number in each line
+//bit[21:0]   R-RW  0~3840 0 vsize  : active lines number in each frame
+#define   DOLBY_TV_SWAP_CTRL3                      (0x33f5)
+#define P_DOLBY_TV_SWAP_CTRL3                      (volatile unsigned int *)((0x33f5  << 2) + 0xff900000)
+//bit[28:16]  R-RW  0~8191 0  hsync_width  : hsync signal width (high effective)
+//bit[21:0]   R-RW  0~8191 0  vsync_width  : vysnc singal width (high effective)
+#define   DOLBY_TV_SWAP_CTRL4                      (0x33f6)
+#define P_DOLBY_TV_SWAP_CTRL4                      (volatile unsigned int *)((0x33f6  << 2) + 0xff900000)
+//bit[28:16]  R-RW  0~8191 0  hsync_backporch  : pixels number between hsync and h_active_duration
+//bit[21:0]   R-RW  0~8191 0  vsync_backporch  : lines number between vsync and v_active_duration
+#define   DOLBY_TV_SWAP_CTRL5                      (0x33f7)
+#define P_DOLBY_TV_SWAP_CTRL5                      (volatile unsigned int *)((0x33f7  << 2) + 0xff900000)
+//[25:8]      R-RW                           :   reg_tunnel_sel for tunnel bit match swap
+//bit[4]      R-RW  0~1  0   bl_tunnel_mode  :   1 "hdmi input, source is 12bit422 tunnel in 8bit444", 0 "opt mode, 10 bit 444"
+//bit[3:2]    R-RW  0~3  0   bl_uv_mode      :   3 "uv=in_u", 2 "uv[0]=u[0],uv[1]=v[0]", 1 "uv[0]=v[0],uv[1]=u[0]", 0 "uv=in_v"
+//bit[1:0]    R-RW  0~3  0   el_uv_mode      :   3 "uv=in_u", 2 "uv[0]=u[0],uv[1]=v[0]", 1 "uv[0]=v[0],uv[1]=u[0]", 0 "uv=in_v"
+#define   DOLBY_TV_SWAP_CTRL6                      (0x33f8)
+#define P_DOLBY_TV_SWAP_CTRL6                      (volatile unsigned int *)((0x33f8  << 2) + 0xff900000)
+//bit[31]     R-RW  0~1      dm_uv_input     :   uv select
+//bit[23:16]  R-RW  0~1  0   dump_ctrl       :   1 "fixed output bitdepth as 12bit", 0 "output bitdepth based on vdr_bit_depth"
+//bit[15]     R-RW  0~1      datapath_reset_n_enable : manual reset control
+//bit[14]     R-RW  0~1      handshake_reset_n_enable : manual reset control
+//bit[13]     R-RW  0~1      axi_reset_n_enable : manual reset control
+//bit[5:2]    R-RW  0~15     vdr_bit_depth
+//bit[1:0]    R-RW  0~3      reg_hdmi_mode
+#define   DOLBY_TV_SWAP_CTRL7                      (0x33f9)
+#define P_DOLBY_TV_SWAP_CTRL7                      (volatile unsigned int *)((0x33f9  << 2) + 0xff900000)
+//reserved
+#define   DOLBY_TV_AXI2DMA_CTRL0                   (0x33fa)
+#define P_DOLBY_TV_AXI2DMA_CTRL0                   (volatile unsigned int *)((0x33fa  << 2) + 0xff900000)
+//bit[31]        R-RW   0~1  0    reg_req_en         :  enable req after line count
+//bit[30]        R-RW   0~1  0    reg_id_check       :  check the id of data path and req path
+//bit[29]        R-RW   0~1  0    reg_clear_fifo     :  manually reset bit
+//bit[28]        R-RW   0~1  0    reg_vsync_rst      :  soft_rst auto reset enable
+//bit[27]        R-RW   0~1  0    reg_update_addr    :  manually udpate start addr
+//bit[26]        R-RW   0~1  0    reg_addr_auto      :  auto update start addr enable
+//bit[25]        R-RW   0~1  0    reg_keep_receive   :  data path keep receive
+//bit[24:19]     R-RW   0~63 0    reg_req_th         :  fifo_room > req_th, then send the request
+//bit[18:16]     R-RW   0~7  0    reg_arsize         :  axi arsize
+//bit[14:12]     R-RW   0~7  0    reg_arprot         :  axi arprot
+//bit[11:8]      R-RW   0~15 0    reg_aruser         :  axi aruser
+//bit[5:4]       R-RW   0~3  0    reg_arid           :  axi arid
+//bit[3:0]       R-RW   0~2  0    reg_lens           :  default request lens, each burst has "reg_lens+1" data
+#define   DOLBY_TV_AXI2DMA_CTRL1                   (0x33fb)
+#define P_DOLBY_TV_AXI2DMA_CTRL1                   (volatile unsigned int *)((0x33fb  << 2) + 0xff900000)
+//bit[31]        R-RW   0~1     0 axi_addr_mode   :  1 "canvas mode", 0 "normal mode"
+//bit[27:16]     R-RW   0~4095  0 dma_size0       :  total data number in dma0
+//bit[11:0]      R-RW   0~4095  0 dma_size1       :  total data number in dma1
+#define   DOLBY_TV_AXI2DMA_CTRL2                   (0x33fc)
+#define P_DOLBY_TV_AXI2DMA_CTRL2                   (volatile unsigned int *)((0x33fc  << 2) + 0xff900000)
+//bit[31:0]      R-RW   0~4294967295  0 axi_start_addr : axi start address
+#define   DOLBY_TV_AXI2DMA_CTRL3                   (0x33fd)
+#define P_DOLBY_TV_AXI2DMA_CTRL3                   (volatile unsigned int *)((0x33fd  << 2) + 0xff900000)
+//bit[11:0]      R-RW   0~4095        0  hold_line     :  after hold_line the axi slave start requesting
+#define   DOLBY_TV_STATUS0                         (0x33fe)
+#define P_DOLBY_TV_STATUS0                         (volatile unsigned int *)((0x33fe  << 2) + 0xff900000)
+#define   DOLBY_TV_STATUS1                         (0x33ff)
+#define P_DOLBY_TV_STATUS1                         (volatile unsigned int *)((0x33ff  << 2) + 0xff900000)
+#define   DOLBY_TV_ADAPTIVE_SCALE_REGADDR          (0x33e0)
+#define P_DOLBY_TV_ADAPTIVE_SCALE_REGADDR          (volatile unsigned int *)((0x33e0  << 2) + 0xff900000)
+#define   DOLBY_TV_ADAPTIVE_SCALE_REGDATA          (0x33e1)
+#define P_DOLBY_TV_ADAPTIVE_SCALE_REGDATA          (volatile unsigned int *)((0x33e1  << 2) + 0xff900000)
+#define   DOLBY_TV_ADAPTIVE_SCALE_LUTADDR          (0x33e2)
+#define P_DOLBY_TV_ADAPTIVE_SCALE_LUTADDR          (volatile unsigned int *)((0x33e2  << 2) + 0xff900000)
+#define   DOLBY_TV_ADAPTIVE_SCALE_LUTDATA          (0x33e3)
+#define P_DOLBY_TV_ADAPTIVE_SCALE_LUTDATA          (volatile unsigned int *)((0x33e3  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dolby_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOLBY1A_VCBUS_BASE = 0x34
+// -----------------------------------------------
+//
+// Reading file:  dolby1a_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   DOLBY_CORE2A_REG_START                   (0x3400)
+#define P_DOLBY_CORE2A_REG_START                   (volatile unsigned int *)((0x3400  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_CLKGATE_CTRL                (0x3432)
+#define P_DOLBY_CORE2A_CLKGATE_CTRL                (volatile unsigned int *)((0x3432  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_SWAP_CTRL0                  (0x3433)
+#define P_DOLBY_CORE2A_SWAP_CTRL0                  (volatile unsigned int *)((0x3433  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_SWAP_CTRL1                  (0x3434)
+#define P_DOLBY_CORE2A_SWAP_CTRL1                  (volatile unsigned int *)((0x3434  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_SWAP_CTRL2                  (0x3435)
+#define P_DOLBY_CORE2A_SWAP_CTRL2                  (volatile unsigned int *)((0x3435  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_SWAP_CTRL3                  (0x3436)
+#define P_DOLBY_CORE2A_SWAP_CTRL3                  (volatile unsigned int *)((0x3436  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_SWAP_CTRL4                  (0x3437)
+#define P_DOLBY_CORE2A_SWAP_CTRL4                  (volatile unsigned int *)((0x3437  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_SWAP_CTRL5                  (0x3438)
+#define P_DOLBY_CORE2A_SWAP_CTRL5                  (volatile unsigned int *)((0x3438  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_DMA_CTRL                    (0x3439)
+#define P_DOLBY_CORE2A_DMA_CTRL                    (volatile unsigned int *)((0x3439  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_DMA_STATUS                  (0x343a)
+#define P_DOLBY_CORE2A_DMA_STATUS                  (volatile unsigned int *)((0x343a  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_STATUS0                     (0x343b)
+#define P_DOLBY_CORE2A_STATUS0                     (volatile unsigned int *)((0x343b  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_STATUS1                     (0x343c)
+#define P_DOLBY_CORE2A_STATUS1                     (volatile unsigned int *)((0x343c  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_STATUS2                     (0x343d)
+#define P_DOLBY_CORE2A_STATUS2                     (volatile unsigned int *)((0x343d  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_STATUS3                     (0x343e)
+#define P_DOLBY_CORE2A_STATUS3                     (volatile unsigned int *)((0x343e  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_DMA_PORT                    (0x343f)
+#define P_DOLBY_CORE2A_DMA_PORT                    (volatile unsigned int *)((0x343f  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_AXI2DMA_CTRL0               (0x3440)
+#define P_DOLBY_CORE2A_AXI2DMA_CTRL0               (volatile unsigned int *)((0x3440  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_AXI2DMA_CTRL1               (0x3441)
+#define P_DOLBY_CORE2A_AXI2DMA_CTRL1               (volatile unsigned int *)((0x3441  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_AXI2DMA_CTRL2               (0x3442)
+#define P_DOLBY_CORE2A_AXI2DMA_CTRL2               (volatile unsigned int *)((0x3442  << 2) + 0xff900000)
+#define   DOLBY_CORE2A_AXI2DMA_CTRL3               (0x3443)
+#define P_DOLBY_CORE2A_AXI2DMA_CTRL3               (volatile unsigned int *)((0x3443  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dolby1a_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOLBY1B_VCBUS_BASE = 0x35
+// -----------------------------------------------
+//`include "dolby1b_regs.h"
+// -----------------------------------------------
+// CBUS_BASE:  DOLBY2_VCBUS_BASE = 0x36
+// -----------------------------------------------
+//
+// Reading file:  dolby2_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   DOLBY_CORE3_REG_START                    (0x3600)
+#define P_DOLBY_CORE3_REG_START                    (volatile unsigned int *)((0x3600  << 2) + 0xff900000)
+#define   DOLBY_CORE3_CLKGATE_CTRL                 (0x36f0)
+#define P_DOLBY_CORE3_CLKGATE_CTRL                 (volatile unsigned int *)((0x36f0  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL0                   (0x36f1)
+#define P_DOLBY_CORE3_SWAP_CTRL0                   (volatile unsigned int *)((0x36f1  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL1                   (0x36f2)
+#define P_DOLBY_CORE3_SWAP_CTRL1                   (volatile unsigned int *)((0x36f2  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL2                   (0x36f3)
+#define P_DOLBY_CORE3_SWAP_CTRL2                   (volatile unsigned int *)((0x36f3  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL3                   (0x36f4)
+#define P_DOLBY_CORE3_SWAP_CTRL3                   (volatile unsigned int *)((0x36f4  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL4                   (0x36f5)
+#define P_DOLBY_CORE3_SWAP_CTRL4                   (volatile unsigned int *)((0x36f5  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL5                   (0x36f6)
+#define P_DOLBY_CORE3_SWAP_CTRL5                   (volatile unsigned int *)((0x36f6  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL6                   (0x36f7)
+#define P_DOLBY_CORE3_SWAP_CTRL6                   (volatile unsigned int *)((0x36f7  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL7                   (0x36f8)
+#define P_DOLBY_CORE3_SWAP_CTRL7                   (volatile unsigned int *)((0x36f8  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL8                   (0x36f9)
+#define P_DOLBY_CORE3_SWAP_CTRL8                   (volatile unsigned int *)((0x36f9  << 2) + 0xff900000)
+#define   DOLBY_CORE3_SWAP_CTRL9                   (0x36fa)
+#define P_DOLBY_CORE3_SWAP_CTRL9                   (volatile unsigned int *)((0x36fa  << 2) + 0xff900000)
+#define   DOLBY_CORE3_STATUS0                      (0x36fb)
+#define P_DOLBY_CORE3_STATUS0                      (volatile unsigned int *)((0x36fb  << 2) + 0xff900000)
+#define   DOLBY_CORE3_STATUS1                      (0x36fc)
+#define P_DOLBY_CORE3_STATUS1                      (volatile unsigned int *)((0x36fc  << 2) + 0xff900000)
+#define   DOLBY_CORE3_STATUS2                      (0x36fd)
+#define P_DOLBY_CORE3_STATUS2                      (volatile unsigned int *)((0x36fd  << 2) + 0xff900000)
+#define   DOLBY_CORE3_STATUS3                      (0x36fe)
+#define P_DOLBY_CORE3_STATUS3                      (volatile unsigned int *)((0x36fe  << 2) + 0xff900000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dolby2_regs.h
+//
+//`define MADC_VCBUS_BASE              8'h37
+//
+// Reading file:  vpu_madc_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  MADC_VCBUS_BASE = 0x37
+// -----------------------------------------------
+// 0x00-0x1f
+//
+// Reading file:  nr4_nm_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   NR4_MCNR_SAD_GAIN                        (0x3700)
+#define P_NR4_MCNR_SAD_GAIN                        (volatile unsigned int *)((0x3700  << 2) + 0xff900000)
+//Bit 31:25        reserved
+//Bit 24           reg_nr4_bld12vs3_usemaxsad     // unsigned , default = 0  use minsad/maxsad instead of minsad/avgsad to decision if it was texture or flat region, 1: use minsad/maxsad
+//Bit 23:16        reg_nr4_bld12vs3_rate_gain     // unsigned , default = 64  gain to minsad/maxsad or minsad/avgsad before LUT, 64 normalized as "1"
+//Bit 15: 8        reg_nr4_bld1vs2_rate_gain      // unsigned , default = 32  gain to minsad/maxsad or minsad/avgsad before the LUT, 64 normalized as"1"
+//Bit  7: 0        reg_nr4_coefblt_gain           // unsigned , default = 64  gain to final coefblt, normalized 64 as "1"
+#define   NR4_MCNR_LPF_CTRL                        (0x3701)
+#define P_NR4_MCNR_LPF_CTRL                        (volatile unsigned int *)((0x3701  << 2) + 0xff900000)
+//Bit 31            reserved
+//Bit 30:22        reg_nr4_preflt_alpofst         // signed , default = 0  pre filter alpha ofst
+//Bit 21:16        reg_nr4_preflt_alpgain         // unsigned , default = 16  pre filter alpha gain
+//Bit 15:14        reg_nr4_preflt_alpsel          // unsigned , default = 3  pre filter alpha selection for adaptive blending, 0: mv pointed sad, 1: weighted mv pointed sad, 2or3: coefblt
+//Bit 13: 8        reg_nr4_avgsad_gain            // unsigned , default = 8  gain for avg sad before luts
+//Bit  7            reserved
+//Bit  6           reg_nr4_maxsad_mod             // unsigned , default = 1  max sad select mode, 0: mx2_sad, 1: max sad
+//Bit  5           reg_nr4_minsad_mod             // unsigned , default = 1  min sad select mode, 0: sad with min err, 1: min sad
+//Bit  4           reg_nr4_minmaxsad_lpf          // unsigned , default = 1  mode of lpf for minmaxsad, 0: no LPF, 1: [1 2 1]/4
+//Bit  3           reg_nr4_avgsad_lpf             // unsigned , default = 1  mode of lpf for avgsad, 0: no LPF, 1: [1 2 1]/4
+//Bit  2           reg_nr4_minavgsad_ratio_lpf    // unsigned , default = 1  mode of lpf for minsad/avgsad and zmvsad/avgsad, 0: no LPF, 1: [1 2 1]/4
+//Bit  1           reg_nr4_bldvs_lut_lpf          // unsigned , default = 1  mode of lpf for bld12vs3 and bld1vs2 LUT results, 0: no LPF, 1: [1 2 1]/4
+//Bit  0           reg_nr4_final_coef_lpf         // unsigned , default = 1  mode of lpf for final coef_blt_blend123, 0: no LPF, 1: [1 2 1]/4
+#define   NR4_MCNR_BLD_VS3LUT0                     (0x3702)
+#define P_NR4_MCNR_BLD_VS3LUT0                     (volatile unsigned int *)((0x3702  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_bld12vs3_lut0     // unsigned , default = 0
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_bld12vs3_lut1     // unsigned , default = 8
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_bld12vs3_lut2     // unsigned , default = 10
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bld12vs3_lut3     // unsigned , default = 11
+#define   NR4_MCNR_BLD_VS3LUT1                     (0x3703)
+#define P_NR4_MCNR_BLD_VS3LUT1                     (volatile unsigned int *)((0x3703  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_bld12vs3_lut4     // unsigned , default = 12
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_bld12vs3_lut5     // unsigned , default = 14
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_bld12vs3_lut6     // unsigned , default = 16
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bld12vs3_lut7     // unsigned , default = 24
+#define   NR4_MCNR_BLD_VS3LUT2                     (0x3704)
+#define P_NR4_MCNR_BLD_VS3LUT2                     (volatile unsigned int *)((0x3704  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_bld12vs3_lut8     // unsigned , default = 50
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_bld12vs3_lut9     // unsigned , default = 58
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_bld12vs3_lut10    // unsigned , default = 63
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bld12vs3_lut11    // unsigned , default = 63
+#define   NR4_MCNR_BLD_VS2LUT0                     (0x3705)
+#define P_NR4_MCNR_BLD_VS2LUT0                     (volatile unsigned int *)((0x3705  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_bld1vs2_lut0      // unsigned , default = 63
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_bld1vs2_lut1      // unsigned , default = 32
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_bld1vs2_lut2      // unsigned , default = 16
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bld1vs2_lut3      // unsigned , default = 8
+#define   NR4_MCNR_BLD_VS2LUT1                     (0x3706)
+#define P_NR4_MCNR_BLD_VS2LUT1                     (volatile unsigned int *)((0x3706  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:24        reg_nr4_bld1vs2_lut4      // unsigned , default = 4
+//Bit 23:22        reserved
+//Bit 21:16        reg_nr4_bld1vs2_lut5      // unsigned , default = 2
+//Bit 15:14        reserved
+//Bit 13: 8        reg_nr4_bld1vs2_lut6      // unsigned , default = 1
+//Bit  7: 6        reserved
+//Bit  5: 0        reg_nr4_bld1vs2_lut7      // unsigned , default = 0
+#define   NR4_COEFBLT_LUT10                        (0x3707)
+#define P_NR4_COEFBLT_LUT10                        (volatile unsigned int *)((0x3707  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut10     // signed , default = -128
+//Bit 23:16        reg_nr4_coefblt_lut11     // signed , default = -128
+//Bit 15: 8        reg_nr4_coefblt_lut12     // signed , default = -126
+//Bit  7: 0        reg_nr4_coefblt_lut13     // signed , default = -124
+#define   NR4_COEFBLT_LUT11                        (0x3708)
+#define P_NR4_COEFBLT_LUT11                        (volatile unsigned int *)((0x3708  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut14     // signed , default = -120
+//Bit 23:16        reg_nr4_coefblt_lut15     // signed , default = -110
+//Bit 15: 8        reg_nr4_coefblt_lut16     // signed , default = -100
+//Bit  7: 0        reg_nr4_coefblt_lut17     // signed , default = -90
+#define   NR4_COEFBLT_LUT12                        (0x3709)
+#define P_NR4_COEFBLT_LUT12                        (volatile unsigned int *)((0x3709  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut18     // signed , default = -56
+//Bit 23:16        reg_nr4_coefblt_lut19     // signed , default = -32
+//Bit 15: 8        reg_nr4_coefblt_lut110    // signed , default = -64
+//Bit  7: 0        reg_nr4_coefblt_lut111    // signed , default = -128
+#define   NR4_COEFBLT_LUT20                        (0x370a)
+#define P_NR4_COEFBLT_LUT20                        (volatile unsigned int *)((0x370a  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut20     // signed , default = -128
+//Bit 23:16        reg_nr4_coefblt_lut21     // signed , default = -120
+//Bit 15: 8        reg_nr4_coefblt_lut22     // signed , default = -112
+//Bit  7: 0        reg_nr4_coefblt_lut23     // signed , default = -104
+#define   NR4_COEFBLT_LUT21                        (0x370b)
+#define P_NR4_COEFBLT_LUT21                        (volatile unsigned int *)((0x370b  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut24     // signed , default = -96
+//Bit 23:16        reg_nr4_coefblt_lut25     // signed , default = -88
+//Bit 15: 8        reg_nr4_coefblt_lut26     // signed , default = -76
+//Bit  7: 0        reg_nr4_coefblt_lut27     // signed , default = -64
+#define   NR4_COEFBLT_LUT22                        (0x370c)
+#define P_NR4_COEFBLT_LUT22                        (volatile unsigned int *)((0x370c  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut28     // signed , default = -48
+//Bit 23:16        reg_nr4_coefblt_lut29     // signed , default = -32
+//Bit 15: 8        reg_nr4_coefblt_lut210    // signed , default = -64
+//Bit  7: 0        reg_nr4_coefblt_lut211    // signed , default = -108
+#define   NR4_COEFBLT_LUT30                        (0x370d)
+#define P_NR4_COEFBLT_LUT30                        (volatile unsigned int *)((0x370d  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut30     // signed , default = 8
+//Bit 23:16        reg_nr4_coefblt_lut31     // signed , default = 16
+//Bit 15: 8        reg_nr4_coefblt_lut32     // signed , default = 24
+//Bit  7: 0        reg_nr4_coefblt_lut33     // signed , default = 30
+#define   NR4_COEFBLT_LUT31                        (0x370e)
+#define P_NR4_COEFBLT_LUT31                        (volatile unsigned int *)((0x370e  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut34     // signed , default = 36
+//Bit 23:16        reg_nr4_coefblt_lut35     // signed , default = 48
+//Bit 15: 8        reg_nr4_coefblt_lut36     // signed , default = 70
+//Bit  7: 0        reg_nr4_coefblt_lut37     // signed , default = 96
+#define   NR4_COEFBLT_LUT32                        (0x370f)
+#define P_NR4_COEFBLT_LUT32                        (volatile unsigned int *)((0x370f  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_coefblt_lut38     // signed , default = 120
+//Bit 23:16        reg_nr4_coefblt_lut39     // signed , default = 64
+//Bit 15: 8        reg_nr4_coefblt_lut310    // signed , default = 16
+//Bit  7: 0        reg_nr4_coefblt_lut311    // signed , default = -8
+#define   NR4_COEFBLT_CONV                         (0x3710)
+#define P_NR4_COEFBLT_CONV                         (volatile unsigned int *)((0x3710  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:16        reg_nr4_coefblt_convmin   // unsigned , default = 0  minimum of coef. bilateral conversion
+//Bit 15: 8        reg_nr4_coefblt_convmax   // unsigned , default = 255  maximum of coef. bilateral conversion
+//Bit  7: 0        reg_nr4_coefblt_convmid   // unsigned , default = 128  value at midpoint of coef. bilateral conversion
+#define   NR4_DBGWIN_YX0                           (0x3711)
+#define P_NR4_DBGWIN_YX0                           (volatile unsigned int *)((0x3711  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_nr4_dgbwin_yx0        // unsigned , default = 100  ystart for debug window
+//Bit 15:14        reserved
+//Bit 13: 0        reg_nr4_dgbwin_yx1        // unsigned , default = 160  yend   for debug window
+#define   NR4_DBGWIN_YX1                           (0x3712)
+#define P_NR4_DBGWIN_YX1                           (volatile unsigned int *)((0x3712  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_nr4_dgbwin_yx2        // unsigned , default = 200  xstart for debug window
+//Bit 15:14        reserved
+//Bit 13: 0        reg_nr4_dgbwin_yx3        // unsigned , default = 300  xend   for debug window
+#define   NR4_NM_X_CFG                             (0x3713)
+#define P_NR4_NM_X_CFG                             (volatile unsigned int *)((0x3713  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_nr4_nm_xst            // unsigned , default = 8  start for noise meter statistic, dft = 8
+//Bit 15:14        reserved
+//Bit 13: 0        reg_nr4_nm_xed            // unsigned , default = 711  end for noise meter statistic, dft = HSIZE-8-1;
+#define   NR4_NM_Y_CFG                             (0x3714)
+#define P_NR4_NM_Y_CFG                             (volatile unsigned int *)((0x3714  << 2) + 0xff900000)
+//Bit 31:30        reserved
+//Bit 29:16        reg_nr4_nm_yst            // unsigned , default = 8  start for noise meter statistic, dft = 8;
+//Bit 15:14        reserved
+//Bit 13: 0        reg_nr4_nm_yed            // unsigned , default = 231  end for noise meter statistic, dft = VSIZE-8-1;
+#define   NR4_NM_SAD_THD                           (0x3715)
+#define P_NR4_NM_SAD_THD                           (volatile unsigned int *)((0x3715  << 2) + 0xff900000)
+//Bit 31: 8        reserved
+//Bit  7: 0        reg_nr4_nm_sad_thd        // unsigned , default = 255  threshold for (flat region) sad count, dft = 4
+#define   NR4_MCNR_BANDSPLIT_PRAM                  (0x3716)
+#define P_NR4_MCNR_BANDSPLIT_PRAM                  (volatile unsigned int *)((0x3716  << 2) + 0xff900000)
+//Bit 31: 5        reserved
+//Bit  4           reg_nr4_mc_use_bandsplit     // unsigned , default = 1  separate lp and us for mc IIR filter, 0: no BS used; 1: use BS
+//Bit  3           reg_nr4_mc_apply_on_lp       // unsigned , default = 1  use mcnr only on lowpass portion;
+//Bit  2           reg_nr4_mc_apply_on_us       // unsigned , default = 1  use mcnr only on lp complimentary portion;
+//Bit  1: 0        reg_nr4_mc_zmvbs_use_adplpf  // unsigned , default = 1  use adapptive LPF for the zmv pointing data for MCNR, for abs(mvx)<th
+#define   NR4_MCNR_ALP1_SGN_COR                    (0x3717)
+#define P_NR4_MCNR_ALP1_SGN_COR                    (volatile unsigned int *)((0x3717  << 2) + 0xff900000)
+//Bit 31:24        reg_nr4_mc_aph1_sgn_coring0  // unsigned , default = 10  coring to cur-pre before do sgn decision
+//Bit 23:16        reg_nr4_mc_aph1_sgn_coring1  // unsigned , default = 7  coring to cur-pre before do sgn decision
+//Bit 15: 8        reg_nr4_mc_aph1_sgn_core_max0 // unsigned , default = 90  maximum of coring, default = 30/15
+//Bit  7: 0        reg_nr4_mc_aph1_sgn_core_max1 // unsigned , default = 15  maximum of coring, default = 30/15
+#define   NR4_MCNR_ALP1_SGN_PRAM                   (0x3718)
+#define P_NR4_MCNR_ALP1_SGN_PRAM                   (volatile unsigned int *)((0x3718  << 2) + 0xff900000)
+//Bit 31:11        reserved
+//Bit 10           reg_nr4_mc_alp1_sgn_half       // unsigned , default = 1  half block sgn sum mode enable, 0: only use 3x5 whole block sum of sgns; 1: use max(sgn_3x5, sqrt(sgn_left+sgn_righ))
+//Bit  9           reg_nr4_mc_alp1_sgn_frczmv   // unsigned , default = 1  force zmv to calculate the sign_sum;
+//Bit  8           reg_nr4_mc_alp1_sgnmvx_mode  // unsigned , default = 1  blend mode of sgnlut and mvxlut blend mode: 0: sgnlut+ mvxlut; 1: max(sgnlut, mvxlut), default =1
+//Bit  7: 4        reg_nr4_mc_aph1_sgn_crate0   // unsigned , default = 4  rate to var, norm to 16 as 1, default = 2
+//Bit  3: 0        reg_nr4_mc_aph1_sgn_crate1   // unsigned , default = 2  rate to var, norm to 16 as 1, default = 2
+#define   NR4_MCNR_ALP1_MVX_LUT1                   (0x3719)
+#define P_NR4_MCNR_ALP1_MVX_LUT1                   (volatile unsigned int *)((0x3719  << 2) + 0xff900000)
+//Bit 31:28        reg_nr4_mc_alp1_mvx_luty3  // unsigned , default = 14  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 27:24        reg_nr4_mc_alp1_mvx_lutc3  // unsigned , default = 14  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 23:20        reg_nr4_mc_alp1_mvx_luty2  // unsigned , default = 12  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 19:16        reg_nr4_mc_alp1_mvx_lutc2  // unsigned , default = 12  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 15:12        reg_nr4_mc_alp1_mvx_luty1  // unsigned , default = 5  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 11: 8        reg_nr4_mc_alp1_mvx_lutc1  // unsigned , default = 5  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty0  // unsigned , default = 3  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc0  // unsigned , default = 3  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+#define   NR4_MCNR_ALP1_MVX_LUT2                   (0x371a)
+#define P_NR4_MCNR_ALP1_MVX_LUT2                   (volatile unsigned int *)((0x371a  << 2) + 0xff900000)
+//Bit 31:28        reg_nr4_mc_alp1_mvx_luty7  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 27:24        reg_nr4_mc_alp1_mvx_lutc7  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 23:20        reg_nr4_mc_alp1_mvx_luty6  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 19:16        reg_nr4_mc_alp1_mvx_lutc6  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 15:12        reg_nr4_mc_alp1_mvx_luty5  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit 11: 8        reg_nr4_mc_alp1_mvx_lutc5  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty4  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc4  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+#define   NR4_MCNR_ALP1_MVX_LUT3                   (0x371b)
+#define P_NR4_MCNR_ALP1_MVX_LUT3                   (volatile unsigned int *)((0x371b  << 2) + 0xff900000)
+//Bit 31: 8        reserved
+//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty8  // unsigned , default = 6  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
+//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc8  // unsigned , default = 6  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
+#define   NR4_MCNR_ALP1_LP_PRAM                    (0x371c)
+#define P_NR4_MCNR_ALP1_LP_PRAM                    (volatile unsigned int *)((0x371c  << 2) + 0xff900000)
+//Bit 31:18        reserved
+//Bit 17:16        reg_nr4_mc_alp1_lp_sel    // unsigned , default = 1  mode for alp1_lp for lp portion IIR, 0: apha1, 1:dc_dif vs ac analysis; 2: gain/ofst of alp1; 3: max of #1/#2 results
+//Bit 15: 8        reg_nr4_mc_alp1_lp_gain   // unsigned , default = 64  gain to alp1 to get the alp1_lp = alp1*gain/32 + ofset, default =64;
+//Bit  7: 0        reg_nr4_mc_alp1_lp_ofst   // signed , default = 0  offset to alp1 to get the alp1_lp = alp1*gain/32 + ofset, default =10;
+#define   NR4_MCNR_ALP1_SGN_LUT1                   (0x371d)
+#define P_NR4_MCNR_ALP1_SGN_LUT1                   (volatile unsigned int *)((0x371d  << 2) + 0xff900000)
+//Bit 31:28        reg_nr4_mc_alp1_sgn_lut0  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 27:24        reg_nr4_mc_alp1_sgn_lut1  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 23:20        reg_nr4_mc_alp1_sgn_lut2  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 19:16        reg_nr4_mc_alp1_sgn_lut3  // unsigned , default = 4  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 15:12        reg_nr4_mc_alp1_sgn_lut4  // unsigned , default = 5  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 11: 8        reg_nr4_mc_alp1_sgn_lut5  // unsigned , default = 6  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit  7: 4        reg_nr4_mc_alp1_sgn_lut6  // unsigned , default = 7  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit  3: 0        reg_nr4_mc_alp1_sgn_lut7  // unsigned , default = 8  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+#define   NR4_MCNR_ALP1_SGN_LUT2                   (0x371e)
+#define P_NR4_MCNR_ALP1_SGN_LUT2                   (volatile unsigned int *)((0x371e  << 2) + 0xff900000)
+//Bit 31:28        reg_nr4_mc_alp1_sgn_lut8   // unsigned , default = 9  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 27:24        reg_nr4_mc_alp1_sgn_lut9   // unsigned , default = 10  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 23:20        reg_nr4_mc_alp1_sgn_lut10  // unsigned , default = 11  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 19:16        reg_nr4_mc_alp1_sgn_lut11  // unsigned , default = 12  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 15:12        reg_nr4_mc_alp1_sgn_lut12  // unsigned , default = 13  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit 11: 8        reg_nr4_mc_alp1_sgn_lut13  // unsigned , default = 14  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit  7: 4        reg_nr4_mc_alp1_sgn_lut14  // unsigned , default = 15  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+//Bit  3: 0        reg_nr4_mc_alp1_sgn_lut15  // unsigned , default = 15  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
+#define   NR4_RO_NM_SAD_SUM                        (0x371f)
+#define P_NR4_RO_NM_SAD_SUM                        (volatile unsigned int *)((0x371f  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_nm_sad_sum         // unsigned , default = 0  sum of sad, for scene change detectcion, in noise meter
+#define   NR4_RO_NM_SAD_CNT                        (0x3720)
+#define P_NR4_RO_NM_SAD_CNT                        (volatile unsigned int *)((0x3720  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_nm_sad_cnt         // unsigned , default = 0  cnt of sad, for scene change detectcion, in noise meter
+#define   NR4_RO_NM_VAR_SUM                        (0x3721)
+#define P_NR4_RO_NM_VAR_SUM                        (volatile unsigned int *)((0x3721  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_nm_var_sum         // unsigned , default = 0  sum of var, for noise level detection, in noise meter
+#define   NR4_RO_NM_VAR_SCNT                       (0x3722)
+#define P_NR4_RO_NM_VAR_SCNT                       (volatile unsigned int *)((0x3722  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_nm_var_cnt         // unsigned , default = 0  cnt of var, for noise level detection, in noise meter
+#define   NR4_RO_NM_VAR_MIN_MAX                    (0x3723)
+#define P_NR4_RO_NM_VAR_MIN_MAX                    (volatile unsigned int *)((0x3723  << 2) + 0xff900000)
+//Bit 31:22        reserved
+//Bit 21:12        ro_nr4_nm_min_var         // unsigned , default = 1023  min of var, for noise level detection, in noise meter
+//Bit 11:10        reserved
+//Bit  9: 0        ro_nr4_nm_max_var         // unsigned , default = 0  max of var, for noise level detection, in noise meter
+#define   NR4_RO_NR4_DBGPIX_NUM                    (0x3724)
+#define P_NR4_RO_NR4_DBGPIX_NUM                    (volatile unsigned int *)((0x3724  << 2) + 0xff900000)
+//Bit 31:28        reserved
+//Bit 27: 0        ro_nr4_dbgpix_num         // unsigned , default = 0  number of pixels statistic invoved (removed?)
+#define   NR4_RO_NR4_BLDVS2_SUM                    (0x3725)
+#define P_NR4_RO_NR4_BLDVS2_SUM                    (volatile unsigned int *)((0x3725  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_bld1vs2_sum        // unsigned , default = 0  sum of blend_1vs2 with the debug window
+#define   NR4_BLDVS3_SUM                           (0x3726)
+#define P_NR4_BLDVS3_SUM                           (volatile unsigned int *)((0x3726  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_bld12vs3_sum       // unsigned , default = 0  sum of blend_12vs3 with the debug window
+#define   NR4_COEF12_SUM                           (0x3727)
+#define P_NR4_COEF12_SUM                           (volatile unsigned int *)((0x3727  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_coef12_sum         // signed , default = 0  sum of coef_blt_blend12 with the debug window, under 8 bits precision
+#define   NR4_COEF123_SUM                          (0x3728)
+#define P_NR4_COEF123_SUM                          (volatile unsigned int *)((0x3728  << 2) + 0xff900000)
+//Bit 31: 0        ro_nr4_coef123_sum        // signed , default = 0  sum of coef_final with the debug window, under 8 bits precision
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr4_nm_regs.h
+//
+// 0x28-0x38
+//
+// Reading file:  nr_deband_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define   NR_DB_FLT_CTRL                           (0x3738)
+#define P_NR_DB_FLT_CTRL                           (volatile unsigned int *)((0x3738  << 2) + 0xff900000)
+//Bit 31:27        reserved
+//Bit 26           reg_nrdeband_reset1       // unsigned , default = 0  0 : no reset seed  1: reload chroma seed
+//Bit 25           reg_nrdeband_reset0       // unsigned , default = 0  0 : no reset seed  1: reload luma seed
+//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  0 : yuv 1: RGB
+//Bit 23           reg_nrdeband_en11         // unsigned , default = 1  debanding registers of side lines, [0] for luma,   same for below
+//Bit 22           reg_nrdeband_en10         // unsigned , default = 1  debanding registers of side lines, [1] for chroma, same for below
+//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
+//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
+//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
+//Bit 16            reserved
+//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
+//Bit 12            reserved
+//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
+//Bit  8            reserved
+//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   debanding random hp portion xor, [0] for luma
+//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   debanding random hp portion xor, [1] for chroma
+//Bit  5           reg_nrdeband_en1          // unsigned , default = 1   debanding registers,  for luma
+//Bit  4           reg_nrdeband_en0          // unsigned , default = 1   debanding registers,  for chroma
+//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
+//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
+#define   NR_DB_FLT_YC_THRD                        (0x3739)
+#define P_NR_DB_FLT_YC_THRD                        (volatile unsigned int *)((0x3739  << 2) + 0xff900000)
+//Bit 31:28        reg_nrdeband_luma_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
+//Bit 27:24        reg_nrdeband_luma_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
+//Bit 23:20        reg_nrdeband_luma_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
+//Bit 19:16        reg_nrdeband_luma_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
+//Bit 15:12        reg_nrdeband_chrm_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
+//Bit 11: 8        reg_nrdeband_chrm_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
+//Bit  7: 4        reg_nrdeband_chrm_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
+//Bit  3: 0        reg_nrdeband_chrm_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif
+#define   NR_DB_FLT_RANDLUT                        (0x373a)
+#define P_NR_DB_FLT_RANDLUT                        (volatile unsigned int *)((0x373a  << 2) + 0xff900000)
+//Bit 31:24        reserved
+//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   lut0
+//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   lut0
+//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   lut0
+//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   lut0
+//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   lut0
+//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   lut0
+//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   lut0
+//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   lut0
+#define   NR_DB_FLT_PXI_THRD                       (0x373b)
+#define P_NR_DB_FLT_PXI_THRD                       (volatile unsigned int *)((0x373b  << 2) + 0xff900000)
+//Bit 31:26        reserved
+//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   to luma/|u/v| for using the denoise
+//Bit 15:10        reserved
+//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   to luma/|u/v| for using the denoise
+#define   NR_DB_FLT_SEED_Y                         (0x373c)
+#define P_NR_DB_FLT_SEED_Y                         (volatile unsigned int *)((0x373c  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  noise adding seed for Y. seed[0]= 0x60a52f20; as default
+#define   NR_DB_FLT_SEED_U                         (0x373d)
+#define P_NR_DB_FLT_SEED_U                         (volatile unsigned int *)((0x373d  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  noise adding seed for U. seed[0]= 0x60a52f27; as default
+#define   NR_DB_FLT_SEED_V                         (0x373e)
+#define P_NR_DB_FLT_SEED_V                         (volatile unsigned int *)((0x373e  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
+#define   NR_DB_FLT_SEED3                          (0x373f)
+#define P_NR_DB_FLT_SEED3                          (volatile unsigned int *)((0x373f  << 2) + 0xff900000)
+//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr_deband_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpu_madc_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  NR4NM_VCBUS_BASE = 0x68
+// -----------------------------------------------
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./vcbus_regs.h
+//
+//
+// Reading file:  ./ge2d_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+////// GE2D Registers    0x8a0 - 0x8ff
+//address is 0xd016_0000 - 0xd0160000 - 0xd01603ff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  GE2D_GCBUS_BASE = 0x00
+// -----------------------------------------------
+//Bit 31, destination bytemask only if destination bitmask is enable
+//Bit 30, destination bitmask enable
+//Bit 29, source2 key  enable
+//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
+//Bit 27, source1 key  enable
+//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
+//Bit 25:24, dst1 8bit mode component selection,
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
+//Bit 22:17,  reserved
+//Bit 16:15, src2 8bit mode component selection,
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
+//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
+//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
+//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
+//Bit 9:7    reserved
+//Bit 6:5,   src1  8bit mode component selection,
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
+//Bit 3      src1 lookup table enable
+//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
+//Bit 0      src1 separate buffer enable
+#define   GE2D_GEN_CTRL0                           (0x00a0)
+#define P_GE2D_GEN_CTRL0                           (volatile unsigned int *)((0x00a0  << 2) + 0xff940000)
+//Bit 31, soft rst
+//Bit 30, dst write response counter reset
+//Bit 29, disable adding dst write response count to busy bit
+//Bit 28:26, reserved
+//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
+//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
+//Bit 23:22 src2 burst size control
+//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
+//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords
+//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
+//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
+//Bit 11, dst2 request urgent enable
+//Bit 10, src1 request urgent enable
+//Bit 9,  src2 request urgent enable
+//Bit 8,  dst1 request urgent enable
+//Bit 7:0 src1 global alpha
+#define   GE2D_GEN_CTRL1                           (0x00a1)
+#define P_GE2D_GEN_CTRL1                           (volatile unsigned int *)((0x00a1  << 2) + 0xff940000)
+//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0;
+//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
+//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
+//                 otherwise, color_out = (color < 128) ? color: color + 1;
+//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
+//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
+//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs
+//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs
+//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs
+//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs
+//Bit 23     if true, dst little endian, otherwise big endian
+//Bit 22:19 dst1 color_map
+//        dst1_format=0                  : output 8-bit;
+//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
+//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
+//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
+//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
+//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
+//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
+//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
+//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
+//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
+//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
+//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
+//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
+//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
+//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
+//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
+//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
+//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
+//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
+//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
+//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
+//Bit 15    if true, src2 little endian, otherwise big endian
+//Bit 14:11  src2 color_map
+//        src2_format=0                 : output 8-bit;
+//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
+//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
+//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
+//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
+//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
+//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
+//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
+//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
+//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
+//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
+//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
+//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
+//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
+//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
+//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
+//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
+//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
+//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
+//Bit 7     if true, src1 little endian, otherwise big endian
+//Bit 6:3   src1 color_map
+//        src1_format=0                 : output 8-bit;
+//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
+//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
+//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
+//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
+//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
+//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
+//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
+//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
+//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
+//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
+//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
+//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
+//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
+//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
+//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
+//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
+//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
+//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
+//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
+//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
+//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit
+#define   GE2D_GEN_CTRL2                           (0x00a2)
+#define P_GE2D_GEN_CTRL2                           (volatile unsigned int *)((0x00a2  << 2) + 0xff940000)
+//Bit 9     if true, all src2 data use default color
+//Bit 8     if true, all src1 data use default color
+//Bit 7     if true, dst x/y swap
+//Bit 6     if true, dst x direction reversely read
+//Bit 5     if true, dst y direction reversely read
+//Bit 4     if true, src2 x direction reversely read
+//Bit 3     if true, src2 y direction reversely read
+//Bit 2     if true, src1 x direction reversely read
+//Bit 1     if true, src1 y direction reversely read
+//Bit 0     cmd write
+#define   GE2D_CMD_CTRL                            (0x00a3)
+#define P_GE2D_CMD_CTRL                            (volatile unsigned int *)((0x00a3  << 2) + 0xff940000)
+//Read only
+//Bit 28:17 dst write response counter, for debug only
+//Bit 16:7  ge2d_dp status, for debug only
+//Bit 6     read src1 cmd ready
+//Bit 5     read src2 cmd ready
+//Bit 4     pre dpcmd ready
+//Bit 3     ge2d dpcmd ready
+//Bit 2     ge2d buffer command valid
+//Bit 1     ge2d current command valid
+//Bit 0     ge2d busy
+#define   GE2D_STATUS0                             (0x00a4)
+#define P_GE2D_STATUS0                             (volatile unsigned int *)((0x00a4  << 2) + 0xff940000)
+//
+//Read only
+// Bit 29:16 ge2d_dst1_status, for debug only
+// Bit    15 ge2d_rd_src2 core.fifo_empty
+// Bit    14 ge2d_rd_src2 core.fifo_overflow
+// Bit 13:12 ge2d_rd_src2 core.req_st
+// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
+// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
+// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
+// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
+// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
+// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
+// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
+// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
+// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
+#define   GE2D_STATUS1                             (0x00a5)
+#define P_GE2D_STATUS1                             (volatile unsigned int *)((0x00a5  << 2) + 0xff940000)
+//SRC1 default clolor
+//{Y,Cb,Cr,A}/{R,G,B,A}
+#define   GE2D_SRC1_DEF_COLOR                      (0x00a6)
+#define P_GE2D_SRC1_DEF_COLOR                      (volatile unsigned int *)((0x00a6  << 2) + 0xff940000)
+//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
+//Bit 28:16, SRC1 clip x start
+//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
+//Bit 12:0, SRC1 clip x end
+#define   GE2D_SRC1_CLIPX_START_END                (0x00a7)
+#define P_GE2D_SRC1_CLIPX_START_END                (volatile unsigned int *)((0x00a7  << 2) + 0xff940000)
+//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
+//Bit 28:16, SRC1 clip y start
+//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
+//Bit 12:0, SRC1 clip y end
+#define   GE2D_SRC1_CLIPY_START_END                (0x00a8)
+#define P_GE2D_SRC1_CLIPY_START_END                (volatile unsigned int *)((0x00a8  << 2) + 0xff940000)
+//Bit 31:24, SRC1 canvas address0
+//Bit 23:16, SRC1 canvas address1
+//Bit 15:8, SRC1 canvas address2
+#define   GE2D_SRC1_CANVAS                         (0x00a9)
+#define P_GE2D_SRC1_CANVAS                         (volatile unsigned int *)((0x00a9  << 2) + 0xff940000)
+//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
+//             or x even/odd start chroma extra data when y/c ratio = 1
+//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
+//Bit 29:16, SRC1 x start, signed data
+//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
+//             or x even/odd end chroma extra data when y/c ratio = 1
+//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
+//Bit 13:0, SRC1 x end, signed data
+#define   GE2D_SRC1_X_START_END                    (0x00aa)
+#define P_GE2D_SRC1_X_START_END                    (volatile unsigned int *)((0x00aa  << 2) + 0xff940000)
+//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
+//             or y even/odd start chroma extra data when y/c ratio = 1
+//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
+//Bit 28:16, SRC1 y start
+//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
+//             or y even/odd end chroma extra data when y/c ratio = 1
+//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
+//Bit 12:0, SRC1 y end
+#define   GE2D_SRC1_Y_START_END                    (0x00ab)
+#define P_GE2D_SRC1_Y_START_END                    (volatile unsigned int *)((0x00ab  << 2) + 0xff940000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define   GE2D_SRC1_LUT_ADDR                       (0x00ac)
+#define P_GE2D_SRC1_LUT_ADDR                       (volatile unsigned int *)((0x00ac  << 2) + 0xff940000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define   GE2D_SRC1_LUT_DAT                        (0x00ad)
+#define P_GE2D_SRC1_LUT_DAT                        (volatile unsigned int *)((0x00ad  << 2) + 0xff940000)
+//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
+//Bit 18, horizontal formatter en
+//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
+//Bit 16, vertical formatter en
+//Bit 15:8 X direction chroma phase,
+//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
+//                or start/end even/odd chroma phase  when y/c ratio = 1
+//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
+//Bit 7:0  Y direction chroma phase,
+//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
+//          or start/end even/odd chroma phase  when y/c ratio = 1
+//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2
+#define   GE2D_SRC1_FMT_CTRL                       (0x00ae)
+#define P_GE2D_SRC1_FMT_CTRL                       (volatile unsigned int *)((0x00ae  << 2) + 0xff940000)
+//SRC2 default clolor
+//{Y,Cb,Cr,A}/{R,G,B,A}
+#define   GE2D_SRC2_DEF_COLOR                      (0x00af)
+#define P_GE2D_SRC2_DEF_COLOR                      (volatile unsigned int *)((0x00af  << 2) + 0xff940000)
+//Bit 28:16, SRC2 clip x start
+//Bit 12:0, SRC2 clip x end
+#define   GE2D_SRC2_CLIPX_START_END                (0x00b0)
+#define P_GE2D_SRC2_CLIPX_START_END                (volatile unsigned int *)((0x00b0  << 2) + 0xff940000)
+//Bit 28:16, SRC2 clip y start
+//Bit 12:0, SRC2 clip y end
+#define   GE2D_SRC2_CLIPY_START_END                (0x00b1)
+#define P_GE2D_SRC2_CLIPY_START_END                (volatile unsigned int *)((0x00b1  << 2) + 0xff940000)
+//Bit 28:16, SRC2 x start
+//Bit 12:0, SRC2 x end
+#define   GE2D_SRC2_X_START_END                    (0x00b2)
+#define P_GE2D_SRC2_X_START_END                    (volatile unsigned int *)((0x00b2  << 2) + 0xff940000)
+//Bit 28:16, SRC2 y start
+//Bit 12:0, SRC2 y end
+#define   GE2D_SRC2_Y_START_END                    (0x00b3)
+#define P_GE2D_SRC2_Y_START_END                    (volatile unsigned int *)((0x00b3  << 2) + 0xff940000)
+//Bit 28:16, DST clip x start
+//Bit 12:0, DST clip x end
+#define   GE2D_DST_CLIPX_START_END                 (0x00b4)
+#define P_GE2D_DST_CLIPX_START_END                 (volatile unsigned int *)((0x00b4  << 2) + 0xff940000)
+//
+//Bit 28:16, DST clip y start
+//Bit 12:0, DST clip y end
+#define   GE2D_DST_CLIPY_START_END                 (0x00b5)
+#define P_GE2D_DST_CLIPY_START_END                 (volatile unsigned int *)((0x00b5  << 2) + 0xff940000)
+//Bit 28:16, DST x start
+//Bit 12:0, DST x end
+#define   GE2D_DST_X_START_END                     (0x00b6)
+#define P_GE2D_DST_X_START_END                     (volatile unsigned int *)((0x00b6  << 2) + 0xff940000)
+//
+//Bit 28:16, DST x start
+//Bit 12:0, DST x end
+#define   GE2D_DST_Y_START_END                     (0x00b7)
+#define P_GE2D_DST_Y_START_END                     (volatile unsigned int *)((0x00b7  << 2) + 0xff940000)
+//Bit 23:16 DST2 canvas address
+//Bit 15:8 SRC2 canvas address
+//Bit 7:0 DST1 canvas address
+#define   GE2D_SRC2_DST_CANVAS                     (0x00b8)
+#define P_GE2D_SRC2_DST_CANVAS                     (volatile unsigned int *)((0x00b8  << 2) + 0xff940000)
+//vertical scaler phase step
+//Bit 28:0,  5.24 format
+#define   GE2D_VSC_START_PHASE_STEP                (0x00b9)
+#define P_GE2D_VSC_START_PHASE_STEP                (volatile unsigned int *)((0x00b9  << 2) + 0xff940000)
+//phase slope
+//Bit 24:0, bit 24 signed bit
+#define   GE2D_VSC_PHASE_SLOPE                     (0x00ba)
+#define P_GE2D_VSC_PHASE_SLOPE                     (volatile unsigned int *)((0x00ba  << 2) + 0xff940000)
+//Bit 30:29, vertical repeat line0 number
+//Bit 23:0, vertical scaler initial phase
+#define   GE2D_VSC_INI_CTRL                        (0x00bb)
+#define P_GE2D_VSC_INI_CTRL                        (volatile unsigned int *)((0x00bb  << 2) + 0xff940000)
+//horizontal scaler phase step
+//Bit 28:0,  5.24 format
+#define   GE2D_HSC_START_PHASE_STEP                (0x00bc)
+#define P_GE2D_HSC_START_PHASE_STEP                (volatile unsigned int *)((0x00bc  << 2) + 0xff940000)
+//phase slope
+//Bit 24:0, bit 24 signed bit
+#define   GE2D_HSC_PHASE_SLOPE                     (0x00bd)
+#define P_GE2D_HSC_PHASE_SLOPE                     (volatile unsigned int *)((0x00bd  << 2) + 0xff940000)
+//Bit 30:29, horizontal repeat line0 number
+//Bit 23:0, horizontal scaler initial phase
+#define   GE2D_HSC_INI_CTRL                        (0x00be)
+#define P_GE2D_HSC_INI_CTRL                        (volatile unsigned int *)((0x00be  << 2) + 0xff940000)
+//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
+//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode
+#define   GE2D_HSC_ADV_CTRL                        (0x00bf)
+#define P_GE2D_HSC_ADV_CTRL                        (volatile unsigned int *)((0x00bf  << 2) + 0xff940000)
+//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
+//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4
+//Bit 28, horizontal scaler dividing mode enable
+//Bit 27:15, horizontal dividing length, if bit 28 is enable
+//Bit 14, pre horizontal scaler enable
+//Bit 13, pre vertical scale enable
+//Bit 12, vertical scale enable
+//Bit 11, horizontal scaler enable
+//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line,
+//        otherwise using treat horizontal repeat line number as minus line number.
+//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line,
+//        otherwise using treat vertical repeat line number as minus line number.
+//Bit 7, if true, always use phase0 in vertical scaler
+//Bit 6:4, vertical scaler bank length
+//Bit 3, if true, always use phase0 in horizontal scaler
+//Bit 2:0, horizontal scaler bank length
+#define   GE2D_SC_MISC_CTRL                        (0x00c0)
+#define P_GE2D_SC_MISC_CTRL                        (volatile unsigned int *)((0x00c0  << 2) + 0xff940000)
+//Read only
+//vertical scaler next round integer pixel pointer, signed data
+//Bit 13:0
+#define   GE2D_VSC_NRND_POINT                      (0x00c1)
+#define P_GE2D_VSC_NRND_POINT                      (volatile unsigned int *)((0x00c1  << 2) + 0xff940000)
+//Read only
+//vertical scaler next round phase
+//bit 23:0
+#define   GE2D_VSC_NRND_PHASE                      (0x00c2)
+#define P_GE2D_VSC_NRND_PHASE                      (volatile unsigned int *)((0x00c2  << 2) + 0xff940000)
+//Read only
+//horizontal scaler next round integer pixel pointer, signed data
+//Bit 13:0
+#define   GE2D_HSC_NRND_POINT                      (0x00c3)
+#define P_GE2D_HSC_NRND_POINT                      (volatile unsigned int *)((0x00c3  << 2) + 0xff940000)
+//Read only
+//horizontal scaler next round phase
+//bit 23:0
+#define   GE2D_HSC_NRND_PHASE                      (0x00c4)
+#define P_GE2D_HSC_NRND_PHASE                      (volatile unsigned int *)((0x00c4  << 2) + 0xff940000)
+//
+//Bit 28:20, pre_offset0
+//Bit 18:10, pre_offset1
+//Bit 8:0,   pre_offset2
+#define   GE2D_MATRIX_PRE_OFFSET                   (0x00c5)
+#define P_GE2D_MATRIX_PRE_OFFSET                   (volatile unsigned int *)((0x00c5  << 2) + 0xff940000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define   GE2D_MATRIX_COEF00_01                    (0x00c6)
+#define P_GE2D_MATRIX_COEF00_01                    (volatile unsigned int *)((0x00c6  << 2) + 0xff940000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define   GE2D_MATRIX_COEF02_10                    (0x00c7)
+#define P_GE2D_MATRIX_COEF02_10                    (volatile unsigned int *)((0x00c7  << 2) + 0xff940000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define   GE2D_MATRIX_COEF11_12                    (0x00c8)
+#define P_GE2D_MATRIX_COEF11_12                    (volatile unsigned int *)((0x00c8  << 2) + 0xff940000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define   GE2D_MATRIX_COEF20_21                    (0x00c9)
+#define P_GE2D_MATRIX_COEF20_21                    (volatile unsigned int *)((0x00c9  << 2) + 0xff940000)
+//Bit 28:16 coef22
+//Bit 7    input y/cb/cr saturation enable
+//Bit 0    conversion matrix enable
+#define   GE2D_MATRIX_COEF22_CTRL                  (0x00ca)
+#define P_GE2D_MATRIX_COEF22_CTRL                  (volatile unsigned int *)((0x00ca  << 2) + 0xff940000)
+//Bit 28:20, offset0
+//Bit 18:10, offset1
+//Bit 8:0,   offset2
+#define   GE2D_MATRIX_OFFSET                       (0x00cb)
+#define P_GE2D_MATRIX_OFFSET                       (volatile unsigned int *)((0x00cb  << 2) + 0xff940000)
+//Bit 26:25, SRC1 color multiplier alpha selection
+//           if 00, Cs = Csr
+//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
+//           if 10, Cs = Csr * Ag (if source is premultipied)
+//Bit 24    SRC2 color multiplier alpha selection
+//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.
+//Bit 22:12 ALU color operation
+//          bit10:8 Blending Mode Parameter
+//            3'b000: ADD               Cs*Fs + Cd*Fd
+//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
+//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
+//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
+//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
+//            3'b101: LOGIC OP          Cs op Cd
+//          bit7:4 Source Color Blending Factor CFs
+//            4'b0000: ZERO                        0
+//            4'b0001: ONE                         1
+//            4'b0010: SRC_COLOR                   Cs(RGBs)
+//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
+//            4'b0100: DST_COLOR                   Cd(RGBd)
+//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
+//            4'b0110: SRC_ALPHA                   As
+//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
+//            4'b1000: DST_ALPHA                   Ad
+//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
+//            4'b1010: CONST_COLOR                 Cc(RGBc)
+//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
+//            4'b1100: CONST_ALPHA                 Ac
+//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
+//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
+//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
+//            4'b0000: ZERO                        0
+//            4'b0001: ONE                         1
+//            4'b0010: SRC_COLOR                   Cs(RGBs)
+//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
+//            4'b0100: DST_COLOR                   Cd(RGBd)
+//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
+//            4'b0110: SRC_ALPHA                   As
+//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
+//            4'b1000: DST_ALPHA                   Ad
+//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
+//            4'b1010: CONST_COLOR                 Cc(RGBc)
+//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
+//            4'b1100: CONST_ALPHA                 Ac
+//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
+//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
+//          bit3:0 logic operations, when bit10:8 == LOGIC OP
+//            4'b0000: CLEAR                       0
+//            4'b0001: COPY                        s
+//            4'b0010: NOOP                        d
+//            4'b0011: SET                         1
+//            4'b0100: COPY_INVERT                 ~s
+//            4'b0101: INVERT                      ~d
+//            4'b0110: AND_REVERSE                 s & ~d
+//            4'b0111: OR_REVERSE                  s | ~d
+//            4'b1000: AND                         s & d
+//            4'b1001: OR                          s | d
+//            4'b1010: NAND                        ~(s & d)
+//            4'b1011: NOR                         ~(s | d)
+//            4'b1100: XOR                         s ^ d
+//            4'b1101: EQUIV                       ~(s ^ d)
+//            4'b1110: AND_INVERTED                ~s & d
+//            4'b1111: OR_INVERTED                 ~s | d
+//Bit 10:0  ALU alpha operation
+//            bit10:8 Blending Equation Math Operation
+//              3'b000: ADD               As*Fs + Ad*Fd
+//              3'b001: SUBTRACT          As*Fs - Ad*Fd
+//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
+//              3'b011: MIN               min(As*Fs, Ad*Fd)
+//              3'b100: MAX               max(As*Fs, Ad*Fd)
+//              3'b101: LOGIC OP          As op Ad
+//            bit7:4 Source alpha Blending Factor AFs
+//              4'b0000                       0
+//              4'b0001                       1
+//              4'b0010                       As
+//              4'b0011                       1 - As
+//              4'b0100                       Ad
+//              4'b0101                       1 - Ad
+//              4'b0110                       Ac
+//              4'b0111                       1 - Ac
+//               ....                         reserved
+//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
+//              4'b0000                       0
+//              4'b0001                       1
+//              4'b0010                       As
+//              4'b0011                       1 - As
+//              4'b0100                       Ad
+//              4'b0101                       1 - Ad
+//              4'b0110                       Ac
+//              4'b0111                       1 - Ac
+//               ....                         reserved
+//            bit3:0 logic operations, when bit10:8 == LOGIC OP
+//              4'b0000: CLEAR                       0
+//              4'b0001: COPY                        s
+//              4'b0010: NOOP                        d
+//              4'b0011: SET                         1
+//              4'b0100: COPY_INVERT                 ~s
+//              4'b0101: INVERT                      ~d
+//              4'b0110: AND_REVERSE                 s & ~d
+//              4'b0111: OR_REVERSE                  s | ~d
+//              4'b1000: AND                         s & d
+//              4'b1001: OR                          s | d
+//              4'b1010: NAND                        ~(s & d)
+//              4'b1011: NOR                         ~(s | d)
+//              4'b1100: XOR                         s ^ d
+//              4'b1101: EQUIV                       ~(s ^ d)
+//              4'b1110: AND_INVERTED                ~s & d
+//              4'b1111: OR_INVERTED                 ~s | d
+#define   GE2D_ALU_OP_CTRL                         (0x00cc)
+#define P_GE2D_ALU_OP_CTRL                         (volatile unsigned int *)((0x00cc  << 2) + 0xff940000)
+//bit 31:0 (RGBA,YCBCRA)
+#define   GE2D_ALU_CONST_COLOR                     (0x00cd)
+#define P_GE2D_ALU_CONST_COLOR                     (volatile unsigned int *)((0x00cd  << 2) + 0xff940000)
+//SRC1 Key
+//31:0
+#define   GE2D_SRC1_KEY                            (0x00ce)
+#define P_GE2D_SRC1_KEY                            (volatile unsigned int *)((0x00ce  << 2) + 0xff940000)
+//SRC1 Key Mask
+//31:0
+#define   GE2D_SRC1_KEY_MASK                       (0x00cf)
+#define P_GE2D_SRC1_KEY_MASK                       (volatile unsigned int *)((0x00cf  << 2) + 0xff940000)
+//SRC2 Key
+//31:0
+#define   GE2D_SRC2_KEY                            (0x00d0)
+#define P_GE2D_SRC2_KEY                            (volatile unsigned int *)((0x00d0  << 2) + 0xff940000)
+//SRC2 Key Mask
+//31:0
+#define   GE2D_SRC2_KEY_MASK                       (0x00d1)
+#define P_GE2D_SRC2_KEY_MASK                       (volatile unsigned int *)((0x00d1  << 2) + 0xff940000)
+//Destination Bit Mask
+//31:0
+#define   GE2D_DST_BITMASK                         (0x00d2)
+#define P_GE2D_DST_BITMASK                         (volatile unsigned int *)((0x00d2  << 2) + 0xff940000)
+//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
+//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
+//Bit 30:16     DP on counter
+//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
+//Bit 14:0      DP off counter
+#define   GE2D_DP_ONOFF_CTRL                       (0x00d3)
+#define P_GE2D_DP_ONOFF_CTRL                       (volatile unsigned int *)((0x00d3  << 2) + 0xff940000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8	    type of index, 0: vertical coef
+//						   1: horizontal coef
+//Bit 6:0 	coef index
+#define   GE2D_SCALE_COEF_IDX                      (0x00d4)
+#define P_GE2D_SCALE_COEF_IDX                      (volatile unsigned int *)((0x00d4  << 2) + 0xff940000)
+//coefficients for vertical filter and horizontal filter
+#define   GE2D_SCALE_COEF                          (0x00d5)
+#define P_GE2D_SCALE_COEF                          (volatile unsigned int *)((0x00d5  << 2) + 0xff940000)
+//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
+//                                for the area outside the clipping window. As below:
+//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
+//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
+//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
+//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
+//Bit 23:16 src2 outside alpha
+//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above.
+//Bit 7:0   src1 outside alpha
+#define   GE2D_SRC_OUTSIDE_ALPHA                   (0x00d6)
+#define P_GE2D_SRC_OUTSIDE_ALPHA                   (volatile unsigned int *)((0x00d6  << 2) + 0xff940000)
+//Bit 31       antiflick enable
+//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha
+//Bit 23:16     register value for the first line alpha when bit 24 is 1
+//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha
+//Bit 7:0      register value for the last line alpha when bit 8 is 1
+#define   GE2D_ANTIFLICK_CTRL0                     (0x00d8)
+#define P_GE2D_ANTIFLICK_CTRL0                     (volatile unsigned int *)((0x00d8  << 2) + 0xff940000)
+//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA
+//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
+//Bit 23:16, R mult coef for converting RGB to Y
+//Bit 15:8,  G mult coef for converting RGB to Y
+//Bit 7:0,   B mult coef for converting RGB to Y
+//Y = (R * y_r + G * y_g + B * y_b) / 256
+#define   GE2D_ANTIFLICK_CTRL1                     (0x00d9)
+#define P_GE2D_ANTIFLICK_CTRL1                     (volatile unsigned int *)((0x00d9  << 2) + 0xff940000)
+//Bit 31:24, Y threhold1, when   0<Y<=th1, use filter0;
+//Bit 23:16, color antiflick filter0 n3
+//Bit 15:8,  color antiflick filter0 n2
+//Bit 7:0,   color antiflick filter0 n1
+//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
+#define   GE2D_ANTIFLICK_COLOR_FILT0               (0x00da)
+#define P_GE2D_ANTIFLICK_COLOR_FILT0               (volatile unsigned int *)((0x00da  << 2) + 0xff940000)
+//Bit 31:24, Y threhold2, when th1<Y<=th2, use filter1;
+//Bit 23:16, color antiflick filter1 n3
+//Bit 15:8,  color antiflick filter1 n2
+//Bit 7:0,   color antiflick filter1 n1
+#define   GE2D_ANTIFLICK_COLOR_FILT1               (0x00db)
+#define P_GE2D_ANTIFLICK_COLOR_FILT1               (volatile unsigned int *)((0x00db  << 2) + 0xff940000)
+//Bit 31:24, Y threhold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
+//Bit 23:16, color antiflick filter2 n3
+//Bit 15:8,  color antiflick filter2 n2
+//Bit 7:0,   color antiflick filter2 n1
+#define   GE2D_ANTIFLICK_COLOR_FILT2               (0x00dc)
+#define P_GE2D_ANTIFLICK_COLOR_FILT2               (volatile unsigned int *)((0x00dc  << 2) + 0xff940000)
+//Bit 23:16, color antiflick filter3 n3
+//Bit 15:8,  color antiflick filter3 n2
+//Bit 7:0,   color antiflick filter3 n1
+#define   GE2D_ANTIFLICK_COLOR_FILT3               (0x00dd)
+#define P_GE2D_ANTIFLICK_COLOR_FILT3               (volatile unsigned int *)((0x00dd  << 2) + 0xff940000)
+//Bit 31:24, Alpha threhold1, when   0<Alpha<=th1, use filter0;
+//Bit 23:16, Alpha antiflick filter0 n3
+//Bit 15:8,  Alpha antiflick filter0 n2
+//Bit 7:0,   Alpha antiflick filter0 n1
+//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
+#define   GE2D_ANTIFLICK_ALPHA_FILT0               (0x00de)
+#define P_GE2D_ANTIFLICK_ALPHA_FILT0               (volatile unsigned int *)((0x00de  << 2) + 0xff940000)
+//Bit 31:24, Alpha threhold2, when th1<Alpha<=th2, use filter1;
+//Bit 23:16, Alpha antiflick filter1 n3
+//Bit 15:8,  Alpha antiflick filter1 n2
+//Bit 7:0,   Alpha antiflick filter1 n1
+#define   GE2D_ANTIFLICK_ALPHA_FILT1               (0x00df)
+#define P_GE2D_ANTIFLICK_ALPHA_FILT1               (volatile unsigned int *)((0x00df  << 2) + 0xff940000)
+//Bit 31:24, Alpha threhold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
+//Bit 23:16, Alpha antiflick filter2 n3
+//Bit 15:8,  Alpha antiflick filter2 n2
+//Bit 7:0,   Alpha antiflick filter2 n1
+#define   GE2D_ANTIFLICK_ALPHA_FILT2               (0x00e0)
+#define P_GE2D_ANTIFLICK_ALPHA_FILT2               (volatile unsigned int *)((0x00e0  << 2) + 0xff940000)
+//Bit 23:16, Alpha antiflick filter3 n3
+//Bit 15:8,  Alpha antiflick filter3 n2
+//Bit 7:0,   Alpha antiflick filter3 n1
+#define   GE2D_ANTIFLICK_ALPHA_FILT3               (0x00e1)
+#define P_GE2D_ANTIFLICK_ALPHA_FILT3               (volatile unsigned int *)((0x00e1  << 2) + 0xff940000)
+//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
+//Bit 30:22 din_offset (signed data)
+//Bit 21:14 map_coef (unsigned data)
+//Bit 13:10 map_sr (unsigned data)
+//Bit 9:1   dout_offset (signed data)
+//Bit 0     enable
+#define   GE2D_SRC1_RANGE_MAP_Y_CTRL               (0x00e3)
+#define P_GE2D_SRC1_RANGE_MAP_Y_CTRL               (volatile unsigned int *)((0x00e3  << 2) + 0xff940000)
+//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
+//Bit 30:22 din_offset (signed data)
+//Bit 21:14 map_coef (unsigned data)
+//Bit 13:10 map_sr (unsigned data)
+//Bit 9:1   dout_offset (signed data)
+//Bit 0     enable
+#define   GE2D_SRC1_RANGE_MAP_CB_CTRL              (0x00e4)
+#define P_GE2D_SRC1_RANGE_MAP_CB_CTRL              (volatile unsigned int *)((0x00e4  << 2) + 0xff940000)
+//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
+//Bit 30:22 din_offset (signed data)
+//Bit 21:14 map_coef (unsigned data)
+//Bit 13:10 map_sr (unsigned data)
+//Bit 9:1   dout_offset (signed data)
+//Bit 0     enable
+#define   GE2D_SRC1_RANGE_MAP_CR_CTRL              (0x00e5)
+#define P_GE2D_SRC1_RANGE_MAP_CR_CTRL              (volatile unsigned int *)((0x00e5  << 2) + 0xff940000)
+//Bit 21:16     src1 prearbitor burst number
+//Bit 13:8      src2 prearbitor burst number
+//Bit 5:0       dst prearbitor burst number
+#define   GE2D_ARB_BURST_NUM                       (0x00e6)
+#define P_GE2D_ARB_BURST_NUM                       (volatile unsigned int *)((0x00e6  << 2) + 0xff940000)
+//each 6bit ID, high 4bit are thread ID, low 2bits are the token
+//Bit 21:16 src1 ID
+//Bit 13:8 src2 ID
+//Bit 5:0  dst ID
+#define   GE2D_TID_TOKEN                           (0x00e7)
+#define P_GE2D_TID_TOKEN                           (volatile unsigned int *)((0x00e7  << 2) + 0xff940000)
+//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
+//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
+//Bit 25:24, dst2 8bit mode component selection,
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 22:19 dst2 color_map
+//        dst2_format=0                  : output 8-bit;
+//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
+//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
+//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
+//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
+//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
+//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
+//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
+//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
+//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
+//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
+//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
+//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
+//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
+//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
+//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
+//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
+//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
+//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
+//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
+//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
+//Bit 15     reserved
+//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
+//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
+//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
+//Bit     9 reserved
+//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
+//Bit  7: 6 reserved
+//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
+//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
+//Bit     1 reserved
+//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
+#define   GE2D_GEN_CTRL3                           (0x00e8)
+#define P_GE2D_GEN_CTRL3                           (volatile unsigned int *)((0x00e8  << 2) + 0xff940000)
+//Read only
+// Bit 13:0 ge2d_dst2_status, for debug only
+#define   GE2D_STATUS2                             (0x00e9)
+#define P_GE2D_STATUS2                             (volatile unsigned int *)((0x00e9  << 2) + 0xff940000)
+//Bit 27:26  src1 Y fifo size control, 00: 512, 01: 256, 10: 128 11: 96
+//Bit 25:24  src2 fifo size control, 00: 512, 01: 256, 10: 128 11: 96
+//Bit 23:22  dst1 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
+//Bit 21:20  dst2 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
+//Bit 19:18, dst1 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
+//Bit 17:16, dst2 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
+//Bit 15:1, top_wrap_ctrl
+//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
+#define   GE2D_GEN_CTRL4                           (0x00ea)
+#define P_GE2D_GEN_CTRL4                           (volatile unsigned int *)((0x00ea  << 2) + 0xff940000)
+#define   GE2D_GCLK_CTRL0                          (0x00ef)
+#define P_GE2D_GCLK_CTRL0                          (volatile unsigned int *)((0x00ef  << 2) + 0xff940000)
+#define   GE2D_GCLK_CTRL1                          (0x00f0)
+#define P_GE2D_GCLK_CTRL1                          (volatile unsigned int *)((0x00f0  << 2) + 0xff940000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./ge2d_regs.h
+//
+
+// canvas.h
+// ---------------------------
+#define DC_CAV_LUT_DATAL                           (0x0012 << 2)
+#define P_DC_CAV_LUT_DATAL                         (volatile unsigned int *)((0x0012  << 2) + 0xff638000)
+#define DC_CAV_LUT_DATAH                           (0x0013 << 2)
+#define P_DC_CAV_LUT_DATAH                         (volatile unsigned int *)((0x0013  << 2) + 0xff638000)
+#define DC_CAV_LUT_ADDR                            (0x0014 << 2)
+#define P_DC_CAV_LUT_ADDR                          (volatile unsigned int *)((0x0014  << 2) + 0xff638000)
+#define DC_CAV_LUT_RDATAL                          (0x0015 << 2)
+#define P_DC_CAV_LUT_RDATAL                        (volatile unsigned int *)((0x0015  << 2) + 0xff638000)
+#define DC_CAV_LUT_RDATAH                          (0x0016 << 2)
+#define P_DC_CAV_LUT_RDATAH                        (volatile unsigned int *)((0x0016  << 2) + 0xff638000)
+
+
+#define VPU_RDARB_MODE_L1C1                        (0x2790)
+#define VPU_RDARB_MODE_L1C2                        (0x2799)
+#define VPU_RDARB_MODE_L2C1                        (0x279d)
+#define VPU_WRARB_MODE_L2C1                        (0x27a2)
+
+// secure_apb.h
+
+//	registers for mipi_dsi (12'h8a0 - 12'h8ff)
+//========================================================================
+//
+// Reading file:  dsi_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// MIPI DSI HOST CONTROLLER Registers 0x1c00 - 0x1cff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DSI_CBUS_BASE = 0x1c
+#define MIPI_DSI_REGISTER
+// -----------------------------------------------
+//------------------------------------------------------------------------------
+// DWC IP registers: Synopsys IP, please refer to MIPI DSI HOST Databook
+//------------------------------------------------------------------------------
+#define MIPI_DSI_DWC_VERSION_OS                    0x1c00
+#define MIPI_DSI_DWC_PWR_UP_OS                     0x1c01
+#define MIPI_DSI_DWC_CLKMGR_CFG_OS                 0x1c02
+#define MIPI_DSI_DWC_DPI_VCID_OS                   0x1c03
+#define MIPI_DSI_DWC_DPI_COLOR_CODING_OS           0x1c04
+#define MIPI_DSI_DWC_DPI_CFG_POL_OS                0x1c05
+#define MIPI_DSI_DWC_DPI_LP_CMD_TIM_OS             0x1c06
+#define MIPI_DSI_DWC_PCKHDL_CFG_OS                 0x1c0b
+#define MIPI_DSI_DWC_GEN_VCID_OS                   0x1c0c
+#define MIPI_DSI_DWC_MODE_CFG_OS                   0x1c0d
+#define MIPI_DSI_DWC_VID_MODE_CFG_OS               0x1c0e
+#define MIPI_DSI_DWC_VID_PKT_SIZE_OS               0x1c0f
+#define MIPI_DSI_DWC_VID_NUM_CHUNKS_OS             0x1c10
+#define MIPI_DSI_DWC_VID_NULL_SIZE_OS              0x1c11
+#define MIPI_DSI_DWC_VID_HSA_TIME_OS               0x1c12
+#define MIPI_DSI_DWC_VID_HBP_TIME_OS               0x1c13
+#define MIPI_DSI_DWC_VID_HLINE_TIME_OS             0x1c14
+#define MIPI_DSI_DWC_VID_VSA_LINES_OS              0x1c15
+#define MIPI_DSI_DWC_VID_VBP_LINES_OS              0x1c16
+#define MIPI_DSI_DWC_VID_VFP_LINES_OS              0x1c17
+#define MIPI_DSI_DWC_VID_VACTIVE_LINES_OS          0x1c18
+#define MIPI_DSI_DWC_EDPI_CMD_SIZE_OS              0x1c19
+#define MIPI_DSI_DWC_CMD_MODE_CFG_OS               0x1c1a
+#define MIPI_DSI_DWC_GEN_HDR_OS                    0x1c1b
+#define MIPI_DSI_DWC_GEN_PLD_DATA_OS               0x1c1c
+#define MIPI_DSI_DWC_CMD_PKT_STATUS_OS             0x1c1d
+#define MIPI_DSI_DWC_TO_CNT_CFG_OS                 0x1c1e
+#define MIPI_DSI_DWC_HS_RD_TO_CNT_OS               0x1c1f
+#define MIPI_DSI_DWC_LP_RD_TO_CNT_OS               0x1c20
+#define MIPI_DSI_DWC_HS_WR_TO_CNT_OS               0x1c21
+#define MIPI_DSI_DWC_LP_WR_TO_CNT_OS               0x1c22
+#define MIPI_DSI_DWC_BTA_TO_CNT_OS                 0x1c23
+#define MIPI_DSI_DWC_SDF_3D_OS                     0x1c24
+#define MIPI_DSI_DWC_LPCLK_CTRL_OS                 0x1c25
+#define MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS          0x1c26
+#define MIPI_DSI_DWC_PHY_TMR_CFG_OS                0x1c27
+#define MIPI_DSI_DWC_PHY_RSTZ_OS                   0x1c28
+#define MIPI_DSI_DWC_PHY_IF_CFG_OS                 0x1c29
+#define MIPI_DSI_DWC_PHY_ULPS_CTRL_OS              0x1c2a
+#define MIPI_DSI_DWC_PHY_TX_TRIGGERS_OS            0x1c2b
+#define MIPI_DSI_DWC_PHY_STATUS_OS                 0x1c2c
+#define MIPI_DSI_DWC_PHY_TST_CTRL0_OS              0x1c2d
+#define MIPI_DSI_DWC_PHY_TST_CTRL1_OS              0x1c2e
+#define MIPI_DSI_DWC_INT_ST0_OS                    0x1c2f
+#define MIPI_DSI_DWC_INT_ST1_OS                    0x1c30
+#define MIPI_DSI_DWC_INT_MSK0_OS                   0x1c31
+#define MIPI_DSI_DWC_INT_MSK1_OS                   0x1c32
+//------------------------------------------------------------------------------
+// Top-level registers: AmLogic proprietary
+//------------------------------------------------------------------------------
+// 31: 4    Reserved.                                                                           Default 0.
+//     3 RW ~tim_rst_n:  1=Assert SW reset on mipi_dsi_host_timing block.   0=Release reset.    Default 1.
+//     2 RW ~dpi_rst_n:  1=Assert SW reset on mipi_dsi_host_dpi block.      0=Release reset.    Default 1.
+//     1 RW ~intr_rst_n: 1=Assert SW reset on mipi_dsi_host_intr block.     0=Release reset.    Default 1.
+//     0 RW ~dwc_rst_n:  1=Assert SW reset on IP core.                      0=Release reset.    Default 1.
+#define MIPI_DSI_TOP_SW_RESET                      0x1cf0
+// 31: 5    Reserved.                                                                                                       Default 0.
+//     4 RW manual_edpihalt:  1=Manual suspend VencL; 0=do not suspend VencL.                                               Default 0.
+//     3 RW auto_edpihalt_en: 1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL. Default 0.
+//     2 RW clock_freerun: Apply to auto-clock gate only.                                                                   Default 0.
+//                          0=Default, use auto-clock gating to save power;
+//                          1=use free-run clock, disable auto-clock gating, for debug mode.
+//     1 RW enable_pixclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable pixclk.      Default 0.
+//     0 RW enable_sysclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable sysclk.      Default 0.
+#define MIPI_DSI_TOP_CLK_CNTL                      0x1cf1
+// 31:27    Reserved.                                                                       Default 0.
+//    26 RW de_dpi_pol:     1= Invert DE polarity from mipi_dsi_host_dpi.                   Default 0.
+//    25 RW hsync_dpi_pol:  1= Invert HS polarity from mipi_dsi_host_dpi.                   Default 0.
+//    24 RW vsync_dpi_pol:  1= Invert VS polarity from mipi_dsi_host_dpi.                   Default 0.
+// 23:20 RW dpi_color_mode: Define DPI pixel format.                                        Default 0.
+//                           0=16-bit RGB565 config 1;
+//                           1=16-bit RGB565 config 2;
+//                           2=16-bit RGB565 config 3;
+//                           3=18-bit RGB666 config 1;
+//                           4=18-bit RGB666 config 2;
+//                           5=24-bit RGB888;
+//                           6=20-bit YCbCr 4:2:2;
+//                           7=24-bit YCbCr 4:2:2;
+//                           8=16-bit YCbCr 4:2:2;
+//                           9=30-bit RGB;
+//                          10=36-bit RGB;
+//                          11=12-bit YCbCr 4:2:0.
+//    19    Reserved.                                                                       Default 0.
+// 18:16 RW in_color_mode:  Define VENC data width.                                         Default 0.
+//                          0=30-bit pixel;
+//                          1=24-bit pixel;
+//                          2=18-bit pixel, RGB666;
+//                          3=16-bit pixel, RGB565.
+// 15:14 RW chroma_subsample: Define method of chroma subsampling.                          Default 0.
+//                            Applicable to YUV422 or YUV420 only.
+//                            0=Use even pixel's chroma;
+//                            1=Use odd pixel's chroma;
+//                            2=Use averaged value between even and odd pair.
+// 13:12 RW comp2_sel:  Select which component to be Cr or B: 0=comp0; 1=comp1; 2=comp2.    Default 2.
+// 11:10 RW comp1_sel:  Select which component to be Cb or G: 0=comp0; 1=comp1; 2=comp2.    Default 1.
+//  9: 8 RW comp0_sel:  Select which component to be Y  or R: 0=comp0; 1=comp1; 2=comp2.    Default 0.
+//     7    Reserved.                                                                       Default 0.
+//     6 RW de_venc_pol:    1= Invert DE polarity from VENC.                                Default 0.
+//     5 RW hsync_venc_pol: 1= Invert HS polarity from VENC.                                Default 0.
+//     4 RW vsync_venc_pol: 1= Invert VS polarity from VENC.                                Default 0.
+//     3 RW dpicolorm:      Signal to IP.                                                   Default 0.
+//     2 RW dpishutdn:      Signal to IP.                                                   Default 0.
+//     1    Reserved.                                                                       Default 0.
+//     0    Reserved.                                                                       Default 0.
+#define MIPI_DSI_TOP_CNTL                          0x1cf2
+// 31:16    Reserved.                                                                                                           Default 0.
+// 15: 8 RW suspend_frame_rate: Define rate of timed-suspend.                                                                   Default 0.
+//                              0=Execute suspend every frame; 1=Every other frame; ...; 255=Every 256 frame.
+//  7: 3    Reserved.                                                                                                           Default 0.
+//     2 RW timed_suspend_en:   1=Enable timed suspend VencL. 0=Disable timed suspend.                                          Default 0.
+//     1 RW manual_suspend_en:  1=Enable manual suspend VencL. 1=Cancel manual suspend VencL.                                   Default 0.
+//     0 RW suspend_on_edpihalt:1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL.   Default 1.
+#define MIPI_DSI_TOP_SUSPEND_CNTL                  0x1cf3
+// 31:29    Reserved.                                                                                                           Default 0.
+// 28:16 RW suspend_line_end:   Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
+// 15:13    Reserved.                                                                                                           Default 0.
+// 12: 0 RW suspend_line_start: Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
+#define MIPI_DSI_TOP_SUSPEND_LINE                  0x1cf4
+// 31:29    Reserved.                                                                                                           Default 0.
+// 28:16 RW suspend_pix_end:    Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
+// 15:13    Reserved.                                                                                                           Default 0.
+// 12: 0 RW suspend_pix_start:  Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
+#define MIPI_DSI_TOP_SUSPEND_PIX                   0x1cf5
+// 31:20    Reserved.                                                                                                           Default 0.
+// 19:10 RW meas_vsync:     Control on measuring Host Controller's vsync.                                                       Default 0.
+//                          [   19] meas_en:        1=Enable measurement
+//                          [   18] accum_meas_en:  0=meas_count is cleared at the end of each measure;
+//                                                  1=meas_count is accumulated at the end of each measure.
+//                          [17:10] vsync_span:     Define the duration of a measure is to last for how many Vsyncs.
+//  9: 0 RW meas_edpite:    Control on measuring Display Slave's edpite.                                                        Default 0.
+//                          [    9] meas_en:        1=Enable measurement
+//                          [    8] accum_meas_en:  0=meas_count is cleared at the end of each measure;
+//                                                  1=meas_count is accumulated at the end of each measure.
+//                          [ 7: 0] edpite_span:    Define the duration of a measure is to last for how many edpite.
+#define MIPI_DSI_TOP_MEAS_CNTL                     0x1cf6
+//    31 R  stat_edpihalt:  status of edpihalt signal from IP.              Default 0.
+// 30:29    Reserved.                                                       Default 0.
+// 28:16 R  stat_te_line:   Snapshot of Host's line position at edpite.     Default 0.
+// 15:13    Reserved.                                                       Default 0.
+// 12: 0 R  stat_te_pix:    Snapshot of Host's pixel position at edpite.    Default 0.
+#define MIPI_DSI_TOP_STAT                          0x1cf7
+// To measure display slave's frame rate, we can use a reference clock to measure the duration of one of more edpite pulse(s).
+// Measurement control is by register MIPI_DSI_TOP_MEAS_CNTL bit[9:0].
+// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
+// Mesurement result is in MIPI_DSI_TOP_MEAS_STAT_TE0 and MIPI_DSI_TOP_MEAS_STAT_TE1, as below:
+// edpite_meas_count[47:0]: Number of reference clock cycles counted during one measure period (non-incremental measure), or
+//                          during all measure periods so far (incremental measure).
+// edpite_meas_count_n[3:0]:Number of measure periods has been done. Number can wrap over.
+//
+// 31: 0 R  edpite_meas_count[31:0].    Default 0.
+#define MIPI_DSI_TOP_MEAS_STAT_TE0                 0x1cf8
+// 19:16 R  edpite_meas_count_n.        Default 0.
+// 15: 0 R  edpite_meas_count[47:32].   Default 0.
+#define MIPI_DSI_TOP_MEAS_STAT_TE1                 0x1cf9
+// To measure Host's frame rate, we can use a reference clock to measure the duration of one of more Vsync pulse(s).
+// Measurement control is by register MIPI_DSI_TOP_MEAS_CNTL bit[19:10].
+// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
+// Mesurement result is in MIPI_DSI_TOP_MEAS_STAT_VS0 and MIPI_DSI_TOP_MEAS_STAT_VS1, as below:
+// vsync_meas_count[47:0]:  Number of reference clock cycles counted during one measure period (non-incremental measure), or
+//                          during all measure periods so far (incremental measure).
+// vsync_meas_count_n[3:0]: Number of measure periods has been done. Number can wrap over.
+//
+// 31: 0 R  vsync_meas_count[31:0].     Default 0.
+#define MIPI_DSI_TOP_MEAS_STAT_VS0                 0x1cfa
+// 19:16 R  vsync_meas_count_n.         Default 0.
+// 15: 0 R  vsync_meas_count[47:32].    Default 0.
+#define MIPI_DSI_TOP_MEAS_STAT_VS1                 0x1cfb
+// 31:16 RW intr_stat/clr. For each bit, read as this interrupt level status, write 1 to clear. Default 0.
+//                         Note: To clear the interrupt level, simply write 1 to the specific bit, no need to write 0 afterwards.
+//          [31:22] Reserved
+//          [   21] stat/clr of EOF interrupt
+//          [   20] stat/clr of de_fall interrupt
+//          [   19] stat/clr of de_rise interrupt
+//          [   18] stat/clr of vs_fall interrupt
+//          [   17] stat/clr of vs_rise interrupt
+//          [   16] stat/clr of dwc_edpite interrupt
+// 15: 0 RW intr_enable. For each bit, 1=enable this interrupt, 0=disable.                      Default 0.
+//          [15: 6] Reserved
+//          [    5] EOF (End_Of_Field) interrupt
+//          [    4] de_fall interrupt
+//          [    3] de_rise interrupt
+//          [    2] vs_fall interrupt
+//          [    1] vs_rise interrupt
+//          [    0] dwc_edpite interrupt
+#define MIPI_DSI_TOP_INTR_CNTL_STAT                0x1cfc
+// 31: 2    Reserved.   Default 0.
+//  1: 0 RW mem_pd.     Default 3.
+#define MIPI_DSI_TOP_MEM_PD                        0x1cfd
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dsi_regs.h
+#define VD1_HDR2_CTRL                      0x3800
+#define VD1_HDR2_CLK_GATE                  0x3801
+#define VD1_HDR2_MATRIXI_COEF00_01         0x3802
+#define VD1_HDR2_MATRIXI_COEF02_10         0x3803
+#define VD1_HDR2_MATRIXI_COEF11_12         0x3804
+#define VD1_HDR2_MATRIXI_COEF20_21         0x3805
+#define VD1_HDR2_MATRIXI_COEF22            0x3806
+#define VD1_HDR2_MATRIXI_COEF30_31         0x3807
+#define VD1_HDR2_MATRIXI_COEF32_40         0x3808
+#define VD1_HDR2_MATRIXI_COEF41_42         0x3809
+#define VD1_HDR2_MATRIXI_OFFSET0_1         0x380a
+#define VD1_HDR2_MATRIXI_OFFSET2           0x380b
+#define VD1_HDR2_MATRIXI_PRE_OFFSET0_1     0x380c
+#define VD1_HDR2_MATRIXI_PRE_OFFSET2       0x380d
+#define VD1_HDR2_MATRIXO_COEF00_01         0x380e
+#define VD1_HDR2_MATRIXO_COEF02_10         0x380f
+#define VD1_HDR2_MATRIXO_COEF11_12         0x3810
+#define VD1_HDR2_MATRIXO_COEF20_21         0x3811
+#define VD1_HDR2_MATRIXO_COEF22            0x3812
+#define VD1_HDR2_MATRIXO_COEF30_31         0x3813
+#define VD1_HDR2_MATRIXO_COEF32_40         0x3814
+#define VD1_HDR2_MATRIXO_COEF41_42         0x3815
+#define VD1_HDR2_MATRIXO_OFFSET0_1         0x3816
+#define VD1_HDR2_MATRIXO_OFFSET2           0x3817
+#define VD1_HDR2_MATRIXO_PRE_OFFSET0_1     0x3818
+#define VD1_HDR2_MATRIXO_PRE_OFFSET2       0x3819
+#define VD1_HDR2_MATRIXI_CLIP              0x381a
+#define VD1_HDR2_MATRIXO_CLIP              0x381b
+#define VD1_HDR2_CGAIN_OFFT                0x381c
+#define VD1_EOTF_LUT_ADDR_PORT             0x381e
+#define VD1_EOTF_LUT_DATA_PORT             0x381f
+#define VD1_OETF_LUT_ADDR_PORT             0x3820
+#define VD1_OETF_LUT_DATA_PORT             0x3821
+#define VD1_CGAIN_LUT_ADDR_PORT            0x3822
+#define VD1_CGAIN_LUT_DATA_PORT            0x3823
+#define VD1_HDR2_CGAIN_COEF0               0x3824
+#define VD1_HDR2_CGAIN_COEF1               0x3825
+#define VD1_OGAIN_LUT_ADDR_PORT            0x3826
+#define VD1_OGAIN_LUT_DATA_PORT            0x3827
+#define VD1_HDR2_ADPS_CTRL                 0x3828
+#define VD1_HDR2_ADPS_ALPHA0               0x3829
+#define VD1_HDR2_ADPS_ALPHA1               0x382a
+#define VD1_HDR2_ADPS_BETA0                0x382b
+#define VD1_HDR2_ADPS_BETA1                0x382c
+#define VD1_HDR2_ADPS_BETA2                0x382d
+#define VD1_HDR2_ADPS_COEF0                0x382e
+#define VD1_HDR2_ADPS_COEF1                0x382f
+#define VD1_HDR2_GMUT_CTRL                 0x3830
+#define VD1_HDR2_GMUT_COEF0                0x3831
+#define VD1_HDR2_GMUT_COEF1                0x3832
+#define VD1_HDR2_GMUT_COEF2                0x3833
+#define VD1_HDR2_GMUT_COEF3                0x3834
+#define VD1_HDR2_GMUT_COEF4                0x3835
+#define VD1_HDR2_PIPE_CTRL1                0x3836
+#define VD1_HDR2_PIPE_CTRL2                0x3837
+#define VD1_HDR2_PIPE_CTRL3                0x3838
+#define VD1_HDR2_PROC_WIN1                 0x3839
+#define VD1_HDR2_PROC_WIN2                 0x383a
+#define VD1_HDR2_MATRIXI_EN_CTRL           0x383b
+#define VD1_HDR2_MATRIXO_EN_CTRL           0x383c
+
+#define VD2_HDR2_CTRL                      0x3850
+#define VD2_HDR2_CLK_GATE                  0x3851
+#define VD2_HDR2_MATRIXI_COEF00_01         0x3852
+#define VD2_HDR2_MATRIXI_COEF02_10         0x3853
+#define VD2_HDR2_MATRIXI_COEF11_12         0x3854
+#define VD2_HDR2_MATRIXI_COEF20_21         0x3855
+#define VD2_HDR2_MATRIXI_COEF22            0x3856
+#define VD2_HDR2_MATRIXI_COEF30_31         0x3857
+#define VD2_HDR2_MATRIXI_COEF32_40         0x3858
+#define VD2_HDR2_MATRIXI_COEF41_42         0x3859
+#define VD2_HDR2_MATRIXI_OFFSET0_1         0x385a
+#define VD2_HDR2_MATRIXI_OFFSET2           0x385b
+#define VD2_HDR2_MATRIXI_PRE_OFFSET0_1     0x385c
+#define VD2_HDR2_MATRIXI_PRE_OFFSET2       0x385d
+#define VD2_HDR2_MATRIXO_COEF00_01         0x385e
+#define VD2_HDR2_MATRIXO_COEF02_10         0x385f
+#define VD2_HDR2_MATRIXO_COEF11_12         0x3860
+#define VD2_HDR2_MATRIXO_COEF20_21         0x3861
+#define VD2_HDR2_MATRIXO_COEF22            0x3862
+#define VD2_HDR2_MATRIXO_COEF30_31         0x3863
+#define VD2_HDR2_MATRIXO_COEF32_40         0x3864
+#define VD2_HDR2_MATRIXO_COEF41_42         0x3865
+#define VD2_HDR2_MATRIXO_OFFSET0_1         0x3866
+#define VD2_HDR2_MATRIXO_OFFSET2           0x3867
+#define VD2_HDR2_MATRIXO_PRE_OFFSET0_1     0x3868
+#define VD2_HDR2_MATRIXO_PRE_OFFSET2       0x3869
+#define VD2_HDR2_MATRIXI_CLIP              0x386a
+#define VD2_HDR2_MATRIXO_CLIP              0x386b
+#define VD2_HDR2_CGAIN_OFFT                0x386c
+#define VD2_EOTF_LUT_ADDR_PORT             0x386e
+#define VD2_EOTF_LUT_DATA_PORT             0x386f
+#define VD2_OETF_LUT_ADDR_PORT             0x3870
+#define VD2_OETF_LUT_DATA_PORT             0x3871
+#define VD2_CGAIN_LUT_ADDR_PORT            0x3872
+#define VD2_CGAIN_LUT_DATA_PORT            0x3873
+#define VD2_HDR2_CGAIN_COEF0               0x3874
+#define VD2_HDR2_CGAIN_COEF1               0x3875
+#define VD2_OGAIN_LUT_ADDR_PORT            0x3876
+#define VD2_OGAIN_LUT_DATA_PORT            0x3877
+#define VD2_HDR2_ADPS_CTRL                 0x3878
+#define VD2_HDR2_ADPS_ALPHA0               0x3879
+#define VD2_HDR2_ADPS_ALPHA1               0x387a
+#define VD2_HDR2_ADPS_BETA0                0x387b
+#define VD2_HDR2_ADPS_BETA1                0x387c
+#define VD2_HDR2_ADPS_BETA2                0x387d
+#define VD2_HDR2_ADPS_COEF0                0x387e
+#define VD2_HDR2_ADPS_COEF1                0x387f
+#define VD2_HDR2_GMUT_CTRL                 0x3880
+#define VD2_HDR2_GMUT_COEF0                0x3881
+#define VD2_HDR2_GMUT_COEF1                0x3882
+#define VD2_HDR2_GMUT_COEF2                0x3883
+#define VD2_HDR2_GMUT_COEF3                0x3884
+#define VD2_HDR2_GMUT_COEF4                0x3885
+#define VD2_HDR2_PIPE_CTRL1                0x3886
+#define VD2_HDR2_PIPE_CTRL2                0x3887
+#define VD2_HDR2_PIPE_CTRL3                0x3888
+#define VD2_HDR2_PROC_WIN1                 0x3889
+#define VD2_HDR2_PROC_WIN2                 0x388a
+#define VD2_HDR2_MATRIXI_EN_CTRL           0x388b
+#define VD2_HDR2_MATRIXO_EN_CTRL           0x388c
+
+#define OSD1_HDR2_CTRL                      0x38a0
+#define OSD1_HDR2_CLK_GATE                  0x38a1
+#define OSD1_HDR2_MATRIXI_COEF00_01         0x38a2
+#define OSD1_HDR2_MATRIXI_COEF02_10         0x38a3
+#define OSD1_HDR2_MATRIXI_COEF11_12         0x38a4
+#define OSD1_HDR2_MATRIXI_COEF20_21         0x38a5
+#define OSD1_HDR2_MATRIXI_COEF22            0x38a6
+#define OSD1_HDR2_MATRIXI_COEF30_31         0x38a7
+#define OSD1_HDR2_MATRIXI_COEF32_40         0x38a8
+#define OSD1_HDR2_MATRIXI_COEF41_42         0x38a9
+#define OSD1_HDR2_MATRIXI_OFFSET0_1         0x38aa
+#define OSD1_HDR2_MATRIXI_OFFSET2           0x38ab
+#define OSD1_HDR2_MATRIXI_PRE_OFFSET0_1     0x38ac
+#define OSD1_HDR2_MATRIXI_PRE_OFFSET2       0x38ad
+#define OSD1_HDR2_MATRIXO_COEF00_01         0x38ae
+#define OSD1_HDR2_MATRIXO_COEF02_10         0x38af
+#define OSD1_HDR2_MATRIXO_COEF11_12         0x38b0
+#define OSD1_HDR2_MATRIXO_COEF20_21         0x38b1
+#define OSD1_HDR2_MATRIXO_COEF22            0x38b2
+#define OSD1_HDR2_MATRIXO_COEF30_31         0x38b3
+#define OSD1_HDR2_MATRIXO_COEF32_40         0x38b4
+#define OSD1_HDR2_MATRIXO_COEF41_42         0x38b5
+#define OSD1_HDR2_MATRIXO_OFFSET0_1         0x38b6
+#define OSD1_HDR2_MATRIXO_OFFSET2           0x38b7
+#define OSD1_HDR2_MATRIXO_PRE_OFFSET0_1     0x38b8
+#define OSD1_HDR2_MATRIXO_PRE_OFFSET2       0x38b9
+#define OSD1_HDR2_MATRIXI_CLIP              0x38ba
+#define OSD1_HDR2_MATRIXO_CLIP              0x38bb
+#define OSD1_HDR2_CGAIN_OFFT                0x38bc
+#define OSD1_EOTF_LUT_ADDR_PORT             0x38be
+#define OSD1_EOTF_LUT_DATA_PORT             0x38bf
+#define OSD1_OETF_LUT_ADDR_PORT             0x38c0
+#define OSD1_OETF_LUT_DATA_PORT             0x38c1
+#define OSD1_CGAIN_LUT_ADDR_PORT            0x38c2
+#define OSD1_CGAIN_LUT_DATA_PORT            0x38c3
+#define OSD1_HDR2_CGAIN_COEF0               0x38c4
+#define OSD1_HDR2_CGAIN_COEF1               0x38c5
+#define OSD1_OGAIN_LUT_ADDR_PORT            0x38c6
+#define OSD1_OGAIN_LUT_DATA_PORT            0x38c7
+#define OSD1_HDR2_ADPS_CTRL                 0x38c8
+#define OSD1_HDR2_ADPS_ALPHA0               0x38c9
+#define OSD1_HDR2_ADPS_ALPHA1               0x38ca
+#define OSD1_HDR2_ADPS_BETA0                0x38cb
+#define OSD1_HDR2_ADPS_BETA1                0x38cc
+#define OSD1_HDR2_ADPS_BETA2                0x38cd
+#define OSD1_HDR2_ADPS_COEF0                0x38ce
+#define OSD1_HDR2_ADPS_COEF1                0x38cf
+#define OSD1_HDR2_GMUT_CTRL                 0x38d0
+#define OSD1_HDR2_GMUT_COEF0                0x38d1
+#define OSD1_HDR2_GMUT_COEF1                0x38d2
+#define OSD1_HDR2_GMUT_COEF2                0x38d3
+#define OSD1_HDR2_GMUT_COEF3                0x38d4
+#define OSD1_HDR2_GMUT_COEF4                0x38d5
+#define OSD1_HDR2_PIPE_CTRL1                0x38d6
+#define OSD1_HDR2_PIPE_CTRL2                0x38d7
+#define OSD1_HDR2_PIPE_CTRL3                0x38d8
+#define OSD1_HDR2_PROC_WIN1                 0x38d9
+#define OSD1_HDR2_PROC_WIN2                 0x38da
+#define OSD1_HDR2_MATRIXI_EN_CTRL           0x38db
+#define OSD1_HDR2_MATRIXO_EN_CTRL           0x38dc
diff --git a/include/amlogic/asm/romboot.h b/include/amlogic/asm/romboot.h
new file mode 100644
index 0000000000..338365e87a
--- /dev/null
+++ b/include/amlogic/asm/romboot.h
@@ -0,0 +1,53 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/romboot.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __BOOT_ROM_H_
+#define __BOOT_ROM_H_
+#ifndef __ASSEMBLY__
+//#include <stdint.h>
+//uint8_t simple_i2c(uint8_t adr);
+//void spi_pin_mux(void);
+//void spi_init(void);
+//uint32_t spi_read(uint32_t src, uint32_t mem, uint32_t size);
+//void udelay(uint32_t usec);
+//void boot_des_decrypt(uint8_t *ct, uint8_t *pt, uint32_t size);
+
+#endif /* ! __ASSEMBLY__ */
+#include "config.h"
+
+/* Magic number to "boot" up A53 */
+#define AO_SEC_SD_CFG10_CB			0x80000000
+
+/*BOOT device and ddr size*/
+/*31-28: boot device id, 27-24: boot device para, 23-20: reserved*/
+/*19-8: ddr size, 7-0: board revision*/
+//#define P_AO_SEC_GP_CFG0                                     0xDA100240 //defined in secure_apb.h
+#define AO_SEC_GP_CFG7_W0_BIT			8
+#define AO_SEC_GP_CFG7_W0			0x100
+
+#define BOOT_ID_RESERVED	0
+#define BOOT_ID_EMMC		1
+#define BOOT_ID_NAND		2
+#define BOOT_ID_SPI		3
+#define BOOT_ID_SDCARD		4
+#define BOOT_ID_USB		5
+
+#endif /* __BOOT_ROM_H_ */
diff --git a/include/amlogic/asm/sd_emmc.h b/include/amlogic/asm/sd_emmc.h
new file mode 100644
index 0000000000..81de3a9674
--- /dev/null
+++ b/include/amlogic/asm/sd_emmc.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2016 Carlo Caione <carlo@caione.org>
+ */
+
+#ifndef __SD_EMMC_H__
+#define __SD_EMMC_H__
+
+#include <mmc.h>
+
+#define SDIO_PORT_A			0
+#define SDIO_PORT_B			1
+#define SDIO_PORT_C			2
+
+#define SD_EMMC_CLKSRC_24M		24000000	/* 24 MHz */
+#define SD_EMMC_CLKSRC_DIV2		1000000000	/* 1 GHz */
+
+#define MESON_SD_EMMC_CLOCK		0x00
+#define CLK_MAX_DIV   GENMASK(5, 0)
+#define CLK_MAX_SRC   GENMASK(7, 6)
+#define	Cfg_div 	0
+#define Cfg_src		6
+#define Cfg_co_phase	8
+#define	Cfg_tx_phase	10
+#define	Cfg_rx_phase	12
+#define	Cfg_sram_pd		14
+#define	Cfg_tx_delay	16
+#define	Cfg_rx_delay	22
+#define	Cfg_always_on	28
+#define	Cfg_irq_sdio_sleep   29
+#define Cfg_irq_sdio_sleep_ds		30
+
+#define MESON_SD_EMMC_DELAY1	0x4
+#define DLY_D0_MASK	GENMASK(5, 0)
+#define DLY_D1_MASK	GENMASK(11, 6)
+#define DLY_D2_MASK	GENMASK(17, 12)
+#define DLY_D3_MASK	GENMASK(23, 18)
+#define DLY_D4_MASK	GENMASK(31, 24)
+#define Dly_d0	0
+#define Dly_d1	6
+#define Dly_d2	12
+#define Dly_d3	18
+#define Dly_d4	24
+
+#define MESON_SD_EMMC_DELAY2	0x8
+#define DLY_D5_MASK	GENMASK(5, 0)
+#define DLY_D6_MASK	GENMASK(11, 6)
+#define DLY_D7_MASK	GENMASK(17, 12)
+#define DLY_D8_MASK	GENMASK(23, 18)
+#define DLY_D9_MASK	GENMASK(31, 24)
+#define Dly_d5	0
+#define Dly_d6	6
+#define Dly_d7	12
+#define Dly_d8	18
+#define Dly_d9	24
+
+#define MESON_SD_EMMC_ADJUST	0xC
+#define CALI_SEL_MASK	GENMASK(11, 8)
+#define ADJ_DLY_MASK	GENMASK(21, 16)
+#define Cfg_cali_sel	8
+#define Cfg_cali_en		12
+#define Cfg_adj_en		13
+#define Cfg_cali_rise	14
+#define Cfg_ds_en		15
+#define Cfg_adj_dly		16
+#define Cfg_adj_auto	22
+#define Cfg_adj_init	23
+
+#define MESON_SD_EMMC_START		0x40
+#define   CFG_DESC_INIT			BIT(0)
+#define   CFG_DESC_BUSY			BIT(1)
+#define   CFG_DESC_ADDR			2
+
+#define MESON_SD_EMMC_CFG		0x44
+#define   CFG_BUS_WIDTH_MASK		GENMASK(1, 0)
+#define   CFG_BUS_WIDTH_1		0
+#define   CFG_BUS_WIDTH_4		1
+#define   CFG_BUS_WIDTH_8		2
+#define   CFG_DDR				BIT(2)
+#define   CFG_BL_LEN_MASK		GENMASK(7, 4)
+#define   CFG_BL_LEN_SHIFT		4
+#define   CFG_BL_LEN_512		(9 << 4)
+#define   CFG_RESP_TIMEOUT_MASK		GENMASK(11, 8)
+#define   CFG_RESP_TIMEOUT_256		(8 << 8)
+#define   CFG_RC_CC_MASK		GENMASK(15, 12)
+#define   CFG_RC_CC_16			(4 << 12)
+#define   CFG_SDCLK_ALWAYS_ON		BIT(18)
+#define   CFG_AUTO_CLK			BIT(23)
+
+#define MESON_SD_EMMC_STATUS		0x48
+#define   STATUS_MASK			GENMASK(15, 0)
+#define   STATUS_ERR_MASK		GENMASK(12, 0)
+#define   STATUS_RXD_ERR_MASK		GENMASK(7, 0)
+#define   STATUS_TXD_ERR		BIT(8)
+#define   STATUS_DESC_ERR		BIT(9)
+#define   STATUS_RESP_ERR		BIT(10)
+#define   STATUS_RESP_TIMEOUT		BIT(11)
+#define   STATUS_DESC_TIMEOUT		BIT(12)
+#define   STATUS_END_OF_CHAIN		BIT(13)
+
+#define MESON_SD_EMMC_IRQ_EN		0x4c
+
+#define MESON_SD_EMMC_CMD_CFG		0x50
+#define   CMD_CFG_LENGTH_MASK		GENMASK(8, 0)
+#define   CMD_CFG_BLOCK_MODE		BIT(9)
+#define   CMD_CFG_R1B			BIT(10)
+#define   CMD_CFG_END_OF_CHAIN		BIT(11)
+#define   CMD_CFG_TIMEOUT_4S		(12 << 12)
+#define   CMD_CFG_NO_RESP		BIT(16)
+#define   CMD_CFG_NO_CMD		BIT(17)
+#define   CMD_CFG_DATA_IO		BIT(18)
+#define   CMD_CFG_DATA_WR		BIT(19)
+#define   CMD_CFG_RESP_NOCRC		BIT(20)
+#define   CMD_CFG_RESP_128		BIT(21)
+#define   CMD_CFG_RESP_NUM		BIT(22)
+#define   CMD_CFG_DATA_NUM		BIT(23)
+#define   CMD_CFG_CMD_INDEX_MASK	GENMASK(29, 24)
+#define   CMD_CFG_CMD_INDEX_SHIFT	24
+#define   CMD_CFG_ERR			BIT(30)
+#define   CMD_CFG_OWNER			BIT(31)
+
+#define MESON_SD_EMMC_CMD_ARG		0x54
+#define MESON_SD_EMMC_CMD_DAT		0x58
+#define MESON_SD_EMMC_CMD_RSP		0x5c
+#define MESON_SD_EMMC_CMD_RSP1		0x60
+#define MESON_SD_EMMC_CMD_RSP2		0x64
+#define MESON_SD_EMMC_CMD_RSP3		0x68
+
+#define SD_EMMC_RXD_ERROR               (1 << 0)
+#define SD_EMMC_TXD_ERROR               (1 << 1)
+#define SD_EMMC_DESC_ERROR              (1 << 2)
+#define SD_EMMC_RESP_CRC_ERROR          (1 << 3)
+#define SD_EMMC_RESP_TIMEOUT_ERROR      (1 << 4)
+#define SD_EMMC_DESC_TIMEOUT_ERROR      (1 << 5)
+
+#endif
diff --git a/include/amlogic/asm/secure_apb.h b/include/amlogic/asm/secure_apb.h
new file mode 100644
index 0000000000..a146334e50
--- /dev/null
+++ b/include/amlogic/asm/secure_apb.h
@@ -0,0 +1,4235 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_register_map_h.pl
+//
+// and was applied to the file
+//
+// ./register_map.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#include <amlogic/asm/regs.h>
+
+#ifdef REGISTER_H
+#else
+#define REGISTER_H
+#endif
+
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_secure_apb4_h.pl
+//
+// and was applied to the file
+//
+// ./secure_apb4_ee.h ./ao_rti_reg.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+
+#ifdef SECURE_APB_H
+#else
+#define SECURE_APB_H
+
+//
+// Reading file:  ./secure_apb4_ee.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//========================================================================
+// MIPI_DSI_PHY
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF644000
+//  APB4_DECODER_SECURE_BASE         32'hFF644000
+//`define MIPI_DSI_PHY_START      8'h00
+//`define MIPI_DSI_PHY_END        16'hffff
+#define     MIPI_DSI_PHY_CTRL                                  (0xff644000 + (0x000 << 2))
+#define SEC_MIPI_DSI_PHY_CTRL                                  (0xff644000 + (0x000 << 2))
+#define   P_MIPI_DSI_PHY_CTRL                                  (volatile uint32_t *)(0xff644000 + (0x000 << 2))
+#define     MIPI_DSI_CHAN_CTRL                                 (0xff644000 + (0x001 << 2))
+#define SEC_MIPI_DSI_CHAN_CTRL                                 (0xff644000 + (0x001 << 2))
+#define   P_MIPI_DSI_CHAN_CTRL                                 (volatile uint32_t *)(0xff644000 + (0x001 << 2))
+#define     MIPI_DSI_CHAN_STS                                  (0xff644000 + (0x002 << 2))
+#define SEC_MIPI_DSI_CHAN_STS                                  (0xff644000 + (0x002 << 2))
+#define   P_MIPI_DSI_CHAN_STS                                  (volatile uint32_t *)(0xff644000 + (0x002 << 2))
+#define     MIPI_DSI_CLK_TIM                                   (0xff644000 + (0x003 << 2))
+#define SEC_MIPI_DSI_CLK_TIM                                   (0xff644000 + (0x003 << 2))
+#define   P_MIPI_DSI_CLK_TIM                                   (volatile uint32_t *)(0xff644000 + (0x003 << 2))
+#define     MIPI_DSI_HS_TIM                                    (0xff644000 + (0x004 << 2))
+#define SEC_MIPI_DSI_HS_TIM                                    (0xff644000 + (0x004 << 2))
+#define   P_MIPI_DSI_HS_TIM                                    (volatile uint32_t *)(0xff644000 + (0x004 << 2))
+#define     MIPI_DSI_LP_TIM                                    (0xff644000 + (0x005 << 2))
+#define SEC_MIPI_DSI_LP_TIM                                    (0xff644000 + (0x005 << 2))
+#define   P_MIPI_DSI_LP_TIM                                    (volatile uint32_t *)(0xff644000 + (0x005 << 2))
+#define     MIPI_DSI_ANA_UP_TIM                                (0xff644000 + (0x006 << 2))
+#define SEC_MIPI_DSI_ANA_UP_TIM                                (0xff644000 + (0x006 << 2))
+#define   P_MIPI_DSI_ANA_UP_TIM                                (volatile uint32_t *)(0xff644000 + (0x006 << 2))
+#define     MIPI_DSI_INIT_TIM                                  (0xff644000 + (0x007 << 2))
+#define SEC_MIPI_DSI_INIT_TIM                                  (0xff644000 + (0x007 << 2))
+#define   P_MIPI_DSI_INIT_TIM                                  (volatile uint32_t *)(0xff644000 + (0x007 << 2))
+#define     MIPI_DSI_WAKEUP_TIM                                (0xff644000 + (0x008 << 2))
+#define SEC_MIPI_DSI_WAKEUP_TIM                                (0xff644000 + (0x008 << 2))
+#define   P_MIPI_DSI_WAKEUP_TIM                                (volatile uint32_t *)(0xff644000 + (0x008 << 2))
+#define     MIPI_DSI_LPOK_TIM                                  (0xff644000 + (0x009 << 2))
+#define SEC_MIPI_DSI_LPOK_TIM                                  (0xff644000 + (0x009 << 2))
+#define   P_MIPI_DSI_LPOK_TIM                                  (volatile uint32_t *)(0xff644000 + (0x009 << 2))
+#define     MIPI_DSI_LP_WCHDOG                                 (0xff644000 + (0x00a << 2))
+#define SEC_MIPI_DSI_LP_WCHDOG                                 (0xff644000 + (0x00a << 2))
+#define   P_MIPI_DSI_LP_WCHDOG                                 (volatile uint32_t *)(0xff644000 + (0x00a << 2))
+#define     MIPI_DSI_ANA_CTRL                                  (0xff644000 + (0x00b << 2))
+#define SEC_MIPI_DSI_ANA_CTRL                                  (0xff644000 + (0x00b << 2))
+#define   P_MIPI_DSI_ANA_CTRL                                  (volatile uint32_t *)(0xff644000 + (0x00b << 2))
+#define     MIPI_DSI_CLK_TIM1                                  (0xff644000 + (0x00c << 2))
+#define SEC_MIPI_DSI_CLK_TIM1                                  (0xff644000 + (0x00c << 2))
+#define   P_MIPI_DSI_CLK_TIM1                                  (volatile uint32_t *)(0xff644000 + (0x00c << 2))
+#define     MIPI_DSI_TURN_WCHDOG                               (0xff644000 + (0x00d << 2))
+#define SEC_MIPI_DSI_TURN_WCHDOG                               (0xff644000 + (0x00d << 2))
+#define   P_MIPI_DSI_TURN_WCHDOG                               (volatile uint32_t *)(0xff644000 + (0x00d << 2))
+#define     MIPI_DSI_ULPS_CHECK                                (0xff644000 + (0x00e << 2))
+#define SEC_MIPI_DSI_ULPS_CHECK                                (0xff644000 + (0x00e << 2))
+#define   P_MIPI_DSI_ULPS_CHECK                                (volatile uint32_t *)(0xff644000 + (0x00e << 2))
+#define     MIPI_DSI_TEST_CTRL0                                (0xff644000 + (0x00f << 2))
+#define SEC_MIPI_DSI_TEST_CTRL0                                (0xff644000 + (0x00f << 2))
+#define   P_MIPI_DSI_TEST_CTRL0                                (volatile uint32_t *)(0xff644000 + (0x00f << 2))
+#define     MIPI_DSI_TEST_CTRL1                                (0xff644000 + (0x010 << 2))
+#define SEC_MIPI_DSI_TEST_CTRL1                                (0xff644000 + (0x010 << 2))
+#define   P_MIPI_DSI_TEST_CTRL1                                (volatile uint32_t *)(0xff644000 + (0x010 << 2))
+//========================================================================
+//  Temp sensor PLL
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF634800
+//  APB4_DECODER_SECURE_BASE         32'hFF634800
+#define     TS_PLL_CFG_REG1                                    (0xff634800 + (0x001 << 2))
+#define SEC_TS_PLL_CFG_REG1                                    (0xff634800 + (0x001 << 2))
+#define   P_TS_PLL_CFG_REG1                                    (volatile uint32_t *)(0xff634800 + (0x001 << 2))
+#define     TS_PLL_CFG_REG2                                    (0xff634800 + (0x002 << 2))
+#define SEC_TS_PLL_CFG_REG2                                    (0xff634800 + (0x002 << 2))
+#define   P_TS_PLL_CFG_REG2                                    (volatile uint32_t *)(0xff634800 + (0x002 << 2))
+#define     TS_PLL_CFG_REG3                                    (0xff634800 + (0x003 << 2))
+#define SEC_TS_PLL_CFG_REG3                                    (0xff634800 + (0x003 << 2))
+#define   P_TS_PLL_CFG_REG3                                    (volatile uint32_t *)(0xff634800 + (0x003 << 2))
+#define     TS_PLL_CFG_REG4                                    (0xff634800 + (0x004 << 2))
+#define SEC_TS_PLL_CFG_REG4                                    (0xff634800 + (0x004 << 2))
+#define   P_TS_PLL_CFG_REG4                                    (volatile uint32_t *)(0xff634800 + (0x004 << 2))
+#define     TS_PLL_CFG_REG5                                    (0xff634800 + (0x005 << 2))
+#define SEC_TS_PLL_CFG_REG5                                    (0xff634800 + (0x005 << 2))
+#define   P_TS_PLL_CFG_REG5                                    (volatile uint32_t *)(0xff634800 + (0x005 << 2))
+#define     TS_PLL_CFG_REG6                                    (0xff634800 + (0x006 << 2))
+#define SEC_TS_PLL_CFG_REG6                                    (0xff634800 + (0x006 << 2))
+#define   P_TS_PLL_CFG_REG6                                    (volatile uint32_t *)(0xff634800 + (0x006 << 2))
+#define     TS_PLL_CFG_REG7                                    (0xff634800 + (0x007 << 2))
+#define SEC_TS_PLL_CFG_REG7                                    (0xff634800 + (0x007 << 2))
+#define   P_TS_PLL_CFG_REG7                                    (volatile uint32_t *)(0xff634800 + (0x007 << 2))
+#define     TS_PLL_STAT0                                       (0xff634800 + (0x010 << 2))
+#define SEC_TS_PLL_STAT0                                       (0xff634800 + (0x010 << 2))
+#define   P_TS_PLL_STAT0                                       (volatile uint32_t *)(0xff634800 + (0x010 << 2))
+#define     TS_PLL_STAT1                                       (0xff634800 + (0x011 << 2))
+#define SEC_TS_PLL_STAT1                                       (0xff634800 + (0x011 << 2))
+#define   P_TS_PLL_STAT1                                       (volatile uint32_t *)(0xff634800 + (0x011 << 2))
+#define     TS_PLL_STAT2                                       (0xff634800 + (0x012 << 2))
+#define SEC_TS_PLL_STAT2                                       (0xff634800 + (0x012 << 2))
+#define   P_TS_PLL_STAT2                                       (volatile uint32_t *)(0xff634800 + (0x012 << 2))
+#define     TS_PLL_STAT3                                       (0xff634800 + (0x013 << 2))
+#define SEC_TS_PLL_STAT3                                       (0xff634800 + (0x013 << 2))
+#define   P_TS_PLL_STAT3                                       (volatile uint32_t *)(0xff634800 + (0x013 << 2))
+#define     TS_PLL_STAT4                                       (0xff634800 + (0x014 << 2))
+#define SEC_TS_PLL_STAT4                                       (0xff634800 + (0x014 << 2))
+#define   P_TS_PLL_STAT4                                       (volatile uint32_t *)(0xff634800 + (0x014 << 2))
+#define     TS_PLL_STAT5                                       (0xff634800 + (0x015 << 2))
+#define SEC_TS_PLL_STAT5                                       (0xff634800 + (0x015 << 2))
+#define   P_TS_PLL_STAT5                                       (volatile uint32_t *)(0xff634800 + (0x015 << 2))
+#define     TS_PLL_STAT6                                       (0xff634800 + (0x016 << 2))
+#define SEC_TS_PLL_STAT6                                       (0xff634800 + (0x016 << 2))
+#define   P_TS_PLL_STAT6                                       (volatile uint32_t *)(0xff634800 + (0x016 << 2))
+#define     TS_PLL_STAT7                                       (0xff634800 + (0x017 << 2))
+#define SEC_TS_PLL_STAT7                                       (0xff634800 + (0x017 << 2))
+#define   P_TS_PLL_STAT7                                       (volatile uint32_t *)(0xff634800 + (0x017 << 2))
+#define     TS_PLL_STAT8                                       (0xff634800 + (0x018 << 2))
+#define SEC_TS_PLL_STAT8                                       (0xff634800 + (0x018 << 2))
+#define   P_TS_PLL_STAT8                                       (volatile uint32_t *)(0xff634800 + (0x018 << 2))
+#define     TS_PLL_STAT9                                       (0xff634800 + (0x019 << 2))
+#define SEC_TS_PLL_STAT9                                       (0xff634800 + (0x019 << 2))
+#define   P_TS_PLL_STAT9                                       (volatile uint32_t *)(0xff634800 + (0x019 << 2))
+//========================================================================
+//  Temp sensor DDR
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF634C00
+//  APB4_DECODER_SECURE_BASE         32'hFF634C00
+#define     TS_DDR_CFG_REG1                                    (0xff634c00 + (0x001 << 2))
+#define SEC_TS_DDR_CFG_REG1                                    (0xff634c00 + (0x001 << 2))
+#define   P_TS_DDR_CFG_REG1                                    (volatile uint32_t *)(0xff634c00 + (0x001 << 2))
+#define     TS_DDR_CFG_REG2                                    (0xff634c00 + (0x002 << 2))
+#define SEC_TS_DDR_CFG_REG2                                    (0xff634c00 + (0x002 << 2))
+#define   P_TS_DDR_CFG_REG2                                    (volatile uint32_t *)(0xff634c00 + (0x002 << 2))
+#define     TS_DDR_CFG_REG3                                    (0xff634c00 + (0x003 << 2))
+#define SEC_TS_DDR_CFG_REG3                                    (0xff634c00 + (0x003 << 2))
+#define   P_TS_DDR_CFG_REG3                                    (volatile uint32_t *)(0xff634c00 + (0x003 << 2))
+#define     TS_DDR_CFG_REG4                                    (0xff634c00 + (0x004 << 2))
+#define SEC_TS_DDR_CFG_REG4                                    (0xff634c00 + (0x004 << 2))
+#define   P_TS_DDR_CFG_REG4                                    (volatile uint32_t *)(0xff634c00 + (0x004 << 2))
+#define     TS_DDR_CFG_REG5                                    (0xff634c00 + (0x005 << 2))
+#define SEC_TS_DDR_CFG_REG5                                    (0xff634c00 + (0x005 << 2))
+#define   P_TS_DDR_CFG_REG5                                    (volatile uint32_t *)(0xff634c00 + (0x005 << 2))
+#define     TS_DDR_CFG_REG6                                    (0xff634c00 + (0x006 << 2))
+#define SEC_TS_DDR_CFG_REG6                                    (0xff634c00 + (0x006 << 2))
+#define   P_TS_DDR_CFG_REG6                                    (volatile uint32_t *)(0xff634c00 + (0x006 << 2))
+#define     TS_DDR_CFG_REG7                                    (0xff634c00 + (0x007 << 2))
+#define SEC_TS_DDR_CFG_REG7                                    (0xff634c00 + (0x007 << 2))
+#define   P_TS_DDR_CFG_REG7                                    (volatile uint32_t *)(0xff634c00 + (0x007 << 2))
+#define     TS_DDR_STAT0                                       (0xff634c00 + (0x010 << 2))
+#define SEC_TS_DDR_STAT0                                       (0xff634c00 + (0x010 << 2))
+#define   P_TS_DDR_STAT0                                       (volatile uint32_t *)(0xff634c00 + (0x010 << 2))
+#define     TS_DDR_STAT1                                       (0xff634c00 + (0x011 << 2))
+#define SEC_TS_DDR_STAT1                                       (0xff634c00 + (0x011 << 2))
+#define   P_TS_DDR_STAT1                                       (volatile uint32_t *)(0xff634c00 + (0x011 << 2))
+#define     TS_DDR_STAT2                                       (0xff634c00 + (0x012 << 2))
+#define SEC_TS_DDR_STAT2                                       (0xff634c00 + (0x012 << 2))
+#define   P_TS_DDR_STAT2                                       (volatile uint32_t *)(0xff634c00 + (0x012 << 2))
+#define     TS_DDR_STAT3                                       (0xff634c00 + (0x013 << 2))
+#define SEC_TS_DDR_STAT3                                       (0xff634c00 + (0x013 << 2))
+#define   P_TS_DDR_STAT3                                       (volatile uint32_t *)(0xff634c00 + (0x013 << 2))
+#define     TS_DDR_STAT4                                       (0xff634c00 + (0x014 << 2))
+#define SEC_TS_DDR_STAT4                                       (0xff634c00 + (0x014 << 2))
+#define   P_TS_DDR_STAT4                                       (volatile uint32_t *)(0xff634c00 + (0x014 << 2))
+#define     TS_DDR_STAT5                                       (0xff634c00 + (0x015 << 2))
+#define SEC_TS_DDR_STAT5                                       (0xff634c00 + (0x015 << 2))
+#define   P_TS_DDR_STAT5                                       (volatile uint32_t *)(0xff634c00 + (0x015 << 2))
+#define     TS_DDR_STAT6                                       (0xff634c00 + (0x016 << 2))
+#define SEC_TS_DDR_STAT6                                       (0xff634c00 + (0x016 << 2))
+#define   P_TS_DDR_STAT6                                       (volatile uint32_t *)(0xff634c00 + (0x016 << 2))
+#define     TS_DDR_STAT7                                       (0xff634c00 + (0x017 << 2))
+#define SEC_TS_DDR_STAT7                                       (0xff634c00 + (0x017 << 2))
+#define   P_TS_DDR_STAT7                                       (volatile uint32_t *)(0xff634c00 + (0x017 << 2))
+#define     TS_DDR_STAT8                                       (0xff634c00 + (0x018 << 2))
+#define SEC_TS_DDR_STAT8                                       (0xff634c00 + (0x018 << 2))
+#define   P_TS_DDR_STAT8                                       (volatile uint32_t *)(0xff634c00 + (0x018 << 2))
+#define     TS_DDR_STAT9                                       (0xff634c00 + (0x019 << 2))
+#define SEC_TS_DDR_STAT9                                       (0xff634c00 + (0x019 << 2))
+#define   P_TS_DDR_STAT9                                       (volatile uint32_t *)(0xff634c00 + (0x019 << 2))
+//========================================================================
+//  Temp sensor GPU
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF635000
+//  APB4_DECODER_SECURE_BASE         32'hFF635000
+//`define TS_GPU_CFG_REG1                         8'h01
+//`define TS_GPU_CFG_REG2                         8'h02
+//`define TS_GPU_CFG_REG3                         8'h03
+//`define TS_GPU_CFG_REG4                         8'h04
+//`define TS_GPU_CFG_REG5                         8'h05
+//`define TS_GPU_CFG_REG6                         8'h06
+//`define TS_GPU_CFG_REG7                         8'h07
+//`define TS_GPU_STAT0                            8'h10
+//`define TS_GPU_STAT1                            8'h11
+//`define TS_GPU_STAT2                            8'h12
+//`define TS_GPU_STAT3                            8'h13
+//`define TS_GPU_STAT4                            8'h14
+//`define TS_GPU_STAT5                            8'h15
+//`define TS_GPU_STAT6                            8'h16
+//`define TS_GPU_STAT7                            8'h17
+//`define TS_GPU_STAT8                            8'h18
+//`define TS_GPU_STAT9                            8'h19
+//========================================================================
+//  RNG
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF634000
+//  APB4_DECODER_SECURE_BASE         32'hFF634000
+//========================================================================
+//  ACODEC
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF632000
+//  APB4_DECODER_SECURE_BASE         32'hFF632000
+#define     ACODEC_0                                           (0xff632000 + (0x000 << 2))
+#define SEC_ACODEC_0                                           (0xff632000 + (0x000 << 2))
+#define   P_ACODEC_0                                           (volatile uint32_t *)(0xff632000 + (0x000 << 2))
+#define     ACODEC_1                                           (0xff632000 + (0x001 << 2))
+#define SEC_ACODEC_1                                           (0xff632000 + (0x001 << 2))
+#define   P_ACODEC_1                                           (volatile uint32_t *)(0xff632000 + (0x001 << 2))
+#define     ACODEC_2                                           (0xff632000 + (0x002 << 2))
+#define SEC_ACODEC_2                                           (0xff632000 + (0x002 << 2))
+#define   P_ACODEC_2                                           (volatile uint32_t *)(0xff632000 + (0x002 << 2))
+#define     ACODEC_3                                           (0xff632000 + (0x003 << 2))
+#define SEC_ACODEC_3                                           (0xff632000 + (0x003 << 2))
+#define   P_ACODEC_3                                           (volatile uint32_t *)(0xff632000 + (0x003 << 2))
+#define     ACODEC_4                                           (0xff632000 + (0x004 << 2))
+#define SEC_ACODEC_4                                           (0xff632000 + (0x004 << 2))
+#define   P_ACODEC_4                                           (volatile uint32_t *)(0xff632000 + (0x004 << 2))
+#define     ACODEC_5                                           (0xff632000 + (0x005 << 2))
+#define SEC_ACODEC_5                                           (0xff632000 + (0x005 << 2))
+#define   P_ACODEC_5                                           (volatile uint32_t *)(0xff632000 + (0x005 << 2))
+#define     ACODEC_6                                           (0xff632000 + (0x006 << 2))
+#define SEC_ACODEC_6                                           (0xff632000 + (0x006 << 2))
+#define   P_ACODEC_6                                           (volatile uint32_t *)(0xff632000 + (0x006 << 2))
+#define     ACODEC_7                                           (0xff632000 + (0x007 << 2))
+#define SEC_ACODEC_7                                           (0xff632000 + (0x007 << 2))
+#define   P_ACODEC_7                                           (volatile uint32_t *)(0xff632000 + (0x007 << 2))
+//========================================================================
+//  AML USB PHY A
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF636000
+//  APB4_DECODER_SECURE_BASE         32'hFF636000
+#define     AMLUSB_A0                                          (0xff636000 + (0x000 << 2))
+#define SEC_AMLUSB_A0                                          (0xff636000 + (0x000 << 2))
+#define   P_AMLUSB_A0                                          (volatile uint32_t *)(0xff636000 + (0x000 << 2))
+#define     AMLUSB_A1                                          (0xff636000 + (0x001 << 2))
+#define SEC_AMLUSB_A1                                          (0xff636000 + (0x001 << 2))
+#define   P_AMLUSB_A1                                          (volatile uint32_t *)(0xff636000 + (0x001 << 2))
+#define     AMLUSB_A2                                          (0xff636000 + (0x002 << 2))
+#define SEC_AMLUSB_A2                                          (0xff636000 + (0x002 << 2))
+#define   P_AMLUSB_A2                                          (volatile uint32_t *)(0xff636000 + (0x002 << 2))
+#define     AMLUSB_A3                                          (0xff636000 + (0x003 << 2))
+#define SEC_AMLUSB_A3                                          (0xff636000 + (0x003 << 2))
+#define   P_AMLUSB_A3                                          (volatile uint32_t *)(0xff636000 + (0x003 << 2))
+#define     AMLUSB_A4                                          (0xff636000 + (0x004 << 2))
+#define SEC_AMLUSB_A4                                          (0xff636000 + (0x004 << 2))
+#define   P_AMLUSB_A4                                          (volatile uint32_t *)(0xff636000 + (0x004 << 2))
+#define     AMLUSB_A5                                          (0xff636000 + (0x005 << 2))
+#define SEC_AMLUSB_A5                                          (0xff636000 + (0x005 << 2))
+#define   P_AMLUSB_A5                                          (volatile uint32_t *)(0xff636000 + (0x005 << 2))
+#define     AMLUSB_A6                                          (0xff636000 + (0x006 << 2))
+#define SEC_AMLUSB_A6                                          (0xff636000 + (0x006 << 2))
+#define   P_AMLUSB_A6                                          (volatile uint32_t *)(0xff636000 + (0x006 << 2))
+#define     AMLUSB_A7                                          (0xff636000 + (0x007 << 2))
+#define SEC_AMLUSB_A7                                          (0xff636000 + (0x007 << 2))
+#define   P_AMLUSB_A7                                          (volatile uint32_t *)(0xff636000 + (0x007 << 2))
+#define     AMLUSB_A8                                          (0xff636000 + (0x008 << 2))
+#define SEC_AMLUSB_A8                                          (0xff636000 + (0x008 << 2))
+#define   P_AMLUSB_A8                                          (volatile uint32_t *)(0xff636000 + (0x008 << 2))
+#define     AMLUSB_A9                                          (0xff636000 + (0x009 << 2))
+#define SEC_AMLUSB_A9                                          (0xff636000 + (0x009 << 2))
+#define   P_AMLUSB_A9                                          (volatile uint32_t *)(0xff636000 + (0x009 << 2))
+#define     AMLUSB_A10                                         (0xff636000 + (0x00a << 2))
+#define SEC_AMLUSB_A10                                         (0xff636000 + (0x00a << 2))
+#define   P_AMLUSB_A10                                         (volatile uint32_t *)(0xff636000 + (0x00a << 2))
+#define     AMLUSB_A11                                         (0xff636000 + (0x00b << 2))
+#define SEC_AMLUSB_A11                                         (0xff636000 + (0x00b << 2))
+#define   P_AMLUSB_A11                                         (volatile uint32_t *)(0xff636000 + (0x00b << 2))
+#define     AMLUSB_A12                                         (0xff636000 + (0x00c << 2))
+#define SEC_AMLUSB_A12                                         (0xff636000 + (0x00c << 2))
+#define   P_AMLUSB_A12                                         (volatile uint32_t *)(0xff636000 + (0x00c << 2))
+#define     AMLUSB_A13                                         (0xff636000 + (0x00d << 2))
+#define SEC_AMLUSB_A13                                         (0xff636000 + (0x00d << 2))
+#define   P_AMLUSB_A13                                         (volatile uint32_t *)(0xff636000 + (0x00d << 2))
+#define     AMLUSB_A14                                         (0xff636000 + (0x00e << 2))
+#define SEC_AMLUSB_A14                                         (0xff636000 + (0x00e << 2))
+#define   P_AMLUSB_A14                                         (volatile uint32_t *)(0xff636000 + (0x00e << 2))
+#define     AMLUSB_A15                                         (0xff636000 + (0x00f << 2))
+#define SEC_AMLUSB_A15                                         (0xff636000 + (0x00f << 2))
+#define   P_AMLUSB_A15                                         (volatile uint32_t *)(0xff636000 + (0x00f << 2))
+#define     AMLUSB_A16                                         (0xff636000 + (0x010 << 2))
+#define SEC_AMLUSB_A16                                         (0xff636000 + (0x010 << 2))
+#define   P_AMLUSB_A16                                         (volatile uint32_t *)(0xff636000 + (0x010 << 2))
+#define     AMLUSB_A17                                         (0xff636000 + (0x011 << 2))
+#define SEC_AMLUSB_A17                                         (0xff636000 + (0x011 << 2))
+#define   P_AMLUSB_A17                                         (volatile uint32_t *)(0xff636000 + (0x011 << 2))
+#define     AMLUSB_A18                                         (0xff636000 + (0x012 << 2))
+#define SEC_AMLUSB_A18                                         (0xff636000 + (0x012 << 2))
+#define   P_AMLUSB_A18                                         (volatile uint32_t *)(0xff636000 + (0x012 << 2))
+#define     AMLUSB_A19                                         (0xff636000 + (0x013 << 2))
+#define SEC_AMLUSB_A19                                         (0xff636000 + (0x013 << 2))
+#define   P_AMLUSB_A19                                         (volatile uint32_t *)(0xff636000 + (0x013 << 2))
+#define     AMLUSB_A20                                         (0xff636000 + (0x014 << 2))
+#define SEC_AMLUSB_A20                                         (0xff636000 + (0x014 << 2))
+#define   P_AMLUSB_A20                                         (volatile uint32_t *)(0xff636000 + (0x014 << 2))
+#define     AMLUSB_A21                                         (0xff636000 + (0x015 << 2))
+#define SEC_AMLUSB_A21                                         (0xff636000 + (0x015 << 2))
+#define   P_AMLUSB_A21                                         (volatile uint32_t *)(0xff636000 + (0x015 << 2))
+#define     AMLUSB_A22                                         (0xff636000 + (0x016 << 2))
+#define SEC_AMLUSB_A22                                         (0xff636000 + (0x016 << 2))
+#define   P_AMLUSB_A22                                         (volatile uint32_t *)(0xff636000 + (0x016 << 2))
+#define     AMLUSB_A23                                         (0xff636000 + (0x017 << 2))
+#define SEC_AMLUSB_A23                                         (0xff636000 + (0x017 << 2))
+#define   P_AMLUSB_A23                                         (volatile uint32_t *)(0xff636000 + (0x017 << 2))
+#define     AMLUSB_A24                                         (0xff636000 + (0x018 << 2))
+#define SEC_AMLUSB_A24                                         (0xff636000 + (0x018 << 2))
+#define   P_AMLUSB_A24                                         (volatile uint32_t *)(0xff636000 + (0x018 << 2))
+#define     AMLUSB_A25                                         (0xff636000 + (0x019 << 2))
+#define SEC_AMLUSB_A25                                         (0xff636000 + (0x019 << 2))
+#define   P_AMLUSB_A25                                         (volatile uint32_t *)(0xff636000 + (0x019 << 2))
+#define     AMLUSB_A26                                         (0xff636000 + (0x01a << 2))
+#define SEC_AMLUSB_A26                                         (0xff636000 + (0x01a << 2))
+#define   P_AMLUSB_A26                                         (volatile uint32_t *)(0xff636000 + (0x01a << 2))
+#define     AMLUSB_A27                                         (0xff636000 + (0x01b << 2))
+#define SEC_AMLUSB_A27                                         (0xff636000 + (0x01b << 2))
+#define   P_AMLUSB_A27                                         (volatile uint32_t *)(0xff636000 + (0x01b << 2))
+#define     AMLUSB_A28                                         (0xff636000 + (0x01c << 2))
+#define SEC_AMLUSB_A28                                         (0xff636000 + (0x01c << 2))
+#define   P_AMLUSB_A28                                         (volatile uint32_t *)(0xff636000 + (0x01c << 2))
+#define     AMLUSB_A29                                         (0xff636000 + (0x01d << 2))
+#define SEC_AMLUSB_A29                                         (0xff636000 + (0x01d << 2))
+#define   P_AMLUSB_A29                                         (volatile uint32_t *)(0xff636000 + (0x01d << 2))
+#define     AMLUSB_A30                                         (0xff636000 + (0x01e << 2))
+#define SEC_AMLUSB_A30                                         (0xff636000 + (0x01e << 2))
+#define   P_AMLUSB_A30                                         (volatile uint32_t *)(0xff636000 + (0x01e << 2))
+#define     AMLUSB_A31                                         (0xff636000 + (0x01f << 2))
+#define SEC_AMLUSB_A31                                         (0xff636000 + (0x01f << 2))
+#define   P_AMLUSB_A31                                         (volatile uint32_t *)(0xff636000 + (0x01f << 2))
+//========================================================================
+//  AML USB PHY B
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF63A000
+//  APB4_DECODER_SECURE_BASE         32'hFF63A000
+#define     AMLUSB_B0                                          (0xff63a000 + (0x000 << 2))
+#define SEC_AMLUSB_B0                                          (0xff63a000 + (0x000 << 2))
+#define   P_AMLUSB_B0                                          (volatile uint32_t *)(0xff63a000 + (0x000 << 2))
+#define     AMLUSB_B1                                          (0xff63a000 + (0x001 << 2))
+#define SEC_AMLUSB_B1                                          (0xff63a000 + (0x001 << 2))
+#define   P_AMLUSB_B1                                          (volatile uint32_t *)(0xff63a000 + (0x001 << 2))
+#define     AMLUSB_B2                                          (0xff63a000 + (0x002 << 2))
+#define SEC_AMLUSB_B2                                          (0xff63a000 + (0x002 << 2))
+#define   P_AMLUSB_B2                                          (volatile uint32_t *)(0xff63a000 + (0x002 << 2))
+#define     AMLUSB_B3                                          (0xff63a000 + (0x003 << 2))
+#define SEC_AMLUSB_B3                                          (0xff63a000 + (0x003 << 2))
+#define   P_AMLUSB_B3                                          (volatile uint32_t *)(0xff63a000 + (0x003 << 2))
+#define     AMLUSB_B4                                          (0xff63a000 + (0x004 << 2))
+#define SEC_AMLUSB_B4                                          (0xff63a000 + (0x004 << 2))
+#define   P_AMLUSB_B4                                          (volatile uint32_t *)(0xff63a000 + (0x004 << 2))
+#define     AMLUSB_B5                                          (0xff63a000 + (0x005 << 2))
+#define SEC_AMLUSB_B5                                          (0xff63a000 + (0x005 << 2))
+#define   P_AMLUSB_B5                                          (volatile uint32_t *)(0xff63a000 + (0x005 << 2))
+#define     AMLUSB_B6                                          (0xff63a000 + (0x006 << 2))
+#define SEC_AMLUSB_B6                                          (0xff63a000 + (0x006 << 2))
+#define   P_AMLUSB_B6                                          (volatile uint32_t *)(0xff63a000 + (0x006 << 2))
+#define     AMLUSB_B7                                          (0xff63a000 + (0x007 << 2))
+#define SEC_AMLUSB_B7                                          (0xff63a000 + (0x007 << 2))
+#define   P_AMLUSB_B7                                          (volatile uint32_t *)(0xff63a000 + (0x007 << 2))
+#define     AMLUSB_B8                                          (0xff63a000 + (0x008 << 2))
+#define SEC_AMLUSB_B8                                          (0xff63a000 + (0x008 << 2))
+#define   P_AMLUSB_B8                                          (volatile uint32_t *)(0xff63a000 + (0x008 << 2))
+#define     AMLUSB_B9                                          (0xff63a000 + (0x009 << 2))
+#define SEC_AMLUSB_B9                                          (0xff63a000 + (0x009 << 2))
+#define   P_AMLUSB_B9                                          (volatile uint32_t *)(0xff63a000 + (0x009 << 2))
+#define     AMLUSB_B10                                         (0xff63a000 + (0x00a << 2))
+#define SEC_AMLUSB_B10                                         (0xff63a000 + (0x00a << 2))
+#define   P_AMLUSB_B10                                         (volatile uint32_t *)(0xff63a000 + (0x00a << 2))
+#define     AMLUSB_B11                                         (0xff63a000 + (0x00b << 2))
+#define SEC_AMLUSB_B11                                         (0xff63a000 + (0x00b << 2))
+#define   P_AMLUSB_B11                                         (volatile uint32_t *)(0xff63a000 + (0x00b << 2))
+#define     AMLUSB_B12                                         (0xff63a000 + (0x00c << 2))
+#define SEC_AMLUSB_B12                                         (0xff63a000 + (0x00c << 2))
+#define   P_AMLUSB_B12                                         (volatile uint32_t *)(0xff63a000 + (0x00c << 2))
+#define     AMLUSB_B13                                         (0xff63a000 + (0x00d << 2))
+#define SEC_AMLUSB_B13                                         (0xff63a000 + (0x00d << 2))
+#define   P_AMLUSB_B13                                         (volatile uint32_t *)(0xff63a000 + (0x00d << 2))
+#define     AMLUSB_B14                                         (0xff63a000 + (0x00e << 2))
+#define SEC_AMLUSB_B14                                         (0xff63a000 + (0x00e << 2))
+#define   P_AMLUSB_B14                                         (volatile uint32_t *)(0xff63a000 + (0x00e << 2))
+#define     AMLUSB_B15                                         (0xff63a000 + (0x00f << 2))
+#define SEC_AMLUSB_B15                                         (0xff63a000 + (0x00f << 2))
+#define   P_AMLUSB_B15                                         (volatile uint32_t *)(0xff63a000 + (0x00f << 2))
+#define     AMLUSB_B16                                         (0xff63a000 + (0x010 << 2))
+#define SEC_AMLUSB_B16                                         (0xff63a000 + (0x010 << 2))
+#define   P_AMLUSB_B16                                         (volatile uint32_t *)(0xff63a000 + (0x010 << 2))
+#define     AMLUSB_B17                                         (0xff63a000 + (0x011 << 2))
+#define SEC_AMLUSB_B17                                         (0xff63a000 + (0x011 << 2))
+#define   P_AMLUSB_B17                                         (volatile uint32_t *)(0xff63a000 + (0x011 << 2))
+#define     AMLUSB_B18                                         (0xff63a000 + (0x012 << 2))
+#define SEC_AMLUSB_B18                                         (0xff63a000 + (0x012 << 2))
+#define   P_AMLUSB_B18                                         (volatile uint32_t *)(0xff63a000 + (0x012 << 2))
+#define     AMLUSB_B19                                         (0xff63a000 + (0x013 << 2))
+#define SEC_AMLUSB_B19                                         (0xff63a000 + (0x013 << 2))
+#define   P_AMLUSB_B19                                         (volatile uint32_t *)(0xff63a000 + (0x013 << 2))
+#define     AMLUSB_B20                                         (0xff63a000 + (0x014 << 2))
+#define SEC_AMLUSB_B20                                         (0xff63a000 + (0x014 << 2))
+#define   P_AMLUSB_B20                                         (volatile uint32_t *)(0xff63a000 + (0x014 << 2))
+#define     AMLUSB_B21                                         (0xff63a000 + (0x015 << 2))
+#define SEC_AMLUSB_B21                                         (0xff63a000 + (0x015 << 2))
+#define   P_AMLUSB_B21                                         (volatile uint32_t *)(0xff63a000 + (0x015 << 2))
+#define     AMLUSB_B22                                         (0xff63a000 + (0x016 << 2))
+#define SEC_AMLUSB_B22                                         (0xff63a000 + (0x016 << 2))
+#define   P_AMLUSB_B22                                         (volatile uint32_t *)(0xff63a000 + (0x016 << 2))
+#define     AMLUSB_B23                                         (0xff63a000 + (0x017 << 2))
+#define SEC_AMLUSB_B23                                         (0xff63a000 + (0x017 << 2))
+#define   P_AMLUSB_B23                                         (volatile uint32_t *)(0xff63a000 + (0x017 << 2))
+#define     AMLUSB_B24                                         (0xff63a000 + (0x018 << 2))
+#define SEC_AMLUSB_B24                                         (0xff63a000 + (0x018 << 2))
+#define   P_AMLUSB_B24                                         (volatile uint32_t *)(0xff63a000 + (0x018 << 2))
+#define     AMLUSB_B25                                         (0xff63a000 + (0x019 << 2))
+#define SEC_AMLUSB_B25                                         (0xff63a000 + (0x019 << 2))
+#define   P_AMLUSB_B25                                         (volatile uint32_t *)(0xff63a000 + (0x019 << 2))
+#define     AMLUSB_B26                                         (0xff63a000 + (0x01a << 2))
+#define SEC_AMLUSB_B26                                         (0xff63a000 + (0x01a << 2))
+#define   P_AMLUSB_B26                                         (volatile uint32_t *)(0xff63a000 + (0x01a << 2))
+#define     AMLUSB_B27                                         (0xff63a000 + (0x01b << 2))
+#define SEC_AMLUSB_B27                                         (0xff63a000 + (0x01b << 2))
+#define   P_AMLUSB_B27                                         (volatile uint32_t *)(0xff63a000 + (0x01b << 2))
+#define     AMLUSB_B28                                         (0xff63a000 + (0x01c << 2))
+#define SEC_AMLUSB_B28                                         (0xff63a000 + (0x01c << 2))
+#define   P_AMLUSB_B28                                         (volatile uint32_t *)(0xff63a000 + (0x01c << 2))
+#define     AMLUSB_B29                                         (0xff63a000 + (0x01d << 2))
+#define SEC_AMLUSB_B29                                         (0xff63a000 + (0x01d << 2))
+#define   P_AMLUSB_B29                                         (volatile uint32_t *)(0xff63a000 + (0x01d << 2))
+#define     AMLUSB_B30                                         (0xff63a000 + (0x01e << 2))
+#define SEC_AMLUSB_B30                                         (0xff63a000 + (0x01e << 2))
+#define   P_AMLUSB_B30                                         (volatile uint32_t *)(0xff63a000 + (0x01e << 2))
+#define     AMLUSB_B31                                         (0xff63a000 + (0x01f << 2))
+#define SEC_AMLUSB_B31                                         (0xff63a000 + (0x01f << 2))
+#define   P_AMLUSB_B31                                         (volatile uint32_t *)(0xff63a000 + (0x01f << 2))
+//========================================================================
+//  PERIPHS
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF634400
+//  APB4_DECODER_SECURE_BASE         32'hFF634400
+// The following are handled by $periphs/rtl/periphs_reg.v
+//`define PREG_CTLREG0_ADDR                       8'h00
+// ----------------------------
+// ----------------------------
+//`define PREG_JTAG_GPIO_ADDR                     8'h0b   // DWORD base address (0xc120002c >> 2)
+// ----------------------------
+// Pre-defined GPIO addresses
+// ----------------------------
+#define     PREG_PAD_GPIO0_EN_N                                (0xff634400 + (0x010 << 2))
+#define SEC_PREG_PAD_GPIO0_EN_N                                (0xff634400 + (0x010 << 2))
+#define   P_PREG_PAD_GPIO0_EN_N                                (volatile uint32_t *)(0xff634400 + (0x010 << 2))
+#define     PREG_PAD_GPIO0_O                                   (0xff634400 + (0x011 << 2))
+#define SEC_PREG_PAD_GPIO0_O                                   (0xff634400 + (0x011 << 2))
+#define   P_PREG_PAD_GPIO0_O                                   (volatile uint32_t *)(0xff634400 + (0x011 << 2))
+#define     PREG_PAD_GPIO0_I                                   (0xff634400 + (0x012 << 2))
+#define SEC_PREG_PAD_GPIO0_I                                   (0xff634400 + (0x012 << 2))
+#define   P_PREG_PAD_GPIO0_I                                   (volatile uint32_t *)(0xff634400 + (0x012 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO1_EN_N                                (0xff634400 + (0x013 << 2))
+#define SEC_PREG_PAD_GPIO1_EN_N                                (0xff634400 + (0x013 << 2))
+#define   P_PREG_PAD_GPIO1_EN_N                                (volatile uint32_t *)(0xff634400 + (0x013 << 2))
+#define     PREG_PAD_GPIO1_O                                   (0xff634400 + (0x014 << 2))
+#define SEC_PREG_PAD_GPIO1_O                                   (0xff634400 + (0x014 << 2))
+#define   P_PREG_PAD_GPIO1_O                                   (volatile uint32_t *)(0xff634400 + (0x014 << 2))
+#define     PREG_PAD_GPIO1_I                                   (0xff634400 + (0x015 << 2))
+#define SEC_PREG_PAD_GPIO1_I                                   (0xff634400 + (0x015 << 2))
+#define   P_PREG_PAD_GPIO1_I                                   (volatile uint32_t *)(0xff634400 + (0x015 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO2_EN_N                                (0xff634400 + (0x016 << 2))
+#define SEC_PREG_PAD_GPIO2_EN_N                                (0xff634400 + (0x016 << 2))
+#define   P_PREG_PAD_GPIO2_EN_N                                (volatile uint32_t *)(0xff634400 + (0x016 << 2))
+#define     PREG_PAD_GPIO2_O                                   (0xff634400 + (0x017 << 2))
+#define SEC_PREG_PAD_GPIO2_O                                   (0xff634400 + (0x017 << 2))
+#define   P_PREG_PAD_GPIO2_O                                   (volatile uint32_t *)(0xff634400 + (0x017 << 2))
+#define     PREG_PAD_GPIO2_I                                   (0xff634400 + (0x018 << 2))
+#define SEC_PREG_PAD_GPIO2_I                                   (0xff634400 + (0x018 << 2))
+#define   P_PREG_PAD_GPIO2_I                                   (volatile uint32_t *)(0xff634400 + (0x018 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO3_EN_N                                (0xff634400 + (0x019 << 2))
+#define SEC_PREG_PAD_GPIO3_EN_N                                (0xff634400 + (0x019 << 2))
+#define   P_PREG_PAD_GPIO3_EN_N                                (volatile uint32_t *)(0xff634400 + (0x019 << 2))
+#define     PREG_PAD_GPIO3_O                                   (0xff634400 + (0x01a << 2))
+#define SEC_PREG_PAD_GPIO3_O                                   (0xff634400 + (0x01a << 2))
+#define   P_PREG_PAD_GPIO3_O                                   (volatile uint32_t *)(0xff634400 + (0x01a << 2))
+#define     PREG_PAD_GPIO3_I                                   (0xff634400 + (0x01b << 2))
+#define SEC_PREG_PAD_GPIO3_I                                   (0xff634400 + (0x01b << 2))
+#define   P_PREG_PAD_GPIO3_I                                   (volatile uint32_t *)(0xff634400 + (0x01b << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO4_EN_N                                (0xff634400 + (0x01c << 2))
+#define SEC_PREG_PAD_GPIO4_EN_N                                (0xff634400 + (0x01c << 2))
+#define   P_PREG_PAD_GPIO4_EN_N                                (volatile uint32_t *)(0xff634400 + (0x01c << 2))
+#define     PREG_PAD_GPIO4_O                                   (0xff634400 + (0x01d << 2))
+#define SEC_PREG_PAD_GPIO4_O                                   (0xff634400 + (0x01d << 2))
+#define   P_PREG_PAD_GPIO4_O                                   (volatile uint32_t *)(0xff634400 + (0x01d << 2))
+#define     PREG_PAD_GPIO4_I                                   (0xff634400 + (0x01e << 2))
+#define SEC_PREG_PAD_GPIO4_I                                   (0xff634400 + (0x01e << 2))
+#define   P_PREG_PAD_GPIO4_I                                   (volatile uint32_t *)(0xff634400 + (0x01e << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO5_EN_N                                (0xff634400 + (0x020 << 2))
+#define SEC_PREG_PAD_GPIO5_EN_N                                (0xff634400 + (0x020 << 2))
+#define   P_PREG_PAD_GPIO5_EN_N                                (volatile uint32_t *)(0xff634400 + (0x020 << 2))
+#define     PREG_PAD_GPIO5_O                                   (0xff634400 + (0x021 << 2))
+#define SEC_PREG_PAD_GPIO5_O                                   (0xff634400 + (0x021 << 2))
+#define   P_PREG_PAD_GPIO5_O                                   (volatile uint32_t *)(0xff634400 + (0x021 << 2))
+#define     PREG_PAD_GPIO5_I                                   (0xff634400 + (0x022 << 2))
+#define SEC_PREG_PAD_GPIO5_I                                   (0xff634400 + (0x022 << 2))
+#define   P_PREG_PAD_GPIO5_I                                   (volatile uint32_t *)(0xff634400 + (0x022 << 2))
+// ----------------------------
+// ----------------------------
+// Pad conntrols
+// ----------------------------
+//`define PAD_PULL_UP_REG6                    8'h39
+#define     PAD_PULL_UP_REG0                                   (0xff634400 + (0x03a << 2))
+#define SEC_PAD_PULL_UP_REG0                                   (0xff634400 + (0x03a << 2))
+#define   P_PAD_PULL_UP_REG0                                   (volatile uint32_t *)(0xff634400 + (0x03a << 2))
+#define     PAD_PULL_UP_REG1                                   (0xff634400 + (0x03b << 2))
+#define SEC_PAD_PULL_UP_REG1                                   (0xff634400 + (0x03b << 2))
+#define   P_PAD_PULL_UP_REG1                                   (volatile uint32_t *)(0xff634400 + (0x03b << 2))
+#define     PAD_PULL_UP_REG2                                   (0xff634400 + (0x03c << 2))
+#define SEC_PAD_PULL_UP_REG2                                   (0xff634400 + (0x03c << 2))
+#define   P_PAD_PULL_UP_REG2                                   (volatile uint32_t *)(0xff634400 + (0x03c << 2))
+#define     PAD_PULL_UP_REG3                                   (0xff634400 + (0x03d << 2))
+#define SEC_PAD_PULL_UP_REG3                                   (0xff634400 + (0x03d << 2))
+#define   P_PAD_PULL_UP_REG3                                   (volatile uint32_t *)(0xff634400 + (0x03d << 2))
+#define     PAD_PULL_UP_REG4                                   (0xff634400 + (0x03e << 2))
+#define SEC_PAD_PULL_UP_REG4                                   (0xff634400 + (0x03e << 2))
+#define   P_PAD_PULL_UP_REG4                                   (volatile uint32_t *)(0xff634400 + (0x03e << 2))
+#define     PAD_PULL_UP_REG5                                   (0xff634400 + (0x03f << 2))
+#define SEC_PAD_PULL_UP_REG5                                   (0xff634400 + (0x03f << 2))
+#define   P_PAD_PULL_UP_REG5                                   (volatile uint32_t *)(0xff634400 + (0x03f << 2))
+// ----------------------------
+// Random (2)
+// ----------------------------
+//`define RAND64_ADDR0                        8'h40       // DWORD base address (0xc1200138 >> 2)
+//`define RAND64_ADDR1                        8'h41       // DWORD base address (0xc120013c >> 2)
+// ---------------------------
+// Ethernet (1)
+// ----------------------------
+//`define PREG_ETHERNET_ADDR0                 8'h42       // DWORD base address (0xc1200290 >> 2)
+// ---------------------------
+// AM_ANALOG_TOP
+// ----------------------------
+//`define PREG_AM_ANALOG_ADDR                 8'h43       // DWORD base address (0xc1200298 >> 2)
+// ---------------------------
+// Mali55 (1)
+// ----------------------------
+//`define PREG_MALI_BYTE_CNTL                 8'h44
+// ---------------------------
+// WIFI (1)
+// ----------------------------
+//`define PREG_WIFI_CNTL                      8'h45
+#define     PAD_PULL_UP_EN_REG0                                (0xff634400 + (0x048 << 2))
+#define SEC_PAD_PULL_UP_EN_REG0                                (0xff634400 + (0x048 << 2))
+#define   P_PAD_PULL_UP_EN_REG0                                (volatile uint32_t *)(0xff634400 + (0x048 << 2))
+#define     PAD_PULL_UP_EN_REG1                                (0xff634400 + (0x049 << 2))
+#define SEC_PAD_PULL_UP_EN_REG1                                (0xff634400 + (0x049 << 2))
+#define   P_PAD_PULL_UP_EN_REG1                                (volatile uint32_t *)(0xff634400 + (0x049 << 2))
+#define     PAD_PULL_UP_EN_REG2                                (0xff634400 + (0x04a << 2))
+#define SEC_PAD_PULL_UP_EN_REG2                                (0xff634400 + (0x04a << 2))
+#define   P_PAD_PULL_UP_EN_REG2                                (volatile uint32_t *)(0xff634400 + (0x04a << 2))
+#define     PAD_PULL_UP_EN_REG3                                (0xff634400 + (0x04b << 2))
+#define SEC_PAD_PULL_UP_EN_REG3                                (0xff634400 + (0x04b << 2))
+#define   P_PAD_PULL_UP_EN_REG3                                (volatile uint32_t *)(0xff634400 + (0x04b << 2))
+#define     PAD_PULL_UP_EN_REG4                                (0xff634400 + (0x04c << 2))
+#define SEC_PAD_PULL_UP_EN_REG4                                (0xff634400 + (0x04c << 2))
+#define   P_PAD_PULL_UP_EN_REG4                                (volatile uint32_t *)(0xff634400 + (0x04c << 2))
+#define     PAD_PULL_UP_EN_REG5                                (0xff634400 + (0x04d << 2))
+#define SEC_PAD_PULL_UP_EN_REG5                                (0xff634400 + (0x04d << 2))
+#define   P_PAD_PULL_UP_EN_REG5                                (volatile uint32_t *)(0xff634400 + (0x04d << 2))
+//`define PAD_PULL_UP_EN_REG6                 8'h4e
+// ---------------------------
+#define     PREG_ETH_REG0                                      (0xff634400 + (0x050 << 2))
+#define SEC_PREG_ETH_REG0                                      (0xff634400 + (0x050 << 2))
+#define   P_PREG_ETH_REG0                                      (volatile uint32_t *)(0xff634400 + (0x050 << 2))
+#define     PREG_ETH_REG1                                      (0xff634400 + (0x051 << 2))
+#define SEC_PREG_ETH_REG1                                      (0xff634400 + (0x051 << 2))
+#define   P_PREG_ETH_REG1                                      (volatile uint32_t *)(0xff634400 + (0x051 << 2))
+#define     PREG_NAND_CFG_KEY0                                 (0xff634400 + (0x052 << 2))
+#define SEC_PREG_NAND_CFG_KEY0                                 (0xff634400 + (0x052 << 2))
+#define   P_PREG_NAND_CFG_KEY0                                 (volatile uint32_t *)(0xff634400 + (0x052 << 2))
+#define     PREG_NAND_CFG_KEY1                                 (0xff634400 + (0x053 << 2))
+#define SEC_PREG_NAND_CFG_KEY1                                 (0xff634400 + (0x053 << 2))
+#define   P_PREG_NAND_CFG_KEY1                                 (volatile uint32_t *)(0xff634400 + (0x053 << 2))
+#define     PREG_VPU_SECURE0                                   (0xff634400 + (0x054 << 2))
+#define SEC_PREG_VPU_SECURE0                                   (0xff634400 + (0x054 << 2))
+#define   P_PREG_VPU_SECURE0                                   (volatile uint32_t *)(0xff634400 + (0x054 << 2))
+#define     PREG_VPU_SECURE1                                   (0xff634400 + (0x055 << 2))
+#define SEC_PREG_VPU_SECURE1                                   (0xff634400 + (0x055 << 2))
+#define   P_PREG_VPU_SECURE1                                   (volatile uint32_t *)(0xff634400 + (0x055 << 2))
+#define     PREG_ETH_REG2                                      (0xff634400 + (0x056 << 2))
+#define SEC_PREG_ETH_REG2                                      (0xff634400 + (0x056 << 2))
+#define   P_PREG_ETH_REG2                                      (volatile uint32_t *)(0xff634400 + (0x056 << 2))
+#define     PREG_ETH_REG3                                      (0xff634400 + (0x057 << 2))
+#define SEC_PREG_ETH_REG3                                      (0xff634400 + (0x057 << 2))
+#define   P_PREG_ETH_REG3                                      (volatile uint32_t *)(0xff634400 + (0x057 << 2))
+#define     PREG_ETH_REG4                                      (0xff634400 + (0x058 << 2))
+#define SEC_PREG_ETH_REG4                                      (0xff634400 + (0x058 << 2))
+#define   P_PREG_ETH_REG4                                      (volatile uint32_t *)(0xff634400 + (0x058 << 2))
+// ---------------------------
+// Generic production test
+// ----------------------------
+#define     PROD_TEST_REG0                                     (0xff634400 + (0x060 << 2))
+#define SEC_PROD_TEST_REG0                                     (0xff634400 + (0x060 << 2))
+#define   P_PROD_TEST_REG0                                     (volatile uint32_t *)(0xff634400 + (0x060 << 2))
+#define     PROD_TEST_REG1                                     (0xff634400 + (0x061 << 2))
+#define SEC_PROD_TEST_REG1                                     (0xff634400 + (0x061 << 2))
+#define   P_PROD_TEST_REG1                                     (volatile uint32_t *)(0xff634400 + (0x061 << 2))
+#define     PROD_TEST_REG2                                     (0xff634400 + (0x062 << 2))
+#define SEC_PROD_TEST_REG2                                     (0xff634400 + (0x062 << 2))
+#define   P_PROD_TEST_REG2                                     (volatile uint32_t *)(0xff634400 + (0x062 << 2))
+#define     PROD_TEST_REG3                                     (0xff634400 + (0x063 << 2))
+#define SEC_PROD_TEST_REG3                                     (0xff634400 + (0x063 << 2))
+#define   P_PROD_TEST_REG3                                     (volatile uint32_t *)(0xff634400 + (0x063 << 2))
+// am_analog_top
+// ----------------------------
+//`define METAL_REVISION                      8'h6a
+//`define ADC_TOP_MISC                        8'h6b
+//`define DPLL_TOP_MISC                       8'h6c
+//`define ANALOG_TOP_MISC                     8'h6d
+//`define AM_ANALOG_TOP_REG0                  8'h6e
+//`define AM_ANALOG_TOP_REG1                  8'h6f
+// ---------------------------
+// Sticky regs
+// ----------------------------
+#define     PREG_STICKY_REG0                                   (0xff634400 + (0x070 << 2))
+#define SEC_PREG_STICKY_REG0                                   (0xff634400 + (0x070 << 2))
+#define   P_PREG_STICKY_REG0                                   (volatile uint32_t *)(0xff634400 + (0x070 << 2))
+#define     PREG_STICKY_REG1                                   (0xff634400 + (0x071 << 2))
+#define SEC_PREG_STICKY_REG1                                   (0xff634400 + (0x071 << 2))
+#define   P_PREG_STICKY_REG1                                   (volatile uint32_t *)(0xff634400 + (0x071 << 2))
+#define     PREG_STICKY_REG2                                   (0xff634400 + (0x072 << 2))
+#define SEC_PREG_STICKY_REG2                                   (0xff634400 + (0x072 << 2))
+#define   P_PREG_STICKY_REG2                                   (volatile uint32_t *)(0xff634400 + (0x072 << 2))
+#define     PREG_STICKY_REG3                                   (0xff634400 + (0x073 << 2))
+#define SEC_PREG_STICKY_REG3                                   (0xff634400 + (0x073 << 2))
+#define   P_PREG_STICKY_REG3                                   (volatile uint32_t *)(0xff634400 + (0x073 << 2))
+#define     PREG_STICKY_REG4                                   (0xff634400 + (0x074 << 2))
+#define SEC_PREG_STICKY_REG4                                   (0xff634400 + (0x074 << 2))
+#define   P_PREG_STICKY_REG4                                   (volatile uint32_t *)(0xff634400 + (0x074 << 2))
+#define     PREG_STICKY_REG5                                   (0xff634400 + (0x075 << 2))
+#define SEC_PREG_STICKY_REG5                                   (0xff634400 + (0x075 << 2))
+#define   P_PREG_STICKY_REG5                                   (volatile uint32_t *)(0xff634400 + (0x075 << 2))
+#define     PREG_STICKY_REG6                                   (0xff634400 + (0x076 << 2))
+#define SEC_PREG_STICKY_REG6                                   (0xff634400 + (0x076 << 2))
+#define   P_PREG_STICKY_REG6                                   (volatile uint32_t *)(0xff634400 + (0x076 << 2))
+#define     PREG_STICKY_REG7                                   (0xff634400 + (0x077 << 2))
+#define SEC_PREG_STICKY_REG7                                   (0xff634400 + (0x077 << 2))
+#define   P_PREG_STICKY_REG7                                   (volatile uint32_t *)(0xff634400 + (0x077 << 2))
+#define     PREG_STICKY_REG8                                   (0xff634400 + (0x078 << 2))
+#define SEC_PREG_STICKY_REG8                                   (0xff634400 + (0x078 << 2))
+#define   P_PREG_STICKY_REG8                                   (volatile uint32_t *)(0xff634400 + (0x078 << 2))
+#define     PREG_STICKY_REG9                                   (0xff634400 + (0x079 << 2))
+#define SEC_PREG_STICKY_REG9                                   (0xff634400 + (0x079 << 2))
+#define   P_PREG_STICKY_REG9                                   (volatile uint32_t *)(0xff634400 + (0x079 << 2))
+//`define PREG_WRITE_ONCE_REG                 8'h7e
+// ---------------------------
+// AM Ring Oscillator
+// ----------------------------
+#define     AM_RING_OSC_REG0                                   (0xff634400 + (0x07f << 2))
+#define SEC_AM_RING_OSC_REG0                                   (0xff634400 + (0x07f << 2))
+#define   P_AM_RING_OSC_REG0                                   (volatile uint32_t *)(0xff634400 + (0x07f << 2))
+// Control whether to provide random number to HDMITX20
+//`define HDMITX20_RNDNUM                     8'h80
+// ---------------------------
+// Bus Monitoring
+// ----------------------------
+#define     BUS_MONITOR_CNTL                                   (0xff634400 + (0x081 << 2))
+#define SEC_BUS_MONITOR_CNTL                                   (0xff634400 + (0x081 << 2))
+#define   P_BUS_MONITOR_CNTL                                   (volatile uint32_t *)(0xff634400 + (0x081 << 2))
+#define     BUS_MON0_ADDR                                      (0xff634400 + (0x082 << 2))
+#define SEC_BUS_MON0_ADDR                                      (0xff634400 + (0x082 << 2))
+#define   P_BUS_MON0_ADDR                                      (volatile uint32_t *)(0xff634400 + (0x082 << 2))
+#define     BUS_MON0_DATA                                      (0xff634400 + (0x083 << 2))
+#define SEC_BUS_MON0_DATA                                      (0xff634400 + (0x083 << 2))
+#define   P_BUS_MON0_DATA                                      (volatile uint32_t *)(0xff634400 + (0x083 << 2))
+#define     BUS_MON0_DATA_MSK                                  (0xff634400 + (0x084 << 2))
+#define SEC_BUS_MON0_DATA_MSK                                  (0xff634400 + (0x084 << 2))
+#define   P_BUS_MON0_DATA_MSK                                  (volatile uint32_t *)(0xff634400 + (0x084 << 2))
+#define     BUS_MON1_ADDR                                      (0xff634400 + (0x085 << 2))
+#define SEC_BUS_MON1_ADDR                                      (0xff634400 + (0x085 << 2))
+#define   P_BUS_MON1_ADDR                                      (volatile uint32_t *)(0xff634400 + (0x085 << 2))
+#define     BUS_MON1_DATA                                      (0xff634400 + (0x086 << 2))
+#define SEC_BUS_MON1_DATA                                      (0xff634400 + (0x086 << 2))
+#define   P_BUS_MON1_DATA                                      (volatile uint32_t *)(0xff634400 + (0x086 << 2))
+#define     BUS_MON1_DATA_MSK                                  (0xff634400 + (0x087 << 2))
+#define SEC_BUS_MON1_DATA_MSK                                  (0xff634400 + (0x087 << 2))
+#define   P_BUS_MON1_DATA_MSK                                  (volatile uint32_t *)(0xff634400 + (0x087 << 2))
+#define     ASYNC_FIFO_LOCK_ADR                                (0xff634400 + (0x088 << 2))
+#define SEC_ASYNC_FIFO_LOCK_ADR                                (0xff634400 + (0x088 << 2))
+#define   P_ASYNC_FIFO_LOCK_ADR                                (volatile uint32_t *)(0xff634400 + (0x088 << 2))
+#define     SECE_TIMER_CTRL                                    (0xff634400 + (0x089 << 2))
+#define SEC_SECE_TIMER_CTRL                                    (0xff634400 + (0x089 << 2))
+#define   P_SECE_TIMER_CTRL                                    (volatile uint32_t *)(0xff634400 + (0x089 << 2))
+#define     SECE_TIMER_LOW                                     (0xff634400 + (0x08a << 2))
+#define SEC_SECE_TIMER_LOW                                     (0xff634400 + (0x08a << 2))
+#define   P_SECE_TIMER_LOW                                     (volatile uint32_t *)(0xff634400 + (0x08a << 2))
+#define     SECE_TIMER_HIG                                     (0xff634400 + (0x08b << 2))
+#define SEC_SECE_TIMER_HIG                                     (0xff634400 + (0x08b << 2))
+#define   P_SECE_TIMER_HIG                                     (volatile uint32_t *)(0xff634400 + (0x08b << 2))
+// ---------------------------
+// System CPU control registers
+// ----------------------------
+#define     SYS_CPU_POR_CFG0                                   (0xff634400 + (0x090 << 2))
+#define SEC_SYS_CPU_POR_CFG0                                   (0xff634400 + (0x090 << 2))
+#define   P_SYS_CPU_POR_CFG0                                   (volatile uint32_t *)(0xff634400 + (0x090 << 2))
+#define     SYS_CPU_POR_CFG1                                   (0xff634400 + (0x091 << 2))
+#define SEC_SYS_CPU_POR_CFG1                                   (0xff634400 + (0x091 << 2))
+#define   P_SYS_CPU_POR_CFG1                                   (volatile uint32_t *)(0xff634400 + (0x091 << 2))
+#define     SYS_CPU_CFG0                                       (0xff634400 + (0x092 << 2))
+#define SEC_SYS_CPU_CFG0                                       (0xff634400 + (0x092 << 2))
+#define   P_SYS_CPU_CFG0                                       (volatile uint32_t *)(0xff634400 + (0x092 << 2))
+#define     SYS_CPU_CFG1                                       (0xff634400 + (0x093 << 2))
+#define SEC_SYS_CPU_CFG1                                       (0xff634400 + (0x093 << 2))
+#define   P_SYS_CPU_CFG1                                       (volatile uint32_t *)(0xff634400 + (0x093 << 2))
+#define     SYS_CPU_CFG2                                       (0xff634400 + (0x094 << 2))
+#define SEC_SYS_CPU_CFG2                                       (0xff634400 + (0x094 << 2))
+#define   P_SYS_CPU_CFG2                                       (volatile uint32_t *)(0xff634400 + (0x094 << 2))
+#define     SYS_CPU_CFG3                                       (0xff634400 + (0x095 << 2))
+#define SEC_SYS_CPU_CFG3                                       (0xff634400 + (0x095 << 2))
+#define   P_SYS_CPU_CFG3                                       (volatile uint32_t *)(0xff634400 + (0x095 << 2))
+#define     SYS_CPU_CFG4                                       (0xff634400 + (0x096 << 2))
+#define SEC_SYS_CPU_CFG4                                       (0xff634400 + (0x096 << 2))
+#define   P_SYS_CPU_CFG4                                       (volatile uint32_t *)(0xff634400 + (0x096 << 2))
+#define     SYS_CPU_CFG5                                       (0xff634400 + (0x097 << 2))
+#define SEC_SYS_CPU_CFG5                                       (0xff634400 + (0x097 << 2))
+#define   P_SYS_CPU_CFG5                                       (volatile uint32_t *)(0xff634400 + (0x097 << 2))
+#define     SYS_CPU_CFG6                                       (0xff634400 + (0x098 << 2))
+#define SEC_SYS_CPU_CFG6                                       (0xff634400 + (0x098 << 2))
+#define   P_SYS_CPU_CFG6                                       (volatile uint32_t *)(0xff634400 + (0x098 << 2))
+#define     SYS_CPU_CFG7                                       (0xff634400 + (0x099 << 2))
+#define SEC_SYS_CPU_CFG7                                       (0xff634400 + (0x099 << 2))
+#define   P_SYS_CPU_CFG7                                       (volatile uint32_t *)(0xff634400 + (0x099 << 2))
+#define     SYS_CPU_CFG8                                       (0xff634400 + (0x09a << 2))
+#define SEC_SYS_CPU_CFG8                                       (0xff634400 + (0x09a << 2))
+#define   P_SYS_CPU_CFG8                                       (volatile uint32_t *)(0xff634400 + (0x09a << 2))
+#define     SYS_CPU_CFG9                                       (0xff634400 + (0x09b << 2))
+#define SEC_SYS_CPU_CFG9                                       (0xff634400 + (0x09b << 2))
+#define   P_SYS_CPU_CFG9                                       (volatile uint32_t *)(0xff634400 + (0x09b << 2))
+#define     SYS_CPU_CFG10                                      (0xff634400 + (0x09c << 2))
+#define SEC_SYS_CPU_CFG10                                      (0xff634400 + (0x09c << 2))
+#define   P_SYS_CPU_CFG10                                      (volatile uint32_t *)(0xff634400 + (0x09c << 2))
+//`define SYS_CPU_CFG11                       8'h9d
+//`define SYS_CPU_CFG12                       8'h9e
+//`define SYS_CPU_CFG13                       8'h9f
+#define     SYS_CPU_STATUS0                                    (0xff634400 + (0x0a0 << 2))
+#define SEC_SYS_CPU_STATUS0                                    (0xff634400 + (0x0a0 << 2))
+#define   P_SYS_CPU_STATUS0                                    (volatile uint32_t *)(0xff634400 + (0x0a0 << 2))
+#define     SYS_CPU_STATUS1                                    (0xff634400 + (0x0a1 << 2))
+#define SEC_SYS_CPU_STATUS1                                    (0xff634400 + (0x0a1 << 2))
+#define   P_SYS_CPU_STATUS1                                    (volatile uint32_t *)(0xff634400 + (0x0a1 << 2))
+#define     SYS_CPU_STATUS2                                    (0xff634400 + (0x0a2 << 2))
+#define SEC_SYS_CPU_STATUS2                                    (0xff634400 + (0x0a2 << 2))
+#define   P_SYS_CPU_STATUS2                                    (volatile uint32_t *)(0xff634400 + (0x0a2 << 2))
+#define     SYS_CPU_STATUS3                                    (0xff634400 + (0x0a3 << 2))
+#define SEC_SYS_CPU_STATUS3                                    (0xff634400 + (0x0a3 << 2))
+#define   P_SYS_CPU_STATUS3                                    (volatile uint32_t *)(0xff634400 + (0x0a3 << 2))
+#define     SYS_CPU_STATUS4                                    (0xff634400 + (0x0a4 << 2))
+#define SEC_SYS_CPU_STATUS4                                    (0xff634400 + (0x0a4 << 2))
+#define   P_SYS_CPU_STATUS4                                    (volatile uint32_t *)(0xff634400 + (0x0a4 << 2))
+#define     SYS_CPU_STATUS5                                    (0xff634400 + (0x0a5 << 2))
+#define SEC_SYS_CPU_STATUS5                                    (0xff634400 + (0x0a5 << 2))
+#define   P_SYS_CPU_STATUS5                                    (volatile uint32_t *)(0xff634400 + (0x0a5 << 2))
+#define     SYS_CPU_MISC                                       (0xff634400 + (0x0a8 << 2))
+#define SEC_SYS_CPU_MISC                                       (0xff634400 + (0x0a8 << 2))
+#define   P_SYS_CPU_MISC                                       (volatile uint32_t *)(0xff634400 + (0x0a8 << 2))
+// ----------------------------
+// Pin Mux  (9)
+// ----------------------------
+#define     PERIPHS_LOCK_PAD                                   (0xff634400 + (0x0ae << 2))
+#define SEC_PERIPHS_LOCK_PAD                                   (0xff634400 + (0x0ae << 2))
+#define   P_PERIPHS_LOCK_PAD                                   (volatile uint32_t *)(0xff634400 + (0x0ae << 2))
+#define     PERIPHS_LOCK_PIN_MUX                               (0xff634400 + (0x0af << 2))
+#define SEC_PERIPHS_LOCK_PIN_MUX                               (0xff634400 + (0x0af << 2))
+#define   P_PERIPHS_LOCK_PIN_MUX                               (volatile uint32_t *)(0xff634400 + (0x0af << 2))
+#define     PERIPHS_PIN_MUX_0                                  (0xff634400 + (0x0b0 << 2))
+#define SEC_PERIPHS_PIN_MUX_0                                  (0xff634400 + (0x0b0 << 2))
+#define   P_PERIPHS_PIN_MUX_0                                  (volatile uint32_t *)(0xff634400 + (0x0b0 << 2))
+#define     PERIPHS_PIN_MUX_1                                  (0xff634400 + (0x0b1 << 2))
+#define SEC_PERIPHS_PIN_MUX_1                                  (0xff634400 + (0x0b1 << 2))
+#define   P_PERIPHS_PIN_MUX_1                                  (volatile uint32_t *)(0xff634400 + (0x0b1 << 2))
+#define     PERIPHS_PIN_MUX_2                                  (0xff634400 + (0x0b2 << 2))
+#define SEC_PERIPHS_PIN_MUX_2                                  (0xff634400 + (0x0b2 << 2))
+#define   P_PERIPHS_PIN_MUX_2                                  (volatile uint32_t *)(0xff634400 + (0x0b2 << 2))
+#define     PERIPHS_PIN_MUX_3                                  (0xff634400 + (0x0b3 << 2))
+#define SEC_PERIPHS_PIN_MUX_3                                  (0xff634400 + (0x0b3 << 2))
+#define   P_PERIPHS_PIN_MUX_3                                  (volatile uint32_t *)(0xff634400 + (0x0b3 << 2))
+#define     PERIPHS_PIN_MUX_4                                  (0xff634400 + (0x0b4 << 2))
+#define SEC_PERIPHS_PIN_MUX_4                                  (0xff634400 + (0x0b4 << 2))
+#define   P_PERIPHS_PIN_MUX_4                                  (volatile uint32_t *)(0xff634400 + (0x0b4 << 2))
+#define     PERIPHS_PIN_MUX_5                                  (0xff634400 + (0x0b5 << 2))
+#define SEC_PERIPHS_PIN_MUX_5                                  (0xff634400 + (0x0b5 << 2))
+#define   P_PERIPHS_PIN_MUX_5                                  (volatile uint32_t *)(0xff634400 + (0x0b5 << 2))
+#define     PERIPHS_PIN_MUX_6                                  (0xff634400 + (0x0b6 << 2))
+#define SEC_PERIPHS_PIN_MUX_6                                  (0xff634400 + (0x0b6 << 2))
+#define   P_PERIPHS_PIN_MUX_6                                  (volatile uint32_t *)(0xff634400 + (0x0b6 << 2))
+#define     PERIPHS_PIN_MUX_7                                  (0xff634400 + (0x0b7 << 2))
+#define SEC_PERIPHS_PIN_MUX_7                                  (0xff634400 + (0x0b7 << 2))
+#define   P_PERIPHS_PIN_MUX_7                                  (volatile uint32_t *)(0xff634400 + (0x0b7 << 2))
+#define     PERIPHS_PIN_MUX_8                                  (0xff634400 + (0x0b8 << 2))
+#define SEC_PERIPHS_PIN_MUX_8                                  (0xff634400 + (0x0b8 << 2))
+#define   P_PERIPHS_PIN_MUX_8                                  (volatile uint32_t *)(0xff634400 + (0x0b8 << 2))
+#define     PERIPHS_PIN_MUX_9                                  (0xff634400 + (0x0b9 << 2))
+#define SEC_PERIPHS_PIN_MUX_9                                  (0xff634400 + (0x0b9 << 2))
+#define   P_PERIPHS_PIN_MUX_9                                  (volatile uint32_t *)(0xff634400 + (0x0b9 << 2))
+#define     PERIPHS_PIN_MUX_A                                  (0xff634400 + (0x0ba << 2))
+#define SEC_PERIPHS_PIN_MUX_A                                  (0xff634400 + (0x0ba << 2))
+#define   P_PERIPHS_PIN_MUX_A                                  (volatile uint32_t *)(0xff634400 + (0x0ba << 2))
+#define     PERIPHS_PIN_MUX_B                                  (0xff634400 + (0x0bb << 2))
+#define SEC_PERIPHS_PIN_MUX_B                                  (0xff634400 + (0x0bb << 2))
+#define   P_PERIPHS_PIN_MUX_B                                  (volatile uint32_t *)(0xff634400 + (0x0bb << 2))
+#define     PERIPHS_PIN_MUX_C                                  (0xff634400 + (0x0bc << 2))
+#define SEC_PERIPHS_PIN_MUX_C                                  (0xff634400 + (0x0bc << 2))
+#define   P_PERIPHS_PIN_MUX_C                                  (volatile uint32_t *)(0xff634400 + (0x0bc << 2))
+#define     PERIPHS_PIN_MUX_D                                  (0xff634400 + (0x0bd << 2))
+#define SEC_PERIPHS_PIN_MUX_D                                  (0xff634400 + (0x0bd << 2))
+#define   P_PERIPHS_PIN_MUX_D                                  (volatile uint32_t *)(0xff634400 + (0x0bd << 2))
+#define     PERIPHS_PIN_MUX_E                                  (0xff634400 + (0x0be << 2))
+#define SEC_PERIPHS_PIN_MUX_E                                  (0xff634400 + (0x0be << 2))
+#define   P_PERIPHS_PIN_MUX_E                                  (volatile uint32_t *)(0xff634400 + (0x0be << 2))
+#define     PERIPHS_PIN_MUX_F                                  (0xff634400 + (0x0bf << 2))
+#define SEC_PERIPHS_PIN_MUX_F                                  (0xff634400 + (0x0bf << 2))
+#define   P_PERIPHS_PIN_MUX_F                                  (volatile uint32_t *)(0xff634400 + (0x0bf << 2))
+#define     EFUSE_CFG_LOCK                                     (0xff634400 + (0x0c0 << 2))
+#define SEC_EFUSE_CFG_LOCK                                     (0xff634400 + (0x0c0 << 2))
+#define   P_EFUSE_CFG_LOCK                                     (volatile uint32_t *)(0xff634400 + (0x0c0 << 2))
+#define     EFUSE_CLK_A53_CFG01                                (0xff634400 + (0x0c1 << 2))
+#define SEC_EFUSE_CLK_A53_CFG01                                (0xff634400 + (0x0c1 << 2))
+#define   P_EFUSE_CLK_A53_CFG01                                (volatile uint32_t *)(0xff634400 + (0x0c1 << 2))
+#define     EFUSE_CLK_A53_CFG2                                 (0xff634400 + (0x0c2 << 2))
+#define SEC_EFUSE_CLK_A53_CFG2                                 (0xff634400 + (0x0c2 << 2))
+#define   P_EFUSE_CLK_A53_CFG2                                 (volatile uint32_t *)(0xff634400 + (0x0c2 << 2))
+#define     EFUSE_CLK_ENCP_CFG0                                (0xff634400 + (0x0c3 << 2))
+#define SEC_EFUSE_CLK_ENCP_CFG0                                (0xff634400 + (0x0c3 << 2))
+#define   P_EFUSE_CLK_ENCP_CFG0                                (volatile uint32_t *)(0xff634400 + (0x0c3 << 2))
+#define     EFUSE_CLK_MALI_CFG0                                (0xff634400 + (0x0c4 << 2))
+#define SEC_EFUSE_CLK_MALI_CFG0                                (0xff634400 + (0x0c4 << 2))
+#define   P_EFUSE_CLK_MALI_CFG0                                (volatile uint32_t *)(0xff634400 + (0x0c4 << 2))
+#define     EFUSE_CLK_HEVCB_CFG0                               (0xff634400 + (0x0c5 << 2))
+#define SEC_EFUSE_CLK_HEVCB_CFG0                               (0xff634400 + (0x0c5 << 2))
+#define   P_EFUSE_CLK_HEVCB_CFG0                               (volatile uint32_t *)(0xff634400 + (0x0c5 << 2))
+#define     PAD_DS_REG0A                                       (0xff634400 + (0x0d0 << 2))
+#define SEC_PAD_DS_REG0A                                       (0xff634400 + (0x0d0 << 2))
+#define   P_PAD_DS_REG0A                                       (volatile uint32_t *)(0xff634400 + (0x0d0 << 2))
+#define     PAD_DS_REG1A                                       (0xff634400 + (0x0d1 << 2))
+#define SEC_PAD_DS_REG1A                                       (0xff634400 + (0x0d1 << 2))
+#define   P_PAD_DS_REG1A                                       (volatile uint32_t *)(0xff634400 + (0x0d1 << 2))
+#define     PAD_DS_REG2A                                       (0xff634400 + (0x0d2 << 2))
+#define SEC_PAD_DS_REG2A                                       (0xff634400 + (0x0d2 << 2))
+#define   P_PAD_DS_REG2A                                       (volatile uint32_t *)(0xff634400 + (0x0d2 << 2))
+#define     PAD_DS_REG2B                                       (0xff634400 + (0x0d3 << 2))
+#define SEC_PAD_DS_REG2B                                       (0xff634400 + (0x0d3 << 2))
+#define   P_PAD_DS_REG2B                                       (volatile uint32_t *)(0xff634400 + (0x0d3 << 2))
+#define     PAD_DS_REG3A                                       (0xff634400 + (0x0d4 << 2))
+#define SEC_PAD_DS_REG3A                                       (0xff634400 + (0x0d4 << 2))
+#define   P_PAD_DS_REG3A                                       (volatile uint32_t *)(0xff634400 + (0x0d4 << 2))
+#define     PAD_DS_REG4A                                       (0xff634400 + (0x0d5 << 2))
+#define SEC_PAD_DS_REG4A                                       (0xff634400 + (0x0d5 << 2))
+#define   P_PAD_DS_REG4A                                       (volatile uint32_t *)(0xff634400 + (0x0d5 << 2))
+#define     PAD_DS_REG5A                                       (0xff634400 + (0x0d6 << 2))
+#define SEC_PAD_DS_REG5A                                       (0xff634400 + (0x0d6 << 2))
+#define   P_PAD_DS_REG5A                                       (volatile uint32_t *)(0xff634400 + (0x0d6 << 2))
+//========================================================================
+//  RESET_SEC - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hFF64E000
+// APB4_DECODER_SECURE_BASE         32'hFF64E000
+#define     RESET0_SEC_REGISTER                                (0xff64e000 + (0x000 << 2))
+#define SEC_RESET0_SEC_REGISTER                                (0xff64e000 + (0x000 << 2))
+#define   P_RESET0_SEC_REGISTER                                (volatile uint32_t *)(0xff64e000 + (0x000 << 2))
+#define     RESET1_SEC_REGISTER                                (0xff64e000 + (0x001 << 2))
+#define SEC_RESET1_SEC_REGISTER                                (0xff64e000 + (0x001 << 2))
+#define   P_RESET1_SEC_REGISTER                                (volatile uint32_t *)(0xff64e000 + (0x001 << 2))
+#define     RESET2_SEC_REGISTER                                (0xff64e000 + (0x002 << 2))
+#define SEC_RESET2_SEC_REGISTER                                (0xff64e000 + (0x002 << 2))
+#define   P_RESET2_SEC_REGISTER                                (volatile uint32_t *)(0xff64e000 + (0x002 << 2))
+#define     RESET0_SEC_LEVEL                                   (0xff64e000 + (0x010 << 2))
+#define SEC_RESET0_SEC_LEVEL                                   (0xff64e000 + (0x010 << 2))
+#define   P_RESET0_SEC_LEVEL                                   (volatile uint32_t *)(0xff64e000 + (0x010 << 2))
+#define     RESET1_SEC_LEVEL                                   (0xff64e000 + (0x011 << 2))
+#define SEC_RESET1_SEC_LEVEL                                   (0xff64e000 + (0x011 << 2))
+#define   P_RESET1_SEC_LEVEL                                   (volatile uint32_t *)(0xff64e000 + (0x011 << 2))
+#define     RESET2_SEC_LEVEL                                   (0xff64e000 + (0x012 << 2))
+#define SEC_RESET2_SEC_LEVEL                                   (0xff64e000 + (0x012 << 2))
+#define   P_RESET2_SEC_LEVEL                                   (volatile uint32_t *)(0xff64e000 + (0x012 << 2))
+#define     RESET0_SEC_MASK                                    (0xff64e000 + (0x020 << 2))
+#define SEC_RESET0_SEC_MASK                                    (0xff64e000 + (0x020 << 2))
+#define   P_RESET0_SEC_MASK                                    (volatile uint32_t *)(0xff64e000 + (0x020 << 2))
+#define     RESET1_SEC_MASK                                    (0xff64e000 + (0x021 << 2))
+#define SEC_RESET1_SEC_MASK                                    (0xff64e000 + (0x021 << 2))
+#define   P_RESET1_SEC_MASK                                    (volatile uint32_t *)(0xff64e000 + (0x021 << 2))
+#define     RESET2_SEC_MASK                                    (0xff64e000 + (0x022 << 2))
+#define SEC_RESET2_SEC_MASK                                    (0xff64e000 + (0x022 << 2))
+#define   P_RESET2_SEC_MASK                                    (volatile uint32_t *)(0xff64e000 + (0x022 << 2))
+//========================================================================
+//  AUDIO locker - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hFF64a000
+// APB4_DECODER_SECURE_BASE         32'hFF64a000
+#define     AUD_LOCK_EN                                        (0xff64a000 + (0x000 << 2))
+#define SEC_AUD_LOCK_EN                                        (0xff64a000 + (0x000 << 2))
+#define   P_AUD_LOCK_EN                                        (volatile uint32_t *)(0xff64a000 + (0x000 << 2))
+#define     AUD_LOCK_SW_RESET                                  (0xff64a000 + (0x001 << 2))
+#define SEC_AUD_LOCK_SW_RESET                                  (0xff64a000 + (0x001 << 2))
+#define   P_AUD_LOCK_SW_RESET                                  (volatile uint32_t *)(0xff64a000 + (0x001 << 2))
+#define     AUD_LOCK_SW_LATCH                                  (0xff64a000 + (0x002 << 2))
+#define SEC_AUD_LOCK_SW_LATCH                                  (0xff64a000 + (0x002 << 2))
+#define   P_AUD_LOCK_SW_LATCH                                  (volatile uint32_t *)(0xff64a000 + (0x002 << 2))
+#define     AUD_LOCK_HW_LATCH                                  (0xff64a000 + (0x003 << 2))
+#define SEC_AUD_LOCK_HW_LATCH                                  (0xff64a000 + (0x003 << 2))
+#define   P_AUD_LOCK_HW_LATCH                                  (volatile uint32_t *)(0xff64a000 + (0x003 << 2))
+#define     AUD_LOCK_REFCLK_SRC                                (0xff64a000 + (0x004 << 2))
+#define SEC_AUD_LOCK_REFCLK_SRC                                (0xff64a000 + (0x004 << 2))
+#define   P_AUD_LOCK_REFCLK_SRC                                (volatile uint32_t *)(0xff64a000 + (0x004 << 2))
+#define     AUD_LOCK_REFCLK_LAT_INT                            (0xff64a000 + (0x005 << 2))
+#define SEC_AUD_LOCK_REFCLK_LAT_INT                            (0xff64a000 + (0x005 << 2))
+#define   P_AUD_LOCK_REFCLK_LAT_INT                            (volatile uint32_t *)(0xff64a000 + (0x005 << 2))
+#define     AUD_LOCK_IMCLK_LAT_INT                             (0xff64a000 + (0x006 << 2))
+#define SEC_AUD_LOCK_IMCLK_LAT_INT                             (0xff64a000 + (0x006 << 2))
+#define   P_AUD_LOCK_IMCLK_LAT_INT                             (volatile uint32_t *)(0xff64a000 + (0x006 << 2))
+#define     AUD_LOCK_OMCLK_LAT_INT                             (0xff64a000 + (0x007 << 2))
+#define SEC_AUD_LOCK_OMCLK_LAT_INT                             (0xff64a000 + (0x007 << 2))
+#define   P_AUD_LOCK_OMCLK_LAT_INT                             (volatile uint32_t *)(0xff64a000 + (0x007 << 2))
+#define     AUD_LOCK_REFCLK_DS_INT                             (0xff64a000 + (0x008 << 2))
+#define SEC_AUD_LOCK_REFCLK_DS_INT                             (0xff64a000 + (0x008 << 2))
+#define   P_AUD_LOCK_REFCLK_DS_INT                             (volatile uint32_t *)(0xff64a000 + (0x008 << 2))
+#define     AUD_LOCK_IMCLK_DS_INT                              (0xff64a000 + (0x009 << 2))
+#define SEC_AUD_LOCK_IMCLK_DS_INT                              (0xff64a000 + (0x009 << 2))
+#define   P_AUD_LOCK_IMCLK_DS_INT                              (volatile uint32_t *)(0xff64a000 + (0x009 << 2))
+#define     AUD_LOCK_OMCLK_DS_INT                              (0xff64a000 + (0x00a << 2))
+#define SEC_AUD_LOCK_OMCLK_DS_INT                              (0xff64a000 + (0x00a << 2))
+#define   P_AUD_LOCK_OMCLK_DS_INT                              (volatile uint32_t *)(0xff64a000 + (0x00a << 2))
+#define     AUD_LOCK_INT_CLR                                   (0xff64a000 + (0x00b << 2))
+#define SEC_AUD_LOCK_INT_CLR                                   (0xff64a000 + (0x00b << 2))
+#define   P_AUD_LOCK_INT_CLR                                   (volatile uint32_t *)(0xff64a000 + (0x00b << 2))
+#define     AUD_LOCK_GCLK_CTRL                                 (0xff64a000 + (0x00c << 2))
+#define SEC_AUD_LOCK_GCLK_CTRL                                 (0xff64a000 + (0x00c << 2))
+#define   P_AUD_LOCK_GCLK_CTRL                                 (volatile uint32_t *)(0xff64a000 + (0x00c << 2))
+#define     AUD_LOCK_INT_CTRL                                  (0xff64a000 + (0x00d << 2))
+#define SEC_AUD_LOCK_INT_CTRL                                  (0xff64a000 + (0x00d << 2))
+#define   P_AUD_LOCK_INT_CTRL                                  (volatile uint32_t *)(0xff64a000 + (0x00d << 2))
+#define     RO_REF2IMCLK_CNT_L                                 (0xff64a000 + (0x010 << 2))
+#define SEC_RO_REF2IMCLK_CNT_L                                 (0xff64a000 + (0x010 << 2))
+#define   P_RO_REF2IMCLK_CNT_L                                 (volatile uint32_t *)(0xff64a000 + (0x010 << 2))
+#define     RO_REF2IMCLK_CNT_H                                 (0xff64a000 + (0x011 << 2))
+#define SEC_RO_REF2IMCLK_CNT_H                                 (0xff64a000 + (0x011 << 2))
+#define   P_RO_REF2IMCLK_CNT_H                                 (volatile uint32_t *)(0xff64a000 + (0x011 << 2))
+#define     RO_REF2OMCLK_CNT_L                                 (0xff64a000 + (0x012 << 2))
+#define SEC_RO_REF2OMCLK_CNT_L                                 (0xff64a000 + (0x012 << 2))
+#define   P_RO_REF2OMCLK_CNT_L                                 (volatile uint32_t *)(0xff64a000 + (0x012 << 2))
+#define     RO_REF2OMCLK_CNT_H                                 (0xff64a000 + (0x013 << 2))
+#define SEC_RO_REF2OMCLK_CNT_H                                 (0xff64a000 + (0x013 << 2))
+#define   P_RO_REF2OMCLK_CNT_H                                 (volatile uint32_t *)(0xff64a000 + (0x013 << 2))
+#define     RO_IMCLK2REF_CNT_L                                 (0xff64a000 + (0x014 << 2))
+#define SEC_RO_IMCLK2REF_CNT_L                                 (0xff64a000 + (0x014 << 2))
+#define   P_RO_IMCLK2REF_CNT_L                                 (volatile uint32_t *)(0xff64a000 + (0x014 << 2))
+#define     RO_IMCLK2REF_CNT_H                                 (0xff64a000 + (0x015 << 2))
+#define SEC_RO_IMCLK2REF_CNT_H                                 (0xff64a000 + (0x015 << 2))
+#define   P_RO_IMCLK2REF_CNT_H                                 (volatile uint32_t *)(0xff64a000 + (0x015 << 2))
+#define     RO_OMCLK2REF_CNT_L                                 (0xff64a000 + (0x016 << 2))
+#define SEC_RO_OMCLK2REF_CNT_L                                 (0xff64a000 + (0x016 << 2))
+#define   P_RO_OMCLK2REF_CNT_L                                 (volatile uint32_t *)(0xff64a000 + (0x016 << 2))
+#define     RO_OMCLK2REF_CNT_H                                 (0xff64a000 + (0x017 << 2))
+#define SEC_RO_OMCLK2REF_CNT_H                                 (0xff64a000 + (0x017 << 2))
+#define   P_RO_OMCLK2REF_CNT_H                                 (volatile uint32_t *)(0xff64a000 + (0x017 << 2))
+#define     RO_REFCLK_PKG_CNT                                  (0xff64a000 + (0x018 << 2))
+#define SEC_RO_REFCLK_PKG_CNT                                  (0xff64a000 + (0x018 << 2))
+#define   P_RO_REFCLK_PKG_CNT                                  (volatile uint32_t *)(0xff64a000 + (0x018 << 2))
+#define     RO_IMCLK_PKG_CNT                                   (0xff64a000 + (0x019 << 2))
+#define SEC_RO_IMCLK_PKG_CNT                                   (0xff64a000 + (0x019 << 2))
+#define   P_RO_IMCLK_PKG_CNT                                   (volatile uint32_t *)(0xff64a000 + (0x019 << 2))
+#define     RO_OMCLK_PKG_CNT                                   (0xff64a000 + (0x01a << 2))
+#define SEC_RO_OMCLK_PKG_CNT                                   (0xff64a000 + (0x01a << 2))
+#define   P_RO_OMCLK_PKG_CNT                                   (volatile uint32_t *)(0xff64a000 + (0x01a << 2))
+#define     RO_AUD_LOCK_INT_STATUS                             (0xff64a000 + (0x01b << 2))
+#define SEC_RO_AUD_LOCK_INT_STATUS                             (0xff64a000 + (0x01b << 2))
+#define   P_RO_AUD_LOCK_INT_STATUS                             (volatile uint32_t *)(0xff64a000 + (0x01b << 2))
+//========================================================================
+//  AUDIO - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hFF642000
+// APB4_DECODER_SECURE_BASE         32'hFF642000
+#define     EE_AUDIO_CLK_GATE_EN                               (0xff642000 + (0x000 << 2))
+#define SEC_EE_AUDIO_CLK_GATE_EN                               (0xff642000 + (0x000 << 2))
+#define   P_EE_AUDIO_CLK_GATE_EN                               (volatile uint32_t *)(0xff642000 + (0x000 << 2))
+#define     EE_AUDIO_MCLK_A_CTRL                               (0xff642000 + (0x001 << 2))
+#define SEC_EE_AUDIO_MCLK_A_CTRL                               (0xff642000 + (0x001 << 2))
+#define   P_EE_AUDIO_MCLK_A_CTRL                               (volatile uint32_t *)(0xff642000 + (0x001 << 2))
+#define     EE_AUDIO_MCLK_B_CTRL                               (0xff642000 + (0x002 << 2))
+#define SEC_EE_AUDIO_MCLK_B_CTRL                               (0xff642000 + (0x002 << 2))
+#define   P_EE_AUDIO_MCLK_B_CTRL                               (volatile uint32_t *)(0xff642000 + (0x002 << 2))
+#define     EE_AUDIO_MCLK_C_CTRL                               (0xff642000 + (0x003 << 2))
+#define SEC_EE_AUDIO_MCLK_C_CTRL                               (0xff642000 + (0x003 << 2))
+#define   P_EE_AUDIO_MCLK_C_CTRL                               (volatile uint32_t *)(0xff642000 + (0x003 << 2))
+#define     EE_AUDIO_MCLK_D_CTRL                               (0xff642000 + (0x004 << 2))
+#define SEC_EE_AUDIO_MCLK_D_CTRL                               (0xff642000 + (0x004 << 2))
+#define   P_EE_AUDIO_MCLK_D_CTRL                               (volatile uint32_t *)(0xff642000 + (0x004 << 2))
+#define     EE_AUDIO_MCLK_E_CTRL                               (0xff642000 + (0x005 << 2))
+#define SEC_EE_AUDIO_MCLK_E_CTRL                               (0xff642000 + (0x005 << 2))
+#define   P_EE_AUDIO_MCLK_E_CTRL                               (volatile uint32_t *)(0xff642000 + (0x005 << 2))
+#define     EE_AUDIO_MCLK_F_CTRL                               (0xff642000 + (0x006 << 2))
+#define SEC_EE_AUDIO_MCLK_F_CTRL                               (0xff642000 + (0x006 << 2))
+#define   P_EE_AUDIO_MCLK_F_CTRL                               (volatile uint32_t *)(0xff642000 + (0x006 << 2))
+#define     EE_AUDIO_PAD_CTRL0                                 (0xff642000 + (0x007 << 2))
+#define SEC_EE_AUDIO_PAD_CTRL0                                 (0xff642000 + (0x007 << 2))
+#define   P_EE_AUDIO_PAD_CTRL0                                 (volatile uint32_t *)(0xff642000 + (0x007 << 2))
+#define     EE_AUDIO_PAD_CTRL1                                 (0xff642000 + (0x008 << 2))
+#define SEC_EE_AUDIO_PAD_CTRL1                                 (0xff642000 + (0x008 << 2))
+#define   P_EE_AUDIO_PAD_CTRL1                                 (volatile uint32_t *)(0xff642000 + (0x008 << 2))
+#define     EE_AUDIO_SW_RESET                                  (0xff642000 + (0x009 << 2))
+#define SEC_EE_AUDIO_SW_RESET                                  (0xff642000 + (0x009 << 2))
+#define   P_EE_AUDIO_SW_RESET                                  (volatile uint32_t *)(0xff642000 + (0x009 << 2))
+#define     EE_AUDIO_MST_A_SCLK_CTRL0                          (0xff642000 + (0x010 << 2))
+#define SEC_EE_AUDIO_MST_A_SCLK_CTRL0                          (0xff642000 + (0x010 << 2))
+#define   P_EE_AUDIO_MST_A_SCLK_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x010 << 2))
+#define     EE_AUDIO_MST_A_SCLK_CTRL1                          (0xff642000 + (0x011 << 2))
+#define SEC_EE_AUDIO_MST_A_SCLK_CTRL1                          (0xff642000 + (0x011 << 2))
+#define   P_EE_AUDIO_MST_A_SCLK_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x011 << 2))
+#define     EE_AUDIO_MST_B_SCLK_CTRL0                          (0xff642000 + (0x012 << 2))
+#define SEC_EE_AUDIO_MST_B_SCLK_CTRL0                          (0xff642000 + (0x012 << 2))
+#define   P_EE_AUDIO_MST_B_SCLK_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x012 << 2))
+#define     EE_AUDIO_MST_B_SCLK_CTRL1                          (0xff642000 + (0x013 << 2))
+#define SEC_EE_AUDIO_MST_B_SCLK_CTRL1                          (0xff642000 + (0x013 << 2))
+#define   P_EE_AUDIO_MST_B_SCLK_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x013 << 2))
+#define     EE_AUDIO_MST_C_SCLK_CTRL0                          (0xff642000 + (0x014 << 2))
+#define SEC_EE_AUDIO_MST_C_SCLK_CTRL0                          (0xff642000 + (0x014 << 2))
+#define   P_EE_AUDIO_MST_C_SCLK_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x014 << 2))
+#define     EE_AUDIO_MST_C_SCLK_CTRL1                          (0xff642000 + (0x015 << 2))
+#define SEC_EE_AUDIO_MST_C_SCLK_CTRL1                          (0xff642000 + (0x015 << 2))
+#define   P_EE_AUDIO_MST_C_SCLK_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x015 << 2))
+#define     EE_AUDIO_MST_D_SCLK_CTRL0                          (0xff642000 + (0x016 << 2))
+#define SEC_EE_AUDIO_MST_D_SCLK_CTRL0                          (0xff642000 + (0x016 << 2))
+#define   P_EE_AUDIO_MST_D_SCLK_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x016 << 2))
+#define     EE_AUDIO_MST_D_SCLK_CTRL1                          (0xff642000 + (0x017 << 2))
+#define SEC_EE_AUDIO_MST_D_SCLK_CTRL1                          (0xff642000 + (0x017 << 2))
+#define   P_EE_AUDIO_MST_D_SCLK_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x017 << 2))
+#define     EE_AUDIO_MST_E_SCLK_CTRL0                          (0xff642000 + (0x018 << 2))
+#define SEC_EE_AUDIO_MST_E_SCLK_CTRL0                          (0xff642000 + (0x018 << 2))
+#define   P_EE_AUDIO_MST_E_SCLK_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x018 << 2))
+#define     EE_AUDIO_MST_E_SCLK_CTRL1                          (0xff642000 + (0x019 << 2))
+#define SEC_EE_AUDIO_MST_E_SCLK_CTRL1                          (0xff642000 + (0x019 << 2))
+#define   P_EE_AUDIO_MST_E_SCLK_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x019 << 2))
+#define     EE_AUDIO_MST_F_SCLK_CTRL0                          (0xff642000 + (0x01a << 2))
+#define SEC_EE_AUDIO_MST_F_SCLK_CTRL0                          (0xff642000 + (0x01a << 2))
+#define   P_EE_AUDIO_MST_F_SCLK_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x01a << 2))
+#define     EE_AUDIO_MST_F_SCLK_CTRL1                          (0xff642000 + (0x01b << 2))
+#define SEC_EE_AUDIO_MST_F_SCLK_CTRL1                          (0xff642000 + (0x01b << 2))
+#define   P_EE_AUDIO_MST_F_SCLK_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x01b << 2))
+#define     EE_AUDIO_CLK_TDMIN_A_CTRL                          (0xff642000 + (0x020 << 2))
+#define SEC_EE_AUDIO_CLK_TDMIN_A_CTRL                          (0xff642000 + (0x020 << 2))
+#define   P_EE_AUDIO_CLK_TDMIN_A_CTRL                          (volatile uint32_t *)(0xff642000 + (0x020 << 2))
+#define     EE_AUDIO_CLK_TDMIN_B_CTRL                          (0xff642000 + (0x021 << 2))
+#define SEC_EE_AUDIO_CLK_TDMIN_B_CTRL                          (0xff642000 + (0x021 << 2))
+#define   P_EE_AUDIO_CLK_TDMIN_B_CTRL                          (volatile uint32_t *)(0xff642000 + (0x021 << 2))
+#define     EE_AUDIO_CLK_TDMIN_C_CTRL                          (0xff642000 + (0x022 << 2))
+#define SEC_EE_AUDIO_CLK_TDMIN_C_CTRL                          (0xff642000 + (0x022 << 2))
+#define   P_EE_AUDIO_CLK_TDMIN_C_CTRL                          (volatile uint32_t *)(0xff642000 + (0x022 << 2))
+#define     EE_AUDIO_CLK_TDMIN_LB_CTRL                         (0xff642000 + (0x023 << 2))
+#define SEC_EE_AUDIO_CLK_TDMIN_LB_CTRL                         (0xff642000 + (0x023 << 2))
+#define   P_EE_AUDIO_CLK_TDMIN_LB_CTRL                         (volatile uint32_t *)(0xff642000 + (0x023 << 2))
+#define     EE_AUDIO_CLK_TDMOUT_A_CTRL                         (0xff642000 + (0x024 << 2))
+#define SEC_EE_AUDIO_CLK_TDMOUT_A_CTRL                         (0xff642000 + (0x024 << 2))
+#define   P_EE_AUDIO_CLK_TDMOUT_A_CTRL                         (volatile uint32_t *)(0xff642000 + (0x024 << 2))
+#define     EE_AUDIO_CLK_TDMOUT_B_CTRL                         (0xff642000 + (0x025 << 2))
+#define SEC_EE_AUDIO_CLK_TDMOUT_B_CTRL                         (0xff642000 + (0x025 << 2))
+#define   P_EE_AUDIO_CLK_TDMOUT_B_CTRL                         (volatile uint32_t *)(0xff642000 + (0x025 << 2))
+#define     EE_AUDIO_CLK_TDMOUT_C_CTRL                         (0xff642000 + (0x026 << 2))
+#define SEC_EE_AUDIO_CLK_TDMOUT_C_CTRL                         (0xff642000 + (0x026 << 2))
+#define   P_EE_AUDIO_CLK_TDMOUT_C_CTRL                         (volatile uint32_t *)(0xff642000 + (0x026 << 2))
+#define     EE_AUDIO_CLK_SPDIFIN_CTRL                          (0xff642000 + (0x027 << 2))
+#define SEC_EE_AUDIO_CLK_SPDIFIN_CTRL                          (0xff642000 + (0x027 << 2))
+#define   P_EE_AUDIO_CLK_SPDIFIN_CTRL                          (volatile uint32_t *)(0xff642000 + (0x027 << 2))
+#define     EE_AUDIO_CLK_SPDIFOUT_CTRL                         (0xff642000 + (0x028 << 2))
+#define SEC_EE_AUDIO_CLK_SPDIFOUT_CTRL                         (0xff642000 + (0x028 << 2))
+#define   P_EE_AUDIO_CLK_SPDIFOUT_CTRL                         (volatile uint32_t *)(0xff642000 + (0x028 << 2))
+#define     EE_AUDIO_CLK_RESAMPLE_CTRL                         (0xff642000 + (0x029 << 2))
+#define SEC_EE_AUDIO_CLK_RESAMPLE_CTRL                         (0xff642000 + (0x029 << 2))
+#define   P_EE_AUDIO_CLK_RESAMPLE_CTRL                         (volatile uint32_t *)(0xff642000 + (0x029 << 2))
+#define     EE_AUDIO_CLK_LOCKER_CTRL                           (0xff642000 + (0x02a << 2))
+#define SEC_EE_AUDIO_CLK_LOCKER_CTRL                           (0xff642000 + (0x02a << 2))
+#define   P_EE_AUDIO_CLK_LOCKER_CTRL                           (volatile uint32_t *)(0xff642000 + (0x02a << 2))
+#define     EE_AUDIO_CLK_PDMIN_CTRL0                           (0xff642000 + (0x02b << 2))
+#define SEC_EE_AUDIO_CLK_PDMIN_CTRL0                           (0xff642000 + (0x02b << 2))
+#define   P_EE_AUDIO_CLK_PDMIN_CTRL0                           (volatile uint32_t *)(0xff642000 + (0x02b << 2))
+#define     EE_AUDIO_CLK_PDMIN_CTRL1                           (0xff642000 + (0x02c << 2))
+#define SEC_EE_AUDIO_CLK_PDMIN_CTRL1                           (0xff642000 + (0x02c << 2))
+#define   P_EE_AUDIO_CLK_PDMIN_CTRL1                           (volatile uint32_t *)(0xff642000 + (0x02c << 2))
+#define     EE_AUDIO_CLK_SPDIFOUT_B_CTRL                       (0xff642000 + (0x02d << 2))
+#define SEC_EE_AUDIO_CLK_SPDIFOUT_B_CTRL                       (0xff642000 + (0x02d << 2))
+#define   P_EE_AUDIO_CLK_SPDIFOUT_B_CTRL                       (volatile uint32_t *)(0xff642000 + (0x02d << 2))
+#define     EE_AUDIO_TODDR_A_CTRL0                             (0xff642000 + (0x040 << 2))
+#define SEC_EE_AUDIO_TODDR_A_CTRL0                             (0xff642000 + (0x040 << 2))
+#define   P_EE_AUDIO_TODDR_A_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x040 << 2))
+#define     EE_AUDIO_TODDR_A_CTRL1                             (0xff642000 + (0x041 << 2))
+#define SEC_EE_AUDIO_TODDR_A_CTRL1                             (0xff642000 + (0x041 << 2))
+#define   P_EE_AUDIO_TODDR_A_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x041 << 2))
+#define     EE_AUDIO_TODDR_A_START_ADDR                        (0xff642000 + (0x042 << 2))
+#define SEC_EE_AUDIO_TODDR_A_START_ADDR                        (0xff642000 + (0x042 << 2))
+#define   P_EE_AUDIO_TODDR_A_START_ADDR                        (volatile uint32_t *)(0xff642000 + (0x042 << 2))
+#define     EE_AUDIO_TODDR_A_FINISH_ADDR                       (0xff642000 + (0x043 << 2))
+#define SEC_EE_AUDIO_TODDR_A_FINISH_ADDR                       (0xff642000 + (0x043 << 2))
+#define   P_EE_AUDIO_TODDR_A_FINISH_ADDR                       (volatile uint32_t *)(0xff642000 + (0x043 << 2))
+#define     EE_AUDIO_TODDR_A_INT_ADDR                          (0xff642000 + (0x044 << 2))
+#define SEC_EE_AUDIO_TODDR_A_INT_ADDR                          (0xff642000 + (0x044 << 2))
+#define   P_EE_AUDIO_TODDR_A_INT_ADDR                          (volatile uint32_t *)(0xff642000 + (0x044 << 2))
+#define     EE_AUDIO_TODDR_A_STATUS1                           (0xff642000 + (0x045 << 2))
+#define SEC_EE_AUDIO_TODDR_A_STATUS1                           (0xff642000 + (0x045 << 2))
+#define   P_EE_AUDIO_TODDR_A_STATUS1                           (volatile uint32_t *)(0xff642000 + (0x045 << 2))
+#define     EE_AUDIO_TODDR_A_STATUS2                           (0xff642000 + (0x046 << 2))
+#define SEC_EE_AUDIO_TODDR_A_STATUS2                           (0xff642000 + (0x046 << 2))
+#define   P_EE_AUDIO_TODDR_A_STATUS2                           (volatile uint32_t *)(0xff642000 + (0x046 << 2))
+#define     EE_AUDIO_TODDR_A_START_ADDRB                       (0xff642000 + (0x047 << 2))
+#define SEC_EE_AUDIO_TODDR_A_START_ADDRB                       (0xff642000 + (0x047 << 2))
+#define   P_EE_AUDIO_TODDR_A_START_ADDRB                       (volatile uint32_t *)(0xff642000 + (0x047 << 2))
+#define     EE_AUDIO_TODDR_A_FINISH_ADDRB                      (0xff642000 + (0x048 << 2))
+#define SEC_EE_AUDIO_TODDR_A_FINISH_ADDRB                      (0xff642000 + (0x048 << 2))
+#define   P_EE_AUDIO_TODDR_A_FINISH_ADDRB                      (volatile uint32_t *)(0xff642000 + (0x048 << 2))
+#define     EE_AUDIO_TODDR_A_INIT_ADDR                         (0xff642000 + (0x049 << 2))
+#define SEC_EE_AUDIO_TODDR_A_INIT_ADDR                         (0xff642000 + (0x049 << 2))
+#define   P_EE_AUDIO_TODDR_A_INIT_ADDR                         (volatile uint32_t *)(0xff642000 + (0x049 << 2))
+#define     EE_AUDIO_TODDR_B_CTRL0                             (0xff642000 + (0x050 << 2))
+#define SEC_EE_AUDIO_TODDR_B_CTRL0                             (0xff642000 + (0x050 << 2))
+#define   P_EE_AUDIO_TODDR_B_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x050 << 2))
+#define     EE_AUDIO_TODDR_B_CTRL1                             (0xff642000 + (0x051 << 2))
+#define SEC_EE_AUDIO_TODDR_B_CTRL1                             (0xff642000 + (0x051 << 2))
+#define   P_EE_AUDIO_TODDR_B_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x051 << 2))
+#define     EE_AUDIO_TODDR_B_START_ADDR                        (0xff642000 + (0x052 << 2))
+#define SEC_EE_AUDIO_TODDR_B_START_ADDR                        (0xff642000 + (0x052 << 2))
+#define   P_EE_AUDIO_TODDR_B_START_ADDR                        (volatile uint32_t *)(0xff642000 + (0x052 << 2))
+#define     EE_AUDIO_TODDR_B_FINISH_ADDR                       (0xff642000 + (0x053 << 2))
+#define SEC_EE_AUDIO_TODDR_B_FINISH_ADDR                       (0xff642000 + (0x053 << 2))
+#define   P_EE_AUDIO_TODDR_B_FINISH_ADDR                       (volatile uint32_t *)(0xff642000 + (0x053 << 2))
+#define     EE_AUDIO_TODDR_B_INT_ADDR                          (0xff642000 + (0x054 << 2))
+#define SEC_EE_AUDIO_TODDR_B_INT_ADDR                          (0xff642000 + (0x054 << 2))
+#define   P_EE_AUDIO_TODDR_B_INT_ADDR                          (volatile uint32_t *)(0xff642000 + (0x054 << 2))
+#define     EE_AUDIO_TODDR_B_STATUS1                           (0xff642000 + (0x055 << 2))
+#define SEC_EE_AUDIO_TODDR_B_STATUS1                           (0xff642000 + (0x055 << 2))
+#define   P_EE_AUDIO_TODDR_B_STATUS1                           (volatile uint32_t *)(0xff642000 + (0x055 << 2))
+#define     EE_AUDIO_TODDR_B_STATUS2                           (0xff642000 + (0x056 << 2))
+#define SEC_EE_AUDIO_TODDR_B_STATUS2                           (0xff642000 + (0x056 << 2))
+#define   P_EE_AUDIO_TODDR_B_STATUS2                           (volatile uint32_t *)(0xff642000 + (0x056 << 2))
+#define     EE_AUDIO_TODDR_B_START_ADDRB                       (0xff642000 + (0x057 << 2))
+#define SEC_EE_AUDIO_TODDR_B_START_ADDRB                       (0xff642000 + (0x057 << 2))
+#define   P_EE_AUDIO_TODDR_B_START_ADDRB                       (volatile uint32_t *)(0xff642000 + (0x057 << 2))
+#define     EE_AUDIO_TODDR_B_FINISH_ADDRB                      (0xff642000 + (0x058 << 2))
+#define SEC_EE_AUDIO_TODDR_B_FINISH_ADDRB                      (0xff642000 + (0x058 << 2))
+#define   P_EE_AUDIO_TODDR_B_FINISH_ADDRB                      (volatile uint32_t *)(0xff642000 + (0x058 << 2))
+#define     EE_AUDIO_TODDR_B_INIT_ADDR                         (0xff642000 + (0x059 << 2))
+#define SEC_EE_AUDIO_TODDR_B_INIT_ADDR                         (0xff642000 + (0x059 << 2))
+#define   P_EE_AUDIO_TODDR_B_INIT_ADDR                         (volatile uint32_t *)(0xff642000 + (0x059 << 2))
+#define     EE_AUDIO_TODDR_C_CTRL0                             (0xff642000 + (0x060 << 2))
+#define SEC_EE_AUDIO_TODDR_C_CTRL0                             (0xff642000 + (0x060 << 2))
+#define   P_EE_AUDIO_TODDR_C_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x060 << 2))
+#define     EE_AUDIO_TODDR_C_CTRL1                             (0xff642000 + (0x061 << 2))
+#define SEC_EE_AUDIO_TODDR_C_CTRL1                             (0xff642000 + (0x061 << 2))
+#define   P_EE_AUDIO_TODDR_C_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x061 << 2))
+#define     EE_AUDIO_TODDR_C_START_ADDR                        (0xff642000 + (0x062 << 2))
+#define SEC_EE_AUDIO_TODDR_C_START_ADDR                        (0xff642000 + (0x062 << 2))
+#define   P_EE_AUDIO_TODDR_C_START_ADDR                        (volatile uint32_t *)(0xff642000 + (0x062 << 2))
+#define     EE_AUDIO_TODDR_C_FINISH_ADDR                       (0xff642000 + (0x063 << 2))
+#define SEC_EE_AUDIO_TODDR_C_FINISH_ADDR                       (0xff642000 + (0x063 << 2))
+#define   P_EE_AUDIO_TODDR_C_FINISH_ADDR                       (volatile uint32_t *)(0xff642000 + (0x063 << 2))
+#define     EE_AUDIO_TODDR_C_INT_ADDR                          (0xff642000 + (0x064 << 2))
+#define SEC_EE_AUDIO_TODDR_C_INT_ADDR                          (0xff642000 + (0x064 << 2))
+#define   P_EE_AUDIO_TODDR_C_INT_ADDR                          (volatile uint32_t *)(0xff642000 + (0x064 << 2))
+#define     EE_AUDIO_TODDR_C_STATUS1                           (0xff642000 + (0x065 << 2))
+#define SEC_EE_AUDIO_TODDR_C_STATUS1                           (0xff642000 + (0x065 << 2))
+#define   P_EE_AUDIO_TODDR_C_STATUS1                           (volatile uint32_t *)(0xff642000 + (0x065 << 2))
+#define     EE_AUDIO_TODDR_C_STATUS2                           (0xff642000 + (0x066 << 2))
+#define SEC_EE_AUDIO_TODDR_C_STATUS2                           (0xff642000 + (0x066 << 2))
+#define   P_EE_AUDIO_TODDR_C_STATUS2                           (volatile uint32_t *)(0xff642000 + (0x066 << 2))
+#define     EE_AUDIO_TODDR_C_START_ADDRB                       (0xff642000 + (0x067 << 2))
+#define SEC_EE_AUDIO_TODDR_C_START_ADDRB                       (0xff642000 + (0x067 << 2))
+#define   P_EE_AUDIO_TODDR_C_START_ADDRB                       (volatile uint32_t *)(0xff642000 + (0x067 << 2))
+#define     EE_AUDIO_TODDR_C_FINISH_ADDRB                      (0xff642000 + (0x068 << 2))
+#define SEC_EE_AUDIO_TODDR_C_FINISH_ADDRB                      (0xff642000 + (0x068 << 2))
+#define   P_EE_AUDIO_TODDR_C_FINISH_ADDRB                      (volatile uint32_t *)(0xff642000 + (0x068 << 2))
+#define     EE_AUDIO_TODDR_C_INIT_ADDR                         (0xff642000 + (0x069 << 2))
+#define SEC_EE_AUDIO_TODDR_C_INIT_ADDR                         (0xff642000 + (0x069 << 2))
+#define   P_EE_AUDIO_TODDR_C_INIT_ADDR                         (volatile uint32_t *)(0xff642000 + (0x069 << 2))
+#define     EE_AUDIO_FRDDR_A_CTRL0                             (0xff642000 + (0x070 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_CTRL0                             (0xff642000 + (0x070 << 2))
+#define   P_EE_AUDIO_FRDDR_A_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x070 << 2))
+#define     EE_AUDIO_FRDDR_A_CTRL1                             (0xff642000 + (0x071 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_CTRL1                             (0xff642000 + (0x071 << 2))
+#define   P_EE_AUDIO_FRDDR_A_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x071 << 2))
+#define     EE_AUDIO_FRDDR_A_START_ADDR                        (0xff642000 + (0x072 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_START_ADDR                        (0xff642000 + (0x072 << 2))
+#define   P_EE_AUDIO_FRDDR_A_START_ADDR                        (volatile uint32_t *)(0xff642000 + (0x072 << 2))
+#define     EE_AUDIO_FRDDR_A_FINISH_ADDR                       (0xff642000 + (0x073 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_FINISH_ADDR                       (0xff642000 + (0x073 << 2))
+#define   P_EE_AUDIO_FRDDR_A_FINISH_ADDR                       (volatile uint32_t *)(0xff642000 + (0x073 << 2))
+#define     EE_AUDIO_FRDDR_A_INT_ADDR                          (0xff642000 + (0x074 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_INT_ADDR                          (0xff642000 + (0x074 << 2))
+#define   P_EE_AUDIO_FRDDR_A_INT_ADDR                          (volatile uint32_t *)(0xff642000 + (0x074 << 2))
+#define     EE_AUDIO_FRDDR_A_STATUS1                           (0xff642000 + (0x075 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_STATUS1                           (0xff642000 + (0x075 << 2))
+#define   P_EE_AUDIO_FRDDR_A_STATUS1                           (volatile uint32_t *)(0xff642000 + (0x075 << 2))
+#define     EE_AUDIO_FRDDR_A_STATUS2                           (0xff642000 + (0x076 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_STATUS2                           (0xff642000 + (0x076 << 2))
+#define   P_EE_AUDIO_FRDDR_A_STATUS2                           (volatile uint32_t *)(0xff642000 + (0x076 << 2))
+#define     EE_AUDIO_FRDDR_A_START_ADDRB                       (0xff642000 + (0x077 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_START_ADDRB                       (0xff642000 + (0x077 << 2))
+#define   P_EE_AUDIO_FRDDR_A_START_ADDRB                       (volatile uint32_t *)(0xff642000 + (0x077 << 2))
+#define     EE_AUDIO_FRDDR_A_FINISH_ADDRB                      (0xff642000 + (0x078 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_FINISH_ADDRB                      (0xff642000 + (0x078 << 2))
+#define   P_EE_AUDIO_FRDDR_A_FINISH_ADDRB                      (volatile uint32_t *)(0xff642000 + (0x078 << 2))
+#define     EE_AUDIO_FRDDR_A_INIT_ADDR                         (0xff642000 + (0x079 << 2))
+#define SEC_EE_AUDIO_FRDDR_A_INIT_ADDR                         (0xff642000 + (0x079 << 2))
+#define   P_EE_AUDIO_FRDDR_A_INIT_ADDR                         (volatile uint32_t *)(0xff642000 + (0x079 << 2))
+#define     EE_AUDIO_FRDDR_B_CTRL0                             (0xff642000 + (0x080 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_CTRL0                             (0xff642000 + (0x080 << 2))
+#define   P_EE_AUDIO_FRDDR_B_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x080 << 2))
+#define     EE_AUDIO_FRDDR_B_CTRL1                             (0xff642000 + (0x081 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_CTRL1                             (0xff642000 + (0x081 << 2))
+#define   P_EE_AUDIO_FRDDR_B_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x081 << 2))
+#define     EE_AUDIO_FRDDR_B_START_ADDR                        (0xff642000 + (0x082 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_START_ADDR                        (0xff642000 + (0x082 << 2))
+#define   P_EE_AUDIO_FRDDR_B_START_ADDR                        (volatile uint32_t *)(0xff642000 + (0x082 << 2))
+#define     EE_AUDIO_FRDDR_B_FINISH_ADDR                       (0xff642000 + (0x083 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_FINISH_ADDR                       (0xff642000 + (0x083 << 2))
+#define   P_EE_AUDIO_FRDDR_B_FINISH_ADDR                       (volatile uint32_t *)(0xff642000 + (0x083 << 2))
+#define     EE_AUDIO_FRDDR_B_INT_ADDR                          (0xff642000 + (0x084 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_INT_ADDR                          (0xff642000 + (0x084 << 2))
+#define   P_EE_AUDIO_FRDDR_B_INT_ADDR                          (volatile uint32_t *)(0xff642000 + (0x084 << 2))
+#define     EE_AUDIO_FRDDR_B_STATUS1                           (0xff642000 + (0x085 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_STATUS1                           (0xff642000 + (0x085 << 2))
+#define   P_EE_AUDIO_FRDDR_B_STATUS1                           (volatile uint32_t *)(0xff642000 + (0x085 << 2))
+#define     EE_AUDIO_FRDDR_B_STATUS2                           (0xff642000 + (0x086 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_STATUS2                           (0xff642000 + (0x086 << 2))
+#define   P_EE_AUDIO_FRDDR_B_STATUS2                           (volatile uint32_t *)(0xff642000 + (0x086 << 2))
+#define     EE_AUDIO_FRDDR_B_START_ADDRB                       (0xff642000 + (0x087 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_START_ADDRB                       (0xff642000 + (0x087 << 2))
+#define   P_EE_AUDIO_FRDDR_B_START_ADDRB                       (volatile uint32_t *)(0xff642000 + (0x087 << 2))
+#define     EE_AUDIO_FRDDR_B_FINISH_ADDRB                      (0xff642000 + (0x088 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_FINISH_ADDRB                      (0xff642000 + (0x088 << 2))
+#define   P_EE_AUDIO_FRDDR_B_FINISH_ADDRB                      (volatile uint32_t *)(0xff642000 + (0x088 << 2))
+#define     EE_AUDIO_FRDDR_B_INIT_ADDR                         (0xff642000 + (0x089 << 2))
+#define SEC_EE_AUDIO_FRDDR_B_INIT_ADDR                         (0xff642000 + (0x089 << 2))
+#define   P_EE_AUDIO_FRDDR_B_INIT_ADDR                         (volatile uint32_t *)(0xff642000 + (0x089 << 2))
+#define     EE_AUDIO_FRDDR_C_CTRL0                             (0xff642000 + (0x090 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_CTRL0                             (0xff642000 + (0x090 << 2))
+#define   P_EE_AUDIO_FRDDR_C_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x090 << 2))
+#define     EE_AUDIO_FRDDR_C_CTRL1                             (0xff642000 + (0x091 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_CTRL1                             (0xff642000 + (0x091 << 2))
+#define   P_EE_AUDIO_FRDDR_C_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x091 << 2))
+#define     EE_AUDIO_FRDDR_C_START_ADDR                        (0xff642000 + (0x092 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_START_ADDR                        (0xff642000 + (0x092 << 2))
+#define   P_EE_AUDIO_FRDDR_C_START_ADDR                        (volatile uint32_t *)(0xff642000 + (0x092 << 2))
+#define     EE_AUDIO_FRDDR_C_FINISH_ADDR                       (0xff642000 + (0x093 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_FINISH_ADDR                       (0xff642000 + (0x093 << 2))
+#define   P_EE_AUDIO_FRDDR_C_FINISH_ADDR                       (volatile uint32_t *)(0xff642000 + (0x093 << 2))
+#define     EE_AUDIO_FRDDR_C_INT_ADDR                          (0xff642000 + (0x094 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_INT_ADDR                          (0xff642000 + (0x094 << 2))
+#define   P_EE_AUDIO_FRDDR_C_INT_ADDR                          (volatile uint32_t *)(0xff642000 + (0x094 << 2))
+#define     EE_AUDIO_FRDDR_C_STATUS1                           (0xff642000 + (0x095 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_STATUS1                           (0xff642000 + (0x095 << 2))
+#define   P_EE_AUDIO_FRDDR_C_STATUS1                           (volatile uint32_t *)(0xff642000 + (0x095 << 2))
+#define     EE_AUDIO_FRDDR_C_STATUS2                           (0xff642000 + (0x096 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_STATUS2                           (0xff642000 + (0x096 << 2))
+#define   P_EE_AUDIO_FRDDR_C_STATUS2                           (volatile uint32_t *)(0xff642000 + (0x096 << 2))
+#define     EE_AUDIO_FRDDR_C_START_ADDRB                       (0xff642000 + (0x097 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_START_ADDRB                       (0xff642000 + (0x097 << 2))
+#define   P_EE_AUDIO_FRDDR_C_START_ADDRB                       (volatile uint32_t *)(0xff642000 + (0x097 << 2))
+#define     EE_AUDIO_FRDDR_C_FINISH_ADDRB                      (0xff642000 + (0x098 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_FINISH_ADDRB                      (0xff642000 + (0x098 << 2))
+#define   P_EE_AUDIO_FRDDR_C_FINISH_ADDRB                      (volatile uint32_t *)(0xff642000 + (0x098 << 2))
+#define     EE_AUDIO_FRDDR_C_INIT_ADDR                         (0xff642000 + (0x099 << 2))
+#define SEC_EE_AUDIO_FRDDR_C_INIT_ADDR                         (0xff642000 + (0x099 << 2))
+#define   P_EE_AUDIO_FRDDR_C_INIT_ADDR                         (volatile uint32_t *)(0xff642000 + (0x099 << 2))
+#define     EE_AUDIO_ARB_CTRL                                  (0xff642000 + (0x0a0 << 2))
+#define SEC_EE_AUDIO_ARB_CTRL                                  (0xff642000 + (0x0a0 << 2))
+#define   P_EE_AUDIO_ARB_CTRL                                  (volatile uint32_t *)(0xff642000 + (0x0a0 << 2))
+#define     EE_AUDIO_LB_CTRL0                                  (0xff642000 + (0x0b0 << 2))
+#define SEC_EE_AUDIO_LB_CTRL0                                  (0xff642000 + (0x0b0 << 2))
+#define   P_EE_AUDIO_LB_CTRL0                                  (volatile uint32_t *)(0xff642000 + (0x0b0 << 2))
+#define     EE_AUDIO_LB_CTRL1                                  (0xff642000 + (0x0b1 << 2))
+#define SEC_EE_AUDIO_LB_CTRL1                                  (0xff642000 + (0x0b1 << 2))
+#define   P_EE_AUDIO_LB_CTRL1                                  (volatile uint32_t *)(0xff642000 + (0x0b1 << 2))
+#define     EE_AUDIO_LB_DAT_CH_ID0                             (0xff642000 + (0x0b2 << 2))
+#define SEC_EE_AUDIO_LB_DAT_CH_ID0                             (0xff642000 + (0x0b2 << 2))
+#define   P_EE_AUDIO_LB_DAT_CH_ID0                             (volatile uint32_t *)(0xff642000 + (0x0b2 << 2))
+#define     EE_AUDIO_LB_DAT_CH_ID1                             (0xff642000 + (0x0b3 << 2))
+#define SEC_EE_AUDIO_LB_DAT_CH_ID1                             (0xff642000 + (0x0b3 << 2))
+#define   P_EE_AUDIO_LB_DAT_CH_ID1                             (volatile uint32_t *)(0xff642000 + (0x0b3 << 2))
+#define     EE_AUDIO_LB_LB_CH_ID0                              (0xff642000 + (0x0b4 << 2))
+#define SEC_EE_AUDIO_LB_LB_CH_ID0                              (0xff642000 + (0x0b4 << 2))
+#define   P_EE_AUDIO_LB_LB_CH_ID0                              (volatile uint32_t *)(0xff642000 + (0x0b4 << 2))
+#define     EE_AUDIO_LB_LB_CH_ID1                              (0xff642000 + (0x0b5 << 2))
+#define SEC_EE_AUDIO_LB_LB_CH_ID1                              (0xff642000 + (0x0b5 << 2))
+#define   P_EE_AUDIO_LB_LB_CH_ID1                              (volatile uint32_t *)(0xff642000 + (0x0b5 << 2))
+#define     EE_AUDIO_LB_STS                                    (0xff642000 + (0x0b6 << 2))
+#define SEC_EE_AUDIO_LB_STS                                    (0xff642000 + (0x0b6 << 2))
+#define   P_EE_AUDIO_LB_STS                                    (volatile uint32_t *)(0xff642000 + (0x0b6 << 2))
+#define     EE_AUDIO_TDMIN_A_CTRL                              (0xff642000 + (0x0c0 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_CTRL                              (0xff642000 + (0x0c0 << 2))
+#define   P_EE_AUDIO_TDMIN_A_CTRL                              (volatile uint32_t *)(0xff642000 + (0x0c0 << 2))
+#define     EE_AUDIO_TDMIN_A_SWAP                              (0xff642000 + (0x0c1 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_SWAP                              (0xff642000 + (0x0c1 << 2))
+#define   P_EE_AUDIO_TDMIN_A_SWAP                              (volatile uint32_t *)(0xff642000 + (0x0c1 << 2))
+#define     EE_AUDIO_TDMIN_A_MASK0                             (0xff642000 + (0x0c2 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MASK0                             (0xff642000 + (0x0c2 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MASK0                             (volatile uint32_t *)(0xff642000 + (0x0c2 << 2))
+#define     EE_AUDIO_TDMIN_A_MASK1                             (0xff642000 + (0x0c3 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MASK1                             (0xff642000 + (0x0c3 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MASK1                             (volatile uint32_t *)(0xff642000 + (0x0c3 << 2))
+#define     EE_AUDIO_TDMIN_A_MASK2                             (0xff642000 + (0x0c4 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MASK2                             (0xff642000 + (0x0c4 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MASK2                             (volatile uint32_t *)(0xff642000 + (0x0c4 << 2))
+#define     EE_AUDIO_TDMIN_A_MASK3                             (0xff642000 + (0x0c5 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MASK3                             (0xff642000 + (0x0c5 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MASK3                             (volatile uint32_t *)(0xff642000 + (0x0c5 << 2))
+#define     EE_AUDIO_TDMIN_A_STAT                              (0xff642000 + (0x0c6 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_STAT                              (0xff642000 + (0x0c6 << 2))
+#define   P_EE_AUDIO_TDMIN_A_STAT                              (volatile uint32_t *)(0xff642000 + (0x0c6 << 2))
+#define     EE_AUDIO_TDMIN_A_MUTE_VAL                          (0xff642000 + (0x0c7 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MUTE_VAL                          (0xff642000 + (0x0c7 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MUTE_VAL                          (volatile uint32_t *)(0xff642000 + (0x0c7 << 2))
+#define     EE_AUDIO_TDMIN_A_MUTE0                             (0xff642000 + (0x0c8 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MUTE0                             (0xff642000 + (0x0c8 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MUTE0                             (volatile uint32_t *)(0xff642000 + (0x0c8 << 2))
+#define     EE_AUDIO_TDMIN_A_MUTE1                             (0xff642000 + (0x0c9 << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MUTE1                             (0xff642000 + (0x0c9 << 2))
+#define   P_EE_AUDIO_TDMIN_A_MUTE1                             (volatile uint32_t *)(0xff642000 + (0x0c9 << 2))
+#define     EE_AUDIO_TDMIN_A_MUTE2                             (0xff642000 + (0x0ca << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MUTE2                             (0xff642000 + (0x0ca << 2))
+#define   P_EE_AUDIO_TDMIN_A_MUTE2                             (volatile uint32_t *)(0xff642000 + (0x0ca << 2))
+#define     EE_AUDIO_TDMIN_A_MUTE3                             (0xff642000 + (0x0cb << 2))
+#define SEC_EE_AUDIO_TDMIN_A_MUTE3                             (0xff642000 + (0x0cb << 2))
+#define   P_EE_AUDIO_TDMIN_A_MUTE3                             (volatile uint32_t *)(0xff642000 + (0x0cb << 2))
+#define     EE_AUDIO_TDMIN_B_CTRL                              (0xff642000 + (0x0d0 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_CTRL                              (0xff642000 + (0x0d0 << 2))
+#define   P_EE_AUDIO_TDMIN_B_CTRL                              (volatile uint32_t *)(0xff642000 + (0x0d0 << 2))
+#define     EE_AUDIO_TDMIN_B_SWAP                              (0xff642000 + (0x0d1 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_SWAP                              (0xff642000 + (0x0d1 << 2))
+#define   P_EE_AUDIO_TDMIN_B_SWAP                              (volatile uint32_t *)(0xff642000 + (0x0d1 << 2))
+#define     EE_AUDIO_TDMIN_B_MASK0                             (0xff642000 + (0x0d2 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MASK0                             (0xff642000 + (0x0d2 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MASK0                             (volatile uint32_t *)(0xff642000 + (0x0d2 << 2))
+#define     EE_AUDIO_TDMIN_B_MASK1                             (0xff642000 + (0x0d3 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MASK1                             (0xff642000 + (0x0d3 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MASK1                             (volatile uint32_t *)(0xff642000 + (0x0d3 << 2))
+#define     EE_AUDIO_TDMIN_B_MASK2                             (0xff642000 + (0x0d4 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MASK2                             (0xff642000 + (0x0d4 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MASK2                             (volatile uint32_t *)(0xff642000 + (0x0d4 << 2))
+#define     EE_AUDIO_TDMIN_B_MASK3                             (0xff642000 + (0x0d5 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MASK3                             (0xff642000 + (0x0d5 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MASK3                             (volatile uint32_t *)(0xff642000 + (0x0d5 << 2))
+#define     EE_AUDIO_TDMIN_B_STAT                              (0xff642000 + (0x0d6 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_STAT                              (0xff642000 + (0x0d6 << 2))
+#define   P_EE_AUDIO_TDMIN_B_STAT                              (volatile uint32_t *)(0xff642000 + (0x0d6 << 2))
+#define     EE_AUDIO_TDMIN_B_MUTE_VAL                          (0xff642000 + (0x0d7 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MUTE_VAL                          (0xff642000 + (0x0d7 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MUTE_VAL                          (volatile uint32_t *)(0xff642000 + (0x0d7 << 2))
+#define     EE_AUDIO_TDMIN_B_MUTE0                             (0xff642000 + (0x0d8 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MUTE0                             (0xff642000 + (0x0d8 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MUTE0                             (volatile uint32_t *)(0xff642000 + (0x0d8 << 2))
+#define     EE_AUDIO_TDMIN_B_MUTE1                             (0xff642000 + (0x0d9 << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MUTE1                             (0xff642000 + (0x0d9 << 2))
+#define   P_EE_AUDIO_TDMIN_B_MUTE1                             (volatile uint32_t *)(0xff642000 + (0x0d9 << 2))
+#define     EE_AUDIO_TDMIN_B_MUTE2                             (0xff642000 + (0x0da << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MUTE2                             (0xff642000 + (0x0da << 2))
+#define   P_EE_AUDIO_TDMIN_B_MUTE2                             (volatile uint32_t *)(0xff642000 + (0x0da << 2))
+#define     EE_AUDIO_TDMIN_B_MUTE3                             (0xff642000 + (0x0db << 2))
+#define SEC_EE_AUDIO_TDMIN_B_MUTE3                             (0xff642000 + (0x0db << 2))
+#define   P_EE_AUDIO_TDMIN_B_MUTE3                             (volatile uint32_t *)(0xff642000 + (0x0db << 2))
+#define     EE_AUDIO_TDMIN_C_CTRL                              (0xff642000 + (0x0e0 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_CTRL                              (0xff642000 + (0x0e0 << 2))
+#define   P_EE_AUDIO_TDMIN_C_CTRL                              (volatile uint32_t *)(0xff642000 + (0x0e0 << 2))
+#define     EE_AUDIO_TDMIN_C_SWAP                              (0xff642000 + (0x0e1 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_SWAP                              (0xff642000 + (0x0e1 << 2))
+#define   P_EE_AUDIO_TDMIN_C_SWAP                              (volatile uint32_t *)(0xff642000 + (0x0e1 << 2))
+#define     EE_AUDIO_TDMIN_C_MASK0                             (0xff642000 + (0x0e2 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MASK0                             (0xff642000 + (0x0e2 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MASK0                             (volatile uint32_t *)(0xff642000 + (0x0e2 << 2))
+#define     EE_AUDIO_TDMIN_C_MASK1                             (0xff642000 + (0x0e3 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MASK1                             (0xff642000 + (0x0e3 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MASK1                             (volatile uint32_t *)(0xff642000 + (0x0e3 << 2))
+#define     EE_AUDIO_TDMIN_C_MASK2                             (0xff642000 + (0x0e4 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MASK2                             (0xff642000 + (0x0e4 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MASK2                             (volatile uint32_t *)(0xff642000 + (0x0e4 << 2))
+#define     EE_AUDIO_TDMIN_C_MASK3                             (0xff642000 + (0x0e5 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MASK3                             (0xff642000 + (0x0e5 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MASK3                             (volatile uint32_t *)(0xff642000 + (0x0e5 << 2))
+#define     EE_AUDIO_TDMIN_C_STAT                              (0xff642000 + (0x0e6 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_STAT                              (0xff642000 + (0x0e6 << 2))
+#define   P_EE_AUDIO_TDMIN_C_STAT                              (volatile uint32_t *)(0xff642000 + (0x0e6 << 2))
+#define     EE_AUDIO_TDMIN_C_MUTE_VAL                          (0xff642000 + (0x0e7 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MUTE_VAL                          (0xff642000 + (0x0e7 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MUTE_VAL                          (volatile uint32_t *)(0xff642000 + (0x0e7 << 2))
+#define     EE_AUDIO_TDMIN_C_MUTE0                             (0xff642000 + (0x0e8 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MUTE0                             (0xff642000 + (0x0e8 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MUTE0                             (volatile uint32_t *)(0xff642000 + (0x0e8 << 2))
+#define     EE_AUDIO_TDMIN_C_MUTE1                             (0xff642000 + (0x0e9 << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MUTE1                             (0xff642000 + (0x0e9 << 2))
+#define   P_EE_AUDIO_TDMIN_C_MUTE1                             (volatile uint32_t *)(0xff642000 + (0x0e9 << 2))
+#define     EE_AUDIO_TDMIN_C_MUTE2                             (0xff642000 + (0x0ea << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MUTE2                             (0xff642000 + (0x0ea << 2))
+#define   P_EE_AUDIO_TDMIN_C_MUTE2                             (volatile uint32_t *)(0xff642000 + (0x0ea << 2))
+#define     EE_AUDIO_TDMIN_C_MUTE3                             (0xff642000 + (0x0eb << 2))
+#define SEC_EE_AUDIO_TDMIN_C_MUTE3                             (0xff642000 + (0x0eb << 2))
+#define   P_EE_AUDIO_TDMIN_C_MUTE3                             (volatile uint32_t *)(0xff642000 + (0x0eb << 2))
+#define     EE_AUDIO_TDMIN_LB_CTRL                             (0xff642000 + (0x0f0 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_CTRL                             (0xff642000 + (0x0f0 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_CTRL                             (volatile uint32_t *)(0xff642000 + (0x0f0 << 2))
+#define     EE_AUDIO_TDMIN_LB_SWAP                             (0xff642000 + (0x0f1 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_SWAP                             (0xff642000 + (0x0f1 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_SWAP                             (volatile uint32_t *)(0xff642000 + (0x0f1 << 2))
+#define     EE_AUDIO_TDMIN_LB_MASK0                            (0xff642000 + (0x0f2 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MASK0                            (0xff642000 + (0x0f2 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MASK0                            (volatile uint32_t *)(0xff642000 + (0x0f2 << 2))
+#define     EE_AUDIO_TDMIN_LB_MASK1                            (0xff642000 + (0x0f3 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MASK1                            (0xff642000 + (0x0f3 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MASK1                            (volatile uint32_t *)(0xff642000 + (0x0f3 << 2))
+#define     EE_AUDIO_TDMIN_LB_MASK2                            (0xff642000 + (0x0f4 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MASK2                            (0xff642000 + (0x0f4 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MASK2                            (volatile uint32_t *)(0xff642000 + (0x0f4 << 2))
+#define     EE_AUDIO_TDMIN_LB_MASK3                            (0xff642000 + (0x0f5 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MASK3                            (0xff642000 + (0x0f5 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MASK3                            (volatile uint32_t *)(0xff642000 + (0x0f5 << 2))
+#define     EE_AUDIO_TDMIN_LB_STAT                             (0xff642000 + (0x0f6 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_STAT                             (0xff642000 + (0x0f6 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_STAT                             (volatile uint32_t *)(0xff642000 + (0x0f6 << 2))
+#define     EE_AUDIO_TDMIN_LB_MUTE_VAL                         (0xff642000 + (0x0f7 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MUTE_VAL                         (0xff642000 + (0x0f7 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MUTE_VAL                         (volatile uint32_t *)(0xff642000 + (0x0f7 << 2))
+#define     EE_AUDIO_TDMIN_LB_MUTE0                            (0xff642000 + (0x0f8 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MUTE0                            (0xff642000 + (0x0f8 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MUTE0                            (volatile uint32_t *)(0xff642000 + (0x0f8 << 2))
+#define     EE_AUDIO_TDMIN_LB_MUTE1                            (0xff642000 + (0x0f9 << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MUTE1                            (0xff642000 + (0x0f9 << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MUTE1                            (volatile uint32_t *)(0xff642000 + (0x0f9 << 2))
+#define     EE_AUDIO_TDMIN_LB_MUTE2                            (0xff642000 + (0x0fa << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MUTE2                            (0xff642000 + (0x0fa << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MUTE2                            (volatile uint32_t *)(0xff642000 + (0x0fa << 2))
+#define     EE_AUDIO_TDMIN_LB_MUTE3                            (0xff642000 + (0x0fb << 2))
+#define SEC_EE_AUDIO_TDMIN_LB_MUTE3                            (0xff642000 + (0x0fb << 2))
+#define   P_EE_AUDIO_TDMIN_LB_MUTE3                            (volatile uint32_t *)(0xff642000 + (0x0fb << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL0                             (0xff642000 + (0x100 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL0                             (0xff642000 + (0x100 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x100 << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL1                             (0xff642000 + (0x101 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL1                             (0xff642000 + (0x101 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x101 << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL2                             (0xff642000 + (0x102 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL2                             (0xff642000 + (0x102 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL2                             (volatile uint32_t *)(0xff642000 + (0x102 << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL3                             (0xff642000 + (0x103 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL3                             (0xff642000 + (0x103 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL3                             (volatile uint32_t *)(0xff642000 + (0x103 << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL4                             (0xff642000 + (0x104 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL4                             (0xff642000 + (0x104 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL4                             (volatile uint32_t *)(0xff642000 + (0x104 << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL5                             (0xff642000 + (0x105 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL5                             (0xff642000 + (0x105 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL5                             (volatile uint32_t *)(0xff642000 + (0x105 << 2))
+#define     EE_AUDIO_SPDIFIN_CTRL6                             (0xff642000 + (0x106 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_CTRL6                             (0xff642000 + (0x106 << 2))
+#define   P_EE_AUDIO_SPDIFIN_CTRL6                             (volatile uint32_t *)(0xff642000 + (0x106 << 2))
+#define     EE_AUDIO_SPDIFIN_STAT0                             (0xff642000 + (0x107 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_STAT0                             (0xff642000 + (0x107 << 2))
+#define   P_EE_AUDIO_SPDIFIN_STAT0                             (volatile uint32_t *)(0xff642000 + (0x107 << 2))
+#define     EE_AUDIO_SPDIFIN_STAT1                             (0xff642000 + (0x108 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_STAT1                             (0xff642000 + (0x108 << 2))
+#define   P_EE_AUDIO_SPDIFIN_STAT1                             (volatile uint32_t *)(0xff642000 + (0x108 << 2))
+#define     EE_AUDIO_SPDIFIN_STAT2                             (0xff642000 + (0x109 << 2))
+#define SEC_EE_AUDIO_SPDIFIN_STAT2                             (0xff642000 + (0x109 << 2))
+#define   P_EE_AUDIO_SPDIFIN_STAT2                             (volatile uint32_t *)(0xff642000 + (0x109 << 2))
+#define     EE_AUDIO_SPDIFIN_MUTE_VAL                          (0xff642000 + (0x10a << 2))
+#define SEC_EE_AUDIO_SPDIFIN_MUTE_VAL                          (0xff642000 + (0x10a << 2))
+#define   P_EE_AUDIO_SPDIFIN_MUTE_VAL                          (volatile uint32_t *)(0xff642000 + (0x10a << 2))
+#define     EE_AUDIO_RESAMPLE_CTRL0                            (0xff642000 + (0x110 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_CTRL0                            (0xff642000 + (0x110 << 2))
+#define   P_EE_AUDIO_RESAMPLE_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x110 << 2))
+#define     EE_AUDIO_RESAMPLE_CTRL1                            (0xff642000 + (0x111 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_CTRL1                            (0xff642000 + (0x111 << 2))
+#define   P_EE_AUDIO_RESAMPLE_CTRL1                            (volatile uint32_t *)(0xff642000 + (0x111 << 2))
+#define     EE_AUDIO_RESAMPLE_CTRL2                            (0xff642000 + (0x112 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_CTRL2                            (0xff642000 + (0x112 << 2))
+#define   P_EE_AUDIO_RESAMPLE_CTRL2                            (volatile uint32_t *)(0xff642000 + (0x112 << 2))
+#define     EE_AUDIO_RESAMPLE_CTRL3                            (0xff642000 + (0x113 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_CTRL3                            (0xff642000 + (0x113 << 2))
+#define   P_EE_AUDIO_RESAMPLE_CTRL3                            (volatile uint32_t *)(0xff642000 + (0x113 << 2))
+#define     EE_AUDIO_RESAMPLE_COEF0                            (0xff642000 + (0x114 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_COEF0                            (0xff642000 + (0x114 << 2))
+#define   P_EE_AUDIO_RESAMPLE_COEF0                            (volatile uint32_t *)(0xff642000 + (0x114 << 2))
+#define     EE_AUDIO_RESAMPLE_COEF1                            (0xff642000 + (0x115 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_COEF1                            (0xff642000 + (0x115 << 2))
+#define   P_EE_AUDIO_RESAMPLE_COEF1                            (volatile uint32_t *)(0xff642000 + (0x115 << 2))
+#define     EE_AUDIO_RESAMPLE_COEF2                            (0xff642000 + (0x116 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_COEF2                            (0xff642000 + (0x116 << 2))
+#define   P_EE_AUDIO_RESAMPLE_COEF2                            (volatile uint32_t *)(0xff642000 + (0x116 << 2))
+#define     EE_AUDIO_RESAMPLE_COEF3                            (0xff642000 + (0x117 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_COEF3                            (0xff642000 + (0x117 << 2))
+#define   P_EE_AUDIO_RESAMPLE_COEF3                            (volatile uint32_t *)(0xff642000 + (0x117 << 2))
+#define     EE_AUDIO_RESAMPLE_COEF4                            (0xff642000 + (0x118 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_COEF4                            (0xff642000 + (0x118 << 2))
+#define   P_EE_AUDIO_RESAMPLE_COEF4                            (volatile uint32_t *)(0xff642000 + (0x118 << 2))
+#define     EE_AUDIO_RESAMPLE_STATUS1                          (0xff642000 + (0x119 << 2))
+#define SEC_EE_AUDIO_RESAMPLE_STATUS1                          (0xff642000 + (0x119 << 2))
+#define   P_EE_AUDIO_RESAMPLE_STATUS1                          (volatile uint32_t *)(0xff642000 + (0x119 << 2))
+#define     EE_AUDIO_SPDIFOUT_STAT                             (0xff642000 + (0x120 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_STAT                             (0xff642000 + (0x120 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_STAT                             (volatile uint32_t *)(0xff642000 + (0x120 << 2))
+#define     EE_AUDIO_SPDIFOUT_GAIN0                            (0xff642000 + (0x121 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_GAIN0                            (0xff642000 + (0x121 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_GAIN0                            (volatile uint32_t *)(0xff642000 + (0x121 << 2))
+#define     EE_AUDIO_SPDIFOUT_GAIN1                            (0xff642000 + (0x122 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_GAIN1                            (0xff642000 + (0x122 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_GAIN1                            (volatile uint32_t *)(0xff642000 + (0x122 << 2))
+#define     EE_AUDIO_SPDIFOUT_CTRL0                            (0xff642000 + (0x123 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CTRL0                            (0xff642000 + (0x123 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x123 << 2))
+#define     EE_AUDIO_SPDIFOUT_CTRL1                            (0xff642000 + (0x124 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CTRL1                            (0xff642000 + (0x124 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CTRL1                            (volatile uint32_t *)(0xff642000 + (0x124 << 2))
+#define     EE_AUDIO_SPDIFOUT_PREAMB                           (0xff642000 + (0x125 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_PREAMB                           (0xff642000 + (0x125 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_PREAMB                           (volatile uint32_t *)(0xff642000 + (0x125 << 2))
+#define     EE_AUDIO_SPDIFOUT_SWAP                             (0xff642000 + (0x126 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_SWAP                             (0xff642000 + (0x126 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_SWAP                             (volatile uint32_t *)(0xff642000 + (0x126 << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS0                           (0xff642000 + (0x127 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS0                           (0xff642000 + (0x127 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS0                           (volatile uint32_t *)(0xff642000 + (0x127 << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS1                           (0xff642000 + (0x128 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS1                           (0xff642000 + (0x128 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS1                           (volatile uint32_t *)(0xff642000 + (0x128 << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS2                           (0xff642000 + (0x129 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS2                           (0xff642000 + (0x129 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS2                           (volatile uint32_t *)(0xff642000 + (0x129 << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS3                           (0xff642000 + (0x12a << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS3                           (0xff642000 + (0x12a << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS3                           (volatile uint32_t *)(0xff642000 + (0x12a << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS4                           (0xff642000 + (0x12b << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS4                           (0xff642000 + (0x12b << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS4                           (volatile uint32_t *)(0xff642000 + (0x12b << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS5                           (0xff642000 + (0x12c << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS5                           (0xff642000 + (0x12c << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS5                           (volatile uint32_t *)(0xff642000 + (0x12c << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS6                           (0xff642000 + (0x12d << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS6                           (0xff642000 + (0x12d << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS6                           (volatile uint32_t *)(0xff642000 + (0x12d << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS7                           (0xff642000 + (0x12e << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS7                           (0xff642000 + (0x12e << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS7                           (volatile uint32_t *)(0xff642000 + (0x12e << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS8                           (0xff642000 + (0x12f << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS8                           (0xff642000 + (0x12f << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS8                           (volatile uint32_t *)(0xff642000 + (0x12f << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTS9                           (0xff642000 + (0x130 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTS9                           (0xff642000 + (0x130 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTS9                           (volatile uint32_t *)(0xff642000 + (0x130 << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTSA                           (0xff642000 + (0x131 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTSA                           (0xff642000 + (0x131 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTSA                           (volatile uint32_t *)(0xff642000 + (0x131 << 2))
+#define     EE_AUDIO_SPDIFOUT_CHSTSB                           (0xff642000 + (0x132 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_CHSTSB                           (0xff642000 + (0x132 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_CHSTSB                           (volatile uint32_t *)(0xff642000 + (0x132 << 2))
+#define     EE_AUDIO_SPDIFOUT_MUTE_VAL                         (0xff642000 + (0x133 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_MUTE_VAL                         (0xff642000 + (0x133 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_MUTE_VAL                         (volatile uint32_t *)(0xff642000 + (0x133 << 2))
+#define     EE_AUDIO_TDMOUT_A_CTRL0                            (0xff642000 + (0x140 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_CTRL0                            (0xff642000 + (0x140 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x140 << 2))
+#define     EE_AUDIO_TDMOUT_A_CTRL1                            (0xff642000 + (0x141 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_CTRL1                            (0xff642000 + (0x141 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_CTRL1                            (volatile uint32_t *)(0xff642000 + (0x141 << 2))
+#define     EE_AUDIO_TDMOUT_A_SWAP                             (0xff642000 + (0x142 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_SWAP                             (0xff642000 + (0x142 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_SWAP                             (volatile uint32_t *)(0xff642000 + (0x142 << 2))
+#define     EE_AUDIO_TDMOUT_A_MASK0                            (0xff642000 + (0x143 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MASK0                            (0xff642000 + (0x143 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MASK0                            (volatile uint32_t *)(0xff642000 + (0x143 << 2))
+#define     EE_AUDIO_TDMOUT_A_MASK1                            (0xff642000 + (0x144 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MASK1                            (0xff642000 + (0x144 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MASK1                            (volatile uint32_t *)(0xff642000 + (0x144 << 2))
+#define     EE_AUDIO_TDMOUT_A_MASK2                            (0xff642000 + (0x145 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MASK2                            (0xff642000 + (0x145 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MASK2                            (volatile uint32_t *)(0xff642000 + (0x145 << 2))
+#define     EE_AUDIO_TDMOUT_A_MASK3                            (0xff642000 + (0x146 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MASK3                            (0xff642000 + (0x146 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MASK3                            (volatile uint32_t *)(0xff642000 + (0x146 << 2))
+#define     EE_AUDIO_TDMOUT_A_STAT                             (0xff642000 + (0x147 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_STAT                             (0xff642000 + (0x147 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_STAT                             (volatile uint32_t *)(0xff642000 + (0x147 << 2))
+#define     EE_AUDIO_TDMOUT_A_GAIN0                            (0xff642000 + (0x148 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_GAIN0                            (0xff642000 + (0x148 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_GAIN0                            (volatile uint32_t *)(0xff642000 + (0x148 << 2))
+#define     EE_AUDIO_TDMOUT_A_GAIN1                            (0xff642000 + (0x149 << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_GAIN1                            (0xff642000 + (0x149 << 2))
+#define   P_EE_AUDIO_TDMOUT_A_GAIN1                            (volatile uint32_t *)(0xff642000 + (0x149 << 2))
+#define     EE_AUDIO_TDMOUT_A_MUTE_VAL                         (0xff642000 + (0x14a << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MUTE_VAL                         (0xff642000 + (0x14a << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MUTE_VAL                         (volatile uint32_t *)(0xff642000 + (0x14a << 2))
+#define     EE_AUDIO_TDMOUT_A_MUTE0                            (0xff642000 + (0x14b << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MUTE0                            (0xff642000 + (0x14b << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MUTE0                            (volatile uint32_t *)(0xff642000 + (0x14b << 2))
+#define     EE_AUDIO_TDMOUT_A_MUTE1                            (0xff642000 + (0x14c << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MUTE1                            (0xff642000 + (0x14c << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MUTE1                            (volatile uint32_t *)(0xff642000 + (0x14c << 2))
+#define     EE_AUDIO_TDMOUT_A_MUTE2                            (0xff642000 + (0x14d << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MUTE2                            (0xff642000 + (0x14d << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MUTE2                            (volatile uint32_t *)(0xff642000 + (0x14d << 2))
+#define     EE_AUDIO_TDMOUT_A_MUTE3                            (0xff642000 + (0x14e << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MUTE3                            (0xff642000 + (0x14e << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MUTE3                            (volatile uint32_t *)(0xff642000 + (0x14e << 2))
+#define     EE_AUDIO_TDMOUT_A_MASK_VAL                         (0xff642000 + (0x14f << 2))
+#define SEC_EE_AUDIO_TDMOUT_A_MASK_VAL                         (0xff642000 + (0x14f << 2))
+#define   P_EE_AUDIO_TDMOUT_A_MASK_VAL                         (volatile uint32_t *)(0xff642000 + (0x14f << 2))
+#define     EE_AUDIO_TDMOUT_B_CTRL0                            (0xff642000 + (0x150 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_CTRL0                            (0xff642000 + (0x150 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x150 << 2))
+#define     EE_AUDIO_TDMOUT_B_CTRL1                            (0xff642000 + (0x151 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_CTRL1                            (0xff642000 + (0x151 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_CTRL1                            (volatile uint32_t *)(0xff642000 + (0x151 << 2))
+#define     EE_AUDIO_TDMOUT_B_SWAP                             (0xff642000 + (0x152 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_SWAP                             (0xff642000 + (0x152 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_SWAP                             (volatile uint32_t *)(0xff642000 + (0x152 << 2))
+#define     EE_AUDIO_TDMOUT_B_MASK0                            (0xff642000 + (0x153 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MASK0                            (0xff642000 + (0x153 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MASK0                            (volatile uint32_t *)(0xff642000 + (0x153 << 2))
+#define     EE_AUDIO_TDMOUT_B_MASK1                            (0xff642000 + (0x154 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MASK1                            (0xff642000 + (0x154 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MASK1                            (volatile uint32_t *)(0xff642000 + (0x154 << 2))
+#define     EE_AUDIO_TDMOUT_B_MASK2                            (0xff642000 + (0x155 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MASK2                            (0xff642000 + (0x155 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MASK2                            (volatile uint32_t *)(0xff642000 + (0x155 << 2))
+#define     EE_AUDIO_TDMOUT_B_MASK3                            (0xff642000 + (0x156 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MASK3                            (0xff642000 + (0x156 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MASK3                            (volatile uint32_t *)(0xff642000 + (0x156 << 2))
+#define     EE_AUDIO_TDMOUT_B_STAT                             (0xff642000 + (0x157 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_STAT                             (0xff642000 + (0x157 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_STAT                             (volatile uint32_t *)(0xff642000 + (0x157 << 2))
+#define     EE_AUDIO_TDMOUT_B_GAIN0                            (0xff642000 + (0x158 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_GAIN0                            (0xff642000 + (0x158 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_GAIN0                            (volatile uint32_t *)(0xff642000 + (0x158 << 2))
+#define     EE_AUDIO_TDMOUT_B_GAIN1                            (0xff642000 + (0x159 << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_GAIN1                            (0xff642000 + (0x159 << 2))
+#define   P_EE_AUDIO_TDMOUT_B_GAIN1                            (volatile uint32_t *)(0xff642000 + (0x159 << 2))
+#define     EE_AUDIO_TDMOUT_B_MUTE_VAL                         (0xff642000 + (0x15a << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MUTE_VAL                         (0xff642000 + (0x15a << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MUTE_VAL                         (volatile uint32_t *)(0xff642000 + (0x15a << 2))
+#define     EE_AUDIO_TDMOUT_B_MUTE0                            (0xff642000 + (0x15b << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MUTE0                            (0xff642000 + (0x15b << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MUTE0                            (volatile uint32_t *)(0xff642000 + (0x15b << 2))
+#define     EE_AUDIO_TDMOUT_B_MUTE1                            (0xff642000 + (0x15c << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MUTE1                            (0xff642000 + (0x15c << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MUTE1                            (volatile uint32_t *)(0xff642000 + (0x15c << 2))
+#define     EE_AUDIO_TDMOUT_B_MUTE2                            (0xff642000 + (0x15d << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MUTE2                            (0xff642000 + (0x15d << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MUTE2                            (volatile uint32_t *)(0xff642000 + (0x15d << 2))
+#define     EE_AUDIO_TDMOUT_B_MUTE3                            (0xff642000 + (0x15e << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MUTE3                            (0xff642000 + (0x15e << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MUTE3                            (volatile uint32_t *)(0xff642000 + (0x15e << 2))
+#define     EE_AUDIO_TDMOUT_B_MASK_VAL                         (0xff642000 + (0x15f << 2))
+#define SEC_EE_AUDIO_TDMOUT_B_MASK_VAL                         (0xff642000 + (0x15f << 2))
+#define   P_EE_AUDIO_TDMOUT_B_MASK_VAL                         (volatile uint32_t *)(0xff642000 + (0x15f << 2))
+#define     EE_AUDIO_TDMOUT_C_CTRL0                            (0xff642000 + (0x160 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_CTRL0                            (0xff642000 + (0x160 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x160 << 2))
+#define     EE_AUDIO_TDMOUT_C_CTRL1                            (0xff642000 + (0x161 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_CTRL1                            (0xff642000 + (0x161 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_CTRL1                            (volatile uint32_t *)(0xff642000 + (0x161 << 2))
+#define     EE_AUDIO_TDMOUT_C_SWAP                             (0xff642000 + (0x162 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_SWAP                             (0xff642000 + (0x162 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_SWAP                             (volatile uint32_t *)(0xff642000 + (0x162 << 2))
+#define     EE_AUDIO_TDMOUT_C_MASK0                            (0xff642000 + (0x163 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MASK0                            (0xff642000 + (0x163 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MASK0                            (volatile uint32_t *)(0xff642000 + (0x163 << 2))
+#define     EE_AUDIO_TDMOUT_C_MASK1                            (0xff642000 + (0x164 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MASK1                            (0xff642000 + (0x164 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MASK1                            (volatile uint32_t *)(0xff642000 + (0x164 << 2))
+#define     EE_AUDIO_TDMOUT_C_MASK2                            (0xff642000 + (0x165 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MASK2                            (0xff642000 + (0x165 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MASK2                            (volatile uint32_t *)(0xff642000 + (0x165 << 2))
+#define     EE_AUDIO_TDMOUT_C_MASK3                            (0xff642000 + (0x166 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MASK3                            (0xff642000 + (0x166 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MASK3                            (volatile uint32_t *)(0xff642000 + (0x166 << 2))
+#define     EE_AUDIO_TDMOUT_C_STAT                             (0xff642000 + (0x167 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_STAT                             (0xff642000 + (0x167 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_STAT                             (volatile uint32_t *)(0xff642000 + (0x167 << 2))
+#define     EE_AUDIO_TDMOUT_C_GAIN0                            (0xff642000 + (0x168 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_GAIN0                            (0xff642000 + (0x168 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_GAIN0                            (volatile uint32_t *)(0xff642000 + (0x168 << 2))
+#define     EE_AUDIO_TDMOUT_C_GAIN1                            (0xff642000 + (0x169 << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_GAIN1                            (0xff642000 + (0x169 << 2))
+#define   P_EE_AUDIO_TDMOUT_C_GAIN1                            (volatile uint32_t *)(0xff642000 + (0x169 << 2))
+#define     EE_AUDIO_TDMOUT_C_MUTE_VAL                         (0xff642000 + (0x16a << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MUTE_VAL                         (0xff642000 + (0x16a << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MUTE_VAL                         (volatile uint32_t *)(0xff642000 + (0x16a << 2))
+#define     EE_AUDIO_TDMOUT_C_MUTE0                            (0xff642000 + (0x16b << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MUTE0                            (0xff642000 + (0x16b << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MUTE0                            (volatile uint32_t *)(0xff642000 + (0x16b << 2))
+#define     EE_AUDIO_TDMOUT_C_MUTE1                            (0xff642000 + (0x16c << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MUTE1                            (0xff642000 + (0x16c << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MUTE1                            (volatile uint32_t *)(0xff642000 + (0x16c << 2))
+#define     EE_AUDIO_TDMOUT_C_MUTE2                            (0xff642000 + (0x16d << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MUTE2                            (0xff642000 + (0x16d << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MUTE2                            (volatile uint32_t *)(0xff642000 + (0x16d << 2))
+#define     EE_AUDIO_TDMOUT_C_MUTE3                            (0xff642000 + (0x16e << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MUTE3                            (0xff642000 + (0x16e << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MUTE3                            (volatile uint32_t *)(0xff642000 + (0x16e << 2))
+#define     EE_AUDIO_TDMOUT_C_MASK_VAL                         (0xff642000 + (0x16f << 2))
+#define SEC_EE_AUDIO_TDMOUT_C_MASK_VAL                         (0xff642000 + (0x16f << 2))
+#define   P_EE_AUDIO_TDMOUT_C_MASK_VAL                         (volatile uint32_t *)(0xff642000 + (0x16f << 2))
+#define     EE_AUDIO_POW_DET_CTRL0                             (0xff642000 + (0x180 << 2))
+#define SEC_EE_AUDIO_POW_DET_CTRL0                             (0xff642000 + (0x180 << 2))
+#define   P_EE_AUDIO_POW_DET_CTRL0                             (volatile uint32_t *)(0xff642000 + (0x180 << 2))
+#define     EE_AUDIO_POW_DET_CTRL1                             (0xff642000 + (0x181 << 2))
+#define SEC_EE_AUDIO_POW_DET_CTRL1                             (0xff642000 + (0x181 << 2))
+#define   P_EE_AUDIO_POW_DET_CTRL1                             (volatile uint32_t *)(0xff642000 + (0x181 << 2))
+#define     EE_AUDIO_POW_DET_TH_HI                             (0xff642000 + (0x182 << 2))
+#define SEC_EE_AUDIO_POW_DET_TH_HI                             (0xff642000 + (0x182 << 2))
+#define   P_EE_AUDIO_POW_DET_TH_HI                             (volatile uint32_t *)(0xff642000 + (0x182 << 2))
+#define     EE_AUDIO_POW_DET_TH_LO                             (0xff642000 + (0x183 << 2))
+#define SEC_EE_AUDIO_POW_DET_TH_LO                             (0xff642000 + (0x183 << 2))
+#define   P_EE_AUDIO_POW_DET_TH_LO                             (volatile uint32_t *)(0xff642000 + (0x183 << 2))
+#define     EE_AUDIO_POW_DET_VALUE                             (0xff642000 + (0x184 << 2))
+#define SEC_EE_AUDIO_POW_DET_VALUE                             (0xff642000 + (0x184 << 2))
+#define   P_EE_AUDIO_POW_DET_VALUE                             (volatile uint32_t *)(0xff642000 + (0x184 << 2))
+#define     EE_AUDIO_SECURITY_CTRL                             (0xff642000 + (0x193 << 2))
+#define SEC_EE_AUDIO_SECURITY_CTRL                             (0xff642000 + (0x193 << 2))
+#define   P_EE_AUDIO_SECURITY_CTRL                             (volatile uint32_t *)(0xff642000 + (0x193 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_STAT                           (0xff642000 + (0x1a0 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_STAT                           (0xff642000 + (0x1a0 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_STAT                           (volatile uint32_t *)(0xff642000 + (0x1a0 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_GAIN0                          (0xff642000 + (0x1a1 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_GAIN0                          (0xff642000 + (0x1a1 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_GAIN0                          (volatile uint32_t *)(0xff642000 + (0x1a1 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_GAIN1                          (0xff642000 + (0x1a2 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_GAIN1                          (0xff642000 + (0x1a2 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_GAIN1                          (volatile uint32_t *)(0xff642000 + (0x1a2 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CTRL0                          (0xff642000 + (0x1a3 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CTRL0                          (0xff642000 + (0x1a3 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CTRL0                          (volatile uint32_t *)(0xff642000 + (0x1a3 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CTRL1                          (0xff642000 + (0x1a4 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CTRL1                          (0xff642000 + (0x1a4 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CTRL1                          (volatile uint32_t *)(0xff642000 + (0x1a4 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_PREAMB                         (0xff642000 + (0x1a5 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_PREAMB                         (0xff642000 + (0x1a5 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_PREAMB                         (volatile uint32_t *)(0xff642000 + (0x1a5 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_SWAP                           (0xff642000 + (0x1a6 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_SWAP                           (0xff642000 + (0x1a6 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_SWAP                           (volatile uint32_t *)(0xff642000 + (0x1a6 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS0                         (0xff642000 + (0x1a7 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS0                         (0xff642000 + (0x1a7 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS0                         (volatile uint32_t *)(0xff642000 + (0x1a7 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS1                         (0xff642000 + (0x1a8 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS1                         (0xff642000 + (0x1a8 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS1                         (volatile uint32_t *)(0xff642000 + (0x1a8 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS2                         (0xff642000 + (0x1a9 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS2                         (0xff642000 + (0x1a9 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS2                         (volatile uint32_t *)(0xff642000 + (0x1a9 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS3                         (0xff642000 + (0x1aa << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS3                         (0xff642000 + (0x1aa << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS3                         (volatile uint32_t *)(0xff642000 + (0x1aa << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS4                         (0xff642000 + (0x1ab << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS4                         (0xff642000 + (0x1ab << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS4                         (volatile uint32_t *)(0xff642000 + (0x1ab << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS5                         (0xff642000 + (0x1ac << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS5                         (0xff642000 + (0x1ac << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS5                         (volatile uint32_t *)(0xff642000 + (0x1ac << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS6                         (0xff642000 + (0x1ad << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS6                         (0xff642000 + (0x1ad << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS6                         (volatile uint32_t *)(0xff642000 + (0x1ad << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS7                         (0xff642000 + (0x1ae << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS7                         (0xff642000 + (0x1ae << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS7                         (volatile uint32_t *)(0xff642000 + (0x1ae << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS8                         (0xff642000 + (0x1af << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS8                         (0xff642000 + (0x1af << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS8                         (volatile uint32_t *)(0xff642000 + (0x1af << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTS9                         (0xff642000 + (0x1b0 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTS9                         (0xff642000 + (0x1b0 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTS9                         (volatile uint32_t *)(0xff642000 + (0x1b0 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTSA                         (0xff642000 + (0x1b1 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTSA                         (0xff642000 + (0x1b1 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTSA                         (volatile uint32_t *)(0xff642000 + (0x1b1 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_CHSTSB                         (0xff642000 + (0x1b2 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_CHSTSB                         (0xff642000 + (0x1b2 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_CHSTSB                         (volatile uint32_t *)(0xff642000 + (0x1b2 << 2))
+#define     EE_AUDIO_SPDIFOUT_B_MUTE_VAL                       (0xff642000 + (0x1b3 << 2))
+#define SEC_EE_AUDIO_SPDIFOUT_B_MUTE_VAL                       (0xff642000 + (0x1b3 << 2))
+#define   P_EE_AUDIO_SPDIFOUT_B_MUTE_VAL                       (volatile uint32_t *)(0xff642000 + (0x1b3 << 2))
+#define     EE_AUDIO_TORAM_CTRL0                               (0xff642000 + (0x1c0 << 2))
+#define SEC_EE_AUDIO_TORAM_CTRL0                               (0xff642000 + (0x1c0 << 2))
+#define   P_EE_AUDIO_TORAM_CTRL0                               (volatile uint32_t *)(0xff642000 + (0x1c0 << 2))
+#define     EE_AUDIO_TORAM_CTRL1                               (0xff642000 + (0x1c1 << 2))
+#define SEC_EE_AUDIO_TORAM_CTRL1                               (0xff642000 + (0x1c1 << 2))
+#define   P_EE_AUDIO_TORAM_CTRL1                               (volatile uint32_t *)(0xff642000 + (0x1c1 << 2))
+#define     EE_AUDIO_TORAM_START_ADDR                          (0xff642000 + (0x1c2 << 2))
+#define SEC_EE_AUDIO_TORAM_START_ADDR                          (0xff642000 + (0x1c2 << 2))
+#define   P_EE_AUDIO_TORAM_START_ADDR                          (volatile uint32_t *)(0xff642000 + (0x1c2 << 2))
+#define     EE_AUDIO_TORAM_FINISH_ADDR                         (0xff642000 + (0x1c3 << 2))
+#define SEC_EE_AUDIO_TORAM_FINISH_ADDR                         (0xff642000 + (0x1c3 << 2))
+#define   P_EE_AUDIO_TORAM_FINISH_ADDR                         (volatile uint32_t *)(0xff642000 + (0x1c3 << 2))
+#define     EE_AUDIO_TORAM_INT_ADDR                            (0xff642000 + (0x1c4 << 2))
+#define SEC_EE_AUDIO_TORAM_INT_ADDR                            (0xff642000 + (0x1c4 << 2))
+#define   P_EE_AUDIO_TORAM_INT_ADDR                            (volatile uint32_t *)(0xff642000 + (0x1c4 << 2))
+#define     EE_AUDIO_TORAM_STATUS1                             (0xff642000 + (0x1c5 << 2))
+#define SEC_EE_AUDIO_TORAM_STATUS1                             (0xff642000 + (0x1c5 << 2))
+#define   P_EE_AUDIO_TORAM_STATUS1                             (volatile uint32_t *)(0xff642000 + (0x1c5 << 2))
+#define     EE_AUDIO_TORAM_STATUS2                             (0xff642000 + (0x1c6 << 2))
+#define SEC_EE_AUDIO_TORAM_STATUS2                             (0xff642000 + (0x1c6 << 2))
+#define   P_EE_AUDIO_TORAM_STATUS2                             (volatile uint32_t *)(0xff642000 + (0x1c6 << 2))
+#define     EE_AUDIO_TORAM_INIT_ADDR                           (0xff642000 + (0x1c7 << 2))
+#define SEC_EE_AUDIO_TORAM_INIT_ADDR                           (0xff642000 + (0x1c7 << 2))
+#define   P_EE_AUDIO_TORAM_INIT_ADDR                           (volatile uint32_t *)(0xff642000 + (0x1c7 << 2))
+#define     EE_AUDIO_TOACODEC_CTRL0                            (0xff642000 + (0x1d0 << 2))
+#define SEC_EE_AUDIO_TOACODEC_CTRL0                            (0xff642000 + (0x1d0 << 2))
+#define   P_EE_AUDIO_TOACODEC_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x1d0 << 2))
+#define     EE_AUDIO_TOHDMITX_CTRL0                            (0xff642000 + (0x1d1 << 2))
+#define SEC_EE_AUDIO_TOHDMITX_CTRL0                            (0xff642000 + (0x1d1 << 2))
+#define   P_EE_AUDIO_TOHDMITX_CTRL0                            (volatile uint32_t *)(0xff642000 + (0x1d1 << 2))
+//eq drc register
+#define     AED_EQ_CH1_COEF00                                  (0xff642000 + (0x200 << 2))
+#define SEC_AED_EQ_CH1_COEF00                                  (0xff642000 + (0x200 << 2))
+#define   P_AED_EQ_CH1_COEF00                                  (volatile uint32_t *)(0xff642000 + (0x200 << 2))
+#define     AED_EQ_CH1_COEF01                                  (0xff642000 + (0x201 << 2))
+#define SEC_AED_EQ_CH1_COEF01                                  (0xff642000 + (0x201 << 2))
+#define   P_AED_EQ_CH1_COEF01                                  (volatile uint32_t *)(0xff642000 + (0x201 << 2))
+#define     AED_EQ_CH1_COEF02                                  (0xff642000 + (0x202 << 2))
+#define SEC_AED_EQ_CH1_COEF02                                  (0xff642000 + (0x202 << 2))
+#define   P_AED_EQ_CH1_COEF02                                  (volatile uint32_t *)(0xff642000 + (0x202 << 2))
+#define     AED_EQ_CH1_COEF03                                  (0xff642000 + (0x203 << 2))
+#define SEC_AED_EQ_CH1_COEF03                                  (0xff642000 + (0x203 << 2))
+#define   P_AED_EQ_CH1_COEF03                                  (volatile uint32_t *)(0xff642000 + (0x203 << 2))
+#define     AED_EQ_CH1_COEF04                                  (0xff642000 + (0x204 << 2))
+#define SEC_AED_EQ_CH1_COEF04                                  (0xff642000 + (0x204 << 2))
+#define   P_AED_EQ_CH1_COEF04                                  (volatile uint32_t *)(0xff642000 + (0x204 << 2))
+#define     AED_EQ_CH1_COEF10                                  (0xff642000 + (0x205 << 2))
+#define SEC_AED_EQ_CH1_COEF10                                  (0xff642000 + (0x205 << 2))
+#define   P_AED_EQ_CH1_COEF10                                  (volatile uint32_t *)(0xff642000 + (0x205 << 2))
+#define     AED_EQ_CH1_COEF11                                  (0xff642000 + (0x206 << 2))
+#define SEC_AED_EQ_CH1_COEF11                                  (0xff642000 + (0x206 << 2))
+#define   P_AED_EQ_CH1_COEF11                                  (volatile uint32_t *)(0xff642000 + (0x206 << 2))
+#define     AED_EQ_CH1_COEF12                                  (0xff642000 + (0x207 << 2))
+#define SEC_AED_EQ_CH1_COEF12                                  (0xff642000 + (0x207 << 2))
+#define   P_AED_EQ_CH1_COEF12                                  (volatile uint32_t *)(0xff642000 + (0x207 << 2))
+#define     AED_EQ_CH1_COEF13                                  (0xff642000 + (0x208 << 2))
+#define SEC_AED_EQ_CH1_COEF13                                  (0xff642000 + (0x208 << 2))
+#define   P_AED_EQ_CH1_COEF13                                  (volatile uint32_t *)(0xff642000 + (0x208 << 2))
+#define     AED_EQ_CH1_COEF14                                  (0xff642000 + (0x209 << 2))
+#define SEC_AED_EQ_CH1_COEF14                                  (0xff642000 + (0x209 << 2))
+#define   P_AED_EQ_CH1_COEF14                                  (volatile uint32_t *)(0xff642000 + (0x209 << 2))
+#define     AED_EQ_CH1_COEF20                                  (0xff642000 + (0x20a << 2))
+#define SEC_AED_EQ_CH1_COEF20                                  (0xff642000 + (0x20a << 2))
+#define   P_AED_EQ_CH1_COEF20                                  (volatile uint32_t *)(0xff642000 + (0x20a << 2))
+#define     AED_EQ_CH1_COEF21                                  (0xff642000 + (0x20b << 2))
+#define SEC_AED_EQ_CH1_COEF21                                  (0xff642000 + (0x20b << 2))
+#define   P_AED_EQ_CH1_COEF21                                  (volatile uint32_t *)(0xff642000 + (0x20b << 2))
+#define     AED_EQ_CH1_COEF22                                  (0xff642000 + (0x20c << 2))
+#define SEC_AED_EQ_CH1_COEF22                                  (0xff642000 + (0x20c << 2))
+#define   P_AED_EQ_CH1_COEF22                                  (volatile uint32_t *)(0xff642000 + (0x20c << 2))
+#define     AED_EQ_CH1_COEF23                                  (0xff642000 + (0x20d << 2))
+#define SEC_AED_EQ_CH1_COEF23                                  (0xff642000 + (0x20d << 2))
+#define   P_AED_EQ_CH1_COEF23                                  (volatile uint32_t *)(0xff642000 + (0x20d << 2))
+#define     AED_EQ_CH1_COEF24                                  (0xff642000 + (0x20e << 2))
+#define SEC_AED_EQ_CH1_COEF24                                  (0xff642000 + (0x20e << 2))
+#define   P_AED_EQ_CH1_COEF24                                  (volatile uint32_t *)(0xff642000 + (0x20e << 2))
+#define     AED_EQ_CH1_COEF30                                  (0xff642000 + (0x20f << 2))
+#define SEC_AED_EQ_CH1_COEF30                                  (0xff642000 + (0x20f << 2))
+#define   P_AED_EQ_CH1_COEF30                                  (volatile uint32_t *)(0xff642000 + (0x20f << 2))
+#define     AED_EQ_CH1_COEF31                                  (0xff642000 + (0x210 << 2))
+#define SEC_AED_EQ_CH1_COEF31                                  (0xff642000 + (0x210 << 2))
+#define   P_AED_EQ_CH1_COEF31                                  (volatile uint32_t *)(0xff642000 + (0x210 << 2))
+#define     AED_EQ_CH1_COEF32                                  (0xff642000 + (0x211 << 2))
+#define SEC_AED_EQ_CH1_COEF32                                  (0xff642000 + (0x211 << 2))
+#define   P_AED_EQ_CH1_COEF32                                  (volatile uint32_t *)(0xff642000 + (0x211 << 2))
+#define     AED_EQ_CH1_COEF33                                  (0xff642000 + (0x212 << 2))
+#define SEC_AED_EQ_CH1_COEF33                                  (0xff642000 + (0x212 << 2))
+#define   P_AED_EQ_CH1_COEF33                                  (volatile uint32_t *)(0xff642000 + (0x212 << 2))
+#define     AED_EQ_CH1_COEF34                                  (0xff642000 + (0x213 << 2))
+#define SEC_AED_EQ_CH1_COEF34                                  (0xff642000 + (0x213 << 2))
+#define   P_AED_EQ_CH1_COEF34                                  (volatile uint32_t *)(0xff642000 + (0x213 << 2))
+#define     AED_EQ_CH1_COEF40                                  (0xff642000 + (0x214 << 2))
+#define SEC_AED_EQ_CH1_COEF40                                  (0xff642000 + (0x214 << 2))
+#define   P_AED_EQ_CH1_COEF40                                  (volatile uint32_t *)(0xff642000 + (0x214 << 2))
+#define     AED_EQ_CH1_COEF41                                  (0xff642000 + (0x215 << 2))
+#define SEC_AED_EQ_CH1_COEF41                                  (0xff642000 + (0x215 << 2))
+#define   P_AED_EQ_CH1_COEF41                                  (volatile uint32_t *)(0xff642000 + (0x215 << 2))
+#define     AED_EQ_CH1_COEF42                                  (0xff642000 + (0x216 << 2))
+#define SEC_AED_EQ_CH1_COEF42                                  (0xff642000 + (0x216 << 2))
+#define   P_AED_EQ_CH1_COEF42                                  (volatile uint32_t *)(0xff642000 + (0x216 << 2))
+#define     AED_EQ_CH1_COEF43                                  (0xff642000 + (0x217 << 2))
+#define SEC_AED_EQ_CH1_COEF43                                  (0xff642000 + (0x217 << 2))
+#define   P_AED_EQ_CH1_COEF43                                  (volatile uint32_t *)(0xff642000 + (0x217 << 2))
+#define     AED_EQ_CH1_COEF44                                  (0xff642000 + (0x218 << 2))
+#define SEC_AED_EQ_CH1_COEF44                                  (0xff642000 + (0x218 << 2))
+#define   P_AED_EQ_CH1_COEF44                                  (volatile uint32_t *)(0xff642000 + (0x218 << 2))
+#define     AED_EQ_CH1_COEF50                                  (0xff642000 + (0x219 << 2))
+#define SEC_AED_EQ_CH1_COEF50                                  (0xff642000 + (0x219 << 2))
+#define   P_AED_EQ_CH1_COEF50                                  (volatile uint32_t *)(0xff642000 + (0x219 << 2))
+#define     AED_EQ_CH1_COEF51                                  (0xff642000 + (0x21a << 2))
+#define SEC_AED_EQ_CH1_COEF51                                  (0xff642000 + (0x21a << 2))
+#define   P_AED_EQ_CH1_COEF51                                  (volatile uint32_t *)(0xff642000 + (0x21a << 2))
+#define     AED_EQ_CH1_COEF52                                  (0xff642000 + (0x21b << 2))
+#define SEC_AED_EQ_CH1_COEF52                                  (0xff642000 + (0x21b << 2))
+#define   P_AED_EQ_CH1_COEF52                                  (volatile uint32_t *)(0xff642000 + (0x21b << 2))
+#define     AED_EQ_CH1_COEF53                                  (0xff642000 + (0x21c << 2))
+#define SEC_AED_EQ_CH1_COEF53                                  (0xff642000 + (0x21c << 2))
+#define   P_AED_EQ_CH1_COEF53                                  (volatile uint32_t *)(0xff642000 + (0x21c << 2))
+#define     AED_EQ_CH1_COEF54                                  (0xff642000 + (0x21d << 2))
+#define SEC_AED_EQ_CH1_COEF54                                  (0xff642000 + (0x21d << 2))
+#define   P_AED_EQ_CH1_COEF54                                  (volatile uint32_t *)(0xff642000 + (0x21d << 2))
+#define     AED_EQ_CH1_COEF60                                  (0xff642000 + (0x21e << 2))
+#define SEC_AED_EQ_CH1_COEF60                                  (0xff642000 + (0x21e << 2))
+#define   P_AED_EQ_CH1_COEF60                                  (volatile uint32_t *)(0xff642000 + (0x21e << 2))
+#define     AED_EQ_CH1_COEF61                                  (0xff642000 + (0x21f << 2))
+#define SEC_AED_EQ_CH1_COEF61                                  (0xff642000 + (0x21f << 2))
+#define   P_AED_EQ_CH1_COEF61                                  (volatile uint32_t *)(0xff642000 + (0x21f << 2))
+#define     AED_EQ_CH1_COEF62                                  (0xff642000 + (0x220 << 2))
+#define SEC_AED_EQ_CH1_COEF62                                  (0xff642000 + (0x220 << 2))
+#define   P_AED_EQ_CH1_COEF62                                  (volatile uint32_t *)(0xff642000 + (0x220 << 2))
+#define     AED_EQ_CH1_COEF63                                  (0xff642000 + (0x221 << 2))
+#define SEC_AED_EQ_CH1_COEF63                                  (0xff642000 + (0x221 << 2))
+#define   P_AED_EQ_CH1_COEF63                                  (volatile uint32_t *)(0xff642000 + (0x221 << 2))
+#define     AED_EQ_CH1_COEF64                                  (0xff642000 + (0x222 << 2))
+#define SEC_AED_EQ_CH1_COEF64                                  (0xff642000 + (0x222 << 2))
+#define   P_AED_EQ_CH1_COEF64                                  (volatile uint32_t *)(0xff642000 + (0x222 << 2))
+#define     AED_EQ_CH1_COEF70                                  (0xff642000 + (0x223 << 2))
+#define SEC_AED_EQ_CH1_COEF70                                  (0xff642000 + (0x223 << 2))
+#define   P_AED_EQ_CH1_COEF70                                  (volatile uint32_t *)(0xff642000 + (0x223 << 2))
+#define     AED_EQ_CH1_COEF71                                  (0xff642000 + (0x224 << 2))
+#define SEC_AED_EQ_CH1_COEF71                                  (0xff642000 + (0x224 << 2))
+#define   P_AED_EQ_CH1_COEF71                                  (volatile uint32_t *)(0xff642000 + (0x224 << 2))
+#define     AED_EQ_CH1_COEF72                                  (0xff642000 + (0x225 << 2))
+#define SEC_AED_EQ_CH1_COEF72                                  (0xff642000 + (0x225 << 2))
+#define   P_AED_EQ_CH1_COEF72                                  (volatile uint32_t *)(0xff642000 + (0x225 << 2))
+#define     AED_EQ_CH1_COEF73                                  (0xff642000 + (0x226 << 2))
+#define SEC_AED_EQ_CH1_COEF73                                  (0xff642000 + (0x226 << 2))
+#define   P_AED_EQ_CH1_COEF73                                  (volatile uint32_t *)(0xff642000 + (0x226 << 2))
+#define     AED_EQ_CH1_COEF74                                  (0xff642000 + (0x227 << 2))
+#define SEC_AED_EQ_CH1_COEF74                                  (0xff642000 + (0x227 << 2))
+#define   P_AED_EQ_CH1_COEF74                                  (volatile uint32_t *)(0xff642000 + (0x227 << 2))
+#define     AED_EQ_CH1_COEF80                                  (0xff642000 + (0x228 << 2))
+#define SEC_AED_EQ_CH1_COEF80                                  (0xff642000 + (0x228 << 2))
+#define   P_AED_EQ_CH1_COEF80                                  (volatile uint32_t *)(0xff642000 + (0x228 << 2))
+#define     AED_EQ_CH1_COEF81                                  (0xff642000 + (0x229 << 2))
+#define SEC_AED_EQ_CH1_COEF81                                  (0xff642000 + (0x229 << 2))
+#define   P_AED_EQ_CH1_COEF81                                  (volatile uint32_t *)(0xff642000 + (0x229 << 2))
+#define     AED_EQ_CH1_COEF82                                  (0xff642000 + (0x22a << 2))
+#define SEC_AED_EQ_CH1_COEF82                                  (0xff642000 + (0x22a << 2))
+#define   P_AED_EQ_CH1_COEF82                                  (volatile uint32_t *)(0xff642000 + (0x22a << 2))
+#define     AED_EQ_CH1_COEF83                                  (0xff642000 + (0x22b << 2))
+#define SEC_AED_EQ_CH1_COEF83                                  (0xff642000 + (0x22b << 2))
+#define   P_AED_EQ_CH1_COEF83                                  (volatile uint32_t *)(0xff642000 + (0x22b << 2))
+#define     AED_EQ_CH1_COEF84                                  (0xff642000 + (0x22c << 2))
+#define SEC_AED_EQ_CH1_COEF84                                  (0xff642000 + (0x22c << 2))
+#define   P_AED_EQ_CH1_COEF84                                  (volatile uint32_t *)(0xff642000 + (0x22c << 2))
+#define     AED_EQ_CH1_COEF90                                  (0xff642000 + (0x22d << 2))
+#define SEC_AED_EQ_CH1_COEF90                                  (0xff642000 + (0x22d << 2))
+#define   P_AED_EQ_CH1_COEF90                                  (volatile uint32_t *)(0xff642000 + (0x22d << 2))
+#define     AED_EQ_CH1_COEF91                                  (0xff642000 + (0x22e << 2))
+#define SEC_AED_EQ_CH1_COEF91                                  (0xff642000 + (0x22e << 2))
+#define   P_AED_EQ_CH1_COEF91                                  (volatile uint32_t *)(0xff642000 + (0x22e << 2))
+#define     AED_EQ_CH1_COEF92                                  (0xff642000 + (0x22f << 2))
+#define SEC_AED_EQ_CH1_COEF92                                  (0xff642000 + (0x22f << 2))
+#define   P_AED_EQ_CH1_COEF92                                  (volatile uint32_t *)(0xff642000 + (0x22f << 2))
+#define     AED_EQ_CH1_COEF93                                  (0xff642000 + (0x230 << 2))
+#define SEC_AED_EQ_CH1_COEF93                                  (0xff642000 + (0x230 << 2))
+#define   P_AED_EQ_CH1_COEF93                                  (volatile uint32_t *)(0xff642000 + (0x230 << 2))
+#define     AED_EQ_CH1_COEF94                                  (0xff642000 + (0x231 << 2))
+#define SEC_AED_EQ_CH1_COEF94                                  (0xff642000 + (0x231 << 2))
+#define   P_AED_EQ_CH1_COEF94                                  (volatile uint32_t *)(0xff642000 + (0x231 << 2))
+#define     AED_EQ_CH2_COEF00                                  (0xff642000 + (0x232 << 2))
+#define SEC_AED_EQ_CH2_COEF00                                  (0xff642000 + (0x232 << 2))
+#define   P_AED_EQ_CH2_COEF00                                  (volatile uint32_t *)(0xff642000 + (0x232 << 2))
+#define     AED_EQ_CH2_COEF01                                  (0xff642000 + (0x233 << 2))
+#define SEC_AED_EQ_CH2_COEF01                                  (0xff642000 + (0x233 << 2))
+#define   P_AED_EQ_CH2_COEF01                                  (volatile uint32_t *)(0xff642000 + (0x233 << 2))
+#define     AED_EQ_CH2_COEF02                                  (0xff642000 + (0x234 << 2))
+#define SEC_AED_EQ_CH2_COEF02                                  (0xff642000 + (0x234 << 2))
+#define   P_AED_EQ_CH2_COEF02                                  (volatile uint32_t *)(0xff642000 + (0x234 << 2))
+#define     AED_EQ_CH2_COEF03                                  (0xff642000 + (0x235 << 2))
+#define SEC_AED_EQ_CH2_COEF03                                  (0xff642000 + (0x235 << 2))
+#define   P_AED_EQ_CH2_COEF03                                  (volatile uint32_t *)(0xff642000 + (0x235 << 2))
+#define     AED_EQ_CH2_COEF04                                  (0xff642000 + (0x236 << 2))
+#define SEC_AED_EQ_CH2_COEF04                                  (0xff642000 + (0x236 << 2))
+#define   P_AED_EQ_CH2_COEF04                                  (volatile uint32_t *)(0xff642000 + (0x236 << 2))
+#define     AED_EQ_CH2_COEF10                                  (0xff642000 + (0x237 << 2))
+#define SEC_AED_EQ_CH2_COEF10                                  (0xff642000 + (0x237 << 2))
+#define   P_AED_EQ_CH2_COEF10                                  (volatile uint32_t *)(0xff642000 + (0x237 << 2))
+#define     AED_EQ_CH2_COEF11                                  (0xff642000 + (0x238 << 2))
+#define SEC_AED_EQ_CH2_COEF11                                  (0xff642000 + (0x238 << 2))
+#define   P_AED_EQ_CH2_COEF11                                  (volatile uint32_t *)(0xff642000 + (0x238 << 2))
+#define     AED_EQ_CH2_COEF12                                  (0xff642000 + (0x239 << 2))
+#define SEC_AED_EQ_CH2_COEF12                                  (0xff642000 + (0x239 << 2))
+#define   P_AED_EQ_CH2_COEF12                                  (volatile uint32_t *)(0xff642000 + (0x239 << 2))
+#define     AED_EQ_CH2_COEF13                                  (0xff642000 + (0x23a << 2))
+#define SEC_AED_EQ_CH2_COEF13                                  (0xff642000 + (0x23a << 2))
+#define   P_AED_EQ_CH2_COEF13                                  (volatile uint32_t *)(0xff642000 + (0x23a << 2))
+#define     AED_EQ_CH2_COEF14                                  (0xff642000 + (0x23b << 2))
+#define SEC_AED_EQ_CH2_COEF14                                  (0xff642000 + (0x23b << 2))
+#define   P_AED_EQ_CH2_COEF14                                  (volatile uint32_t *)(0xff642000 + (0x23b << 2))
+#define     AED_EQ_CH2_COEF20                                  (0xff642000 + (0x23c << 2))
+#define SEC_AED_EQ_CH2_COEF20                                  (0xff642000 + (0x23c << 2))
+#define   P_AED_EQ_CH2_COEF20                                  (volatile uint32_t *)(0xff642000 + (0x23c << 2))
+#define     AED_EQ_CH2_COEF21                                  (0xff642000 + (0x23d << 2))
+#define SEC_AED_EQ_CH2_COEF21                                  (0xff642000 + (0x23d << 2))
+#define   P_AED_EQ_CH2_COEF21                                  (volatile uint32_t *)(0xff642000 + (0x23d << 2))
+#define     AED_EQ_CH2_COEF22                                  (0xff642000 + (0x23e << 2))
+#define SEC_AED_EQ_CH2_COEF22                                  (0xff642000 + (0x23e << 2))
+#define   P_AED_EQ_CH2_COEF22                                  (volatile uint32_t *)(0xff642000 + (0x23e << 2))
+#define     AED_EQ_CH2_COEF23                                  (0xff642000 + (0x23f << 2))
+#define SEC_AED_EQ_CH2_COEF23                                  (0xff642000 + (0x23f << 2))
+#define   P_AED_EQ_CH2_COEF23                                  (volatile uint32_t *)(0xff642000 + (0x23f << 2))
+#define     AED_EQ_CH2_COEF24                                  (0xff642000 + (0x240 << 2))
+#define SEC_AED_EQ_CH2_COEF24                                  (0xff642000 + (0x240 << 2))
+#define   P_AED_EQ_CH2_COEF24                                  (volatile uint32_t *)(0xff642000 + (0x240 << 2))
+#define     AED_EQ_CH2_COEF30                                  (0xff642000 + (0x241 << 2))
+#define SEC_AED_EQ_CH2_COEF30                                  (0xff642000 + (0x241 << 2))
+#define   P_AED_EQ_CH2_COEF30                                  (volatile uint32_t *)(0xff642000 + (0x241 << 2))
+#define     AED_EQ_CH2_COEF31                                  (0xff642000 + (0x242 << 2))
+#define SEC_AED_EQ_CH2_COEF31                                  (0xff642000 + (0x242 << 2))
+#define   P_AED_EQ_CH2_COEF31                                  (volatile uint32_t *)(0xff642000 + (0x242 << 2))
+#define     AED_EQ_CH2_COEF32                                  (0xff642000 + (0x243 << 2))
+#define SEC_AED_EQ_CH2_COEF32                                  (0xff642000 + (0x243 << 2))
+#define   P_AED_EQ_CH2_COEF32                                  (volatile uint32_t *)(0xff642000 + (0x243 << 2))
+#define     AED_EQ_CH2_COEF33                                  (0xff642000 + (0x244 << 2))
+#define SEC_AED_EQ_CH2_COEF33                                  (0xff642000 + (0x244 << 2))
+#define   P_AED_EQ_CH2_COEF33                                  (volatile uint32_t *)(0xff642000 + (0x244 << 2))
+#define     AED_EQ_CH2_COEF34                                  (0xff642000 + (0x245 << 2))
+#define SEC_AED_EQ_CH2_COEF34                                  (0xff642000 + (0x245 << 2))
+#define   P_AED_EQ_CH2_COEF34                                  (volatile uint32_t *)(0xff642000 + (0x245 << 2))
+#define     AED_EQ_CH2_COEF40                                  (0xff642000 + (0x246 << 2))
+#define SEC_AED_EQ_CH2_COEF40                                  (0xff642000 + (0x246 << 2))
+#define   P_AED_EQ_CH2_COEF40                                  (volatile uint32_t *)(0xff642000 + (0x246 << 2))
+#define     AED_EQ_CH2_COEF41                                  (0xff642000 + (0x247 << 2))
+#define SEC_AED_EQ_CH2_COEF41                                  (0xff642000 + (0x247 << 2))
+#define   P_AED_EQ_CH2_COEF41                                  (volatile uint32_t *)(0xff642000 + (0x247 << 2))
+#define     AED_EQ_CH2_COEF42                                  (0xff642000 + (0x248 << 2))
+#define SEC_AED_EQ_CH2_COEF42                                  (0xff642000 + (0x248 << 2))
+#define   P_AED_EQ_CH2_COEF42                                  (volatile uint32_t *)(0xff642000 + (0x248 << 2))
+#define     AED_EQ_CH2_COEF43                                  (0xff642000 + (0x249 << 2))
+#define SEC_AED_EQ_CH2_COEF43                                  (0xff642000 + (0x249 << 2))
+#define   P_AED_EQ_CH2_COEF43                                  (volatile uint32_t *)(0xff642000 + (0x249 << 2))
+#define     AED_EQ_CH2_COEF44                                  (0xff642000 + (0x24a << 2))
+#define SEC_AED_EQ_CH2_COEF44                                  (0xff642000 + (0x24a << 2))
+#define   P_AED_EQ_CH2_COEF44                                  (volatile uint32_t *)(0xff642000 + (0x24a << 2))
+#define     AED_EQ_CH2_COEF50                                  (0xff642000 + (0x24b << 2))
+#define SEC_AED_EQ_CH2_COEF50                                  (0xff642000 + (0x24b << 2))
+#define   P_AED_EQ_CH2_COEF50                                  (volatile uint32_t *)(0xff642000 + (0x24b << 2))
+#define     AED_EQ_CH2_COEF51                                  (0xff642000 + (0x24c << 2))
+#define SEC_AED_EQ_CH2_COEF51                                  (0xff642000 + (0x24c << 2))
+#define   P_AED_EQ_CH2_COEF51                                  (volatile uint32_t *)(0xff642000 + (0x24c << 2))
+#define     AED_EQ_CH2_COEF52                                  (0xff642000 + (0x24d << 2))
+#define SEC_AED_EQ_CH2_COEF52                                  (0xff642000 + (0x24d << 2))
+#define   P_AED_EQ_CH2_COEF52                                  (volatile uint32_t *)(0xff642000 + (0x24d << 2))
+#define     AED_EQ_CH2_COEF53                                  (0xff642000 + (0x24e << 2))
+#define SEC_AED_EQ_CH2_COEF53                                  (0xff642000 + (0x24e << 2))
+#define   P_AED_EQ_CH2_COEF53                                  (volatile uint32_t *)(0xff642000 + (0x24e << 2))
+#define     AED_EQ_CH2_COEF54                                  (0xff642000 + (0x24f << 2))
+#define SEC_AED_EQ_CH2_COEF54                                  (0xff642000 + (0x24f << 2))
+#define   P_AED_EQ_CH2_COEF54                                  (volatile uint32_t *)(0xff642000 + (0x24f << 2))
+#define     AED_EQ_CH2_COEF60                                  (0xff642000 + (0x250 << 2))
+#define SEC_AED_EQ_CH2_COEF60                                  (0xff642000 + (0x250 << 2))
+#define   P_AED_EQ_CH2_COEF60                                  (volatile uint32_t *)(0xff642000 + (0x250 << 2))
+#define     AED_EQ_CH2_COEF61                                  (0xff642000 + (0x251 << 2))
+#define SEC_AED_EQ_CH2_COEF61                                  (0xff642000 + (0x251 << 2))
+#define   P_AED_EQ_CH2_COEF61                                  (volatile uint32_t *)(0xff642000 + (0x251 << 2))
+#define     AED_EQ_CH2_COEF62                                  (0xff642000 + (0x252 << 2))
+#define SEC_AED_EQ_CH2_COEF62                                  (0xff642000 + (0x252 << 2))
+#define   P_AED_EQ_CH2_COEF62                                  (volatile uint32_t *)(0xff642000 + (0x252 << 2))
+#define     AED_EQ_CH2_COEF63                                  (0xff642000 + (0x253 << 2))
+#define SEC_AED_EQ_CH2_COEF63                                  (0xff642000 + (0x253 << 2))
+#define   P_AED_EQ_CH2_COEF63                                  (volatile uint32_t *)(0xff642000 + (0x253 << 2))
+#define     AED_EQ_CH2_COEF64                                  (0xff642000 + (0x254 << 2))
+#define SEC_AED_EQ_CH2_COEF64                                  (0xff642000 + (0x254 << 2))
+#define   P_AED_EQ_CH2_COEF64                                  (volatile uint32_t *)(0xff642000 + (0x254 << 2))
+#define     AED_EQ_CH2_COEF70                                  (0xff642000 + (0x255 << 2))
+#define SEC_AED_EQ_CH2_COEF70                                  (0xff642000 + (0x255 << 2))
+#define   P_AED_EQ_CH2_COEF70                                  (volatile uint32_t *)(0xff642000 + (0x255 << 2))
+#define     AED_EQ_CH2_COEF71                                  (0xff642000 + (0x256 << 2))
+#define SEC_AED_EQ_CH2_COEF71                                  (0xff642000 + (0x256 << 2))
+#define   P_AED_EQ_CH2_COEF71                                  (volatile uint32_t *)(0xff642000 + (0x256 << 2))
+#define     AED_EQ_CH2_COEF72                                  (0xff642000 + (0x257 << 2))
+#define SEC_AED_EQ_CH2_COEF72                                  (0xff642000 + (0x257 << 2))
+#define   P_AED_EQ_CH2_COEF72                                  (volatile uint32_t *)(0xff642000 + (0x257 << 2))
+#define     AED_EQ_CH2_COEF73                                  (0xff642000 + (0x258 << 2))
+#define SEC_AED_EQ_CH2_COEF73                                  (0xff642000 + (0x258 << 2))
+#define   P_AED_EQ_CH2_COEF73                                  (volatile uint32_t *)(0xff642000 + (0x258 << 2))
+#define     AED_EQ_CH2_COEF74                                  (0xff642000 + (0x259 << 2))
+#define SEC_AED_EQ_CH2_COEF74                                  (0xff642000 + (0x259 << 2))
+#define   P_AED_EQ_CH2_COEF74                                  (volatile uint32_t *)(0xff642000 + (0x259 << 2))
+#define     AED_EQ_CH2_COEF80                                  (0xff642000 + (0x25a << 2))
+#define SEC_AED_EQ_CH2_COEF80                                  (0xff642000 + (0x25a << 2))
+#define   P_AED_EQ_CH2_COEF80                                  (volatile uint32_t *)(0xff642000 + (0x25a << 2))
+#define     AED_EQ_CH2_COEF81                                  (0xff642000 + (0x25b << 2))
+#define SEC_AED_EQ_CH2_COEF81                                  (0xff642000 + (0x25b << 2))
+#define   P_AED_EQ_CH2_COEF81                                  (volatile uint32_t *)(0xff642000 + (0x25b << 2))
+#define     AED_EQ_CH2_COEF82                                  (0xff642000 + (0x25c << 2))
+#define SEC_AED_EQ_CH2_COEF82                                  (0xff642000 + (0x25c << 2))
+#define   P_AED_EQ_CH2_COEF82                                  (volatile uint32_t *)(0xff642000 + (0x25c << 2))
+#define     AED_EQ_CH2_COEF83                                  (0xff642000 + (0x25d << 2))
+#define SEC_AED_EQ_CH2_COEF83                                  (0xff642000 + (0x25d << 2))
+#define   P_AED_EQ_CH2_COEF83                                  (volatile uint32_t *)(0xff642000 + (0x25d << 2))
+#define     AED_EQ_CH2_COEF84                                  (0xff642000 + (0x25e << 2))
+#define SEC_AED_EQ_CH2_COEF84                                  (0xff642000 + (0x25e << 2))
+#define   P_AED_EQ_CH2_COEF84                                  (volatile uint32_t *)(0xff642000 + (0x25e << 2))
+#define     AED_EQ_CH2_COEF90                                  (0xff642000 + (0x25f << 2))
+#define SEC_AED_EQ_CH2_COEF90                                  (0xff642000 + (0x25f << 2))
+#define   P_AED_EQ_CH2_COEF90                                  (volatile uint32_t *)(0xff642000 + (0x25f << 2))
+#define     AED_EQ_CH2_COEF91                                  (0xff642000 + (0x260 << 2))
+#define SEC_AED_EQ_CH2_COEF91                                  (0xff642000 + (0x260 << 2))
+#define   P_AED_EQ_CH2_COEF91                                  (volatile uint32_t *)(0xff642000 + (0x260 << 2))
+#define     AED_EQ_CH2_COEF92                                  (0xff642000 + (0x261 << 2))
+#define SEC_AED_EQ_CH2_COEF92                                  (0xff642000 + (0x261 << 2))
+#define   P_AED_EQ_CH2_COEF92                                  (volatile uint32_t *)(0xff642000 + (0x261 << 2))
+#define     AED_EQ_CH2_COEF93                                  (0xff642000 + (0x262 << 2))
+#define SEC_AED_EQ_CH2_COEF93                                  (0xff642000 + (0x262 << 2))
+#define   P_AED_EQ_CH2_COEF93                                  (volatile uint32_t *)(0xff642000 + (0x262 << 2))
+#define     AED_EQ_CH2_COEF94                                  (0xff642000 + (0x263 << 2))
+#define SEC_AED_EQ_CH2_COEF94                                  (0xff642000 + (0x263 << 2))
+#define   P_AED_EQ_CH2_COEF94                                  (volatile uint32_t *)(0xff642000 + (0x263 << 2))
+#define     AED_EQ_EN                                          (0xff642000 + (0x264 << 2))
+#define SEC_AED_EQ_EN                                          (0xff642000 + (0x264 << 2))
+#define   P_AED_EQ_EN                                          (volatile uint32_t *)(0xff642000 + (0x264 << 2))
+#define     AED_EQ_VOLUME                                      (0xff642000 + (0x265 << 2))
+#define SEC_AED_EQ_VOLUME                                      (0xff642000 + (0x265 << 2))
+#define   P_AED_EQ_VOLUME                                      (volatile uint32_t *)(0xff642000 + (0x265 << 2))
+#define     AED_EQ_VOLUME_SLEW_CNT                             (0xff642000 + (0x266 << 2))
+#define SEC_AED_EQ_VOLUME_SLEW_CNT                             (0xff642000 + (0x266 << 2))
+#define   P_AED_EQ_VOLUME_SLEW_CNT                             (volatile uint32_t *)(0xff642000 + (0x266 << 2))
+#define     AED_MUTE                                           (0xff642000 + (0x267 << 2))
+#define SEC_AED_MUTE                                           (0xff642000 + (0x267 << 2))
+#define   P_AED_MUTE                                           (volatile uint32_t *)(0xff642000 + (0x267 << 2))
+#define     AED_DRC_EN                                         (0xff642000 + (0x268 << 2))
+#define SEC_AED_DRC_EN                                         (0xff642000 + (0x268 << 2))
+#define   P_AED_DRC_EN                                         (volatile uint32_t *)(0xff642000 + (0x268 << 2))
+#define     AED_DRC_AE                                         (0xff642000 + (0x269 << 2))
+#define SEC_AED_DRC_AE                                         (0xff642000 + (0x269 << 2))
+#define   P_AED_DRC_AE                                         (volatile uint32_t *)(0xff642000 + (0x269 << 2))
+#define     AED_DRC_AA                                         (0xff642000 + (0x26a << 2))
+#define SEC_AED_DRC_AA                                         (0xff642000 + (0x26a << 2))
+#define   P_AED_DRC_AA                                         (volatile uint32_t *)(0xff642000 + (0x26a << 2))
+#define     AED_DRC_AD                                         (0xff642000 + (0x26b << 2))
+#define SEC_AED_DRC_AD                                         (0xff642000 + (0x26b << 2))
+#define   P_AED_DRC_AD                                         (volatile uint32_t *)(0xff642000 + (0x26b << 2))
+#define     AED_DRC_AE_1M                                      (0xff642000 + (0x26c << 2))
+#define SEC_AED_DRC_AE_1M                                      (0xff642000 + (0x26c << 2))
+#define   P_AED_DRC_AE_1M                                      (volatile uint32_t *)(0xff642000 + (0x26c << 2))
+#define     AED_DRC_AA_1M                                      (0xff642000 + (0x26d << 2))
+#define SEC_AED_DRC_AA_1M                                      (0xff642000 + (0x26d << 2))
+#define   P_AED_DRC_AA_1M                                      (volatile uint32_t *)(0xff642000 + (0x26d << 2))
+#define     AED_DRC_AD_1M                                      (0xff642000 + (0x26e << 2))
+#define SEC_AED_DRC_AD_1M                                      (0xff642000 + (0x26e << 2))
+#define   P_AED_DRC_AD_1M                                      (volatile uint32_t *)(0xff642000 + (0x26e << 2))
+#define     AED_DRC_OFFSET0                                    (0xff642000 + (0x26f << 2))
+#define SEC_AED_DRC_OFFSET0                                    (0xff642000 + (0x26f << 2))
+#define   P_AED_DRC_OFFSET0                                    (volatile uint32_t *)(0xff642000 + (0x26f << 2))
+#define     AED_DRC_OFFSET1                                    (0xff642000 + (0x270 << 2))
+#define SEC_AED_DRC_OFFSET1                                    (0xff642000 + (0x270 << 2))
+#define   P_AED_DRC_OFFSET1                                    (volatile uint32_t *)(0xff642000 + (0x270 << 2))
+#define     AED_DRC_THD0                                       (0xff642000 + (0x271 << 2))
+#define SEC_AED_DRC_THD0                                       (0xff642000 + (0x271 << 2))
+#define   P_AED_DRC_THD0                                       (volatile uint32_t *)(0xff642000 + (0x271 << 2))
+#define     AED_DRC_THD1                                       (0xff642000 + (0x272 << 2))
+#define SEC_AED_DRC_THD1                                       (0xff642000 + (0x272 << 2))
+#define   P_AED_DRC_THD1                                       (volatile uint32_t *)(0xff642000 + (0x272 << 2))
+#define     AED_DRC_K0                                         (0xff642000 + (0x273 << 2))
+#define SEC_AED_DRC_K0                                         (0xff642000 + (0x273 << 2))
+#define   P_AED_DRC_K0                                         (volatile uint32_t *)(0xff642000 + (0x273 << 2))
+#define     AED_DRC_K1                                         (0xff642000 + (0x274 << 2))
+#define SEC_AED_DRC_K1                                         (0xff642000 + (0x274 << 2))
+#define   P_AED_DRC_K1                                         (volatile uint32_t *)(0xff642000 + (0x274 << 2))
+#define     AED_CLIP_THD                                       (0xff642000 + (0x275 << 2))
+#define SEC_AED_CLIP_THD                                       (0xff642000 + (0x275 << 2))
+#define   P_AED_CLIP_THD                                       (volatile uint32_t *)(0xff642000 + (0x275 << 2))
+#define     AED_NG_THD0                                        (0xff642000 + (0x276 << 2))
+#define SEC_AED_NG_THD0                                        (0xff642000 + (0x276 << 2))
+#define   P_AED_NG_THD0                                        (volatile uint32_t *)(0xff642000 + (0x276 << 2))
+#define     AED_NG_THD1                                        (0xff642000 + (0x277 << 2))
+#define SEC_AED_NG_THD1                                        (0xff642000 + (0x277 << 2))
+#define   P_AED_NG_THD1                                        (volatile uint32_t *)(0xff642000 + (0x277 << 2))
+#define     AED_NG_CNT_THD                                     (0xff642000 + (0x278 << 2))
+#define SEC_AED_NG_CNT_THD                                     (0xff642000 + (0x278 << 2))
+#define   P_AED_NG_CNT_THD                                     (volatile uint32_t *)(0xff642000 + (0x278 << 2))
+#define     AED_NG_CTL                                         (0xff642000 + (0x279 << 2))
+#define SEC_AED_NG_CTL                                         (0xff642000 + (0x279 << 2))
+#define   P_AED_NG_CTL                                         (volatile uint32_t *)(0xff642000 + (0x279 << 2))
+#define     AED_ED_CTL                                         (0xff642000 + (0x27a << 2))
+#define SEC_AED_ED_CTL                                         (0xff642000 + (0x27a << 2))
+#define   P_AED_ED_CTL                                         (volatile uint32_t *)(0xff642000 + (0x27a << 2))
+#define     AED_DEBUG0                                         (0xff642000 + (0x27b << 2))
+#define SEC_AED_DEBUG0                                         (0xff642000 + (0x27b << 2))
+#define   P_AED_DEBUG0                                         (volatile uint32_t *)(0xff642000 + (0x27b << 2))
+#define     AED_DEBUG1                                         (0xff642000 + (0x27c << 2))
+#define SEC_AED_DEBUG1                                         (0xff642000 + (0x27c << 2))
+#define   P_AED_DEBUG1                                         (volatile uint32_t *)(0xff642000 + (0x27c << 2))
+#define     AED_DEBUG2                                         (0xff642000 + (0x27d << 2))
+#define SEC_AED_DEBUG2                                         (0xff642000 + (0x27d << 2))
+#define   P_AED_DEBUG2                                         (volatile uint32_t *)(0xff642000 + (0x27d << 2))
+#define     AED_DEBUG3                                         (0xff642000 + (0x27e << 2))
+#define SEC_AED_DEBUG3                                         (0xff642000 + (0x27e << 2))
+#define   P_AED_DEBUG3                                         (volatile uint32_t *)(0xff642000 + (0x27e << 2))
+#define     AED_DEBUG4                                         (0xff642000 + (0x27f << 2))
+#define SEC_AED_DEBUG4                                         (0xff642000 + (0x27f << 2))
+#define   P_AED_DEBUG4                                         (volatile uint32_t *)(0xff642000 + (0x27f << 2))
+#define     AED_DEBUG5                                         (0xff642000 + (0x280 << 2))
+#define SEC_AED_DEBUG5                                         (0xff642000 + (0x280 << 2))
+#define   P_AED_DEBUG5                                         (volatile uint32_t *)(0xff642000 + (0x280 << 2))
+#define     AED_DEBUG6                                         (0xff642000 + (0x281 << 2))
+#define SEC_AED_DEBUG6                                         (0xff642000 + (0x281 << 2))
+#define   P_AED_DEBUG6                                         (volatile uint32_t *)(0xff642000 + (0x281 << 2))
+#define     AED_DRC_AA_H                                       (0xff642000 + (0x282 << 2))
+#define SEC_AED_DRC_AA_H                                       (0xff642000 + (0x282 << 2))
+#define   P_AED_DRC_AA_H                                       (volatile uint32_t *)(0xff642000 + (0x282 << 2))
+#define     AED_DRC_AD_H                                       (0xff642000 + (0x283 << 2))
+#define SEC_AED_DRC_AD_H                                       (0xff642000 + (0x283 << 2))
+#define   P_AED_DRC_AD_H                                       (volatile uint32_t *)(0xff642000 + (0x283 << 2))
+#define     AED_DRC_AA_1M_H                                    (0xff642000 + (0x284 << 2))
+#define SEC_AED_DRC_AA_1M_H                                    (0xff642000 + (0x284 << 2))
+#define   P_AED_DRC_AA_1M_H                                    (volatile uint32_t *)(0xff642000 + (0x284 << 2))
+#define     AED_DRC_AD_1M_H                                    (0xff642000 + (0x285 << 2))
+#define SEC_AED_DRC_AD_1M_H                                    (0xff642000 + (0x285 << 2))
+#define   P_AED_DRC_AD_1M_H                                    (volatile uint32_t *)(0xff642000 + (0x285 << 2))
+#define     AED_NG_CNT                                         (0xff642000 + (0x286 << 2))
+#define SEC_AED_NG_CNT                                         (0xff642000 + (0x286 << 2))
+#define   P_AED_NG_CNT                                         (volatile uint32_t *)(0xff642000 + (0x286 << 2))
+#define     AED_NG_STEP                                        (0xff642000 + (0x287 << 2))
+#define SEC_AED_NG_STEP                                        (0xff642000 + (0x287 << 2))
+#define   P_AED_NG_STEP                                        (volatile uint32_t *)(0xff642000 + (0x287 << 2))
+#define     AED_TOP_CTL                                        (0xff642000 + (0x288 << 2))
+#define SEC_AED_TOP_CTL                                        (0xff642000 + (0x288 << 2))
+#define   P_AED_TOP_CTL                                        (volatile uint32_t *)(0xff642000 + (0x288 << 2))
+#define     AED_TOP_REQ_CTL                                    (0xff642000 + (0x289 << 2))
+#define SEC_AED_TOP_REQ_CTL                                    (0xff642000 + (0x289 << 2))
+#define   P_AED_TOP_REQ_CTL                                    (volatile uint32_t *)(0xff642000 + (0x289 << 2))
+//========================================================================
+//  HIU - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hFF63C000
+// APB4_DECODER_SECURE_BASE         32'hFF63C000
+#define     HHI_MIPI_CNTL0                                     (0xff63c000 + (0x000 << 2))
+#define SEC_HHI_MIPI_CNTL0                                     (0xff63c000 + (0x000 << 2))
+#define   P_HHI_MIPI_CNTL0                                     (volatile uint32_t *)(0xff63c000 + (0x000 << 2))
+#define     HHI_MIPI_CNTL1                                     (0xff63c000 + (0x001 << 2))
+#define SEC_HHI_MIPI_CNTL1                                     (0xff63c000 + (0x001 << 2))
+#define   P_HHI_MIPI_CNTL1                                     (volatile uint32_t *)(0xff63c000 + (0x001 << 2))
+#define     HHI_MIPI_CNTL2                                     (0xff63c000 + (0x002 << 2))
+#define SEC_HHI_MIPI_CNTL2                                     (0xff63c000 + (0x002 << 2))
+#define   P_HHI_MIPI_CNTL2                                     (volatile uint32_t *)(0xff63c000 + (0x002 << 2))
+#define     HHI_MIPI_STS                                       (0xff63c000 + (0x003 << 2))
+#define SEC_HHI_MIPI_STS                                       (0xff63c000 + (0x003 << 2))
+#define   P_HHI_MIPI_STS                                       (volatile uint32_t *)(0xff63c000 + (0x003 << 2))
+#define     HHI_CHECK_CLK_RESULT                               (0xff63c000 + (0x004 << 2))
+#define SEC_HHI_CHECK_CLK_RESULT                               (0xff63c000 + (0x004 << 2))
+#define   P_HHI_CHECK_CLK_RESULT                               (volatile uint32_t *)(0xff63c000 + (0x004 << 2))
+#define     SCR_HIU                                            (0xff63c000 + (0x00b << 2))
+#define SEC_SCR_HIU                                            (0xff63c000 + (0x00b << 2))
+#define   P_SCR_HIU                                            (volatile uint32_t *)(0xff63c000 + (0x00b << 2))
+//`define HHI_SYS_STS           8'h0c
+#define     HPG_TIMER                                          (0xff63c000 + (0x00f << 2))
+#define SEC_HPG_TIMER                                          (0xff63c000 + (0x00f << 2))
+#define   P_HPG_TIMER                                          (volatile uint32_t *)(0xff63c000 + (0x00f << 2))
+#define     HHI_GP0_PLL_CNTL0                                  (0xff63c000 + (0x010 << 2))
+#define SEC_HHI_GP0_PLL_CNTL0                                  (0xff63c000 + (0x010 << 2))
+#define   P_HHI_GP0_PLL_CNTL0                                  (volatile uint32_t *)(0xff63c000 + (0x010 << 2))
+#define     HHI_GP0_PLL_CNTL1                                  (0xff63c000 + (0x011 << 2))
+#define SEC_HHI_GP0_PLL_CNTL1                                  (0xff63c000 + (0x011 << 2))
+#define   P_HHI_GP0_PLL_CNTL1                                  (volatile uint32_t *)(0xff63c000 + (0x011 << 2))
+#define     HHI_GP0_PLL_CNTL2                                  (0xff63c000 + (0x012 << 2))
+#define SEC_HHI_GP0_PLL_CNTL2                                  (0xff63c000 + (0x012 << 2))
+#define   P_HHI_GP0_PLL_CNTL2                                  (volatile uint32_t *)(0xff63c000 + (0x012 << 2))
+#define     HHI_GP0_PLL_CNTL3                                  (0xff63c000 + (0x013 << 2))
+#define SEC_HHI_GP0_PLL_CNTL3                                  (0xff63c000 + (0x013 << 2))
+#define   P_HHI_GP0_PLL_CNTL3                                  (volatile uint32_t *)(0xff63c000 + (0x013 << 2))
+#define     HHI_GP0_PLL_CNTL4                                  (0xff63c000 + (0x014 << 2))
+#define SEC_HHI_GP0_PLL_CNTL4                                  (0xff63c000 + (0x014 << 2))
+#define   P_HHI_GP0_PLL_CNTL4                                  (volatile uint32_t *)(0xff63c000 + (0x014 << 2))
+#define     HHI_GP0_PLL_CNTL5                                  (0xff63c000 + (0x015 << 2))
+#define SEC_HHI_GP0_PLL_CNTL5                                  (0xff63c000 + (0x015 << 2))
+#define   P_HHI_GP0_PLL_CNTL5                                  (volatile uint32_t *)(0xff63c000 + (0x015 << 2))
+#define     HHI_GP0_PLL_CNTL6                                  (0xff63c000 + (0x016 << 2))
+#define SEC_HHI_GP0_PLL_CNTL6                                  (0xff63c000 + (0x016 << 2))
+#define   P_HHI_GP0_PLL_CNTL6                                  (volatile uint32_t *)(0xff63c000 + (0x016 << 2))
+#define     HHI_GP0_PLL_STS                                    (0xff63c000 + (0x017 << 2))
+#define SEC_HHI_GP0_PLL_STS                                    (0xff63c000 + (0x017 << 2))
+#define   P_HHI_GP0_PLL_STS                                    (volatile uint32_t *)(0xff63c000 + (0x017 << 2))
+//`define HHI_GP1_PLL_CNTL0     8'h18
+//`define HHI_GP1_PLL_CNTL1     8'h19
+//`define HHI_GP1_PLL_CNTL2     8'h1a
+//`define HHI_GP1_PLL_CNTL3     8'h1b
+//`define HHI_GP1_PLL_CNTL4     8'h1c
+//`define HHI_GP1_PLL_CNTL5     8'h1d
+//`define HHI_GP1_PLL_CNTL6     8'h1e
+//`define HHI_GP1_PLL_STS       8'h1f
+//`define HHI_CADC_CNTL           8'h20
+//`define HHI_CADC_CNTL2          8'h21
+//`define HHI_CADC_CNTL3          8'h22
+//`define HHI_CADC_CNTL4          8'h23
+//`define HHI_CADC_CNTL5          8'h24
+//`define HHI_CADC_CNTL6          8'h25
+#define     HHI_PCIE_PLL_CNTL0                                 (0xff63c000 + (0x026 << 2))
+#define SEC_HHI_PCIE_PLL_CNTL0                                 (0xff63c000 + (0x026 << 2))
+#define   P_HHI_PCIE_PLL_CNTL0                                 (volatile uint32_t *)(0xff63c000 + (0x026 << 2))
+#define     HHI_PCIE_PLL_CNTL1                                 (0xff63c000 + (0x027 << 2))
+#define SEC_HHI_PCIE_PLL_CNTL1                                 (0xff63c000 + (0x027 << 2))
+#define   P_HHI_PCIE_PLL_CNTL1                                 (volatile uint32_t *)(0xff63c000 + (0x027 << 2))
+#define     HHI_PCIE_PLL_CNTL2                                 (0xff63c000 + (0x028 << 2))
+#define SEC_HHI_PCIE_PLL_CNTL2                                 (0xff63c000 + (0x028 << 2))
+#define   P_HHI_PCIE_PLL_CNTL2                                 (volatile uint32_t *)(0xff63c000 + (0x028 << 2))
+#define     HHI_PCIE_PLL_CNTL3                                 (0xff63c000 + (0x029 << 2))
+#define SEC_HHI_PCIE_PLL_CNTL3                                 (0xff63c000 + (0x029 << 2))
+#define   P_HHI_PCIE_PLL_CNTL3                                 (volatile uint32_t *)(0xff63c000 + (0x029 << 2))
+#define     HHI_PCIE_PLL_CNTL4                                 (0xff63c000 + (0x02a << 2))
+#define SEC_HHI_PCIE_PLL_CNTL4                                 (0xff63c000 + (0x02a << 2))
+#define   P_HHI_PCIE_PLL_CNTL4                                 (volatile uint32_t *)(0xff63c000 + (0x02a << 2))
+#define     HHI_PCIE_PLL_CNTL5                                 (0xff63c000 + (0x02b << 2))
+#define SEC_HHI_PCIE_PLL_CNTL5                                 (0xff63c000 + (0x02b << 2))
+#define   P_HHI_PCIE_PLL_CNTL5                                 (volatile uint32_t *)(0xff63c000 + (0x02b << 2))
+#define     HHI_PCIE_PLL_STS                                   (0xff63c000 + (0x02c << 2))
+#define SEC_HHI_PCIE_PLL_STS                                   (0xff63c000 + (0x02c << 2))
+#define   P_HHI_PCIE_PLL_STS                                   (volatile uint32_t *)(0xff63c000 + (0x02c << 2))
+//`define HHI_DADC_CNTL           8'h27
+//`define HHI_DADC_CNTL2          8'h28
+//`define HHI_DADC_RDBK0_I        8'h29
+//`define HHI_DADC_CNTL3          8'h2a
+//`define HHI_DADC_CNTL4          8'h2b
+//`define HHI_AFE_TUNNING_CNTL    8'h2c
+//`define HHI_AFE_TUNNING_CNTL_I  8'h2d
+//`define HHI_CVBS_DETECT_CNTL    8'h2e
+#define     HHI_XTAL_DIVN_CNTL                                 (0xff63c000 + (0x02f << 2))
+#define SEC_HHI_XTAL_DIVN_CNTL                                 (0xff63c000 + (0x02f << 2))
+#define   P_HHI_XTAL_DIVN_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x02f << 2))
+#define     HHI_GCLK2_MPEG0                                    (0xff63c000 + (0x030 << 2))
+#define SEC_HHI_GCLK2_MPEG0                                    (0xff63c000 + (0x030 << 2))
+#define   P_HHI_GCLK2_MPEG0                                    (volatile uint32_t *)(0xff63c000 + (0x030 << 2))
+#define     HHI_GCLK2_MPEG1                                    (0xff63c000 + (0x031 << 2))
+#define SEC_HHI_GCLK2_MPEG1                                    (0xff63c000 + (0x031 << 2))
+#define   P_HHI_GCLK2_MPEG1                                    (volatile uint32_t *)(0xff63c000 + (0x031 << 2))
+#define     HHI_GCLK2_MPEG2                                    (0xff63c000 + (0x032 << 2))
+#define SEC_HHI_GCLK2_MPEG2                                    (0xff63c000 + (0x032 << 2))
+#define   P_HHI_GCLK2_MPEG2                                    (volatile uint32_t *)(0xff63c000 + (0x032 << 2))
+#define     HHI_GCLK2_OTHER                                    (0xff63c000 + (0x034 << 2))
+#define SEC_HHI_GCLK2_OTHER                                    (0xff63c000 + (0x034 << 2))
+#define   P_HHI_GCLK2_OTHER                                    (volatile uint32_t *)(0xff63c000 + (0x034 << 2))
+//`define HHI_GCLK2_AO           8'h35
+#define     HHI_HIFI_PLL_CNTL0                                 (0xff63c000 + (0x036 << 2))
+#define SEC_HHI_HIFI_PLL_CNTL0                                 (0xff63c000 + (0x036 << 2))
+#define   P_HHI_HIFI_PLL_CNTL0                                 (volatile uint32_t *)(0xff63c000 + (0x036 << 2))
+#define     HHI_HIFI_PLL_CNTL1                                 (0xff63c000 + (0x037 << 2))
+#define SEC_HHI_HIFI_PLL_CNTL1                                 (0xff63c000 + (0x037 << 2))
+#define   P_HHI_HIFI_PLL_CNTL1                                 (volatile uint32_t *)(0xff63c000 + (0x037 << 2))
+#define     HHI_HIFI_PLL_CNTL2                                 (0xff63c000 + (0x038 << 2))
+#define SEC_HHI_HIFI_PLL_CNTL2                                 (0xff63c000 + (0x038 << 2))
+#define   P_HHI_HIFI_PLL_CNTL2                                 (volatile uint32_t *)(0xff63c000 + (0x038 << 2))
+#define     HHI_HIFI_PLL_CNTL3                                 (0xff63c000 + (0x039 << 2))
+#define SEC_HHI_HIFI_PLL_CNTL3                                 (0xff63c000 + (0x039 << 2))
+#define   P_HHI_HIFI_PLL_CNTL3                                 (volatile uint32_t *)(0xff63c000 + (0x039 << 2))
+#define     HHI_HIFI_PLL_CNTL4                                 (0xff63c000 + (0x03a << 2))
+#define SEC_HHI_HIFI_PLL_CNTL4                                 (0xff63c000 + (0x03a << 2))
+#define   P_HHI_HIFI_PLL_CNTL4                                 (volatile uint32_t *)(0xff63c000 + (0x03a << 2))
+#define     HHI_HIFI_PLL_CNTL5                                 (0xff63c000 + (0x03b << 2))
+#define SEC_HHI_HIFI_PLL_CNTL5                                 (0xff63c000 + (0x03b << 2))
+#define   P_HHI_HIFI_PLL_CNTL5                                 (volatile uint32_t *)(0xff63c000 + (0x03b << 2))
+#define     HHI_HIFI_PLL_CNTL6                                 (0xff63c000 + (0x03c << 2))
+#define SEC_HHI_HIFI_PLL_CNTL6                                 (0xff63c000 + (0x03c << 2))
+#define   P_HHI_HIFI_PLL_CNTL6                                 (volatile uint32_t *)(0xff63c000 + (0x03c << 2))
+#define     HHI_HIFI_PLL_STS                                   (0xff63c000 + (0x03d << 2))
+#define SEC_HHI_HIFI_PLL_STS                                   (0xff63c000 + (0x03d << 2))
+#define   P_HHI_HIFI_PLL_STS                                   (volatile uint32_t *)(0xff63c000 + (0x03d << 2))
+#define     HHI_TIMER90K                                       (0xff63c000 + (0x03f << 2))
+#define SEC_HHI_TIMER90K                                       (0xff63c000 + (0x03f << 2))
+#define   P_HHI_TIMER90K                                       (volatile uint32_t *)(0xff63c000 + (0x03f << 2))
+#define     HHI_MEM_PD_REG0                                    (0xff63c000 + (0x040 << 2))
+#define SEC_HHI_MEM_PD_REG0                                    (0xff63c000 + (0x040 << 2))
+#define   P_HHI_MEM_PD_REG0                                    (volatile uint32_t *)(0xff63c000 + (0x040 << 2))
+//VIU1
+//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
+//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
+//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
+//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
+//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
+//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
+//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
+//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG0                                (0xff63c000 + (0x041 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG0                                (0xff63c000 + (0x041 << 2))
+#define   P_HHI_VPU_MEM_PD_REG0                                (volatile uint32_t *)(0xff63c000 + (0x041 << 2))
+//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
+//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
+//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
+//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
+//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG1                                (0xff63c000 + (0x042 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG1                                (0xff63c000 + (0x042 << 2))
+#define   P_HHI_VPU_MEM_PD_REG1                                (volatile uint32_t *)(0xff63c000 + (0x042 << 2))
+#define     HHI_VPU_MEM_PD_REG3                                (0xff63c000 + (0x043 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG3                                (0xff63c000 + (0x043 << 2))
+#define   P_HHI_VPU_MEM_PD_REG3                                (volatile uint32_t *)(0xff63c000 + (0x043 << 2))
+#define     HHI_VPU_MEM_PD_REG4                                (0xff63c000 + (0x044 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG4                                (0xff63c000 + (0x044 << 2))
+#define   P_HHI_VPU_MEM_PD_REG4                                (volatile uint32_t *)(0xff63c000 + (0x044 << 2))
+//`define HHI_DEMOD_MEM_PD_REG     8'h43
+//`define HHI_AUD_DAC_CTRL          8'h44
+// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
+// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
+// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
+// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
+#define     HHI_VIID_CLK_DIV                                   (0xff63c000 + (0x04a << 2))
+#define SEC_HHI_VIID_CLK_DIV                                   (0xff63c000 + (0x04a << 2))
+#define   P_HHI_VIID_CLK_DIV                                   (volatile uint32_t *)(0xff63c000 + (0x04a << 2))
+#define     HHI_VIID_CLK_CNTL                                  (0xff63c000 + (0x04b << 2))
+#define SEC_HHI_VIID_CLK_CNTL                                  (0xff63c000 + (0x04b << 2))
+#define   P_HHI_VIID_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x04b << 2))
+//`define HHI_VIID_DIVIDER_CNTL   8'h4c
+//bit 1:0   mem_pd_vi_wm,  2'b00: viu1 wm memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG2                                (0xff63c000 + (0x04d << 2))
+#define SEC_HHI_VPU_MEM_PD_REG2                                (0xff63c000 + (0x04d << 2))
+#define   P_HHI_VPU_MEM_PD_REG2                                (volatile uint32_t *)(0xff63c000 + (0x04d << 2))
+// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
+#define     HHI_GCLK_LOCK                                      (0xff63c000 + (0x04f << 2))
+#define SEC_HHI_GCLK_LOCK                                      (0xff63c000 + (0x04f << 2))
+#define   P_HHI_GCLK_LOCK                                      (volatile uint32_t *)(0xff63c000 + (0x04f << 2))
+#define     HHI_GCLK_MPEG0                                     (0xff63c000 + (0x050 << 2))
+#define SEC_HHI_GCLK_MPEG0                                     (0xff63c000 + (0x050 << 2))
+#define   P_HHI_GCLK_MPEG0                                     (volatile uint32_t *)(0xff63c000 + (0x050 << 2))
+#define     HHI_GCLK_MPEG1                                     (0xff63c000 + (0x051 << 2))
+#define SEC_HHI_GCLK_MPEG1                                     (0xff63c000 + (0x051 << 2))
+#define   P_HHI_GCLK_MPEG1                                     (volatile uint32_t *)(0xff63c000 + (0x051 << 2))
+#define     HHI_GCLK_MPEG2                                     (0xff63c000 + (0x052 << 2))
+#define SEC_HHI_GCLK_MPEG2                                     (0xff63c000 + (0x052 << 2))
+#define   P_HHI_GCLK_MPEG2                                     (volatile uint32_t *)(0xff63c000 + (0x052 << 2))
+#define     HHI_GCLK_OTHER                                     (0xff63c000 + (0x054 << 2))
+#define SEC_HHI_GCLK_OTHER                                     (0xff63c000 + (0x054 << 2))
+#define   P_HHI_GCLK_OTHER                                     (volatile uint32_t *)(0xff63c000 + (0x054 << 2))
+#define     HHI_GCLK_SP_MPEG                                   (0xff63c000 + (0x055 << 2))
+#define SEC_HHI_GCLK_SP_MPEG                                   (0xff63c000 + (0x055 << 2))
+#define   P_HHI_GCLK_SP_MPEG                                   (volatile uint32_t *)(0xff63c000 + (0x055 << 2))
+//`define HHI_SYS_OSCIN_CNTL      8'h56
+#define     HHI_SYS_CPU_CLK_CNTL1                              (0xff63c000 + (0x057 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL1                              (0xff63c000 + (0x057 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL1                              (volatile uint32_t *)(0xff63c000 + (0x057 << 2))
+#define     HHI_SYS_CPU_RESET_CNTL                             (0xff63c000 + (0x058 << 2))
+#define SEC_HHI_SYS_CPU_RESET_CNTL                             (0xff63c000 + (0x058 << 2))
+#define   P_HHI_SYS_CPU_RESET_CNTL                             (volatile uint32_t *)(0xff63c000 + (0x058 << 2))
+// PLL Controls
+#define     HHI_VID_CLK_DIV                                    (0xff63c000 + (0x059 << 2))
+#define SEC_HHI_VID_CLK_DIV                                    (0xff63c000 + (0x059 << 2))
+#define   P_HHI_VID_CLK_DIV                                    (volatile uint32_t *)(0xff63c000 + (0x059 << 2))
+#define     HHI_MPEG_CLK_CNTL                                  (0xff63c000 + (0x05d << 2))
+#define SEC_HHI_MPEG_CLK_CNTL                                  (0xff63c000 + (0x05d << 2))
+#define   P_HHI_MPEG_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x05d << 2))
+#define     HHI_VID_CLK_CNTL                                   (0xff63c000 + (0x05f << 2))
+#define SEC_HHI_VID_CLK_CNTL                                   (0xff63c000 + (0x05f << 2))
+#define   P_HHI_VID_CLK_CNTL                                   (volatile uint32_t *)(0xff63c000 + (0x05f << 2))
+//`define HHI_WIFI_CLK_CNTL       8'h60 // MPEG clock control
+//`define HHI_WIFI_PLL_CNTL       8'h61 // WIFI PLL control, word 1
+//`define HHI_WIFI_PLL_CNTL2      8'h62 // WIFI PLL control, word 2
+//`define HHI_WIFI_PLL_CNTL3      8'h63 // WIFI PLL control, word 3
+#define     HHI_TS_CLK_CNTL                                    (0xff63c000 + (0x064 << 2))
+#define SEC_HHI_TS_CLK_CNTL                                    (0xff63c000 + (0x064 << 2))
+#define   P_HHI_TS_CLK_CNTL                                    (volatile uint32_t *)(0xff63c000 + (0x064 << 2))
+#define     HHI_VID_CLK_CNTL2                                  (0xff63c000 + (0x065 << 2))
+#define SEC_HHI_VID_CLK_CNTL2                                  (0xff63c000 + (0x065 << 2))
+#define   P_HHI_VID_CLK_CNTL2                                  (volatile uint32_t *)(0xff63c000 + (0x065 << 2))
+//`define HHI_VID_DIVIDER_CNTL    8'h66
+#define     HHI_SYS_CPU_CLK_CNTL                               (0xff63c000 + (0x067 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL                               (0xff63c000 + (0x067 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL                               (volatile uint32_t *)(0xff63c000 + (0x067 << 2))
+#define     HHI_VID_PLL_CLK_DIV                                (0xff63c000 + (0x068 << 2))
+#define SEC_HHI_VID_PLL_CLK_DIV                                (0xff63c000 + (0x068 << 2))
+#define   P_HHI_VID_PLL_CLK_DIV                                (volatile uint32_t *)(0xff63c000 + (0x068 << 2))
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
+#define     HHI_MALI_CLK_CNTL                                  (0xff63c000 + (0x06c << 2))
+#define SEC_HHI_MALI_CLK_CNTL                                  (0xff63c000 + (0x06c << 2))
+#define   P_HHI_MALI_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x06c << 2))
+#define     HHI_VPU_CLKC_CNTL                                  (0xff63c000 + (0x06d << 2))
+#define SEC_HHI_VPU_CLKC_CNTL                                  (0xff63c000 + (0x06d << 2))
+#define   P_HHI_VPU_CLKC_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x06d << 2))
+//`define HHI_MIPI_PHY_CLK_CNTL   8'h6e
+#define     HHI_VPU_CLK_CNTL                                   (0xff63c000 + (0x06f << 2))
+#define SEC_HHI_VPU_CLK_CNTL                                   (0xff63c000 + (0x06f << 2))
+#define   P_HHI_VPU_CLK_CNTL                                   (volatile uint32_t *)(0xff63c000 + (0x06f << 2))
+//`define HHI_OTHER_PLL_CNTL      8'h70 // OTHER PLL control, word 1
+//`define HHI_OTHER_PLL_CNTL2     8'h71 // OTHER PLL control, word 2
+//`define HHI_OTHER_PLL_CNTL3     8'h72 // OTHER PLL control, word 3
+#define     HHI_HDMI_CLK_CNTL                                  (0xff63c000 + (0x073 << 2))
+#define SEC_HHI_HDMI_CLK_CNTL                                  (0xff63c000 + (0x073 << 2))
+#define   P_HHI_HDMI_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x073 << 2))
+//`define HHI_DEMOD_CLK_CNTL      8'h74 // DEMOD clock control
+//`define HHI_SATA_CLK_CNTL       8'h75 // SATA clock control
+#define     HHI_ETH_CLK_CNTL                                   (0xff63c000 + (0x076 << 2))
+#define SEC_HHI_ETH_CLK_CNTL                                   (0xff63c000 + (0x076 << 2))
+#define   P_HHI_ETH_CLK_CNTL                                   (volatile uint32_t *)(0xff63c000 + (0x076 << 2))
+//`define HHI_CLK_DOUBLE_CNTL     8'h77 // Ethernet clock control
+#define     HHI_VDEC_CLK_CNTL                                  (0xff63c000 + (0x078 << 2))
+#define SEC_HHI_VDEC_CLK_CNTL                                  (0xff63c000 + (0x078 << 2))
+#define   P_HHI_VDEC_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x078 << 2))
+#define     HHI_VDEC2_CLK_CNTL                                 (0xff63c000 + (0x079 << 2))
+#define SEC_HHI_VDEC2_CLK_CNTL                                 (0xff63c000 + (0x079 << 2))
+#define   P_HHI_VDEC2_CLK_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x079 << 2))
+#define     HHI_VDEC3_CLK_CNTL                                 (0xff63c000 + (0x07a << 2))
+#define SEC_HHI_VDEC3_CLK_CNTL                                 (0xff63c000 + (0x07a << 2))
+#define   P_HHI_VDEC3_CLK_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x07a << 2))
+#define     HHI_VDEC4_CLK_CNTL                                 (0xff63c000 + (0x07b << 2))
+#define SEC_HHI_VDEC4_CLK_CNTL                                 (0xff63c000 + (0x07b << 2))
+#define   P_HHI_VDEC4_CLK_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x07b << 2))
+#define     HHI_HDCP22_CLK_CNTL                                (0xff63c000 + (0x07c << 2))
+#define SEC_HHI_HDCP22_CLK_CNTL                                (0xff63c000 + (0x07c << 2))
+#define   P_HHI_HDCP22_CLK_CNTL                                (volatile uint32_t *)(0xff63c000 + (0x07c << 2))
+#define     HHI_VAPBCLK_CNTL                                   (0xff63c000 + (0x07d << 2))
+#define SEC_HHI_VAPBCLK_CNTL                                   (0xff63c000 + (0x07d << 2))
+#define   P_HHI_VAPBCLK_CNTL                                   (volatile uint32_t *)(0xff63c000 + (0x07d << 2))
+//`define HHI_VP9DEC_CLK_CNTL     8'h7e
+// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
+// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
+// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
+// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
+//`define HHI_HDMI_AFC_CNTL       8'h7f
+//`define HHI_HDMIRX_CLK_CNTL     8'h80
+//`define HHI_HDMIRX_AUD_CLK_CNTL 8'h81
+//`define HHI_EDP_APB_CLK_CNTL    8'h82
+#define     HHI_VPU_CLKB_CNTL                                  (0xff63c000 + (0x083 << 2))
+#define SEC_HHI_VPU_CLKB_CNTL                                  (0xff63c000 + (0x083 << 2))
+#define   P_HHI_VPU_CLKB_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x083 << 2))
+//`define HHI_VID_PLL_MOD_CNTL0       8'h84
+//`define HHI_VID_PLL_MOD_LOW_TCNT    8'h85
+//`define HHI_VID_PLL_MOD_HIGH_TCNT   8'h86
+//`define HHI_VID_PLL_MOD_NOM_TCNT    8'h87
+// Removed `define HHI_DDR_CLK_CNTL            8'h88
+//`define HHI_32K_CLK_CNTL            8'h89
+#define     HHI_GEN_CLK_CNTL                                   (0xff63c000 + (0x08a << 2))
+#define SEC_HHI_GEN_CLK_CNTL                                   (0xff63c000 + (0x08a << 2))
+#define   P_HHI_GEN_CLK_CNTL                                   (volatile uint32_t *)(0xff63c000 + (0x08a << 2))
+//`define HHI_GEN_CLK_CNTL2           8'h8b
+//`define HHI_AUDPLL_CLK_OUT_CNTL     8'h8c
+//`define HHI_JTAG_CONFIG             8'h8e
+//`define HHI_VAFE_CLKXTALIN_CNTL       8'h8f
+//`define HHI_VAFE_CLKOSCIN_CNTL        8'h90
+//`define HHI_VAFE_CLKIN_CNTL           8'h91
+//`define HHI_TVFE_AUTOMODE_CLK_CNTL    8'h92
+//`define HHI_VAFE_CLKPI_CNTL       8'h93
+#define     HHI_VDIN_MEAS_CLK_CNTL                             (0xff63c000 + (0x094 << 2))
+#define SEC_HHI_VDIN_MEAS_CLK_CNTL                             (0xff63c000 + (0x094 << 2))
+#define   P_HHI_VDIN_MEAS_CLK_CNTL                             (volatile uint32_t *)(0xff63c000 + (0x094 << 2))
+#define     HHI_MIPIDSI_PHY_CLK_CNTL                           (0xff63c000 + (0x095 << 2))
+#define SEC_HHI_MIPIDSI_PHY_CLK_CNTL                           (0xff63c000 + (0x095 << 2))
+#define   P_HHI_MIPIDSI_PHY_CLK_CNTL                           (volatile uint32_t *)(0xff63c000 + (0x095 << 2))
+#define     HHI_NAND_CLK_CNTL                                  (0xff63c000 + (0x097 << 2))
+#define SEC_HHI_NAND_CLK_CNTL                                  (0xff63c000 + (0x097 << 2))
+#define   P_HHI_NAND_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x097 << 2))
+//`define HHI_ISP_LED_CLK_CNTL        8'h98
+#define     HHI_SD_EMMC_CLK_CNTL                               (0xff63c000 + (0x099 << 2))
+#define SEC_HHI_SD_EMMC_CLK_CNTL                               (0xff63c000 + (0x099 << 2))
+#define   P_HHI_SD_EMMC_CLK_CNTL                               (volatile uint32_t *)(0xff63c000 + (0x099 << 2))
+#define     HHI_WAVE420L_CLK_CNTL                              (0xff63c000 + (0x09a << 2))
+#define SEC_HHI_WAVE420L_CLK_CNTL                              (0xff63c000 + (0x09a << 2))
+#define   P_HHI_WAVE420L_CLK_CNTL                              (volatile uint32_t *)(0xff63c000 + (0x09a << 2))
+#define     HHI_WAVE420L_CLK_CNTL2                             (0xff63c000 + (0x09b << 2))
+#define SEC_HHI_WAVE420L_CLK_CNTL2                             (0xff63c000 + (0x09b << 2))
+#define   P_HHI_WAVE420L_CLK_CNTL2                             (volatile uint32_t *)(0xff63c000 + (0x09b << 2))
+//`define HHI_EDP_TX_PHY_CNTL0        8'h9c
+//`define HHI_EDP_TX_PHY_CNTL1        8'h9d
+//`define HHI_ADC_PLL_CNTL5           8'h9e
+//`define HHI_ADC_PLL_CNTL6           8'h9f
+#define     HHI_MPLL_CNTL0                                     (0xff63c000 + (0x09e << 2))
+#define SEC_HHI_MPLL_CNTL0                                     (0xff63c000 + (0x09e << 2))
+#define   P_HHI_MPLL_CNTL0                                     (volatile uint32_t *)(0xff63c000 + (0x09e << 2))
+#define     HHI_MPLL_CNTL1                                     (0xff63c000 + (0x09f << 2))
+#define SEC_HHI_MPLL_CNTL1                                     (0xff63c000 + (0x09f << 2))
+#define   P_HHI_MPLL_CNTL1                                     (volatile uint32_t *)(0xff63c000 + (0x09f << 2))
+#define     HHI_MPLL_CNTL2                                     (0xff63c000 + (0x0a0 << 2))
+#define SEC_HHI_MPLL_CNTL2                                     (0xff63c000 + (0x0a0 << 2))
+#define   P_HHI_MPLL_CNTL2                                     (volatile uint32_t *)(0xff63c000 + (0x0a0 << 2))
+#define     HHI_MPLL_CNTL3                                     (0xff63c000 + (0x0a1 << 2))
+#define SEC_HHI_MPLL_CNTL3                                     (0xff63c000 + (0x0a1 << 2))
+#define   P_HHI_MPLL_CNTL3                                     (volatile uint32_t *)(0xff63c000 + (0x0a1 << 2))
+#define     HHI_MPLL_CNTL4                                     (0xff63c000 + (0x0a2 << 2))
+#define SEC_HHI_MPLL_CNTL4                                     (0xff63c000 + (0x0a2 << 2))
+#define   P_HHI_MPLL_CNTL4                                     (volatile uint32_t *)(0xff63c000 + (0x0a2 << 2))
+#define     HHI_MPLL_CNTL5                                     (0xff63c000 + (0x0a3 << 2))
+#define SEC_HHI_MPLL_CNTL5                                     (0xff63c000 + (0x0a3 << 2))
+#define   P_HHI_MPLL_CNTL5                                     (volatile uint32_t *)(0xff63c000 + (0x0a3 << 2))
+#define     HHI_MPLL_CNTL6                                     (0xff63c000 + (0x0a4 << 2))
+#define SEC_HHI_MPLL_CNTL6                                     (0xff63c000 + (0x0a4 << 2))
+#define   P_HHI_MPLL_CNTL6                                     (volatile uint32_t *)(0xff63c000 + (0x0a4 << 2))
+#define     HHI_MPLL_CNTL7                                     (0xff63c000 + (0x0a5 << 2))
+#define SEC_HHI_MPLL_CNTL7                                     (0xff63c000 + (0x0a5 << 2))
+#define   P_HHI_MPLL_CNTL7                                     (volatile uint32_t *)(0xff63c000 + (0x0a5 << 2))
+#define     HHI_MPLL_CNTL8                                     (0xff63c000 + (0x0a6 << 2))
+#define SEC_HHI_MPLL_CNTL8                                     (0xff63c000 + (0x0a6 << 2))
+#define   P_HHI_MPLL_CNTL8                                     (volatile uint32_t *)(0xff63c000 + (0x0a6 << 2))
+#define     HHI_MPLL_STS                                       (0xff63c000 + (0x0a7 << 2))
+#define SEC_HHI_MPLL_STS                                       (0xff63c000 + (0x0a7 << 2))
+#define   P_HHI_MPLL_STS                                       (volatile uint32_t *)(0xff63c000 + (0x0a7 << 2))
+#define     HHI_FIX_PLL_CNTL0                                  (0xff63c000 + (0x0a8 << 2))
+#define SEC_HHI_FIX_PLL_CNTL0                                  (0xff63c000 + (0x0a8 << 2))
+#define   P_HHI_FIX_PLL_CNTL0                                  (volatile uint32_t *)(0xff63c000 + (0x0a8 << 2))
+#define     HHI_FIX_PLL_CNTL1                                  (0xff63c000 + (0x0a9 << 2))
+#define SEC_HHI_FIX_PLL_CNTL1                                  (0xff63c000 + (0x0a9 << 2))
+#define   P_HHI_FIX_PLL_CNTL1                                  (volatile uint32_t *)(0xff63c000 + (0x0a9 << 2))
+#define     HHI_FIX_PLL_CNTL2                                  (0xff63c000 + (0x0aa << 2))
+#define SEC_HHI_FIX_PLL_CNTL2                                  (0xff63c000 + (0x0aa << 2))
+#define   P_HHI_FIX_PLL_CNTL2                                  (volatile uint32_t *)(0xff63c000 + (0x0aa << 2))
+#define     HHI_FIX_PLL_CNTL3                                  (0xff63c000 + (0x0ab << 2))
+#define SEC_HHI_FIX_PLL_CNTL3                                  (0xff63c000 + (0x0ab << 2))
+#define   P_HHI_FIX_PLL_CNTL3                                  (volatile uint32_t *)(0xff63c000 + (0x0ab << 2))
+#define     HHI_FIX_PLL_CNTL4                                  (0xff63c000 + (0x0ac << 2))
+#define SEC_HHI_FIX_PLL_CNTL4                                  (0xff63c000 + (0x0ac << 2))
+#define   P_HHI_FIX_PLL_CNTL4                                  (volatile uint32_t *)(0xff63c000 + (0x0ac << 2))
+#define     HHI_FIX_PLL_CNTL5                                  (0xff63c000 + (0x0ad << 2))
+#define SEC_HHI_FIX_PLL_CNTL5                                  (0xff63c000 + (0x0ad << 2))
+#define   P_HHI_FIX_PLL_CNTL5                                  (volatile uint32_t *)(0xff63c000 + (0x0ad << 2))
+#define     HHI_FIX_PLL_CNTL6                                  (0xff63c000 + (0x0ae << 2))
+#define SEC_HHI_FIX_PLL_CNTL6                                  (0xff63c000 + (0x0ae << 2))
+#define   P_HHI_FIX_PLL_CNTL6                                  (volatile uint32_t *)(0xff63c000 + (0x0ae << 2))
+#define     HHI_FIX_PLL_STS                                    (0xff63c000 + (0x0af << 2))
+#define SEC_HHI_FIX_PLL_STS                                    (0xff63c000 + (0x0af << 2))
+#define   P_HHI_FIX_PLL_STS                                    (volatile uint32_t *)(0xff63c000 + (0x0af << 2))
+//`define HHI_ADC_PLL_CNTL            8'haa
+//`define HHI_ADC_PLL_CNTL2           8'hab
+//`define HHI_ADC_PLL_CNTL3           8'hac
+//`define HHI_ADC_PLL_CNTL4           8'had
+//`define HHI_ADC_PLL_STS             8'hae
+//`define HHI_ADC_PLL_CNTL1           8'haf
+//`define HHI_AUDCLK_PLL_CNTL         8'hb0
+//`define HHI_AUDCLK_PLL_CNTL2        8'hb1
+//`define HHI_AUDCLK_PLL_CNTL3        8'hb2
+//`define HHI_AUDCLK_PLL_CNTL4        8'hb3
+//`define HHI_AUDCLK_PLL_CNTL5        8'hb4
+//`define HHI_AUDCLK_PLL_CNTL6        8'hb5
+//`define HHI_L2_DDR_CLK_CNTL         8'hb6
+//`define HHI_PLL_TOP_MISC            8'hba
+#define     HHI_VDAC_CNTL0                                     (0xff63c000 + (0x0bb << 2))
+#define SEC_HHI_VDAC_CNTL0                                     (0xff63c000 + (0x0bb << 2))
+#define   P_HHI_VDAC_CNTL0                                     (volatile uint32_t *)(0xff63c000 + (0x0bb << 2))
+#define     HHI_VDAC_CNTL1                                     (0xff63c000 + (0x0bc << 2))
+#define SEC_HHI_VDAC_CNTL1                                     (0xff63c000 + (0x0bc << 2))
+#define   P_HHI_VDAC_CNTL1                                     (volatile uint32_t *)(0xff63c000 + (0x0bc << 2))
+#define     HHI_SYS_PLL_CNTL0                                  (0xff63c000 + (0x0bd << 2))
+#define SEC_HHI_SYS_PLL_CNTL0                                  (0xff63c000 + (0x0bd << 2))
+#define   P_HHI_SYS_PLL_CNTL0                                  (volatile uint32_t *)(0xff63c000 + (0x0bd << 2))
+#define     HHI_SYS_PLL_CNTL1                                  (0xff63c000 + (0x0be << 2))
+#define SEC_HHI_SYS_PLL_CNTL1                                  (0xff63c000 + (0x0be << 2))
+#define   P_HHI_SYS_PLL_CNTL1                                  (volatile uint32_t *)(0xff63c000 + (0x0be << 2))
+#define     HHI_SYS_PLL_CNTL2                                  (0xff63c000 + (0x0bf << 2))
+#define SEC_HHI_SYS_PLL_CNTL2                                  (0xff63c000 + (0x0bf << 2))
+#define   P_HHI_SYS_PLL_CNTL2                                  (volatile uint32_t *)(0xff63c000 + (0x0bf << 2))
+#define     HHI_SYS_PLL_CNTL3                                  (0xff63c000 + (0x0c0 << 2))
+#define SEC_HHI_SYS_PLL_CNTL3                                  (0xff63c000 + (0x0c0 << 2))
+#define   P_HHI_SYS_PLL_CNTL3                                  (volatile uint32_t *)(0xff63c000 + (0x0c0 << 2))
+#define     HHI_SYS_PLL_CNTL4                                  (0xff63c000 + (0x0c1 << 2))
+#define SEC_HHI_SYS_PLL_CNTL4                                  (0xff63c000 + (0x0c1 << 2))
+#define   P_HHI_SYS_PLL_CNTL4                                  (volatile uint32_t *)(0xff63c000 + (0x0c1 << 2))
+#define     HHI_SYS_PLL_CNTL5                                  (0xff63c000 + (0x0c2 << 2))
+#define SEC_HHI_SYS_PLL_CNTL5                                  (0xff63c000 + (0x0c2 << 2))
+#define   P_HHI_SYS_PLL_CNTL5                                  (volatile uint32_t *)(0xff63c000 + (0x0c2 << 2))
+#define     HHI_SYS_PLL_CNTL6                                  (0xff63c000 + (0x0c3 << 2))
+#define SEC_HHI_SYS_PLL_CNTL6                                  (0xff63c000 + (0x0c3 << 2))
+#define   P_HHI_SYS_PLL_CNTL6                                  (volatile uint32_t *)(0xff63c000 + (0x0c3 << 2))
+#define     HHI_SYS_PLL_STS                                    (0xff63c000 + (0x0c4 << 2))
+#define SEC_HHI_SYS_PLL_STS                                    (0xff63c000 + (0x0c4 << 2))
+#define   P_HHI_SYS_PLL_STS                                    (volatile uint32_t *)(0xff63c000 + (0x0c4 << 2))
+#define     HHI_HDMI_PLL_CNTL0                                 (0xff63c000 + (0x0c8 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL0                                 (0xff63c000 + (0x0c8 << 2))
+#define   P_HHI_HDMI_PLL_CNTL0                                 (volatile uint32_t *)(0xff63c000 + (0x0c8 << 2))
+#define     HHI_HDMI_PLL_CNTL1                                 (0xff63c000 + (0x0c9 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL1                                 (0xff63c000 + (0x0c9 << 2))
+#define   P_HHI_HDMI_PLL_CNTL1                                 (volatile uint32_t *)(0xff63c000 + (0x0c9 << 2))
+#define     HHI_HDMI_PLL_CNTL2                                 (0xff63c000 + (0x0ca << 2))
+#define SEC_HHI_HDMI_PLL_CNTL2                                 (0xff63c000 + (0x0ca << 2))
+#define   P_HHI_HDMI_PLL_CNTL2                                 (volatile uint32_t *)(0xff63c000 + (0x0ca << 2))
+#define     HHI_HDMI_PLL_CNTL3                                 (0xff63c000 + (0x0cb << 2))
+#define SEC_HHI_HDMI_PLL_CNTL3                                 (0xff63c000 + (0x0cb << 2))
+#define   P_HHI_HDMI_PLL_CNTL3                                 (volatile uint32_t *)(0xff63c000 + (0x0cb << 2))
+#define     HHI_HDMI_PLL_CNTL4                                 (0xff63c000 + (0x0cc << 2))
+#define SEC_HHI_HDMI_PLL_CNTL4                                 (0xff63c000 + (0x0cc << 2))
+#define   P_HHI_HDMI_PLL_CNTL4                                 (volatile uint32_t *)(0xff63c000 + (0x0cc << 2))
+#define     HHI_HDMI_PLL_CNTL5                                 (0xff63c000 + (0x0cd << 2))
+#define SEC_HHI_HDMI_PLL_CNTL5                                 (0xff63c000 + (0x0cd << 2))
+#define   P_HHI_HDMI_PLL_CNTL5                                 (volatile uint32_t *)(0xff63c000 + (0x0cd << 2))
+#define     HHI_HDMI_PLL_CNTL6                                 (0xff63c000 + (0x0ce << 2))
+#define SEC_HHI_HDMI_PLL_CNTL6                                 (0xff63c000 + (0x0ce << 2))
+#define   P_HHI_HDMI_PLL_CNTL6                                 (volatile uint32_t *)(0xff63c000 + (0x0ce << 2))
+#define     HHI_HDMI_PLL_STS                                   (0xff63c000 + (0x0cf << 2))
+#define SEC_HHI_HDMI_PLL_STS                                   (0xff63c000 + (0x0cf << 2))
+#define   P_HHI_HDMI_PLL_STS                                   (volatile uint32_t *)(0xff63c000 + (0x0cf << 2))
+//`define HHI_MIPI_CSI_PHY_CLK_CNTL   8'hd0
+//`define HHI_DSI_LVDS_EDP_CNTL0      8'hd1
+//`define HHI_DSI_LVDS_EDP_CNTL1      8'hd2
+//`define HHI_CSI_PHY_CNTL0           8'hd3
+//`define HHI_CSI_PHY_CNTL1           8'hd4
+//`define HHI_CSI_PHY_CNTL2           8'hd5
+//`define HHI_CSI_PHY_CNTL3           8'hd6
+//`define HHI_CSI_PHY_CNTL4           8'hd7
+//`define HHI_DIF_CSI_PHY_CNTL0       8'hd8
+//`define HHI_DIF_CSI_PHY_CNTL1       8'hd9
+//`define HHI_DIF_CSI_PHY_CNTL2       8'hda
+//`define HHI_DIF_CSI_PHY_CNTL3       8'hdb
+//`define HHI_DIF_CSI_PHY_CNTL4       8'hdc
+//`define HHI_DIF_CSI_PHY_CNTL5       8'hdd
+//`define HHI_LVDS_TX_PHY_CNTL0       8'hde
+//`define HHI_LVDS_TX_PHY_CNTL1       8'hdf
+//`define HHI_VID2_PLL_CNTL           8'he0
+//`define HHI_VID2_PLL_CNTL2          8'he1
+//`define HHI_VID2_PLL_CNTL3          8'he2
+//`define HHI_VID2_PLL_CNTL4          8'he3
+//`define HHI_VID2_PLL_CNTL5          8'he4
+//`define HHI_VID2_PLL_CNTL_I         8'he5
+#define     HHI_HDMI_PHY_CNTL0                                 (0xff63c000 + (0x0e8 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL0                                 (0xff63c000 + (0x0e8 << 2))
+#define   P_HHI_HDMI_PHY_CNTL0                                 (volatile uint32_t *)(0xff63c000 + (0x0e8 << 2))
+#define     HHI_HDMI_PHY_CNTL1                                 (0xff63c000 + (0x0e9 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL1                                 (0xff63c000 + (0x0e9 << 2))
+#define   P_HHI_HDMI_PHY_CNTL1                                 (volatile uint32_t *)(0xff63c000 + (0x0e9 << 2))
+#define     HHI_HDMI_PHY_CNTL2                                 (0xff63c000 + (0x0ea << 2))
+#define SEC_HHI_HDMI_PHY_CNTL2                                 (0xff63c000 + (0x0ea << 2))
+#define   P_HHI_HDMI_PHY_CNTL2                                 (volatile uint32_t *)(0xff63c000 + (0x0ea << 2))
+#define     HHI_HDMI_PHY_CNTL3                                 (0xff63c000 + (0x0eb << 2))
+#define SEC_HHI_HDMI_PHY_CNTL3                                 (0xff63c000 + (0x0eb << 2))
+#define   P_HHI_HDMI_PHY_CNTL3                                 (volatile uint32_t *)(0xff63c000 + (0x0eb << 2))
+#define     HHI_HDMI_PHY_CNTL4                                 (0xff63c000 + (0x0ec << 2))
+#define SEC_HHI_HDMI_PHY_CNTL4                                 (0xff63c000 + (0x0ec << 2))
+#define   P_HHI_HDMI_PHY_CNTL4                                 (volatile uint32_t *)(0xff63c000 + (0x0ec << 2))
+#define     HHI_HDMI_PHY_CNTL5                                 (0xff63c000 + (0x0ed << 2))
+#define SEC_HHI_HDMI_PHY_CNTL5                                 (0xff63c000 + (0x0ed << 2))
+#define   P_HHI_HDMI_PHY_CNTL5                                 (volatile uint32_t *)(0xff63c000 + (0x0ed << 2))
+#define     HHI_HDMI_PHY_STATUS                                (0xff63c000 + (0x0ee << 2))
+#define SEC_HHI_HDMI_PHY_STATUS                                (0xff63c000 + (0x0ee << 2))
+#define   P_HHI_HDMI_PHY_STATUS                                (volatile uint32_t *)(0xff63c000 + (0x0ee << 2))
+//`define HHI_ADEC_SYS_CLK_CNTL       8'hf1
+#define     HHI_VID_LOCK_CLK_CNTL                              (0xff63c000 + (0x0f2 << 2))
+#define SEC_HHI_VID_LOCK_CLK_CNTL                              (0xff63c000 + (0x0f2 << 2))
+#define   P_HHI_VID_LOCK_CLK_CNTL                              (volatile uint32_t *)(0xff63c000 + (0x0f2 << 2))
+//`define HHI_ATV_DMD_SYS_CLK_CNTL    8'hf3
+#define     HHI_AXI_PIPEL_CNTL                                 (0xff63c000 + (0x0f4 << 2))
+#define SEC_HHI_AXI_PIPEL_CNTL                                 (0xff63c000 + (0x0f4 << 2))
+#define   P_HHI_AXI_PIPEL_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x0f4 << 2))
+#define     HHI_BT656_CLK_CNTL                                 (0xff63c000 + (0x0f5 << 2))
+#define SEC_HHI_BT656_CLK_CNTL                                 (0xff63c000 + (0x0f5 << 2))
+#define   P_HHI_BT656_CLK_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x0f5 << 2))
+#define     HHI_CDAC_CLK_CNTL                                  (0xff63c000 + (0x0f6 << 2))
+#define SEC_HHI_CDAC_CLK_CNTL                                  (0xff63c000 + (0x0f6 << 2))
+#define   P_HHI_CDAC_CLK_CNTL                                  (volatile uint32_t *)(0xff63c000 + (0x0f6 << 2))
+#define     HHI_SPICC_CLK_CNTL                                 (0xff63c000 + (0x0f7 << 2))
+#define SEC_HHI_SPICC_CLK_CNTL                                 (0xff63c000 + (0x0f7 << 2))
+#define   P_HHI_SPICC_CLK_CNTL                                 (volatile uint32_t *)(0xff63c000 + (0x0f7 << 2))
+//`define HHI_HDMIRX_AUD_PLL_CNTL     8'hf8
+//`define HHI_HDMIRX_AUD_PLL_CNTL2    8'hf9
+//`define HHI_HDMIRX_AUD_PLL_CNTL3    8'hfa
+//`define HHI_HDMIRX_AUD_PLL_CNTL4    8'hfb
+//`define HHI_HDMIRX_AUD_PLL_CNTL5    8'hfc
+//`define HHI_HDMIRX_AUD_PLL_CNTL6    8'hfd
+//`define HHI_HDMIRX_AUD_PLL_CNTL_I   8'hfe
+//========================================================================
+//  HIU - Mailbox
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hFF63C400
+// APB4_DECODER_SECURE_BASE         32'hFF63C400
+#define     HIU_MAILBOX_SET_0                                  (0xff63c400 + (0x001 << 2))
+#define SEC_HIU_MAILBOX_SET_0                                  (0xff63c400 + (0x001 << 2))
+#define   P_HIU_MAILBOX_SET_0                                  (volatile uint32_t *)(0xff63c400 + (0x001 << 2))
+#define     HIU_MAILBOX_STAT_0                                 (0xff63c400 + (0x002 << 2))
+#define SEC_HIU_MAILBOX_STAT_0                                 (0xff63c400 + (0x002 << 2))
+#define   P_HIU_MAILBOX_STAT_0                                 (volatile uint32_t *)(0xff63c400 + (0x002 << 2))
+#define     HIU_MAILBOX_CLR_0                                  (0xff63c400 + (0x003 << 2))
+#define SEC_HIU_MAILBOX_CLR_0                                  (0xff63c400 + (0x003 << 2))
+#define   P_HIU_MAILBOX_CLR_0                                  (volatile uint32_t *)(0xff63c400 + (0x003 << 2))
+#define     HIU_MAILBOX_SET_1                                  (0xff63c400 + (0x004 << 2))
+#define SEC_HIU_MAILBOX_SET_1                                  (0xff63c400 + (0x004 << 2))
+#define   P_HIU_MAILBOX_SET_1                                  (volatile uint32_t *)(0xff63c400 + (0x004 << 2))
+#define     HIU_MAILBOX_STAT_1                                 (0xff63c400 + (0x005 << 2))
+#define SEC_HIU_MAILBOX_STAT_1                                 (0xff63c400 + (0x005 << 2))
+#define   P_HIU_MAILBOX_STAT_1                                 (volatile uint32_t *)(0xff63c400 + (0x005 << 2))
+#define     HIU_MAILBOX_CLR_1                                  (0xff63c400 + (0x006 << 2))
+#define SEC_HIU_MAILBOX_CLR_1                                  (0xff63c400 + (0x006 << 2))
+#define   P_HIU_MAILBOX_CLR_1                                  (volatile uint32_t *)(0xff63c400 + (0x006 << 2))
+#define     HIU_MAILBOX_SET_2                                  (0xff63c400 + (0x007 << 2))
+#define SEC_HIU_MAILBOX_SET_2                                  (0xff63c400 + (0x007 << 2))
+#define   P_HIU_MAILBOX_SET_2                                  (volatile uint32_t *)(0xff63c400 + (0x007 << 2))
+#define     HIU_MAILBOX_STAT_2                                 (0xff63c400 + (0x008 << 2))
+#define SEC_HIU_MAILBOX_STAT_2                                 (0xff63c400 + (0x008 << 2))
+#define   P_HIU_MAILBOX_STAT_2                                 (volatile uint32_t *)(0xff63c400 + (0x008 << 2))
+#define     HIU_MAILBOX_CLR_2                                  (0xff63c400 + (0x009 << 2))
+#define SEC_HIU_MAILBOX_CLR_2                                  (0xff63c400 + (0x009 << 2))
+#define   P_HIU_MAILBOX_CLR_2                                  (volatile uint32_t *)(0xff63c400 + (0x009 << 2))
+#define     HIU_MAILBOX_SET_3                                  (0xff63c400 + (0x00a << 2))
+#define SEC_HIU_MAILBOX_SET_3                                  (0xff63c400 + (0x00a << 2))
+#define   P_HIU_MAILBOX_SET_3                                  (volatile uint32_t *)(0xff63c400 + (0x00a << 2))
+#define     HIU_MAILBOX_STAT_3                                 (0xff63c400 + (0x00b << 2))
+#define SEC_HIU_MAILBOX_STAT_3                                 (0xff63c400 + (0x00b << 2))
+#define   P_HIU_MAILBOX_STAT_3                                 (volatile uint32_t *)(0xff63c400 + (0x00b << 2))
+#define     HIU_MAILBOX_CLR_3                                  (0xff63c400 + (0x00c << 2))
+#define SEC_HIU_MAILBOX_CLR_3                                  (0xff63c400 + (0x00c << 2))
+#define   P_HIU_MAILBOX_CLR_3                                  (volatile uint32_t *)(0xff63c400 + (0x00c << 2))
+#define     HIU_MAILBOX_SET_4                                  (0xff63c400 + (0x00d << 2))
+#define SEC_HIU_MAILBOX_SET_4                                  (0xff63c400 + (0x00d << 2))
+#define   P_HIU_MAILBOX_SET_4                                  (volatile uint32_t *)(0xff63c400 + (0x00d << 2))
+#define     HIU_MAILBOX_STAT_4                                 (0xff63c400 + (0x00e << 2))
+#define SEC_HIU_MAILBOX_STAT_4                                 (0xff63c400 + (0x00e << 2))
+#define   P_HIU_MAILBOX_STAT_4                                 (volatile uint32_t *)(0xff63c400 + (0x00e << 2))
+#define     HIU_MAILBOX_CLR_4                                  (0xff63c400 + (0x00f << 2))
+#define SEC_HIU_MAILBOX_CLR_4                                  (0xff63c400 + (0x00f << 2))
+#define   P_HIU_MAILBOX_CLR_4                                  (volatile uint32_t *)(0xff63c400 + (0x00f << 2))
+#define     HIU_MAILBOX_SET_5                                  (0xff63c400 + (0x010 << 2))
+#define SEC_HIU_MAILBOX_SET_5                                  (0xff63c400 + (0x010 << 2))
+#define   P_HIU_MAILBOX_SET_5                                  (volatile uint32_t *)(0xff63c400 + (0x010 << 2))
+#define     HIU_MAILBOX_STAT_5                                 (0xff63c400 + (0x011 << 2))
+#define SEC_HIU_MAILBOX_STAT_5                                 (0xff63c400 + (0x011 << 2))
+#define   P_HIU_MAILBOX_STAT_5                                 (volatile uint32_t *)(0xff63c400 + (0x011 << 2))
+#define     HIU_MAILBOX_CLR_5                                  (0xff63c400 + (0x012 << 2))
+#define SEC_HIU_MAILBOX_CLR_5                                  (0xff63c400 + (0x012 << 2))
+#define   P_HIU_MAILBOX_CLR_5                                  (volatile uint32_t *)(0xff63c400 + (0x012 << 2))
+#define     HIU_MAILBOX_SET_6                                  (0xff63c400 + (0x013 << 2))
+#define SEC_HIU_MAILBOX_SET_6                                  (0xff63c400 + (0x013 << 2))
+#define   P_HIU_MAILBOX_SET_6                                  (volatile uint32_t *)(0xff63c400 + (0x013 << 2))
+#define     HIU_MAILBOX_STAT_6                                 (0xff63c400 + (0x014 << 2))
+#define SEC_HIU_MAILBOX_STAT_6                                 (0xff63c400 + (0x014 << 2))
+#define   P_HIU_MAILBOX_STAT_6                                 (volatile uint32_t *)(0xff63c400 + (0x014 << 2))
+#define     HIU_MAILBOX_CLR_6                                  (0xff63c400 + (0x015 << 2))
+#define SEC_HIU_MAILBOX_CLR_6                                  (0xff63c400 + (0x015 << 2))
+#define   P_HIU_MAILBOX_CLR_6                                  (volatile uint32_t *)(0xff63c400 + (0x015 << 2))
+#define     HIU_MAILBOX_SET_7                                  (0xff63c400 + (0x016 << 2))
+#define SEC_HIU_MAILBOX_SET_7                                  (0xff63c400 + (0x016 << 2))
+#define   P_HIU_MAILBOX_SET_7                                  (volatile uint32_t *)(0xff63c400 + (0x016 << 2))
+#define     HIU_MAILBOX_STAT_7                                 (0xff63c400 + (0x017 << 2))
+#define SEC_HIU_MAILBOX_STAT_7                                 (0xff63c400 + (0x017 << 2))
+#define   P_HIU_MAILBOX_STAT_7                                 (volatile uint32_t *)(0xff63c400 + (0x017 << 2))
+#define     HIU_MAILBOX_CLR_7                                  (0xff63c400 + (0x018 << 2))
+#define SEC_HIU_MAILBOX_CLR_7                                  (0xff63c400 + (0x018 << 2))
+#define   P_HIU_MAILBOX_CLR_7                                  (volatile uint32_t *)(0xff63c400 + (0x018 << 2))
+//========================================================================
+//  EFUSE
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF630000
+//  APB4_DECODER_SECURE_BASE         32'hFF630000
+#define     EFUSE_CLR                                          (0xff630000 + (0x000 << 2))
+#define SEC_EFUSE_CLR                                          (0xff630000 + (0x000 << 2))
+#define   P_EFUSE_CLR                                          (volatile uint32_t *)(0xff630000 + (0x000 << 2))
+#define     EFUSE_START                                        (0xff630000 + (0x001 << 2))
+#define SEC_EFUSE_START                                        (0xff630000 + (0x001 << 2))
+#define   P_EFUSE_START                                        (volatile uint32_t *)(0xff630000 + (0x001 << 2))
+#define     EFUSE_WDATA0                                       (0xff630000 + (0x004 << 2))
+#define SEC_EFUSE_WDATA0                                       (0xff630000 + (0x004 << 2))
+#define   P_EFUSE_WDATA0                                       (volatile uint32_t *)(0xff630000 + (0x004 << 2))
+#define     EFUSE_WDATA1                                       (0xff630000 + (0x005 << 2))
+#define SEC_EFUSE_WDATA1                                       (0xff630000 + (0x005 << 2))
+#define   P_EFUSE_WDATA1                                       (volatile uint32_t *)(0xff630000 + (0x005 << 2))
+#define     EFUSE_WDATA2                                       (0xff630000 + (0x006 << 2))
+#define SEC_EFUSE_WDATA2                                       (0xff630000 + (0x006 << 2))
+#define   P_EFUSE_WDATA2                                       (volatile uint32_t *)(0xff630000 + (0x006 << 2))
+#define     EFUSE_WDATA3                                       (0xff630000 + (0x007 << 2))
+#define SEC_EFUSE_WDATA3                                       (0xff630000 + (0x007 << 2))
+#define   P_EFUSE_WDATA3                                       (volatile uint32_t *)(0xff630000 + (0x007 << 2))
+#define     EFUSE_RDATA0                                       (0xff630000 + (0x008 << 2))
+#define SEC_EFUSE_RDATA0                                       (0xff630000 + (0x008 << 2))
+#define   P_EFUSE_RDATA0                                       (volatile uint32_t *)(0xff630000 + (0x008 << 2))
+#define     EFUSE_RDATA1                                       (0xff630000 + (0x009 << 2))
+#define SEC_EFUSE_RDATA1                                       (0xff630000 + (0x009 << 2))
+#define   P_EFUSE_RDATA1                                       (volatile uint32_t *)(0xff630000 + (0x009 << 2))
+#define     EFUSE_RDATA2                                       (0xff630000 + (0x00a << 2))
+#define SEC_EFUSE_RDATA2                                       (0xff630000 + (0x00a << 2))
+#define   P_EFUSE_RDATA2                                       (volatile uint32_t *)(0xff630000 + (0x00a << 2))
+#define     EFUSE_RDATA3                                       (0xff630000 + (0x00b << 2))
+#define SEC_EFUSE_RDATA3                                       (0xff630000 + (0x00b << 2))
+#define   P_EFUSE_RDATA3                                       (volatile uint32_t *)(0xff630000 + (0x00b << 2))
+#define     EFUSE_LIC0                                         (0xff630000 + (0x00c << 2))
+#define SEC_EFUSE_LIC0                                         (0xff630000 + (0x00c << 2))
+#define   P_EFUSE_LIC0                                         (volatile uint32_t *)(0xff630000 + (0x00c << 2))
+#define     EFUSE_LIC1                                         (0xff630000 + (0x00d << 2))
+#define SEC_EFUSE_LIC1                                         (0xff630000 + (0x00d << 2))
+#define   P_EFUSE_LIC1                                         (volatile uint32_t *)(0xff630000 + (0x00d << 2))
+#define     EFUSE_LIC2                                         (0xff630000 + (0x00e << 2))
+#define SEC_EFUSE_LIC2                                         (0xff630000 + (0x00e << 2))
+#define   P_EFUSE_LIC2                                         (volatile uint32_t *)(0xff630000 + (0x00e << 2))
+#define     EFUSE_LIC3                                         (0xff630000 + (0x00f << 2))
+#define SEC_EFUSE_LIC3                                         (0xff630000 + (0x00f << 2))
+#define   P_EFUSE_LIC3                                         (volatile uint32_t *)(0xff630000 + (0x00f << 2))
+#define     KL_START0                                          (0xff630000 + (0x020 << 2))
+#define SEC_KL_START0                                          (0xff630000 + (0x020 << 2))
+#define   P_KL_START0                                          (volatile uint32_t *)(0xff630000 + (0x020 << 2))
+#define     KL_START1                                          (0xff630000 + (0x021 << 2))
+#define SEC_KL_START1                                          (0xff630000 + (0x021 << 2))
+#define   P_KL_START1                                          (volatile uint32_t *)(0xff630000 + (0x021 << 2))
+#define     KL_RESP0_0                                         (0xff630000 + (0x024 << 2))
+#define SEC_KL_RESP0_0                                         (0xff630000 + (0x024 << 2))
+#define   P_KL_RESP0_0                                         (volatile uint32_t *)(0xff630000 + (0x024 << 2))
+#define     KL_RESP0_1                                         (0xff630000 + (0x025 << 2))
+#define SEC_KL_RESP0_1                                         (0xff630000 + (0x025 << 2))
+#define   P_KL_RESP0_1                                         (volatile uint32_t *)(0xff630000 + (0x025 << 2))
+#define     KL_RESP0_2                                         (0xff630000 + (0x026 << 2))
+#define SEC_KL_RESP0_2                                         (0xff630000 + (0x026 << 2))
+#define   P_KL_RESP0_2                                         (volatile uint32_t *)(0xff630000 + (0x026 << 2))
+#define     KL_RESP0_3                                         (0xff630000 + (0x027 << 2))
+#define SEC_KL_RESP0_3                                         (0xff630000 + (0x027 << 2))
+#define   P_KL_RESP0_3                                         (volatile uint32_t *)(0xff630000 + (0x027 << 2))
+#define     KL_RESP1_0                                         (0xff630000 + (0x028 << 2))
+#define SEC_KL_RESP1_0                                         (0xff630000 + (0x028 << 2))
+#define   P_KL_RESP1_0                                         (volatile uint32_t *)(0xff630000 + (0x028 << 2))
+#define     KL_RESP1_1                                         (0xff630000 + (0x029 << 2))
+#define SEC_KL_RESP1_1                                         (0xff630000 + (0x029 << 2))
+#define   P_KL_RESP1_1                                         (volatile uint32_t *)(0xff630000 + (0x029 << 2))
+#define     KL_RESP1_2                                         (0xff630000 + (0x02a << 2))
+#define SEC_KL_RESP1_2                                         (0xff630000 + (0x02a << 2))
+#define   P_KL_RESP1_2                                         (volatile uint32_t *)(0xff630000 + (0x02a << 2))
+#define     KL_RESP1_3                                         (0xff630000 + (0x02b << 2))
+#define SEC_KL_RESP1_3                                         (0xff630000 + (0x02b << 2))
+#define   P_KL_RESP1_3                                         (volatile uint32_t *)(0xff630000 + (0x02b << 2))
+#define     KL_RAM                                             (0xff630000 + (0x040 << 2))
+#define SEC_KL_RAM                                             (0xff630000 + (0x040 << 2))
+#define   P_KL_RAM                                             (volatile uint32_t *)(0xff630000 + (0x040 << 2))
+#define     RNG_SEC_CONFIG_REG1                                (0xff630000 + (0x081 << 2))
+#define SEC_RNG_SEC_CONFIG_REG1                                (0xff630000 + (0x081 << 2))
+#define   P_RNG_SEC_CONFIG_REG1                                (volatile uint32_t *)(0xff630000 + (0x081 << 2))
+#define     RNG_SEC_CONFIG_REG2                                (0xff630000 + (0x082 << 2))
+#define SEC_RNG_SEC_CONFIG_REG2                                (0xff630000 + (0x082 << 2))
+#define   P_RNG_SEC_CONFIG_REG2                                (volatile uint32_t *)(0xff630000 + (0x082 << 2))
+#define     RNG_SEC_DATA                                       (0xff630000 + (0x084 << 2))
+#define SEC_RNG_SEC_DATA                                       (0xff630000 + (0x084 << 2))
+#define   P_RNG_SEC_DATA                                       (volatile uint32_t *)(0xff630000 + (0x084 << 2))
+#define     RNG_SEC_STS                                        (0xff630000 + (0x085 << 2))
+#define SEC_RNG_SEC_STS                                        (0xff630000 + (0x085 << 2))
+#define   P_RNG_SEC_STS                                        (volatile uint32_t *)(0xff630000 + (0x085 << 2))
+#define     RNG_USR_DATA                                       (0xff630000 + (0x086 << 2))
+#define SEC_RNG_USR_DATA                                       (0xff630000 + (0x086 << 2))
+#define   P_RNG_USR_DATA                                       (volatile uint32_t *)(0xff630000 + (0x086 << 2))
+#define     RNG_USR_STS                                        (0xff630000 + (0x087 << 2))
+#define SEC_RNG_USR_STS                                        (0xff630000 + (0x087 << 2))
+#define   P_RNG_USR_STS                                        (volatile uint32_t *)(0xff630000 + (0x087 << 2))
+//========================================================================
+//  Ethernet Phy
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF64C000
+//  APB4_DECODER_SECURE_BASE         32'hFF64C000
+#define     ETH_PHY_DBG_CTL0                                   (0xff64c000 + (0x000 << 2))
+#define SEC_ETH_PHY_DBG_CTL0                                   (0xff64c000 + (0x000 << 2))
+#define   P_ETH_PHY_DBG_CTL0                                   (volatile uint32_t *)(0xff64c000 + (0x000 << 2))
+#define     ETH_PHY_DBG_CTL1                                   (0xff64c000 + (0x001 << 2))
+#define SEC_ETH_PHY_DBG_CTL1                                   (0xff64c000 + (0x001 << 2))
+#define   P_ETH_PHY_DBG_CTL1                                   (volatile uint32_t *)(0xff64c000 + (0x001 << 2))
+#define     ETH_PHY_DBG_CFG0                                   (0xff64c000 + (0x002 << 2))
+#define SEC_ETH_PHY_DBG_CFG0                                   (0xff64c000 + (0x002 << 2))
+#define   P_ETH_PHY_DBG_CFG0                                   (volatile uint32_t *)(0xff64c000 + (0x002 << 2))
+#define     ETH_PHY_DBG_CFG1                                   (0xff64c000 + (0x003 << 2))
+#define SEC_ETH_PHY_DBG_CFG1                                   (0xff64c000 + (0x003 << 2))
+#define   P_ETH_PHY_DBG_CFG1                                   (volatile uint32_t *)(0xff64c000 + (0x003 << 2))
+#define     ETH_PHY_DBG_CFG2                                   (0xff64c000 + (0x004 << 2))
+#define SEC_ETH_PHY_DBG_CFG2                                   (0xff64c000 + (0x004 << 2))
+#define   P_ETH_PHY_DBG_CFG2                                   (volatile uint32_t *)(0xff64c000 + (0x004 << 2))
+#define     ETH_PHY_DBG_CFG3                                   (0xff64c000 + (0x005 << 2))
+#define SEC_ETH_PHY_DBG_CFG3                                   (0xff64c000 + (0x005 << 2))
+#define   P_ETH_PHY_DBG_CFG3                                   (volatile uint32_t *)(0xff64c000 + (0x005 << 2))
+#define     ETH_PHY_DBG_CFG4                                   (0xff64c000 + (0x006 << 2))
+#define SEC_ETH_PHY_DBG_CFG4                                   (0xff64c000 + (0x006 << 2))
+#define   P_ETH_PHY_DBG_CFG4                                   (volatile uint32_t *)(0xff64c000 + (0x006 << 2))
+#define     ETH_PLL_STS                                        (0xff64c000 + (0x010 << 2))
+#define SEC_ETH_PLL_STS                                        (0xff64c000 + (0x010 << 2))
+#define   P_ETH_PLL_STS                                        (volatile uint32_t *)(0xff64c000 + (0x010 << 2))
+#define     ETH_PLL_CTL0                                       (0xff64c000 + (0x011 << 2))
+#define SEC_ETH_PLL_CTL0                                       (0xff64c000 + (0x011 << 2))
+#define   P_ETH_PLL_CTL0                                       (volatile uint32_t *)(0xff64c000 + (0x011 << 2))
+#define     ETH_PLL_CTL1                                       (0xff64c000 + (0x012 << 2))
+#define SEC_ETH_PLL_CTL1                                       (0xff64c000 + (0x012 << 2))
+#define   P_ETH_PLL_CTL1                                       (volatile uint32_t *)(0xff64c000 + (0x012 << 2))
+#define     ETH_PLL_CTL2                                       (0xff64c000 + (0x013 << 2))
+#define SEC_ETH_PLL_CTL2                                       (0xff64c000 + (0x013 << 2))
+#define   P_ETH_PLL_CTL2                                       (volatile uint32_t *)(0xff64c000 + (0x013 << 2))
+#define     ETH_PLL_CTL3                                       (0xff64c000 + (0x014 << 2))
+#define SEC_ETH_PLL_CTL3                                       (0xff64c000 + (0x014 << 2))
+#define   P_ETH_PLL_CTL3                                       (volatile uint32_t *)(0xff64c000 + (0x014 << 2))
+#define     ETH_PLL_CTL4                                       (0xff64c000 + (0x015 << 2))
+#define SEC_ETH_PLL_CTL4                                       (0xff64c000 + (0x015 << 2))
+#define   P_ETH_PLL_CTL4                                       (volatile uint32_t *)(0xff64c000 + (0x015 << 2))
+#define     ETH_PLL_CTL5                                       (0xff64c000 + (0x016 << 2))
+#define SEC_ETH_PLL_CTL5                                       (0xff64c000 + (0x016 << 2))
+#define   P_ETH_PLL_CTL5                                       (volatile uint32_t *)(0xff64c000 + (0x016 << 2))
+#define     ETH_PLL_CTL6                                       (0xff64c000 + (0x017 << 2))
+#define SEC_ETH_PLL_CTL6                                       (0xff64c000 + (0x017 << 2))
+#define   P_ETH_PLL_CTL6                                       (volatile uint32_t *)(0xff64c000 + (0x017 << 2))
+#define     ETH_PLL_CTL7                                       (0xff64c000 + (0x018 << 2))
+#define SEC_ETH_PLL_CTL7                                       (0xff64c000 + (0x018 << 2))
+#define   P_ETH_PLL_CTL7                                       (volatile uint32_t *)(0xff64c000 + (0x018 << 2))
+#define     ETH_PHY_CNTL0                                      (0xff64c000 + (0x020 << 2))
+#define SEC_ETH_PHY_CNTL0                                      (0xff64c000 + (0x020 << 2))
+#define   P_ETH_PHY_CNTL0                                      (volatile uint32_t *)(0xff64c000 + (0x020 << 2))
+#define     ETH_PHY_CNTL1                                      (0xff64c000 + (0x021 << 2))
+#define SEC_ETH_PHY_CNTL1                                      (0xff64c000 + (0x021 << 2))
+#define   P_ETH_PHY_CNTL1                                      (volatile uint32_t *)(0xff64c000 + (0x021 << 2))
+#define     ETH_PHY_CNTL2                                      (0xff64c000 + (0x022 << 2))
+#define SEC_ETH_PHY_CNTL2                                      (0xff64c000 + (0x022 << 2))
+#define   P_ETH_PHY_CNTL2                                      (volatile uint32_t *)(0xff64c000 + (0x022 << 2))
+#define     ETH_PHY_STS0                                       (0xff64c000 + (0x025 << 2))
+#define SEC_ETH_PHY_STS0                                       (0xff64c000 + (0x025 << 2))
+#define   P_ETH_PHY_STS0                                       (volatile uint32_t *)(0xff64c000 + (0x025 << 2))
+#define     ETH_PHY_STS1                                       (0xff64c000 + (0x026 << 2))
+#define SEC_ETH_PHY_STS1                                       (0xff64c000 + (0x026 << 2))
+#define   P_ETH_PHY_STS1                                       (volatile uint32_t *)(0xff64c000 + (0x026 << 2))
+#define     ETH_PHY_STS2                                       (0xff64c000 + (0x027 << 2))
+#define SEC_ETH_PHY_STS2                                       (0xff64c000 + (0x027 << 2))
+#define   P_ETH_PHY_STS2                                       (volatile uint32_t *)(0xff64c000 + (0x027 << 2))
+#define     ETH_PHY_DBG_REG                                    (0xff64c000 + (0x028 << 2))
+#define SEC_ETH_PHY_DBG_REG                                    (0xff64c000 + (0x028 << 2))
+#define   P_ETH_PHY_DBG_REG                                    (volatile uint32_t *)(0xff64c000 + (0x028 << 2))
+//========================================================================
+//  PDM
+//========================================================================
+//
+// Reading file:  ../audio/rtl/pdm_reg.vh
+//
+//  APB4_DECODER_NON_SECURE_BASE     32'hFF640000
+//  APB4_DECODER_SECURE_BASE         32'hFF640000
+#define     PDM_CTRL                                           (0xff640000 + (0x000 << 2))
+#define SEC_PDM_CTRL                                           (0xff640000 + (0x000 << 2))
+#define   P_PDM_CTRL                                           (volatile uint32_t *)(0xff640000 + (0x000 << 2))
+#define     PDM_HCIC_CTRL1                                     (0xff640000 + (0x001 << 2))
+#define SEC_PDM_HCIC_CTRL1                                     (0xff640000 + (0x001 << 2))
+#define   P_PDM_HCIC_CTRL1                                     (volatile uint32_t *)(0xff640000 + (0x001 << 2))
+#define     PDM_HCIC_CTRL2                                     (0xff640000 + (0x002 << 2))
+#define SEC_PDM_HCIC_CTRL2                                     (0xff640000 + (0x002 << 2))
+#define   P_PDM_HCIC_CTRL2                                     (volatile uint32_t *)(0xff640000 + (0x002 << 2))
+#define     PDM_F1_CTRL                                        (0xff640000 + (0x003 << 2))
+#define SEC_PDM_F1_CTRL                                        (0xff640000 + (0x003 << 2))
+#define   P_PDM_F1_CTRL                                        (volatile uint32_t *)(0xff640000 + (0x003 << 2))
+#define     PDM_F2_CTRL                                        (0xff640000 + (0x004 << 2))
+#define SEC_PDM_F2_CTRL                                        (0xff640000 + (0x004 << 2))
+#define   P_PDM_F2_CTRL                                        (volatile uint32_t *)(0xff640000 + (0x004 << 2))
+#define     PDM_F3_CTRL                                        (0xff640000 + (0x005 << 2))
+#define SEC_PDM_F3_CTRL                                        (0xff640000 + (0x005 << 2))
+#define   P_PDM_F3_CTRL                                        (volatile uint32_t *)(0xff640000 + (0x005 << 2))
+#define     PDM_HPF_CTRL                                       (0xff640000 + (0x006 << 2))
+#define SEC_PDM_HPF_CTRL                                       (0xff640000 + (0x006 << 2))
+#define   P_PDM_HPF_CTRL                                       (volatile uint32_t *)(0xff640000 + (0x006 << 2))
+#define     PDM_CHAN_CTRL                                      (0xff640000 + (0x007 << 2))
+#define SEC_PDM_CHAN_CTRL                                      (0xff640000 + (0x007 << 2))
+#define   P_PDM_CHAN_CTRL                                      (volatile uint32_t *)(0xff640000 + (0x007 << 2))
+#define     PDM_CHAN_CTRL1                                     (0xff640000 + (0x008 << 2))
+#define SEC_PDM_CHAN_CTRL1                                     (0xff640000 + (0x008 << 2))
+#define   P_PDM_CHAN_CTRL1                                     (volatile uint32_t *)(0xff640000 + (0x008 << 2))
+#define     PDM_COEFF_ADDR                                     (0xff640000 + (0x009 << 2))
+#define SEC_PDM_COEFF_ADDR                                     (0xff640000 + (0x009 << 2))
+#define   P_PDM_COEFF_ADDR                                     (volatile uint32_t *)(0xff640000 + (0x009 << 2))
+#define     PDM_COEFF_DATA                                     (0xff640000 + (0x00a << 2))
+#define SEC_PDM_COEFF_DATA                                     (0xff640000 + (0x00a << 2))
+#define   P_PDM_COEFF_DATA                                     (volatile uint32_t *)(0xff640000 + (0x00a << 2))
+#define     PDM_CLKG_CTRL                                      (0xff640000 + (0x00b << 2))
+#define SEC_PDM_CLKG_CTRL                                      (0xff640000 + (0x00b << 2))
+#define   P_PDM_CLKG_CTRL                                      (volatile uint32_t *)(0xff640000 + (0x00b << 2))
+#define     PDM_STS                                            (0xff640000 + (0x00c << 2))
+#define SEC_PDM_STS                                            (0xff640000 + (0x00c << 2))
+#define   P_PDM_STS                                            (volatile uint32_t *)(0xff640000 + (0x00c << 2))
+//bit 1  HPF filter output overflow.  means the PCLK is too slow.
+//bit 0  HCIC filter output overflow. means the CTS_PDM_CLK is too slow. can't finished the filter function.
+#define     PDM_MUTE_VALUE                                     (0xff640000 + (0x00d << 2))
+#define SEC_PDM_MUTE_VALUE                                     (0xff640000 + (0x00d << 2))
+#define   P_PDM_MUTE_VALUE                                     (volatile uint32_t *)(0xff640000 + (0x00d << 2))
+//
+// Closing file:  ../audio/rtl/pdm_reg.vh
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./secure_apb4_ee.h
+//
+//
+// Reading file:  ./ao_rti_reg.h
+//
+//#define AO_RTI_REG_BASE 0x00
+// APB4_DECODER_NON_SECURE_BASE     32'hFF800000
+// APB4_DECODER_SECURE_BASE         32'hFF800000
+// Registers not affected by the Watchdog timer
+#define     AO_RTI_STATUS_REG0                                 (0xff800000 + (0x000 << 2))
+#define SEC_AO_RTI_STATUS_REG0                                 (0xff800000 + (0x000 << 2))
+#define   P_AO_RTI_STATUS_REG0                                 (volatile uint32_t *)(0xff800000 + (0x000 << 2))
+#define     AO_RTI_STATUS_REG1                                 (0xff800000 + (0x001 << 2))
+#define SEC_AO_RTI_STATUS_REG1                                 (0xff800000 + (0x001 << 2))
+#define   P_AO_RTI_STATUS_REG1                                 (volatile uint32_t *)(0xff800000 + (0x001 << 2))
+#define     AO_RTI_STATUS_REG2                                 (0xff800000 + (0x002 << 2))
+#define SEC_AO_RTI_STATUS_REG2                                 (0xff800000 + (0x002 << 2))
+#define   P_AO_RTI_STATUS_REG2                                 (volatile uint32_t *)(0xff800000 + (0x002 << 2))
+#define     AO_RTI_STATUS_REG3                                 (0xff800000 + (0x003 << 2))
+#define SEC_AO_RTI_STATUS_REG3                                 (0xff800000 + (0x003 << 2))
+#define   P_AO_RTI_STATUS_REG3                                 (volatile uint32_t *)(0xff800000 + (0x003 << 2))
+//`define AO_RTI_PWR_CNTL_REG1        8'h03
+#define     AO_RTI_PWR_CNTL_REG0                               (0xff800000 + (0x004 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG0                               (0xff800000 + (0x004 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG0                               (volatile uint32_t *)(0xff800000 + (0x004 << 2))
+#define     AO_RTI_PINMUX_REG0                                 (0xff800000 + (0x005 << 2))
+#define SEC_AO_RTI_PINMUX_REG0                                 (0xff800000 + (0x005 << 2))
+#define   P_AO_RTI_PINMUX_REG0                                 (volatile uint32_t *)(0xff800000 + (0x005 << 2))
+#define     AO_RTI_PINMUX_REG1                                 (0xff800000 + (0x006 << 2))
+#define SEC_AO_RTI_PINMUX_REG1                                 (0xff800000 + (0x006 << 2))
+#define   P_AO_RTI_PINMUX_REG1                                 (volatile uint32_t *)(0xff800000 + (0x006 << 2))
+//`define AO_REMAP_REG1               8'h08
+#define     AO_PAD_DS_A                                        (0xff800000 + (0x007 << 2))
+#define SEC_AO_PAD_DS_A                                        (0xff800000 + (0x007 << 2))
+#define   P_AO_PAD_DS_A                                        (volatile uint32_t *)(0xff800000 + (0x007 << 2))
+#define     AO_PAD_DS_B                                        (0xff800000 + (0x008 << 2))
+#define SEC_AO_PAD_DS_B                                        (0xff800000 + (0x008 << 2))
+#define   P_AO_PAD_DS_B                                        (volatile uint32_t *)(0xff800000 + (0x008 << 2))
+#define     AO_GPIO_O_EN_N                                     (0xff800000 + (0x009 << 2))
+#define SEC_AO_GPIO_O_EN_N                                     (0xff800000 + (0x009 << 2))
+#define   P_AO_GPIO_O_EN_N                                     (volatile uint32_t *)(0xff800000 + (0x009 << 2))
+#define     AO_GPIO_I                                          (0xff800000 + (0x00a << 2))
+#define SEC_AO_GPIO_I                                          (0xff800000 + (0x00a << 2))
+#define   P_AO_GPIO_I                                          (volatile uint32_t *)(0xff800000 + (0x00a << 2))
+#define     AO_RTI_PULL_UP_REG                                 (0xff800000 + (0x00b << 2))
+#define SEC_AO_RTI_PULL_UP_REG                                 (0xff800000 + (0x00b << 2))
+#define   P_AO_RTI_PULL_UP_REG                                 (volatile uint32_t *)(0xff800000 + (0x00b << 2))
+#define     AO_RTI_PULL_UP_EN_REG                              (0xff800000 + (0x00c << 2))
+#define SEC_AO_RTI_PULL_UP_EN_REG                              (0xff800000 + (0x00c << 2))
+#define   P_AO_RTI_PULL_UP_EN_REG                              (volatile uint32_t *)(0xff800000 + (0x00c << 2))
+#define     AO_GPIO_O                                          (0xff800000 + (0x00d << 2))
+#define SEC_AO_GPIO_O                                          (0xff800000 + (0x00d << 2))
+#define   P_AO_GPIO_O                                          (volatile uint32_t *)(0xff800000 + (0x00d << 2))
+//`define AO_RTI_JTAG_CONFIG_REG      8'h0C
+//`define AO_RTI_WD_MARK              8'h0D
+#define     AO_CPU_CNTL                                        (0xff800000 + (0x00e << 2))
+#define SEC_AO_CPU_CNTL                                        (0xff800000 + (0x00e << 2))
+#define   P_AO_CPU_CNTL                                        (volatile uint32_t *)(0xff800000 + (0x00e << 2))
+#define     AO_CPU_CNTL2                                       (0xff800000 + (0x00f << 2))
+#define SEC_AO_CPU_CNTL2                                       (0xff800000 + (0x00f << 2))
+#define   P_AO_CPU_CNTL2                                       (volatile uint32_t *)(0xff800000 + (0x00f << 2))
+#define     AO_RTI_GEN_CNTL_REG0                               (0xff800000 + (0x010 << 2))
+#define SEC_AO_RTI_GEN_CNTL_REG0                               (0xff800000 + (0x010 << 2))
+#define   P_AO_RTI_GEN_CNTL_REG0                               (volatile uint32_t *)(0xff800000 + (0x010 << 2))
+#define     AO_CPU_CNTL_NS                                     (0xff800000 + (0x011 << 2))
+#define SEC_AO_CPU_CNTL_NS                                     (0xff800000 + (0x011 << 2))
+#define   P_AO_CPU_CNTL_NS                                     (volatile uint32_t *)(0xff800000 + (0x011 << 2))
+#define     AO_METAL_REVISION_1                                (0xff800000 + (0x012 << 2))
+#define SEC_AO_METAL_REVISION_1                                (0xff800000 + (0x012 << 2))
+#define   P_AO_METAL_REVISION_1                                (volatile uint32_t *)(0xff800000 + (0x012 << 2))
+#define     AO_CLK_GATE0                                       (0xff800000 + (0x013 << 2))
+#define SEC_AO_CLK_GATE0                                       (0xff800000 + (0x013 << 2))
+#define   P_AO_CLK_GATE0                                       (volatile uint32_t *)(0xff800000 + (0x013 << 2))
+#define     AO_CLK_GATE0_SP                                    (0xff800000 + (0x014 << 2))
+#define SEC_AO_CLK_GATE0_SP                                    (0xff800000 + (0x014 << 2))
+#define   P_AO_CLK_GATE0_SP                                    (volatile uint32_t *)(0xff800000 + (0x014 << 2))
+#define     AO_TIMEBASE_CNTL1                                  (0xff800000 + (0x015 << 2))
+#define SEC_AO_TIMEBASE_CNTL1                                  (0xff800000 + (0x015 << 2))
+#define   P_AO_TIMEBASE_CNTL1                                  (volatile uint32_t *)(0xff800000 + (0x015 << 2))
+#define     AO_OSCIN_CNTL                                      (0xff800000 + (0x016 << 2))
+#define SEC_AO_OSCIN_CNTL                                      (0xff800000 + (0x016 << 2))
+#define   P_AO_OSCIN_CNTL                                      (volatile uint32_t *)(0xff800000 + (0x016 << 2))
+#define     AO_PINMUX_LOCK                                     (0xff800000 + (0x017 << 2))
+#define SEC_AO_PINMUX_LOCK                                     (0xff800000 + (0x017 << 2))
+#define   P_AO_PINMUX_LOCK                                     (volatile uint32_t *)(0xff800000 + (0x017 << 2))
+#define     AO_AHB2DDR_CNTL                                    (0xff800000 + (0x018 << 2))
+#define SEC_AO_AHB2DDR_CNTL                                    (0xff800000 + (0x018 << 2))
+#define   P_AO_AHB2DDR_CNTL                                    (volatile uint32_t *)(0xff800000 + (0x018 << 2))
+#define     AO_TIMEBASE_CNTL                                   (0xff800000 + (0x019 << 2))
+#define SEC_AO_TIMEBASE_CNTL                                   (0xff800000 + (0x019 << 2))
+#define   P_AO_TIMEBASE_CNTL                                   (volatile uint32_t *)(0xff800000 + (0x019 << 2))
+#define     AO_GEN_CLK_CNTL                                    (0xff800000 + (0x01a << 2))
+#define SEC_AO_GEN_CLK_CNTL                                    (0xff800000 + (0x01a << 2))
+#define   P_AO_GEN_CLK_CNTL                                    (volatile uint32_t *)(0xff800000 + (0x01a << 2))
+//`define AO_RTI_INTER_OSC_CTL0       8'h1b
+//`define AO_RTI_INTER_OSC_CTL1       8'h1c
+#define     AO_CEC_CLK_CNTL_REG0                               (0xff800000 + (0x01d << 2))
+#define SEC_AO_CEC_CLK_CNTL_REG0                               (0xff800000 + (0x01d << 2))
+#define   P_AO_CEC_CLK_CNTL_REG0                               (volatile uint32_t *)(0xff800000 + (0x01d << 2))
+#define     AO_CEC_CLK_CNTL_REG1                               (0xff800000 + (0x01e << 2))
+#define SEC_AO_CEC_CLK_CNTL_REG1                               (0xff800000 + (0x01e << 2))
+#define   P_AO_CEC_CLK_CNTL_REG1                               (volatile uint32_t *)(0xff800000 + (0x01e << 2))
+#define     AO_METAL_REVISION                                  (0xff800000 + (0x01f << 2))
+#define SEC_AO_METAL_REVISION                                  (0xff800000 + (0x01f << 2))
+#define   P_AO_METAL_REVISION                                  (volatile uint32_t *)(0xff800000 + (0x01f << 2))
+//`define AO_IRQ_MASK_FIQ_SEL         8'h20
+#define     AO_IRQ_GPIO_REG                                    (0xff800000 + (0x021 << 2))
+#define SEC_AO_IRQ_GPIO_REG                                    (0xff800000 + (0x021 << 2))
+#define   P_AO_IRQ_GPIO_REG                                    (volatile uint32_t *)(0xff800000 + (0x021 << 2))
+//`define AO_IRQ_STAT                 8'h22
+//`define AO_IRQ_STAT_CLR             8'h23
+#define     AO_SAR_CLK                                         (0xff800000 + (0x024 << 2))
+#define SEC_AO_SAR_CLK                                         (0xff800000 + (0x024 << 2))
+#define   P_AO_SAR_CLK                                         (volatile uint32_t *)(0xff800000 + (0x024 << 2))
+#define     AO_RTC_ALT_CLK_CNTL0                               (0xff800000 + (0x025 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL0                               (0xff800000 + (0x025 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL0                               (volatile uint32_t *)(0xff800000 + (0x025 << 2))
+#define     AO_RTC_ALT_CLK_CNTL1                               (0xff800000 + (0x026 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL1                               (0xff800000 + (0x026 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL1                               (volatile uint32_t *)(0xff800000 + (0x026 << 2))
+#define     AO_TIMESTAMP_CNTL2                                 (0xff800000 + (0x027 << 2))
+#define SEC_AO_TIMESTAMP_CNTL2                                 (0xff800000 + (0x027 << 2))
+#define   P_AO_TIMESTAMP_CNTL2                                 (volatile uint32_t *)(0xff800000 + (0x027 << 2))
+#define     AO_DEBUG_REG0                                      (0xff800000 + (0x028 << 2))
+#define SEC_AO_DEBUG_REG0                                      (0xff800000 + (0x028 << 2))
+#define   P_AO_DEBUG_REG0                                      (volatile uint32_t *)(0xff800000 + (0x028 << 2))
+#define     AO_DEBUG_REG1                                      (0xff800000 + (0x029 << 2))
+#define SEC_AO_DEBUG_REG1                                      (0xff800000 + (0x029 << 2))
+#define   P_AO_DEBUG_REG1                                      (volatile uint32_t *)(0xff800000 + (0x029 << 2))
+#define     AO_DEBUG_REG2                                      (0xff800000 + (0x02a << 2))
+#define SEC_AO_DEBUG_REG2                                      (0xff800000 + (0x02a << 2))
+#define   P_AO_DEBUG_REG2                                      (volatile uint32_t *)(0xff800000 + (0x02a << 2))
+#define     AO_DEBUG_REG3                                      (0xff800000 + (0x02b << 2))
+#define SEC_AO_DEBUG_REG3                                      (0xff800000 + (0x02b << 2))
+#define   P_AO_DEBUG_REG3                                      (volatile uint32_t *)(0xff800000 + (0x02b << 2))
+#define     AO_TIMESTAMP_CNTL1                                 (0xff800000 + (0x02c << 2))
+#define SEC_AO_TIMESTAMP_CNTL1                                 (0xff800000 + (0x02c << 2))
+#define   P_AO_TIMESTAMP_CNTL1                                 (volatile uint32_t *)(0xff800000 + (0x02c << 2))
+#define     AO_TIMESTAMP_CNTL                                  (0xff800000 + (0x02d << 2))
+#define SEC_AO_TIMESTAMP_CNTL                                  (0xff800000 + (0x02d << 2))
+#define   P_AO_TIMESTAMP_CNTL                                  (volatile uint32_t *)(0xff800000 + (0x02d << 2))
+#define     AO_TIMESTAMP_RD0                                   (0xff800000 + (0x02e << 2))
+#define SEC_AO_TIMESTAMP_RD0                                   (0xff800000 + (0x02e << 2))
+#define   P_AO_TIMESTAMP_RD0                                   (volatile uint32_t *)(0xff800000 + (0x02e << 2))
+#define     AO_TIMESTAMP_RD1                                   (0xff800000 + (0x02f << 2))
+#define SEC_AO_TIMESTAMP_RD1                                   (0xff800000 + (0x02f << 2))
+#define   P_AO_TIMESTAMP_RD1                                   (volatile uint32_t *)(0xff800000 + (0x02f << 2))
+#define     SP_HOLD_CTRL                                       (0xff800000 + (0x031 << 2))
+#define SEC_SP_HOLD_CTRL                                       (0xff800000 + (0x031 << 2))
+#define   P_SP_HOLD_CTRL                                       (volatile uint32_t *)(0xff800000 + (0x031 << 2))
+#define     AO_FR_EE_WR_ONCE                                   (0xff800000 + (0x032 << 2))
+#define SEC_AO_FR_EE_WR_ONCE                                   (0xff800000 + (0x032 << 2))
+#define   P_AO_FR_EE_WR_ONCE                                   (volatile uint32_t *)(0xff800000 + (0x032 << 2))
+#define     AO_CPU_STAT1                                       (0xff800000 + (0x033 << 2))
+#define SEC_AO_CPU_STAT1                                       (0xff800000 + (0x033 << 2))
+#define   P_AO_CPU_STAT1                                       (volatile uint32_t *)(0xff800000 + (0x033 << 2))
+#define     AO_CPU_STAT2                                       (0xff800000 + (0x034 << 2))
+#define SEC_AO_CPU_STAT2                                       (0xff800000 + (0x034 << 2))
+#define   P_AO_CPU_STAT2                                       (volatile uint32_t *)(0xff800000 + (0x034 << 2))
+#define     AO_CPU_TIMESTAMP                                   (0xff800000 + (0x035 << 2))
+#define SEC_AO_CPU_TIMESTAMP                                   (0xff800000 + (0x035 << 2))
+#define   P_AO_CPU_TIMESTAMP                                   (volatile uint32_t *)(0xff800000 + (0x035 << 2))
+#define     AO_CPU_TIMESTAMP2                                  (0xff800000 + (0x036 << 2))
+#define SEC_AO_CPU_TIMESTAMP2                                  (0xff800000 + (0x036 << 2))
+#define   P_AO_CPU_TIMESTAMP2                                  (volatile uint32_t *)(0xff800000 + (0x036 << 2))
+#define     AO_CPU_CNTL3                                       (0xff800000 + (0x037 << 2))
+#define SEC_AO_CPU_CNTL3                                       (0xff800000 + (0x037 << 2))
+#define   P_AO_CPU_CNTL3                                       (volatile uint32_t *)(0xff800000 + (0x037 << 2))
+// general Power control
+#define     AO_RTI_PWR_SYS_CPU_CNTL0                           (0xff800000 + (0x038 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL0                           (0xff800000 + (0x038 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL0                           (volatile uint32_t *)(0xff800000 + (0x038 << 2))
+#define     AO_RTI_PWR_SYS_CPU_CNTL1                           (0xff800000 + (0x039 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL1                           (0xff800000 + (0x039 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL1                           (volatile uint32_t *)(0xff800000 + (0x039 << 2))
+#define     AO_RTI_GEN_PWR_SLEEP0                              (0xff800000 + (0x03a << 2))
+#define SEC_AO_RTI_GEN_PWR_SLEEP0                              (0xff800000 + (0x03a << 2))
+#define   P_AO_RTI_GEN_PWR_SLEEP0                              (volatile uint32_t *)(0xff800000 + (0x03a << 2))
+#define     AO_RTI_GEN_PWR_ISO0                                (0xff800000 + (0x03b << 2))
+#define SEC_AO_RTI_GEN_PWR_ISO0                                (0xff800000 + (0x03b << 2))
+#define   P_AO_RTI_GEN_PWR_ISO0                                (volatile uint32_t *)(0xff800000 + (0x03b << 2))
+#define     AO_RTI_GEN_PWR_ACK0                                (0xff800000 + (0x03c << 2))
+#define SEC_AO_RTI_GEN_PWR_ACK0                                (0xff800000 + (0x03c << 2))
+#define   P_AO_RTI_GEN_PWR_ACK0                                (volatile uint32_t *)(0xff800000 + (0x03c << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xff800000 + (0x03d << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xff800000 + (0x03d << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (volatile uint32_t *)(0xff800000 + (0x03d << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xff800000 + (0x03e << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xff800000 + (0x03e << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (volatile uint32_t *)(0xff800000 + (0x03e << 2))
+#define     AO_CPU_CNTL4                                       (0xff800000 + (0x03f << 2))
+#define SEC_AO_CPU_CNTL4                                       (0xff800000 + (0x03f << 2))
+#define   P_AO_CPU_CNTL4                                       (volatile uint32_t *)(0xff800000 + (0x03f << 2))
+#define     AO_CEC_GEN_CNTL                                    (0xff800000 + (0x040 << 2))
+#define SEC_AO_CEC_GEN_CNTL                                    (0xff800000 + (0x040 << 2))
+#define   P_AO_CEC_GEN_CNTL                                    (volatile uint32_t *)(0xff800000 + (0x040 << 2))
+#define     AO_CEC_RW_REG                                      (0xff800000 + (0x041 << 2))
+#define SEC_AO_CEC_RW_REG                                      (0xff800000 + (0x041 << 2))
+#define   P_AO_CEC_RW_REG                                      (volatile uint32_t *)(0xff800000 + (0x041 << 2))
+#define     AO_CEC_INTR_MASKN                                  (0xff800000 + (0x042 << 2))
+#define SEC_AO_CEC_INTR_MASKN                                  (0xff800000 + (0x042 << 2))
+#define   P_AO_CEC_INTR_MASKN                                  (volatile uint32_t *)(0xff800000 + (0x042 << 2))
+#define     AO_CEC_INTR_CLR                                    (0xff800000 + (0x043 << 2))
+#define SEC_AO_CEC_INTR_CLR                                    (0xff800000 + (0x043 << 2))
+#define   P_AO_CEC_INTR_CLR                                    (volatile uint32_t *)(0xff800000 + (0x043 << 2))
+#define     AO_CEC_INTR_STAT                                   (0xff800000 + (0x044 << 2))
+#define SEC_AO_CEC_INTR_STAT                                   (0xff800000 + (0x044 << 2))
+#define   P_AO_CEC_INTR_STAT                                   (volatile uint32_t *)(0xff800000 + (0x044 << 2))
+#define     AO_CPU_CNTL5                                       (0xff800000 + (0x045 << 2))
+#define SEC_AO_CPU_CNTL5                                       (0xff800000 + (0x045 << 2))
+#define   P_AO_CPU_CNTL5                                       (volatile uint32_t *)(0xff800000 + (0x045 << 2))
+#define     AO_WATCHDOG_CNTL                                   (0xff800000 + (0x048 << 2))
+#define SEC_AO_WATCHDOG_CNTL                                   (0xff800000 + (0x048 << 2))
+#define   P_AO_WATCHDOG_CNTL                                   (volatile uint32_t *)(0xff800000 + (0x048 << 2))
+#define     AO_WATCHDOG_CNTL1                                  (0xff800000 + (0x049 << 2))
+#define SEC_AO_WATCHDOG_CNTL1                                  (0xff800000 + (0x049 << 2))
+#define   P_AO_WATCHDOG_CNTL1                                  (volatile uint32_t *)(0xff800000 + (0x049 << 2))
+#define     AO_WATCHDOG_TCNT                                   (0xff800000 + (0x04a << 2))
+#define SEC_AO_WATCHDOG_TCNT                                   (0xff800000 + (0x04a << 2))
+#define   P_AO_WATCHDOG_TCNT                                   (volatile uint32_t *)(0xff800000 + (0x04a << 2))
+#define     AO_WATCHDOG_RESET                                  (0xff800000 + (0x04b << 2))
+#define SEC_AO_WATCHDOG_RESET                                  (0xff800000 + (0x04b << 2))
+#define   P_AO_WATCHDOG_RESET                                  (volatile uint32_t *)(0xff800000 + (0x04b << 2))
+#define     AO_RTI_STICKY_REG0                                 (0xff800000 + (0x04c << 2))
+#define SEC_AO_RTI_STICKY_REG0                                 (0xff800000 + (0x04c << 2))
+#define   P_AO_RTI_STICKY_REG0                                 (volatile uint32_t *)(0xff800000 + (0x04c << 2))
+#define     AO_RTI_STICKY_REG1                                 (0xff800000 + (0x04d << 2))
+#define SEC_AO_RTI_STICKY_REG1                                 (0xff800000 + (0x04d << 2))
+#define   P_AO_RTI_STICKY_REG1                                 (volatile uint32_t *)(0xff800000 + (0x04d << 2))
+#define     AO_RTI_STICKY_REG2                                 (0xff800000 + (0x04e << 2))
+#define SEC_AO_RTI_STICKY_REG2                                 (0xff800000 + (0x04e << 2))
+#define   P_AO_RTI_STICKY_REG2                                 (volatile uint32_t *)(0xff800000 + (0x04e << 2))
+#define     AO_RTI_STICKY_REG3                                 (0xff800000 + (0x04f << 2))
+#define SEC_AO_RTI_STICKY_REG3                                 (0xff800000 + (0x04f << 2))
+#define   P_AO_RTI_STICKY_REG3                                 (volatile uint32_t *)(0xff800000 + (0x04f << 2))
+//
+// Secure APB3 Slot 2 registers
+//
+#define     AO_SEC_REG0                                        (0xff800000 + (0x050 << 2))
+#define SEC_AO_SEC_REG0                                        (0xff800000 + (0x050 << 2))
+#define   P_AO_SEC_REG0                                        (volatile uint32_t *)(0xff800000 + (0x050 << 2))
+//`define AO_SEC_REG1                     8'h51
+#define     AO_IR_BLASTER_ADDR0                                (0xff800000 + (0x053 << 2))
+#define SEC_AO_IR_BLASTER_ADDR0                                (0xff800000 + (0x053 << 2))
+#define   P_AO_IR_BLASTER_ADDR0                                (volatile uint32_t *)(0xff800000 + (0x053 << 2))
+#define     AO_IR_BLASTER_ADDR1                                (0xff800000 + (0x054 << 2))
+#define SEC_AO_IR_BLASTER_ADDR1                                (0xff800000 + (0x054 << 2))
+#define   P_AO_IR_BLASTER_ADDR1                                (volatile uint32_t *)(0xff800000 + (0x054 << 2))
+#define     AO_IR_BLASTER_ADDR2                                (0xff800000 + (0x055 << 2))
+#define SEC_AO_IR_BLASTER_ADDR2                                (0xff800000 + (0x055 << 2))
+#define   P_AO_IR_BLASTER_ADDR2                                (volatile uint32_t *)(0xff800000 + (0x055 << 2))
+#define     AO_IR_BLASTER_ADDR3                                (0xff800000 + (0x056 << 2))
+#define SEC_AO_IR_BLASTER_ADDR3                                (0xff800000 + (0x056 << 2))
+#define   P_AO_IR_BLASTER_ADDR3                                (volatile uint32_t *)(0xff800000 + (0x056 << 2))
+#define     AO_SEC_TMODE_PWD0                                  (0xff800000 + (0x058 << 2))
+#define SEC_AO_SEC_TMODE_PWD0                                  (0xff800000 + (0x058 << 2))
+#define   P_AO_SEC_TMODE_PWD0                                  (volatile uint32_t *)(0xff800000 + (0x058 << 2))
+#define     AO_SEC_TMODE_PWD1                                  (0xff800000 + (0x059 << 2))
+#define SEC_AO_SEC_TMODE_PWD1                                  (0xff800000 + (0x059 << 2))
+#define   P_AO_SEC_TMODE_PWD1                                  (volatile uint32_t *)(0xff800000 + (0x059 << 2))
+#define     AO_SEC_TMODE_PWD2                                  (0xff800000 + (0x05a << 2))
+#define SEC_AO_SEC_TMODE_PWD2                                  (0xff800000 + (0x05a << 2))
+#define   P_AO_SEC_TMODE_PWD2                                  (volatile uint32_t *)(0xff800000 + (0x05a << 2))
+#define     AO_SEC_TMODE_PWD3                                  (0xff800000 + (0x05b << 2))
+#define SEC_AO_SEC_TMODE_PWD3                                  (0xff800000 + (0x05b << 2))
+#define   P_AO_SEC_TMODE_PWD3                                  (volatile uint32_t *)(0xff800000 + (0x05b << 2))
+#define     AO_WRITE_ONCE0                                     (0xff800000 + (0x05c << 2))
+#define SEC_AO_WRITE_ONCE0                                     (0xff800000 + (0x05c << 2))
+#define   P_AO_WRITE_ONCE0                                     (volatile uint32_t *)(0xff800000 + (0x05c << 2))
+#define     AO_WRITE_ONCE1                                     (0xff800000 + (0x05d << 2))
+#define SEC_AO_WRITE_ONCE1                                     (0xff800000 + (0x05d << 2))
+#define   P_AO_WRITE_ONCE1                                     (volatile uint32_t *)(0xff800000 + (0x05d << 2))
+#define     AO_WRITE_ONCE2                                     (0xff800000 + (0x05e << 2))
+#define SEC_AO_WRITE_ONCE2                                     (0xff800000 + (0x05e << 2))
+#define   P_AO_WRITE_ONCE2                                     (volatile uint32_t *)(0xff800000 + (0x05e << 2))
+#define     AO_SEC_SCRATCH                                     (0xff800000 + (0x05f << 2))
+#define SEC_AO_SEC_SCRATCH                                     (0xff800000 + (0x05f << 2))
+#define   P_AO_SEC_SCRATCH                                     (volatile uint32_t *)(0xff800000 + (0x05f << 2))
+#define     AO_MSG_INDEX0                                      (0xff800000 + (0x060 << 2))
+#define SEC_AO_MSG_INDEX0                                      (0xff800000 + (0x060 << 2))
+#define   P_AO_MSG_INDEX0                                      (volatile uint32_t *)(0xff800000 + (0x060 << 2))
+#define     AO_MSG_INDEX1                                      (0xff800000 + (0x061 << 2))
+#define SEC_AO_MSG_INDEX1                                      (0xff800000 + (0x061 << 2))
+#define   P_AO_MSG_INDEX1                                      (volatile uint32_t *)(0xff800000 + (0x061 << 2))
+#define     AO_MSG_INDEX2                                      (0xff800000 + (0x062 << 2))
+#define SEC_AO_MSG_INDEX2                                      (0xff800000 + (0x062 << 2))
+#define   P_AO_MSG_INDEX2                                      (volatile uint32_t *)(0xff800000 + (0x062 << 2))
+#define     AO_MSG_INDEX3                                      (0xff800000 + (0x063 << 2))
+#define SEC_AO_MSG_INDEX3                                      (0xff800000 + (0x063 << 2))
+#define   P_AO_MSG_INDEX3                                      (volatile uint32_t *)(0xff800000 + (0x063 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_MASK_0                      (0xff800000 + (0x066 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_MASK_0                      (0xff800000 + (0x066 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_MASK_0                      (volatile uint32_t *)(0xff800000 + (0x066 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_MASK_1                      (0xff800000 + (0x067 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_MASK_1                      (0xff800000 + (0x067 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_MASK_1                      (volatile uint32_t *)(0xff800000 + (0x067 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_MASK_2                      (0xff800000 + (0x068 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_MASK_2                      (0xff800000 + (0x068 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_MASK_2                      (volatile uint32_t *)(0xff800000 + (0x068 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xff800000 + (0x069 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xff800000 + (0x069 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (volatile uint32_t *)(0xff800000 + (0x069 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xff800000 + (0x06a << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xff800000 + (0x06a << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (volatile uint32_t *)(0xff800000 + (0x06a << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xff800000 + (0x06b << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xff800000 + (0x06b << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (volatile uint32_t *)(0xff800000 + (0x06b << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xff800000 + (0x06c << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xff800000 + (0x06c << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (volatile uint32_t *)(0xff800000 + (0x06c << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xff800000 + (0x06d << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xff800000 + (0x06d << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (volatile uint32_t *)(0xff800000 + (0x06d << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xff800000 + (0x06e << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xff800000 + (0x06e << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (volatile uint32_t *)(0xff800000 + (0x06e << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xff800000 + (0x06f << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xff800000 + (0x06f << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (volatile uint32_t *)(0xff800000 + (0x06f << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xff800000 + (0x070 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xff800000 + (0x070 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (volatile uint32_t *)(0xff800000 + (0x070 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xff800000 + (0x071 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xff800000 + (0x071 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (volatile uint32_t *)(0xff800000 + (0x071 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xff800000 + (0x072 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xff800000 + (0x072 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (volatile uint32_t *)(0xff800000 + (0x072 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xff800000 + (0x073 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xff800000 + (0x073 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (volatile uint32_t *)(0xff800000 + (0x073 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xff800000 + (0x074 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xff800000 + (0x074 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (volatile uint32_t *)(0xff800000 + (0x074 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG4_0                      (0xff800000 + (0x075 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG4_0                      (0xff800000 + (0x075 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG4_0                      (volatile uint32_t *)(0xff800000 + (0x075 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG4_1                      (0xff800000 + (0x076 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG4_1                      (0xff800000 + (0x076 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG4_1                      (volatile uint32_t *)(0xff800000 + (0x076 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG4_2                      (0xff800000 + (0x077 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG4_2                      (0xff800000 + (0x077 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG4_2                      (volatile uint32_t *)(0xff800000 + (0x077 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG5_0                      (0xff800000 + (0x078 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG5_0                      (0xff800000 + (0x078 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG5_0                      (volatile uint32_t *)(0xff800000 + (0x078 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG5_1                      (0xff800000 + (0x079 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG5_1                      (0xff800000 + (0x079 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG5_1                      (volatile uint32_t *)(0xff800000 + (0x079 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG5_2                      (0xff800000 + (0x07a << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG5_2                      (0xff800000 + (0x07a << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG5_2                      (volatile uint32_t *)(0xff800000 + (0x07a << 2))
+#define     AO_SEC_AO_CPU_SRAM_REG0_0                          (0xff800000 + (0x07c << 2))
+#define SEC_AO_SEC_AO_CPU_SRAM_REG0_0                          (0xff800000 + (0x07c << 2))
+#define   P_AO_SEC_AO_CPU_SRAM_REG0_0                          (volatile uint32_t *)(0xff800000 + (0x07c << 2))
+#define     AO_SEC_AO_CPU_SRAM_REG0_1                          (0xff800000 + (0x07d << 2))
+#define SEC_AO_SEC_AO_CPU_SRAM_REG0_1                          (0xff800000 + (0x07d << 2))
+#define   P_AO_SEC_AO_CPU_SRAM_REG0_1                          (volatile uint32_t *)(0xff800000 + (0x07d << 2))
+#define     AO_SEC_AO_CPU_SRAM_REG1_0                          (0xff800000 + (0x07e << 2))
+#define SEC_AO_SEC_AO_CPU_SRAM_REG1_0                          (0xff800000 + (0x07e << 2))
+#define   P_AO_SEC_AO_CPU_SRAM_REG1_0                          (volatile uint32_t *)(0xff800000 + (0x07e << 2))
+#define     AO_SEC_AO_CPU_SRAM_REG1_1                          (0xff800000 + (0x07f << 2))
+#define SEC_AO_SEC_AO_CPU_SRAM_REG1_1                          (0xff800000 + (0x07f << 2))
+#define   P_AO_SEC_AO_CPU_SRAM_REG1_1                          (volatile uint32_t *)(0xff800000 + (0x07f << 2))
+#define     AO_SEC_SD_CFG0                                     (0xff800000 + (0x080 << 2))
+#define SEC_AO_SEC_SD_CFG0                                     (0xff800000 + (0x080 << 2))
+#define   P_AO_SEC_SD_CFG0                                     (volatile uint32_t *)(0xff800000 + (0x080 << 2))
+#define     AO_SEC_SD_CFG1                                     (0xff800000 + (0x081 << 2))
+#define SEC_AO_SEC_SD_CFG1                                     (0xff800000 + (0x081 << 2))
+#define   P_AO_SEC_SD_CFG1                                     (volatile uint32_t *)(0xff800000 + (0x081 << 2))
+#define     AO_SEC_SD_CFG2                                     (0xff800000 + (0x082 << 2))
+#define SEC_AO_SEC_SD_CFG2                                     (0xff800000 + (0x082 << 2))
+#define   P_AO_SEC_SD_CFG2                                     (volatile uint32_t *)(0xff800000 + (0x082 << 2))
+#define     AO_SEC_SD_CFG3                                     (0xff800000 + (0x083 << 2))
+#define SEC_AO_SEC_SD_CFG3                                     (0xff800000 + (0x083 << 2))
+#define   P_AO_SEC_SD_CFG3                                     (volatile uint32_t *)(0xff800000 + (0x083 << 2))
+#define     AO_SEC_SD_CFG4                                     (0xff800000 + (0x084 << 2))
+#define SEC_AO_SEC_SD_CFG4                                     (0xff800000 + (0x084 << 2))
+#define   P_AO_SEC_SD_CFG4                                     (volatile uint32_t *)(0xff800000 + (0x084 << 2))
+#define     AO_SEC_SD_CFG5                                     (0xff800000 + (0x085 << 2))
+#define SEC_AO_SEC_SD_CFG5                                     (0xff800000 + (0x085 << 2))
+#define   P_AO_SEC_SD_CFG5                                     (volatile uint32_t *)(0xff800000 + (0x085 << 2))
+#define     AO_SEC_SD_CFG6                                     (0xff800000 + (0x086 << 2))
+#define SEC_AO_SEC_SD_CFG6                                     (0xff800000 + (0x086 << 2))
+#define   P_AO_SEC_SD_CFG6                                     (volatile uint32_t *)(0xff800000 + (0x086 << 2))
+#define     AO_SEC_SD_CFG7                                     (0xff800000 + (0x087 << 2))
+#define SEC_AO_SEC_SD_CFG7                                     (0xff800000 + (0x087 << 2))
+#define   P_AO_SEC_SD_CFG7                                     (volatile uint32_t *)(0xff800000 + (0x087 << 2))
+#define     AO_SEC_SD_CFG8                                     (0xff800000 + (0x088 << 2))
+#define SEC_AO_SEC_SD_CFG8                                     (0xff800000 + (0x088 << 2))
+#define   P_AO_SEC_SD_CFG8                                     (volatile uint32_t *)(0xff800000 + (0x088 << 2))
+#define     AO_SEC_SD_CFG9                                     (0xff800000 + (0x089 << 2))
+#define SEC_AO_SEC_SD_CFG9                                     (0xff800000 + (0x089 << 2))
+#define   P_AO_SEC_SD_CFG9                                     (volatile uint32_t *)(0xff800000 + (0x089 << 2))
+#define     AO_SEC_SD_CFG10                                    (0xff800000 + (0x08a << 2))
+#define SEC_AO_SEC_SD_CFG10                                    (0xff800000 + (0x08a << 2))
+#define   P_AO_SEC_SD_CFG10                                    (volatile uint32_t *)(0xff800000 + (0x08a << 2))
+#define     AO_SEC_SD_CFG11                                    (0xff800000 + (0x08b << 2))
+#define SEC_AO_SEC_SD_CFG11                                    (0xff800000 + (0x08b << 2))
+#define   P_AO_SEC_SD_CFG11                                    (volatile uint32_t *)(0xff800000 + (0x08b << 2))
+#define     AO_SEC_SD_CFG12                                    (0xff800000 + (0x08c << 2))
+#define SEC_AO_SEC_SD_CFG12                                    (0xff800000 + (0x08c << 2))
+#define   P_AO_SEC_SD_CFG12                                    (volatile uint32_t *)(0xff800000 + (0x08c << 2))
+#define     AO_SEC_SD_CFG13                                    (0xff800000 + (0x08d << 2))
+#define SEC_AO_SEC_SD_CFG13                                    (0xff800000 + (0x08d << 2))
+#define   P_AO_SEC_SD_CFG13                                    (volatile uint32_t *)(0xff800000 + (0x08d << 2))
+#define     AO_SEC_SD_CFG14                                    (0xff800000 + (0x08e << 2))
+#define SEC_AO_SEC_SD_CFG14                                    (0xff800000 + (0x08e << 2))
+#define   P_AO_SEC_SD_CFG14                                    (volatile uint32_t *)(0xff800000 + (0x08e << 2))
+#define     AO_SEC_SD_CFG15                                    (0xff800000 + (0x08f << 2))
+#define SEC_AO_SEC_SD_CFG15                                    (0xff800000 + (0x08f << 2))
+#define   P_AO_SEC_SD_CFG15                                    (volatile uint32_t *)(0xff800000 + (0x08f << 2))
+#define     AO_SEC_GP_CFG0                                     (0xff800000 + (0x090 << 2))
+#define SEC_AO_SEC_GP_CFG0                                     (0xff800000 + (0x090 << 2))
+#define   P_AO_SEC_GP_CFG0                                     (volatile uint32_t *)(0xff800000 + (0x090 << 2))
+#define     AO_SEC_GP_CFG1                                     (0xff800000 + (0x091 << 2))
+#define SEC_AO_SEC_GP_CFG1                                     (0xff800000 + (0x091 << 2))
+#define   P_AO_SEC_GP_CFG1                                     (volatile uint32_t *)(0xff800000 + (0x091 << 2))
+#define     AO_SEC_GP_CFG2                                     (0xff800000 + (0x092 << 2))
+#define SEC_AO_SEC_GP_CFG2                                     (0xff800000 + (0x092 << 2))
+#define   P_AO_SEC_GP_CFG2                                     (volatile uint32_t *)(0xff800000 + (0x092 << 2))
+#define     AO_SEC_GP_CFG3                                     (0xff800000 + (0x093 << 2))
+#define SEC_AO_SEC_GP_CFG3                                     (0xff800000 + (0x093 << 2))
+#define   P_AO_SEC_GP_CFG3                                     (volatile uint32_t *)(0xff800000 + (0x093 << 2))
+#define     AO_SEC_GP_CFG4                                     (0xff800000 + (0x094 << 2))
+#define SEC_AO_SEC_GP_CFG4                                     (0xff800000 + (0x094 << 2))
+#define   P_AO_SEC_GP_CFG4                                     (volatile uint32_t *)(0xff800000 + (0x094 << 2))
+#define     AO_SEC_GP_CFG5                                     (0xff800000 + (0x095 << 2))
+#define SEC_AO_SEC_GP_CFG5                                     (0xff800000 + (0x095 << 2))
+#define   P_AO_SEC_GP_CFG5                                     (volatile uint32_t *)(0xff800000 + (0x095 << 2))
+#define     AO_SEC_GP_CFG6                                     (0xff800000 + (0x096 << 2))
+#define SEC_AO_SEC_GP_CFG6                                     (0xff800000 + (0x096 << 2))
+#define   P_AO_SEC_GP_CFG6                                     (volatile uint32_t *)(0xff800000 + (0x096 << 2))
+#define     AO_SEC_GP_CFG7                                     (0xff800000 + (0x097 << 2))
+#define SEC_AO_SEC_GP_CFG7                                     (0xff800000 + (0x097 << 2))
+#define   P_AO_SEC_GP_CFG7                                     (volatile uint32_t *)(0xff800000 + (0x097 << 2))
+#define     AO_SEC_GP_CFG8                                     (0xff800000 + (0x098 << 2))
+#define SEC_AO_SEC_GP_CFG8                                     (0xff800000 + (0x098 << 2))
+#define   P_AO_SEC_GP_CFG8                                     (volatile uint32_t *)(0xff800000 + (0x098 << 2))
+#define     AO_SEC_GP_CFG9                                     (0xff800000 + (0x099 << 2))
+#define SEC_AO_SEC_GP_CFG9                                     (0xff800000 + (0x099 << 2))
+#define   P_AO_SEC_GP_CFG9                                     (volatile uint32_t *)(0xff800000 + (0x099 << 2))
+#define     AO_SEC_GP_CFG10                                    (0xff800000 + (0x09a << 2))
+#define SEC_AO_SEC_GP_CFG10                                    (0xff800000 + (0x09a << 2))
+#define   P_AO_SEC_GP_CFG10                                    (volatile uint32_t *)(0xff800000 + (0x09a << 2))
+#define     AO_SEC_GP_CFG11                                    (0xff800000 + (0x09b << 2))
+#define SEC_AO_SEC_GP_CFG11                                    (0xff800000 + (0x09b << 2))
+#define   P_AO_SEC_GP_CFG11                                    (volatile uint32_t *)(0xff800000 + (0x09b << 2))
+#define     AO_SEC_GP_CFG12                                    (0xff800000 + (0x09c << 2))
+#define SEC_AO_SEC_GP_CFG12                                    (0xff800000 + (0x09c << 2))
+#define   P_AO_SEC_GP_CFG12                                    (volatile uint32_t *)(0xff800000 + (0x09c << 2))
+#define     AO_SEC_GP_CFG13                                    (0xff800000 + (0x09d << 2))
+#define SEC_AO_SEC_GP_CFG13                                    (0xff800000 + (0x09d << 2))
+#define   P_AO_SEC_GP_CFG13                                    (volatile uint32_t *)(0xff800000 + (0x09d << 2))
+#define     AO_SEC_GP_CFG14                                    (0xff800000 + (0x09e << 2))
+#define SEC_AO_SEC_GP_CFG14                                    (0xff800000 + (0x09e << 2))
+#define   P_AO_SEC_GP_CFG14                                    (volatile uint32_t *)(0xff800000 + (0x09e << 2))
+#define     AO_SEC_GP_CFG15                                    (0xff800000 + (0x09f << 2))
+#define SEC_AO_SEC_GP_CFG15                                    (0xff800000 + (0x09f << 2))
+#define   P_AO_SEC_GP_CFG15                                    (volatile uint32_t *)(0xff800000 + (0x09f << 2))
+#define     AO_CECB_CLK_CNTL_REG0                              (0xff800000 + (0x0a0 << 2))
+#define SEC_AO_CECB_CLK_CNTL_REG0                              (0xff800000 + (0x0a0 << 2))
+#define   P_AO_CECB_CLK_CNTL_REG0                              (volatile uint32_t *)(0xff800000 + (0x0a0 << 2))
+#define     AO_CECB_CLK_CNTL_REG1                              (0xff800000 + (0x0a1 << 2))
+#define SEC_AO_CECB_CLK_CNTL_REG1                              (0xff800000 + (0x0a1 << 2))
+#define   P_AO_CECB_CLK_CNTL_REG1                              (volatile uint32_t *)(0xff800000 + (0x0a1 << 2))
+#define     AO_CECB_GEN_CNTL                                   (0xff800000 + (0x0a2 << 2))
+#define SEC_AO_CECB_GEN_CNTL                                   (0xff800000 + (0x0a2 << 2))
+#define   P_AO_CECB_GEN_CNTL                                   (volatile uint32_t *)(0xff800000 + (0x0a2 << 2))
+#define     AO_CECB_RW_REG                                     (0xff800000 + (0x0a3 << 2))
+#define SEC_AO_CECB_RW_REG                                     (0xff800000 + (0x0a3 << 2))
+#define   P_AO_CECB_RW_REG                                     (volatile uint32_t *)(0xff800000 + (0x0a3 << 2))
+#define     AO_CECB_INTR_MASKN                                 (0xff800000 + (0x0a4 << 2))
+#define SEC_AO_CECB_INTR_MASKN                                 (0xff800000 + (0x0a4 << 2))
+#define   P_AO_CECB_INTR_MASKN                                 (volatile uint32_t *)(0xff800000 + (0x0a4 << 2))
+#define     AO_CECB_INTR_CLR                                   (0xff800000 + (0x0a5 << 2))
+#define SEC_AO_CECB_INTR_CLR                                   (0xff800000 + (0x0a5 << 2))
+#define   P_AO_CECB_INTR_CLR                                   (volatile uint32_t *)(0xff800000 + (0x0a5 << 2))
+#define     AO_CECB_INTR_STAT                                  (0xff800000 + (0x0a6 << 2))
+#define SEC_AO_CECB_INTR_STAT                                  (0xff800000 + (0x0a6 << 2))
+#define   P_AO_CECB_INTR_STAT                                  (volatile uint32_t *)(0xff800000 + (0x0a6 << 2))
+#define     AO_SEC_M4_CPU_SRAM_REG0_0                          (0xff800000 + (0x0a7 << 2))
+#define SEC_AO_SEC_M4_CPU_SRAM_REG0_0                          (0xff800000 + (0x0a7 << 2))
+#define   P_AO_SEC_M4_CPU_SRAM_REG0_0                          (volatile uint32_t *)(0xff800000 + (0x0a7 << 2))
+#define     AO_SEC_M4_CPU_SRAM_REG0_1                          (0xff800000 + (0x0a8 << 2))
+#define SEC_AO_SEC_M4_CPU_SRAM_REG0_1                          (0xff800000 + (0x0a8 << 2))
+#define   P_AO_SEC_M4_CPU_SRAM_REG0_1                          (volatile uint32_t *)(0xff800000 + (0x0a8 << 2))
+#define     AO_SEC_M4_CPU_SRAM_REG1_0                          (0xff800000 + (0x0a9 << 2))
+#define SEC_AO_SEC_M4_CPU_SRAM_REG1_0                          (0xff800000 + (0x0a9 << 2))
+#define   P_AO_SEC_M4_CPU_SRAM_REG1_0                          (volatile uint32_t *)(0xff800000 + (0x0a9 << 2))
+#define     AO_SEC_M4_CPU_SRAM_REG1_1                          (0xff800000 + (0x0aa << 2))
+#define SEC_AO_SEC_M4_CPU_SRAM_REG1_1                          (0xff800000 + (0x0aa << 2))
+#define   P_AO_SEC_M4_CPU_SRAM_REG1_1                          (volatile uint32_t *)(0xff800000 + (0x0aa << 2))
+#define     AO_SEC_M4_CPU_SRAM_REG2_0                          (0xff800000 + (0x0ab << 2))
+#define SEC_AO_SEC_M4_CPU_SRAM_REG2_0                          (0xff800000 + (0x0ab << 2))
+#define   P_AO_SEC_M4_CPU_SRAM_REG2_0                          (volatile uint32_t *)(0xff800000 + (0x0ab << 2))
+//`define AO_RTC_ADDR0                    8'h70 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR1                    8'h71 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR2                    8'h72 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR3                    8'h73 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR4                    8'h74 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+#define     AO_SEC_JTAG_SP_CTRL                                (0xff800000 + (0x0ac << 2))
+#define SEC_AO_SEC_JTAG_SP_CTRL                                (0xff800000 + (0x0ac << 2))
+#define   P_AO_SEC_JTAG_SP_CTRL                                (volatile uint32_t *)(0xff800000 + (0x0ac << 2))
+#define     AO_SEC_JTAG_PWD_SP_0                               (0xff800000 + (0x0ad << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_0                               (0xff800000 + (0x0ad << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_0                               (volatile uint32_t *)(0xff800000 + (0x0ad << 2))
+#define     AO_SEC_JTAG_PWD_SP_1                               (0xff800000 + (0x0ae << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_1                               (0xff800000 + (0x0ae << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_1                               (volatile uint32_t *)(0xff800000 + (0x0ae << 2))
+#define     AO_SEC_JTAG_PWD_SP_2                               (0xff800000 + (0x0af << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_2                               (0xff800000 + (0x0af << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_2                               (volatile uint32_t *)(0xff800000 + (0x0af << 2))
+#define     AO_SEC_JTAG_PWD_SP_3                               (0xff800000 + (0x0b0 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_3                               (0xff800000 + (0x0b0 << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_3                               (volatile uint32_t *)(0xff800000 + (0x0b0 << 2))
+#define     AO_SEC_JTAG_PWD_SP_CNTL                            (0xff800000 + (0x0b1 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_CNTL                            (0xff800000 + (0x0b1 << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_CNTL                            (volatile uint32_t *)(0xff800000 + (0x0b1 << 2))
+#define     AO_SEC_JTAG_PWD_SP_ADDR0                           (0xff800000 + (0x0b2 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_ADDR0                           (0xff800000 + (0x0b2 << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_ADDR0                           (volatile uint32_t *)(0xff800000 + (0x0b2 << 2))
+#define     AO_SEC_JTAG_PWD_SP_ADDR1                           (0xff800000 + (0x0b3 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_ADDR1                           (0xff800000 + (0x0b3 << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_ADDR1                           (volatile uint32_t *)(0xff800000 + (0x0b3 << 2))
+#define     AO_SEC_JTAG_PWD_SP_ADDR2                           (0xff800000 + (0x0b4 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_ADDR2                           (0xff800000 + (0x0b4 << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_ADDR2                           (volatile uint32_t *)(0xff800000 + (0x0b4 << 2))
+#define     AO_SEC_JTAG_PWD_SP_ADDR3                           (0xff800000 + (0x0b5 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SP_ADDR3                           (0xff800000 + (0x0b5 << 2))
+#define   P_AO_SEC_JTAG_PWD_SP_ADDR3                           (volatile uint32_t *)(0xff800000 + (0x0b5 << 2))
+#define     AO_SEC_JTAG_SCP_CTRL                               (0xff800000 + (0x0b6 << 2))
+#define SEC_AO_SEC_JTAG_SCP_CTRL                               (0xff800000 + (0x0b6 << 2))
+#define   P_AO_SEC_JTAG_SCP_CTRL                               (volatile uint32_t *)(0xff800000 + (0x0b6 << 2))
+#define     AO_SEC_JTAG_PWD_SCP_0                              (0xff800000 + (0x0b7 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_0                              (0xff800000 + (0x0b7 << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_0                              (volatile uint32_t *)(0xff800000 + (0x0b7 << 2))
+#define     AO_SEC_JTAG_PWD_SCP_1                              (0xff800000 + (0x0b8 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_1                              (0xff800000 + (0x0b8 << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_1                              (volatile uint32_t *)(0xff800000 + (0x0b8 << 2))
+#define     AO_SEC_JTAG_PWD_SCP_2                              (0xff800000 + (0x0b9 << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_2                              (0xff800000 + (0x0b9 << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_2                              (volatile uint32_t *)(0xff800000 + (0x0b9 << 2))
+#define     AO_SEC_JTAG_PWD_SCP_3                              (0xff800000 + (0x0ba << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_3                              (0xff800000 + (0x0ba << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_3                              (volatile uint32_t *)(0xff800000 + (0x0ba << 2))
+#define     AO_SEC_JTAG_PWD_SCP_CNTL                           (0xff800000 + (0x0bb << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_CNTL                           (0xff800000 + (0x0bb << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_CNTL                           (volatile uint32_t *)(0xff800000 + (0x0bb << 2))
+#define     AO_SEC_JTAG_PWD_SCP_ADDR0                          (0xff800000 + (0x0bc << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_ADDR0                          (0xff800000 + (0x0bc << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_ADDR0                          (volatile uint32_t *)(0xff800000 + (0x0bc << 2))
+#define     AO_SEC_JTAG_PWD_SCP_ADDR1                          (0xff800000 + (0x0bd << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_ADDR1                          (0xff800000 + (0x0bd << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_ADDR1                          (volatile uint32_t *)(0xff800000 + (0x0bd << 2))
+#define     AO_SEC_JTAG_PWD_SCP_ADDR2                          (0xff800000 + (0x0be << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_ADDR2                          (0xff800000 + (0x0be << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_ADDR2                          (volatile uint32_t *)(0xff800000 + (0x0be << 2))
+#define     AO_SEC_JTAG_PWD_SCP_ADDR3                          (0xff800000 + (0x0bf << 2))
+#define SEC_AO_SEC_JTAG_PWD_SCP_ADDR3                          (0xff800000 + (0x0bf << 2))
+#define   P_AO_SEC_JTAG_PWD_SCP_ADDR3                          (volatile uint32_t *)(0xff800000 + (0x0bf << 2))
+#define     M4_CPU_CNTL                                        (0xff800000 + (0x0c0 << 2))
+#define SEC_M4_CPU_CNTL                                        (0xff800000 + (0x0c0 << 2))
+#define   P_M4_CPU_CNTL                                        (volatile uint32_t *)(0xff800000 + (0x0c0 << 2))
+#define     M4_CPU_CNTL_NS                                     (0xff800000 + (0x0c1 << 2))
+#define SEC_M4_CPU_CNTL_NS                                     (0xff800000 + (0x0c1 << 2))
+#define   P_M4_CPU_CNTL_NS                                     (volatile uint32_t *)(0xff800000 + (0x0c1 << 2))
+#define     M4_CPU_CNTL2                                       (0xff800000 + (0x0c2 << 2))
+#define SEC_M4_CPU_CNTL2                                       (0xff800000 + (0x0c2 << 2))
+#define   P_M4_CPU_CNTL2                                       (volatile uint32_t *)(0xff800000 + (0x0c2 << 2))
+#define     M4_CPU_CNTL3                                       (0xff800000 + (0x0c3 << 2))
+#define SEC_M4_CPU_CNTL3                                       (0xff800000 + (0x0c3 << 2))
+#define   P_M4_CPU_CNTL3                                       (volatile uint32_t *)(0xff800000 + (0x0c3 << 2))
+#define     M4_CPU_CNTL4                                       (0xff800000 + (0x0c4 << 2))
+#define SEC_M4_CPU_CNTL4                                       (0xff800000 + (0x0c4 << 2))
+#define   P_M4_CPU_CNTL4                                       (volatile uint32_t *)(0xff800000 + (0x0c4 << 2))
+#define     M4_CPU_CNTL5                                       (0xff800000 + (0x0c5 << 2))
+#define SEC_M4_CPU_CNTL5                                       (0xff800000 + (0x0c5 << 2))
+#define   P_M4_CPU_CNTL5                                       (volatile uint32_t *)(0xff800000 + (0x0c5 << 2))
+#define     M4_CPU_TIMESTAMP                                   (0xff800000 + (0x0c6 << 2))
+#define SEC_M4_CPU_TIMESTAMP                                   (0xff800000 + (0x0c6 << 2))
+#define   P_M4_CPU_TIMESTAMP                                   (volatile uint32_t *)(0xff800000 + (0x0c6 << 2))
+#define     M4_CPU_TIMESTAMP2                                  (0xff800000 + (0x0c7 << 2))
+#define SEC_M4_CPU_TIMESTAMP2                                  (0xff800000 + (0x0c7 << 2))
+#define   P_M4_CPU_TIMESTAMP2                                  (volatile uint32_t *)(0xff800000 + (0x0c7 << 2))
+#define     M4_CPU_STAT1                                       (0xff800000 + (0x0c8 << 2))
+#define SEC_M4_CPU_STAT1                                       (0xff800000 + (0x0c8 << 2))
+#define   P_M4_CPU_STAT1                                       (volatile uint32_t *)(0xff800000 + (0x0c8 << 2))
+#define     M4_CPU_STAT2                                       (0xff800000 + (0x0c9 << 2))
+#define SEC_M4_CPU_STAT2                                       (0xff800000 + (0x0c9 << 2))
+#define   P_M4_CPU_STAT2                                       (volatile uint32_t *)(0xff800000 + (0x0c9 << 2))
+#define     AO_CEC_STICKY_DATA0                                (0xff800000 + (0x0ca << 2))
+#define SEC_AO_CEC_STICKY_DATA0                                (0xff800000 + (0x0ca << 2))
+#define   P_AO_CEC_STICKY_DATA0                                (volatile uint32_t *)(0xff800000 + (0x0ca << 2))
+#define     AO_CEC_STICKY_DATA1                                (0xff800000 + (0x0cb << 2))
+#define SEC_AO_CEC_STICKY_DATA1                                (0xff800000 + (0x0cb << 2))
+#define   P_AO_CEC_STICKY_DATA1                                (volatile uint32_t *)(0xff800000 + (0x0cb << 2))
+#define     AO_CEC_STICKY_DATA2                                (0xff800000 + (0x0cc << 2))
+#define SEC_AO_CEC_STICKY_DATA2                                (0xff800000 + (0x0cc << 2))
+#define   P_AO_CEC_STICKY_DATA2                                (volatile uint32_t *)(0xff800000 + (0x0cc << 2))
+#define     AO_CEC_STICKY_DATA3                                (0xff800000 + (0x0cd << 2))
+#define SEC_AO_CEC_STICKY_DATA3                                (0xff800000 + (0x0cd << 2))
+#define   P_AO_CEC_STICKY_DATA3                                (volatile uint32_t *)(0xff800000 + (0x0cd << 2))
+#define     AO_CEC_STICKY_DATA4                                (0xff800000 + (0x0ce << 2))
+#define SEC_AO_CEC_STICKY_DATA4                                (0xff800000 + (0x0ce << 2))
+#define   P_AO_CEC_STICKY_DATA4                                (volatile uint32_t *)(0xff800000 + (0x0ce << 2))
+#define     AO_CEC_STICKY_DATA5                                (0xff800000 + (0x0cf << 2))
+#define SEC_AO_CEC_STICKY_DATA5                                (0xff800000 + (0x0cf << 2))
+#define   P_AO_CEC_STICKY_DATA5                                (volatile uint32_t *)(0xff800000 + (0x0cf << 2))
+#define     AO_CEC_STICKY_DATA6                                (0xff800000 + (0x0d0 << 2))
+#define SEC_AO_CEC_STICKY_DATA6                                (0xff800000 + (0x0d0 << 2))
+#define   P_AO_CEC_STICKY_DATA6                                (volatile uint32_t *)(0xff800000 + (0x0d0 << 2))
+#define     AO_CEC_STICKY_DATA7                                (0xff800000 + (0x0d1 << 2))
+#define SEC_AO_CEC_STICKY_DATA7                                (0xff800000 + (0x0d1 << 2))
+#define   P_AO_CEC_STICKY_DATA7                                (volatile uint32_t *)(0xff800000 + (0x0d1 << 2))
+#define     AO_SEC_SP_CFG0                                     (0xff800000 + (0x0e0 << 2))
+#define SEC_AO_SEC_SP_CFG0                                     (0xff800000 + (0x0e0 << 2))
+#define   P_AO_SEC_SP_CFG0                                     (volatile uint32_t *)(0xff800000 + (0x0e0 << 2))
+#define     AO_SEC_SP_CFG1                                     (0xff800000 + (0x0e1 << 2))
+#define SEC_AO_SEC_SP_CFG1                                     (0xff800000 + (0x0e1 << 2))
+#define   P_AO_SEC_SP_CFG1                                     (volatile uint32_t *)(0xff800000 + (0x0e1 << 2))
+#define     AO_SEC_SP_CFG2                                     (0xff800000 + (0x0e2 << 2))
+#define SEC_AO_SEC_SP_CFG2                                     (0xff800000 + (0x0e2 << 2))
+#define   P_AO_SEC_SP_CFG2                                     (volatile uint32_t *)(0xff800000 + (0x0e2 << 2))
+#define     AO_SEC_SP_CFG3                                     (0xff800000 + (0x0e3 << 2))
+#define SEC_AO_SEC_SP_CFG3                                     (0xff800000 + (0x0e3 << 2))
+#define   P_AO_SEC_SP_CFG3                                     (volatile uint32_t *)(0xff800000 + (0x0e3 << 2))
+#define     AO_SEC_SP_CFG4                                     (0xff800000 + (0x0e4 << 2))
+#define SEC_AO_SEC_SP_CFG4                                     (0xff800000 + (0x0e4 << 2))
+#define   P_AO_SEC_SP_CFG4                                     (volatile uint32_t *)(0xff800000 + (0x0e4 << 2))
+#define     AO_SEC_SP_CFG5                                     (0xff800000 + (0x0e5 << 2))
+#define SEC_AO_SEC_SP_CFG5                                     (0xff800000 + (0x0e5 << 2))
+#define   P_AO_SEC_SP_CFG5                                     (volatile uint32_t *)(0xff800000 + (0x0e5 << 2))
+#define     AO_SEC_SP_CFG6                                     (0xff800000 + (0x0e6 << 2))
+#define SEC_AO_SEC_SP_CFG6                                     (0xff800000 + (0x0e6 << 2))
+#define   P_AO_SEC_SP_CFG6                                     (volatile uint32_t *)(0xff800000 + (0x0e6 << 2))
+#define     AO_SEC_SP_CFG7                                     (0xff800000 + (0x0e7 << 2))
+#define SEC_AO_SEC_SP_CFG7                                     (0xff800000 + (0x0e7 << 2))
+#define   P_AO_SEC_SP_CFG7                                     (volatile uint32_t *)(0xff800000 + (0x0e7 << 2))
+#define     AO_SEC_SP_CFG8                                     (0xff800000 + (0x0e8 << 2))
+#define SEC_AO_SEC_SP_CFG8                                     (0xff800000 + (0x0e8 << 2))
+#define   P_AO_SEC_SP_CFG8                                     (volatile uint32_t *)(0xff800000 + (0x0e8 << 2))
+#define     AO_SEC_SP_CFG9                                     (0xff800000 + (0x0e9 << 2))
+#define SEC_AO_SEC_SP_CFG9                                     (0xff800000 + (0x0e9 << 2))
+#define   P_AO_SEC_SP_CFG9                                     (volatile uint32_t *)(0xff800000 + (0x0e9 << 2))
+#define     AO_SEC_SP_CFG10                                    (0xff800000 + (0x0ea << 2))
+#define SEC_AO_SEC_SP_CFG10                                    (0xff800000 + (0x0ea << 2))
+#define   P_AO_SEC_SP_CFG10                                    (volatile uint32_t *)(0xff800000 + (0x0ea << 2))
+#define     AO_SEC_SP_CFG11                                    (0xff800000 + (0x0eb << 2))
+#define SEC_AO_SEC_SP_CFG11                                    (0xff800000 + (0x0eb << 2))
+#define   P_AO_SEC_SP_CFG11                                    (volatile uint32_t *)(0xff800000 + (0x0eb << 2))
+#define     AO_SEC_SP_CFG12                                    (0xff800000 + (0x0ec << 2))
+#define SEC_AO_SEC_SP_CFG12                                    (0xff800000 + (0x0ec << 2))
+#define   P_AO_SEC_SP_CFG12                                    (volatile uint32_t *)(0xff800000 + (0x0ec << 2))
+#define     AO_SEC_SP_CFG13                                    (0xff800000 + (0x0ed << 2))
+#define SEC_AO_SEC_SP_CFG13                                    (0xff800000 + (0x0ed << 2))
+#define   P_AO_SEC_SP_CFG13                                    (volatile uint32_t *)(0xff800000 + (0x0ed << 2))
+#define     AO_SEC_SP_CFG14                                    (0xff800000 + (0x0ee << 2))
+#define SEC_AO_SEC_SP_CFG14                                    (0xff800000 + (0x0ee << 2))
+#define   P_AO_SEC_SP_CFG14                                    (volatile uint32_t *)(0xff800000 + (0x0ee << 2))
+#define     AO_SEC_SP_CFG15                                    (0xff800000 + (0x0ef << 2))
+#define SEC_AO_SEC_SP_CFG15                                    (0xff800000 + (0x0ef << 2))
+#define   P_AO_SEC_SP_CFG15                                    (volatile uint32_t *)(0xff800000 + (0x0ef << 2))
+#define     AO_TIMER_CTRL                                      (0xff800000 + (0x0f0 << 2))
+#define SEC_AO_TIMER_CTRL                                      (0xff800000 + (0x0f0 << 2))
+#define   P_AO_TIMER_CTRL                                      (volatile uint32_t *)(0xff800000 + (0x0f0 << 2))
+#define     AO_TIMER_SEC_SCP_CTRL                              (0xff800000 + (0x0f1 << 2))
+#define SEC_AO_TIMER_SEC_SCP_CTRL                              (0xff800000 + (0x0f1 << 2))
+#define   P_AO_TIMER_SEC_SCP_CTRL                              (volatile uint32_t *)(0xff800000 + (0x0f1 << 2))
+#define     AO_TIMER_SEC_SP_CTRL                               (0xff800000 + (0x0f2 << 2))
+#define SEC_AO_TIMER_SEC_SP_CTRL                               (0xff800000 + (0x0f2 << 2))
+#define   P_AO_TIMER_SEC_SP_CTRL                               (volatile uint32_t *)(0xff800000 + (0x0f2 << 2))
+#define     AO_TIMERA_REG                                      (0xff800000 + (0x0f3 << 2))
+#define SEC_AO_TIMERA_REG                                      (0xff800000 + (0x0f3 << 2))
+#define   P_AO_TIMERA_REG                                      (volatile uint32_t *)(0xff800000 + (0x0f3 << 2))
+#define     AO_TIMERA_CUR_REG                                  (0xff800000 + (0x0f4 << 2))
+#define SEC_AO_TIMERA_CUR_REG                                  (0xff800000 + (0x0f4 << 2))
+#define   P_AO_TIMERA_CUR_REG                                  (volatile uint32_t *)(0xff800000 + (0x0f4 << 2))
+#define     AO_TIMERB_REG                                      (0xff800000 + (0x0f5 << 2))
+#define SEC_AO_TIMERB_REG                                      (0xff800000 + (0x0f5 << 2))
+#define   P_AO_TIMERB_REG                                      (volatile uint32_t *)(0xff800000 + (0x0f5 << 2))
+#define     AO_TIMERB_CUR_REG                                  (0xff800000 + (0x0f6 << 2))
+#define SEC_AO_TIMERB_CUR_REG                                  (0xff800000 + (0x0f6 << 2))
+#define   P_AO_TIMERB_CUR_REG                                  (volatile uint32_t *)(0xff800000 + (0x0f6 << 2))
+#define     AO_TIMERC_REG                                      (0xff800000 + (0x0f7 << 2))
+#define SEC_AO_TIMERC_REG                                      (0xff800000 + (0x0f7 << 2))
+#define   P_AO_TIMERC_REG                                      (volatile uint32_t *)(0xff800000 + (0x0f7 << 2))
+#define     AO_TIMERC_CUR_REG                                  (0xff800000 + (0x0f8 << 2))
+#define SEC_AO_TIMERC_CUR_REG                                  (0xff800000 + (0x0f8 << 2))
+#define   P_AO_TIMERC_CUR_REG                                  (volatile uint32_t *)(0xff800000 + (0x0f8 << 2))
+#define     AO_TIMERE_REG                                      (0xff800000 + (0x0f9 << 2))
+#define SEC_AO_TIMERE_REG                                      (0xff800000 + (0x0f9 << 2))
+#define   P_AO_TIMERE_REG                                      (volatile uint32_t *)(0xff800000 + (0x0f9 << 2))
+#define     AO_TIMERE_HI_REG                                   (0xff800000 + (0x0fa << 2))
+#define SEC_AO_TIMERE_HI_REG                                   (0xff800000 + (0x0fa << 2))
+#define   P_AO_TIMERE_HI_REG                                   (volatile uint32_t *)(0xff800000 + (0x0fa << 2))
+#define     AO_TIMERF_REG                                      (0xff800000 + (0x0fb << 2))
+#define SEC_AO_TIMERF_REG                                      (0xff800000 + (0x0fb << 2))
+#define   P_AO_TIMERF_REG                                      (volatile uint32_t *)(0xff800000 + (0x0fb << 2))
+#define     AO_TIMERF_HI_REG                                   (0xff800000 + (0x0fc << 2))
+#define SEC_AO_TIMERF_HI_REG                                   (0xff800000 + (0x0fc << 2))
+#define   P_AO_TIMERF_HI_REG                                   (volatile uint32_t *)(0xff800000 + (0x0fc << 2))
+#define     AO_TIMERG_REG                                      (0xff800000 + (0x0fd << 2))
+#define SEC_AO_TIMERG_REG                                      (0xff800000 + (0x0fd << 2))
+#define   P_AO_TIMERG_REG                                      (volatile uint32_t *)(0xff800000 + (0x0fd << 2))
+#define     AO_TIMERG_HI_REG                                   (0xff800000 + (0x0fe << 2))
+#define SEC_AO_TIMERG_HI_REG                                   (0xff800000 + (0x0fe << 2))
+#define   P_AO_TIMERG_HI_REG                                   (volatile uint32_t *)(0xff800000 + (0x0fe << 2))
+// ----------------------------
+// PWM C-D
+// ----------------------------
+//#define AO_PWM_CD_REG_BASE 0x02
+// APB4_DECODER_NON_SECURE_BASE     32'hFF802000
+// APB4_DECODER_SECURE_BASE         32'hFF802000
+#define     AO_PWM_PWM_C                                       (0xff802000 + (0x000 << 2))
+#define SEC_AO_PWM_PWM_C                                       (0xff802000 + (0x000 << 2))
+#define   P_AO_PWM_PWM_C                                       (volatile uint32_t *)(0xff802000 + (0x000 << 2))
+#define     AO_PWM_PWM_D                                       (0xff802000 + (0x001 << 2))
+#define SEC_AO_PWM_PWM_D                                       (0xff802000 + (0x001 << 2))
+#define   P_AO_PWM_PWM_D                                       (volatile uint32_t *)(0xff802000 + (0x001 << 2))
+#define     AO_PWM_MISC_REG_CD                                 (0xff802000 + (0x002 << 2))
+#define SEC_AO_PWM_MISC_REG_CD                                 (0xff802000 + (0x002 << 2))
+#define   P_AO_PWM_MISC_REG_CD                                 (volatile uint32_t *)(0xff802000 + (0x002 << 2))
+#define     AO_PWM_DELTA_SIGMA_CD                              (0xff802000 + (0x003 << 2))
+#define SEC_AO_PWM_DELTA_SIGMA_CD                              (0xff802000 + (0x003 << 2))
+#define   P_AO_PWM_DELTA_SIGMA_CD                              (volatile uint32_t *)(0xff802000 + (0x003 << 2))
+#define     AO_PWM_TIME_CD                                     (0xff802000 + (0x004 << 2))
+#define SEC_AO_PWM_TIME_CD                                     (0xff802000 + (0x004 << 2))
+#define   P_AO_PWM_TIME_CD                                     (volatile uint32_t *)(0xff802000 + (0x004 << 2))
+#define     AO_PWM_C2                                          (0xff802000 + (0x005 << 2))
+#define SEC_AO_PWM_C2                                          (0xff802000 + (0x005 << 2))
+#define   P_AO_PWM_C2                                          (volatile uint32_t *)(0xff802000 + (0x005 << 2))
+#define     AO_PWM_D2                                          (0xff802000 + (0x006 << 2))
+#define SEC_AO_PWM_D2                                          (0xff802000 + (0x006 << 2))
+#define   P_AO_PWM_D2                                          (volatile uint32_t *)(0xff802000 + (0x006 << 2))
+#define     AO_PWM_BLINK_CD                                    (0xff802000 + (0x007 << 2))
+#define SEC_AO_PWM_BLINK_CD                                    (0xff802000 + (0x007 << 2))
+#define   P_AO_PWM_BLINK_CD                                    (volatile uint32_t *)(0xff802000 + (0x007 << 2))
+#define     AO_PWM_LOCK_CD                                     (0xff802000 + (0x008 << 2))
+#define SEC_AO_PWM_LOCK_CD                                     (0xff802000 + (0x008 << 2))
+#define   P_AO_PWM_LOCK_CD                                     (volatile uint32_t *)(0xff802000 + (0x008 << 2))
+// ----------------------------
+// UART
+// ----------------------------
+//#define AO_UART_REG_BASE 0x03
+// APB4_DECODER_NON_SECURE_BASE     32'hFF803000
+// APB4_DECODER_SECURE_BASE         32'hFF803000
+#define     AO_UART_WFIFO                                      (0xff803000 + (0x000 << 2))
+#define SEC_AO_UART_WFIFO                                      (0xff803000 + (0x000 << 2))
+#define   P_AO_UART_WFIFO                                      (volatile uint32_t *)(0xff803000 + (0x000 << 2))
+#define     AO_UART_RFIFO                                      (0xff803000 + (0x001 << 2))
+#define SEC_AO_UART_RFIFO                                      (0xff803000 + (0x001 << 2))
+#define   P_AO_UART_RFIFO                                      (volatile uint32_t *)(0xff803000 + (0x001 << 2))
+#define     AO_UART_CONTROL                                    (0xff803000 + (0x002 << 2))
+#define SEC_AO_UART_CONTROL                                    (0xff803000 + (0x002 << 2))
+#define   P_AO_UART_CONTROL                                    (volatile uint32_t *)(0xff803000 + (0x002 << 2))
+#define     AO_UART_STATUS                                     (0xff803000 + (0x003 << 2))
+#define SEC_AO_UART_STATUS                                     (0xff803000 + (0x003 << 2))
+#define   P_AO_UART_STATUS                                     (volatile uint32_t *)(0xff803000 + (0x003 << 2))
+#define     AO_UART_MISC                                       (0xff803000 + (0x004 << 2))
+#define SEC_AO_UART_MISC                                       (0xff803000 + (0x004 << 2))
+#define   P_AO_UART_MISC                                       (volatile uint32_t *)(0xff803000 + (0x004 << 2))
+#define     AO_UART_REG5                                       (0xff803000 + (0x005 << 2))
+#define SEC_AO_UART_REG5                                       (0xff803000 + (0x005 << 2))
+#define   P_AO_UART_REG5                                       (volatile uint32_t *)(0xff803000 + (0x005 << 2))
+// ----------------------------
+// UART2
+// ----------------------------
+//#define AO_UART2_REG_BASE 0x04
+// APB4_DECODER_NON_SECURE_BASE     32'hFF804000
+// APB4_DECODER_SECURE_BASE         32'hFF804000
+#define     AO_UART2_WFIFO                                     (0xff804000 + (0x000 << 2))
+#define SEC_AO_UART2_WFIFO                                     (0xff804000 + (0x000 << 2))
+#define   P_AO_UART2_WFIFO                                     (volatile uint32_t *)(0xff804000 + (0x000 << 2))
+#define     AO_UART2_RFIFO                                     (0xff804000 + (0x001 << 2))
+#define SEC_AO_UART2_RFIFO                                     (0xff804000 + (0x001 << 2))
+#define   P_AO_UART2_RFIFO                                     (volatile uint32_t *)(0xff804000 + (0x001 << 2))
+#define     AO_UART2_CONTROL                                   (0xff804000 + (0x002 << 2))
+#define SEC_AO_UART2_CONTROL                                   (0xff804000 + (0x002 << 2))
+#define   P_AO_UART2_CONTROL                                   (volatile uint32_t *)(0xff804000 + (0x002 << 2))
+#define     AO_UART2_STATUS                                    (0xff804000 + (0x003 << 2))
+#define SEC_AO_UART2_STATUS                                    (0xff804000 + (0x003 << 2))
+#define   P_AO_UART2_STATUS                                    (volatile uint32_t *)(0xff804000 + (0x003 << 2))
+#define     AO_UART2_MISC                                      (0xff804000 + (0x004 << 2))
+#define SEC_AO_UART2_MISC                                      (0xff804000 + (0x004 << 2))
+#define   P_AO_UART2_MISC                                      (volatile uint32_t *)(0xff804000 + (0x004 << 2))
+#define     AO_UART2_REG5                                      (0xff804000 + (0x005 << 2))
+#define SEC_AO_UART2_REG5                                      (0xff804000 + (0x005 << 2))
+#define   P_AO_UART2_REG5                                      (volatile uint32_t *)(0xff804000 + (0x005 << 2))
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+//#define AO_I2C_M_REG_BASE 0x05
+// APB4_DECODER_NON_SECURE_BASE     32'hFF805000
+// APB4_DECODER_SECURE_BASE         32'hFF805000
+#define     AO_I2C_M_0_CONTROL_REG                             (0xff805000 + (0x000 << 2))
+#define SEC_AO_I2C_M_0_CONTROL_REG                             (0xff805000 + (0x000 << 2))
+#define   P_AO_I2C_M_0_CONTROL_REG                             (volatile uint32_t *)(0xff805000 + (0x000 << 2))
+#define     AO_I2C_M_0_SLAVE_ADDR                              (0xff805000 + (0x001 << 2))
+#define SEC_AO_I2C_M_0_SLAVE_ADDR                              (0xff805000 + (0x001 << 2))
+#define   P_AO_I2C_M_0_SLAVE_ADDR                              (volatile uint32_t *)(0xff805000 + (0x001 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST0                             (0xff805000 + (0x002 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST0                             (0xff805000 + (0x002 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST0                             (volatile uint32_t *)(0xff805000 + (0x002 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST1                             (0xff805000 + (0x003 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST1                             (0xff805000 + (0x003 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST1                             (volatile uint32_t *)(0xff805000 + (0x003 << 2))
+#define     AO_I2C_M_0_WDATA_REG0                              (0xff805000 + (0x004 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG0                              (0xff805000 + (0x004 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG0                              (volatile uint32_t *)(0xff805000 + (0x004 << 2))
+#define     AO_I2C_M_0_WDATA_REG1                              (0xff805000 + (0x005 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG1                              (0xff805000 + (0x005 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG1                              (volatile uint32_t *)(0xff805000 + (0x005 << 2))
+#define     AO_I2C_M_0_RDATA_REG0                              (0xff805000 + (0x006 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG0                              (0xff805000 + (0x006 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG0                              (volatile uint32_t *)(0xff805000 + (0x006 << 2))
+#define     AO_I2C_M_0_RDATA_REG1                              (0xff805000 + (0x007 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG1                              (0xff805000 + (0x007 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG1                              (volatile uint32_t *)(0xff805000 + (0x007 << 2))
+#define     AO_I2C_M_0_TIMEOUT_TH                              (0xff805000 + (0x008 << 2))
+#define SEC_AO_I2C_M_0_TIMEOUT_TH                              (0xff805000 + (0x008 << 2))
+#define   P_AO_I2C_M_0_TIMEOUT_TH                              (volatile uint32_t *)(0xff805000 + (0x008 << 2))
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+//#define AO_I2C_S_REG_BASE 0x06
+// APB4_DECODER_NON_SECURE_BASE     32'hFF806000
+// APB4_DECODER_SECURE_BASE         32'hFF806000
+#define     AO_I2C_S_CONTROL_REG                               (0xff806000 + (0x000 << 2))
+#define SEC_AO_I2C_S_CONTROL_REG                               (0xff806000 + (0x000 << 2))
+#define   P_AO_I2C_S_CONTROL_REG                               (volatile uint32_t *)(0xff806000 + (0x000 << 2))
+#define     AO_I2C_S_SEND_REG                                  (0xff806000 + (0x001 << 2))
+#define SEC_AO_I2C_S_SEND_REG                                  (0xff806000 + (0x001 << 2))
+#define   P_AO_I2C_S_SEND_REG                                  (volatile uint32_t *)(0xff806000 + (0x001 << 2))
+#define     AO_I2C_S_RECV_REG                                  (0xff806000 + (0x002 << 2))
+#define SEC_AO_I2C_S_RECV_REG                                  (0xff806000 + (0x002 << 2))
+#define   P_AO_I2C_S_RECV_REG                                  (volatile uint32_t *)(0xff806000 + (0x002 << 2))
+#define     AO_I2C_S_CNTL1_REG                                 (0xff806000 + (0x003 << 2))
+#define SEC_AO_I2C_S_CNTL1_REG                                 (0xff806000 + (0x003 << 2))
+#define   P_AO_I2C_S_CNTL1_REG                                 (volatile uint32_t *)(0xff806000 + (0x003 << 2))
+// ----------------------------
+// PWM A-B
+// ----------------------------
+//#define AO_PWM_AB_REG_BASE 0x07
+// APB4_DECODER_NON_SECURE_BASE     32'hFF807000
+// APB4_DECODER_SECURE_BASE         32'hFF807000
+#define     AO_PWM_PWM_A                                       (0xff807000 + (0x000 << 2))
+#define SEC_AO_PWM_PWM_A                                       (0xff807000 + (0x000 << 2))
+#define   P_AO_PWM_PWM_A                                       (volatile uint32_t *)(0xff807000 + (0x000 << 2))
+#define     AO_PWM_PWM_B                                       (0xff807000 + (0x001 << 2))
+#define SEC_AO_PWM_PWM_B                                       (0xff807000 + (0x001 << 2))
+#define   P_AO_PWM_PWM_B                                       (volatile uint32_t *)(0xff807000 + (0x001 << 2))
+#define     AO_PWM_MISC_REG_AB                                 (0xff807000 + (0x002 << 2))
+#define SEC_AO_PWM_MISC_REG_AB                                 (0xff807000 + (0x002 << 2))
+#define   P_AO_PWM_MISC_REG_AB                                 (volatile uint32_t *)(0xff807000 + (0x002 << 2))
+#define     AO_PWM_DELTA_SIGMA_AB                              (0xff807000 + (0x003 << 2))
+#define SEC_AO_PWM_DELTA_SIGMA_AB                              (0xff807000 + (0x003 << 2))
+#define   P_AO_PWM_DELTA_SIGMA_AB                              (volatile uint32_t *)(0xff807000 + (0x003 << 2))
+#define     AO_PWM_TIME_AB                                     (0xff807000 + (0x004 << 2))
+#define SEC_AO_PWM_TIME_AB                                     (0xff807000 + (0x004 << 2))
+#define   P_AO_PWM_TIME_AB                                     (volatile uint32_t *)(0xff807000 + (0x004 << 2))
+#define     AO_PWM_A2                                          (0xff807000 + (0x005 << 2))
+#define SEC_AO_PWM_A2                                          (0xff807000 + (0x005 << 2))
+#define   P_AO_PWM_A2                                          (volatile uint32_t *)(0xff807000 + (0x005 << 2))
+#define     AO_PWM_B2                                          (0xff807000 + (0x006 << 2))
+#define SEC_AO_PWM_B2                                          (0xff807000 + (0x006 << 2))
+#define   P_AO_PWM_B2                                          (volatile uint32_t *)(0xff807000 + (0x006 << 2))
+#define     AO_PWM_BLINK_AB                                    (0xff807000 + (0x007 << 2))
+#define SEC_AO_PWM_BLINK_AB                                    (0xff807000 + (0x007 << 2))
+#define   P_AO_PWM_BLINK_AB                                    (volatile uint32_t *)(0xff807000 + (0x007 << 2))
+#define     AO_PWM_LOCK_AB                                     (0xff807000 + (0x008 << 2))
+#define SEC_AO_PWM_LOCK_AB                                     (0xff807000 + (0x008 << 2))
+#define   P_AO_PWM_LOCK_AB                                     (volatile uint32_t *)(0xff807000 + (0x008 << 2))
+// ----------------------------
+// Multiformat IR Remote
+// ----------------------------
+//#define AO_MF_IR_DEC_REG_BASE 0x08
+// APB4_DECODER_NON_SECURE_BASE     32'hFF808000
+// APB4_DECODER_SECURE_BASE         32'hFF808000
+#define     AO_IR_DEC_LDR_ACTIVE                               (0xff808000 + (0x000 << 2))
+#define SEC_AO_IR_DEC_LDR_ACTIVE                               (0xff808000 + (0x000 << 2))
+#define   P_AO_IR_DEC_LDR_ACTIVE                               (volatile uint32_t *)(0xff808000 + (0x000 << 2))
+#define     AO_IR_DEC_LDR_IDLE                                 (0xff808000 + (0x001 << 2))
+#define SEC_AO_IR_DEC_LDR_IDLE                                 (0xff808000 + (0x001 << 2))
+#define   P_AO_IR_DEC_LDR_IDLE                                 (volatile uint32_t *)(0xff808000 + (0x001 << 2))
+#define     AO_IR_DEC_LDR_REPEAT                               (0xff808000 + (0x002 << 2))
+#define SEC_AO_IR_DEC_LDR_REPEAT                               (0xff808000 + (0x002 << 2))
+#define   P_AO_IR_DEC_LDR_REPEAT                               (volatile uint32_t *)(0xff808000 + (0x002 << 2))
+#define     AO_IR_DEC_BIT_0                                    (0xff808000 + (0x003 << 2))
+#define SEC_AO_IR_DEC_BIT_0                                    (0xff808000 + (0x003 << 2))
+#define   P_AO_IR_DEC_BIT_0                                    (volatile uint32_t *)(0xff808000 + (0x003 << 2))
+#define     AO_IR_DEC_REG0                                     (0xff808000 + (0x004 << 2))
+#define SEC_AO_IR_DEC_REG0                                     (0xff808000 + (0x004 << 2))
+#define   P_AO_IR_DEC_REG0                                     (volatile uint32_t *)(0xff808000 + (0x004 << 2))
+#define     AO_IR_DEC_FRAME                                    (0xff808000 + (0x005 << 2))
+#define SEC_AO_IR_DEC_FRAME                                    (0xff808000 + (0x005 << 2))
+#define   P_AO_IR_DEC_FRAME                                    (volatile uint32_t *)(0xff808000 + (0x005 << 2))
+#define     AO_IR_DEC_STATUS                                   (0xff808000 + (0x006 << 2))
+#define SEC_AO_IR_DEC_STATUS                                   (0xff808000 + (0x006 << 2))
+#define   P_AO_IR_DEC_STATUS                                   (volatile uint32_t *)(0xff808000 + (0x006 << 2))
+#define     AO_IR_DEC_REG1                                     (0xff808000 + (0x007 << 2))
+#define SEC_AO_IR_DEC_REG1                                     (0xff808000 + (0x007 << 2))
+#define   P_AO_IR_DEC_REG1                                     (volatile uint32_t *)(0xff808000 + (0x007 << 2))
+#define     AO_MF_IR_DEC_LDR_ACTIVE                            (0xff808000 + (0x010 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_ACTIVE                            (0xff808000 + (0x010 << 2))
+#define   P_AO_MF_IR_DEC_LDR_ACTIVE                            (volatile uint32_t *)(0xff808000 + (0x010 << 2))
+#define     AO_MF_IR_DEC_LDR_IDLE                              (0xff808000 + (0x011 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_IDLE                              (0xff808000 + (0x011 << 2))
+#define   P_AO_MF_IR_DEC_LDR_IDLE                              (volatile uint32_t *)(0xff808000 + (0x011 << 2))
+#define     AO_MF_IR_DEC_LDR_REPEAT                            (0xff808000 + (0x012 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_REPEAT                            (0xff808000 + (0x012 << 2))
+#define   P_AO_MF_IR_DEC_LDR_REPEAT                            (volatile uint32_t *)(0xff808000 + (0x012 << 2))
+#define     AO_MF_IR_DEC_BIT_0                                 (0xff808000 + (0x013 << 2))
+#define SEC_AO_MF_IR_DEC_BIT_0                                 (0xff808000 + (0x013 << 2))
+#define   P_AO_MF_IR_DEC_BIT_0                                 (volatile uint32_t *)(0xff808000 + (0x013 << 2))
+#define     AO_MF_IR_DEC_REG0                                  (0xff808000 + (0x014 << 2))
+#define SEC_AO_MF_IR_DEC_REG0                                  (0xff808000 + (0x014 << 2))
+#define   P_AO_MF_IR_DEC_REG0                                  (volatile uint32_t *)(0xff808000 + (0x014 << 2))
+#define     AO_MF_IR_DEC_FRAME                                 (0xff808000 + (0x015 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME                                 (0xff808000 + (0x015 << 2))
+#define   P_AO_MF_IR_DEC_FRAME                                 (volatile uint32_t *)(0xff808000 + (0x015 << 2))
+#define     AO_MF_IR_DEC_STATUS                                (0xff808000 + (0x016 << 2))
+#define SEC_AO_MF_IR_DEC_STATUS                                (0xff808000 + (0x016 << 2))
+#define   P_AO_MF_IR_DEC_STATUS                                (volatile uint32_t *)(0xff808000 + (0x016 << 2))
+#define     AO_MF_IR_DEC_REG1                                  (0xff808000 + (0x017 << 2))
+#define SEC_AO_MF_IR_DEC_REG1                                  (0xff808000 + (0x017 << 2))
+#define   P_AO_MF_IR_DEC_REG1                                  (volatile uint32_t *)(0xff808000 + (0x017 << 2))
+#define     AO_MF_IR_DEC_REG2                                  (0xff808000 + (0x018 << 2))
+#define SEC_AO_MF_IR_DEC_REG2                                  (0xff808000 + (0x018 << 2))
+#define   P_AO_MF_IR_DEC_REG2                                  (volatile uint32_t *)(0xff808000 + (0x018 << 2))
+#define     AO_MF_IR_DEC_DURATN2                               (0xff808000 + (0x019 << 2))
+#define SEC_AO_MF_IR_DEC_DURATN2                               (0xff808000 + (0x019 << 2))
+#define   P_AO_MF_IR_DEC_DURATN2                               (volatile uint32_t *)(0xff808000 + (0x019 << 2))
+#define     AO_MF_IR_DEC_DURATN3                               (0xff808000 + (0x01a << 2))
+#define SEC_AO_MF_IR_DEC_DURATN3                               (0xff808000 + (0x01a << 2))
+#define   P_AO_MF_IR_DEC_DURATN3                               (volatile uint32_t *)(0xff808000 + (0x01a << 2))
+#define     AO_MF_IR_DEC_FRAME1                                (0xff808000 + (0x01b << 2))
+#define SEC_AO_MF_IR_DEC_FRAME1                                (0xff808000 + (0x01b << 2))
+#define   P_AO_MF_IR_DEC_FRAME1                                (volatile uint32_t *)(0xff808000 + (0x01b << 2))
+#define     AO_MF_IR_DEC_STATUS1                               (0xff808000 + (0x01c << 2))
+#define SEC_AO_MF_IR_DEC_STATUS1                               (0xff808000 + (0x01c << 2))
+#define   P_AO_MF_IR_DEC_STATUS1                               (volatile uint32_t *)(0xff808000 + (0x01c << 2))
+#define     AO_MF_IR_DEC_STATUS2                               (0xff808000 + (0x01d << 2))
+#define SEC_AO_MF_IR_DEC_STATUS2                               (0xff808000 + (0x01d << 2))
+#define   P_AO_MF_IR_DEC_STATUS2                               (volatile uint32_t *)(0xff808000 + (0x01d << 2))
+#define     AO_MF_IR_DEC_REG3                                  (0xff808000 + (0x01e << 2))
+#define SEC_AO_MF_IR_DEC_REG3                                  (0xff808000 + (0x01e << 2))
+#define   P_AO_MF_IR_DEC_REG3                                  (volatile uint32_t *)(0xff808000 + (0x01e << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV0                            (0xff808000 + (0x01f << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV0                            (0xff808000 + (0x01f << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV0                            (volatile uint32_t *)(0xff808000 + (0x01f << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV1                            (0xff808000 + (0x020 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV1                            (0xff808000 + (0x020 << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV1                            (volatile uint32_t *)(0xff808000 + (0x020 << 2))
+#define     AO_MF_IR_DEC_FILTE                                 (0xff808000 + (0x021 << 2))
+#define SEC_AO_MF_IR_DEC_FILTE                                 (0xff808000 + (0x021 << 2))
+#define   P_AO_MF_IR_DEC_FILTE                                 (volatile uint32_t *)(0xff808000 + (0x021 << 2))
+#define     AO_MF_IR_DEC_IRQ_CTL                               (0xff808000 + (0x022 << 2))
+#define SEC_AO_MF_IR_DEC_IRQ_CTL                               (0xff808000 + (0x022 << 2))
+#define   P_AO_MF_IR_DEC_IRQ_CTL                               (volatile uint32_t *)(0xff808000 + (0x022 << 2))
+#define     AO_MF_IR_DEC_FIFO_CTL                              (0xff808000 + (0x023 << 2))
+#define SEC_AO_MF_IR_DEC_FIFO_CTL                              (0xff808000 + (0x023 << 2))
+#define   P_AO_MF_IR_DEC_FIFO_CTL                              (volatile uint32_t *)(0xff808000 + (0x023 << 2))
+#define     AO_MF_IR_DEC_WIDTH_NEW                             (0xff808000 + (0x024 << 2))
+#define SEC_AO_MF_IR_DEC_WIDTH_NEW                             (0xff808000 + (0x024 << 2))
+#define   P_AO_MF_IR_DEC_WIDTH_NEW                             (volatile uint32_t *)(0xff808000 + (0x024 << 2))
+#define     AO_MF_IR_DEC_REPEAT_DET                            (0xff808000 + (0x025 << 2))
+#define SEC_AO_MF_IR_DEC_REPEAT_DET                            (0xff808000 + (0x025 << 2))
+#define   P_AO_MF_IR_DEC_REPEAT_DET                            (volatile uint32_t *)(0xff808000 + (0x025 << 2))
+#define     AO_IR_DEC_DEMOD_CNTL0                              (0xff808000 + (0x030 << 2))
+#define SEC_AO_IR_DEC_DEMOD_CNTL0                              (0xff808000 + (0x030 << 2))
+#define   P_AO_IR_DEC_DEMOD_CNTL0                              (volatile uint32_t *)(0xff808000 + (0x030 << 2))
+#define     AO_IR_DEC_DEMOD_CNTL1                              (0xff808000 + (0x031 << 2))
+#define SEC_AO_IR_DEC_DEMOD_CNTL1                              (0xff808000 + (0x031 << 2))
+#define   P_AO_IR_DEC_DEMOD_CNTL1                              (volatile uint32_t *)(0xff808000 + (0x031 << 2))
+#define     AO_IR_DEC_DEMOD_IIR_THD                            (0xff808000 + (0x032 << 2))
+#define SEC_AO_IR_DEC_DEMOD_IIR_THD                            (0xff808000 + (0x032 << 2))
+#define   P_AO_IR_DEC_DEMOD_IIR_THD                            (volatile uint32_t *)(0xff808000 + (0x032 << 2))
+#define     AO_IR_DEC_DEMOD_THD0                               (0xff808000 + (0x033 << 2))
+#define SEC_AO_IR_DEC_DEMOD_THD0                               (0xff808000 + (0x033 << 2))
+#define   P_AO_IR_DEC_DEMOD_THD0                               (volatile uint32_t *)(0xff808000 + (0x033 << 2))
+#define     AO_IR_DEC_DEMOD_THD1                               (0xff808000 + (0x034 << 2))
+#define SEC_AO_IR_DEC_DEMOD_THD1                               (0xff808000 + (0x034 << 2))
+#define   P_AO_IR_DEC_DEMOD_THD1                               (volatile uint32_t *)(0xff808000 + (0x034 << 2))
+#define     AO_IR_DEC_DEMOD_SUM_CNT0                           (0xff808000 + (0x035 << 2))
+#define SEC_AO_IR_DEC_DEMOD_SUM_CNT0                           (0xff808000 + (0x035 << 2))
+#define   P_AO_IR_DEC_DEMOD_SUM_CNT0                           (volatile uint32_t *)(0xff808000 + (0x035 << 2))
+#define     AO_IR_DEC_DEMOD_SUM_CNT1                           (0xff808000 + (0x036 << 2))
+#define SEC_AO_IR_DEC_DEMOD_SUM_CNT1                           (0xff808000 + (0x036 << 2))
+#define   P_AO_IR_DEC_DEMOD_SUM_CNT1                           (volatile uint32_t *)(0xff808000 + (0x036 << 2))
+#define     AO_IR_DEC_DEMOD_CNT0                               (0xff808000 + (0x037 << 2))
+#define SEC_AO_IR_DEC_DEMOD_CNT0                               (0xff808000 + (0x037 << 2))
+#define   P_AO_IR_DEC_DEMOD_CNT0                               (volatile uint32_t *)(0xff808000 + (0x037 << 2))
+#define     AO_IR_DEC_DEMOD_CNT1                               (0xff808000 + (0x038 << 2))
+#define SEC_AO_IR_DEC_DEMOD_CNT1                               (0xff808000 + (0x038 << 2))
+#define   P_AO_IR_DEC_DEMOD_CNT1                               (volatile uint32_t *)(0xff808000 + (0x038 << 2))
+// ---------------------------
+// SAR ADC
+// ---------------------------
+//#define AO_SAR_ADC_REG_BASE 0x09
+// APB4_DECODER_NON_SECURE_BASE     32'hFF809000
+// APB4_DECODER_SECURE_BASE         32'hFF809000
+#define     AO_SAR_ADC_REG0                                    (0xff809000 + (0x000 << 2))
+#define SEC_AO_SAR_ADC_REG0                                    (0xff809000 + (0x000 << 2))
+#define   P_AO_SAR_ADC_REG0                                    (volatile uint32_t *)(0xff809000 + (0x000 << 2))
+#define     AO_SAR_ADC_CHAN_LIST                               (0xff809000 + (0x001 << 2))
+#define SEC_AO_SAR_ADC_CHAN_LIST                               (0xff809000 + (0x001 << 2))
+#define   P_AO_SAR_ADC_CHAN_LIST                               (volatile uint32_t *)(0xff809000 + (0x001 << 2))
+#define     AO_SAR_ADC_AVG_CNTL                                (0xff809000 + (0x002 << 2))
+#define SEC_AO_SAR_ADC_AVG_CNTL                                (0xff809000 + (0x002 << 2))
+#define   P_AO_SAR_ADC_AVG_CNTL                                (volatile uint32_t *)(0xff809000 + (0x002 << 2))
+#define     AO_SAR_ADC_REG3                                    (0xff809000 + (0x003 << 2))
+#define SEC_AO_SAR_ADC_REG3                                    (0xff809000 + (0x003 << 2))
+#define   P_AO_SAR_ADC_REG3                                    (volatile uint32_t *)(0xff809000 + (0x003 << 2))
+#define     AO_SAR_ADC_DELAY                                   (0xff809000 + (0x004 << 2))
+#define SEC_AO_SAR_ADC_DELAY                                   (0xff809000 + (0x004 << 2))
+#define   P_AO_SAR_ADC_DELAY                                   (volatile uint32_t *)(0xff809000 + (0x004 << 2))
+#define     AO_SAR_ADC_LAST_RD                                 (0xff809000 + (0x005 << 2))
+#define SEC_AO_SAR_ADC_LAST_RD                                 (0xff809000 + (0x005 << 2))
+#define   P_AO_SAR_ADC_LAST_RD                                 (volatile uint32_t *)(0xff809000 + (0x005 << 2))
+#define     AO_SAR_ADC_FIFO_RD                                 (0xff809000 + (0x006 << 2))
+#define SEC_AO_SAR_ADC_FIFO_RD                                 (0xff809000 + (0x006 << 2))
+#define   P_AO_SAR_ADC_FIFO_RD                                 (volatile uint32_t *)(0xff809000 + (0x006 << 2))
+#define     AO_SAR_ADC_AUX_SW                                  (0xff809000 + (0x007 << 2))
+#define SEC_AO_SAR_ADC_AUX_SW                                  (0xff809000 + (0x007 << 2))
+#define   P_AO_SAR_ADC_AUX_SW                                  (volatile uint32_t *)(0xff809000 + (0x007 << 2))
+#define     AO_SAR_ADC_CHAN_10_SW                              (0xff809000 + (0x008 << 2))
+#define SEC_AO_SAR_ADC_CHAN_10_SW                              (0xff809000 + (0x008 << 2))
+#define   P_AO_SAR_ADC_CHAN_10_SW                              (volatile uint32_t *)(0xff809000 + (0x008 << 2))
+#define     AO_SAR_ADC_DETECT_IDLE_SW                          (0xff809000 + (0x009 << 2))
+#define SEC_AO_SAR_ADC_DETECT_IDLE_SW                          (0xff809000 + (0x009 << 2))
+#define   P_AO_SAR_ADC_DETECT_IDLE_SW                          (volatile uint32_t *)(0xff809000 + (0x009 << 2))
+#define     AO_SAR_ADC_DELTA_10                                (0xff809000 + (0x00a << 2))
+#define SEC_AO_SAR_ADC_DELTA_10                                (0xff809000 + (0x00a << 2))
+#define   P_AO_SAR_ADC_DELTA_10                                (volatile uint32_t *)(0xff809000 + (0x00a << 2))
+#define     AO_SAR_ADC_REG11                                   (0xff809000 + (0x00b << 2))
+#define SEC_AO_SAR_ADC_REG11                                   (0xff809000 + (0x00b << 2))
+#define   P_AO_SAR_ADC_REG11                                   (volatile uint32_t *)(0xff809000 + (0x00b << 2))
+#define     AO_SAR_ADC_REG12                                   (0xff809000 + (0x00c << 2))
+#define SEC_AO_SAR_ADC_REG12                                   (0xff809000 + (0x00c << 2))
+#define   P_AO_SAR_ADC_REG12                                   (volatile uint32_t *)(0xff809000 + (0x00c << 2))
+#define     AO_SAR_ADC_REG13                                   (0xff809000 + (0x00d << 2))
+#define SEC_AO_SAR_ADC_REG13                                   (0xff809000 + (0x00d << 2))
+#define   P_AO_SAR_ADC_REG13                                   (volatile uint32_t *)(0xff809000 + (0x00d << 2))
+#define     AO_SAR_ADC_CHNL01                                  (0xff809000 + (0x00e << 2))
+#define SEC_AO_SAR_ADC_CHNL01                                  (0xff809000 + (0x00e << 2))
+#define   P_AO_SAR_ADC_CHNL01                                  (volatile uint32_t *)(0xff809000 + (0x00e << 2))
+#define     AO_SAR_ADC_CHNL23                                  (0xff809000 + (0x00f << 2))
+#define SEC_AO_SAR_ADC_CHNL23                                  (0xff809000 + (0x00f << 2))
+#define   P_AO_SAR_ADC_CHNL23                                  (volatile uint32_t *)(0xff809000 + (0x00f << 2))
+#define     AO_SAR_ADC_CHNL45                                  (0xff809000 + (0x010 << 2))
+#define SEC_AO_SAR_ADC_CHNL45                                  (0xff809000 + (0x010 << 2))
+#define   P_AO_SAR_ADC_CHNL45                                  (volatile uint32_t *)(0xff809000 + (0x010 << 2))
+#define     AO_SAR_ADC_CHNL67                                  (0xff809000 + (0x011 << 2))
+#define SEC_AO_SAR_ADC_CHNL67                                  (0xff809000 + (0x011 << 2))
+#define   P_AO_SAR_ADC_CHNL67                                  (volatile uint32_t *)(0xff809000 + (0x011 << 2))
+// ---------------------------
+// MAIL BOX (M3/M4)
+// ---------------------------
+//#define AO_MAILBOX_REG_BASE 0x0a
+// APB4_DECODER_NON_SECURE_BASE     32'hFF80a000
+// APB4_DECODER_SECURE_BASE         32'hFF80a000
+#define     AO_MAILBOX_SET_0                                   (0xff80a000 + (0x001 << 2))
+#define SEC_AO_MAILBOX_SET_0                                   (0xff80a000 + (0x001 << 2))
+#define   P_AO_MAILBOX_SET_0                                   (volatile uint32_t *)(0xff80a000 + (0x001 << 2))
+#define     AO_MAILBOX_STAT_0                                  (0xff80a000 + (0x002 << 2))
+#define SEC_AO_MAILBOX_STAT_0                                  (0xff80a000 + (0x002 << 2))
+#define   P_AO_MAILBOX_STAT_0                                  (volatile uint32_t *)(0xff80a000 + (0x002 << 2))
+#define     AO_MAILBOX_CLR_0                                   (0xff80a000 + (0x003 << 2))
+#define SEC_AO_MAILBOX_CLR_0                                   (0xff80a000 + (0x003 << 2))
+#define   P_AO_MAILBOX_CLR_0                                   (volatile uint32_t *)(0xff80a000 + (0x003 << 2))
+#define     AO_MAILBOX_SET_1                                   (0xff80a000 + (0x004 << 2))
+#define SEC_AO_MAILBOX_SET_1                                   (0xff80a000 + (0x004 << 2))
+#define   P_AO_MAILBOX_SET_1                                   (volatile uint32_t *)(0xff80a000 + (0x004 << 2))
+#define     AO_MAILBOX_STAT_1                                  (0xff80a000 + (0x005 << 2))
+#define SEC_AO_MAILBOX_STAT_1                                  (0xff80a000 + (0x005 << 2))
+#define   P_AO_MAILBOX_STAT_1                                  (volatile uint32_t *)(0xff80a000 + (0x005 << 2))
+#define     AO_MAILBOX_CLR_1                                   (0xff80a000 + (0x006 << 2))
+#define SEC_AO_MAILBOX_CLR_1                                   (0xff80a000 + (0x006 << 2))
+#define   P_AO_MAILBOX_CLR_1                                   (volatile uint32_t *)(0xff80a000 + (0x006 << 2))
+#define     AO_MAILBOX_SET_2                                   (0xff80a000 + (0x007 << 2))
+#define SEC_AO_MAILBOX_SET_2                                   (0xff80a000 + (0x007 << 2))
+#define   P_AO_MAILBOX_SET_2                                   (volatile uint32_t *)(0xff80a000 + (0x007 << 2))
+#define     AO_MAILBOX_STAT_2                                  (0xff80a000 + (0x008 << 2))
+#define SEC_AO_MAILBOX_STAT_2                                  (0xff80a000 + (0x008 << 2))
+#define   P_AO_MAILBOX_STAT_2                                  (volatile uint32_t *)(0xff80a000 + (0x008 << 2))
+#define     AO_MAILBOX_CLR_2                                   (0xff80a000 + (0x009 << 2))
+#define SEC_AO_MAILBOX_CLR_2                                   (0xff80a000 + (0x009 << 2))
+#define   P_AO_MAILBOX_CLR_2                                   (volatile uint32_t *)(0xff80a000 + (0x009 << 2))
+#define     AO_MAILBOX_SET_3                                   (0xff80a000 + (0x00a << 2))
+#define SEC_AO_MAILBOX_SET_3                                   (0xff80a000 + (0x00a << 2))
+#define   P_AO_MAILBOX_SET_3                                   (volatile uint32_t *)(0xff80a000 + (0x00a << 2))
+#define     AO_MAILBOX_STAT_3                                  (0xff80a000 + (0x00b << 2))
+#define SEC_AO_MAILBOX_STAT_3                                  (0xff80a000 + (0x00b << 2))
+#define   P_AO_MAILBOX_STAT_3                                  (volatile uint32_t *)(0xff80a000 + (0x00b << 2))
+#define     AO_MAILBOX_CLR_3                                   (0xff80a000 + (0x00c << 2))
+#define SEC_AO_MAILBOX_CLR_3                                   (0xff80a000 + (0x00c << 2))
+#define   P_AO_MAILBOX_CLR_3                                   (volatile uint32_t *)(0xff80a000 + (0x00c << 2))
+// ---------------------------
+// RTC (4)
+// ---------------------------
+// Moved to the secure APB3 bus
+// `define AO_RTC_ADDR0                8'hd0
+// `define AO_RTC_ADDR1                8'hd1
+// `define AO_RTC_ADDR2                8'hd2
+// `define AO_RTC_ADDR3                8'hd3
+// `define AO_RTC_ADDR4                8'hd4
+//
+// Closing file:  ./ao_rti_reg.h
+//
+
+#define P_DMA_T0   (volatile uint32_t *)0xff63e000
+#define P_DMA_T1   (volatile uint32_t *)0xff63e004
+#define P_DMA_T2   (volatile uint32_t *)0xff63e008
+#define P_DMA_T3   (volatile uint32_t *)0xff63e00c
+#define P_DMA_T4   (volatile uint32_t *)0xff63e010
+#define P_DMA_T5   (volatile uint32_t *)0xff63e014
+#define P_DMA_STS0 (volatile uint32_t *)0xff63e020
+#define P_DMA_STS1 (volatile uint32_t *)0xff63e024
+#define P_DMA_STS2 (volatile uint32_t *)0xff63e028
+#define P_DMA_STS3 (volatile uint32_t *)0xff63e02c
+#define P_DMA_STS4 (volatile uint32_t *)0xff63e030
+#define P_DMA_STS5 (volatile uint32_t *)0xff63e034
+#define P_DMA_CFG  (volatile uint32_t *)0xff63e040
+#define P_DMA_SEC  (volatile uint32_t *)0xff63e044
+
+#endif // SECURE_APB_H
+
+
diff --git a/include/amlogic/auge_sound.h b/include/amlogic/auge_sound.h
new file mode 100644
index 0000000000..2defa8018a
--- /dev/null
+++ b/include/amlogic/auge_sound.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * include/amlogic/auge_sound.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __AUGE_SOUND_H__
+#define __AUGE_SOUND_H__
+
+/* auge audio register is defined in asm/arch/secure_apb.h */
+
+int aml_audio_init(void);
+
+#endif
diff --git a/include/amlogic/blxx2bl33_param.h b/include/amlogic/blxx2bl33_param.h
new file mode 100644
index 0000000000..b2a5304e14
--- /dev/null
+++ b/include/amlogic/blxx2bl33_param.h
@@ -0,0 +1,27 @@
+#ifndef __BLXX2BL33_PARAM_H__
+#define __BLXX2BL33_PARAM_H__
+#include <common.h>
+
+/* !!! don't try to modify the Micro unless make a consistency with blxx */
+
+#define BL2E2BL33_PARAM_START	(0x0e00000)
+#define BL2E2BL33_PARAM_END	(0x1000000)
+
+#define BLXX2BL33_PARAM_DEBUG	(0)
+
+/* define the parameter type here and make sure the same with blxx */
+enum {
+	STORAGE_PARAM_TPYE = 1,
+	BL2PARMA_PARAM_TYPE = 2,
+	/* other */
+};
+
+struct param_e {
+	unsigned int type;
+	unsigned int len;	/* must be 8 bytes align */
+	unsigned char data[1];	/* user defined parameter */
+};
+
+struct param_e *param_of(int type);
+
+#endif
\ No newline at end of file
diff --git a/include/amlogic/canvas.h b/include/amlogic/canvas.h
new file mode 100644
index 0000000000..dc9ed10f02
--- /dev/null
+++ b/include/amlogic/canvas.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CANVAS_H
+#define CANVAS_H
+
+#define CANVAS_ADDR_LMASK       0x1fffffff
+#define CANVAS_WIDTH_LMASK      0x7
+#define CANVAS_WIDTH_LWID       3
+#define CANVAS_WIDTH_LBIT       29
+
+#define CANVAS_WIDTH_HMASK      0x1ff
+#define CANVAS_WIDTH_HBIT       0
+#define CANVAS_HEIGHT_MASK      0x1fff
+#define CANVAS_HEIGHT_BIT       9
+#define CANVAS_YWRAP            (1<<23)
+#define CANVAS_XWRAP            (1<<22)
+#define CANVAS_ADDR_NOWRAP      0x00
+#define CANVAS_ADDR_WRAPX       0x01
+#define CANVAS_ADDR_WRAPY       0x02
+#define CANVAS_BLKMODE_MASK     3
+#define CANVAS_BLKMODE_BIT      24
+#define CANVAS_BLKMODE_LINEAR   0x00
+#define CANVAS_BLKMODE_32X32    0x01
+#define CANVAS_BLKMODE_64X32    0x02
+
+#define CANVAS_LUT_INDEX_BIT    0
+#define CANVAS_LUT_INDEX_MASK   0x7
+#define CANVAS_LUT_WR_EN        (0x2 << 8)
+#define CANVAS_LUT_RD_EN        (0x1 << 8)
+
+typedef struct {
+	ulong addr;
+	u32 width;
+	u32 height;
+	u32 wrap;
+	u32 blkmode;
+} canvas_t;
+
+#define OSD1_CANVAS_INDEX 0x40
+#define OSD2_CANVAS_INDEX 0x43
+
+extern void canvas_init(void);
+
+extern void canvas_config(u32 index, ulong addr, u32 width,
+			  u32 height, u32 wrap, u32 blkmode);
+
+extern void canvas_read(u32 index, canvas_t *p);
+
+extern void canvas_copy(unsigned src, unsigned dst);
+
+extern void canvas_update_addr(u32 index, u32 addr);
+
+extern unsigned int canvas_get_addr(u32 index);
+
+#endif /* CANVAS_H */
diff --git a/include/amlogic/color.h b/include/amlogic/color.h
new file mode 100644
index 0000000000..9839d11999
--- /dev/null
+++ b/include/amlogic/color.h
@@ -0,0 +1,51 @@
+/*
+ * include/linux/amlogic/vout/color.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _COLOR_H_
+#define _COLOR_H_
+
+enum color_index_e {
+	COLOR_INDEX_NULL = 0,
+	COLOR_INDEX_02_PAL4 = 2,
+	COLOR_INDEX_04_PAL16 = 4,
+	COLOR_INDEX_08_PAL256 = 8,
+	COLOR_INDEX_16_655 = 9,
+	COLOR_INDEX_16_844 = 10,
+	COLOR_INDEX_16_6442 = 11 ,
+	COLOR_INDEX_16_4444_R = 12,
+	COLOR_INDEX_16_4642_R = 13,
+	COLOR_INDEX_16_1555_A = 14,
+	COLOR_INDEX_16_4444_A = 15,
+	COLOR_INDEX_16_565 = 16,
+
+	COLOR_INDEX_24_6666_A = 19,
+	COLOR_INDEX_24_6666_R = 20,
+	COLOR_INDEX_24_8565 = 21,
+	COLOR_INDEX_24_5658 = 22,
+	COLOR_INDEX_24_888_B = 23,
+	COLOR_INDEX_24_RGB = 24,
+
+	COLOR_INDEX_32_BGRA = 29,
+	COLOR_INDEX_32_ABGR = 30,
+	COLOR_INDEX_32_RGBA = 31,
+	COLOR_INDEX_32_ARGB = 32,
+
+	COLOR_INDEX_YUV_422 = 33,
+};
+
+#endif
diff --git a/include/amlogic/cpu_id.h b/include/amlogic/cpu_id.h
new file mode 100644
index 0000000000..588c131262
--- /dev/null
+++ b/include/amlogic/cpu_id.h
@@ -0,0 +1,90 @@
+/*
+ * include/amlogic/cpu_id.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#define MESON_CPU_MAJOR_ID_M6		0x16
+#define MESON_CPU_MAJOR_ID_M6TV		0x17
+#define MESON_CPU_MAJOR_ID_M6TVL	0x18
+#define MESON_CPU_MAJOR_ID_M8		0x19
+#define MESON_CPU_MAJOR_ID_MTVD		0x1A
+#define MESON_CPU_MAJOR_ID_M8B		0x1B
+#define MESON_CPU_MAJOR_ID_MG9TV	0x1C
+#define MESON_CPU_MAJOR_ID_M8M2		0x1D
+#define MESON_CPU_MAJOR_ID_GXBB		0x1F
+#define MESON_CPU_MAJOR_ID_GXTVBB	0x20
+#define MESON_CPU_MAJOR_ID_GXL		0x21
+#define MESON_CPU_MAJOR_ID_GXM		0x22
+#define MESON_CPU_MAJOR_ID_TXL		0x23
+#define MESON_CPU_MAJOR_ID_TXLX		0x24
+#define MESON_CPU_MAJOR_ID_AXG		0x25
+#define MESON_CPU_MAJOR_ID_GXLX		0x26
+#define MESON_CPU_MAJOR_ID_TXHD		0x27
+#define MESON_CPU_MAJOR_ID_G12A		0x28
+#define MESON_CPU_MAJOR_ID_G12B		0x29
+#define MESON_CPU_MAJOR_ID_SM1		0x2B
+#define MESON_CPU_MAJOR_ID_A1		0x2C
+#define MESON_CPU_MAJOR_ID_TL1		0x2E
+#define MESON_CPU_MAJOR_ID_TM2		0x2F
+#define MESON_CPU_MAJOR_ID_C1		0x30
+#define MESON_CPU_MAJOR_ID_SC2		0x32
+#define MESON_CPU_MAJOR_ID_C2		0x33
+
+
+#define MESON_CPU_PACKAGE_ID_905D	0X00
+#define MESON_CPU_PACKAGE_ID_905M	0x20
+#define MESON_CPU_PACKAGE_ID_905X	0X80
+#define MESON_CPU_PACKAGE_ID_905L	0XC0
+#define MESON_CPU_PACKAGE_ID_905M2	0XE0
+
+#define MESON_CPU_PACKAGE_ID_T962X	0x10
+#define MESON_CPU_PACKAGE_ID_T962E	0x20
+
+#define MESON_CPU_PACKAGE_ID_A113X	0x37
+#define MESON_CPU_PACKAGE_ID_A113D	0xD0
+
+#define MESON_CPU_CHIP_REVISION_A	0xA
+#define MESON_CPU_CHIP_REVISION_B	0xB
+#define MESON_CPU_CHIP_REVISION_C	0xC
+#define MESON_CPU_CHIP_REVISION_D	0xD
+
+typedef struct cpu_id {
+	unsigned int family_id:8;
+	unsigned int package_id:8;
+	unsigned int chip_rev:8; //RevA/RevB etc.
+	unsigned int reserve:4;
+	unsigned int layout_ver:4;
+} cpu_id_t;
+
+typedef struct chip_id {
+	unsigned int version;
+	unsigned char chipid[16];
+} chip_id_t;
+
+cpu_id_t get_cpu_id(void);
+
+extern chip_id_t aml_chip_id;
+int get_chip_id(unsigned char *buff, unsigned int size);
+
+/**
+ * TODO: Remove this API after move static system information to RO
+ * register or SRAM
+ *
+ * Should *NOT* call this API directly, always use get_chip_id()
+ */
+int __get_chip_id(unsigned char *buff, unsigned int size);
diff --git a/include/amlogic/enc_clk_config.h b/include/amlogic/enc_clk_config.h
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/include/amlogic/enc_clk_config.h
@@ -0,0 +1 @@
+
diff --git a/include/amlogic/fb.h b/include/amlogic/fb.h
new file mode 100644
index 0000000000..d19e96928e
--- /dev/null
+++ b/include/amlogic/fb.h
@@ -0,0 +1,399 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#ifdef __KERNEL__
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor_user)
+#else
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+#endif
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	__u32 smem_len;			/* Length of frame buffer mem */
+	__u32 type;			/* see FB_TYPE_*		*/
+	__u32 type_aux;			/* Interleave for interleaved Planes */
+	__u32 visual;			/* see FB_VISUAL_*		*/
+	__u16 xpanstep;			/* zero if no hardware panning  */
+	__u16 ypanstep;			/* zero if no hardware panning  */
+	__u16 ywrapstep;		/* zero if no hardware ywrap    */
+	__u32 line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
+	__u32 accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	__u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the pallette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	__u32 offset;			/* beginning of bitfield	*/
+	__u32 length;			/* length of bitfield		*/
+	__u32 msb_right;		/* != 0 : Most significant bit is */
+					/* right */
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	__u32 xres;			/* visible resolution		*/
+	__u32 yres;
+	__u32 xres_virtual;		/* virtual resolution		*/
+	__u32 yres_virtual;
+	__u32 xoffset;			/* offset from virtual to visible */
+	__u32 yoffset;			/* resolution			*/
+
+	__u32 bits_per_pixel;		/* guess what			*/
+	__u32 grayscale;		/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/
+
+	__u32 nonstd;			/* != 0 Non standard pixel format */
+
+	__u32 activate;			/* see FB_ACTIVATE_*		*/
+
+	__u32 height;			/* height of picture in mm    */
+	__u32 width;			/* width of picture in mm     */
+
+	__u32 accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
+	__u32 left_margin;		/* time from sync to picture	*/
+	__u32 right_margin;		/* time from picture to sync	*/
+	__u32 upper_margin;		/* time from sync to picture	*/
+	__u32 lower_margin;
+	__u32 hsync_len;		/* length of horizontal sync	*/
+	__u32 vsync_len;		/* length of vertical sync	*/
+	__u32 sync;			/* see FB_SYNC_*		*/
+	__u32 vmode;			/* see FB_VMODE_*		*/
+	__u32 rotate;			/* angle we rotate counter clockwise */
+	__u32 reserved[5];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	__u32 start;			/* First entry	*/
+	__u32 len;			/* Number of entries */
+	__u16 *red;			/* Red values	*/
+	__u16 *green;
+	__u16 *blue;
+	__u16 *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	__u32 console;
+	__u32 framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+#define CANVAS_ALIGNED(x)  (((x) + 63) & ~63)
+
+enum osd_index_e {
+	OSD1 = 0,
+	OSD2,
+	VIU2_OSD1
+};
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	__u32 flags;			/* FB_VBLANK flags */
+	__u32 count;			/* counter of retraces since boot */
+	__u32 vcount;			/* current scanline position */
+	__u32 hcount;			/* current scandot position */
+	__u32 reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	__u32 dx;
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 sx;
+	__u32 sy;
+};
+
+struct fb_fillrect {
+	__u32 dx;	/* screen-relative */
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 color;
+	__u32 rop;
+};
+
+struct fb_image {
+	__u32 dx;		/* Where to place image */
+	__u32 dy;
+	__u32 width;		/* Size of image */
+	__u32 height;
+	__u32 fg_color;		/* Only used when a mono bitmap */
+	__u32 bg_color;
+	__u8  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	__u16 x, y;
+};
+
+struct fb_cursor {
+	__u16 set;		/* what to set */
+	__u16 enable;		/* cursor on/off */
+	__u16 rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+#ifdef CONFIG_FB_BACKLIGHT
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+#endif
+
+#endif /* _LINUX_FB_H */
diff --git a/include/amlogic/instaboot.h b/include/amlogic/instaboot.h
new file mode 100644
index 0000000000..cfcae9ef4a
--- /dev/null
+++ b/include/amlogic/instaboot.h
@@ -0,0 +1,24 @@
+#ifndef __INSTABOOT_H_
+#define __INSTABOOT_H_
+
+#define __NEW_UTS_LEN 64
+
+struct new_utsname {
+	char sysname[__NEW_UTS_LEN + 1];
+	char nodename[__NEW_UTS_LEN + 1];
+	char release[__NEW_UTS_LEN + 1];
+	char version[__NEW_UTS_LEN + 1];
+	char machine[__NEW_UTS_LEN + 1];
+	char domainname[__NEW_UTS_LEN + 1];
+};
+
+struct instaboot_info {
+	struct new_utsname uts;
+	unsigned int version_code;
+};
+#define INSTABOOT_SIG	"INSTABOOT"
+
+extern int get_instaboot_header(struct instaboot_info* ib_info);
+extern int fdt_instaboot(void *fdt);
+
+#endif /* __INSTABOOT_H_ */
diff --git a/include/amlogic/jtag.h b/include/amlogic/jtag.h
new file mode 100644
index 0000000000..c85c513721
--- /dev/null
+++ b/include/amlogic/jtag.h
@@ -0,0 +1,61 @@
+#ifndef __MESON_JTAG_H__
+#define __MESON_JTAG_H__
+
+#define INVALID_ID		-1
+
+/* ioctl command */
+#define JTAG_CLRPINMUX		0
+#define JTAG_SETPINMUX		1
+#define JTAG_EANBLE		2
+#define JTAG_DISABLE		3
+
+/* jtag type */
+#define JTAG_A			0
+#define JTAG_B			1
+#define SWD_A			2
+
+/* core type */
+#define	AP			1 /* a35 a53 a72 ... */
+#define SCP			2 /* m3 */
+#define SP			3 /* m4 */
+#define DSPA			4 /* dsp-a */
+#define	DSPB			5 /* dsp-b */
+#define	DIF			6 /* dif */
+#define	AOCPU			7 /* aocpu */
+#define	AUCPU			8 /* aucpu */
+
+/*
+ * bitmap for jtag select ID:
+ *
+ *	|---|---|---|---|---|---|---|------|------|
+ *	| 9 | 8 | 6 | 5 | 4 | 3 | 2 |   1  |   0  |
+ *	|---|---|---|---|---|---|---|------|------|
+ *	|   core type   | jtag type |cluster type |
+ *	|---------------|-----------|-------------|
+ */
+#define CORE_TYPE_SHIFT	5
+#define JTAG_TYPE_SHIFT	2
+#define CLUSTER_TYPE_SHIFT	0
+
+#define CORE_TYPE_MASK	0xf
+#define JTAG_TYPE_MASK	0x7
+#define CLUSTER_TYPE_MASK	0x3
+
+#define JTAG_SELECT_ID(core_type, jtag_type, cluster_type) \
+	(((core_type & CORE_TYPE_MASK) << CORE_TYPE_SHIFT) |\
+	((jtag_type & JTAG_TYPE_MASK) << JTAG_TYPE_SHIFT) |\
+	((cluster_type & CLUSTER_TYPE_MASK) << CLUSTER_TYPE_SHIFT))
+
+#define CLUSTER_TYPE_UPDATE(id, cluster_type) \
+	((id & (~(CLUSTER_TYPE_MASK))) | cluster_type)
+
+#define CORE_TYPE_GET(id) \
+	((id >> CORE_TYPE_SHIFT) & CORE_TYPE_MASK)
+
+#define JTAG_TYPE_GET(id) \
+	((id >> JTAG_TYPE_SHIFT) & JTAG_TYPE_MASK)
+
+#define CLUSTER_TYPE_GET(id) \
+	((id >> CLUSTER_TYPE_SHIFT) & CLUSTER_TYPE_MASK)
+
+#endif /*_MESON_JTAG_H_*/
diff --git a/include/amlogic/keyunify.h b/include/amlogic/keyunify.h
new file mode 100644
index 0000000000..c89865f574
--- /dev/null
+++ b/include/amlogic/keyunify.h
@@ -0,0 +1,56 @@
+/*
+ * \file        keymanage.h
+ * \brief       API from drivers/keymange
+ *
+ * \version     1.0.0
+ * \date        15/07/7
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2015 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __KEYUNIFY_H__
+#define __KEYUNIFY_H__
+
+//APIs of key_unify*: unify interfaces for nandkeys/emmckeys/efuse keys
+
+int key_unify_init(const char* seednum, const char* dtbaddr);
+
+int key_unify_uninit(void);
+
+//keyType: user type to define how to parse/check the key value before burn to target
+int key_unify_write(const char* keyname, const void* keydata, const unsigned datalen);
+
+int key_unify_read(const char* keyname, void* keydata, const unsigned bufLen);
+
+int key_unify_query_size(const char* keyname, ssize_t* keysize);
+
+int key_unify_query_exist(const char* keyname, int* exist);
+
+int key_unify_query_secure(const char* keyname, int* isSecure);
+
+int key_unify_query_canOverWrite(const char* keyname, int* canOverWrite);
+
+//Does the key configured in dts
+int key_unify_query_key_has_configure(const char* keyname);
+
+//Another APIs with APP concers, like special flower hdcp2
+//These APIs are based on key_unify_*
+//
+int key_manage_init(const char* seednum, const char* dtbaddr);
+int key_manage_exit(void);
+
+int key_manage_write(const char* keyname, const void* keydata, const unsigned datalen);
+
+int key_manage_read(const char* keyname, void* keydata, const unsigned bufLen);
+
+int key_manage_query_size(const char* keyname, ssize_t* keysize);
+
+int key_manage_query_exist(const char* keyname, int* exist);
+
+int key_manage_query_secure(const char* keyname, int* isSecure);
+
+int key_manage_query_canOverWrite(const char* keyname, int* canOverWrite);
+
+#endif// #ifndef __KEYUNIFY_H__
+
diff --git a/include/amlogic/media/vout/aml_cvbs.h b/include/amlogic/media/vout/aml_cvbs.h
new file mode 100644
index 0000000000..e4d0687d9b
--- /dev/null
+++ b/include/amlogic/media/vout/aml_cvbs.h
@@ -0,0 +1,13 @@
+#ifndef __INC_AML_CVBS_H__
+#define __INC_AML_CVBS_H__
+
+void cvbs_init(void);
+void cvbs_show_valid_vmode(void);
+int cvbs_outputmode_check(char *vmode_name, unsigned int frac);
+int cvbs_set_vmode(char* vmode_name);
+int cvbs_set_bist(char* bist_mode);
+int cvbs_set_vdac(int status);
+int cvbs_reg_debug(int argc, char* const argv[]);
+
+#endif
+
diff --git a/include/amlogic/media/vout/aml_vinfo.h b/include/amlogic/media/vout/aml_vinfo.h
new file mode 100644
index 0000000000..7a453b26d6
--- /dev/null
+++ b/include/amlogic/media/vout/aml_vinfo.h
@@ -0,0 +1,148 @@
+#ifndef __AML_VINFO_H_
+#define __AML_VINFO_H_
+
+struct vinfo_s {
+	ushort width;  /* Number of columns (i.e. 160) */
+	ushort height; /* Number of rows (i.e. 100) */
+	ushort field_height; /* for interlace */
+	u_char vl_bpix; /* Bits per pixel, 0 = 1 */
+
+	void *vd_base; /* Start of framebuffer memory */
+
+	void *vd_console_address; /* Start of console buffer */
+	short console_col;
+	short console_row;
+
+	int vd_color_fg;
+	int vd_color_bg;
+
+	ushort *cmap; /* Pointer to the colormap */
+	void *priv; /* Pointer to driver-specific data */
+};
+
+
+/************************************************************************/
+/* ** BITMAP DISPLAY SUPPORT						*/
+/************************************************************************/
+#if defined(CONFIG_CMD_BMP) || defined(CONFIG_SPLASH_SCREEN)
+# include <bmp_layout.h>
+# include <asm/byteorder.h>
+#endif
+
+/*
+ *  Information about displays we are using. This is for configuring
+ *  the LCD controller and memory allocation. Someone has to know what
+ *  is connected, as we can't autodetect anything.
+ */
+#define CONFIG_SYS_HIGH	0	/* Pins are active high			*/
+#define CONFIG_SYS_LOW		1	/* Pins are active low			*/
+
+#define LCD_COLOR2	2
+#define LCD_COLOR4	4
+#define LCD_COLOR8	8
+#define LCD_COLOR16	16
+#define LCD_COLOR24	24
+#define LCD_COLOR32	32
+
+
+/*----------------------------------------------------------------------*/
+#if defined(CONFIG_LCD_INFO_BELOW_LOGO)
+# define LCD_INFO_X		0
+# define LCD_INFO_Y		(BMP_LOGO_HEIGHT + VIDEO_FONT_HEIGHT)
+#elif defined(CONFIG_LCD_LOGO)
+# define LCD_INFO_X		(BMP_LOGO_WIDTH + 4 * VIDEO_FONT_WIDTH)
+# define LCD_INFO_Y		(VIDEO_FONT_HEIGHT)
+#else
+# define LCD_INFO_X		(VIDEO_FONT_WIDTH)
+# define LCD_INFO_Y		(VIDEO_FONT_HEIGHT)
+#endif
+
+/* Calculate nr. of bits per pixel  and nr. of colors */
+#define NBITS(bit_code)		(bit_code)
+#define NCOLORS(bit_code)	(1 << NBITS(bit_code))
+
+/************************************************************************/
+/* ** CONSOLE CONSTANTS							*/
+/************************************************************************/
+#if LCD_BPP == LCD_MONOCHROME
+
+/*
+ * Simple black/white definitions
+ */
+# define CONSOLE_COLOR_BLACK	0
+# define CONSOLE_COLOR_WHITE	1	/* Must remain last / highest	*/
+
+#elif LCD_BPP == LCD_COLOR8
+
+/*
+ * 8bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	0
+# define CONSOLE_COLOR_RED	1
+# define CONSOLE_COLOR_GREEN	2
+# define CONSOLE_COLOR_YELLOW	3
+# define CONSOLE_COLOR_BLUE	4
+# define CONSOLE_COLOR_MAGENTA	5
+# define CONSOLE_COLOR_CYAN	6
+# define CONSOLE_COLOR_GREY	14
+# define CONSOLE_COLOR_WHITE	15	/* Must remain last / highest	*/
+
+#elif LCD_BPP == LCD_COLOR24
+/*
+ * 24bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	 0
+# define CONSOLE_COLOR_RED 	0x0000ff
+# define CONSOLE_COLOR_GREEN	0x00ff00
+# define CONSOLE_COLOR_YELLOW	0x00ffff
+# define CONSOLE_COLOR_BLUE	0xff0000
+# define CONSOLE_COLOR_MAGENTA	0xff00ff
+# define CONSOLE_COLOR_CYAN	0xffff00
+# define CONSOLE_COLOR_GREY	0x808080
+# define CONSOLE_COLOR_WHITE	0xffffff	/* Must remain last / highest	*/
+
+#else
+
+/*
+ * 16bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	0x0000
+# define CONSOLE_COLOR_RED 		0xf800
+# define CONSOLE_COLOR_GREEN	0x07e0
+# define CONSOLE_COLOR_YELLOW	0xffe0
+# define CONSOLE_COLOR_BLUE		0x001f
+# define CONSOLE_COLOR_MAGENTA	0xf81f
+# define CONSOLE_COLOR_CYAN		0x07ff
+# define CONSOLE_COLOR_WHITE	0xffff	/* Must remain last / highest	*/
+
+#endif /* color definitions */
+
+/************************************************************************/
+#ifndef PAGE_SIZE
+# define PAGE_SIZE	4096
+#endif
+
+/************************************************************************/
+/* ** CONSOLE DEFINITIONS & FUNCTIONS					*/
+/************************************************************************/
+#if defined(CONFIG_LCD_LOGO) && !defined(CONFIG_LCD_INFO_BELOW_LOGO)
+# define CONSOLE_ROWS		((info->vl_row-BMP_LOGO_HEIGHT) \
+					/ VIDEO_FONT_HEIGHT)
+#else
+# define CONSOLE_ROWS		(info->vl_row / VIDEO_FONT_HEIGHT)
+#endif
+
+#define CONSOLE_COLS		(panel_info.vl_col / VIDEO_FONT_WIDTH)
+#define CONSOLE_ROW_SIZE	(VIDEO_FONT_HEIGHT * lcd_line_length)
+#define CONSOLE_ROW_FIRST	(info->vd_console_address)
+#define CONSOLE_ROW_SECOND	(info->vd_console_address + CONSOLE_ROW_SIZE)
+#define CONSOLE_ROW_LAST	(info->vd_console_address + CONSOLE_SIZE \
+					- CONSOLE_ROW_SIZE)
+#define CONSOLE_SIZE		(CONSOLE_ROW_SIZE * CONSOLE_ROWS)
+#define CONSOLE_SCROLL_SIZE	(CONSOLE_SIZE - CONSOLE_ROW_SIZE)
+
+# define COLOR_MASK(c)		(c)
+
+/************************************************************************/
+
+#endif
diff --git a/include/amlogic/media/vout/aml_vmode.h b/include/amlogic/media/vout/aml_vmode.h
new file mode 100644
index 0000000000..738bcd73b2
--- /dev/null
+++ b/include/amlogic/media/vout/aml_vmode.h
@@ -0,0 +1,98 @@
+
+#ifndef __AML_VMODE_H_
+#define __AML_VMODE_H_
+
+typedef enum vmode_e {
+	VMODE_480I = 0,
+	VMODE_480I_RPT,
+	VMODE_480CVBS,
+	VMODE_480P,
+	VMODE_480P_RPT,
+	VMODE_480P_120HZ,
+	VMODE_576I,
+	VMODE_576I_RPT,
+	VMODE_576CVBS,
+	VMODE_576P,
+	VMODE_576P_RPT,
+	VMODE_576P_100HZ,
+	VMODE_720P,
+	VMODE_768P,
+	VMODE_1080I,
+	VMODE_1080P,
+	VMODE_720P_50HZ,
+	VMODE_720P_100HZ,
+	VMODE_720P_120HZ,
+	VMODE_1080I_50HZ,
+	VMODE_1080I_100HZ,
+	VMODE_1080I_120HZ,
+	VMODE_1080P_30HZ,
+	VMODE_1080P_50HZ,
+	VMODE_1080P_25HZ,
+	VMODE_1080P_24HZ,
+	VMODE_1080P_100HZ,
+	VMODE_1080P_120HZ,
+	VMODE_4K2K_30HZ,
+	VMODE_4K2K_25HZ,
+	VMODE_4K2K_24HZ,
+	VMODE_4K2K_SMPTE,
+	VMODE_4K2K_SMPTE_25HZ,
+	VMODE_4K2K_SMPTE_30HZ,
+	VMODE_4K2K_SMPTE_50HZ,
+	VMODE_4K2K_SMPTE_60HZ,
+	VMODE_4K2K_SMPTE_50HZ_Y420,
+	VMODE_4K2K_SMPTE_60HZ_Y420,
+	VMODE_4K2K_FAKE_5G,
+	VMODE_4K2K_60HZ,
+	VMODE_4K2K_60HZ_Y420,
+	VMODE_4K2K_50HZ,
+	VMODE_4K2K_50HZ_Y420,
+	VMODE_4K2K_5G,
+	VMODE_4K1K_120HZ,
+	VMODE_4K1K_120HZ_Y420,
+	VMODE_4K1K_100HZ,
+	VMODE_4K1K_100HZ_Y420,
+	VMODE_4K05K_240HZ,
+	VMODE_4K05K_240HZ_Y420,
+	VMODE_4K05K_200HZ,
+	VMODE_4K05K_200HZ_Y420,
+	VMODE_640x480p60hz,
+	VMODE_800x480p60hz,
+	VMODE_800x600p60hz,
+	VMODE_852x480p60hz,
+	VMODE_854x480p60hz,
+	VMODE_1024x600p60hz,
+	VMODE_1024x768p60hz,
+	VMODE_1152x864p75hz,
+	VMODE_1280x600p60hz,
+	VMODE_1280x768p60hz,
+	VMODE_1280x800p60hz,
+	VMODE_1280x960p60hz,
+	VMODE_1280x1024p60hz,
+	VMODE_1360x768p60hz,
+	VMODE_1366x768p60hz,
+	VMODE_1400x1050p60hz,
+	VMODE_1440x900p60hz,
+	VMODE_1440x2560p60hz,
+	VMODE_1440x2560p70hz,
+	VMODE_1600x900p60hz,
+	VMODE_1600x1200p60hz,
+	VMODE_1680x1050p60hz,
+	VMODE_1920x1200p60hz,
+	VMODE_2160x1200p90hz,
+	VMODE_2560x1080p60hz,
+	VMODE_2560x1440p60hz,
+	VMODE_2560x1600p60hz,
+	VMODE_3440x1440p60hz,
+	VMODE_VGA,
+	VMODE_SVGA,
+	VMODE_XGA,
+	VMODE_SXGA,
+	VMODE_WSXGA,
+	VMODE_FHDVGA,
+	VMODE_LCD,
+	VMODE_MAX,
+	VMODE_INIT_NULL,
+	VMODE_MASK = 0xFF,
+} vmode_t;
+
+#endif
diff --git a/include/amlogic/media/vout/aml_vout.h b/include/amlogic/media/vout/aml_vout.h
new file mode 100644
index 0000000000..53448bfc1e
--- /dev/null
+++ b/include/amlogic/media/vout/aml_vout.h
@@ -0,0 +1,25 @@
+#ifndef __AML_VOUT_H_
+#define __AML_VOUT_H_
+
+#include <amlogic/media/vout/aml_vinfo.h>
+
+#define VOUT_VIU1_SEL    1
+#define VOUT_VIU2_SEL    2
+
+enum viu_mux_e {
+	VIU_MUX_ENCL = 0,
+	VIU_MUX_ENCI,
+	VIU_MUX_ENCP,
+	VIU_MUX_MAX,
+};
+
+void vout_init(void);
+void vout_vinfo_dump(void);
+int vout_get_current_vmode(void);
+int vout_get_current_axis(int *axis);
+void vout_set_current_vmode(int mode);
+struct vinfo_s *vout_get_current_vinfo(void);
+void vout_viu_mux(int viu_sel, int venc_sel);
+extern unsigned long get_fb_addr(void);
+#endif
+
diff --git a/include/amlogic/media/vout/hdmitx/hdmi_common.h b/include/amlogic/media/vout/hdmitx/hdmi_common.h
new file mode 100644
index 0000000000..66fdedd1d6
--- /dev/null
+++ b/include/amlogic/media/vout/hdmitx/hdmi_common.h
@@ -0,0 +1,655 @@
+#ifndef __HDMI_COMMON_H__
+#define __HDMI_COMMON_H__
+
+/* Little-Endian format */
+enum scdc_addr {
+	SINK_VER = 0x01,
+	SOURCE_VER, /* RW */
+	UPDATE_0 = 0x10, /* RW */
+	UPDATE_1, /* RW */
+	TMDS_CFG = 0x20, /* RW */
+	SCRAMBLER_ST,
+	CONFIG_0 = 0x30, /* RW */
+	STATUS_FLAGS_0 = 0x40,
+	STATUS_FLAGS_1,
+	ERR_DET_0_L = 0x50,
+	ERR_DET_0_H,
+	ERR_DET_1_L,
+	ERR_DET_1_H,
+	ERR_DET_2_L,
+	ERR_DET_2_H,
+	ERR_DET_CHKSUM,
+	TEST_CONFIG_0 = 0xC0, /* RW */
+	MANUFACT_IEEE_OUI_2 = 0xD0,
+	MANUFACT_IEEE_OUI_1,
+	MANUFACT_IEEE_OUI_0,
+	DEVICE_ID = 0xD3, /* 0xD3 ~ 0xDD */
+	/* RW   0xDE ~ 0xFF */
+	MANUFACT_SPECIFIC = 0xDE,
+};
+
+#define HDMITX_VIC420_OFFSET	0x100
+#define HDMITX_VESA_OFFSET	0x300
+
+/* HDMI VIC definitions */
+enum hdmi_vic {
+	/* Refer to CEA 861-D */
+	HDMI_unkown = 0,
+	HDMI_640x480p60_4x3 = 1,
+	HDMI_720x480p60_4x3 = 2,
+	HDMI_720x480p60_16x9 = 3,
+	HDMI_1280x720p60_16x9 = 4,
+	HDMI_1920x1080i60_16x9 = 5,
+	HDMI_720x480i60_4x3 = 6,
+	HDMI_720x480i60_16x9 = 7,
+	HDMI_720x240p60_4x3 = 8,
+	HDMI_720x240p60_16x9 = 9,
+	HDMI_2880x480i60_4x3 = 10,
+	HDMI_2880x480i60_16x9 = 11,
+	HDMI_2880x240p60_4x3 = 12,
+	HDMI_2880x240p60_16x9 = 13,
+	HDMI_1440x480p60_4x3 = 14,
+	HDMI_1440x480p60_16x9 = 15,
+	HDMI_1920x1080p60_16x9 = 16,
+	HDMI_720x576p50_4x3 = 17,
+	HDMI_720x576p50_16x9 = 18,
+	HDMI_1280x720p50_16x9 = 19,
+	HDMI_1920x1080i50_16x9 = 20,
+	HDMI_720x576i50_4x3 = 21,
+	HDMI_720x576i50_16x9 = 22,
+	HDMI_720x288p_4x3 = 23,
+	HDMI_720x288p_16x9 = 24,
+	HDMI_2880x576i50_4x3 = 25,
+	HDMI_2880x576i50_16x9 = 26,
+	HDMI_2880x288p50_4x3 = 27,
+	HDMI_2880x288p50_16x9 = 28,
+	HDMI_1440x576p_4x3 = 29,
+	HDMI_1440x576p_16x9 = 30,
+	HDMI_1920x1080p50_16x9 = 31,
+	HDMI_1920x1080p24_16x9 = 32,
+	HDMI_1920x1080p25_16x9 = 33,
+	HDMI_1920x1080p30_16x9 = 34,
+	HDMI_2880x480p60_4x3 = 35,
+	HDMI_2880x480p60_16x9 = 36,
+	HDMI_2880x576p50_4x3 = 37,
+	HDMI_2880x576p50_16x9 = 38,
+	HDMI_1920x1080i_t1250_50_16x9 = 39,
+	HDMI_1920x1080i100_16x9 = 40,
+	HDMI_1280x720p100_16x9 = 41,
+	HDMI_720x576p100_4x3 = 42,
+	HDMI_720x576p100_16x9 = 43,
+	HDMI_720x576i100_4x3 = 44,
+	HDMI_720x576i100_16x9 = 45,
+	HDMI_1920x1080i120_16x9 = 46,
+	HDMI_1280x720p120_16x9 = 47,
+	HDMI_720x480p120_4x3 = 48,
+	HDMI_720x480p120_16x9 = 49,
+	HDMI_720x480i120_4x3 = 50,
+	HDMI_720x480i120_16x9 = 51,
+	HDMI_720x576p200_4x3 = 52,
+	HDMI_720x576p200_16x9 = 53,
+	HDMI_720x576i200_4x3 = 54,
+	HDMI_720x576i200_16x9 = 55,
+	HDMI_720x480p240_4x3 = 56,
+	HDMI_720x480p240_16x9 = 57,
+	HDMI_720x480i240_4x3 = 58,
+	HDMI_720x480i240_16x9 = 59,
+	/* Refet to CEA 861-F */
+	HDMI_1280x720p24_16x9 = 60,
+	HDMI_1280x720p25_16x9 = 61,
+	HDMI_1280x720p30_16x9 = 62,
+	HDMI_1920x1080p120_16x9 = 63,
+	HDMI_1920x1080p100_16x9 = 64,
+	HDMI_1280x720p24_64x27 = 65,
+	HDMI_1280x720p25_64x27 = 66,
+	HDMI_1280x720p30_64x27 = 67,
+	HDMI_1280x720p50_64x27 = 68,
+	HDMI_1280x720p60_64x27 = 69,
+	HDMI_1280x720p100_64x27 = 70,
+	HDMI_1280x720p120_64x27 = 71,
+	HDMI_1920x1080p24_64x27 = 72,
+	HDMI_1920x1080p25_64x27 = 73,
+	HDMI_1920x1080p30_64x27 = 74,
+	HDMI_1920x1080p50_64x27 = 75,
+	HDMI_1920x1080p60_64x27 = 76,
+	HDMI_1920x1080p100_64x27 = 77,
+	HDMI_1920x1080p120_64x27 = 78,
+	HDMI_1680x720p24_64x27 = 79,
+	HDMI_1680x720p25_64x27 = 80,
+	HDMI_1680x720p30_64x27 = 81,
+	HDMI_1680x720p50_64x27 = 82,
+	HDMI_1680x720p60_64x27 = 83,
+	HDMI_1680x720p100_64x27 = 84,
+	HDMI_1680x720p120_64x27 = 85,
+	HDMI_2560x1080p24_64x27 = 86,
+	HDMI_2560x1080p25_64x27 = 87,
+	HDMI_2560x1080p30_64x27 = 88,
+	HDMI_2560x1080p50_64x27 = 89,
+	HDMI_2560x1080p60_64x27 = 90,
+	HDMI_2560x1080p100_64x27 = 91,
+	HDMI_2560x1080p120_64x27 = 92,
+	HDMI_3840x2160p24_16x9 = 93,
+	HDMI_3840x2160p25_16x9 = 94,
+	HDMI_3840x2160p30_16x9 = 95,
+	HDMI_3840x2160p50_16x9 = 96,
+	HDMI_3840x2160p60_16x9 = 97,
+	HDMI_4096x2160p24_256x135 = 98,
+	HDMI_4096x2160p25_256x135 = 99,
+	HDMI_4096x2160p30_256x135 = 100,
+	HDMI_4096x2160p50_256x135 = 101,
+	HDMI_4096x2160p60_256x135 = 102,
+	HDMI_3840x2160p24_64x27 = 103,
+	HDMI_3840x2160p25_64x27 = 104,
+	HDMI_3840x2160p30_64x27 = 105,
+	HDMI_3840x2160p50_64x27 = 106,
+	HDMI_3840x2160p60_64x27 = 107,
+	HDMI_RESERVED = 108,
+	/*
+	the following vic is for those y420 mode
+	they are all beyond OFFSET_HDMITX_VIC420(0x1000)
+	and they has same vic with normal vic in the lower bytes.
+	*/
+	HDMI_VIC_Y420 =	HDMITX_VIC420_OFFSET,
+	HDMI_3840x2160p50_16x9_Y420 =
+		HDMITX_VIC420_OFFSET + HDMI_3840x2160p50_16x9,
+	HDMI_3840x2160p60_16x9_Y420 =
+		HDMITX_VIC420_OFFSET + HDMI_3840x2160p60_16x9,
+	HDMI_4096x2160p50_256x135_Y420 =
+		HDMITX_VIC420_OFFSET + HDMI_4096x2160p50_256x135,
+	HDMI_4096x2160p60_256x135_Y420 =
+		HDMITX_VIC420_OFFSET + HDMI_4096x2160p60_256x135,
+	HDMI_3840x2160p50_64x27_Y420 =
+		HDMITX_VIC420_OFFSET + HDMI_3840x2160p50_64x27,
+	HDMI_3840x2160p60_64x27_Y420 =
+		HDMITX_VIC420_OFFSET + HDMI_3840x2160p60_64x27,
+	HDMIV_640x480p60hz = HDMITX_VESA_OFFSET,
+	HDMIV_800x480p60hz,
+	HDMIV_800x600p60hz,
+	HDMIV_852x480p60hz,
+	HDMIV_854x480p60hz,
+	HDMIV_1024x600p60hz,
+	HDMIV_1024x768p60hz,
+	HDMIV_1152x864p75hz,
+	HDMIV_1280x600p60hz,
+	HDMIV_1280x768p60hz,
+	HDMIV_1280x800p60hz,
+	HDMIV_1280x960p60hz,
+	HDMIV_1280x1024p60hz,
+	HDMIV_1360x768p60hz,
+	HDMIV_1366x768p60hz,
+	HDMIV_1400x1050p60hz,
+	HDMIV_1440x900p60hz,
+	HDMIV_1440x2560p60hz,
+	HDMIV_1440x2560p70hz,
+	HDMIV_1600x900p60hz,
+	HDMIV_1600x1200p60hz,
+	HDMIV_1680x1050p60hz,
+	HDMIV_1920x1200p60hz,
+	HDMIV_2160x1200p90hz,
+	HDMIV_2560x1080p60hz,
+	HDMIV_2560x1440p60hz,
+	HDMIV_2560x1600p60hz,
+	HDMIV_3440x1440p60hz,
+	HDMIV_2400x1200p90hz,
+};
+
+/* Compliance with old definitions */
+#define HDMI_640x480p60         HDMI_640x480p60_4x3
+#define HDMI_480p60             HDMI_720x480p60_4x3
+#define HDMI_480p60_16x9        HDMI_720x480p60_16x9
+#define HDMI_720p60             HDMI_1280x720p60_16x9
+#define HDMI_1080i60            HDMI_1920x1080i60_16x9
+#define HDMI_480i60             HDMI_720x480i60_4x3
+#define HDMI_480i60_16x9        HDMI_720x480i60_16x9
+#define HDMI_480i60_16x9_rpt    HDMI_2880x480i60_16x9
+#define HDMI_1440x480p60        HDMI_1440x480p60_4x3
+#define HDMI_1440x480p60_16x9   HDMI_1440x480p60_16x9
+#define HDMI_1080p60            HDMI_1920x1080p60_16x9
+#define HDMI_576p50             HDMI_720x576p50_4x3
+#define HDMI_576p50_16x9        HDMI_720x576p50_16x9
+#define HDMI_720p50             HDMI_1280x720p50_16x9
+#define HDMI_1080i50            HDMI_1920x1080i50_16x9
+#define HDMI_576i50             HDMI_720x576i50_4x3
+#define HDMI_576i50_16x9        HDMI_720x576i50_16x9
+#define HDMI_576i50_16x9_rpt    HDMI_2880x576i50_16x9
+#define HDMI_1080p50            HDMI_1920x1080p50_16x9
+#define HDMI_1080p24            HDMI_1920x1080p24_16x9
+#define HDMI_1080p25            HDMI_1920x1080p25_16x9
+#define HDMI_1080p30            HDMI_1920x1080p30_16x9
+#define HDMI_1080p120           HDMI_1920x1080p120_16x9
+#define HDMI_480p60_16x9_rpt    HDMI_2880x480p60_16x9
+#define HDMI_576p50_16x9_rpt    HDMI_2880x576p50_16x9
+#define HDMI_4k2k_24            HDMI_3840x2160p24_16x9
+#define HDMI_4k2k_25            HDMI_3840x2160p25_16x9
+#define HDMI_4k2k_30            HDMI_3840x2160p30_16x9
+#define HDMI_4k2k_50            HDMI_3840x2160p50_16x9
+#define HDMI_4k2k_60            HDMI_3840x2160p60_16x9
+#define HDMI_4k2k_smpte_24      HDMI_4096x2160p24_256x135
+#define HDMI_4k2k_smpte_50      HDMI_4096x2160p50_256x135
+#define HDMI_4k2k_smpte_60      HDMI_4096x2160p60_256x135
+
+/* CEA TIMING STRUCT DEFINITION */
+struct hdmi_cea_timing {
+	unsigned int pixel_freq; /* Unit: 1000 */
+	unsigned int h_freq; /* Unit: Hz */
+	unsigned int v_freq; /* Unit: 0.001 Hz */
+	unsigned int vsync_polarity:1; /* 1: positive  0: negative */
+	unsigned int hsync_polarity:1;
+	unsigned short h_active;
+	unsigned short h_total;
+	unsigned short h_blank;
+	unsigned short h_front;
+	unsigned short h_sync;
+	unsigned short h_back;
+	unsigned short v_active;
+	unsigned short v_total;
+	unsigned short v_blank;
+	unsigned short v_front;
+	unsigned short v_sync;
+	unsigned short v_back;
+	unsigned short v_sync_ln;
+};
+
+/* Refer CEA861-D Page 116 Table 55 */
+struct dtd {
+	unsigned short pixel_clock;
+	unsigned short h_active;
+	unsigned short h_blank;
+	unsigned short v_active;
+	unsigned short v_blank;
+	unsigned short h_sync_offset;
+	unsigned short h_sync;
+	unsigned short v_sync_offset;
+	unsigned short v_sync;
+	unsigned char h_image_size;
+	unsigned char v_image_size;
+	unsigned char h_border;
+	unsigned char v_border;
+	unsigned char flags;
+	enum hdmi_vic vic;
+};
+
+/* Dolby Version support information from EDID*/
+/* Refer to DV Spec version2.9 page26 to page39*/
+enum block_type {
+	ERROR_NULL = 0,
+	ERROR_LENGTH,
+	ERROR_OUI,
+	ERROR_VER,
+	CORRECT,
+};
+
+
+
+#define DV_IEEE_OUI             0x00D046
+#define HDR10_PLUS_IEEE_OUI	0x90848B
+
+#define HDMI_PACKET_VEND        1
+#define HDMI_PACKET_DRM		0x86
+
+#define CMD_CONF_OFFSET         (0x14 << 24)
+#define CONF_AVI_BT2020         (CMD_CONF_OFFSET + 0X2000 + 0x00)
+	#define CLR_AVI_BT2020          0x0
+	#define SET_AVI_BT2020          0x1
+/* set value as COLORSPACE_RGB444, YUV422, YUV444, YUV420 */
+#define CONF_AVI_RGBYCC_INDIC   (CMD_CONF_OFFSET + 0X2000 + 0x01)
+#define CONF_AVI_Q01            (CMD_CONF_OFFSET + 0X2000 + 0x02)
+	#define RGB_RANGE_DEFAULT       0
+	#define RGB_RANGE_LIM           1
+	#define RGB_RANGE_FUL           2
+	#define RGB_RANGE_RSVD          3
+#define CONF_AVI_YQ01           (CMD_CONF_OFFSET + 0X2000 + 0x03)
+	#define YCC_RANGE_LIM           0
+	#define YCC_RANGE_FUL           1
+	#define YCC_RANGE_RSVD          2
+
+struct hdr_info {
+	unsigned int hdr_sup_eotf_sdr:1;
+	unsigned int hdr_sup_eotf_hdr:1;
+	unsigned int hdr_sup_eotf_smpte_st_2084:1;
+	unsigned int hdr_sup_eotf_hlg:1;
+	unsigned int hdr_sup_SMD_type1:1;
+	unsigned char hdr_lum_max;
+	unsigned char hdr_lum_avg;
+	unsigned char hdr_lum_min;
+	unsigned char rawdata[7];
+};
+
+struct hdr10_plus_info {
+	uint32_t ieeeoui;
+	uint8_t length;
+	uint8_t application_version;
+};
+
+enum hdmi_hdr_transfer {
+	T_UNKNOWN = 0,
+	T_BT709,
+	T_UNDEF,
+	T_BT601,
+	T_BT470M,
+	T_BT470BG,
+	T_SMPTE170M,
+	T_SMPTE240M,
+	T_LINEAR,
+	T_LOG100,
+	T_LOG316,
+	T_IEC61966_2_4,
+	T_BT1361E,
+	T_IEC61966_2_1,
+	T_BT2020_10,
+	T_BT2020_12,
+	T_SMPTE_ST_2084,
+	T_SMPTE_ST_28,
+	T_HLG,
+};
+
+enum hdmi_hdr_color {
+	C_UNKNOWN = 0,
+	C_BT709,
+	C_UNDEF,
+	C_BT601,
+	C_BT470M,
+	C_BT470BG,
+	C_SMPTE170M,
+	C_SMPTE240M,
+	C_FILM,
+	C_BT2020,
+};
+
+/* master_display_info for display device */
+struct master_display_info_s {
+	u32 present_flag;
+	u32 features;			/* feature bits bt2020/2084 */
+	u32 primaries[3][2];		/* normalized 50000 in G,B,R order */
+	u32 white_point[2]; 	/* normalized 50000 */
+	u32 luminance[2];		/* max/min lumin, normalized 10000 */
+	u32 max_content;		/* Maximum Content Light Level */
+	u32 max_frame_average;	/* Maximum Frame-average Light Level */
+};
+
+struct hdr10plus_para {
+	uint8_t application_version;
+	uint8_t targeted_max_lum;
+	uint8_t average_maxrgb;
+	uint8_t distribution_values[9];
+	uint8_t num_bezier_curve_anchors;
+	uint32_t knee_point_x;
+	uint32_t knee_point_y;
+	uint8_t bezier_curve_anchors[9];
+	uint8_t graphics_overlay_flag;
+	uint8_t no_delay_flag;
+};
+
+struct dv_info {
+	unsigned char rawdata[27];
+	enum block_type block_flag;
+	uint32_t ieeeoui;
+	uint8_t ver; /* 0 or 1 or 2*/
+	uint8_t length;/*ver1: 15 or 12*/
+
+	uint8_t sup_yuv422_12bit:1;
+	/* if as 0, then support RGB tunnel mode */
+	uint8_t sup_2160p60hz:1;
+	/* if as 0, then support 2160p30hz */
+	uint8_t sup_global_dimming:1;
+	uint16_t Rx;
+	uint16_t Ry;
+	uint16_t Gx;
+	uint16_t Gy;
+	uint16_t Bx;
+	uint16_t By;
+	uint16_t Wx;
+	uint16_t Wy;
+	uint16_t tminPQ;
+	uint16_t tmaxPQ;
+	uint8_t dm_major_ver;
+	uint8_t dm_minor_ver;
+	uint8_t dm_version;
+	uint8_t tmaxLUM;
+	uint8_t colorimetry:1;/* ver1*/
+	uint8_t tminLUM;
+	uint8_t low_latency;/* ver1_12 and 2*/
+	uint8_t sup_backlight_control:1;/*only ver2*/
+	uint8_t backlt_min_luma;/*only ver2*/
+	uint8_t Interface;/*only ver2*/
+	uint8_t sup_10b_12b_444;/*only ver2*/
+	uint8_t support_DV_RGB_444_8BIT;
+	uint8_t support_LL_YCbCr_422_12BIT;
+	uint8_t support_LL_RGB_444_10BIT;
+	uint8_t support_LL_RGB_444_12BIT;
+};
+
+enum eotf_type {
+	EOTF_T_NULL = 0,
+	EOTF_T_DOLBYVISION,
+	EOTF_T_HDR10,
+	EOTF_T_SDR,
+	EOTF_T_LL_MODE,
+	EOTF_T_MAX,
+};
+
+enum mode_type {
+	YUV422_BIT12 = 0,
+	RGB_8BIT,
+	RGB_10_12BIT,
+	YUV444_10_12BIT,
+};
+
+/* Dolby Version VSIF  parameter*/
+struct dv_vsif_para {
+	uint8_t ver; /* 0 or 1 or 2*/
+	uint8_t length;/*ver1: 15 or 12*/
+	union {
+		struct {
+			uint8_t low_latency:1;
+			uint8_t dobly_vision_signal:1;
+			uint8_t backlt_ctrl_MD_present:1;
+			uint8_t auxiliary_MD_present:1;
+			uint8_t eff_tmax_PQ_hi;
+			uint8_t eff_tmax_PQ_low;
+			uint8_t auxiliary_runmode;
+			uint8_t auxiliary_runversion;
+			uint8_t auxiliary_debug0;
+		} ver2;
+	} vers;
+};
+
+#define Y420CMDB_MAX 32
+#define VIC_MAX_NUM  256
+struct rx_cap {
+	unsigned int native_Mode;
+	/*video*/
+	unsigned int VIC[VIC_MAX_NUM];
+	unsigned int VIC_count;
+	unsigned int native_VIC;
+	/*vendor*/
+	unsigned int IEEEOUI;
+	unsigned int Max_TMDS_Clock1; /* HDMI1.4b TMDS_CLK */
+	unsigned int HF_IEEEOUI;	/* For HDMI Forum */
+	unsigned int Max_TMDS_Clock2; /* HDMI2.0 TMDS_CLK */
+	/* CEA861-F, Table 56, Colorimetry Data Block */
+	unsigned int colorimetry_data;
+	unsigned int scdc_present:1;
+	unsigned int scdc_rr_capable:1; /* SCDC read request */
+	unsigned int lte_340mcsc_scramble:1;
+	unsigned support_ycbcr444_flag:1;
+	unsigned support_ycbcr422_flag:1;
+	unsigned int dc_y444:1;
+	unsigned int dc_30bit:1;
+	unsigned int dc_36bit:1;
+	unsigned int dc_48bit:1;
+	unsigned int dc_y420:1;
+	unsigned int dc_30bit_420:1;
+	unsigned int dc_36bit_420:1;
+	unsigned int dc_48bit_420:1;
+	unsigned char edid_version;
+	unsigned char edid_revision;
+	unsigned int ColorDeepSupport;
+	unsigned int Video_Latency;
+	unsigned int Audio_Latency;
+	unsigned int Interlaced_Video_Latency;
+	unsigned int Interlaced_Audio_Latency;
+	unsigned int threeD_present;
+	unsigned int threeD_Multi_present;
+	unsigned int hdmi_vic_LEN;
+	enum hdmi_vic preferred_mode;
+	struct dtd dtd[16];
+	unsigned char dtd_idx;
+	unsigned char flag_vfpdb;
+	unsigned char number_of_dtd;
+	unsigned char pref_colorspace;
+	struct hdr_info hdr_info;
+	struct dv_info dv_info;
+	struct hdr10_plus_info hdr10plus_info;
+	/*blk0 check sum*/
+	unsigned char chksum;
+	/*blk0-3 check sum*/
+	char checksum[10];
+	unsigned char edid_changed;
+	/* for total = 32*8 = 256 VICs */
+	/* for Y420CMDB bitmap */
+	unsigned char bitmap_valid;
+	unsigned char bitmap_length;
+	unsigned char y420_all_vic;
+	unsigned char y420cmdb_bitmap[Y420CMDB_MAX];
+};
+
+enum color_attr_type {
+	COLOR_ATTR_YCBCR444_12BIT = 0,
+	COLOR_ATTR_YCBCR422_12BIT,
+	COLOR_ATTR_YCBCR420_12BIT,
+	COLOR_ATTR_RGB_12BIT,
+	COLOR_ATTR_YCBCR444_10BIT,
+	COLOR_ATTR_YCBCR422_10BIT,
+	COLOR_ATTR_YCBCR420_10BIT,
+	COLOR_ATTR_RGB_10BIT,
+	COLOR_ATTR_YCBCR444_8BIT,
+	COLOR_ATTR_YCBCR422_8BIT,
+	COLOR_ATTR_YCBCR420_8BIT,
+	COLOR_ATTR_RGB_8BIT,
+	COLOR_ATTR_RESERVED,
+};
+
+struct color_attr_to_string {
+	enum color_attr_type color_attr;
+	const char *color_attr_string;
+};
+
+enum hdmi_color_depth {
+	HDMI_COLOR_DEPTH_24B = 4,
+	HDMI_COLOR_DEPTH_30B = 5,
+	HDMI_COLOR_DEPTH_36B = 6,
+	HDMI_COLOR_DEPTH_48B = 7,
+};
+
+enum hdmi_color_format {
+	HDMI_COLOR_FORMAT_RGB,
+	HDMI_COLOR_FORMAT_422,
+	HDMI_COLOR_FORMAT_444,
+	HDMI_COLOR_FORMAT_420,
+};
+
+enum hdmi_color_range {
+	HDMI_COLOR_RANGE_LIM,
+	HDMI_COLOR_RANGE_FUL,
+};
+
+enum hdmi_audio_packet {
+	HDMI_AUDIO_PACKET_SMP = 0x02,
+	HDMI_AUDIO_PACKET_1BT = 0x07,
+	HDMI_AUDIO_PACKET_DST = 0x08,
+	HDMI_AUDIO_PACKET_HBR = 0x09,
+};
+
+enum hdmi_phy_para {
+	HDMI_PHYPARA_6G = 1, /* 2160p60hz 444 8bit */
+	HDMI_PHYPARA_4p5G, /* 2160p50hz 420 12bit */
+	HDMI_PHYPARA_3p7G, /* 2160p30hz 444 10bit */
+	HDMI_PHYPARA_3G, /* 2160p24hz 444 8bit */
+	HDMI_PHYPARA_LT3G, /* 1080p60hz 444 12bit */
+	HDMI_PHYPARA_DEF = HDMI_PHYPARA_LT3G,
+	HDMI_PHYPARA_270M, /* 480p60hz 444 8bit */
+};
+
+/* get hdmi cea timing
+ * t: struct hdmi_cea_timing *
+ */
+#define GET_TIMING(name) (t->name)
+
+struct parse_cd {
+	enum hdmi_color_depth cd;
+	const char *name;
+};
+
+struct parse_cs {
+	enum hdmi_color_format cs;
+	const char *name;
+};
+
+struct parse_cr {
+	enum hdmi_color_format cr;
+	const char *name;
+};
+
+#define EDID_BLK_NO	4
+#define EDID_BLK_SIZE	128
+struct hdmi_format_para {
+	enum hdmi_vic vic;
+	char *name; /* full name, 1280x720p60hz */
+	char *sname; /* short name, 1280x720p60hz -> 720p60hz */
+	char ext_name[32];
+	enum hdmi_color_depth cd; /* cd8, cd10 or cd12 */
+	enum hdmi_color_format cs; /* rgb, y444, y422, y420 */
+	enum hdmi_color_range cr; /* limit, full */
+	unsigned int pixel_repetition_factor;
+	unsigned int progress_mode:1; /* 0: Interlace  1: Progressive */
+	unsigned int scrambler_en:1;
+	unsigned int tmds_clk_div40:1;
+	unsigned int tmds_clk; /* Unit: 1000 */
+	struct hdmi_cea_timing timing;
+};
+
+struct hdmi_support_mode {
+	enum hdmi_vic vic;
+	char *sname;
+	char y420;
+};
+
+#define DOLBY_VISION_LL_RGB             3
+#define DOLBY_VISION_LL_YUV             2
+#define DOLBY_VISION_STD_ENABLE         1
+#define DOLBY_VISION_DISABLE            0
+#define DOLBY_VISION_ENABLE	1
+
+#define HDMI_IEEEOUI 0x000C03
+#define MODE_LEN	32
+#define VESA_MAX_TIMING 64
+
+typedef struct input_hdmi_data {
+	char ubootenv_hdmimode[MODE_LEN];
+	char ubootenv_colorattribute[MODE_LEN];
+	int ubootenv_dv_type;
+	#if 0
+	bool isbestpolicy;
+	bool isSupport4K30Hz;
+	bool isSupport4K;
+	bool isDeepColor;
+	bool isframeratepriority;
+	bool isLowPowerMode;
+	#endif
+	struct rx_cap *pRXCap;
+} hdmi_data_t;
+
+typedef struct scene_output_info {
+	char final_displaymode[MODE_LEN];
+	char final_deepcolor[MODE_LEN];
+	int final_dv_type;
+} scene_output_info_t;
+
+struct dispmode_vic {
+	const char *disp_mode;
+	enum hdmi_vic VIC;
+};
+
+#endif
+
diff --git a/include/amlogic/media/vout/hdmitx/hdmitx.h b/include/amlogic/media/vout/hdmitx/hdmitx.h
new file mode 100644
index 0000000000..1458741089
--- /dev/null
+++ b/include/amlogic/media/vout/hdmitx/hdmitx.h
@@ -0,0 +1,11 @@
+#ifndef __HDMITX_H_
+#define __HDMITX_H_
+#include "hdmi_common.h"
+#include "hdmitx_module.h"
+#include "hdmitx_reg.h"
+#include "mach_reg.h"
+
+int hdmitx_likely_frac_rate_mode(char *m);
+int hdmi_outputmode_check(char *mode, unsigned int frac);
+
+#endif
diff --git a/include/amlogic/media/vout/hdmitx/hdmitx_ext.h b/include/amlogic/media/vout/hdmitx/hdmitx_ext.h
new file mode 100644
index 0000000000..acf58a8091
--- /dev/null
+++ b/include/amlogic/media/vout/hdmitx/hdmitx_ext.h
@@ -0,0 +1,6 @@
+#ifndef __HDMITX_EXT_H__
+#define __HDMITX_EXT_H__
+
+void hdmitx_init(void);
+
+#endif
diff --git a/include/amlogic/media/vout/hdmitx/hdmitx_module.h b/include/amlogic/media/vout/hdmitx/hdmitx_module.h
new file mode 100644
index 0000000000..60d22f63e3
--- /dev/null
+++ b/include/amlogic/media/vout/hdmitx/hdmitx_module.h
@@ -0,0 +1,106 @@
+#ifndef __HDMITX_MODULE_H__
+#define __HDMITX_MODULE_H__
+
+#include "hdmi_common.h"
+#include "hdmitx_ext.h"
+
+struct hdmitx_dev {
+	unsigned char rx_edid[512]; /* some RX may exceeds 256Bytes */
+	struct {
+		int (*get_hpd_state)(void);
+		int (*read_edid)(unsigned char *buf, unsigned char addr,
+				 unsigned char blk_no);
+		void (*turn_off)(void);
+		void (*list_support_modes)(void);
+		void (*dump_regs)(void);
+		void (*test_bist)(unsigned int mode);
+		void (*test_prbs)(void);
+		void (*set_div40)(bool div40);
+		void (*output_blank)(unsigned int blank);
+	} hwop;
+	unsigned char rawedid[EDID_BLK_SIZE * EDID_BLK_NO];
+	struct rx_cap RXCap;
+	struct hdmi_format_para *para;
+	enum hdmi_vic vic;
+	unsigned int frac_rate_policy;
+	unsigned int mode420;
+	unsigned int dc30;
+	enum eotf_type hdmi_current_eotf_type;
+	enum mode_type hdmi_current_tunnel_mode;
+	/* Add dongle_mode, clock, phy may be different from mbox */
+	unsigned int dongle_mode;
+};
+
+struct hdmitx_dev *hdmitx_get_hdev(void);
+
+struct hdmi_format_para *hdmi_get_fmt_paras(enum hdmi_vic vic);
+enum hdmi_vic hdmi_get_fmt_vic(char const *name);
+void hdmi_parse_attr(struct hdmi_format_para *para, char const *name);
+int hdmitx_edid_VIC_support(enum hdmi_vic vic);
+enum hdmi_vic hdmitx_edid_vic_tab_map_vic(const char *disp_mode);
+const char *hdmitx_edid_vic_tab_map_string(enum hdmi_vic vic);
+const char *hdmitx_edid_vic_to_string(enum hdmi_vic vic);
+bool hdmitx_edid_check_valid_mode(struct hdmitx_dev *hdev,
+	struct hdmi_format_para *para);
+enum hdmi_vic hdmitx_edid_get_VIC(struct hdmitx_dev *hdev,
+	const char *disp_mode, char force_flag);
+bool edid_parsing_ok(struct hdmitx_dev *hdev);
+bool is_dolby_enabled(void);
+bool is_tv_support_dv(struct hdmitx_dev *hdev);
+void dolbyvision_scene_process(hdmi_data_t *hdmi_data,
+	scene_output_info_t *output_info);
+void sdr_scene_process(hdmi_data_t *hdmi_data,
+	scene_output_info_t *output_info);
+void get_hdmi_data(struct hdmitx_dev *hdev, hdmi_data_t *data);
+bool pre_process_str(char *name);
+struct hdmi_format_para *hdmi_tst_fmt_name(char const *name, char const *attr);
+bool is_supported_mode_attr(hdmi_data_t *hdmi_data, char *mode_attr);
+int get_ubootenv_dv_type(void);
+void hdmi_tx_set(struct hdmitx_dev *hdev);
+/* Parsing RAW EDID data from edid to pRXCap */
+unsigned int hdmi_edid_parsing(unsigned char *edid, struct rx_cap *pRXCap);
+struct hdmi_format_para *hdmi_match_dtd_paras(struct dtd *t);
+bool hdmimode_is_interlaced(enum hdmi_vic vic);
+void hdmitx_ddc_init(void);
+void hdmitx_set_clk(struct hdmitx_dev *hdev);
+void hdmitx_turnoff(void);
+int hdmitx_get_hpd_state(void);
+void hdmitx_prbs(void);
+unsigned int hdmitx_rd_check_reg(unsigned int addr, unsigned int exp_data,
+	unsigned int mask);
+void hdmitx_hdcp_init(void);
+void hdmitx_set_phypara(enum hdmi_phy_para mode);
+void hdmitx_test_prbs(void);
+void hdmitx_set_div40(bool div40);
+
+extern void hdmitx_set_drm_pkt(struct master_display_info_s *data);
+bool hdmitx_find_vendor(struct hdmitx_dev *hdev);
+#ifndef CONFIG_AML_HDMITX20
+void __attribute__((weak))hdmitx_set_drm_pkt(struct master_display_info_s *data)
+{
+}
+#endif
+
+void hdmitx_set_vsif_pkt(enum eotf_type type, enum mode_type tunnel_mode,
+	struct dv_vsif_para *data);
+void hdmitx_set_hdr10plus_pkt(unsigned int flag,
+	struct hdr10plus_para *data);
+
+#ifndef printk
+#define printk printf
+#endif
+#ifndef pr_info
+#define pr_info printf
+#endif
+
+#define hdmitx_debug() /* printf("hd: %s[%d]\n", __func__, __LINE__) */
+
+extern struct hdr_info *hdmitx_get_rx_hdr_info(void);
+#ifndef CONFIG_AML_HDMITX20
+struct hdr_info * __attribute__((weak))hdmitx_get_rx_hdr_info(void)
+{
+	return NULL;
+}
+#endif
+
+#endif
diff --git a/include/amlogic/media/vout/hdmitx/hdmitx_reg.h b/include/amlogic/media/vout/hdmitx/hdmitx_reg.h
new file mode 100644
index 0000000000..b13e4ab986
--- /dev/null
+++ b/include/amlogic/media/vout/hdmitx/hdmitx_reg.h
@@ -0,0 +1,1041 @@
+/*
+ * driver/amlogic/media/vout/hdmitx/hdmitx_reg.h
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _HDMI_TX_REG_H
+#define _HDMI_TX_REG_H
+
+/* TOP-level wrapper registers addresses */
+/* bit24: 1 means secure access */
+/* bit28: 1 means DWC, 0 means TOP */
+#define SEC_OFFSET           (0x1UL << 24)
+#define TOP_OFFSET_MASK      (0x0UL << 24)
+#define TOP_SEC_OFFSET_MASK  ((TOP_OFFSET_MASK) | (SEC_OFFSET))
+#define DWC_OFFSET_MASK      (0x10UL << 24)
+#define DWC_SEC_OFFSET_MASK  ((DWC_OFFSET_MASK) | (SEC_OFFSET))
+
+/* Bit 7 RW Reserved. Default 1. */
+/* Bit 6 RW Reserved. Default 1. */
+/* Bit 5 RW Reserved. Default 1. */
+/* Bit 4 RW sw_reset_phyif: PHY interface. 1=Apply reset; 0=Release from reset.
+ *     Default 1.
+ * Bit 3 RW sw_reset_intr:  interrupt module. 1=Apply reset;
+ *     0=Release from reset. Default 1.
+ * Bit 2 RW sw_reset_mem:   KSV/REVOC mem. 1=Apply reset; 0=Release from reset.
+ *     Default 1.
+ * Bit 1 RW sw_reset_rnd:   random number interface to HDCP. 1=Apply reset;
+ *     0=Release from reset. Default 1.
+ * Bit 0 RW sw_reset_core: connects to IP's ~irstz. 1=Apply reset;
+ *     0=Release from reset. Default 1.
+ */
+#define HDMITX_TOP_SW_RESET                     (TOP_OFFSET_MASK + 0x000)
+
+/* Bit 12 RW i2s_ws_inv:1=Invert i2s_ws; 0=No invert. Default 0. */
+/* Bit 11 RW i2s_clk_inv: 1=Invert i2s_clk; 0=No invert. Default 0. */
+/* Bit 10 RW spdif_clk_inv: 1=Invert spdif_clk; 0=No invert. Default 0. */
+/* Bit 9 RW tmds_clk_inv: 1=Invert tmds_clk; 0=No invert. Default 0. */
+/* Bit 8 RW pixel_clk_inv: 1=Invert pixel_clk; 0=No invert. Default 0. */
+/* Bit 4 RW cec_clk_en: 1=enable cec_clk; 0=disable. Default 0. */
+/* Bit 3 RW i2s_clk_en: 1=enable i2s_clk; 0=disable. Default 0. */
+/* Bit 2 RW spdif_clk_en: 1=enable spdif_clk; 0=disable. Default 0. */
+/* Bit 1 RW tmds_clk_en: 1=enable tmds_clk;  0=disable. Default 0. */
+/* Bit 0 RW pixel_clk_en: 1=enable pixel_clk; 0=disable. Default 0. */
+#define HDMITX_TOP_CLK_CNTL                     (TOP_OFFSET_MASK + 0x001)
+
+/* Bit 11: 0 RW hpd_valid_width: filter out width <= M*1024.    Default 0. */
+/* Bit 15:12 RW hpd_glitch_width: filter out glitch <= N.       Default 0. */
+#define HDMITX_TOP_HPD_FILTER                   (TOP_OFFSET_MASK + 0x002)
+
+/* intr_maskn: MASK_N, one bit per interrupt source.
+ *     1=Enable interrupt source; 0=Disable interrupt source. Default 0.
+ * [  4] hdcp22_rndnum_err
+ * [  3] nonce_rfrsh_rise
+ * [  2] hpd_fall_intr
+ * [  1] hpd_rise_intr
+ * [  0] core_intr
+ */
+#define HDMITX_TOP_INTR_MASKN                   (TOP_OFFSET_MASK + 0x003)
+
+/* Bit 30: 0 RW intr_stat: For each bit, write 1 to manually set the interrupt
+ *     bit, read back the interrupt status. */
+/* Bit    31 R  IP interrupt status */
+/* Bit     2 RW hpd_fall */
+/* Bit     1 RW hpd_rise */
+/* Bit     0 RW IP interrupt */
+#define HDMITX_TOP_INTR_STAT                    (TOP_OFFSET_MASK + 0x004)
+
+/* [4]	  hdcp22_rndnum_err */
+/* [3]	  nonce_rfrsh_rise */
+/* [2]	  hpd_fall */
+/* [1]	  hpd_rise */
+/* [0]	  core_intr_rise */
+#define HDMITX_TOP_INTR_STAT_CLR                (TOP_OFFSET_MASK + 0x005)
+
+/* Bit 14:12 RW tmds_sel: 3'b000=Output zero; 3'b001=Output normal TMDS data;
+ *     3'b010=Output PRBS data; 3'b100=Output shift pattern.         Default 0.
+ * Bit 11: 9 RW shift_pttn_repeat: 0=New pattern every clk cycle; 1=New pattern
+ *     every 2 clk cycles; ...; 7=New pattern every 8 clk cycles.  Default 0.
+ * Bit 8 RW shift_pttn_en: 1= Eanble shift pattern generator; 0=Disable.
+ *     Default 0.
+ * Bit 4: 3 RW prbs_pttn_mode: 0=PRBS11; 1=PRBS15; 2=PRBS7; 3=PRBS31. Default 0.
+ * Bit 2: 1 RW prbs_pttn_width: 0=idle; 1=output 8-bit pattern;
+ *     2=Output 1-bit pattern; 3=output 10-bit pattern. Default 0.
+ * Bit 0 RW prbs_pttn_en: 1=Enable PRBS generator; 0=Disable. Default 0.
+ */
+#define HDMITX_TOP_BIST_CNTL                    (TOP_OFFSET_MASK + 0x006)
+
+/* Bit 29:20 RW shift_pttn_data[59:50]. Default 0. */
+/* Bit 19:10 RW shift_pttn_data[69:60]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[79:70]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_012               (TOP_OFFSET_MASK + 0x007)
+
+/* Bit 29:20 RW shift_pttn_data[29:20]. Default 0. */
+/* Bit 19:10 RW shift_pttn_data[39:30]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[49:40]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_345               (TOP_OFFSET_MASK + 0x008)
+
+/* Bit 19:10 RW shift_pttn_data[ 9: 0]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[19:10]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_67                (TOP_OFFSET_MASK + 0x009)
+
+/* Bit 25:16 RW tmds_clk_pttn[19:10]. Default 0. */
+/* Bit  9: 0 RW tmds_clk_pttn[ 9: 0]. Default 0. */
+#define HDMITX_TOP_TMDS_CLK_PTTN_01             (TOP_OFFSET_MASK + 0x00A)
+
+/* Bit 25:16 RW tmds_clk_pttn[39:30]. Default 0. */
+/* Bit  9: 0 RW tmds_clk_pttn[29:20]. Default 0. */
+#define HDMITX_TOP_TMDS_CLK_PTTN_23             (TOP_OFFSET_MASK + 0x00B)
+
+/* Bit 1 RW shift_tmds_clk_pttn:1=Enable shifting clk pattern,
+ * used when TMDS CLK rate = TMDS character rate /4.    Default 0.
+ * Bit 0 R  Reserved. Default 0.
+ */
+/* [	1] shift_tmds_clk_pttn */
+/* [	0] load_tmds_clk_pttn */
+#define HDMITX_TOP_TMDS_CLK_PTTN_CNTL           (TOP_OFFSET_MASK + 0x00C)
+
+/* Bit 0 RW revocmem_wr_fail: Read back 1 to indicate Host write REVOC MEM
+ * failure, write 1 to clear the failure flag.  Default 0.
+ */
+#define HDMITX_TOP_REVOCMEM_STAT                (TOP_OFFSET_MASK + 0x00D)
+
+/* Bit     0 R  filtered HPD status. */
+#define HDMITX_TOP_STAT0                        (TOP_OFFSET_MASK + 0x00E)
+#define HDMITX_TOP_SKP_CNTL_STAT                (TOP_SEC_OFFSET_MASK + 0x010)
+#define HDMITX_TOP_NONCE_0                      (TOP_SEC_OFFSET_MASK + 0x011)
+#define HDMITX_TOP_NONCE_1                      (TOP_SEC_OFFSET_MASK + 0x012)
+#define HDMITX_TOP_NONCE_2                      (TOP_SEC_OFFSET_MASK + 0x013)
+#define HDMITX_TOP_NONCE_3                      (TOP_SEC_OFFSET_MASK + 0x014)
+#define HDMITX_TOP_PKF_0                        (TOP_SEC_OFFSET_MASK + 0x015)
+#define HDMITX_TOP_PKF_1                        (TOP_SEC_OFFSET_MASK + 0x016)
+#define HDMITX_TOP_PKF_2                        (TOP_SEC_OFFSET_MASK + 0x017)
+#define HDMITX_TOP_PKF_3                        (TOP_SEC_OFFSET_MASK + 0x018)
+#define HDMITX_TOP_DUK_0                        (TOP_SEC_OFFSET_MASK + 0x019)
+#define HDMITX_TOP_DUK_1                        (TOP_SEC_OFFSET_MASK + 0x01A)
+#define HDMITX_TOP_DUK_2                        (TOP_SEC_OFFSET_MASK + 0x01B)
+#define HDMITX_TOP_DUK_3                        (TOP_SEC_OFFSET_MASK + 0x01C)
+/* [26:24] infilter_ddc_intern_clk_divide */
+/* [23:16] infilter_ddc_sample_clk_divide */
+/* [10: 8] infilter_cec_intern_clk_divide */
+/* [ 7: 0] infilter_cec_sample_clk_divide */
+#define HDMITX_TOP_INFILTER                     (TOP_OFFSET_MASK + 0x01D)
+#define HDMITX_TOP_NSEC_SCRATCH                 (TOP_OFFSET_MASK + 0x01E)
+#define HDMITX_TOP_SEC_SCRATCH                  (TOP_SEC_OFFSET_MASK + 0x01F)
+#define HDMITX_TOP_EMP_CNTL0                  (TOP_OFFSET_MASK + 0x020)
+#define HDMITX_TOP_EMP_CNTL1                  (TOP_OFFSET_MASK + 0x021)
+#define HDMITX_TOP_EMP_MEMADDR_START                  (TOP_OFFSET_MASK + 0x022)
+#define HDMITX_TOP_EMP_STAT0                  (TOP_OFFSET_MASK + 0x023)
+#define HDMITX_TOP_EMP_STAT1                  (TOP_OFFSET_MASK + 0x024)
+#define HDMITX_TOP_AXI_ASYNC_CNTL0                  (TOP_OFFSET_MASK + 0x025)
+#define HDMITX_TOP_AXI_ASYNC_CNTL1                  (TOP_OFFSET_MASK + 0x026)
+#define HDMITX_TOP_AXI_ASYNC_STAT0                  (TOP_OFFSET_MASK + 0x027)
+#define HDMITX_TOP_I2C_BUSY_CNT_MAX                  (TOP_OFFSET_MASK + 0x028)
+#define HDMITX_TOP_I2C_BUSY_CNT_STAT                  (TOP_OFFSET_MASK + 0x029)
+#define HDMITX_TOP_HDCP22_BSOD                  (TOP_OFFSET_MASK + 0x02A)
+#define HDMITX_TOP_DDC_CNTL                  (TOP_OFFSET_MASK + 0x02B)
+#define HDMITX_TOP_REVOCMEM_ADDR_S                  (TOP_OFFSET_MASK + 0x2000 >> 2)
+#define HDMITX_TOP_REVOCMEM_ADDR_E                  (TOP_OFFSET_MASK + 0x365E >> 2)
+
+#define HDMITX_TOP_DONT_TOUCH0                  (TOP_OFFSET_MASK + 0x0FE)
+#define HDMITX_TOP_DONT_TOUCH1                  (TOP_OFFSET_MASK + 0x0FF)
+
+/* DWC_HDMI_TX Controller registers addresses */
+
+/* Identification Registers */
+#define HDMITX_DWC_DESIGN_ID                    (DWC_OFFSET_MASK + 0x0000)
+#define HDMITX_DWC_REVISION_ID                  (DWC_OFFSET_MASK + 0x0001)
+#define HDMITX_DWC_PRODUCT_ID0                  (DWC_OFFSET_MASK + 0x0002)
+#define HDMITX_DWC_PRODUCT_ID1                  (DWC_OFFSET_MASK + 0x0003)
+#define HDMITX_DWC_CONFIG0_ID                   (DWC_OFFSET_MASK + 0x0004)
+#define HDMITX_DWC_CONFIG1_ID                   (DWC_OFFSET_MASK + 0x0005)
+#define HDMITX_DWC_CONFIG2_ID                   (DWC_OFFSET_MASK + 0x0006)
+#define HDMITX_DWC_CONFIG3_ID                   (DWC_OFFSET_MASK + 0x0007)
+
+/* Interrupt Registers */
+#define HDMITX_DWC_IH_FC_STAT0                  (DWC_OFFSET_MASK + 0x0100)
+#define HDMITX_DWC_IH_FC_STAT1                  (DWC_OFFSET_MASK + 0x0101)
+#define HDMITX_DWC_IH_FC_STAT2                  (DWC_OFFSET_MASK + 0x0102)
+#define HDMITX_DWC_IH_AS_STAT0                  (DWC_OFFSET_MASK + 0x0103)
+#define HDMITX_DWC_IH_PHY_STAT0                 (DWC_OFFSET_MASK + 0x0104)
+#define HDMITX_DWC_IH_I2CM_STAT0                (DWC_OFFSET_MASK + 0x0105)
+#define HDMITX_DWC_IH_CEC_STAT0                 (DWC_OFFSET_MASK + 0x0106)
+#define HDMITX_DWC_IH_VP_STAT0                  (DWC_OFFSET_MASK + 0x0107)
+#define HDMITX_DWC_IH_I2CMPHY_STAT0             (DWC_OFFSET_MASK + 0x0108)
+#define HDMITX_DWC_IH_DECODE                    (DWC_OFFSET_MASK + 0x0170)
+/* [  7] mute_AUDI */
+/* [  6] mute_ACP */
+/* [  5] mute_HBR */
+/* [  4] mute_MAS */
+/* [  3] mute_NVBI */
+/* [  2] mute_AUDS */
+/* [  1] mute_ACR */
+/* [  0] mute_NULL */
+#define HDMITX_DWC_IH_MUTE_FC_STAT0             (DWC_OFFSET_MASK + 0x0180)
+/* [  7] mute_GMD */
+/* [  6] mute_ISRC1 */
+/* [  5] mute_ISRC2 */
+/* [  4] mute_VSD */
+/* [  3] mute_SPD */
+/* [  2] mute_AMP */
+/* [  1] mute_AVI */
+/* [  0] mute_GCP */
+#define HDMITX_DWC_IH_MUTE_FC_STAT1             (DWC_OFFSET_MASK + 0x0181)
+/* [  1] mute_LowPriority_fifo_full */
+/* [  0] mute_HighPriority_fifo_full */
+#define HDMITX_DWC_IH_MUTE_FC_STAT2             (DWC_OFFSET_MASK + 0x0182)
+/* [  4] mute_aud_fifo_underrun */
+/* [  3] mute_aud_fifo_overrun */
+/* [  2] mute_aud_fifo_empty_thr. oififoemptythr tied to 0. */
+/* [  1] mute_aud_fifo_empty */
+/* [  0] mute_aud_fifo_full */
+#define HDMITX_DWC_IH_MUTE_AS_STAT0             (DWC_OFFSET_MASK + 0x0183)
+#define HDMITX_DWC_IH_MUTE_PHY_STAT0            (DWC_OFFSET_MASK + 0x0184)
+/* [  2] mute_scdc_readreq */
+/* [  1] mute_edid_i2c_master_done */
+/* [  0] mute_edid_i2c_master_error */
+#define HDMITX_DWC_IH_MUTE_I2CM_STAT0           (DWC_OFFSET_MASK + 0x0185)
+/* [  6] cec_wakeup */
+/* [  5] cec_error_follower */
+/* [  4] cec_error_initiator */
+/* [  3] cec_arb_lost */
+/* [  2] cec_nack */
+/* [  1] cec_eom */
+/* [  0] cec_done */
+#define HDMITX_DWC_IH_MUTE_CEC_STAT0            (DWC_OFFSET_MASK + 0x0186)
+#define HDMITX_DWC_IH_MUTE_VP_STAT0             (DWC_OFFSET_MASK + 0x0187)
+#define HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0        (DWC_OFFSET_MASK + 0x0188)
+/* [  1] mute_wakeup_interrupt */
+/* [  0] mute_all_interrupt */
+#define HDMITX_DWC_IH_MUTE                      (DWC_OFFSET_MASK + 0x01FF)
+
+/* Video Sampler Registers */
+/* [  7] internal_de_generator */
+/* [4:0] video_mapping */
+#define HDMITX_DWC_TX_INVID0                    (DWC_OFFSET_MASK + 0x0200)
+/* [  2] bcbdata_stuffing */
+/* [  1] rcrdata_stuffing */
+/* [  0] gydata_stuffing */
+#define HDMITX_DWC_TX_INSTUFFING                (DWC_OFFSET_MASK + 0x0201)
+#define HDMITX_DWC_TX_GYDATA0                   (DWC_OFFSET_MASK + 0x0202)
+#define HDMITX_DWC_TX_GYDATA1                   (DWC_OFFSET_MASK + 0x0203)
+#define HDMITX_DWC_TX_RCRDATA0                  (DWC_OFFSET_MASK + 0x0204)
+#define HDMITX_DWC_TX_RCRDATA1                  (DWC_OFFSET_MASK + 0x0205)
+#define HDMITX_DWC_TX_BCBDATA0                  (DWC_OFFSET_MASK + 0x0206)
+#define HDMITX_DWC_TX_BCBDATA1                  (DWC_OFFSET_MASK + 0x0207)
+
+/* Video Packetizer Registers */
+#define HDMITX_DWC_VP_STATUS                    (DWC_OFFSET_MASK + 0x0800)
+/* [3:0] desired_pr_factor */
+#define HDMITX_DWC_VP_PR_CD                     (DWC_OFFSET_MASK + 0x0801)
+/* [  5] default_phase */
+/* [  2] ycc422_stuffing */
+/* [  1] pp_stuffing */
+/* [  0] pr_stuffing */
+#define HDMITX_DWC_VP_STUFF                     (DWC_OFFSET_MASK + 0x0802)
+#define HDMITX_DWC_VP_REMAP                     (DWC_OFFSET_MASK + 0x0803)
+#define HDMITX_DWC_VP_CONF                      (DWC_OFFSET_MASK + 0x0804)
+/* [  7] mask_int_full_prpt */
+/* [  6] mask_int_empty_prpt */
+/* [  5] mask_int_full_ppack */
+/* [  4] mask_int_empty_ppack */
+/* [  3] mask_int_full_remap */
+/* [  2] mask_int_empty_remap */
+/* [  1] mask_int_full_byp */
+/* [  0] mask_int_empty_byp */
+#define HDMITX_DWC_VP_MASK                      (DWC_OFFSET_MASK + 0x0807)
+
+/* Frmae Composer Registers */
+/* [  7] HDCP_keepout */
+/* [  6] vs_in_pol: 0=active low; 1=active high. */
+/* [  5] hs_in_pol: 0=active low; 1=active high. */
+/* [  4] de_in_pol: 0=active low; 1=active high. */
+/* [  3] dvi_modez: 0=dvi; 1=hdmi. */
+/* [  1] r_v_blank_in_osc */
+/* [  0] in_I_P: 0=progressive; 1=interlaced. */
+#define HDMITX_DWC_FC_INVIDCONF                 (DWC_OFFSET_MASK + 0x1000)
+/* [7:0] H_in_active[7:0] */
+#define HDMITX_DWC_FC_INHACTV0                  (DWC_OFFSET_MASK + 0x1001)
+/* [5:0] H_in_active[13:8] */
+#define HDMITX_DWC_FC_INHACTV1                  (DWC_OFFSET_MASK + 0x1002)
+/* [7:0] H_in_blank[7:0] */
+#define HDMITX_DWC_FC_INHBLANK0                 (DWC_OFFSET_MASK + 0x1003)
+/* [4:0] H_in_blank[12:8] */
+#define HDMITX_DWC_FC_INHBLANK1                 (DWC_OFFSET_MASK + 0x1004)
+/* [7:0] V_in_active[7:0] */
+#define HDMITX_DWC_FC_INVACTV0                  (DWC_OFFSET_MASK + 0x1005)
+/* [4:0] V_in_active[12:8] */
+#define HDMITX_DWC_FC_INVACTV1                  (DWC_OFFSET_MASK + 0x1006)
+/* [7:0] V_in_blank */
+#define HDMITX_DWC_FC_INVBLANK                  (DWC_OFFSET_MASK + 0x1007)
+/* [7:0] H_in_delay[7:0] */
+#define HDMITX_DWC_FC_HSYNCINDELAY0             (DWC_OFFSET_MASK + 0x1008)
+/* [4:0] H_in_delay[12:8] */
+#define HDMITX_DWC_FC_HSYNCINDELAY1             (DWC_OFFSET_MASK + 0x1009)
+/* [7:0] H_in_width[7:0] */
+#define HDMITX_DWC_FC_HSYNCINWIDTH0             (DWC_OFFSET_MASK + 0x100A)
+/* [1:0] H_in_width[9:8] */
+#define HDMITX_DWC_FC_HSYNCINWIDTH1             (DWC_OFFSET_MASK + 0x100B)
+/* [7:0] V_in_delay */
+#define HDMITX_DWC_FC_VSYNCINDELAY              (DWC_OFFSET_MASK + 0x100C)
+/* [5:0] V_in_width */
+#define HDMITX_DWC_FC_VSYNCINWIDTH              (DWC_OFFSET_MASK + 0x100D)
+#define HDMITX_DWC_FC_INFREQ0                   (DWC_OFFSET_MASK + 0x100E)
+#define HDMITX_DWC_FC_INFREQ1                   (DWC_OFFSET_MASK + 0x100F)
+#define HDMITX_DWC_FC_INFREQ2                   (DWC_OFFSET_MASK + 0x1010)
+#define HDMITX_DWC_FC_CTRLDUR                   (DWC_OFFSET_MASK + 0x1011)
+#define HDMITX_DWC_FC_EXCTRLDUR                 (DWC_OFFSET_MASK + 0x1012)
+#define HDMITX_DWC_FC_EXCTRLSPAC                (DWC_OFFSET_MASK + 0x1013)
+#define HDMITX_DWC_FC_CH0PREAM                  (DWC_OFFSET_MASK + 0x1014)
+#define HDMITX_DWC_FC_CH1PREAM                  (DWC_OFFSET_MASK + 0x1015)
+#define HDMITX_DWC_FC_CH2PREAM                  (DWC_OFFSET_MASK + 0x1016)
+/* [3:2] YQ */
+/* [1:0] CN */
+#define HDMITX_DWC_FC_AVICONF3                  (DWC_OFFSET_MASK + 0x1017)
+/* [  2] default_phase */
+/* [  1] set_avmute */
+/* [  0] clear_avmute */
+#define HDMITX_DWC_FC_GCP                       (DWC_OFFSET_MASK + 0x1018)
+/* [  7] rgb_ycc_indication[2] */
+/* [  6] active_format_present */
+/* [5:4] scan_information */
+/* [3:2] bar_information */
+/* [1:0] rgb_ycc_indication[1:0] */
+#define HDMITX_DWC_FC_AVICONF0                  (DWC_OFFSET_MASK + 0x1019)
+/* [7:6] colorimetry */
+/* [5:4] picture_aspect_ratio */
+/* [3:0] active_aspect_ratio */
+#define HDMITX_DWC_FC_AVICONF1                  (DWC_OFFSET_MASK + 0x101A)
+/* [  7] IT_content */
+/* [6:4] extended_colorimetry */
+/* [3:2] quantization_range */
+/* [1:0] non_uniform_picture_scaling */
+#define HDMITX_DWC_FC_AVICONF2                  (DWC_OFFSET_MASK + 0x101B)
+#define HDMITX_DWC_FC_AVIVID                    (DWC_OFFSET_MASK + 0x101C)
+#define HDMITX_DWC_FC_AVIETB0                   (DWC_OFFSET_MASK + 0x101D)
+#define HDMITX_DWC_FC_AVIETB1                   (DWC_OFFSET_MASK + 0x101E)
+#define HDMITX_DWC_FC_AVISBB0                   (DWC_OFFSET_MASK + 0x101F)
+#define HDMITX_DWC_FC_AVISBB1                   (DWC_OFFSET_MASK + 0x1020)
+#define HDMITX_DWC_FC_AVIELB0                   (DWC_OFFSET_MASK + 0x1021)
+#define HDMITX_DWC_FC_AVIELB1                   (DWC_OFFSET_MASK + 0x1022)
+#define HDMITX_DWC_FC_AVISRB0                   (DWC_OFFSET_MASK + 0x1023)
+#define HDMITX_DWC_FC_AVISRB1                   (DWC_OFFSET_MASK + 0x1024)
+/* [3:0] CT: coding type */
+#define HDMITX_DWC_FC_AUDICONF0                 (DWC_OFFSET_MASK + 0x1025)
+/* [5:4] SS: sampling size */
+/* [2:0] SF: sampling frequency */
+#define HDMITX_DWC_FC_AUDICONF1                 (DWC_OFFSET_MASK + 0x1026)
+/* CA: channel allocation */
+#define HDMITX_DWC_FC_AUDICONF2                 (DWC_OFFSET_MASK + 0x1027)
+/* [6:5] LFEPBL: LFE playback info */
+/* [  4] DM_INH: down mix enable */
+/* [3:0] LSv: Level shift value */
+#define HDMITX_DWC_FC_AUDICONF3                 (DWC_OFFSET_MASK + 0x1028)
+#define HDMITX_DWC_FC_VSDIEEEID0                (DWC_OFFSET_MASK + 0x1029)
+#define HDMITX_DWC_FC_VSDSIZE                   (DWC_OFFSET_MASK + 0x102A)
+#define HDMITX_DWC_FC_VSDIEEEID1                (DWC_OFFSET_MASK + 0x1030)
+#define HDMITX_DWC_FC_VSDIEEEID2                (DWC_OFFSET_MASK + 0x1031)
+#define HDMITX_DWC_FC_VSDPAYLOAD0               (DWC_OFFSET_MASK + 0x1032)
+#define HDMITX_DWC_FC_VSDPAYLOAD1               (DWC_OFFSET_MASK + 0x1033)
+#define HDMITX_DWC_FC_VSDPAYLOAD2               (DWC_OFFSET_MASK + 0x1034)
+#define HDMITX_DWC_FC_VSDPAYLOAD3               (DWC_OFFSET_MASK + 0x1035)
+#define HDMITX_DWC_FC_VSDPAYLOAD4               (DWC_OFFSET_MASK + 0x1036)
+#define HDMITX_DWC_FC_VSDPAYLOAD5               (DWC_OFFSET_MASK + 0x1037)
+#define HDMITX_DWC_FC_VSDPAYLOAD6               (DWC_OFFSET_MASK + 0x1038)
+#define HDMITX_DWC_FC_VSDPAYLOAD7               (DWC_OFFSET_MASK + 0x1039)
+#define HDMITX_DWC_FC_VSDPAYLOAD8               (DWC_OFFSET_MASK + 0x103A)
+#define HDMITX_DWC_FC_VSDPAYLOAD9               (DWC_OFFSET_MASK + 0x103B)
+#define HDMITX_DWC_FC_VSDPAYLOAD10              (DWC_OFFSET_MASK + 0x103C)
+#define HDMITX_DWC_FC_VSDPAYLOAD11              (DWC_OFFSET_MASK + 0x103D)
+#define HDMITX_DWC_FC_VSDPAYLOAD12              (DWC_OFFSET_MASK + 0x103E)
+#define HDMITX_DWC_FC_VSDPAYLOAD13              (DWC_OFFSET_MASK + 0x103F)
+#define HDMITX_DWC_FC_VSDPAYLOAD14              (DWC_OFFSET_MASK + 0x1040)
+#define HDMITX_DWC_FC_VSDPAYLOAD15              (DWC_OFFSET_MASK + 0x1041)
+#define HDMITX_DWC_FC_VSDPAYLOAD16              (DWC_OFFSET_MASK + 0x1042)
+#define HDMITX_DWC_FC_VSDPAYLOAD17              (DWC_OFFSET_MASK + 0x1043)
+#define HDMITX_DWC_FC_VSDPAYLOAD18              (DWC_OFFSET_MASK + 0x1044)
+#define HDMITX_DWC_FC_VSDPAYLOAD19              (DWC_OFFSET_MASK + 0x1045)
+#define HDMITX_DWC_FC_VSDPAYLOAD20              (DWC_OFFSET_MASK + 0x1046)
+#define HDMITX_DWC_FC_VSDPAYLOAD21              (DWC_OFFSET_MASK + 0x1047)
+#define HDMITX_DWC_FC_VSDPAYLOAD22              (DWC_OFFSET_MASK + 0x1048)
+#define HDMITX_DWC_FC_VSDPAYLOAD23              (DWC_OFFSET_MASK + 0x1049)
+#define HDMITX_DWC_FC_SPDVENDORNAME0            (DWC_OFFSET_MASK + 0x104A)
+#define HDMITX_DWC_FC_SPDVENDORNAME1            (DWC_OFFSET_MASK + 0x104B)
+#define HDMITX_DWC_FC_SPDVENDORNAME2            (DWC_OFFSET_MASK + 0x104C)
+#define HDMITX_DWC_FC_SPDVENDORNAME3            (DWC_OFFSET_MASK + 0x104D)
+#define HDMITX_DWC_FC_SPDVENDORNAME4            (DWC_OFFSET_MASK + 0x104E)
+#define HDMITX_DWC_FC_SPDVENDORNAME5            (DWC_OFFSET_MASK + 0x104F)
+#define HDMITX_DWC_FC_SPDVENDORNAME6            (DWC_OFFSET_MASK + 0x1050)
+#define HDMITX_DWC_FC_SPDVENDORNAME7            (DWC_OFFSET_MASK + 0x1051)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME0           (DWC_OFFSET_MASK + 0x1052)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME1           (DWC_OFFSET_MASK + 0x1053)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME2           (DWC_OFFSET_MASK + 0x1054)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME3           (DWC_OFFSET_MASK + 0x1055)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME4           (DWC_OFFSET_MASK + 0x1056)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME5           (DWC_OFFSET_MASK + 0x1057)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME6           (DWC_OFFSET_MASK + 0x1058)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME7           (DWC_OFFSET_MASK + 0x1059)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME8           (DWC_OFFSET_MASK + 0x105A)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME9           (DWC_OFFSET_MASK + 0x105B)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME10          (DWC_OFFSET_MASK + 0x105C)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME11          (DWC_OFFSET_MASK + 0x105D)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME12          (DWC_OFFSET_MASK + 0x105E)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME13          (DWC_OFFSET_MASK + 0x105F)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME14          (DWC_OFFSET_MASK + 0x1060)
+#define HDMITX_DWC_FC_SPDPRODUCTNAME15          (DWC_OFFSET_MASK + 0x1061)
+#define HDMITX_DWC_FC_SPDDEVICEINF              (DWC_OFFSET_MASK + 0x1062)
+/* [7:4] aud_packet_sampflat */
+/* [  0] aud_packet_layout */
+#define HDMITX_DWC_FC_AUDSCONF                  (DWC_OFFSET_MASK + 0x1063)
+#define HDMITX_DWC_FC_AUDSSTAT                  (DWC_OFFSET_MASK + 0x1064)
+/* [  7] V3r */
+/* [  6] V2r */
+/* [  5] V1r */
+/* [  4] V0r */
+/* [  3] V3l */
+/* [  2] V2l */
+/* [  1] V1l */
+/* [  0] V0l */
+#define HDMITX_DWC_FC_AUDSV                     (DWC_OFFSET_MASK + 0x1065)
+#define HDMITX_DWC_FC_AUDSU                     (DWC_OFFSET_MASK + 0x1066)
+#define HDMITX_DWC_FC_AUDSCHNLS0                (DWC_OFFSET_MASK + 0x1067)
+#define HDMITX_DWC_FC_AUDSCHNLS1                (DWC_OFFSET_MASK + 0x1068)
+#define HDMITX_DWC_FC_AUDSCHNLS2                (DWC_OFFSET_MASK + 0x1069)
+#define HDMITX_DWC_FC_AUDSCHNLS3                (DWC_OFFSET_MASK + 0x106A)
+#define HDMITX_DWC_FC_AUDSCHNLS4                (DWC_OFFSET_MASK + 0x106B)
+#define HDMITX_DWC_FC_AUDSCHNLS5                (DWC_OFFSET_MASK + 0x106C)
+#define HDMITX_DWC_FC_AUDSCHNLS6                (DWC_OFFSET_MASK + 0x106D)
+#define HDMITX_DWC_FC_AUDSCHNLS7                (DWC_OFFSET_MASK + 0x106E)
+#define HDMITX_DWC_FC_AUDSCHNLS8                (DWC_OFFSET_MASK + 0x106F)
+#define HDMITX_DWC_FC_DATACH0FILL               (DWC_OFFSET_MASK + 0x1070)
+#define HDMITX_DWC_FC_DATACH1FILL               (DWC_OFFSET_MASK + 0x1071)
+#define HDMITX_DWC_FC_DATACH2FILL               (DWC_OFFSET_MASK + 0x1072)
+#define HDMITX_DWC_FC_CTRLQHIGH                 (DWC_OFFSET_MASK + 0x1073)
+#define HDMITX_DWC_FC_CTRLQLOW                  (DWC_OFFSET_MASK + 0x1074)
+#define HDMITX_DWC_FC_ACP0                      (DWC_OFFSET_MASK + 0x1075)
+#define HDMITX_DWC_FC_ACP16                     (DWC_OFFSET_MASK + 0x1082)
+#define HDMITX_DWC_FC_ACP15                     (DWC_OFFSET_MASK + 0x1083)
+#define HDMITX_DWC_FC_ACP14                     (DWC_OFFSET_MASK + 0x1084)
+#define HDMITX_DWC_FC_ACP13                     (DWC_OFFSET_MASK + 0x1085)
+#define HDMITX_DWC_FC_ACP12                     (DWC_OFFSET_MASK + 0x1086)
+#define HDMITX_DWC_FC_ACP11                     (DWC_OFFSET_MASK + 0x1087)
+#define HDMITX_DWC_FC_ACP10                     (DWC_OFFSET_MASK + 0x1088)
+#define HDMITX_DWC_FC_ACP9                      (DWC_OFFSET_MASK + 0x1089)
+#define HDMITX_DWC_FC_ACP8                      (DWC_OFFSET_MASK + 0x108A)
+#define HDMITX_DWC_FC_ACP7                      (DWC_OFFSET_MASK + 0x108B)
+#define HDMITX_DWC_FC_ACP6                      (DWC_OFFSET_MASK + 0x108C)
+#define HDMITX_DWC_FC_ACP5                      (DWC_OFFSET_MASK + 0x108D)
+#define HDMITX_DWC_FC_ACP4                      (DWC_OFFSET_MASK + 0x108E)
+#define HDMITX_DWC_FC_ACP3                      (DWC_OFFSET_MASK + 0x108F)
+#define HDMITX_DWC_FC_ACP2                      (DWC_OFFSET_MASK + 0x1090)
+#define HDMITX_DWC_FC_ACP1                      (DWC_OFFSET_MASK + 0x1091)
+#define HDMITX_DWC_FC_ISCR1_0                   (DWC_OFFSET_MASK + 0x1092)
+#define HDMITX_DWC_FC_ISCR1_16                  (DWC_OFFSET_MASK + 0x1093)
+#define HDMITX_DWC_FC_ISCR1_15                  (DWC_OFFSET_MASK + 0x1094)
+#define HDMITX_DWC_FC_ISCR1_14                  (DWC_OFFSET_MASK + 0x1095)
+#define HDMITX_DWC_FC_ISCR1_13                  (DWC_OFFSET_MASK + 0x1096)
+#define HDMITX_DWC_FC_ISCR1_12                  (DWC_OFFSET_MASK + 0x1097)
+#define HDMITX_DWC_FC_ISCR1_11                  (DWC_OFFSET_MASK + 0x1098)
+#define HDMITX_DWC_FC_ISCR1_10                  (DWC_OFFSET_MASK + 0x1099)
+#define HDMITX_DWC_FC_ISCR1_9                   (DWC_OFFSET_MASK + 0x109A)
+#define HDMITX_DWC_FC_ISCR1_8                   (DWC_OFFSET_MASK + 0x109B)
+#define HDMITX_DWC_FC_ISCR1_7                   (DWC_OFFSET_MASK + 0x109C)
+#define HDMITX_DWC_FC_ISCR1_6                   (DWC_OFFSET_MASK + 0x109D)
+#define HDMITX_DWC_FC_ISCR1_5                   (DWC_OFFSET_MASK + 0x109E)
+#define HDMITX_DWC_FC_ISCR1_4                   (DWC_OFFSET_MASK + 0x109F)
+#define HDMITX_DWC_FC_ISCR1_3                   (DWC_OFFSET_MASK + 0x10A0)
+#define HDMITX_DWC_FC_ISCR1_2                   (DWC_OFFSET_MASK + 0x10A1)
+#define HDMITX_DWC_FC_ISCR1_1                   (DWC_OFFSET_MASK + 0x10A2)
+#define HDMITX_DWC_FC_ISCR0_15                  (DWC_OFFSET_MASK + 0x10A3)
+#define HDMITX_DWC_FC_ISCR0_14                  (DWC_OFFSET_MASK + 0x10A4)
+#define HDMITX_DWC_FC_ISCR0_13                  (DWC_OFFSET_MASK + 0x10A5)
+#define HDMITX_DWC_FC_ISCR0_12                  (DWC_OFFSET_MASK + 0x10A6)
+#define HDMITX_DWC_FC_ISCR0_11                  (DWC_OFFSET_MASK + 0x10A7)
+#define HDMITX_DWC_FC_ISCR0_10                  (DWC_OFFSET_MASK + 0x10A8)
+#define HDMITX_DWC_FC_ISCR0_9                   (DWC_OFFSET_MASK + 0x10A9)
+#define HDMITX_DWC_FC_ISCR0_8                   (DWC_OFFSET_MASK + 0x10AA)
+#define HDMITX_DWC_FC_ISCR0_7                   (DWC_OFFSET_MASK + 0x10AB)
+#define HDMITX_DWC_FC_ISCR0_6                   (DWC_OFFSET_MASK + 0x10AC)
+#define HDMITX_DWC_FC_ISCR0_5                   (DWC_OFFSET_MASK + 0x10AD)
+#define HDMITX_DWC_FC_ISCR0_4                   (DWC_OFFSET_MASK + 0x10AE)
+#define HDMITX_DWC_FC_ISCR0_3                   (DWC_OFFSET_MASK + 0x10AF)
+#define HDMITX_DWC_FC_ISCR0_2                   (DWC_OFFSET_MASK + 0x10B0)
+#define HDMITX_DWC_FC_ISCR0_1                   (DWC_OFFSET_MASK + 0x10B1)
+#define HDMITX_DWC_FC_ISCR0_0                   (DWC_OFFSET_MASK + 0x10B2)
+/* [  4] spd_auto */
+/* [  3] vsd_auto */
+/* [  2] isrc2_auto */
+/* [  1] isrc1_auto */
+/* [  0] acp_auto */
+#define HDMITX_DWC_FC_DATAUTO0                  (DWC_OFFSET_MASK + 0x10B3)
+#define HDMITX_DWC_FC_DATAUTO1                  (DWC_OFFSET_MASK + 0x10B4)
+#define HDMITX_DWC_FC_DATAUTO2                  (DWC_OFFSET_MASK + 0x10B5)
+#define HDMITX_DWC_FC_DATMAN                    (DWC_OFFSET_MASK + 0x10B6)
+/* [  5] nvbi_auto: insert on Vsync */
+/* [  4] amp_auto: insert on Vsync */
+/* [  3] avi_auto: insert on Vsync */
+/* [  2] gcp_auto: insert on Vsync */
+/* [  1] audi_auto: insert on Vsync */
+/* [  0] acr_auto: insert on CTS update. Assert this bit later to avoid
+ * inital packets with false CTS value
+ */
+#define HDMITX_DWC_FC_DATAUTO3                  (DWC_OFFSET_MASK + 0x10B7)
+#define HDMITX_DWC_FC_RDRB0                     (DWC_OFFSET_MASK + 0x10B8)
+#define HDMITX_DWC_FC_RDRB1                     (DWC_OFFSET_MASK + 0x10B9)
+#define HDMITX_DWC_FC_RDRB2                     (DWC_OFFSET_MASK + 0x10BA)
+#define HDMITX_DWC_FC_RDRB3                     (DWC_OFFSET_MASK + 0x10BB)
+#define HDMITX_DWC_FC_RDRB4                     (DWC_OFFSET_MASK + 0x10BC)
+#define HDMITX_DWC_FC_RDRB5                     (DWC_OFFSET_MASK + 0x10BD)
+#define HDMITX_DWC_FC_RDRB6                     (DWC_OFFSET_MASK + 0x10BE)
+#define HDMITX_DWC_FC_RDRB7                     (DWC_OFFSET_MASK + 0x10BF)
+#define HDMITX_DWC_FC_RDRB8                     (DWC_OFFSET_MASK + 0x10C0)
+#define HDMITX_DWC_FC_RDRB9                     (DWC_OFFSET_MASK + 0x10C1)
+#define HDMITX_DWC_FC_RDRB10                    (DWC_OFFSET_MASK + 0x10C2)
+#define HDMITX_DWC_FC_RDRB11                    (DWC_OFFSET_MASK + 0x10C3)
+/* [  7] AUDI_int_mask */
+/* [  6] ACP_int_mask */
+/* [  5] HBR_int_mask */
+/* [  2] AUDS_int_mask */
+/* [  1] ACR_int_mask */
+/* [  0] NULL_int_mask */
+#define HDMITX_DWC_FC_MASK0                     (DWC_OFFSET_MASK + 0x10D2)
+/* [  7] GMD_int_mask */
+/* [  6] ISRC1_int_mask */
+/* [  5] ISRC2_int_mask */
+/* [  4] VSD_int_mask */
+/* [  3] SPD_int_mask */
+/* [  1] AVI_int_mask */
+/* [  0] GCP_int_mask */
+#define HDMITX_DWC_FC_MASK1                     (DWC_OFFSET_MASK + 0x10D6)
+/* [  1] LowPriority_fifo_full */
+/* [  0] HighPriority_fifo_full */
+#define HDMITX_DWC_FC_MASK2                     (DWC_OFFSET_MASK + 0x10DA)
+/* [7:4] incoming_pr_factor */
+/* [3:0] output_pr_factor */
+#define HDMITX_DWC_FC_PRCONF                    (DWC_OFFSET_MASK + 0x10E0)
+/* [  4] scrambler_ucp_line */
+/* [  0] scrambler_en. Only update this bit once we've sent SCDC message*/
+#define HDMITX_DWC_FC_SCRAMBLER_CTRL            (DWC_OFFSET_MASK + 0x10E1)
+#define HDMITX_DWC_FC_MULTISTREAM_CTRL          (DWC_OFFSET_MASK + 0x10E2)
+/* [  6] nvbi_tx_en */
+/* [  5] amp_tx_en */
+/* [  4] aut_tx_en */
+/* [  3] audi_tx_en */
+/* [  2] avi_tx_en */
+/* [  1] gcp_tx_en */
+/* [  0] acr_tx_en */
+#define HDMITX_DWC_FC_PACKET_TX_EN              (DWC_OFFSET_MASK + 0x10E3)
+/* [  1] actspc_hdlr_tgl */
+/* [  0] actspc_hdlr_en */
+#define HDMITX_DWC_FC_ACTSPC_HDLR_CFG           (DWC_OFFSET_MASK + 0x10E8)
+#define HDMITX_DWC_FC_INVACT_2D_0               (DWC_OFFSET_MASK + 0x10E9)
+/* [3:0] fc_invact_2d_0[11:8] */
+/* [7:0] fc_invact_2d_0[7:0] */
+#define HDMITX_DWC_FC_INVACT_2D_1               (DWC_OFFSET_MASK + 0x10EA)
+
+#define HDMITX_DWC_FC_GMD_STAT                  (DWC_OFFSET_MASK + 0x1100)
+#define HDMITX_DWC_FC_GMD_EN                    (DWC_OFFSET_MASK + 0x1101)
+#define HDMITX_DWC_FC_GMD_UP                    (DWC_OFFSET_MASK + 0x1102)
+#define HDMITX_DWC_FC_GMD_CONF                  (DWC_OFFSET_MASK + 0x1103)
+#define HDMITX_DWC_FC_GMD_HB                    (DWC_OFFSET_MASK + 0x1104)
+#define HDMITX_DWC_FC_GMD_PB0                   (DWC_OFFSET_MASK + 0x1105)
+#define HDMITX_DWC_FC_GMD_PB1                   (DWC_OFFSET_MASK + 0x1106)
+#define HDMITX_DWC_FC_GMD_PB2                   (DWC_OFFSET_MASK + 0x1107)
+#define HDMITX_DWC_FC_GMD_PB3                   (DWC_OFFSET_MASK + 0x1108)
+#define HDMITX_DWC_FC_GMD_PB4                   (DWC_OFFSET_MASK + 0x1109)
+#define HDMITX_DWC_FC_GMD_PB5                   (DWC_OFFSET_MASK + 0x110A)
+#define HDMITX_DWC_FC_GMD_PB6                   (DWC_OFFSET_MASK + 0x110B)
+#define HDMITX_DWC_FC_GMD_PB7                   (DWC_OFFSET_MASK + 0x110C)
+#define HDMITX_DWC_FC_GMD_PB8                   (DWC_OFFSET_MASK + 0x110D)
+#define HDMITX_DWC_FC_GMD_PB9                   (DWC_OFFSET_MASK + 0x110E)
+#define HDMITX_DWC_FC_GMD_PB10                  (DWC_OFFSET_MASK + 0x110F)
+#define HDMITX_DWC_FC_GMD_PB11                  (DWC_OFFSET_MASK + 0x1110)
+#define HDMITX_DWC_FC_GMD_PB12                  (DWC_OFFSET_MASK + 0x1111)
+#define HDMITX_DWC_FC_GMD_PB13                  (DWC_OFFSET_MASK + 0x1112)
+#define HDMITX_DWC_FC_GMD_PB14                  (DWC_OFFSET_MASK + 0x1113)
+#define HDMITX_DWC_FC_GMD_PB15                  (DWC_OFFSET_MASK + 0x1114)
+#define HDMITX_DWC_FC_GMD_PB16                  (DWC_OFFSET_MASK + 0x1115)
+#define HDMITX_DWC_FC_GMD_PB17                  (DWC_OFFSET_MASK + 0x1116)
+#define HDMITX_DWC_FC_GMD_PB18                  (DWC_OFFSET_MASK + 0x1117)
+#define HDMITX_DWC_FC_GMD_PB19                  (DWC_OFFSET_MASK + 0x1118)
+#define HDMITX_DWC_FC_GMD_PB20                  (DWC_OFFSET_MASK + 0x1119)
+#define HDMITX_DWC_FC_GMD_PB21                  (DWC_OFFSET_MASK + 0x111A)
+#define HDMITX_DWC_FC_GMD_PB22                  (DWC_OFFSET_MASK + 0x111B)
+#define HDMITX_DWC_FC_GMD_PB23                  (DWC_OFFSET_MASK + 0x111C)
+#define HDMITX_DWC_FC_GMD_PB24                  (DWC_OFFSET_MASK + 0x111D)
+#define HDMITX_DWC_FC_GMD_PB25                  (DWC_OFFSET_MASK + 0x111E)
+#define HDMITX_DWC_FC_GMD_PB26                  (DWC_OFFSET_MASK + 0x111F)
+#define HDMITX_DWC_FC_GMD_PB27                  (DWC_OFFSET_MASK + 0x1120)
+
+/* Audio Metadata Packet Registers */
+#define HDMITX_DWC_FC_AMP_HB01                  (DWC_OFFSET_MASK + 0x1128)
+#define HDMITX_DWC_FC_AMP_HB02                  (DWC_OFFSET_MASK + 0x1129)
+#define HDMITX_DWC_FC_AMP_PB00                  (DWC_OFFSET_MASK + 0x112A)
+#define HDMITX_DWC_FC_AMP_PB01                  (DWC_OFFSET_MASK + 0x112B)
+#define HDMITX_DWC_FC_AMP_PB02                  (DWC_OFFSET_MASK + 0x112C)
+#define HDMITX_DWC_FC_AMP_PB03                  (DWC_OFFSET_MASK + 0x112D)
+#define HDMITX_DWC_FC_AMP_PB04                  (DWC_OFFSET_MASK + 0x112E)
+#define HDMITX_DWC_FC_AMP_PB05                  (DWC_OFFSET_MASK + 0x112F)
+#define HDMITX_DWC_FC_AMP_PB06                  (DWC_OFFSET_MASK + 0x1130)
+#define HDMITX_DWC_FC_AMP_PB07                  (DWC_OFFSET_MASK + 0x1131)
+#define HDMITX_DWC_FC_AMP_PB08                  (DWC_OFFSET_MASK + 0x1132)
+#define HDMITX_DWC_FC_AMP_PB09                  (DWC_OFFSET_MASK + 0x1133)
+#define HDMITX_DWC_FC_AMP_PB10                  (DWC_OFFSET_MASK + 0x1134)
+#define HDMITX_DWC_FC_AMP_PB11                  (DWC_OFFSET_MASK + 0x1135)
+#define HDMITX_DWC_FC_AMP_PB12                  (DWC_OFFSET_MASK + 0x1136)
+#define HDMITX_DWC_FC_AMP_PB13                  (DWC_OFFSET_MASK + 0x1137)
+#define HDMITX_DWC_FC_AMP_PB14                  (DWC_OFFSET_MASK + 0x1138)
+#define HDMITX_DWC_FC_AMP_PB15                  (DWC_OFFSET_MASK + 0x1139)
+#define HDMITX_DWC_FC_AMP_PB16                  (DWC_OFFSET_MASK + 0x113A)
+#define HDMITX_DWC_FC_AMP_PB17                  (DWC_OFFSET_MASK + 0x113B)
+#define HDMITX_DWC_FC_AMP_PB18                  (DWC_OFFSET_MASK + 0x113C)
+#define HDMITX_DWC_FC_AMP_PB19                  (DWC_OFFSET_MASK + 0x113D)
+#define HDMITX_DWC_FC_AMP_PB20                  (DWC_OFFSET_MASK + 0x113E)
+#define HDMITX_DWC_FC_AMP_PB21                  (DWC_OFFSET_MASK + 0x113F)
+#define HDMITX_DWC_FC_AMP_PB22                  (DWC_OFFSET_MASK + 0x1140)
+#define HDMITX_DWC_FC_AMP_PB23                  (DWC_OFFSET_MASK + 0x1141)
+#define HDMITX_DWC_FC_AMP_PB24                  (DWC_OFFSET_MASK + 0x1142)
+#define HDMITX_DWC_FC_AMP_PB25                  (DWC_OFFSET_MASK + 0x1143)
+#define HDMITX_DWC_FC_AMP_PB26                  (DWC_OFFSET_MASK + 0x1144)
+#define HDMITX_DWC_FC_AMP_PB27                  (DWC_OFFSET_MASK + 0x1145)
+
+/* NTSC VBI Packet Registers */
+#define HDMITX_DWC_FC_NVBI_HB01                 (DWC_OFFSET_MASK + 0x1148)
+#define HDMITX_DWC_FC_NVBI_HB02                 (DWC_OFFSET_MASK + 0x1149)
+#define HDMITX_DWC_FC_NVBI_PB01                 (DWC_OFFSET_MASK + 0x114A)
+#define HDMITX_DWC_FC_NVBI_PB02                 (DWC_OFFSET_MASK + 0x114B)
+#define HDMITX_DWC_FC_NVBI_PB03                 (DWC_OFFSET_MASK + 0x114C)
+#define HDMITX_DWC_FC_NVBI_PB04                 (DWC_OFFSET_MASK + 0x114D)
+#define HDMITX_DWC_FC_NVBI_PB05                 (DWC_OFFSET_MASK + 0x114E)
+#define HDMITX_DWC_FC_NVBI_PB06                 (DWC_OFFSET_MASK + 0x114F)
+#define HDMITX_DWC_FC_NVBI_PB07                 (DWC_OFFSET_MASK + 0x1150)
+#define HDMITX_DWC_FC_NVBI_PB08                 (DWC_OFFSET_MASK + 0x1151)
+#define HDMITX_DWC_FC_NVBI_PB09                 (DWC_OFFSET_MASK + 0x1152)
+#define HDMITX_DWC_FC_NVBI_PB10                 (DWC_OFFSET_MASK + 0x1153)
+#define HDMITX_DWC_FC_NVBI_PB11                 (DWC_OFFSET_MASK + 0x1154)
+#define HDMITX_DWC_FC_NVBI_PB12                 (DWC_OFFSET_MASK + 0x1155)
+#define HDMITX_DWC_FC_NVBI_PB13                 (DWC_OFFSET_MASK + 0x1156)
+#define HDMITX_DWC_FC_NVBI_PB14                 (DWC_OFFSET_MASK + 0x1157)
+#define HDMITX_DWC_FC_NVBI_PB15                 (DWC_OFFSET_MASK + 0x1158)
+#define HDMITX_DWC_FC_NVBI_PB16                 (DWC_OFFSET_MASK + 0x1159)
+#define HDMITX_DWC_FC_NVBI_PB17                 (DWC_OFFSET_MASK + 0x115A)
+#define HDMITX_DWC_FC_NVBI_PB18                 (DWC_OFFSET_MASK + 0x115B)
+#define HDMITX_DWC_FC_NVBI_PB19                 (DWC_OFFSET_MASK + 0x115C)
+#define HDMITX_DWC_FC_NVBI_PB20                 (DWC_OFFSET_MASK + 0x115D)
+#define HDMITX_DWC_FC_NVBI_PB21                 (DWC_OFFSET_MASK + 0x115E)
+#define HDMITX_DWC_FC_NVBI_PB22                 (DWC_OFFSET_MASK + 0x115F)
+#define HDMITX_DWC_FC_NVBI_PB23                 (DWC_OFFSET_MASK + 0x1160)
+#define HDMITX_DWC_FC_NVBI_PB24                 (DWC_OFFSET_MASK + 0x1161)
+#define HDMITX_DWC_FC_NVBI_PB25                 (DWC_OFFSET_MASK + 0x1162)
+#define HDMITX_DWC_FC_NVBI_PB26                 (DWC_OFFSET_MASK + 0x1163)
+#define HDMITX_DWC_FC_NVBI_PB27                 (DWC_OFFSET_MASK + 0x1164)
+#define HDMITX_DWC_FC_DRM_HB01                  (DWC_OFFSET_MASK + 0x1168)
+#define HDMITX_DWC_FC_DRM_HB02                  (DWC_OFFSET_MASK + 0x1169)
+#define HDMITX_DWC_FC_DRM_PB00                  (DWC_OFFSET_MASK + 0x116A)
+#define HDMITX_DWC_FC_DRM_PB01                  (DWC_OFFSET_MASK + 0x116B)
+#define HDMITX_DWC_FC_DRM_PB02                  (DWC_OFFSET_MASK + 0x116C)
+#define HDMITX_DWC_FC_DRM_PB03                  (DWC_OFFSET_MASK + 0x116D)
+#define HDMITX_DWC_FC_DRM_PB04                  (DWC_OFFSET_MASK + 0x116E)
+#define HDMITX_DWC_FC_DRM_PB05                  (DWC_OFFSET_MASK + 0x116F)
+#define HDMITX_DWC_FC_DRM_PB06                  (DWC_OFFSET_MASK + 0x1170)
+#define HDMITX_DWC_FC_DRM_PB07                  (DWC_OFFSET_MASK + 0x1171)
+#define HDMITX_DWC_FC_DRM_PB08                  (DWC_OFFSET_MASK + 0x1172)
+#define HDMITX_DWC_FC_DRM_PB09                  (DWC_OFFSET_MASK + 0x1173)
+#define HDMITX_DWC_FC_DRM_PB10                  (DWC_OFFSET_MASK + 0x1174)
+#define HDMITX_DWC_FC_DRM_PB11                  (DWC_OFFSET_MASK + 0x1175)
+#define HDMITX_DWC_FC_DRM_PB12                  (DWC_OFFSET_MASK + 0x1176)
+#define HDMITX_DWC_FC_DRM_PB13                  (DWC_OFFSET_MASK + 0x1177)
+#define HDMITX_DWC_FC_DRM_PB14                  (DWC_OFFSET_MASK + 0x1178)
+#define HDMITX_DWC_FC_DRM_PB15                  (DWC_OFFSET_MASK + 0x1179)
+#define HDMITX_DWC_FC_DRM_PB16                  (DWC_OFFSET_MASK + 0x117A)
+#define HDMITX_DWC_FC_DRM_PB17                  (DWC_OFFSET_MASK + 0x117B)
+#define HDMITX_DWC_FC_DRM_PB18                  (DWC_OFFSET_MASK + 0x117C)
+#define HDMITX_DWC_FC_DRM_PB19                  (DWC_OFFSET_MASK + 0x117D)
+#define HDMITX_DWC_FC_DRM_PB20                  (DWC_OFFSET_MASK + 0x117E)
+#define HDMITX_DWC_FC_DRM_PB21                  (DWC_OFFSET_MASK + 0x117F)
+#define HDMITX_DWC_FC_DRM_PB22                  (DWC_OFFSET_MASK + 0x1180)
+#define HDMITX_DWC_FC_DRM_PB23                  (DWC_OFFSET_MASK + 0x1181)
+#define HDMITX_DWC_FC_DRM_PB24                  (DWC_OFFSET_MASK + 0x1182)
+#define HDMITX_DWC_FC_DRM_PB25                  (DWC_OFFSET_MASK + 0x1183)
+#define HDMITX_DWC_FC_DRM_PB26                  (DWC_OFFSET_MASK + 0x1184)
+
+#define HDMITX_DWC_FC_DBGFORCE                  (DWC_OFFSET_MASK + 0x1200)
+#define HDMITX_DWC_FC_DBGAUD0CH0                (DWC_OFFSET_MASK + 0x1201)
+#define HDMITX_DWC_FC_DBGAUD1CH0                (DWC_OFFSET_MASK + 0x1202)
+#define HDMITX_DWC_FC_DBGAUD2CH0                (DWC_OFFSET_MASK + 0x1203)
+#define HDMITX_DWC_FC_DBGAUD0CH1                (DWC_OFFSET_MASK + 0x1204)
+#define HDMITX_DWC_FC_DBGAUD1CH1                (DWC_OFFSET_MASK + 0x1205)
+#define HDMITX_DWC_FC_DBGAUD2CH1                (DWC_OFFSET_MASK + 0x1206)
+#define HDMITX_DWC_FC_DBGAUD0CH2                (DWC_OFFSET_MASK + 0x1207)
+#define HDMITX_DWC_FC_DBGAUD1CH2                (DWC_OFFSET_MASK + 0x1208)
+#define HDMITX_DWC_FC_DBGAUD2CH2                (DWC_OFFSET_MASK + 0x1209)
+#define HDMITX_DWC_FC_DBGAUD0CH3                (DWC_OFFSET_MASK + 0x120A)
+#define HDMITX_DWC_FC_DBGAUD1CH3                (DWC_OFFSET_MASK + 0x120B)
+#define HDMITX_DWC_FC_DBGAUD2CH3                (DWC_OFFSET_MASK + 0x120C)
+#define HDMITX_DWC_FC_DBGAUD0CH4                (DWC_OFFSET_MASK + 0x120D)
+#define HDMITX_DWC_FC_DBGAUD1CH4                (DWC_OFFSET_MASK + 0x120E)
+#define HDMITX_DWC_FC_DBGAUD2CH4                (DWC_OFFSET_MASK + 0x120F)
+#define HDMITX_DWC_FC_DBGAUD0CH5                (DWC_OFFSET_MASK + 0x1210)
+#define HDMITX_DWC_FC_DBGAUD1CH5                (DWC_OFFSET_MASK + 0x1211)
+#define HDMITX_DWC_FC_DBGAUD2CH5                (DWC_OFFSET_MASK + 0x1212)
+#define HDMITX_DWC_FC_DBGAUD0CH6                (DWC_OFFSET_MASK + 0x1213)
+#define HDMITX_DWC_FC_DBGAUD1CH6                (DWC_OFFSET_MASK + 0x1214)
+#define HDMITX_DWC_FC_DBGAUD2CH6                (DWC_OFFSET_MASK + 0x1215)
+#define HDMITX_DWC_FC_DBGAUD0CH7                (DWC_OFFSET_MASK + 0x1216)
+#define HDMITX_DWC_FC_DBGAUD1CH7                (DWC_OFFSET_MASK + 0x1217)
+#define HDMITX_DWC_FC_DBGAUD2CH7                (DWC_OFFSET_MASK + 0x1218)
+#define HDMITX_DWC_FC_DBGTMDS0                  (DWC_OFFSET_MASK + 0x1219)
+#define HDMITX_DWC_FC_DBGTMDS1                  (DWC_OFFSET_MASK + 0x121A)
+#define HDMITX_DWC_FC_DBGTMDS2                  (DWC_OFFSET_MASK + 0x121B)
+
+/* HDMI Source PHY Registers */
+#define HDMITX_DWC_PHY_CONF0                    (DWC_OFFSET_MASK + 0x3000)
+#define HDMITX_DWC_PHY_TST0                     (DWC_OFFSET_MASK + 0x3001)
+#define HDMITX_DWC_PHY_TST1                     (DWC_OFFSET_MASK + 0x3002)
+#define HDMITX_DWC_PHY_TST2                     (DWC_OFFSET_MASK + 0x3003)
+#define HDMITX_DWC_PHY_STAT0                    (DWC_OFFSET_MASK + 0x3004)
+#define HDMITX_DWC_PHY_INT0                     (DWC_OFFSET_MASK + 0x3005)
+#define HDMITX_DWC_PHY_MASK0                    (DWC_OFFSET_MASK + 0x3006)
+#define HDMITX_DWC_PHY_POL0                     (DWC_OFFSET_MASK + 0x3007)
+
+/* I2C Master PHY Registers */
+#define HDMITX_DWC_I2CM_PHY_SLAVE               (DWC_OFFSET_MASK + 0x3020)
+#define HDMITX_DWC_I2CM_PHY_ADDRESS             (DWC_OFFSET_MASK + 0x3021)
+#define HDMITX_DWC_I2CM_PHY_DATAO_1             (DWC_OFFSET_MASK + 0x3022)
+#define HDMITX_DWC_I2CM_PHY_DATAO_0             (DWC_OFFSET_MASK + 0x3023)
+#define HDMITX_DWC_I2CM_PHY_DATAI_1             (DWC_OFFSET_MASK + 0x3024)
+#define HDMITX_DWC_I2CM_PHY_DATAI_0             (DWC_OFFSET_MASK + 0x3025)
+#define HDMITX_DWC_I2CM_PHY_OPERATION           (DWC_OFFSET_MASK + 0x3026)
+#define HDMITX_DWC_I2CM_PHY_INT                 (DWC_OFFSET_MASK + 0x3027)
+#define HDMITX_DWC_I2CM_PHY_CTLINT              (DWC_OFFSET_MASK + 0x3028)
+#define HDMITX_DWC_I2CM_PHY_DIV                 (DWC_OFFSET_MASK + 0x3029)
+#define HDMITX_DWC_I2CM_PHY_SOFTRSTZ            (DWC_OFFSET_MASK + 0x302A)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302B)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x302C)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x302D)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x302E)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302F)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x3030)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x3031)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x3032)
+#define HDMITX_DWC_I2CM_PHY_SDA_HOLD            (DWC_OFFSET_MASK + 0x3033)
+
+/* Audio Sampler Registers */
+
+  /* [  7] sw_audio_fifo_rst */
+  /* [  5] 0=select SPDIF; 1=select I2S. */
+  /* [3:0] i2s_in_en: enable it later in test.c */
+
+#define HDMITX_DWC_AUD_CONF0                    (DWC_OFFSET_MASK + 0x3100)
+/* [4:0] i2s_width */
+/* [7:5] i2s_mode: 0=standard I2S mode */
+#define HDMITX_DWC_AUD_CONF1                    (DWC_OFFSET_MASK + 0x3101)
+/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
+/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_INT                      (DWC_OFFSET_MASK + 0x3102)
+  /* [  1] NLPCM */
+#define HDMITX_DWC_AUD_CONF2                    (DWC_OFFSET_MASK + 0x3103)
+
+/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
+ * Enable it later when audio starts.
+ */
+#define HDMITX_DWC_AUD_INT1                     (DWC_OFFSET_MASK + 0x3104)
+
+#define HDMITX_DWC_AUD_N1                       (DWC_OFFSET_MASK + 0x3200)
+#define HDMITX_DWC_AUD_N2                       (DWC_OFFSET_MASK + 0x3201)
+#define HDMITX_DWC_AUD_N3                       (DWC_OFFSET_MASK + 0x3202)
+#define HDMITX_DWC_AUD_CTS1                     (DWC_OFFSET_MASK + 0x3203)
+#define HDMITX_DWC_AUD_CTS2                     (DWC_OFFSET_MASK + 0x3204)
+#define HDMITX_DWC_AUD_CTS3                     (DWC_OFFSET_MASK + 0x3205)
+#define HDMITX_DWC_AUD_INPUTCLKFS               (DWC_OFFSET_MASK + 0x3206)
+/* [  7] sw_audio_fifo_rst */
+#define HDMITX_DWC_AUD_SPDIF0                   (DWC_OFFSET_MASK + 0x3300)
+/* [4:0] spdif_width */
+/* [  7] setnlpcm */
+#define HDMITX_DWC_AUD_SPDIF1                   (DWC_OFFSET_MASK + 0x3301)
+/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
+/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_SPDIFINT                 (DWC_OFFSET_MASK + 0x3302)
+/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_SPDIFINT1                (DWC_OFFSET_MASK + 0x3303)
+
+/* Generic Parallel Audio Interface Registers   (DWC_OFFSET_MASK + 0x3500) */
+/* Audio DMA Registers                          (DWC_OFFSET_MASK + 0x3600) */
+
+/* Main Controller Registers */
+/* [  6] hdcpclk_disable */
+/* [  5] cecclk_disable */
+/* [  4] cscclk_disable */
+/* [  3] audclk_disable */
+/* [  2] prepclk_disable */
+/* [  1] tmdsclk_disable */
+/* [  0] pixelclk_disable */
+#define HDMITX_DWC_MC_CLKDIS                    (DWC_OFFSET_MASK + 0x4001)
+/*
+ * [  7] gpaswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  6] cecswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  4] spdifswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  3] i2sswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  2] prepswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  1] tmdsswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  0] pixelswrst_req: 0=generate reset pulse; 1=no reset.
+ */
+#define HDMITX_DWC_MC_SWRSTZREQ                 (DWC_OFFSET_MASK + 0x4002)
+#define HDMITX_DWC_MC_OPCTRL                    (DWC_OFFSET_MASK + 0x4003)
+/* [  0] CSC enable */
+#define HDMITX_DWC_MC_FLOWCTRL                  (DWC_OFFSET_MASK + 0x4004)
+#define HDMITX_DWC_MC_PHYRSTZ                   (DWC_OFFSET_MASK + 0x4005)
+#define HDMITX_DWC_MC_LOCKONCLOCK               (DWC_OFFSET_MASK + 0x4006)
+
+/* Color Space Converter Registers */
+/* [  7] csc_limit */
+#define HDMITX_DWC_CSC_CFG                      (DWC_OFFSET_MASK + 0x4100)
+#define HDMITX_DWC_CSC_SCALE                    (DWC_OFFSET_MASK + 0x4101)
+#define HDMITX_DWC_CSC_COEF_A1_MSB              (DWC_OFFSET_MASK + 0x4102)
+#define HDMITX_DWC_CSC_COEF_A1_LSB              (DWC_OFFSET_MASK + 0x4103)
+#define HDMITX_DWC_CSC_COEF_A2_MSB              (DWC_OFFSET_MASK + 0x4104)
+#define HDMITX_DWC_CSC_COEF_A2_LSB              (DWC_OFFSET_MASK + 0x4105)
+#define HDMITX_DWC_CSC_COEF_A3_MSB              (DWC_OFFSET_MASK + 0x4106)
+#define HDMITX_DWC_CSC_COEF_A3_LSB              (DWC_OFFSET_MASK + 0x4107)
+#define HDMITX_DWC_CSC_COEF_A4_MSB              (DWC_OFFSET_MASK + 0x4108)
+#define HDMITX_DWC_CSC_COEF_A4_LSB              (DWC_OFFSET_MASK + 0x4109)
+#define HDMITX_DWC_CSC_COEF_B1_MSB              (DWC_OFFSET_MASK + 0x410A)
+#define HDMITX_DWC_CSC_COEF_B1_LSB              (DWC_OFFSET_MASK + 0x410B)
+#define HDMITX_DWC_CSC_COEF_B2_MSB              (DWC_OFFSET_MASK + 0x410C)
+#define HDMITX_DWC_CSC_COEF_B2_LSB              (DWC_OFFSET_MASK + 0x410D)
+#define HDMITX_DWC_CSC_COEF_B3_MSB              (DWC_OFFSET_MASK + 0x410E)
+#define HDMITX_DWC_CSC_COEF_B3_LSB              (DWC_OFFSET_MASK + 0x410F)
+#define HDMITX_DWC_CSC_COEF_B4_MSB              (DWC_OFFSET_MASK + 0x4110)
+#define HDMITX_DWC_CSC_COEF_B4_LSB              (DWC_OFFSET_MASK + 0x4111)
+#define HDMITX_DWC_CSC_COEF_C1_MSB              (DWC_OFFSET_MASK + 0x4112)
+#define HDMITX_DWC_CSC_COEF_C1_LSB              (DWC_OFFSET_MASK + 0x4113)
+#define HDMITX_DWC_CSC_COEF_C2_MSB              (DWC_OFFSET_MASK + 0x4114)
+#define HDMITX_DWC_CSC_COEF_C2_LSB              (DWC_OFFSET_MASK + 0x4115)
+#define HDMITX_DWC_CSC_COEF_C3_MSB              (DWC_OFFSET_MASK + 0x4116)
+#define HDMITX_DWC_CSC_COEF_C3_LSB              (DWC_OFFSET_MASK + 0x4117)
+#define HDMITX_DWC_CSC_COEF_C4_MSB              (DWC_OFFSET_MASK + 0x4118)
+#define HDMITX_DWC_CSC_COEF_C4_LSB              (DWC_OFFSET_MASK + 0x4119)
+#define HDMITX_DWC_CSC_LIMIT_UP_MSB             (DWC_OFFSET_MASK + 0x411A)
+#define HDMITX_DWC_CSC_LIMIT_UP_LSB             (DWC_OFFSET_MASK + 0x411B)
+#define HDMITX_DWC_CSC_LIMIT_DN_MSB             (DWC_OFFSET_MASK + 0x411C)
+#define HDMITX_DWC_CSC_LIMIT_DN_LSB             (DWC_OFFSET_MASK + 0x411D)
+
+/* HDCP Encryption Engine Registers */
+#define HDMITX_DWC_A_HDCPCFG0                   (DWC_SEC_OFFSET_MASK + 0x5000)
+/* [  4] hdcp_lock */
+/* [  3] dissha1check */
+/* [  2] ph2upshiftenc */
+/* [  1] encryptiondisable */
+/* [  0] swresetn. Write 0 to activate, self-clear to 1. */
+#define HDMITX_DWC_A_HDCPCFG1                   (DWC_SEC_OFFSET_MASK + 0x5001)
+#define HDMITX_DWC_A_HDCPOBS0                   (DWC_OFFSET_MASK + 0x5002)
+#define HDMITX_DWC_A_HDCPOBS1                   (DWC_OFFSET_MASK + 0x5003)
+#define HDMITX_DWC_A_HDCPOBS2                   (DWC_OFFSET_MASK + 0x5004)
+#define HDMITX_DWC_A_HDCPOBS3                   (DWC_OFFSET_MASK + 0x5005)
+#define HDMITX_DWC_A_APIINTCLR                  (DWC_OFFSET_MASK + 0x5006)
+#define HDMITX_DWC_A_APIINTSTAT                 (DWC_OFFSET_MASK + 0x5007)
+/* [  7] hdcp_engaged_int_mask */
+/* [  6] hdcp_failed_int_mask */
+/* [  4] i2c_nack_int_mask */
+/* [  3] lost_arbitration_int_mask */
+/* [  2] keepout_error_int_mask */
+/* [  1] ksv_sha1_calc_int_mask */
+/* [  0] ksv_access_int_mask */
+#define HDMITX_DWC_A_APIINTMSK                  (DWC_OFFSET_MASK + 0x5008)
+/* [6:5] unencryptconf */
+/* [  4] dataenpol */
+/* [  3] vsyncpol */
+/* [  1] hsyncpol */
+#define HDMITX_DWC_A_VIDPOLCFG                  (DWC_OFFSET_MASK + 0x5009)
+#define HDMITX_DWC_A_OESSWCFG                   (DWC_OFFSET_MASK + 0x500A)
+#define HDMITX_DWC_A_COREVERLSB                 (DWC_OFFSET_MASK + 0x5014)
+#define HDMITX_DWC_A_COREVERMSB                 (DWC_OFFSET_MASK + 0x5015)
+/* [  3] sha1_fail */
+/* [  2] ksv_ctrl_update */
+/* [  1] Rsvd for read-only ksv_mem_access */
+/* [  0] ksv_mem_request */
+#define HDMITX_DWC_A_KSVMEMCTRL                 (DWC_OFFSET_MASK + 0x5016)
+
+#define HDMITX_DWC_HDCP_BSTATUS_0               (DWC_OFFSET_MASK + 0x5020)
+#define HDMITX_DWC_HDCP_BSTATUS_1               (DWC_OFFSET_MASK + 0x5021)
+#define HDMITX_DWC_HDCP_M0_0                    (DWC_OFFSET_MASK + 0x5022)
+#define HDMITX_DWC_HDCP_M0_1                    (DWC_OFFSET_MASK + 0x5023)
+#define HDMITX_DWC_HDCP_M0_2                    (DWC_OFFSET_MASK + 0x5024)
+#define HDMITX_DWC_HDCP_M0_3                    (DWC_OFFSET_MASK + 0x5025)
+#define HDMITX_DWC_HDCP_M0_4                    (DWC_OFFSET_MASK + 0x5026)
+#define HDMITX_DWC_HDCP_M0_5                    (DWC_OFFSET_MASK + 0x5027)
+#define HDMITX_DWC_HDCP_M0_6                    (DWC_OFFSET_MASK + 0x5028)
+#define HDMITX_DWC_HDCP_M0_7                    (DWC_OFFSET_MASK + 0x5029)
+#define HDMITX_DWC_HDCP_KSV                     (DWC_OFFSET_MASK + 0x502A)
+#define HDMITX_DWC_HDCP_VH                      (DWC_OFFSET_MASK + 0x52A5)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
+#define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
+
+/* HDCP BKSV Registers */
+#define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
+#define HDMITX_DWC_HDCPREG_BKSV1                (DWC_OFFSET_MASK + 0x7801)
+#define HDMITX_DWC_HDCPREG_BKSV2                (DWC_OFFSET_MASK + 0x7802)
+#define HDMITX_DWC_HDCPREG_BKSV3                (DWC_OFFSET_MASK + 0x7803)
+#define HDMITX_DWC_HDCPREG_BKSV4                (DWC_OFFSET_MASK + 0x7804)
+
+/* HDCP AN Registers */
+#define HDMITX_DWC_HDCPREG_ANCONF               (DWC_OFFSET_MASK + 0x7805)
+#define HDMITX_DWC_HDCPREG_AN0                  (DWC_OFFSET_MASK + 0x7806)
+#define HDMITX_DWC_HDCPREG_AN1                  (DWC_OFFSET_MASK + 0x7807)
+#define HDMITX_DWC_HDCPREG_AN2                  (DWC_OFFSET_MASK + 0x7808)
+#define HDMITX_DWC_HDCPREG_AN3                  (DWC_OFFSET_MASK + 0x7809)
+#define HDMITX_DWC_HDCPREG_AN4                  (DWC_OFFSET_MASK + 0x780A)
+#define HDMITX_DWC_HDCPREG_AN5                  (DWC_OFFSET_MASK + 0x780B)
+#define HDMITX_DWC_HDCPREG_AN6                  (DWC_OFFSET_MASK + 0x780C)
+#define HDMITX_DWC_HDCPREG_AN7                  (DWC_OFFSET_MASK + 0x780D)
+#define HDMITX_DWC_HDCPREG_RMLCTL               (DWC_OFFSET_MASK + 0x780E)
+
+/* Encrypted DPK Embedded Storage Registers */
+#define HDMITX_DWC_HDCPREG_RMLSTS               (DWC_OFFSET_MASK + 0x780F)
+#define HDMITX_DWC_HDCPREG_SEED0                (DWC_SEC_OFFSET_MASK + 0x7810)
+#define HDMITX_DWC_HDCPREG_SEED1                (DWC_SEC_OFFSET_MASK + 0x7811)
+#define HDMITX_DWC_HDCPREG_DPK0                 (DWC_SEC_OFFSET_MASK + 0x7812)
+#define HDMITX_DWC_HDCPREG_DPK1                 (DWC_SEC_OFFSET_MASK + 0x7813)
+#define HDMITX_DWC_HDCPREG_DPK2                 (DWC_SEC_OFFSET_MASK + 0x7814)
+#define HDMITX_DWC_HDCPREG_DPK3                 (DWC_SEC_OFFSET_MASK + 0x7815)
+#define HDMITX_DWC_HDCPREG_DPK4                 (DWC_SEC_OFFSET_MASK + 0x7816)
+#define HDMITX_DWC_HDCPREG_DPK5                 (DWC_SEC_OFFSET_MASK + 0x7817)
+#define HDMITX_DWC_HDCPREG_DPK6                 (DWC_SEC_OFFSET_MASK + 0x7818)
+
+/* HDCP22 Registers */
+#define HDMITX_DWC_HDCP22REG_ID                 (DWC_OFFSET_MASK + 0x7900)
+#define HDMITX_DWC_HDCP22REG_CTRL               (DWC_SEC_OFFSET_MASK + 0x7904)
+#define HDMITX_DWC_HDCP22REG_CTRL1              (DWC_OFFSET_MASK + 0x7905)
+#define HDMITX_DWC_HDCP22REG_STS                (DWC_OFFSET_MASK + 0x7908)
+#define HDMITX_DWC_HDCP22REG_MASK               (DWC_OFFSET_MASK + 0x790C)
+#define HDMITX_DWC_HDCP22REG_STAT               (DWC_OFFSET_MASK + 0x790D)
+#define HDMITX_DWC_HDCP22REG_MUTE               (DWC_OFFSET_MASK + 0x790E)
+
+
+/* ********** CEC related ********** */
+
+/* CEC 2.0 Engine Registers */
+#define HDMITX_DWC_CEC_CTRL                     (DWC_OFFSET_MASK + 0x7D00)
+#define HDMITX_DWC_CEC_INTR_MASK                (DWC_OFFSET_MASK + 0x7D02)
+#define HDMITX_DWC_CEC_LADD_LOW                 (DWC_OFFSET_MASK + 0x7D05)
+#define HDMITX_DWC_CEC_LADD_HIGH                (DWC_OFFSET_MASK + 0x7D06)
+#define HDMITX_DWC_CEC_TX_CNT                   (DWC_OFFSET_MASK + 0x7D07)
+#define HDMITX_DWC_CEC_RX_CNT                   (DWC_OFFSET_MASK + 0x7D08)
+#define HDMITX_DWC_CEC_TX_DATA00                (DWC_OFFSET_MASK + 0x7D10)
+#define HDMITX_DWC_CEC_TX_DATA01                (DWC_OFFSET_MASK + 0x7D11)
+#define HDMITX_DWC_CEC_TX_DATA02                (DWC_OFFSET_MASK + 0x7D12)
+#define HDMITX_DWC_CEC_TX_DATA03                (DWC_OFFSET_MASK + 0x7D13)
+#define HDMITX_DWC_CEC_TX_DATA04                (DWC_OFFSET_MASK + 0x7D14)
+#define HDMITX_DWC_CEC_TX_DATA05                (DWC_OFFSET_MASK + 0x7D15)
+#define HDMITX_DWC_CEC_TX_DATA06                (DWC_OFFSET_MASK + 0x7D16)
+#define HDMITX_DWC_CEC_TX_DATA07                (DWC_OFFSET_MASK + 0x7D17)
+#define HDMITX_DWC_CEC_TX_DATA08                (DWC_OFFSET_MASK + 0x7D18)
+#define HDMITX_DWC_CEC_TX_DATA09                (DWC_OFFSET_MASK + 0x7D19)
+#define HDMITX_DWC_CEC_TX_DATA10                (DWC_OFFSET_MASK + 0x7D1A)
+#define HDMITX_DWC_CEC_TX_DATA11                (DWC_OFFSET_MASK + 0x7D1B)
+#define HDMITX_DWC_CEC_TX_DATA12                (DWC_OFFSET_MASK + 0x7D1C)
+#define HDMITX_DWC_CEC_TX_DATA13                (DWC_OFFSET_MASK + 0x7D1D)
+#define HDMITX_DWC_CEC_TX_DATA14                (DWC_OFFSET_MASK + 0x7D1E)
+#define HDMITX_DWC_CEC_TX_DATA15                (DWC_OFFSET_MASK + 0x7D1F)
+#define HDMITX_DWC_CEC_RX_DATA00                (DWC_OFFSET_MASK + 0x7D20)
+#define HDMITX_DWC_CEC_RX_DATA01                (DWC_OFFSET_MASK + 0x7D21)
+#define HDMITX_DWC_CEC_RX_DATA02                (DWC_OFFSET_MASK + 0x7D22)
+#define HDMITX_DWC_CEC_RX_DATA03                (DWC_OFFSET_MASK + 0x7D23)
+#define HDMITX_DWC_CEC_RX_DATA04                (DWC_OFFSET_MASK + 0x7D24)
+#define HDMITX_DWC_CEC_RX_DATA05                (DWC_OFFSET_MASK + 0x7D25)
+#define HDMITX_DWC_CEC_RX_DATA06                (DWC_OFFSET_MASK + 0x7D26)
+#define HDMITX_DWC_CEC_RX_DATA07                (DWC_OFFSET_MASK + 0x7D27)
+#define HDMITX_DWC_CEC_RX_DATA08                (DWC_OFFSET_MASK + 0x7D28)
+#define HDMITX_DWC_CEC_RX_DATA09                (DWC_OFFSET_MASK + 0x7D29)
+#define HDMITX_DWC_CEC_RX_DATA10                (DWC_OFFSET_MASK + 0x7D2A)
+#define HDMITX_DWC_CEC_RX_DATA11                (DWC_OFFSET_MASK + 0x7D2B)
+#define HDMITX_DWC_CEC_RX_DATA12                (DWC_OFFSET_MASK + 0x7D2C)
+#define HDMITX_DWC_CEC_RX_DATA13                (DWC_OFFSET_MASK + 0x7D2D)
+#define HDMITX_DWC_CEC_RX_DATA14                (DWC_OFFSET_MASK + 0x7D2E)
+#define HDMITX_DWC_CEC_RX_DATA15                (DWC_OFFSET_MASK + 0x7D2F)
+#define HDMITX_DWC_CEC_LOCK_BUF                 (DWC_OFFSET_MASK + 0x7D30)
+#define HDMITX_DWC_CEC_WAKEUPCTRL               (DWC_OFFSET_MASK + 0x7D31)
+
+/* I2C Master Registers(E-DDC/SCDC) */
+#define HDMITX_DWC_I2CM_SLAVE                   (DWC_OFFSET_MASK + 0x7E00)
+#define HDMITX_DWC_I2CM_ADDRESS                 (DWC_OFFSET_MASK + 0x7E01)
+#define HDMITX_DWC_I2CM_DATAO                   (DWC_OFFSET_MASK + 0x7E02)
+#define HDMITX_DWC_I2CM_DATAI                   (DWC_OFFSET_MASK + 0x7E03)
+#define HDMITX_DWC_I2CM_OPERATION               (DWC_OFFSET_MASK + 0x7E04)
+/* [  2] done_mask */
+/* [  6] read_req_mask */
+#define HDMITX_DWC_I2CM_INT                     (DWC_OFFSET_MASK + 0x7E05)
+/* [  6] nack_mask */
+/* [  2] arbitration_error_mask */
+#define HDMITX_DWC_I2CM_CTLINT                  (DWC_OFFSET_MASK + 0x7E06)
+/* [  3] i2c_fast_mode: 0=standard mode; 1=fast mode. */
+#define HDMITX_DWC_I2CM_DIV                     (DWC_OFFSET_MASK + 0x7E07)
+#define HDMITX_DWC_I2CM_SEGADDR                 (DWC_OFFSET_MASK + 0x7E08)
+#define HDMITX_DWC_I2CM_SOFTRSTZ                (DWC_OFFSET_MASK + 0x7E09)
+#define HDMITX_DWC_I2CM_SEGPTR                  (DWC_OFFSET_MASK + 0x7E0A)
+/* I2CM_SS_SCL_HCNT = RndUp(min_ss_scl_htime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_SS_SCL_LCNT = RndUp(min_ss_scl_ltime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_FS_SCL_HCNT = RndUp(min_fs_scl_htime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_FS_SCL_LCNT = RndUp(min_fs_scl_ltime*Freq(sfrclkInMHz)/1000) */
+/* Where Freq(sfrclkInMHz)=24; */
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0B)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E0C)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E0D)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E0E)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0F)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E10)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E11)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E12)
+#define HDMITX_DWC_I2CM_SDA_HOLD                (DWC_OFFSET_MASK + 0x7E13)
+/* [  5] updt_rd_vsyncpoll_en */
+/* [  4] read_request_en */
+/* [  0] read_update */
+#define HDMITX_DWC_I2CM_SCDC_UPDATE             (DWC_OFFSET_MASK + 0x7E14)
+#define HDMITX_DWC_I2CM_READ_BUFF0              (DWC_OFFSET_MASK + 0x7E20)
+#define HDMITX_DWC_I2CM_READ_BUFF1              (DWC_OFFSET_MASK + 0x7E21)
+#define HDMITX_DWC_I2CM_READ_BUFF2              (DWC_OFFSET_MASK + 0x7E22)
+#define HDMITX_DWC_I2CM_READ_BUFF3              (DWC_OFFSET_MASK + 0x7E23)
+#define HDMITX_DWC_I2CM_READ_BUFF4              (DWC_OFFSET_MASK + 0x7E24)
+#define HDMITX_DWC_I2CM_READ_BUFF5              (DWC_OFFSET_MASK + 0x7E25)
+#define HDMITX_DWC_I2CM_READ_BUFF6              (DWC_OFFSET_MASK + 0x7E26)
+#define HDMITX_DWC_I2CM_READ_BUFF7              (DWC_OFFSET_MASK + 0x7E27)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE0            (DWC_OFFSET_MASK + 0x7E30)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE1            (DWC_OFFSET_MASK + 0x7E31)
+
+#endif  /* __HDMI_TX_REG_H_ */
diff --git a/include/amlogic/media/vout/hdmitx/mach_reg.h b/include/amlogic/media/vout/hdmitx/mach_reg.h
new file mode 100644
index 0000000000..865eddb198
--- /dev/null
+++ b/include/amlogic/media/vout/hdmitx/mach_reg.h
@@ -0,0 +1,625 @@
+#ifndef __MACH_REG_H__
+#define __MACH_REG_H__
+
+/*
+ * RePacket HDMI related registers rd/wr
+ */
+struct reg_map {
+        uint32_t base_addr;
+};
+
+#define CBUS_REG_IDX            0
+#define PERIPHS_REG_IDX         1
+#define VCBUS_REG_IDX           2
+#define AOBUS_REG_IDX           3
+#define HHI_REG_IDX             4
+#define RESET_CBUS_REG_IDX      5
+#define HDMITX_REG_IDX          6
+#define HDMITX_SEC_REG_IDX      7
+#define ELP_ESM_REG_IDX         8
+/* new added in SC2 */
+#define ANACTRL_REG_IDX		9
+#define PWRCTRL_REG_IDX		10
+#define RESETCTRL_REG_IDX	11
+#define SYSCTRL_REG_IDX		12
+#define REG_IDX_END		13
+
+#define BASE_REG_OFFSET              24
+
+#define PERIPHS_REG_ADDR(reg) \
+	((PERIPHS_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define VCBUS_REG_ADDR(reg) \
+	((VCBUS_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define AOBUS_REG_ADDR(reg) \
+	((AOBUS_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define HHI_REG_ADDR(reg) \
+	((HHI_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define RESET_CBUS_REG_ADDR(reg) \
+	((RESET_CBUS_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define HDMITX_SEC_REG_ADDR(reg) \
+	((HDMITX_SEC_REG_IDX << BASE_REG_OFFSET) + (reg))/*DWC*/
+#define HDMITX_REG_ADDR(reg) \
+        ((HDMITX_REG_IDX << BASE_REG_OFFSET) + (reg))/*TOP*/
+#define ELP_ESM_REG_ADDR(reg) \
+	((ELP_ESM_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define ANACTRL_REG_ADDR(reg) \
+	((ANACTRL_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define PWRCTRL_REG_ADDR(reg) \
+	((PWRCTRL_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define RESETCTRL_REG_ADDR(reg) \
+	((RESETCTRL_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+#define SYSCTRL_REG_ADDR(reg) \
+	((SYSCTRL_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+
+struct reg_s {
+	unsigned int reg;
+	unsigned int val;
+};
+
+unsigned int hd_read_reg(unsigned int addr);
+void hd_write_reg(unsigned int addr, unsigned int val);
+void hd_set_reg_bits(unsigned int addr, unsigned int value, unsigned int offset,
+	unsigned int len);
+uint32_t hd_get_paddr(uint32_t addr);
+unsigned int hdmitx_rd_reg(unsigned int addr);
+void hdmitx_wr_reg(unsigned int addr, unsigned int data);
+void hdmitx_set_reg_bits(unsigned int addr, unsigned int value,
+        unsigned int offset, unsigned int len);
+void hdmitx_poll_reg(unsigned int addr, unsigned int val, unsigned long timeout);
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xfe000000 */
+#define CLKCTRL_SYS_CLK_EN0_REG2 0x0013
+#define P_CLKCTRL_SYS_CLK_EN0_REG2 HHI_REG_ADDR(CLKCTRL_SYS_CLK_EN0_REG2)
+#define CLKCTRL_VID_CLK_CTRL 0x0030
+#define P_CLKCTRL_VID_CLK_CTRL HHI_REG_ADDR(CLKCTRL_VID_CLK_CTRL)
+#define CLKCTRL_VID_CLK_CTRL2 0x0031
+#define P_CLKCTRL_VID_CLK_CTRL2 HHI_REG_ADDR(CLKCTRL_VID_CLK_CTRL2)
+#define CLKCTRL_VID_CLK_DIV 0x0032
+#define P_CLKCTRL_VID_CLK_DIV HHI_REG_ADDR(CLKCTRL_VID_CLK_DIV)
+#define CLKCTRL_HDMI_CLK_CTRL 0x0038
+#define P_CLKCTRL_HDMI_CLK_CTRL HHI_REG_ADDR(CLKCTRL_HDMI_CLK_CTRL)
+#define CLKCTRL_VID_PLL_CLK_DIV 0x0039
+#define P_CLKCTRL_VID_PLL_CLK_DIV HHI_REG_ADDR(CLKCTRL_VID_PLL_CLK_DIV)
+#define CLKCTRL_HDCP22_CLK_CTRL 0x0040
+#define P_CLKCTRL_HDCP22_CLK_CTRL HHI_REG_ADDR(CLKCTRL_HDCP22_CLK_CTRL)
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xfe002000 */
+#define RESETCTRL_RESET0 0x0000
+#define P_RESETCTRL_RESET0 RESETCTRL_REG_ADDR(RESETCTRL_RESET0)
+#define RESETCTRL_RESET2 0x0002
+#define P_RESETCTRL_RESET2 RESETCTRL_REG_ADDR(RESETCTRL_RESET2)
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xfe004000 */
+#define PADCTRL_PIN_MUX_REGB 0x0b
+#define P_PADCTRL_PIN_MUX_REGB PERIPHS_REG_ADDR(PADCTRL_PIN_MUX_REGB)
+#define PADCTRL_GPIOH_I 0x50
+#define P_PADCTRL_GPIOH_I PERIPHS_REG_ADDR(PADCTRL_GPIOH_I)
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xfe008000 */
+#define ANACTRL_HDMIPLL_CTRL0 0x0070
+#define P_ANACTRL_HDMIPLL_CTRL0 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL0)
+#define ANACTRL_HDMIPLL_CTRL1 0x0071
+#define P_ANACTRL_HDMIPLL_CTRL1 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL1)
+#define ANACTRL_HDMIPLL_CTRL2 0x0072
+#define P_ANACTRL_HDMIPLL_CTRL2 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL2)
+#define ANACTRL_HDMIPLL_CTRL3 0x0073
+#define P_ANACTRL_HDMIPLL_CTRL3 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL3)
+#define ANACTRL_HDMIPLL_CTRL4 0x0074
+#define P_ANACTRL_HDMIPLL_CTRL4 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL4)
+#define ANACTRL_HDMIPLL_CTRL5 0x0075
+#define P_ANACTRL_HDMIPLL_CTRL5 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL5)
+#define ANACTRL_HDMIPLL_CTRL6 0x0076
+#define P_ANACTRL_HDMIPLL_CTRL6 ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_CTRL6)
+#define ANACTRL_HDMIPLL_STS 0x0077
+#define P_ANACTRL_HDMIPLL_STS ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_STS)
+#define ANACTRL_HDMIPLL_VLOCK 0x0079
+#define P_ANACTRL_HDMIPLL_VLOCK ANACTRL_REG_ADDR(ANACTRL_HDMIPLL_VLOCK)
+#define ANACTRL_HDMIPHY_CTRL0 0x0080
+#define P_ANACTRL_HDMIPHY_CTRL0 ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_CTRL0)
+#define ANACTRL_HDMIPHY_CTRL1 0x0081
+#define P_ANACTRL_HDMIPHY_CTRL1 ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_CTRL1)
+#define ANACTRL_HDMIPHY_CTRL2 0x0082
+#define P_ANACTRL_HDMIPHY_CTRL2 ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_CTRL2)
+#define ANACTRL_HDMIPHY_CTRL3 0x0083
+#define P_ANACTRL_HDMIPHY_CTRL3 ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_CTRL3)
+#define ANACTRL_HDMIPHY_CTRL4 0x0084
+#define P_ANACTRL_HDMIPHY_CTRL4 ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_CTRL4)
+#define ANACTRL_HDMIPHY_CTRL5 0x0085
+#define P_ANACTRL_HDMIPHY_CTRL5 ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_CTRL5)
+#define ANACTRL_HDMIPHY_STS 0x0086
+#define P_ANACTRL_HDMIPHY_STS ANACTRL_REG_ADDR(ANACTRL_HDMIPHY_STS)
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xfe00c000 */
+#define PWRCTRL_MEM_PD11 0x001b
+#define P_PWRCTRL_MEM_PD11 PWRCTRL_REG_ADDR(PWRCTRL_MEM_PD11)
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xfe010000 */
+#define SYSCTRL_DEBUG_REG0 0x90
+#define P_SYSCTRL_DEBUG_REG0 SYSCTRL_REG_ADDR(SYSCTRL_DEBUG_REG0)
+
+/* REG_BASE:  REGISTER_BASE_ADDR = 0xff000000 */
+#define VENC_DVI_SETTING 0x1b62	/* register.h:8014 */
+#define P_VENC_DVI_SETTING VCBUS_REG_ADDR(VENC_DVI_SETTING)
+
+#define VENC_VIDEO_TST_EN 0x1b70
+#define P_VENC_VIDEO_TST_EN VCBUS_REG_ADDR(VENC_VIDEO_TST_EN)
+#define VENC_VIDEO_TST_MDSEL 0x1b71
+#define P_VENC_VIDEO_TST_MDSEL VCBUS_REG_ADDR(VENC_VIDEO_TST_MDSEL)
+#define VENC_VIDEO_TST_Y 0x1b72
+#define P_VENC_VIDEO_TST_Y VCBUS_REG_ADDR(VENC_VIDEO_TST_Y)
+#define VENC_VIDEO_TST_CB 0x1b73
+#define P_VENC_VIDEO_TST_CB VCBUS_REG_ADDR(VENC_VIDEO_TST_CB)
+#define VENC_VIDEO_TST_CR 0x1b74
+#define P_VENC_VIDEO_TST_CR VCBUS_REG_ADDR(VENC_VIDEO_TST_CR)
+#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
+#define P_VENC_VIDEO_TST_CLRBAR_STRT VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_STRT)
+#define VENC_VIDEO_TST_CLRBAR_WIDTH 0x1b76
+#define P_VENC_VIDEO_TST_CLRBAR_WIDTH \
+		VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_WIDTH)
+#define VENC_VIDEO_TST_VDCNT_STSET 0x1b77
+#define P_VENC_VIDEO_TST_VDCNT_STSET VCBUS_REG_ADDR(VENC_VIDEO_TST_VDCNT_STSET)
+#define VENC_VDAC_SETTING 0x1b7e
+#define P_VENC_VDAC_SETTING VCBUS_REG_ADDR(VENC_VDAC_SETTING)
+#define ENCP_VIDEO_EN 0x1b80	/* register.h:8078 */
+#define P_ENCP_VIDEO_EN VCBUS_REG_ADDR(ENCP_VIDEO_EN)
+#define ENCP_VIDEO_SYNC_MODE 0x1b81	/* register.h:8079 */
+#define P_ENCP_VIDEO_SYNC_MODE VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_MODE)
+#define ENCP_MACV_EN 0x1b82	/* register.h:8080 */
+#define P_ENCP_MACV_EN VCBUS_REG_ADDR(ENCP_MACV_EN)
+#define ENCP_VIDEO_Y_SCL 0x1b83	/* register.h:8081 */
+#define P_ENCP_VIDEO_Y_SCL VCBUS_REG_ADDR(ENCP_VIDEO_Y_SCL)
+#define ENCP_VIDEO_PB_SCL 0x1b84	/* register.h:8082 */
+#define P_ENCP_VIDEO_PB_SCL VCBUS_REG_ADDR(ENCP_VIDEO_PB_SCL)
+#define ENCP_VIDEO_PR_SCL 0x1b85	/* register.h:8083 */
+#define P_ENCP_VIDEO_PR_SCL VCBUS_REG_ADDR(ENCP_VIDEO_PR_SCL)
+#define ENCP_VIDEO_SYNC_SCL 0x1b86	/* register.h:8084 */
+#define P_ENCP_VIDEO_SYNC_SCL VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_SCL)
+#define ENCP_VIDEO_MACV_SCL 0x1b87	/* register.h:8085 */
+#define P_ENCP_VIDEO_MACV_SCL VCBUS_REG_ADDR(ENCP_VIDEO_MACV_SCL)
+#define ENCP_VIDEO_Y_OFFST 0x1b88	/* register.h:8086 */
+#define P_ENCP_VIDEO_Y_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_Y_OFFST)
+#define ENCP_VIDEO_PB_OFFST 0x1b89	/* register.h:8087 */
+#define P_ENCP_VIDEO_PB_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_PB_OFFST)
+#define ENCP_VIDEO_PR_OFFST 0x1b8a	/* register.h:8088 */
+#define P_ENCP_VIDEO_PR_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_PR_OFFST)
+#define ENCP_VIDEO_SYNC_OFFST 0x1b8b	/* register.h:8089 */
+#define P_ENCP_VIDEO_SYNC_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_OFFST)
+#define ENCP_VIDEO_MACV_OFFST 0x1b8c	/* register.h:8090 */
+#define P_ENCP_VIDEO_MACV_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_MACV_OFFST)
+#define ENCP_VIDEO_MODE 0x1b8d	/* register.h:8092 */
+#define P_ENCP_VIDEO_MODE VCBUS_REG_ADDR(ENCP_VIDEO_MODE)
+#define ENCP_VIDEO_MODE_ADV 0x1b8e	/* register.h:8093 */
+#define P_ENCP_VIDEO_MODE_ADV VCBUS_REG_ADDR(ENCP_VIDEO_MODE_ADV)
+#define ENCP_DBG_PX_RST 0x1b90	/* register.h:8095 */
+#define P_ENCP_DBG_PX_RST VCBUS_REG_ADDR(ENCP_DBG_PX_RST)
+#define ENCP_DBG_LN_RST 0x1b91	/* register.h:8096 */
+#define P_ENCP_DBG_LN_RST VCBUS_REG_ADDR(ENCP_DBG_LN_RST)
+#define ENCP_DBG_PX_INT 0x1b92	/* register.h:8097 */
+#define P_ENCP_DBG_PX_INT VCBUS_REG_ADDR(ENCP_DBG_PX_INT)
+#define ENCP_DBG_LN_INT 0x1b93	/* register.h:8098 */
+#define P_ENCP_DBG_LN_INT VCBUS_REG_ADDR(ENCP_DBG_LN_INT)
+#define ENCP_VIDEO_YFP1_HTIME 0x1b94	/* register.h:8100 */
+#define P_ENCP_VIDEO_YFP1_HTIME VCBUS_REG_ADDR(ENCP_VIDEO_YFP1_HTIME)
+#define ENCP_VIDEO_YFP2_HTIME 0x1b95	/* register.h:8101 */
+#define P_ENCP_VIDEO_YFP2_HTIME VCBUS_REG_ADDR(ENCP_VIDEO_YFP2_HTIME)
+#define ENCP_VIDEO_YC_DLY 0x1b96	/* register.h:8102 */
+#define P_ENCP_VIDEO_YC_DLY VCBUS_REG_ADDR(ENCP_VIDEO_YC_DLY)
+#define ENCP_VIDEO_MAX_PXCNT 0x1b97	/* register.h:8103 */
+#define P_ENCP_VIDEO_MAX_PXCNT VCBUS_REG_ADDR(ENCP_VIDEO_MAX_PXCNT)
+#define ENCP_VIDEO_HSPULS_BEGIN 0x1b98	/* register.h:8104 */
+#define P_ENCP_VIDEO_HSPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_BEGIN)
+#define ENCP_VIDEO_HSPULS_END 0x1b99	/* register.h:8105 */
+#define P_ENCP_VIDEO_HSPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_END)
+#define ENCP_VIDEO_HSPULS_SWITCH 0x1b9a	/* register.h:8106 */
+#define P_ENCP_VIDEO_HSPULS_SWITCH VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_SWITCH)
+#define ENCP_VIDEO_VSPULS_BEGIN 0x1b9b	/* register.h:8107 */
+#define P_ENCP_VIDEO_VSPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_BEGIN)
+#define ENCP_VIDEO_VSPULS_END 0x1b9c	/* register.h:8108 */
+#define P_ENCP_VIDEO_VSPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_END)
+#define ENCP_VIDEO_VSPULS_BLINE 0x1b9d	/* register.h:8109 */
+#define P_ENCP_VIDEO_VSPULS_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_BLINE)
+#define ENCP_VIDEO_VSPULS_ELINE 0x1b9e	/* register.h:8110 */
+#define P_ENCP_VIDEO_VSPULS_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_ELINE)
+#define ENCP_VIDEO_EQPULS_BEGIN 0x1b9f	/* register.h:8111 */
+#define P_ENCP_VIDEO_EQPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_BEGIN)
+#define ENCP_VIDEO_EQPULS_END 0x1ba0	/* register.h:8112 */
+#define P_ENCP_VIDEO_EQPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_END)
+#define ENCP_VIDEO_EQPULS_BLINE 0x1ba1	/* register.h:8113 */
+#define P_ENCP_VIDEO_EQPULS_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_BLINE)
+#define ENCP_VIDEO_EQPULS_ELINE 0x1ba2	/* register.h:8114 */
+#define P_ENCP_VIDEO_EQPULS_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_ELINE)
+#define ENCP_VIDEO_HAVON_END 0x1ba3	/* register.h:8115 */
+#define P_ENCP_VIDEO_HAVON_END VCBUS_REG_ADDR(ENCP_VIDEO_HAVON_END)
+#define ENCP_VIDEO_HAVON_BEGIN 0x1ba4	/* register.h:8116 */
+#define P_ENCP_VIDEO_HAVON_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HAVON_BEGIN)
+#define ENCP_VIDEO_VAVON_ELINE 0x1baf	/* register.h:8117 */
+#define P_ENCP_VIDEO_VAVON_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VAVON_ELINE)
+#define ENCP_VIDEO_VAVON_BLINE 0x1ba6	/* register.h:8118 */
+#define P_ENCP_VIDEO_VAVON_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VAVON_BLINE)
+#define ENCP_VIDEO_HSO_BEGIN 0x1ba7	/* register.h:8119 */
+#define P_ENCP_VIDEO_HSO_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HSO_BEGIN)
+#define ENCP_VIDEO_HSO_END 0x1ba8	/* register.h:8120 */
+#define P_ENCP_VIDEO_HSO_END VCBUS_REG_ADDR(ENCP_VIDEO_HSO_END)
+#define ENCP_VIDEO_VSO_BEGIN 0x1ba9	/* register.h:8121 */
+#define P_ENCP_VIDEO_VSO_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BEGIN)
+#define ENCP_VIDEO_VSO_END 0x1baa	/* register.h:8122 */
+#define P_ENCP_VIDEO_VSO_END VCBUS_REG_ADDR(ENCP_VIDEO_VSO_END)
+#define ENCP_VIDEO_VSO_BLINE 0x1bab	/* register.h:8123 */
+#define P_ENCP_VIDEO_VSO_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BLINE)
+#define ENCP_VIDEO_VSO_ELINE 0x1bac	/* register.h:8124 */
+#define P_ENCP_VIDEO_VSO_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VSO_ELINE)
+#define ENCP_VIDEO_SYNC_WAVE_CURVE 0x1bad	/* register.h:8125 */
+#define P_ENCP_VIDEO_SYNC_WAVE_CURVE VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_WAVE_CURVE)
+#define ENCP_VIDEO_MAX_LNCNT 0x1bae	/* register.h:8126 */
+#define P_ENCP_VIDEO_MAX_LNCNT VCBUS_REG_ADDR(ENCP_VIDEO_MAX_LNCNT)
+#define ENCP_VIDEO_SY_VAL 0x1bb0	/* register.h:8127 */
+#define P_ENCP_VIDEO_SY_VAL VCBUS_REG_ADDR(ENCP_VIDEO_SY_VAL)
+#define ENCP_VIDEO_SY2_VAL 0x1bb1	/* register.h:8128 */
+#define P_ENCP_VIDEO_SY2_VAL VCBUS_REG_ADDR(ENCP_VIDEO_SY2_VAL)
+#define ENCP_VIDEO_BLANKY_VAL 0x1bb2	/* register.h:8129 */
+#define P_ENCP_VIDEO_BLANKY_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKY_VAL)
+#define ENCP_VIDEO_BLANKPB_VAL 0x1bb3	/* register.h:8130 */
+#define P_ENCP_VIDEO_BLANKPB_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKPB_VAL)
+#define ENCP_VIDEO_BLANKPR_VAL 0x1bb4	/* register.h:8131 */
+#define P_ENCP_VIDEO_BLANKPR_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKPR_VAL)
+#define ENCP_VIDEO_HOFFST 0x1bb5	/* register.h:8132 */
+#define P_ENCP_VIDEO_HOFFST VCBUS_REG_ADDR(ENCP_VIDEO_HOFFST)
+#define ENCP_VIDEO_VOFFST 0x1bb6	/* register.h:8133 */
+#define P_ENCP_VIDEO_VOFFST VCBUS_REG_ADDR(ENCP_VIDEO_VOFFST)
+#define ENCP_VIDEO_RGB_CTRL 0x1bb7	/* register.h:8134 */
+#define P_ENCP_VIDEO_RGB_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_RGB_CTRL)
+#define ENCP_VIDEO_FILT_CTRL 0x1bb8	/* register.h:8135 */
+#define P_ENCP_VIDEO_FILT_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_FILT_CTRL)
+#define ENCP_VIDEO_OFLD_VPEQ_OFST 0x1bb9	/* register.h:8136 */
+#define P_ENCP_VIDEO_OFLD_VPEQ_OFST VCBUS_REG_ADDR(ENCP_VIDEO_OFLD_VPEQ_OFST)
+#define ENCP_VIDEO_OFLD_VOAV_OFST 0x1bba	/* register.h:8137 */
+#define P_ENCP_VIDEO_OFLD_VOAV_OFST VCBUS_REG_ADDR(ENCP_VIDEO_OFLD_VOAV_OFST)
+#define ENCP_VIDEO_MATRIX_CB 0x1bbb	/* register.h:8138 */
+#define P_ENCP_VIDEO_MATRIX_CB VCBUS_REG_ADDR(ENCP_VIDEO_MATRIX_CB)
+#define ENCP_VIDEO_MATRIX_CR 0x1bbc	/* register.h:8139 */
+#define P_ENCP_VIDEO_MATRIX_CR VCBUS_REG_ADDR(ENCP_VIDEO_MATRIX_CR)
+#define ENCP_VIDEO_RGBIN_CTRL 0x1bbd	/* register.h:8140 */
+#define P_ENCP_VIDEO_RGBIN_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_RGBIN_CTRL)
+#define ENCP_MACV_BLANKY_VAL 0x1bc0	/* register.h:8142 */
+#define P_ENCP_MACV_BLANKY_VAL VCBUS_REG_ADDR(ENCP_MACV_BLANKY_VAL)
+#define ENCP_MACV_MAXY_VAL 0x1bc1	/* register.h:8143 */
+#define P_ENCP_MACV_MAXY_VAL VCBUS_REG_ADDR(ENCP_MACV_MAXY_VAL)
+#define ENCP_MACV_1ST_PSSYNC_STRT 0x1bc2	/* register.h:8144 */
+#define P_ENCP_MACV_1ST_PSSYNC_STRT VCBUS_REG_ADDR(ENCP_MACV_1ST_PSSYNC_STRT)
+#define ENCP_MACV_PSSYNC_STRT 0x1bc3	/* register.h:8145 */
+#define P_ENCP_MACV_PSSYNC_STRT VCBUS_REG_ADDR(ENCP_MACV_PSSYNC_STRT)
+#define ENCP_MACV_AGC_STRT 0x1bc4	/* register.h:8146 */
+#define P_ENCP_MACV_AGC_STRT VCBUS_REG_ADDR(ENCP_MACV_AGC_STRT)
+#define ENCP_MACV_AGC_END 0x1bc5	/* register.h:8147 */
+#define P_ENCP_MACV_AGC_END VCBUS_REG_ADDR(ENCP_MACV_AGC_END)
+#define ENCP_MACV_WAVE_END 0x1bc6	/* register.h:8148 */
+#define P_ENCP_MACV_WAVE_END VCBUS_REG_ADDR(ENCP_MACV_WAVE_END)
+#define ENCP_MACV_STRTLINE 0x1bc7	/* register.h:8149 */
+#define P_ENCP_MACV_STRTLINE VCBUS_REG_ADDR(ENCP_MACV_STRTLINE)
+#define ENCP_MACV_ENDLINE 0x1bc8	/* register.h:8150 */
+#define P_ENCP_MACV_ENDLINE VCBUS_REG_ADDR(ENCP_MACV_ENDLINE)
+#define ENCP_MACV_TS_CNT_MAX_L 0x1bc9	/* register.h:8151 */
+#define P_ENCP_MACV_TS_CNT_MAX_L VCBUS_REG_ADDR(ENCP_MACV_TS_CNT_MAX_L)
+#define ENCP_MACV_TS_CNT_MAX_H 0x1bca	/* register.h:8152 */
+#define P_ENCP_MACV_TS_CNT_MAX_H VCBUS_REG_ADDR(ENCP_MACV_TS_CNT_MAX_H)
+#define ENCP_MACV_TIME_DOWN 0x1bcb	/* register.h:8153 */
+#define P_ENCP_MACV_TIME_DOWN VCBUS_REG_ADDR(ENCP_MACV_TIME_DOWN)
+#define ENCP_MACV_TIME_LO 0x1bcc	/* register.h:8154 */
+#define P_ENCP_MACV_TIME_LO VCBUS_REG_ADDR(ENCP_MACV_TIME_LO)
+#define ENCP_MACV_TIME_UP 0x1bcd	/* register.h:8155 */
+#define P_ENCP_MACV_TIME_UP VCBUS_REG_ADDR(ENCP_MACV_TIME_UP)
+#define ENCP_MACV_TIME_RST 0x1bce	/* register.h:8156 */
+#define P_ENCP_MACV_TIME_RST VCBUS_REG_ADDR(ENCP_MACV_TIME_RST)
+#define ENCP_VBI_CTRL 0x1bd0	/* register.h:8158 */
+#define P_ENCP_VBI_CTRL VCBUS_REG_ADDR(ENCP_VBI_CTRL)
+#define ENCP_VBI_SETTING 0x1bd1	/* register.h:8159 */
+#define P_ENCP_VBI_SETTING VCBUS_REG_ADDR(ENCP_VBI_SETTING)
+#define ENCP_VBI_BEGIN 0x1bd2	/* register.h:8160 */
+#define P_ENCP_VBI_BEGIN VCBUS_REG_ADDR(ENCP_VBI_BEGIN)
+#define ENCP_VBI_WIDTH 0x1bd3	/* register.h:8161 */
+#define P_ENCP_VBI_WIDTH VCBUS_REG_ADDR(ENCP_VBI_WIDTH)
+#define ENCP_VBI_HVAL 0x1bd4	/* register.h:8162 */
+#define P_ENCP_VBI_HVAL VCBUS_REG_ADDR(ENCP_VBI_HVAL)
+#define ENCP_VBI_DATA0 0x1bd5	/* register.h:8163 */
+#define P_ENCP_VBI_DATA0 VCBUS_REG_ADDR(ENCP_VBI_DATA0)
+#define ENCP_VBI_DATA1 0x1bd6	/* register.h:8164 */
+#define P_ENCP_VBI_DATA1 VCBUS_REG_ADDR(ENCP_VBI_DATA1)
+
+#define ENCI_VIDEO_MODE 0x1b00	/* register.h:8185 */
+#define P_ENCI_VIDEO_MODE VCBUS_REG_ADDR(ENCI_VIDEO_MODE)
+#define ENCI_VIDEO_MODE_ADV 0x1b01	/* register.h:8186 */
+#define P_ENCI_VIDEO_MODE_ADV VCBUS_REG_ADDR(ENCI_VIDEO_MODE_ADV)
+#define ENCI_VIDEO_FSC_ADJ 0x1b02	/* register.h:8187 */
+#define P_ENCI_VIDEO_FSC_ADJ VCBUS_REG_ADDR(ENCI_VIDEO_FSC_ADJ)
+#define ENCI_VIDEO_BRIGHT 0x1b03	/* register.h:8188 */
+#define P_ENCI_VIDEO_BRIGHT VCBUS_REG_ADDR(ENCI_VIDEO_BRIGHT)
+#define ENCI_VIDEO_CONT 0x1b04	/* register.h:8189 */
+#define P_ENCI_VIDEO_CONT VCBUS_REG_ADDR(ENCI_VIDEO_CONT)
+#define ENCI_VIDEO_SAT 0x1b05	/* register.h:8190 */
+#define P_ENCI_VIDEO_SAT VCBUS_REG_ADDR(ENCI_VIDEO_SAT)
+#define ENCI_VIDEO_HUE 0x1b06	/* register.h:8191 */
+#define P_ENCI_VIDEO_HUE VCBUS_REG_ADDR(ENCI_VIDEO_HUE)
+#define ENCI_VIDEO_SCH 0x1b07	/* register.h:8192 */
+#define P_ENCI_VIDEO_SCH VCBUS_REG_ADDR(ENCI_VIDEO_SCH)
+#define ENCI_SYNC_MODE 0x1b08	/* register.h:8193 */
+#define P_ENCI_SYNC_MODE VCBUS_REG_ADDR(ENCI_SYNC_MODE)
+#define ENCI_SYNC_CTRL 0x1b09	/* register.h:8194 */
+#define P_ENCI_SYNC_CTRL VCBUS_REG_ADDR(ENCI_SYNC_CTRL)
+#define ENCI_SYNC_HSO_BEGIN 0x1b0a	/* register.h:8195 */
+#define P_ENCI_SYNC_HSO_BEGIN VCBUS_REG_ADDR(ENCI_SYNC_HSO_BEGIN)
+#define ENCI_SYNC_HSO_END 0x1b0b	/* register.h:8196 */
+#define P_ENCI_SYNC_HSO_END VCBUS_REG_ADDR(ENCI_SYNC_HSO_END)
+#define ENCI_SYNC_VSO_EVN 0x1b0c	/* register.h:8197 */
+#define P_ENCI_SYNC_VSO_EVN VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVN)
+#define ENCI_SYNC_VSO_ODD 0x1b0d	/* register.h:8198 */
+#define P_ENCI_SYNC_VSO_ODD VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODD)
+#define ENCI_SYNC_VSO_EVNLN 0x1b0e	/* register.h:8199 */
+#define P_ENCI_SYNC_VSO_EVNLN VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVNLN)
+#define ENCI_SYNC_VSO_ODDLN 0x1b0f	/* register.h:8200 */
+#define P_ENCI_SYNC_VSO_ODDLN VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODDLN)
+#define ENCI_SYNC_HOFFST 0x1b10	/* register.h:8201 */
+#define P_ENCI_SYNC_HOFFST VCBUS_REG_ADDR(ENCI_SYNC_HOFFST)
+#define ENCI_SYNC_VOFFST 0x1b11	/* register.h:8202 */
+#define P_ENCI_SYNC_VOFFST VCBUS_REG_ADDR(ENCI_SYNC_VOFFST)
+#define ENCI_SYNC_ADJ 0x1b12	/* register.h:8203 */
+#define P_ENCI_SYNC_ADJ VCBUS_REG_ADDR(ENCI_SYNC_ADJ)
+#define ENCI_RGB_SETTING 0x1b13	/* register.h:8204 */
+#define P_ENCI_RGB_SETTING VCBUS_REG_ADDR(ENCI_RGB_SETTING)
+#define ENCI_DE_H_BEGIN 0x1b16	/* register.h:8207 */
+#define P_ENCI_DE_H_BEGIN VCBUS_REG_ADDR(ENCI_DE_H_BEGIN)
+#define ENCI_DE_H_END 0x1b17	/* register.h:8208 */
+#define P_ENCI_DE_H_END VCBUS_REG_ADDR(ENCI_DE_H_END)
+#define ENCI_DE_V_BEGIN_EVEN 0x1b18	/* register.h:8209 */
+#define P_ENCI_DE_V_BEGIN_EVEN VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_EVEN)
+#define ENCI_DE_V_END_EVEN 0x1b19	/* register.h:8210 */
+#define P_ENCI_DE_V_END_EVEN VCBUS_REG_ADDR(ENCI_DE_V_END_EVEN)
+#define ENCI_DE_V_BEGIN_ODD 0x1b1a	/* register.h:8211 */
+#define P_ENCI_DE_V_BEGIN_ODD VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_ODD)
+#define ENCI_DE_V_END_ODD 0x1b1b	/* register.h:8212 */
+#define P_ENCI_DE_V_END_ODD VCBUS_REG_ADDR(ENCI_DE_V_END_ODD)
+#define ENCI_VBI_SETTING 0x1b20	/* register.h:8213 */
+#define P_ENCI_VBI_SETTING VCBUS_REG_ADDR(ENCI_VBI_SETTING)
+#define ENCI_VBI_CCDT_EVN 0x1b21	/* register.h:8214 */
+#define P_ENCI_VBI_CCDT_EVN VCBUS_REG_ADDR(ENCI_VBI_CCDT_EVN)
+#define ENCI_VBI_CCDT_ODD 0x1b22	/* register.h:8215 */
+#define P_ENCI_VBI_CCDT_ODD VCBUS_REG_ADDR(ENCI_VBI_CCDT_ODD)
+#define ENCI_VBI_CC525_LN 0x1b23	/* register.h:8216 */
+#define P_ENCI_VBI_CC525_LN VCBUS_REG_ADDR(ENCI_VBI_CC525_LN)
+#define ENCI_VBI_CC625_LN 0x1b24	/* register.h:8217 */
+#define P_ENCI_VBI_CC625_LN VCBUS_REG_ADDR(ENCI_VBI_CC625_LN)
+#define ENCI_VBI_WSSDT 0x1b25	/* register.h:8218 */
+#define P_ENCI_VBI_WSSDT VCBUS_REG_ADDR(ENCI_VBI_WSSDT)
+#define ENCI_VBI_WSS_LN 0x1b26	/* register.h:8219 */
+#define P_ENCI_VBI_WSS_LN VCBUS_REG_ADDR(ENCI_VBI_WSS_LN)
+#define ENCI_VBI_CGMSDT_L 0x1b27	/* register.h:8220 */
+#define P_ENCI_VBI_CGMSDT_L VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_L)
+#define ENCI_VBI_CGMSDT_H 0x1b28	/* register.h:8221 */
+#define P_ENCI_VBI_CGMSDT_H VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_H)
+#define ENCI_VBI_CGMS_LN 0x1b29	/* register.h:8222 */
+#define P_ENCI_VBI_CGMS_LN VCBUS_REG_ADDR(ENCI_VBI_CGMS_LN)
+#define ENCI_VBI_TTX_HTIME 0x1b2a	/* register.h:8223 */
+#define P_ENCI_VBI_TTX_HTIME VCBUS_REG_ADDR(ENCI_VBI_TTX_HTIME)
+#define ENCI_VBI_TTX_LN 0x1b2b	/* register.h:8224 */
+#define P_ENCI_VBI_TTX_LN VCBUS_REG_ADDR(ENCI_VBI_TTX_LN)
+#define ENCI_VBI_TTXDT0 0x1b2c	/* register.h:8225 */
+#define P_ENCI_VBI_TTXDT0 VCBUS_REG_ADDR(ENCI_VBI_TTXDT0)
+#define ENCI_VBI_TTXDT1 0x1b2d	/* register.h:8226 */
+#define P_ENCI_VBI_TTXDT1 VCBUS_REG_ADDR(ENCI_VBI_TTXDT1)
+#define ENCI_VBI_TTXDT2 0x1b2e	/* register.h:8227 */
+#define P_ENCI_VBI_TTXDT2 VCBUS_REG_ADDR(ENCI_VBI_TTXDT2)
+#define ENCI_VBI_TTXDT3 0x1b2f	/* register.h:8228 */
+#define P_ENCI_VBI_TTXDT3 VCBUS_REG_ADDR(ENCI_VBI_TTXDT3)
+#define ENCI_MACV_N0 0x1b30	/* register.h:8229 */
+#define P_ENCI_MACV_N0 VCBUS_REG_ADDR(ENCI_MACV_N0)
+#define ENCI_MACV_N1 0x1b31	/* register.h:8230 */
+#define P_ENCI_MACV_N1 VCBUS_REG_ADDR(ENCI_MACV_N1)
+#define ENCI_MACV_N2 0x1b32	/* register.h:8231 */
+#define P_ENCI_MACV_N2 VCBUS_REG_ADDR(ENCI_MACV_N2)
+#define ENCI_MACV_N3 0x1b33	/* register.h:8232 */
+#define P_ENCI_MACV_N3 VCBUS_REG_ADDR(ENCI_MACV_N3)
+#define ENCI_MACV_N4 0x1b34	/* register.h:8233 */
+#define P_ENCI_MACV_N4 VCBUS_REG_ADDR(ENCI_MACV_N4)
+#define ENCI_MACV_N5 0x1b35	/* register.h:8234 */
+#define P_ENCI_MACV_N5 VCBUS_REG_ADDR(ENCI_MACV_N5)
+#define ENCI_MACV_N6 0x1b36	/* register.h:8235 */
+#define P_ENCI_MACV_N6 VCBUS_REG_ADDR(ENCI_MACV_N6)
+#define ENCI_MACV_N7 0x1b37	/* register.h:8236 */
+#define P_ENCI_MACV_N7 VCBUS_REG_ADDR(ENCI_MACV_N7)
+#define ENCI_MACV_N8 0x1b38	/* register.h:8237 */
+#define P_ENCI_MACV_N8 VCBUS_REG_ADDR(ENCI_MACV_N8)
+#define ENCI_MACV_N9 0x1b39	/* register.h:8238 */
+#define P_ENCI_MACV_N9 VCBUS_REG_ADDR(ENCI_MACV_N9)
+#define ENCI_MACV_N10 0x1b3a	/* register.h:8239 */
+#define P_ENCI_MACV_N10 VCBUS_REG_ADDR(ENCI_MACV_N10)
+#define ENCI_MACV_N11 0x1b3b	/* register.h:8240 */
+#define P_ENCI_MACV_N11 VCBUS_REG_ADDR(ENCI_MACV_N11)
+#define ENCI_MACV_N12 0x1b3c	/* register.h:8241 */
+#define P_ENCI_MACV_N12 VCBUS_REG_ADDR(ENCI_MACV_N12)
+#define ENCI_MACV_N13 0x1b3d	/* register.h:8242 */
+#define P_ENCI_MACV_N13 VCBUS_REG_ADDR(ENCI_MACV_N13)
+#define ENCI_MACV_N14 0x1b3e	/* register.h:8243 */
+#define P_ENCI_MACV_N14 VCBUS_REG_ADDR(ENCI_MACV_N14)
+#define ENCI_MACV_N15 0x1b3f	/* register.h:8244 */
+#define P_ENCI_MACV_N15 VCBUS_REG_ADDR(ENCI_MACV_N15)
+#define ENCI_MACV_N16 0x1b40	/* register.h:8245 */
+#define P_ENCI_MACV_N16 VCBUS_REG_ADDR(ENCI_MACV_N16)
+#define ENCI_MACV_N17 0x1b41	/* register.h:8246 */
+#define P_ENCI_MACV_N17 VCBUS_REG_ADDR(ENCI_MACV_N17)
+#define ENCI_MACV_N18 0x1b42	/* register.h:8247 */
+#define P_ENCI_MACV_N18 VCBUS_REG_ADDR(ENCI_MACV_N18)
+#define ENCI_MACV_N19 0x1b43	/* register.h:8248 */
+#define P_ENCI_MACV_N19 VCBUS_REG_ADDR(ENCI_MACV_N19)
+#define ENCI_MACV_N20 0x1b44	/* register.h:8249 */
+#define P_ENCI_MACV_N20 VCBUS_REG_ADDR(ENCI_MACV_N20)
+#define ENCI_MACV_N21 0x1b45	/* register.h:8250 */
+#define P_ENCI_MACV_N21 VCBUS_REG_ADDR(ENCI_MACV_N21)
+#define ENCI_MACV_N22 0x1b46	/* register.h:8251 */
+#define P_ENCI_MACV_N22 VCBUS_REG_ADDR(ENCI_MACV_N22)
+#define ENCI_DBG_PX_RST 0x1b48	/* register.h:8253 */
+#define P_ENCI_DBG_PX_RST VCBUS_REG_ADDR(ENCI_DBG_PX_RST)
+#define ENCI_DBG_FLDLN_RST 0x1b49	/* register.h:8254 */
+#define P_ENCI_DBG_FLDLN_RST VCBUS_REG_ADDR(ENCI_DBG_FLDLN_RST)
+#define ENCI_DBG_PX_INT 0x1b4a	/* register.h:8255 */
+#define P_ENCI_DBG_PX_INT VCBUS_REG_ADDR(ENCI_DBG_PX_INT)
+#define ENCI_DBG_FLDLN_INT 0x1b4b	/* register.h:8256 */
+#define P_ENCI_DBG_FLDLN_INT VCBUS_REG_ADDR(ENCI_DBG_FLDLN_INT)
+#define ENCI_DBG_MAXPX 0x1b4c	/* register.h:8257 */
+#define P_ENCI_DBG_MAXPX VCBUS_REG_ADDR(ENCI_DBG_MAXPX)
+#define ENCI_DBG_MAXLN 0x1b4d	/* register.h:8258 */
+#define P_ENCI_DBG_MAXLN VCBUS_REG_ADDR(ENCI_DBG_MAXLN)
+#define ENCI_MACV_MAX_AMP 0x1b50	/* register.h:8259 */
+#define P_ENCI_MACV_MAX_AMP VCBUS_REG_ADDR(ENCI_MACV_MAX_AMP)
+#define ENCI_MACV_PULSE_LO 0x1b51	/* register.h:8260 */
+#define P_ENCI_MACV_PULSE_LO VCBUS_REG_ADDR(ENCI_MACV_PULSE_LO)
+#define ENCI_MACV_PULSE_HI 0x1b52	/* register.h:8261 */
+#define P_ENCI_MACV_PULSE_HI VCBUS_REG_ADDR(ENCI_MACV_PULSE_HI)
+#define ENCI_MACV_BKP_MAX 0x1b53	/* register.h:8262 */
+#define P_ENCI_MACV_BKP_MAX VCBUS_REG_ADDR(ENCI_MACV_BKP_MAX)
+#define ENCI_CFILT_CTRL 0x1b54	/* register.h:8263 */
+#define P_ENCI_CFILT_CTRL VCBUS_REG_ADDR(ENCI_CFILT_CTRL)
+#define ENCI_CFILT7 0x1b55	/* register.h:8264 */
+#define P_ENCI_CFILT7 VCBUS_REG_ADDR(ENCI_CFILT7)
+#define ENCI_YC_DELAY 0x1b56	/* register.h:8265 */
+#define P_ENCI_YC_DELAY VCBUS_REG_ADDR(ENCI_YC_DELAY)
+#define ENCI_VIDEO_EN 0x1b57	/* register.h:8266 */
+#define P_ENCI_VIDEO_EN VCBUS_REG_ADDR(ENCI_VIDEO_EN)
+#define VENC_VIDEO_PROG_MODE 0x1b68	/* /../ucode/register.h:8023 */
+#define P_VENC_VIDEO_PROG_MODE		VCBUS_REG_ADDR(VENC_VIDEO_PROG_MODE)
+
+#define ENCI_DVI_HSO_BEGIN 0x1c00	/* register.h:8280 */
+#define P_ENCI_DVI_HSO_BEGIN VCBUS_REG_ADDR(ENCI_DVI_HSO_BEGIN)
+#define ENCI_DVI_HSO_END 0x1c01	/* register.h:8281 */
+#define P_ENCI_DVI_HSO_END VCBUS_REG_ADDR(ENCI_DVI_HSO_END)
+#define ENCI_DVI_VSO_BLINE_EVN 0x1c02	/* register.h:8282 */
+#define P_ENCI_DVI_VSO_BLINE_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_BLINE_EVN)
+#define ENCI_DVI_VSO_BLINE_ODD 0x1c03	/* register.h:8283 */
+#define P_ENCI_DVI_VSO_BLINE_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_BLINE_ODD)
+#define ENCI_DVI_VSO_ELINE_EVN 0x1c04	/* register.h:8284 */
+#define P_ENCI_DVI_VSO_ELINE_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_ELINE_EVN)
+#define ENCI_DVI_VSO_ELINE_ODD 0x1c05	/* register.h:8285 */
+#define P_ENCI_DVI_VSO_ELINE_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_ELINE_ODD)
+#define ENCI_DVI_VSO_BEGIN_EVN 0x1c06	/* register.h:8286 */
+#define P_ENCI_DVI_VSO_BEGIN_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_BEGIN_EVN)
+#define ENCI_DVI_VSO_BEGIN_ODD 0x1c07	/* register.h:8287 */
+#define P_ENCI_DVI_VSO_BEGIN_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_BEGIN_ODD)
+#define ENCI_DVI_VSO_END_EVN 0x1c08	/* register.h:8288 */
+#define P_ENCI_DVI_VSO_END_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_END_EVN)
+#define ENCI_DVI_VSO_END_ODD 0x1c09	/* register.h:8289 */
+#define P_ENCI_DVI_VSO_END_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_END_ODD)
+#define ENCI_CFILT_CTRL2 0x1c0a	/* register.h:8295 */
+#define P_ENCI_CFILT_CTRL2 VCBUS_REG_ADDR(ENCI_CFILT_CTRL2)
+#define ENCI_DACSEL_0 0x1c0b	/* register.h:8296 */
+#define P_ENCI_DACSEL_0 VCBUS_REG_ADDR(ENCI_DACSEL_0)
+#define ENCI_DACSEL_1 0x1c0c	/* register.h:8297 */
+#define P_ENCI_DACSEL_1 VCBUS_REG_ADDR(ENCI_DACSEL_1)
+#define ENCP_DACSEL_0 0x1c0d	/* register.h:8298 */
+#define P_ENCP_DACSEL_0 VCBUS_REG_ADDR(ENCP_DACSEL_0)
+#define ENCP_DACSEL_1 0x1c0e	/* register.h:8299 */
+#define P_ENCP_DACSEL_1 VCBUS_REG_ADDR(ENCP_DACSEL_1)
+#define ENCP_MAX_LINE_SWITCH_POINT 0x1c0f	/* register.h:8300 */
+#define P_ENCP_MAX_LINE_SWITCH_POINT VCBUS_REG_ADDR(ENCP_MAX_LINE_SWITCH_POINT)
+#define ENCI_TST_EN 0x1c10	/* register.h:8301 */
+#define P_ENCI_TST_EN VCBUS_REG_ADDR(ENCI_TST_EN)
+#define ENCI_TST_MDSEL 0x1c11	/* register.h:8302 */
+#define P_ENCI_TST_MDSEL VCBUS_REG_ADDR(ENCI_TST_MDSEL)
+#define ENCI_TST_Y 0x1c12	/* register.h:8303 */
+#define P_ENCI_TST_Y VCBUS_REG_ADDR(ENCI_TST_Y)
+#define ENCI_TST_CB 0x1c13	/* register.h:8304 */
+#define P_ENCI_TST_CB VCBUS_REG_ADDR(ENCI_TST_CB)
+#define ENCI_TST_CR 0x1c14	/* register.h:8305 */
+#define P_ENCI_TST_CR VCBUS_REG_ADDR(ENCI_TST_CR)
+#define ENCI_TST_CLRBAR_STRT 0x1c15	/* register.h:8306 */
+#define P_ENCI_TST_CLRBAR_STRT VCBUS_REG_ADDR(ENCI_TST_CLRBAR_STRT)
+#define ENCI_TST_CLRBAR_WIDTH 0x1c16	/* register.h:8307 */
+#define P_ENCI_TST_CLRBAR_WIDTH VCBUS_REG_ADDR(ENCI_TST_CLRBAR_WIDTH)
+#define ENCI_TST_VDCNT_STSET 0x1c17	/* register.h:8308 */
+#define P_ENCI_TST_VDCNT_STSET VCBUS_REG_ADDR(ENCI_TST_VDCNT_STSET)
+#define ENCI_VFIFO2VD_CTL 0x1c18	/* register.h:8313 */
+#define P_ENCI_VFIFO2VD_CTL VCBUS_REG_ADDR(ENCI_VFIFO2VD_CTL)
+#define ENCI_VFIFO2VD_PIXEL_START 0x1c19	/* register.h:8315 */
+#define P_ENCI_VFIFO2VD_PIXEL_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_PIXEL_START)
+#define ENCI_VFIFO2VD_PIXEL_END 0x1c1a	/* register.h:8317 */
+#define P_ENCI_VFIFO2VD_PIXEL_END VCBUS_REG_ADDR(ENCI_VFIFO2VD_PIXEL_END)
+#define ENCI_VFIFO2VD_LINE_TOP_START 0x1c1b	/* register.h:8319 */
+#define P_ENCI_VFIFO2VD_LINE_TOP_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_TOP_START)
+#define ENCI_VFIFO2VD_LINE_TOP_END 0x1c1c	/* register.h:8321 */
+#define P_ENCI_VFIFO2VD_LINE_TOP_END \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_TOP_END)
+#define ENCI_VFIFO2VD_LINE_BOT_START 0x1c1d	/* register.h:8323 */
+#define P_ENCI_VFIFO2VD_LINE_BOT_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_BOT_START)
+#define ENCI_VFIFO2VD_LINE_BOT_END 0x1c1e	/* register.h:8325 */
+#define P_ENCI_VFIFO2VD_LINE_BOT_END \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_BOT_END)
+#define ENCI_VFIFO2VD_CTL2 0x1c1f	/* register.h:8326 */
+#define P_ENCI_VFIFO2VD_CTL2 VCBUS_REG_ADDR(ENCI_VFIFO2VD_CTL2)
+
+#define ENCP_DVI_HSO_BEGIN 0x1c30	/* register.h:8354 */
+#define P_ENCP_DVI_HSO_BEGIN VCBUS_REG_ADDR(ENCP_DVI_HSO_BEGIN)
+#define ENCP_DVI_HSO_END 0x1c31	/* register.h:8355 */
+#define P_ENCP_DVI_HSO_END VCBUS_REG_ADDR(ENCP_DVI_HSO_END)
+#define ENCP_DVI_VSO_BLINE_EVN 0x1c32	/* register.h:8356 */
+#define P_ENCP_DVI_VSO_BLINE_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_BLINE_EVN)
+#define ENCP_DVI_VSO_BLINE_ODD 0x1c33	/* register.h:8357 */
+#define P_ENCP_DVI_VSO_BLINE_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_BLINE_ODD)
+#define ENCP_DVI_VSO_ELINE_EVN 0x1c34	/* register.h:8358 */
+#define P_ENCP_DVI_VSO_ELINE_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_ELINE_EVN)
+#define ENCP_DVI_VSO_ELINE_ODD 0x1c35	/* register.h:8359 */
+#define P_ENCP_DVI_VSO_ELINE_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_ELINE_ODD)
+#define ENCP_DVI_VSO_BEGIN_EVN 0x1c36	/* register.h:8360 */
+#define P_ENCP_DVI_VSO_BEGIN_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_BEGIN_EVN)
+#define ENCP_DVI_VSO_BEGIN_ODD 0x1c37	/* register.h:8361 */
+#define P_ENCP_DVI_VSO_BEGIN_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_BEGIN_ODD)
+#define ENCP_DVI_VSO_END_EVN 0x1c38	/* register.h:8362 */
+#define P_ENCP_DVI_VSO_END_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_END_EVN)
+#define ENCP_DVI_VSO_END_ODD 0x1c39	/* register.h:8363 */
+#define P_ENCP_DVI_VSO_END_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_END_ODD)
+#define ENCP_DE_H_BEGIN 0x1c3a	/* register.h:8364 */
+#define P_ENCP_DE_H_BEGIN VCBUS_REG_ADDR(ENCP_DE_H_BEGIN)
+#define ENCP_DE_H_END 0x1c3b	/* register.h:8365 */
+#define P_ENCP_DE_H_END VCBUS_REG_ADDR(ENCP_DE_H_END)
+#define ENCP_DE_V_BEGIN_EVEN 0x1c3c	/* register.h:8366 */
+#define P_ENCP_DE_V_BEGIN_EVEN VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_EVEN)
+#define ENCP_DE_V_END_EVEN 0x1c3d	/* register.h:8367 */
+#define P_ENCP_DE_V_END_EVEN VCBUS_REG_ADDR(ENCP_DE_V_END_EVEN)
+#define ENCP_DE_V_BEGIN_ODD 0x1c3e	/* register.h:8368 */
+#define P_ENCP_DE_V_BEGIN_ODD VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_ODD)
+#define ENCP_DE_V_END_ODD 0x1c3f	/* register.h:8369 */
+#define P_ENCP_DE_V_END_ODD VCBUS_REG_ADDR(ENCP_DE_V_END_ODD)
+#define ENCI_SYNC_LINE_LENGTH 0x1c40	/* register.h:8372 */
+#define P_ENCI_SYNC_LINE_LENGTH VCBUS_REG_ADDR(ENCI_SYNC_LINE_LENGTH)
+#define ENCI_SYNC_PIXEL_EN 0x1c41	/* register.h:8375 */
+#define P_ENCI_SYNC_PIXEL_EN VCBUS_REG_ADDR(ENCI_SYNC_PIXEL_EN)
+#define ENCI_SYNC_TO_LINE_EN 0x1c42	/* register.h:8382 */
+#define P_ENCI_SYNC_TO_LINE_EN VCBUS_REG_ADDR(ENCI_SYNC_TO_LINE_EN)
+#define ENCI_SYNC_TO_PIXEL 0x1c43	/* register.h:8384 */
+#define P_ENCI_SYNC_TO_PIXEL VCBUS_REG_ADDR(ENCI_SYNC_TO_PIXEL)
+#define ENCP_SYNC_LINE_LENGTH 0x1c44	/* register.h:8387 */
+#define P_ENCP_SYNC_LINE_LENGTH VCBUS_REG_ADDR(ENCP_SYNC_LINE_LENGTH)
+#define ENCP_SYNC_PIXEL_EN 0x1c45	/* register.h:8390 */
+#define P_ENCP_SYNC_PIXEL_EN VCBUS_REG_ADDR(ENCP_SYNC_PIXEL_EN)
+#define ENCP_SYNC_TO_LINE_EN 0x1c46	/* register.h:8397 */
+#define P_ENCP_SYNC_TO_LINE_EN VCBUS_REG_ADDR(ENCP_SYNC_TO_LINE_EN)
+#define ENCP_SYNC_TO_PIXEL 0x1c47	/* register.h:8399 */
+#define P_ENCP_SYNC_TO_PIXEL VCBUS_REG_ADDR(ENCP_SYNC_TO_PIXEL)
+
+#define VPP_POSTBLEND_H_SIZE 0x1d21
+#define P_VPP_POSTBLEND_H_SIZE VCBUS_REG_ADDR(VPP_POSTBLEND_H_SIZE)
+
+
+#define VPU_VIU_VENC_MUX_CTRL 0x271a	/* register.h:9214 */
+#define P_VPU_VIU_VENC_MUX_CTRL VCBUS_REG_ADDR(VPU_VIU_VENC_MUX_CTRL)
+#define VPU_HDMI_SETTING 0x271b	/* register.h:9229 */
+#define P_VPU_HDMI_SETTING VCBUS_REG_ADDR(VPU_HDMI_SETTING)
+
+#define VPU_HDMI_DATA_OVR 0x2727	/* register.h:9270 */
+#define P_VPU_HDMI_DATA_OVR VCBUS_REG_ADDR(VPU_HDMI_DATA_OVR)
+#define VPU_HDMI_FMT_CTRL 0x2743
+#define P_VPU_HDMI_FMT_CTRL VCBUS_REG_ADDR(VPU_HDMI_FMT_CTRL)
+/* For GXM and later */
+#define VPU_HDMI_DITH_CNTL 0x27fc
+#define P_VPU_HDMI_DITH_CNTL VCBUS_REG_ADDR(VPU_HDMI_DITH_CNTL)
+
+#endif
diff --git a/include/amlogic/media/vout/lcd/aml_lcd.h b/include/amlogic/media/vout/lcd/aml_lcd.h
new file mode 100644
index 0000000000..ef3334a5fb
--- /dev/null
+++ b/include/amlogic/media/vout/lcd/aml_lcd.h
@@ -0,0 +1,168 @@
+/*
+ * include/amlogic/media/vout/lcd/aml_lcd.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef INC_AML_LCD_H
+#define INC_AML_LCD_H
+
+#include <common.h>
+#include <linux/list.h>
+#include <amlogic/media/vout/lcd/lcd_vout.h>
+#ifdef CONFIG_AML_LCD_EXTERN
+#include <amlogic/media/vout/lcd/lcd_extern.h>
+#endif
+#ifdef CONFIG_AML_BL_EXTERN
+#include <amlogic/media/vout/lcd/bl_extern.h>
+#endif
+
+#define LCD_GPIO_MAX                  0xff
+#define LCD_GPIO_OUTPUT_LOW           0
+#define LCD_GPIO_OUTPUT_HIGH          1
+#define LCD_GPIO_INPUT                2
+
+
+#define LCD_EXT_I2C_BUS_0             0  //A
+#define LCD_EXT_I2C_BUS_1             1  //B
+#define LCD_EXT_I2C_BUS_2             2  //C
+#define LCD_EXT_I2C_BUS_3             3  //D
+#define LCD_EXT_I2C_BUS_4             4  //AO
+#define LCD_EXT_I2C_BUS_MAX           0xff
+
+
+#define LCD_EXT_I2C_BUS_INVALID       0xff
+#define LCD_EXT_I2C_ADDR_INVALID      0xff
+#define LCD_EXT_GPIO_INVALID          0xff
+
+#define LCD_EXT_SPI_CLK_FREQ_DFT      10 /* unit: KHz */
+
+
+#define LCD_EXT_CMD_TYPE_CMD_DELAY    0x00
+#define LCD_EXT_CMD_TYPE_CMD2_DELAY   0x01  /* for i2c device 2nd addr */
+#define LCD_EXT_CMD_TYPE_NONE         0x10
+#define LCD_EXT_CMD_TYPE_CMD          0xc0
+#define LCD_EXT_CMD_TYPE_CMD2         0xc1  /* for i2c device 2nd addr */
+#define LCD_EXT_CMD_TYPE_GPIO         0xf0
+#define LCD_EXT_CMD_TYPE_CHECK        0xfc
+#define LCD_EXT_CMD_TYPE_DELAY        0xfd
+#define LCD_EXT_CMD_TYPE_END          0xff
+
+#define LCD_EXT_CMD_SIZE_DYNAMIC      0xff
+#define LCD_EXT_DYNAMIC_SIZE_INDEX    1
+
+
+#define LCD_GPIO_NAME_MAX             15
+struct lcd_cpu_gpio_s {
+	char name[LCD_GPIO_NAME_MAX];
+	struct gpio_desc gpio;
+	int probe_flag;
+	int register_flag;
+};
+
+
+#define Rsv_val 0xffffffff
+struct ext_lcd_config_s {
+	const char panel_type[20];
+	int lcd_type;
+	unsigned char lcd_bits;
+
+	unsigned short h_active;
+	unsigned short v_active;
+	unsigned short h_period;
+	unsigned short v_period;
+	unsigned short hsync_width;
+	unsigned short hsync_bp;
+	unsigned short hsync_pol;
+	unsigned short vsync_width;
+	unsigned short vsync_bp;
+	unsigned short vsync_pol;
+
+	unsigned int customer_val_0; //fr_adjust_type
+	unsigned int customer_val_1; //ss_level
+	unsigned int customer_val_2; //clk_auto_generate
+	unsigned int customer_val_3; //pixel clock(unit in Hz)
+	unsigned int customer_val_4;
+	unsigned int customer_val_5;
+	unsigned int customer_val_6;
+	unsigned int customer_val_7;
+	unsigned int customer_val_8;
+	unsigned int customer_val_9;
+
+	unsigned int if_attr_val0;
+	unsigned int if_attr_val1;
+	unsigned int if_attr_val2;
+	unsigned int if_attr_val3;
+	unsigned int if_attr_val4;
+	unsigned int if_attr_val5;
+	unsigned int if_attr_val6;
+	unsigned int if_attr_val7;
+	unsigned int if_attr_val8;
+	unsigned int if_attr_val9;
+
+	unsigned char *cmd_init_on;
+	unsigned char *cmd_init_off;
+	struct lcd_power_step_s *power_on_step;
+	struct lcd_power_step_s *power_off_step;
+
+	/* backlight */
+	unsigned int level_default;
+	unsigned int level_max;
+	unsigned int level_min;
+	unsigned int level_mid;
+	unsigned int level_mid_mapping;
+
+	unsigned int bl_method;
+	unsigned int bl_en_gpio;
+	unsigned short bl_en_gpio_on;
+	unsigned short bl_en_gpio_off;
+	unsigned short bl_power_on_delay;
+	unsigned short bl_power_off_delay;
+
+	unsigned int pwm_method;
+	unsigned int pwm_port;
+	unsigned int pwm_freq;
+	unsigned int pwm_duty_max;
+	unsigned int pwm_duty_min;
+	unsigned int pwm_gpio;
+	unsigned int pwm_gpio_off;
+
+	unsigned int pwm2_method;
+	unsigned int pwm2_port;
+	unsigned int pwm2_freq;
+	unsigned int pwm2_duty_max;
+	unsigned int pwm2_duty_min;
+	unsigned int pwm2_gpio;
+	unsigned int pwm2_gpio_off;
+
+	unsigned int pwm_level_max;
+	unsigned int pwm_level_min;
+	unsigned int pwm2_level_max;
+	unsigned int pwm2_level_min;
+
+	unsigned int pwm_on_delay;
+	unsigned int pwm_off_delay;
+
+	/* backlight extern */
+	unsigned int bl_ext_index;
+};
+
+#define LCD_NUM_MAX         10
+
+extern struct ext_lcd_config_s ext_lcd_config[LCD_NUM_MAX];
+
+#endif /* INC_AML_LCD_H */
diff --git a/include/amlogic/media/vout/lcd/bl_extern.h b/include/amlogic/media/vout/lcd/bl_extern.h
new file mode 100644
index 0000000000..6604672cea
--- /dev/null
+++ b/include/amlogic/media/vout/lcd/bl_extern.h
@@ -0,0 +1,88 @@
+/*
+ * include/amlogicmedia/vout/lcd/bl_extern.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _INC_AML_BL_EXTERN_H_
+#define _INC_AML_BL_EXTERN_H_
+
+enum bl_extern_type_e {
+	BL_EXTERN_I2C = 0,
+	BL_EXTERN_SPI,
+	BL_EXTERN_MIPI,
+	BL_EXTERN_MAX,
+};
+
+#define BL_EXTERN_I2C_BUS_A          0
+#define BL_EXTERN_I2C_BUS_B          1
+#define BL_EXTERN_I2C_BUS_C          2
+#define BL_EXTERN_I2C_BUS_D          3
+#define BL_EXTERN_I2C_BUS_AO         4
+
+#define BL_EXTERN_I2C_BUS_0          BL_EXTERN_I2C_BUS_A
+#define BL_EXTERN_I2C_BUS_1          BL_EXTERN_I2C_BUS_B
+#define BL_EXTERN_I2C_BUS_2          BL_EXTERN_I2C_BUS_C
+#define BL_EXTERN_I2C_BUS_3          BL_EXTERN_I2C_BUS_D
+#define BL_EXTERN_I2C_BUS_4          BL_EXTERN_I2C_BUS_AO
+#define BL_EXTERN_I2C_BUS_MAX        5
+
+#define BL_EXTERN_INIT_ON_MAX       200
+#define BL_EXTERN_INIT_OFF_MAX      50
+
+#define BL_EXTERN_GPIO_NUM_MAX      6
+#define BL_EXTERN_INDEX_INVALID     0xff
+#define BL_EXTERN_NAME_LEN_MAX      30
+struct bl_extern_config_s {
+	unsigned char index;
+	char name[BL_EXTERN_NAME_LEN_MAX];
+	enum bl_extern_type_e type;
+	unsigned char i2c_addr;
+	unsigned char i2c_bus;
+	unsigned int dim_min;
+	unsigned int dim_max;
+
+	unsigned char init_loaded;
+	unsigned char cmd_size;
+	unsigned char *init_on;
+	unsigned char *init_off;
+	unsigned int init_on_cnt;
+	unsigned int init_off_cnt;
+};
+
+/* global API */
+#define BL_EXT_DRIVER_MAX    10
+struct aml_bl_extern_driver_s {
+	int (*power_on)(void);
+	int (*power_off)(void);
+	int (*set_level)(unsigned int level);
+	void (*config_print)(void);
+	int (*device_power_on)(void);
+	int (*device_power_off)(void);
+	int (*device_bri_update)(unsigned int level);
+	struct bl_extern_config_s *config;
+};
+
+extern struct aml_bl_extern_driver_s *aml_bl_extern_get_driver(void);
+extern int aml_bl_extern_device_load(const void *dt_blob, int index);
+extern struct bl_extern_config_s bl_extern_config_dtf;
+#ifdef CONFIG_AML_LCD_TABLET
+extern int dsi_write_cmd(unsigned char *payload);
+#endif
+
+#endif
+
diff --git a/include/amlogic/media/vout/lcd/bl_ldim.h b/include/amlogic/media/vout/lcd/bl_ldim.h
new file mode 100644
index 0000000000..fb42eb3f71
--- /dev/null
+++ b/include/amlogic/media/vout/lcd/bl_ldim.h
@@ -0,0 +1,118 @@
+/*
+ * include/amlogic/media/vout/lcd/bl_ldim.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef INC_AML_BL_LDIM_H
+#define INC_AML_BL_LDIM_H
+
+#include <common.h>
+#include <linux/list.h>
+#include <amlogic/media/vout/lcd/aml_lcd.h>
+#include <spi.h>
+
+enum ldim_dev_type_e {
+	LDIM_DEV_TYPE_NORMAL = 0,
+	LDIM_DEV_TYPE_SPI,
+	LDIM_DEV_TYPE_I2C,
+	LDIM_DEV_TYPE_MAX,
+};
+
+#define LDIM_INIT_ON_MAX     300
+#define LDIM_INIT_OFF_MAX    20
+
+struct ldim_pinmux_ctrl_s {
+	char *name;
+	unsigned int pinmux_set[LCD_PINMUX_NUM][2];
+	unsigned int pinmux_clr[LCD_PINMUX_NUM][2];
+};
+
+struct ldim_config_s {
+	unsigned char row;
+	unsigned char col;
+};
+
+struct ldim_dev_config_s {
+	char name[20];
+	char pinmux_name[20];
+	unsigned char type;
+	int cs_hold_delay;
+	int cs_clk_delay;
+	int en_gpio;
+	int en_gpio_on;
+	int en_gpio_off;
+	int lamp_err_gpio;
+	unsigned char fault_check;
+	unsigned char write_check;
+
+	unsigned int dim_min;
+	unsigned int dim_max;
+
+	unsigned char init_loaded;
+	unsigned char cmd_size;
+	unsigned char *init_on;
+	unsigned char *init_off;
+	unsigned int init_on_cnt;
+	unsigned int init_off_cnt;
+
+	unsigned char pinctrl_ver;
+	struct ldim_pinmux_ctrl_s *ldim_pinmux;
+	struct bl_pwm_config_s pwm_config;
+	char gpio_name[BL_GPIO_NUM_MAX][LCD_GPIO_NAME_MAX];
+
+	unsigned short bl_regnum;
+};
+
+#define LDIM_SPI_NAME_MAX    30
+struct ldim_spi_dev_info_s {
+	char modalias[20];
+	char spi_name[LDIM_SPI_NAME_MAX];
+	int mode;
+	int max_speed_hz;
+	int bus_num;
+	int chip_select;
+	int wordlen;
+
+	struct spi_slave *spi;
+};
+
+/*******global API******/
+struct aml_ldim_driver_s {
+	int valid_flag;
+	int dev_index;
+	struct ldim_config_s *ldim_conf;
+	struct ldim_dev_config_s *ldev_conf;
+	unsigned short *ldim_matrix_buf;
+	int (*power_on)(void);
+	int (*power_off)(void);
+	int (*set_level)(unsigned int level);
+	void (*config_print)(void);
+	int (*pinmux_ctrl)(int status);
+	void (*device_config_print)(void);
+	int (*device_power_on)(void);
+	int (*device_power_off)(void);
+	int (*device_bri_update)(unsigned short *buf, unsigned char len);
+	struct ldim_spi_dev_info_s *spi_info;
+};
+
+extern struct ldim_dev_config_s ldim_config_dft;
+
+extern struct aml_ldim_driver_s *aml_ldim_get_driver(void);
+extern int aml_ldim_probe(char *dt_addr, int flag); /* flag: 0=dts, 1=bsp, 2=unifykey */
+
+#endif /* INC_AML_BL_LDIM_H */
diff --git a/include/amlogic/media/vout/lcd/lcd_extern.h b/include/amlogic/media/vout/lcd/lcd_extern.h
new file mode 100644
index 0000000000..dc6ef565a8
--- /dev/null
+++ b/include/amlogic/media/vout/lcd/lcd_extern.h
@@ -0,0 +1,116 @@
+/*
+ * include/amlogic/media/vout/lcd/lcd_extern.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _INC_AML_LCD_EXTERN_H_
+#define _INC_AML_LCD_EXTERN_H_
+#include <amlogic/media/vout/lcd/lcd_vout.h>
+
+enum lcd_extern_type_e {
+	LCD_EXTERN_I2C = 0,
+	LCD_EXTERN_SPI,
+	LCD_EXTERN_MIPI,
+	LCD_EXTERN_MAX,
+};
+
+#define LCD_EXTERN_I2C_BUS_A          0
+#define LCD_EXTERN_I2C_BUS_B          1
+#define LCD_EXTERN_I2C_BUS_C          2
+#define LCD_EXTERN_I2C_BUS_D          3
+#define LCD_EXTERN_I2C_BUS_AO         4
+
+#define LCD_EXTERN_I2C_BUS_0          LCD_EXTERN_I2C_BUS_A
+#define LCD_EXTERN_I2C_BUS_1          LCD_EXTERN_I2C_BUS_B
+#define LCD_EXTERN_I2C_BUS_2          LCD_EXTERN_I2C_BUS_C
+#define LCD_EXTERN_I2C_BUS_3          LCD_EXTERN_I2C_BUS_D
+#define LCD_EXTERN_I2C_BUS_4          LCD_EXTERN_I2C_BUS_AO
+#define LCD_EXTERN_I2C_BUS_MAX        5
+
+
+#define LCD_EXTERN_INIT_ON_MAX        3000
+#define LCD_EXTERN_INIT_OFF_MAX       100
+
+#define LCD_EXTERN_GPIO_NUM_MAX       6
+#define LCD_EXTERN_GPIO_LEN_MAX       10
+#define LCD_EXTERN_INDEX_INVALID      0xff
+#define LCD_EXTERN_NAME_LEN_MAX       30
+
+#define LCD_EXTERN_NUM_MAX            20
+
+struct lcd_extern_config_s {
+	unsigned char index;
+	char name[LCD_EXTERN_NAME_LEN_MAX];
+	enum lcd_extern_type_e type;
+	unsigned char status;
+
+	unsigned char i2c_addr;
+	unsigned char i2c_addr2;
+	unsigned char i2c_bus;
+
+	unsigned char spi_clk_pol;
+	unsigned short spi_clk_freq; /*KHz */
+	unsigned short spi_delay_us;
+
+	unsigned char cmd_size;
+	unsigned char table_init_loaded; /* internal use */
+	unsigned int table_init_on_cnt;
+	unsigned int table_init_off_cnt;
+	unsigned char *table_init_on;
+	unsigned char *table_init_off;
+};
+
+struct lcd_extern_common_s {
+	unsigned char lcd_ext_key_valid;
+	char gpio_name[LCD_EXTERN_GPIO_NUM_MAX][LCD_EXTERN_GPIO_LEN_MAX];
+
+	unsigned char i2c_bus;
+	unsigned char i2c_gpio_sck;
+	unsigned char i2c_gpio_sda;
+
+	unsigned char spi_gpio_cs;
+	unsigned char spi_gpio_clk;
+	unsigned char spi_gpio_data;
+
+	struct lcd_pinmux_ctrl_s *lcd_ext_pinmux;
+	unsigned int pinmux_set[LCD_PINMUX_NUM][2];
+	unsigned int pinmux_clr[LCD_PINMUX_NUM][2];
+	unsigned char pinmux_gpio_off;
+	unsigned char pinmux_valid;
+};
+
+//global API
+struct aml_lcd_extern_driver_s {
+	struct lcd_extern_config_s *config;
+	struct lcd_extern_common_s *common;
+	int (*reg_read)  (unsigned char reg, unsigned char *buf);
+	int (*reg_write) (unsigned char reg, unsigned char value);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	void (*info_print)(void);
+};
+
+extern struct aml_lcd_extern_driver_s *aml_lcd_extern_get_driver(void);
+extern int aml_lcd_extern_probe(const void *dt_blob, int index);
+extern int aml_lcd_extern_remove(void);
+
+extern struct lcd_extern_config_s ext_config_dtf;
+extern struct lcd_extern_common_s ext_common_dft;
+
+#endif
+
diff --git a/include/amlogic/media/vout/lcd/lcd_vout.h b/include/amlogic/media/vout/lcd/lcd_vout.h
new file mode 100644
index 0000000000..a5c0f3d817
--- /dev/null
+++ b/include/amlogic/media/vout/lcd/lcd_vout.h
@@ -0,0 +1,520 @@
+/*
+ * include/amlogic/media/vout/lcd/lcd_vout.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef INC_AML_LCD_VOUT_H
+#define INC_AML_LCD_VOUT_H
+
+#include <common.h>
+#include <linux/list.h>
+#include <dm.h>
+#include <asm/gpio.h>
+
+/* **********************************
+ * debug print define
+ * ********************************** */
+//#define LCD_DEBUG_INFO
+extern unsigned int lcd_debug_print_flag;
+
+#define LCDPR(fmt, args...)     printf("lcd: "fmt"", ## args)
+#define LCDERR(fmt, args...)    printf("lcd: error: "fmt"", ## args)
+
+/* **********************************
+ * clk parameter bit define
+ * pll_ctrl, div_ctrl, clk_ctrl
+ * ********************************** */
+/* ******** pll_ctrl ******** */
+#define PLL_CTRL_OD3                20 /* [21:20] */
+#define PLL_CTRL_OD2                18 /* [19:18] */
+#define PLL_CTRL_OD1                16 /* [17:16] */
+#define PLL_CTRL_N                  9  /* [13:9] */
+#define PLL_CTRL_M                  0  /* [8:0] */
+
+/* ******** div_ctrl ******** */
+#define DIV_CTRL_EDP_DIV1           24 /* [26:24] */
+#define DIV_CTRL_EDP_DIV0           20 /* [23:20] */
+#define DIV_CTRL_DIV_SEL            8 /* [15:8] */
+#define DIV_CTRL_XD                 0 /* [7:0] */
+
+/* ******** clk_ctrl ******** */
+#define CLK_CTRL_LEVEL              28 /* [30:28] */
+#define CLK_CTRL_FRAC               0  /* [18:0] */
+
+
+#define LCD_PINMUX_END          0xff
+#define LCD_PINMUX_NUM          15
+
+/* **********************************
+ * VENC to TCON sync delay
+ * ********************************** */
+#define TTL_DELAY                   13
+
+
+/* **********************************
+ * global control define
+ * ********************************** */
+enum lcd_mode_e {
+	LCD_MODE_TV = 0,
+	LCD_MODE_TABLET,
+	LCD_MODE_MAX,
+};
+
+enum lcd_chip_e {
+	LCD_CHIP_G12A = 0,
+	LCD_CHIP_G12B, 	/* 1 */
+	LCD_CHIP_TL1,
+	LCD_CHIP_SM1,
+	LCD_CHIP_MAX,
+};
+
+enum lcd_type_e {
+	LCD_TTL = 0,
+	LCD_LVDS,
+	LCD_VBYONE,
+	LCD_MIPI,
+	LCD_MLVDS,
+	LCD_TYPE_MAX,
+};
+
+#define MOD_LEN_MAX        30
+struct lcd_basic_s {
+	char model_name[MOD_LEN_MAX];
+	enum lcd_type_e lcd_type;
+	unsigned char lcd_bits;
+
+	unsigned short h_active; /* Horizontal display area */
+	unsigned short v_active; /* Vertical display area */
+	unsigned short h_period; /* Horizontal total period time */
+	unsigned short v_period; /* Vertical total period time */
+	unsigned short h_period_min;
+	unsigned short h_period_max;
+	unsigned short v_period_min;
+	unsigned short v_period_max;
+	unsigned int lcd_clk_min;
+	unsigned int lcd_clk_max;
+
+	unsigned short screen_width;  /* screen physical width in "mm" unit */
+	unsigned short screen_height; /* screen physical height in "mm" unit */
+};
+
+#define LCD_CLK_FRAC_UPDATE     (1 << 0)
+#define LCD_CLK_PLL_CHANGE      (1 << 1)
+struct lcd_timing_s {
+	unsigned char clk_auto; /* clk parameters auto generation */
+	unsigned char fr_adjust_type; /* 0=clock, 1=htotal, 2=vtotal */
+	unsigned char clk_change; /* internal used */
+	unsigned int lcd_clk;   /* pixel clock(unit: Hz) */
+	unsigned int lcd_clk_dft; /* internal used */
+	unsigned int h_period_dft; /* internal used */
+	unsigned int v_period_dft; /* internal used */
+	unsigned int pll_ctrl;  /* pll settings */
+	unsigned int div_ctrl;  /* divider settings */
+	unsigned int clk_ctrl;  /* clock settings */
+
+	unsigned int ss_level;
+
+	unsigned short sync_duration_num;
+	unsigned short sync_duration_den;
+
+	unsigned short video_on_pixel;
+	unsigned short video_on_line;
+
+	unsigned short hsync_width;
+	unsigned short hsync_bp;
+	unsigned short hsync_pol;
+	unsigned short vsync_width;
+	unsigned short vsync_bp;
+	unsigned short vsync_pol;
+	/* unsigned int vsync_h_phase; // [31]sign, [15:0]value */
+	unsigned int h_offset;
+	unsigned int v_offset;
+
+	unsigned short de_hs_addr;
+	unsigned short de_he_addr;
+	unsigned short de_vs_addr;
+	unsigned short de_ve_addr;
+
+	unsigned short hs_hs_addr;
+	unsigned short hs_he_addr;
+	unsigned short hs_vs_addr;
+	unsigned short hs_ve_addr;
+
+	unsigned short vs_hs_addr;
+	unsigned short vs_he_addr;
+	unsigned short vs_vs_addr;
+	unsigned short vs_ve_addr;
+};
+
+struct ttl_config_s {
+	unsigned int clk_pol;
+	unsigned int sync_valid; /* [1]DE, [0]hvsync */
+	unsigned int swap_ctrl; /* [1]rb swap, [0]bit swap */
+};
+
+#define LVDS_PHY_VSWING_DFT        3
+#define LVDS_PHY_PREEM_DFT         0
+#define LVDS_PHY_CLK_VSWING_DFT    0
+#define LVDS_PHY_CLK_PREEM_DFT     0
+struct lvds_config_s {
+	unsigned int lvds_repack;
+	unsigned int dual_port;
+	unsigned int pn_swap;
+	unsigned int port_swap;
+	unsigned int lane_reverse;
+	unsigned int port_sel;
+	unsigned int phy_vswing;
+	unsigned int phy_preem;
+	unsigned int phy_clk_vswing;
+	unsigned int phy_clk_preem;
+};
+
+#define VX1_PHY_VSWING_DFT           3
+#define VX1_PHY_PREEM_DFT            0
+
+#define VX1_PWR_ON_RESET_DLY_DFT     500 /* 500ms */
+#define VX1_HPD_DATA_DELAY_DFT       10 /* 10ms */
+#define VX1_CDR_TRAINING_HOLD_DFT    200 /* 200ms */
+
+#define VX1_SW_FILTER_TIME_DFT       10 /* 10*100us=1ms */
+#define VX1_SW_FILTER_CNT_DFT        6
+#define VX1_SW_FILTER_RETRY_CNT_DFT  2
+#define VX1_SW_FILTER_RETRY_DLY_DFT  100 /* 100ms */
+#define VX1_SW_CDR_DET_TIME_DFT      20 /* 20us*100=2ms */
+#define VX1_SW_CDR_DET_CNT_DFT       100
+#define VX1_SW_CDR_TIMEOUT_CNT_DFT   100
+
+struct vbyone_config_s {
+	unsigned int lane_count;
+	unsigned int region_num;
+	unsigned int byte_mode;
+	unsigned int color_fmt;
+	unsigned int phy_div;
+	unsigned int bit_rate;
+	unsigned int phy_vswing; /*[5:4]:ext_pullup, [3:0]vswing*/
+	unsigned int phy_preem;
+	unsigned int ctrl_flag;
+		/* bit[0]:power_on_reset_en
+		   bit[1]:hpd_data_delay_en
+		   bit[2]:cdr_training_hold_en
+		   bit[3]:hw_filter_en
+		   bit[5:4]:sw_filter */
+
+	/* ctrl timing */
+	unsigned int power_on_reset_delay; /* ms */
+	unsigned int hpd_data_delay; /* ms */
+	unsigned int cdr_training_hold; /* ms */
+	/* hw filter */
+	unsigned int hpd_hw_filter_time; /* ms */
+	unsigned int hpd_hw_filter_cnt;
+	unsigned int lockn_hw_filter_time; /* ms */
+	unsigned int lockn_hw_filter_cnt;
+	/* sw filter */
+	unsigned int vx1_sw_filter_en; /* 0=disable, 1=sw_filter, 2=sw_filter with sw_reset */
+	unsigned int vx1_sw_filter_time; /* 100us base */
+	unsigned int vx1_sw_filter_cnt;
+	unsigned int vx1_sw_filter_retry_cnt;
+	unsigned int vx1_sw_filter_retry_delay; /* ms base */
+	unsigned int vx1_sw_cdr_detect_time; /* us base * 100 times, must cover tcon lockn pulse */
+	unsigned int vx1_sw_cdr_detect_cnt;
+	unsigned int vx1_sw_cdr_timeout_cnt;
+};
+
+/* mipi-dsi config */
+/* Operation mode parameters */
+#define OPERATION_VIDEO_MODE     0
+#define OPERATION_COMMAND_MODE   1
+
+#define SYNC_PULSE               0x0
+#define SYNC_EVENT               0x1
+#define BURST_MODE               0x2
+
+/* command config */
+#define DSI_CMD_SIZE_INDEX       1  /* byte[1] */
+#define DSI_GPIO_INDEX           2  /* byte[2] */
+
+#define DSI_INIT_ON_MAX          100
+#define DSI_INIT_OFF_MAX         30
+
+struct dsi_config_s {
+	unsigned char lane_num;
+	unsigned int bit_rate_max; /* MHz */
+	unsigned int bit_rate_min; /* MHz*/
+	unsigned int bit_rate; /* Hz */
+	unsigned int clk_factor; /* bit_rate/pclk */
+	unsigned int factor_numerator;
+	unsigned int factor_denominator; /* 100 */
+	unsigned char operation_mode_init; /* 0=video mode, 1=command mode */
+	unsigned char operation_mode_display; /* 0=video mode, 1=command mode */
+	unsigned char video_mode_type; /* 0=sync_pulse, 1=sync_event, 2=burst */
+	unsigned char clk_always_hs; /* 0=disable, 1=enable */
+	unsigned char phy_switch; /* 0=auto, 1=standard, 2=slow */
+
+	unsigned int venc_data_width;
+	unsigned int dpi_data_format;
+
+	unsigned char *dsi_init_on;
+	unsigned char *dsi_init_off;
+	unsigned char extern_init;
+
+	unsigned char check_en;
+	unsigned char check_reg;
+	unsigned char check_cnt;
+	unsigned char check_state;
+};
+
+struct mlvds_config_s {
+	unsigned int channel_num;
+	unsigned int channel_sel0;
+	unsigned int channel_sel1;
+	unsigned int clk_phase; /* [13:12]=clk01_sel, [11:8]=pi2, [7:4]=pi1, [3:0]=pi0 */
+	unsigned int pn_swap;
+	unsigned int bit_swap; /* MSB/LSB reverse */
+	unsigned int phy_vswing;
+	unsigned int phy_preem;
+
+	/* internal used */
+	unsigned int pi_clk_sel; /* bit[9:0] */
+	unsigned int bit_rate; /* Hz */
+};
+
+struct lcd_ctrl_config_s {
+	struct ttl_config_s *ttl_config;
+	struct lvds_config_s *lvds_config;
+	struct vbyone_config_s *vbyone_config;
+	struct dsi_config_s *mipi_config;
+	struct mlvds_config_s *mlvds_config;
+};
+
+/* **********************************
+ * power control define
+ * ********************************** */
+enum lcd_power_type_e {
+	LCD_POWER_TYPE_CPU = 0,
+	LCD_POWER_TYPE_PMU,
+	LCD_POWER_TYPE_SIGNAL,
+	LCD_POWER_TYPE_EXTERN,
+	LCD_POWER_TYPE_MAX,
+};
+
+#define LCD_CPU_GPIO_NAME_MAX        15
+
+/* Power Control */
+#define LCD_CPU_GPIO_NUM_MAX         10
+
+#define LCD_PWR_STEP_MAX             15
+struct lcd_power_step_s {
+	unsigned char type;
+	int index; /* point to lcd_cpu_gpio or lcd_extern */
+	unsigned short value;
+	unsigned short delay;
+};
+
+struct lcd_power_ctrl_s {
+	char cpu_gpio[LCD_CPU_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX];
+	struct lcd_power_step_s power_on_step[LCD_PWR_STEP_MAX];
+	struct lcd_power_step_s power_off_step[LCD_PWR_STEP_MAX];
+};
+
+#define LCD_PINMX_MAX              20
+#define BL_PINMUX_MAX              20
+#define LCD_PINMUX_NAME_LEN_MAX    30
+struct lcd_pinmux_ctrl_s {
+	char *name;
+	unsigned int pinmux_set[LCD_PINMUX_NUM][2];
+	unsigned int pinmux_clr[LCD_PINMUX_NUM][2];
+};
+
+#define LCD_ENABLE_RETRY_MAX    3
+struct lcd_config_s {
+	unsigned char lcd_mode;
+	unsigned char lcd_key_valid;
+	unsigned char lcd_clk_path; /* 0=hpll, 1=gp0_pll */
+	unsigned char retry_enable_flag;
+	unsigned char retry_enable_cnt;
+	unsigned int backlight_index;
+	struct lcd_basic_s lcd_basic;
+	struct lcd_timing_s lcd_timing;
+	struct lcd_ctrl_config_s lcd_control;
+	struct lcd_power_ctrl_s *lcd_power;
+	unsigned char pinctrl_ver;
+	struct lcd_pinmux_ctrl_s *lcd_pinmux;
+	unsigned int pinmux_set[LCD_PINMUX_NUM][2];
+	unsigned int pinmux_clr[LCD_PINMUX_NUM][2];
+};
+
+extern struct lcd_config_s lcd_config_dft;
+
+/* ==============backlight control config================== */
+enum bl_ctrl_method_e {
+	BL_CTRL_GPIO = 0,
+	BL_CTRL_PWM,
+	BL_CTRL_PWM_COMBO,
+	BL_CTRL_LOCAL_DIMMING,
+	BL_CTRL_EXTERN,
+	BL_CTRL_MAX,
+};
+
+enum bl_pwm_method_e {
+	BL_PWM_NEGATIVE = 0,
+	BL_PWM_POSITIVE,
+	BL_PWM_METHOD_MAX,
+};
+
+enum bl_pwm_port_e {
+	BL_PWM_A = 0,
+	BL_PWM_B,
+	BL_PWM_C,
+	BL_PWM_D,
+	BL_PWM_E,
+	BL_PWM_F,
+	BL_PWM_VS,
+	BL_PWM_MAX,
+};
+
+enum bl_off_policy_e {
+	BL_OFF_POLICY_NONE = 0,
+	BL_OFF_POLICY_ALWAYS,
+	BL_OFF_POLICY_ONCE,
+	BL_OFF_POLICY_MAX,
+};
+
+#define XTAL_FREQ_HZ		(24*1000*1000) /* 24M in HZ */
+#define XTAL_HALF_FREQ_HZ	(24*1000*500)  /* 24M/2 in HZ */
+
+#define BL_FREQ_DEFAULT			1000 /* unit: HZ */
+#define BL_FREQ_VS_DEFAULT		2    /* multiple 2 of vfreq */
+
+#define BL_LEVEL_MAX		255
+#define BL_LEVEL_MIN		10
+#define BL_LEVEL_OFF		1
+
+#define BL_LEVEL_MID		128
+#define BL_LEVEL_MID_MAPPED	BL_LEVEL_MID //102
+#define BL_LEVEL_DEFAULT	BL_LEVEL_MID
+
+#define BL_GPIO_NUM_MAX		5
+
+struct bl_pwm_config_s {
+	unsigned int index;
+	enum bl_pwm_method_e pwm_method;
+	enum bl_pwm_port_e pwm_port;
+	unsigned int level_max;
+	unsigned int level_min;
+	unsigned int pwm_freq; /* pwm_vs: 1~4(vfreq), pwm: freq(unit: Hz) */
+	unsigned int pwm_duty; /* unit: % */
+	unsigned int pwm_duty_max; /* unit: % */
+	unsigned int pwm_duty_min; /* unit: % */
+	unsigned int pwm_cnt; /* internal used for pwm control */
+	unsigned int pwm_pre_div; /* internal used for pwm control */
+	unsigned int pwm_max; /* internal used for pwm control */
+	unsigned int pwm_min; /* internal used for pwm control */
+	unsigned int pwm_level; /* internal used for pwm control */
+	unsigned int pwm_gpio;
+	unsigned int pwm_gpio_off;
+	unsigned int pinmux_flag;
+	unsigned int pinmux_set[10][2];
+	unsigned int pinmux_clr[10][2];
+};
+
+struct bl_config_s {
+	unsigned char bl_key_valid;
+	char name[20];
+	int level_default;
+	int level_min;
+	int level_max;
+	int level_mid;
+	int level_mid_mapping;
+	int level;
+
+	enum bl_ctrl_method_e method;
+	unsigned int en_gpio;
+	unsigned int en_gpio_on;
+	unsigned int en_gpio_off;
+	unsigned short power_on_delay;
+	unsigned short power_off_delay;
+	unsigned int dim_max;
+	unsigned int dim_min;
+	unsigned int en_sequence_reverse;
+
+	struct bl_pwm_config_s *bl_pwm;
+	struct bl_pwm_config_s *bl_pwm_combo0;
+	struct bl_pwm_config_s *bl_pwm_combo1;
+	unsigned int pwm_on_delay;
+	unsigned int pwm_off_delay;
+
+	char gpio_name[BL_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX];
+	unsigned char pinctrl_ver;
+	struct lcd_pinmux_ctrl_s *bl_pinmux;
+	unsigned int pinmux_set[10][2];
+	unsigned int pinmux_clr[10][2];
+	int bl_extern_index;
+};
+
+extern struct bl_config_s bl_config_dft;
+
+/* ==============lcd driver================== */
+struct aml_lcd_drv_s {
+	char version[15];
+	enum lcd_chip_e chip_type;
+	unsigned char lcd_status;
+
+	struct lcd_config_s *lcd_config;
+	struct bl_config_s *bl_config;
+
+	int  (*outputmode_check)(char *mode, unsigned int frac);
+	int  (*config_check)(char *mode, unsigned int frac);
+	void (*driver_init_pre)(void);
+	int  (*driver_init)(void);
+	void (*driver_disable)(void);
+	void (*list_support_mode)(void);
+	int  (*lcd_probe)(void);
+	int  (*lcd_outputmode_check)(char *mode, unsigned int frac);
+	void (*lcd_prepare)(char *mode, unsigned int frac);
+	void (*lcd_enable)(char *mode, unsigned int frac);
+	void (*lcd_disable)(void);
+	void (*lcd_set_ss)(int level);
+	char *(*lcd_get_ss)(void);
+	void (*lcd_test)(int num);
+	void (*lcd_clk)(void);
+	void (*lcd_info)(void);
+	void (*lcd_reg)(void);
+	void (*lcd_tcon_reg)(void);
+	void (*lcd_tcon_table)(void);
+	void (*bl_power_ctrl)(int status);
+	void (*bl_set_level)(unsigned int level);
+	unsigned int (*bl_get_level)(void);
+	void (*bl_config_print)(void);
+	int unifykey_test_flag;
+	void (*unifykey_test)(void);
+	void (*unifykey_tcon_test)(void);
+	void (*unifykey_dump)(void);
+	void (*lcd_extern_info)(void);
+
+	/* for factory test */
+	struct lcd_power_step_s *factory_lcd_power_on_step;
+	int factory_bl_power_on_delay;
+};
+
+extern void lcd_config_bsp_init(void);
+
+extern struct aml_lcd_drv_s *aml_lcd_get_driver(void);
+
+extern int lcd_probe(void);
+
+#endif /* INC_AML_LCD_VOUT_H */
diff --git a/include/amlogic/media/vpp/vpp.h b/include/amlogic/media/vpp/vpp.h
new file mode 100644
index 0000000000..d77ddd3879
--- /dev/null
+++ b/include/amlogic/media/vpp/vpp.h
@@ -0,0 +1,24 @@
+#ifndef _VPP_INC_H_
+#define _VPP_INC_H_
+
+extern void vpp_init(void);
+void vpp_pq_init(int brightness, int contrast, int sat, int hue);
+void vpp_pq_load(void);
+
+#define VPP_CM_RGB    0   /* same as COLOR_FMT_RGB444*/
+#define VPP_CM_YUV    2   /* same as COLOR_FMT_YUV444*/
+
+enum vpp_gamma_sel_e {
+	VPP_GAMMA_R = 0,
+	VPP_GAMMA_G,
+	VPP_GAMMA_B
+};
+
+extern void vpp_load_gamma_table(unsigned short *data, unsigned int len, enum vpp_gamma_sel_e flag);
+extern void vpp_init_lcd_gamma_table(void);
+
+extern void vpp_matrix_update(int type);
+extern void vpp_viu2_matrix_update(int type);
+extern void hdr_tx_pkt_cb(void);
+
+#endif
diff --git a/include/amlogic/media/vpu/vpu.h b/include/amlogic/media/vpu/vpu.h
new file mode 100644
index 0000000000..26bd575e07
--- /dev/null
+++ b/include/amlogic/media/vpu/vpu.h
@@ -0,0 +1,11 @@
+#ifndef _VPU_INC_H_
+#define _VPU_INC_H_
+
+extern void vcbus_test(void);
+extern int vpu_probe(void);
+extern int vpu_remove(void);
+extern int vpu_clk_change(int level);
+extern void vpu_clk_get(void);
+extern void vpu_info_print(void);
+
+#endif
diff --git a/include/amlogic/saradc.h b/include/amlogic/saradc.h
new file mode 100644
index 0000000000..7344a2bfa1
--- /dev/null
+++ b/include/amlogic/saradc.h
@@ -0,0 +1,103 @@
+#ifndef __MESON_SARADC_H__
+#define __MESON_SARADC_H__
+
+#include <common.h>
+#include <adc.h>
+#include <clk.h>
+
+enum ADC_CHANNEL_TYPE {
+	MESON_SARADC_CH0 = 0,
+	MESON_SARADC_CH1,
+	MESON_SARADC_CH2,
+	MESON_SARADC_CH3,
+	MESON_SARADC_CH4,
+	MESON_SARADC_CH5,
+	MESON_SARADC_CH6,
+	MESON_SARADC_CH7,
+	MESON_SARADC_CH_MAX,
+};
+
+enum MESON_SARADC_AVG_MODE {
+	NO_AVERAGING = 0x0,
+	MEAN_AVERAGING = 0x1,
+	MEDIAN_AVERAGING = 0x2,
+};
+
+enum MESON_SARADC_NUM_SAMPLES {
+	ONE_SAMPLE = 0x0,
+	TWO_SAMPLES = 0x1,
+	FOUR_SAMPLES = 0x2,
+	EIGHT_SAMPLES = 0x3,
+};
+
+enum MESON_SARADC_RESOLUTION {
+	SARADC_10BIT = 10,
+	SARADC_12BIT = 12,
+	SARADC_22BIT = 22,
+};
+
+enum MESON_SARADC_BIT_STATE {
+	BIT_LOW = 0,
+	BIT_HIGH = 1,
+};
+
+struct meson_saradc;
+
+struct meson_saradc_diff_ops {
+	void (*extra_init)(struct meson_saradc *priv);
+	void (*set_ch7_mux)(struct meson_saradc *priv, int ch, int mux);
+	void (*enable_decim_filter)(struct meson_saradc *priv,
+				    int ch, unsigned int mode);
+	void (*set_ref_voltage)(struct meson_saradc *priv, unsigned int mode);
+	int (*get_fifo_channel)(int val);
+	int (*get_fifo_data)(struct meson_saradc *priv,
+			     struct adc_uclass_platdata *uc_pdata, int val);
+};
+
+/*
+ * struct meson_saradc_data - describe the differences of different platform
+ *
+ * @reg3_ring_counter_disable: to disable continuous ring counter.
+ * gxl and later: 1; others(gxtvbb etc): 0
+ * @reg11_vref_en: g12a and later: 0; others(axg etc): 1
+ * @reg11_cmv_sel: g12a and later: 0; others(axg etc): 1
+ * @reg11_eoc:     g12a and later: 1; others(axg etc): 0
+ * @has_bl30_integration:
+ * @num_channels: the number of adc channels
+ * @self_test_channel: channel of self-test
+ * @resolution: gxl and later: 12bit; others(gxtvbb etc): 10bit
+ * @clock_rate: saradc clock rate
+ */
+struct meson_saradc_data {
+	bool reg3_ring_counter_disable;
+	bool reg11_vref_en;
+	bool reg11_cmv_sel;
+	bool reg11_eoc;
+	bool has_bl30_integration;
+	unsigned char self_test_channel;
+	unsigned char num_channels;
+	unsigned int resolution;
+	const struct meson_saradc_diff_ops *dops;
+	unsigned int capacity;
+	unsigned long clock_rate;
+};
+
+struct meson_saradc {
+	phys_addr_t base;
+	int active_channel;
+	unsigned int current_mode;
+	struct clk xtal;
+	struct clk adc_mux;
+	struct clk adc_div;
+	struct clk adc_gate;
+	struct meson_saradc_data *data;
+};
+
+extern const struct adc_ops meson_saradc_ops;
+int meson_saradc_probe(struct udevice *dev);
+int meson_saradc_remove(struct udevice *dev);
+int meson_saradc_ofdata_to_platdata(struct udevice *dev);
+
+#define SARADC_CH_SELF_TEST	MESON_SARADC_CH7
+
+#endif /*_MESON_SARADC_H_*/
diff --git a/include/amlogic/secure_storage.h b/include/amlogic/secure_storage.h
new file mode 100644
index 0000000000..3a0148204b
--- /dev/null
+++ b/include/amlogic/secure_storage.h
@@ -0,0 +1,46 @@
+#ifndef __SECURE_STORAGE_H__
+#define __SECURE_STORAGE_H__
+
+/* return value*/
+#define RET_OK		0
+#define RET_EFAIL	1
+#define RET_EINVAL	2
+#define RET_EMEM	3
+
+#define RET_EUND	-1
+#define SMC_UNK		0xffffffff
+
+
+#ifdef CONFIG_SECURE_STORAGE
+/* funtion name: secure_storage_write
+ * keyname : key name is ascii string
+ * keybuf : key buf
+ * keylen : key buf len
+ * keyattr: Secure/Normal, ...
+ *
+ * return  0: ok, 0x1fe: no space, other fail
+ * */
+int32_t secure_storage_write(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t keyattr);
+int32_t secure_storage_read(uint8_t *keyname, uint8_t *keybuf,
+				uint32_t keylen, uint32_t *reallen);
+int32_t secure_storage_query(uint8_t *keyname, uint32_t *retval);
+int32_t secure_storage_tell(uint8_t *keyname, uint32_t *retval);
+int32_t secure_storage_verify(uint8_t *keyname, uint8_t *hashbuf);
+int32_t secure_storage_status(uint8_t *keyname, uint32_t *retval);
+void *secure_storage_getbuffer(uint32_t *size);
+void secure_storage_notifier(void);
+void secure_storage_notifier_ex(uint32_t storagesize, uint32_t rsvarg);
+int32_t secure_storage_list(uint8_t *listbuf, uint32_t buflen,
+				uint32_t *readlen);
+int32_t secure_storage_remove(uint8_t *keyname);
+void secure_storage_set_info(uint32_t info);
+int32_t secure_storage_set_enctype(uint32_t type);
+/* return 0: success, -1: fail*/
+int32_t secure_storage_get_enctype(void);
+/*return -1: no storage, 0: default enc, 1: efuse enc, 2: fixed enc*/
+int32_t secure_storage_version(void);
+/*return -1: no storage, others: version*/
+#endif
+
+#endif
diff --git a/include/amlogic/sound.h b/include/amlogic/sound.h
new file mode 100644
index 0000000000..4aceb7c9fd
--- /dev/null
+++ b/include/amlogic/sound.h
@@ -0,0 +1,180 @@
+/*
+ * include/amlogic/sound.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _SOUND_H_
+#define _SOUND_H_
+
+#define AIU_958_BPF			0x1500
+#define AIU_958_BRST		0x1501
+#define AIU_958_LENGTH		0x1502
+#define AIU_958_PADDSIZE	0x1503
+#define AIU_958_MISC		0x1504
+#define AIU_958_FORCE_LEFT	0x1505
+#define AIU_958_DISCARD_NUM	0x1506
+#define AIU_958_DCU_FF_CTRL	0x1507
+#define AIU_958_CHSTAT_L0	0x1508
+#define AIU_958_CHSTAT_L1	0x1509
+#define AIU_958_CTRL		0x150a
+#define AIU_958_RPT			0x150b
+#define AIU_I2S_MUTE_SWAP	0x150c
+#define AIU_I2S_SOURCE_DESC	0x150d
+#define AIU_I2S_MED_CTRL	0x150e
+#define AIU_I2S_MED_THRESH	0x150f
+#define AIU_I2S_DAC_CFG		0x1510
+#define AIU_I2S_SYNC		0x1511
+#define AIU_I2S_MISC		0x1512
+#define AIU_I2S_OUT_CFG		0x1513
+#define AIU_I2S_FF_CTRL		0x1514
+#define AIU_RST_SOFT		0x1515
+#define AIU_CLK_CTRL		0x1516
+#define AIU_MIX_ADCCFG		0x1517
+#define AIU_MIX_CTRL		0x1518
+#define AIU_CLK_CTRL_MORE	0x1519
+#define AIU_958_POP			0x151a
+#define AIU_MIX_GAIN		0x151b
+#define AIU_958_SYNWORD1	0x151c
+#define AIU_958_SYNWORD2	0x151d
+#define AIU_958_SYNWORD3	0x151e
+#define AIU_958_SYNWORD1_MASK	0x151f
+#define AIU_958_SYNWORD2_MASK	0x1520
+#define AIU_958_SYNWORD3_MASK	0x1521
+#define AIU_958_FFRDOUT_THD		0x1522
+#define AIU_958_LENGTH_PER_PAUSE	0x1523
+#define AIU_958_PAUSE_NUM		0x1524
+#define AIU_958_PAUSE_PAYLOAD	0x1525
+#define AIU_958_AUTO_PAUSE		0x1526
+#define AIU_958_PAUSE_PD_LENGTH	0x1527
+#define AIU_CODEC_DAC_LRCLK_CTRL	0x1528
+#define AIU_CODEC_ADC_LRCLK_CTRL	0x1529
+#define AIU_HDMI_CLK_DATA_CTRL		0x152a
+#define AIU_CODEC_CLK_DATA_CTRL		0x152b
+#define AIU_ACODEC_CTRL			0x152c
+#define AIU_958_CHSTAT_R0		0x1530
+#define AIU_958_CHSTAT_R1		0x1531
+#define AIU_958_VALID_CTRL		0x1532
+#define AIU_AUDIO_AMP_REG0		0x153c
+#define AIU_AUDIO_AMP_REG1		0x153d
+#define AIU_AUDIO_AMP_REG2		0x153e
+#define AIU_AUDIO_AMP_REG3		0x153f
+#define AIU_AIFIFO2_CTRL		0x1540
+#define AIU_AIFIFO2_STATUS		0x1541
+#define AIU_AIFIFO2_GBIT		0x1542
+#define AIU_AIFIFO2_CLB			0x1543
+#define AIU_CRC_CTRL			0x1544
+#define AIU_CRC_STATUS			0x1545
+#define AIU_CRC_SHIFT_REG		0x1546
+#define AIU_CRC_IREG			0x1547
+#define AIU_CRC_CAL_REG1		0x1548
+#define AIU_CRC_CAL_REG0		0x1549
+#define AIU_CRC_POLY_COEF1		0x154a
+#define AIU_CRC_POLY_COEF0		0x154b
+#define AIU_CRC_BIT_SIZE1		0x154c
+#define AIU_CRC_BIT_SIZE0		0x154d
+#define AIU_CRC_BIT_CNT1		0x154e
+#define AIU_CRC_BIT_CNT0		0x154f
+#define AIU_AMCLK_GATE_HI		0x1550
+#define AIU_AMCLK_GATE_LO		0x1551
+#define AIU_AMCLK_MSR			0x1552
+#define AIU_AUDAC_CTRL0			0x1553
+#define AIU_DELTA_SIGMA0		0x1555
+#define AIU_DELTA_SIGMA1		0x1556
+#define AIU_DELTA_SIGMA2		0x1557
+#define AIU_DELTA_SIGMA3		0x1558
+#define AIU_DELTA_SIGMA4		0x1559
+#define AIU_DELTA_SIGMA5		0x155a
+#define AIU_DELTA_SIGMA6		0x155b
+#define AIU_DELTA_SIGMA7		0x155c
+#define AIU_DELTA_SIGMA_LCNTS	0x155d
+#define AIU_DELTA_SIGMA_RCNTS	0x155e
+#define AIU_MEM_I2S_START_PTR	0x1560
+#define AIU_MEM_I2S_RD_PTR		0x1561
+#define AIU_MEM_I2S_END_PTR		0x1562
+#define AIU_MEM_I2S_MASKS		0x1563
+#define AIU_MEM_I2S_CONTROL		0x1564
+#define AIU_MEM_IEC958_START_PTR	0x1565
+#define AIU_MEM_IEC958_RD_PTR		0x1566
+#define AIU_MEM_IEC958_END_PTR		0x1567
+#define AIU_MEM_IEC958_MASKS		0x1568
+#define AIU_MEM_IEC958_CONTROL		0x1569
+#define AIU_MEM_AIFIFO2_START_PTR	0x156a
+#define AIU_MEM_AIFIFO2_CURR_PTR	0x156b
+#define AIU_MEM_AIFIFO2_END_PTR		0x156c
+#define AIU_MEM_AIFIFO2_BYTES_AVAIL	0x156d
+#define AIU_MEM_AIFIFO2_CONTROL		0x156e
+#define AIU_MEM_AIFIFO2_MAN_WP		0x156f
+#define AIU_MEM_AIFIFO2_MAN_RP		0x1570
+#define AIU_MEM_AIFIFO2_LEVEL		0x1571
+#define AIU_MEM_AIFIFO2_BUF_CNTL	0x1572
+#define AIU_MEM_I2S_MAN_WP		0x1573
+#define AIU_MEM_I2S_MAN_RP		0x1574
+#define AIU_MEM_I2S_LEVEL		0x1575
+#define AIU_MEM_I2S_BUF_CNTL	0x1576
+#define AIU_MEM_I2S_BUF_WRAP_COUNT	0x1577
+#define AIU_MEM_I2S_MEM_CTL			0x1578
+#define AIU_MEM_IEC958_MEM_CTL		0x1579
+#define AIU_MEM_IEC958_WRAP_COUNT	0x157a
+#define AIU_MEM_IEC958_IRQ_LEVEL	0x157b
+#define AIU_MEM_IEC958_MAN_WP		0x157c
+#define AIU_MEM_IEC958_MAN_RP		0x157d
+#define AIU_MEM_IEC958_LEVEL		0x157e
+#define AIU_MEM_IEC958_BUF_CNTL		0x157f
+#define AIU_AIFIFO_CTRL		0x1580
+#define AIU_AIFIFO_STATUS	0x1581
+#define AIU_AIFIFO_GBIT		0x1582
+#define AIU_AIFIFO_CLB		0x1583
+#define AIU_MEM_AIFIFO_START_PTR	0x1584
+#define AIU_MEM_AIFIFO_CURR_PTR		0x1585
+#define AIU_MEM_AIFIFO_END_PTR		0x1586
+#define AIU_MEM_AIFIFO_BYTES_AVAIL	0x1587
+#define AIU_MEM_AIFIFO_CONTROL		0x1588
+#define AIU_MEM_AIFIFO_MAN_WP		0x1589
+#define AIU_MEM_AIFIFO_MAN_RP		0x158a
+#define AIU_MEM_AIFIFO_LEVEL		0x158b
+#define AIU_MEM_AIFIFO_BUF_CNTL		0x158c
+#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT	0x158d
+#define AIU_MEM_AIFIFO2_BUF_WRAP_COUNT	0x158e
+#define AIU_MEM_AIFIFO_MEM_CTL		0x158f
+#define AIFIFO_TIME_STAMP_CNTL		0x1590
+#define AIFIFO_TIME_STAMP_SYNC_0	0x1591
+#define AIFIFO_TIME_STAMP_SYNC_1	0x1592
+#define AIFIFO_TIME_STAMP_0			0x1593
+#define AIFIFO_TIME_STAMP_1			0x1594
+#define AIFIFO_TIME_STAMP_2			0x1595
+#define AIFIFO_TIME_STAMP_3			0x1596
+#define AIFIFO_TIME_STAMP_LENGTH	0x1597
+#define AIFIFO2_TIME_STAMP_CNTL		0x1598
+#define AIFIFO2_TIME_STAMP_SYNC_0	0x1599
+#define AIFIFO2_TIME_STAMP_SYNC_1	0x159a
+#define AIFIFO2_TIME_STAMP_0		0x159b
+#define AIFIFO2_TIME_STAMP_1		0x159c
+#define AIFIFO2_TIME_STAMP_2		0x159d
+#define AIFIFO2_TIME_STAMP_3		0x159e
+#define AIFIFO2_TIME_STAMP_LENGTH	0x159f
+#define IEC958_TIME_STAMP_CNTL		0x15a0
+#define IEC958_TIME_STAMP_SYNC_0	0x15a1
+#define IEC958_TIME_STAMP_SYNC_1	0x15a2
+#define IEC958_TIME_STAMP_0		0x15a3
+#define IEC958_TIME_STAMP_1		0x15a4
+#define IEC958_TIME_STAMP_2		0x15a5
+#define IEC958_TIME_STAMP_3		0x15a6
+#define IEC958_TIME_STAMP_LENGTH	0x15a7
+#define AIU_MEM_AIFIFO2_MEM_CTL		0x15a8
+#define AIU_I2S_CBUS_DDR_CNTL		0x15a9
+#define AIU_I2S_CBUS_DDR_WDATA		0x15aa
+#define AIU_I2S_CBUS_DDR_ADDR		0x15ab
+
+int aml_audio_init(void);
+
+#endif /* _SOUND_H_ */
diff --git a/include/amlogic/spicc.h b/include/amlogic/spicc.h
new file mode 100644
index 0000000000..282af845c5
--- /dev/null
+++ b/include/amlogic/spicc.h
@@ -0,0 +1,44 @@
+/*
+ * Amlogic Meson SPI communication controller(SPICC)
+ *
+ * Copyright (C) 2017 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ */
+
+#ifndef __SPICC_H__
+#define __SPICC_H__
+
+#define SPICC_DEFAULT_CLK_RATE 166666666
+#define CS_GPIO_MAX 2
+
+/*
+ * @compatible:
+ * @reg: controller registers address.
+ * @mem_map: memory_mapped for read operations.
+ * @clk_rate:
+ * @clk_set_rate:
+ * @pinctrl_enable:
+ * @num_chipselect:
+ * @cs_gpios:
+ */
+struct spicc_platdata {
+#ifndef CONFIG_OF_CONTROL
+	char *compatible;
+	int clk_rate;
+	int (*clk_set_rate)(int rate);
+	int (*clk_enable)(bool enable);
+	int (*pinctrl_enable)(bool enable);
+#endif
+	void __iomem *reg;
+	const char *cs_gpio_names[CS_GPIO_MAX];
+	unsigned int clk_cs_delay;
+	unsigned int mo_delay;
+	unsigned int mi_delay;
+	unsigned int mi_capture_delay;
+	unsigned int tt_delay;
+	unsigned int ti_delay;
+};
+
+#endif /* __SPICC_H__ */
\ No newline at end of file
diff --git a/include/amlogic/spifc.h b/include/amlogic/spifc.h
new file mode 100644
index 0000000000..0eb759896a
--- /dev/null
+++ b/include/amlogic/spifc.h
@@ -0,0 +1,44 @@
+/*
+ * Amlogic SPI flash controller(SPIFC)
+ *
+ * Copyright (C) 2018 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ */
+
+#ifndef __SPIFC_H__
+#define __SPIFC_H__
+
+/*
+ * @reg: controller registers base address.
+ * @mem_map: memory_mapped for read operations.
+ * @core: clk source, usually clk_81, 166M max.
+ * @speed: spi bus frequency, and you should know
+ *			we use clk_81 as the clk source now, max
+ *	  		speed is 166M.
+ * @io_num: max io number, SIO0 SIO1 SIO2 SIO3.
+ * @max_cs: the max slave device number, we support
+ * 			spi-nor, spi-nand now.
+ * @cs_gpios: gpio array, we use the cs pin as
+ *            gpio, cause the spifc controller
+ *            can not hold enough time sometimes.
+ */
+
+struct spifc_platdata {
+	ulong reg;
+	ulong mem_map;
+	u32 speed;
+	u32 mode;
+	u32 io_num;
+	u32 max_cs;
+};
+
+/* this is cs pin number, not slave device cs number */
+/* #define SPIFC_MAX_CS	1 */
+#define SPIFC_BUS_NUM	0
+/* slave device cs number */
+#define SPIFC_SNOR_CS	0
+#define SPIFC_SNAND_CS	1
+
+#endif /* __SPIFC_H__ */
\ No newline at end of file
diff --git a/include/amlogic/storage.h b/include/amlogic/storage.h
new file mode 100644
index 0000000000..5bdb4cb00e
--- /dev/null
+++ b/include/amlogic/storage.h
@@ -0,0 +1,501 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Header file of storage interface module
+ *
+ * Copyright (C) 2018 Amlogic Corporation
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ */
+
+#ifndef __STORAGE_H__
+#define __STORAGE_H__
+
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#include <jffs2/jffs2.h>
+
+#define RSV_UNVAIL	140	/* rsv unvail error */
+
+#define DISPROTECT_KEY			BIT(0)
+#define DISPROTECT_SECURE		BIT(1)
+#define DISPROTECT_FBBT			BIT(2)
+#define DISPROTECT_HYNIX		BIT(3)
+
+#define PART_PROTECT_FLAG		BIT(4)
+enum boot_type_e {
+	BOOT_EMMC = 1,
+	BOOT_SD = 1 << 1,
+	BOOT_NAND_NFTL = 1 << 2,
+	BOOT_NAND_MTD = 1 << 3,
+	BOOT_SNAND = 1 << 4,/* spi nand */
+	BOOT_SNOR = 1 << 5,/* spi nor */
+	BOOT_NONE = 0xFF
+};
+
+#define RSV_KEY "key"
+#define RSV_ENV "env"
+#define RSV_DTB "dtb"
+#define RSV_BBT "bbt"
+
+#define DISCRETE_BOOTLOADER 1
+#define COMPACT_BOOTLOADER 0
+
+struct nand_startup_parameter {
+	int page_size;
+	int block_size;
+	int layout_reserve_size;
+	int pages_per_block;
+	int setup_data;
+	/* */
+	int page0_disable;
+};
+
+#define BL2E_STORAGE_PARAM_SIZE		(0x80)
+#define BOOT_FIRST_BLOB_SIZE        (254*1024)
+#define BOOT_FILLER_SIZE            (4*1024)
+#define BOOT_RESERVED_SIZE          (4*1024)
+#define BOOT_RANDOM_NONCE           (16)
+#define BOOT_BL2E_SIZE              (66672) //74864-8K
+#define BOOT_EBL2E_SIZE             (BOOT_FILLER_SIZE + BOOT_RESERVED_SIZE + BOOT_BL2E_SIZE)
+#define BOOT_BL2X_SIZE              (66672)
+#define MAX_BOOT_AREA_ENTRIES		(8)
+/* bl2 core address base */
+#define BL2_CORE_BASE_OFFSET_EMMC	(0x200)
+/* boot area entry index */
+#define BOOT_AREA_BB1ST             (0)
+/* filler and reserved are considered part of the bl2E in storage view */
+#define BOOT_AREA_BL2E              (1)
+#define BOOT_AREA_BL2X              (2)
+#define BOOT_AREA_DDRFIP            (3)
+#define BOOT_AREA_DEVFIP            (4)
+#define BOOT_AREA_INVALID           (MAX_BOOT_AREA_ENTRIES)
+
+typedef struct boot_area_entry {
+    /* name */
+    char name[11];
+    /* index */
+    uint8_t idx;
+    uint64_t offset;
+    uint64_t size;
+} boot_area_entry_t;
+
+struct boot_layout {
+    boot_area_entry_t *boot_entry;
+};
+
+struct emmc_startup_parameter {
+	//sd_emmc_setup_t setup;
+};
+
+struct spi_nand_startup_parameter {
+	uint32_t pagesize;
+	uint32_t pages_per_eraseblock;
+	uint32_t eraseblocks_per_lun;
+	uint32_t planes_per_lun;
+	uint32_t luns_per_target;
+	uint32_t ntargets;
+	int layout_reserve_size;
+};
+
+struct storage_boot_entry {
+	uint32_t offset;
+	uint32_t size;
+};
+
+union storage_independent_parameter {
+	struct nand_startup_parameter nsp;
+	struct emmc_startup_parameter esp;
+	struct spi_nand_startup_parameter snasp;
+};
+
+struct storage_startup_parameter {
+	uint8_t boot_device;
+	uint8_t	boot_seq;
+	uint8_t	boot_bakups;
+	uint8_t reserved;
+	struct storage_boot_entry boot_entry[MAX_BOOT_AREA_ENTRIES];
+	union storage_independent_parameter sip;
+};
+
+struct storage_info_t {
+	u8 name[32];
+	u8 id[8];
+	u32 read_unit;
+	u32 write_unit;
+	u32 erase_unit;
+	u64 caps;/* total size */
+	u8 mode;/* bootloader mode, compact or  discrete */
+};
+
+struct storage_t {
+	enum boot_type_e type;
+	struct storage_info_t info;
+	u32 init_flag;
+	struct list_head list;
+	int (*get_part_count)(void);
+	int (*list_part_name)(int idx, char *part_name);
+	/* when part_name is null, default to ops in whole chip */
+	/* int (*block_is_bad)(const char *part_name, loff_t off); */
+	u64 (*get_part_size)(const char *part_name);
+	int (*read)(const char *part_name, loff_t off,
+		    size_t size, void *dest);
+	int (*write)(const char *part_name, loff_t off,
+		     size_t size, void *source);
+	int (*erase)(const char *part_name, loff_t off,
+		     size_t size, int scrub_flag);
+
+#define BOOT_OPS_ALL 0xFF/* for cpy parameter operates all copies */
+	u8 (*get_copies)(const char *part_name);
+	u64 (*get_copy_size)(const char *part_name);
+	int (*boot_read)(const char *part_name,
+			 u8 cpy, size_t size, void *dest);
+	int (*boot_write)(const char *part_name,
+			  u8 cpy, size_t size, void *source);
+	int (*boot_erase)(const char *part_name, u8 cpy);
+
+	u32 (*get_rsv_size)(const char *rsv_name);
+	int (*read_rsv)(const char *rsv_name, size_t size, void *buf);
+	int (*write_rsv)(const char *rsv_name, size_t size, void *buf);
+	int (*erase_rsv)(const char *rsv_name);
+	int (*protect_rsv)(const char *rsv_name,
+			   bool ops);/*true:on false:off*/
+};
+
+struct device_node_t {
+	enum boot_type_e index;
+	char *type;
+	int (*pre)(void);
+	int (*probe)(u32 init_flag);
+};
+
+/**
+ * we use a valid device list to manage the storage devices,
+ * and every type of device can only exist ONE in this list.
+ * we will scan and add the valid storage device to the list
+ * in the init process, and of cause you can register the device
+ * by you own.
+ */
+#define NAND_BOOT_NORMAL                0
+#define NAND_BOOT_UPGRATE               1
+#define NAND_BOOT_ERASE_PROTECT_CACHE   2
+#define NAND_BOOT_ERASE_ALL             3
+#define NAND_BOOT_SCRUB_ALL             4
+#define NAND_SCAN_ID_INIT               5
+/**
+ * @usage: init all the valid storage device
+ *
+ * @init_flag: it's only works for MLC/EMMC driver
+ * 0 NAND_BOOT_NORMAL:normal init, but can't operates the phy data area
+ * 1 NAND_BOOT_UPGRATE:same as 0, but operation on phy data area is allowed
+ * 2 NAND_BOOT_ERASE_PROTECT_CACHE:only erase rsv area
+ * 3 NAND_BOOT_ERASE_ALL:erase whole device
+ * 4 NAND_BOOT_SCRUB_ALL:erase whole device
+ * 5 NAND_SCAN_ID_INIT:only read nand id
+ *
+ * @return: init result
+ *          0 = failed
+ *          other = device_index that device probe successfully
+ */
+int store_init(u32 init_flag);
+
+/**
+ * @usage: register a storage device to the valid list
+ *
+ * @param: the description pointer of your storage device
+ *
+ * @return: registration result
+ *          0 = success
+ *          1 = fail
+ */
+int store_register(struct storage_t *store_dev);
+
+/**
+ * @usage: unregister a storage device from the valid list
+ *
+ * @store_dev: the description pointer of your storage device
+ */
+void store_unregister(struct storage_t *store_dev);
+
+/**
+ * @usage: check the type of device is valid on this board
+ *
+ * @type: the device type that you want to check
+ *
+ * @return: is the device valid
+ *          0 = invalid
+ *          1 = valid
+ */
+u8 store_device_valid(enum boot_type_e type);
+
+/**
+ * @usage: set the 'type' device as current device, and you can operates it
+ *
+ * @type: the device type that you want to set
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_set_device(enum boot_type_e type);
+
+/**
+ * @usage: get the type of current storage device
+ *
+ * @return: storage device type
+ */
+enum boot_type_e store_get_type(void);
+
+/**
+ * @usage: get information about the current device
+ *
+ * @info: the pointer for the information
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_get_device_info(struct storage_info_t *info);
+
+/**
+ * @usage: read data from storage device
+ *
+ * @name: partition name, when it's null the target
+ *        will regards as whole device.
+ * @off: offset to the 0 address of partition/device
+ * @size: the amount of bytes to read
+ * @buf: pointer of target buffer
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_read(const char *name, loff_t off, size_t size, void *buf);
+
+/**
+ * @usage: write data to storage device
+ *
+ * @name: partition name, when it's null the target
+ *        will regards as whole device.
+ * @off: offset to the 0 address of partition/device
+ * @size: the amount of bytes to write
+ * @buf: pointer of source buffer
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_write(const char *name, loff_t off, size_t size, void *buf);
+
+/**
+ * @usage: erase the storage device
+ *
+ * @name: partition name, when it's null the target
+ *        will regards as whole device.
+ * @off: offset to the 0 address of partition/device
+ * @size: the amount of bytes to erase
+ * @scrub: scrub flag(scrub operates will works only when the device support)
+ *          0 = no scrub, just erase
+ *          1 = use scrub operates instead of erase
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_erase(const char *name, loff_t off, size_t size, int scrub);
+
+/**
+ * @usage: get the partition size or capacity of device
+ *
+ * @name: partition name, when it's null the target
+ *        will regards as whole device.
+ *
+ * @return: the amount of bytes to the partition or device size
+ */
+u64 store_part_size(const char *name);
+
+/**
+ * @usage: get the copy number of [name]
+ *
+ * @name: only can be "bl2" or "tpl"/"fip" in discrete mode
+ *        be "bootloader" in compact mode
+ * @return: the copy number of the "bootloader" or "tpl"
+ */
+u8 store_boot_copy_num(const char *name);
+
+/**
+ * @usage: get the 1st boot copy nubmer of current device.
+ * for eMMC: 0 -> user partition; 1 -> boot0; 2 -> boot1
+ */
+u8 store_boot_copy_start(void);
+
+/**
+ * @usage: get the bootup index of [name]
+ *
+ * @name: do not care discrete mode or compact mode
+ * 		"bl2" "spl" could be used as the one romboot loaded
+ * 		"fip" "devfip" "tpl" or "bootloader" would be the main u-boot.
+ * @return: the copy number of the "bootloader" or "tpl"
+ */
+u8 store_bootup_bootidx(const char *name);
+
+/**
+ * @usage: restore the bootidx/bootdev etc.
+ */
+void store_restore_bootidx(void);
+
+/**
+ * @usage: get the copy size of [name]
+ *
+ * @name: name: only can be "bl2" or "tpl"/"fip" in discrete mode
+ *        be "bootloader" in compact mode
+ *
+ * @return: the size of every copy
+ */
+u64 store_boot_copy_size(const char *name);
+
+/**
+ * @usage: read the [name] data from storage device
+ *
+ * @name: only can be "bl2" or "tpl"/"fip" in discrete mode
+ *        be "bootloader" in compact mode
+ * @copy: which copy you want read
+ * @size: the amount of bytes to read
+ * @buf: pointer of the target buffer
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_boot_read(const char *name, u8 copy, size_t size, void *buf);
+
+/**
+ * @usage: write the [name] data into storage device
+ *
+ * @name: only can be "bl2" or "tpl"/"fip" in discrete mode
+ *        be "bootloader" in compact mode
+ * @copy: which copy you want write,
+ *        it will write to all copies when copy = BOOT_OPS_ALL
+ * @size: the amount of bytes to write
+ * @buf: pointer of the source buffer
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_boot_write(const char *name, u8 copy, size_t size, void *buf);
+
+/**
+ * @usage: erase the [name] data
+ *
+ * @name: only can be "bl2" or "tpl"/"fip" in discrete mode
+ *        be "bootloader" in compact mode
+ * @copy: which copy you want erase,
+ *        it will erase all copies when copy = BOOT_OPS_ALL
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_boot_erase(const char *name, u8 copy);
+
+/**
+ * @usage: get the rsv info size
+ *
+ * @name: rsv info name, please refer to
+ *        RSV_KEY   "key"
+ *        RSV_ENV   "env"
+ *        RSV_DTB   "dtb"
+ *        RSV_BBT   "bbt"
+ *
+ * @return: the amount bytes of the rsv info
+ */
+u32 store_rsv_size(const char *name);
+
+/**
+ * @usage: read the rsv info from storage device
+ *
+ * @name: rsv info name, please refer to
+ *        RSV_KEY   "key"
+ *        RSV_ENV   "env"
+ *        RSV_DTB   "dtb"
+ *        RSV_BBT   "bbt"
+ * @size: the amount of bytes to read
+ * @buf: pointer of the target buffer
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_rsv_read(const char *name, size_t size, void *buf);
+
+/**
+ * @usage: write the rsv info to the storage device
+ *
+ * @name: rsv info name, please refer to
+ *        RSV_KEY   "key"
+ *        RSV_ENV   "env"
+ *        RSV_DTB   "dtb"
+ *        RSV_BBT   "bbt"
+ * @size: the amount of bytes to write
+ * @buf: pointer of the source buffer
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_rsv_write(const char *name, size_t size, void *buf);
+
+/**
+ * @usage: erase the rsv info
+ *
+ * @name: rsv info name, please refer to
+ *        RSV_KEY   "key"
+ *        RSV_ENV   "env"
+ *        RSV_DTB   "dtb"
+ *        RSV_BBT   "bbt"
+ *        it will erase all reserve information
+ *        when name is null
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_rsv_erase(const char *name);
+
+/**
+ * @usage: turn on/off the protection of rsv info
+ *
+ * @name: rsv info name, please refer to
+ *        RSV_KEY   "key"
+ *        RSV_ENV   "env"
+ *        RSV_DTB   "dtb"
+ *        RSV_BBT   "bbt"
+ *        it will operates all reserve information
+ *        when name is null
+ * @ops: turn on/off the rsv info protection
+ *       true = turn on the protection
+ *       flase = turn off the protection
+ *
+ * @return: result of the operation
+ *          0 = success
+ *          other = fail
+ */
+int store_rsv_protect(const char *name, bool ops);
+
+/**
+ * @usage: get bootloader mode for current storage
+ *
+ * @return: result of the operation
+ *          0 = COMPACT_BOOTLOADER
+ *          1 = DISCRETE_BOOTLOADER
+ */
+int store_get_device_bootloader_mode(void);
+
+int sheader_need(void);
+void sheader_load(void *addr);
+
+#endif/* __STORAGE_H__ */
diff --git a/include/amlogic/storagekey.h b/include/amlogic/storagekey.h
new file mode 100644
index 0000000000..f258b82c95
--- /dev/null
+++ b/include/amlogic/storagekey.h
@@ -0,0 +1,57 @@
+#ifndef __STORAGEKEY_H__
+#define __STORAGEKEY_H__
+
+
+/* storage key interface */
+/**
+ *1.amlkey_init: init storage key
+ * return ok 0, fail not 0
+ */
+extern int32_t amlkey_init(uint8_t *seed, uint32_t len);
+
+/**
+ *2. amlkey_isexsit: query key, already programmed ?
+ * return: exsit 1, non 0
+ */
+extern int32_t amlkey_isexsit(const uint8_t * name);
+
+/**
+ * 3. query if the key is secure
+ * return secure 1, non 0;
+ */
+extern int32_t amlkey_issecure(const uint8_t * name);
+
+/**
+ * 4. amlkey_size: actual bytes of key value
+ *  return actual size.
+ */
+extern ssize_t amlkey_size(const uint8_t *name);
+
+/**
+ *5. amlkey_read: read non-secure key in bytes.
+ * return actual size read back; 0 means read failed!
+ */
+extern ssize_t amlkey_read(const uint8_t *name,
+				uint8_t *buffer, uint32_t len);
+
+/**
+ * 6. amlkey_write: write secure/non-secure key in bytes.
+ * return actual size write down. 0 means write failed!
+ */
+extern ssize_t amlkey_write(const uint8_t *name,
+				uint8_t *buffer, uint32_t len, uint32_t secure);
+
+/**
+ * 7. get the hash value of programmed secure key | 32bytes length, sha256
+ * return success 0, fail -1
+ */
+extern int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash);
+
+/**
+ * 8. amlkey_del: del key by name
+ * return success 0, fail non-0.
+ */
+extern int32_t amlkey_del(const uint8_t * name);
+
+
+#endif /* __STORAGEKEY_H__ */
diff --git a/include/amlogic/store_wrapper.h b/include/amlogic/store_wrapper.h
new file mode 100644
index 0000000000..0f3007de95
--- /dev/null
+++ b/include/amlogic/store_wrapper.h
@@ -0,0 +1,56 @@
+/*
+ * \file        store_wrapper.h
+ * \brief       wraaper for storage apis
+ *
+ * \version     1.0.0
+ * \date        2019/5/30
+ * \author      Sam.Wu <yihui.wu@amlgic.com>
+ *
+ * Copyright (c) 2019 Amlogic. All Rights Reserved.
+ *
+ */
+#ifndef __STORE_WRAPPER_H__
+#define __STORE_WRAPPER_H__
+#include <amlogic/storage.h>
+
+//logic write/read, if not MTD, same as store_write
+int store_logic_write(const char *name, loff_t off, size_t size, void *buf);
+
+int store_logic_read(const char *name, loff_t off, size_t size, void *buf);
+
+u64 store_logic_cap(const char* partName);
+
+#define AML_MAGIC_HDR_L       (0x4c4d4140) //"@AML"
+#define AML_MAGIC_HDR_R       (0x544f4f42) //"BOOT"
+
+#define AML_MAGIC_CORE        (0X54534242) //"BBST"
+#define AML_MAGIC_BL2E        (0x45324c42) //"BL2E"
+#define AML_MAGIC_BL2X        (0x58324c42) //"BL2X"
+#define AML_MAGIC_DDRF        (0x46524444) //"DDRF"
+#define AML_MAGIC_DEVF        (0x46564544) //"DEVF"
+typedef struct{
+	unsigned int  nMagic;          //"BBST", "BL2E", "BL2X", "DDRF", "DEVF"
+	unsigned int  nOffset;         //offset from file head of file
+	unsigned int  nPayLoadSize;    //size of payload
+	unsigned int  nReserved;       //reserved for future
+}payload_info_item_t, *p_payload_info_item_t;
+
+typedef struct{
+	unsigned char  szSHA2[32];     //sha256 of sizeof(payload_info_t) - sizeof(szSHA2)
+	unsigned int   nMagicL;        //"@AML"
+	unsigned int   nMagicR;        //"BOOT"
+	unsigned char  byVersion;      //version:0,1,2,....
+	unsigned char  byItemNum;      //number of items
+	unsigned short nSize;          //sizeof(this) = sizeof(hdr) + sizeof(item) * byItemNum
+	unsigned char  szReserved1[4];
+	char           szTimeStamp[16];//"SC2-YYYYMMDDHHmm" e.g "SC2-202007082259"
+
+}payload_info_hdr_t, *p_payload_info_hdr_t;
+
+typedef struct{
+	payload_info_hdr_t  hdr;         //header
+	payload_info_item_t arrItems[1]; //items
+}payload_info_t, *p_payload_info_t;
+
+#endif//#ifndef __STORE_WRAPPER_H__
+
diff --git a/include/amlstorage/emmc_partitions.h b/include/amlstorage/emmc_partitions.h
new file mode 100644
index 0000000000..5edc1f89c8
--- /dev/null
+++ b/include/amlstorage/emmc_partitions.h
@@ -0,0 +1,271 @@
+#ifndef _AML_MMC_H
+#define _AML_MMC_H
+
+#include <asm/io.h>
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <mmc.h>
+#include <div64.h>
+#include <env.h>
+#include <malloc.h>
+#include <asm/cache.h>
+//#include <amlogic/asm/clock.h>
+#include <amlstorage/partition_table.h>
+#include <amlstorage/emmc_storage.h>
+#include <linux/sizes.h>
+
+#define     AML_MMC_DBG
+
+#define     MAX_DEVICE_NUM                  32
+#define     MAX_DEVICE_NAME_LEN             16
+#define     MAX_MMC_PART_NUM                32
+#define     MAX_MMC_PART_NAME_LEN           16
+
+#ifndef CONFIG_AML_MMC_INHERENT_PART
+#define     PARTITION_RESERVED              (8*SZ_1M)  // 8MB
+#define     MMC_BOOT_PARTITION_RESERVED     (32*SZ_1M) // 32MB
+#define     RESERVED_GPT_OFFSET     (36*SZ_1M) // 36MB
+
+#define     MMC_BOOT_NAME                   "bootloader"
+#define     MMC_BOOT_NAME0                   "bootloader-boot0"
+#define     MMC_BOOT_NAME1                   "bootloader-boot1"
+#define     MMC_BOOT_DEVICE_SIZE            (0x4*SZ_1M)
+
+#define     MMC_RESERVED_NAME               "reserved"
+#define     MMC_RESERVED_SIZE               (64*SZ_1M)
+#define		MMC_BOTTOM_RSV_SIZE				(0)
+#endif		/* CONFIG_AML_MMC_INHERENT_PART */
+
+#define     MMC_FREERTOS_NAME               "rtos-0"
+#define		MMC_NBG_NAME					"NBG"
+
+#define     MMC_CACHE_NAME                  "cache"
+// #define     MMC_CACHE_SIZE                  (512*SZ_1M) // this is not used and should be get from spl
+
+#define     MMC_ENV_NAME                    "env"
+#define     MMC_ENV_SIZE                    (8*SZ_1M)
+
+#define     MMC_KEY_NAME                    "key"
+#define     MMC_KEY_SIZE                    (256*1024)
+#define     EMMCKEY_RESERVE_OFFSET           (0x4000)
+#define     MMC_RESERVED_OFFSET              (36*SZ_1M)
+#define     MMC_BLOCK_SIZE                   (512)
+// #define     MMC_SECURE_NAME                 "secure"
+// #define     MMC_SECURE_SIZE                 (0x1*SZ_1M)
+
+#define MMC_DDR_PARAMETER_NAME	"ddr-parameter"
+#define DDR_PARAMETER_OFFSET	(SZ_1M * 8)
+#define DDR_PARAMETER_SIZE	(4 * 512)
+
+#define     MMC_MPT_VERSION_1               "01.00.00"
+#define     MMC_MPT_VERSION_2               "01.02.00"
+/* version in use, fixme when kenel driver is updated. */
+#define		MMC_MPT_VERSION					MMC_MPT_VERSION_1
+
+#define     MMC_PARTITIONS_MAGIC            "MPT" // MMC Partition Table
+#define     MMC_CARD_PARTITION_NAME         "card"
+
+/* virtual partitions*/
+
+#define MMC_MBR_NAME    ("AML_MBR")
+/* offset&size of mbr will not be used */
+#define MMC_MBR_OFFSET  (0x0)
+#define MMC_MBR_SIZE    (0x200)
+
+/*
+* partition table
+* |<----partition_table---->|<----key---->|
+*
+*/
+#define MMC_TABLE_NAME		("AML_TABLE")
+#define MMC_TABLE_OFFSET		(0x0)
+#define MMC_TABLE_SIZE		(16*1024)
+
+/*
+* write 128KB data pattern
+* |<----pattern---->||<------DTB------>|
+*/
+#define	MMC_PATTERN_NAME		"pattern"
+#define CALI_PATTERN_OFFSET	(SZ_1M * 3)
+#define CALI_PATTERN_SIZE	(256 * 512)
+#define CALI_BLOCK_SIZE		(512)
+#define CALI_PATTERN		(0x55aa55aa)
+
+#define	MMC_MAGIC_NAME		"magic"
+#define MAGIC_OFFSET	(SZ_1M * 6)
+#define MAGIC_SIZE	(256 * 512)
+#define MAGIC_BLOCK_SIZE		(512)
+#define MAGIC_PATTERN	(0X00FF00FF)
+
+#define	MMC_RANDOM_NAME		"random"
+#define RANDOM_OFFSET	(SZ_1M * 7)
+#define RANDOM_SIZE	(256 * 512)
+#define RANDOM_BLOCK_SIZE		(512)
+#define RANDOM_PATTERN	(0X52414E44)
+/*
+ * 2 copies dtb were stored in dtb area.
+ * each is 256K.
+ * timestamp&checksum are in the tail.
+ * |<--------------DTB Area-------------->|
+ * |<------DTB1------->|<------DTB2------>|
+ */
+#define MMC_DTB_NAME		"dtb"
+#define DTB_OFFSET		(SZ_1M * 4)
+#define DTB_BLK_SIZE		(512)
+#define DTB_BLK_CNT			(512)
+#define DTB_SIZE			(DTB_BLK_CNT * DTB_BLK_SIZE)
+#define DTB_COPIES			(2)
+#define DTB_AREA_BLK_CNT	(DTB_BLK_CNT * DTB_COPIES)
+#define EMMC_DTB_DEV		(1)
+#define EMMC_FASTBOOT_CONTEXT_DEV         (1)
+
+#define MMC_FASTBOOT_CONTEXT_NAME     "fastboot_context"
+#define FASTBOOT_CONTEXT_OFFSET  (SZ_1M * 5)
+#define FASTBOOT_CONTEXT_SIZE    (512)
+#define GPT_LBA_COUNT 34
+#define GPT_TOTAL_SIZE (GPT_LBA_COUNT * 512)
+
+struct virtual_partition {
+	char name[MAX_MMC_PART_NAME_LEN];
+	uint64_t offset;
+	uint64_t size;
+};
+
+#define VIRTUAL_PARTITION_ELEMENT(na, of, sz) {.name = na, .offset = of, .size = sz,}
+
+struct aml_pattern {
+	char name[MAX_MMC_PART_NAME_LEN];
+	unsigned int pattern;
+};
+#define AML_PATTERN_ELEMENT(na, pa) {.name = na, .pattern = pa,}
+
+#ifdef AML_MMC_DBG
+#define aml_mmc_dbg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+                  __func__, __LINE__, ##__VA_ARGS__)
+
+#define aml_mmc_msg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+                  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define aml_mmc_dbg(fmt, ...)
+#define aml_mmc_msg(fmt, ...) printk( fmt "\n",  ##__VA_ARGS__)
+#endif
+
+#define DOS_MBR	0
+#define DOS_PBR	1
+
+#define DOS_PBR_FSTYPE_OFFSET	0x36
+#define DOS_PBR32_FSTYPE_OFFSET	0x52
+
+#define DOS_PART_DISKSIG_OFFSET	0x1b8
+#define DOS_PART_TBL_OFFSET	0x1be
+#define DOS_PART_MAGIC_OFFSET	0x1fe
+#define DOS_PBR_MEDIA_TYPE_OFFSET	0x15
+
+#define DOS_PARTITION_COUNT 32
+
+typedef struct dos_partition {
+	unsigned char boot_ind;		/* 0x80 - active			*/
+	unsigned char head;		/* starting head			*/
+	unsigned char sector;		/* starting sector			*/
+	unsigned char cyl;		/* starting cylinder			*/
+	unsigned char sys_ind;		/* What partition type			*/
+	unsigned char end_head;		/* end head				*/
+	unsigned char end_sector;	/* end sector				*/
+	unsigned char end_cyl;		/* end cylinder				*/
+	unsigned char start4[4];	/* starting sector counting from 0	*/
+	unsigned char size4[4];		/* nr of sectors in partition		*/
+} dos_partition_t;
+
+struct dos_mbr_or_ebr{
+	unsigned char bootstart[446];
+	struct dos_partition part_entry[4];
+	unsigned char magic[2];
+};
+
+struct mmc_partitions_fmt {
+    char magic[4];
+    unsigned char version[12];
+    int part_num;
+    int checksum;
+    struct partitions partitions[MAX_MMC_PART_NUM];
+};
+
+struct mmc_partition_config{
+    unsigned char version[12];
+    int part_num;
+    struct partitions partitions[MAX_MMC_PART_NUM];
+    unsigned option;
+    void * private_data;
+};
+
+/*
+struct _mmc_device{
+    char name[MAX_DEVICE_NAME_LEN];
+    uint64_t  offset;
+    uint64_t  size;
+    void * private_data;
+    struct list_head list;
+};
+*/
+
+#define LOCK_MAJOR_VERSION 1
+#define LOCK_MINOR_VERSION 0
+
+#define LOCK_DATA_SIZE 16
+
+typedef struct LockData {
+	uint8_t version_major;
+	uint8_t version_minor;
+	uint8_t unlock_ability;
+
+	/* Padding to eight bytes. */
+	uint8_t reserved1;
+
+	/* 0: unlock    1: lock*/
+	uint8_t lock_state;
+
+	/* 0: unlock    1: lock*/
+	uint8_t lock_critical_state;
+
+	/* 0: enable bootloader version rollback 1: prevent bootloader version rollback*/
+	uint8_t lock_bootloader;
+	uint8_t reserved2[1];
+} LockData_t;
+
+/*512Bytes*/
+typedef struct FastbootContext {
+	/* locks */
+	LockData_t lock;
+	uint8_t rsv[248];
+	/* checksum, storage driver care */
+	uint32_t crc32;
+} FastbootContext_t;
+
+extern bool is_partition_checked;
+extern struct partitions emmc_partition_table[];
+
+extern int get_emmc_partition_arraysize(void);
+
+/*
+ * get the partition number by name
+ * return value
+ *	< 0 means no partition found
+ *	>= 0 means valid partition
+ */
+extern int get_partition_num_by_name(char const *name);
+
+struct partitions* find_mmc_partition_by_name (char const *name);
+struct partitions *aml_get_partition_by_name(const char *name);
+int mmc_boot_size(char *name, uint64_t* size);
+struct virtual_partition *aml_get_virtual_partition_by_name(const char *name);
+bool aml_is_emmc_tsd (struct mmc *mmc);
+int mmc_device_init (struct mmc *mmc);
+
+#define PARTITION_ELEMENT(na, sz, flags) {.name = na, .size = sz, .mask_flags = flags,}
+
+#endif
diff --git a/include/amlstorage/emmc_storage.h b/include/amlstorage/emmc_storage.h
new file mode 100644
index 0000000000..f2dc55fde7
--- /dev/null
+++ b/include/amlstorage/emmc_storage.h
@@ -0,0 +1,76 @@
+/***********************************************
+*****Storage config of board, for ACS use.*****
+***********************************************/
+
+#ifndef __STORAGE_H
+#define __STORAGE_H
+
+#include <linux/types.h>
+#include <amlogic/asm/romboot.h>
+#ifndef __ASSEMBLY__
+
+//Partition table defines
+#define NAND_PART_SIZE_FULL		-1
+#define MAX_PART_NUM			32
+#define	 MAX_PART_NAME_LEN		16
+//#define 	SZ_1M 					0x100000
+
+#define STORE_CODE		1
+#define	STORE_CACHE		(1<<1)
+#define STORE_DATA		(1<<2)
+
+#define SPI_BOOT_FLAG		0
+#define NAND_BOOT_FLAG 		1
+#define EMMC_BOOT_FLAG 		2
+#define CARD_BOOT_FLAG 		3
+#define SPI_NAND_FLAG		4
+#define SPI_EMMC_FLAG		5
+
+#define CARD_TYPE_SHIFT		4
+#define CARD_TYPE_MASK		0xf
+#define CARD_TYPE_UNKNOWN	0        /* unknown */
+//#define CARD_TYPE_MMC		1        /* MMC card */
+//#define CARD_TYPE_SD		2        /* SD card */
+#define CARD_TYPE_SDIO		3        /* SDIO card */
+#define CARD_TYPE_SD_COMBO	4        /* SD combo (IO+mem) card */
+#define CARD_TYPE_NON_SDIO	5        /* NON sdio device (means SD/MMC card) */
+
+#define AML_GET_CARD_TYPE(val, port)    ((val >> (port * CARD_TYPE_SHIFT)) & CARD_TYPE_MASK)
+#define AML_SET_CARD_TYPE(val, port, type)   \
+    (val |= ((type & CARD_TYPE_MASK) << (port * CARD_TYPE_SHIFT)))
+
+/* storage device */
+#define STORAGE_DEV_NOSET	(0)
+#define STORAGE_DEV_EMMC	(1)
+#define STORAGE_DEV_NAND	(2)
+#define STORAGE_DEV_SPI		(3)
+#define STORAGE_DEV_SDCARD	(4)
+#define STORAGE_DEV_USB		(5)
+
+struct partitions {
+	char name[MAX_PART_NAME_LEN];			/* identifier string */
+	uint64_t size;			/* partition size */
+	uint64_t offset;		/* offset within the master space */
+	unsigned mask_flags;		/* master flags to mask out for this partition */
+};
+
+struct config_nand {
+	unsigned enable_slc;
+	unsigned order_ce;
+	unsigned reserved[2];
+};
+
+struct config_mmc {
+	unsigned type;
+	unsigned port;
+	unsigned reserved[2];
+};
+
+struct store_config {
+	unsigned  store_device_flag;			// indicate storage devices on each board
+	struct config_nand  nand_configs;			// specital config for nand
+	struct config_mmc  mmc_configs;			// specital config for mmc
+};
+
+#endif
+#endif
diff --git a/include/amlstorage/partition_table.h b/include/amlstorage/partition_table.h
new file mode 100644
index 0000000000..4e170f3748
--- /dev/null
+++ b/include/amlstorage/partition_table.h
@@ -0,0 +1,72 @@
+#ifndef _PARTITION_TABLE_H
+#define _PARTITION_TABLE_H
+// #ifdef CONFIG_STORE_COMPATIBLE
+#include <amlstorage/emmc_storage.h>
+#include <amlogic/storage.h>
+// #endif
+//#include <asm/arch/nand.h>
+//#include <asm/arch/poc.h>
+
+
+#define STORE_DBG
+#ifdef STORE_DBG
+#define store_dbg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+				  __func__, __LINE__, ##__VA_ARGS__)
+
+#define store_msg(fmt, ...) printk( "%s: line:%d " fmt "\n", \
+				  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define store_dbg(fmt, ...)
+#define store_msg(fmt, ...) printk( fmt "\n",  ##__VA_ARGS__)
+#endif
+
+//boot_flag
+//#define R_BOOT_DEVICE_FLAG  READ_CBUS_REG(ASSIST_POR_CONFIG)
+
+//#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+//#define POR_BOOT_VALUE 	((((R_BOOT_DEVICE_FLAG>>9)&1)<<2)|((R_BOOT_DEVICE_FLAG>>6)&3))
+//#else
+//#define POR_BOOT_VALUE 	(R_BOOT_DEVICE_FLAG & 7)
+//#endif
+
+//#if 1 /*defined in poc.h*/
+//#define POR_NAND_BOOT()	 ((POR_BOOT_VALUE == 7) || (POR_BOOT_VALUE == 6))
+//#define POR_SPI_BOOT()  		((POR_BOOT_VALUE == 5) || (POR_BOOT_VALUE == 4))
+//#define POR_EMMC_BOOT()	((IS_MESON_M8M2_CPU | IS_MESON_M8BABY_CPU)?((POR_BOOT_VALUE == 3) || ((POR_BOOT_VALUE == 1))):(POR_BOOT_VALUE == 3))
+//#define POR_CARD_BOOT() 	(POR_BOOT_VALUE == 0)
+//#endif
+
+#define SPI_BOOT_FLAG 			0
+#define NAND_BOOT_FLAG 		1
+#define EMMC_BOOT_FLAG 		2
+#define CARD_BOOT_FLAG 		3
+#define SPI_NAND_FLAG			4
+#define SPI_EMMC_FLAG			5
+
+#define _AML_DEVICE_BOOT_FLAG_DEFAULT   (0XFFFFFFFF)
+
+#define START_ADDR 			0xd9000200
+#define TABLE_MAGIC_NAME  		"part"
+#define STORE_MAGIC_NAME  		"stor"
+#define ACS_SET_LEN 			 128
+
+extern int info_disprotect;
+
+extern int has_boot_slot;
+extern int has_system_slot;
+extern bool dynamic_partition;
+extern bool vendor_boot_partition;
+
+extern int get_partition_from_dts(unsigned char * buffer);
+
+extern int get_partitions_table(struct partitions **table);
+
+#define AML_DTB_IMG_MAX_SZ  ((256<<10) - 512)
+extern struct partitions *get_partitions(void);
+
+extern int get_partition_count(void);
+extern void free_partitions(void);
+/* only nand&emmc for gxb and later soc */
+
+#endif// #ifndef _PARTITION_TABLE_H
+
diff --git a/include/mmc.h b/include/mmc.h
index 073b01f82b..cee30386a8 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -109,6 +109,10 @@ struct bd_info;
 #define MMC_CMD_SET_BLOCK_COUNT         23
 #define MMC_CMD_WRITE_SINGLE_BLOCK	24
 #define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
+#define MMC_CMD_SET_WRITE_PROTECT	28
+#define MMC_CMD_CLR_WRITE_PROT		29
+#define MMC_CMD_SEND_WRITE_PROT		30
+#define MMC_CMD_SEND_WRITE_PROT_TYPE	31
 #define MMC_CMD_ERASE_GROUP_START	35
 #define MMC_CMD_ERASE_GROUP_END		36
 #define MMC_CMD_ERASE			38
@@ -213,6 +217,7 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 /*
  * EXT_CSD fields
  */
+#define EXT_CSD_CLASS_6_CTRL		59	/*R/W/E_P*/
 #define EXT_CSD_ENH_START_ADDR		136	/* R/W */
 #define EXT_CSD_ENH_SIZE_MULT		140	/* R/W */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
@@ -236,12 +241,15 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define EXT_CSD_HS_TIMING		185	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_DRIVER_STRENGTH		197	/* RO */
 #define EXT_CSD_PART_SWITCH_TIME	199	/* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
 #define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
 #define EXT_CSD_BOOT_MULT		226	/* RO */
-#define EXT_CSD_GENERIC_CMD6_TIME       248     /* RO */
+#define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
+#define EXT_CSD_DEV_LIFETIME_EST_TYP_A	268	/* RO */
+#define EXT_CSD_DEV_LIFETIME_EST_TYP_B	269	/* RO */
 #define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
 
 /*
@@ -337,6 +345,20 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define ENHNCD_SUPPORT		(0x2)
 #define PART_ENH_ATTRIB		(0x1f)
 
+#define US_PWR_WP_DIS_BIT      1<<3
+#define US_PERM_WP_DIS_BIT     1<<4
+#define WP_CLEAR_TYPE          0
+#define WP_POWER_ON_TYPE       (1<<1)
+#define WP_TEMPORARY_TYPE      1
+#define WP_PERMANENT_TYPE      ((1<<0)|(1<<1))
+#define WP_TYPE_MASK           3
+#define WP_ENABLE_MASK         7
+#define WP_TEMPORARY_EN_BIT    0
+#define WP_POWER_ON_EN_BIT     (1<<0)
+#define WP_PERM_EN_BIT         (1<<2)
+#define WP_GRP_SIZE_MASK       31
+
+
 #define MMC_QUIRK_RETRY_SEND_CID	BIT(0)
 #define MMC_QUIRK_RETRY_SET_BLOCKLEN	BIT(1)
 #define MMC_QUIRK_RETRY_APP_CMD	BIT(2)
@@ -693,6 +715,8 @@ struct mmc {
 #if CONFIG_IS_ENABLED(MMC_WRITE)
 	struct sd_ssr	ssr;	/* SD status register */
 #endif
+	uint dev_lifetime_est_typ_a;
+	uint dev_lifetime_est_typ_b;
 	u64 capacity;
 	u64 capacity_user;
 	u64 capacity_boot;
diff --git a/include/part.h b/include/part.h
index 6f604e7315..1f7495b97e 100644
--- a/include/part.h
+++ b/include/part.h
@@ -30,12 +30,15 @@ struct block_drvr {
 #define PART_TYPE_ISO		0x03
 #define PART_TYPE_AMIGA		0x04
 #define PART_TYPE_EFI		0x05
+#define PART_TYPE_AML		0x06
 
 /* maximum number of partition entries supported by search */
 #define DOS_ENTRY_NUMBERS	8
 #define ISO_ENTRY_NUMBERS	64
 #define MAC_ENTRY_NUMBERS	64
 #define AMIGA_ENTRY_NUMBERS	8
+#define AML_ENTRY_NUMBERS	128
+
 /*
  * Type string for U-Boot bootable partitions
  */
-- 
2.30.2

