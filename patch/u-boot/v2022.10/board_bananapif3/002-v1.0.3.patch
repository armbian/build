From 956d2424b828e3582839a056d240dec34bef0c78 Mon Sep 17 00:00:00 2001
From: James Deng <james.deng@spacemit.com>
Date: Wed, 19 Jun 2024 15:18:09 +0800
Subject: [PATCH] Update to v1.0.3

Signed-off-by: James Deng <james.deng@spacemit.com>
---
 arch/riscv/dts/Makefile                       |    4 +-
 arch/riscv/dts/k1-x.dtsi                      |   57 +-
 arch/riscv/dts/k1-x_MUSE-Book.dts             |  246 ++++
 arch/riscv/dts/k1-x_MUSE-N1.dts               |    0
 arch/riscv/dts/k1-x_kx312.dts                 |   55 +
 arch/riscv/dts/k1-x_milkv-jupiter.dts         |  284 ++++
 arch/riscv/dts/k1-x_pinctrl.dtsi              |    4 +-
 arch/riscv/dts/k1-x_spm8821.dtsi              |   11 +-
 board/spacemit/k1-x/Kconfig                   |    5 +
 board/spacemit/k1-x/configs/uboot_fdt.its     |   28 +
 board/spacemit/k1-x/k1-x.env                  |   31 +-
 board/spacemit/k1-x/k1x.c                     |   83 +-
 board/spacemit/k1-x/splash.c                  |   54 +-
 cmd/spacemit_flash.c                          |   31 +-
 configs/k1_defconfig                          |    6 +-
 drivers/clk/clk-uclass.c                      |    9 +-
 drivers/ddr/spacemit/k1x/ddr_freq.c           |   50 +-
 .../ddr/spacemit/k1x/lpddr4_silicon_init.c    |   33 +-
 drivers/fastboot/Kconfig                      |   21 +
 drivers/fastboot/fb_blk.c                     |   24 +-
 drivers/fastboot/fb_getvar.c                  |   13 +-
 drivers/fastboot/fb_mtd.c                     |   22 +-
 drivers/fastboot/fb_spacemit.c                |  118 +-
 drivers/i2c/spacemit_i2c.c                    |    1 -
 drivers/mtd/mtdpart.c                         |    2 +-
 drivers/pci/pcie_dw_k1x.c                     |   11 -
 drivers/power/pmic/spacemit_pmic.c            |   12 +-
 drivers/spi/Kconfig                           |    5 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/k1x_spi.c                         |  467 +++++++
 drivers/spi/k1x_spi.h                         |  128 ++
 drivers/sysreset/Kconfig                      |    5 -
 drivers/sysreset/Makefile                     |    1 -
 drivers/sysreset/sysreset_spacemit.c          |   84 --
 drivers/sysreset/sysreset_watchdog.c          |    3 +-
 drivers/video/spacemit/Kconfig                |    7 +
 drivers/video/spacemit/Makefile               |    3 +-
 drivers/video/spacemit/dsi/Makefile           |    1 +
 .../video/spacemit/dsi/drv/spacemit_dphy.c    |   59 +-
 .../video/spacemit/dsi/drv/spacemit_dsi_drv.c |    8 +-
 .../dsi/include/spacemit_dsi_common.h         |    5 +-
 .../spacemit/dsi/include/spacemit_video_tx.h  |   10 +-
 .../spacemit/dsi/video/lcd/lcd_gx09inx101.c   |    7 +-
 .../spacemit/dsi/video/lcd/lcd_icnl9911c.c    |    3 +-
 .../dsi/video/lcd/lcd_lt8911ext_edp_1080p.c   |  130 ++
 .../spacemit/dsi/video/spacemit_mipi_port.c   |  226 ++--
 .../spacemit/dsi/video/spacemit_video_tx.c    |   17 +-
 drivers/video/spacemit/spacemit_dpu.c         |   56 +-
 drivers/video/spacemit/spacemit_edp.c         | 1156 +++++++++++++++++
 drivers/video/spacemit/spacemit_mipi.c        |   10 +-
 drivers/watchdog/Kconfig                      |    6 +
 drivers/watchdog/Makefile                     |    1 +
 drivers/watchdog/spacemit_pmic_wdt.c          |  274 ++++
 drivers/watchdog/spacemit_wdt.c               |    8 +-
 include/fb_spacemit.h                         |   18 +
 include/power/spacemit/spm8821.h              |   15 +
 56 files changed, 3453 insertions(+), 476 deletions(-)
 create mode 100644 arch/riscv/dts/k1-x_MUSE-Book.dts
 mode change 100755 => 100644 arch/riscv/dts/k1-x_MUSE-N1.dts
 create mode 100644 arch/riscv/dts/k1-x_milkv-jupiter.dts
 create mode 100644 drivers/spi/k1x_spi.c
 create mode 100644 drivers/spi/k1x_spi.h
 delete mode 100644 drivers/sysreset/sysreset_spacemit.c
 create mode 100644 drivers/video/spacemit/dsi/video/lcd/lcd_lt8911ext_edp_1080p.c
 create mode 100644 drivers/video/spacemit/spacemit_edp.c
 create mode 100644 drivers/watchdog/spacemit_pmic_wdt.c

diff --git a/arch/riscv/dts/Makefile b/arch/riscv/dts/Makefile
index 19926479..99309182 100644
--- a/arch/riscv/dts/Makefile
+++ b/arch/riscv/dts/Makefile
@@ -9,7 +9,9 @@ dtb-$(CONFIG_TARGET_SIFIVE_UNMATCHED) += hifive-unmatched-a00.dtb
 dtb-$(CONFIG_TARGET_SIPEED_MAIX) += k210-maix-bit.dtb
 dtb-$(CONFIG_TARGET_SPACEMIT_K1PRO) += k1-pro_qemu.dtb k1-pro_sim.dtb k1-pro_fpga.dtb
 dtb-$(CONFIG_TARGET_SPACEMIT_K1X) += k1-x_evb.dtb k1-x_deb2.dtb k1-x_deb1.dtb k1-x_hs450.dtb \
-				     k1-x_kx312.dtb k1-x_MINI-PC.dtb k1-x_mingo.dtb k1-x_MUSE-N1.dtb k1-x_MUSE-Pi.dtb k1-x_spl.dtb
+				     k1-x_kx312.dtb k1-x_MINI-PC.dtb k1-x_mingo.dtb k1-x_MUSE-N1.dtb \
+				     k1-x_MUSE-Pi.dtb k1-x_spl.dtb k1-x_milkv-jupiter.dtb \
+				     k1-x_MUSE-Book.dtb
 
 include $(srctree)/scripts/Makefile.dts
 
diff --git a/arch/riscv/dts/k1-x.dtsi b/arch/riscv/dts/k1-x.dtsi
index 04af9f99..c462a053 100644
--- a/arch/riscv/dts/k1-x.dtsi
+++ b/arch/riscv/dts/k1-x.dtsi
@@ -657,6 +657,54 @@
 			};
 		};
 
+		spi0: spi0@d4026000 {
+			compatible = "spacemit,k1x-spi";
+			reg = <0x0 0xd4026000 0x0 0x30>;
+			clocks = <&ccu CLK_SSPA0>;
+			resets = <&reset RESET_SSPA0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clock-frequency = <26000000>;
+			port = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi1@d4026800 {
+			compatible = "spacemit,k1x-spi";
+			reg = <0x0 0xd4026800 0x0 0x30>;
+			clocks = <&ccu CLK_SSPA1>;
+			resets = <&reset RESET_SSPA1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clock-frequency = <26000000>;
+			port = <1>;
+			status = "disabled";
+		};
+
+		spi2: spi2@f0613000 {
+			compatible = "spacemit,k1x-spi";
+			reg = <0x0 0xf0614000 0x0 0x30>;
+			clocks = <&ccu CLK_SEC_SSP2>;
+			resets = <&reset RESET_SEC_SSP2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clock-frequency = <26000000>;
+			port = <2>;
+			status = "disabled";
+		};
+
+		spi3: spi3@d401c000 {
+			compatible = "spacemit,k1x-spi";
+			reg = <0x0 0xd401c000 0x0 0x30>;
+			clocks = <&ccu CLK_SSP3>;
+			resets = <&reset RESET_SSP3>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clock-frequency = <26000000>;
+			port = <3>;
+			status = "disabled";
+		};
+
 		qspi: spi@d420c000 {
 			compatible = "spacemit,k1x-qspi";
 			#address-cells = <1>;
@@ -701,9 +749,9 @@
 				#address-cells = <1>;
 				#size-cells = <0>;
 
-				dpu_out_mipi: endpoint@0 {
+				dpu_out_dsi: endpoint@0 {
 					reg = <0>;
-					remote-endpoint = <&mipi_in_dpu>;
+					remote-endpoint = <&dsi_in_dpu>;
 				};
 
 				dpu_out_hdmi: endpoint@1 {
@@ -737,9 +785,9 @@
 				mipi_in: port {
 					#address-cells = <1>;
 					#size-cells = <0>;
-					mipi_in_dpu: endpoint@0 {
+					dsi_in_dpu: endpoint@0 {
 						reg = <0>;
-						remote-endpoint = <&dpu_out_mipi>;
+						remote-endpoint = <&dpu_out_dsi>;
 					};
 				};
 			};
@@ -884,7 +932,6 @@
 
 	wdt_reboot {
 		compatible = "wdt-reboot";
-		wdt = <&watchdog>;
 		status = "okay";
 	};
 
diff --git a/arch/riscv/dts/k1-x_MUSE-Book.dts b/arch/riscv/dts/k1-x_MUSE-Book.dts
new file mode 100644
index 00000000..90e46cdd
--- /dev/null
+++ b/arch/riscv/dts/k1-x_MUSE-Book.dts
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "k1-x_spm8821.dtsi"
+
+/ {
+	model = "k1-x_MUSE-Book";
+
+	aliases {
+		efuse_power = &ldo_31;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x80000000>;
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200 debug loglevel=8,initcall_debug=1 rdinit=/init.tmp";
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&cpu_0 {
+	/* boot frequency for cluster-0, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster0 = <1228000>;
+	/* boot frequency for cluster-1, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster1 = <1228000>;
+};
+
+&dramc {
+	/* dram data rate, should be 1200, 1600, or 2400 */
+	datarate = <2400>;
+};
+
+&cpus {
+	timebase-frequency = <24000000>;
+};
+
+&ccu {
+	pll2-freq = <2800000000>;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&i2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		vin-supply-names = "eeprom_1v8";
+		status = "okay";
+	};
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4_2>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	battery: battery@b {
+		compatible = "sbs,sbs-battery";
+		reg = <0x0b>;
+		sbs,i2c-retry-count = <2>;
+		sbs,poll-retry-count = <1>;
+	};
+};
+
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6_2>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	lt8911exb_i2c@29 {
+		compatible = "lontium,lt8911exb";
+		reg = <0x29>;
+		status = "okay";
+
+		enable-gpios = <&gpio 83 0>;
+		bl-gpios = <&gpio 75 0>;
+		standby-gpios = <&gpio 92 0>;
+		reset-gpios = <&gpio 114 0>;
+
+		port {
+			lt8911exb_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_66  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     2 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	gpio80_pmx_func0: gpio80_pmx_func0 {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_80, MUX_MODE0, (EDGE_BOTH | PULL_UP | PAD_3V_DS4))  /* mmc cd */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49 GPIO_49 2
+		&pinctrl 58 GPIO_58 1
+		&pinctrl 63 GPIO_63 5
+		&pinctrl 70 PRI_TDI 4
+		&pinctrl 74 GPIO_74 1
+		&pinctrl 80 GPIO_80 4
+		&pinctrl 90 GPIO_90 3
+		&pinctrl 96 DVL0 2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 123 GPIO_123 5
+	>;
+};
+
+&udc {
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc1 &gpio80_pmx_func0>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	cd-inverted;
+	cap-sd-highspeed;
+	sdh-phy-module = <0>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	sdh-phy-module = <1>;
+	status = "okay";
+};
+
+&pcie2_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie2_4>;
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+&efuse {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "disabled";
+};
+
+&ldo_27 {
+	regulator-init-microvolt = <1200000>;
+	regulator-boot-on;
+	regulator-state-mem {
+			regulator-off-in-suspend;
+	};
+};
+
+&mipi_dsi {
+	bit-clk = <933000000>;
+	pix-clk = <142000000>;
+	status = "okay";
+
+	ports {
+		mipi_in: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dsi_out: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&lt8911exb_in>;
+			};
+		};
+	};
+};
+
+&panel {
+	force-attached = "lt8911ext_edp_1080p";
+	bl-gpios = <&gpio 44 0>;
+	status = "okay";
+};
+
diff --git a/arch/riscv/dts/k1-x_MUSE-N1.dts b/arch/riscv/dts/k1-x_MUSE-N1.dts
old mode 100755
new mode 100644
diff --git a/arch/riscv/dts/k1-x_kx312.dts b/arch/riscv/dts/k1-x_kx312.dts
index 61047289..d352a42d 100644
--- a/arch/riscv/dts/k1-x_kx312.dts
+++ b/arch/riscv/dts/k1-x_kx312.dts
@@ -69,6 +69,30 @@
 	status = "okay";
 };
 
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6_2>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	lt8911exb_i2c@29 {
+		compatible = "lontium,lt8911exb";
+		reg = <0x29>;
+		status = "okay";
+
+		enable-gpios = <&gpio 83 0>;
+		bl-gpios = <&gpio 75 0>;
+		standby-gpios = <&gpio 92 0>;
+		reset-gpios = <&gpio 114 0>;
+
+		port {
+			lt8911exb_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
 &pinctrl {
 	pinctrl-single,gpio-range = <
 		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
@@ -177,6 +201,37 @@
 &hdmi {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "disabled";
+};
+
+&ldo_27 {
+	regulator-init-microvolt = <1200000>;
+	regulator-boot-on;
+	regulator-state-mem {
+			regulator-off-in-suspend;
+	};
+};
+
+&mipi_dsi {
+	bit-clk = <933000000>;
+	pix-clk = <142000000>;
+	status = "okay";
+
+	ports {
+		mipi_in: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dsi_out: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&lt8911exb_in>;
+			};
+		};
+	};
+};
+
+&panel {
+	force-attached = "lt8911ext_edp_1080p";
+	bl-gpios = <&gpio 44 0>;
 	status = "okay";
 };
 
diff --git a/arch/riscv/dts/k1-x_milkv-jupiter.dts b/arch/riscv/dts/k1-x_milkv-jupiter.dts
new file mode 100644
index 00000000..eb9e97b8
--- /dev/null
+++ b/arch/riscv/dts/k1-x_milkv-jupiter.dts
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "k1-x_spm8821.dtsi"
+
+/ {
+	model = "Milk-V Jupiter";
+
+	aliases {
+		efuse_power = &ldo_31;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x80000000>;
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200 debug loglevel=8,initcall_debug=1 rdinit=/init.tmp";
+		stdout-path = "serial0:115200n8";
+	};
+
+	usb3hub:usb3hub {
+		compatible = "spacemit,usb-hub";
+		hub-gpios = <
+			&gpio 123 0	/* usb3 hub en */
+			&gpio 124 0>;	/* usb3 hub rst*/
+		vbus-gpios = <&gpio 97 0>;	/* gpio_97 for usb3 hub output vbus */
+		regulator-force-boot-off;
+		vbus_delay_ms = <250>;
+		status = "okay";
+	};
+};
+
+&cpu_0 {
+	/* boot frequency for cluster-0, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster0 = <1228000>;
+	/* boot frequency for cluster-1, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster1 = <1228000>;
+};
+
+&dramc {
+	/* dram data rate, should be 1200, 1600, or 2400 */
+	datarate = <2400>;
+};
+
+&cpus {
+	timebase-frequency = <24000000>;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&i2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c04";
+		reg = <0x50>;
+		vin-supply-names = "eeprom_1v8";
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&i2c4 {
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&i2c6 {
+	status = "disabled";
+};
+
+&i2c7 {
+	status = "disabled";
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_66  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range DVL1     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	usbp1_vbus: usbp1_vbus {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_NONE | PULL_UP | PAD_1V8_DS2))    /* drive_vbus1_iso */
+		>;
+	};
+
+	gpio80_pmx_func0: gpio80_pmx_func0 {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_80, MUX_MODE0, (EDGE_BOTH | PULL_UP | PAD_3V_DS4))  /* mmc cd */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49 GPIO_49 2
+		&pinctrl 58 GPIO_58 1
+		&pinctrl 63 GPIO_63 5
+		&pinctrl 70 PRI_TDI 4
+		&pinctrl 74 GPIO_74 1
+		&pinctrl 80 GPIO_80 4
+		&pinctrl 90 GPIO_90 3
+		&pinctrl 96 DVL0 2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 123 GPIO_123 5
+	>;
+};
+
+&udc {
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	status = "okay";
+};
+
+&usbdrd3 {
+	status = "okay";
+	vbus-supply = <&usb3hub>;
+	dwc3@c0a00000 {
+		dr_mode = "host";
+		phy_type = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+	};
+};
+
+&sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc1 &gpio80_pmx_func0>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	cd-inverted;
+	cap-sd-highspeed;
+	sdh-phy-module = <0>;
+	clk-src-freq = <204800000>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	sdh-phy-module = <1>;
+	clk-src-freq = <375000000>;
+	status = "okay";
+};
+
+&eth0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac0>;
+
+	phy-reset-pin = <110>;
+
+	clk_tuning_enable;
+	clk-tuning-by-delayline;
+	tx-phase = <90>;
+	rx-phase = <73>;
+
+	phy-mode = "rgmii";
+	phy-addr = <1>;
+	phy-handle = <&rgmii>;
+
+	ref-clock-from-phy;
+
+	mdio {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii: phy@0 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+		};
+	};
+};
+
+&pcie0_rc {
+	status = "disabled";
+};
+
+&pcie1_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie1_3>;
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+&efuse {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "disabled";
+};
+
+&panel {
+	dcp-gpios = <&gpio 82 0>;
+	dcn-gpios = <&gpio 83 0>;
+	bl-gpios = <&gpio 44 0>;
+	reset-gpios = <&gpio 81 0>;
+	status = "disabled";
+};
diff --git a/arch/riscv/dts/k1-x_pinctrl.dtsi b/arch/riscv/dts/k1-x_pinctrl.dtsi
index 996be629..878e4693 100644
--- a/arch/riscv/dts/k1-x_pinctrl.dtsi
+++ b/arch/riscv/dts/k1-x_pinctrl.dtsi
@@ -333,8 +333,8 @@
 
     pinctrl_i2c6_2: i2c6_2_grp {
         pinctrl-single,pins =<
-            K1X_PADCONF(GPIO_56,    MUX_MODE2, (EDGE_NONE | PULL_UP | PAD_1V8_DS0))    /* i2c6_scl */
-            K1X_PADCONF(GPIO_57,    MUX_MODE2, (EDGE_NONE | PULL_UP | PAD_1V8_DS0))    /* i2c6_sda */
+            K1X_PADCONF(GPIO_56,    MUX_MODE5, (EDGE_NONE | PULL_UP | PAD_1V8_DS0))    /* i2c6_scl */
+            K1X_PADCONF(GPIO_57,    MUX_MODE5, (EDGE_NONE | PULL_UP | PAD_1V8_DS0))    /* i2c6_sda */
         >;
     };
 
diff --git a/arch/riscv/dts/k1-x_spm8821.dtsi b/arch/riscv/dts/k1-x_spm8821.dtsi
index dec7d2af..beadf044 100644
--- a/arch/riscv/dts/k1-x_spm8821.dtsi
+++ b/arch/riscv/dts/k1-x_spm8821.dtsi
@@ -12,13 +12,6 @@
 		bus = <8>;
 		u-boot,dm-spl;
 
-		pmic-reset {
-			compatible = "spacemit,spm8821-reset";
-			reboot-reg = <0x7e>;    /* Address of the reboot register */
-			reboot-mask = <0x02>;   /* Bit mask for triggering a reboot */
-			status = "okay";
-		};
-
 		regulators {
 			/* buck */
 			dcdc_6: DCDC_REG1 {
@@ -139,6 +132,10 @@
 			sw_2: SWITCH_REG1 {
 				regulator-name = "switch1";
 			};
+
+			wdt_pm8821: PMIC_WDT {
+				wdt-name = "wdt_pm8821";
+			};
 		};
 	};
 };
diff --git a/board/spacemit/k1-x/Kconfig b/board/spacemit/k1-x/Kconfig
index 6ec53bc8..94866b5a 100644
--- a/board/spacemit/k1-x/Kconfig
+++ b/board/spacemit/k1-x/Kconfig
@@ -12,6 +12,10 @@ config SYS_CPU
 config SYS_CONFIG_NAME
 	default "k1-x"
 
+config K1_X_BOARD_DEFAULT_SN
+	string "k1-x board default serial number"
+	default "0000000000000000"
+
 config SYS_TEXT_BASE
 	default 0x81200000 if SPL
 	default 0x80000000 if !RISCV_SMODE
@@ -95,6 +99,7 @@ config K1_X_BOARD_SIMULATION
 	bool "k1-x board simulation"
 	help
 	  k1-x board is simulation.
+
 endchoice
 
 endif
diff --git a/board/spacemit/k1-x/configs/uboot_fdt.its b/board/spacemit/k1-x/configs/uboot_fdt.its
index 1797fa4e..61799904 100644
--- a/board/spacemit/k1-x/configs/uboot_fdt.its
+++ b/board/spacemit/k1-x/configs/uboot_fdt.its
@@ -100,6 +100,24 @@
 				algo = "crc32";
 			};
 		};
+		fdt_10 {
+			description = "k1-x_milkv-jupiter";
+			type = "flat_dt";
+			compression = "none";
+			data = /incbin/("../dtb/k1-x_milkv-jupiter.dtb");
+			hash-1 {
+				algo = "crc32";
+			};
+		};
+		fdt_11 {
+			description = "k1-x_MUSE-Book.dtb";
+			type = "flat_dt";
+			compression = "none";
+			data = /incbin/("../dtb/k1-x_MUSE-Book.dtb");
+			hash-1 {
+				algo = "crc32";
+			};
+		};
 	};
 
 	configurations {
@@ -149,5 +167,15 @@
 			loadables = "uboot";
 			fdt = "fdt_9";
 		};
+		conf_10 {
+			description = "k1-x_milkv-jupiter";
+			loadables = "uboot";
+			fdt = "fdt_10";
+		};
+		conf_11 {
+			description = "k1-x_MUSE-Book";
+			loadables = "uboot";
+			fdt = "fdt_11";
+		};
 	};
 };
diff --git a/board/spacemit/k1-x/k1x.c b/board/spacemit/k1-x/k1x.c
index dde9cafc..2d6ed099 100644
--- a/board/spacemit/k1-x/k1x.c
+++ b/board/spacemit/k1-x/k1x.c
@@ -305,10 +305,6 @@ int run_uboot_shell(void)
 
 void _load_env_from_blk(struct blk_desc *dev_desc, const char *dev_name, int dev)
 {
-	/*
-	TODO:
-		load env from bootfs, if bootfs is fat/ext4 at blk dev, use fatload/ext4load.
-	*/
 	int err;
 	u32 part;
 	char cmd[128];
@@ -423,26 +419,18 @@ void import_env_from_bootfs(void)
 #endif
 		break;
 	case BOOT_MODE_NOR:
-#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
 		struct blk_desc *dev_desc;
+		char *blk_name;
+		int blk_index;
 
-		/*nvme need scan at first*/
-		if (!strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, 4)
-						&& run_command("nvme scan", 0)){
-			pr_err("can not find any nvme devices!\n");
+		if (get_available_blk_dev(&blk_name, &blk_index)){
+			printf("can not get available blk dev\n");
 			return;
 		}
 
-		if (strlen(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME) > 0){
-			/* First try partition names on the default device */
-			dev_desc = blk_get_dev(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME,
-								CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX);
-			if (dev_desc) {
-				_load_env_from_blk(dev_desc, CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME,
-							CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX);
-			}
-	}
-#endif
+		dev_desc = blk_get_dev(blk_name, blk_index);
+		if (dev_desc)
+			_load_env_from_blk(dev_desc, blk_name, blk_index);
 		break;
 	case BOOT_MODE_EMMC:
 	case BOOT_MODE_SD:
@@ -515,10 +503,16 @@ void setenv_boot_mode(void)
 		env_set("boot_device", "nand");
 		break;
 	case BOOT_MODE_NOR:
+		char *blk_name;
+		int blk_index;
+
+		if (get_available_blk_dev(&blk_name, &blk_index)){
+			printf("can not get available blk dev\n");
+			return;
+		}
+
 		env_set("boot_device", "nor");
-#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
-		env_set("boot_devnum", simple_itoa(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX));
-#endif
+		env_set("boot_devnum", simple_itoa(blk_index));
 		break;
 	case BOOT_MODE_EMMC:
 		env_set("boot_device", "mmc");
@@ -710,11 +704,8 @@ void set_env_ethaddr(u8 *eeprom_data) {
 
 void set_dev_serial_no(uint8_t *eeprom_data)
 {
-	u8 sn[6] = {0};
-	char cmd_str[128] = {0};
 	struct tlvinfo_tlv *tlv_entry = NULL;
-	int i = 0;
-	unsigned int seed = 0;
+	char *strval;
 
 	// Decide where to read the serial number from
 	if (eeprom_data != NULL) {
@@ -722,35 +713,18 @@ void set_dev_serial_no(uint8_t *eeprom_data)
 	} else {
 		read_from_eeprom(&tlv_entry, TLV_CODE_SERIAL_NUMBER);
 	}
-	if (tlv_entry && tlv_entry->length == 12) {
-		for (i = 0; i < 12; i++) {
-			if (tlv_entry->value[i] != 0) {
-				pr_err("Serial number is valid.\n");
-				return;
-			}
-		}
-	}
 
-	pr_info("Generate rand serial number:\n");
-	/* Generate rand serial number */
-	seed = get_ticks();
-	for (i = 0; i < 6; i++) {
-		sn[i] = rand_r(&seed);
-		pr_info("%02x", sn[i]);
+	if (tlv_entry && (0 < tlv_entry->length) && (tlv_entry->length <= 32)) {
+		pr_info("Serial number is valid.\n");
+		strval = malloc(tlv_entry->length + 1);
+		memcpy(strval, tlv_entry->value, tlv_entry->length);
+		strval[tlv_entry->length] = 0;
+		env_set("serial#", strval);
+		free(strval);
+	}
+	else {
+		env_set("serial#", CONFIG_K1_X_BOARD_DEFAULT_SN);
 	}
-	pr_info("\n");
-
-	/*must read before set/write to eeprom using tlv_eeprom command*/
-	run_command("tlv_eeprom", 0);
-
-	/* save serial number to eeprom */
-	snprintf(cmd_str, (sizeof(cmd_str) - 1), "tlv_eeprom set 0x23 %02x%02x%02x%02x%02x%02x", \
-			sn[0], sn[1], sn[2], sn[3], sn[4], sn[5]);
-	run_command(cmd_str, 0);
-
-	memset(cmd_str, 0, sizeof(cmd_str));
-	snprintf(cmd_str, (sizeof(cmd_str) - 1), "tlv_eeprom write");
-	run_command(cmd_str, 0);
 }
 
 struct code_desc_info {
@@ -830,9 +804,6 @@ int board_late_init(void)
 	struct tlvinfo_tlv *first_entry = NULL;
 
 	// save_ddr_training_info();
-	if (IS_ENABLED(CONFIG_SYSRESET_SPACEMIT))
-		device_bind_driver(gd->dm_root, "spacemit_sysreset",
-					"spacemit_sysreset", NULL);
 
 	// it MAY be NULL when did NOT load build-in env and eeprom is empty
 	if (NULL == env_get("product_name"))
diff --git a/board/spacemit/k1-x/splash.c b/board/spacemit/k1-x/splash.c
index bde77aaf..68c0af0f 100644
--- a/board/spacemit/k1-x/splash.c
+++ b/board/spacemit/k1-x/splash.c
@@ -52,42 +52,27 @@ int set_mmc_splash_location(struct splash_location *locations) {
 }
 
 int set_nor_splash_location(struct splash_location *locations) {
-	struct blk_desc *dev_desc;
-	struct disk_partition info;
-	int err;
-	u32 part;
+	int part, blk_index;
+	char *blk_name;
 	char devpart_str[16];
 
-	if (run_command("nvme scan", 0)) {
-		pr_err("Cannot scan NVMe devices!\n");
+	if (get_available_blk_dev(&blk_name, &blk_index)){
+		printf("can not get available blk dev\n");
 		return -1;
 	}
-
-	dev_desc = blk_get_dev("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX);
-	if (!dev_desc) {
-		pr_err("Cannot find NVMe device\n");
+	part = detect_blk_dev_or_partition_exist(blk_name, blk_index, BOOTFS_NAME);
+	if (part < 0)
 		return -1;
-	}
 
-	for (part = 1; part <= MAX_SEARCH_PARTITIONS; part++) {
-		err = part_get_info(dev_desc, part, &info);
-		if (err) {
-			continue;
-		}
+	snprintf(devpart_str, sizeof(devpart_str), "%d:%d", blk_index, part);
 
-		if (!strcmp(BOOTFS_NAME, info.name)) {
-			break;
-		}
-	}
-
-	if (part > MAX_SEARCH_PARTITIONS) {
-		pr_err("Failed to find bootfs on NOR\n");
+	if (!strcmp("mmc", blk_name))
+		locations[0].name = "emmc_fs";
+	else if (!strcmp("nvme", blk_name))
+		locations[0].name = "nvme_fs";
+	else
 		return -1;
-	}
-
-	snprintf(devpart_str, sizeof(devpart_str), "%d:%d", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX, part);
 
-	locations[0].name = "nvme_fs";
 	locations[0].storage = SPLASH_STORAGE_NVME;
 	locations[0].flags = SPLASH_STORAGE_FS;
 	locations[0].devpart = strdup(devpart_str);
@@ -157,7 +142,20 @@ int splash_screen_prepare(void)
 		env_set("splashsource", "nand_fs");
 		break;
 	case BOOT_MODE_NOR:
-		env_set("splashsource", "nvme_fs");
+		int blk_index;
+		char *blk_name;
+
+		if (get_available_blk_dev(&blk_name, &blk_index)){
+			printf("can not get available blk dev\n");
+			return -1;
+		}
+
+		if (!strcmp("mmc", blk_name))
+			env_set("splashsource", "emmc_fs");
+		else if (!strcmp("nvme", blk_name))
+			env_set("splashsource", "nvme_fs");
+		else
+			printf("not defind blk dev while prepare for splash screen\n");
 		break;
 	case BOOT_MODE_SHELL:
 	case BOOT_MODE_USB:
diff --git a/cmd/spacemit_flash.c b/cmd/spacemit_flash.c
index 3cf46d02..3695598e 100644
--- a/cmd/spacemit_flash.c
+++ b/cmd/spacemit_flash.c
@@ -855,17 +855,18 @@ static int load_recovery_file(struct cmd_tbl *cmdtp, struct flash_dev *fdev,
 
 static int perform_flash_operations(struct cmd_tbl *cmdtp, struct flash_dev *fdev)
 {
+	char *blk_dev;
+	int blk_index;
+
 	u32 boot_mode = get_boot_pin_select();
 	switch(boot_mode){
-#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
 	case BOOT_MODE_NOR:
-		/*nvme devices need scan at first*/
-		if (!strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, 4)){
-			run_command("nvme scan", 0);
+		if (get_available_blk_dev(&blk_dev, &blk_index)){
+			printf("can not get availabel blk dev\n");
+			return -1;
 		}
 
-		fdev->dev_desc = blk_get_dev(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME,
-							 CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX);
+		fdev->dev_desc = blk_get_dev(blk_dev, blk_index);
 		if (!fdev->dev_desc || fdev->dev_desc->type == DEV_TYPE_UNKNOWN) {
 			printf("get blk faild\n");
 			return -1;
@@ -874,17 +875,12 @@ static int perform_flash_operations(struct cmd_tbl *cmdtp, struct flash_dev *fde
 		if (flash_image(cmdtp, fdev)) {
 			return RESULT_FAIL;
 		}
-
 		break;
-#endif //CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
-
 	case BOOT_MODE_NAND:
 		if (flash_image(cmdtp, fdev)) {
 			return RESULT_FAIL;
 		}
-
 		break;
-
 	case BOOT_MODE_EMMC:
 	case BOOT_MODE_SD:
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
@@ -951,26 +947,21 @@ void get_mtd_partition_file(struct flash_dev *fdev)
 void get_blk_partition_file(char *file_name)
 {
 	struct blk_desc *dev_desc = NULL;
-	const char *blk_name;
+	char *blk_name;
 	int blk_index;
 
 	u32 boot_mode = get_boot_pin_select();
 	switch(boot_mode){
-#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
 	case BOOT_MODE_NOR:
-		blk_name = CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME;
-		blk_index = CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX;
-
-		/*nvme devices need scan at first*/
-		if (!strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, 4)){
-			run_command("nvme scan", 0);
+		if (get_available_blk_dev(&blk_name, &blk_index)){
+			printf("can not get availabel blk dev\n");
+			return;
 		}
 
 		dev_desc = blk_get_devnum_by_typename(blk_name, blk_index);
 		if (dev_desc != NULL)
 			strcpy(file_name, FLASH_CONFIG_FILE_NAME);
 		return;
-#endif //CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
 	case BOOT_MODE_NAND:
 		return;
 	case BOOT_MODE_EMMC:
diff --git a/configs/k1_defconfig b/configs/k1_defconfig
index db0f4a31..629d04cb 100644
--- a/configs/k1_defconfig
+++ b/configs/k1_defconfig
@@ -155,6 +155,7 @@ CONFIG_FASTBOOT_MMC_BOOT1_NAME="fsbl"
 CONFIG_FASTBOOT_MMC_BOOT2_NAME="fsbl_1"
 CONFIG_FASTBOOT_CMD_OEM_READ=y
 CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV=y
+CONFIG_FASTBOOT_SUPPORT_SECOND_BLOCK_DEV=y
 CONFIG_FASTBOOT_CMD_OEM_CONFIG_ACCESS=y
 CONFIG_SPL_FASTBOOT_CMD_OEM_CONFIG_ACCESS=y
 CONFIG_FASTBOOT_CMD_OEM_ERASE=y
@@ -219,10 +220,10 @@ CONFIG_SYS_NS16550_IER=0x40
 # CONFIG_SIFIVE_SERIAL is not set
 CONFIG_SPI=y
 CONFIG_K1X_QSPI=y
+CONFIG_K1X_SPI=y
 # CONFIG_SYSRESET_SBI is not set
 # CONFIG_SYSRESET_SYSCON is not set
 CONFIG_SYSRESET_WATCHDOG=y
-CONFIG_SYSRESET_SPACEMIT=y
 CONFIG_TIMER_EARLY=y
 CONFIG_USB=y
 CONFIG_USB_XHCI_HCD=y
@@ -253,8 +254,9 @@ CONFIG_BMP_32BPP=y
 CONFIG_VIDEO_SPACEMIT=y
 CONFIG_DISPLAY_SPACEMIT_HDMI=y
 CONFIG_DISPLAY_SPACEMIT_MIPI=y
-CONFIG_WDT=y
+CONFIG_DISPLAY_SPACEMIT_EDP=y
 CONFIG_WDT_SPACEMIT=y
+CONFIG_WDT_PMIC_SPACEMIT=y
 CONFIG_JFFS2_NOR=y
 CONFIG_JFFS2_USE_MTD_READ=y
 CONFIG_UBIFS_SILENCE_MSG=y
diff --git a/drivers/clk/clk-uclass.c b/drivers/clk/clk-uclass.c
index d533f62c..f54d1bda 100644
--- a/drivers/clk/clk-uclass.c
+++ b/drivers/clk/clk-uclass.c
@@ -607,10 +607,6 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	if (!ops->set_parent)
 		return -ENOSYS;
 
-	ret = ops->set_parent(clk, parent);
-	if (ret)
-		return ret;
-
 	/* get private clock struct used for cache */
 	clk_get_priv(clk, &clkp);
 	clk_get_priv(parent, &parentp);
@@ -631,6 +627,11 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 
 		}
 	}
+
+	ret = ops->set_parent(clk, parent);
+	if (ret)
+		return ret;
+
 	if (CONFIG_IS_ENABLED(CLK_CCF))
 		ret = device_reparent(clkp->dev, parentp->dev);
 
diff --git a/drivers/ddr/spacemit/k1x/ddr_freq.c b/drivers/ddr/spacemit/k1x/ddr_freq.c
index 938e9892..4a25f511 100644
--- a/drivers/ddr/spacemit/k1x/ddr_freq.c
+++ b/drivers/ddr/spacemit/k1x/ddr_freq.c
@@ -119,6 +119,14 @@ static u32 mode_register_read(u32 MR, u32 CH, u32 CS)
 	return UI3;
 }
 
+u32 ddr_get_mr8(void)
+{
+	u32 mr8;
+	mr8 = mode_register_read(8, 0, 0);
+	return (mr8&0xff);
+}
+
+#ifdef CONFIG_SPL_BUILD
 static u32 format_size(u32 density, u32 io_width)
 {
 	u32 size = 0;
@@ -154,21 +162,42 @@ static u32 format_size(u32 density, u32 io_width)
 
 	return size;
 }
-
-u32 ddr_get_mr8(void)
+#else
+static inline u32 map_format_size(u32 val)
 {
-	u32 mr8;
-	mr8 = mode_register_read(8, 0, 0);
-	return (mr8&0xff);
+	u32 tmp;
+
+	tmp = (val & 0x1);
+	if (tmp == 0)
+		return 0;
+	tmp = (val & 0x1f0000) >> 16;
+	switch (tmp) {
+	case 0xd:
+		return 512;
+	case 0xe:
+		return 1024;
+	case 0xf:
+		return 2048;
+	case 0x10:
+		return 4096;
+	case 0x11:
+		return 8192;
+	default:
+		printf("donot support such density=0x%x device\n", val);
+		return 0;
+		break;
+	}
 }
+#endif
 
 u32 ddr_get_density(void)
 {
 	u32 ddr_size = 0;
-	u32 mr8_cs00, mr8_cs01, mr8_cs10, mr8_cs11;
-	u32 io_width_cs00, io_width_cs01, io_width_cs10, io_width_cs11;
 	u32 cs0_size = 0;
 	u32 cs1_size = 0;
+#ifdef CONFIG_SPL_BUILD
+	u32 mr8_cs00, mr8_cs01, mr8_cs10, mr8_cs11;
+	u32 io_width_cs00, io_width_cs01, io_width_cs10, io_width_cs11;
 
 	mr8_cs00 = mode_register_read(8, 0, 0);
 	mr8_cs01 = mode_register_read(8, 1, 0);
@@ -189,10 +218,15 @@ u32 ddr_get_density(void)
 		cs1_size = mr8_cs10 ? format_size(((mr8_cs10 >> 2) & 0xf), io_width_cs10) : 0;
 		cs1_size += mr8_cs11 ? format_size(((mr8_cs11 >> 2) & 0xf), io_width_cs11) : 0;
 	}
+#else
+	cs0_size = map_format_size(readl((void*)0xc0000000 + 0x200));
+	if (ddr_cs_num > 1) {
+		cs1_size = map_format_size(readl((void*)0xc0000000 + 0x208));
+	}
+#endif
 
 	ddr_size = cs0_size + cs1_size;
 	pr_info("DDR size = %d MB\n", ddr_size);
-
 	return ddr_size;
 }
 
diff --git a/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c b/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c
index c41ab53e..27bc592c 100644
--- a/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c
+++ b/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c
@@ -526,8 +526,10 @@ void init_table_mc_a0(uint32_t ddrc_base)
 	REG32(ddrc_base + mc_cfg2_addr) = mc_cfg2_org;
 }
 
-void ddr_dfc_table_init(unsigned int DDRC_BASE)
+void ddr_dfc_table_init(unsigned int DDRC_BASE, unsigned int ddr_size_mb)
 {
+	unsigned int idx;
+
 	REG32(DDRC_BASE + 0x74) = 0x00040303;
 	REG32(DDRC_BASE + 0x78) = 0x00000044;
 	REG32(DDRC_BASE + 0x70) = 0x00000000;
@@ -603,18 +605,25 @@ void ddr_dfc_table_init(unsigned int DDRC_BASE)
 	REG32(DDRC_BASE + 0x74) = 0x1302000d;
 	REG32(DDRC_BASE + 0x78) = 0x00000024;
 	REG32(DDRC_BASE + 0x70) = 0x00000018;
+	idx = 0x00000019;
+	if (16384 == ddr_size_mb) {
+		REG32(DDRC_BASE + 0x74) = 0x13020095;
+		REG32(DDRC_BASE + 0x78) = 0x00000024;
+		REG32(DDRC_BASE + 0x70) = idx++;
+	}
 	REG32(DDRC_BASE + 0x74) = 0x00000002;
 	REG32(DDRC_BASE + 0x78) = 0x00002008;
-	REG32(DDRC_BASE + 0x70) = 0x00000019;
+	REG32(DDRC_BASE + 0x70) = idx++;
 	REG32(DDRC_BASE + 0x74) = 0x00000000;
 	REG32(DDRC_BASE + 0x78) = 0x00002008;
-	REG32(DDRC_BASE + 0x70) = 0x0000001a;
+	REG32(DDRC_BASE + 0x70) = idx++;
 	REG32(DDRC_BASE + 0x74) = 0x00040380;
 	REG32(DDRC_BASE + 0x78) = 0x00020044;
-	REG32(DDRC_BASE + 0x70) = 0x0000001b;
+	REG32(DDRC_BASE + 0x70) = idx;
 	REG32(DDRC_BASE + 0x74) = 0x00040380;
 	REG32(DDRC_BASE + 0x78) = 0x00020044;
 	REG32(DDRC_BASE + 0x70) = 0x0000012e;
+
 	REG32(DDRC_BASE + 0x74) = 0x00040b43;
 	REG32(DDRC_BASE + 0x78) = 0x00000044;
 	REG32(DDRC_BASE + 0x70) = 0x00000180;
@@ -651,15 +660,21 @@ void ddr_dfc_table_init(unsigned int DDRC_BASE)
 	REG32(DDRC_BASE + 0x74) = 0x1302000d;
 	REG32(DDRC_BASE + 0x78) = 0x00000024;
 	REG32(DDRC_BASE + 0x70) = 0x0000018b;
+	idx = 0x0000018c;
+	if (16384 == ddr_size_mb) {
+		REG32(DDRC_BASE + 0x74) = 0x13020095;
+		REG32(DDRC_BASE + 0x78) = 0x00000024;
+		REG32(DDRC_BASE + 0x70) = idx++;
+	}
 	REG32(DDRC_BASE + 0x74) = 0x00000002;
 	REG32(DDRC_BASE + 0x78) = 0x00002008;
-	REG32(DDRC_BASE + 0x70) = 0x0000018c;
+	REG32(DDRC_BASE + 0x70) = idx++;
 	REG32(DDRC_BASE + 0x74) = 0x00000000;
 	REG32(DDRC_BASE + 0x78) = 0x00002008;
-	REG32(DDRC_BASE + 0x70) = 0x0000018d;
+	REG32(DDRC_BASE + 0x70) = idx++;
 	REG32(DDRC_BASE + 0x74) = 0x00040b00;
 	REG32(DDRC_BASE + 0x78) = 0x00020044;
-	REG32(DDRC_BASE + 0x70) = 0x0000018e;
+	REG32(DDRC_BASE + 0x70) = idx;
 }
 
 void top_DDR_MC_init(unsigned DDRC_BASE, unsigned int fp)
@@ -1048,7 +1063,7 @@ void lpddr4_silicon_init(u32 ddr_base, u32 data_rate)
 	adjust_mapping(ddr_base, cs_num, size_mb, mr8_value);
 	LogMsg(0,"ddr density: %u MB \n", size_mb);
 
-	ddr_dfc_table_init(0xF0000000);
+	ddr_dfc_table_init(0xF0000000, size_mb);
 	init_table_mc_a0(0xF0000000);
 
 	top_training_fp_all(ddr_base, cs_num, 0, info->para);
@@ -1060,6 +1075,8 @@ void lpddr4_silicon_init(u32 ddr_base, u32 data_rate)
 	fp=2;
 	ddr_dfc(fp);
 	top_training_fp_all(ddr_base, cs_num, fp, info->para);
+	if (16384 == size_mb)
+		REG32(ddr_base + 0x24) = (0x10020095 | (3 << 24)); //bit7 MR21 RFU
 
 	/* change dram frequency */
 	switch(data_rate) {
diff --git a/drivers/fastboot/Kconfig b/drivers/fastboot/Kconfig
index ebf741b8..3831d9d6 100644
--- a/drivers/fastboot/Kconfig
+++ b/drivers/fastboot/Kconfig
@@ -269,6 +269,27 @@ config FASTBOOT_SUPPORT_BLOCK_DEV_INDEX
 	help
 	  The block device number.
 
+config FASTBOOT_SUPPORT_SECOND_BLOCK_DEV
+	bool "Support second blk device"
+	depends on (FASTBOOT_FLASH_MTD || FASTBOOT_MULTI_FLASH_OPTION_MTD) && FASTBOOT_SUPPORT_BLOCK_DEV
+	help
+	  If support other blk dev on mtd flash, it would try to detect it whild detect
+	  the first blk dev fail.
+
+config FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_NAME
+	string "Target second name for block device"
+	depends on FASTBOOT_SUPPORT_SECOND_BLOCK_DEV
+	default "mmc"
+	help
+	  The block device name, such as mmc/nvme/usb/sata
+
+config FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_INDEX
+	int "The block device number"
+	depends on FASTBOOT_SUPPORT_SECOND_BLOCK_DEV
+	default 2
+	help
+	  The second block device number.
+
 config FASTBOOT_CMD_OEM_CONFIG_ACCESS
 	bool "Enable the 'oem config' command"
 	help
diff --git a/drivers/fastboot/fb_blk.c b/drivers/fastboot/fb_blk.c
index e27c7c77..bb756d3f 100644
--- a/drivers/fastboot/fb_blk.c
+++ b/drivers/fastboot/fb_blk.c
@@ -33,19 +33,19 @@ static int do_get_part_info(struct blk_desc **dev_desc, const char *name,
 			    struct disk_partition *info)
 {
 	int ret = -1;
-#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
-	if (strlen(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME) > 0){
-
-		/* First try partition names on the default device */
-		*dev_desc = blk_get_dev(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME,
-							 CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX);
-		if (*dev_desc) {
-			ret = part_get_info_by_name(*dev_desc, name, info);
-			if (ret >= 0)
-				return ret;
-		}
+	char *blk_dev;
+	int blk_index = -1;
+
+	if (get_available_blk_dev(&blk_dev, &blk_index))
+		return -1;
+
+	/* First try partition names on the default device */
+	*dev_desc = blk_get_dev(blk_dev, blk_index);
+	if (*dev_desc) {
+		ret = part_get_info_by_name(*dev_desc, name, info);
+		if (ret >= 0)
+			return ret;
 	}
-#endif
 
 	printf("has not define block device name \n");
 	return ret;
diff --git a/drivers/fastboot/fb_getvar.c b/drivers/fastboot/fb_getvar.c
index cc656fa8..e28ed235 100644
--- a/drivers/fastboot/fb_getvar.c
+++ b/drivers/fastboot/fb_getvar.c
@@ -290,19 +290,15 @@ static void getvar_mtd_size(char *var_parameter, char *response)
 static void getvar_blk_size(char *var_parameter, char *response)
 {
 	struct blk_desc *dev_desc = NULL;
-	const char *blk_name;
+	char *blk_name;
 	int blk_index;
 
 	u32 boot_mode = get_boot_pin_select();
 	switch(boot_mode){
 	case BOOT_MODE_NOR:
-#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
-		blk_name = CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME;
-		blk_index = CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX;
-
-		/*nvme devices need scan at first*/
-		if (!strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, 4)){
-			run_command("nvme scan", 0);
+		if (get_available_blk_dev(&blk_name, &blk_index)){
+			fastboot_okay("NULL", response);
+			return;
 		}
 
 		dev_desc = blk_get_devnum_by_typename(blk_name, blk_index);
@@ -311,7 +307,6 @@ static void getvar_blk_size(char *var_parameter, char *response)
 		else
 			fastboot_okay("NULL", response);
 		return;
-#endif
 	case BOOT_MODE_EMMC:
 	case BOOT_MODE_SD:
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
diff --git a/drivers/fastboot/fb_mtd.c b/drivers/fastboot/fb_mtd.c
index 5b1a7c4c..491a71b7 100644
--- a/drivers/fastboot/fb_mtd.c
+++ b/drivers/fastboot/fb_mtd.c
@@ -24,8 +24,6 @@ struct fb_mtd_sparse {
 	struct part_info	*part;
 };
 
-static bool unlock_flag = false;
-
 static bool mtd_is_aligned_with_min_io_size(struct mtd_info *mtd, u64 size)
 {
 	return !do_div(size, mtd->writesize);
@@ -364,6 +362,14 @@ void fastboot_mtd_flash_write(const char *cmd, void *download_buffer,
 						response, fdev);
 		return;
 	}
+
+	/*flash env*/
+	/*if (strcmp(cmd, "env") == 0) {*/
+	/*	printf("flash env \n");*/
+	/*	fastboot_oem_flash_env(cmd, fastboot_buf_addr, download_bytes,*/
+	/*							response, fdev);*/
+	/*	return;*/
+	/*}*/
 #endif
 
 	ret = fb_mtd_lookup(cmd, &mtd, &part);
@@ -374,12 +380,6 @@ void fastboot_mtd_flash_write(const char *cmd, void *download_buffer,
 		return;
 	}
 
-	/*unlock nor flash protect*/
-	if (!unlock_flag && mtd->type == MTD_NORFLASH){
-		run_commandf("sf probe;sf protect unlock 0 0x%x", mtd->size);
-		unlock_flag = true;
-	}
-
 	if (need_erase) {
 		/*must erase at first when write data to mtd devices*/
 		printf("Erasing MTD partition %s\n", part->name);
@@ -492,12 +492,6 @@ void fastboot_mtd_flash_erase(const char *cmd, char *response)
 		return;
 	}
 
-	/*unlock nor flash protect*/
-	if (!unlock_flag && mtd->type == MTD_NORFLASH){
-		run_commandf("sf probe;sf protect unlock 0 0x%x", mtd->size);
-		unlock_flag = true;
-	}
-
 	ret = _fb_mtd_erase(mtd, 0);
 	if (ret) {
 		pr_err("failed erasing from device %s", mtd->name);
diff --git a/drivers/fastboot/fb_spacemit.c b/drivers/fastboot/fb_spacemit.c
index 4cad9090..fd1db024 100644
--- a/drivers/fastboot/fb_spacemit.c
+++ b/drivers/fastboot/fb_spacemit.c
@@ -74,19 +74,18 @@ int _write_gpt_partition(struct flash_dev *fdev)
 #if CONFIG_IS_ENABLED(FASTBOOT_SUPPORT_BLOCK_DEV)
 	case BOOT_MODE_NOR:
 	case BOOT_MODE_NAND:
-		pr_info("write gpt to dev:%s\n", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME);
+		char *blk_name;
+		int blk_index;
 
-		/*nvme need scan at first*/
-		if (!strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, 4)
-						&& nvme_scan_namespace()){
-			pr_err("can not can nvme devices!");
+		if (get_available_blk_dev(&blk_name, &blk_index)){
 			ret = -1;
 			goto err;
 		}
 
+		pr_info("write gpt to dev:%s\n", blk_name);
+
 		sprintf(gpt_table_str, "gpt write %s %x '%s'",
-			CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX,
-			fdev->gptinfo.gpt_table);
+			blk_name, blk_index, fdev->gptinfo.gpt_table);
 		if (run_command(gpt_table_str, 0)){
 			pr_err("write gpt fail");
 			ret = -1;
@@ -876,8 +875,8 @@ struct oem_config_info
 	char* (*convert)(char *);
 };
 const struct oem_config_info config_info[] = {
-	{ "product_name", TLV_CODE_PRODUCT_NAME, 16, NULL },
-	{ "serial#", TLV_CODE_SERIAL_NUMBER, 12, NULL },
+	{ "product_name", TLV_CODE_PRODUCT_NAME, 32, NULL },
+	{ "serial#", TLV_CODE_SERIAL_NUMBER, 32, NULL },
 	{ "ethaddr", TLV_CODE_MAC_BASE, 17, NULL },
 	{ "ethsize", TLV_CODE_MAC_SIZE, 6, NULL },/*size must equal or less than 65535*/
 	{ "manufacture_date", TLV_CODE_MANUF_DATE, 19, NULL },
@@ -1010,11 +1009,14 @@ static void write_oem_configuration(char *config, char *response)
 		}
 	}
 
-	if (ret){
-		fastboot_fail("write key fail", response);
-		return;
-	}
+	if (0 == ret)
+		fastboot_okay(NULL, response);
+	else
+		fastboot_fail("NOT exist", response);
+}
 
+static void flush_oem_configuration(char *config, char *response)
+{
 #if defined(CONFIG_SPL_BUILD)
 	if (0 == write_tlvinfo_to_eeprom())
 #else
@@ -1045,6 +1047,8 @@ void fastboot_config_access(char *operation, char *config, char *response)
 		read_oem_configuration(config, response);
 	else if (0 == strcmp(operation, "write"))
 		write_oem_configuration(config, response);
+	else if (0 == strcmp(operation, "flush"))
+		flush_oem_configuration(config, response);
 	else
 		fastboot_fail("NOT support", response);
 }
@@ -1308,3 +1312,91 @@ void clear_storage_data(char *cmd_parameter, char *response)
 }
 
 #endif /*CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_ERASE)*/
+
+/**
+ * @brief detect blk dev exist or not.
+ *
+ * @param blk_name try to find blk dev.
+ * @param partition try to find partition exist or not.
+ * @return int return partition index while finding partition in blk dev.
+*/
+int detect_blk_dev_or_partition_exist(char *blk_name, int blk_index, char *partition)
+{
+	struct blk_desc *dev_desc;
+	struct disk_partition info;
+	u32 part;
+	int err;
+
+	dev_desc = blk_get_dev(blk_name, blk_index);
+	if (!dev_desc) {
+		pr_info("Cannot find blk device\n");
+		return -1;
+	}
+
+	if (partition != NULL) {
+		for (part = 1; part <= MAX_SEARCH_PARTITIONS; part++) {
+			err = part_get_info(dev_desc, part, &info);
+			if (err) {
+				continue;
+			}
+
+			if (!strcmp(partition, info.name)) {
+				return part;
+			}
+		}
+
+		if (part > MAX_SEARCH_PARTITIONS) {
+			pr_info("can not find partition in blk dev\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * @brief try to find available blk dev while defind multi blks at nor boot.
+ *
+ * @param blk_dev return available blk dev.
+ * @param index return available blk index.
+ * @param return return 0 while detect available blk dev.
+*/
+int get_available_blk_dev(char **blk_dev, int *index)
+{
+#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
+	static bool scan_nvme = false;
+	/*nvme devices need scan at first*/
+	if (!scan_nvme){
+		if (!strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME, 4)
+#ifdef CONFIG_FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_NAME
+			|| !strncmp("nvme", CONFIG_FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_NAME, 4)
+#endif
+		){
+			run_command("nvme scan", 0);
+			scan_nvme = true;
+		}
+	}
+#endif
+
+#ifdef CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
+	if (strlen(CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME) > 0){
+		*blk_dev = CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME;
+		*index = CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_INDEX;
+		if (detect_blk_dev_or_partition_exist(*blk_dev, *index, NULL) < 0){
+#ifdef CONFIG_FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_NAME
+			*blk_dev = CONFIG_FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_NAME;
+			*index = CONFIG_FASTBOOT_SUPPORT_SECOND_BLOCK_DEV_INDEX;
+			if (detect_blk_dev_or_partition_exist(*blk_dev, *index, NULL) < 0)
+#endif
+				return -1;
+		}
+	}else{
+		printf("not defind blk dev, check make config\n");
+		return -1;
+	}
+#else
+	printf("not defind blk dev, check make config\n");
+	return -1;
+#endif //CONFIG_FASTBOOT_SUPPORT_BLOCK_DEV_NAME
+	return 0;
+}
diff --git a/drivers/i2c/spacemit_i2c.c b/drivers/i2c/spacemit_i2c.c
index 2ed5707a..1ea8fbd6 100644
--- a/drivers/i2c/spacemit_i2c.c
+++ b/drivers/i2c/spacemit_i2c.c
@@ -398,7 +398,6 @@ void i2c_init_board(void)
 
 	mmio_write_32(0xd4051024, (*(unsigned int *)0xd4051024) | (1 << 6));
 	mmio_write_32(0xd4090104, (*(unsigned int *)0xd4090104) | (1 << 4));
-	mmio_write_32(0xd4090108, (*(unsigned int *)0xd4090108) | (1 << 31));
 
 	mmio_write_32(0xd401e228, (*(unsigned int *)0xd401e228) | (1 << 1));
         mmio_write_32(0xd401e22c, (*(unsigned int *)0xd401e22c) | (1 << 1));
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
index d61a0f2d..7454e96f 100644
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -533,7 +533,7 @@ static int do_del_mtd_partitions(struct mtd_info *master)
 		debug("Deleting %s MTD partition\n", slave->name);
 		ret = del_mtd_device(slave);
 		if (ret < 0) {
-			pr_debug("Error when deleting partition \"%s\" (%d)\n",
+			pr_err("Error when deleting partition \"%s\" (%d)\n",
 			       slave->name, ret);
 			err = ret;
 			continue;
diff --git a/drivers/pci/pcie_dw_k1x.c b/drivers/pci/pcie_dw_k1x.c
index a51ade0e..9116b582 100644
--- a/drivers/pci/pcie_dw_k1x.c
+++ b/drivers/pci/pcie_dw_k1x.c
@@ -298,7 +298,6 @@ void porta_rterm(struct pcie_dw_k1x *k1x)
 	u32 val;
 
 	//REG32(PMUA_REG_BASE + 0x3CC) = 0x4000003f;
-	val = k1x_pcie_conf0_reg_readl(k1x, 0);
 	val = 0x4000003f;
 	k1x_pcie_conf0_reg_writel(k1x, 0 , val);
 
@@ -391,12 +390,10 @@ void porta_rterm(struct pcie_dw_k1x *k1x)
 	k1x_pcie_phy0_reg_writel(k1x, (0x12 << 2), val);
 
 	//REG32(0xC0B10000 + (0x02 << 2)) = 0x00000B78; // PU_ADDR_CLK_CFG of lane0
-	val = k1x_pcie_phy0_reg_readl(k1x, (0x02 << 2));
 	val = 0x00000B78;
 	k1x_pcie_phy0_reg_writel(k1x, (0x02 << 2), val);
 
 	//REG32(0xC0B10000 + (0x06 << 2)) = 0x00000400; // force rcv done
-	val = k1x_pcie_phy0_reg_readl(k1x, (0x06 << 2));
 	val = 0x00000400;
 	k1x_pcie_phy0_reg_writel(k1x, (0x06 << 2), val);
 	printk("Now waiting portA resister tuning done...\n");
@@ -608,25 +605,17 @@ static int init_phy(struct pcie_dw_k1x *k1x)
 	k1x_pcie_phy_reg_writel(k1x, (0x12 << 2), val);
 
 	// PU_ADDR_CLK_CFG of lane0
-	val = k1x_pcie_phy_reg_readl(k1x, (0x02 << 2));
 	val = 0x00000B78;
 	k1x_pcie_phy_reg_writel(k1x, (0x02 << 2), val);
 
 	 // PU_ADDR_CLK_CFG of lane1
-	val = k1x_pcie_phy_reg_readl(k1x, 0x400 + (0x02 << 2));
 	val = 0x00000B78;
 	k1x_pcie_phy_reg_writel(k1x, 0x400 + (0x02 << 2), val);
 
 	// force rcv done
-	val = k1x_pcie_phy_reg_readl(k1x, (0x06 << 2));
 	val = 0x00000400;
 	k1x_pcie_phy_reg_writel(k1x, (0x06 << 2), val);
 
-	// force rcv done
-	val = k1x_pcie_phy_reg_readl(k1x, 0x400 + (0x06 << 2));
-	val = 0x00000400;
-	k1x_pcie_phy_reg_writel(k1x, 0x400 + (0x06 << 2), val);
-
 	// waiting pll lock
 	printk("waiting pll lock...\n");
 	do
diff --git a/drivers/power/pmic/spacemit_pmic.c b/drivers/power/pmic/spacemit_pmic.c
index 7f259dc2..ccbd66ae 100644
--- a/drivers/power/pmic/spacemit_pmic.c
+++ b/drivers/power/pmic/spacemit_pmic.c
@@ -76,15 +76,14 @@ static const struct pmic_child_info pmic_children_info[] = {
 	{ .prefix = "EDCDC_REG", .driver = "pm8xx_buck"},
 	{ .prefix = "LDO_REG", .driver = "pm8xx_ldo"},
 	{ .prefix = "SWITCH_REG", .driver = "pm8xx_switch"},
+	{ .prefix = "PMIC_WDT", .driver = "pm8xx_wdt"},
 	{ },
 };
 
 static int pm8xx_bind(struct udevice *dev)
 {
 	ofnode regulators_node;
-	ofnode pmic_reset_node;
 	int children;
-	int ret;
 
 	regulators_node = dev_read_subnode(dev, "regulators");
 	if (!ofnode_valid(regulators_node)) {
@@ -99,15 +98,6 @@ static int pm8xx_bind(struct udevice *dev)
 	if (!children)
 		debug("%s: %s - no child found\n", __func__, dev->name);
 
-	pmic_reset_node = dev_read_subnode(dev, "pmic-reset");
-	if (ofnode_valid(pmic_reset_node) && ofnode_is_available(pmic_reset_node)) {
-		debug("Binding pmic-reset node\n");
-		ret = device_bind_driver_to_node(dev, "pmic_sysreset", "pmic_sysreset", pmic_reset_node, NULL);
-		if (ret) {
-			debug("Failed to bind pmic_sysreset driver: %d\n", ret);
-		}
-	}
-
 	/* Always return success for this device */
 	return 0;
 }
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index c5993e67..48a34b34 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -163,6 +163,11 @@ config K1X_QSPI
 	  Enable the Spacemit K1X Quad-SPI (QSPI) driver.
 	  This driver support spi flash single, quad and memory reads.
 
+config K1X_SPI
+	bool "Spacemit K1X SPI driver"
+	help
+	  Enable the Spacemit K1X SPI driver.
+
 config DESIGNWARE_SPI
 	bool "Designware SPI driver"
 	help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 410a24df..1f5a7b69 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_CF_SPI) += cf_spi.o
 obj-$(CONFIG_CORTINA_SFLASH) += ca_sflash.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 obj-$(CONFIG_K1X_QSPI) += k1x_qspi.o
+obj-$(CONFIG_K1X_SPI) += k1x_spi.o
 obj-$(CONFIG_DESIGNWARE_SPI) += designware_spi.o
 obj-$(CONFIG_EXYNOS_SPI) += exynos_spi.o
 obj-$(CONFIG_FSL_DSPI) += fsl_dspi.o
diff --git a/drivers/spi/k1x_spi.c b/drivers/spi/k1x_spi.c
new file mode 100644
index 00000000..08b90c1a
--- /dev/null
+++ b/drivers/spi/k1x_spi.c
@@ -0,0 +1,467 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Support for Spacemit k1x spi controller
+ *
+ * Copyright (c) 2023, spacemit Corporation.
+ *
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <dm.h>
+#include <spi.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <clk.h>
+#include <reset.h>
+#include <asm/gpio.h>
+#include "k1x_spi.h"
+
+#define TIMEOUT 		100000
+
+#define SSP_DATA_16BIT		16
+#define SSP_DATA_8BIT		8
+#define SSP_DATA_32BIT		32
+#define SSP_DATA_18BIT		18
+
+#define SSP_CLK_26		26000000
+#define SSP_CLK_6P5		6500000
+
+#define K1X_APBC_BASE   0xd4015000
+#define K1X_APBC2_BASE  0xf0610000
+#define K1X_GPIO_BASE	0xd4019000
+#define APBC_SSPA0		0x80	/* Clock/Reset Control Register for SSPA0 */
+#define APBC_SSPA1		0x84	/* Clock/Reset Control Register for SSPA1 */
+#define APBC_SSP2		0x4	    /* Clock/Reset Control Register for SSPA1 */
+#define APBC_SSP3		0x7C	/* Clock/Reset Control Register for SSP3 */
+#define K1X_APBC_ADDR(x)		((uint32_t)((K1X_APBC_BASE) + (x)))
+#define REG_APBC_SSPA0_CLK_RST	K1X_APBC_ADDR(APBC_SSPA0) /*Clock/Reset Control Register for SSPA 0*/
+#define REG_APBC_SSPA1_CLK_RST	K1X_APBC_ADDR(APBC_SSPA1) /*Clock/Reset Control Register for SSPA 1*/
+#define REG_APBC_SSP2_CLK_RST	((uint32_t)(K1X_APBC2_BASE + APBC_SSP2)) /*Clock/Reset Control Register for SSPA 1*/
+#define REG_APBC_SSP3_CLK_RST	K1X_APBC_ADDR(APBC_SSP3)  /*Clock/Reset Control Register for SSP 3*/
+
+/* Common APB clock register bit definitions */
+#define APBC_APBCLK		(1<<0)  /* APB Bus Clock Enable */
+#define APBC_FNCLK		(1<<1)  /* Functional Clock Enable */
+#define APBC_RST		(1<<2)  /* Reset Generation */
+
+/* APB functional Clock Selection Mask */
+#define APBC_FNCLKSEL(x)        (((x) & 0x7) << 4)
+
+#define SSP_DATA_16_BIT		(15 << 5)
+#define SSP_DATA_8_BIT		(7 << 5)
+#define SSP_DATA_32_BIT		(31 << 5)
+#define SSP_DATA_18_BIT		(17 << 5)
+
+struct k1x_spi {
+	void __iomem *base;
+	struct clk clk;
+	struct reset_ctl reset;
+	unsigned int speed;
+	unsigned int freq;
+	unsigned int mode;
+	unsigned int port;
+	unsigned int cs_gpio;
+	int master;
+	int flags;
+	int n_bytes;
+	int (*write)(struct k1x_spi *priv);
+	int (*read)(struct k1x_spi *priv);
+	int data_length;
+	void *tx;
+	void *tx_end;
+	void *rx;
+	void *rx_end;
+	int len;
+	int dma;
+};
+
+static bool k1x_spi_txfifo_full(struct k1x_spi *priv)
+{
+	return !(readl(priv->base + REG_SSP_STATUS) & BIT_SSP_TNF);
+}
+
+int k1x_spi_flush(struct k1x_spi *priv)
+{
+	unsigned long limit = 1 << 13;
+
+	do {
+		while (readl(priv->base + REG_SSP_STATUS) & BIT_SSP_RNE)
+			readl(priv->base + REG_SSP_DATAR);
+	} while ((readl(priv->base + REG_SSP_STATUS) & BIT_SSP_BSY) && --limit);
+	writel(BIT_SSP_ROR, priv->base + REG_SSP_STATUS);
+
+	return limit;
+}
+
+static int null_writer(struct k1x_spi *priv)
+{
+	u8 n_bytes = priv->n_bytes;
+
+	if (k1x_spi_txfifo_full(priv)
+		|| (priv->tx == priv->tx_end))
+		return 0;
+
+	writel(0, priv->base + REG_SSP_DATAR);
+	priv->tx += n_bytes;
+
+	return 1;
+}
+
+static int null_reader(struct k1x_spi *priv)
+{
+	u8 n_bytes = priv->n_bytes;
+
+	while ((readl(priv->base + REG_SSP_STATUS) & BIT_SSP_RNE)
+	       && (priv->rx < priv->rx_end)) {
+		readl(priv->base + REG_SSP_DATAR);
+		priv->rx += n_bytes;
+	}
+
+	return priv->rx == priv->rx_end;
+}
+
+static int u8_writer(struct k1x_spi *priv)
+{
+	if (k1x_spi_txfifo_full(priv)
+		|| (priv->tx == priv->tx_end))
+		return 0;
+
+	writel(*(u8 *)(priv->tx), priv->base + REG_SSP_DATAR);
+	++priv->tx;
+
+	return 1;
+}
+
+static int u8_reader(struct k1x_spi *priv)
+{
+	while ((readl(priv->base + REG_SSP_STATUS) & BIT_SSP_RNE)
+	       && (priv->rx < priv->rx_end)) {
+		*(u8 *)(priv->rx) = readl(priv->base + REG_SSP_DATAR);
+		++priv->rx;
+	}
+
+	return priv->rx == priv->rx_end;
+}
+
+void k1x_spi_set_selfloop(struct k1x_spi *priv, int is_loop)
+{
+	if (is_loop)
+		writel(BIT_SSP_LBM | readl(REG_SSP_TOP_CTRL + priv->base),
+				REG_SSP_TOP_CTRL + priv->base);
+	else
+		writel((~BIT_SSP_LBM) & readl(REG_SSP_TOP_CTRL + priv->base),
+				REG_SSP_TOP_CTRL + priv->base);
+}
+
+static void k1x_gpio_set_output(int gpio, int value)
+{
+	void __iomem *reg;
+	u32 reg_gbase = 0, reg_goff = 0, bit_no = 0;
+	u32 val;
+
+	if (gpio < 96) {
+		reg_goff = (gpio >> 5) * (0x4);
+	} else {
+		reg_goff = 0x100;
+	}
+	reg_gbase = K1X_GPIO_BASE + reg_goff;
+	bit_no = (gpio) & 0x1f;
+
+	reg =  (void *)(ulong)(reg_gbase + 0xc);
+	val = readl(reg);
+	val |= 1 << bit_no;
+	writel(val, reg);
+
+	udelay(2);
+
+	if (value) {
+		reg =  (void *)(ulong)(reg_gbase + 0x18);
+		val = readl(reg);
+		val |= 1 << bit_no;
+		writel(val, reg);
+	} else {
+		reg =  (void *)(ulong)(reg_gbase + 0x24);
+		val = readl(reg);
+		val |= 1 << bit_no;
+		writel(val, reg);
+	}
+}
+
+static void k1x_gpio_set_value(int gpio, int value)
+{
+	void __iomem *reg;
+	u32 reg_gbase = 0, reg_goff = 0, bit_no = 0;
+	u32 val;
+
+	if (gpio < 96) {
+		reg_goff = (gpio >> 5) * (0x4);
+	} else {
+		reg_goff = 0x100;
+	}
+	reg_gbase = K1X_GPIO_BASE + reg_goff;
+	bit_no = (gpio) & 0x1f;
+
+	if (value) {
+		reg =  (void *)(ulong)(reg_gbase + 0x18);
+		val = readl(reg);
+		val |= 1 << bit_no;
+		writel(val, reg);
+	} else {
+		reg =  (void *)(ulong)(reg_gbase + 0x24);
+		val = readl(reg);
+		val |= 1 << bit_no;
+		writel(val, reg);
+	}
+}
+
+static void k1x_stop_ssp(struct k1x_spi *priv)
+{
+	writel(BIT_SSP_ROR | BIT_SSP_TINT, priv->base + REG_SSP_STATUS);
+	writel(BITS_SSP_RFT(8) | BITS_SSP_TFT(7), priv->base + REG_SSP_FIFO_CTRL);
+	writel(0, priv->base + REG_SSP_TO);
+}
+
+int k1x_spi_pio_xfer(struct k1x_spi *priv, int len, void *din, unsigned long flags)
+{
+	if (flags & SPI_XFER_BEGIN) {
+		k1x_gpio_set_value(priv->cs_gpio, 0);
+	}
+
+	do {
+		if (priv->read(priv)) {
+			k1x_stop_ssp(priv);
+			break;
+		}
+	} while (priv->write(priv));
+
+	if (flags & SPI_XFER_END) {
+		k1x_gpio_set_value(priv->cs_gpio, 1);
+	}
+
+	din = priv->rx;
+	return 0;
+}
+
+static int k1x_spi_transfer_config(struct k1x_spi *priv)
+{
+	uint32_t sscr0 = 0;
+	u32 top_ctrl;
+	u32 fifo_ctrl;
+
+	priv->n_bytes = 1;
+
+	/* empty read buffer */
+	if (k1x_spi_flush(priv) == 0) {
+		printf("k1x spi flush failed\n");
+		return -1;
+	}
+
+	top_ctrl = readl(priv->base + REG_SSP_TOP_CTRL);
+	fifo_ctrl = readl(priv->base + REG_SSP_FIFO_CTRL);
+
+	switch (priv->mode) {
+	case SPI_MODE_0:
+		break;
+	case SPI_MODE_1:
+		sscr0 |= BIT_SSP_SPH;
+		break;
+	case SPI_MODE_2:
+		sscr0 |= BIT_SSP_SPO;
+		break;
+	case SPI_MODE_3:
+		sscr0 |= BIT_SSP_SPO | BIT_SSP_SPH;
+		break;
+	default:
+		return -1;
+	}
+	top_ctrl |= sscr0;
+
+	priv->speed = 0x0;
+	switch (priv->data_length) {
+	case 8:
+		priv->speed |= SSP_DATA_8_BIT;
+		break;
+	case 18:
+		priv->speed |= SSP_DATA_18_BIT;
+		break;
+	case 32:
+		priv->speed |= SSP_DATA_32_BIT;
+		break;
+	case 16:
+	default:
+		priv->speed |= SSP_DATA_16_BIT;
+	}
+	top_ctrl |= priv->speed;
+
+	writel(BIT_SSP_ROR | BIT_SSP_TINT, priv->base + REG_SSP_STATUS);
+	writel(0xbb8, priv->base + REG_SSP_TO);
+
+	top_ctrl |= BIT_SSP_HOLD_FRAME_LOW;
+
+	top_ctrl &= ~BIT_SSP_SSE;
+	writel(top_ctrl, priv->base + REG_SSP_TOP_CTRL);
+	writel(fifo_ctrl, priv->base + REG_SSP_FIFO_CTRL);
+	top_ctrl |= BIT_SSP_SSE;
+
+	writel(top_ctrl, priv->base + REG_SSP_TOP_CTRL);
+
+	return 0;
+}
+
+static int k1x_spi_claim_bus(struct udevice *dev)
+{
+	return 0;
+}
+
+static int k1x_spi_release_bus(struct udevice *dev)
+{
+	u32 val = 0;
+	struct udevice *bus = dev->parent;
+	struct k1x_spi *priv = dev_get_priv(bus);
+	printf("k1x spi release bus\n");
+
+	val = readl(priv->base + REG_SSP_TOP_CTRL);
+	val &= ~(BIT_SSP_SSE | BIT_SSP_HOLD_FRAME_LOW);
+	writel(val, priv->base + REG_SSP_TOP_CTRL);
+	return 0;
+}
+
+static int k1x_spi_set_mode(struct udevice *bus, uint mode)
+{
+	struct k1x_spi *priv = dev_get_priv(bus);
+
+	printf("k1x spi set mode = %d.\n", mode);
+	priv->mode = mode;
+
+	return 0;
+}
+
+static int k1x_spi_set_speed(struct udevice *bus, uint speed)
+{
+	struct k1x_spi *priv = dev_get_priv(bus);
+
+	printf("k1x spi set speed = %d\n", speed);
+
+	if (priv->freq != speed) {
+		priv->freq = speed;
+		clk_set_rate(&priv->clk, priv->freq);
+	}
+
+	return 0;
+}
+
+static int k1x_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			   const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct k1x_spi *priv = dev_get_priv(bus);
+	int ret;
+
+	priv->len = bitlen >> 3;
+
+	priv->tx = (void *)dout;
+	priv->tx_end = priv->tx + priv->len;
+	priv->rx = din;
+	priv->rx_end = priv->rx + priv->len;
+	if (priv->tx) {
+		priv->write = u8_writer;
+	} else {
+		priv->write = null_writer;
+	}
+	if (priv->rx) {
+		priv->read = u8_reader;
+	} else {
+		priv->read = null_reader;
+	}
+
+	k1x_spi_transfer_config(priv);
+	ret = k1x_spi_pio_xfer(priv, priv->len, din, flags);
+
+	return ret;
+}
+
+static int k1x_spi_probe(struct udevice *dev)
+{
+	struct k1x_spi *priv = dev_get_priv(dev);
+	int ret;
+
+	priv->base = dev_remap_addr(dev);
+	if (!priv->base)
+		return -EINVAL;
+
+	priv->freq = dev_read_u32_default(dev, "clock-frequency", 0);
+	if (!priv->freq) {
+		printf("Please provide clock-frequency!\n");
+		return -EINVAL;
+	}
+
+	dev_read_u32(dev, "port", &priv->port);
+	if ((priv->port < 0) || (priv->port > 4)) {
+		printf("Please provide valid port num!\n");
+		return -EINVAL;
+	}
+
+	dev_read_u32(dev, "cs-gpio", &priv->cs_gpio);
+	printf("cs gpio %d\n", priv->cs_gpio);
+	if ((priv->cs_gpio < 0) || (priv->cs_gpio > 128)) {
+		printf("Please provide valid gpio num!\n");
+		return -EINVAL;
+	}
+
+	ret = clk_get_by_index(dev, 0, &priv->clk);
+	if (ret) {
+		pr_err("It has no clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_index(dev, 0, &priv->reset);
+	if (ret) {
+		pr_err("It has no reset: %d\n", ret);
+		return ret;
+	}
+
+	k1x_gpio_set_output(priv->cs_gpio, 1);
+
+	/* default clk */
+	clk_set_rate(&priv->clk, priv->freq);
+	clk_enable(&priv->clk);
+	reset_deassert(&priv->reset);
+
+	/* current default settings */
+	writel(0, priv->base + REG_SSP_TOP_CTRL);
+	writel(0, priv->base + REG_SSP_FIFO_CTRL);
+	writel(BITS_SSP_RFT(8) | BITS_SSP_TFT(7), priv->base + REG_SSP_FIFO_CTRL);
+	writel(SSP_DATA_8_BIT, priv->base + REG_SSP_TOP_CTRL);
+	priv->dma = 0;
+	priv->data_length = SSP_DATA_8BIT;
+	writel(0, priv->base + REG_SSP_TO);
+	writel(0, priv->base + REG_SSP_PSP_CTRL);
+
+	/* loopback test need the following setting */
+	//k1x_spi_set_selfloop(priv, 1);
+
+	return 0;
+}
+
+static const struct dm_spi_ops k1x_spi_ops = {
+	.claim_bus	= k1x_spi_claim_bus,
+	.release_bus	= k1x_spi_release_bus,
+	.set_mode = k1x_spi_set_mode,
+	.set_speed = k1x_spi_set_speed,
+	.xfer = k1x_spi_xfer,
+};
+
+static const struct udevice_id k1x_spi_ids[] = {
+	{ .compatible = "spacemit,k1x-spi" },
+	{ }
+};
+
+U_BOOT_DRIVER(k1x_spi) = {
+	.name = "k1x_spi",
+	.id = UCLASS_SPI,
+	.of_match = k1x_spi_ids,
+	.ops = &k1x_spi_ops,
+	.priv_auto = sizeof(struct k1x_spi),
+	.probe = k1x_spi_probe,
+};
diff --git a/drivers/spi/k1x_spi.h b/drivers/spi/k1x_spi.h
new file mode 100644
index 00000000..c6aef30e
--- /dev/null
+++ b/drivers/spi/k1x_spi.h
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Support for Spacemit k1x spi controller
+ *
+ * Copyright (c) 2023, spacemit Corporation.
+ *
+ */
+
+#ifndef _K1X_SPI_H
+#define _K1X_SPI_H
+
+/* registers definitions for SSP0 */
+#define REG_SSP_TOP_CTRL			(0x00)/*SSP Top Control Register*/
+#define REG_SSP_FIFO_CTRL			(0x04)/*SSP FIFO Control Register*/
+#define REG_SSP_INT_EN				(0x08)/*SSP Interrupt Enable Register*/
+#define REG_SSP_TO				(0x0C)/*SSP Time Out Register*/
+#define REG_SSP_DATAR				(0x10)/*SSP Data Register*/
+#define REG_SSP_STATUS				(0x14)/*SSP Status Register*/
+#define REG_SSP_PSP_CTRL			(0x18)/*SSP Programmable Serial Protocol Control Register*/
+#define REG_SSP_NET_WORK_CTRL			(0x1C)/*SSP Net Work Control Register*/
+#define REG_SSP_NET_WORK_STATUS			(0x20)/*SSP Net Work Status Register*/
+#define REG_SSP_RWOT_CTRL			(0x24)/*SSP RWOT Control Register*/
+#define REG_SSP_RWOT_CCM			(0x28)/*SSP RWOT Counter Cycles Match Register*/
+#define REG_SSP_RWOT_CVWRn			(0x2C)/*SSP RWOT Counter Value Write for Read Request Register*/
+
+/* bits definitions for register REG_SSP0_SSP_TOP_CTRL */
+#define BIT_SSP_TTELP				( BIT(18) )
+#define BIT_SSP_TTE				( BIT(17) )
+#define BIT_SSP_SCFR				( BIT(16) )
+#define BIT_SSP_IFS				( BIT(15) )
+#define BIT_SSP_HOLD_FRAME_LOW			( BIT(14) )
+#define BIT_SSP_TRAIL				( BIT(13) )
+#define BIT_SSP_LBM				( BIT(12) )
+#define BIT_SSP_SPH				( BIT(11) )
+#define BIT_SSP_SPO				( BIT(10) )
+#define BITS_SSP_DSS(_X_)			( (_X_) << 5 & (BIT(5)|BIT(6)|BIT(7)|BIT(8)|BIT(9)) )
+#define BIT_SSP_SFRMDIR				( BIT(4) )
+#define BIT_SSP_SCLKDIR				( BIT(3) )
+#define BITS_SSP_FRF(_X_)			( (_X_) << 1 & (BIT(1)|BIT(2)) )
+#define BIT_SSP_SSE				( BIT(0) )
+
+/* bits definitions for register REG_SSP0_SSP_FIFO_CTRL */
+#define BIT_SSP_STRF				( BIT(19) )
+#define BIT_SSP_EFWR				( BIT(18) )
+#define BIT_SSP_RXFIFO_AUTO_FULL_CTRL		( BIT(17) )
+#define BIT_SSP_FPCKE				( BIT(16) )
+#define BITS_SSP_TXFIFO_WR_ENDIAN(_X_)		( (_X_) << 14 & (BIT(14)|BIT(15)) )
+#define BITS_SSP_RXFIFO_RD_ENDIAN(_X_)		( (_X_) << 12 & (BIT(12)|BIT(13)) )
+#define BIT_SSP_RSRE				( BIT(11) )
+#define BIT_SSP_TSRE				( BIT(10) )
+#define BITS_SSP_RFT(_X_)			( (_X_) << 5 & (BIT(5)|BIT(6)|BIT(7)|BIT(8)|BIT(9)) )
+#define BITS_SSP_TFT(_X_)			( (_X_) & (BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)) )
+
+/* bits definitions for register REG_SSP0_SSP_INT_EN */
+#define BIT_SSP_EBCEI				( BIT(6) )
+#define BIT_SSP_TIM				( BIT(5) )
+#define BIT_SSP_RIM				( BIT(4) )
+#define BIT_SSP_TIE				( BIT(3) )
+#define BIT_SSP_RIE				( BIT(2) )
+#define BIT_SSP_TINTE				( BIT(1) )
+#define BIT_SSP_PINTE				( BIT(0) )
+
+/* bits definitions for register REG_SSP0_SSP_TO */
+#define BITS_SSP_TIMEOUT(_X_)			( (_X_) & (BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7)|BIT(8)|BIT(9)|BIT(10)|BIT(11)|BIT(12)|BIT(13)|BIT(14)|BIT(15)|BIT(16)|BIT(17)|BIT(18)|BIT(19)|BIT(20)|BIT(21)|BIT(22)|BIT(23)) )
+
+/* bits definitions for register REG_SSP0_SSP_DATAR */
+#define BITS_SSP_DATA(_X_)			(_X_)
+
+/* bits definitions for register REG_SSP0_SSP_STATUS */
+#define BIT_SSP_OSS				( BIT(23) )
+#define BIT_SSP_TX_OSS				( BIT(22) )
+#define BIT_SSP_BCE				( BIT(21) )
+#define BIT_SSP_ROR				( BIT(20) )
+#define BITS_SSP_RFL(_X_)			( (_X_) << 15 & (BIT(15)|BIT(16)|BIT(17)|BIT(18)|BIT(19)) )
+#define SSP_SSSR_RFL_MSK			(0x1f << 15)	/* Receive FIFO Level */
+#define BIT_SSP_RNE				( BIT(14) )
+#define BIT_SSP_RFS				( BIT(13) )
+#define BIT_SSP_TUR				( BIT(12) )
+#define BITS_SSP_TFL(_X_)			( (_X_) << 7 & (BIT(7)|BIT(8)|BIT(9)|BIT(10)|BIT(11)) )
+#define SSP_SSSR_TFL_MSK			(0x1f << 7)	/* Transmit FIFO Level */
+#define BIT_SSP_TNF				( BIT(6) )
+#define BIT_SSP_TFS				( BIT(5) )
+#define BIT_SSP_EOC				( BIT(4) )
+#define BIT_SSP_TINT				( BIT(3) )
+#define BIT_SSP_PINT				( BIT(2) )
+#define BIT_SSP_CSS				( BIT(1) )
+#define BIT_SSP_BSY				( BIT(0) )
+
+/* bits definitions for register REG_SSP0_SSP_PSP_CTRL */
+#define BITS_SSP_EDMYSTOP(_X_)			( (_X_) << 27 & (BIT(27)|BIT(28)|BIT(29)) )
+#define BITS_SSP_DMYSTOP(_X_)			( (_X_) << 25 & (BIT(25)|BIT(26)) )
+#define BITS_SSP_EDMYSTRT(_X_)			( (_X_) << 23 & (BIT(23)|BIT(24)) )
+#define BITS_SSP_DMYSTRT(_X_)			( (_X_) << 21 & (BIT(21)|BIT(22)) )
+#define BITS_SSP_STRTDLY(_X_)			( (_X_) << 18 & (BIT(18)|BIT(19)|BIT(20)) )
+#define BITS_SSP_SFRMWDTH(_X_)			( (_X_) << 12 & (BIT(12)|BIT(13)|BIT(14)|BIT(15)|BIT(16)|BIT(17)) )
+#define SSP_SSPSP_SFRMWDTH_BASE			12
+#define SSP_SSPSP_SFRMWDTH_MSK			(BIT(12)|BIT(13)|BIT(14)|BIT(15)|BIT(16)|BIT(17))
+
+#define BITS_SSP_SFRMDLY(_X_)			( (_X_) << 5 & (BIT(5)|BIT(6)|BIT(7)|BIT(8)|BIT(9)|BIT(10)|BIT(11)) )
+#define BIT_SSP_SFRMP				( BIT(4) )
+#define BIT_SSP_FSRT				( BIT(3) )
+#define BIT_SSP_ETDS				( BIT(2) )
+#define BITS_SSP_SCMODE(_X_)			( (_X_) & (BIT(0)|BIT(1)) )
+
+/* bits definitions for register REG_SSP0_SSP_NET_WORK_CTRL */
+#define BITS_SSP_RTSA(_X_)			( (_X_) << 12 & (BIT(12)|BIT(13)|BIT(14)|BIT(15)|BIT(16)|BIT(17)|BIT(18)|BIT(19)) )
+#define BITS_SSP_TTSA(_X_)			( (_X_) << 4 & (BIT(4)|BIT(5)|BIT(6)|BIT(7)|BIT(8)|BIT(9)|BIT(10)|BIT(11)) )
+#define BITS_SSP_FRDC(_X_)			( (_X_) << 1 & (BIT(1)|BIT(2)|BIT(3)) )
+#define BIT_SSP_NET_WORK_MOD			( BIT(0) )
+
+/* bits definitions for register REG_SSP0_SSP_NET_WORK_STATUS */
+#define BIT_SSP_NMBSY				( BIT(3) )
+#define BITS_SSP_TSS(_X_)			( (_X_) & (BIT(0)|BIT(1)|BIT(2)) )
+
+/* bits definitions for register REG_SSP0_SSP_RWOT_CTRL */
+#define BIT_SSP_MASK_RWOT_LAST_SAMPLE		( BIT(4) )
+#define BIT_SSP_CLR_RWOT_CYCLE			( BIT(3) )
+#define BIT_SSP_SET_RWOT_CYCLE			( BIT(2) )
+#define BIT_SSP_CYCLE_RWOT_EN			( BIT(1) )
+#define BIT_SSP_RWOT				( BIT(0) )
+
+/* bits definitions for register REG_SSP0_SSP_RWOT_CCM */
+#define BITS_SSP_SSPRWOTCCM(_X_)		(_X_)
+
+/* bits definitions for register REG_SSP0_SSP_RWOT_CVWRn */
+#define BITS_SSP_SSPRWOTCVWR(_X_)		(_X_)
+
+#endif /* _K1X_SPI_H */
diff --git a/drivers/sysreset/Kconfig b/drivers/sysreset/Kconfig
index 1eb6ee6d..03f7fdd5 100644
--- a/drivers/sysreset/Kconfig
+++ b/drivers/sysreset/Kconfig
@@ -193,11 +193,6 @@ config SYSRESET_MPC83XX
 	help
 	  Reboot support for NXP MPC83xx SoCs.
 
-config SYSRESET_SPACEMIT
-	bool "Enable support spacemit SoC family reboot driver"
-	help
-	  Reboot support for spacemit SoCs.
-
 endif
 
 endmenu
diff --git a/drivers/sysreset/Makefile b/drivers/sysreset/Makefile
index 934e428b..0ed3bbf3 100644
--- a/drivers/sysreset/Makefile
+++ b/drivers/sysreset/Makefile
@@ -23,4 +23,3 @@ obj-$(CONFIG_SYSRESET_RESETCTL) += sysreset_resetctl.o
 obj-$(CONFIG_SYSRESET_$(SPL_TPL_)AT91) += sysreset_at91.o
 obj-$(CONFIG_$(SPL_TPL_)SYSRESET_X86) += sysreset_x86.o
 obj-$(CONFIG_TARGET_XTFPGA) += sysreset_xtfpga.o
-obj-$(CONFIG_SYSRESET_SPACEMIT) += sysreset_spacemit.o
diff --git a/drivers/sysreset/sysreset_spacemit.c b/drivers/sysreset/sysreset_spacemit.c
deleted file mode 100644
index 01366b83..00000000
--- a/drivers/sysreset/sysreset_spacemit.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (C) 2023, Spacemit
- */
-
-#include <common.h>
-#include <dm.h>
-#include <errno.h>
-#include <sysreset.h>
-#include <asm/io.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
-#include <power/pmic.h>
-
-struct pmic_sysreset_data {
-	u32 reboot_reg;
-	u32 reboot_mask;
-	int type;
-};
-
-static int pmic_sysreboot_types(const char *compat) {
-	if (!strcmp(compat, "spacemit,spm8821-reset"))
-		return 1;
-	return 0;
-}
-
-static int pmic_sysreset_request(struct udevice *dev, enum sysreset_t type)
-{
-	struct pmic_sysreset_data *data = dev_get_priv(dev);
-	struct udevice *pmic_dev;
-	int ret, value;
-
-	ret = uclass_get_device(UCLASS_PMIC, 0, &pmic_dev);
-	if (ret) {
-		pr_err("Failed to find PMIC device\n");
-		return ret;
-	}
-
-	switch (data->type) {
-		case 1:
-			value = pmic_reg_read(pmic_dev, data->reboot_reg);
-			if (ret) {
-				pr_err("Failed to read reboot register for spm8821: %d\n", ret);
-				return ret;
-			}
-			value |= data->reboot_mask;
-			ret = pmic_reg_write(pmic_dev, data->reboot_reg, value);
-			if (ret) {
-				pr_err("Failed to write reboot register for spm8821: %d\n", ret);
-				return ret;
-			}
-			break;
-		default:
-			pr_err("Unsupported PMIC type for sysreset\n");
-			return -ENOSYS;
-	}
-
-	mdelay(100);
-	return -EINPROGRESS;
-}
-
-static int pmic_sysreset_probe(struct udevice *dev)
-{
-	struct pmic_sysreset_data *data = dev_get_priv(dev);
-	const char *compat = dev_read_string(dev, "compatible");
-
-	data->reboot_reg = dev_read_u32_default(dev, "reboot-reg", 0);
-	data->reboot_mask = dev_read_u32_default(dev, "reboot-mask", 0);
-	data->type = pmic_sysreboot_types(compat);
-
-	return 0;
-}
-
-static struct sysreset_ops pmic_sysreset_ops = {
-	.request = pmic_sysreset_request,
-};
-
-U_BOOT_DRIVER(pmic_sysreset) = {
-	.name   = "pmic_sysreset",
-	.id     = UCLASS_SYSRESET,
-	.priv_auto = sizeof(struct pmic_sysreset_data),
-	.ops    = &pmic_sysreset_ops,
-	.probe  = pmic_sysreset_probe,
-};
diff --git a/drivers/sysreset/sysreset_watchdog.c b/drivers/sysreset/sysreset_watchdog.c
index 8a659ee9..761d7ced 100644
--- a/drivers/sysreset/sysreset_watchdog.c
+++ b/drivers/sysreset/sysreset_watchdog.c
@@ -43,8 +43,7 @@ static int wdt_reboot_of_to_plat(struct udevice *dev)
 	struct wdt_reboot_plat *plat = dev_get_plat(dev);
 	int err;
 
-	err = uclass_get_device_by_phandle(UCLASS_WDT, dev,
-					   "wdt", &plat->wdt);
+	err = uclass_get_device(UCLASS_WDT, 0, &plat->wdt);
 	if (err) {
 		pr_err("unable to find wdt device\n");
 		return err;
diff --git a/drivers/video/spacemit/Kconfig b/drivers/video/spacemit/Kconfig
index 5e2ba84e..db16c567 100644
--- a/drivers/video/spacemit/Kconfig
+++ b/drivers/video/spacemit/Kconfig
@@ -43,4 +43,11 @@ config DISPLAY_SPACEMIT_MIPI
 	  This enables Mobile Industry Processor Interface(MIPI) display
 	  support.
 
+config DISPLAY_SPACEMIT_EDP
+	bool "EDP Port"
+	depends on DISPLAY_SPACEMIT_MIPI
+	help
+	  This enables Mobile Industry Processor Interface(EDP) display
+	  support.
+
 endif
diff --git a/drivers/video/spacemit/Makefile b/drivers/video/spacemit/Makefile
index c5849bdd..e60af710 100644
--- a/drivers/video/spacemit/Makefile
+++ b/drivers/video/spacemit/Makefile
@@ -3,7 +3,8 @@
 ifdef CONFIG_VIDEO_SPACEMIT
 obj-y += dsi/
 obj-y += spacemit_dpu.o
-obj-$(CONFIG_DISPLAY_SPACEMIT_MIPI) += spacemit_mipi.o
 obj-$(CONFIG_DISPLAY_SPACEMIT_HDMI) += spacemit_hdmi.o
+obj-$(CONFIG_DISPLAY_SPACEMIT_MIPI) += spacemit_mipi.o
+obj-$(CONFIG_DISPLAY_SPACEMIT_EDP) += spacemit_edp.o
 
 endif
diff --git a/drivers/video/spacemit/dsi/Makefile b/drivers/video/spacemit/dsi/Makefile
index 00d52e3a..8f067fd3 100644
--- a/drivers/video/spacemit/dsi/Makefile
+++ b/drivers/video/spacemit/dsi/Makefile
@@ -8,4 +8,5 @@ obj-y += video/spacemit_video_tx.o \
 
 obj-y += video/lcd/lcd_icnl9911c.o
 obj-y += video/lcd/lcd_gx09inx101.o
+obj-y += video/lcd/lcd_lt8911ext_edp_1080p.o
 
diff --git a/drivers/video/spacemit/dsi/drv/spacemit_dphy.c b/drivers/video/spacemit/dsi/drv/spacemit_dphy.c
index 887627d6..1e9cbe9a 100644
--- a/drivers/video/spacemit/dsi/drv/spacemit_dphy.c
+++ b/drivers/video/spacemit/dsi/drv/spacemit_dphy.c
@@ -59,9 +59,9 @@ static void dphy_set_bit_clk_src(uint32_t bit_clk_src,
 
 static void dphy_set_timing(struct spacemit_dphy_ctx *dphy_ctx)
 {
-    uint32_t bitclk;
-	int ui, wakeup;
-	int hs_prep, hs_zero, hs_trail, hs_exit, ck_zero, ck_trail;
+	uint32_t bit_clk, lpx_clk, lpx_time, ta_get, ta_go;
+	int ui, wakeup, reg;
+	int hs_prep, hs_zero, hs_trail, hs_exit, ck_zero, ck_trail, ck_exit;
 	int esc_clk, esc_clk_t;
 	struct spacemit_dphy_timing *phy_timing;
 
@@ -75,10 +75,18 @@ static void dphy_set_timing(struct spacemit_dphy_ctx *dphy_ctx)
 	esc_clk = dphy_ctx->esc_clk/1000;
 	esc_clk_t = 1000/esc_clk;
 
-	bitclk = dphy_ctx->phy_freq / 1000;
-	ui = 1000/bitclk + 1;
+	bit_clk = dphy_ctx->phy_freq / 1000;
+	ui = 1000/bit_clk + 1;
+
+	pr_info("%s: esc_clk %d bit_clk %d\n", __func__, esc_clk, bit_clk);
+
+	lpx_clk = (phy_timing->lpx_constant + phy_timing->lpx_ui * ui) / esc_clk_t + 1;
+	lpx_time = lpx_clk * esc_clk_t;
+
+	/* Below is for NT35451 */
+	ta_get = lpx_time * 5 / esc_clk_t - 1;
+	ta_go = lpx_time * 4 / esc_clk_t - 1;
 
-	/*Jessica: Why no wakeup_ui?*/
 	wakeup = phy_timing->wakeup_constant;
 	wakeup = wakeup / esc_clk_t + 1;
 
@@ -112,17 +120,40 @@ static void dphy_set_timing(struct spacemit_dphy_ctx *dphy_ctx)
 	ck_trail = phy_timing->ck_trail_constant + phy_timing->ck_trail_ui * ui;
 	ck_trail = ck_trail / esc_clk_t + 1;
 
-	//dsi_write(DSI_PHY_TIME_0, reg);
-	dsi_write(DSI_PHY_TIME_0, 0x06010603);
+	ck_exit = hs_exit;
+
+	reg = (hs_exit << CFG_DPHY_TIME_HS_EXIT_SHIFT)
+		| (hs_trail << CFG_DPHY_TIME_HS_TRAIL_SHIFT)
+		| (hs_zero << CFG_DPHY_TIME_HS_ZERO_SHIFT)
+		| (hs_prep << CFG_DPHY_TIME_HS_PREP_SHIFT);
+
+	pr_debug("%s dphy time0 hs_exit %d hs_trail %d hs_zero %d hs_prep %d reg 0x%x\n", __func__, hs_exit, hs_trail, hs_zero, hs_prep, reg);
+	dsi_write(DSI_PHY_TIME_0, reg);
+	// dsi_write(DSI_PHY_TIME_0, 0x06010603);
+
+	reg = (ta_get << CFG_DPHY_TIME_TA_GET_SHIFT)
+		| (ta_go << CFG_DPHY_TIME_TA_GO_SHIFT)
+		| (wakeup << CFG_DPHY_TIME_WAKEUP_SHIFT);
+
+	pr_debug("%s dphy time1 ta_get %d ta_go %d wakeup %d reg 0x%x\n", __func__, ta_get, ta_go, wakeup, reg);
+	dsi_write(DSI_PHY_TIME_1, reg);
+	// dsi_write(DSI_PHY_TIME_1, 0x130fcd98);
+
+	reg = (ck_exit << CFG_DPHY_TIME_CLK_EXIT_SHIFT)
+		| (ck_trail << CFG_DPHY_TIME_CLK_TRAIL_SHIFT)
+		| (ck_zero << CFG_DPHY_TIME_CLK_ZERO_SHIFT)
+		| (lpx_clk << CFG_DPHY_TIME_CLK_LPX_SHIFT);
 
-	//dsi_write(DSI_PHY_TIME_1, reg);
-	dsi_write(DSI_PHY_TIME_1, 0x130fcd98);
+	pr_debug("%s dphy time2 ck_exit %d ck_trail %d ck_zero %d lpx_clk %d reg 0x%x\n", __func__, ck_exit, ck_trail, ck_zero, lpx_clk, reg);
+	dsi_write(DSI_PHY_TIME_2, reg);
+	// dsi_write(DSI_PHY_TIME_2, 0x06040c04);
 
-	//dsi_write(DSI_PHY_TIME_2, reg);
-	dsi_write(DSI_PHY_TIME_2, 0x06040c04);
+	reg = (lpx_clk << CFG_DPHY_TIME_LPX_SHIFT)
+		| phy_timing->req_ready << CFG_DPHY_TIME_REQRDY_SHIFT;
 
-	//dsi_write(DSI_PHY_TIME_3, reg);
-	dsi_write(DSI_PHY_TIME_3, 0x43c);
+	pr_debug("%s dphy time3 lpx_clk %d req_ready %d reg 0x%x\n", __func__, lpx_clk, phy_timing->req_ready, reg);
+	dsi_write(DSI_PHY_TIME_3, reg);
+	// dsi_write(DSI_PHY_TIME_3, 0x43c);
 
 	/* calculated timing on brownstone:
 	 * DSI_PHY_TIME_0 0x06080204
diff --git a/drivers/video/spacemit/dsi/drv/spacemit_dsi_drv.c b/drivers/video/spacemit/dsi/drv/spacemit_dsi_drv.c
index affbbc18..35f0b157 100644
--- a/drivers/video/spacemit/dsi/drv/spacemit_dsi_drv.c
+++ b/drivers/video/spacemit/dsi/drv/spacemit_dsi_drv.c
@@ -15,7 +15,9 @@
 #define SPACEMIT_DSI_NAME "spacemit_dsi"
 #define SPACEMIT_DSI_VERSION	"1.0.0"
 
-#define SPACEMIT_ESC_CLK_DEFAULT 52000000
+#define SPACEMIT_ESC_CLK_DEFAULT	51200000
+#define SPACEMIT_BIT_CLK_DEFAULT	614400000
+
 #define MIPI_CLK_MIN 800000000
 
 #define SPACEMIT_DSI_MAX_TX_FIFO_BYTES	256
@@ -777,6 +779,9 @@ int spacemit_dsi_open(struct spacemit_dsi_device* device_ctx, struct spacemit_mi
 		return -1;
 	}
 
+	device_ctx->bit_clk_rate = mipi_info->phy_bit_clock;
+	device_ctx->esc_clk_rate = mipi_info->phy_esc_clock;
+
 	if(mipi_info->split_enable)
 		lane_number = mipi_info->lane_number >> 1;
 	else
@@ -882,6 +887,7 @@ int spacemit_dsi_probe(void)
 	spacemit_dsi_dev.id = 0;
 
 	spacemit_dsi_dev.esc_clk_rate = SPACEMIT_ESC_CLK_DEFAULT;
+	spacemit_dsi_dev.bit_clk_rate = SPACEMIT_BIT_CLK_DEFAULT;
 
 	ret = spacemit_dsi_register_device(&spacemit_dsi_dev);
 	if(ret != 0){
diff --git a/drivers/video/spacemit/dsi/include/spacemit_dsi_common.h b/drivers/video/spacemit/dsi/include/spacemit_dsi_common.h
index 1ec3a5d6..56075c3e 100644
--- a/drivers/video/spacemit/dsi/include/spacemit_dsi_common.h
+++ b/drivers/video/spacemit/dsi/include/spacemit_dsi_common.h
@@ -90,7 +90,9 @@ struct spacemit_mipi_info {
 	unsigned int work_mode; /*command_mode, video_mode*/
 	unsigned int rgb_mode;
 	unsigned int lane_number;
-	unsigned int phy_freq;
+	unsigned int phy_bit_clock;
+	unsigned int phy_esc_clock;
+
 	unsigned int split_enable;
 	unsigned int eotp_enable;
 
@@ -138,5 +140,6 @@ int lcd_mipi_probe(void);
 
 int lcd_icnl9911c_init(void);
 int lcd_gx09inx101_init(void);
+int lcd_lt8911ext_edp_1080p_init(void);
 
 #endif /*_SPACEMIT_DSI_COMMON_H_*/
diff --git a/drivers/video/spacemit/dsi/include/spacemit_video_tx.h b/drivers/video/spacemit/dsi/include/spacemit_video_tx.h
index 05e60589..32bc2bbf 100644
--- a/drivers/video/spacemit/dsi/include/spacemit_video_tx.h
+++ b/drivers/video/spacemit/dsi/include/spacemit_video_tx.h
@@ -26,6 +26,8 @@ enum {
 enum panel_type {
 	LCD_MIPI = 0,
 	LCD_HDMI = 1,
+	LCD_EDP = 2,
+	LCD_DP = 3,
 	LCD_NULL
 };
 
@@ -144,6 +146,7 @@ struct lcd_mipi_tx_data {
 };
 
 struct spacemit_panel_priv {
+	char panel_name[128];
 	struct gpio_desc ldo_1v2_gpio;
 	unsigned int ldo_1v8;
 	unsigned int ldo_2v8;
@@ -155,7 +158,11 @@ struct spacemit_panel_priv {
 	struct gpio_desc bl;
 	struct gpio_desc enable;
 	struct gpio_desc reset;
-
+	bool dcp_valid;
+	bool dcn_valid;
+	bool bl_valid;
+	bool enable_valid;
+	bool reset_valid;
 };
 extern int lcd_id;
 extern int lcd_width;
@@ -168,6 +175,7 @@ int video_tx_get_modes(struct video_tx_device *video_tx,
 		       struct spacemit_mode_modeinfo *modelist);
 int video_tx_dpms(struct video_tx_device *video_tx, int mode);
 void video_tx_esd_check(struct video_tx_device *video_tx);
+void video_tx_reset(struct video_tx_device *video_tx);
 
 /* Client functions */
 int video_tx_register_device(struct video_tx_device *tx_device);
diff --git a/drivers/video/spacemit/dsi/video/lcd/lcd_gx09inx101.c b/drivers/video/spacemit/dsi/video/lcd/lcd_gx09inx101.c
index b73206ec..0aceda40 100644
--- a/drivers/video/spacemit/dsi/video/lcd/lcd_gx09inx101.c
+++ b/drivers/video/spacemit/dsi/video/lcd/lcd_gx09inx101.c
@@ -38,10 +38,10 @@ struct spacemit_mode_modeinfo gx09inx101_spacemit_modelist[] = {
 struct spacemit_mipi_info gx09inx101_mipi_info = {
 	.height = 1920,
 	.width = 1200,
-	.hfp = 80,/* unit: pixel */
+	.hfp = 80, /* unit: pixel */
 	.hbp = 40,
 	.hsync = 10,
-	.vfp = 20, /*unit: line*/
+	.vfp = 20, /* unit: line */
 	.vbp = 16,
 	.vsync = 4,
 	.fps = 60,
@@ -49,7 +49,8 @@ struct spacemit_mipi_info gx09inx101_mipi_info = {
 	.work_mode = SPACEMIT_DSI_MODE_VIDEO, /*command_mode, video_mode*/
 	.rgb_mode = DSI_INPUT_DATA_RGB_MODE_888,
 	.lane_number = 4,
-	.phy_freq = 624*1000,
+	.phy_bit_clock = 614400000,
+	.phy_esc_clock = 51200000,
 	.split_enable = 0,
 	.eotp_enable = 0,
 
diff --git a/drivers/video/spacemit/dsi/video/lcd/lcd_icnl9911c.c b/drivers/video/spacemit/dsi/video/lcd/lcd_icnl9911c.c
index d6e0bc5a..a678d01d 100644
--- a/drivers/video/spacemit/dsi/video/lcd/lcd_icnl9911c.c
+++ b/drivers/video/spacemit/dsi/video/lcd/lcd_icnl9911c.c
@@ -49,7 +49,8 @@ struct spacemit_mipi_info icnl9911c_mipi_info = {
 	.work_mode = SPACEMIT_DSI_MODE_VIDEO, /*command_mode, video_mode*/
 	.rgb_mode = DSI_INPUT_DATA_RGB_MODE_888,
 	.lane_number = 4,
-	.phy_freq = 624*1000,
+	.phy_bit_clock = 614400000,
+	.phy_esc_clock = 51200000,
 	.split_enable = 0,
 	.eotp_enable = 0,
 
diff --git a/drivers/video/spacemit/dsi/video/lcd/lcd_lt8911ext_edp_1080p.c b/drivers/video/spacemit/dsi/video/lcd/lcd_lt8911ext_edp_1080p.c
new file mode 100644
index 00000000..51b59bc7
--- /dev/null
+++ b/drivers/video/spacemit/dsi/video/lcd/lcd_lt8911ext_edp_1080p.c
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 Spacemit Co., Ltd.
+ *
+ */
+
+#include <linux/kernel.h>
+#include "../../include/spacemit_dsi_common.h"
+#include "../../include/spacemit_video_tx.h"
+#include <linux/delay.h>
+
+#define UNLOCK_DELAY 0
+
+struct spacemit_mode_modeinfo lt8911ext_edp_1080p_spacemit_modelist[] = {
+	{
+		.name = "1920x1080-60",
+		.refresh = 60,
+		.xres = 1920,
+		.yres = 1080,
+		.real_xres = 1920,
+		.real_yres = 1080,
+		.left_margin = 200,
+		.right_margin = 48,
+		.hsync_len = 32,
+		.upper_margin = 31,
+		.lower_margin = 3,
+		.vsync_len = 6,
+		.hsync_invert = 0,
+		.vsync_invert = 0,
+		.invert_pixclock = 0,
+		.pixclock_freq = 148*1000,
+		.pix_fmt_out = OUTFMT_RGB888,
+		.width = 309,
+		.height = 174,
+	},
+};
+
+struct spacemit_mipi_info lt8911ext_edp_1080p_mipi_info = {
+	.height = 1080,
+	.width = 1920,
+	.hfp = 48, /* unit: pixel */
+	.hbp = 200,
+	.hsync = 32,
+	.vfp = 3, /* unit: line */
+	.vbp = 31,
+	.vsync = 6,
+	.fps = 60,
+
+	.work_mode = SPACEMIT_DSI_MODE_VIDEO, /*command_mode, video_mode*/
+	.rgb_mode = DSI_INPUT_DATA_RGB_MODE_888,
+	.lane_number = 4,
+	.phy_bit_clock = 933000000,
+	.phy_esc_clock = 51200000,
+	.split_enable = 0,
+	.eotp_enable = 1,
+
+	.burst_mode = DSI_BURST_MODE_BURST,
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_set_id_cmds[] = {
+
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_read_id_cmds[] = {
+
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_set_power_cmds[] = {
+
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_read_power_cmds[] = {
+
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_init_cmds[] = {
+	{SPACEMIT_DSI_DCS_LWRITE, SPACEMIT_DSI_LP_MODE, 200, 2, {0x11, 0x00}},
+	{SPACEMIT_DSI_DCS_LWRITE, SPACEMIT_DSI_LP_MODE,  50, 2, {0x29, 0x00}},
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_sleep_out_cmds[] = {
+	{SPACEMIT_DSI_DCS_SWRITE,SPACEMIT_DSI_LP_MODE,200,1,{0x11}},
+	{SPACEMIT_DSI_DCS_SWRITE,SPACEMIT_DSI_LP_MODE,50,1,{0x29}},
+};
+
+static struct spacemit_dsi_cmd_desc lt8911ext_edp_1080p_sleep_in_cmds[] = {
+	{SPACEMIT_DSI_DCS_SWRITE,SPACEMIT_DSI_LP_MODE,50,1,{0x28}},
+	{SPACEMIT_DSI_DCS_SWRITE,SPACEMIT_DSI_LP_MODE,200,1,{0x10}},
+};
+
+
+struct lcd_mipi_panel_info lcd_lt8911ext_edp_1080p = {
+	.lcd_name = "lt8911ext_edp_1080p",
+	.lcd_id = 0x00,
+	.panel_id0 = 0x00,
+	.power_value = 0x00,
+	.panel_type = LCD_EDP,
+	.width_mm = 309,
+	.height_mm = 174,
+	.dft_pwm_bl = 128,
+	.set_id_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_set_id_cmds),
+	.read_id_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_read_id_cmds),
+	.init_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_init_cmds),
+	.set_power_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_set_power_cmds),
+	.read_power_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_read_power_cmds),
+	.sleep_out_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_sleep_out_cmds),
+	.sleep_in_cmds_num = ARRAY_SIZE(lt8911ext_edp_1080p_sleep_in_cmds),
+	//.drm_modeinfo = lt8911ext_edp_1080p_modelist,
+	.spacemit_modeinfo = lt8911ext_edp_1080p_spacemit_modelist,
+	.mipi_info = &lt8911ext_edp_1080p_mipi_info,
+	.set_id_cmds = lt8911ext_edp_1080p_set_id_cmds,
+	.read_id_cmds = lt8911ext_edp_1080p_read_id_cmds,
+	.set_power_cmds = lt8911ext_edp_1080p_set_power_cmds,
+	.read_power_cmds = lt8911ext_edp_1080p_read_power_cmds,
+	.init_cmds = lt8911ext_edp_1080p_init_cmds,
+	.sleep_out_cmds = lt8911ext_edp_1080p_sleep_out_cmds,
+	.sleep_in_cmds = lt8911ext_edp_1080p_sleep_in_cmds,
+	.bitclk_sel = 3,
+	.bitclk_div = 1,
+	.pxclk_sel = 2,
+	.pxclk_div = 6,
+};
+
+int lcd_lt8911ext_edp_1080p_init(void)
+{
+	int ret;
+
+	ret = lcd_mipi_register_panel(&lcd_lt8911ext_edp_1080p);
+	return ret;
+}
diff --git a/drivers/video/spacemit/dsi/video/spacemit_mipi_port.c b/drivers/video/spacemit/dsi/video/spacemit_mipi_port.c
index 8455671d..1463501b 100644
--- a/drivers/video/spacemit/dsi/video/spacemit_mipi_port.c
+++ b/drivers/video/spacemit/dsi/video/spacemit_mipi_port.c
@@ -28,21 +28,6 @@ int lcd_width = 0;
 int lcd_height = 0;
 char *lcd_name = NULL;
 
-//extern unsigned int board_id;
-
-
-static int set_bit_value(int value, int low_bit, int high_bit, int bits_val)
-{
-	int mask;
-
-	mask = (1 << (high_bit - low_bit + 1)) - 1;
-	mask = mask << low_bit;
-	value &= ~mask;
-	value |= (bits_val << low_bit);
-
-	return value;
-}
-
 static bool __maybe_unused lcd_mipi_readid(struct lcd_mipi_tx_data *video_tx_client)
 {
 	struct spacemit_dsi_rx_buf dbuf;
@@ -77,12 +62,14 @@ static bool __maybe_unused lcd_mipi_readid(struct lcd_mipi_tx_data *video_tx_cli
 static int lcd_mipi_reset(struct spacemit_panel_priv *priv)
 {
 	/* reset lcm */
-	dm_gpio_set_value(&priv->reset, 1);
-	mdelay(10);
-	dm_gpio_set_value(&priv->reset, 0);
-	mdelay(10);
-	dm_gpio_set_value(&priv->reset, 1);
-	mdelay(120);
+	if (priv->reset_valid) {
+		dm_gpio_set_value(&priv->reset, 1);
+		mdelay(10);
+		dm_gpio_set_value(&priv->reset, 0);
+		mdelay(10);
+		dm_gpio_set_value(&priv->reset, 1);
+		mdelay(120);
+	}
 
 	return 0;
 }
@@ -90,11 +77,21 @@ static int lcd_mipi_reset(struct spacemit_panel_priv *priv)
 static int lcd_mipi_dc_enable(bool power_on, struct spacemit_panel_priv *priv)
 {
 	if(power_on){
-		dm_gpio_set_value(&priv->dcp, 1);
-		dm_gpio_set_value(&priv->dcn, 1);
+		if (priv->enable_valid)
+			dm_gpio_set_value(&priv->enable, 1);
+
+		if (priv->dcp_valid)
+			dm_gpio_set_value(&priv->dcp, 1);
+		if (priv->dcn_valid)
+			dm_gpio_set_value(&priv->dcn, 1);
 	} else {
-		dm_gpio_set_value(&priv->dcp, 0);
-		dm_gpio_set_value(&priv->dcn, 0);
+		if (priv->enable_valid)
+			dm_gpio_set_value(&priv->enable, 0);
+
+		if (priv->dcp_valid)
+			dm_gpio_set_value(&priv->dcp, 0);
+		if (priv->dcn_valid)
+			dm_gpio_set_value(&priv->dcn, 0);
 	}
 
 	return 0;
@@ -155,16 +152,19 @@ static int lcd_mipi_panel_reset(struct video_tx_device *dev)
 		return -1;
 	}
 
-	ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->init_cmds,
-			video_tx_client->panel_info->init_cmds_num);
-	if(ret) {
-		pr_info("send init cmd fail!\n ");
-	}
-	ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->sleep_out_cmds,
-			video_tx_client->panel_info->sleep_out_cmds_num);
-	if(ret) {
-		pr_info("send sleep out fail!\n ");
+	if (video_tx_client->panel_info->panel_type == LCD_MIPI) {
+		ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->init_cmds,
+				video_tx_client->panel_info->init_cmds_num);
+		if(ret) {
+			pr_info("send init cmd fail!\n ");
+		}
+		ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->sleep_out_cmds,
+				video_tx_client->panel_info->sleep_out_cmds_num);
+		if(ret) {
+			pr_info("send sleep out fail!\n ");
+		}
 	}
+
 	ret = spacemit_mipi_ready_for_datatx(0, video_tx_client->panel_info->mipi_info);
 	if (0 != ret) {
 		pr_info("lcd_mipi spacemit_mipi_ready_for_datatx fail!\n ");
@@ -174,74 +174,6 @@ static int lcd_mipi_panel_reset(struct video_tx_device *dev)
 	return 0;
 }
 
-void dpc_update_clocks(struct lcd_mipi_panel_info *panel_info)
-{
-	unsigned int value = 0;
-	unsigned int freq_sel = 0;
-	unsigned int freq_div = 0;
-	unsigned int timeout = 50;
-
-	/* bitclk */
-
-	freq_sel = panel_info->bitclk_sel;
-	freq_div = panel_info->bitclk_div;
-	value = readl((void *)(uintptr_t)0xd4282844);
-	value = set_bit_value(value, 20, 21, freq_sel);
-	value = set_bit_value(value, 17, 19, freq_div);
-	writel(value, (void *)(uintptr_t)0xd4282844);
-	value |= BIT(31);
-	writel(value, (void *)(uintptr_t)0xd4282844);
-
-	/* wait freq change successful */
-	while (true) {
-		value = readl((void *)(uintptr_t)0xd4282844);
-
-		if ((value & BIT(31)) == 0)
-			break;
-
-		if (timeout == 0) {
-			pr_info("failed to change dpu bitclk frequency\n");
-			break;
-		}
-
-		timeout--;
-
-		udelay(10);
-	}
-
-	/* pxclk */
-	timeout = 50;
-	freq_sel = panel_info->pxclk_sel;
-	freq_div = panel_info->pxclk_div;
-	value = readl((void *)(uintptr_t)0xd428284c);
-	value = set_bit_value(value, 21, 23, freq_sel);
-	value = set_bit_value(value, 17, 20, freq_div);
-	writel(value, (void *)(uintptr_t)0xd428284c);
-
-	value = readl((void *)(uintptr_t)0xd4282844);
-	value |= BIT(30);
-	writel(value,(void *)(uintptr_t) 0xd4282844);
-
-	/* wait freq change successful */
-	while (true) {
-		value = readl((void *)(uintptr_t)0xd4282844);
-
-		if ((value & BIT(30)) == 0)
-			break;
-
-		if (timeout == 0) {
-			pr_info("failed to change dpu pxclk frequency\n");
-			break;
-		}
-
-		timeout--;
-
-		udelay(10);
-	}
-
-	pr_debug("dpu clk1 = 0x%x\n", readl((void *)(uintptr_t)0xd4282844));
-	pr_debug("dpu clk2 = 0x%x\n", readl((void *)(uintptr_t)0xd428284c));
-}
 static int lcd_mipi_identify(struct video_tx_device *dev)
 {
 	struct lcd_mipi_tx_data  *video_tx_client =
@@ -249,7 +181,7 @@ static int lcd_mipi_identify(struct video_tx_device *dev)
 	struct lcd_mipi_panel_info *panel_info = NULL;
 	bool is_panel = false;
 	int ret = 0;
-	int i, num;
+	int i;
 
 	ret = lcd_mipi_dc_enable(true, video_tx_client->priv);
 	if (ret) {
@@ -261,13 +193,15 @@ static int lcd_mipi_identify(struct video_tx_device *dev)
 		if(!panel_info)
 			continue;
 
-		dpc_update_clocks(panel_info);
-
-		pr_debug("now check lcd (%s)\n",panel_info->lcd_name);
+		pr_debug("identify lcd (%s)\n",panel_info->lcd_name);
 
 		video_tx_client->panel_info = panel_info;
 
-		for (num = 0; num < 1; num++) {
+		if (panel_info->panel_type == LCD_EDP) {
+
+			is_panel = true;
+		} else {
+
 			ret = lcd_mipi_reset(video_tx_client->priv);
 			if (ret) {
 				pr_info("lcd_mipi gpio reset failded!\n");
@@ -283,9 +217,6 @@ static int lcd_mipi_identify(struct video_tx_device *dev)
 			is_panel = lcd_mipi_readid(video_tx_client);
 
 			spacemit_mipi_close(0);
-
-			if (is_panel)
-				break;
 		}
 
 		if (!is_panel) {
@@ -319,8 +250,11 @@ static int lcd_mipi_init(struct video_tx_device *dev)
 		return -1;
 	}
 
-	ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->init_cmds,
-			video_tx_client->panel_info->init_cmds_num);
+	if (video_tx_client->panel_info->panel_type == LCD_MIPI) {
+
+		ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->init_cmds,
+				video_tx_client->panel_info->init_cmds_num);
+	}
 
 	return ret;
 }
@@ -345,8 +279,11 @@ static int lcd_mipi_sleep_out(struct video_tx_device *dev)
 		return -1;
 	}
 
-	ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->sleep_out_cmds,
-			video_tx_client->panel_info->sleep_out_cmds_num);
+	if (video_tx_client->panel_info->panel_type == LCD_MIPI) {
+
+		ret = spacemit_mipi_write_cmds(0, video_tx_client->panel_info->sleep_out_cmds,
+				video_tx_client->panel_info->sleep_out_cmds_num);
+	}
 
 	ret = spacemit_mipi_ready_for_datatx(0, video_tx_client->panel_info->mipi_info);
 	if(0 != ret) {
@@ -406,10 +343,13 @@ static int lcd_bl_enable(struct video_tx_device *dev, bool enable)
 				video_tx_get_drvdata(dev);
 	struct spacemit_panel_priv *priv = video_tx_client->priv;
 
-	if (enable)
-		dm_gpio_set_value(&priv->bl, 1);
-	else
-		dm_gpio_set_value(&priv->bl, 0);
+	if (priv->bl_valid) {
+
+		if (enable)
+			dm_gpio_set_value(&priv->bl, 1);
+		else
+			dm_gpio_set_value(&priv->bl, 0);
+	}
 
 	return 0;
 }
@@ -484,9 +424,14 @@ int lcd_mipi_probe(void)
 		return ret;
 	}
 
-	lcd_icnl9911c_init();
-	lcd_gx09inx101_init();
-
+	if (strcmp("lt8911ext_edp_1080p", priv->panel_name) == 0) {
+		tx_device_client.panel_type = LCD_EDP;
+		tx_device.panel_type = tx_device_client.panel_type;
+		lcd_lt8911ext_edp_1080p_init();
+	} else {
+		// lcd_icnl9911c_init();
+		lcd_gx09inx101_init();
+	}
 
 	return 0;
 }
@@ -500,34 +445,65 @@ static int spacemit_panel_of_to_plat(struct udevice *dev)
 {
 
 	struct spacemit_panel_priv *priv = dev_get_priv(dev);
+	const char *name;
 	int ret;
 
+	memset(priv, 0, sizeof(*priv));
+
+	name = dev_read_string(dev, "force-attached");
+	if (name) {
+		strcpy(priv->panel_name, name);
+		pr_info("spacemit_panel_of_to_plat panel %s \n", priv->panel_name);
+	}
+
 	ret = gpio_request_by_name(dev, "dcp-gpios", 0, &priv->dcp,
 				   GPIOD_IS_OUT);
 	if (ret) {
-		pr_info("%s: Warning: cannot get dcp GPIO: ret=%d\n",
+		pr_debug("%s: Warning: cannot get dcp GPIO: ret=%d\n",
 		      __func__, ret);
+		priv->dcp_valid = false;
+	} else {
+		priv->dcp_valid = true;
 	}
 
 	ret = gpio_request_by_name(dev, "dcn-gpios", 0, &priv->dcn,
 				   GPIOD_IS_OUT);
 	if (ret) {
-		pr_info("%s: Warning: cannot get dcn GPIO: ret=%d\n",
+		pr_debug("%s: Warning: cannot get dcn GPIO: ret=%d\n",
 		      __func__, ret);
+		priv->dcn_valid = false;
+	} else {
+		priv->dcn_valid = true;
 	}
 
 	ret = gpio_request_by_name(dev, "bl-gpios", 0, &priv->bl,
 				   GPIOD_IS_OUT);
 	if (ret) {
-		pr_info("%s: Warning: cannot get bl GPIO: ret=%d\n",
+		pr_debug("%s: Warning: cannot get bl GPIO: ret=%d\n",
 		      __func__, ret);
+		priv->bl_valid = false;
+	} else {
+		priv->bl_valid = true;
+	}
+
+	ret = gpio_request_by_name(dev, "enable-gpios", 0, &priv->enable,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		pr_debug("%s: Warning: cannot get enable GPIO: ret=%d\n",
+		      __func__, ret);
+		priv->enable_valid = false;
+	} else {
+		priv->enable_valid = true;
 	}
 
 	ret = gpio_request_by_name(dev, "reset-gpios", 0, &priv->reset,
 				   GPIOD_IS_OUT);
 	if (ret) {
-		pr_info("%s: Warning: cannot get reset GPIO: ret=%d\n",
+		pr_debug("%s: Warning: cannot get reset GPIO: ret=%d\n",
 		      __func__, ret);
+		priv->reset_valid = false;
+	} else {
+		priv->reset_valid = true;
 	}
 
 	return 0;
diff --git a/drivers/video/spacemit/dsi/video/spacemit_video_tx.c b/drivers/video/spacemit/dsi/video/spacemit_video_tx.c
index 3647eb6e..94e21c7c 100644
--- a/drivers/video/spacemit/dsi/video/spacemit_video_tx.c
+++ b/drivers/video/spacemit/dsi/video/spacemit_video_tx.c
@@ -89,6 +89,21 @@ void video_tx_esd_check(struct video_tx_device *video_tx)
 	}
 }
 
+void video_tx_reset(struct video_tx_device *video_tx)
+{
+	int ret;
+
+	if (!video_tx->driver->panel_reset) {
+		pr_info("reset() not implemented\n");
+		return;
+	}
+
+	ret = video_tx->driver->panel_reset(video_tx);
+	if(ret) {
+		pr_info("panel reset fail!\n");
+	}
+}
+
 
 /**
  * video_tx_register_device - register a video tx with the framework
@@ -115,7 +130,7 @@ int video_tx_register_device(struct video_tx_device *tx_device)
 	tx_devices[tx_device_num] = tx_device;
 	tx_device_num++;
 
-	pr_info("fb: video_tx (port %d) register device!\n", tx_device->panel_type);
+	pr_debug("fb: video_tx (panel_type %d) register device!\n", tx_device->panel_type);
 	return 0;
 }
 
diff --git a/drivers/video/spacemit/spacemit_dpu.c b/drivers/video/spacemit/spacemit_dpu.c
index 05477659..9544676e 100644
--- a/drivers/video/spacemit/spacemit_dpu.c
+++ b/drivers/video/spacemit/spacemit_dpu.c
@@ -178,6 +178,9 @@ static void dsi_dpu_init(struct spacemit_mode_modeinfo *spacemit_mode, ulong fbb
 	vsp = spacemit_mode->hsync_invert ? 0 : 1;
 	hsp = spacemit_mode->hsync_invert ? 0 : 1;
 
+	pr_debug("dsi_dpu_init hbp %d, hfp %d hsync %d vsp %d \n", hbp, hfp, hsync, vsp);
+	pr_debug("dsi_dpu_init vbp %d, vfp %d vsync %d hsp %d \n", vbp, vfp, vsync, hsp);
+
 	dsi_dpu_write((void __iomem *)0xa1c, 0x2223);
 	dsi_dpu_write((void __iomem *)0x18000, (spacemit_mode->yres << 16) | spacemit_mode->xres);
 	dsi_dpu_write((void __iomem *)0x18018, 0x20);
@@ -228,7 +231,7 @@ static int spacemit_display_init(struct udevice *dev, ulong fbbase, ofnode ep_no
 	ofnode remote;
 	const char *compat;
 	struct display_plat *disp_uc_plat;
-	// struct udevice *panel = NULL;
+	struct udevice *panel = NULL;
 
 	struct spacemit_mode_modeinfo *spacemit_mode = NULL;
 
@@ -353,10 +356,42 @@ static int spacemit_display_init(struct udevice *dev, ulong fbbase, ofnode ep_no
 		uc_priv->xsize = spacemit_mode->xres;
 		uc_priv->ysize = spacemit_mode->yres;
 
-		dsi_dpu_init(spacemit_mode, fbbase);
-		video_tx_esd_check(fbi.tx);
-		video_tx = fbi.tx;
-		video_tx->driver->bl_enable(video_tx, true);
+		pr_info("%s: panel type %d\n", __func__, fbi.tx->panel_type);
+
+		if (fbi.tx->panel_type == LCD_MIPI) {
+			dsi_dpu_init(spacemit_mode, fbbase);
+			video_tx_esd_check(fbi.tx);
+			video_tx = fbi.tx;
+			video_tx->driver->bl_enable(video_tx, true);
+
+		} else if (fbi.tx->panel_type == LCD_EDP){
+			dsi_dpu_init(spacemit_mode, fbbase);
+			video_tx_reset(fbi.tx);
+			video_tx = fbi.tx;
+
+			ret = uclass_first_device_err(UCLASS_PANEL, &panel);
+			if (ret) {
+				if (ret != -ENODEV)
+					pr_info("panel device error %d\n", ret);
+
+				return ret;
+			}
+
+			ret = panel_get_display_timing(panel, &timing);
+			if (ret) {
+				pr_info("%s: timing error: %d\n", __func__, ret);
+			}
+
+			ret = panel_enable_backlight(panel);
+			if (ret) {
+				pr_info("%s: backlight error: %d\n", __func__, ret);
+				return ret;
+			}
+
+			video_tx->driver->bl_enable(video_tx, true);
+		} else {
+			pr_info("%s: Failed to find panel\n", __func__);
+		}
 
 		pr_info("fb=%lx, size=%d %d\n", fbbase, uc_priv->xsize, uc_priv->ysize);
 
@@ -370,7 +405,7 @@ static int spacemit_dpu_probe(struct udevice *dev)
 {
 	struct video_uc_plat *plat = dev_get_uclass_plat(dev);
 	struct spacemit_dpu_priv *priv = dev_get_priv(dev);
-	struct udevice *udev;
+	// struct udevice *udev;
 	ofnode port, node;
 	int ret;
 
@@ -389,6 +424,7 @@ static int spacemit_dpu_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
+	/*
 	for (uclass_find_first_device(UCLASS_VIDEO, &udev);
 		udev;
 		uclass_find_next_device(&udev)) {
@@ -409,6 +445,14 @@ static int spacemit_dpu_probe(struct udevice *dev)
 		pr_info("%s:bridge device %s\n", __func__, udev->name);
 	}
 
+	for (uclass_find_first_device(UCLASS_PANEL, &udev);
+		udev;
+		uclass_find_next_device(&udev)) {
+
+		pr_info("%s:panel device %s\n", __func__, udev->name);
+	}
+	*/
+
 	for (node = ofnode_first_subnode(port);
 		ofnode_valid(node);
 		node = dev_read_next_subnode(node)) {
diff --git a/drivers/video/spacemit/spacemit_edp.c b/drivers/video/spacemit/spacemit_edp.c
new file mode 100644
index 00000000..b9b04f80
--- /dev/null
+++ b/drivers/video/spacemit/spacemit_edp.c
@@ -0,0 +1,1156 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 Spacemit Co., Ltd.
+ *
+ */
+
+#include <common.h>
+#include <backlight.h>
+#include <dm.h>
+#include <mipi_dsi.h>
+#include <panel.h>
+#include <asm/gpio.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+#include <power/regulator.h>
+#include <i2c.h>
+#include <asm/arch/gpio.h>
+#include <asm/io.h>
+
+
+// #define _Test_Pattern_
+// #define _uart_debug_
+// #define _read_edid_
+// #define _Msa_Active_Only_
+#define _eDP_2G7_
+// #define _eDP_1G62_
+#define _link_train_enable_
+
+struct edp_panel_priv {
+	struct udevice *reg;
+	struct udevice *backlight;
+
+	struct gpio_desc reset_gpio;
+	struct gpio_desc standby_gpio;
+
+	struct gpio_desc enable_gpio;
+	struct gpio_desc bl_gpio;
+};
+
+static const struct display_timing default_timing = {
+	.pixelclock.typ		= 142850000,
+	.hactive.typ		= 1920,
+	.hfront_porch.typ	= 48,
+	.hback_porch.typ	= 200,
+	.hsync_len.typ		= 32,
+	.vactive.typ		= 1080,
+	.vfront_porch.typ	= 3,
+	.vback_porch.typ	= 31,
+	.vsync_len.typ		= 6,
+};
+
+static int edp_panel_i2c_write(struct udevice *dev, uint addr, uint8_t data)
+{
+	uint8_t valb;
+	int err;
+	valb = data;
+
+	err = dm_i2c_write(dev, addr, &valb, 1);
+	return err;
+}
+
+static int edp_panel_i2c_read(struct udevice *dev, uint8_t addr, uint8_t *data)
+{
+	uint8_t valb;
+	int err;
+
+	err = dm_i2c_read(dev, addr, &valb, 1);
+	if (err)
+		return err;
+
+	*data = (int)valb;
+	return 0;
+}
+
+static u8 LT8911EXB_IIC_Read_byte(struct udevice *dev, u8 reg)
+{
+	uint8_t valb;
+	int err;
+
+	err = dm_i2c_read(dev, reg, &valb, 1);
+	if (err)
+		return err;
+	mdelay(10);
+
+	return (int)valb;
+
+}
+
+static void LT8911EXB_IIC_Write_byte(struct udevice *dev,u8 reg, u8 val)
+{
+	dm_i2c_write(dev, reg, &val, 1);
+	mdelay(10);
+}
+
+enum {
+	hfp = 0,
+	hs,
+	hbp,
+	hact,
+	htotal,
+	vfp,
+	vs,
+	vbp,
+	vact,
+	vtotal,
+	pclk_10khz
+};
+
+bool	ScrambleMode = 0;
+bool	flag_mipi_on = 0;
+
+#ifdef _read_edid_ // read eDP panel EDID
+
+u8		EDID_DATA[128] = { 0 };
+u16		EDID_Timing[11] = { 0 };
+
+bool	EDID_Reply = 0;
+#endif
+
+#define _1080P_eDP_Panel_
+#define _MIPI_Lane_ 4   // 3, 2, 1
+
+#define _MIPI_data_PN_Swap_En	0xF0
+#define _MIPI_data_PN_Swap_Dis	0x00
+
+#define _MIPI_data_PN_ _MIPI_data_PN_Swap_Dis
+
+#define _No_swap_		0x00    // 3210 default
+#define _MIPI_data_3210_	0       // default
+#define _MIPI_data_0123_	21
+#define _MIPI_data_2103_	20
+
+#define _MIPI_data_sequence_ _No_swap_
+
+#define _Nvid 0         // 0: 0x0080,default
+static int Nvid_Val[] = { 0x0080, 0x0800 };
+
+#ifdef _1080P_eDP_Panel_
+
+#define eDP_lane	2
+#define PCR_PLL_PREDIV	0x40
+
+//According to the timing of the Mipi signal, modify the following parameters:
+static int MIPI_Timing[] =
+// hfp,	hs,	hbp,	hact,	htotal,	vfp,	vs,	vbp,	vact,	vtotal,	pixel_CLK/10000
+//-----|---|------|-------|--------|-----|-----|-----|--------|--------|---------------
+{48, 32, 200, 1920, 2200, 3, 6, 31, 1080, 1120, 14285};     // boe config for linux
+
+//#define _6bit_ // eDP panel Color Depth，262K color
+#define _8bit_ // eDP panel Color Depth，16.7M color
+
+#endif
+
+void Reset_LT8911EXB(struct udevice *dev)
+{
+	struct edp_panel_priv *priv = dev_get_priv(dev);
+
+	pr_debug("%s: device %s\n", __func__, dev->name);
+
+	dm_gpio_set_value(&priv->reset_gpio, 1);
+	mdelay(150);
+	dm_gpio_set_value(&priv->reset_gpio, 0);
+	mdelay(150);
+	dm_gpio_set_value(&priv->reset_gpio, 1);
+	mdelay(150);
+
+}
+
+void LT8911EX_ChipID(struct udevice *dev)                                          // read Chip ID
+{
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );                                //register bank
+	LT8911EXB_IIC_Write_byte(dev, 0x08, 0x7f );
+
+#ifdef _uart_debug_
+	pr_info( "\r\nLT8911EXB chip ID: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x00 ) );    // 0x17
+	pr_info( ",0x%x", LT8911EXB_IIC_Read_byte(dev, 0x01 ) );                          // 0x05
+	pr_info( ",0x%x", LT8911EXB_IIC_Read_byte(dev, 0x02 ) );                           // 0xE0
+#endif
+}
+
+void LT8911EXB_read_edid(struct udevice *dev)
+{
+#ifdef _read_edid_
+	u8 reg, i, j;
+//	bool	aux_reply, aux_ack, aux_nack, aux_defer;
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	LT8911EXB_IIC_Write_byte(dev, 0x00, 0x20 ); //Soft Link train
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa6 );
+	LT8911EXB_IIC_Write_byte(dev, 0x2a, 0x01 );
+
+	/*set edid offset addr*/
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x40 ); //CMD
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x00 ); //addr[15:8]
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x50 ); //addr[7:0]
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x00 ); //data lenth
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x00 ); //data lenth
+	LT8911EXB_IIC_Write_byte(dev, 0x2c, 0x00 ); //start Aux read edid
+
+#ifdef _uart_debug_
+	pr_info( "\r\n" );
+	pr_info( "\r\nRead eDP EDID......" );
+#endif
+
+	mdelay( 20 );                         //more than 10ms
+	reg = LT8911EXB_IIC_Read_byte(dev, 0x25);
+
+	pr_debug( "\r\nRead eDP EDID.reg = %02x.....\n", reg);
+	if( ( reg & 0x0f ) == 0x0c )
+	{
+		for( j = 0; j < 8; j++ )
+		{
+			if( j == 7 )
+			{
+				LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x10 ); //MOT
+			}else
+			{
+				LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x50 );
+			}
+
+			LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x00 );
+			LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x50 );
+			LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x0f );
+			LT8911EXB_IIC_Write_byte(dev, 0x2c, 0x00 ); //start Aux read edid
+			mdelay( 50 );                         //more than 50ms
+
+			if( LT8911EXB_IIC_Read_byte(dev, 0x39 ) == 0x31 )
+			{
+				LT8911EXB_IIC_Read_byte(dev, 0x2b );
+				for( i = 0; i < 16; i++ )
+				{
+					EDID_DATA[j * 16 + i] = LT8911EXB_IIC_Read_byte(dev, 0x2b );
+				}
+
+				EDID_Reply = 1;
+			}else
+			{
+				EDID_Reply = 0;
+				return;
+			}
+		}
+
+		EDID_Timing[hfp] = (EDID_DATA[0x41] & 0xC0) * 4 + EDID_DATA[0x3e];
+		EDID_Timing[hs] = (EDID_DATA[0x41] & 0x30) * 16 + EDID_DATA[0x3f];
+		EDID_Timing[hbp] = ((EDID_DATA[0x3a] & 0x0f) * 0x100 + EDID_DATA[0x39]) - ((EDID_DATA[0x41] & 0x30) * 16 + EDID_DATA[0x3f]) - ((EDID_DATA[0x41] & 0xC0 ) * 4 + EDID_DATA[0x3e]);
+		EDID_Timing[hact] = (EDID_DATA[0x3a] & 0xf0) * 16 + EDID_DATA[0x38];
+		EDID_Timing[htotal] = (EDID_DATA[0x3a] & 0xf0) * 16 + EDID_DATA[0x38] + ((EDID_DATA[0x3a] & 0x0f) * 0x100 + EDID_DATA[0x39]);
+		EDID_Timing[vfp] = (EDID_DATA[0x41] & 0x0c) * 4 + (EDID_DATA[0x40] & 0xf0 ) / 16;
+		EDID_Timing[vs] = (EDID_DATA[0x41] & 0x03) * 16 + (EDID_DATA[0x40] & 0x0f );
+		EDID_Timing[vbp] = ((EDID_DATA[0x3d] & 0x03) * 0x100 + EDID_DATA[0x3c]) - ((EDID_DATA[0x41] & 0x03) * 16 + (EDID_DATA[0x40] & 0x0f)) - ((EDID_DATA[0x41] & 0x0c) * 4 + (EDID_DATA[0x40] & 0xf0 ) / 16);
+		EDID_Timing[vact] = (EDID_DATA[0x3d] & 0xf0) * 16 + EDID_DATA[0x3b];
+		EDID_Timing[vtotal] = (EDID_DATA[0x3d] & 0xf0 ) * 16 + EDID_DATA[0x3b] + ((EDID_DATA[0x3d] & 0x03) * 0x100 + EDID_DATA[0x3c]);
+		EDID_Timing[pclk_10khz] = EDID_DATA[0x37] * 0x100 + EDID_DATA[0x36];
+		pr_info( "eDP Timing = { H_FP / H_pluse / H_BP / H_act / H_tol / V_FP / V_pluse / V_BP / V_act / V_tol / D_CLK };" );
+		pr_info( "eDP Timing = { %d       %d       %d     %d     %d     %d      %d       %d     %d    %d    %d };\n",
+				(u32)EDID_Timing[hfp],(u32)EDID_Timing[hs],(u32)EDID_Timing[hbp],(u32)EDID_Timing[hact],(u32)EDID_Timing[htotal],
+				(u32)EDID_Timing[vfp],(u32)EDID_Timing[vs],(u32)EDID_Timing[vbp],(u32)EDID_Timing[vact],(u32)EDID_Timing[vtotal],(u32)EDID_Timing[pclk_10khz]);
+	}
+
+	return;
+
+#endif
+}
+
+static int lt8911exb_i2c_test(struct udevice *dev)                            //void LT8911EX_ChipID( void )
+{
+    u8 retry = 0;
+    uint8_t chip_id_h = 0, chip_id_m = 0, chip_id_l = 0;
+    int ret = -EAGAIN;
+
+    pr_debug("%s: device %s \n", __func__, dev->name);
+
+    while(retry++ < 3) {
+        ret = edp_panel_i2c_write(dev, 0xff, 0x81);
+
+        if(ret < 0) {
+            pr_info("LT8911EXB i2c test write addr:0xff failed\n");
+            continue;
+        }
+        edp_panel_i2c_read(dev, 0xff, &chip_id_l);
+
+        ret = edp_panel_i2c_write(dev, 0x08, 0x7f);
+
+        if(ret < 0) {
+            pr_info("LT8911EXB i2c test write addr:0x08 failed\n");
+            continue;
+        }
+        edp_panel_i2c_read(dev, 0x01, &chip_id_m);
+        pr_debug("LT8911EXB i2c test success chipid: 0x%x,0x%x\n", chip_id_m, chip_id_l);
+
+        edp_panel_i2c_read(dev, 0x00, &chip_id_l);
+        edp_panel_i2c_read(dev, 0x01, &chip_id_m);
+        edp_panel_i2c_read(dev, 0x02, &chip_id_h);
+        // LT8911EXB i2c test success chipid: 0xe0517
+        pr_debug("LT8911EXB i2c test success chipid: 0x%x%x%x\n", chip_id_h, chip_id_m, chip_id_l);
+
+        ret = 0;
+        break;
+    }
+
+    return ret;
+}
+
+void LT8911EXB_MIPI_Video_Timing(struct udevice *dev)                                    // ( struct video_timing *video_format )
+{
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xd0 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0d, (u8)( MIPI_Timing[vtotal] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0e, (u8)( MIPI_Timing[vtotal] % 256 ) );    //vtotal
+	LT8911EXB_IIC_Write_byte(dev, 0x0f, (u8)( MIPI_Timing[vact] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x10, (u8)( MIPI_Timing[vact] % 256 ) );      //vactive
+
+	LT8911EXB_IIC_Write_byte(dev, 0x11, (u8)( MIPI_Timing[htotal] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x12, (u8)( MIPI_Timing[htotal] % 256 ) );    //htotal
+	LT8911EXB_IIC_Write_byte(dev, 0x13, (u8)( MIPI_Timing[hact] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, (u8)( MIPI_Timing[hact] % 256 ) );      //hactive
+
+	LT8911EXB_IIC_Write_byte(dev, 0x15, (u8)( MIPI_Timing[vs] % 256 ) );        //vsa
+	LT8911EXB_IIC_Write_byte(dev, 0x16, (u8)( MIPI_Timing[hs] % 256 ) );        //hsa
+	LT8911EXB_IIC_Write_byte(dev, 0x17, (u8)( MIPI_Timing[vfp] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x18, (u8)( MIPI_Timing[vfp] % 256 ) );       //vfp
+
+	LT8911EXB_IIC_Write_byte(dev, 0x19, (u8)( MIPI_Timing[hfp] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x1a, (u8)( MIPI_Timing[hfp] % 256 ) );       //hfp
+
+	#ifdef _uart_debug_
+	pr_info("------\n");
+	pr_info("MIPI_Timing[vtotal] / 256 = %d\n", MIPI_Timing[vtotal] / 256);
+	pr_info("MIPI_Timing[vtotal]  256 = %d\n", MIPI_Timing[vtotal] % 256);
+	pr_info("MIPI_Timing[vact] / 256 = %d\n", MIPI_Timing[vact] / 256);
+	pr_info("MIPI_Timing[vact]  256 = %d\n", MIPI_Timing[vact] % 256);
+	pr_info("MIPI_Timing[htotal] / 256 = %d\n", MIPI_Timing[htotal] / 256);
+	pr_info("MIPI_Timing[htotal]  256 = %d\n", MIPI_Timing[htotal] % 256);
+	pr_info("MIPI_Timing[hact] / 256 = %d\n", MIPI_Timing[hact] / 256);
+	pr_info("MIPI_Timing[hact]  256 = %d\n", MIPI_Timing[hact] % 256);
+
+	pr_info("MIPI_Timing[vs]  256 = %d\n", MIPI_Timing[vs] % 256);
+	pr_info("MIPI_Timing[hs]  256 = %d\n", MIPI_Timing[hs] % 256);
+
+	pr_info("MIPI_Timing[vfp] / 256 = %d\n", MIPI_Timing[vfp] / 256);
+	pr_info("MIPI_Timing[vfp]  256 = %d\n", MIPI_Timing[vfp] % 256);
+	pr_info("MIPI_Timing[hfp] / 256 = %d\n", MIPI_Timing[hfp] / 256);
+	pr_info("MIPI_Timing[hfp]  256 = %d\n", MIPI_Timing[hfp] % 256);
+	pr_info("------\n");
+	#endif
+
+}
+
+void LT8911EXB_eDP_Video_cfg(struct udevice *dev)                                        // ( struct video_timing *video_format )
+{
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa8 );
+	LT8911EXB_IIC_Write_byte(dev, 0x2d, 0x88 );                                 // MSA from register
+
+#ifdef _Msa_Active_Only_
+	LT8911EXB_IIC_Write_byte(dev, 0x05, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x06, 0x00 );                                 //htotal
+	LT8911EXB_IIC_Write_byte(dev, 0x07, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x08, 0x00 );                                 //h_start
+
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0x00 );                                 //hsa
+	LT8911EXB_IIC_Write_byte(dev, 0x0b, (u8)( MIPI_Timing[hact] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, (u8)( MIPI_Timing[hact] % 256 ) );      //hactive
+
+	LT8911EXB_IIC_Write_byte(dev, 0x0d, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0e, 0x00 );                                 //vtotal
+
+	LT8911EXB_IIC_Write_byte(dev, 0x11, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x12, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x15, (u8)( MIPI_Timing[vact] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x16, (u8)( MIPI_Timing[vact] % 256 ) );      //vactive
+
+#else
+
+	LT8911EXB_IIC_Write_byte(dev, 0x05, (u8)( MIPI_Timing[htotal] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x06, (u8)( MIPI_Timing[htotal] % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x07, (u8)( ( MIPI_Timing[hs] + MIPI_Timing[hbp] ) / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x08, (u8)( ( MIPI_Timing[hs] + MIPI_Timing[hbp] ) % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, (u8)( MIPI_Timing[hs] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, (u8)( MIPI_Timing[hs] % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0b, (u8)( MIPI_Timing[hact] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, (u8)( MIPI_Timing[hact] % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0d, (u8)( MIPI_Timing[vtotal] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x0e, (u8)( MIPI_Timing[vtotal] % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x11, (u8)( ( MIPI_Timing[vs] + MIPI_Timing[vbp] ) / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x12, (u8)( ( MIPI_Timing[vs] + MIPI_Timing[vbp] ) % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, (u8)( MIPI_Timing[vs] % 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x15, (u8)( MIPI_Timing[vact] / 256 ) );
+	LT8911EXB_IIC_Write_byte(dev, 0x16, (u8)( MIPI_Timing[vact] % 256 ) );
+
+	#ifdef _uart_debug_
+	pr_info("------\n");
+	pr_info("(u8)( MIPI_Timing[htotal] / 256 ) = %d\n", (MIPI_Timing[htotal] / 256));
+	pr_info("(u8)( MIPI_Timing[htotal]  256 ) = %d\n", (MIPI_Timing[htotal] % 256));
+	pr_info("(u8)( ( MIPI_Timing[hs] + MIPI_Timing[hbp] ) / 256 )  = %d\n", ((MIPI_Timing[hs] + MIPI_Timing[hbp]) / 256));
+	pr_info("(u8)( ( MIPI_Timing[hs] + MIPI_Timing[hbp] )  256 ) = %d\n", ((MIPI_Timing[hs] + MIPI_Timing[hbp]) % 256));
+	pr_info("(u8)( MIPI_Timing[hs] / 256 ) = %d\n", (MIPI_Timing[hs] / 256));
+	pr_info("(u8)( MIPI_Timing[hs]  256 ) = %d\n", (MIPI_Timing[hs] % 256));
+	pr_info("(u8)( MIPI_Timing[hact] / 256 )  = %d\n", (MIPI_Timing[hact] / 256));
+	pr_info("(u8)( MIPI_Timing[hact]  256 ) = %d\n", (MIPI_Timing[hact] % 256));
+
+	pr_info("(u8)( ( MIPI_Timing[vs] + MIPI_Timing[vbp] ) / 256 ) = %d\n", ((MIPI_Timing[vs] + MIPI_Timing[vbp]) / 256));
+	pr_info("(u8)( ( MIPI_Timing[vs] + MIPI_Timing[vbp] )  256 ) = %d\n", ((MIPI_Timing[vs] + MIPI_Timing[vbp]) % 256));
+
+	pr_info("(u8)( MIPI_Timing[vs]  256 ) = %d\n", (MIPI_Timing[vs] % 256));
+	pr_info("(u8)( MIPI_Timing[vact] / 256 )  = %d\n", (MIPI_Timing[vact] / 256));
+	pr_info("(u8)( MIPI_Timing[vact]  256 ) = %d\n", (MIPI_Timing[vact] % 256));
+	pr_info("------\n");
+	#endif
+#endif
+
+
+}
+
+void LT8911EXB_init(struct udevice *dev)
+{
+	u8	i;
+	u8	pcr_pll_postdiv;
+	u8	pcr_m;
+	u16 Temp16;
+
+	/* init */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x08, 0x7f ); // i2c over aux issue
+	LT8911EXB_IIC_Write_byte(dev, 0x49, 0xff ); // enable 0x87xx
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x5a, 0x0e ); // GPIO test output
+
+	//for power consumption//
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+	LT8911EXB_IIC_Write_byte(dev, 0x05, 0x06 );
+	LT8911EXB_IIC_Write_byte(dev, 0x43, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x44, 0x1f );
+	LT8911EXB_IIC_Write_byte(dev, 0x45, 0xf7 );
+	LT8911EXB_IIC_Write_byte(dev, 0x46, 0xf6 );
+	LT8911EXB_IIC_Write_byte(dev, 0x49, 0x7f );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 );
+#if ( eDP_lane == 2 )
+	{
+		LT8911EXB_IIC_Write_byte(dev, 0x12, 0x33 );
+	}
+#elif ( eDP_lane == 1 )
+	{
+		LT8911EXB_IIC_Write_byte(dev, 0x12, 0x11 );
+	}
+#endif
+
+	/* mipi Rx analog */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x32, 0x51 );
+	LT8911EXB_IIC_Write_byte(dev, 0x35, 0x22 ); //EQ current 0x22/0x42/0x62/0x82/0xA2/0xC2/0xe2
+	LT8911EXB_IIC_Write_byte(dev, 0x3a, 0x77 ); //EQ 12.5db
+	LT8911EXB_IIC_Write_byte(dev, 0x3b, 0x77 ); //EQ 12.5db
+
+	LT8911EXB_IIC_Write_byte(dev, 0x4c, 0x0c );
+	LT8911EXB_IIC_Write_byte(dev, 0x4d, 0x00 );
+
+	/* dessc_pcr  pll analog */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x6a, 0x40 );
+	LT8911EXB_IIC_Write_byte(dev, 0x6b, PCR_PLL_PREDIV );
+
+	Temp16 = MIPI_Timing[pclk_10khz];
+
+	if( MIPI_Timing[pclk_10khz] < 8800 )
+	{
+		LT8911EXB_IIC_Write_byte(dev, 0x6e, 0x82 ); //0x44:pre-div = 2 ,pixel_clk=44~ 88MHz
+		pcr_pll_postdiv = 0x08;
+	}else
+	if( MIPI_Timing[pclk_10khz] < 17600 )
+	{
+		LT8911EXB_IIC_Write_byte(dev, 0x6e, 0x81 ); //0x40:pre-div = 1, pixel_clk =88~176MHz
+		pcr_pll_postdiv = 0x04;
+	}else
+	{
+		LT8911EXB_IIC_Write_byte(dev, 0x6e, 0x80 ); //0x40:pre-div = 0, pixel_clk =176~200MHz
+		pcr_pll_postdiv = 0x02;
+	}
+
+	pcr_m = (u8)( Temp16 * pcr_pll_postdiv / 25 / 100 );
+
+	/* dessc pll digital */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );     // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0xa9, 0x31 );
+	LT8911EXB_IIC_Write_byte(dev, 0xaa, 0x17 );
+	LT8911EXB_IIC_Write_byte(dev, 0xab, 0xba );
+	LT8911EXB_IIC_Write_byte(dev, 0xac, 0xe1 );
+	LT8911EXB_IIC_Write_byte(dev, 0xad, 0x47 );
+	LT8911EXB_IIC_Write_byte(dev, 0xae, 0x01 );
+	LT8911EXB_IIC_Write_byte(dev, 0xae, 0x11 );
+
+	/* Digital Top */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );                             // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0xc0, 0x01 );                             //select mipi Rx
+#ifdef _6bit_
+	LT8911EXB_IIC_Write_byte(dev, 0xb0, 0xd0 );                             //enable dither
+#else
+	LT8911EXB_IIC_Write_byte(dev, 0xb0, 0x00 );                             // disable dither
+#endif
+
+	/* mipi Rx Digital */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xd0 );                             // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x00, _MIPI_data_PN_ + _MIPI_Lane_ % 4 ); // 0: 4 Lane / 1: 1 Lane / 2 : 2 Lane / 3: 3 Lane
+	LT8911EXB_IIC_Write_byte(dev, 0x02, 0x08 );                             //settle
+	LT8911EXB_IIC_Write_byte(dev, 0x03, _MIPI_data_sequence_ );             // default is 0x00
+	LT8911EXB_IIC_Write_byte(dev, 0x08, 0x00 );
+//	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0x12 );                             //pcr mode
+
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x80 );                             //fifo position
+	LT8911EXB_IIC_Write_byte(dev, 0x1c, 0x80 );                             //fifo position
+
+	// hs mode:MIPI行采样；vs mode:MIPI帧采样
+	LT8911EXB_IIC_Write_byte(dev, 0x24, 0x70 );                             // 0x30  [3:0]  line limit	  //pcr mode( de hs vs)
+
+	LT8911EXB_IIC_Write_byte(dev, 0x31, 0x0a );
+
+	/*stage1 hs mode*/
+	LT8911EXB_IIC_Write_byte(dev, 0x25, 0x90 );                             // 0x80		   // line limit
+	LT8911EXB_IIC_Write_byte(dev, 0x2a, 0x3a );                             // 0x04		   // step in limit
+	LT8911EXB_IIC_Write_byte(dev, 0x21, 0x4f );                             // hs_step
+	LT8911EXB_IIC_Write_byte(dev, 0x22, 0xff );
+
+	/*stage2 de mode*/
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0x02 );                             //de adjust pre line
+	LT8911EXB_IIC_Write_byte(dev, 0x38, 0x02 );                             //de_threshold 1
+	LT8911EXB_IIC_Write_byte(dev, 0x39, 0x04 );                             //de_threshold 2
+	LT8911EXB_IIC_Write_byte(dev, 0x3a, 0x08 );                             //de_threshold 3
+	LT8911EXB_IIC_Write_byte(dev, 0x3b, 0x10 );                             //de_threshold 4
+
+	LT8911EXB_IIC_Write_byte(dev, 0x3f, 0x04 );                             //de_step 1
+	LT8911EXB_IIC_Write_byte(dev, 0x40, 0x08 );                             //de_step 2
+	LT8911EXB_IIC_Write_byte(dev, 0x41, 0x10 );                             //de_step 3
+	LT8911EXB_IIC_Write_byte(dev, 0x42, 0x60 );                             //de_step 4
+
+	/*stage2 hs mode*/
+	LT8911EXB_IIC_Write_byte(dev, 0x1e, 0x0A );//LT8911EXB_IIC_Write_byte(dev, 0x1e, 0x01 );                             // 0x11
+	LT8911EXB_IIC_Write_byte(dev, 0x23, 0xf0 );                             // 0x80			   //
+
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x80 );                             // 0xa0
+
+#ifdef _Test_Pattern_
+	LT8911EXB_IIC_Write_byte(dev, 0x26, ( pcr_m | 0x80 ) );
+#else
+
+	LT8911EXB_IIC_Write_byte(dev, 0x26, pcr_m );
+
+#endif
+
+	LT8911EXB_MIPI_Video_Timing(dev);         //defualt setting is 1080P
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x03, 0x7b ); //PCR reset
+	LT8911EXB_IIC_Write_byte(dev, 0x03, 0xff );
+
+#ifdef _eDP_2G7_
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x19, 0x31 );
+	LT8911EXB_IIC_Write_byte(dev, 0x1a, 0x36 ); // sync m
+	LT8911EXB_IIC_Write_byte(dev, 0x1b, 0x00 ); // sync_k [7:0]
+	LT8911EXB_IIC_Write_byte(dev, 0x1c, 0x00 ); // sync_k [13:8]
+
+	// txpll Analog
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0x00 ); // div hardware mode, for ssc.
+
+//	LT8911EXB_IIC_Write_byte(dev, 0x01, 0x18 );// default : 0x18
+	LT8911EXB_IIC_Write_byte(dev, 0x02, 0x42 );
+	LT8911EXB_IIC_Write_byte(dev, 0x03, 0x00 ); // txpll en = 0
+	LT8911EXB_IIC_Write_byte(dev, 0x03, 0x01 ); // txpll en = 1
+//	LT8911EXB_IIC_Write_byte(dev, 0x04, 0x3a );// default : 0x3A
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x10 ); // cal en = 0
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfc );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfd );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x11 ); // cal en = 1
+
+	// ssc
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x13, 0x83 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x41 );
+	LT8911EXB_IIC_Write_byte(dev, 0x16, 0x0a );
+	LT8911EXB_IIC_Write_byte(dev, 0x18, 0x0a );
+	LT8911EXB_IIC_Write_byte(dev, 0x19, 0x33 );
+#endif
+
+#ifdef _eDP_1G62_
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x19, 0x31 );
+	LT8911EXB_IIC_Write_byte(dev, 0x1a, 0x20 ); // sync m
+	LT8911EXB_IIC_Write_byte(dev, 0x1b, 0x19 ); // sync_k [7:0]
+	LT8911EXB_IIC_Write_byte(dev, 0x1c, 0x99 ); // sync_k [13:8]
+
+	// txpll Analog
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0x00 ); // div hardware mode, for ssc.
+	//	LT8911EXB_IIC_Write_byte(dev, 0x01, 0x18 );// default : 0x18
+	LT8911EXB_IIC_Write_byte(dev, 0x02, 0x42 );
+	LT8911EXB_IIC_Write_byte(dev, 0x03, 0x00 ); // txpll en = 0
+	LT8911EXB_IIC_Write_byte(dev, 0x03, 0x01 ); // txpll en = 1
+	//	LT8911EXB_IIC_Write_byte(dev, 0x04, 0x3a );// default : 0x3A
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x10 ); // cal en = 0
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfc );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfd );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x11 ); // cal en = 1
+
+	//ssc
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+	LT8911EXB_IIC_Write_byte(dev, 0x13, 0x83 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x41 );
+	LT8911EXB_IIC_Write_byte(dev, 0x16, 0x0a );
+	LT8911EXB_IIC_Write_byte(dev, 0x18, 0x0a );
+	LT8911EXB_IIC_Write_byte(dev, 0x19, 0x33 );
+#endif
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+
+	for( i = 0; i < 5; i++ ) //Check Tx PLL
+	{
+		mdelay( 5 );
+		if( LT8911EXB_IIC_Read_byte(dev, 0x37 ) & 0x02 )
+		{
+			pr_debug( "\r\nLT8911 tx pll locked \n");
+			break;
+		}else
+		{
+			pr_debug( "\r\nLT8911 tx pll unlocked \n");
+			LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+			LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfc );
+			LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfd );
+
+			LT8911EXB_IIC_Write_byte(dev, 0xff, 0x87 );
+			LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x10 );
+			LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x11 );
+		}
+	}
+
+	// AUX reset
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x07, 0xfe );
+	LT8911EXB_IIC_Write_byte(dev, 0x07, 0xff );
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0xfc );
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0xfe );
+
+	/* tx phy */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x11, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x13, 0x10 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x0c );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x08 );
+	LT8911EXB_IIC_Write_byte(dev, 0x13, 0x20 );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x82 ); // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x0e, 0x35 );
+//	LT8911EXB_IIC_Write_byte(dev, 0x12, 0xff );
+//	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x80 );
+//	LT8911EXB_IIC_Write_byte(dev, 0x40, 0x22 );
+
+	/*eDP Tx Digital */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa8 ); // Change Reg bank
+
+#ifdef _Test_Pattern_
+
+	LT8911EXB_IIC_Write_byte(dev, 0x24, 0x50 ); // bit2 ~ bit 0 : test panttern image mode
+	LT8911EXB_IIC_Write_byte(dev, 0x25, 0x70 ); // bit6 ~ bit 4 : test Pattern color
+	LT8911EXB_IIC_Write_byte(dev, 0x27, 0x50 ); //0x50:Pattern; 0x10:mipi video
+
+//	LT8911EXB_IIC_Write_byte(dev, 0x2d, 0x00 ); //  pure color setting
+//	LT8911EXB_IIC_Write_byte(dev, 0x2d, 0x84 ); // black color
+	LT8911EXB_IIC_Write_byte(dev, 0x2d, 0x88 ); //  block
+
+#else
+	LT8911EXB_IIC_Write_byte(dev, 0x27, 0x10 ); //0x50:Pattern; 0x10:mipi video
+#endif
+
+#ifdef _6bit_
+	LT8911EXB_IIC_Write_byte(dev, 0x17, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x18, 0x00 );
+#else
+	// _8bit_
+	LT8911EXB_IIC_Write_byte(dev, 0x17, 0x10 );
+	LT8911EXB_IIC_Write_byte(dev, 0x18, 0x20 );
+#endif
+
+	/* nvid */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa0 );                             // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x00, (u8)( Nvid_Val[_Nvid] / 256 ) );    // 0x08
+	LT8911EXB_IIC_Write_byte(dev, 0x01, (u8)( Nvid_Val[_Nvid] % 256 ) );    // 0x00
+}
+
+void LT8911EXB_video_check(struct udevice *dev)
+{
+	u32 reg = 0x00;
+	/* mipi byte clk check*/
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );     // Change Reg bank
+	LT8911EXB_IIC_Write_byte(dev, 0x1d, 0x00 );     //FM select byte clk
+	LT8911EXB_IIC_Write_byte(dev, 0x40, 0xf7 );
+	LT8911EXB_IIC_Write_byte(dev, 0x41, 0x30 );
+
+	if( ScrambleMode ) {
+		LT8911EXB_IIC_Write_byte(dev, 0xa1, 0x82 ); //eDP scramble mode;
+	} else {
+		LT8911EXB_IIC_Write_byte(dev, 0xa1, 0x02 ); // DP scramble mode;
+	}
+
+//	LT8911EXB_IIC_Write_byte(dev, 0x17, 0xf0 ); // 0xf0:Close scramble; 0xD0 : Open scramble
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0x7d );
+	LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfd );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );
+	mdelay( 200 );
+	if( LT8911EXB_IIC_Read_byte(dev, 0x50 ) == 0x03 )
+	{
+		reg	   = LT8911EXB_IIC_Read_byte(dev, 0x4d );
+		reg	   = reg * 256 + LT8911EXB_IIC_Read_byte(dev, 0x4e );
+		reg	   = reg * 256 + LT8911EXB_IIC_Read_byte(dev, 0x4f );
+
+		pr_debug( "\r\nvideo check: mipi byteclk = %d ", reg ); // mipi byteclk = reg * 1000
+		pr_debug( "\r\nvideo check: mipi bitrate = %d ", reg * 8 ); // mipi byteclk = reg * 1000
+		pr_debug( "\r\nvideo check: mipi pclk = %d ", reg /3 * 4 * 1000 ); // mipi byteclk = reg * 1000
+	}else
+	{
+		pr_debug( "\r\nvideo check: mipi clk unstable" );
+	}
+
+	/* mipi vtotal check*/
+	reg	   = LT8911EXB_IIC_Read_byte(dev, 0x76 );
+	reg	   = reg * 256 + LT8911EXB_IIC_Read_byte(dev, 0x77 );
+
+	pr_debug( "\r\nvideo check: Vtotal =  %d", reg);
+
+	/* mipi word count check*/
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xd0 );
+	reg	   = LT8911EXB_IIC_Read_byte(dev, 0x82 );
+	reg	   = reg * 256 + LT8911EXB_IIC_Read_byte(dev, 0x83 );
+	reg	   = reg / 3;
+
+	pr_debug( "\r\nvideo check: Hact(word counter) =  %d", reg);
+
+	/* mipi Vact check*/
+	reg	   = LT8911EXB_IIC_Read_byte(dev, 0x85 );
+	reg	   = reg * 256 + LT8911EXB_IIC_Read_byte(dev, 0x86 );
+
+	pr_debug( "\r\nvideo check: Vact = %d", reg);
+}
+
+void DpcdWrite(struct udevice *dev, u32 Address, u8 Data )
+{
+	/***************************
+	   注意大小端的问题!
+	   这里默认是大端模式
+
+	   Pay attention to the Big-Endian and Little-Endian!
+	   The default mode is Big-Endian here.
+
+	 ****************************/
+	u8	AddressH   = 0x0f & ( Address >> 16 );
+	u8	AddressM   = 0xff & ( Address >> 8 );
+	u8	AddressL   = 0xff & Address;
+
+	u8	reg;
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa6 );
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, ( 0x80 | AddressH ) );  //CMD
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, AddressM );             //addr[15:8]
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, AddressL );             //addr[7:0]
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x00 );                 //data lenth
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, Data );                 //data
+	LT8911EXB_IIC_Write_byte(dev, 0x2c, 0x00 );                 //start Aux
+
+	mdelay( 20 );                                         //more than 10ms
+	reg = LT8911EXB_IIC_Read_byte(dev, 0x25 );
+
+	if( ( reg & 0x0f ) == 0x0c )
+	{
+		return;
+	}
+}
+
+u8 DpcdRead(struct udevice *dev, u32 Address )
+{
+	/***************************
+	   注意大小端的问题!
+	   这里默认是大端模式
+
+	   Pay attention to the Big-Endian and Little-Endian!
+	   The default mode is Big-Endian here.
+
+	 ****************************/
+
+	u8	DpcdValue  = 0x00;
+	u8	AddressH   = 0x0f & ( Address >> 16 );
+	u8	AddressM   = 0xff & ( Address >> 8 );
+	u8	AddressL   = 0xff & Address;
+	u8	reg;
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	LT8911EXB_IIC_Write_byte(dev, 0x00, 0x20 );                 //Soft Link train
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa6 );
+	LT8911EXB_IIC_Write_byte(dev, 0x2a, 0x01 );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa6 );
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, ( 0x90 | AddressH ) );  //CMD
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, AddressM );             //addr[15:8]
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, AddressL );             //addr[7:0]
+	LT8911EXB_IIC_Write_byte(dev, 0x2b, 0x00 );                 //data lenth
+	LT8911EXB_IIC_Write_byte(dev, 0x2c, 0x00 );                 //start Aux read edid
+
+	mdelay( 50 );                                         //more than 10ms
+	reg = LT8911EXB_IIC_Read_byte(dev, 0x25 );
+	if( ( reg & 0x0f ) == 0x0c )
+	{
+		if( LT8911EXB_IIC_Read_byte(dev, 0x39 ) == 0x22 )
+		{
+			LT8911EXB_IIC_Read_byte(dev, 0x2b );
+			DpcdValue = LT8911EXB_IIC_Read_byte(dev, 0x2b );
+		}
+	}else
+	{
+		LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 ); // change bank
+		LT8911EXB_IIC_Write_byte(dev, 0x07, 0xfe );
+		LT8911EXB_IIC_Write_byte(dev, 0x07, 0xff );
+		LT8911EXB_IIC_Write_byte(dev, 0x0a, 0xfc );
+		LT8911EXB_IIC_Write_byte(dev, 0x0a, 0xfe );
+	}
+
+	return DpcdValue;
+}
+
+void LT8911EX_link_train(struct udevice *dev)
+{
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+	LT8911EXB_IIC_Write_byte(dev, 0x06, 0xdf ); // rset VID TX
+	LT8911EXB_IIC_Write_byte(dev, 0x06, 0xff );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );
+
+//	LT8911EXB_IIC_Write_byte(dev, 0x17, 0xf0 ); // turn off scramble
+
+	if( ScrambleMode ) {
+		LT8911EXB_IIC_Write_byte(dev, 0xa1, 0x82 ); // eDP scramble mode;
+
+		/* Aux operater init */
+
+		LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+		LT8911EXB_IIC_Write_byte(dev, 0x00, 0x20 ); //Soft Link train
+		LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa6 );
+		LT8911EXB_IIC_Write_byte(dev, 0x2a, 0x01 );
+
+		DpcdWrite(dev, 0x010a, 0x01 );
+		mdelay( 10 );
+		DpcdWrite(dev, 0x0102, 0x00 );
+		mdelay( 10 );
+		DpcdWrite(dev, 0x010a, 0x01 );
+
+		mdelay( 200 );
+	} else {
+		LT8911EXB_IIC_Write_byte(dev, 0xa1, 0x02 ); // DP scramble mode;
+	}
+
+	/* Aux setup */
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	LT8911EXB_IIC_Write_byte(dev, 0x00, 0x60 );     //Soft Link train
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xa6 );
+	LT8911EXB_IIC_Write_byte(dev, 0x2a, 0x00 );
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x81 );
+	LT8911EXB_IIC_Write_byte(dev, 0x07, 0xfe );
+	LT8911EXB_IIC_Write_byte(dev, 0x07, 0xff );
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0xfc );
+	LT8911EXB_IIC_Write_byte(dev, 0x0a, 0xfe );
+
+	/* link train */
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );
+	LT8911EXB_IIC_Write_byte(dev, 0x1a, eDP_lane );
+
+#ifdef _link_train_enable_
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	LT8911EXB_IIC_Write_byte(dev, 0x00, 0x64 );
+	LT8911EXB_IIC_Write_byte(dev, 0x01, 0x0a );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0x85 );
+	LT8911EXB_IIC_Write_byte(dev, 0x0c, 0xc5 );
+#else
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	LT8911EXB_IIC_Write_byte(dev, 0x00, 0x00 );
+	LT8911EXB_IIC_Write_byte(dev, 0x01, 0x0a );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x80 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x81 );
+	mdelay( 50 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0x84 );
+	mdelay( 50 );
+	LT8911EXB_IIC_Write_byte(dev, 0x14, 0xc0 );
+#endif
+}
+
+void LT8911EX_link_train_result(struct udevice *dev)
+{
+	u8 i, reg;
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	for( i = 0; i < 10; i++ )
+	{
+		reg = LT8911EXB_IIC_Read_byte(dev, 0x82 );
+		if( reg & 0x20 )
+		{
+			if( ( reg & 0x1f ) == 0x1e )
+			{
+				pr_debug( "\r\nLink train success, 0x82 = 0x%x", reg );
+			} else
+			{
+				pr_debug( "\r\nLink train fail, 0x82 = 0x%x", reg );
+			}
+
+			pr_debug( "\r\npanel link rate: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x83 ) );
+			pr_debug( "\r\npanel link count: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x84 ) );
+			return;
+		}else
+		{
+			pr_debug( "\r\nlink trian on going..." );
+		}
+		mdelay( 100 );
+	}
+}
+
+enum
+{
+	_Level0_ = 0,                                               // 27.8 mA  0x83/0x00
+	_Level1_,                                                   // 26.2 mA  0x82/0xe0
+	_Level2_,                                                   // 24.6 mA  0x82/0xc0
+	_Level3_,                                                   // 23 mA    0x82/0xa0
+	_Level4_,                                                   // 21.4 mA  0x82/0x80
+	_Level5_,                                                   // 18.2 mA  0x82/0x40
+	_Level6_,                                                   // 16.6 mA  0x82/0x20
+	_Level7_,                                                   // 15mA     0x82/0x00  // level 1
+	_Level8_,                                                   // 12.8mA   0x81/0x00  // level 2
+	_Level9_,                                                   // 11.2mA   0x80/0xe0  // level 3
+	_Level10_,                                                  // 9.6mA    0x80/0xc0  // level 4
+	_Level11_,                                                  // 8mA      0x80/0xa0  // level 5
+	_Level12_,                                                  // 6mA      0x80/0x80  // level 6
+};
+
+u8	Swing_Setting1[] = { 0x83, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x81, 0x80, 0x80, 0x80, 0x80 };
+u8	Swing_Setting2[] = { 0x00, 0xe0, 0xc0, 0xa0, 0x80, 0x40, 0x20, 0x00, 0x00, 0xe0, 0xc0, 0xa0, 0x80 };
+
+u8	Level = _Level7_;
+
+void LT8911EX_TxSwingPreSet(struct udevice *dev)
+{
+	LT8911EXB_IIC_Write_byte(dev, 0xFF, 0x82 );
+	LT8911EXB_IIC_Write_byte(dev, 0x22, Swing_Setting1[Level] );    //lane 0 tap0
+	LT8911EXB_IIC_Write_byte(dev, 0x23, Swing_Setting2[Level] );
+	LT8911EXB_IIC_Write_byte(dev, 0x24, 0x80 );                     //lane 0 tap1
+	LT8911EXB_IIC_Write_byte(dev, 0x25, 0x00 );
+
+#if ( eDP_lane == 2 )
+	LT8911EXB_IIC_Write_byte(dev, 0x26, Swing_Setting1[Level] );    //lane 1 tap0
+	LT8911EXB_IIC_Write_byte(dev, 0x27, Swing_Setting2[Level] );
+	LT8911EXB_IIC_Write_byte(dev, 0x28, 0x80 );                     //lane 1 tap1
+	LT8911EXB_IIC_Write_byte(dev, 0x29, 0x00 );
+#endif
+}
+
+void PCR_Status(struct udevice *dev)                                         // for debug
+{
+#ifdef _uart_debug_
+	u8 reg;
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xd0 );
+	reg = LT8911EXB_IIC_Read_byte(dev, 0x87 );
+
+	pr_info( "\r\nReg0xD087 =	");
+	pr_info( " 0x%x ", reg );
+	pr_info( "\r\n " );
+	if( reg & 0x10 )
+	{
+		pr_info( "\r\nPCR Clock stable" );
+	}else
+	{
+		pr_info( "\r\nPCR Clock unstable" );
+	}
+	pr_info( "\r\n " );
+#endif
+}
+
+void LT8911EXB_LinkTrainResultCheck(struct udevice *dev)
+{
+#ifdef _link_train_enable_
+	u8	i;
+	u8	val;
+	//int ret;
+
+	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+	for( i = 0; i < 10; i++ )
+	{
+		val = LT8911EXB_IIC_Read_byte(dev, 0x82 );
+		if( val & 0x20 )
+		{
+			if( ( val & 0x1f ) == 0x1e )
+			{
+#ifdef _uart_debug_
+				pr_info( "\r\nedp link train successed: 0x%x", val );
+#endif
+				return;
+			}else
+			{
+#ifdef _uart_debug_
+				pr_info( "\r\nedp link train failed: 0x%x", val );
+#endif
+				LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+				LT8911EXB_IIC_Write_byte(dev, 0x00, 0x00 );
+				LT8911EXB_IIC_Write_byte(dev, 0x01, 0x0a );
+				LT8911EXB_IIC_Write_byte(dev, 0x14, 0x80 );
+				LT8911EXB_IIC_Write_byte(dev, 0x14, 0x81 );
+				mdelay( 50 );
+				LT8911EXB_IIC_Write_byte(dev, 0x14, 0x84 );
+				mdelay( 50 );
+				LT8911EXB_IIC_Write_byte(dev, 0x14, 0xc0 );
+			}
+
+#ifdef _uart_debug_
+
+			val = LT8911EXB_IIC_Read_byte(dev, 0x83 );
+			pr_info( "\r\npanel link rate: 0x%x", val );
+			val = LT8911EXB_IIC_Read_byte(dev, 0x84 );
+			pr_info( "\r\npanel link count:0x%x ", val );
+#endif
+			mdelay( 100 );
+		}else
+		{
+			mdelay( 100 );
+		}
+	}
+#endif
+}
+
+static int edp_panel_enable_backlight(struct udevice *dev)
+{
+	pr_debug("%s: device %s \n", __func__, dev->name);
+
+	Reset_LT8911EXB(dev);     // Reset LT8911EXB
+	LT8911EX_ChipID(dev);     // read Chip ID
+
+	LT8911EXB_eDP_Video_cfg(dev);
+
+	LT8911EXB_init(dev);
+	LT8911EX_TxSwingPreSet(dev);
+
+	LT8911EXB_read_edid(dev); // for debug
+	ScrambleMode = 0;
+	LT8911EX_link_train(dev);
+	LT8911EXB_LinkTrainResultCheck(dev);
+	LT8911EX_link_train_result(dev);	// for debug
+
+	LT8911EXB_video_check(dev);		// just for Check MIPI Input
+
+	pr_debug("\r\nDpcdRead(0x0202) = 0x%x\r\n",DpcdRead(dev,0x0202));
+
+	PCR_Status(dev);			// just for Check PCR CLK
+
+	return 0;
+}
+
+static int edp_panel_get_display_timing(struct udevice *dev,
+					    struct display_timing *timings)
+{
+	pr_debug("%s: device %s \n", __func__, dev->name);
+	memcpy(timings, &default_timing, sizeof(*timings));
+	return 0;
+}
+
+static int edp_panel_of_to_plat(struct udevice *dev)
+{
+	pr_debug("%s: device %s \n", __func__, dev->name);
+	return 0;
+}
+
+static int edp_panel_probe(struct udevice *dev)
+{
+	struct edp_panel_priv *priv = dev_get_priv(dev);
+	int ret = 0;
+
+	pr_debug("%s: device %s \n", __func__, dev->name);
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0, &priv->reset_gpio,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		pr_info("%s: Warning: cannot get reset GPIO: ret=%d\n",
+		      __func__, ret);
+	}
+
+	ret = gpio_request_by_name(dev, "standby-gpios", 0, &priv->standby_gpio,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		pr_info("%s: Warning: cannot get standy GPIO: ret=%d\n",
+		      __func__, ret);
+	}
+
+	ret = gpio_request_by_name(dev, "enable-gpios", 0, &priv->enable_gpio,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		pr_info("%s: Warning: cannot get enable GPIO: ret=%d\n",
+		      __func__, ret);
+	}
+
+	ret = gpio_request_by_name(dev, "bl-gpios", 0, &priv->bl_gpio,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		pr_info("%s: Warning: cannot get bl GPIO: ret=%d\n",
+		      __func__, ret);
+	}
+
+	dm_gpio_set_value(&priv->enable_gpio, 1);
+	dm_gpio_set_value(&priv->standby_gpio, 1);
+	dm_gpio_set_value(&priv->bl_gpio, 1);
+	mdelay(100);
+
+	Reset_LT8911EXB(dev);
+
+	ret = lt8911exb_i2c_test(dev);
+
+	return ret;
+}
+
+static const struct panel_ops edp_panel_ops = {
+	.enable_backlight = edp_panel_enable_backlight,
+	.get_display_timing = edp_panel_get_display_timing,
+};
+
+static const struct udevice_id edp_panel_ids[] = {
+	{ .compatible = "lontium,lt8911exb" },
+	{ }
+};
+
+U_BOOT_DRIVER(edp_panel) = {
+	.name			= "edp_panel",
+	.id			= UCLASS_PANEL,
+	.of_match		= edp_panel_ids,
+	.ops			= &edp_panel_ops,
+	.of_to_plat		= edp_panel_of_to_plat,
+	.probe			= edp_panel_probe,
+	.plat_auto		= sizeof(struct mipi_dsi_panel_plat),
+	.priv_auto		= sizeof(struct edp_panel_priv),
+};
diff --git a/drivers/video/spacemit/spacemit_mipi.c b/drivers/video/spacemit/spacemit_mipi.c
index 29b0f62d..7d3f0d9a 100644
--- a/drivers/video/spacemit/spacemit_mipi.c
+++ b/drivers/video/spacemit/spacemit_mipi.c
@@ -109,6 +109,9 @@ static int spacemit_mipi_dsi_probe(struct udevice *dev)
 	struct power_domain pm_domain;
 	unsigned long rate;
 	int ret;
+	u32 bit_clk, pix_clk;
+
+	pr_debug("%s: device %s \n", __func__, dev->name);
 
 	ret = power_domain_get(dev, &pm_domain);
 	if (ret) {
@@ -224,7 +227,9 @@ static int spacemit_mipi_dsi_probe(struct udevice *dev)
 		return ret;
 	}
 
-	ret = clk_set_rate(&priv->pxclk, 88000000);
+	pix_clk = dev_read_u32_default(dev, "pix-clk", 88000000);
+	ret = clk_set_rate(&priv->pxclk, pix_clk);
+
 	if (ret < 0) {
 		pr_err("clk_set_rate mipi dsi pxclk failed: %d\n", ret);
 		return ret;
@@ -242,7 +247,8 @@ static int spacemit_mipi_dsi_probe(struct udevice *dev)
 		return ret;
 	}
 
-	ret = clk_set_rate(&priv->bitclk, 614400000);
+	bit_clk = dev_read_u32_default(dev, "bit-clk", 614400000);
+	ret = clk_set_rate(&priv->bitclk, bit_clk);
 	if (ret < 0) {
 		pr_err("clk_set_rate mipi dsi bitclk failed: %d\n", ret);
 		return ret;
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 8fede0e5..fc65d0ac 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -98,6 +98,12 @@ config WDT_SPACEMIT
 	  The watchdog will perform a full SoC reset resulting in a
 	  reboot of the entire system.
 
+config WDT_PMIC_SPACEMIT
+	bool "SPACEMIT pmic watchdog timer support"
+	depends on WDT
+	help
+	  Enable support for the watchdog timer on pmic SoC.
+
 config WDT_ARMADA_37XX
 	bool "Marvell Armada 37xx watchdog timer support"
 	depends on WDT && ARMADA_3700
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index fd4bfb39..7dd11e8c 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -44,3 +44,4 @@ obj-$(CONFIG_WDT_SUNXI) += sunxi_wdt.o
 obj-$(CONFIG_WDT_TANGIER) += tangier_wdt.o
 obj-$(CONFIG_WDT_XILINX) += xilinx_wwdt.o
 obj-$(CONFIG_WDT_SPACEMIT) += spacemit_wdt.o
+obj-$(CONFIG_WDT_PMIC_SPACEMIT) += spacemit_pmic_wdt.o
\ No newline at end of file
diff --git a/drivers/watchdog/spacemit_pmic_wdt.c b/drivers/watchdog/spacemit_pmic_wdt.c
new file mode 100644
index 00000000..e73e4223
--- /dev/null
+++ b/drivers/watchdog/spacemit_pmic_wdt.c
@@ -0,0 +1,274 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <wdt.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <dm/device_compat.h>
+#include <power/spacemit/spacemit_pmic.h>
+#include <power/pmic.h>
+
+enum pmic_model {
+	PMIC_MODEL_UNKNOWN,
+	PMIC_MODEL_SPM8821,
+};
+
+struct pmic_wdt_priv {
+	struct udevice *pmic_dev;
+	fdt_addr_t base;
+	fdt_addr_t pwr_ctrl0;
+	fdt_addr_t pwr_ctrl2;
+	enum pmic_model model;
+};
+
+static int pmic_wdt_initialize(struct udevice *dev, u64 timeout_ms)
+{
+	struct pmic_wdt_priv *priv = dev_get_priv(dev);
+	if (!priv) {
+		pr_err("Failed to get private data\n");
+		return -ENODEV;
+	}
+
+	int ret;
+	uint timeout_val;
+	uint reg_val;
+
+	switch (priv->model) {
+	case PMIC_MODEL_SPM8821:
+		if (timeout_ms <= 1000) {
+			timeout_val = SPM8821_WDT_TIMEOUT_1S;
+		} else if (timeout_ms <= 4000) {
+			timeout_val = SPM8821_WDT_TIMEOUT_4S;
+		} else if (timeout_ms <= 8000) {
+			timeout_val = SPM8821_WDT_TIMEOUT_8S;
+		} else {
+			timeout_val = SPM8821_WDT_TIMEOUT_16S;
+		}
+
+		// Clear the status
+		ret = pmic_reg_read(priv->pmic_dev, priv->base);
+		if (ret < 0) return ret;
+		reg_val = ret | SPM8821_WDT_CLEAR_STATUS;
+		ret = pmic_reg_write(priv->pmic_dev, priv->base, reg_val);
+		if (ret) return ret;
+
+		// Set the timeout value
+		ret = pmic_reg_read(priv->pmic_dev, priv->base);
+		if (ret < 0) return ret;
+		reg_val = (reg_val & ~(0x3 << 1)) | (timeout_val << 1);
+		ret = pmic_reg_write(priv->pmic_dev, priv->base, reg_val);
+		if (ret) return ret;
+
+		// Enable the watchdog
+		ret = pmic_reg_read(priv->pmic_dev, priv->base);
+		if (ret < 0) return ret;
+		reg_val |= SPM8821_WDT_ENABLE;
+		ret = pmic_reg_write(priv->pmic_dev, priv->base, reg_val);
+		if (ret) return ret;
+
+		// Enable watchdog reset
+		ret = pmic_reg_read(priv->pmic_dev, priv->pwr_ctrl0);
+		if (ret < 0) return ret;
+		reg_val = ret | SPM8821_WDT_RESET_ENABLE;
+		ret = pmic_reg_write(priv->pmic_dev, priv->pwr_ctrl0, reg_val);
+		if (ret) return ret;
+
+		break;
+	default:
+		pr_err("Unsupported PMIC model: %d\n", priv->model);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pmic_wdt_reset(struct udevice *dev)
+{
+	struct pmic_wdt_priv *priv = dev_get_priv(dev);
+	if (!priv) {
+		pr_err("Failed to get private data\n");
+		return -ENODEV;
+	}
+
+	int ret;
+	uint reg_val;
+
+	switch (priv->model) {
+	case PMIC_MODEL_SPM8821:
+		/* Clear watchdog timer status */
+		ret = pmic_reg_read(priv->pmic_dev, priv->base);
+		if (ret < 0) return ret;
+		reg_val = ret | SPM8821_WDT_CLEAR_STATUS;
+		ret = pmic_reg_write(priv->pmic_dev, priv->base, reg_val);
+		if (ret) return ret;
+
+		ret = pmic_reg_read(priv->pmic_dev, priv->pwr_ctrl0);
+		if (ret < 0) return ret;
+		reg_val = ret | 0x1;
+		ret = pmic_reg_write(priv->pmic_dev, priv->pwr_ctrl0, reg_val);
+		if (ret) return ret;
+
+		break;
+	default:
+		pr_err("Unsupported PMIC model: %d\n", priv->model);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pmic_wdt_start(struct udevice *dev, u64 timeout_ms, ulong flags)
+{
+	struct pmic_wdt_priv *priv = dev_get_priv(dev);
+	if (!priv) {
+		pr_err("Failed to get private data\n");
+		return -ENODEV;
+	}
+
+	int ret = pmic_wdt_initialize(dev, timeout_ms);
+	if (ret) {
+		return ret;
+	}
+
+	uint value;
+
+	switch (priv->model) {
+	case PMIC_MODEL_SPM8821:
+		/* Start watchdog timer */
+		ret = pmic_reg_read(priv->pmic_dev, priv->base);
+		if (ret < 0) return ret;
+
+		value = ret | SPM8821_WDT_ENABLE;
+		ret = pmic_reg_write(priv->pmic_dev, priv->base, value);
+		if (ret) return ret;
+
+		break;
+	default:
+		pr_err("Unsupported PMIC model: %d\n", priv->model);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pmic_wdt_stop(struct udevice *dev)
+{
+	struct pmic_wdt_priv *priv = dev_get_priv(dev);
+	if (!priv) {
+		pr_err("Failed to get private data\n");
+		return -ENODEV;
+	}
+
+	int ret;
+	uint reg_val;
+
+	switch (priv->model) {
+	case PMIC_MODEL_SPM8821:
+		ret = pmic_reg_read(priv->pmic_dev, priv->base);
+		if (ret < 0) return ret;
+		reg_val = ret & ~SPM8821_WDT_ENABLE;
+		ret = pmic_reg_write(priv->pmic_dev, priv->base, reg_val);
+		if (ret) return ret;
+
+		break;
+	default:
+		pr_err("Unsupported PMIC model: %d\n", priv->model);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pmic_wdt_remove(struct udevice *dev)
+{
+	return pmic_wdt_stop(dev);
+}
+
+static int pmic_wdt_expire_now(struct udevice *dev, ulong flags)
+{
+	struct pmic_wdt_priv *priv = dev_get_priv(dev);
+	if (!priv) {
+		pr_err("Failed to get private data\n");
+		return -ENODEV;
+	}
+
+	int ret;
+	uint reg_val;
+
+	switch (priv->model) {
+	case PMIC_MODEL_SPM8821:
+		/* Set SW_RST bit of PWR_CTRL2 */
+		ret = pmic_reg_read(priv->pmic_dev, priv->pwr_ctrl2);
+		if (ret < 0) return ret;
+		reg_val = ret | SPM8821_SW_RST;
+		ret = pmic_reg_write(priv->pmic_dev, priv->pwr_ctrl2, reg_val);
+		if (ret) return ret;
+
+		mdelay(100);
+
+		break;
+	default:
+		pr_err("Unsupported PMIC model: %d\n", priv->model);
+		return -EINVAL;
+	}
+
+	return -ENODEV;
+}
+
+static int pmic_wdt_probe(struct udevice *dev)
+{
+	struct pmic_wdt_priv *priv = dev_get_priv(dev);
+	if (!priv)
+		return -ENOMEM;
+
+	const char *wdt_name = dev_read_string(dev, "wdt-name");
+	if (!wdt_name) {
+		pr_err("Failed to read wdt-name string\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(wdt_name, "wdt_pm8821") == 0) {
+		priv->model = PMIC_MODEL_SPM8821;
+		priv->base = SPM8821_WDT_CTRL;
+		priv->pwr_ctrl0 = SPM8821_PWR_CTRL0;
+		priv->pwr_ctrl2 = SPM8821_PWR_CTRL2;
+	} else {
+		priv->model = PMIC_MODEL_UNKNOWN;
+		pr_err("Device is not compatible: %s\n", wdt_name);
+		return -EINVAL;
+	}
+
+	/* Get parent PMIC device */
+	priv->pmic_dev = dev_get_parent(dev);
+	if (!priv->pmic_dev) {
+		pr_err("Failed to get parent PMIC device\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static struct wdt_ops pmic_wdt_ops = {
+	.start = pmic_wdt_start,
+	.stop = pmic_wdt_stop,
+	.reset = pmic_wdt_reset,
+	.expire_now = pmic_wdt_expire_now,
+};
+
+static const struct udevice_id pmic_wdt_ids[] = {
+	{ .compatible = "spacemit,k1x-pm8821-wdt" },
+	{ /* sentinel */ }
+};
+
+U_BOOT_DRIVER(pm8xx_wdt) = {
+	.name = "pm8xx_wdt",
+	.id = UCLASS_WDT,
+	.of_match = pmic_wdt_ids,
+	.probe = pmic_wdt_probe,
+	.priv_auto = sizeof(struct pmic_wdt_priv),
+	.ops = &pmic_wdt_ops,
+	.remove = pmic_wdt_remove,
+	.flags  = DM_FLAG_OS_PREPARE,
+};
diff --git a/drivers/watchdog/spacemit_wdt.c b/drivers/watchdog/spacemit_wdt.c
index a7769cce..3a23a983 100644
--- a/drivers/watchdog/spacemit_wdt.c
+++ b/drivers/watchdog/spacemit_wdt.c
@@ -118,7 +118,6 @@ static int spacemit_wdt_start(struct udevice *dev, u64 timeout_ms, ulong flags)
 	return 0;
 }
 
-
 static int spacemit_wdt_stop(struct udevice *dev)
 {
 	struct spacemit_wdt_priv *priv = dev_get_priv(dev);
@@ -132,6 +131,11 @@ static int spacemit_wdt_stop(struct udevice *dev)
 	return 0;
 }
 
+static int spacemit_wdt_remove(struct udevice *dev)
+{
+	return spacemit_wdt_stop(dev);
+}
+
 static int spacemit_wdt_expire_now(struct udevice *dev, ulong flags)
 {
 	initialize_wdt(dev, 0);
@@ -196,4 +200,6 @@ U_BOOT_DRIVER(spacemit_wdt) = {
 	.of_match = spacemit_wdt_ids,
 	.probe = spacemit_wdt_probe,
 	.ops = &spacemit_wdt_ops,
+	.remove = spacemit_wdt_remove,
+	.flags  = DM_FLAG_OS_PREPARE,
 };
diff --git a/include/fb_spacemit.h b/include/fb_spacemit.h
index f07f64db..296ad46b 100644
--- a/include/fb_spacemit.h
+++ b/include/fb_spacemit.h
@@ -290,4 +290,22 @@ void clear_storage_data(char *cmd_parameter, char *response);
 int _write_gpt_partition(struct flash_dev *fdev);
 int _write_mtd_partition(struct flash_dev *fdev);
 
+/**
+ * @brief detect blk dev exist or not.
+ *
+ * @param blk_name try to find blk dev.
+ * @param partition try to find partition exist or not.
+* @return int return partition index while finding partition in blk dev.
+*/
+int detect_blk_dev_or_partition_exist(char *blk_name, int blk_index, char *partition);
+
+/**
+ * @brief try to find available blk dev while defind multi blks at nor boot.
+ *
+ * @param blk_dev return available blk dev.
+ * @param index return available blk index.
+ * @param return return 0 while detect available blk dev.
+*/
+int get_available_blk_dev(char **blk_dev, int *index);
+
 #endif
diff --git a/include/power/spacemit/spm8821.h b/include/power/spacemit/spm8821.h
index ef34b762..b9c2058c 100644
--- a/include/power/spacemit/spm8821.h
+++ b/include/power/spacemit/spm8821.h
@@ -83,6 +83,21 @@
 #define SPM8821_SWITCH_CTRL_REG		0x59
 #define SPM8821_SWTICH_EN_MASK		0x1
 
+/* Watchdog Timer Registers */
+#define SPM8821_WDT_CTRL           0x44
+#define SPM8821_PWR_CTRL0          0x7C
+#define SPM8821_PWR_CTRL2          0x7E
+
+/* Watchdog Timer Control Bits */
+#define SPM8821_WDT_CLEAR_STATUS     0x1
+#define SPM8821_SW_RST               0x2
+#define SPM8821_WDT_RESET_ENABLE     0x80
+#define SPM8821_WDT_ENABLE           0x8
+#define SPM8821_WDT_TIMEOUT_1S       0x0
+#define SPM8821_WDT_TIMEOUT_4S       0x1
+#define SPM8821_WDT_TIMEOUT_8S       0x2
+#define SPM8821_WDT_TIMEOUT_16S      0x3
+
 enum SPM8821_buck_reg {
 	SPM8821_ID_DCDC1,
 	SPM8821_ID_DCDC2,
-- 
2.39.2

From 3e7449e5b68fe755b54fddd59b4ff8abc1458314 Mon Sep 17 00:00:00 2001
From: Lijun Li <lijun.li@spacemit.com>
Date: Tue, 18 Jun 2024 19:10:39 +0800
Subject: [PATCH] display: optimize edp init time

Signed-off-by: Lijun Li <lijun.li@spacemit.com>
---
 .../video/spacemit/dsi/drv/spacemit_dphy.c    |  2 +-
 drivers/video/spacemit/spacemit_dpu.c         |  2 +-
 drivers/video/spacemit/spacemit_edp.c         | 69 ++++++++++---------
 3 files changed, 37 insertions(+), 36 deletions(-)

diff --git a/drivers/video/spacemit/dsi/drv/spacemit_dphy.c b/drivers/video/spacemit/dsi/drv/spacemit_dphy.c
index 1e9cbe9a..c415a8d4 100644
--- a/drivers/video/spacemit/dsi/drv/spacemit_dphy.c
+++ b/drivers/video/spacemit/dsi/drv/spacemit_dphy.c
@@ -78,7 +78,7 @@ static void dphy_set_timing(struct spacemit_dphy_ctx *dphy_ctx)
 	bit_clk = dphy_ctx->phy_freq / 1000;
 	ui = 1000/bit_clk + 1;
 
-	pr_info("%s: esc_clk %d bit_clk %d\n", __func__, esc_clk, bit_clk);
+	pr_debug("%s: esc_clk %d bit_clk %d\n", __func__, esc_clk, bit_clk);
 
 	lpx_clk = (phy_timing->lpx_constant + phy_timing->lpx_ui * ui) / esc_clk_t + 1;
 	lpx_time = lpx_clk * esc_clk_t;
diff --git a/drivers/video/spacemit/spacemit_dpu.c b/drivers/video/spacemit/spacemit_dpu.c
index 9544676e..ed0f88f9 100644
--- a/drivers/video/spacemit/spacemit_dpu.c
+++ b/drivers/video/spacemit/spacemit_dpu.c
@@ -356,7 +356,7 @@ static int spacemit_display_init(struct udevice *dev, ulong fbbase, ofnode ep_no
 		uc_priv->xsize = spacemit_mode->xres;
 		uc_priv->ysize = spacemit_mode->yres;
 
-		pr_info("%s: panel type %d\n", __func__, fbi.tx->panel_type);
+		pr_debug("%s: panel type %d\n", __func__, fbi.tx->panel_type);
 
 		if (fbi.tx->panel_type == LCD_MIPI) {
 			dsi_dpu_init(spacemit_mode, fbbase);
diff --git a/drivers/video/spacemit/spacemit_edp.c b/drivers/video/spacemit/spacemit_edp.c
index b9b04f80..0f382bb0 100644
--- a/drivers/video/spacemit/spacemit_edp.c
+++ b/drivers/video/spacemit/spacemit_edp.c
@@ -80,7 +80,7 @@ static u8 LT8911EXB_IIC_Read_byte(struct udevice *dev, u8 reg)
 	err = dm_i2c_read(dev, reg, &valb, 1);
 	if (err)
 		return err;
-	mdelay(10);
+	udelay(100);
 
 	return (int)valb;
 
@@ -89,7 +89,7 @@ static u8 LT8911EXB_IIC_Read_byte(struct udevice *dev, u8 reg)
 static void LT8911EXB_IIC_Write_byte(struct udevice *dev,u8 reg, u8 val)
 {
 	dm_i2c_write(dev, reg, &val, 1);
-	mdelay(10);
+	udelay(100);
 }
 
 enum {
@@ -158,9 +158,9 @@ void Reset_LT8911EXB(struct udevice *dev)
 	pr_debug("%s: device %s\n", __func__, dev->name);
 
 	dm_gpio_set_value(&priv->reset_gpio, 1);
-	mdelay(150);
+	mdelay(50);
 	dm_gpio_set_value(&priv->reset_gpio, 0);
-	mdelay(150);
+	mdelay(50);
 	dm_gpio_set_value(&priv->reset_gpio, 1);
 	mdelay(150);
 
@@ -721,7 +721,8 @@ void LT8911EXB_video_check(struct udevice *dev)
 	LT8911EXB_IIC_Write_byte(dev, 0x09, 0xfd );
 
 	LT8911EXB_IIC_Write_byte(dev, 0xff, 0x85 );
-	mdelay( 200 );
+
+	mdelay(100);
 	if( LT8911EXB_IIC_Read_byte(dev, 0x50 ) == 0x03 )
 	{
 		reg	   = LT8911EXB_IIC_Read_byte(dev, 0x4d );
@@ -907,33 +908,33 @@ void LT8911EX_link_train(struct udevice *dev)
 #endif
 }
 
-void LT8911EX_link_train_result(struct udevice *dev)
-{
-	u8 i, reg;
-	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
-	for( i = 0; i < 10; i++ )
-	{
-		reg = LT8911EXB_IIC_Read_byte(dev, 0x82 );
-		if( reg & 0x20 )
-		{
-			if( ( reg & 0x1f ) == 0x1e )
-			{
-				pr_debug( "\r\nLink train success, 0x82 = 0x%x", reg );
-			} else
-			{
-				pr_debug( "\r\nLink train fail, 0x82 = 0x%x", reg );
-			}
-
-			pr_debug( "\r\npanel link rate: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x83 ) );
-			pr_debug( "\r\npanel link count: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x84 ) );
-			return;
-		}else
-		{
-			pr_debug( "\r\nlink trian on going..." );
-		}
-		mdelay( 100 );
-	}
-}
+// void LT8911EX_link_train_result(struct udevice *dev)
+// {
+// 	u8 i, reg;
+// 	LT8911EXB_IIC_Write_byte(dev, 0xff, 0xac );
+// 	for( i = 0; i < 10; i++ )
+// 	{
+// 		reg = LT8911EXB_IIC_Read_byte(dev, 0x82 );
+// 		if( reg & 0x20 )
+// 		{
+// 			if( ( reg & 0x1f ) == 0x1e )
+// 			{
+// 				pr_debug( "\r\nLink train success, 0x82 = 0x%x", reg );
+// 			} else
+// 			{
+// 				pr_debug( "\r\nLink train fail, 0x82 = 0x%x", reg );
+// 			}
+
+// 			pr_debug( "\r\npanel link rate: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x83 ) );
+// 			pr_debug( "\r\npanel link count: 0x%x", LT8911EXB_IIC_Read_byte(dev, 0x84 ) );
+// 			return;
+// 		}else
+// 		{
+// 			pr_debug( "\r\nlink trian on going..." );
+// 		}
+// 		mdelay( 100 );
+// 	}
+// }
 
 enum
 {
@@ -1062,7 +1063,7 @@ static int edp_panel_enable_backlight(struct udevice *dev)
 	ScrambleMode = 0;
 	LT8911EX_link_train(dev);
 	LT8911EXB_LinkTrainResultCheck(dev);
-	LT8911EX_link_train_result(dev);	// for debug
+	// LT8911EX_link_train_result(dev);	// for debug
 
 	LT8911EXB_video_check(dev);		// just for Check MIPI Input
 
@@ -1125,7 +1126,7 @@ static int edp_panel_probe(struct udevice *dev)
 	dm_gpio_set_value(&priv->enable_gpio, 1);
 	dm_gpio_set_value(&priv->standby_gpio, 1);
 	dm_gpio_set_value(&priv->bl_gpio, 1);
-	mdelay(100);
+	mdelay(50);
 
 	Reset_LT8911EXB(dev);
 
-- 
2.39.2

From 34b213294c2ca1e8e15251f26e05863d3a00fa49 Mon Sep 17 00:00:00 2001
From: zhangmeng <zhangmeng.kevin@spacemit.com>
Date: Tue, 18 Jun 2024 12:29:18 +0800
Subject: [PATCH] muse-book: delete battery device node from board dts

Signed-off-by: zhangmeng <zhangmeng.kevin@spacemit.com>
---
 arch/riscv/dts/k1-x_MUSE-Book.dts | 14 --------------
 1 file changed, 14 deletions(-)

diff --git a/arch/riscv/dts/k1-x_MUSE-Book.dts b/arch/riscv/dts/k1-x_MUSE-Book.dts
index 90e46cdd..78718be4 100644
--- a/arch/riscv/dts/k1-x_MUSE-Book.dts
+++ b/arch/riscv/dts/k1-x_MUSE-Book.dts
@@ -64,20 +64,6 @@
 	};
 };
 
-&i2c4 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c4_2>;
-	clock-frequency = <400000>;
-	status = "okay";
-
-	battery: battery@b {
-		compatible = "sbs,sbs-battery";
-		reg = <0x0b>;
-		sbs,i2c-retry-count = <2>;
-		sbs,poll-retry-count = <1>;
-	};
-};
-
 &i2c6 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c6_2>;
-- 
2.39.2

