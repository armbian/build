From a5e197e1a6b576e75f5a916f64fbc4717b5f3ca1 Mon Sep 17 00:00:00 2001
From: James Deng <james.deng@spacemit.com>
Date: Sat, 29 Jun 2024 09:30:51 +0800
Subject: [PATCH] Update for v1.0.5

Signed-off-by: James Deng <james.deng@spacemit.com>
---
 arch/riscv/dts/Makefile                       |   3 +-
 arch/riscv/dts/k1-x.dtsi                      |  16 +-
 arch/riscv/dts/k1-x_MUSE-Book.dts             |   2 +-
 arch/riscv/dts/k1-x_MUSE-N1.dts               |   4 +-
 arch/riscv/dts/k1-x_lpi3a.dts                 | 284 ++++++++++++++++++
 arch/riscv/dts/k1-x_pm853.dtsi                |   4 +-
 arch/riscv/dts/k1-x_spl.dts                   |   5 +-
 arch/riscv/dts/k1-x_spm8821.dtsi              |   2 +-
 arch/riscv/dts/m1-x_milkv-jupiter.dts         | 284 ++++++++++++++++++
 board/spacemit/k1-x/Kconfig                   |   4 -
 board/spacemit/k1-x/configs/uboot_fdt.its     |  29 ++
 board/spacemit/k1-x/k1-x.env                  |   6 +-
 board/spacemit/k1-x/k1x.c                     |  22 --
 board/spacemit/k1-x/spl.c                     |  31 +-
 cmd/spacemit_flash.c                          |   2 +
 configs/k1_defconfig                          |  10 +-
 drivers/ddr/spacemit/k1x/ddr_freq.c           |  48 +--
 drivers/ddr/spacemit/k1x/ddr_init.c           |  12 +-
 drivers/ddr/spacemit/k1x/ddr_init_asic.h      |  26 ++
 .../ddr/spacemit/k1x/lpddr4_silicon_init.c    | 211 +++++++++++--
 drivers/fastboot/fb_mtd.c                     |  33 +-
 drivers/fastboot/fb_spacemit.c                |   1 +
 drivers/mmc/mmc.c                             |  24 +-
 drivers/mmc/mmc_write.c                       |  23 +-
 drivers/nvme/nvme.c                           |  52 ++--
 include/configs/k1-x.h                        |  15 +-
 26 files changed, 992 insertions(+), 161 deletions(-)
 create mode 100644 arch/riscv/dts/k1-x_lpi3a.dts
 create mode 100644 arch/riscv/dts/m1-x_milkv-jupiter.dts

diff --git a/arch/riscv/dts/Makefile b/arch/riscv/dts/Makefile
index 99309182..02d5855f 100644
--- a/arch/riscv/dts/Makefile
+++ b/arch/riscv/dts/Makefile
@@ -11,7 +11,8 @@ dtb-$(CONFIG_TARGET_SPACEMIT_K1PRO) += k1-pro_qemu.dtb k1-pro_sim.dtb k1-pro_fpg
 dtb-$(CONFIG_TARGET_SPACEMIT_K1X) += k1-x_evb.dtb k1-x_deb2.dtb k1-x_deb1.dtb k1-x_hs450.dtb \
 				     k1-x_kx312.dtb k1-x_MINI-PC.dtb k1-x_mingo.dtb k1-x_MUSE-N1.dtb \
 				     k1-x_MUSE-Pi.dtb k1-x_spl.dtb k1-x_milkv-jupiter.dtb \
-				     k1-x_MUSE-Book.dtb
+				     k1-x_MUSE-Book.dtb m1-x_milkv-jupiter.dtb \
+				     k1-x_lpi3a.dtb
 
 include $(srctree)/scripts/Makefile.dts
 
diff --git a/arch/riscv/dts/k1-x.dtsi b/arch/riscv/dts/k1-x.dtsi
index c462a053..54cde04a 100644
--- a/arch/riscv/dts/k1-x.dtsi
+++ b/arch/riscv/dts/k1-x.dtsi
@@ -28,7 +28,7 @@
 			device_type = "cpu";
 			reg = <0>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu0_intc: interrupt-controller {
@@ -42,7 +42,7 @@
 			device_type = "cpu";
 			reg = <1>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu1_intc: interrupt-controller {
@@ -56,7 +56,7 @@
 			device_type = "cpu";
 			reg = <2>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu2_intc: interrupt-controller {
@@ -70,7 +70,7 @@
 			device_type = "cpu";
 			reg = <3>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu3_intc: interrupt-controller {
@@ -84,7 +84,7 @@
 			device_type = "cpu";
 			reg = <4>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu4_intc: interrupt-controller {
@@ -98,7 +98,7 @@
 			device_type = "cpu";
 			reg = <5>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu5_intc: interrupt-controller {
@@ -112,7 +112,7 @@
 			device_type = "cpu";
 			reg = <6>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu6_intc: interrupt-controller {
@@ -126,7 +126,7 @@
 			device_type = "cpu";
 			reg = <7>;
 			status = "okay";
-			riscv,isa = "rv64imafdcv_zicsr_zifencei_zicbom_zicboz_zicbop_zihintpause_zicond_zba_zbb_zbc_zbs_svpbmt_sstc_sscofpmf";
+			riscv,isa = "rv64imafdcv";
 			mmu-type = "riscv,sv39";
 
 			cpu7_intc: interrupt-controller {
diff --git a/arch/riscv/dts/k1-x_MUSE-Book.dts b/arch/riscv/dts/k1-x_MUSE-Book.dts
index 78718be4..25246966 100644
--- a/arch/riscv/dts/k1-x_MUSE-Book.dts
+++ b/arch/riscv/dts/k1-x_MUSE-Book.dts
@@ -8,7 +8,7 @@
 #include "k1-x_spm8821.dtsi"
 
 / {
-	model = "k1-x_MUSE-Book";
+	model = "M1-MUSE-BOOK";
 
 	aliases {
 		efuse_power = &ldo_31;
diff --git a/arch/riscv/dts/k1-x_MUSE-N1.dts b/arch/riscv/dts/k1-x_MUSE-N1.dts
index 530ff4c1..6051fb58 100644
--- a/arch/riscv/dts/k1-x_MUSE-N1.dts
+++ b/arch/riscv/dts/k1-x_MUSE-N1.dts
@@ -190,13 +190,13 @@
 &pcie1_rc {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_pcie1_3>;
-	status = "okay";
+	status = "disabled";
 };
 
 &pcie2_rc {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_pcie2_4>;
-	status = "okay";
+	status = "disabled";
 };
 
 &qspi {
diff --git a/arch/riscv/dts/k1-x_lpi3a.dts b/arch/riscv/dts/k1-x_lpi3a.dts
new file mode 100644
index 00000000..7952ba84
--- /dev/null
+++ b/arch/riscv/dts/k1-x_lpi3a.dts
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "k1-x_spm8821.dtsi"
+
+/ {
+	model = "SiPEED LPi3A board";
+
+	aliases {
+		efuse_power = &ldo_31;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x80000000>;
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200 debug loglevel=8,initcall_debug=1 rdinit=/init.tmp";
+		stdout-path = "serial0:115200n8";
+	};
+
+	usb3hub:usb3hub {
+		compatible = "spacemit,usb-hub";
+		hub-gpios = <
+			&gpio 123 0	/* usb3 hub en */
+			&gpio 124 0>;	/* usb3 hub rst*/
+		vbus-gpios = <&gpio 97 0>;	/* gpio_97 for usb3 hub output vbus */
+		regulator-force-boot-off;
+		vbus_delay_ms = <250>;
+		status = "okay";
+	};
+};
+
+&cpu_0 {
+	/* boot frequency for cluster-0, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster0 = <1228000>;
+	/* boot frequency for cluster-1, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster1 = <1228000>;
+};
+
+&dramc {
+	/* dram data rate, should be 1200, 1600, or 2400 */
+	datarate = <2400>;
+};
+
+&cpus {
+	timebase-frequency = <24000000>;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&i2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		vin-supply-names = "eeprom_1v8";
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&i2c4 {
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&i2c6 {
+	status = "disabled";
+};
+
+&i2c7 {
+	status = "disabled";
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_66  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range DVL1     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	usbp1_vbus: usbp1_vbus {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_NONE | PULL_UP | PAD_1V8_DS2))    /* drive_vbus1_iso */
+		>;
+	};
+
+	gpio80_pmx_func0: gpio80_pmx_func0 {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_80, MUX_MODE0, (EDGE_BOTH | PULL_UP | PAD_3V_DS4))  /* mmc cd */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49 GPIO_49 2
+		&pinctrl 58 GPIO_58 1
+		&pinctrl 63 GPIO_63 5
+		&pinctrl 70 PRI_TDI 4
+		&pinctrl 74 GPIO_74 1
+		&pinctrl 80 GPIO_80 4
+		&pinctrl 90 GPIO_90 3
+		&pinctrl 96 DVL0 2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 123 GPIO_123 5
+	>;
+};
+
+&udc {
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	status = "okay";
+};
+
+&usbdrd3 {
+	status = "okay";
+	vbus-supply = <&usb3hub>;
+	dwc3@c0a00000 {
+		dr_mode = "host";
+		phy_type = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+	};
+};
+
+&sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc1 &gpio80_pmx_func0>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	cd-inverted;
+	cap-sd-highspeed;
+	sdh-phy-module = <0>;
+	clk-src-freq = <204800000>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	sdh-phy-module = <1>;
+	clk-src-freq = <375000000>;
+	status = "okay";
+};
+
+&eth0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac0>;
+
+	phy-reset-pin = <110>;
+
+	clk_tuning_enable;
+	clk-tuning-by-delayline;
+	tx-phase = <90>;
+	rx-phase = <73>;
+
+	phy-mode = "rgmii";
+	phy-addr = <1>;
+	phy-handle = <&rgmii>;
+
+	ref-clock-from-phy;
+
+	mdio {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii: phy@0 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+		};
+	};
+};
+
+&pcie0_rc {
+	status = "disabled";
+};
+
+&pcie1_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie1_3>;
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+&efuse {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "disabled";
+};
+
+&panel {
+	dcp-gpios = <&gpio 82 0>;
+	dcn-gpios = <&gpio 83 0>;
+	bl-gpios = <&gpio 44 0>;
+	reset-gpios = <&gpio 81 0>;
+	status = "disabled";
+};
diff --git a/arch/riscv/dts/k1-x_pm853.dtsi b/arch/riscv/dts/k1-x_pm853.dtsi
index 27859866..fac8d0c2 100644
--- a/arch/riscv/dts/k1-x_pm853.dtsi
+++ b/arch/riscv/dts/k1-x_pm853.dtsi
@@ -18,7 +18,7 @@
 				regulator-name = "dcdc1";
 				regulator-min-microvolt = <480000>;
 				regulator-max-microvolt = <3160000>;
-				regulator-init-microvolt = <950000>;
+				regulator-init-microvolt = <1050000>;
 				regulator-boot-on;
 				u-boot,dm-spl;
 				regulator-state-mem {
@@ -243,7 +243,7 @@
 				regulator-name = "edcdc1";
 				regulator-min-microvolt = <600000>;
 				regulator-max-microvolt = <1500000>;
-				regulator-init-microvolt = <950000>;
+				regulator-init-microvolt = <1050000>;
 				regulator-boot-on;
 				u-boot,dm-spl;
 				regulator-state-mem {
diff --git a/arch/riscv/dts/k1-x_spl.dts b/arch/riscv/dts/k1-x_spl.dts
index fe5d9993..d18a6256 100644
--- a/arch/riscv/dts/k1-x_spl.dts
+++ b/arch/riscv/dts/k1-x_spl.dts
@@ -23,9 +23,9 @@
 
 	cpu@0 {
 		/* boot frequency for cluster-0, should be 1600000, 1228000, 819000, or 614000 */
-		boot_freq_cluster0 = <1228000>;
+		boot_freq_cluster0 = <1600000>;
 		/* boot frequency for cluster-1, should be 1600000, 1228000, 819000, or 614000 */
-		boot_freq_cluster1 = <1228000>;
+		boot_freq_cluster1 = <1600000>;
 		u-boot,dm-spl;
 	};
 };
@@ -80,6 +80,7 @@
 		/* dram data rate, should be 1200, 1600, or 2400 */
 		datarate = <2400>;
 		cs-num = <2>;
+		type = "LPDDR4X";
 		u-boot,dm-spl;
 	};
 
diff --git a/arch/riscv/dts/k1-x_spm8821.dtsi b/arch/riscv/dts/k1-x_spm8821.dtsi
index beadf044..6bb780a2 100644
--- a/arch/riscv/dts/k1-x_spm8821.dtsi
+++ b/arch/riscv/dts/k1-x_spm8821.dtsi
@@ -18,7 +18,7 @@
 				regulator-name = "dcdc1";
 				regulator-min-microvolt = <500000>;
 				regulator-max-microvolt = <3450000>;
-				regulator-init-microvolt = <950000>;
+				regulator-init-microvolt = <1050000>;
 				regulator-boot-on;
 				u-boot,dm-spl;
 				regulator-state-mem {
diff --git a/arch/riscv/dts/m1-x_milkv-jupiter.dts b/arch/riscv/dts/m1-x_milkv-jupiter.dts
new file mode 100644
index 00000000..06484ade
--- /dev/null
+++ b/arch/riscv/dts/m1-x_milkv-jupiter.dts
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "k1-x_spm8821.dtsi"
+
+/ {
+	model = "Milk-V(M1) Jupiter";
+
+	aliases {
+		efuse_power = &ldo_31;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x80000000>;
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200 debug loglevel=8,initcall_debug=1 rdinit=/init.tmp";
+		stdout-path = "serial0:115200n8";
+	};
+
+	usb3hub:usb3hub {
+		compatible = "spacemit,usb-hub";
+		hub-gpios = <
+			&gpio 123 0	/* usb3 hub en */
+			&gpio 124 0>;	/* usb3 hub rst*/
+		vbus-gpios = <&gpio 97 0>;	/* gpio_97 for usb3 hub output vbus */
+		regulator-force-boot-off;
+		vbus_delay_ms = <250>;
+		status = "okay";
+	};
+};
+
+&cpu_0 {
+	/* boot frequency for cluster-0, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster0 = <1228000>;
+	/* boot frequency for cluster-1, should be 1600000, 1228000, 819000, or 614000 */
+	boot_freq_cluster1 = <1228000>;
+};
+
+&dramc {
+	/* dram data rate, should be 1200, 1600, or 2400 */
+	datarate = <2400>;
+};
+
+&cpus {
+	timebase-frequency = <24000000>;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&i2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c04";
+		reg = <0x50>;
+		vin-supply-names = "eeprom_1v8";
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&i2c4 {
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&i2c6 {
+	status = "disabled";
+};
+
+&i2c7 {
+	status = "disabled";
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_66  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range DVL1     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	usbp1_vbus: usbp1_vbus {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_NONE | PULL_UP | PAD_1V8_DS2))    /* drive_vbus1_iso */
+		>;
+	};
+
+	gpio80_pmx_func0: gpio80_pmx_func0 {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_80, MUX_MODE0, (EDGE_BOTH | PULL_UP | PAD_3V_DS4))  /* mmc cd */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49 GPIO_49 2
+		&pinctrl 58 GPIO_58 1
+		&pinctrl 63 GPIO_63 5
+		&pinctrl 70 PRI_TDI 4
+		&pinctrl 74 GPIO_74 1
+		&pinctrl 80 GPIO_80 4
+		&pinctrl 90 GPIO_90 3
+		&pinctrl 96 DVL0 2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 123 GPIO_123 5
+	>;
+};
+
+&udc {
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	status = "okay";
+};
+
+&usbdrd3 {
+	status = "okay";
+	vbus-supply = <&usb3hub>;
+	dwc3@c0a00000 {
+		dr_mode = "host";
+		phy_type = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+	};
+};
+
+&sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc1 &gpio80_pmx_func0>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	cd-inverted;
+	cap-sd-highspeed;
+	sdh-phy-module = <0>;
+	clk-src-freq = <204800000>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	sdh-phy-module = <1>;
+	clk-src-freq = <375000000>;
+	status = "okay";
+};
+
+&eth0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac0>;
+
+	phy-reset-pin = <110>;
+
+	clk_tuning_enable;
+	clk-tuning-by-delayline;
+	tx-phase = <90>;
+	rx-phase = <73>;
+
+	phy-mode = "rgmii";
+	phy-addr = <1>;
+	phy-handle = <&rgmii>;
+
+	ref-clock-from-phy;
+
+	mdio {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii: phy@0 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+		};
+	};
+};
+
+&pcie0_rc {
+	status = "disabled";
+};
+
+&pcie1_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie1_3>;
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+&efuse {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "disabled";
+};
+
+&panel {
+	dcp-gpios = <&gpio 82 0>;
+	dcn-gpios = <&gpio 83 0>;
+	bl-gpios = <&gpio 44 0>;
+	reset-gpios = <&gpio 81 0>;
+	status = "disabled";
+};
diff --git a/board/spacemit/k1-x/Kconfig b/board/spacemit/k1-x/Kconfig
index 94866b5a..daf3f988 100644
--- a/board/spacemit/k1-x/Kconfig
+++ b/board/spacemit/k1-x/Kconfig
@@ -12,10 +12,6 @@ config SYS_CPU
 config SYS_CONFIG_NAME
 	default "k1-x"
 
-config K1_X_BOARD_DEFAULT_SN
-	string "k1-x board default serial number"
-	default "0000000000000000"
-
 config SYS_TEXT_BASE
 	default 0x81200000 if SPL
 	default 0x80000000 if !RISCV_SMODE
diff --git a/board/spacemit/k1-x/configs/uboot_fdt.its b/board/spacemit/k1-x/configs/uboot_fdt.its
index 61799904..fc4033c7 100644
--- a/board/spacemit/k1-x/configs/uboot_fdt.its
+++ b/board/spacemit/k1-x/configs/uboot_fdt.its
@@ -118,6 +118,24 @@
 				algo = "crc32";
 			};
 		};
+		fdt_12 {
+                        description = "m1-x_milkv-jupiter";
+                        type = "flat_dt";
+                        compression = "none";
+                        data = /incbin/("../dtb/m1-x_milkv-jupiter.dtb");
+                        hash-1 {
+                                algo = "crc32";
+                        };
+		};
+		fdt_13 {
+                        description = "k1-x_lpi3a";
+                        type = "flat_dt";
+                        compression = "none";
+                        data = /incbin/("../dtb/k1-x_lpi3a.dtb");
+                        hash-1 {
+                                algo = "crc32";
+                        };
+                };
 	};
 
 	configurations {
@@ -177,5 +195,16 @@
 			loadables = "uboot";
 			fdt = "fdt_11";
 		};
+		conf_12 {
+                        description = "m1-x_milkv-jupiter";
+                        loadables = "uboot";
+                        fdt = "fdt_12";
+                };
+		 conf_13 {
+                        description = "k1-x_lpi3a";
+                        loadables = "uboot";
+                        fdt = "fdt_13";
+                };
+
 	};
 };
diff --git a/board/spacemit/k1-x/k1x.c b/board/spacemit/k1-x/k1x.c
index 2d6ed099..8a42f5d8 100644
--- a/board/spacemit/k1-x/k1x.c
+++ b/board/spacemit/k1-x/k1x.c
@@ -722,9 +722,6 @@ void set_dev_serial_no(uint8_t *eeprom_data)
 		env_set("serial#", strval);
 		free(strval);
 	}
-	else {
-		env_set("serial#", CONFIG_K1_X_BOARD_DEFAULT_SN);
-	}
 }
 
 struct code_desc_info {
@@ -931,25 +928,6 @@ enum env_location env_get_location(enum env_operation op, int prio)
 
 int misc_init_r(void)
 {
-#ifdef CONFIG_DYNAMIC_DDR_CLK_FREQ
-	int ret;
-	char cmd[32];
-
-	ret = ddr_freq_max();
-	if(ret < 0) {
-		pr_debug("%s: Try to adjust ddr freq failed!\n", __func__);
-		return ret;
-	}
-
-	// change DDR data rate to 2400MT/s and set
-	sprintf(cmd, "ddrfreq %d", 6);
-	pr_debug("cmd:%s\n", cmd);
-	if (run_command(cmd, 0)) {
-			pr_err("DDR frequency change fail\n");
-			return -1;
-	}
-#endif
-
 	return 0;
 }
 
diff --git a/board/spacemit/k1-x/spl.c b/board/spacemit/k1-x/spl.c
index f03022c3..7993f8ce 100644
--- a/board/spacemit/k1-x/spl.c
+++ b/board/spacemit/k1-x/spl.c
@@ -82,11 +82,12 @@ extern int __data_start[], __data_end[];
 extern int k1x_eeprom_init(void);
 extern int spacemit_eeprom_read(uint8_t chip, uint8_t *buffer, uint8_t id);
 extern bool get_mac_address(uint64_t *mac_addr);
-extern bool get_ddr_cs_number(uint32_t *cs_num);
+extern void update_ddr_info(void);
 extern enum board_boot_mode get_boot_storage(void);
 extern int spl_mtd_read(struct mtd_info *mtd, ulong sector, ulong count, void *buf);
 char *product_name;
 extern u32 ddr_cs_num;
+extern const char *ddr_type;
 
 int timer_init(void)
 {
@@ -462,9 +463,7 @@ int spl_board_init_f(void)
 #endif
 	// get_mac_address(&mac_addr);
 
-	// if fail to get ddr cs number from eeprom, update it from dts node
-	if (!get_ddr_cs_number(&ddr_cs_num))
-		ddr_cs_num = 0;
+	update_ddr_info();
 
 	// restore prevous saved ddr training info data
 	// flag = restore_ddr_training_info(chipid, mac_addr);
@@ -669,18 +668,28 @@ char *get_product_name(void)
 	return NULL;
 }
 
-bool get_ddr_cs_number(uint32_t *cs_num)
+void update_ddr_info(void)
 {
 	int eeprom_addr;
+	uint8_t *info;
 
 	eeprom_addr = k1x_eeprom_init();
-	if ((eeprom_addr >= 0) && (NULL != cs_num) && (0 == spacemit_eeprom_read(
-		eeprom_addr, (uint8_t*)cs_num, TLV_CODE_DDR_CSNUM))) {
-		pr_info("Get ddr cs num %d from eeprom\n", *cs_num);
-		return true;
-	}
+	if (eeprom_addr < 0)
+		return;
 
-	return false;
+	// read ddr type from eeprom
+	info = malloc(32);
+	memset(info, 0, 32);
+	if (0 == spacemit_eeprom_read(eeprom_addr, info, TLV_CODE_DDR_TYPE))
+		ddr_type = info;
+	else
+		free(info);
+
+	// if fail to get ddr cs number from eeprom, update it from dts node
+	if (0 == spacemit_eeprom_read(eeprom_addr, (uint8_t*)&ddr_cs_num, TLV_CODE_DDR_CSNUM))
+		pr_info("Get ddr cs num %d from eeprom\n", ddr_cs_num);
+	else
+		ddr_cs_num = 0;
 }
 
 void spl_board_init(void)
diff --git a/cmd/spacemit_flash.c b/cmd/spacemit_flash.c
index 3695598e..1da11394 100644
--- a/cmd/spacemit_flash.c
+++ b/cmd/spacemit_flash.c
@@ -28,6 +28,7 @@
 #include <mtd.h>
 #include <fb_mtd.h>
 #include <nvme.h>
+#include <watchdog.h>
 
 static int dev_emmc_num = -1;
 static int dev_sdio_num = -1;
@@ -365,6 +366,7 @@ void recovery_show_result(struct flash_dev *fdev, int ret)
 
 	while(1){
 		/* do not retrun while flashing over! */
+		WATCHDOG_RESET();
 	}
 
 }
diff --git a/configs/k1_defconfig b/configs/k1_defconfig
index 629d04cb..9a90a13b 100644
--- a/configs/k1_defconfig
+++ b/configs/k1_defconfig
@@ -29,7 +29,7 @@ CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x1000000
 CONFIG_STACK_SIZE=0x100000
 CONFIG_FIT=y
 CONFIG_SPL_FIT_SIGNATURE=y
-CONFIG_SPL_LOAD_FIT_ADDRESS=0x20000000
+CONFIG_SPL_LOAD_FIT_ADDRESS=0x11000000
 # CONFIG_BOOTSTD is not set
 CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_SUPPORT_RAW_INITRD=y
@@ -37,7 +37,7 @@ CONFIG_BOOTDELAY=0
 CONFIG_AUTOBOOT_KEYED=y
 CONFIG_AUTOBOOT_STOP_STR="s"
 CONFIG_USE_BOOTCOMMAND=y
-CONFIG_BOOTCOMMAND="bootm 0x20000000"
+CONFIG_BOOTCOMMAND="bootm 0x11000000"
 CONFIG_LOGLEVEL=7
 CONFIG_SPL_LOGLEVEL=1
 # CONFIG_SYS_DEVICE_NULLDEV is not set
@@ -80,7 +80,7 @@ CONFIG_SYS_CBSIZE=256
 CONFIG_SYS_PBSIZE=276
 # CONFIG_CMD_CPU is not set
 CONFIG_CMD_TLV_EEPROM=y
-CONFIG_SYS_BOOTM_LEN=0xa000000
+CONFIG_SYS_BOOTM_LEN=0x10000000
 CONFIG_CMD_EEPROM=y
 CONFIG_CMD_MD5SUM=y
 CONFIG_CMD_ZIP=y
@@ -145,8 +145,8 @@ CONFIG_DYNAMIC_DDR_CLK_FREQ=y
 CONFIG_DMA=y
 CONFIG_DMA_CHANNELS=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
-CONFIG_FASTBOOT_BUF_ADDR=0x20000000
-CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_BUF_ADDR=0x11000000
+CONFIG_FASTBOOT_BUF_SIZE=0x10000000
 CONFIG_FASTBOOT_FLASH=y
 CONFIG_FASTBOOT_MULTI_FLASH_OPTION=y
 CONFIG_FASTBOOT_FLASH_MMC_DEV=2
diff --git a/drivers/ddr/spacemit/k1x/ddr_freq.c b/drivers/ddr/spacemit/k1x/ddr_freq.c
index 4a25f511..d63a1c65 100644
--- a/drivers/ddr/spacemit/k1x/ddr_freq.c
+++ b/drivers/ddr/spacemit/k1x/ddr_freq.c
@@ -102,6 +102,7 @@ enum DCLK_BYPASS_sel {
 #define FREQ_MAX		~(0U)
 
 u32 ddr_cs_num = DDR_CS_NUM;
+const char *ddr_type;
 
 static u32 mode_register_read(u32 MR, u32 CH, u32 CS)
 {
@@ -205,8 +206,8 @@ u32 ddr_get_density(void)
 	io_width_cs00 = mr8_cs00 ? mr8_cs00 >> 6 : 0;
 	io_width_cs01 = mr8_cs01 ? mr8_cs01 >> 6 : 0;
 
-	cs0_size = mr8_cs00 ? format_size(((mr8_cs00 >> 2) & 0xf), io_width_cs00) : 0;
-	cs0_size += mr8_cs01 ? format_size(((mr8_cs01 >> 2) & 0xf), io_width_cs01) : 0;
+	cs0_size = (mr8_cs00 != 0xFF) ? format_size(((mr8_cs00 >> 2) & 0xf), io_width_cs00) : 0;
+	cs0_size += (mr8_cs01 != 0xFF) ? format_size(((mr8_cs01 >> 2) & 0xf), io_width_cs01) : 0;
 
 	if (ddr_cs_num > 1) {
 		mr8_cs10 = mode_register_read(8, 0, 1);
@@ -215,8 +216,8 @@ u32 ddr_get_density(void)
 		io_width_cs10 = mr8_cs10 ? mr8_cs10 >> 6 : 0;
 		io_width_cs11 = mr8_cs11 ? mr8_cs11 >> 6 : 0;
 
-		cs1_size = mr8_cs10 ? format_size(((mr8_cs10 >> 2) & 0xf), io_width_cs10) : 0;
-		cs1_size += mr8_cs11 ? format_size(((mr8_cs11 >> 2) & 0xf), io_width_cs11) : 0;
+		cs1_size = (mr8_cs10 != 0xFF) ? format_size(((mr8_cs10 >> 2) & 0xf), io_width_cs10) : 0;
+		cs1_size += (mr8_cs11 != 0xFF) ? format_size(((mr8_cs11 >> 2) & 0xf), io_width_cs11) : 0;
 	}
 #else
 	cs0_size = map_format_size(readl((void*)0xc0000000 + 0x200));
@@ -252,12 +253,10 @@ uint32_t get_ddr_rev_id(void)
 /* adjust ddr frequency to the max value */
 int ddr_freq_max(void)
 {
-//	return ddr_freq_change(MAX_FREQ_LV - 1);
+//	return ddr_freq_change(freq_levels[MAX_FREQ_LV - 1].data_rate);
 	return 0;
 }
 
-#ifndef CONFIG_SPL_BUILD
-
 static struct dfc_level_config freq_levels[MAX_FREQ_LV] =
 {
 /*	freq_lv, timing, pll, pll_div, data_rate, high_freq, vol_lv */
@@ -281,6 +280,17 @@ static int get_cur_freq_level(void)
 	return level;
 }
 
+static int get_datarate_freq_level(uint32_t data_rate)
+{
+	int i;
+	for (i = ARRAY_SIZE(freq_levels) - 1; i >= 0; i--) {
+		if (data_rate >= freq_levels[i].data_rate)
+			return freq_levels[i].freq_lv;
+	}
+
+	return freq_levels[1].freq_lv;
+}
+
 static int dfc_bypass_conf(struct dfc_level_config *cfg)
 {
 	int bypass_sel, timeout = 1000;
@@ -498,9 +508,9 @@ static int ddr_freq_init(void)
 	return 0;
 }
 
-static int ddr_freq_change(u32 freq_level)
+int ddr_freq_change(u32 data_rate)
 {
-	int ret, freq_curr;
+	int ret, freq_curr, freq_level;
 
 	ret = ddr_freq_init();
 	if (ret < 0) {
@@ -509,6 +519,7 @@ static int ddr_freq_change(u32 freq_level)
 	}
 
 	freq_curr = get_cur_freq_level();
+	freq_level = get_datarate_freq_level(data_rate);
 
 	if(freq_curr == freq_level) {
 		/* dram frequency is same as the target already */
@@ -535,14 +546,15 @@ static int ddr_freq_change(u32 freq_level)
 	clear_dfc_int_status();
 	enable_dfc_int(false);
 
-	pr_info("%s: ddr frequency change from level %d to %d\n", __func__, freq_curr, get_cur_freq_level());
+	printf("Change DDR data rate to %dMT/s\n", freq_levels[get_cur_freq_level()].data_rate);
 
 	return 0;
 }
 
+#ifndef CONFIG_SPL_BUILD
 int do_ddr_freq(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
 {
-	u32 freq_level;
+	u32 datarate;
 	int i;
 
 	if (argc <= 1 || argc > 2) {
@@ -561,22 +573,22 @@ int do_ddr_freq(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
 		return CMD_RET_SUCCESS;
 	}
 
-	freq_level = simple_strtoul(argv[1], NULL, 0);
-	if(freq_level >= MAX_FREQ_LV) {
+	datarate = simple_strtoul(argv[1], NULL, 0);
+	if ((datarate > freq_levels[MAX_FREQ_LV - 1].data_rate)
+		|| (datarate < freq_levels[0].data_rate)) {
 		/* invalid parameter, report error */
 		return CMD_RET_USAGE;
 	}
 
-	ddr_freq_change(freq_level);
-	pr_info("Change DDR data rate to %dMT/s\n", freq_levels[get_cur_freq_level()].data_rate);
+	ddr_freq_change(datarate);
 
 	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
 	ddrfreq, CONFIG_SYS_MAXARGS, 1, do_ddr_freq,
-	"Adjusting the DRAM working frequency",
-	"ddrfreq list	- display the valid frequncy points\n"
-	"ddrfreq [0~7]	- adjust dram working frequency to level[0~7]"
+	"Adjusting the DRAM working data rate",
+	"list		- display the valid data rate list\n"
+	"ddrfreq [600~3200]	- adjust dram working data rate"
 );
 #endif
diff --git a/drivers/ddr/spacemit/k1x/ddr_init.c b/drivers/ddr/spacemit/k1x/ddr_init.c
index 1529a79b..2a1233f5 100644
--- a/drivers/ddr/spacemit/k1x/ddr_init.c
+++ b/drivers/ddr/spacemit/k1x/ddr_init.c
@@ -27,6 +27,8 @@
 #define TOP_DDR_NUM				1
 
 extern u32 ddr_cs_num;
+extern const char *ddr_type;
+extern int ddr_freq_change(u32 data_rate);
 
 static int test_pattern(fdt_addr_t base, fdt_size_t size)
 {
@@ -114,7 +116,7 @@ ERR_HANDLE:
 }
 
 #ifdef CONFIG_K1_X_BOARD_ASIC
-extern void lpddr4_silicon_init(uint32_t base, uint32_t data_rate);
+extern void lpddr4_silicon_init(uint32_t base, const char *ddr_type, uint32_t data_rate);
 #endif
 
 static int spacemit_ddr_probe(struct udevice *dev)
@@ -149,12 +151,18 @@ static int spacemit_ddr_probe(struct udevice *dev)
 		ddr_cs_num = DDR_CS_NUM;
 	}
 
+	if (NULL == ddr_type) {
+		ddr_type = dev_read_string(dev, "type");
+	}
+	printf("DDR type %s\n", ddr_type);
+
 	/* init dram */
 	uint64_t start = get_timer(0);
-	lpddr4_silicon_init(ddrc_base, ddr_datarate);
+	lpddr4_silicon_init(ddrc_base, ddr_type, ddr_datarate);
 	start = get_timer(start);
 	printf("lpddr4_silicon_init consume %lldms\n", start);
 #endif
+	ddr_freq_change(ddr_datarate);
 
 	ret = test_pattern(CONFIG_SYS_SDRAM_BASE, DDR_CHECK_SIZE);
 	if (ret < 0) {
diff --git a/drivers/ddr/spacemit/k1x/ddr_init_asic.h b/drivers/ddr/spacemit/k1x/ddr_init_asic.h
index a6b05e01..b87fb1d8 100644
--- a/drivers/ddr/spacemit/k1x/ddr_init_asic.h
+++ b/drivers/ddr/spacemit/k1x/ddr_init_asic.h
@@ -73,6 +73,32 @@ typedef enum {
 	IO_X8,
 } io_width;
 
+// emu for IO parameter
+typedef enum {
+	SAMSUNG = 0x1,
+	SK_HYNIX = 0x6,
+	MICRON = 0xff,
+}manufacturer_id;
+
+typedef enum {
+	R_240 = 1,
+	R_120,
+	R_80,
+	R_60,
+	R_48,
+	R_40,
+}tx_ds_odt_rx_odt;
+
+typedef enum {
+	VOH_0P6 = 0x0,
+	VOH_0P5,
+}pu_cal;
+
+typedef enum {
+	LPDDR4X = 0x0,
+	LPDDR4,
+}device_type;
+
 static const unsigned char lpddr4_training_img[] = {
 	0x79, 0x71, 0x06, 0xf4, 0x22, 0xf0, 0x00, 0x18, 0x23, 0x3c, 0xa4, 0xfc,
 	0x83, 0x37, 0x84, 0xfd, 0x9c, 0x63, 0x23, 0x26, 0xf4, 0xfe, 0x83, 0x37,
diff --git a/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c b/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c
index 27bc592c..04290d8e 100644
--- a/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c
+++ b/drivers/ddr/spacemit/k1x/lpddr4_silicon_init.c
@@ -72,6 +72,29 @@ static const struct addrmap_info ddr_addrmap[] = {
 	{IO_X8 , DDR_16Gb, BANK_8, ROW_18, COL_10},
 };
 
+struct io_para_info {
+	u32 manufacturer;
+	u32 devicetype;
+	u32 ca_vref;
+	u32 tx_pdrv;
+	u32 tx_ndrv;
+	u32 tx_odt;
+	u32 tx_vref;
+	u32 rx_drv;
+	u32 rx_pu_cal;
+	u32 rx_odt;
+	u32 rx_soc_odt;
+	u32 rx_vref;
+};
+
+const struct io_para_info ddr_io_para_table[] = {
+	{SK_HYNIX, LPDDR4X, 0x9D, R_40, R_40, R_60, 0x19, R_60, VOH_0P6, R_60, R_60, 0x55},
+	{SK_HYNIX, LPDDR4, 0xB2, R_40, R_40, R_120, 0xA7, R_60, VOH_0P6, R_80, R_80, 0x33},
+	// {SK_HYNIX, LPDDR4, 0xB2, R_40, R_40, R_60, 0xA7, R_48, VOH_0P6, R_48, R_48, 0x00},
+};
+
+const struct io_para_info *io_para_update;
+
 void enable_PLL(void)
 {
 	unsigned read_data = 0;
@@ -82,7 +105,6 @@ void enable_PLL(void)
 	read_data = REG32(0xd4282800 + 0x3b4);
 	while ((read_data & 0x30000) != 0x30000) {
 		read_data = REG32(0xd4282800 + 0x3b4);
-
 	}
 
 	return;
@@ -211,8 +233,25 @@ void fp_timing_init(unsigned DDRC_BASE)
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0104)= 0xF0800400;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0100)= 0x00000E20;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x010c)= 0x19194314;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x010c);
+	read_data &= 0x00008FFF;
+	read_data |= (io_para_update->ca_vref << 24) | (io_para_update->tx_vref << 16) | (io_para_update->rx_soc_odt << 12);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x010c) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0110)= 0x20440000;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0114)= 0x20440000;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0110);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0110) = read_data;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0114);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0114) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x018c) = 0x00000030;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0190) = 0x06400030;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0194) = 0x80e001c0;
@@ -231,13 +270,33 @@ void fp_timing_init(unsigned DDRC_BASE)
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01c4) = 0x00000006;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01d8) = 0x00010190;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x014c) = 0x000c4090;
+	if (LPDDR4 == io_para_update->devicetype)
+		REG32(DDRC_BASE+MC_CH0_BASE+0x0200) = ((0x1 << 31) | (0x1E << 8) | (0x6 << 0)); // DRAM wdqs timing
+
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03e4) = 0x15000A02;
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03ec) = 0x0000046c;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0104)= 0xA0800400;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0100)= 0x00000C18;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x010c)= 0x9d194314;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x010c);
+	read_data &= 0x00008FFF;
+	read_data |= (io_para_update->ca_vref << 24) | (io_para_update->tx_vref << 16) | (io_para_update->rx_soc_odt << 12);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x010c) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0110)= 0x00440000;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0114)= 0x00440000;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0110);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0110) = read_data;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0114);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0114) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x018c) = 0x00430000;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0190) = 0x05350028;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0194) = 0x80A80151;
@@ -256,13 +315,33 @@ void fp_timing_init(unsigned DDRC_BASE)
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01c4) = 0x00000004;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01d8) = 0x0000D94E;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x014c) = 0x0007204a;
+	if (LPDDR4 == io_para_update->devicetype)
+		REG32(DDRC_BASE+MC_CH0_BASE+0x0200) = ((0x1 << 31) | (0x1B << 8) | (0x4 << 0)); // DRAM wdqs timing
+
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03e4) = 0x13000802;
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03ec) = 0x00000450;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0104)= 0x50800400;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0100)= 0x0000080e;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x010c)= 0x9d194314;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x010c);
+	read_data &= 0x00008FFF;
+	read_data |= (io_para_update->ca_vref << 24) | (io_para_update->tx_vref << 16) | (io_para_update->rx_soc_odt << 12);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x010c) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0110)= 0x00440000;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0114)= 0x00440000;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0110);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0110) = read_data;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0114);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0114) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x018c) = 0x00280018;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0190) = 0x03200018;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0194) = 0x807000e0;
@@ -281,13 +360,33 @@ void fp_timing_init(unsigned DDRC_BASE)
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01c4) = 0x00000003;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01d8) = 0x00008190;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x014c) = 0x00030848;
+	if (LPDDR4 == io_para_update->devicetype)
+		REG32(DDRC_BASE+MC_CH0_BASE+0x0200) = ((0x1 << 31) | (0x15 << 8) | (0x0 << 0)); // DRAM wdqs timing
+
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03e4) = 0x0a000402;
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03ec) = 0x00000480;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0104)= 0x00800400;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0100)= 0x0000080e;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x010c)= 0x9d194314;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x010c);
+	read_data &= 0x00008FFF;
+	read_data |= (io_para_update->ca_vref << 24) | (io_para_update->tx_vref << 16) | (io_para_update->rx_soc_odt << 12);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x010c) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0110)= 0x00440000;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0114)= 0x00440000;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0110);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0110) = read_data;
+
+	read_data = REG32(DDRC_BASE+MC_CH0_BASE+0x0114);
+	read_data &= 0xFF80FFFF;
+	read_data |= (io_para_update->tx_odt << 20) | (io_para_update->rx_drv << 16);
+	REG32(DDRC_BASE+MC_CH0_BASE+0x0114) = read_data;
+
 	REG32(DDRC_BASE+MC_CH0_BASE+0x018c) = 0x00280018;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0190) = 0x03200018;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x0194) = 0x805400A8;
@@ -306,6 +405,9 @@ void fp_timing_init(unsigned DDRC_BASE)
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01c4) = 0x00000003;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x01d8) = 0x00008190;
 	REG32(DDRC_BASE+MC_CH0_BASE+0x014c) = 0x00030848;
+	if (LPDDR4 == io_para_update->devicetype)
+		REG32(DDRC_BASE+MC_CH0_BASE+0x0200) = ((0x1 << 31) | (0x15 << 8) | (0x0 << 0)); // DRAM wdqs timing
+
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03e4) = 0x0a000402;
 	REG32(DDRC_BASE+MC_CH0_PHY_BASE+0x03ec) = 0x00000480;
 
@@ -679,6 +781,8 @@ void ddr_dfc_table_init(unsigned int DDRC_BASE, unsigned int ddr_size_mb)
 
 void top_DDR_MC_init(unsigned DDRC_BASE, unsigned int fp)
 {
+	u32 temp_data;
+
 	REG32(DDRC_BASE + 0x44) = 0x00040300;
 	REG32(DDRC_BASE + 0x48) = 0x00000001;
 	REG32(DDRC_BASE + 0x64) = 0x100d0803;
@@ -698,6 +802,12 @@ void top_DDR_MC_init(unsigned DDRC_BASE, unsigned int fp)
 	REG32(DDRC_BASE + MC_CH0_BASE + 0xc0) = 0x14008000;
 	REG32(DDRC_BASE + MC_CH0_BASE + 0xc4) = 0x000000b8;
 	REG32(DDRC_BASE + MC_CH0_BASE + 0xc8) = 0x0000FFFF;
+
+	temp_data = REG32(DDRC_BASE + MC_CH0_BASE + 0xc8);
+	temp_data &= 0xFFFDFFFF;
+	temp_data |= io_para_update->rx_pu_cal << 17;
+	REG32(DDRC_BASE + MC_CH0_BASE + 0xc8) = temp_data;
+
 	REG32(DDRC_BASE + MC_CH0_BASE + 0xcc) = 0x200;
 	fp_timing_init(DDRC_BASE);
 	fp_sel(DDRC_BASE, fp);
@@ -716,7 +826,8 @@ void top_DDR_wr_ds_odt_vref(unsigned DPHY0_BASE,unsigned combination)
 	data = REG32(DPHY0_BASE + COMMON_OFFSET + 0xc);
 	switch (combination) {
 	case 2:
-		d_reg2 = 0xd8;
+		// d_reg2 = 0xd8;
+		d_reg2 = (io_para_update->tx_pdrv << 5) | (io_para_update->tx_ndrv << 2);
 		data &= 0xFFFF00FF;
 		data |= (d_reg2 << 8);
 		REG32(DPHY0_BASE + COMMON_OFFSET + 0xc) = data;
@@ -745,13 +856,15 @@ void top_DDR_rx_ds_odt_vref(unsigned DPHY0_BASE,unsigned combination)
 	switch (combination) {
 	case 2:
 		data = REG32(DPHY0_BASE + COMMON_OFFSET + 0xc);
-		data &= 0xFF00FFFF;
-		d_reg3 = 0xE4;
+		data &= 0xFFC0FFFF;
+			// d_reg3 = 0xE4;
+		d_reg3 = (io_para_update->rx_odt << 3) | io_para_update->rx_odt;
 		data |= (d_reg3 << 16);
 		REG32(DPHY0_BASE + COMMON_OFFSET + 0xc) = data;
 		REG32(DPHY0_BASE + COMMON_OFFSET + FREQ_POINT_OFFSET + 0xc) = data;
 		REG32(DPHY0_BASE + COMMON_OFFSET + FREQ_POINT_OFFSET * 2 + 0xc) = data;
 		REG32(DPHY0_BASE + COMMON_OFFSET + FREQ_POINT_OFFSET * 3 + 0xc) = data;
+
 		REG32(DPHY0_BASE + subPHY_B_OFFSET + COMMON_OFFSET + 0xc) = data;
 		REG32(DPHY0_BASE + subPHY_B_OFFSET + COMMON_OFFSET + FREQ_POINT_OFFSET + 0xc) = data;
 		REG32(DPHY0_BASE + subPHY_B_OFFSET + COMMON_OFFSET + FREQ_POINT_OFFSET * 2 + 0xc) = data;
@@ -759,9 +872,12 @@ void top_DDR_rx_ds_odt_vref(unsigned DPHY0_BASE,unsigned combination)
 
 		data = REG32(DPHY0_BASE + COMMON_OFFSET + 0x4);
 		data &= 0x0000FFFF;
-		rx_ref_d1 = 0x55;
-		rx_ref_d2 = 0x55;
+		// rx_ref_d1 = 0x55;//high 4 bit for DQS, low for bit for DQ,both vref=0.3*vddq
+		// rx_ref_d2 = 0x55;//high 4 bit for DQS, low for bit for DQ
+		rx_ref_d1 = io_para_update->rx_vref;//high 4 bit for DQS, low for bit for DQ,both vref=0.3*vddq
+		rx_ref_d2 = io_para_update->rx_vref;//high 4 bit for DQS, low for bit for DQ
 		data |= (rx_ref_d1 << 16) | (rx_ref_d2 << 24);
+
 		REG32(DPHY0_BASE + COMMON_OFFSET + 0x4) = data;
 		REG32(DPHY0_BASE + COMMON_OFFSET + FREQ_POINT_OFFSET + 0x4) = data;
 		REG32(DPHY0_BASE + COMMON_OFFSET + FREQ_POINT_OFFSET * 2 + 0x4) = data;
@@ -803,11 +919,23 @@ void top_DDR_phy_init(unsigned DDRC_BASE,unsigned fp)
 
 	REG32(0xd4282800 + 0x3A4) &= 0xFFFF00FF;
 	REG32(0xd4282800 + 0x3A4) |= (0xF << 8);
-	REG32(0xd4282800 + 0x398) |= (0x3 << 10);
+
+	if (LPDDR4X == io_para_update->devicetype) {
+		REG32(0xd4282800 + 0x398) |= (0x3 << 10);
+		LogMsg(0, "Address[0x%08x]=0x%08x \n", (0xd4282800 + 0x398), REG32(0xd4282800 + 0x398));
+	} else {
+		REG32(0xd4282800+0x398)|=(0x2<<10);
+		REG32(0xd4282800+0x398)&=0xFFFFCFFF;
+		REG32(0xd4282800+0x398)|=(0x3<<12); //external LDO ouput voltage 881mv
+		LogMsg(0,"Address[0x%08x]=0x%08x \n\r",(0xd4282800+0x398),REG32(0xd4282800+0x398));
+	}
+
 	REG32(DPHY0_BASE + COMMON_OFFSET) = 0x0;
 	REG32(DPHY0_BASE + COMMON_OFFSET + subPHY_B_OFFSET) = 0x0;
+
 	REG32(DPHY0_BASE + COMMON_OFFSET) = 0x1;
 	REG32(DPHY0_BASE + COMMON_OFFSET + subPHY_B_OFFSET) = 0x1;
+
 	REG32(DPHY0_BASE + 0x0064) = 0x4349;
 	REG32(DPHY0_BASE + FREQ_POINT_OFFSET + 0x0064) = 0x4349;
 	REG32(DPHY0_BASE + FREQ_POINT_OFFSET * 2 + 0x064) = 0x4349;
@@ -863,39 +991,45 @@ void top_DDR_MC_Phy_Device_Init(unsigned int DDRC_BASE,unsigned int cs_val,unsig
 	unsigned DFI_PHY_USER_COMMAND_0 = DDRC_BASE + 0x13D0;
 	__maybe_unused unsigned DPHY0_BASE = DDRC_BASE + 0x40000;
 	unsigned read_data = 0;
-	unsigned cs_num;
+	unsigned cs_sel;
+	unsigned status_check;
 
 	if (cs_val == 1) {
-		cs_num = 0x1;
+		cs_sel = 0x1;
+		status_check = 0x1;
 	} else {
-		cs_num = 0x3;
+		cs_sel = 0x3;
+		status_check = 0x11;
 	}
 
 	top_DDR_MC_init(DDRC_BASE, fp);
 	top_DDR_phy_init(DDRC_BASE, fp);
 
-	REG32(DFI_PHY_USER_COMMAND_0) = 0x13000001;
+	REG32(DFI_PHY_USER_COMMAND_0) = (0x10000001 | (cs_sel << 24)); //MCK6 DFI phy user cmd, set init_start
 	read_data = REG32(DDRC_BASE + MC_CH0_PHY_BASE + 0x3fc);
+	LogMsg(0, "wait PHY INIT \n");
 	while ((read_data & 0x80000000) != 0x80000000) {
 		read_data = REG32(DDRC_BASE + MC_CH0_PHY_BASE + 0x3fc);
 	}
 	LogMsg(0, "PHY INIT done \n");
 
-	REG32(DFI_PHY_USER_COMMAND_0) = 0x13000100;
-	REG32(DDRC_BASE + 0x20) = (0x10000001 | (cs_num << 24));
+	REG32(DFI_PHY_USER_COMMAND_0) = (0x10000100 | (cs_sel << 24)); //MCK6 DFI phy user cmd, clear init_start
+
+	/*start init DRAM*/
+	REG32(DDRC_BASE + 0x20) = (0x10000001 | (cs_sel << 24));//USER_COMMAND_0
 
 	LogMsg(0, "wait DRAM INIT \n");
 	read_data = REG32(DDRC_BASE + 0x8);
-	while ((read_data & 0x00000011) != 0x00011) {
+	while((read_data & status_check) != status_check) {
 		read_data = REG32(DDRC_BASE + 0x8);
 	}
 	LogMsg(0, "DRAM INIT done \n");
 
-	REG32(DDRC_BASE + 0x24) = (0x10020001 | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x10020002 | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x1002000d | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x10020003 | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x10020016 | (cs_num << 24));
+	REG32(DDRC_BASE + 0x24) = (0x10020001 | (cs_sel << 24)); //Init MR1, read-preamble, write-preamble, read-postamble, nWR
+	REG32(DDRC_BASE + 0x24) = (0x10020002 | (cs_sel << 24)); //Init MR2, WL, RL
+	REG32(DDRC_BASE + 0x24) = (0x1002000d | (cs_sel << 24)); //Init MR13, fsp_op, fsp_wr, vrcg
+	REG32(DDRC_BASE + 0x24) = (0x10020003 | (cs_sel << 24)); //Init MR3, pull-down drive strength, pull-calibration point, write-post amble.
+	REG32(DDRC_BASE + 0x24) = (0x10020016 | (cs_sel << 24)); //Init MR22, update SOC ODT
 
 	REG32(DDRC_BASE + 0x20) = 0x11002000;
 	REG32(DDRC_BASE + 0x20) = 0x11001000;
@@ -904,10 +1038,10 @@ void top_DDR_MC_Phy_Device_Init(unsigned int DDRC_BASE,unsigned int cs_val,unsig
 		REG32(DDRC_BASE + 0x20) = 0x12001000;
 	}
 
-	REG32(DDRC_BASE + 0x24) = (0x1002000C | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x1002000E | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x1002000B | (cs_num << 24));
-	REG32(DDRC_BASE + 0x24) = (0x10020017 | (cs_num << 24));
+	REG32(DDRC_BASE + 0x24) = (0x1002000C | (cs_sel << 24)); //Init MR12, update Vref(ca), Vref(ca) range
+	REG32(DDRC_BASE + 0x24) = (0x1002000E | (cs_sel << 24)); //Init MR14, update Vref(dq), Vref(dq) range
+	REG32(DDRC_BASE + 0x24) = (0x1002000B | (cs_sel << 24)); //Init MR11, update CA ODT/DQ ODT
+	REG32(DDRC_BASE + 0x24) = (0x10020017 | (cs_sel << 24)); //Init MR23, update DQS internal timer runtime
 	LogMsg(0, "DRAM Mode register Init done.....\n");
 
 	return;
@@ -936,17 +1070,34 @@ void adjust_timing(u32 DDRC_BASE)
 	REG32(DDRC_BASE + MC_CH0_BASE + 0x01fc) = 0x000C005E;
 }
 
+static const struct io_para_info* io_para_select(u32 device_type)
+{
+	u32 i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(ddr_io_para_table); i++) {
+		if (device_type == ddr_io_para_table[i].devicetype) {
+			return &ddr_io_para_table[i];
+		}
+	}
+
+	return NULL;
+}
+
 void adjust_mapping(u32 DDRC_BASE, u32 cs_num, u32 size_mb, u32 mr8_value)
 {
 	u32 area_length_mb, area_length_cfg;
 	u32 cs1_start_addr_l, cs1_start_addr_h;
 	u32 io_width, density;
 	u32 i, read_data;
-	const struct addrmap_info *addrmap = &ddr_addrmap[13]; 
+	// ddr_addrmap[13] defalut, {IO_X8 , DDR_8Gb , BANK_8, ROW_17, COL_10}
+	const struct addrmap_info *addrmap = &ddr_addrmap[13];
 
 	area_length_mb = size_mb / cs_num;
 	// area_length_mb = size_mb >> (cs_num -1);
 	switch (area_length_mb) {
+	case 512: // 512M
+		area_length_cfg = 0xD;
+		break;
 	case 1024: // 1GB
 		area_length_cfg = 0xE;
 		break;
@@ -1017,9 +1168,10 @@ void adjust_mapping(u32 DDRC_BASE, u32 cs_num, u32 size_mb, u32 mr8_value)
 	LogMsg("DEBUG-ADDR[0x%x]:0x%x\n", (DDRC_BASE + MC_CH0_BASE + 0x20), REG32(DDRC_BASE + MC_CH0_BASE + 0x20));
 	LogMsg("DEBUG-ADDR[0x%x]:0x%x\n", (DDRC_BASE + MC_CH0_BASE + 0x24), REG32(DDRC_BASE + MC_CH0_BASE + 0x24));
 }
+
 __maybe_unused static int printf_no_output(const char *fmt, ...)
 {
-        return 0;
+	return 0;
 }
 
 static void top_training_fp_all(u32 ddr_base, u32 cs_num, u32 boot_pp, void *input)
@@ -1046,7 +1198,7 @@ static void top_training_fp_all(u32 ddr_base, u32 cs_num, u32 boot_pp, void *inp
 	training(to_traning_param);
 }
 
-void lpddr4_silicon_init(u32 ddr_base, u32 data_rate)
+void lpddr4_silicon_init(u32 ddr_base, const char *ddr_type, u32 data_rate)
 {
 	u32 fp=0;
 	u32 size_mb, mr8_value, cs_num;;
@@ -1056,6 +1208,13 @@ void lpddr4_silicon_init(u32 ddr_base, u32 data_rate)
 	info = (struct ddr_training_info_t*)map_sysmem(DDR_TRAINING_INFO_BUFF, 0);
 	top_Common_config();
 
+	if (0 == strcasecmp(ddr_type, "LPDDR4"))
+		io_para_update = io_para_select(LPDDR4);
+	else
+		io_para_update = io_para_select(LPDDR4X);
+	if (NULL == io_para_update)
+		io_para_update = &ddr_io_para_table[0];
+
 	top_DDR_MC_Phy_Device_Init(ddr_base, cs_num, 0);
 
 	size_mb = ddr_get_density();
diff --git a/drivers/fastboot/fb_mtd.c b/drivers/fastboot/fb_mtd.c
index 491a71b7..192f9f44 100644
--- a/drivers/fastboot/fb_mtd.c
+++ b/drivers/fastboot/fb_mtd.c
@@ -18,12 +18,15 @@
 #include <u-boot/crc.h>
 #include <mapmem.h>
 #include <mtd.h>
+#include <linux/mtd/spi-nor.h>
 
 struct fb_mtd_sparse {
 	struct mtd_info		*mtd;
 	struct part_info	*part;
 };
 
+static bool unlock_flag = false;
+
 static bool mtd_is_aligned_with_min_io_size(struct mtd_info *mtd, u64 size)
 {
 	return !do_div(size, mtd->writesize);
@@ -294,6 +297,23 @@ int fastboot_mtd_get_part_info(const char *part_name,
 	}
 }
 
+static void _nor_unlock(struct mtd_info *mtd)
+{
+	if (!unlock_flag && mtd->type == MTD_NORFLASH){
+		if (mtd->parent != NULL && mtd->parent->priv != NULL){
+				struct spi_nor *nor_dev = (struct spi_nor *)mtd->parent->priv;
+				if (nor_dev->flash_unlock != NULL){
+					nor_dev->flash_unlock(nor_dev, 0, mtd->size);
+				}else{
+					pr_info("not define unlock\n");
+				}
+		}else{
+			pr_info("not define priv\n");
+		}
+		unlock_flag = true;
+	}
+}
+
 /**
  * fastboot_mtd_flash_write() - Write image to MTD for fastboot
  *
@@ -363,13 +383,6 @@ void fastboot_mtd_flash_write(const char *cmd, void *download_buffer,
 		return;
 	}
 
-	/*flash env*/
-	/*if (strcmp(cmd, "env") == 0) {*/
-	/*	printf("flash env \n");*/
-	/*	fastboot_oem_flash_env(cmd, fastboot_buf_addr, download_bytes,*/
-	/*							response, fdev);*/
-	/*	return;*/
-	/*}*/
 #endif
 
 	ret = fb_mtd_lookup(cmd, &mtd, &part);
@@ -380,6 +393,9 @@ void fastboot_mtd_flash_write(const char *cmd, void *download_buffer,
 		return;
 	}
 
+	/*unlock nor flash protect*/
+	_nor_unlock(mtd);
+
 	if (need_erase) {
 		/*must erase at first when write data to mtd devices*/
 		printf("Erasing MTD partition %s\n", part->name);
@@ -492,6 +508,9 @@ void fastboot_mtd_flash_erase(const char *cmd, char *response)
 		return;
 	}
 
+	/*unlock nor flash protect*/
+	_nor_unlock(mtd);
+
 	ret = _fb_mtd_erase(mtd, 0);
 	if (ret) {
 		pr_err("failed erasing from device %s", mtd->name);
diff --git a/drivers/fastboot/fb_spacemit.c b/drivers/fastboot/fb_spacemit.c
index fd1db024..8b22f64f 100644
--- a/drivers/fastboot/fb_spacemit.c
+++ b/drivers/fastboot/fb_spacemit.c
@@ -884,6 +884,7 @@ const struct oem_config_info config_info[] = {
 	{ "manufacturer", TLV_CODE_MANUF_NAME, 32, NULL },
 	{ "sdk_version", TLV_CODE_SDK_VERSION, 3, NULL},
 	{ "ddr_cs_num", TLV_CODE_DDR_CSNUM, 3, NULL},
+	{ "ddr_type", TLV_CODE_DDR_TYPE, 32, NULL},
 	{ "pmic_type", TLV_CODE_PMIC_TYPE, 3, NULL},
 	{ "eeprom_i2c_index", TLV_CODE_EEPROM_I2C_INDEX, 3, NULL},
 	{ "eeprom_pin_group", TLV_CODE_EEPROM_PIN_GROUP, 3, NULL},
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index bcc8997b..66755084 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -405,6 +405,18 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 
+	if (blkcnt > 1){
+		cmd.cmdidx = MMC_CMD_SET_BLOCK_COUNT;
+		cmd.cmdarg = blkcnt & 0x0000FFFF;
+		cmd.resp_type = MMC_RSP_R1;
+		if (mmc_send_cmd(mmc, &cmd, NULL)) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+			pr_err("mmc fail to set block count\n");
+#endif
+			return 0;
+		}
+	}
+
 	if (blkcnt > 1)
 		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
 	else
@@ -425,18 +437,6 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 	if (mmc_send_cmd(mmc, &cmd, &data))
 		return 0;
 
-	if (blkcnt > 1) {
-		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
-		cmd.cmdarg = 0;
-		cmd.resp_type = MMC_RSP_R1b;
-		if (mmc_send_cmd(mmc, &cmd, NULL)) {
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-			pr_err("mmc fail to send stop cmd\n");
-#endif
-			return 0;
-		}
-	}
-
 	return blkcnt;
 }
 
diff --git a/drivers/mmc/mmc_write.c b/drivers/mmc/mmc_write.c
index eab94c7b..5264a2d4 100644
--- a/drivers/mmc/mmc_write.c
+++ b/drivers/mmc/mmc_write.c
@@ -140,6 +140,16 @@ static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
 		return 0;
 	}
 
+	if (blkcnt > 1){
+		cmd.cmdidx = MMC_CMD_SET_BLOCK_COUNT;
+		cmd.cmdarg = blkcnt & 0x0000FFFF;
+		cmd.resp_type = MMC_RSP_R1;
+		if (mmc_send_cmd(mmc, &cmd, NULL)) {
+			printf("mmc fail to set block count\n");
+			return 0;
+		}
+	}
+
 	if (blkcnt == 0)
 		return 0;
 	else if (blkcnt == 1)
@@ -164,19 +174,6 @@ static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
 		return 0;
 	}
 
-	/* SPI multiblock writes terminate using a special
-	 * token, not a STOP_TRANSMISSION request.
-	 */
-	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
-		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
-		cmd.cmdarg = 0;
-		cmd.resp_type = MMC_RSP_R1b;
-		if (mmc_send_cmd(mmc, &cmd, NULL)) {
-			printf("mmc fail to send stop cmd\n");
-			return 0;
-		}
-	}
-
 	/* Waiting for the ready status */
 	if (mmc_poll_for_busy(mmc, timeout_ms))
 		return 0;
diff --git a/drivers/nvme/nvme.c b/drivers/nvme/nvme.c
index 5fd2fb9e..98e8cd87 100644
--- a/drivers/nvme/nvme.c
+++ b/drivers/nvme/nvme.c
@@ -71,7 +71,7 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	}
 
 	nprps = DIV_ROUND_UP(length, page_size);
-	num_pages = DIV_ROUND_UP(nprps, prps_per_page);
+	num_pages = DIV_ROUND_UP(nprps - 1, prps_per_page - 1);
 
 	if (nprps > dev->prp_entry_num) {
 		free(dev->prp_pool);
@@ -84,13 +84,13 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 			printf("Error: malloc prp_pool fail\n");
 			return -ENOMEM;
 		}
-		dev->prp_entry_num = prps_per_page * num_pages;
+		dev->prp_entry_num = num_pages * (prps_per_page - 1) + 1;
 	}
 
 	prp_pool = dev->prp_pool;
 	i = 0;
 	while (nprps) {
-		if (i == ((page_size >> 3) - 1)) {
+		if ((i == (prps_per_page - 1)) && nprps > 1) {
 			*(prp_pool + i) = cpu_to_le64((ulong)prp_pool +
 					page_size);
 			i = 0;
@@ -103,7 +103,7 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	*prp2 = (ulong)dev->prp_pool;
 
 	flush_dcache_range((ulong)dev->prp_pool, (ulong)dev->prp_pool +
-			   dev->prp_entry_num * sizeof(u64));
+			   num_pages * page_size);
 
 	return 0;
 }
@@ -577,17 +577,22 @@ static int nvme_set_queue_count(struct nvme_dev *dev, int count)
 	return min(result & 0xffff, result >> 16) + 1;
 }
 
-static void nvme_create_io_queues(struct nvme_dev *dev)
+static int nvme_create_io_queues(struct nvme_dev *dev)
 {
 	unsigned int i;
+	int ret;
 
 	for (i = dev->queue_count; i <= dev->max_qid; i++)
 		if (!nvme_alloc_queue(dev, i, dev->q_depth))
-			break;
+			return log_msg_ret("all", -ENOMEM);
 
-	for (i = dev->online_queues; i <= dev->queue_count - 1; i++)
-		if (nvme_create_queue(dev->queues[i], i))
-			break;
+	for (i = dev->online_queues; i <= dev->queue_count - 1; i++) {
+		ret = nvme_create_queue(dev->queues[i], i);
+		if (ret)
+			return log_msg_ret("cre", ret);
+	}
+
+	return 0;
 }
 
 static int nvme_setup_io_queues(struct nvme_dev *dev)
@@ -597,14 +602,18 @@ static int nvme_setup_io_queues(struct nvme_dev *dev)
 
 	nr_io_queues = 1;
 	result = nvme_set_queue_count(dev, nr_io_queues);
-	if (result <= 0)
+	if (result <= 0) {
+		log_debug("Cannot set queue count (err=%dE)\n", result);
 		return result;
+	}
 
 	dev->max_qid = nr_io_queues;
 
 	/* Free previously allocated queues */
 	nvme_free_queues(dev, nr_io_queues + 1);
-	nvme_create_io_queues(dev);
+	result = nvme_create_io_queues(dev);
+	if (result)
+		return result;
 
 	return 0;
 }
@@ -682,8 +691,13 @@ int nvme_scan_namespace(void)
 
 	uclass_foreach_dev(dev, uc) {
 		ret = device_probe(dev);
-		if (ret)
-			return ret;
+		if (ret) {
+			log_err("Failed to probe '%s': err=%dE\n", dev->name,
+				ret);
+			/* Bail if we ran out of memory, else keep trying */
+			if (ret != -EBUSY)
+				return ret;
+		}
 	}
 
 	return 0;
@@ -822,8 +836,8 @@ int nvme_init(struct udevice *udev)
 	ndev->udev = udev;
 	INIT_LIST_HEAD(&ndev->namespaces);
 	if (readl(&ndev->bar->csts) == -1) {
-		ret = -ENODEV;
-		printf("Error: %s: Out of memory!\n", udev->name);
+		ret = -EBUSY;
+		printf("Error: %s: Controller not ready!\n", udev->name);
 		goto free_nvme;
 	}
 
@@ -841,8 +855,10 @@ int nvme_init(struct udevice *udev)
 	ndev->dbs = ((void __iomem *)ndev->bar) + 4096;
 
 	ret = nvme_configure_admin_queue(ndev);
-	if (ret)
+	if (ret) {
+		log_debug("Unable to configure admin queue (err=%dE)\n", ret);
 		goto free_queue;
+	}
 
 	/* Allocate after the page size is known */
 	ndev->prp_pool = memalign(ndev->page_size, MAX_PRP_POOL);
@@ -854,8 +870,10 @@ int nvme_init(struct udevice *udev)
 	ndev->prp_entry_num = MAX_PRP_POOL >> 3;
 
 	ret = nvme_setup_io_queues(ndev);
-	if (ret)
+	if (ret) {
+		log_debug("Unable to setup I/O queues(err=%dE)\n", ret);
 		goto free_queue;
+	}
 
 	nvme_get_info_from_identify(ndev);
 
diff --git a/include/configs/k1-x.h b/include/configs/k1-x.h
index 9796a66e..1098880f 100644
--- a/include/configs/k1-x.h
+++ b/include/configs/k1-x.h
@@ -78,11 +78,17 @@
 
 #define TLV_CODE_SDK_VERSION		0x40
 #define TLV_CODE_DDR_CSNUM		0x41
+#define TLV_CODE_DDR_TYPE		0x42
 
 #define TLV_CODE_PMIC_TYPE		0x80
 #define TLV_CODE_EEPROM_I2C_INDEX	0x81
 #define TLV_CODE_EEPROM_PIN_GROUP	0x82
 
+// #define RAMDISK_LOAD_ADDR		(CONFIG_FASTBOOT_BUF_ADDR + CONFIG_FASTBOOT_BUF_SIZE)
+// #define DTB_LOAD_ADDR		(CONFIG_FASTBOOT_BUF_ADDR + CONFIG_FASTBOOT_BUF_SIZE * 2)
+#define RAMDISK_LOAD_ADDR		0x21000000
+#define DTB_LOAD_ADDR			0x31000000
+
 #ifndef __ASSEMBLY__
 #include "linux/types.h"
 
@@ -146,7 +152,7 @@ struct boot_storage_op
 
 #define BOOTENV_DEVICE_CONFIG \
 	"product_name=" DEFAULT_PRODUCT_NAME "\0" \
-	"serial#=123456789ABC\0" \
+	"serial#=0123456789ABCDEF\0" \
 	"manufacturer=" CONFIG_SYS_VENDOR "\0" \
 	"manufacture_date=01/16/2023 11:02:20\0" \
 	"device_version=1\0" \
@@ -158,8 +164,11 @@ struct boot_storage_op
 /*if env not use for spl, please define to board/spacemit/k1-x/k1-x.env */
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"stdout_flash=serial,vidconsole\0" \
-	"kernel_comp_addr_r=0x18000000\0" \
-	"kernel_comp_size=0x4000000\0" \
+	"kernel_comp_addr_r=" __stringify(CONFIG_SYS_LOAD_ADDR) "\0" \
+	"kernel_comp_size=" __stringify(CONFIG_FASTBOOT_BUF_SIZE) "\0" \
+	"kernel_addr_r=" __stringify(CONFIG_FASTBOOT_BUF_ADDR) "\0" \
+	"ramdisk_addr=" __stringify(RAMDISK_LOAD_ADDR) "\0" \
+	"dtb_addr=" __stringify(DTB_LOAD_ADDR) "\0" \
 	"scriptaddr=0x2c100000\0" \
 	"pxefile_addr_r=0x0c200000\0" \
 	"ipaddr=192.168.1.15\0" \
-- 
2.39.2

