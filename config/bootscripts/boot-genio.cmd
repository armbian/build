# DO NOT EDIT THIS FILE
#
# Please edit /boot/armbianEnv.txt to set supported parameters
#

setenv overlay_error "false"
# default values
setenv rootdev "LABEL=armbi_root"
setenv verbosity "1"
setenv console "both"
setenv bootlogo "false"
setenv rootfstype "ext4"
setenv docker_optimizations "on"
setenv earlycon "off"

# Set load address for temporary file loading (armbianEnv.txt, overlays, etc)
# Using address that doesn't conflict with kernel (0x45000000) Note: on Arm64 it has to be 2mb aligned
# Ramdisk (0x49000000),
# or fdt (0x44000000)
setenv load_addr "0x43000000"

# Move ramdisk further away to avoid kernel overwrite (176MB space for kernel)
setenv ramdisk_addr_r "0x50000000"

test -n "${distro_bootpart}" || distro_bootpart=1

echo "Boot script loaded from ${devtype} ${devnum}:${distro_bootpart}"

# get PARTUUID of first partition on SD/eMMC/UFS the boot script was loaded from
echo "Detecting PARTUUID for ${devtype} device ${devnum}:${distro_bootpart}..."

# Explicitly clear partuuid as U-Boot variables set by functions or used in loops may not behave as expected
setenv partuuid

if test "${devtype}" = "mmc" || test "${devtype}" = "scsi" || test "${devtype}" = "usb"; then
	part uuid ${devtype} ${devnum}:${distro_bootpart} partuuid
fi

# Use PARTUUID if available (more reliable), otherwise fall back to rootdev label
if test -n "${partuuid}"; then
  setenv rootdev "PARTUUID=${partuuid}"
fi

# Load armbianEnv.txt if it exists - using direct load instead of test -e for better compatibility
# This happens AFTER PARTUUID detection so user can override rootdev if needed
echo "Attempting to load ${prefix}armbianEnv.txt from ${devtype} ${devnum}:${distro_bootpart} to ${load_addr}..."
if load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}armbianEnv.txt; then
	echo "Successfully loaded armbianEnv.txt (${filesize} bytes)"
	if env import -t ${load_addr} ${filesize}; then
		echo "Successfully imported environment from armbianEnv.txt"
	else
		echo "Warning: Failed to import environment from armbianEnv.txt"
	fi
else
	echo "armbianEnv.txt not found or failed to load - using default environment"
fi

echo "Final rootdev: ${rootdev}"

if test "${bootlogo}" = "true" ; then
	setenv consoleargs "splash plymouth.ignore-serial-consoles ${consoleargs}"
else
	setenv consoleargs "splash=verbose ${consoleargs}"
fi

if test "${console}" = "display" || test "${console}" = "both"; then setenv consoleargs "console=tty1"; fi
if test "${console}" = "serial" || test "${console}" = "both"; then setenv consoleargs "console=ttyS0,921600 ${consoleargs}"; fi
if test "${earlycon}" = "on"; then setenv consoleargs "earlycon ${consoleargs}"; fi
if test "${bootlogo}" = "true"; then
	setenv consoleargs "splash plymouth.ignore-serial-consoles ${consoleargs}"
else
	setenv consoleargs "splash=verbose ${consoleargs}"
fi

setenv bootargs "root=${rootdev} rootwait rootfstype=${rootfstype} ${consoleargs} consoleblank=0 loglevel=${verbosity} ubootpart=${partuuid} usb-storage.quirks=${usbstoragequirks} ${extraargs} ${extraboardargs}"

if test "${docker_optimizations}" = "on"; then setenv bootargs "${bootargs} cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory"; fi

echo "Final bootargs: ${bootargs}"

echo "Loading kernel image to ${kernel_addr_r}..."
load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_r} ${prefix}Image
echo "Loading initramfs to ${ramdisk_addr_r}..."
load ${devtype} ${devnum}:${distro_bootpart} ${ramdisk_addr_r} ${prefix}uInitrd
echo "Loading device tree ${fdtfile} to ${fdt_addr_r}..."
load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}dtb/${fdtfile}
fdt addr ${fdt_addr_r}
fdt resize 65536
for overlay_file in ${overlays}; do
	if load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}dtb/mediatek/overlay/${overlay_prefix}-${overlay_file}.dtbo; then
		echo "Applying kernel provided DT overlay ${overlay_prefix}-${overlay_file}.dtbo"
		fdt apply ${load_addr} || setenv overlay_error "true"
	elif load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}dtb/mediatek/overlay/${overlay_file}.dtbo; then
		echo "Applying kernel provided DT overlay ${overlay_file}.dtbo"
		fdt apply ${load_addr} || setenv overlay_error "true"
	fi
done
for overlay_file in ${user_overlays}; do
	if load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}overlay-user/${overlay_file}.dtbo; then
		echo "Applying user provided DT overlay ${overlay_file}.dtbo"
		fdt apply ${load_addr} || setenv overlay_error "true"
	fi
done
if test "${overlay_error}" = "true"; then
	echo "Error applying DT overlays, restoring original DT"
	load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}dtb/${fdtfile}
else
	if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}dtb/mediatek/overlay/${overlay_prefix}-fixup.scr; then
		load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}dtb/mediatek/overlay/${overlay_prefix}-fixup.scr
		echo "Applying kernel provided DT fixup script (${overlay_prefix}-fixup.scr)"
		source ${load_addr}
	fi
	if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}fixup.scr; then
		load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}fixup.scr
		echo "Applying user provided fixup script (fixup.scr)"
		source ${load_addr}
	fi
fi

# Resize the fdt to the actual size of the final dtb
fdt resize

echo "Booting kernel from ${kernel_addr_r} with initramfs at ${ramdisk_addr_r} and DTB at ${fdt_addr_r}..."
booti ${kernel_addr_r} ${ramdisk_addr_r} ${fdt_addr_r}

# Recompile with:
# mkimage -C none -A arm -T script -d /boot/boot.cmd /boot/boot.scr
