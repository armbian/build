# DO NOT EDIT THIS FILE
#
# Please edit /boot/armbianEnv.txt to set supported parameters
#

setenv overlay_error "false"
# default values
setenv rootdev "LABEL=armbi_root"
setenv verbosity "1"
setenv console "both"
setenv bootlogo "false"
setenv rootfstype "ext4"
setenv docker_optimizations "on"
setenv earlycon "off"

# U-Boot memory layout
# ATTENTION: all hex references have to be quoted, even in comments, otherwise mkimage produces invalid .scr
# Note: on arm64 must be 2mb aligned
# Reserved areas:
# low RAM "0x43200000" "0x43DFFFFF"
# mid RAM "0x54600000" "0x547FFFFF"
# mid RAM "0x60000000" "0x61FFFFFF"
# Thus addresses using estimated max sizes

# Script/load address (boot scripts, small)
# "0x43000000" = 1,116,277,120 bytes = ~1 MB
# Important: the u-boot standard is "loadaddr" (CONFIG_SYS_TEXT_BASE=="0x4c000000"), "not load_addr" - used specifically on below script
setenv load_addr "0x43000000"

# FDT address (device tree, small)
# "0x56000000" = 1,436,207,360 bytes = ~2 MB
setenv fdt_addr_r "0x56000000"

# Kernel load address (100 MB)
# "0x40000000" - "0x46400000"
# 1,073,741,824 - 1,173,637,760 bytes = 100 MB
setenv kernel_addr_r "0x40000000"

# Initramfs load address (500 MB)
# "0x64000000" - "0x83800000"
# 1,677,721,600 - 2,177,441,600 bytes = 500 MB
# Positioned in high RAM to avoid reserved hole
setenv ramdisk_addr_r "0x64000000"


test -n "${distro_bootpart}" || distro_bootpart=1

echo "Boot script loaded from ${devtype} ${devnum}:${distro_bootpart}"

# get PARTUUID of first partition on SD/eMMC/UFS the boot script was loaded from
echo "Detecting PARTUUID for ${devtype} device ${devnum}:${distro_bootpart}..."

# Explicitly clear partuuid as U-Boot variables set by functions or used in loops may not behave as expected
setenv partuuid

if test "${devtype}" = "mmc" || test "${devtype}" = "scsi" || test "${devtype}" = "usb"; then
	part uuid ${devtype} ${devnum}:${distro_bootpart} partuuid
fi

# Use PARTUUID if available (more reliable), otherwise fall back to rootdev label
if test -n "${partuuid}"; then
  setenv rootdev "PARTUUID=${partuuid}"
fi

# Load armbianEnv.txt if it exists - using direct load instead of test -e for better compatibility
# This happens AFTER PARTUUID detection so user can override rootdev if needed
echo "Attempting to load ${prefix}armbianEnv.txt from ${devtype} ${devnum}:${distro_bootpart} to ${load_addr}..."
if load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}armbianEnv.txt; then
	echo "Successfully loaded armbianEnv.txt (${filesize} bytes)"
	if env import -t ${load_addr} ${filesize}; then
		echo "Successfully imported environment from armbianEnv.txt"
	else
		echo "Warning: Failed to import environment from armbianEnv.txt"
	fi
else
	echo "armbianEnv.txt not found or failed to load - using default environment"
fi

echo "Final rootdev: ${rootdev}"

if test "${console}" = "display" || test "${console}" = "both"; then setenv consoleargs "console=tty1"; fi
if test "${console}" = "serial" || test "${console}" = "both"; then setenv consoleargs "console=ttyS0,921600 ${consoleargs}"; fi
if test "${earlycon}" = "on"; then setenv consoleargs "earlycon ${consoleargs}"; fi
if test "${bootlogo}" = "true"; then
	setenv consoleargs "splash plymouth.ignore-serial-consoles ${consoleargs}"
else
	setenv consoleargs "splash=verbose ${consoleargs}"
fi

setenv bootargs "root=${rootdev} rootwait rootfstype=${rootfstype} ${consoleargs} consoleblank=0 loglevel=${verbosity} ubootpart=${partuuid} usb-storage.quirks=${usbstoragequirks} ${extraargs} ${extraboardargs}"

if test "${docker_optimizations}" = "on"; then setenv bootargs "${bootargs} cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory"; fi

echo "Final bootargs: ${bootargs}"

echo "Loading kernel image to ${kernel_addr_r}..."
load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_r} ${prefix}Image
echo "Loading initramfs to ${ramdisk_addr_r}..."
load ${devtype} ${devnum}:${distro_bootpart} ${ramdisk_addr_r} ${prefix}uInitrd
echo "Loading device tree ${fdtfile} to ${fdt_addr_r}..."
load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}dtb/${fdtfile}
fdt addr ${fdt_addr_r}
fdt resize 65536
for overlay_file in ${overlays}; do
	if load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}dtb/mediatek/overlay/${overlay_prefix}-${overlay_file}.dtbo; then
		echo "Applying kernel provided DT overlay ${overlay_prefix}-${overlay_file}.dtbo"
		fdt apply ${load_addr} || setenv overlay_error "true"
	elif load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}dtb/mediatek/overlay/${overlay_file}.dtbo; then
		echo "Applying kernel provided DT overlay ${overlay_file}.dtbo"
		fdt apply ${load_addr} || setenv overlay_error "true"
	fi
done
for overlay_file in ${user_overlays}; do
	if load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}overlay-user/${overlay_file}.dtbo; then
		echo "Applying user provided DT overlay ${overlay_file}.dtbo"
		fdt apply ${load_addr} || setenv overlay_error "true"
	fi
done
if test "${overlay_error}" = "true"; then
	echo "Error applying DT overlays, restoring original DT"
	load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}dtb/${fdtfile}
else
	if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}dtb/mediatek/overlay/${overlay_prefix}-fixup.scr; then
		load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}dtb/mediatek/overlay/${overlay_prefix}-fixup.scr
		echo "Applying kernel provided DT fixup script (${overlay_prefix}-fixup.scr)"
		source ${load_addr}
	fi
	if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}fixup.scr; then
		load ${devtype} ${devnum}:${distro_bootpart} ${load_addr} ${prefix}fixup.scr
		echo "Applying user provided fixup script (fixup.scr)"
		source ${load_addr}
	fi
fi

# Resize the fdt to the actual size of the final dtb
fdt resize

echo "Booting kernel from ${kernel_addr_r} with initramfs at ${ramdisk_addr_r} and DTB at ${fdt_addr_r}..."
booti ${kernel_addr_r} ${ramdisk_addr_r} ${fdt_addr_r}

# Recompile with:
# mkimage -C none -A arm -T script -d /boot/boot.cmd /boot/boot.scr
