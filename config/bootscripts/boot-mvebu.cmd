# DO NOT EDIT THIS FILE
#
# Please edit /boot/armbianEnv.txt to set supported parameters
#

# default environment variables
setenv align_overlap_oboe_avoidance "on"
setenv align_to "0x00001000"
setenv emmc_fix "off"
setenv eth1addr "00:50:43:25:fb:84"
setenv eth2addr "00:50:43:84:25:2f"
setenv eth3addr "00:50:43:0d:19:18"
setenv ethaddr "00:50:43:84:fb:2f"
setenv exit_on_critical_errors "on"
setenv fdt_extrasize "0x00010000"
setenv overlay_error "false"
setenv rootdev "/dev/mmcblk0p1"
setenv rootfstype "ext4"
setenv spi_workaround "off"
setenv verbosity "1"

# load addresses
setenv load_addr "0x00300000"
setenv fdt_addr_r "0x02040000"
setenv kernel_addr_r "0x02080000"
setenv ramdisk_addr_r "0x03080000"

# environment run variables
setenv align_addr_next 'if test "${align_overlap_oboe_avoidance}" = "on" ; then setexpr addr_next ${addr_next} + 1 ; fi ; setexpr modulo ${addr_next} % ${align_to} ; if itest ${modulo} -gt 0 ; then setexpr addr_next ${addr_next} / ${align_to} ; setexpr addr_next ${addr_next} + 1 ; setexpr addr_next ${addr_next} * ${align_to} ; fi'
setenv inform 'if test "${verbosity}" != "" ; then if itest ${verbosity} -gt 0 ; then echo "${message}" ; fi ; fi'
setenv warn 'echo "** WARNING: ${message}"'
setenv critical_error 'echo "!! CRITICAL: ${message}" ; if test "${exit_on_critical_errors}" = "on" ; then exit ; fi'

# environment variables that can be overruled by U-Boot (commandline)
if test "${envfile}" = "" ; then
	setenv envfile 'armbianEnv.txt'
fi
if test "${fdtfile}" = "" ; then
	setenv message "\$fdtfile not set"
	run critical_error
fi
if test "${bootfile}" = "" ; then
	setenv bootfile 'zImage'
fi
if test "${ramdiskfile}" = "" ; then
	setenv ramdiskfile 'uInitrd'
fi

if setexpr setexpr 1 + 1 ; then
	setenv setexpr "available"
else
	setenv message "Using configured load addresses"
	run warn
fi

echo "Boot script loaded from ${devtype}"

# load (merge) on-disk environment
setenv file "${prefix}${envfile}"
if test -e ${devtype} ${devnum} ${file} ; then
	if load ${devtype} ${devnum} ${load_addr} ${file} ; then
		if env import -t ${load_addr} ${filesize} ; then
			setenv message "Imported environment (${file}) from ${devtype} to ${load_addr}"
			run inform
		else
			setenv message "Could not import environment (${file}) - using default environment"
			run warn
		fi
	else
		setenv message "Could not load environment (${file}) - using default environment"
		run warn
	fi
fi

# compose kernel commandline options (bootargs)
setenv consoleargs 'console=ttyS0,115200'
if test "${earlycon}" = "on" ; then
	setenv consoleargs "earlycon ${consoleargs}"
fi

setenv bootargs "root=${rootdev} rootwait rootfstype=${rootfstype} ${consoleargs} ubootdev=${devtype} scandelay loglevel=${verbosity} usb-storage.quirks=${usbstoragequirks} ${extraargs} ${extraboardargs}"

# load the device tree blob
setenv file "${prefix}dtb/${fdtfile}"
if load ${devtype} ${devnum} ${fdt_addr_r} ${file} ; then
	setenv message "Loaded DT (${file}) from ${devtype} to ${fdt_addr_r}"
	run inform
else
	setenv message "Could not load ${file}"
	run critical_error
fi

setenv fdtfilesize ${filesize}
fdt addr ${fdt_addr_r}
fdt resize ${fdt_extrasize}

# process "overlays=..." from $envfile
if test "${overlays}" != "" ; then
	setenv message "Loading kernel provided DT overlay(s) from ${devtype} to ${load_addr}"
	run inform

	for overlay_file in ${overlays}; do
		setenv file "${prefix}dtb/overlay/${overlay_prefix}-${overlay_file}.dtbo"
		if test -e ${devtype} ${devnum} ${file} ; then
			if load ${devtype} ${devnum} ${load_addr} ${file} ; then
				if fdt apply ${load_addr} ; then
					setenv message "Applied DT overlay ${overlay} (${file})"
					run inform
				else
					setenv overlay_error "true"
					setenv message "Could NOT apply DT overlay ${file}"
					run warn
				fi
			else
				setenv message "Could NOT load DT overlay ${file}"
				run warn
			fi
		else
			setenv message "Could NOT find DT overlay ${file}"
			run warn
		fi
	done
fi

# process "user_overlays=..." from $envfile
if test "${user_overlays}" != "" ; then
	setenv message "Loading user provided DT overlay(s) from ${devtype} to ${load_addr}"
	run inform

	for user_overlay in ${user_overlays}; do
		setenv file "${prefix}overlay-user/${overlay_file}.dtbo"
		if test -e ${devtype} ${devnum} ${file} ; then
			if load ${devtype} ${devnum} ${load_addr} ${file} ; then
				if fdt apply ${load_addr} ; then
					setenv message "Applied user DT overlay ${user_overlay} (${file})"
					run inform
				else
					setenv overlay_error "true"
					setenv message "Could NOT apply user DT overlay ${file}"
					run warn
				fi
			else
				setenv message "Could NOT load user DT overlay ${file}"
				run warn
			fi
		else
			setenv message "Could NOT find user DT overlay ${file}"
			run warn
		fi
	done
fi

if test "${overlay_error}" = "true"; then
	setenv message "Could not apply DT overlays"
	run warn

	setenv file "${prefix}dtb/${fdtfile}"
	if load ${devtype} ${devnum} ${fdt_addr_r} ${file} ; then
		setenv message "Loaded original DT (${file}) from ${devtype} to ${fdt_addr_r}"
		run inform

		setenv fdtfilesize ${filesize}
		fdt addr ${fdt_addr_r}
		fdt resize ${fdt_extrasize}
	else
		setenv message "Could not load original DT (${file})"
		run critical_error
	fi
else
	for fixup_script in ${prefix}dtb/overlay/${overlay_prefix}-fixup.scr ${prefix}fixup.scr ; do
		if test -e ${devtype} ${devnum} ${fixup_script} ; then
			if load ${devtype} ${devnum} ${load_addr} ${fixup_script} ; then
				if source ${load_addr} ; then
					setenv message "Sourced fixup script (${fixup_script}) from ${devtype} to ${load_addr}"
					run inform
				else
					setenv message "Fixup script (${fixup_script}) returned an error"
					run warn
				fi
			else
				setenv message "Could not load fixup script (${fixup_script})"
				run warn
			fi
		fi
	done
fi

# eMMC fix
if test "${emmc_fix}" = "on"; then
	echo "Applying eMMC compatibility fix to the DT"
	fdt rm /soc/internal-regs/sdhci@d8000/ cd-gpios
	fdt set /soc/internal-regs/sdhci@d8000/ non-removable
fi

# SPI - SATA workaround
if test "${spi_workaround}" = "on"; then
	echo "Applying SPI workaround to the DT"
	fdt set /soc/internal-regs/sata@e0000 status "disabled"
	fdt set /soc/internal-regs/sata@a8000 status "disabled"
	fdt set /soc/spi@10680 status "okay"
	fdt set /soc/spi@10680/spi-flash@0 status "okay"
fi

# resize (trim) device tree after all overlays have been applied and fixup scripts have been run
fdt resize

if test "${setexpr}" = "available" ; then
	fdt header get fdt_totalsize totalsize

	if test "${fdt_totalsize}" = "" ; then
		setenv message "Calculating DT size"
		run inform

		# 'fdt resize' will align upwards to 4k address boundary
		setexpr fdt_totalsize ${fdtfilesize} / 0x1000
		setexpr fdt_totalsize ${fdt_totalsize} + 1
		setexpr fdt_totalsize ${fdt_totalsize} * 0x1000
		if test "${fdt_extrasize}" != "" ; then
			setexpr fdt_totalsize ${fdt_totalsize} + ${fdt_extrasize}
		fi
	fi

	setexpr addr_next ${fdt_addr_r} + ${fdt_totalsize}
	run align_addr_next
	setenv kernel_addr_r ${addr_next}
fi

setenv file "${prefix}${bootfile}"
if load ${devtype} ${devnum} ${kernel_addr_r} ${file} ; then
	setenv message "Loaded kernel (${file}) from ${devtype} to ${kernel_addr_r}"
	run inform
else
	setenv message "Could not load ${file}"
	run critical_error
fi

if test "${setexpr}" = "available" ; then
	setexpr addr_next ${kernel_addr_r} + ${filesize}
	run align_addr_next
	setenv ramdisk_addr_r ${addr_next}
fi

setenv file "${prefix}${ramdiskfile}"
if load ${devtype} ${devnum} ${ramdisk_addr_r} ${file} ; then
	setenv message "Loaded initial ramdisk (${file}) from ${devtype} to ${ramdisk_addr_r}"
	run inform
else
	setenv message "Could not load ${file}"
	run critical_error
fi

bootz ${kernel_addr_r} ${ramdisk_addr_r} ${fdt_addr_r}
setenv message "Could not boot kernel"
run critical_error

# Recompile with:
# mkimage -C none -A arm -T script -d /boot/boot.cmd /boot/boot.scr
